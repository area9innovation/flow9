#!/usr/bin/python

# This script starts the flowc as a java application.
# NOTE: flowc must be found inside directories in PATH env.
#
# In case when server is started, this script provides
# a port tunneling for the server, which rejects
# requests while server is busy (i.e. do not queue
# requests). 

import subprocess
import re
import os
import sys
import time
import socket

# Prevent full stack trace when user press Ctrl-C
sys.tracebacklimit=0

if sys.version_info[0] > 2:
	import _thread as thread
else:
	import thread

def find_flowdir():
	paths = os.environ['PATH'].split(os.pathsep)
	for path in paths:
		path = path.rstrip(os.sep)
		if os.path.isfile(os.path.join(path, 'flowc')):
			return os.path.split(path)[0]
	return None

def run_flowc1(args):
	java_ver = subprocess.Popen(["java", "-fullversion"], stdout=subprocess.PIPE, stderr=subprocess.PIPE).communicate()[1]
	ver_no = int(re.match(r'[^"]*"([0-9]+)', java_ver.decode('utf-8')).group(1))
	flowdir = find_flowdir()
	
	if flowdir == None:
		print("Flow directory not found: flowc must be found by PATH environment variable")
		print("PATH variable: " + os.environ['PATH'])
		return 1

	run_args = ['java', '-Xss12m', '-Xmx3g', '-Xms1g']
	if ver_no < 9:
		run_args += ['-XX:+UseConcMarkSweepGC', '-XX:ParallelGCThreads=2']
	java_cp = os.path.join(flowdir, 'src', 'java', '.') + ':'
	java_jar = os.path.join(flowdir, 'tools', 'flowc', 'flowc.jar')
	java_bin_dir = os.path.join(flowdir, 'bin')
	run_args += ['-cp', java_cp, '-jar', java_jar, 'bin-dir=' + java_bin_dir]
	run_args += args
	proc = subprocess.Popen(run_args)
	proc.communicate()
	return proc.returncode

def server(input_port, server_port):
	try:
		dock_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
		dock_socket.bind(('', input_port))
		dock_socket.listen(5)
		while True:
			client_socket = dock_socket.accept()[0]
			server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
			server_socket.connect(('localhost', server_port))
			thread.start_new_thread(forward_request, (client_socket, server_socket))
			thread.start_new_thread(forward_response, (server_socket, client_socket))

	except:
		print("Couldn't start server via proxy")
		sys.exit(1)

request_sent = False

def forward_request(source, destination):
	global request_sent
	if request_sent:
		source.sendall('HTTP/1.1 503 Server is busy.\r\n\r\n'.encode())
	else:
		request_sent = True
		string = ' '
		while string:
			try:
				string = source.recv(1024)
			except:
				string = False
			if string:
				destination.sendall(string)
			else:
				source.shutdown(socket.SHUT_RD)
				destination.shutdown(socket.SHUT_WR)

def forward_response(source, destination):
	global request_sent
	string = ' '
	while string:
		try:
			string = source.recv(1024)
		except:
			string = False
		if string:
			destination.sendall(string)
		else:
			request_sent = False
			destination.shutdown(socket.SHUT_WR)

def main():
	args = sys.argv[1:]
	if 'server-mode=1' in args:
		input_port = 10001
		server_port = 10002
		server_args = []
		port_explicitly_set = False
		for arg in args:
			port = re.match(r'server-port=(\d+)', arg)
			if not port == None:
				input_port = int(port.group(1))
				server_port = input_port + 1
				server_args += ["server-port=" + str(server_port)]
				port_explicitly_set = True
			else:
				server_args += [arg]
		if not port_explicitly_set:
			server_args += ["server-port=" + str(server_port)]
		thread.start_new_thread(server, (input_port, server_port))
		return run_flowc1(server_args)
	else:
		return run_flowc1(args)

if __name__ == '__main__':
	sys.exit(main())
