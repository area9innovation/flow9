static const char *SHADER_common[] = {
  "#ifndef GL_ES\n",
  "#define highp\n",
  "#define frag_highp\n",
  "#define mediump\n",
  "#define lowp\n",
  "#else\n",
  "#ifndef GL_FRAGMENT_PRECISION_HIGH\n",
  "#define frag_highp mediump\n",
  "#else\n",
  "#define frag_highp highp\n",
  "#endif\n",
  "#endif\n",
  "\n",
  "#if defined(GL_ES) || (__VERSION__ <= 120)\n",
  "    #define in  varying\n",
  "    #define out varying\n",
  "#else\n",
  "    #define attribute    in\n",
  "    #define texture2D    texture\n",
  "    #define gl_FragColor fragColor\n",
  "#endif\n",
  NULL
};

static const char *SHADER_draw_frag[] = {
  "#ifdef EXTERNAL_TEXTURE\n",
  "#extension GL_OES_EGL_image_external : require\n",
  "#endif\n",
  "\n",
  "uniform lowp vec4 u_mainColor;\n",
  "\n",
  "#ifdef DRAW_FANCY\n",
  "\n",
  "#ifdef EXTERNAL_TEXTURE\n",
  "uniform samplerExternalOES s_tex;\n",
  "#else\n",
  "uniform lowp sampler2D s_tex;\n",
  "#endif\n",
  "\n",
  "#define TEX(pos) texture2D(s_tex, pos)\n",
  "\n",
  "uniform bool u_useTexture;\n",
  "\n",
  "// Will swizzle the red and blue channels when accessing the texture if true\n",
  "// Necessary for some video formats in order to avoid swizzling on the CPU\n",
  "uniform bool u_swizzleRB;\n",
  "\n",
  "in lowp vec4 v_drawColor;\n",
  "in frag_highp vec2 v_texCoord;\n",
  "#endif\n",
  "\n",
  "#ifndef GL_ES\n",
  "out frag_highp vec4 fragColor;\n",
  "#endif\n",
  "\n",
  "void main() {\n",
  "#ifndef DRAW_FANCY  \n",
  "  gl_FragColor = u_mainColor;\n",
  "#else\n",
  "  lowp vec4 color;\n",
  "  if (u_useTexture) {\n",
  "    color = TEX(v_texCoord);\n",
  "    if (u_swizzleRB)\n",
  "      color.rb = color.br;\n",
  "    color.rgb = mix(color.rgb, u_mainColor.rgb * color.a, u_mainColor.a);\n",
  "  } else {\n",
  "    color = u_mainColor;\n",
  "  }\n",
  "  gl_FragColor = color * v_drawColor;\n",
  "#endif\n",
  "}\n",
  NULL
};

static const char *SHADER_draw_vert[] = {
  "uniform highp vec2 u_out_pixel_size; // 2.0 / w, -2.0 / h\n",
  "uniform highp vec2 u_out_offset;\n",
  "\n",
  "uniform highp mat3 u_cmatrix;\n",
  "\n",
  "attribute highp vec2 a_VertexPos;\n",
  "\n",
  "#ifdef DRAW_FANCY\n",
  "attribute lowp vec4 a_VertexColor;\n",
  "attribute frag_highp vec2 a_VertexTexCoord;\n",
  "\n",
  "out lowp vec4 v_drawColor;\n",
  "out frag_highp vec2 v_texCoord;\n",
  "#endif\n",
  "\n",
  "void main()\n",
  "{\n",
  "  // Transform pixel coordinates\n",
  "  highp vec3 eye_pos = u_cmatrix * vec3(a_VertexPos, 1.0);\n",
  "  highp vec2 local_xy = eye_pos.xy - eye_pos.z*u_out_offset;\n",
  "  highp vec2 clip_xy = local_xy * u_out_pixel_size;\n",
  "  gl_Position = vec4(clip_xy, 0.0, eye_pos.z);\n",
  "\n",
  "#ifdef DRAW_FANCY\n",
  "  // Copy properties\n",
  "  v_drawColor = a_VertexColor;\n",
  "  v_texCoord = a_VertexTexCoord;\n",
  "#endif\n",
  "}\n",
  NULL
};

static const char *SHADER_filter_frag[] = {
  "uniform lowp sampler2D s_tex;\n",
  "#define TEX(pos) texture2D(s_tex, pos)\n",
  "\n",
  "#ifdef ONE_TEXTURE\n",
  "#define MASK(pos) TEX(pos)\n",
  "#else\n",
  "uniform lowp sampler2D s_mask;\n",
  "#define MASK(pos) texture2D(s_mask, pos)\n",
  "#endif\n",
  "\n",
  "in frag_highp vec2 v_texCoord;\n",
  "\n",
  "uniform bool u_filter_inner;\n",
  "\n",
  "#ifdef FILTER_SHADOW\n",
  "uniform lowp vec4 u_shadow_color; // non-premultiplied\n",
  "#endif\n",
  "\n",
  "#ifdef FILTER_BEVEL\n",
  "uniform lowp vec4 u_bevel_color1; // non-premultiplied\n",
  "uniform lowp vec4 u_bevel_color2;\n",
  "#define USE_MASK_B\n",
  "#endif\n",
  "\n",
  "#ifdef TEX_SHIFTS\n",
  "\n",
  "#if defined(USE_MASK_B) && defined(USE_SWIZZLE_SHIFT)\n",
  "#define SWIZZLE_MASK_B\n",
  "#endif\n",
  "\n",
  "#if defined(LOCAL_BLUR) || defined(FILTER_BLUR)\n",
  "  #define VSHIFT_COUNT TEX_SHIFTS*4\n",
  "  #define GET_MASK(id) (0.25*(MASK(SHIFT_COORD(id*4)) + MASK(SHIFT_COORD(id*4+1)) + MASK(SHIFT_COORD(id*4+2)) + MASK(SHIFT_COORD(id*4+3))))\n",
  "#else\n",
  "  #define VSHIFT_COUNT TEX_SHIFTS\n",
  "  #define GET_MASK(id) MASK(SHIFT_COORD(id))\n",
  "#endif\n",
  "\n",
  "#ifdef SWIZZLE_MASK_B\n",
  "  in frag_highp vec4 v_shift_coord[VSHIFT_COUNT];\n",
  "  #define SHIFT_COORD_A(i) v_shift_coord[i].xy\n",
  "  #define SHIFT_COORD_B(i) v_shift_coord[i].zw\n",
  "#else\n",
  "  in frag_highp vec2 v_shift_coord_a[VSHIFT_COUNT];\n",
  "  #define SHIFT_COORD_A(i) v_shift_coord_a[i]\n",
  "  #ifdef USE_MASK_B\n",
  "    in frag_highp vec2 v_shift_coord_b[VSHIFT_COUNT];\n",
  "    #define SHIFT_COORD_B(i) v_shift_coord_b[i]\n",
  "  #endif\n",
  "#endif\n",
  "\n",
  "#endif\n",
  "\n",
  "#ifndef GL_ES\n",
  "out frag_highp vec4 fragColor;\n",
  "#endif\n",
  "\n",
  "void main() {\n",
  "  lowp vec4 color = TEX(v_texCoord);\n",
  "\n",
  "#ifndef TEX_SHIFTS\n",
  "  lowp vec4 mask = MASK(v_texCoord);\n",
  "#else\n",
  "  #define SHIFT_COORD(i) SHIFT_COORD_A(i)\n",
  "  lowp vec4 mask = GET_MASK(0);\n",
  "  #undef SHIFT_COORD\n",
  "#ifdef USE_MASK_B\n",
  "  #define SHIFT_COORD(i) SHIFT_COORD_B(i)\n",
  "  lowp vec4 mask2 = GET_MASK(0);\n",
  "  #undef SHIFT_COORD\n",
  "#endif\n",
  "#endif\n",
  "\n",
  "#if defined(FILTER_MASK)\n",
  "  // Mask filter\n",
  "  color *= mask.a;\n",
  "#elif defined(FILTER_BLUR)\n",
  "  // Local blur filter\n",
  "  color = mask;\n",
  "#elif defined(FILTER_SHADOW) || defined(FILTER_BEVEL)\n",
  "  // Complex filters\n",
  " #if defined(FILTER_SHADOW)\n",
  "    if (u_filter_inner) {\n",
  "      color += (u_shadow_color * color.a - color * u_shadow_color.a) * (1.0 - mask.a);\n",
  "    } else {\n",
  "      color += u_shadow_color * (mask.a * (1.0 - color.a));\n",
  "    }\n",
  " #elif defined(FILTER_BEVEL)\n",
  "    lowp float adiff = mask.a - mask2.a;\n",
  "    if (u_filter_inner) {\n",
  "      lowp vec4 bcolor = (adiff > 0.0 ? u_bevel_color1 : u_bevel_color2);\n",
  "      color += (bcolor * color.a - color * bcolor.a) * adiff;\n",
  "    } else {\n",
  "      lowp vec4 bcolor = (adiff > 0.0 ? u_bevel_color1 : u_bevel_color2);\n",
  "      color += bcolor * (adiff * (1.0 - color.a));\n",
  "    }\n",
  " #endif\n",
  "#else\n",
  "#error No filter selected\n",
  "#endif\n",
  "\n",
  "  gl_FragColor = color;\n",
  "}\n",
  NULL
};

static const char *SHADER_filter_vert[] = {
  "uniform highp vec2 u_out_pixel_size; // 2.0 / w, -2.0 / h\n",
  "uniform highp vec2 u_out_offset;\n",
  "uniform highp vec2 u_in_pixel_size; // 1.0 / w, -1.0 / h\n",
  "uniform highp vec2 u_in_offset;\n",
  "\n",
  "attribute highp vec2 a_VertexPos;\n",
  "\n",
  "out frag_highp vec2 v_texCoord;\n",
  "\n",
  "#ifdef TEX_SHIFTS\n",
  "uniform highp vec2 u_tex_shifts[TEX_SHIFTS];\n",
  "\n",
  "#ifdef FILTER_BEVEL\n",
  "#define USE_MASK_B\n",
  "#endif\n",
  "\n",
  "#if defined(USE_MASK_B) && defined(USE_SWIZZLE_SHIFT)\n",
  "#define SWIZZLE_MASK_B\n",
  "#endif\n",
  "\n",
  "#if defined(LOCAL_BLUR) || defined(FILTER_BLUR)\n",
  "/* For trivial 3x3 gaussian (sigma <= 0.95 for 90% accuracy):\n",
  "\n",
  "     u_blur_shift = alpha * texel_size;\n",
  "     alpha = 2*exp(-1/2/sigma^2)/(1 + 2*exp(-1/2/sigma^2))\n",
  " */\n",
  "\n",
  "  #define USE_LOCAL_BLUR\n",
  "  uniform frag_highp vec2 u_local_blur_shift;\n",
  "\n",
  "  #define VSHIFT_COUNT TEX_SHIFTS*4\n",
  "#else\n",
  "  #define VSHIFT_COUNT TEX_SHIFTS\n",
  "#endif\n",
  "\n",
  "#ifdef SWIZZLE_MASK_B\n",
  "  out frag_highp vec4 v_shift_coord[VSHIFT_COUNT];\n",
  "  #define STORE_VSHIFT(i,base) v_shift_coord[i] = vec4(base+shift, base-shift);\n",
  "#else\n",
  "  out frag_highp vec2 v_shift_coord_a[VSHIFT_COUNT];\n",
  "  #ifdef USE_MASK_B\n",
  "    out frag_highp vec2 v_shift_coord_b[VSHIFT_COUNT];\n",
  "    #define STORE_VSHIFT(i,base) v_shift_coord_a[i] = base+shift; v_shift_coord_b[i] = base-shift;\n",
  "  #else\n",
  "    #define STORE_VSHIFT(i,base) v_shift_coord_a[i] = base+shift;\n",
  "  #endif\n",
  "#endif\n",
  "\n",
  "#endif // TEX_SHIFTS\n",
  "\n",
  "void main()\n",
  "{\n",
  "  // Transform pixel coordinates\n",
  "  highp vec2 out_coord = a_VertexPos - u_out_offset;\n",
  "  gl_Position = vec4(out_coord * u_out_pixel_size, 0.0, 1.0);\n",
  "\n",
  "  // Compute texture coordinates\n",
  "  highp vec2 scaled_xy = (a_VertexPos - u_in_offset) * u_in_pixel_size;\n",
  "  v_texCoord = vec2(scaled_xy.x, 1.0 + scaled_xy.y);\n",
  "\n",
  "#ifdef TEX_SHIFTS\n",
  "  // Compute blur tap coordinates\n",
  "  for (int i = 0; i < TEX_SHIFTS; i++) {\n",
  "    highp vec2 shift = u_tex_shifts[i] * u_in_pixel_size;\n",
  "\n",
  "#ifndef USE_LOCAL_BLUR\n",
  "    STORE_VSHIFT(i, v_texCoord);\n",
  "#else\n",
  "    STORE_VSHIFT(i*4+0, v_texCoord + u_local_blur_shift);\n",
  "    STORE_VSHIFT(i*4+1, v_texCoord + vec2(u_local_blur_shift.x,-u_local_blur_shift.y));\n",
  "    STORE_VSHIFT(i*4+2, v_texCoord + vec2(-u_local_blur_shift.x,u_local_blur_shift.y));\n",
  "    STORE_VSHIFT(i*4+3, v_texCoord - u_local_blur_shift);\n",
  "#endif\n",
  "  }\n",
  "#endif\n",
  "}\n",
  NULL
};

static const char *SHADER_font_frag[] = {
  "#ifndef DRAW_FANCY\n",
  "#error DRAW_FANCY required\n",
  "#endif\n",
  "\n",
  "uniform lowp sampler2D s_tex;\n",
  "#define TEX(pos) texture2D(s_tex, pos)\n",
  "\n",
  "in lowp vec4 v_drawColor;\n",
  "in frag_highp vec2 v_texCoord;\n",
  "\n",
  "uniform lowp float u_font_dist_min;\n",
  "uniform mediump float u_font_dist_coeff;\n",
  "\n",
  "#ifndef GL_ES\n",
  "out frag_highp vec4 fragColor;\n",
  "#endif\n",
  "\n",
  "void main() {\n",
  "  mediump float dist = TEX(v_texCoord).a - u_font_dist_min;\n",
  "  mediump float t = clamp(dist * u_font_dist_coeff, 0.0, 1.0);\n",
  "#ifndef GL_ES\n",
  "  //lowp float alpha = smoothstep(u_font_dist_min, u_font_dist_max, dist);\n",
  "  lowp float alpha = t * t * (3.0 - 2.0*t);\n",
  "  gl_FragColor = v_drawColor * alpha;\n",
  "#else\n",
  "  gl_FragColor = v_drawColor * t;\n",
  "#endif\n",
  "}",
  NULL
};

static const char *SHADER_gauss_frag[] = {
  "#define GAUSS_SHIFTS TEX_SHIFTS\n",
  "\n",
  "uniform lowp sampler2D s_tex;\n",
  "#define TEX(pos) texture2D(s_tex, pos)\n",
  "\n",
  "in frag_highp vec2 v_texCoord;\n",
  "\n",
  "#ifdef USE_SWIZZLE_SHIFT\n",
  "in frag_highp vec4 v_shift_coord[GAUSS_SHIFTS];\n",
  "#define SHIFT_COORD_A(i) v_shift_coord[i].xy\n",
  "#define SHIFT_COORD_B(i) v_shift_coord[i].zw\n",
  "#else\n",
  "in frag_highp vec2 v_shift_coord_a[GAUSS_SHIFTS];\n",
  "in frag_highp vec2 v_shift_coord_b[GAUSS_SHIFTS];\n",
  "#define SHIFT_COORD_A(i) v_shift_coord_a[i]\n",
  "#define SHIFT_COORD_B(i) v_shift_coord_b[i]\n",
  "#endif\n",
  "\n",
  "uniform mediump float u_gauss_base_coeff;\n",
  "uniform mediump vec4 u_gauss_shift_coeff;\n",
  "\n",
  "#ifndef GL_ES\n",
  "out frag_highp vec4 fragColor;\n",
  "#endif\n",
  "\n",
  "void main() {\n",
  "  mediump vec4 cb = TEX(v_texCoord);\n",
  "  mediump mat4 c;\n",
  "\n",
  "  c[0] = TEX(SHIFT_COORD_A(0)) + TEX(SHIFT_COORD_B(0));\n",
  "\n",
  "#if GAUSS_SHIFTS == 1\n",
  "  // 5x5: <= 1.54\n",
  "  cb = c[0]*u_gauss_shift_coeff[0] + cb*u_gauss_shift_coeff[1];\n",
  "#elif GAUSS_SHIFTS == 2\n",
  "  // 9x9: <= 2.12\n",
  "  c[1] = TEX(SHIFT_COORD_A(1));\n",
  "  c[2] = TEX(SHIFT_COORD_B(1));\n",
  "  c[3] = cb;\n",
  "  cb = c * u_gauss_shift_coeff;\n",
  "#elif GAUSS_SHIFTS == 3\n",
  "  // 13x13: <= 2.95\n",
  "  c[1] = TEX(SHIFT_COORD_A(1)) + TEX(SHIFT_COORD_B(1));\n",
  "  c[2] = TEX(SHIFT_COORD_A(2)) + TEX(SHIFT_COORD_B(2));\n",
  "  c[3] = cb;\n",
  "  cb = c * u_gauss_shift_coeff;\n",
  "#elif GAUSS_SHIFTS == 4\n",
  "  // 17x17: <= 4.95\n",
  "  c[1] = TEX(SHIFT_COORD_A(1)) + TEX(SHIFT_COORD_B(1));\n",
  "  c[2] = TEX(SHIFT_COORD_A(2)) + TEX(SHIFT_COORD_B(2));\n",
  "  c[3] = TEX(SHIFT_COORD_A(3)) + TEX(SHIFT_COORD_B(3));\n",
  "  cb = cb * u_gauss_base_coeff + c * u_gauss_shift_coeff;\n",
  "#else\n",
  "#error Invalid gauss shift count\n",
  "#endif\n",
  "  \n",
  "  gl_FragColor = cb;\n",
  "}\n",
  NULL
};

