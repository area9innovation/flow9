import tools/dsl/dynjoin/grammar;
import tools/dsl/dsl_eval;
import tools/dsl/dsl_runtime_common;


grammar = defineDynJoin();

// Test that evaluation of this testcase gives the expected program
testDynJoin(testname : string, testcase : string, expected : string) -> void {
	program = parseProgram(testname, grammar, testcase);
	env0 = makeDslEnv();
	env = DslEnv(env0 with locals = addCommonDslRuntime([], env0.locals));
	value = cleanDsl(evaluateDsl(env, program));

	expectedAst = cleanDsl(parseProgram(testname + " expected", grammar, expected));
	if (value != expectedAst) {
		println(testname + " FAILED. Expected: ");
		println(prettyDsl(expectedAst));
		println("Got after eval:");
		println(prettyDsl(value));
		println("Before eval it was:");
		println(prettyDsl(program));
	}
}

// Cleans up excessive brace nodes
cleanDsl(e : DslAst) -> DslAst {
	switch (e) {
		DslBool(value): e;
		DslInt(value): e;
		DslDouble(value): e;
		DslString(value): e;
		DslList(value): DslList(mapList(value, cleanDsl));
		DslNode(name, args, pos): {
			if (name == "brace") {
				bargs = list2array(getDslList(args[0]));
				if (length(bargs) == 1) {
					cleanDsl(bargs[0]);
				} else {
					DslNode(name, map(args, cleanDsl), pos);
				}
			} else if (name == "int" || name == "double" || name == "string") {
				args[0];
			} else {
				DslNode(name, map(args, cleanDsl), pos);
			}
		}
	}
}

main() {
	/*
	testDynJoin("dyn var 1", 
		<< ~a = 1 + 1; a >>, 
		<< a = 2; a >>
	);

	testDynJoin("dyn fn 1", 
		<< add = \~a, ~b -> a + b; add(1 + 3, 1 + 2) >>, 
		<< b = 3; a = 4; a + b >>
	);

	testDynJoin("join 1",
		<< ~a = 1; join a + 1 >>,
		<< a = 1; __tmp__0 = \a -> a + 1; __tmp__0(a) >>
	);
*/
	testDynJoin("join 2",
		<< fact = \~n -> if (n <= 1) n else n * fact(n - 1); fact(5) >>,
		<< n = 5; if (n <= 1) n else n * fact(n - 1) >>
	);

	testDynJoin("runtime", 
		<< range(1, 3) >>,
		<< [1, 2, 3] >>
	);

	testDynJoin("runtime 2", 
		<< ~n = 3; range(1, n) >>,
		<< [1, 2, 3] >>
	);

	quit(0);
}
