import tools/dsl/registry/dsl_transformation;
import tools/dsl/dsl_extract_egraph;
import tools/dsl/dsl_parse;
import tools/dsl/dsl_util;

export {
	// Register a pure Gringo grammar for a language
	registerDslParser(language : string, grammar : string, requires : [string]) -> DslGrammar;

	// Extend an existing grammar with a new language syntax
	registerDslParserExtension(language : string, grammar : string) -> void;

	// Build a grammar for this language
	buildDslGrammar(language : string) -> Maybe<DslGrammar>;

	// Parse this program in this language using the registry
	parseDslProgram(language : string, program : string) -> DslAstEnv;
}

// From complete language to the grammar
dslGrammars : ref Tree<string, DslGrammar> = ref makeTree();

registerDslParser(language : string, grammar : string, requires : [string]) -> DslGrammar {
	dslgrammar = defineGrammar(language, grammar, requires);
	println("Registered parser for " + language);
	dslGrammars := setTree(^dslGrammars, language, dslgrammar);
	dslgrammar
}

// From language extension name to the grammar
dslGrammarExtensions : ref Tree<string, Tree<string, GTerm>> = ref makeTree();

registerDslParserExtension(language : string, grammar : string) -> void {
	extension = parseGrammarExtension(grammar);
	println("Registered parser extension for " + language);
	dslGrammarExtensions := setTree(^dslGrammarExtensions, language, extension);
}

parseDslProgram(lang : string, program : string) -> DslAstEnv {
	astenv = DslAstEnv(lang, DslString(program), makeTree(), makeDslEGraph(), 0, "");

	mgrammar = lookupTree(^dslGrammars, lang);
	mgrammar ?? {
		// TODO: We could do error handling better
		// TODO: We could insert directly into the egraph as well
		ast = parseProgram(lang, mgrammar, program);

		// This does side effects.
		root = addDslAst(astenv.egraph, lang, ast);

		if (false) {
			println("We parsed " + astenv.language + " to " + prettyDsl(ast));
			printDslEGraph(astenv.egraph, root, "");
		}
		DslAstEnv(astenv with ast = ast, root = root);
	} : {
		// Could not find it. Let us build one
		mgram = buildDslGrammar(lang);
		switch (mgram) {
			None(): {
				println("Could not build grammar for " + lang);
				DslAstEnv(astenv with error = "Could not build grammar for " + lang);
			}
			Some(gram): {
				// And go pick it up
				parseDslProgram(lang, program);
			}
		}
	}
}

buildDslGrammar(language : string) -> Maybe<DslGrammar> {
	mgram = lookupTree(^dslGrammars, language);
	mgram ?? {
		Some(mgram);
	} : {
		foldTree(^dslGrammarExtensions, None(), \name, extension, acc : Maybe<DslGrammar> -> {
			if (strContains(language, name)) {
				// OK, we got it
				// Cut off the 'name' from the string, representing syntax
				core = takeBefore(language, "+" + name, language) + takeAfter(language, name, "");
				if (core == language) {
					println("Could not find base language from " + language + " for " + name + ". Did you mean lambda+" + name + "?");
					None();
				} else {
					mbase = buildDslGrammar(core);
					switch (mbase) {
						None(): {
							println("Could not find base grammar for " + core + " from " + language);
							None();
						}
						Some(base): {
							extend = DslGrammar(extendGringoRules(base.term, extension));
							// Register the new, combined grammar
							dslGrammars := setTree(^dslGrammars, language, extend);
							Some(extend)
						}
					}
				}
			} else {
				acc;
			}
		});
	}
}
