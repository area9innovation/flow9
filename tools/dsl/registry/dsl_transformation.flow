import tools/dsl/dsl_ast;
import ds/tree;

export {
	DslTransformation(
		// parse, desugar, eval, compile, optimize
		phase : string, 
		// The specification is a pattern or rule that describes what this transformation
		// does to a language. Read | as "cut" in these:
		// "lambda|-syntax" means "lambda-syntax" is converted to "lambda", i.e. parsed
		// "dot|-syntax" means "*dot-syntax" is converted to "dot", i.e. parsed
		// "|-comprehension" means "lang-comprehension" is lowered to "lang"
		// So we convert a language with the suffix to a language without the
		// part after the |.
		// "lambda|-syntax" can also be considered shorthand for a rewrite like:
		// "*lambda-syntax => *lambda"
		// 
		// TODO: What about compilers and typing? We could do:
		// "lambda => flow-syntax" for compilers
		// "lambda => lambda+type" for typing
		// Challenge: If we compile lambda+array to flow, we might have
		// special rules that work for array.
		specification : string, 
		// How does the transformation work?
		fn : (DslAstEnv) -> DslAstEnv,
	);

	DslAstEnv(
		language : string,
		ast : DslAst,
		env : Tree<string, DslAst>,
		error : string
	);

/*
		// A lowering from a given language to another
		// The runtime should be code that has to be added for the lowered program to work
		DslTransformLower(fromSyntax : string, toLanguage : string, rules : string, runtime : string);

		// E-graph rewriting
		DslTransformRewrite(fromSyntax : string, toLanguage : string, rules : string, costs : string, default : string, runtime : string);
*/
}
