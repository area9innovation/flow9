import tools/dsl/dsl_ast;
import tools/dsl/dsl_egraph;
import ds/tree;

export {
	DslTransformation(
		// parse, desugar, eval, compile, optimize
		phase : string, 
		// The specification is a pattern or rule that describes what this transformation
		// does to a language. Read | as "cut" in these:
		// "lambda|+syntax" means "lambda+syntax" is converted to "lambda", i.e. parsed
		// "dot|+syntax" means "*dot+syntax" is converted to "dot", i.e. parsed
		// "|-comprehension" means "lang-comprehension" is lowered to "lang"
		// So we convert a language with the suffix to a language without the
		// part after the |.
		// "lambda|+syntax" can also be considered shorthand for a rewrite like:
		// "*lambda+syntax => *lambda"
		// 
		// TODO: What about compilers and typing? We could do:
		// "lambda => flow+syntax" for compilers
		// "lambda => lambda+type" for typing
		// Challenge: If we compile lambda+array to flow, we might have
		// special rules that work for array.
		specification : string, 
		// How does the transformation work?
		fn : (DslAstEnv) -> DslAstEnv,
	);

	DslAstEnv(
		// TODO: This is inside the egraph, so should go
		language : string,
		// TODO: This should be replaced by the egraph
		ast : DslAst,
		// TODO: This should probably be by language, and
		// maybe be in the egraph?
		env : Tree<string, DslAst>,
		egraph : DslEGraph,
		root : int,
		error : string
	);
}
