import tools/dsl/dsl_parse;
import tools/dsl/dsl_rewrite;

import tools/dsl/languages/ast_syntax;

export {
	// This adds bag comprehensions to a language
	defineDataFun(language : DslLanguage) -> DslLanguage;
}

defineDataFun(language : DslLanguage) -> DslLanguage {

	// OK, extend this language with the "bag/list comprehension" syntax
	bag = extendGrammar(language.grammar, << 
		atom = atom | datafun;

		datafun = '[' ws exp '|' ws datafun_exps ']' ws $"datafun_2";

		datafun_exps = // listof(datafun_exp, ",")
			$"nil" datafun_exp $"cons" ("," ws datafun_exp $"cons")*;

		datafun_exp = idbind ws "in" ws exp $"datafun_in_2" // This is a loop
			| exp $"datafun_filter_1"; 					// This is just a filter
	>>);

	// TODO: Figure out how to handle an arbitrary list of conditions
	// in the loop part
	rewriting = defineDslRewriting(bag, language.grammar, ";", << 
			// 1-d loop
			[ $e | $a in $c ] 					=> map($c, \$a -> $e);
			[ $e | $a in $c, $f ] 				=> fold($c, nil(), \acc, $a -> if ($f) cons($e, acc) else acc);

			// 2-d loops
			[ $e | $a in $c, $b in $d ] 		=> fold($c, nil(), \acc, $a -> fold($d, acc, \acc2, $b -> cons($e, acc2)));
			[ $e | $a in $c, $b in $d, $f ] 	=> fold($c, nil(), \acc, $a -> 
													fold($d, acc, \acc2, $b -> if ($f) cons($e, acc2) else acc2)
												);
			[ $e | $a in $c, $f, $b in $d ] 	=> fold($c, nil(), \acc, $a -> 
													if ($f) fold($d, acc, \acc2, $b -> cons($e, acc2)) else acc
												);
			[ $e | $a in $c, $f, $b in $d, $g ] => fold($c, nil(), \acc, $a -> 
													if ($f) fold($d, acc, \acc2, $b -> if ($g) cons($e, acc2) else acc2) else acc
												);
		>>, <<
			datafun => 1000000;
		>>,
		<< 0 >>);

/*
			[ $e | a_1 in $c_1, a_2 in $c_2 ] => fold($c_1, nil(), \acc_1, a_1 -> 
				fold($c_2, acc_1, \acc_2, a_2 -> cons($e, acc_2))
			);

			[ $e | a_1 in $c_1, a_2 in $c_2, ..., a_n in $c_2 ] => fold($c_1, nil(), \acc_1, a_1 -> 
				fold($c_2, acc_1, \acc_2, a_2 -> 
					...
					fold($c_n, acc_(n - 1), \acc_n, a_n -> cons($e, acc_n))
				)
			);
*/

	// Here is a version working on the AST
	ast = defineDslAst();
	rewrite1 = defineDslRewriting(ast.grammar, ast.grammar, ";", << 
			// This is AST syntax, and it works:
			datafun($e, [datafun_in($id, $c)]) 
			=> 
			call(var("map"),
				[$c, lambda([$id], $e)]
			);
		>>, <<
			datafun => 1000000;
		>>,
		<< 0 >>
	);

	if (false) {
		test = parseProgram("bag", bag, << 
			[ 2 * a | a in list ]
		>>);
		r = rewriteDsl(test, rewrite1, 2);
		println(prettyDsl(test));
		println(prettyDsl(r));
	}



	if (false) {
		test = parseProgram("bag", bag, << 
			[ cons(f, cons(a, nil())) | f in list, a in list, f != a]
		>>);
		r = rewriteDsl(test, rewriting, 2);
		println(prettyDsl(test));
		println(prettyDsl(r));
	}

	DslLanguage(
		"bag",
		bag, 
		arrayPush(language.rewritings, rewriting),
		language.compilers
	)
}
