import tools/dsl/dsl_parse;
import tools/dsl/dsl_lowering;
import tools/dsl/dsl_runtime_common;
import tools/dsl/languages/ast_syntax;

export {
	// This adds while to a language. NOTICE: DOES NOT WORK YET
	// Syntax:
	// while (e) { body }
	//
	// This translates to
	//
	// %tmp% = \ -> {
	//    if (e) { body; %tmp%() }
	// }; %tmp%()
	defineWhile(language : DslLanguage) -> DslLanguage;
}

defineWhile(language : DslLanguage) -> DslLanguage {
	while_gram = extendGrammar(language.grammar, <<
		atom = 'while' !letterOrDigit ws "(" ws exp ")" ws "{" ws expsemi "}" ws $"brace_1" $"while_2" | atom;
	>>);

	// TODO: We should extract the free vars in the condition, and turn those into
	// arguments on the while function
	lowering = defineDslLowering(defineDslAst().grammar, language.grammar, ";;", <<
		while($cond, $b) => {
			// TODO: We need a general mechanism for this
			tmpId = "tmp";
			whileCall = call(var(tmpId), nil());
			let(tmpId, lambda(nil(), ifelse(cond, brace(
				cons(
					b,
					cons(whileCall, nil())
				)
			), nil())), whileCall)
		} ;;
	>>);

	DslLanguage("while", while_gram, None(), Some(lowering), None(), makeTree(),
		[], Some(language)
	);
}
