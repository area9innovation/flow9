import tools/dsl/dsl_parse;
import tools/dsl/dsl_runtime;

export {
	// This adds tuples to a language
	// Syntax:
	// () is the null-tuple, represented as nil()
	// ( 1, ) is the one-tuple, represented as cons(1, nil())
	// ( 1, 2 ) is pair, represented as cons(2, cons(1, nil()))
	// ( 1, 2, 3 ) is triple
	// a.first => first(a) peels until the last element of a list
	// a.second => second(a) peels until the second last element of a list
	defineTuples(language : DslLanguage) -> DslLanguage;
}

defineTuples(language : DslLanguage) -> DslLanguage {
	tuples = extendGrammar(language.grammar, << 
		atom = atom | '(' ws ')' ws $"nil" $"tuple_1" 
			| '(' ws $"nil" exp "," ws $"cons" ')' $"tuple_1"
			| '(' ws exps  ')' $"tuple_1";
	>>);

	DslLanguage("tuples", tuples, None(), None(), None(),
		addCommonDslRuntime(["listAt", "length"], 
			defineDslRuntime(language, [
				Pair("nth", <<
					\l, n -> {
						// Extract from the tuple wrapper
						// TODO: We could do an optimization where we just
						// remove the tuple wrapper instead?

						li = nodeChild(l, 0);
						listAt(li, length(li) - n)
					}
				>>),
				Pair("first", << \l -> nth(l, 1) >>),
				Pair("second", << \l -> nth(l, 2) >>),
				Pair("third", << \l -> nth(l, 3) >>),
				Pair("fourth", << \l -> nth(l, 4) >>),
				Pair("fifth", << \l -> nth(l, 5) >>),
				Pair("sixth", << \l -> nth(l, 6) >>),
			])
		),
		[], Some(language)
	);
}
