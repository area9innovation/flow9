import tools/dsl/dsl_parse;
import tools/dsl/dsl_runtime;

export {
	// This adds tuples to a language
	// Syntax:
	// () is the null-tuple, represented as nil()
	// ( 1, ) is the one-tuple, represented as cons(1, nil())
	// ( 1, 2 ) is pair, represented as cons(2, cons(1, nil()))
	// a.first => first(a) peels until the last element of a list
	// a.second => second(a) peels until the second last element of a list
	defineTuples(language : DslLanguage) -> DslLanguage;
}

defineTuples(language : DslLanguage) -> DslLanguage {
	tuples = extendGrammar(language.grammar, << 
		atom = atom | '(' ws ')' ws $"nil" $"tuple_1" 
			| '(' ws $"nil" exp "," ws $"cons" ')' $"tuple_1"
			| '(' ws exps  ')' $"tuple_1";
	>>);

	DslLanguage("tuples", tuples, None(), None(), None(),
		defineDslRuntime(language, [
			Pair("listAt", <<
				\xs, i -> {
					if (i <= 0) head(xs)
					else listAt(tail(xs), i - 1)
				}
			>>),
			Pair("length", <<
				\xs -> if (xs == nil()) 0 else 1 + length(tail(xs))
			>>),
			Pair("nth", <<
				\l, n -> {
					// Extract from the tuple wrapper
					// TODO: We could do an optimization where we just
					// remove the tuple wrapper instead?

					li = child(l, 0);
					listAt(li, length(li) - n)
				}
			>>),
			Pair("first", << \l -> nth(l, 1) >>),
			Pair("second", << \l -> nth(l, 2) >>),
			Pair("third", << \l -> nth(l, 3) >>),
			Pair("fourth", << \l -> nth(l, 4) >>),
			Pair("fifth", << \l -> nth(l, 5) >>),
			Pair("sixth", << \l -> nth(l, 6) >>),
		]),
		[], Some(language)
	);
}
