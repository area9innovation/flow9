import tools/dsl/registry/dsl_registry;
import tools/dsl/registry/dsl_specification;
import tools/dsl/dsl_match_egraph;
import tools/dsl/dsl_lowering;
import tools/dsl/registry/dsl_run;

export {
	// Does a bottom-up visit of the e-graph, visiting the first node that
	// match the filter, and then applying those nodes with the
	// result of their children
	lowerDslEGraph(e : DslAstEnv, eclass : int,
		specification : string,
		lowering : DslLowering,
	) -> Maybe<DslENode>;
}

lowerDslEGraph(env : DslAstEnv, eclass : int, 
	specification : string,
	lowering : DslLowering,
) -> Maybe<DslENode> {
	e = env.egraph;
	root = getDslEClassRoot(e, eclass);
	nodes = getDslEClassNodes(e, root);
	matching = set2array(filterSet(nodes, \n -> matchDslSpecification(n.language, specification)));
	fold(matching, None(), \acc, preferred -> {
		children = filtermap(preferred.args, \childClass -> {
			lowerDslEGraph(env, childClass, specification, lowering)
		});
		if (length(children) != length(preferred.args)) {
			println("ERROR: Expected more children in transformation");
			acc
		} else {
			term = combineENode(preferred, children);

			resultLanguage = resultDslTransformation(preferred.language, specification);
			lowerDslENode(env, specification, resultLanguage, lowering, eclass, term);

			node = DslENode(
					resultLanguage,
					term,
					preferred.args
				);
			Some(node);
		}
	})
}

// OK, we know this node is the right language. Process it
lowerDslENode(e : DslAstEnv, specification : string, resultLanguage : string, lowering : DslLowering, eclass : int, term : DslAst) -> void {
	iterList(lowering.replacements, \r : DslReplacement -> {
		lowerDslENodeWithReplacement(e, specification, resultLanguage, lowering.toLanguage, r, eclass, term)
	})
}

combineENode(node : DslENode, children : [DslENode]) -> DslAst {
	val = node.value;
	switch (node.value) {
		DslBool(value): val
		DslInt(value): val
		DslDouble(value): val
		DslString(value): val
		DslList(value): DslList(array2list(map(children, \c -> c.value)));
		DslNode(name, args, pos): DslNode(name, map(children, \c -> c.value), pos);
	}
}

lowerDslENodeWithReplacement(e : DslAstEnv, specification : string, resultLanguage, toLanguage : string, replacement : DslReplacement, 
	eclass : int, term : DslAst) -> void {
	acc = DslENodeMatch(makeTree(), false);
	bindings = dslENodeMatch(acc, term, replacement.pattern);
	if (!bindings.fail) {
		astEnv = DslAstEnv(e with language = toLanguage, ast = replacement.replacement);
		
		println("Lowering to " + toLanguage);
		desugared = performDslTransformations("desugar", "lambda", astEnv);
		// println(prettyDsl(desugared.ast));

		env = makeDslEnv();
		runtime = getDslLanguageRuntime(specification);
		nenv = DslEnv(env 
			with globals = mapTree(desugared.env, \a -> [a]), 
			locals = mergeTree(mergeTree(astEnv.env, bindings.bindings), runtime)
		);

		result = evaluateDsl(nenv, desugared.ast);

		if (false) {
			println("This match: " + prettyDsl(term) + " against " + prettyDsl(replacement.pattern));
			/*traverseInOrder(bindings.bindings, \name, val -> {
				println("  " + name + " = " + prettyDsl(val));
			});*/
			println("gives " + prettyDsl(result));
		}

		newEclass = addDslAst(e.egraph, resultLanguage, result);
		unionDslEClass(e.egraph, eclass, newEclass);
		{}
	}
}
