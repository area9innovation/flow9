import tools/dsl/dsl_parse;
import tools/dsl/dsl_rewrite;
import tools/dsl/dsl_lowering;
import tools/dsl/dsl_compiler;
import tools/dsl/dsl_eval;
import tools/dsl/dsl_language;

export {
	// Parse and desugar a program in this language
	parseDsl(file : string, language : DslLanguage, program : string) -> DslAst;

	// Optimize this program
	optimizeDsl(language : DslLanguage, program : DslAst) -> DslAst;

	// A simple way to run
	runDsl(file : string, language : DslLanguage, program : string) -> DslAst;

	// For more control, prepare an environment for use with evaluateDsl
	prepareDslEnv(env : DslEnv, language : DslLanguage) -> DslEnv;
}

parseDsl(file : string, language : DslLanguage, program : string) -> DslAst {
	parsed = parseProgram(file, language.grammar, program);
	debug = false && file == "record-test";
	if (debug) {
		println("Before desugaring");
		println(prettyDsl(parsed));
	}
	desugared = desugarDsl(file, language, parsed);
	lifted = liftDslGlobal(desugared);
	if (debug) {
		println("After desugaring, lowering and global lifting");
		println(prettyDsl(lifted));
	}
	lifted;
}

desugarDsl(file : string, language : DslLanguage, parsed : DslAst) -> DslAst {
	debug = false && file == "record-test";

	desugar = language.desugaring;
	desugared = desugar ?? rewriteDsl(parsed, desugar, 2) : parsed;

	lowering = language.lowering;
	lowered = lowering ?? lowerDsl(lowering, desugared) : desugared;

	if (debug) {
		println("After lowering in desugaring " + file);
		println(prettyDsl(lowered));
	}

	base = language.baseLanguage;
	base ?? desugarDsl(file + "+" + base.name, base, lowered) : lowered
}

optimizeDsl(language : DslLanguage, program : DslAst) -> DslAst {
	opt = language.optimization;
	optimized = opt ?? {
		rewriteDsl(program, opt, 2);
	} : program;
	base = language.baseLanguage;
	base ?? optimizeDsl(base, optimized) : optimized;
}

runDsl(file : string, language : DslLanguage, program : string) -> DslAst {
	p = parseDsl(file, language, program);
	// println("After lowering " + file);
	// println(prettyDsl(p));
	env = prepareDslEnv(makeDslEnv(), language);
	if (false) {
		traverseInOrder(env.globals, \id, vals -> {
			println(id + " = " + superglue(vals, prettyDsl, ";\n  "));
		})
	}
	evaluateDsl(env, p);
}

prepareDslEnv(env : DslEnv, language : DslLanguage) -> DslEnv {
	base = language.baseLanguage;
	nenv = base ?? {
		prepareDslEnv(env, base);
	} : env;
	DslEnv(foldTree(language.runtime, nenv.globals, \name, val, acc -> {
		treePushToArrayUnique(acc, name, val)
	}), nenv.locals)
}

// Lifts "global_let" to be at the top as "lets"
liftDslGlobal(p : DslAst) -> DslAst {
//	println("Before lifting " + prettyDsl(p));
	lets = liftDslGlobalLets(makeTree(), p);
//	println("After lifting " + prettyDsl(lets.second));
	foldTree(lets.first, lets.second, \gl, def, acc -> {
		DslNode("let", [DslString(gl), def, acc], 0)
	});
}

liftDslGlobalLets(acc : Tree<string, DslAst>, p : DslAst) -> Pair<Tree<string, DslAst>, DslAst> {
	switch (p) {
		DslBool(value): Pair(acc, p);
		DslInt(value): Pair(acc, p);
		DslDouble(value): Pair(acc, p);
		DslString(value): Pair(acc, p);
		DslList(value): {
			nlist = foldList(value, Pair(acc, makeList()), \acc2, val -> {
				nval = liftDslGlobalLets(acc2.first, val);
				Pair(nval.first, Cons(nval.second, acc2.second))
			});
			// The foldList constructs in reverse order, so we have to reverse this list
			Pair(nlist.first, DslList(reverseList(nlist.second)));
		}
		DslNode(name, args, pos): {
			nargs = fold(args, Pair(acc, []), \acc2, arg -> {
				narg = liftDslGlobalLets(acc2.first, arg);
				Pair(narg.first, arrayPush(acc2.second, narg.second));
			});
			eargs = nargs.second;
			if (name == "global_let") {
				Pair(
					setTree(nargs.first, getDslString(eargs[0]), eargs[1]),
					eargs[2]
				)
			} else {
				Pair(nargs.first, DslNode(name, eargs, pos));
			}
		}
	}
}
