import tools/dsl/lambda;
import tools/dsl/gringo;
import tools/dsl/ast_syntax;
import tools/dsl/datafun;
import tools/dsl/dsl_rewrite;
import tools/dsl/dsl_compiler;
import tools/dsl/dsl_eval;
import tools/dsl/dsl2flow;
import tools/dsl/gringo_actions;

main() {
	if (false) {
		gringo = defineGringo();
		testGringo = parseProgram("test-gringo", gringo.grammar, << 
			truth = listof(keyword('true'), "," ws);
			truth
		>>);
		replacedGringo = rewriteDsl(testGringo, gringo.rewritings[0], 2);
		gr = dsl2flow(replacedGringo);
		println(gterm2string(gr));
		println(compileDsl(gringo.compilers[0], replacedGringo));
	}

	lambda = defineLambda();

	// OK, extend this language with the "dot" syntax
	lambdaDot = extendGrammar(lambda.grammar, << 
		postfix = postfix | "." ws $"nil" $"swap" $"cons" id $"var_1" $"swap" ( "(" ws mexps ")" ws)? $"call_2" ;
		mexps = exp $"cons" ("," ws exp $"cons")* ("," ws)?;
	>>);

	if (true) {
		defineDataFun(lambda);
		{}
	}

	//
	// This is the program to test
	//

	testValue = parseProgram("test-program", lambda.grammar, << 
		{
			foo = \a, b, c -> {
				a + b + c
			};
			foo(1, 2, 3);
			a = 1;
			2 + 3;
			1.3 + 4.6
		}
	>>);

	replaced = rewriteDsl(testValue, lambda.rewritings[0], 2);

	if (false) {
		println(prettyDsl(testValue));
		println("is optimized to\n");
		println(prettyDsl(replaced));
		// 123 + 23 + 34 + 34
	}

	program = compileDsl(lambda.compilers[1], replaced);
	println("The program   " /*+ prettyDsl(testValue) */ + "   compiles to " + program);

	println("It evaluates to " + prettyDsl(evaluateDsl(makeDslEnv(), testValue)));

	if (true) {
		programs = [<< 1 + 2 * 3 >>, << (1 + 2) * 3 >>, << 1 - 2 - 3 >>, << (1 - 2) - 3 >>, << 1 - (2 - 3) >>];
		iter(programs, \p -> {
			program2 = parseProgram("test-programs", lambda.grammar, p);
			println("Testing precedence and associativity: " + p + " => " + compileDsl(lambda.compilers[0], program2) + "  =  " + prettyDsl(evaluateDsl(makeDslEnv(), program2)));
		});
	}

	println("Done");
	quit(0);
}
