import tools/dsl/dsl_parse;

export {
	makeDslEnv() -> DslEnv;
	evaluateDsl(env : DslEnv, p : DslAst) -> DslAst;

	DslEnv(globals : Tree<string, [DslAst]>, locals : Tree<string, DslAst>);
}

makeDslEnv() -> DslEnv {
	DslEnv(makeTree(), makeTree());
}

evaluateDsl(env : DslEnv, p : DslAst) -> DslAst {
	switch (p) {
		DslNode(name, args, pos): {
			if (name == "ifelse") {
				cond = evaluateDsl(env, args[0]);
				evaluateDsl(env, if (getDslBool(cond)) args[1] else args[2]);
			} else if (name == "let") {
				let = getDslString(args[0]);
				val = evaluateDsl(env, args[1]);
				node = getDslNode(val);
				if (node.name == "lambda") {
					nenv = DslEnv(treePushToArrayUnique(env.globals, let, val), env.locals);
					evaluateDsl(nenv, args[2]);
				} else {
					nenv = DslEnv(env.globals, setTree(env.locals, let, val));
					evaluateDsl(nenv, args[2]);
				}
			} else if (name == "var") {
				mvar = lookupTree(env.locals, getDslString(args[0]));
				mvar ?? mvar : {
					p;
				}
			} else if (name == "lambda") {
				instantiateDslLocals(env, p);
			} else if (name == "call") {
				fn = evaluateDsl(env, args[0]);
				// println("Call to " + prettyDsl(fn));
				lambda : DslNode = getDslNode(fn);
				if (lambda.name == "lambda") {
					eargs : List<DslAst> = getDslList(evaluateDsl(env, args[1]));
					nargs = list2array(getDslList(lambda.args[0]));
					body = lambda.args[1];
					nenv = DslEnv(env.globals, foldi(list2array(eargs), env.locals, \i, acc, arg -> {
						// println("Setting par " + getDslString(nargs[i]) + " to " + prettyDsl(arg));
						setTree(acc, getDslString(nargs[i]), arg)
					}));
					evaluateDsl(nenv, body);
				} else if (lambda.name == "var") {
					// Normal functions
					vname = getDslString(lambda.args[0]);
					globals = getTreeArrayValue(env.globals, vname);
					nargsCall = countList(getDslList(args[1]));
					matches = filter(globals, \gl -> {
						nargs = countList(getDslList(getDslNode(gl).args[0]));
						nargs == nargsCall;
					});
					if (matches != []) {
						if (length(matches) != 1) {
							println("Can not resolve overloaded " + vname);
							eargs : List<DslAst> = getDslList(evaluateDsl(env, args[1]));
							DslNode(vname, list2array(eargs), pos);
						} else {
							evaluateDsl(env, DslNode("call", [matches[0], args[1]], pos));
						}
					} else {
						eargs : List<DslAst> = getDslList(evaluateDsl(env, args[1]));
						mnative = getDslNative(vname);
						mnative ?? {
							mnative.fn(list2array(eargs));
						} : {
							// We just make a node
							node = DslNode(vname, list2array(eargs), pos);
							if (globals != []) {
								println("Can not find overload for " + vname + " with " + i2s(nargsCall) + " arguments");
							} else {
								println("Unknown var " + vname + ", just making a node" /* + prettyDsl(node)*/);
							}
							node;
						}
					}
				} else {
					println("ERROR: Can not call " + prettyDsl(fn));
					p;
				}
			} else if (name == "and") {
				// Shortcircut
				left = evaluateDsl(env, args[0]);
				if (getDslBool(left)) {
					evaluateDsl(env, args[1]);
				} else left;
			} else if (name == "or") {
				// Shortcircut
				left = evaluateDsl(env, args[0]);
				if (getDslBool(left)) {
					left
				} else evaluateDsl(env, args[1]);
			} else {
				// Normal functions
				eargs = map(args, \a -> {
					evaluateDsl(env, a);
				});
				mnative = getDslNative(name);
				mnative ?? {
					mnative.fn(eargs)
				} : {
					// OK, we fallback to construction
					DslNode(name, eargs, pos);
				}
			}
		}
		DslList(value): {
			DslList(mapList(value, \v -> evaluateDsl(env, v)));
		}
		DslBool(value): p;
		DslInt(value): p;
		DslDouble(value): p;
		DslString(value): p;
	}
}

instantiateDslLocals(env : DslEnv, p : DslAst) -> DslAst {
	var = \id : string -> {
		DslNode("var", [DslString(id)], 0)
	};
	switch (p) {
		DslNode(name, args, pos): {
			if (name == "let") {
				let = getDslString(args[0]);
				val = instantiateDslLocals(env, args[1]);
				nenv = DslEnv(env with locals = setTree(env.locals, let, var(let)));
				DslNode(name, [args[0], val, 
					instantiateDslLocals(nenv, args[2])
				], pos);
			} else if (name == "var") {
				lookupTreeDef(env.locals, getDslString(args[0]), p);
			} else if (name == "lambda") {
				largs = getDslList(args[0]);
				nlocals : Tree<string, DslAst> = foldList(largs, env.locals, \acc, darg -> {
					arg = getDslString(darg);
					setTree(acc, arg, DslNode("var", [darg], pos))
				});
				newBody = instantiateDslLocals(DslEnv(env.globals, nlocals), args[1]);
				DslNode(name, [args[0], newBody], pos)
			} else {
				// Normal functions
				eargs = map(args, \a -> {
					instantiateDslLocals(env, a);
				});
				DslNode(name, eargs, pos);
			}
		}
		DslList(value): {
			DslList(mapList(value, \v -> instantiateDslLocals(env, v)));
		}
		DslBool(value): p;
		DslInt(value): p;
		DslDouble(value): p;
		DslString(value): p;
	}
}


DslNativeBuiltin(
	fn : (([DslAst]) -> DslAst)
);

builtinNativeDsls : ref Maybe<Tree<string, DslNativeBuiltin>> = ref None();

getDslNative(name : string) -> Maybe<DslNativeBuiltin> {
	two = \fn : (DslAst, DslAst) -> DslAst -> {
		DslNativeBuiltin(\args -> fn(args[0], args[1]))
	};
	one = \fn : (DslAst) -> DslAst -> {
		DslNativeBuiltin(\args -> fn(args[0]));
	};
	n : Tree<string, DslNativeBuiltin> = onlyOnce(builtinNativeDsls, \ -> {
		pairs2tree([
			Pair("add", two(addDsl)),
			Pair("sub", two(subDsl)),
			Pair("mul", two(mulDsl)),
			Pair("div", two(divDsl)),
			Pair("mod", two(modDsl)),
			Pair("equal", two(equalDsl)),
			Pair("not_equal", two(notEqualDsl)),
			Pair("less", two(lessDsl)),
			Pair("less_equal", two(lessEqualDsl)),
			Pair("greater", two(greaterDsl)),
			Pair("greater_equal", two(greaterEqualDsl)),
			Pair("cons", two(consDsl)),
			Pair("nil", DslNativeBuiltin(\args -> {
				// println("Calling nil with " + toString(args));
				DslList(makeList())
			})),
			Pair("head", one(headDsl)),
			Pair("tail", one(tailDsl)),
			Pair("not", one(notDsl)),
			Pair("negate", one(negateDsl)),
			Pair("brace", one(braceDsl)),

			// Get the name of a node
			Pair("nodeName", one(nodeNameDsl)),
			// Get child #n of a node
			Pair("nodeChild", two(nodeChildDsl)),
			// Make a node
			Pair("makeNode", two(makeNodeDsl)),
			Pair("println", one(printlnDsl)),
		])
	});
	lookupTree(n, name);
}

addDsl(left : DslAst, right : DslAst) -> DslAst {
	error = \ -> {
		println("Can not add " + prettyDsl(left) + " and " + prettyDsl(right));
		DslNode("add", [left, right], 0);
	}
	switch (left) {
		DslBool(value): error();
		DslInt(lvalue): {
			switch (right) {
				DslInt(rvalue): DslInt(lvalue + rvalue);
				DslDouble(rvalue): DslDouble(i2d(lvalue) + rvalue);
				DslString(rvalue): DslString(i2s(lvalue) + rvalue);
				default: error();
			}
		}
		DslDouble(lvalue): {
			switch (right) {
				DslInt(rvalue): DslDouble(lvalue + i2d(rvalue));
				DslDouble(rvalue): DslDouble(lvalue + rvalue);
				DslString(rvalue): DslString(d2s(lvalue) + rvalue);
				default: error();
			}
		}
		DslString(lvalue): {
			switch (right) {
				DslInt(rvalue): DslString(lvalue + i2s(rvalue));
				DslDouble(rvalue): DslString(lvalue + d2s(rvalue));
				DslString(rvalue): DslString(lvalue + rvalue);
				default: error();
			}
		}
		DslList(lvalue): error();
		DslNode(name, args, pos): error();
	}
}

subDsl(left : DslAst, right : DslAst) -> DslAst {
	error = \ -> {
		println("Can not subtract " + prettyDsl(left) + " and " + prettyDsl(right));
		DslNode("sub", [left, right], 0);
	}
	switch (left) {
		DslBool(value): error();
		DslInt(lvalue): {
			switch (right) {
				DslInt(rvalue): DslInt(lvalue - rvalue);
				DslDouble(rvalue): DslDouble(i2d(lvalue) - rvalue);
				default: error();
			}
		}
		DslDouble(lvalue): {
			switch (right) {
				DslInt(rvalue): DslDouble(lvalue - i2d(rvalue));
				DslDouble(rvalue): DslDouble(lvalue - rvalue);
				default: error();
			}
		}
		DslString(lvalue): error();
		DslList(lvalue): error();
		DslNode(name, args, pos): error();
	}
}

mulDsl(left : DslAst, right : DslAst) -> DslAst {
	error = \ -> {
		println("Can not multiply " + prettyDsl(left) + " and " + prettyDsl(right));
		DslNode("mul", [left, right], 0);
	}
	switch (left) {
		DslBool(value): error();
		DslInt(lvalue): {
			switch (right) {
				DslInt(rvalue): DslInt(lvalue * rvalue);
				DslDouble(rvalue): DslDouble(i2d(lvalue) * rvalue);
				default: error();
			}
		}
		DslDouble(lvalue): {
			switch (right) {
				DslInt(rvalue): DslDouble(lvalue * i2d(rvalue));
				DslDouble(rvalue): DslDouble(lvalue * rvalue);
				default: error();
			}
		}
		DslString(lvalue): error();
		DslList(lvalue): error();
		DslNode(name, args, pos): error();
	}
}

divDsl(left : DslAst, right : DslAst) -> DslAst {
	error = \ -> {
		println("Can not multiply " + prettyDsl(left) + " and " + prettyDsl(right));
		DslNode("div", [left, right], 0);
	}
	switch (left) {
		DslBool(value): error();
		DslInt(lvalue): {
			switch (right) {
				DslInt(rvalue): DslInt(lvalue / rvalue);
				DslDouble(rvalue): DslDouble(i2d(lvalue) / rvalue);
				default: error();
			}
		}
		DslDouble(lvalue): {
			switch (right) {
				DslInt(rvalue): DslDouble(lvalue / i2d(rvalue));
				DslDouble(rvalue): DslDouble(lvalue / rvalue);
				default: error();
			}
		}
		DslString(lvalue): error();
		DslList(lvalue): error();
		DslNode(name, args, pos): error();
	}
}

modDsl(left : DslAst, right : DslAst) -> DslAst {
	error = \ -> {
		println("Can not multiply " + prettyDsl(left) + " and " + prettyDsl(right));
		DslNode("mod", [left, right], 0);
	}
	switch (left) {
		DslBool(value): error();
		DslInt(lvalue): {
			switch (right) {
				DslInt(rvalue): DslInt(lvalue % rvalue);
				DslDouble(rvalue): DslDouble(i2d(lvalue) % rvalue);
				default: error();
			}
		}
		DslDouble(lvalue): {
			switch (right) {
				DslInt(rvalue): DslDouble(lvalue % i2d(rvalue));
				DslDouble(rvalue): DslDouble(lvalue % rvalue);
				default: error();
			}
		}
		DslString(lvalue): error();
		DslList(lvalue): error();
		DslNode(name, args, pos): error();
	}
}

compareDsl(left : DslAst, right : DslAst) -> int {
	genericCompare(left, right);
}

equalDsl(left : DslAst, right : DslAst) -> DslAst {
	DslBool(compareDsl(left, right) == 0);
}

notEqualDsl(left : DslAst, right : DslAst) -> DslAst {
	DslBool(compareDsl(left, right) != 0);
}

lessDsl(left : DslAst, right : DslAst) -> DslAst {
	DslBool(compareDsl(left, right) < 0);
}

lessEqualDsl(left : DslAst, right : DslAst) -> DslAst {
	DslBool(compareDsl(left, right) <= 0);
}

greaterDsl(left : DslAst, right : DslAst) -> DslAst {
	DslBool(compareDsl(left, right) > 0);
}

greaterEqualDsl(left : DslAst, right : DslAst) -> DslAst {
	DslBool(compareDsl(left, right) >= 0);
}

notDsl(val : DslAst) -> DslAst {
	DslBool(!getDslBool(val));
}

negateDsl(val : DslAst) -> DslAst {
	error = \ -> {
		println("Can not negate " + prettyDsl(val));
		DslNode("negate", [val], 0);
	}
	switch (val){
		DslBool(value): error();
		DslInt(value): DslInt(-value);
		DslDouble(value): DslDouble(-value);
		DslString(value): error();
		DslList(value): error();
		DslNode(name, args, pos): error();
	}
}

consDsl(left : DslAst, right : DslAst) -> DslAst {
	rlist = getDslList(right);
	DslList(Cons(left, rlist));
}

headDsl(val : DslAst) -> DslAst {
	list = getDslList(val);
	switch (list) {
		EmptyList(): DslList(list);
		Cons(head, __): head;
	}
}

tailDsl(val : DslAst) -> DslAst {
	list = getDslList(val);
	DslList(switch (list) {
		EmptyList(): list;
		Cons(head, tail_): tail_;
	})
}

braceDsl(val : DslAst) -> DslAst {
	switch (val) {
		DslList(l): {
			headList(l, val)
		}
		default: val;
	}
}

nodeNameDsl(val : DslAst) -> DslAst {
	node = getDslNode(val);
	DslString(node.name);
}

nodeChildDsl(val : DslAst, n : DslAst) -> DslAst {
	node = getDslNode(val);
	i = getDslInt(n);
	elementAt(node.args, i, val)
}

makeNodeDsl(name : DslAst, args : DslAst) -> DslAst {
	DslNode(
		getDslString(name),
		list2array(getDslList(args)),
		0
	)
}

printlnDsl(val : DslAst) -> DslAst {
	println(prettyDsl(val));
	val;
}
