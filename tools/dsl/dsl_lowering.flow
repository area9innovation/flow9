import tools/dsl/dsl_rules;

export {
	// Define a lowering from a given language to another, running the "to" program in the given language
	defineDslLowering(from : DslGrammar, to : DslLanguage, sep : string, rules : string) -> DslLowering;

	// Lower the DSL according to these rules
	lowerDsl(lowering : DslLowering, program : DslAst) -> DslAst;
}

defineDslLowering(from : DslGrammar, to : DslLanguage, sep : string, rules : string) -> DslLowering {
	trules = parseRules(from, to.grammar, sep, rules);
	patterns : List<DslReplacement> = mapList(getDslList(trules.rules), \rule -> {
		node = getDslNode(rule);
		pattern = node.args[0];
		replacement = node.args[1];
		DslReplacement(pattern, replacement);
	});

	DslLowering(to, patterns);
}

lowerDsl(lowering : DslLowering, program : DslAst) -> DslAst {
	engine = DslMatchingEngine(lowering, makeTree(), program, false);
	doDslLowering(engine, program)
}

DslMatchingEngine(
	lowering : DslLowering,
	// Any bindings we have from a pattern
	bindings : Tree<string, DslAst>,
	// What is the node currently?
	term : DslAst,
	// Did we fail the matching?
	fail : bool,
);

doDslLowering(engine : DslMatchingEngine, program : DslAst) -> DslAst {
	nengine = foldList(engine.lowering.replacements, engine, \acc, replacement : DslReplacement -> {
		dslNodeReplacement(engine, program, replacement)
	});
	switch (program) {
		DslBool(value): nengine.term;
		DslInt(value): nengine.term;
		DslDouble(value): nengine.term;
		DslString(value): nengine.term;
		DslList(value): {
			DslList(mapList(value, \tt -> {
				doDslLowering(nengine, tt);
			}))
		}
		DslNode(name, args, pos): {
			DslNode(name,
				map(args, \arg -> {
					doDslLowering(nengine, arg);
				}),
				pos
			)
		}
	}
}

dslNodeReplacement(engine : DslMatchingEngine, term : DslAst, replacement : DslReplacement) -> DslMatchingEngine {
	// TODO. Check if the pattern matches
	engine
}
