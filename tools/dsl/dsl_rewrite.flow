import tools/dsl/dsl_pretty;
import tools/dsl/dsl_rules;
import tools/dsl/dsl_util;
import ds/egraph_matching;
import ds/egraph_extract;

export {
	// Parses a set of EGraph rewriting rules in the given language grammars.
	// Make sure the grammars have a "bind_1" semantic action for variables.
	// Also, the grammar should have a "ws" rule for whitespace.
	defineDslRewriting(from : DslGrammar, to : DslGrammar, sep : string, rules : string, costs : string, defaultVal : string) -> DslRewriting;

	// Perform N iterations of rewrites, and extract the best result
	rewriteDsl(program : DslAst, rewriting : DslRewriting, iterations : int) -> DslAst;

	// This reports any nodes with missing costs, for debugging
	missingDslCosts(actions : Set<string>, costs : DslCosts) -> void;
}

defineDslRewriting(from : DslGrammar, to : DslGrammar, sep : string, rules : string, costs : string, defaultVal : string) -> DslRewriting {
	DslRewriting(
		parseRules(from, to, rules, sep),
		rewriteCosts(costs),
		parseProgram("Default value", to, defaultVal)
	)
}

rewriteCosts(costs : string) -> DslCosts {
	costlang = defineGrammar("cost", <<
		costs = ws $"nil" (cost $"cons")*;
		cost = id "=>" ws int ";" ws $"cost_2";
		costs
	>>, ["ws", "int", "id"]);

	thecosts : List<DslAst> = getDslList(parseProgram("Costs", costlang, costs));
	costMap = foldList(thecosts, makeTree(), \acc, ast -> {
		node = getDslNode(ast);
		if (length(node.args) == 2) {
			name = getDslString(node.args[0]);
			cost = getDslInt(node.args[1]);
			setTree(acc, name, cost)
		} else acc;
	});

	DslCosts(costMap);
}

dslRules2replacements(rules : DslAst) -> [EReplacement<DslAst>] {
	error = \ -> {
		println("Expected rule, got " + prettyDsl(rules));
		[];
	}
	switch (rules) {
		DslBool(value): error();
		DslInt(value): error()
		DslDouble(value): error()
		DslString(value): error()
		DslList(value): {
			foldList(value, [], \acc, val -> {
				concat(acc, dslRules2replacements(val))
			});
		}
		DslNode(name, args, pos): {
			if (name == "rule") {
				pattern = dsl2pattern(args[0]);
				replacement = args[1];
				[
					EReplacement(pattern, \bindings : Tree<string, DslAst> -> {
						replaceDsl(bindings, replacement)
					})
				];
			} else error();
		}
	}
}

/*
This could be:

		bind(a)     => EPatternVar(a);
		node(args)  => EPatternTerm(a, args)
		e		   	=> EPatternTerm(e, $nil);
	
and then recursive application of this in some lowering system, followed by dsl2flow.
*/
dsl2pattern(ast : DslAst) -> EPattern<DslAst> {
	switch (ast) {
		DslBool(value): EPatternTerm(ast, []);
		DslInt(value): EPatternTerm(ast, []);
		DslDouble(value): EPatternTerm(ast, []);
		DslString(value): EPatternTerm(ast, []);
		DslList(value): EPatternTerm(DslList(makeList()), map(list2array(value), dsl2pattern));
		DslNode(name, args, pos): {
			if (name == "bind") {
				bind = getDslString(args[0]);
				EPatternVar(bind)
			} else {
				EPatternTerm(
					DslNode(name, [], pos),
					map(args, dsl2pattern)
				)
			}
		}
	}
}

replaceDsl(bindings : Tree<string, DslAst>, ast : DslAst) -> DslAst {
	switch (ast) {
		DslBool(value): ast;
		DslInt(value): ast;
		DslDouble(value): ast;
		DslString(value): ast;
		DslList(value): {
			DslList(mapList(value, \val : DslAst -> {
				replaceDsl(bindings, val)
			}))
		}
		DslNode(name, args, pos): {
			if (name == "bind") {
				bind = getDslString(args[0]);
				mvalue = lookupTree(bindings, bind);
				mvalue ?? {
					// println("Replaced " + bind + " with " + prettyDsl(mvalue));
					mvalue;
				} : {
					println("Unknown binding in replacement " + bind);
					ast;
				}
			} else {
				DslNode(name, map(args, \a -> replaceDsl(bindings, a)), pos);
			}
		}
	}
}

buildDslEGraph() -> EGraph<DslAst> {
	splitChildren = \a : DslAst -> switch (a) {
		DslBool(value): Pair(a, []);
		DslInt(value): Pair(a, []);
		DslDouble(value): Pair(a, []);
		DslString(value): Pair(a, []);
		DslList(value): Pair(DslList(makeList()), list2array(value));
		DslNode(name, args, pos): Pair(DslNode(name, [], pos), args);
	};
	makeEGraph(splitChildren);
}

buildDslEMatchEngine(egraph : EGraph<DslAst>, def : DslAst) -> EMatchEngine<DslAst> {
	makeEMatchEngine(egraph, def, combineDsl);
}

combineDsl(head : DslAst, args : [DslAst]) -> DslAst {
	switch (head) {
		DslBool(value): head;
		DslInt(value): head;
		DslDouble(value): head;
		DslString(value): head;
		DslList(value): DslList(array2list(args));
		DslNode(name, __, pos): DslNode(name, args, pos);
	}
};

rewriteDsl(program : DslAst, rewriting : DslRewriting, iterations : int) -> DslAst {
	egraph = buildDslEGraph();
	root = addEExp(egraph, program);
	match = buildDslEMatchEngine(egraph, rewriting.defaultValue);

	replacements = dslRules2replacements(rewriting.rules.rules);

	performEReplacements(match, iterations, root, replacements);

	if (false) {
		iterEGraph(egraph, \eclass, nodes : Set<ENode<DslAst>> -> {
			println(i2s(eclass) + ": " + superglue(set2array(nodes), \n : ENode<DslAst> -> prettyDsl(n.head), ", "));
		});
	}

	extracts : Tree<int, EClassCost<DslAst>> = extractEGraph(egraph,
		\node : ENode<DslAst>, ccosts : [EClassCost<DslAst>] -> {
			childcosts = fold(ccosts, 0, \acc, c -> {
				acc + c.cost
			});
			headCost = dslCost(rewriting.costs.costs, node.head);
			// println("'" + prettyDsl(node.head) + "' cost " + i2s(headCost) + " with child cost " + i2s(childcosts));
			headCost  + childcosts;
		}
	);

	reduced = extractDsl(egraph, extracts, root);
	reduced;
}

dslCost(costs : Tree<string, int>, a : DslAst) -> int {
	switch (a) {
		DslBool(value): lookupTreeDef(costs, "bool", 1);
		DslInt(value): lookupTreeDef(costs, "int", 1);
		DslDouble(value): lookupTreeDef(costs, "double", 1);
		DslString(value): lookupTreeDef(costs, "string", 1);
		DslList(value): lookupTreeDef(costs, "list", 1);
		DslNode(name, args, pos): lookupTreeDef(costs, name, 1);
	}
}

extractDsl(egraph : EGraph<DslAst>, extracts : Tree<int, EClassCost<DslAst>>, eclass : int) -> DslAst {
	root = getEClassRoot(egraph, eclass);
	mextract = lookupTree(extracts, root);
	mextract ?? {
		node : ENode<DslAst> = mextract.node;
		children = map(node.args, \a : int -> {
			extractDsl(egraph, extracts, a);
		});
		combineDsl(node.head, children)
	} : {
		nodes : Set<ENode<DslAst>> = getUnionMapValue(egraph.eclass, eclass);
		println("Could not resolve " + i2s(eclass) + " with " + superglue(set2array(nodes), \n : ENode<DslAst> -> prettyDsl(n.head), ", "));
		DslNode("Could not resolve " + i2s(eclass), [], 0)
	}
}

missingDslCosts(actions : Set<string>, costs : DslCosts) -> void {
	missing = differenceSets(actions,
		buildSet(getTreeKeys(costs.costs))
	);
	if (!isEmptySet(missing)) {
		println("Actions with missing costs: " + strGlue(set2array(missing), ", "))
	}
}
