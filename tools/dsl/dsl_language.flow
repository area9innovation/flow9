import text/gringo/gringo_ast;
import ds/tree;
import tools/dsl/dsl_ast;

export {
	DslLanguage(
		name : string,
		// The grammar to parse the entire language
		grammar : DslGrammar,
		// Any egraph-based desugaring specific to this language variant
		desugaring : Maybe<DslRewriting>,

		// Any lowering-based desugaring specific to this langauge variant?
		lowering : Maybe<DslLowering>,

		// Optimizations for this language
		optimization : Maybe<DslRewriting>,

		// Functions for the runtime required for this language
		runtime : Tree<string, DslAst>,
		// Set of compilers to various languages
		compilers : [DslCompiler],
		// If we are extending a language, which one is it?
		baseLanguage : Maybe<DslLanguage>,
	);

	// This is a simple Gringo grammar
	DslGrammar(term : GTerm);

	// A rewriting system
	DslRewriting(
		// The rules define how to match patterns and instantiate them
		rules : DslRules,
		// A map from actions to costs
		costs : DslCosts,
		// The default value for the plumbing of the rewrite engine to work
		defaultValue: DslAst
	);
		DslRules(rules : DslAst);

		DslCosts(costs : Tree<string, int>);

	DslLowering(
		replacements : List<DslReplacement>,
	);
		DslReplacement(
			pattern : DslAst,
			replacement : DslAst
		);


	// A compiler to a given target
	DslCompiler(
		target : string,
		// Per AST node, how to translate it
		blueprints : Tree<string, DslTranslation>
	);

		DslTranslation(pattern : DslPattern, output : [DslBlueprint]);
			// How to match and expand the AST nodes into bindings
			DslPattern(id : string, args : [string]);

			// The language to construct the output
			DslBlueprint ::= DslString, DslSubstitute, DslGlue;
				// Instantiate a bound value with this precedence
				DslSubstitute(bind : string, precedence : int);
				// Instantiate a DslList with this separate in between items
				DslGlue(bind : string, separator : string);
}
