import tools/flowc/statements/fs_transform;

export {
	//fsStatIds(new_id: () -> int) -> (FsStat) -> FsStat;
	//fsExpIds(new_id: () -> int) -> (FsExp) -> FsExp;
	fsIds(new_id: () -> int) -> (FsAll) -> FsAll;
/*	
	fsWrapStatCaseVarsWithCasts(e : FsStat, names: FiGlobalNames) -> FsStat;
	fsWrapExpCaseVarsWithCasts(e : FsExp, names: FiGlobalNames) -> FsExp;

	fsMakeStatCastsExplicit(s : FsStat, type: FiType, names: FiGlobalNames) -> FsStat;
	fsMakeExpCastsExplicit(e : FsExp, type: FiType, names: FiGlobalNames, do: bool) -> FsExp;

	fsStatSSA(s: FsStat, vars: Tree<string, int>) -> Pair<FsStat, Tree<string, int>>;
	fsExpSSA(e: FsExp, vars: Tree<string, int>) -> FsExp;

	fsInterpolateTyparsStat(s : FsStat, names: FiGlobalNames) -> FsStat;
	fsInterpolateTyparsExp(e : FsExp, names: FiGlobalNames) -> FsExp;

	fsStatReturnVars(s : FsStat) -> FsStat;
	fsExpReturnVars(e : FsExp) -> FsExp;
*/
}

/*
fsStatIds(new_id: () -> int) -> (FsStat) -> FsStat {
	\s -> switch(s) {
		FsIf(__,__,__,__):     FsIf(s with id = new_id());
		FsSwitch(__,__,__,__): FsSwitch(s with id = new_id());
		FsLet(__,__,__,__):    FsLet(s with id = new_id());
		FsSeq(__, __):         FsSeq(s with id = new_id());
		FsWrapExp(__,__):      FsWrapExp(s with id = new_id());
		FsRet(__,__):          FsRet(s with id = new_id());
		FsAssign(__,__,__):    FsAssign(s with id = new_id());
		FsModRc(__,__,__):     FsModRc(s with id = new_id());
		FsDecRc(__,__):        FsDecRc(s with id = new_id());
		//FsVarDecl(__,__):      FsVarDecl(s with id = new_id());
		FsVarDef(__,__,__):    FsVarDef(s with id = new_id());
		FsLet1(__,__,__):      FsLet1(s with id = new_id());
	}
}

fsExpIds(new_id: () -> int) -> (FsExp) -> FsExp {
	\e -> switch(e) {
		FsLambda(__,__,__,__,__): FsLambda(e with id = new_id());
		FsCall(__,__,__,__):      FsCall(e with id = new_id());
		FsCallPrim(__,__,__,__):  FsCallPrim(e with id = new_id());
		FsCast(__,__,__,__):      FsCast(e with id = new_id());
		FsConst(__,__):           FsConst(e with id = new_id());
		FsTailCall(__,__,__,__):  FsTailCall(e with id = new_id());
		FsIncRc(__,__,__):        FsIncRc(e with id = new_id());
		FsVar(__,__,__,__):       FsVar(e with id = new_id()); 
	}
}
*/

fsIds(new_id: () -> int) -> (FsAll) -> FsAll {
	\s -> switch(s) {
		FsIf(__,__,__,__):        FsIf(s with id = new_id());
		FsSwitch(__,__,__,__):    FsSwitch(s with id = new_id());
		FsLet(__,__,__,__):       FsLet(s with id = new_id());
		FsSeq(__, __):            FsSeq(s with id = new_id());
		FsWrapExp(__,__):         FsWrapExp(s with id = new_id());
		FsRet(__,__):             FsRet(s with id = new_id());
		FsAssign(__,__,__):       FsAssign(s with id = new_id());
		FsModRc(__,__,__):        FsModRc(s with id = new_id());
		FsDecRc(__,__):           FsDecRc(s with id = new_id());
		FsIncRc(__,__,__):        FsIncRc(s with id = new_id());
		//FsVarDecl(__,__):         FsVarDecl(s with id = new_id());
		FsVarDef(__,__,__):       FsVarDef(s with id = new_id());
		FsLet1(__,__,__):         FsLet1(s with id = new_id());
		FsLambda(__,__,__,__,__): FsLambda(s with id = new_id());
		FsCall(__,__,__,__):      FsCall(s with id = new_id());
		FsCallPrim(__,__,__,__):  FsCallPrim(s with id = new_id());
		FsCast(__,__,__,__):      FsCast(s with id = new_id());
		FsConst(__,__):           FsConst(s with id = new_id());
		FsTailCall(__,__,__,__):  FsTailCall(s with id = new_id());
		FsVar(__,__,__,__):       FsVar(s with id = new_id()); 
	}
}


/*
fsWrapStatCaseVarsWithCasts(s : FsStat, names: FiGlobalNames) -> FsStat {
	switch(s) {
		FsIf(cond, s1, s2, __,__): {
			FsIf(s with
				cond = fsWrapExpCaseVarsWithCasts(cond, names),
				s1 = fsWrapStatCaseVarsWithCasts(s1, names),
				s2 = fsWrapStatCaseVarsWithCasts(s2, names),
			);
		}
		FsSwitch(v, __, cases, __,__): {
			FsSwitch(s with
				cases = map(cases, \c -> {
					body1 = fsWrapStatCaseVarsWithCasts(c.body, names);
					if (c.struct == "default") {
						FsCase(c with body = body1);
					} else {
						switch (lookupTree(names.structs, c.struct)) {
							Some(struct): {
								args_to_wrap = filtermapi(c.args, \i, arg -> {
									arg_type = struct.args[i].type;
									arg_typars = fiCollectTypars(arg_type, makeSet());
									if (isEmptySet(arg_typars)) None() else Some(Pair(arg.name, arg_type));
								});
								body2 = if (args_to_wrap == []) body1 else fsDoWrapCaseVarsWithCasts(body1, args_to_wrap);
								FsCase(c with body = body2);
							}
							None(): {
								fail0("struct " + c.struct + "is not found");
							}
						}
					}
				})
			);
		}
		FsLet(v, x, s1,__,__): {
			FsLet(s with 
				e = fsWrapExpCaseVarsWithCasts(x, names),
				s = fsWrapStatCaseVarsWithCasts(s1, names)
			);
		}
		FsSeq(ss, __,__): {
			FsSeq(s with ss = map(ss, \x -> fsWrapStatCaseVarsWithCasts(x, names)));
		}
		FsWrapExp(x, __): {
			FsWrapExp(s with e = fsWrapExpCaseVarsWithCasts(x, names));
		}
		FsRet(x,__): {
			FsRet(s with e = fsWrapExpCaseVarsWithCasts(x, names));
		}
		FsAssign(to, what, __): {
			FsAssign(s with 
				to = fsWrapExpCaseVarsWithCasts(to, names),
				what = fsWrapExpCaseVarsWithCasts(what, names),
			);
		}
		FsModRc(__, x,__): {
			FsModRc(s with e = fsWrapExpCaseVarsWithCasts(x, names));
		}
		default: s;
	}
}

fsWrapExpCaseVarsWithCasts(e : FsExp, names: FiGlobalNames) -> FsExp {
	switch(e) {
		FsLambda(__,closure, args, body, type1,__): {
			FsLambda(e with body = fsWrapStatCaseVarsWithCasts(body, names));
		}
		FsCall(fn, args,__,__): {
			FsCall(e with
				f = fsWrapExpCaseVarsWithCasts(fn, names),
				args = map(args, \arg -> fsWrapExpCaseVarsWithCasts(arg, names))
			);
		}
		FsCallPrim(__,es,__,__): {
			FsCallPrim(e with es = map(es, \x -> fsWrapExpCaseVarsWithCasts(x, names)));
		}
		default: e;
	}
}

fsDoWrapCaseVarsWithCasts(e : FsStat, vars: [Pair<string, FiType>]) -> FsStat {
	switch (e) {
		FsLet(v, vtype, ex, s,__): {
			switch (find(vars, \p -> p.first == v)) {
				Some(p): {
					FsLet(e with 
						e = fsMakeCast(ex, fsExpType(ex), vtype),
						s = fsDoWrapCaseVarsWithCasts(s, vars)
					);
				}
				None(): e;
			}
		}
		FsSeq(ss, __): {
			FsSeq(e with ss = map(ss, \x -> fsDoWrapCaseVarsWithCasts(x, vars)));
		}
		default: e;
	}
}

fsMakeStatCastsExplicit(s : FsStat, type: FiType, names: FiGlobalNames) -> FsStat {
	do_cast = \x -> fsMakeStatCastsExplicit(x, type, names);
	switch(s) {
		FsLet(v, vtype, e1, s1,__): {
			FsLet(s with 
				e = fsMakeExpCastsExplicit(e1, vtype, names, true),
				s = do_cast(s1)
			);
		}
		FsIf(e1, s1, s2, __): {
			FsIf(s with
				cond = fsMakeExpCastsExplicit(e1, FiTypeBool(), names, true),
				s1 = do_cast(s1),
				s2 = do_cast(s2),
			);
		}
		FsSwitch(v, __, cases, __,__): {
			FsSwitch(s with
				cases = map(cases, \c -> FsCase(c with body = do_cast(c.body)))
			);
		}
		FsSeq(ss, __,__): {
			FsSeq(s with ss = map(ss, do_cast));
		}
		FsWrapExp(e, start): {
			FsWrapExp(fsMakeExpCastsExplicit(e, fsExpType(e), names, false), start);
		}
		FsRet(e, start): {
			FsRet(fsMakeExpCastsExplicit(e, type, names, true), start);
		}
		FsAssign(to, what, start): {
			tp = fsExpType(to);
			switch (tp) {
				FiTypeRef(t): {
					switch (fsExpType(what)) {
						FiTypeRef(__): FsAssign(
							fsMakeExpCastsExplicit(to, tp, names, false), 
							fsMakeExpCastsExplicit(what, tp, names, true), start
						);
						default: FsAssign(
							fsMakeExpCastsExplicit(to, tp, names, false), 
							fsMakeExpCastsExplicit(what, t, names, true), start
						);
					}
				}
				default: {
					FsAssign(
						fsMakeExpCastsExplicit(to, tp, names, false), 
						fsMakeExpCastsExplicit(what, tp, names, true), start
					);
				}
			}
		}
		FsModRc(__,e,__): {
			FsModRc(s with e = fsMakeExpCastsExplicit(e, type, names, false));
		}
		FsTailCall(__,__,__): s;
		FsVarDecl(var,__): s;
	}
}

fsMakeExpCastsExplicit(e : FsExp, type: FiType, names: FiGlobalNames, do: bool) -> FsExp {
	no_cast = \x -> fsMakeExpCastsExplicit(x, FiTypeVoid(), names, false);
	e1 = switch(e) {
		FsLambda(__,closure, args, body, type1,__): {
			switch (type) {
				FiTypeFunction(__,returnType): {
					FsLambda(e with 
						body = fsMakeStatCastsExplicit(body, returnType, names),
						type = FiTypeFunction(type1 with returnType = returnType)
					);
				}
				FiTypeParameter(__): {
					FsLambda(e with body = fsMakeStatCastsExplicit(body, fsStatType(body), names));
				}
				FiTypeFlow(): {
					FsLambda(e with body = fsMakeStatCastsExplicit(body, fsStatType(body), names));
				}
				FiTypeNative(): {
					FsLambda(e with body = fsMakeStatCastsExplicit(body, fsStatType(body), names));
				}
				default: {
					fail0("non func type: " + toString(type) + ", expected: " + toString(type) + "\n" + toStringFormatted(e));
				}
			}
		}
		FsCall(fn, args,__,__): {
			debug = ref false;
			fn_type = cast(fsExpType(fn): FiType -> FiTypeFunction);
			FsCall(e with
				f = fsMakeExpCastsExplicit(fn, fn_type, names, false),
				args = mapi(args, \i, arg ->
					fsMakeExpCastsExplicit(arg, fn_type.args[i].type, names, true)
				)
			);
		}
		FsCallPrim(__,__,type1,__): {
			fsMakeCallPrimCastsExplicit(e, type1, names);
		}
		default: e;
	}
	type1 = fsExpType(e1);
	if (!do) e1 else {
		fsMakeCast(e1, type1, type);
	}
}

fsMakeCast(e: FsExp, from: FiType, to: FiType) -> FsExp {
	if (fiEqualTypes(from, to) || to == FiTypeVoid()) e else {
		switch (fiMatchTyparsSym(from, to, Pair(makeTree(), makeTree()))) {
			Some(p): {
				from1 = fiApplyTypeSubstitution(p.first, from);
				to1 = fiApplyTypeSubstitution(p.second, to);
				if (fiEqualTypes(from1, to1)) e else FsCast(e, from1, to1, -1);
			}
			None(): {
				FsCast(e, from, to, -1);
			}
		}
	}
}

fsMakeCallPrimCastsExplicit(e : FsCallPrim, type: FiType, names: FiGlobalNames) -> FsExp {
	def_case = \do -> FsCallPrim(e with es = map(e.es, \x -> fsMakeExpCastsExplicit(x, type, names, do)));
	typed_case = \tp, do -> FsCallPrim(e with es = map(e.es, \x -> fsMakeExpCastsExplicit(x, tp, names, do)));
	struct_case = \name -> {
		struct = lookupTreeDef(names.structs, name, FiTypeStruct("", [], [], 0));
		switch (type) {
			FiTypeName(__,typars): {
				typar_subst = foldi(struct.typars, makeTree(), \i, acc, tp ->
					switch (tp) {
						FiTypeParameter(nm): setTree(acc, nm, typars[i]);
						default: acc;
					}
				);
				FsCallPrim(e with es = mapi(e.es, \i, x ->
					fsMakeExpCastsExplicit(x, fiApplyTypeSubstitution(typar_subst, struct.args[i].type), names, true)
				));
			}
			default: {
				fail0("struct type must be FiTypeName, got: " + toString(type));
			}
		}
	}
	dearray_type = \tp -> switch (tp) {
		FiTypeArray(t): t;
		default: FiTypeVoid();
	}
	deref_type = \tp -> switch (tp) {
		FiTypeRef(t): t;
		default: FiTypeVoid();
	}
	switch (e.op) {
		FsOrPrim():  def_case(false);
		FsAndPrim(): def_case(false);
		FsNotPrim(): def_case(false);

		FsEqPrim():  typed_case(fiTypeUpperBoundary(fsExpType(e.es[0]), fsExpType(e.es[1]), names), true);
		FsNePrim():  typed_case(fiTypeUpperBoundary(fsExpType(e.es[0]), fsExpType(e.es[1]), names), true);
		FsLePrim():  typed_case(fiTypeUpperBoundary(fsExpType(e.es[0]), fsExpType(e.es[1]), names), true);
		FsGePrim():  typed_case(fiTypeUpperBoundary(fsExpType(e.es[0]), fsExpType(e.es[1]), names), true);
		FsLtPrim():  typed_case(fiTypeUpperBoundary(fsExpType(e.es[0]), fsExpType(e.es[1]), names), true);
		FsGtPrim():  typed_case(fiTypeUpperBoundary(fsExpType(e.es[0]), fsExpType(e.es[1]), names), true);

		FsPlusPrim():  def_case(true);
		FsMinusPrim(): def_case(true);
		FsMulPrim():   def_case(true);
		FsDivPrim():   def_case(true);
		FsModPrim():   def_case(true);
		FsNegPrim():   def_case(true);
		FsArrayPrim(): typed_case(dearray_type(type), true);
		FsIndexPrim(): FsCallPrim(e with es = [
			fsMakeExpCastsExplicit(e.es[0], FiTypeArray(type), names, true),
			fsMakeExpCastsExplicit(e.es[1], FiTypeInt(), names, true)
		]);
		FsDerefPrim(): typed_case(FiTypeRef(type), true);
		FsRefPrim(): typed_case(deref_type(type), true);
		FsStructPrim(name): struct_case(name);
		FsFieldPrim(name): {
			if (name == "structname") {
				def_case(false);
			} else {
				switch (fsExpType(e.es[0])) {
					FiTypeName(struct_name, typars): {
						switch (lookupTree(names.structs, struct_name)) {
							Some(struct): {
								switch (find(struct.args, \arg -> arg.name == name)) {
									Some(arg): {
										fsMakeCast(def_case(false), arg.type, type);
									}
									None(): fail0("field " + name + " of struct " + struct_name + " is not found");
								}
							}
							None(): def_case(false);
						}
					}
					default: def_case(false);
				}
			}
		}
		FsRequirePrim(file):  def_case(false);
		FsUnsafePrim(name):   def_case(false);
		FsIfPrim(): {
			FsCallPrim(e with
				es = [
					fsMakeExpCastsExplicit(e.es[0], FiTypeBool(), names, false),
					fsMakeExpCastsExplicit(e.es[1], type, names, true),
					fsMakeExpCastsExplicit(e.es[2], type, names, true)
				]
			);
		}
		FsReusePrim(name, reuse): struct_case(name);
	}
}

fsStatSSA(s: FsStat, vars: Tree<string, int>) -> Pair<FsStat, Tree<string, int>> {
	switch(s) {
		FsLet(v, vtype, e, s1, __): {
			if (v == "__") {
				p = fsStatSSA(s1, vars);
				Pair(FsLet(s with e = fsExpSSA(e, vars), s = p.first), p.second);
			} else {
				new_vars = setTree(vars, v, lookupTreeDef(vars, v, 0) + 1);
				p = fsStatSSA(s1, new_vars);
				Pair(
					FsLet(
						fsSSAvar(v, new_vars),
						vtype, 
						fsExpSSA(e, new_vars), 
						p.first, -1
					),
					p.second
				);
			}
		}
		FsIf(cond, s1, s2,__,__): {
			Pair(
				FsIf(s with
					cond = fsExpSSA(cond, vars),
					s1 = fsStatSSA(s1, vars).first,
					s2 = fsStatSSA(s2, vars).first
				), 
				vars
			);
		}
		FsSwitch(var, __, cases, type,__): {
			Pair(
				FsSwitch(s with
					x = fsExpSSA(var, vars),
					cases = map(cases, \c -> {
						new_vars = fold(c.args, vars, \acc, arg -> 
							if (arg.name == "__") acc else
							setTree(acc, arg.name, lookupTreeDef(vars, arg.name, 0) + 1)
						);
						FsCase(c with
							args = map(c.args, \arg -> FsVar(arg with name = fsSSAvar(arg.name, new_vars))),
							body = fsStatSSA(c.body, vars).first
						);
					})
				), 
				vars
			);
		}
		FsSeq(es,__): {
			p = fold(es, Pair([], vars), \acc, e -> {
				x = fsStatSSA(e, acc.second);
				Pair(concat(acc.first, [x.first]), x.second);
			});
			Pair(FsSeq(s with ss = p.first), p.second);
		}
		FsWrapExp(e, start): {
			Pair(FsWrapExp(fsExpSSA(e, vars), start), vars);
		}
		FsRet(e, start): {
			Pair(FsRet(fsExpSSA(e, vars), start), vars);
		}

		FsVarDecl(var, start): {
			if (var.name == "__") {
				Pair(s, vars);
			} else {
				new_vars = setTree(vars, var.name, lookupTreeDef(vars, var.name, 0) + 1);
				Pair(
					FsVarDecl(FsVar(var with name = fsSSAvar(var.name, new_vars)), start),
					new_vars
				);
			}
		}
		FsAssign(to, what, start): {
			Pair(
				FsAssign(
					fsExpSSA(to, vars), 
					fsExpSSA(what, vars), start
				),
				vars
			);
		}
		FsModRc(op, e, info): {
			Pair(FsModRc(op, fsExpSSA(e, vars), info), vars);
		}
	}
}

fsExpSSA(e: FsExp, vars: Tree<string, int>) -> FsExp {
	switch(e) {
		FsLambda(closure, args, body,__,__): {
			new_vars = fold(args, vars, \acc, arg ->
				if (arg.name == "__") acc else {
					setTree(acc, arg.name, lookupTreeDef(acc, arg.name, 0) + 1);
				}
			);
			FsLambda(e with
				closure = map(closure, \v -> FsVar(v with name = fsSSAvar(v.name, new_vars))),
				args = map(args, \arg ->
					FsVar(fsSSAvar(arg.name, new_vars), false, arg.type, -1)
				),
				body = fsStatSSA(body, new_vars).first
			);
		}
		FsCall(fn, args,__,__): {
			FsCall(e with
				f = fsExpSSA(fn, vars),
				args = map(args, \arg -> fsExpSSA(arg, vars))
			);
		}
		FsCallPrim(__, es,__,__): {
			FsCallPrim(e with es = map(es, \x -> fsExpSSA(x, vars)));
		}
		FsVar(name, __,__,__): {
			FsVar(e with name = fsSSAvar(name, vars));
		}
		FsConst(__,__): e;
	}
}

fsSSAvar(v: string, vars: Tree<string, int>) -> string {
	if (v == "__") v else {
		i = lookupTreeDef(vars, v, 0);
		if (i == 0) fail("fsSSAvar: i == 0, v=" + v);
		v + if (i == 1) "" else "__ssa_" + i2s(i - 1);
	}
}

fsInterpolateTyparsStat(s : FsStat, names: FiGlobalNames) -> FsStat {
	do_interpolate = \x -> fsInterpolateTyparsStat(x, names);
	switch(s) {
		FsLet(v, vtype, e1, s1,__): {
			FsLet(s with 
				e = fsInterpolateTyparsExp(e1, names),
				s = do_interpolate(s1)
			);
		}
		FsIf(e1, s1, s2, __): {
			FsIf(s with
				cond = fsInterpolateTyparsExp(e1, names),
				s1 = do_interpolate(s1),
				s2 = do_interpolate(s2),
			);
		}
		FsSwitch(v, __, cases, __): {
			FsSwitch(s with
				cases = map(cases, \c -> FsCase(c with body = do_interpolate(c.body)))
			);
		}
		FsSeq(ss, __): {
			FsSeq(s with ss = map(ss, do_interpolate));
		}
		FsWrapExp(e, start): {
			FsWrapExp(fsInterpolateTyparsExp(e, names), start);
		}
		FsRet(e, start): {
			FsRet(fsInterpolateTyparsExp(e, names), start);
		}
		FsAssign(var, e, start): {
			FsAssign(var, fsInterpolateTyparsExp(e, names), start);
		}
		FsModRc(op, e, start): {
			FsModRc(op, fsInterpolateTyparsExp(e, names), start);
		}
		FsTailCall(__,__,__): s;
		FsVarDecl(var,__): s;
	}
}

fsInterpolateTyparsExp(e : FsExp, names: FiGlobalNames) -> FsExp {
	do_interpolate = \x -> fsInterpolateTyparsExp(x, names);
	switch(e) {
		FsLambda(closure, args, body, type,__): {
			FsLambda(e with body = fsInterpolateTyparsStat(body, names));
		}
		FsCall(fn, args, ret_type,__): {
			fn1 = fsInterpolateTyparsExp(fn, names);
			fn_type = fsExpType(fn1);
			args1 = mapi(args, \i, arg -> fsInterpolateTyparsExp(arg, names));
			switch (fn_type) {
				FiTypeFunction(fn_args, returnType): {
					// Match arguments 
					args_unified = mapi(args1, \i, arg -> fiUnifyTypes(fsExpType(arg), fn_args[i].type));
					ret_unified = fiUnifyTypes(returnType, ret_type);
					FsCall(e with 
						f = fsSetExpType(fn1, FiTypeFunction(
							mapi(fn_args, \i, arg -> FiFunArg(arg.name, args_unified[i].second)),
							ret_unified.second
						)), 
						args = mapi(args1, \i, arg -> fsSetExpType(arg, args_unified[i].first)),
						type = ret_unified.first
					);
				}
				default: {
					FsCall(e with f = fn1, args = args1);
				}
			}
		}
		FsCallPrim(__,__,type1,__): {
			fsInterpolateTyparsCallPrim(e, names);
		}
		default: e;
	}
}

fsInterpolateTyparsCallPrim(e : FsCallPrim, names: FiGlobalNames) -> FsExp {
	def_interpolate = \ -> FsCallPrim(e with es = map(e.es, \x -> fsInterpolateTyparsExp(x, names)));
	interpolate_struct = \name -> {
		struct = lookupTreeDef(names.structs, name, FiTypeStruct("", [], [], 0));
		type = fsExpType(e);
		switch (type) {
			FiTypeName(__,typars): {
				typar_subst = foldi(struct.typars, makeTree(), \i, acc, tp ->
					switch (tp) {
						FiTypeParameter(nm): setTree(acc, nm, typars[i]);
						default: acc;
					}
				);
				subst = foldi(struct.args, makeTree(), \i, sub, struct_arg -> 
					fiMatchTypars(fsExpType(e.es[i]), fiApplyTypeSubstitution(typar_subst, struct_arg.type), sub)
				);
				FsCallPrim(e with es = mapi(e.es, \i, x ->
					fsSetExpType(
						fsInterpolateTyparsExp(x, names), 
						fiApplyTypeSubstitution(subst, fsExpType(x))
					)
				));
			}
			default: {
				fail0("struct type must be FiTypeName, got: " + toString(type));
			}
		}
	}
	switch (e.op) {
		FsOrPrim():  def_interpolate();
		FsAndPrim(): def_interpolate();
		FsNotPrim(): def_interpolate();

		FsEqPrim():  def_interpolate();
		FsNePrim():  def_interpolate();
		FsLePrim():  def_interpolate();
		FsGePrim():  def_interpolate();
		FsLtPrim():  def_interpolate();
		FsGtPrim():  def_interpolate();

		FsPlusPrim():  def_interpolate();
		FsMinusPrim(): def_interpolate();
		FsMulPrim():   def_interpolate();
		FsDivPrim():   def_interpolate();
		FsModPrim():   def_interpolate();
		FsNegPrim():   def_interpolate();
		FsArrayPrim(): def_interpolate();
		FsIndexPrim(): def_interpolate();
		FsDerefPrim(): def_interpolate();
		FsRefPrim(): def_interpolate();
		FsStructPrim(name): interpolate_struct(name);
		FsFieldPrim(name): def_interpolate();
		FsRequirePrim(__): def_interpolate();
		FsUnsafePrim(__): def_interpolate();
		FsIfPrim(): def_interpolate();
		FsReusePrim(name, reuse): interpolate_struct(name);
	}
}

fsStatReturnVars(s : FsStat) -> FsStat {
	switch(s) {
		FsLet(v, vtype, e, s1, start): {
			FsLet(v, vtype, fsExpReturnVars(e), fsStatReturnVars(s1), start);
		}
		FsIf(e, s1, s2, __,__): {
			FsIf(s with
				cond = fsExpReturnVars(e),
				s1 = fsStatReturnVars(s1),
				s2 = fsStatReturnVars(s2),
			);
		}
		FsSwitch(v, __, cases, __,__): {
			FsSwitch(s with
				cases = map(cases, \c -> FsCase(c with body = fsStatReturnVars(c.body)))
			);
		}
		FsSeq(ss, __): {
			FsSeq(s with ss = mapConcat(ss, \x -> fsUnwrapSeq(fsStatReturnVars(x))));
		}
		FsRet(e, start): {
			er = fsExpReturnVars(e);
			//ret = FsRet(, start);
			switch (er) {
				FsVar(__,__,__,__): FsRet(er, start);
				default: {
					type = fsExpType(er);
					switch (type) {
						FiTypeVoid():
							FsSeq([FsWrapExp(er, start), FsRet(FsConst(FiVoid(start), -1), -1)], -1);
						default: {
							FsLet("__ret_var__", type, er, FsRet(FsVar("__ret_var__", false, type, -1), -1), -1);
						}
					}
				}
			}
		}
		FsWrapExp(e, start): FsWrapExp(fsExpReturnVars(e), start);
		FsAssign(var, e, start): {
			FsAssign(var, fsExpReturnVars(e), start);
		}
		default: s;
	}
}

fsExpReturnVars(e : FsExp) -> FsExp {
	switch(e) {
		FsLambda(__,__,body,__,__): {
			FsLambda(e with body = fsStatReturnVars(body));
		}
		FsCall(fn, args, ret_type, start): {
			FsCall(fsExpReturnVars(fn), map(args, fsExpReturnVars), ret_type, start);
		}
		FsCallPrim(__,es,__,__): {
			FsCallPrim(e with es = map(es, fsExpReturnVars));
		}
		default: e;
	}
}
*/
