import tools/flowc/statements/fs_helpers;
import tools/flowc/incremental/fi_type_unify;

export {
	fsWrapCaseVarsWithCasts(e : FsStat, vars: [Pair<string, FiType>]) -> FsStat;
	fsMakeStatCastsExplicit(s : FsStat, type: FiType, names: FiGlobalNames) -> FsStat;
	fsMakeExpCastsExplicit(e : FsExp, type: FiType, names: FiGlobalNames, do: bool) -> FsExp;

	fsStatSSA(s: FsStat, vars: Tree<string, int>) -> Pair<FsStat, Tree<string, int>>;
	fsExpSSA(e: FsExp, vars: Tree<string, int>) -> FsExp;

	fsInterpolateTyparsStat(s : FsStat, names: FiGlobalNames) -> FsStat;
	fsInterpolateTyparsExp(e : FsExp, names: FiGlobalNames) -> FsExp;
}

fsWrapCaseVarsWithCasts(e : FsStat, vars: [Pair<string, FiType>]) -> FsStat {
	switch (e) {
		FsLet(v, type, ex): {
			switch (find(vars, \p -> p.first == v)) {
				Some(p): {
					ex_wrapped = fsMakeCast(ex, fsExpType(ex), type);
					FsLet(e with e = ex_wrapped);
				}
				None(): e;
			}
		}
		FsSeq(ss, __): {
			FsSeq(e with ss = map(ss, \x -> fsWrapCaseVarsWithCasts(x, vars)));
		}
		default: e;
	}
}

fsMakeStatCastsExplicit(s : FsStat, type: FiType, names: FiGlobalNames) -> FsStat {
	do_cast = \x -> fsMakeStatCastsExplicit(x, type, names);
	switch(s) {
		FsLet(name, vtype, e1): {
			FsLet(s with e = fsMakeExpCastsExplicit(e1, vtype, names, true));
		}
		FsIf(e1, s1, s2, __): {
			FsIf(s with
				cond = fsMakeExpCastsExplicit(e1, FiTypeBool(), names, true),
				s1 = do_cast(s1),
				s2 = do_cast(s2),
			);
		}
		FsSwitch(v, __, cases, __): {
			FsSwitch(s with
				cases = map(cases, \c -> FsCase(c with body = do_cast(c.body)))
			);
		}
		FsSeq(ss, __): {
			FsSeq(s with ss = map(ss, do_cast));
		}
		FsWrapExp(e): {
			FsWrapExp(fsMakeExpCastsExplicit(e, fsExpType(e), names, false));
		}
		FsRet(e): {
			FsRet(fsMakeExpCastsExplicit(e, type, names, true));
		}
		FsTailCall(__): {
			s;
		}
		FsVarDecl(var): {
			s;
		}
		FsAssign(var, e): {
			FsAssign(var, fsMakeExpCastsExplicit(e, var.type, names, true));
		}
	}
}

fsMakeExpCastsExplicit(e : FsExp, type: FiType, names: FiGlobalNames, do: bool) -> FsExp {
	no_cast = \x -> fsMakeExpCastsExplicit(x, FiTypeVoid(), names, false);
	e1 = switch(e) {
		FsLambda(closure, args, body, type1): {
			switch (type) {
				FiTypeFunction(__,returnType): {
					FsLambda(e with 
						body = fsMakeStatCastsExplicit(body, returnType, names),
						type = FiTypeFunction(type1 with returnType = returnType)
					);
				}
				FiTypeParameter(__): {
					FsLambda(e with body = fsMakeStatCastsExplicit(body, fsStatType(body), names));
				}
				FiTypeFlow(): {
					FsLambda(e with body = fsMakeStatCastsExplicit(body, fsStatType(body), names));
				}
				FiTypeNative(): {
					FsLambda(e with body = fsMakeStatCastsExplicit(body, fsStatType(body), names));
				}
				default: {
					fail0("non func type: " + toString(type) + ", expected: " + toString(type) + "\n" + toStringFormatted(e));
				}
			}
		}
		FsCall(fn, args,__): {
			debug = ref false;
			fn_type = cast(fsExpType(fn): FiType -> FiTypeFunction);
			FsCall(e with
				f = fsMakeExpCastsExplicit(fn, fn_type, names, false),
				args = mapi(args, \i, arg ->
					fsMakeExpCastsExplicit(arg, fn_type.args[i].type, names, true)
				)
			);
		}
		FsCallPrim(__,__,type1): {
			fsMakeCallPrimCastsExplicit(e, type1, names);
		}
		FsRequire(__, ex,__): {
			FsRequire(e with e = no_cast(ex));
		}
		FsUnsafe(__, ex,__): {
			FsUnsafe(e with fallback = no_cast(ex));
		}
		FsCast(ex, from, to): {
			FsCast(e with e = no_cast(ex));
		}
		FsTernaryIf(cond, pos, neg, type1): {
			FsTernaryIf(e with
				cond = fsMakeExpCastsExplicit(cond, FiTypeBool(), names, false),
				s1 = fsMakeExpCastsExplicit(pos, type1, names, true),
				s2 = fsMakeExpCastsExplicit(neg, type1, names, true),
			);
		}
		default: e;
	}
	type1 = fsExpType(e1);
	if (!do) e1 else {
		fsMakeCast(e1, type1, type);
	}
}

fsMakeCast(e: FsExp, from: FiType, to: FiType) -> FsExp {
	if (fiEqualTypes(from, to) || to == FiTypeVoid()) e else {
		switch (fiMatchTyparsSym(from, to, Pair(makeTree(), makeTree()))) {
			Some(p): {
				from1 = fiApplyTypeSubstitution(p.first, from);
				to1 = fiApplyTypeSubstitution(p.second, to);
				if (fiEqualTypes(from1, to1)) e else FsCast(e, from1, to1);
			}
			None(): {
				FsCast(e, from, to);
			}
		}
	}
}

fsTypeUpperBoundary(t1: FiType, t2: FiType, names: FiGlobalNames) -> FiType {
	if (t1 == t2) t1 else {
		t0 = switch (t2) {
			FiTypeFlow(): t2;
			FiTypeNative(): t2;
			default: t1;
		}
		switch (t1) {
			FiTypeFlow(): t1;
			FiTypeNative(): t1;
			FiTypeName(n1, __): {
				switch (t2) {
					FiTypeFlow(): t2;
					FiTypeNative(): t2;
					FiTypeName(n2, __): {
						switch (lookupTree(names.structs, n1)) {
							Some(__): t2;
							None(): {
								switch (lookupTree(names.structs, n2)) {
									Some(__): t1;
									None(): {
										u1 = lookupTreeDef(names.unions, n1, FiTypeUnion("", [], [], 0));
										u2 = lookupTreeDef(names.unions, n2, FiTypeUnion("", [], [], 0));
										if (isEmptySet(differenceSets(buildSet(u1.typenames), buildSet(u2.typenames)))) t2 else t1;
									}
								}
							}
						}
					}
					default: t0;
				}
			} 
			default: t0;
		}
	}
}

fsMakeCallPrimCastsExplicit(e : FsCallPrim, type: FiType, names: FiGlobalNames) -> FsExp {
	def_case = \do -> FsCallPrim(e with es = map(e.es, \x -> fsMakeExpCastsExplicit(x, type, names, do)));
	typed_case = \tp, do -> FsCallPrim(e with es = map(e.es, \x -> fsMakeExpCastsExplicit(x, tp, names, do)));
	dearray_type = \tp -> switch (tp) {
		FiTypeArray(t): t;
		default: FiTypeVoid();
	}
	deref_type = \tp -> switch (tp) {
		FiTypeRef(t): t;
		default: FiTypeVoid();
	}
	switch (e.op) {
		FcOrPrim():  def_case(false);
		FcAndPrim(): def_case(false);
		FcNotPrim(): def_case(false);

		FcEqPrim():  typed_case(fsTypeUpperBoundary(fsExpType(e.es[0]), fsExpType(e.es[1]), names), true);
		FcNePrim():  typed_case(fsTypeUpperBoundary(fsExpType(e.es[0]), fsExpType(e.es[1]), names), true);
		FcLePrim():  typed_case(fsTypeUpperBoundary(fsExpType(e.es[0]), fsExpType(e.es[1]), names), true);
		FcGePrim():  typed_case(fsTypeUpperBoundary(fsExpType(e.es[0]), fsExpType(e.es[1]), names), true);
		FcLtPrim():  typed_case(fsTypeUpperBoundary(fsExpType(e.es[0]), fsExpType(e.es[1]), names), true);
		FcGtPrim():  typed_case(fsTypeUpperBoundary(fsExpType(e.es[0]), fsExpType(e.es[1]), names), true);

		FcPlusPrim():  def_case(true);
		FcMinusPrim(): def_case(true);
		FcMulPrim():   def_case(true);
		FcDivPrim():   def_case(true);
		FcModPrim():   def_case(true);
		FcNegPrim():   def_case(true);
		FcArrayPrim(): typed_case(dearray_type(type), true);
		FcIndexPrim(): FsCallPrim(e with es = [
			fsMakeExpCastsExplicit(e.es[0], FiTypeArray(type), names, true),
			fsMakeExpCastsExplicit(e.es[1], FiTypeInt(), names, true)
		]);
		FcDerefPrim(): typed_case(FiTypeRef(type), true);
		FcAssignPrim(): {
			var_type = fsExpType(e.es[0]);
			exp_type = fsExpType(e.es[1]);
			type1 = switch (var_type) {
				FiTypeRef(t): t;
				FiTypeParameter(__): exp_type;
				FiTypeFlow(): FiTypeFlow();
				default: fail0("illegal assign type: " + prettyFiType(dummyPretty, var_type, makeSet()));
			}
			FsCallPrim(e with es = [
				fsMakeExpCastsExplicit(e.es[0], var_type, names, false),
				fsMakeExpCastsExplicit(e.es[1], type1, names, true)
			]);
		}
		FcRefPrim(): typed_case(deref_type(type), true);
		FcStructPrim(struct_name): {
			struct = lookupTreeDef(names.structs, struct_name, FiTypeStruct("", [], [], 0));
			switch (type) {
				FiTypeName(__,typars): {
					typar_subst = foldi(struct.typars, makeTree(), \i, acc, tp ->
						switch (tp) {
							FiTypeParameter(nm): setTree(acc, nm, typars[i]);
							default: acc;
						}
					);
					FsCallPrim(e with es = mapi(e.es, \i, x ->
						fsMakeExpCastsExplicit(x, fiApplyTypeSubstitution(typar_subst, struct.args[i].type), names, true)
					));
				}
				default: {
					fail0("struct type must be FiTypeName, got: " + toString(type));
				}
			}
		}
		FcFieldPrim(name): {
			if (name == "structname") {
				def_case(false);
			} else {
				switch (fsExpType(e.es[0])) {
					FiTypeName(struct_name, typars): {
						switch (lookupTree(names.structs, struct_name)) {
							Some(struct): {
								switch (find(struct.args, \arg -> arg.name == name)) {
									Some(arg): {
										fsMakeCast(def_case(false), arg.type, type);
									}
									None(): fail0("field " + name + " of struct " + struct_name + " is not found");
								}
							}
							None(): def_case(false);
						}
					}
					default: def_case(false);
				}
			}
		}
		FcSetMutablePrim(name): FsCallPrim(e with es = [ // TODO - do it right
			fsMakeExpCastsExplicit(e.es[0], fsExpType(e.es[0]), names, false),
			fsMakeExpCastsExplicit(e.es[1], fsExpType(e.es[1]), names, true)
		]);
		FcCreateClosurePrim(structName, functionName): fail0("// TODO: FcCreateClosurePrim");
		FcQuote():   fail0("// TODO: FcQuote");
		FcUnquote(): fail0("// TODO: FcUnquote");
	}
}

fsStatSSA(s: FsStat, vars: Tree<string, int>) -> Pair<FsStat, Tree<string, int>> {
	switch(s) {
		FsLet(v, vtype, e): {
			if (v == "__") {
				Pair(
					FsLet(s with
						e = fsExpSSA(e, vars)
					),
					vars
				);
			} else {
				v_ind = lookupTreeDef(vars, v, 0);
				new_vars = setTree(vars, v, v_ind + 1);
				Pair(
					FsLet(s with
						name = fsSSAvar(v, new_vars),
						e = fsExpSSA(e, new_vars)
					),
					new_vars
				);
			}
		}
		FsIf(cond, s1, s2,__): {
			Pair(
				FsIf(s with
					cond = fsExpSSA(cond, vars),
					s1 = fsStatSSA(s1, vars).first,
					s2 = fsStatSSA(s2, vars).first
				), 
				vars
			);
		}
		FsSwitch(var, __, cases, type): {
			Pair(
				FsSwitch(s with
					x = FsVar(var with name = fsSSAvar(var.name, vars)),
					cases = map(cases, \c -> {
						new_vars = fold(c.args, vars, \acc, arg -> 
							if (arg == "__") acc else
							setTree(acc, arg, lookupTreeDef(vars, arg, 0) + 1)
						);
						FsCase(c with body = fsStatSSA(c.body, new_vars).first);
					})
				), 
				vars
			);
		}
		FsSeq(es,__): {
			p = fold(es, Pair([], vars), \acc, e -> {
				x = fsStatSSA(e, acc.second);
				Pair(concat(acc.first, [x.first]), x.second);
			});
			Pair(FsSeq(s with ss = p.first), p.second);
		}
		FsWrapExp(e): {
			Pair(FsWrapExp(fsExpSSA(e, vars)), vars);
		}
		FsRet(e): {
			Pair(FsRet(fsExpSSA(e, vars)), vars);
		}
		FsTailCall(__): {
			Pair(s, vars);
		}
		FsVarDecl(var): {
			if (var.name == "__") {
				Pair(s, vars);
			} else {
				v_ind = lookupTreeDef(vars, var.name, 0);
				new_vars = setTree(vars, var.name, v_ind + 1);
				Pair(
					FsVarDecl(FsVar(var with name = fsSSAvar(var.name, new_vars))),
					new_vars
				);
			}
		}
		FsAssign(var, e): {
			Pair(
				FsAssign(
					FsVar(var with name = fsSSAvar(var.name, vars)), 
					fsExpSSA(e, vars)
				),
				vars
			);
		}
	}
}

fsExpSSA(e: FsExp, vars: Tree<string, int>) -> FsExp {
	switch(e) {
		FsLambda(closure, args, body,__): {
			new_vars = fold(args, vars, \acc, arg ->
				if (arg.name == "__") acc else {
					arg_i = lookupTreeDef(acc, arg.name, 0);
					setTree(acc, arg.name, arg_i + 1);
				}
			);
			FsLambda(e with
				closure = map(closure, \v -> fsSSAvar(v, new_vars)),
				args = map(args, \arg -> {
					arg_i = lookupTreeDef(new_vars, arg.name, 0);
					FiFunArg(arg with 
						name = fsSSAvar(arg.name, new_vars)
					);
				}),
				body = fsStatSSA(body, new_vars).first
			);
		}
		FsCall(fn, args,__): {
			FsCall(e with
				f = fsExpSSA(fn, vars),
				args = map(args, \arg -> fsExpSSA(arg, vars))
			);
		}
		FsTernaryIf(cond, s1, s2,__): {
			FsTernaryIf(e with
				cond = fsExpSSA(cond, vars),
				s1 = fsExpSSA(s1, vars),
				s2 = fsExpSSA(s2, vars)
			);
		}
		FsCast(ex, __, __): {
			FsCast(e with e = fsExpSSA(ex, vars));
		}
		FsCallPrim(__, es,__): {
			FsCallPrim(e with es = map(es, \x -> fsExpSSA(x, vars)));
		}
		FsRequire(__, ex,__): {
			FsRequire(e with e = fsExpSSA(ex, vars));
		}
		FsUnsafe(__, ex,__): {
			FsUnsafe(e with fallback = fsExpSSA(ex, vars));
		}
		FsVar(name,__,__): {
			i = lookupTreeDef(vars, name, 0);
			FsVar(e with name = fsSSAvar(name, vars));
		}
		FiVoid(__):       e;
		FiDouble(__,__):  e;
		FiInt(__,__):     e;
		FiString(__,__):  e;
		FiBool(__,__):    e;
	}
}

fsSSAvar(v: string, vars: Tree<string, int>) -> string {
	i = lookupTreeDef(vars, v, 0);
	v + if (i <= 1) "" else "__ssa_" + i2s(i - 1);
}

fsInterpolateTyparsStat(s : FsStat, names: FiGlobalNames) -> FsStat {
	do_interpolate = \x -> fsInterpolateTyparsStat(x, names);
	switch(s) {
		FsLet(name, vtype, e1): {
			FsLet(s with e = fsInterpolateTyparsExp(e1, names));
		}
		FsIf(e1, s1, s2, __): {
			FsIf(s with
				cond = fsInterpolateTyparsExp(e1, names),
				s1 = do_interpolate(s1),
				s2 = do_interpolate(s2),
			);
		}
		FsSwitch(v, __, cases, __): {
			FsSwitch(s with
				cases = map(cases, \c -> FsCase(c with body = do_interpolate(c.body)))
			);
		}
		FsSeq(ss, __): {
			FsSeq(s with ss = map(ss, do_interpolate));
		}
		FsWrapExp(e): {
			FsWrapExp(fsInterpolateTyparsExp(e, names));
		}
		FsRet(e): {
			FsRet(fsInterpolateTyparsExp(e, names));
		}
		FsTailCall(__): {
			s;
		}
		FsVarDecl(var): {
			s;
		}
		FsAssign(var, e): {
			FsAssign(var, fsInterpolateTyparsExp(e, names));
		}
	}
}

fsInterpolateTyparsExp(e : FsExp, names: FiGlobalNames) -> FsExp {
	do_interpolate = \x -> fsInterpolateTyparsExp(x, names);
	switch(e) {
		FsLambda(closure, args, body, type): {
			FsLambda(e with body = fsInterpolateTyparsStat(body, names));
		}
		FsCall(fn, args, ret_type): {
			fn1 = fsInterpolateTyparsExp(fn, names);
			fn_type = fsExpType(fn1);
			args1 = mapi(args, \i, arg -> fsInterpolateTyparsExp(arg, names));
			switch (fn_type) {
				FiTypeFunction(fn_args, returnType): {
					// Match arguments 
					args_unified = mapi(args1, \i, arg -> fiUnifyTypes(fsExpType(arg), fn_args[i].type));
					ret_unified = fiUnifyTypes(returnType, ret_type);
					FsCall(e with 
						f = fsSetExpType(fn1, FiTypeFunction(
							mapi(fn_args, \i, arg -> FiFunArg(arg.name, args_unified[i].second)),
							ret_unified.second
						)), 
						args = mapi(args1, \i, arg -> fsSetExpType(arg, args_unified[i].first)),
						type = ret_unified.first
					);
				}
				default: {
					FsCall(e with f = fn1, args = args1);
				}
			}
		}
		FsCallPrim(__,__,type1): {
			fsInterpolateTyparsCallPrim(e, names);
		}
		FsRequire(__, ex,__): {
			FsRequire(e with e = do_interpolate(ex));
		}
		FsUnsafe(__, ex,__): {
			FsUnsafe(e with fallback = do_interpolate(ex));
		}
		FsCast(ex, from, to): {
			FsCast(e with e = do_interpolate(ex));
		}
		FsTernaryIf(cond, pos, neg, type1): {
			FsTernaryIf(e with
				cond = fsInterpolateTyparsExp(cond, names),
				s1 = fsInterpolateTyparsExp(pos, names),
				s2 = fsInterpolateTyparsExp(neg, names),
			);
		}
		default: e;
	}
}

fsInterpolateTyparsCallPrim(e : FsCallPrim, names: FiGlobalNames) -> FsExp {
	def_interpolate = \ -> FsCallPrim(e with es = map(e.es, \x -> fsInterpolateTyparsExp(x, names)));
	switch (e.op) {
		FcOrPrim():  def_interpolate();
		FcAndPrim(): def_interpolate();
		FcNotPrim(): def_interpolate();

		FcEqPrim():  def_interpolate();
		FcNePrim():  def_interpolate();
		FcLePrim():  def_interpolate();
		FcGePrim():  def_interpolate();
		FcLtPrim():  def_interpolate();
		FcGtPrim():  def_interpolate();

		FcPlusPrim():  def_interpolate();
		FcMinusPrim(): def_interpolate();
		FcMulPrim():   def_interpolate();
		FcDivPrim():   def_interpolate();
		FcModPrim():   def_interpolate();
		FcNegPrim():   def_interpolate();
		FcArrayPrim(): def_interpolate();
		FcIndexPrim(): def_interpolate();
		FcDerefPrim(): def_interpolate();
		FcAssignPrim(): def_interpolate();
		FcRefPrim(): def_interpolate();
		FcStructPrim(struct_name): {
			struct = lookupTreeDef(names.structs, struct_name, FiTypeStruct("", [], [], 0));
			type = fsExpType(e);
			switch (type) {
				FiTypeName(__,typars): {
					typar_subst = foldi(struct.typars, makeTree(), \i, acc, tp ->
						switch (tp) {
							FiTypeParameter(nm): setTree(acc, nm, typars[i]);
							default: acc;
						}
					);
					subst = foldi(struct.args, makeTree(), \i, sub, struct_arg -> 
						fiMatchTypars(fsExpType(e.es[i]), fiApplyTypeSubstitution(typar_subst, struct_arg.type), sub)
					);
					FsCallPrim(e with es = mapi(e.es, \i, x ->
						fsSetExpType(
							fsInterpolateTyparsExp(x, names), 
							fiApplyTypeSubstitution(subst, fsExpType(x))
						)
					));
				}
				default: {
					fail0("struct type must be FiTypeName, got: " + toString(type));
				}
			}
		}
		FcFieldPrim(name): def_interpolate();
		FcSetMutablePrim(name): def_interpolate();
		FcCreateClosurePrim(structName, functionName): def_interpolate();
		FcQuote():   def_interpolate();
		FcUnquote(): def_interpolate();
	}
}
