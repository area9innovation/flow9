import tools/flowc/statements/fs_helpers;
import tools/flowc/incremental/fi_helpers;
import sys/exception;

export {
	fsWrapCaseVarsWithCasts(e : FsStat, vars: [Pair<string, FiType>]) -> FsStat;
	fsMakeStatCastsExplicit(s : FsStat, type: FiType, names: FiGlobalNames) -> FsStat;
	fsMakeExpCastsExplicit(e : FsExp, type: FiType, names: FiGlobalNames, do: bool) -> FsExp;

	fsStatSSA(s: FsStat, vars: Tree<string, int>) -> Pair<FsStat, Tree<string, int>>;
	fsExpSSA(e: FsExp, vars: Tree<string, int>) -> FsExp;
}

fsWrapCaseVarsWithCasts(e : FsStat, vars: [Pair<string, FiType>]) -> FsStat {
	switch (e) {
		FsLet(v, type, ex): {
			switch (find(vars, \p -> p.first == v)) {
				Some(p): {
					ex_wrapped = FsCast(ex, fsExpType(ex), type);
					FsLet(e with e = ex_wrapped);
				}
				None(): e;
			}
		}
		FsSeq(ss, __): {
			FsSeq(e with ss = map(ss, \x -> fsWrapCaseVarsWithCasts(x, vars)));
		}
		default: e;
	}
}

fsMakeStatCastsExplicit(s : FsStat, type: FiType, names: FiGlobalNames) -> FsStat {
	do_cast = \x -> fsMakeStatCastsExplicit(x, type, names);
	switch(s) {
		FsLet(name, vtype, e1): {
			FsLet(s with e = fsMakeExpCastsExplicit(e1, vtype, names, true));
		}
		FsIf(e1, s1, s2, __): {
			FsIf(s with
				cond = fsMakeExpCastsExplicit(e1, FiTypeBool(), names, true),
				s1 = do_cast(s1),
				s2 = do_cast(s2),
			);
		}
		FsSwitch(v, cases, __): {
			FsSwitch(s with
				cases = map(cases, \c -> FsCase(c with body = do_cast(c.body)))
			);
		}
		FsSeq(ss, __): {
			FsSeq(s with ss = map(ss, do_cast));
		}
		FsWrap(e): {
			FsWrap(fsMakeExpCastsExplicit(e, fsExpType(e), names, false));
		}
		FsRet(e): {
			FsRet(fsMakeExpCastsExplicit(e, type, names, true));
		}
		FsVarDecl(var): {
			s;
		}
		FsAssign(var, e): {
			FsAssign(var, fsMakeExpCastsExplicit(e, var.type, names, true));
		}
	}
}

debug_explicit_casts = ref false;

fsMakeExpCastsExplicit(e : FsExp, type: FiType, names: FiGlobalNames, do: bool) -> FsExp {
	no_cast = \x -> fsMakeExpCastsExplicit(x, FiTypeVoid(), names, false);
	e1 = switch(e) {
		FsLambda(closure, args, body, type1): {
			switch (type) {
				FiTypeFunction(__,returnType): {
					FsLambda(e with body = fsMakeStatCastsExplicit(body, returnType, names));
				}
				FiTypeParameter(__): {
					FsLambda(e with body = fsMakeStatCastsExplicit(body, type1.returnType, names));
				}
				default: {
					throw("non func type: " + toString(type) + ", expected: " + toString(type) + "\n" + toStringFormatted(e));
				}
			}
		}
		FsCall(fn, args,__): {
			debug = ref false;
			fn_type = cast(fsExpType(fn): FiType -> FiTypeFunction);
			fn_args = switch (fn) {
				FsVar(name, __, local): {
					/*if (name == "fold") {
						debug := true;
						debug_explicit_casts := true;
					}*/
					if (local) fn_type.args else {
						decl = lookupTreeDef(names.toplevel, name, FiGlobalVar("", FiVoid(0), FiTypeVoid(), 0, 0));
						switch (decl) {
							FiFunctionDec(__,__,tp,__,__): {
								//tp.args;
								fn_type.args;
							}
							FiNativeDec(__,__,tp,__,__,__,__): {
								switch (tp) {
									FiTypeFunction(fn_args,__): {
										//fn_args;
										fn_type.args;
									}
									default: fn_type.args;
								}
							}
							default: fn_type.args;
						}
					}
				}
				default: fn_type.args;
			}
			/*if (^debug) {
				println(
					//"fn_args:\n" + toStringFormatted(fn_args) + "\n" +
					"fn_args(1):\n" + toStringFormatted(map(args, \arg -> fsExpType(arg))) + "\n" +
					"fn_type.args:\n" + toStringFormatted(fn_type.args) + "\n"
				);
			}*/
			ret = FsCall(e with
				f = fsMakeExpCastsExplicit(fn, fn_type, names, false),
				args = mapi(args, \i, arg ->
					fsMakeExpCastsExplicit(arg, fn_type.args[i].type, names, true)
				)
			);
			/*if (^debug_explicit_casts) {
				println("______________________________________");
			}*/
			debug_explicit_casts := false;
			ret;
		}
		FsCallPrim(__,__,type1): {
			fsMakeCallPrimCastsExplicit(e, type1, names);
		}
		FsRequire(__, ex,__): {
			FsRequire(e with e = no_cast(ex));
		}
		FsUnsafe(__, ex,__): {
			FsUnsafe(e with fallback = no_cast(ex));
		}
		FsCast(ex, from, to): {
			FsCast(e with e = no_cast(ex));
		}
		FsTernary(cond, pos, neg, type1): {
			FsTernary(e with
				cond = fsMakeExpCastsExplicit(cond, FiTypeBool(), names, false),
				s1 = fsMakeExpCastsExplicit(pos, type1, names, true),
				s2 = fsMakeExpCastsExplicit(neg, type1, names, true),
			);
		}
		default: e;
	}
	type1 = fsExpType(e1);
	if (!do || fiEqualTypes(type1, type) || type == FiTypeVoid()) {
		/*if (^debug_explicit_casts) {
			println("no explicit cast(1) from:\n" + toStringFormatted(type1) + "\nto\n" + toStringFormatted(type) + "\n\n" +
				"do: " + b2s(do) + ", fiEqualTypes(type1, type): " + b2s(fiEqualTypes(type1, type))
			);
		}*/
		e1 
	} else {
		switch (type) {
			FiTypeParameter(__): e1;
			default: {
				FsCast(e1, type1, type);
			}
		}
	}
}

fsMakeCallPrimCastsExplicit(e : FsCallPrim, type: FiType, names: FiGlobalNames) -> FsExp {
	def_case = \do -> FsCallPrim(e with es = map(e.es, \x -> fsMakeExpCastsExplicit(x, type, names, do)));
	typed_case = \tp, do -> FsCallPrim(e with es = map(e.es, \x -> fsMakeExpCastsExplicit(x, tp, names, do)));
	dearray_type = \tp -> switch (tp) {
		FiTypeArray(t): t;
		default: FiTypeVoid();
	}
	deref_type = \tp -> switch (tp) {
		FiTypeRef(t): t;
		default: FiTypeVoid();
	}
	switch (e.op) {
		FcOrPrim():  def_case(false);
		FcAndPrim(): def_case(false);
		FcNotPrim(): def_case(false);

		FcEqPrim():  typed_case(fsExpType(e.es[0]), true);
		FcNePrim():  typed_case(fsExpType(e.es[0]), true);
		FcLePrim():  typed_case(fsExpType(e.es[0]), true);
		FcGePrim():  typed_case(fsExpType(e.es[0]), true);
		FcLtPrim():  typed_case(fsExpType(e.es[0]), true);
		FcGtPrim():  typed_case(fsExpType(e.es[0]), true);

		FcPlusPrim():  def_case(true);
		FcMinusPrim(): def_case(true);
		FcMulPrim():   def_case(true);
		FcDivPrim():   def_case(true);
		FcModPrim():   def_case(true);
		FcNegPrim():   def_case(true);
		FcArrayPrim(): typed_case(dearray_type(type), true);
		FcIndexPrim(): FsCallPrim(e with es = [
			fsMakeExpCastsExplicit(e.es[0], FiTypeArray(type), names, true),
			fsMakeExpCastsExplicit(e.es[1], FiTypeInt(), names, true)
		]);
		FcDerefPrim(): typed_case(FiTypeRef(type), true);
		FcAssignPrim(): {
			var_type = fsExpType(e.es[0]);
			exp_type = fsExpType(e.es[1]);
			type1 = switch (var_type) {
				FiTypeRef(t): t;
				FiTypeParameter(__): exp_type;
				FiTypeFlow(): FiTypeFlow();
				default: throw("illegal assign type: " + prettyFiType(dummyPretty, var_type, makeSet()));
			}
			FsCallPrim(e with es = [
				fsMakeExpCastsExplicit(e.es[0], var_type, names, false),
				fsMakeExpCastsExplicit(e.es[1], type1, names, true)
			]);
		}
		FcRefPrim(): typed_case(deref_type(type), true);
		FcStructPrim(struct_name): {
			struct = lookupTreeDef(names.structs, struct_name, FiTypeStruct("", [], [], 0));
			FsCallPrim(e with es = mapi(e.es, \i, x -> fsMakeExpCastsExplicit(x, struct.args[i].type, names, true)));
		}
		FcFieldPrim(name): {
			if (name == "structname") {
				def_case(false);
			} else {
				switch (fsExpType(e.es[0])) {
					FiTypeName(struct_name, typars): {
						switch (lookupTree(names.structs, struct_name)) {
							Some(struct): {
								switch (find(struct.args, \arg -> arg.name == name)) {
									Some(arg): {
										if (fiEqualTypes(type, arg.type)) def_case(false) else 
										FsCast(def_case(false), arg.type, type);
									}
									None(): fail0("field " + name + " of struct " + struct_name + " is not found");
								}
							}
							None(): def_case(false);
						}
					}
					default: def_case(false);
				}
			}
		}
		FcSetMutablePrim(name): FsCallPrim(e with es = [ // TODO - do it right
			fsMakeExpCastsExplicit(e.es[0], fsExpType(e.es[0]), names, false),
			fsMakeExpCastsExplicit(e.es[1], fsExpType(e.es[1]), names, true)
		]);
		FcCreateClosurePrim(structName, functionName): fail0("// TODO: FcCreateClosurePrim");
		FcQuote():   fail0("// TODO: FcQuote");
		FcUnquote(): fail0("// TODO: FcUnquote");
	}
}

fsStatSSA(s: FsStat, vars: Tree<string, int>) -> Pair<FsStat, Tree<string, int>> {
	switch(s) {
		FsLet(v, vtype, e): {
			if (v == "__") {
				Pair(
					FsLet(s with
						e = fsExpSSA(e, vars)
					),
					vars
				);
			} else {
				v_ind = lookupTreeDef(vars, v, 0);
				new_vars = setTree(vars, v, v_ind + 1);
				Pair(
					FsLet(s with
						name = fsSSAvar(v, new_vars),
						e = fsExpSSA(e, new_vars)
					),
					new_vars
				);
			}
		}
		FsIf(cond, s1, s2,__): {
			Pair(
				FsIf(s with
					cond = fsExpSSA(cond, vars),
					s1 = fsStatSSA(s1, vars).first,
					s2 = fsStatSSA(s2, vars).first
				), 
				vars
			);
		}
		FsSwitch(var, cases, type): {
			Pair(
				FsSwitch(s with
					x = FsVar(var with name = fsSSAvar(var.name, vars)),
					cases = map(cases, \c -> {
						new_vars = fold(c.args, vars, \acc, arg -> 
							if (arg == "__") acc else
							setTree(acc, arg, lookupTreeDef(vars, arg, 0) + 1)
						);
						FsCase(c with body = fsStatSSA(c.body, new_vars).first);
					})
				), 
				vars
			);
		}
		FsSeq(es,__): {
			p = fold(es, Pair([], vars), \acc, e -> {
				x = fsStatSSA(e, acc.second);
				Pair(concat(acc.first, [x.first]), x.second);
			});
			Pair(FsSeq(s with ss = p.first), p.second);
		}
		FsWrap(e): {
			Pair(FsWrap(fsExpSSA(e, vars)), vars);
		}
		FsRet(e): {
			Pair(FsRet(fsExpSSA(e, vars)), vars);
		}
		FsVarDecl(var): {
			if (var.name == "__") {
				Pair(s, vars);
			} else {
				v_ind = lookupTreeDef(vars, var.name, 0);
				new_vars = setTree(vars, var.name, v_ind + 1);
				Pair(
					FsVarDecl(FsVar(var with name = fsSSAvar(var.name, new_vars))),
					new_vars
				);
			}
		}
		FsAssign(var, e): {
			Pair(
				FsAssign(
					FsVar(var with name = fsSSAvar(var.name, vars)), 
					fsExpSSA(e, vars)
				),
				vars
			);
		}
	}
}

fsExpSSA(e: FsExp, vars: Tree<string, int>) -> FsExp {
	switch(e) {
		FsLambda(closure, args, body,__): {
			new_vars = fold(args, vars, \acc, arg ->
				if (arg.name == "__") acc else {
					arg_i = lookupTreeDef(acc, arg.name, 0);
					setTree(acc, arg.name, arg_i + 1);
				}
			);
			FsLambda(e with
				closure = map(closure, \v -> fsSSAvar(v, new_vars)),
				args = map(args, \arg -> {
					arg_i = lookupTreeDef(new_vars, arg.name, 0);
					FiFunArg(arg with 
						name = fsSSAvar(arg.name, new_vars);
					);
				}),
				body = fsStatSSA(body, new_vars).first
			);
		}
		FsCall(fn, args,__): {
			FsCall(e with
				f = fsExpSSA(fn, vars),
				args = map(args, \arg -> fsExpSSA(arg, vars))
			);
		}
		FsTernary(cond, s1, s2,__): {
			FsTernary(e with
				cond = fsExpSSA(cond, vars),
				s1 = fsExpSSA(s1, vars),
				s2 = fsExpSSA(s2, vars)
			);
		}
		FsCast(ex, __, __): {
			FsCast(e with e = fsExpSSA(ex, vars));
		}
		FsCallPrim(__, es,__): {
			FsCallPrim(e with es = map(es, \x -> fsExpSSA(x, vars)));
		}
		FsRequire(__, ex,__): {
			FsRequire(e with e = fsExpSSA(ex, vars));
		}
		FsUnsafe(__, ex,__): {
			FsUnsafe(e with fallback = fsExpSSA(ex, vars));
		}
		FsVar(name,__,__): {
			i = lookupTreeDef(vars, name, 0);
			FsVar(e with name = fsSSAvar(name, vars));
		}
		FiVoid(__):       e;
		FiDouble(__,__):  e;
		FiInt(__,__):     e;
		FiString(__,__):  e;
		FiBool(__,__):    e;
	}
}

fsSSAvar(v: string, vars: Tree<string, int>) -> string {
	i = lookupTreeDef(vars, v, 0);
	v + if (i <= 1) "" else "__ssa_" + i2s(i - 1);
}