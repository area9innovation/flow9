import tools/flowc/incremental/fiexp;
import tools/flowc/memory/fmexp;

export {
	// General control-flow statements
	FsStat ::= FsIf, FsSwitch, FsSeq, FsAtomic, FsLet;

		FsIf(cond: FsExp, s1: FsStat, s2: FsStat, type: FiType, start: int);
		FsSwitch(x: FsVar, switchType: FiType, cases: [FsCase], type: FiType, start: int);
			FsCase(struct: string, args: [FsVar], body: FsStat, start: int);
		FsSeq(ss: [FsStat], type: FiType, start: int);
		FsLet(var: FsVar, e: FsExp, s: FsStat, type: FiType, start: int);

	// Statements, which doesn't contain other statements
	FsAtomic ::= FsWrapExp, FsRet, FsTailCall, FsVarDecl, FsAssign, FsMemory;

		FsWrapExp(e: FsExp, start: int);
		FsRet(e: FsExp, start: int);
		FsTailCall(start: int);
		FsVarDecl(var: FsVar, start: int);
		FsAssign(to: FsExp, what: FsExp, start: int);
		FsMemory(op: FmMemoryOp, e: FsExp, start: int);

	// Expressions (returns value)
	FsExp ::= FsLambda, FsCall, FsCallPrim, FsVar, FiConst;
		FsLambda(toplevel: bool, closure: [FsVar], args: [FiFunArg], body: FsStat, type : FiTypeFunction, start: int);
		FsCall(f: FsExp, args: [FsExp], type : FiType, start: int);
		FsCallPrim(op: FmPrim, es: [FsExp], type: FiType, start: int);
		FsVar(name: string, traits: FsVarTraits, type: FiType, start: int);
			FsVarTraits(
				kind: FsVarKind,
				firstUse: bool,  // first use
				lastUse: bool,   // last use
				returnVar: bool, // a variable, which is returned
			);
			FsVarKind ::= FsVarLocal, FsVarGlobal, FsVarArg, FsVarClosure;
				FsVarLocal(); FsVarGlobal(); FsVarArg(); FsVarClosure();
}
