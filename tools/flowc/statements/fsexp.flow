import tools/flowc/incremental/fiexp;

export {
	// General control-flow statements
	FsStat ::= FsIf, FsSwitch, FsSeq, FsAtomic;

		FsIf(cond: FsExp, s1: FsStat, s2: FsStat, type: FiType);
		FsSwitch(x: FsVar, switchType: FiType, cases: [FsCase], type: FiType);
			FsCase(struct: string, args: [FsVar], body: FsStat);
		FsSeq(ss: [FsStat], type: FiType);

	// Statements, which doesn't contain other statements
	FsAtomic ::= FsLet, FsWrapExp, FsRet, FsTailCall, FsVarDecl, FsAssign, FsMemory;

		FsLet(var: FsVar, e: FsExp);
		FsWrapExp(e: FsExp);
		FsRet(e: FsExp);
		FsTailCall();
		FsVarDecl(var: FsVar);
		FsAssign(var: FsVar, e: FsExp);
		FsMemory(op: FsMemoryOp, e: FsExp);

		// Memory bookkeeping operations
		// Uses Preceus algorithm: https://www.microsoft.com/en-us/research/uploads/prod/2020/11/perceus-tr-v1.pdf
		FsMemoryOp ::= FmDup, FmDrop, FmReuse, FmDispose, FmIsUnique, FmDecRef, FmNull;
			FmDup(); FmDrop(); FmReuse(); FmDispose(); FmIsUnique(); FmDecRef(); FmNull();

	// Expressions (returns value)
	FsExp ::= FsLambda, FsCall, FsCallPrim, FsTernaryIf, FsCast, FsRequire, FsUnsafe, FsVar, FiConst;
		FsLambda(closure: [FsVar], args: [FiFunArg], body: FsStat, type : FiTypeFunction);
		FsCall(f: FsExp, args: [FsExp], type : FiType);
		FsCallPrim(op: FsPrim, es: [FsExp], type: FiType);
		FsRequire(flowfile : string, e : FsExp, type : FiType);
		FsUnsafe(name : string, fallback : FsExp, type : FiType);
		FsCast(e: FsExp, from : FiType, to : FiType);
		FsTernaryIf(cond: FsExp, s1: FsExp, s2: FsExp, type: FiType);
		FsVar(name: string, type: FiType, kind: FsVarKind);
			FsVarKind ::= FsVarGlobal, FsVarLoc, FsVarArg, FsVarRet, FsVarReuse;
			FsVarGlobal(); // A global variable (maybe of a functional type)
			FsVarLoc();    // A local variable defined by a let statement, i.e. x = f(y, z);
			FsVarArg();    // A local variable which is an argument of a function/lambda, i.e. fn(x: T1) { ... g(x) ... }
			FsVarRet();    // Return variable - needs special treatment
			FsVarReuse();  // a variable for reusing structs

	FsPrim ::= FcPrim, FsReuseStructPrim;
		// Reuse previously allocated struct, don't allocate a new one
		FsReuseStructPrim(name: string, reuse: FsVar);
}
