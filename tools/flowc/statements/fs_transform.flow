import ds/array;
import tools/flowc/statements/fs_helpers;
import tools/flowc/manipulation/common;

export {
	//fsStatMap(s: FsStat, trans_s: (FsStat) -> FsStat, trans_e: (FsExp) -> FsExp) -> FsStat;
	//fsExpMap(e: FsExp, trans_s: (FsStat) -> FsStat, trans_e: (FsExp) -> FsExp) -> FsExp;

	// A local description of scope environment in expression
	FsTraverseEnv(
		// Pair: the AST parent node and the index of a child, containing the current node
		parents: List<Pair<FsAll, int>>,
		locals: Tree<string, FsVar>,
		args: Tree<string, FsVar>,
		lets: Tree<string, FsVar>
	);

	fsMap(s: FsAll, fn: (FsAll) -> FsAll, args_first: bool) -> FsAll;
	fsMap2(s: FsAll, fn: ([?], FsAll) -> ?) -> ?;

	fsFold(s: FsAll, v: ?, fn: (?, FsAll) -> ?, args_first: bool) ->?;
	fsFoldr(s: FsAll, v: ?, fn: (?, FsAll) -> ?, args_first: bool) ->?;

	//fsStatIter(s: FsStat, trans_s: (FsStat) -> void, trans_e: (FsExp) -> void) -> void;
	//fsExpIter(e: FsExp, trans_s: (FsStat) -> void, trans_e: (FsExp) -> void) -> void;
}
/*
fsStatMap(s: FsStat, trans_s: (FsStat) -> FsStat, trans_e: (FsExp) -> FsExp) -> FsStat {
	trans_s(switch (s) {
		FsIf(cond, s1, s2,__): {
			FsIf(s with
				cond = fsExpMap(cond, trans_s, trans_e),
				s1 = fsStatMap(s1, trans_s, trans_e),
				s2 = fsStatMap(s2, trans_s, trans_e)
			);
		}
		FsSwitch(x, sw_type, cases,__): {
			FsSwitch(s with 
				cases = map(cases, \c -> FsCase(c with body = fsStatMap(c.body, trans_s, trans_e)))
			);
		}
		FsSeq(ss,__): {
			FsSeq(s with 
				ss = map(ss, \x -> fsStatMap(x, trans_s, trans_e))
			);
		}
		FsLet(__, e1, s1,__): {
			FsLet(s with 
				e = fsExpMap(e1, trans_s, trans_e),
				s = fsStatMap(s1, trans_s, trans_e),
			);
		}
		FsLet1(__, e1,__): {
			FsLet1(s with 
				e = fsExpMap(e1, trans_s, trans_e)
			);
		}
		FsWrapExp(e,__): {
			FsWrapExp(s with e = fsExpMap(e, trans_s, trans_e));
		}
		FsRet(e,__): {
			FsRet(s with e = fsExpMap(e, trans_s, trans_e));
		}
		FsVarDecl(var,__): {
			s;
		}
		FsVarDef(v, e,__): {
			FsVarDef(s with e = fsExpMap(e, trans_s, trans_e));
		}
		FsAssign(to, what,__): {
			FsAssign(s with 
				to = fsExpMap(to, trans_s, trans_e),
				what = fsExpMap(what, trans_s, trans_e)
			);
		}
		FsModRc(__, e,__): {
			FsModRc(s with e = fsExpMap(e, trans_s, trans_e));
		}
		FsDecRc(e,__): {
			FsDecRc(s with e = fsExpMap(e, trans_s, trans_e));
		}
	});
}

fsExpMap(ex: FsExp, trans_s: (FsStat) -> FsStat, trans_e: (FsExp) -> FsExp) -> FsExp {
	trans_e(switch(ex) {
		FsLambda(__,__, body, __,__): {
			FsLambda(ex with body = fsStatMap(body, trans_s, trans_e));
		}
		FsCall(fn, args, __,__): {
			FsCall(ex with 
				f = fsExpMap(fn, trans_s, trans_e),
				args = map(args, \x -> fsExpMap(x, trans_s, trans_e))
			);
		}
		FsCallPrim(op, es, __,__): {
			FsCallPrim(ex with es = map(es, \x -> fsExpMap(x, trans_s, trans_e)));
		}
		FsTailCall(args, vals,__,__): {
			FsTailCall(ex with
				//args = map(args, \x -> cast(fsExpMap(x, trans_s, trans_e): FsExp -> FsVar)),
				vals = map(vals, \x -> fsExpMap(x, trans_s, trans_e))
			);
		}
		FsCast(e, from, type,__): {
			FsCast(ex with e = fsExpMap(e, trans_s, trans_e));
		}
		FsIncRc(e,__,__): {
			FsIncRc(ex with e = fsExpMap(e, trans_s, trans_e));
		}
		FsVar(name,__,__,__): ex;
		FsConst(__,__): ex;
	});
}
*/
fsMap(a: FsAll, f: (FsAll) -> FsAll, args_first: bool) -> FsAll {
	map_var = \x -> cast(fsMap(x, f, args_first): FsAll -> FsVar);
	map_exp = \x -> cast(fsMap(x, f, args_first): FsAll -> FsExp);
	map_stat = \x -> cast(fsMap(x, f, args_first): FsAll -> FsStat);
	do_args = \s -> switch (s) {
		FsIf(cond, s1, s2,__):
			FsIf(s with cond = map_exp(cond), s1 = map_stat(s1), s2 = map_stat(s2));
		FsSwitch(x, sw_type, cases,__):
			FsSwitch(s with x = map_var(x), cases = map(cases, \c -> FsCase(c with body = map_stat(c.body))));
		FsSeq(ss,__):
			FsSeq(s with ss = map(ss, \x -> map_stat(x)));
		FsLet(v, e1, s1,__): 
			FsLet(s with var = map_var(v), e = map_exp(e1), s = map_stat(s1));
		FsLet1(v, e1,__):
			FsLet1(s with var = map_var(v), e = map_exp(e1));
		FsWrapExp(e,__):
			FsWrapExp(s with e = map_exp(e));
		FsRet(e,__):
			FsRet(s with e = map_exp(e));
		//FsVarDecl(var,__):
		//	FsVarDecl(s with var = map_var(var));
		FsVarDef(v, e,__):
			FsVarDef(s with var = map_var(v), e = map_exp(e));
		FsAssign(to, what,__):
			FsAssign(s with to = map_exp(to), what = map_exp(what));
		FsModRc(__, e,__):
			FsModRc(s with e = map_exp(e));
		FsDecRc(e,__):
			FsDecRc(s with e = map_exp(e));
		FsIncRc(e,__,__):
			FsIncRc(s with e = map_exp(e));
		FsLambda(closure, args, body, __,__):
			FsLambda(s with closure = map(closure, map_var), args = map(args, map_var), body = map_stat(body));
		FsCall(fn, args, __,__):
			FsCall(s with f = map_exp(fn), args = map(args, \x -> map_exp(x)));
		FsCallPrim(__, es, __,__):
			FsCallPrim(s with es = map(es, \x -> map_exp(x)));
		FsTailCall(args, vals,__,__):
			FsTailCall(s with 
				args = map(args, \x -> map_var(x)),
				vals = map(vals, \x -> map_exp(x))
			);
		FsCast(e, from, type,__):
			FsCast(s with e = map_exp(e));
		FsVar(name,__,__,__): s;
		FsConst(__,__): s;
	}
	if (args_first) f(do_args(a)) else do_args(f(a));
}

fsMap2(a: FsAll, f: ([?], FsAll) -> ?) -> ? {
	get_args = \s -> switch (s) {
		FsIf(cond, s1, s2,__):   [cond, s1, s2];
		FsSwitch(x,__, cs,__):   concat([x], map(cs, \c -> c.body));
		FsSeq(ss,__):            ss;
		FsLet(v, e1, s1,__):     [v, e1, s1];
		FsLet1(v, e1,__):        [v, e1];
		FsWrapExp(e1,__):        [e1];
		FsRet(e1,__):            [e1];
		FsVarDef(v, e1,__):      [v, e1];
		FsAssign(to, what,__):   [to, what];
		FsModRc(__, e1,__):      [e1];
		FsDecRc(e1,__):          [e1];
		FsIncRc(e1,__,__):       [e1];
		FsLambda(cl,as,e,__,__): concat3(cl, as, [e]);
		FsCall(fn, args, __,__): concat([fn], args);
		FsCallPrim(__,es,__,__): es;
		FsTailCall(as,vs,__,__): concat(as, vs);
		FsCast(e1,__,__,__):     [e1];
		//FsVarDecl(var,__):       [var];
		FsVar(__,__,__,__):      [];
		FsConst(__,__):          [];
	}
	f(map(get_args(a), \x -> fsMap2(x, f)), a);
}

fsFold(s: FsAll, v0: ?, f: (?, FsAll) -> ?, args_first: bool) -> ? {
	do_fold = \w, xs -> fold(xs, w, \acc, x -> fsFold(x, acc, f, args_first));
	do_args = \v -> switch (s) {
		FsIf(cond, s1, s2,__):   do_fold(v, [cond, s1, s2]);
		FsSwitch(x,__, cs,__):   do_fold(v, concat([x], map(cs, \c -> c.body)));
		FsSeq(ss,__):            do_fold(v, ss);
		FsLet(w, e1, s1,__):     do_fold(v, [w, e1, s1]);
		FsLet1(w, e1,__):        do_fold(v, [w, e1]);
		FsWrapExp(e1,__):        fsFold(e1, v, f, args_first);
		FsRet(e1,__):            fsFold(e1, v, f, args_first);
		FsVarDef(w, e1,__):      do_fold(v, [w, e1]);
		FsAssign(to, what,__):   do_fold(v, [to, what]);
		FsModRc(__, e1,__):      fsFold(e1, v, f, args_first);
		FsIncRc(e1,__,__):       fsFold(e1, v, f, args_first);
		FsDecRc(e1,__):          fsFold(e1, v, f, args_first);
		FsLambda(cl,as,e,__,__): do_fold(v, concat3(cl, as, [e]));
		FsCall(fn, args, __,__): do_fold(v, concat([fn], args));
		FsCallPrim(__,es,__,__): do_fold(v, es);
		FsTailCall(as,vs,__,__): do_fold(v, concat(as, vs));
		FsCast(e1,__,__,__):     fsFold(e1, v, f, args_first);
		//FsVarDecl(w,__):         fsFold(w, v, f, args_first);
		FsVar(__,__,__,__):      v;
		FsConst(__,__):          v;
	}
	if (args_first) f(do_args(v0), s) else do_args(f(v0, s));
}

fsFoldr(s: FsAll, v0: ?, f: (?, FsAll) -> ?, args_first: bool) -> ? {
	do_foldr = \w, xs -> foldr(xs, w, \acc, x -> fsFoldr(x, acc, f, args_first));
	do_args = \v -> switch (s) {
		FsIf(cond, s1, s2,__):   do_foldr(v, [cond, s1, s2]);
		FsSwitch(x,__, cs,__):   do_foldr(v, concat([x], map(cs, \c -> c.body)));
		FsSeq(ss,__):            do_foldr(v, ss);
		FsLet(w, e1, s1,__):     do_foldr(v, [w, e1, s1]);
		FsLet1(w, e1,__):        do_foldr(v, [w, e1]);
		FsWrapExp(e1,__):        fsFoldr(e1, v, f, args_first);
		FsRet(e1,__):            fsFoldr(e1, v, f, args_first);
		FsVarDef(w, e1,__):      do_foldr(v, [w, e1]);
		FsAssign(to, what,__):   do_foldr(v, [to, what]);
		FsModRc(__, e1,__):      fsFoldr(e1, v, f, args_first);
		FsIncRc(e1,__,__):       fsFoldr(e1, v, f, args_first);
		FsDecRc(e1,__):          fsFoldr(e1, v, f, args_first);
		FsLambda(cl,as,e,__,__): do_foldr(v, concat3(cl, as, [e]));
		FsCall(fn, args, __,__): do_foldr(v, concat([fn], args));
		FsCallPrim(__,es,__,__): do_foldr(v, es);
		FsTailCall(as,vs,__,__): do_foldr(v, concat(as, vs));
		FsCast(e1,__,__,__):     fsFoldr(e1, v, f, args_first);
		//FsVarDecl(w,__):         fsFoldr(w, v, f, args_first);
		FsVar(__,__,__,__):      v;
		FsConst(__,__):          v;
	}
	if (args_first) do_args(f(v0, s)) else f(do_args(v0), s);
}
/*
fsStatIter(s: FsStat, trans_s: (FsStat) -> void, trans_e: (FsExp) -> void) -> void {
	switch (s) {
		FsIf(cond, s1, s2,__): {
			fsExpIter(cond, trans_s, trans_e);
			fsStatIter(s1, trans_s, trans_e);
			fsStatIter(s2, trans_s, trans_e);
		}
		FsSwitch(x, sw_type, cases,__): {
			fsExpIter(x, trans_s, trans_e);
			iter(cases, \c -> fsStatIter(c.body, trans_s, trans_e));
		}
		FsSeq(ss,__): { 
			iter(ss, \x -> fsStatIter(x, trans_s, trans_e));
		}
		FsLet(__, def, body,__): { 
			fsExpIter(def, trans_s, trans_e);
			fsStatIter(body, trans_s, trans_e);
		}
		FsLet1(__, def,__): { 
			fsExpIter(def, trans_s, trans_e);
		}
		FsWrapExp(e,__): {
			fsExpIter(e, trans_s, trans_e);
		}
		FsRet(e,__): {
			fsExpIter(e, trans_s, trans_e);
		}
		FsVarDecl(var,__): { 
			fsExpIter(var, trans_s, trans_e);
		}
		FsVarDef(v, e,__): {
			fsExpIter(v, trans_s, trans_e);
			fsExpIter(e, trans_s, trans_e);
		}
		FsAssign(to, what,__): {
			fsExpIter(to, trans_s, trans_e);
			fsExpIter(what, trans_s, trans_e);
		}
		FsModRc(__, e,__): {
			fsExpIter(e, trans_s, trans_e);
		}
		FsDecRc(e,__): {
			fsExpIter(e, trans_s, trans_e);
		}
	}
	trans_s(s);
}

fsExpIter(ex: FsExp, trans_s: (FsStat) -> void, trans_e: (FsExp) -> void) -> void {
	switch(ex) {
		FsLambda(__,__, body, __,__): {
			fsStatIter(body, trans_s, trans_e);
		}
		FsCall(fn, args, __,__): {
			fsExpIter(fn, trans_s, trans_e);
			iter(args, \x -> fsExpIter(x, trans_s, trans_e));
		}
		FsCallPrim(op, es, __,__): {
			iter(es, \x -> fsExpIter(x, trans_s, trans_e));
		}
		FsTailCall(args, vals,__,__): { 
			iter(args, \arg -> fsExpIter(arg, trans_s, trans_e));
			iter(vals, \val -> fsExpIter(val, trans_s, trans_e));
		}
		FsCast(e,__,__,__): {
			fsExpIter(e, trans_s, trans_e);
		}
		FsIncRc(e,__,__): {
			fsExpIter(e, trans_s, trans_e);
		}
		FsVar(name,__,__,__): { }
		FsConst(__,__): { }
	};
	trans_e(ex);
}
*/

/*
fsFoldMap(e: FsAll, acc: ?, fn: (FsAll, FsTraverseEnv, ?) -> Pair<FsAll, ?>, order: AstTraverseOrder) -> Pair<FsAll, ?> {
	fsDoFoldMap(e, 
		FsTraverseEnv(makeList(), makeTree(), makeTree(), makeTree()),
		acc, fn, order
	);
}

fsDoFoldMap(e: FsAll, env: FsTraverseEnv, acc: ?, fn: (FsAll, FsTraverseEnv, ?) -> Pair<FsAll, ?>, order: AstTraverseOrder) -> Pair<FsAll, ?> {
	if (order.argsFirst) {
		env1 = FsTraverseEnv(env with parents = Cons(e, env.parents));
		p = fsDoFoldMapArgs(e, env1, acc, fn, order);
		fn(p.first, env, p.second);
	} else {
		p = fn(e, env, acc);
		env1 = FsTraverseEnv(env with parents = Cons(p.first, env.parents));
		fsDoFoldMapArgs(p.first, env1, p.second, fn, order);
	}
}

fsDoFoldMapArgs(
	e: FsAll, env: FsTraverseEnv, acc: ?, 
	fn: (FsAll, FsTraverseEnv, ?) -> Pair<FsAll, ?>,
	order: AstTraverseOrder
) -> ? {
	switch (s) {
		FsIf(cond, s1, s2): {
			if (order.direct) {
				p_cond = fsDoFoldMap(cond, env, acc, fn, order);
				p_s1 = fsDoFoldMap(p_cond.first, env, p_cond.second, fn, order);
				p_s2 = fsDoFoldMap(p_s1.first, env, p_s1.second, fn, order);
				Pair(FsIf(p_cond.first, p_s1.first, p_s2.first), p_s2.second);
			} else {
				p_s2 = fsDoFoldMap(p_s1.first, env, p_s1.second, fn, order);
				p_s1 = fsDoFoldMap(p_cond.first, env, p_cond.second, fn, order);
				p_cond = fsDoFoldMap(cond, env, acc, fn, order);
				Pair(FsIf(p_cond.first, p_s1.first, p_s2.first), p_s2.second);
			}
		}
		FsSwitch(x, sw_type, cases): {
			fsDoFoldMap(x, trans_s, trans_e);
			iter(cases, \c -> fsDoFoldMap(c.body, trans_s, trans_e));
		}
		FsSeq(ss): { 
			iter(ss, \x -> fsDoFoldMap(x, trans_s, trans_e));
		}
		FsLet(v, e): {
			fsDoFoldMap(v, trans_s, trans_e);
			fsDoFoldMap(e, trans_s, trans_e);
		}
		FsWrapExp(e): {
			fsDoFoldMap(e, trans_s, trans_e);
		}
		FsRet(e): {
			fsDoFoldMap(e, trans_s, trans_e);
		}
		FsTailCall(): { }
		FsVarDecl(var): { 
			fsDoFoldMap(var, trans_s, trans_e);
		}
		FsAssign(to, what): {
			fsDoFoldMap(to, trans_s, trans_e);
			fsDoFoldMap(what, trans_s, trans_e);
		}
		FsMemory(op, e): {
			fsDoFoldMap(e, trans_s, trans_e);
		}
		FsLambda(__,__,__, body, __): {
			fsDoFoldMap(body, trans_s, trans_e);
		}
		FsCall(fn, args, __): {
			fsDoFoldMap(fn, trans_s, trans_e);
			iter(args, \x -> fsDoFoldMap(x, trans_s, trans_e));
		}
		FsCallPrim(op, es, __): {
			iter(es, \x -> fsDoFoldMap(x, trans_s, trans_e));
		}
		FsCast(e,__,__): {
			fsDoFoldMap(e, trans_s, trans_e);
		}
		FsVar(name,__,__): { }
		FiConst(): { }
	}
}
*/
/*
fsStatFoldMap(
	s: FsStat, acc: ?, 
	fn_s: (FsStat, ?) -> Pair<FsStat, ?>,
	fn_e: (FsExp, ?) -> Pair<FsExp, ?>
	) -> ? {
	switch (s) {
		FsIf(cond, s1, s2): {
			fsExpFold(cond, trans_s, trans_e);
			fsStatFold(s1, trans_s, trans_e);
			fsStatFold(s2, trans_s, trans_e);
		}
		FsSwitch(x, sw_type, cases): {
			fsExpFold(x, trans_s, trans_e);
			iter(cases, \c -> fsStatFold(c.body, trans_s, trans_e));
		}
		FsSeq(ss): { 
			iter(ss, \x -> fsStatFold(x, trans_s, trans_e));
		}
		FsLet(v, e): {
			fsExpFold(v, trans_s, trans_e);
			fsExpFold(e, trans_s, trans_e);
		}
		FsWrapExp(e): {
			fsExpFold(e, trans_s, trans_e);
		}
		FsRet(e): {
			fsExpFold(e, trans_s, trans_e);
		}
		FsTailCall(): { }
		FsVarDecl(var): { 
			fsExpFold(var, trans_s, trans_e);
		}
		FsAssign(to, what): {
			fsExpFold(to, trans_s, trans_e);
			fsExpFold(what, trans_s, trans_e);
		}
		FsMemory(op, e): {
			fsExpFold(e, trans_s, trans_e);
		}
	}
	trans_s(s);
}

fsExpFold(ex: FsExp, acc: ?, fn_s: (?, FsStat) -> ?, fn_e: (?, FsExp) -> ?) -> ? {
	switch(ex) {
		FsLambda(__,__,__, body, __): {
			fsStatFold(body, trans_s, trans_e);
		}
		FsCall(fn, args, __): {
			fsExpFold(fn, trans_s, trans_e);
			iter(args, \x -> fsExpFold(x, trans_s, trans_e));
		}
		FsCallPrim(op, es, __): {
			iter(es, \x -> fsExpFold(x, trans_s, trans_e));
		}
		FsCast(e,__,__): {
			fsExpFold(e, trans_s, trans_e);
		}
		FsVar(name,__,__): { }
		FiConst(): { }
	};
	trans_e(ex);
}


fsFoldMap(s: FsAll, acc: ?, fn: (FsAll, ?) -> Pair<FsAll, ?>, order: AstTraverseOrder) -> Pair<FsAll, ?> {
	if (order.argsFirst) {
		env1 = FiExpEnv(env with parents = Cons(e, env.parents));
		p = fiFoldMapExpArgs(e, env1, acc, fn, order);
		fn(p.first, env, p.second);
	} else {
		p = fn(e, env, acc);
		env1 = FiExpEnv(env with parents = Cons(p.first, env.parents));
		fiFoldMapExpArgs(p.first, env1, p.second, fn, order);
	}
}

fsDoFoldMap(s: FsAll, acc: ?, fn: (FsAll, ?) -> Pair<FsAll, ?>, order: AstTraverseOrder) -> Pair<FsAll, ?> {
	
}
*/