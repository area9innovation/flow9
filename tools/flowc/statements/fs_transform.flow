import ds/array;
import tools/flowc/statements/fs_helpers;
import tools/flowc/manipulation/common;

export {
	// A local description of scope environment in expression
	FsTraverseEnv(
		// Pair: the AST parent node and the index of a child, containing the current node
		parents: List<Pair<FsAll, int>>,
		locals: Tree<string, FsVar>,
		args: Tree<string, FsVar>,
		lets: Tree<string, FsVar>
	);

	fsMap(s: FsAll, fn: (FsAll) -> FsAll, args_first: bool) -> FsAll;
	fsMap2(s: FsAll, fn: ([?], FsAll) -> ?) -> ?;

	fsFold(s: FsAll, v: ?, fn: (?, FsAll) -> ?, args_first: bool) ->?;
	fsFoldr(s: FsAll, v: ?, fn: (?, FsAll) -> ?, args_first: bool) ->?;
}

fsMap(a: FsAll, f: (FsAll) -> FsAll, args_first: bool) -> FsAll {
	map_var = \x -> cast(fsMap(x, f, args_first): FsAll -> FsVar);
	map_exp = \x -> cast(fsMap(x, f, args_first): FsAll -> FsExp);
	map_stat = \x -> cast(fsMap(x, f, args_first): FsAll -> FsStat);
	do_args = \s -> switch (s) {
		FsIf(cond, s1, s2,__):
			FsIf(s with cond = map_exp(cond), s1 = map_stat(s1), s2 = map_stat(s2));
		FsSwitch(x, sw_type, cases,__):
			FsSwitch(s with x = map_var(x), cases = map(cases, \c -> FsCase(c with body = map_stat(c.body))));
		FsSeq(ss,__):
			FsSeq(s with ss = map(ss, \x -> map_stat(x)));
		FsLet(v, e1,__):
			FsLet(s with var = map_var(v), e = map_exp(e1));
		FsWrapExp(e,__):
			FsWrapExp(s with e = map_exp(e));
		FsRet(e,__):
			FsRet(s with e = map_exp(e));
		FsAssign(to, what,__):
			FsAssign(s with to = map_exp(to), what = map_exp(what));
		FsModRc(__, e,__):
			FsModRc(s with e = map_exp(e));
		FsDecRc(e,__):
			FsDecRc(s with e = map_exp(e));
		FsIncRc(e,__,__):
			FsIncRc(s with e = map_exp(e));
		FsLambda(closure, args, body, __,__):
			FsLambda(s with closure = map(closure, map_var), args = map(args, map_var), body = map_stat(body));
		FsCall(fn, args, __,__):
			FsCall(s with f = map_exp(fn), args = map(args, \x -> map_exp(x)));
		FsCallPrim(__, es, __,__):
			FsCallPrim(s with es = map(es, \x -> map_exp(x)));
		FsTailCall(args, vals,__,__):
			FsTailCall(s with 
				args = map(args, \x -> map_var(x)),
				vals = map(vals, \x -> map_exp(x))
			);
		FsCast(e, from, type,__):
			FsCast(s with e = map_exp(e));
		FsVar(name,__,__,__): s;
		FsConst(__,__): s;
	}
	if (args_first) f(do_args(a)) else do_args(f(a));
}

fsMap2(a: FsAll, f: ([?], FsAll) -> ?) -> ? {
	get_args = \s -> switch (s) {
		FsIf(cond, s1, s2,__):   [cond, s1, s2];
		FsSwitch(x,__, cs,__):   concat([x], map(cs, \c -> c.body));
		FsSeq(ss,__):            ss;
		FsLet(v, e1,__):        [v, e1];
		FsWrapExp(e1,__):        [e1];
		FsRet(e1,__):            [e1];
		FsAssign(to, what,__):   [to, what];
		FsModRc(__, e1,__):      [e1];
		FsDecRc(e1,__):          [e1];
		FsIncRc(e1,__,__):       [e1];
		FsLambda(cl,as,e,__,__): concat3(cl, as, [e]);
		FsCall(fn, args, __,__): concat([fn], args);
		FsCallPrim(__,es,__,__): es;
		FsTailCall(as,vs,__,__): concat(as, vs);
		FsCast(e1,__,__,__):     [e1];
		FsVar(__,__,__,__):      [];
		FsConst(__,__):          [];
	}
	f(map(get_args(a), \x -> fsMap2(x, f)), a);
}

fsFold(s: FsAll, v0: ?, f: (?, FsAll) -> ?, args_first: bool) -> ? {
	do_fold = \w, xs -> fold(xs, w, \acc, x -> fsFold(x, acc, f, args_first));
	do_args = \v -> switch (s) {
		FsIf(cond, s1, s2,__):   do_fold(v, [cond, s1, s2]);
		FsSwitch(x,__, cs,__):   do_fold(v, concat([x], map(cs, \c -> c.body)));
		FsSeq(ss,__):            do_fold(v, ss);
		FsLet(w, e1,__):        do_fold(v, [w, e1]);
		FsWrapExp(e1,__):        fsFold(e1, v, f, args_first);
		FsRet(e1,__):            fsFold(e1, v, f, args_first);
		FsAssign(to, what,__):   do_fold(v, [to, what]);
		FsModRc(__, e1,__):      fsFold(e1, v, f, args_first);
		FsIncRc(e1,__,__):       fsFold(e1, v, f, args_first);
		FsDecRc(e1,__):          fsFold(e1, v, f, args_first);
		FsLambda(cl,as,e,__,__): do_fold(v, concat3(cl, as, [e]));
		FsCall(fn, args, __,__): do_fold(v, concat([fn], args));
		FsCallPrim(__,es,__,__): do_fold(v, es);
		FsTailCall(as,vs,__,__): do_fold(v, concat(as, vs));
		FsCast(e1,__,__,__):     fsFold(e1, v, f, args_first);
		FsVar(__,__,__,__):      v;
		FsConst(__,__):          v;
	}
	if (args_first) f(do_args(v0), s) else do_args(f(v0, s));
}

fsFoldr(s: FsAll, v0: ?, f: (?, FsAll) -> ?, args_first: bool) -> ? {
	do_foldr = \w, xs -> foldr(xs, w, \acc, x -> fsFoldr(x, acc, f, args_first));
	do_args = \v -> switch (s) {
		FsIf(cond, s1, s2,__):   do_foldr(v, [cond, s1, s2]);
		FsSwitch(x,__, cs,__):   do_foldr(v, concat([x], map(cs, \c -> c.body)));
		FsSeq(ss,__):            do_foldr(v, ss);
		FsLet(w, e1,__):        do_foldr(v, [w, e1]);
		FsWrapExp(e1,__):        fsFoldr(e1, v, f, args_first);
		FsRet(e1,__):            fsFoldr(e1, v, f, args_first);
		FsAssign(to, what,__):   do_foldr(v, [to, what]);
		FsModRc(__, e1,__):      fsFoldr(e1, v, f, args_first);
		FsIncRc(e1,__,__):       fsFoldr(e1, v, f, args_first);
		FsDecRc(e1,__):          fsFoldr(e1, v, f, args_first);
		FsLambda(cl,as,e,__,__): do_foldr(v, concat3(cl, as, [e]));
		FsCall(fn, args, __,__): do_foldr(v, concat([fn], args));
		FsCallPrim(__,es,__,__): do_foldr(v, es);
		FsTailCall(as,vs,__,__): do_foldr(v, concat(as, vs));
		FsCast(e1,__,__,__):     fsFoldr(e1, v, f, args_first);
		FsVar(__,__,__,__):      v;
		FsConst(__,__):          v;
	}
	if (args_first) do_args(f(v0, s)) else f(do_args(v0), s);
}
