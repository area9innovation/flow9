import tools/flowc/statements/fs_transform;
import tools/flowc/incremental/fi_helpers;

export {
	// Try to reuse a freshly freed structs
	fsReuse(s : FsStat, debug: bool) -> void;
}

fsReuse(s : FsStat, debug: bool) -> void {
	//id2reuse = generate(0, num, \__ -> ref "");
	id_counter = ref 0;
	new_id = \-> {
		id = ^id_counter;
		id_counter := id + 1;
		"__reused_" + i2s(id);
	}
	ignore(fsFold2(s, Cons(makeTree(), EmptyList()),
		\acc: Cons<Tree<FiType, [FsDecRc]>>, x: FsAll -> {
			switch (x) {
				FsLambda(closure, args,__,__,id): {
					Cons(makeTree(), acc);
				}
				FsDecRc(v,__,__): {
					if (fiTypeIsScalar(v.type)) acc else {
						type = fiPurifyType(v.type);
						Cons(
							setTree(acc.head,
								type, 
								arrayPush(lookupTreeDef(acc.head, type, []), x)
							),
							acc.tail
						);
					}
				}
				FsCallPrim(op, es, t,__): {
					switch (op) {
						FsStructPrim(struct, reuse): {
							type = fiPurifyType(t);
							switch (lookupTree(acc.head, type)) {
								Some(decs): {
									if (length(decs) == 0) acc else {
										reuse_id = new_id();
										dec = decs[0];
										dec.reuse ::= reuse_id;
										op.reuse ::= reuse_id;
										Cons(
											setTree(acc.head, type, tail(decs)),
											acc.tail
										);
									}
								}
								None(): acc;
							}
						}
						default: {
							if (debug) {
								println("fsTryToReuseInExp RESULT - NONE, op: " + toString(op));
							}
							acc
						}
					}
				}
				default: {
					acc;
				}
			}
		},
		\acc, x -> {
			switch (x) {
				FsLambda(__,__,__,__,id): {
					cast(acc.tail: List<Tree<FiType, [FsDecRc]>> -> Cons<Tree<FiType, [FsDecRc]>>);
				}
				default: acc;
			}
		},
		\args -> args,
		\p1, p2 -> Cons(mergeTree(p1.head, p2.head), p1.tail)
	));
}
