import ds/hashset;
import tools/flowc/statements/fs_expand;

export {
	fsReuse(s: FsStat, debug: bool, name: string) -> FsStat;

	// Markups the AST nodes, which are used in reuse analysis, with unique ids
	fsReuseMarkup(s: FsStat) -> Pair<FsStat, int>;

	// Try to reuse a freshly freed structs
	fsReuseAdd(s : FsStat, debug: bool) -> void;

	// Add implicit decRcFinish in branches, which don't have reuses
	fsReuseImplicitDecs(s: FsStat, num_ids: int, debug0: bool, name: string) -> [FsMem];
}

fsReuse(s: FsStat, debug: bool, name: string) -> FsStat {
	p = fsReuseMarkup(s);
	if (debug) {
		println("REUSE MARKUP:\n" + fs2s(p.first));
	}
	types = fsReuseTypes(s, debug);
	reuse_cases = fsReuseId2varsPost2(s, types, debug);
	/*

FsReuseCase(
	released: FsAll,
	reused:   [FsAll],
	ignored:  [FsAll]
);
	*/
	ids2s = \ids -> "[" + superglue(ids, \x -> i2s(x.id), ", ") + "]";
	case2s = \rc -> {
		"released=" + i2s(rc.released.id) + ", reused=" + ids2s(rc.reused) + ", ignored=" + ids2s(rc.ignored) 
	}
	println("reuse_cases:" + if (length(reuse_cases) == 0) "[]" else 
		"\n" + superglue(reuse_cases, \c -> "\t" + case2s(c), "\n")
	);
/*
	fsReuseAdd(p.first, debug);
	if (debug) {
		println("REUSE ADDED:\n" + fs2s(p.first));
	}
	mem = fsReuseImplicitDecs(p.first, p.second, debug, name);
	fsExpandMem(p.first, mem);
*/
	s;
}

fsReuseMarkup(s: FsStat) -> Pair<FsStat, int> {
	id_counter = ref 0;
	new_id = \-> {
		id = ^id_counter;
		id_counter := ^id_counter + 1;
		id;
	}
	s1 = cast(fsMap(s, \x -> switch(x) {
		FsIf(c,__,__,__):         FsIf(x with id = new_id());
		FsSwitch(__,__,__,__):    FsSwitch(x with id = new_id());
		FsSeq(__, __):            FsSeq(x with id = new_id());
		FsWrapExp(e,__):          FsWrapExp(x with id = new_id());
		FsRet(e,__):              FsRet(x with id = new_id());
		FsAssign(e1, e2,__):      FsAssign(x with id = new_id());
		FsLet(__,e,__,__):        FsLet(x with id = new_id());
		FsDecRc(__,__,__):        FsDecRc(x with id = new_id());
		FsLambda(__,__,__,__,__): FsLambda(x with id = new_id());
		default: fsSetId(x, -1);
	}, false): FsAll -> FsStat);
	Pair(s1, ^id_counter);
}

// fsFold1(s: FsAll, v0: ?, pre: (?, FsAll) -> ?, post: (?, FsAll) -> ?, order: ([FsAll]) -> [FsAll]) -> ? {
//	post(fold(order(fsArgs(s)), pre(v0, s), \acc, x -> fsFold1(x, acc, pre, post, order)), s);
//}

/*
fsFold3(s: FsAll, v: ?, 
	fn: (?, FsAll) -> ?, 
	merge_branches: (?, ?) -> ?,
	init: () -> ?,
	copy: (?) -> ?,
	args_first: bool, backwards: bool
) -> ?;
*/

fsReuseTypes(s : FsStat, debug: bool) -> [FiType] {
	dec_types = fsFold(s, makeSet(), \acc, x -> switch (x) {
		FsDecRc(v,__, id): 
			if (fiTypeIsScalar(v.type)) acc else {
				insertSet(acc, v.type);
			}
		default: acc;
	}, true);
	create_types = fsFold(s, makeSet(), \acc, x -> switch (x) {
		FsCallPrim(op, es, t, id): {
			switch (op) {
				FsStructPrim(struct, reuse): {
					insertSet(acc, t);
				}
				default: acc;
			}
		}
		default: acc;
	}, true);
	ret = set2array(intersectSets(dec_types, create_types));
	if (debug) {
		println("Potentially reusable types:\n" + 
			concatStrings(map(ret, \t -> "\t" + pretFiType(t) + "\n"))
		);
	}
	ret;
}

FsReuseIgnore(
	reused:  [FsAll],
	ignored: [FsAll]
);

FsReuseCase(
	released: FsAll,
	reused:   [FsAll],
	ignored:  [FsAll]
);

FsReuseAcc(
	reuses:   [FsReuseCase],
	variants: Tree<FiType, FsReuseIgnore> // Variants are indexed by types!
);

fsMergeReuseIgnore(s: FsAll, ups: [FsReuseIgnore]) -> FsReuseIgnore {
	if (forall(ups, \up -> length(up.reused) == 0 && length(up.reused) == 0)) {
		FsReuseIgnore([], [s]);
	} else {
		FsReuseIgnore(
			concatA(map(ups, \up -> up.reused)),
			concatA(map(ups, \up -> up.ignored))
		);
	}
}

fsMergeReuseAcc(s: FsAll, accs: [FsReuseAcc], types: [FiType]) -> FsReuseAcc {
	FsReuseAcc(
		concatA(map(accs, \acc -> acc.reuses)),
		fold(types, makeTree(), \acc, type -> 
			setTree(acc, type, 
				fsMergeReuseIgnore(s, map(accs,
					\ac -> lookupTreeDef(ac.variants, type, FsReuseIgnore([], []))
				))
			)
		)
	)
}

/*
fsFold4(s: FsAll, v: ?, 
	fn: (?, FsAll) -> ?, 
	merge_branches: (FsAll, [?]) -> ?,
	init: () -> ?,
	copy: (?) -> ?,
	args_first: bool, backwards: bool
) -> ?;
*/

fsReuseId2varsPost2(s: FsStat, types: [FiType], debug: bool) -> [FsReuseCase] {
	show_vars = \vs -> "[" + strGlue(set2array(vs), ", ") + "]";
	make_acc = \-> FsReuseAcc([], makeTree());
	fsFold4(s, make_acc(),
		\acc, x: FsAll -> {
			switch (x) {
				FsCallPrim(op, es, type,__): {
					switch (op) {
						FsStructPrim(__,__): {
							ri = lookupTreeDef(acc.variants, type, FsReuseIgnore([], []));
							FsReuseAcc(acc with
								variants = setTree(acc.variants, type,
									FsReuseIgnore(ri with reused = arrayPush(ri.reused, x))
								)
							);
						}
						default: acc;
					}
				}
				FsDecRc(v, mode,__): {
					switch (lookupTree(acc.variants, v.type)) {
						Some(ri): {
							new_reuses = map(ri.reused, \y -> FsReuseCase(y, ri.reused, ri.ignored));
							FsReuseAcc(acc with
								reuses = concat(acc.reuses, new_reuses)
							);
						}
						None(): acc;
					}
				}
				default: {
					acc;
				}
			}
		},
		\x, accs -> fsMergeReuseAcc(x, accs, types), // merge_branches
		make_acc, // init
		idfn,  // copy
		true,  // args_first
		false, // backwards
	).reuses;
}

fsReuseAdd(s : FsStat, debug: bool) -> void {
	id_counter = ref 0;
	new_id = \-> {
		id = ^id_counter;
		id_counter := ^id_counter + 1;
		i2s(id);
	}
	ignore(fsFold2(s, Cons(makeTree(), EmptyList()),
		\acc: Cons<Tree<FiType, [FsDecRc]>>, x: FsAll -> {
			switch (x) {
				FsLambda(__,__,__,__,__): {
					Cons(makeTree(), acc);
				}
				FsDecRc(v,__, id): {
					if (fiTypeIsScalar(v.type)) acc else {
						Cons(
							setTree(acc.head,
								v.type, 
								arrayPush(lookupTreeDef(acc.head, v.type, []), x)
							),
							acc.tail
						);
					}
				}
				FsCallPrim(op, es, t, id): {
					switch (op) {
						FsStructPrim(struct, reuse): {
							type = fiPurifyType(t);
							switch (lookupTree(acc.head, type)) {
								Some(decs): {
									if (length(decs) == 0) acc else {
										reuse_id = new_id();
										dec = decs[0];
										dec.mode ::= FsDecReuse(reuse_id);
										op.reuse ::= reuse_id;
										Cons(
											setTree(acc.head, type, tail(decs)),
											acc.tail
										);
									}
								}
								None(): acc;
							}
						}
						default: acc;
					}
				}
				default: acc;
			}
		},
		\acc, x -> {
			switch (x) {
				FsLambda(__,__,__,__,__): {
					cast(acc.tail: List<Tree<FiType, [FsDecRc]>> -> Cons<Tree<FiType, [FsDecRc]>>);
				}
				default: acc;
			}
		},
		\args -> args,
		\p1, p2 -> Cons(mergeTree(p1.head, p2.head), p1.tail)
	));
}

fsReuseImplicitDecs(s: FsStat, num_ids: int, debug: bool, name: string) -> [FsMem] {
	dec2var = fsFold(s, makeTree(), \acc, x -> switch (x) {
		FsDecRc(v,__,__): setTree(acc, v.name, v);
		default: acc;
	}, true);
	t1 = timestamp();
	last = fsReuseLast(s, num_ids, debug, name);
	fsShowTiming(name + ": fsReuseLast(s1, num_ids, ^debug, name)", t1);
	t2 = timestamp();
	id2mem = fsReuseId2Mem(s, num_ids, last, dec2var);
	if (debug) {
		println("reuse: id2mem:\n" + fsMemArray2string(id2mem));
	}
	fsShowTiming(name + ": fsReuseId2Mem(s1, num_ids, last, dec2var)", t2);
	id2mem;
}

fsReuseId2Mem(s: FsStat, num: int, last: [Set<string>], dec2var: Tree<string, FsVar>) -> [FsMem] {
	id2mem = generate(0, num, \__ -> ref FsMem(makeTree(), makeSet(), makeTree()));
	add_id = \x, id -> if (0 <= id) {
		id2mem[id] := fsReuseAddUnused2Mem(^(id2mem[id]), id, last, dec2var);
	}
	fsIter(s, \x -> switch (x) {
		FsIf(__,__,__, id):  add_id(x, id);
		FsSwitch(__,__,__, id): add_id(x, id);
		FsSeq(__, id): add_id(x, id);
		FsRet(__, id): add_id(x, id);
		FsWrapExp(__, id): add_id(x, id);
		FsLet(__,__,__, id): add_id(x, id);
		FsAssign(t__,__, id): add_id(x, id);
		default: {}
	}, true);
	map(id2mem, \m -> ^m);
}

fsReuseAddUnused2Mem(mem: FsMem, id: int, last: [Set<string>], dec2var: Tree<string, FsVar>) -> FsMem {
	foldSet(last[id], mem, \acc, x ->
		FsMem(acc with
			unused = setTree(
				acc.unused,
				lookupTreeDef(dec2var, x, FsVar(x, FiTypeVoid())),
				FsDecFinish()
			)
		)
	);
}

fsReuseLast(s: FsStat, num: int, debug: bool, name: string) -> [Set<string>] {
	s1 = timestamp();
	pre = fsReuseId2varsPre(s, num, debug);
	fsShowTiming(name + ": fsReuseId2varsPre(s, num, debug)", s1);

	s2 = timestamp();
	post = fsReuseId2varsPost(s, num, debug);
	fsShowTiming(name + ": fsReuseId2varsPost(s, num, debug)", s2);

	s3 = timestamp();
	last = fsReuseId2varsLast(s, num, pre, post, debug);
	fsShowTiming(name + ": fsReuseId2varsLast(s, num, debug)", s2);

	if (debug) {
		set_tree2s1 = \st -> {
			superglue(
				filtermapi(st, \i, x -> if (isEmptySet(x)) None() else Some(Pair(i, x))), 
				\p -> "\t" + i2s(p.first) + ": " + "[" + strGlue(set2array(p.second), ", ") + "]", "\n"
			);
		}
		hashset_tree2s1 = \st -> {
			superglue(
				filtermapi(st, \i, x -> if (isEmptyHashSet(x)) None() else Some(Pair(i, x))),
				\p -> "\t" + i2s(p.first) + ": " + "[" + strGlue(hashSet2array(p.second), ", ") + "]", "\n"
			);
		}
		println(
			//"pre:\n" + hashset_tree2s1(pre) + "\n" +
			"pre:\n" + set_tree2s1(pre) + "\n" +
			"post:\n" + set_tree2s1(post) + "\n" +
			"last:\n" + set_tree2s1(last) + "\n" +
			""
		);
	}
	last;
}

fsReuseId2varsPre(s: FsStat, num: int, debug: bool) -> [Set<string>] {
	id2vars = generate(0, num, \__ -> ref makeSet());
	fsFold2(s, Cons(makeSet(), EmptyList()),
		\acc: Cons<Set<string>>, x: FsAll -> {
			switch (x) {
				FsLambda(__,__,__,__,__): {
					Cons(makeSet(), acc);
				}
				FsDecRc(v, mode, id): {
					switch (mode) {
						FsDecReuse(reuse): {
							id2vars[id] := acc.head;
							Cons(insertSet(acc.head, reuse), acc.tail);
						}
						default: acc;
					}
				}
				default: {
					if (x.id != -1) {
						id2vars[x.id] := acc.head;
					}
					acc;
				}
			}
		},
		\acc, x -> switch (x) {
			FsLambda(__,__,__,__,id): {
				cast(acc.tail: List<Set<string>> -> Cons<Set<string>>);
			}
			default: acc;
		},
		\args -> args,
		\p1, p2 -> Cons(mergeSets(p1.head, p2.head), p1.tail)
	);
	map(id2vars, \x -> ^x);
}

fsReuseId2varsPost(s: FsStat, num: int, debug: bool) -> [Set<string>] {
	show_vars = \vs -> "[" + strGlue(set2array(vs), ", ") + "]";
	id2reused = generate(0, num, \__ -> ref makeSet());
	merge_sets = \id, x -> id2reused[id] := mergeSets(^(id2reused[id]), x);
	fsFold2(s, Cons(makeSet(), EmptyList()),
		\acc, x -> {
			switch (x) {
				FsLambda(__,__,__,__,__): {
					Cons(makeSet(), acc);
				}
				default: acc;
			}
		},
		\acc, x: FsAll -> {
			switch (x) {
				FsLambda(__,__,__,__,id): {
					merge_sets(id, acc.head);
					cast(acc.tail: List<Set<string>> -> Cons<Set<string>>);
				}
				FsCallPrim(op, es, t,__): {
					new_reuse = switch (op) {
						FsStructPrim(__, reuse): {
							if (reuse != "") insertSet(acc.head, reuse) else acc.head;
						}
						default: acc.head;
					}
					Cons(new_reuse, acc.tail);
				}
				default: {
					if (x.id != -1) {
						merge_sets(x.id, acc.head);
					}
					acc;
				}
			}
		},
		\args -> reverseA(args),
		\p1, p2 -> Cons(mergeSets(p1.head, p2.head), p1.tail)
	);
	map(id2reused, \x -> ^x);
}

fsReuseId2varsLast(s: FsStat, num: int, pre: [Set<string>], post: [Set<string>], debug: bool) -> [Set<string>] {
	show_hash_vars = \vs -> "[" + strGlue(hashSet2array(vs), ", ") + "]";
	show_set_vars = \vs -> "[" + strGlue(set2array(vs), ", ") + "]";
	id2vars = generate(0, num, \__ -> ref makeSet());
	fsFold2(s, Cons(makeSet(), makeList()),
		\acc: Cons<Set<string>>, x: FsAll -> {
			do_diff = \ -> {
				diff = foldSet(acc.head, 
					foldSet(post[x.id], pre[x.id], \ac, v -> removeSet(ac, v)),
					\ac, v -> removeSet(ac, v)
				);
				id2vars[x.id] := diff;
				diff;
			}
			switch (x) {
				FsLambda(__,__,__,__,id): {
					do_diff();
					Cons(makeSet(), acc);
				}
				default: {
					if (x.id == -1) acc else {
						diff = do_diff();
						Cons(mergeSets(acc.head, diff), acc.tail);
					}
				}
			}
		},
		\acc, x -> {
			switch (x) {
				FsLambda(__,__,__,__,id): {
					cast(acc.tail: List<Set<string>> -> Cons<Set<string>>);
				}
				default: acc;
			}
		},
		\args -> args,
		\p1, p2 -> Cons(mergeSets(p1.head, p2.head), p1.tail)
	);
	map(id2vars, \x -> ^x);
}
