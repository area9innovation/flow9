import tools/flowc/statements/fs_transform;
import tools/flowc/incremental/fi_helpers;

export {
	// Try to reuse a freshly freed structs
	fsReuse(s : FsStat, debug: bool) -> void;
}

fsReuse(s : FsStat, debug: bool) -> void {
	id_counter = ref 0;
	new_id = \-> {
		id = ^id_counter;
		id_counter := id + 1;
		"__reused_" + i2s(id);
	}
	ignore(fsFold2(s, Cons(makeTree(), EmptyList()),
		\acc: Cons<Tree<FiType, [FsDecRc]>>, x: FsAll -> {
			switch (x) {
				FsLambda(closure, args,__,__,id): {
					Cons(makeTree(), acc);
				}
				FsDecRc(v,__,__): {
					if (fiTypeIsScalar(v.type)) acc else {
						type = fiPurifyType(v.type);
						Cons(
							setTree(acc.head,
								type, 
								arrayPush(lookupTreeDef(acc.head, type, []), x)
							),
							acc.tail
						);
					}
				}
				FsCallPrim(op, es, t,__): {
					switch (op) {
						FsStructPrim(struct, reuse): {
							type = fiPurifyType(t);
							switch (lookupTree(acc.head, type)) {
								Some(decs): {
									if (length(decs) == 0) acc else {
										reuse_id = new_id();
										dec = decs[0];
										dec.mode ::= FsDecReuse(reuse_id);
										op.reuse ::= reuse_id;
										Cons(
											setTree(acc.head, type, tail(decs)),
											acc.tail
										);
									}
								}
								None(): acc;
							}
						}
						default: {
							if (debug) {
								println("fsTryToReuseInExp RESULT - NONE, op: " + toString(op));
							}
							acc
						}
					}
				}
				default: {
					acc;
				}
			}
		},
		\acc, x -> {
			switch (x) {
				FsLambda(__,__,__,__,id): {
					cast(acc.tail: List<Tree<FiType, [FsDecRc]>> -> Cons<Tree<FiType, [FsDecRc]>>);
				}
				default: acc;
			}
		},
		\args -> args,
		\p1, p2 -> Cons(mergeTree(p1.head, p2.head), p1.tail)
	));
}

fsId2reusePost(s: FsStat, num: int, debug: bool) -> [Set<string>] {
	show_vars = \vs -> "[" + strGlue(set2array(vs), ", ") + "]";
	id2reused = generate(0, num, \__ -> ref makeSet());
	merge_sets = \id, x -> id2reused[id] := mergeSets(^(id2reused[id]), x);
	fsFold2(s, Cons(makeSet(), EmptyList()),
		\acc, x -> {
			switch (x) {
				FsLambda(__,__,__,__,id): {
					Cons(makeSet(), acc);
				}
				default: acc;
			}
		},
		\acc, x: FsAll -> {
			switch (x) {
				FsLambda(__,__,__,__,id): {
					merge_sets(id, acc.head);
					cast(acc.tail: List<Set<string>> -> Cons<Set<string>>);
				}
				FsCallPrim(op, es, t,__): {
					new_reuse = switch (op) {
						FsStructPrim(__, reuse): {
							if (reuse != "") insertSet(acc.head, reuse) else acc.head;
						}
						default: acc.head;
					}
					Cons(new_reuse, acc.tail);
				}
				default: {
					if (x.id != -1) {
						merge_sets(x.id, acc.head);
					}
					acc;
				}
			}
		},
		\args -> reverseA(args),
		\p1, p2 -> Cons(mergeSets(p1.head, p2.head), p1.tail)
	);
	map(id2reused, \x -> ^x);
}

