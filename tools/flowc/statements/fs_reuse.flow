import ds/hashset;
import tools/flowc/statements/fs_transform;
import tools/flowc/statements/fs_helpers;

export {
	// Try to reuse a freshly freed structs
	fsReuseAdd(s : FsStat, debug: bool) -> void;

	// Add implicit decRcFinish in branches, which don't have reuses
	fsReuseImplicitDecs(s: FsStat, num_ids: int, debug0: bool, name: string) -> [FsMem];
}

fsReuseAdd(s : FsStat, debug: bool) -> void {
	id_counter = ref 0;
	new_id = \-> {
		id = ^id_counter;
		id_counter := id + 1;
		"__reused_" + i2s(id);
	}
	ignore(fsFold2(s, Cons(makeTree(), EmptyList()),
		\acc: Cons<Tree<FiType, [FsDecRc]>>, x: FsAll -> {
			switch (x) {
				FsLambda(closure, args,__,__,id): {
					Cons(makeTree(), acc);
				}
				FsDecRc(v,__,__): {
					if (fiTypeIsScalar(v.type)) acc else {
						type = fiPurifyType(v.type);
						Cons(
							setTree(acc.head,
								type, 
								arrayPush(lookupTreeDef(acc.head, type, []), x)
							),
							acc.tail
						);
					}
				}
				FsCallPrim(op, es, t,__): {
					switch (op) {
						FsStructPrim(struct, reuse): {
							type = fiPurifyType(t);
							switch (lookupTree(acc.head, type)) {
								Some(decs): {
									if (length(decs) == 0) acc else {
										reuse_id = new_id();
										dec = decs[0];
										dec.mode ::= FsDecReuse(reuse_id);
										op.reuse ::= reuse_id;
										Cons(
											setTree(acc.head, type, tail(decs)),
											acc.tail
										);
									}
								}
								None(): acc;
							}
						}
						default: {
							if (debug) {
								println("fsTryToReuseInExp RESULT - NONE, op: " + toString(op));
							}
							acc
						}
					}
				}
				default: {
					acc;
				}
			}
		},
		\acc, x -> {
			switch (x) {
				FsLambda(__,__,__,__,id): {
					cast(acc.tail: List<Tree<FiType, [FsDecRc]>> -> Cons<Tree<FiType, [FsDecRc]>>);
				}
				default: acc;
			}
		},
		\args -> args,
		\p1, p2 -> Cons(mergeTree(p1.head, p2.head), p1.tail)
	));
}

fsReuseImplicitDecs(s: FsStat, num_ids: int, debug0: bool, name: string) -> [FsMem] {
	debug = ref debug0;
	add_var = \x, acc, v -> {
		switch (lookupTree(acc, v.name)) {
			Some(w): fail(
				"Duplicate variable: " + v.name + " of type: " + pretFiType(v.type) + ", already is of type: " + pretFiType(w.type) + " in:\n" + 
				fs2s(x) + "\n" +
				"IN:\n" + fs2s(s)
			);
			None(): { }
		}
		setTree(acc, v.name, v);
	}
	name2var = fsFold(s, makeTree(), \acc, x -> switch (x) {
		FsLet(v,__,__,__): add_var(x, acc, v);
		FsLambda(__,args,__,__,__): fold(args, acc, \ac, arg -> add_var(x, ac, arg));
		default: acc;
	}, true);
	t1 = timestamp();
	last = fsReuseLast(s, num_ids, ^debug, name);
	fsShowTiming(name + ": fsReuseLast(s1, num_ids, ^debug, name)", t1);
	t2 = timestamp();
	id2mem = fsReuseId2Mem(s, num_ids, last, name2var);
	if (^debug) {
		println("id2mem:\n" +
			supergluei(
				filter(id2mem, \mem -> sizeTree(mem.incs) > 0 || sizeSet(mem.decs) > 0 || sizeSet(mem.unused) > 0),
				\i, mem -> {
					mem_s = fsMem2string(mem);
					"\t" + i2s(i) + ": " + if (strContains(mem_s, "\n")) strIndent(strIndent(mem_s)) else mem_s;
				}, "\n"
			) 
		);
	}
	fsShowTiming(name + ": fsId2Mem(s1, num_ids, last, name2var)", t2);
	id2mem;
}

fsReuseId2Mem(s: FsStat, num: int, last: [Set<string>], name2var: Tree<string, FsVar>) -> [FsMem] {
	make_mem = \ -> FsMem(makeTree(), makeSet(), makeSet());
	id2mem = generate(0, num, \__ -> ref make_mem());
	fsIter(s, \x -> switch (x) {
		FsIf(cond, pos, neg, id):  {
			id2mem[id] := fsReuseAddUnused2Mem(^(id2mem[id]), id, last, name2var);
		};
		FsSwitch(v,__, cs, id): {
			id2mem[id] := fsReuseAddUnused2Mem(^(id2mem[id]), id, last, name2var);
		}
		FsSeq(ss, id): {
			id2mem[id] := fsReuseAddUnused2Mem(^(id2mem[id]), id, last, name2var);
		}
		FsRet(e, id): {
			id2mem[id] := fsReuseAddUnused2Mem(^(id2mem[id]), id, last, name2var);
		}
		FsWrapExp(e, id): {
			id2mem[id] := fsReuseAddUnused2Mem(^(id2mem[id]), id, last, name2var);
		}
		FsLet(__,e, __, id): {
			id2mem[id] := fsReuseAddUnused2Mem(^(id2mem[id]), id, last, name2var);
		}
		FsAssign(to, what, id): {
			id2mem[id] := fsReuseAddUnused2Mem(^(id2mem[id]), id, last, name2var);
		}
		FsIncRc(__,__,__): fail("FsIncRc met during memory operations markup");
		FsDecRc(__,__,__): fail("FsDecRc met during memory operations markup");
		default: {}
	}, true);
	map(id2mem, \m -> ^m);
}

fsReuseAddUnused2Mem(mem: FsMem, id: int, last: [Set<string>], name2var: Tree<string, FsVar>) -> FsMem {
	foldSet(last[id], mem, \acc, x ->
		FsMem(acc with unused = insertSet(acc.unused, lookupTreeDef(name2var, x, FsVar(x, FiTypeVoid()))))
	);
}

fsReuseLast(s: FsStat, num: int, debug: bool, name: string) -> [Set<string>] {
	s1 = timestamp();
	pre = fsReuseId2varsPre(s, num, debug);
	fsShowTiming(name + ": fsReuseId2varsPre(s, num, debug)", s1);

	s2 = timestamp();
	post = fsReuseId2varsPost(s, num, debug);
	fsShowTiming(name + ": fsReuseId2varsPost(s, num, debug)", s2);

	s3 = timestamp();
	last = fsReuseId2varsLast(s, num, pre, post, debug);
	fsShowTiming(name + ": fsReuseId2varsLast(s, num, debug)", s2);

	if (debug) {
		set_tree2s1 = \st -> {
			superglue(
				filtermapi(st, \i, x -> if (isEmptySet(x)) None() else Some(Pair(i, x))), 
				\p -> "\t" + i2s(p.first) + ": " + "[" + strGlue(set2array(p.second), ", ") + "]", "\n"
			);
		}
		hashset_tree2s1 = \st -> {
			superglue(
				filtermapi(st, \i, x -> if (isEmptyHashSet(x)) None() else Some(Pair(i, x))),
				\p -> "\t" + i2s(p.first) + ": " + "[" + strGlue(hashSet2array(p.second), ", ") + "]", "\n"
			);
		}
		println(
			//"pre:\n" + hashset_tree2s1(pre) + "\n" +
			//"post:\n" + set_tree2s1(post) + "\n" +
			"last:\n" + set_tree2s1(last) + "\n" +
			""
		);
	}
	last;
}

fsReuseId2varsPre(s: FsStat, num: int, debug: bool) -> [HashSet<string>] {
	id2vars = generate(0, num, \__ -> ref makeHashSet(fastHashString));
	fsFold2(s, Cons(makeHashSet(fastHashString), EmptyList()),
		\acc: Cons<HashSet<string>>, x: FsAll -> {
			switch (x) {
				FsLambda(closure, args,__,__,id): {
					Cons(makeHashSet(fastHashString), acc);
				}
				FsDecRc(v, mode, id): {
					switch (mode) {
						FsDecReuse(reuse): {
							new_vars = copyHashSet(acc.head);
							insertHashSet(acc.head, reuse);
							id2vars[id] := acc.head;
							Cons(new_vars, acc.tail);
						}
						default: acc;
					}
				}
				default: {
					if (x.id != -1) {
						id2vars[x.id] := acc.head;
					}
					acc;
				}
			}
		},
		\acc, x -> switch (x) {
			FsLambda(__,__,__,__,id): {
				cast(acc.tail: List<HashSet<string>> -> Cons<HashSet<string>>);
			}
			default: acc;
		},
		\args -> args,
		\p1, p2 -> Cons(mergeHashSets(p1.head, p2.head), p1.tail)
	);
	map(id2vars, \x -> ^x);
}

fsReuseId2varsPost(s: FsStat, num: int, debug: bool) -> [Set<string>] {
	show_vars = \vs -> "[" + strGlue(set2array(vs), ", ") + "]";
	id2reused = generate(0, num, \__ -> ref makeSet());
	merge_sets = \id, x -> id2reused[id] := mergeSets(^(id2reused[id]), x);
	fsFold2(s, Cons(makeSet(), EmptyList()),
		\acc, x -> {
			switch (x) {
				FsLambda(__,__,__,__,id): {
					Cons(makeSet(), acc);
				}
				default: acc;
			}
		},
		\acc, x: FsAll -> {
			switch (x) {
				FsLambda(__,__,__,__,id): {
					merge_sets(id, acc.head);
					cast(acc.tail: List<Set<string>> -> Cons<Set<string>>);
				}
				FsCallPrim(op, es, t,__): {
					new_reuse = switch (op) {
						FsStructPrim(__, reuse): {
							if (reuse != "") insertSet(acc.head, reuse) else acc.head;
						}
						default: acc.head;
					}
					Cons(new_reuse, acc.tail);
				}
				default: {
					if (x.id != -1) {
						merge_sets(x.id, acc.head);
					}
					acc;
				}
			}
		},
		\args -> reverseA(args),
		\p1, p2 -> Cons(mergeSets(p1.head, p2.head), p1.tail)
	);
	map(id2reused, \x -> ^x);
}

fsReuseId2varsLast(s: FsStat, num: int, pre: [HashSet<string>], post: [Set<string>], debug: bool) -> [Set<string>] {
	show_hash_vars = \vs -> "[" + strGlue(hashSet2array(vs), ", ") + "]";
	show_set_vars = \vs -> "[" + strGlue(set2array(vs), ", ") + "]";
	id2vars = generate(0, num, \__ -> ref makeSet());
	hash2set = \x -> foldHashSet(x, makeSet(), \acc, v -> insertSet(acc, v));
	fsFold2(s, Cons(makeHashSet(fastHashString), makeList()),
		\acc: Cons<HashSet<string>>, x: FsAll -> {
			do_diff = \ -> {
				diff = copyHashSet(pre[x.id]);
				iterSet(post[x.id], \v -> removeHashSet(diff, v));
				iterHashSet(acc.head, \v -> removeHashSet(diff, v));
				id2vars[x.id] := hash2set(diff);
				diff;
			}
			switch (x) {
				FsLambda(__,__,__,__,id): {
					do_diff();
					Cons(makeHashSet(fastHashString), acc);
				}
				default: {
					if (x.id == -1) acc else {
						diff = do_diff();
						new_head = mergeHashSets(acc.head, diff);
						Cons(new_head, acc.tail);
					}
				}
			}
		},
		\acc, x -> {
			switch (x) {
				FsLambda(__,__,__,__,id): {
					cast(acc.tail: List<HashSet<string>> -> Cons<HashSet<string>>);
				}
				default: acc;
			}
		},
		\args -> args,
		\p1, p2 -> Cons(mergeHashSets(p1.head, p2.head), p1.tail)
	);
	map(id2vars, \x -> ^x);
}
