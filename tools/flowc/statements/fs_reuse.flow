import ds/hashset;
import tools/flowc/statements/fs_expand;
//import tools/flowc/statements/fs2_utils;

export {
	fsReuse(s: FsStat, debug: bool, name: string) -> FsStat;

	// Markups the AST nodes, which are used in reuse analysis, with unique ids
	fsReuseMarkup(s: FsStat) -> Pair<FsStat, int>;

	// Try to reuse a freshly freed structs
	//fsReuseAdd(s : FsStat, debug: bool) -> void;

	// Add implicit decRcFinish in branches, which don't have reuses
	//fsReuseImplicitDecs(s: FsStat, num_ids: int, debug0: bool, name: string) -> [FsMem];
}

fsReuse(s0: FsStat, debug: bool, name: string) -> FsStat {
	p = fsReuseMarkup(s0);
	if (debug) {
		println("REUSE MARKUP:\n" + fs2s(p.first));
	}
	s = p.first;
	types = fsReuseTypes(s, debug, name);
	if (length(types) == 0) s else {
		if (debug) {
			println(name + " reuse types:\n" +
				superglue(types, \t -> "\t" + pretFiType(t), "\n")
			);
		}
		all_reuses = fsFindReuseVariants(s, types, debug);
		if (debug) {
			println(name + " reuse_cases:\n" + fsReuseVariantArray2s(all_reuses) + "\n\n");
		}
		choosed_reuses = fsReuseChooseVariant(all_reuses);
		if (debug) {
			println(name + " choosed_reuses:\n" + fsReuseVariantArray2s(choosed_reuses) + "\n\n");
		}
		s1: FsStat = fsReuseApplyCases(s, choosed_reuses);
		if (debug) {
			println(name + " reuse applied:\n" + fs2s(s1));
		}
		//fsStat2fs2Stat(x: FsStat) -> Fs2Stat;
		//fs2Stat2fsStat(x: Fs2Stat, acc: [FsStat]) -> FsStat;
		/*x = fsStat2fs2Stat(s);
		println("Fs2Stat:\n" + fs22s(x));
		s2: FsStat = fs2Stat2fsStat(x, []);
		if (!fsEqualExprs(s, s2)) {
			fail0(
				"!fsEqualExprs(s, s2):\n" +
				"diff:\n" + strIndent(superglue(fsDiffExprs(s, s2, []), \q -> 
					"diff:\n" + strIndent(fs2s(q.first)) + "\n != \n" + strIndent(fs2s(q.second)) + "\n", "\n"
				)) + "\n" +
				"s:\n" + strIndent(fs2s(s)) + "\n" +
				"s2:\n" + strIndent(fs2s(s2)) + "\n"
			);
		}
		s2;
		*/

		//s1;
		s;
	}
}

fsReuseMarkup(s: FsStat) -> Pair<FsStat, int> {
	id_counter = ref 0;
	new_id = \-> {
		id = ^id_counter;
		id_counter := ^id_counter + 1;
		id;
	}
	s1 = cast(fsMap(s, \x -> switch(x) {
		FsIf(c,__,__,__,__):      FsIf(x with id = new_id());
		FsSwitch(__,__,__,__,__): FsSwitch(x with id = new_id());
		FsWrapExp(__,__,__):      FsWrapExp(x with id = new_id());
		FsRet(__,__,__):          FsRet(x with id = new_id());
		FsAssign(__,__,__,__):    FsAssign(x with id = new_id());
		FsLet(__,__,__,__,__):    FsLet(x with id = new_id());
		FsDecRc(__,__,__,__):     FsDecRc(x with id = new_id());
		FsIncRc(__,__,__,__):     FsIncRc(x with id = new_id());
		FsTailCall(__,__):        FsTailCall(x with id = new_id());
		FsCallPrim(__,__,__,__):  FsCallPrim(x with id = new_id());
		FsClosure(__,__,__):      FsClosure(x with id = new_id());
		FsLambda(__,__,__,__,__): FsLambda(x with id = new_id());
		FsCall(__,__,__,__):      FsCall(x with id = new_id());
		FsCast(__,__,__,__):      FsCast(x with id = new_id());
		FsVarUse(__,__,__):       FsVarUse(x with id = new_id());
		FsConst(__,__):           FsConst(x with id = new_id());
	}, false): FsAll -> FsStat);
	Pair(s1, ^id_counter);
}

fsReuseTypes(s : FsStat, debug: bool, name: string) -> [FiType] {
	dec_types = fsFold(s, makeSet(), \acc, x -> switch (x) {
		FsDecRc(v,__, id,__): 
			if (fiTypeIsScalar(v.type)) acc else {
				insertSet(acc, v.type);
			}
		default: acc;
	}, true);
	/*println(name + " dec types:" +
		if (sizeSet(dec_types) == 0) "[]" else superglue(set2array(dec_types), \t -> "\t" + pretFiType(t), "\n")
	);*/
	create_types = fsFold(s, makeSet(), \acc, x -> switch (x) {
		FsCallPrim(op, es, t, id): {
			switch (op) {
				FsStructPrim(struct, reuse): {
					insertSet(acc, t);
				}
				default: acc;
			}
		}
		default: acc;
	}, true);
	/*println(name + " create types:" +
		if (sizeSet(create_types) == 0) "[]" else superglue(set2array(create_types), \t -> "\t" + pretFiType(t), "\n")
	);*/
	ret = set2array(intersectSets(dec_types, create_types));
	if (debug) {
		println("Potentially reusable types:\n" + 
			concatStrings(map(ret, \t -> "\t" + pretFiType(t) + "\n"))
		);
	}
	ret;
}

FsReuseAcc(
	reused:  [FsAll],
	ignored: [FsAll]
);

FsReuseVariant(
	released: FsDecRc,
	reused:   [FsAll],
	ignored:  [FsAll]
);

fsIds2s(xs: [FsAll]) -> string {
	"[" + superglue(xs, \x -> i2s(x.id), ", ") + "]";
}

fsReuseIgnore2s(ri: FsReuseAcc) -> string {
	"reused=" + fsIds2s(ri.reused) + ", ignored=" + fsIds2s(ri.ignored)
}

fsReuseVariant2s(rc: FsReuseVariant) -> string {
	"released=" + i2s(rc.released.id) + ", reused=" + fsIds2s(rc.reused) + ", ignored=" + fsIds2s(rc.ignored) 
}

fsReuseVariantArray2s(reuses: [FsReuseVariant]) -> string {
	if (length(reuses) == 0) "[]" else 
	superglue(reuses, \c -> "\t" + fsReuseVariant2s(c), "\n")
}

fsReusedAcc2s(acc: Tree<FiType, FsReuseAcc>, types: [FiType]) -> string {
	variants = superglue(types, \t -> switch (lookupTree(acc, t)) {
		Some(ri): "\t" + pretFiType(t) + " => " + fsReuseIgnore2s(ri);
		None():   "\t" + pretFiType(t) + " => NONE";
	}, "\n");
	"variants: " + (if (variants == "") "[]" else "\n" + variants) + "\n";
}

fsMergeReuseIgnore(s: FsAll, ups: [FsReuseAcc]) -> FsReuseAcc {
	if (forall(ups, \up -> length(up.reused) == 0 && length(up.reused) == 0)) {
		FsReuseAcc([], [s]);
	} else {
		FsReuseAcc(
			concatA(map(ups, \up -> up.reused)),
			concatA(map(ups, \up -> up.ignored))
		);
	}
}

fsMergeReuseAcc(s: FsAll, accs: [Tree<FiType, FsReuseAcc>], types: [FiType]) -> Tree<FiType, FsReuseAcc> {
	fold(types, makeTree(), \acc, type -> 
		setTree(acc, type, 
			fsMergeReuseIgnore(s, map(accs,
				\ac -> lookupTreeDef(ac, type, FsReuseAcc([], []))
			))
		)
	);
}

fsFindReuseVariants(s: FsStat, types: [FiType], debug: bool) -> [FsReuseVariant] {
	show_vars = \vs -> "[" + strGlue(set2array(vs), ", ") + "]";
	make_acc = \-> makeTree();
	reuses = ref [];
	fsFold4(s, make_acc(),
		\acc, x: FsAll -> {
			/*if (debug && x.id != -1) {
				println(i2s(x.id) + " PRE: \n" + strIndent(fsReusedAcc2s(acc, types)));
			}*/
			acc1 = switch (x) {
				FsCallPrim(op, es, type,__): {
					switch (op) {
						FsStructPrim(__,__): {
							ri = lookupTreeDef(acc, type, FsReuseAcc([], []));
							setTree(acc, type,
								FsReuseAcc(ri with reused = arrayPush(ri.reused, x))
							);
						}
						default: acc;
					}
				}
				FsDecRc(v, mode,__,__): {
					switch (lookupTree(acc, v.type)) {
						Some(ri): {
							new_reuse = FsReuseVariant(x, ri.reused, ri.ignored);
							/*if (debug) {
								println(i2s(x.id) + " NEW REUSE:\n" + strIndent(fsReuseVariant2s(new_reuse)));
							}*/
							refArrayPush(reuses, new_reuse);
						}
						None(): {
							/*if (debug) {
								println(i2s(x.id) + " NO VARIANTS");
							}*/
						}
					}
					acc;
				}
				default: {
					acc;
				}
			}
			/*if (debug && x.id != -1) {
				println(i2s(x.id) + " POST: \n" + strIndent(fsReusedAcc2s(acc1, types)));
			}*/
			acc1
		},
		\x, accs -> fsMergeReuseAcc(x, accs, types), // merge_branches
		make_acc, // init
		idfn,  // copy
		true,  // args_first
		true,  // backwards
	);
	^reuses;
}
/*
fsFindReuseVariants1(s: FsStat, acc: [FsReuseVariant], debug: bool) -> [FsReuseVariant] {
	switch (s) {
		FsIf(__, s1, s2,__): {
			fsFindReuseVariants1(s1, fsFindReuseVariants1(s2, acc, debug), debug);
		}
		FsSwitch(__,__, cs,__): {
			fold(cs, acc, \ac, c -> fsFindReuseVariants1(c.body, ac, debug));
		}
		FsSeq(ss,__): {
			fold(ss, acc, \ac, x -> fsFindReuseVariants1(x, ac, debug));
		}
		FsLet(__,__, s1,__): {
			fsFindReuseVariants1(s1, ac, debug);
		}
		FsWrapExp(__,__): acc;
		FsRet(__,__): acc;
		FsAssign(__,__,__): acc;
		FsIncRc(__,__,__): acc;
		FsDecRc(v,__,__): {
			potential_reuses = fsFindReuseVariants1()
		}
	}
}
*/

fsReuseChooseVariant(cases: [FsReuseVariant]) -> [FsReuseVariant] /*Tree<int, FsReuseVariant>*/ {
	vs = values2arrayTree(cases, \v -> v.released);
	choose_variant = \cs -> fold(tail(cs), cs[0], \acc, c ->
		if (length(c.reused) > length(acc.reused)) c else acc
	);
	vs_filtered = mapTree(vs, choose_variant);
	getTreeValues(vs_filtered)
}

fsReuseApplyCases(s: FsStat, cases: [FsReuseVariant]) -> FsStat {
	id_counter = ref 0;
	new_id = \-> {
		id = ^id_counter;
		id_counter := ^id_counter + 1;
		"___reuse_" + i2s(id);
	}
	updates = fold(cases, makeTree(), \acc, c -> {
		reuse_id = new_id();
		acc1 = setTree(acc, c.released.id, FsDecRc(c.released with mode = FsDecReuse(reuse_id)));
		acc2 = fold(c.reused, acc1, \ac, x -> {
			x1 = switch (x) {
				FsCallPrim(op,__,__,__): {
					switch (op) {
						FsStructPrim(__,__): {
							FsCallPrim(x with op = FsStructPrim(op with reuse = reuse_id));
						}
						default: x;
					}
				}
				default: x;
			}
			setTree(ac, x.id, x1);
		});
		fold(c.ignored, acc2, \ac, x -> {
			x1 = switch (x) {
				FsStat(): FsDecRc(c.released with mode = FsDecFinish(reuse_id), id = -1, next = Some(x));
				default: fail0(fs2s(x) + " must be FsStat");
			}
			setTree(ac, x.id, x1);
		});
	});
	cast(fsMap(s, \x: FsAll -> lookupTreeDef(updates, x.id, x), true): FsAll -> FsStat);
}

/*fsReuseAdd(s : FsStat, debug: bool) -> void {
 	id_counter = ref 0;
 	new_id = \-> {
 		id = ^id_counter;
 		id_counter := ^id_counter + 1;
		i2s(id);
 	}
	ignore(fsFold2(s, Cons(makeTree(), EmptyList()),
		\acc: Cons<Tree<FiType, [FsDecRc]>>, x: FsAll -> {
			switch (x) {
				FsLambda(__,__,__,__,__): {
					Cons(makeTree(), acc);
				}
				FsDecRc(v,__, id): {
					if (fiTypeIsScalar(v.type)) acc else {
						Cons(
							setTree(acc.head,
								v.type, 
								arrayPush(lookupTreeDef(acc.head, v.type, []), x)
							),
							acc.tail
						);
					}
				}
				FsCallPrim(op, es, t, id): {
 					switch (op) {
						FsStructPrim(struct, reuse): {
							type = fiPurifyType(t);
							switch (lookupTree(acc.head, type)) {
								Some(decs): {
									if (length(decs) == 0) acc else {
										reuse_id = new_id();
										dec = decs[0];
										//dec.mode ::= FsDecReuse(reuse_id);
										//op.reuse ::= reuse_id;
										Cons(
											setTree(acc.head, type, tail(decs)),
											acc.tail
										);
									}
								}
								None(): acc;
							}
 						}
						default: acc;
 					}
 				}
				default: acc;
 			}
		},
		\acc, x -> {
			switch (x) {
				FsLambda(__,__,__,__,__): {
					cast(acc.tail: List<Tree<FiType, [FsDecRc]>> -> Cons<Tree<FiType, [FsDecRc]>>);
				}
				default: acc;
 			}
		},
		\args -> args,
		\p1, p2 -> Cons(mergeTree(p1.head, p2.head), p1.tail)
	));
}
*/

/*
fsReuseId2Mem(s: FsStat, num: int, last: [Set<string>], dec2var: Tree<string, FsVar>) -> [FsMem] {
	id2mem = generate(0, num, \__ -> ref FsMem(makeTree(), makeSet(), makeTree()));
	add_id = \x, id -> if (0 <= id) {
		id2mem[id] := fsReuseAddUnused2Mem(^(id2mem[id]), id, last, dec2var);
	}
	fsIter(s, \x -> switch (x) {
		FsIf(__,__,__, id):  add_id(x, id);
		FsSwitch(__,__,__, id): add_id(x, id);
		FsSeq(__, id): add_id(x, id);
		FsRet(__, id): add_id(x, id);
		FsWrapExp(__, id): add_id(x, id);
		FsLet(__,__,__, id): add_id(x, id);
		FsAssign(t__,__, id): add_id(x, id);
		default: {}
	}, true);
	map(id2mem, \m -> ^m);
}

fsReuseAddUnused2Mem(mem: FsMem, id: int, last: [Set<string>], dec2var: Tree<string, FsVar>) -> FsMem {
	foldSet(last[id], mem, \acc, x ->
		FsMem(acc with
			unused = setTree(
				acc.unused,
				lookupTreeDef(dec2var, x, FsVar(x, FiTypeVoid())),
				FsDecFinish("")
			)
		)
	);
}
*/