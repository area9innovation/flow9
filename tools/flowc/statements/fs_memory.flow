import ds/treeutils;
import tools/flowc/incremental/fi_helpers;
import tools/flowc/statements/fs_transform;
import tools/flowc/statements/fs_utils;

export {
	//fsStatPerceus(s: FsStat, names: FiGlobalNames) -> FsStat;
	fsStatPerceus1(s: FsStat, names: FiGlobalNames) -> FsStat;

	//fsExpPerceus(e: FsExp, names: FiGlobalNames) -> FsExp;

	debug_perceus = ref false;
}

FsVarTag ::= FsVarTagDecl, FsVarTagArg, FsVarTagClosure, FsVarTagUse, FsVarTagTailCall;
	FsVarTagDecl();
	FsVarTagArg();
	FsVarTagClosure();
	FsVarTagUse(kind: FsVarKind /*, isAssignedTo: bool*/);
		FsVarKind ::= FsVarKindLocal, FsVarKindGlobal;
			FsVarKindLocal(); 
			FsVarKindGlobal(isFunc: bool);
	FsVarTagTailCall();

fsStatPerceus1(s: FsStat, names: FiGlobalNames) -> FsStat {
	// fsMap(s: FsAll, fn: (FsAll) -> FsAll) -> FsAll;
	id_counter = ref 0;
	new_id = \-> {
		id = ^id_counter;
		id_counter := ^id_counter + 1;
		id;
	}
	s1 = cast(fsMap(s, fsIds(new_id), false): FsAll -> FsStat);
	if (^debug_perceus) {
		println("s1 with ids:\n" + 
			"s:\n" + fs2s(s) + "\n" + 
			"s1:\n" + fs2s(s1) + "\n"
			//"s RAW:\n" + toStringFormatted(s1) + "\n"
		);
	}

	var_tags = fsFold(s1, makeTree(), \acc, x: FsAll -> {
		switch (x) {
			//FsIf(cond, s1, s2,__):   fsFold(s2, fsFold(s1, fsFold(cond, v, f), f), f);
			//FsSwitch(x,__, cs,__):   do_fold(concat([x], map(cs, \c -> c.body)));
			//FsSeq(ss,__):            do_fold(ss);
			//FsLet(v,__,__,__): setTree(acc, v.id, FsVarTagDecl());
			FsLet(v,__,__):   setTree(acc, v.id, FsVarTagDecl());
			//FsWrapExp(e1,__):        fsFold(e1, v, f);
			//FsRet(e1,__):            fsFold(e1, v, f);
			//FsVarDef(v,__,__): setTree(acc, v.id, FsVarTagDecl());
			//FsAssign(to, what,__):   fsFold(what, fsFold(to, v, f), f);
			//FsModRc(__, e1,__):      fsFold(e1, v, f);
			//FsIncRc(e1,__,__):       fsFold(e1, v, f);
			//FsDecRc(e1,__):          fsFold(e1, v, f);
			FsLambda(closure, args,__,__,__): {
				fold(args, 
					fold(closure, acc, \ac, v -> setTree(ac, v.id, FsVarTagClosure())), 
					\ac, v -> setTree(ac, v.id, FsVarTagArg())
				);
			}
			//FsCall(fn, args, __,__): do_fold(concat([fn], args));
			//FsCallPrim(__,es,__,__): do_fold(es);
			FsTailCall(args, vals,__,__): 
				fold(args, acc, \ac, v -> setTree(ac, v.id, FsVarTagTailCall()));
			//FsCast(e1,__,__,__):     fsFold(e1, v, f);
			//FsVarDecl(v,__): setTree(acc, v.id, FsVarTagDecl());
			FsVar(name,__,__,id): {
				kind = switch (lookupTree(names.toplevel, name)) {
					Some(decl): {
						FsVarKindGlobal(switch (decl) {
							FiGlobalVar(__,__,__,__,__): false;
							default: true;
						});
					}
					None(): FsVarKindLocal();
				}
				setTree(acc, id, FsVarTagUse(kind));
			}
			default: acc;
			//FsConst(__,__):          v;
		}
	}, true);
	if (^debug_perceus) {
		println(
			"var_tags:\n" + superglue(tree2pairs(var_tags), \p -> 
				"\t" + i2s(p.first) + "->" + toString(p.second), "\n"
			) + "\n"
			""
		);
	}

	id2vars_pre = fsFold(s1, Pair(makeTree(), makeSet()), \acc, x: FsAll -> {
		s2 = switch (x) {
			FsVar(__,__,__,id): 
				switch (lookupTree(var_tags, id)) {
					Some(tag): {
						switch (tag) {
							FsVarTagDecl(): insertSet(acc.second, FsVar(x with id = -1));
							FsVarTagArg():  insertSet(acc.second, FsVar(x with id = -1));
							default:        acc.second;
							//FsVarClosure(): acc.second;
							//FsVarGlobal(isFunc): acc.second;
							//FsVarTailCall(): acc.second;
						}
					}
					None(): acc.second;
				}
			default: acc.second;
		}
		Pair(
			setTree(acc.first, x.id, s2),
			s2,
		)
	}, false).first;
	id2vars_post = fsFoldr(s1, Pair(makeTree(), makeSet()), \acc, x: FsAll ->
		Pair(
			setTree(acc.first, x.id, acc.second),
			switch (x) {
				FsVar(__,__,__,id): //insertSet(acc.second, x);
					switch (lookupTree(var_tags, id)) {
						Some(tag): {
							switch (tag) {
								FsVarTagUse(kind): {
									switch (kind) {
										FsVarKindLocal(): insertSet(acc.second, FsVar(x with id = -1));
										FsVarKindGlobal(isFunc): acc.second;
									}
								}
								default: acc.second;
							}
						}
						None(): acc.second;
					}
				default: acc.second;
			},
		), true
	).first;
	id2vars_last = mapTree2(id2vars_pre, \id, pre_vars -> 
		differenceSets(pre_vars, lookupTreeDef(id2vars_post, id, makeSet()))
	);
	set_tree2s = \st -> {
		superglue(tree2pairs(st), \p -> 
			i2s(p.first) + ": [" + superglue(set2array(p.second), \v -> v.name, ", ") + "]", "\n" 
		);
	}
	if (^debug_perceus) {
		println(
			"id2vars_pre:\n" + set_tree2s(id2vars_pre) + "\n" +
			"id2vars_post:\n" + set_tree2s(id2vars_post) + "\n" +
			"id2vars_last:\n" + set_tree2s(id2vars_last) + "\n" +
			""
		);
	}
	dec_unused = \x -> {
		unused = filter(set2array(lookupTreeDef(id2vars_last, x.id, makeSet())), \v ->
			!(fiTypeIsScalar(v.type) || fiIsGlobalFunction(v.name, names))
		);
		if (length(unused) == 0) x else {
			FsSeq(concat(
				map(unused, \v -> FsDecRc(v, -1)),
				fsUnwrapSeq(x)
			), -1);
		}
	}
	cast(fsMap(s1, \x -> switch (x) {
		FsIf(cond, pos, neg, id):  {
			FsIf(x with s1 = dec_unused(pos), s2 = dec_unused(pos));
		};
		FsSwitch(__,__, cs,__): {
			FsSwitch(x with cases = map(cs, \c -> FsCase(c with body = dec_unused(c.body))));
		}
		FsWrapExp(e1,__): {
			if (fiTypeIsScalar(fsExpType(e1))) x else {
				FsDecRc(e1, -1);
			}
		}
		FsModRc(__, e1,__): {
			fail("double memory operators markup");
			x;
		}
		FsVar(name,__,type, id): {
			if (fiTypeIsScalar(type) || fiIsGlobal(name, names)) x  else {
				unused = lookupTreeDef(id2vars_last, x.id, makeSet());
				if (containsSet(unused, FsVar(name, false, type, -1))) {
					switch (lookupTree(var_tags, id)) {
						Some(tag): {
							switch (tag) {
								FsVarTagUse(kind): {
									FsVar(x with last = true);
								}
								default: x;
							}
						}
						None(): x;
					}
				} else {
					x;
				}
			}
		}
		default: x;
	}, true): FsAll -> FsStat);

	//fsDoStatPerceus1(s1, makeTree(), names).first;
	//fsStatMap(fsDoStatPerceus(s1, [], names).first, fsStatOptimize, idfn);
}

/*
fsStatPerceus(s: FsStat, names: FiGlobalNames) -> FsStat {
	s1 = fsStatLastVarUsage(s, makeSet(), names).first;
	if (^debug_perceus) {
		println("LAST VARS:\n" + 
			"s:\n" + fsStat2s(s) + "\n" + 
			"s1:\n" + fsStat2s(s1) + "\n"
			//"s RAW:\n" + toStringFormatted(s1) + "\n"
		);
	}
	fsDoStatPerceus1(s1, makeTree(), names).first;
	//fsStatMap(fsDoStatPerceus(s1, [], names).first, fsStatOptimize, idfn);
}

fsExpPerceus(e: FsExp, names: FiGlobalNames) -> FsExp {
	e1 = fsExpLastVarUsage(e, makeSet(), names).first;
	fsDoExpPerceus2(e1, makeTree(), names).first;
	//fsExpMap(fsDoExpPerceus(e1, names), fsStatOptimize, idfn);
}


fsDoStatPerceus1(s: FsStat, locals: Tree<string, FsVar>, names: FiGlobalNames) -> Pair<FsStat, Tree<string, FsVar>> {
	switch (s) {
		FsIf(c, s1, s2,__): {
			c_p = fsDoExpPerceus2(c, locals, names);
			s1_p = fsDoStatPerceus1(s1, c_p.second, names);
			s2_p = fsDoStatPerceus1(s2, c_p.second, names);

			if (^debug_perceus) {
				println("FSIF:\n" + 
					"locals: [" + superglue(getTreeValues(locals), fsExp2s, ", ") + "]\n" + 
					"c_p.second: [" + superglue(getTreeValues(c_p.second), fsExp2s, ", ") + "]\n" + 
			
					"s1:\n" + strIndent(fsStat2s(s1)) + "\n" +
					"s2:\n" + strIndent(fsStat2s(s2)) + "\n" +
					// fsUnusedVars(s: FsStat, locals: Tree<string, FsVar>) -> [FsVar]
					"s2 unused: [" + superglue(fsUnusedVars(s2, c_p.second), fsExp2s, ", ") + "]\n"
					//"s RAW:\n" + toStringFormatted(s1) + "\n"
				);
			}

			Pair(fsWrapSeq(concat(c_p.third,
				[FsIf(s with
					cond = c_p.first,
					s1 = fsInsertDecUnused(s1_p.first, c_p.second),
					s2 = fsInsertDecUnused(s2_p.first, c_p.second)
				)])), 
				mergeTree(s1_p.second, s2_p.second)
			);
		}
		FsSwitch(x, sw_type, cs,__): {
			x_p = fsDoExpPerceus2(x, locals, names);
			cs_p = map(cs, \c -> {
				c_m = fsDoStatPerceus1(c.body, x_p.second, names);
				Pair(FsCase(c with body = fsInsertDecUnused(c_m.first, x_p.second)), c_m.second);
			});
			Pair(fsWrapSeq(concat(x_p.third,
				[FsSwitch(s with 
					x = x_p.first,
					cases = map(cs_p, \p -> p.first)
				)])), 
				mergeTrees(map(cs_p, \p -> p.second))
			);
		}
		FsSeq(es,__): {
			p_es = fold(es, Pair([], locals), \acc, x -> {
				p_x = fsDoStatPerceus1(x, acc.second, names);
				Pair(concat(acc.first, fsUnwrapSeq(p_x.first)), p_x.second);
			});
			Pair(fsWrapSeq(p_es.first), p_es.second);
		}
		FsLet(var, e1, s1,__): {
			e1_p = fsDoExpPerceus2(e1, setTree(locals, var.name, var), names);
			s1_p = fsDoStatPerceus1(s1, e1_p.second, names);
			Pair(fsWrapSeq(concat(e1_p.third,
				[FsLet(s with
					e = e1_p.first,
					s = s1_p.first
				)])),
				s1_p.second
			);
		}
		FsLet1(var, e1,__): {
			e1_p = fsDoExpPerceus2(e1, setTree(locals, var.name, var), names);
			Pair(fsWrapSeq(concat(e1_p.third,
				[FsLet1(s with
					e = e1_p.first
				)])),
				e1_p.second
			);
		}
		FsVarDef(v, e,__): {
			fail("obsolete");
			Pair(s, locals);
		}
		FsWrapExp(e,__): {
			e_p = fsDoExpPerceus2(e, locals, names);
			Pair(fsWrapSeq(concat3(e_p.third,
					[FsWrapExp(s with e = e_p.first)],
					if (fsExpType(e) == FiTypeVoid()) [] else [FsModRc(-1, e, -1)],
				)),
				e_p.second
			);
		}
		FsRet(e,__): {
			e_p = fsDoExpPerceus2(e, locals, names);
			Pair(fsWrapSeq(concat(e_p.third,
				[FsRet(s with e = e_p.first)])),
				e_p.second
			);
		}
		FsVarDecl(var,__): {
			fail("obsolete");
			Pair(s, locals);
		}
		FsAssign(to, what,__): {
			to_p = fsDoExpPerceus2(to, locals, names);
			what_p = fsDoExpPerceus2(what, to_p.second, names);
			Pair(fsWrapSeq(concat3(to_p.third, what_p.third,
				[FsAssign(s with to = to_p.first, what = what_p.first)])), 
				what_p.second
			);
		}
		FsModRc(delta, e,__): {
			fail("double memory operators markup");
			Pair(s, locals);
		}
		FsDecRc(e,__): {
			fail("double memory operators markup");
			Pair(s, locals);
		}
	}
}

fsDoExpPerceus2(ex: FsExp, locals: Tree<string, FsVar>, names: FiGlobalNames) -> Triple<FsExp, Tree<string, FsVar>, [FsModRc]> {
	t = fsDoExpPerceus1(ex, locals, makeTree(), names);
	Triple(t.first, t.second, map(tree2pairs(t.third), \p -> FsModRc(p.second, p.first, -1)));
}

fsDoExpPerceus1(ex: FsExp, locals: Tree<string, FsVar>, incs: Tree<FsVar, int>, names: FiGlobalNames) -> Triple<FsExp, Tree<string, FsVar>, Tree<FsVar, int>> {
	inc = \v, acc -> setTree(acc, v, lookupTreeDef(acc, v, 0) + 1);
	switch (ex) {
		FsCall(f, args, type,__): {
			f_p = fsDoExpPerceus1(f, locals, incs, names);
			args_p = fold(args, Triple([], f_p.second, f_p.third), \acc, arg -> {
				arg_p = fsDoExpPerceus1(arg, acc.second, acc.third, names);
				Triple(concat(acc.first, [arg_p.first]), arg_p.second, arg_p.third);
			});
			Triple(
				FsCall(ex with 
					f = f_p.first, 
					args = args_p.first
				), 
				args_p.second,
				args_p.third
			);
		}
		FsLambda(closure, args, body, type,__): {
			closure_locals = fold(closure, makeTree(), \acc, arg -> setTree(acc, arg.name, FsVar(arg with last = false)));
			args_locals = values2tree(args, \arg -> arg.name);
			body_p = fsDoStatPerceus1(body, mergeTree(closure_locals, args_locals), names);
			unused_vars = filter(args, \v -> v.last && !fiTypeIsScalar(v.type));
			body1 = if (length(unused_vars) == 0) body_p.first else {
				FsSeq(concat(
					map(unused_vars, \v -> FsModRc(-1, v, -1)),
					[body_p.first]
				), -1);
			}
			closure_p = fold(closure, Pair(locals, incs), \acc, v -> {
				v_p = fsDoExpPerceus1(v, acc.first, acc.second, names);
				Pair(v_p.second, v_p.third);
			});
			Triple(
				FsLambda(ex with body = body1), closure_p.first, closure_p.second
			);
		}
		FsCallPrim(op, es, type,__): {
			es_p = fold(es, Triple([], locals, incs), \acc, e -> {
				e_p = fsDoExpPerceus1(e, acc.second, acc.third, names);
				Triple(concat(acc.first, [e_p.first]), e_p.second, e_p.third);
			});
			Triple(
				FsCallPrim(ex with es = es_p.first),
				es_p.second, es_p.third
			);
		}
		FsTailCall(__,vals,__,__): {
			es_p = fold(vals, Triple([], locals, incs), \acc, val -> {
				val_p = fsDoExpPerceus1(val, acc.second, acc.third, names);
				Triple(
					concat(acc.first, [val_p.first]), 
					val_p.second,
					val_p.third
				);
			});
			Triple(
				FsTailCall(ex with vals = es_p.first), 
				es_p.second,
				es_p.third
			);
		}
		FsCast(e, from, type,__): {
			e_p = fsDoExpPerceus1(e, locals, incs, names);
			Triple(FsCast(ex with e = e_p.first), e_p.second, e_p.third);
		}
		FsVar(name, last, type,__): {
			Triple(ex, 
				if (containsKeyTree(names.toplevel, name)) locals else setTree(locals, name, ex),
				if (fiTypeIsScalar(type) || last || fiIsGlobalFunction(name, names)) incs else inc(ex, incs)
			);
		}
		FsIncRc(e,__,__): {
			fail("double memory operators markup");
			Triple(ex, locals, incs);
		}
		FsConst(__,__): Triple(ex, locals, incs);
	}
}

fsUnusedVars(s: FsStat, locals: Tree<string, FsVar>) -> [FsVar] {
	s_vars = map(fsStatVars(s, []), \v -> v.name);
	filter(getTreeValues(locals), \v -> 
		!v.last && !fiTypeIsScalar(v.type) && !contains(s_vars, v.name)
	);
}

fsInsertDecUnused(s: FsStat, locals: Tree<string, FsVar>) -> FsStat {
	s_vars = map(fsStatVars(s, []), \v -> v.name);
	unused_vars = filter(getTreeValues(locals), \v -> 
		!v.last && !fiTypeIsScalar(v.type) && !contains(s_vars, v.name)
	);
	if (length(unused_vars) == 0) s else {
		FsSeq(concat(
			map(unused_vars, \v -> 
				FsModRc(-1, v, -1)
			),
			fsUnwrapSeq(s)
		), -1);
	}
}

fsExpVars(ex: FsExp, vars: [FsVar]) -> [FsVar] {
	switch (ex) {
		FsCall(f, args, type,__): {
			fold(args, fsExpVars(f, vars), \acc, x -> fsExpVars(x, acc));
		}
		FsLambda(closure, args, body, type,__): {
			fold(closure, vars, \acc, x -> concat(acc, [x]));
		}
		FsCallPrim(op, es, type,__): {
			fold(es, vars, \acc, x -> fsExpVars(x, acc));
		}
		FsTailCall(__,vals,__,__): {
			fold(vals, vars, \acc, x -> fsExpVars(x, acc));
		}
		FsCast(e,__,__,__): {
			fsExpVars(e, vars);
		}
		FsIncRc(e,__,__): {
			fsExpVars(e, vars);
		}
		FsVar(name,__,__,__): {
			concat(vars, [ex]);
		}
		FsConst(__,__): vars;
	}
}

fsStatVars(s: FsStat, vars: [FsVar]) -> [FsVar] {
	switch (s) {
		FsIf(cond, s1, s2,__): {
			fsStatVars(s2, fsStatVars(s1, fsExpVars(cond, vars)));
		}
		FsSwitch(x, sw_type, cases,__): {
			fold(cases, fsExpVars(x, vars), \acc, c -> fsStatVars(c.body, acc));
		}
		FsSeq(es,__): {
			fold(es, vars, \acc, x -> fsStatVars(x, acc));
		}
		FsLet(var, e1, s1,__): {
			fsStatVars(s1, fsExpVars(e1, vars));
		}
		FsLet1(var, e1,__): {
			fsExpVars(e1, vars);
		}
		FsVarDef(v, e,__): {
			fsExpVars(e, vars);
		}
		FsWrapExp(e,__): {
			fsExpVars(e, vars);
		}
		FsRet(e,__): {
			fsExpVars(e, vars);
		}
		FsVarDecl(var,__): {
			vars;
		}
		FsAssign(to, what,__): {
			fsExpVars(what, fsExpVars(to, vars));
		}
		FsModRc(__, e,__): {
			fsExpVars(e, vars);
		}
		FsDecRc(e,__): {
			fsExpVars(e, vars);
		}
	}
}

// Traverse the AST backwards and markup the first variable use as last

fsStatLastVarUsage(ex: FsStat, vars: Set<string>, names: FiGlobalNames) -> Pair<FsStat, Set<string>> {
	switch(ex) {
		FsIf(cond, s1, s2,__): {
			p1 = fsStatLastVarUsage(s1, vars, names);
			p2 = fsStatLastVarUsage(s2, vars, names);
			c = fsExpLastVarUsage(cond, mergeSets(p1.second, p2.second), names);
			Pair(
				FsIf(ex with 
					cond = c.first,
					s1 = p1.first,
					s2 = p2.first
				),
				c.second
			);
		}
		FsSwitch(v, type, cases,__): {
			cases_ps = map(cases, \c -> {
				p = fsStatLastVarUsage(c.body, vars, names);
				Pair(FsCase(c with body = p.first), p.second);
			});
			vars1 = fold(cases_ps, vars, \acc, p -> mergeSets(acc, p.second));
			v_p = fsExpLastVarUsage(v, vars1, names);
			Pair(
				FsSwitch(ex with
					x = cast(v_p.first: FsExp -> FsVar),
					cases = map(cases_ps, \p -> p.first)
				),
				v_p.second
			);
		}
		FsSeq(ss,__): {
			ps = foldr(ss, Pair([], vars), \acc, x -> {
				p = fsStatLastVarUsage(x, acc.second, names);
				Pair(concat([p.first], acc.first), p.second);
			});
			Pair(
				FsSeq(ex with ss = ps.first),
				ps.second
			);
		}
		FsLet(__, e1, s1,__): {
			p1 = fsStatLastVarUsage(s1, vars, names);
			p2 = fsExpLastVarUsage(e1, p1.second, names);
			Pair(
				FsLet(ex with 
					e = p2.first,
					s = p1.first
				),
				p2.second
			);
		}
		FsLet1(__, e1,__): {
			p2 = fsExpLastVarUsage(e1, vars, names);
			Pair(
				FsLet1(ex with 
					e = p2.first
				),
				p2.second
			);
		}
		FsAssign(to, what,__): {
			p1 = fsExpLastVarUsage(what, vars, names);
			p2 = fsExpLastVarUsage(to, p1.second, names);
			Pair(
				FsAssign(ex with
					to = p2.first,
					what = p1.first
				),
				p2.second
			);
		}
		FsModRc(__, e,__): {
			p = fsExpLastVarUsage(e, vars, names);
			Pair(FsModRc(ex with e = p.first), p.second);
		}
		FsDecRc(e,__): {
			p = fsExpLastVarUsage(e, vars, names);
			Pair(FsDecRc(ex with e = p.first), p.second);
		}
		FsWrapExp(e,__): {
			p = fsExpLastVarUsage(e, vars, names);
			Pair(FsWrapExp(ex with e = p.first), p.second);
		}
		FsRet(e,__): {
			p = fsExpLastVarUsage(e, vars, names);
			Pair(FsRet(ex with e = p.first), p.second);
		}
		FsVarDef(v, e,__): {
			fail("obsolete: " + toStringFormatted(ex));
			p = fsExpLastVarUsage(e, vars, names);
			Pair(
				FsVarDef(ex with 
					var = FsVar(v with last = !containsSet(p.second, v.name)),
					e = p.first
				),
				insertSet(p.second, v.name)
			);
		}
		FsVarDecl(var,__): {
			Pair(ex, vars);
		}
	}
}

fsExpLastVarUsage(ex: FsExp, vars: Set<string>, names: FiGlobalNames) -> Pair<FsExp, Set<string>> {
	update_var : (FsVar, Set<string>) -> Pair<FsVar, Set<string>> = \var, vs -> Pair(
		FsVar(var with last = !containsSet(vs, var.name) && !fiIsGlobal(var.name, names)),
		insertSet(vs, var.name)
	);
	switch(ex) {
		FsLambda(closure, args, body, __,__): {
			p_b = fsStatLastVarUsage(body, makeSet(), names);
			p_args = foldr(args, Pair([], p_b.second), \acc, v -> {
				p_v = update_var(v, acc.second);
				Pair(concat([p_v.first], acc.first), p_v.second);
			});
			p_cl = foldr(closure, Pair([], vars), \acc, v -> {
				p_v = update_var(v, acc.second);
				Pair(concat([p_v.first], acc.first), p_v.second);
			});
			Pair(
				FsLambda(ex with 
					closure = p_cl.first,
					args = p_args.first,
					body = p_b.first
				), 
				p_cl.second
			);
		}
		FsCall(fn, args, __,__): {
			ps = foldr(args, Pair([], vars), \acc, x -> {
				p = fsExpLastVarUsage(x, acc.second, names);
				Pair(concat([p.first], acc.first), p.second);
			});
			fp = fsExpLastVarUsage(fn, ps.second, names);
			Pair(
				FsCall(ex with
					f = fp.first,
					args = ps.first
				),
				fp.second
			);
		}
		FsCast(e, from, type,__): {
			pe = fsExpLastVarUsage(e, vars, names);
			Pair(FsCast(ex with e = pe.first), pe.second);
		}
		FsCallPrim(op, es, __,__): {
			ps = foldr(es, Pair([], vars), \acc, x -> {
				p = fsExpLastVarUsage(x, acc.second, names);
				Pair(concat([p.first], acc.first), p.second);
			});
			Pair(FsCallPrim(ex with es = ps.first), ps.second);
		}
		FsTailCall(__,vals,__,__): {
			ps = foldr(vals, Pair([], vars), \acc, x -> {
				p = fsExpLastVarUsage(x, acc.second, names);
				Pair(concat([p.first], acc.first), p.second);
			});
			Pair(FsTailCall(ex with vals = ps.first), ps.second);
		}
		FsIncRc(e, type,__): {
			pe = fsExpLastVarUsage(e, vars, names);
			Pair(FsIncRc(ex with e = pe.first), pe.second);
		}
		FsVar(name, last,__,__): {
			update_var(ex, vars);
		}
		FsConst(__,__): Pair(ex, vars);
	}
}
*/

/*fsStatOptimize(s: FsStat) -> FsStat {
	switch (s) {
		FsSeq(ss): {
			equal_e = \e1, e2 -> switch (e1) {
				FsVar(name1,__,__):
					switch (e2) {
						FsVar(name2,__,__): name1 == name2;
						default: false;
					}
				default: false;
			}
			delta = \x1, x2 -> {
				switch (x1) {
					FsMemory(op1, e1): {
						switch (x2) {
							FsMemory(op2, e2): {
								if (!equal_e(e1, e2)) None() else {
									switch (op1) {
										FsIncRc(d1): 
											switch (op2) {
												FsDecRc(d2): Some(Pair(d1 - d2, e1));
												default: None();
											}
										default: None();
									}
								}
							}
							default: None();
						}
					}
					default: None();
				}
			}
			FsSeq(s with 
				ss = transformArrayPairs(
					mapConcat(ss, fsUnwrapSeq), 
					\x1, x2 -> maybeMap(delta(x1, x2), \p ->
						if (p.first == 0) [] else [FsMemory(FsRC(p.first), p.second)]
					)
				)
			);
		}
		default: s;
	}
}
*/
