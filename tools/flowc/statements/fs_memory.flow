import ds/treeutils;
import tools/flowc/statements/fs_transform;

export {
	fsStatPerceus(s: FsStat, names: FiGlobalNames, debug: bool) -> FsStat;
}

FsPerceusAcc(
	id2vars: Tree<int, Set<FsVar>>,
	vars: Set<FsVar>
);

fsMergeStacks(l1: List<Set<FsVar>>, l2: List<Set<FsVar>>) -> List<Set<FsVar>> {
	switch (l1) {
		Cons(s1, t1): {
			switch (l2) {
				Cons(s2, t2): {
					Cons(mergeSets(s1, s2), fsMergeStacks(t1, t2));
				}
				EmptyList(): l1;
			}
		}
		EmptyList(): l2;
	}
}

fsMergeStacks1(l1: List<Pair<Set<FsVar>, int>>, l2: List<Pair<Set<FsVar>, int>>) -> List<Pair<Set<FsVar>, int>> {
	switch (l1) {
		Cons(p1, t1): {
			switch (l2) {
				Cons(p2, t2): {
					Cons(
						Pair(mergeSets(p1.first, p2.first), p1.second), 
						fsMergeStacks1(t1, t2)
					);
				}
				EmptyList(): l1;
			}
		}
		EmptyList(): l2;
	}
}

fsStatPerceus(s: FsStat, names: FiGlobalNames, debug: bool) -> FsStat {
	id_counter = ref 0;
	new_id = \-> {
		id = ^id_counter;
		id_counter := ^id_counter + 1;
		id;
	}
	s1 = cast(fsMap(s, fsIds(new_id), false): FsAll -> FsStat);
	if (debug) {
		println("s1 with ids:\n" +
			//"s:\n" + fs2s(s) + "\n" +
			"s1:\n" + fs2s(s1) + "\n"
			//"s RAW:\n" + toStringFormatted(s1) + "\n"
		);
	}
	show_vars = \vs -> "[" + superglue(set2array(vs), \v -> v.name, ", ") + "]";
	merge_vars = \p1, p2 -> FsPerceusAcc(
		mergeTreeCustom(p1.id2vars, p2.id2vars, \id, x1, x2 -> mergeSets(x1, x2)),
		mergeSets(p1.vars, p2.vars)
	);
	empty_acc = FsPerceusAcc(makeTree(), makeSet());
	id2vars_pre: Tree<int, Set<FsVar>> = fsFold1(s1, Pair(empty_acc, makeList()),
		\acc, x: FsAll -> {
			add_v = \ac, v -> if (fiTypeIsScalar(v.type)) ac else insertSet(ac, v);
			switch (x) {
				FsLambda(closure, args,__,__,__): {
					new_vars = fold(args, fold(closure, makeSet(), \ac, v -> add_v(ac, v)), \ac, v -> add_v(ac, v));
					Pair(FsPerceusAcc(setTree(acc.first.id2vars, x.id, new_vars), new_vars), Cons(acc.first.vars, acc.second));
				}
				FsLet(v, __, id): {
					new_vars = add_v(acc.first.vars, v);
					Pair(FsPerceusAcc(setTree(acc.first.id2vars, x.id, new_vars), new_vars), acc.second);
				}
				default: {
					Pair(FsPerceusAcc(setTree(acc.first.id2vars, x.id, acc.first.vars), acc.first.vars), acc.second);
				}
			}
		},
		\acc, x -> {
			switch (x) {
				FsLambda(__,__,__,__,id): {
					switch (acc.second) {
						Cons(pop_vars, pop_stack): {
							if (debug) {
								println("(A) id=" + i2s(id) + " poping stack: " + show_vars(pop_vars));
							}
							Pair(FsPerceusAcc(acc.first.id2vars, pop_vars), pop_stack);
						}
						default: acc;
					}
				}
				default: acc;
			}
		},
		\args -> args,
		\p1, p2 -> Pair(merge_vars(p1.first, p2.first), fsMergeStacks(p1.second, p2.second))
	).first.id2vars;

	id2vars_post: Tree<int, Set<FsVar>> = fsFold1(s1, Pair(empty_acc, makeList()),
		\acc, x -> {
			switch (x) {
				FsLambda(__,__,__,__,id): {
					if (debug) {
						st = switch (acc.second) {
							Cons(vars,__): show_vars(vars);
							EmptyList(): ""
						}
						println(
							"(B) id=" + i2s(id) + " pushing stack: [" + show_vars(acc.first.vars) + "]\n" +
							"\tacc.second: [" + st + "]\n"
						);
					}
					Pair(
						FsPerceusAcc(setTree(acc.first.id2vars, x.id, makeSet()), makeSet()), 
						Cons(acc.first.vars, acc.second)
					);
				}
				default: acc;
			}
		},
		\acc, x: FsAll -> {
			add_v = \ac, v -> if (fiIsGlobal(v.name, names) || fiTypeIsScalar(v.type)) ac else insertSet(ac, v);
			switch (x) {
				FsLambda(__,__,__,__,__): {
					switch (acc.second) {
						Cons(new_vars, new_stack): {
							if (debug) {
								println("(B) id=" + i2s(x.id) + " poping stack: " + show_vars(new_vars));
							}
							Pair(FsPerceusAcc(setTree(acc.first.id2vars, x.id, acc.first.vars), new_vars), new_stack);
						}
						default: fail0("empty stack pop");
					}
				}
				FsVarUse(v,__,id): {
					new_vars = add_v(acc.first.vars, v);
					Pair(FsPerceusAcc(setTree(acc.first.id2vars, x.id, acc.first.vars), new_vars), acc.second);
				}
				default: {
					Pair(FsPerceusAcc(setTree(acc.first.id2vars, x.id, acc.first.vars), acc.first.vars), acc.second);
				}
			}
		},
		\args -> reverseA(args),
		\p1, p2 -> Pair(merge_vars(p1.first, p2.first), fsMergeStacks(p1.second, p2.second))
	).first.id2vars;

	id2vars_last: Tree<int, Set<FsVar>> = fsFold1(s1, Pair(empty_acc, makeList()),
		\acc, x: FsAll -> {
			pre_vars = lookupTreeDef(id2vars_pre, x.id, makeSet());
			post_vars = lookupTreeDef(id2vars_post, x.id, makeSet());
			diff1 = differenceSets(pre_vars, post_vars);
			diff = differenceSets(diff1, acc.first.vars);
			if (debug) {
				println(
					"(C) x.id: " + i2s(x.id) + "\n" +
					strIndent(
						"pre_vars: " + show_vars(pre_vars) + "\n" +
						"post_vars: " + show_vars(post_vars) + "\n" +
						"acc.first.vars: " + show_vars(acc.first.vars) + "\n" +
						"diff1: " + show_vars(diff1) + "\n" +
						"diff: " + show_vars(diff)
					)
				);
			}
			switch (x) {
				FsLambda(__,__,__,__,id): {
					if (debug) {
						println("(C) id=" + i2s(id) + " pushing stack: " + show_vars(acc.first.vars));
					}
					Pair(FsPerceusAcc(setTree(acc.first.id2vars, x.id, diff), makeSet()), Cons(acc.first.vars, acc.second));
				}
				default: {
					Pair(FsPerceusAcc(setTree(acc.first.id2vars, x.id, diff), mergeSets(acc.first.vars, diff1)), acc.second);
				}
			}
		},
		\acc, x -> {
			switch (x) {
				FsLambda(__,__,__,__,id): {
					switch (acc.second) {
						Cons(vars, t): {
							if (debug) {
								println("(C) id=" + i2s(id) + " poping stack: " + show_vars(vars));
							}
							Pair(FsPerceusAcc(acc.first.id2vars, vars), t);
						}
						default: acc;
					}
				}
				default: acc;
			}
		},
		\args -> args,
		\p1, p2 -> Pair(merge_vars(p1.first, p2.first), fsMergeStacks(p1.second, p2.second))
	).first.id2vars;

	if (debug) {
		set_tree2s = \st -> {
			superglue(tree2pairs(st), \p ->
				i2s(p.first) + ": " + show_vars(p.second), "\n"
			);
		}
		println(
			"id2vars_pre:\n" + set_tree2s(id2vars_pre) + "\n" +
			"id2vars_post:\n" + set_tree2s(id2vars_post) + "\n" +
			"id2vars_last:\n" + set_tree2s(id2vars_last) + "\n" +
			""
		);
	}
	dec_unused = \id, x -> {
		unused = set2array(lookupTreeDef(id2vars_last, id, makeSet()));
		if (debug) {
			println("to dec <" + i2s(id) + "> unused: [" + superglue(unused, \v -> v.name, ", ") + "]");
		}
		if (length(unused) == 0) x else {
			FsSeq(concat(
				map(unused, \v -> FsDecRc(FsVarUse(v, false, -1), -1)),
				fsUnwrapSeq(x)
			), -1);
		}
	}
	rc_markuped = fsMap(s1, \x -> switch (x) {
		FsIf(cond, pos, neg, id):  {
			FsIf(x with s1 = dec_unused(pos.id, pos), s2 = dec_unused(neg.id, neg));
		};
		FsSwitch(__,__, cs,__): {
			FsSwitch(x with cases = map(cs, \c -> FsCase(c with body = dec_unused(c.body.id, c.body))));
		}
		FsWrapExp(e1,__): {
			if (fiTypeIsScalar(fsType(e1))) x else {
				FsDecRc(e1, -1);
			}
		}
		FsVarUse(v, __, id): {
			if (fiIsGlobalFunction(v.name, names) || fiTypeIsScalar(v.type)) x  else {
				unused = lookupTreeDef(id2vars_last, id, makeSet());
				if (!containsSet(unused, v)) {
					FsVarUse(x with incRc = true);
				} else {
					x;
				}
			}
		}
		FsLambda(__,__, body,__,id): {
			FsLambda(x with body = dec_unused(id, body));
		}
		default: x;
	}, true);

	// Pull the closure incRc operations from let statements for lambdas
	cast(fsMap(rc_markuped, \x -> switch (x) {
		FsLet(__,e,__): {
			switch (e) {
				FsClosure(vars, lambda,__): {
					inc_closure = filter(vars, \v -> v.incRc);
					if (length(inc_closure) == 0) x else {
						//lambda = FsLambda(e with closure = map(closure, \v -> FsVarUse(v with incRc = false)));
						//let = FsLet(x with e = lambda);
						//FsSeq(concat(map(inc_closure, \v -> FsWrapExp(v, -1)), [let]), -1);
						FsSeq(concat(map(inc_closure, \v -> FsWrapExp(v, -1)), [x]), -1);
					}
				}
				default: x;
			}
		}
		default: x;
	}, true): FsAll -> FsStat);
}

fsIds(new_id: () -> int) -> (FsAll) -> FsAll {
	\s -> switch(s) {
		FsIf(__,__,__,__):        FsIf(s with id = new_id());
		FsSwitch(__,__,__,__):    FsSwitch(s with id = new_id());
		FsSeq(__, __):            FsSeq(s with id = new_id());
		FsWrapExp(__,__):         FsWrapExp(s with id = new_id());
		FsRet(__,__):             FsRet(s with id = new_id());
		FsAssign(__,__,__):       FsAssign(s with id = new_id());
		FsIncRc(__,__,__):        FsIncRc(s with id = new_id());
		FsDecRc(__,__):           FsDecRc(s with id = new_id());
		FsLet(__,__,__):          FsLet(s with id = new_id());
		FsClosure(__,__,__):      FsClosure(s with id = new_id());
		FsLambda(__,__,__,__,__): FsLambda(s with id = new_id());
		FsCall(__,__,__,__):      FsCall(s with id = new_id());
		FsCallPrim(__,__,__,__):  FsCallPrim(s with id = new_id());
		FsCast(__,__,__,__):      FsCast(s with id = new_id());
		FsConst(__,__):           FsConst(s with id = new_id());
		FsTailCall(__,__,__,__):  FsTailCall(s with id = new_id());
		FsVarUse(__,__,__):       FsVarUse(s with id = new_id()); 
	}
}
