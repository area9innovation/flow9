import ds/array;
import ds/multiset;
import tools/flowc/incremental/fi_helpers;
import tools/flowc/statements/fs_transform;

export {
	//fsStatPerceus(s: FsStat) -> FsStat;
	fsExpPerceus(e: FsExp, name: string) -> FsExp;
}
/*
fsStatPerceus(s: FsStat) -> FsStat {
	s1 = fsStatLastVarUsage(s, makeSet()).first;
	fsStatTransform(fsDoStatPerceus(s1, FsPerceusEnv(makeSet())), fsStatOptimize, idfn);
}
*/
do_perceus_debug  = ref false;

FsPerceusEnv(
	caseArgs: Set<string>
);

fsExpPerceus(e: FsExp, name: string) -> FsExp {
	do_perceus_debug := name == "main";
	//fsTraverseExpLasVarUsage(e, makeSet());
	e1 = fsExpLastVarUsage(e, makeSet()).first;
	/*if (^do_perceus_debug) {
		println(
			"EXP:\n" + fsExp2s(e) + "\n\n" + 
			"EXP1:\n" + fsExp2s(e1)
		);
	}*/
	e2 = fsExpFirstVarUsage(e1, makeSet()).first;
	fsExpTransform(fsDoExpPerceus(e2), fsStatOptimize, idfn);
	//fsDoExpPerceus(e2);
}

MemOps(pre: [FsMemory], post: [FsMemory]);

fsDoStatPerceus(s: FsStat, env: FsPerceusEnv) -> FsStat {
	switch (s) {
		FsIf(cond, s1, s2, __,__): {
			expOps = fsExpMemOps(cond);
			fsWrapSeq(concat(
				expOps.pre,
				[FsIf(s with
					cond = fsDoExpPerceus(cond),
					s1 = fsWrapSeq(concat(expOps.post, fsUnwrapSeq(fsDoStatPerceus(s1, env)))),
					s2 = fsWrapSeq(concat(expOps.post, fsUnwrapSeq(fsDoStatPerceus(s2, env))))
				)]
			));
		}
		FsSwitch(x, sw_type, cases,__,__): {
			xOps = fsExpMemOps(x);
			fsWrapSeq(concat(
				xOps.pre,
				[FsSwitch(s with 
					cases = map(cases, \c -> {
						env1 = FsPerceusEnv(env with 
							caseArgs = fold(c.args, env.caseArgs, \acc, arg -> 
								insertSet(acc, arg.name)
							)
						);
						FsCase(c with 
							body = fsWrapSeq(concat(
								xOps.post, 
								fsUnwrapSeq(fsDoStatPerceus(c.body, env1))
							))
						)
					})
				)]
			));
		}
		FsSeq(es, type,__): {
			fsWrapSeq(concatA(
				map(es, \x -> fsUnwrapSeq(fsDoStatPerceus(x, env)))
			));
		}
		FsLet(v, e, s1, __,start): {
			eOps = fsExpMemOps(e);
			/*env1 = if (!containsSet(env.caseArgs, v.name)) env else {
				FsPerceusEnv(env with caseArgs = removeSet(env.caseArgs, v.name));
			}
			post = concat(eOps.post, fsUnwrapSeq(fsDoStatPerceus(s1, env1)));
			post1 = if (!containsSet(env.caseArgs, v.name)) post else {
				concat([FsMemory(FsDup(), v, start)], post);
			}*/
			fsWrapSeq(concat(
				eOps.pre,
				[FsLet(s with
					e = fsDoExpPerceus(e),
					//s = fsWrapSeq(post1)
					s = fsWrapSeq(concat(eOps.post, fsUnwrapSeq(fsDoStatPerceus(s1, env))))
				)]
			));
		}
		FsWrapExp(e,__): {
			eOps = fsExpMemOps(e);
			fsWrapSeq(concat3(eOps.pre, [FsWrapExp(s with e = fsDoExpPerceus(e))], eOps.post));
		}
		FsRet(e,__): {
			FsRet(s with e = fsDoExpPerceus(e));
		}
		FsTailCall(__): {
			s;
		}
		FsVarDecl(var,__): {
			s;
		}
		FsAssign(to, what,__): {
			toOps = fsExpMemOps(to);
			whatOps = fsExpMemOps(what);
			fsWrapSeq(concat3(
				concat3(toOps.pre, toOps.post, whatOps.pre),
				[FsAssign(s with to = fsDoExpPerceus(to), what = fsDoExpPerceus(what))],
				whatOps.post
			));
		}
		FsMemory(op, e,__): {
			FsMemory(s with e = fsDoExpPerceus(e));
		}
	}
}

fsExpMemOps(ex: FsExp) -> MemOps {
	vars1 = multiSet2pairs(fsExpVars(ex, makeMultiSet()));
	if (exists(vars1, \p -> p.second > 1)) {
		println("exists(vars1, \\p -> p.second > 1):\n" + fsExp2s(ex));
	}
	vars2 = filter(vars1, \v -> !fiTypeIsScalar(v.first.type) && !fsVarIsGlobalFunc(v.first.traits));
	// Filter out arguemnt vars, which are used exactly once in each go-through function body path 
	vars = filter(vars2, \v -> 
		switch (v.first.traits.kind) {
			FsVarTmp(): false;
			default: true;
		}
	);
	to_dup = \v -> {
		c1 = if (v.first.traits.lastUse) v.second - 1 else v.second;
		// Global variables should be bumped ref counter by 1
		if (fsVarIsGlobal(v.first.traits)) c1 + 1 else c1;
	}
	to_drop = \v -> -v.second;
	MemOps(
		filtermap(vars, \v -> 
			if (to_dup(v) == 0) None() else Some(FsMemory(FsRC(to_dup(v)), v.first, v.first.start))
		),
		map(vars, \v -> 
			FsMemory(FsRC(to_drop(v)), v.first, v.first.start)
		)
	);
	/*
	to_dup = \v -> v.traits.firstUse && !v.traits.lastUse;
	to_drop = \v -> !(fiTypeIsScalar(v.type)) && !fsVarIsGlobalFunc(v.traits) && v.traits.lastUse;
	MemOps(
		filtermap(vars, \v -> 
			if (to_dup(v)) Some(FsMemory(FsIncRC(), v, v.start)) else None()
		),
		filtermap(vars, \v -> 
			if (to_drop(v)) Some(FsMemory(if (v.traits.firstUse) FsCheckRC() else FsDecRC(), v, v.start)) else None()
		)
	);
	*/
}

fsExpVars(ex: FsExp, vars: MultiSet<FsVar>) -> MultiSet<FsVar> {
	switch (ex) {
		FsCall(f, args, type,__): {
			fold(args, fsExpVars(f, vars), \acc, x -> fsExpVars(x, acc));
		}
		FsLambda(toplevel, closure, args, body, type,__): {
			fold(closure, vars, \acc, x -> insertMultiSet(acc, x));
		}
		FsCallPrim(op, es, type,__): {
			fold(es, vars, \acc, x -> fsExpVars(x, acc));
		}
		FsVar(name,__,__,__): {
			insertMultiSet(vars, ex);
		}
		FiString(s, __): vars;
		FiVoid(__):      vars;
		FiBool(b, __):   vars;
		FiInt(i, __):    vars;
		FiDouble(d, __): vars;
	}
}

fsStatLocals(ex: FsExp, vars: MultiSet<FsVar>) -> MultiSet<FsVar> {
	switch (ex) {
		FsCall(f, args, type,__): {
			fold(args, fsExpVars(f, vars), \acc, x -> fsExpVars(x, acc));
		}
		FsLambda(toplevel, closure, args, body, type,__): {
			vars;
		}
		FsCallPrim(op, es, type,__): {
			fold(es, vars, \acc, x -> fsExpVars(x, acc));
		}
		FsVar(name, __,__,__): {
			insertMultiSet(vars, ex);
		}
		FiString(s, __): vars;
		FiVoid(__):      vars;
		FiBool(b, __):   vars;
		FiInt(i, __):    vars;
		FiDouble(d, __): vars;
	}
}

fsDoExpPerceus(ex: FsExp) -> FsExp {
	switch (ex) {
		FsCall(f, args, type,__): {
			FsCall(ex with
				f = fsDoExpPerceus(f),
				args = map(args, fsDoExpPerceus)
			);
		}
		FsLambda(toplevel, closure, args, body, type, start): {
			FsLambda(ex with body = fsDoStatPerceus(body, FsPerceusEnv(makeSet())));
		}
		FsCallPrim(op, es, type,__): {
			FsCallPrim(ex with es = map(es, fsDoExpPerceus));
		}
		FsVar(name,__,__,__): ex;
		FiString(s, __): ex;
		FiVoid(__):      ex;
		FiBool(b, __):   ex;
		FiInt(i, __):    ex;
		FiDouble(d, __): ex;
	}
}

fsStatOptimize(s: FsStat) -> FsStat {
	switch (s) {
		FsSeq(ss, type,__): {
			equal_e = \e1, e2 -> switch (e1) {
				FsVar(name1,__,__,__):
					switch (e2) {
						FsVar(name2,__,__,__): name1 == name2;
						default: false;
					}
				default: false;
			}
			delta = \x1, x2 -> {
				switch (x1) {
					FsMemory(op1, e1, __): {
						switch (x2) {
							FsMemory(op2, e2, __): {
								if (!equal_e(e1, e2)) None() else {
									switch (op1) {
										FsRC(d1): 
											switch (op2) {
												FsRC(d2): Some(Pair(d1 + d2, e1));
												default: None();
											}
										default: None();
									}
								}
							}
							default: None();
						}
					}
					default: None();
				}
			}
			FsSeq(s with 
				ss = transformArrayPairs(
					mapConcat(ss, fsUnwrapSeq), 
					\x1, x2 -> maybeMap(delta(x1, x2), \p ->
						if (p.first == 0) [] else [FsMemory(FsRC(p.first), p.second, 0)]
					)
				)
			);
		}
		default: s;
	}
}


// Traverse the AST backwards and markup the first variable use as last

fsStatLastVarUsage(ex: FsStat, vars: Set<string>) -> Pair<FsStat, Set<string>> {
	switch(ex) {
		FsLet(v, e, s1, __,__): {
			p1 = fsStatLastVarUsage(s1, vars);
			p2 = fsExpLastVarUsage(e, p1.second);
			Pair(
				FsLet(ex with 
					var = FsVar(v with traits = FsVarTraits(v.traits with lastUse = !containsSet(p1.second, v.name))),
					e = p2.first,
					s = p1.first
				),
				insertSet(p2.second, v.name)
			);
		}
		FsIf(cond, s1, s2, __,__): {
			p1 = fsStatLastVarUsage(s1, vars);
			p2 = fsStatLastVarUsage(s2, vars);
			c = fsExpLastVarUsage(cond, mergeSets(p1.second, p2.second));
			Pair(
				FsIf(ex with 
					cond = c.first,
					s1 = p1.first,
					s2 = p2.first
				),
				c.second
			);
		}
		FsSwitch(v, type, cases, __,__): {
			cases_ps = map(cases, \c -> {
				p = fsStatLastVarUsage(c.body, vars);
				Pair(FsCase(c with body = p.first), p.second);
			});
			vars1 = fold(cases_ps, vars, \acc, p -> mergeSets(acc, p.second));
			Pair(
				FsSwitch(ex with
					x = FsVar(v with traits = FsVarTraits(v.traits with lastUse = !containsSet(vars1, v.name))),
					cases = map(cases_ps, \p -> p.first)
				),
				insertSet(vars1, v.name)
			);
		}
		FsSeq(ss, __,__): {
			ps = foldr(ss, Pair([], vars), \acc, x -> {
				p = fsStatLastVarUsage(x, acc.second);
				Pair(concat([p.first], acc.first), p.second);
			});
			Pair(
				FsSeq(ex with ss = ps.first),
				ps.second
			);
		}
		FsAssign(to, what, __): {
			p1 = fsExpLastVarUsage(what, vars);
			p2 = fsExpLastVarUsage(to, p1.second);
			Pair(
				FsAssign(ex with
					to = p2.first,
					what = p1.first
				),
				p2.second
			);
		}
		FsMemory(op, e, __): {
			p = fsExpLastVarUsage(e, vars);
			Pair(FsMemory(ex with e = p.first), p.second);
		}
		FsWrapExp(e, start): {
			p = fsExpLastVarUsage(e, vars);
			Pair(FsWrapExp(ex with e = p.first), p.second);
		}
		FsRet(e, start): {
			p = fsExpLastVarUsage(e, vars);
			Pair(FsRet(ex with e = p.first), p.second);
		}
		FsTailCall(start): {
			Pair(ex, vars);
		}
		FsVarDecl(var, start): {
			Pair(ex, vars);
		}
	}
}

fsExpLastVarUsage(ex: FsExp, vars: Set<string>) -> Pair<FsExp, Set<string>> {
	switch(ex) {
		FsLambda(toplevel, closure, args, body, __,__): {
			p = fsStatLastVarUsage(body, makeSet());
			Pair(FsLambda(ex with body = p.first), vars);
		}
		FsCall(fn, args, __,__): {
			ps = fold(args, Pair([], vars), \acc, x -> {
				p = fsExpLastVarUsage(x, acc.second);
				Pair(concat(acc.first, [p.first]), p.second);
			});
			fp = fsExpLastVarUsage(fn, ps.second);
			Pair(
				FsCall(ex with
					f = fp.first,
					args = ps.first
				),
				fp.second
			);
		}
		FsCallPrim(op, es, __,__): {
			ps = foldr(es, Pair([], vars), \acc, x -> {
				p = fsExpLastVarUsage(x, acc.second);
				Pair(concat([p.first], acc.first), p.second);
			});
			Pair(FsCallPrim(ex with es = ps.first), ps.second);
		}
		FsVar(name, traits,__,__): {
			Pair(
				FsVar(ex with traits = FsVarTraits(traits with lastUse = !containsSet(vars, name))), 
				insertSet(vars, name)
			);
		}
		default: Pair(ex, vars);
	}
}

// Traverse the AST straight and markup the first variable use as first

fsStatFirstVarUsage(ex: FsStat, vars: Set<string>) -> Pair<FsStat, Set<string>> {
	switch(ex) {
		FsLet(v, e, s1, __,__): {
			p1 = fsExpFirstVarUsage(e, vars);
			p2 = fsStatFirstVarUsage(s1, p1.second);
			Pair(
				FsLet(ex with
					e = p1.first,
					s = p2.first
				),
				p2.second
			);
		}
		FsIf(cond, s1, s2, __,__): {
			c = fsExpFirstVarUsage(cond, vars);
			p1 = fsStatFirstVarUsage(s1, c.second);
			p2 = fsStatFirstVarUsage(s2, c.second);
			Pair(
				FsIf(ex with 
					cond = c.first,
					s1 = p1.first,
					s2 = p2.first
				),
				mergeSets(p1.second, p2.second)
			);
		}
		FsSwitch(v, type, cases, __,__): {
			vars1 = insertSet(vars, v.name);
			cases_ps = map(cases, \c -> {
				p = fsStatFirstVarUsage(c.body, vars1);
				Pair(FsCase(c with body = p.first), p.second);
			});
			Pair(
				FsSwitch(ex with
					x = FsVar(v with traits = FsVarTraits(v.traits with firstUse = !containsSet(vars, v.name))),
					cases = map(cases_ps, \p -> p.first)
				),
				fold(cases_ps, vars1, \acc, p -> mergeSets(acc, p.second))
			);
		}
		FsSeq(ss, __,__): {
			ps = fold(ss, Pair([], vars), \acc, x -> {
				p = fsStatFirstVarUsage(x, acc.second);
				Pair(concat(acc.first, [p.first]), p.second);
			});
			Pair(
				FsSeq(ex with ss = ps.first),
				ps.second
			);
		}
		FsAssign(to, what, __): {
			p1 = fsExpFirstVarUsage(what, vars);
			p2 = fsExpFirstVarUsage(to, vars);
			Pair(
				FsAssign(ex with
					to = p2.first,
					what = p1.first
				),
				mergeSets(p1.second, p2.second)
			);
		}
		FsMemory(op, e, __): {
			p = fsExpFirstVarUsage(e, vars);
			Pair(FsMemory(ex with e = p.first), p.second);
		}
		FsWrapExp(e, start): {
			p = fsExpFirstVarUsage(e, vars);
			Pair(FsWrapExp(ex with e = p.first), p.second);
		}
		FsRet(e, start): {
			p = fsExpFirstVarUsage(e, vars);
			Pair(FsRet(ex with e = p.first), p.second);
		}
		FsTailCall(start): {
			Pair(ex, vars);
		}
		FsVarDecl(var, start): {
			Pair(ex, vars);
		}
	}
}

fsExpFirstVarUsage(ex: FsExp, vars: Set<string>) -> Pair<FsExp, Set<string>> {
	switch(ex) {
		FsLambda(toplevel, closure, args, body, __,__): {
			p = fsStatFirstVarUsage(body, makeSet());
			Pair(FsLambda(ex with body = p.first), p.second);
		}
		FsCall(fn, args, __,__): {
			fp = fsExpFirstVarUsage(fn, vars);
			ps = fold(args, Pair([], fp.second), \acc, x -> {
				p = fsExpFirstVarUsage(x, acc.second);
				Pair(concat(acc.first, [p.first]), p.second);
			});
			Pair(
				FsCall(ex with
					f = fp.first,
					args = ps.first
				),
				ps.second
			);
		}
		FsCallPrim(op, es, __,__): {
			ps = fold(es, Pair([], vars), \acc, x -> {
				p = fsExpFirstVarUsage(x, acc.second);
				Pair(concat(acc.first, [p.first]), p.second);
			});
			Pair(FsCallPrim(ex with es = ps.first), ps.second);
		}
		FsVar(name, traits,__,__): {
			Pair(
				FsVar(ex with traits = FsVarTraits(traits with firstUse = !containsSet(vars, name))), 
				insertSet(vars, name)
			);
		}
		default: Pair(ex, vars);
	}
}
