import ds/treeutils;
import tools/flowc/statements/fs_transform;

export {
	fsStatPerceus(s: FsStat, debug: bool) -> FsStat;
}

FsPerceusAcc(
	id2vars: Tree<int, Set<FsVar>>,
	vars: Set<FsVar>
);

fsMergeStacks(l1: List<Set<FsVar>>, l2: List<Set<FsVar>>) -> List<Set<FsVar>> {
	switch (l1) {
		Cons(s1, t1): {
			switch (l2) {
				Cons(s2, t2): {
					Cons(mergeSets(s1, s2), fsMergeStacks(t1, t2));
				}
				EmptyList(): l1;
			}
		}
		EmptyList(): l2;
	}
}

fsStatPerceus(s: FsStat, debug: bool) -> FsStat {
	id_counter = ref 0;
	new_id = \-> {
		id = ^id_counter;
		id_counter := ^id_counter + 1;
		id;
	}
	s1 = cast(fsMap(s, fsIds(new_id), false): FsAll -> FsStat);
	if (debug) {
		println("s1 with ids:\n" +
			//"s:\n" + fs2s(s) + "\n" +
			"s1:\n" + fs2s(s1) + "\n"
			//"s RAW:\n" + toStringFormatted(s1) + "\n"
		);
	}
	show_vars = \vs -> "[" + superglue(set2array(vs), \v -> v.name, ", ") + "]";
	merge_vars = \p1, p2 -> FsPerceusAcc(
		mergeTreeCustom(p1.id2vars, p2.id2vars, \id, x1, x2 -> mergeSets(x1, x2)),
		mergeSets(p1.vars, p2.vars)
	);
	empty_acc = FsPerceusAcc(makeTree(), makeSet());
	id2vars_pre: Tree<int, Set<FsVar>> = fsFold1(s1, Pair(empty_acc, makeList()),
		\acc, x: FsAll -> {
			add_v = \ac, v -> if (fiTypeIsScalar(v.type)) ac else insertSet(ac, v);
			switch (x) {
				FsLambda(closure, args,__,__,__): {
					new_vars = fold(args, fold(closure, makeSet(), \ac, v -> add_v(ac, v)), \ac, v -> add_v(ac, v));
					Pair(FsPerceusAcc(setTree(acc.first.id2vars, x.id, new_vars), new_vars), Cons(acc.first.vars, acc.second));
				}
				FsLet(v, __, id): {
					new_vars = add_v(acc.first.vars, v);
					Pair(FsPerceusAcc(setTree(acc.first.id2vars, x.id, new_vars), new_vars), acc.second);
				}
				default: {
					Pair(FsPerceusAcc(setTree(acc.first.id2vars, x.id, acc.first.vars), acc.first.vars), acc.second);
				}
			}
		},
		\acc, x -> {
			switch (x) {
				FsLambda(__,__,__,__,id): {
					switch (acc.second) {
						Cons(pop_vars, pop_stack): {
							if (debug) {
								println("(A) id=" + i2s(id) + " poping stack: " + show_vars(pop_vars));
							}
							Pair(FsPerceusAcc(acc.first.id2vars, pop_vars), pop_stack);
						}
						default: acc;
					}
				}
				default: acc;
			}
		},
		\args -> args,
		\p1, p2 -> Pair(merge_vars(p1.first, p2.first), fsMergeStacks(p1.second, p2.second))
	).first.id2vars;

	id2vars_post: Tree<int, Set<FsVar>> = fsFold1(s1, Pair(empty_acc, makeList()),
		\acc, x -> {
			switch (x) {
				FsLambda(__,__,__,__,id): {
					if (debug) {
						st = switch (acc.second) {
							Cons(vars,__): show_vars(vars);
							EmptyList(): ""
						}
						println(
							"(B) id=" + i2s(id) + " pushing stack: [" + show_vars(acc.first.vars) + "]\n" +
							"\tacc.second: [" + st + "]\n"
						);
					}
					Pair(
						FsPerceusAcc(setTree(acc.first.id2vars, x.id, makeSet()), makeSet()), 
						Cons(acc.first.vars, acc.second)
					);
				}
				default: acc;
			}
		},
		\acc, x: FsAll -> {
			add_v = \ac, v -> if (fiTypeIsScalar(v.type)) ac else insertSet(ac, v);
			switch (x) {
				FsLambda(__,__,__,__,__): {
					switch (acc.second) {
						Cons(new_vars, new_stack): {
							if (debug) {
								println("(B) id=" + i2s(x.id) + " poping stack: " + show_vars(new_vars));
							}
							Pair(FsPerceusAcc(setTree(acc.first.id2vars, x.id, acc.first.vars), new_vars), new_stack);
						}
						default: fail0("empty stack pop");
					}
				}
				FsVarUse(v, local, id): {
					new_vars = if (local) add_v(acc.first.vars, v) else acc.first.vars;
					Pair(FsPerceusAcc(setTree(acc.first.id2vars, x.id, acc.first.vars), new_vars), acc.second);
				}
				default: {
					Pair(FsPerceusAcc(setTree(acc.first.id2vars, x.id, acc.first.vars), acc.first.vars), acc.second);
				}
			}
		},
		\args -> reverseA(args),
		\p1, p2 -> Pair(merge_vars(p1.first, p2.first), fsMergeStacks(p1.second, p2.second))
	).first.id2vars;

	id2vars_last: Tree<int, Set<FsVar>> = fsFold1(s1, Pair(empty_acc, makeList()),
		\acc, x: FsAll -> {
			pre_vars = lookupTreeDef(id2vars_pre, x.id, makeSet());
			post_vars = lookupTreeDef(id2vars_post, x.id, makeSet());
			diff1 = differenceSets(pre_vars, post_vars);
			diff = differenceSets(diff1, acc.first.vars);
			if (debug) {
				println(
					"(C) x.id: " + i2s(x.id) + "\n" +
					strIndent(
						"pre_vars: " + show_vars(pre_vars) + "\n" +
						"post_vars: " + show_vars(post_vars) + "\n" +
						"acc.first.vars: " + show_vars(acc.first.vars) + "\n" +
						"diff1: " + show_vars(diff1) + "\n" +
						"diff: " + show_vars(diff)
					)
				);
			}
			switch (x) {
				FsLambda(__,__,__,__,id): {
					if (debug) {
						println("(C) id=" + i2s(id) + " pushing stack: " + show_vars(acc.first.vars));
					}
					Pair(FsPerceusAcc(setTree(acc.first.id2vars, x.id, diff), makeSet()), Cons(acc.first.vars, acc.second));
				}
				default: {
					Pair(FsPerceusAcc(setTree(acc.first.id2vars, x.id, diff), mergeSets(acc.first.vars, diff1)), acc.second);
				}
			}
		},
		\acc, x -> {
			switch (x) {
				FsLambda(__,__,__,__,id): {
					switch (acc.second) {
						Cons(vars, t): {
							if (debug) {
								println("(C) id=" + i2s(id) + " poping stack: " + show_vars(vars));
							}
							Pair(FsPerceusAcc(acc.first.id2vars, vars), t);
						}
						default: acc;
					}
				}
				default: acc;
			}
		},
		\args -> args,
		\p1, p2 -> Pair(merge_vars(p1.first, p2.first), fsMergeStacks(p1.second, p2.second))
	).first.id2vars;

	if (debug) {
		set_tree2s = \st -> {
			superglue(tree2pairs(st), \p ->
				i2s(p.first) + ": " + show_vars(p.second), "\n"
			);
		}
		println(
			"id2vars_pre:\n" + set_tree2s(id2vars_pre) + "\n" +
			"id2vars_post:\n" + set_tree2s(id2vars_post) + "\n" +
			"id2vars_last:\n" + set_tree2s(id2vars_last) + "\n" +
			""
		);
	}
	dec_unused = \id, x -> {
		unused = set2array(lookupTreeDef(id2vars_last, id, makeSet()));
		if (debug) {
			println("to dec <" + i2s(id) + "> unused: [" + superglue(unused, \v -> v.name, ", ") + "]");
		}
		if (length(unused) == 0) x else {
			FsSeq(concat(
				map(unused, \v -> FsDecRc(FsVarUse(v, true, -1), -1)),
				fsUnwrapSeq(x)
			), -1);
		}
	}
	add_incs = \e: FsExp, x: FsStat -> {
		incs = tree2pairs(fsExpVarIncs(e, makeTree(), id2vars_last));
		if (debug) {
			println("incs for <" + i2s(e.id) + ">: [" + superglue(incs, \p -> p.first.name + "=" + i2s(p.second), ", "  ) + "]");
		}
		if (length(incs) == 0) x else {
			FsSeq(concat(
				map(incs, \p -> FsIncRc(p.second, FsVarUse(p.first, true, -1), -1)),
				fsUnwrapSeq(x)
			), -1);
		}
	}
	cast(fsMap(s1, \x -> switch (x) {
		FsIf(cond, pos, neg, id):  {
			add_incs(cond, 
				FsIf(x with 
					s1 = dec_unused(pos.id, pos),
					s2 = dec_unused(neg.id, neg)
				)
			);
		};
		FsSwitch(v,__, cs,__): {
			add_incs(v, 
				FsSwitch(x with 
					cases = map(cs, \c ->
						FsCase(c with body = dec_unused(c.body.id, c.body))
					)
				)
			);
		}
		FsRet(e,__): {
			add_incs(e, x);
		}
		FsWrapExp(e,__): {
			x1 = if (fiTypeIsScalar(fsType(e))) x else {
				FsDecRc(e, -1);
			}
			add_incs(e, x1);
		}
		FsLet(__,e,__): {
			add_incs(e, x);
		}
		FsAssign(to, what,__): {
			add_incs(to, add_incs(what, x));
		}
		FsIncRc(__,__,__): fail0("FsIncRc met during memory operations markup");
		FsDecRc(__,__): fail0("FsDecRc met during memory operations markup");
		FsLambda(__,__, body,__,id): {
			FsLambda(x with body = dec_unused(id, body));
		}
		default: x;
	}, true): FsAll -> FsStat);
}

fsExpVarIncs(e: FsExp, acc: Tree<FsVar, int>, last: Tree<int, Set<FsVar>>) -> Tree<FsVar, int> {
	switch (e) {
		FsClosure(closure, __,__): {
			fold(closure, acc, \ac, x -> fsExpVarIncs(x, ac, last));
		}
		FsCall(f, args,__,__): {
			fold(args, fsExpVarIncs(f, acc, last), \ac, x ->
				fsExpVarIncs(x, ac, last)
			);
		}
		FsCallPrim(__, es,__,__): {
			fold(es, acc, \ac, x -> fsExpVarIncs(x, ac, last));
		}
		FsTailCall(args, vals, type, id): {
			fold(vals, acc, \ac, x -> fsExpVarIncs(x, ac, last));
		}
		FsCast(e1,__,__,__): {
			fsExpVarIncs(e1, acc, last);
		}
		FsVarUse(x, local, id): {
			if ((!local && fiTypeIsFunction(x.type)) || fiTypeIsScalar(x.type) || containsSet(lookupTreeDef(last, id, makeSet()), x)
			) acc else {
				setTree(acc, x, lookupTreeDef(acc, x, 0) + 1);
			}
		}
		FsConst(c, id): acc;
	}
}

fsIds(new_id: () -> int) -> (FsAll) -> FsAll {
	\s -> switch(s) {
		FsIf(__,__,__,__):        FsIf(s with id = new_id());
		FsSwitch(__,__,__,__):    FsSwitch(s with id = new_id());
		FsSeq(__, __):            FsSeq(s with id = new_id());
		FsWrapExp(__,__):         FsWrapExp(s with id = new_id());
		FsRet(__,__):             FsRet(s with id = new_id());
		FsAssign(__,__,__):       FsAssign(s with id = new_id());
		FsIncRc(__,__,__):        FsIncRc(s with id = new_id());
		FsDecRc(__,__):           FsDecRc(s with id = new_id());
		FsLet(__,__,__):          FsLet(s with id = new_id());
		FsClosure(__,__,__):      FsClosure(s with id = new_id());
		FsLambda(__,__,__,__,__): FsLambda(s with id = new_id());
		FsCall(__,__,__,__):      FsCall(s with id = new_id());
		FsCallPrim(__,__,__,__):  FsCallPrim(s with id = new_id());
		FsCast(__,__,__,__):      FsCast(s with id = new_id());
		FsConst(__,__):           FsConst(s with id = new_id());
		FsTailCall(__,__,__,__):  FsTailCall(s with id = new_id());
		FsVarUse(__,__,__):       FsVarUse(s with id = new_id());
	}
}
