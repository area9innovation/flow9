import ds/treeutils;
import tools/flowc/statements/fs_transform;

export {
	fsStatPerceus(s: FsStat, debug: bool) -> FsStat;
}

fsStatPerceus(s: FsStat, debug: bool) -> FsStat {
	id_counter = ref 0;
	new_id = \-> {
		id = ^id_counter;
		id_counter := ^id_counter + 1;
		id;
	}
	s1 = cast(fsMap(s, fsIds(new_id), false): FsAll -> FsStat);
	if (debug) {
		println("s1 with ids:\n" +
			//"s:\n" + fs2s(s) + "\n" +
			"s1:\n" + fs2s(s1) + "\n"
			//"s RAW:\n" + toStringFormatted(s1) + "\n"
		);
	}
	add_var = \x, acc, v -> {
		switch (lookupTree(acc, v.name)) {
			Some(w): fail(
				"Duplicate variable: " + v.name + " of type: " + pretFiType(v.type) + ", already is of type: " + pretFiType(w.type) + " in:\n" + 
				fs2s(x) + "\n" +
				"IN:\n" + fs2s(s1)
			);
			None(): { }
		}
		setTree(acc, v.name, v);
	}
	varName2type = fsFold(s1, makeTree(), \acc, x -> switch (x) {
		FsLet(v,__,__,__,__): add_var(x, acc, v);
		FsLambda(__,args,__,__,__): fold(args, acc, \ac, arg -> add_var(x, ac, arg));
		default: acc;
	}, true);
	id2vars_last = fsFindLast(s1, ^id_counter, debug);
	cast(fsMap(s1, \x -> switch (x) {
		FsIf(cond,__, pos, neg, id):  {
			memops = fsGetMemops(cond, id2vars_last, debug);
			fsAddIncs(memops,
				FsIf(x with
					s1 = fsDecUnused(pos.id, fsAddDecs2(memops, pos, id), id2vars_last, varName2type, debug),
					s2 = fsDecUnused(neg.id, fsAddDecs2(memops, neg, id), id2vars_last, varName2type, debug)
				), id
			);
		};
		FsSwitch(v,__,__, cs, id): {
			memops = fsGetMemops(v, id2vars_last, debug);
			fsAddIncs(memops,
				FsSwitch(x with
					cases = map(cs, \c ->
						FsCase(c with
							body = fsDecUnused(c.body.id, fsAddDecs2(memops, c.body, id), id2vars_last, varName2type, debug)
						)
					)
				), id
			);
		}
		FsRet(e,__,id): {
			memops = fsGetMemops(e, id2vars_last, debug);
			fsAddDecs1(memops, fsAddIncs(memops, x, id), id);
		}
		FsWrapExp(e,__,id): {
			memops = fsGetMemops(e, id2vars_last, debug);
			x1 = if (fiTypeIsScalar(fsType(e))) x else {
				FsDecRc(e, -1);
			}
			fsAddIncs(memops, fsAddDecs(memops, x1, id), id);
		}
		FsLet(__,e,__,s2, id): {
			memops = fsGetMemops(e, id2vars_last, debug);
			fsAddIncs(memops, FsLet(x with s = fsAddDecs2(memops, s2, s2.id)), id);
		}
		FsAssign(to, what,__,id): {
			memops = fsGetMemops2(to, what, id2vars_last, debug);
			fsAddIncs(memops, fsAddDecs(memops, x, id), id);
		}
		FsIncRc(__,__,__): fail0("FsIncRc met during memory operations markup");
		FsDecRc(__,__): fail0("FsDecRc met during memory operations markup");
		FsLambda(__,__, body,__,id): {
			FsLambda(x with body = fsDecUnused(id, body, id2vars_last, varName2type, debug));
		}
		default: x;
	}, true): FsAll -> FsStat);
}

fsFindLast(s: FsStat, num: int, debug: bool) -> [Set<string>] {
	id2vars_pre = fsId2varsPre(s, num, debug);
	id2vars_post = fsId2varsPost(s, num, debug);
	id2vars_last = fsId2varsLast(s, num, id2vars_pre, id2vars_post, debug);
	if (debug) {
		set_tree2s = \st -> {
			superglue(tree2pairs(st), \p ->
				i2s(p.first) + ": " + "[" + strGlue(set2array(p.second), ", ") + "]", "\n"
			);
		}
		set_tree2s1 = \st -> {
			supergluei(st, \i, p ->
				i2s(i) + ": " + "[" + strGlue(set2array(p), ", ") + "]", "\n"
			);
		}
		println(
			"id2vars_pre:\n" + set_tree2s1(id2vars_pre) + "\n" +
			"id2vars_post:\n" + set_tree2s1(id2vars_post) + "\n" +
			"id2vars_last:\n" + set_tree2s1(id2vars_last) + "\n" +
			""
		);
	}
	id2vars_last;
}

fsLookupLast(x: FsAll, last: [Set<string>], id: int) -> Set<string> {
	if (id == -1) {
		makeSet();
	} else {
		last[id];
	}
}

fsContainsLast(x: FsAll, last: [Set<string>], id: int, var: string) -> bool {
	if (id == -1) {
		false;
	} else {
		containsSet(last[id], var);
	}
}

fsIsEmptyLast(x: FsAll, last: [Set<string>], id: int) -> bool {
	if (id == -1) {
		true;
	} else {
		isEmptySet(last[id]);
	}
}


fsDecUnused(id: int, x: FsStat, id2vars_last: [Set<string>], varName2type: Tree<string, FsVar>, debug: bool) -> FsStat {
	if (fsIsEmptyLast(x, id2vars_last, id)) x else {
		unused = map(set2array(fsLookupLast(x, id2vars_last, id)), \v_name ->
			switch (lookupTree(varName2type, v_name)) {
				Some(v): v;
				None(): fail0("Unknown variable: " + v_name);
			}
		);
		if (debug) {
			println("to dec <" + i2s(id) + "> unused: [" + superglue(unused, \v -> v.name, ", ") + "]");
		}
		FsSeq(concat(
			map(unused, \v -> FsDecRc(FsVarUse(v, FsVarLocal(), false, -1), -1)),
			fsUnwrapSeq(x)
		), -1);
	}
}

fsGetMemops(e: FsExp, id2vars_last: [Set<string>], debug: bool) -> [Pair<FsVar, FsMemOps>] {
	memops = tree2pairs(fsExpVarIncs(e, makeTree(), id2vars_last, -1, FsOrPrim()));
	if (debug) {
		memops_str = superglue(memops, \p -> p.first.name + "=inc(" + i2s(p.second.incs) + ")" + if (p.second.dec) ", dec" else "", ", ");
		println("memops for <" + i2s(e.id) + ">: [" + memops_str + "]");
	}
	memops;
}

fsGetMemops2(e1: FsExp, e2: FsExp, id2vars_last: [Set<string>], debug: bool) -> [Pair<FsVar, FsMemOps>] {
	memops = tree2pairs(fsExpVarIncs(e2, 
		fsExpVarIncs(e1, makeTree(), id2vars_last, -1, FsOrPrim()), 
		id2vars_last, -1, FsOrPrim()
	));
	if (debug) {
		memops_str = superglue(memops, \p -> p.first.name + "=inc(" + i2s(p.second.incs) + ")" + if (p.second.dec) ", dec" else "", ", ");
		println("memops for <" + i2s(e1.id) + ", " + i2s(e2.id) + ">: [" + memops_str + "]");
	}
	memops;
}

fsAddIncs(memops: [Pair<FsVar, FsMemOps>], x: FsStat, id: int) -> FsStat {
	incs = filtermap(memops, \p ->
		if (p.second.incs > 0) {
			Some(FsIncRc(p.second.incs, FsVarUse(p.first, FsVarLocal(), false, -1), -1));
		} else {
			None();
		}
	);
	if (length(incs) == 0) x else {
		FsSeq(concat(incs, fsUnwrapSeq(x)), id);
	}
}

fsAddDecs(memops: [Pair<FsVar, FsMemOps>], x: FsStat, id: int) -> FsStat {
	decs = filtermap(memops, \p ->
		if (p.second.dec) {
			Some(FsDecRc(FsVarUse(p.first, FsVarLocal(), false, -1), -1));
		} else {
			None();
		}
	);
	if (length(decs) == 0) x else {
		FsSeq(concat(fsUnwrapSeq(x), decs), id);
	}
}

fsAddDecs1(memops: [Pair<FsVar, FsMemOps>], x: FsStat, id: int) -> FsStat {
	decs = filtermap(memops, \p ->
		if (p.second.dec) Some(FsDecRc(FsVarUse(p.first, FsVarLocal(), false, -1), -1)) else None()
	);
	if (length(decs) == 0) x else {
		seq1 = fsUnwrapSeq(x);
		ret = cast(seq1[length(seq1) - 1]: FsStat -> FsRet);
		switch (ret.e) {
			FsTailCall(__,__,__,__): {
				FsSeq(concat3(tail(seq1), decs, [ret]), id);
			}
			default: {
				ret_var = FsVar("tmp_return_var", fsType(ret));
				FsSeq(
					arrayPush(tail(seq1),
						FsLet(ret_var, ret.e, [],
							FsSeq(arrayPush(decs, FsRet(FsVarUse(ret_var, FsVarLocal(), false, -1), [], -1)), id),
							-1
						)
					), -1
				);
			}
		}
	}
}

fsAddDecs2(memops: [Pair<FsVar, FsMemOps>], x: FsStat, id: int) -> FsStat {
	decs = filtermap(memops, \p ->
		if (p.second.dec) {
			Some(FsDecRc(FsVarUse(p.first, FsVarLocal(), false, -1), -1));
		} else {
			None();
		}
	);
	if (length(decs) == 0) x else {
		FsSeq(concat(decs, fsUnwrapSeq(x)), id);
	}
}

fsExpVarIncs(e: FsExp, acc: Tree<FsVar, FsMemOps>, last: [Set<string>], ind: int, op: FsPrim) -> Tree<FsVar, FsMemOps> {
	switch (e) {
		FsClosure(closure, __,__): {
			fold(closure, acc, \ac, x -> fsExpVarIncs(x, ac, last, -1, FsOrPrim()));
		}
		FsCall(f, args,__,__): {
			fold(args, fsExpVarIncs(f, acc, last, -1, FsOrPrim()), \ac, x ->
				fsExpVarIncs(x, ac, last, -1, FsOrPrim())
			);
		}
		FsCallPrim(o, es,__,__): {
			foldi(es, acc, \i, ac, x -> fsExpVarIncs(x, ac, last, i, o));
		}
		FsTailCall(args, vals, type, id): {
			fold(vals, acc, \ac, x -> fsExpVarIncs(x, ac, last, -1, FsOrPrim()));
		}
		FsCast(e1,__,__,__): {
			fsExpVarIncs(e1, acc, last, -1, FsOrPrim());
		}
		FsVarUse(x, kind, last1, id): {
			call_case = \-> if (fsContainsLast(e, last, id, x.name)) acc else {
				switch (lookupTree(acc, x)) {
					Some(p): setTree(acc, x, FsMemOps(p with incs = p.incs + 1));
					None(): setTree(acc, x, FsMemOps(x, 1, false));
				}
			}
			prim_case = \-> if (!fsContainsLast(e, last, id, x.name)) acc else {
				switch (lookupTree(acc, x)) {
					Some(p): setTree(acc, x, FsMemOps(p with dec = true));
					None(): setTree(acc, x, FsMemOps(x, 0, true));
				}
			}
			if (fiTypeIsScalar(x.type)) acc else {
				switch (kind) {
					FsVarGlobalFunc(): acc;
					FsVarUninit(): acc;
					default: {
						switch (op) {
							FsGePrim(): prim_case();
							FsLePrim(): prim_case();
							FsGtPrim(): prim_case();
							FsLtPrim(): prim_case();
							FsEqPrim(): prim_case();
							FsNePrim(): prim_case();
							FsFieldPrim(__,__): prim_case();
							FsIndexPrim(): prim_case();
							FsDerefPrim(): prim_case();
							default: call_case();
						}
					}
				}
			}
		}
		FsConst(c, id): acc;
	}
}

fsMergeSets(arr: [ref Set<string>], id: int, s: Set<string>) -> void {
	arr[id] := mergeSets(^(arr[id]), s);
}

fsId2varsPre(s1: FsStat, num: int, debug: bool) -> [Set<string>] {
	id2vars = generate(0, num, \__ -> ref makeSet());
	fsFold2(s1, Cons(makeSet(), EmptyList()),
		\acc, x: FsAll -> {
			add_v = \ac, v -> if (fiTypeIsScalar(v.type)) ac else insertSet(ac, v.name);
			switch (x) {
				FsLambda(closure, args,__,__,id): {
					new_vars = fold(args, fold(closure, makeSet(), \ac, v -> add_v(ac, v)), \ac, v -> add_v(ac, v));
					fsMergeSets(id2vars, id, new_vars);
					Cons(new_vars, acc);
				}
				FsLet(v, __,__,__,id): {
					new_vars = add_v(acc.head, v);
					fsMergeSets(id2vars, id, acc.head);
					Cons(new_vars, acc.tail);
				}
				FsIf(__,__,__,__, id):  {
					fsMergeSets(id2vars, id, acc.head);
					acc;
				}
				FsSwitch(__,__,__,__, id): {
					fsMergeSets(id2vars, id, acc.head);
					acc;
				}
				FsSeq(__, id): {
					fsMergeSets(id2vars, id, acc.head);
					acc;
				}
				FsRet(__,__,id): {
					fsMergeSets(id2vars, id, acc.head);
					acc;
				}
				FsWrapExp(__,__,id): {
					fsMergeSets(id2vars, id, acc.head);
					acc;
				}
				FsAssign(__,__,__,id): {
					fsMergeSets(id2vars, id, acc.head);
					acc;
				}
				FsVarUse(v, kind, last, id): {
					fsMergeSets(id2vars, id, acc.head);
					acc;
				}
				default: {
					acc;
				}
			}
		},
		\acc, x -> {
			switch (x) {
				FsLambda(__,__,__,__,id): {
					cast(acc.tail: List<Set<string>> -> Cons<Set<string>>);
				}
				default: acc;
			}
		},
		\args -> args,
		\p1, p2 -> Cons(mergeSets(p1.head, p2.head), p1.tail)
	);
	map(id2vars, \x -> ^x);
}

fsId2varsPost(s1: FsStat, num: int, debug: bool) -> [Set<string>] {
	show_vars = \vs -> "[" + strGlue(set2array(vs), ", ") + "]";
	id2vars = generate(0, num, \__ -> ref makeSet());
	fsFold2(s1, Cons(makeSet(), EmptyList()),
		\acc, x -> {
			switch (x) {
				FsLambda(__,__,__,__,id): {
					if (debug) {
						st = switch (acc) {
							Cons(vars,__): show_vars(vars);
							EmptyList(): ""
						}
						println(
							"(B) id=" + i2s(id) + " pushing stack: [" + show_vars(acc.head) + "]\n" +
							"\tacc.second: [" + st + "]\n"
						);
					}
					fsMergeSets(id2vars, id, makeSet());
					Cons(makeSet(), acc);
				}
				default: acc;
			}
		},
		\acc, x: FsAll -> {
			switch (x) {
				FsLambda(__,__,__,__,id): {
					fsMergeSets(id2vars, id, acc.head);
					cast(acc.tail: List<Set<string>> -> Cons<Set<string>>);
				}
				FsVarUse(v, kind, last, id): {
					new_vars = switch (kind) {
						FsVarLocal(): {
							if (fiTypeIsScalar(v.type)) acc.head else insertSet(acc.head, v.name);
						}
						default: acc.head;
					}
					fsMergeSets(id2vars, id, acc.head);
					Cons(new_vars, acc.tail);
				}
				FsIf(__,__,__,__, id):  {
					fsMergeSets(id2vars, id, acc.head);
					acc;
				}
				FsLet(__,__,__,__,id): {
					fsMergeSets(id2vars, id, acc.head);
					acc;
				}
				FsSwitch(__,__,__,__, id): {
					fsMergeSets(id2vars, id, acc.head);
					acc;
				}
				FsSeq(__, id): {
					fsMergeSets(id2vars, id, acc.head);
					acc;
				}
				FsRet(__,__,id): {
					fsMergeSets(id2vars, id, acc.head);
					acc;
				}
				FsWrapExp(__,__,id): {
					fsMergeSets(id2vars, id, acc.head);
					acc;
				}
				FsAssign(__,__,__,id): {
					fsMergeSets(id2vars, id, acc.head);
					acc;
				}
				default: {
					acc;
				}
			}
		},
		\args -> reverseA(args),
		\p1, p2 -> Cons(mergeSets(p1.head, p2.head), p1.tail)
	);
	map(id2vars, \x -> ^x);
}

fsId2varsLast(s1: FsStat, num: int, id2vars_pre: [Set<string>], id2vars_post: [Set<string>], debug: bool) -> [Set<string>] {
	show_vars = \vs -> "[" + strGlue(set2array(vs), ", ") + "]";
	id2vars = generate(0, num, \__ -> ref makeSet());
	fsFold2(s1, Cons(makeSet(), makeList()),
		\acc: Cons<Set<string>>, x: FsAll -> {
			do_diff = \ -> {
				pre_vars = fsLookupLast(x, id2vars_pre, x.id);
				post_vars = fsLookupLast(x, id2vars_post, x.id);
				diff1 = differenceSets(pre_vars, post_vars);
				diff = differenceSets(diff1, acc.head);
				if (debug) {
					println(
						"(C) x.id: " + i2s(x.id) + "\n" +
						strIndent(
							"pre_vars: " + show_vars(pre_vars) + "\n" +
							"post_vars: " + show_vars(post_vars) + "\n" +
							"acc.head: " + show_vars(acc.head) + "\n" +
							"diff1: " + show_vars(diff1) + "\n" +
							"diff: " + show_vars(diff)
						)
					);
				}
				Pair(diff, diff1);
			}
			switch (x) {
				FsLambda(__,__,__,__,id): {
					if (debug) {
						println("(C) id=" + i2s(id) + " pushing stack: " + show_vars(acc.head));
					}
					p = do_diff();
					fsMergeSets(id2vars, id, p.first);
					Cons(makeSet(), acc);
				}
				FsIf(__,__,__,__, id):  {
					p = do_diff();
					fsMergeSets(id2vars, id, p.first);
					Cons(mergeSets(acc.head, p.second), acc.tail);
				}
				FsLet(__,__,__,__,id): {
					p = do_diff();
					fsMergeSets(id2vars, id, p.first);
					Cons(mergeSets(acc.head, p.second), acc.tail);
				}
				FsSwitch(__,__,__,__, id): {
					p = do_diff();
					fsMergeSets(id2vars, id, p.first);
					Cons(mergeSets(acc.head, p.second), acc.tail);
				}
				FsSeq(__, id): {
					p = do_diff();
					fsMergeSets(id2vars, id, p.first);
					Cons(mergeSets(acc.head, p.second), acc.tail);
				}
				FsRet(__,__,id): {
					p = do_diff();
					fsMergeSets(id2vars, id, p.first);
					Cons(mergeSets(acc.head, p.second), acc.tail);
				}
				FsWrapExp(__,__,id): {
					p = do_diff();
					fsMergeSets(id2vars, id, p.first);
					Cons(mergeSets(acc.head, p.second), acc.tail);
				}
				FsAssign(__,__,__,id): {
					p = do_diff();
					fsMergeSets(id2vars, id, p.first);
					Cons(mergeSets(acc.head, p.second), acc.tail);
				}
				FsVarUse(__,__,__,id): {
					p = do_diff();
					fsMergeSets(id2vars, id, p.first);
					Cons(mergeSets(acc.head, p.second), acc.tail);
				}
				default: {
					acc;
				}
			}
		},
		\acc, x -> {
			switch (x) {
				FsLambda(__,__,__,__,id): {
					cast(acc.tail: List<Set<string>> -> Cons<Set<string>>);
				}
				default: acc;
			}
		},
		\args -> args,
		\p1, p2 -> Cons(mergeSets(p1.head, p2.head), p1.tail)
	);
	map(id2vars, \x -> ^x);
}

fsIds(new_id: () -> int) -> (FsAll) -> FsAll {
	\s -> switch(s) {
		FsIf(__,__,__,__,__):     FsIf(s with id = new_id());
		FsSwitch(__,__,__,__,__): FsSwitch(s with id = new_id());
		FsSeq(__, __):            FsSeq(s with id = new_id());
		FsWrapExp(__,__,__):      FsWrapExp(s with id = new_id());
		FsRet(__,__,__):          FsRet(s with id = new_id());
		FsAssign(__,__,__,__):    FsAssign(s with id = new_id());
		FsLet(__,__,__,__,__):    FsLet(s with id = new_id());
		FsLambda(__,__,__,__,__): FsLambda(s with id = new_id());
		FsVarUse(__,__,__,__):    FsVarUse(s with id = new_id());
		default: s;
	}
}
