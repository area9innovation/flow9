import ds/treeutils;
import tools/flowc/statements/fs_transform;

export {
	fsStatPerceus(s: FsStat, names: FiGlobalNames, debug: bool) -> FsStat;
}

fsStatPerceus(s: FsStat, names: FiGlobalNames, debug: bool) -> FsStat {
	id_counter = ref 0;
	new_id = \-> {
		id = ^id_counter;
		id_counter := ^id_counter + 1;
		id;
	}
	s1 = cast(fsMap(s, fsIds(new_id), false): FsAll -> FsStat);
	if (debug) {
		println("s1 with ids:\n" +
			//"s:\n" + fs2s(s) + "\n" +
			"s1:\n" + fs2s(s1) + "\n"
			//"s RAW:\n" + toStringFormatted(s1) + "\n"
		);
	}
	merge_vars = \p1, p2 -> Pair(
		mergeTreeCustom(p1.first, p2.first, \id, x1, x2 -> mergeSets(x1, x2)),
		mergeSets(p1.second, p2.second)
	);
	id2vars_pre: Tree<int, Set<FsVar>> = fsFold1(s1, Pair(makeTree(), makeSet()),
		\acc, x: FsAll -> {
			add_v = \ac, v -> if (fiTypeIsScalar(v.type)) ac else insertSet(ac, v);
			s2 = switch (x) {
				FsLet(v, __, id): add_v(acc.second, v);
				FsLambda(clos, args,__,__,__): {
					fold(clos,
						fold(args, makeSet(),
							\ac, v -> add_v(ac, v)
						),
						\ac, v -> add_v(ac, v)
					);
				}
				default: acc.second;
			}
			Pair(setTree(acc.first, x.id, s2), s2);
		},
		\acc, x -> acc,
		\args -> args,
		merge_vars
	).first;

	id2vars_post: Tree<int, Set<FsVar>> = fsFold1(s1, Pair(makeTree(), makeSet()),
		\acc, x -> acc,
		\acc, x: FsAll -> {
			add_v = \ac, v -> if (fiIsGlobal(v.name, names)) ac else insertSet(ac, v);
			s2 = switch (x) {
				FsVarUse(v, id): add_v(acc.second, v);
				default: acc.second;
			}
			Pair(setTree(acc.first, x.id, acc.second), s2)
		},
		\args -> reverseA(args),
		merge_vars
	).first;

	//id2vars_last1 = mapTree2(id2vars_pre, \id, pre_vars ->
	//	differenceSets(pre_vars, lookupTreeDef(id2vars_post, id, makeSet()))
	//);

	id2vars_last: Tree<int, Set<FsVar>> = fsFold1(s1, Pair(makeTree(), makeSet()),
		\acc, x: FsAll -> {
			pre_vars = lookupTreeDef(id2vars_pre, x.id, makeSet());
			post_vars = lookupTreeDef(id2vars_post, x.id, makeSet());
			diff1 = differenceSets(pre_vars, post_vars);
			diff = differenceSets(diff1, acc.second);
			Pair(setTree(acc.first, x.id, diff), mergeSets(acc.second, diff1));
		},
		\acc, x -> acc,
		\args -> args,
		merge_vars
	).first;

	if (debug) {
		set_tree2s = \st -> {
			superglue(tree2pairs(st), \p ->
				i2s(p.first) + ": [" + superglue(set2array(p.second), \v -> v.name, ", ") + "]", "\n"
			);
		}
		println(
			"id2vars_pre:\n" + set_tree2s(id2vars_pre) + "\n" +
			"id2vars_post:\n" + set_tree2s(id2vars_post) + "\n" +
			"id2vars_last:\n" + set_tree2s(id2vars_last) + "\n" +
			""
		);
	}
	dec_unused = \id, x -> {
		unused = set2array(lookupTreeDef(id2vars_last, id, makeSet()));
		if (debug) {
			println("to dec <" + i2s(id) + "> unused: [" + superglue(unused, \v -> v.name, ", ") + "]");
		}
		if (length(unused) == 0) x else {
			FsSeq(concat(
				map(unused, \v -> FsDecRc(FsVarUse(v, -1), -1)),
				fsUnwrapSeq(x)
			), -1);
		}
	}
	cast(fsMap(s1, \x -> switch (x) {
		FsIf(cond, pos, neg, id):  {
			FsIf(x with s1 = dec_unused(pos.id, pos), s2 = dec_unused(neg.id, neg));
		};
		FsSwitch(__,__, cs,__): {
			FsSwitch(x with cases = map(cs, \c -> FsCase(c with body = dec_unused(c.body.id, c.body))));
		}
		FsWrapExp(e1,__): {
			if (fiTypeIsScalar(fsType(e1))) x else {
				FsDecRc(e1, -1);
			}
		}
		FsModRc(__, e1,__): {
			fail("double memory operators markup");
			x;
		}
		FsVarUse(v, id): {
			if (fiIsGlobalFunction(v.name, names)) x  else {
				unused = lookupTreeDef(id2vars_last, id, makeSet());
				if (!containsSet(unused, v)) {
					FsIncRc(x, v.type, -1);
				} else {
					x;
				}
			}
		}
		FsLambda(__,__, body,__,id): {
			FsLambda(x with body = dec_unused(id, body));
		}
		default: x;
	}, true): FsAll -> FsStat);
}

fsIds(new_id: () -> int) -> (FsAll) -> FsAll {
	\s -> switch(s) {
		FsIf(__,__,__,__):        FsIf(s with id = new_id());
		FsSwitch(__,__,__,__):    FsSwitch(s with id = new_id());
		FsSeq(__, __):            FsSeq(s with id = new_id());
		FsWrapExp(__,__):         FsWrapExp(s with id = new_id());
		FsRet(__,__):             FsRet(s with id = new_id());
		FsAssign(__,__,__):       FsAssign(s with id = new_id());
		FsModRc(__,__,__):        FsModRc(s with id = new_id());
		FsDecRc(__,__):           FsDecRc(s with id = new_id());
		FsIncRc(__,__,__):        FsIncRc(s with id = new_id());
		FsLet(__,__,__):          FsLet(s with id = new_id());
		FsLambda(__,__,__,__,__): FsLambda(s with id = new_id());
		FsCall(__,__,__,__):      FsCall(s with id = new_id());
		FsCallPrim(__,__,__,__):  FsCallPrim(s with id = new_id());
		FsCast(__,__,__,__):      FsCast(s with id = new_id());
		FsConst(__,__):           FsConst(s with id = new_id());
		FsTailCall(__,__,__,__):  FsTailCall(s with id = new_id());
		FsVarUse(__,__):          FsVarUse(s with id = new_id()); 
	}
}
