import ds/treeutils;
import ds/hashset;
import tools/flowc/statements/fs_transform;

export {
	fs_fast_prim_ops = true;
	fsStatPerceus(s: FsStat, debug: bool, name: string) -> FsStat;
}

fsStatPerceus(s: FsStat, debug0: bool, name: string) -> FsStat {
	id_counter = ref 0;
	new_id = \-> {
		id = ^id_counter;
		id_counter := ^id_counter + 1;
		id;
	}
	debug = ref debug0;
	/*num_ids1 = fsFold(s, 0, \acc, x -> acc + fsCountId(x), true);
	if (^debug) {
		println("going to markup with ids, num ids: " + i2s(num_ids1) + "  ... ");
	}*/
	markup_id = fsIds(new_id);
	s1 = cast(fsMap(s, \x -> markup_id(x), false): FsAll -> FsStat);
	num_ids = ^id_counter;
	/*if (num_ids != num_ids1) {
		println("num_ids (^id_counter) != num_ids1: " + i2s(num_ids) + " != " + i2s(num_ids1) + "\n" + 
			"s:\n" + strIndent(fs2s(s)) + "\n"
			"s1 WITH ids:\n" + strIndent(fs2s(s1)) + "\n" + 
			"increments:\n" + strGlue(fsFold(s, [], \acc, x -> arrayPush(acc, "\t" + fs2string(x, 1) + " => " + i2s(fsCountId(x))), true), "\n")
		);
	}*/
	if (^debug) {
		println("s1 with ids:\n" +
			//"s:\n" + fs2s(s) + "\n" +
			"s1:\n" + fs2s(s1) + "\n"
			//"s RAW:\n" + toStringFormatted(s1) + "\n"
		);
	}
	add_var = \x, acc, v -> {
		switch (lookupTree(acc, v.name)) {
			Some(w): fail(
				"Duplicate variable: " + v.name + " of type: " + pretFiType(v.type) + ", already is of type: " + pretFiType(w.type) + " in:\n" + 
				fs2s(x) + "\n" +
				"IN:\n" + fs2s(s1)
			);
			None(): { }
		}
		setTree(acc, v.name, v);
	}
	name2var = fsFold(s1, makeTree(), \acc, x -> switch (x) {
		FsLet(v,__,__,__): add_var(x, acc, v);
		FsLambda(__,args,__,__,__): fold(args, acc, \ac, arg -> add_var(x, ac, arg));
		default: acc;
	}, true);
/*
// Shows a message that some operation is started, with indentation accoring to the verbosity level.
	fcStartOperationMessage(verbose: int, verbosity_level: int, header: string, name: string, thread_id: int) -> double;

	// Shows a message that some operation is ended, with time elapsed (if > 0), with indentation accoring to the verbosity level.
	fcEndOperationMessage(verbose: int, verbosity_level: int, header: string, name: string, start: double, thread_id: int) -> void;

*/
	t1 = timestamp();
	last = fsFindLast(s1, ^id_counter, ^debug, name);
	fsShowTiming(name + ": fsFindLast(s1, ^id_counter, ^debug, name)", t1);

	//if (^debug) {
	//	println("Last:\n" + supergluei(last, \i, x -> "\t" + i2s(i) + ": {" + strGlue(set2array(x), "\n") + "}", "\n"))
	//}

	crash = ref false;

	//if (false) {
	//	fsVerifyControlFlowPaths(s1, ^id_counter, last, name, debug, crash);
	//}

	t2 = timestamp();
	/*ret = cast(fsMap(s1, \x -> switch (x) {
		FsIf(cond, pos, neg, id):  {
			memops = fsGetMemops(cond, last, ^debug);
			fsDecUnused(id,
				fsAddIncs(memops,
					FsIf(x with
						s1 = fsAddDecs2(memops, pos, id),
						s2 = fsAddDecs2(memops, neg, id)
					), id
				), last, name2var, ^debug
			);
		};
		FsSwitch(v,__, cs, id): {
			memops = fsGetMemops(v, last, ^debug);
			fsDecUnused(id,
				fsAddIncs(memops,
					FsSwitch(x with
						cases = map(cs, \c ->
							FsCase(c with
								body = fsAddDecs2(memops, c.body, id)
							)
						)
					), id
				), last, name2var, ^debug
			);
		}
		FsSeq(ss, id): {
			fsDecUnused(id, x, last, name2var, ^debug);
		}
		FsRet(e, id): {
			memops = fsGetMemops(e, last, ^debug);
			fsDecUnused(id, fsAddDecs1(memops, fsAddIncs(memops, x, id), id), last, name2var, ^debug);
		}
		FsWrapExp(e, id): {
			memops = fsGetMemops(e, last, ^debug);
			fsDecUnused(id, fsAddIncs(memops, fsAddDecs(memops, x, id), id), last, name2var, ^debug);
		}
		FsLet(__, e, s2, id): {
			memops = fsGetMemops(e, last, ^debug);
			fsDecUnused(id,
				fsAddIncs(memops, FsLet(x with
					s = fsAddDecs2(memops, s2, s2.id)
				), id),
				last, name2var, ^debug
			);
		}
		FsAssign(to, what, id): {
			memops = fsGetMemops2(to, what, last, ^debug);
			fsDecUnused(id,
				fsAddIncs(memops, fsAddDecs(memops, x, id), id),
				last, name2var, ^debug
			);
		}
		FsIncRc(__,__,__): fail0("FsIncRc met during memory operations markup");
		FsDecRc(__,__,__): fail0("FsDecRc met during memory operations markup");
		default: x;
	}, true): FsAll -> FsStat);
	fsShowTiming(name + ": ret = cast(fsMap(s1, \\x -> switch (x) {...", t2);
	*/

	t3 = timestamp();
	id2mem = fsId2Mem(s1, num_ids, last, name2var);
	if (^debug) {
		println("id2mem:\n" +
			supergluei(
				filter(id2mem, \mem -> sizeTree(mem.incs) > 0 || sizeSet(mem.decs) > 0 || sizeSet(mem.unused) > 0),
				\i, mem -> {
					mem_s = fsMem2string(mem);
					"\t" + i2s(i) + ": " + if (strContains(mem_s, "\n")) strIndent(strIndent(mem_s)) else mem_s;
				}, "\n"
			) 
		);
		//iteri(id2mem, \i, mem ->
		//	println("\t" + i2s(i) + ":\n" + strIndent(strIndent(fsMem2string(mem))))
		//);
	}
	ret1 = fsExpandMemOps(s1, id2mem);
	fsShowTiming(name + ": fsExpandMemOps(s1, fsId2Mem(s1, num_ids, last, name2var))", t3);
	
	/*if (!fsEqualExprs(ret, ret1)) {
		println("!fsEqualExprs(ret, ret1)\n" +
			"num_ids: " + i2s(num_ids) + "\n" +
			"diff:\n" + strIndent(superglue(fsDiffExprs(ret, ret1, []), \p -> 
				"NOT EQUAL:\n" + strIndent(fs2string(p.first, 2)) + "\n!=\n" + strIndent(fs2string(p.second, 2)) + "\n", "\n"
			)) + "\n" +
			"ret:\n" + strIndent(fs2string(ret, -1)) + "\n" +
			"ret1:\n" + strIndent(fs2string(ret1, -1)) + "\n"
		);
		crash := true;
	}*/

	if (^crash) {
		println("s1 with ids:\n" +
			//"s:\n" + fs2s(s) + "\n" +
			"s1:\n" + fs2s(s1) + "\n"
			//"s RAW:\n" + toStringFormatted(s1) + "\n"
		);
		 fsFindLast(s1, ^id_counter, ^debug, name);
		fail("CRAHS");
	}
	ret1;
}

fsExpandIncs(m: FsMem) -> [FsStat] {
	map(tree2pairs(m.incs), \p ->
		FsIncRc(p.second, FsVarUse(p.first, FsVarLocal(), false, -1), -1)
	);
}

fsExpandDecs(m: FsMem) -> [FsStat] {
	map(set2array(m.decs), \v ->
		FsDecRc(FsVarUse(v, FsVarLocal(), false, -1), "", -1)
	);
}

fsExpandUnused(m: FsMem) -> [FsStat] {
	map(set2array(m.unused), \v ->
		FsDecRc(FsVarUse(v, FsVarLocal(), false, -1), "", -1)
	);
}

// fsStatSetId

fsAppendFirst(ops: [FsStat], x: FsStat) -> FsStat {
	fsWrapSeq(concat(ops, fsUnwrapSeq(x)));
}

fsAppendLast(x: FsStat, ops: [FsStat]) -> FsStat {
	fsWrapSeq(concat(fsUnwrapSeq(x), ops));
}

fsAppendReturn(x: FsRet, ops: [FsStat]) -> FsStat {
	if (length(ops) == 0) x else {
		ret_var = FsVar("tmp_return_var", fsType(x.e));
		FsLet(ret_var, x.e,
			FsSeq(arrayPush(ops, FsRet(FsVarUse(ret_var, FsVarLocal(), false, -1), -1)), -1),
			-1
		);
	}
}

fsMem2string(m: FsMem) -> string {
	components = filter([
		if (isEmptyTree(m.incs)) "" else "incs: {" + superglue(tree2pairs(m.incs), \p -> p.first.name + " -> " + i2s(p.second), ", ") + "}",
		if (isEmptySet(m.decs)) "" else "decs: {" + superglue(set2array(m.decs), \v -> v.name, ", ") + "}",
		if (isEmptySet(m.unused)) "" else "unused: {" + superglue(set2array(m.unused), \v -> v.name, ", ") + "}"
	], isNotSpace);
	strGlue(components, "\n");
}

fsExpandMemOps(s: FsStat, id2mem: [FsMem]) -> FsStat {
	cast(fsMap(s, \x -> switch (x) {
		FsIf(cond, pos, neg, id):  {
			fsAppendFirst(
				fsExpandUnused(id2mem[id]),
				fsAppendFirst(
					fsExpandIncs(id2mem[id]),
					FsIf(x with
						s1 = fsAppendFirst(fsExpandDecs(id2mem[id]), pos),
						s2 = fsAppendFirst(fsExpandDecs(id2mem[id]), neg)
					)
				)
			);
		};
		FsSwitch(v, __, cs, id): {
			fsAppendFirst(
				fsExpandUnused(id2mem[id]),
				fsAppendFirst(
					fsExpandIncs(id2mem[id]),
					FsSwitch(x with
						cases = map(cs, \c -> 
							FsCase(c with
								body = fsAppendFirst(fsExpandDecs(id2mem[id]), c.body)
							)
						)
					)
				)
			);
		}
		FsSeq(ss, id): {
			fsAppendFirst(fsExpandUnused(id2mem[id]), x);
		}
		FsRet(e, id): {
			fsAppendFirst(
				fsExpandUnused(id2mem[id]),
				fsAppendFirst(
					fsExpandIncs(id2mem[id]),
					fsAppendReturn(x, fsExpandDecs(id2mem[id]))
				)
			);
		}
		FsWrapExp(e, id): {
			fsAppendFirst(
				fsExpandUnused(id2mem[id]),
				fsAppendFirst(
					fsExpandIncs(id2mem[id]),
					fsAppendLast(x, fsExpandDecs(id2mem[id]))
				)
			);
		}
		FsLet(__,e, s1, id): {
			fsAppendFirst(
				fsExpandUnused(id2mem[id]),
				fsAppendFirst(
					fsExpandIncs(id2mem[id]),
					FsLet(x with
						s = fsAppendFirst(fsExpandDecs(id2mem[id]), s1)
					)
				)
			);
		}
		FsAssign(to, what, id): {
			fsAppendFirst(
				fsExpandUnused(id2mem[id]),
				fsAppendFirst(
					fsExpandIncs(id2mem[id]),
					fsAppendLast(x, fsExpandDecs(id2mem[id]))
				)
			);
		}
		FsIncRc(__,__,__): fail0("FsIncRc met during memory operations markup");
		FsDecRc(__,__,__): fail0("FsDecRc met during memory operations markup");
		default: x;
	}, true): FsAll -> FsStat);
}


fsShowTiming(msg: string, start: double) -> void {
	fsShowTiming1(msg, timestamp() - start);
}

fsShowTiming1(msg: string, delta: double) -> void {
	/*t = delta / 1000.0;
	if (t > 0.1) {
		println("\nAAAA " + msg + " took " + d2st(t, 2) + "s.");
	}*/
}

fsId2Mem(s: FsStat, num: int, last: [Set<string>], name2var: Tree<string, FsVar>) -> [FsMem] {
	make_mem = \ -> FsMem(makeTree(), makeSet(), makeSet());
	id2mem = generate(0, num, \__ -> ref make_mem());
	fsIter(s, \x -> switch (x) {
		FsIf(cond, pos, neg, id):  {
			id2mem[id] := fsAddUnused2Mem(
				fsAddExp2Mem(make_mem(), cond, last, None()),
				id, last, name2var
			);
		};
		FsSwitch(v,__, cs, id): {
			id2mem[id] := fsAddUnused2Mem(
				fsAddExp2Mem(make_mem(), v, last, None()),
				id, last, name2var
			);
		}
		FsSeq(ss, id): {
			id2mem[id] := fsAddUnused2Mem(make_mem(), id, last, name2var);
		}
		FsRet(e, id): {
			id2mem[id] := fsAddUnused2Mem(
				fsAddExp2Mem(make_mem(), e, last, None()),
				id, last, name2var
			);
		}
		FsWrapExp(e, id): {
			id2mem[id] := fsAddUnused2Mem(
				fsAddExp2Mem(make_mem(), e, last, None()),
				id, last, name2var
			);
		}
		FsLet(__,e, __, id): {
			id2mem[id] := fsAddUnused2Mem(
				fsAddExp2Mem(make_mem(), e, last, None()),
				id, last, name2var
			);
		}
		FsAssign(to, what, id): {
			id2mem[id] := fsAddUnused2Mem(
				fsAddExp2Mem(
					fsAddExp2Mem(make_mem(), to, last, None()),
					what, last, None()
				),
				id, last, name2var
			);
		}
		FsIncRc(__,__,__): fail("FsIncRc met during memory operations markup");
		FsDecRc(__,__,__): fail("FsDecRc met during memory operations markup");
		default: {}
	}, true);
	map(id2mem, \m -> ^m);
}

fsFindLast(s: FsStat, num: int, debug: bool, name: string) -> [Set<string>] {
	s1 = timestamp();
	pre = fsId2varsPreHash(s, num, debug);
	fsShowTiming(name + ": fsId2varsPre(s, num, debug)", s1);

	s2 = timestamp();
	post = fsId2varsPost(s, num, debug);
	fsShowTiming(name + ": fsId2varsPost(s, num, debug)", s2);

	s3 = timestamp();
	last = fsId2varsLastHash(s, num, pre, post, debug);
	fsShowTiming(name + ": fsId2varsLast(s, num, debug)", s2);

	if (debug) {
		/*set_tree2s = \st -> {
			superglue(
				filtermapi(tree2pairs(st), \i, p -> if (sizeSet(p.second) > 0) Some(Pair(i, p)) else None()), 
				\p -> "\t" + i2s(p.first) + ": " + "[" + strGlue(set2array(p.second), ", ") + "]", "\n"
			);
		}*/
		set_tree2s1 = \st -> {
			superglue(
				filtermapi(st, \i, x -> if (isEmptySet(x)) None() else Some(Pair(i, x))), 
				\p -> "\t" + i2s(p.first) + ": " + "[" + strGlue(set2array(p.second), ", ") + "]", "\n"
			);
		}
		hashset_tree2s1 = \st -> {
			superglue(
				filtermapi(st, \i, x -> if (isEmptyHashSet(x)) None() else Some(Pair(i, x))),
				\p -> "\t" + i2s(p.first) + ": " + "[" + strGlue(hashSet2array(p.second), ", ") + "]", "\n"
			);
		}
		println(
			//"pre:\n" + hashset_tree2s1(pre) + "\n" +
			//"post:\n" + set_tree2s1(post) + "\n" +
			"last:\n" + set_tree2s1(last) + "\n" +
			""
		);
	}
	last;
}

/*fsLookupLast(last: [Set<string>], id: int) -> Set<string> {
	if (id == -1) {
		makeSet();
	} else {
		last[id];
	}
}*/

fsContainsLast(x: FsAll, last: [Set<string>], id: int, var: string) -> bool {
	if (id == -1) {
		false;
	} else {
		containsSet(last[id], var);
	}
}

fsIsEmptyLast(x: FsAll, last: [Set<string>], id: int) -> bool {
	if (id == -1) {
		true;
	} else {
		isEmptySet(last[id]);
	}
}


fsDecUnused(id: int, x: FsStat, last: [Set<string>], name2var: Tree<string, FsVar>, debug: bool) -> FsStat {
	if (fsIsEmptyLast(x, last, id)) {
		if (debug) {
			println("to dec <" + i2s(id) + "> unused: []");
		}
		x;
	} else {
		unused = map(set2array(last[id]), \v_name ->
			switch (lookupTree(name2var, v_name)) {
				Some(v): v;
				None(): fail0("Unknown variable: " + v_name);
			}
		);
		if (debug) {
			println("to dec <" + i2s(id) + "> unused: [" + superglue(unused, \v -> v.name, ", ") + "]");
		}
		FsSeq(concat(
			map(unused, \v -> FsDecRc(FsVarUse(v, FsVarLocal(), false, -1), "", -1)),
			fsUnwrapSeq(x)
		), -1);
	}
}

FsMemOps(
	var: FsVar,
	incs: int,  // How much we need to increment a RC of a var before evaluation of an expression
	dec: bool,  // Should we drop the var in the end of evaluation of an expression explicitly
);

fsGetMemops(e: FsExp, last: [Set<string>], debug: bool) -> [Pair<FsVar, FsMemOps>] {
	memops = tree2pairs(fsExpVarIncs(e, makeTree(), last, -1, FsOrPrim()));
	if (debug) {
		memops_str = superglue(memops, \p -> p.first.name + "=inc(" + i2s(p.second.incs) + ")" + if (p.second.dec) ", dec" else "", ", ");
		println("memops for <" + i2s(e.id) + ">: [" + memops_str + "]" +
			if (e.id != -1) "" else "EXP:\n" + strIndent(fs2s(e))
		);
	}
	memops;
}

fsGetMemops2(e1: FsExp, e2: FsExp, last: [Set<string>], debug: bool) -> [Pair<FsVar, FsMemOps>] {
	memops = tree2pairs(fsExpVarIncs(e2, 
		fsExpVarIncs(e1, makeTree(), last, -1, FsOrPrim()), 
		last, -1, FsOrPrim()
	));
	if (debug) {
		memops_str = superglue(memops, \p -> p.first.name + "=inc(" + i2s(p.second.incs) + ")" + if (p.second.dec) ", dec" else "", ", ");
		println("memops for <" + i2s(e1.id) + ", " + i2s(e2.id) + ">: [" + memops_str + "]" +
			if (e1.id != -1 && e2.id != 1) "" else
				"EXP 1:\n" + strIndent(fs2s(e1)) + "\n" +
				"EXP 2:\n" + strIndent(fs2s(e2)) + "\n"
		);
	}
	memops;
}

fsAddIncs(memops: [Pair<FsVar, FsMemOps>], x: FsStat, id: int) -> FsStat {
	incs = filtermap(memops, \p ->
		if (p.second.incs > 0) {
			Some(FsIncRc(p.second.incs, FsVarUse(p.first, FsVarLocal(), false, -1), -1));
		} else {
			None();
		}
	);
	if (length(incs) == 0) x else {
		//FsSeq(concat(incs, fsUnwrapSeq(x)), id);
		FsSeq(concat(incs, fsUnwrapSeq(x)), -1);
	}
}

fsAddDecs(memops: [Pair<FsVar, FsMemOps>], x: FsStat, id: int) -> FsStat {
	decs = filtermap(memops, \p ->
		if (p.second.dec) {
			Some(FsDecRc(FsVarUse(p.first, FsVarLocal(), false, -1), "", -1));
		} else {
			None();
		}
	);
	if (length(decs) == 0) x else {
		//FsSeq(concat(fsUnwrapSeq(x), decs), id);
		FsSeq(concat(fsUnwrapSeq(x), decs), -1);
	}
}

fsAddDecs2(memops: [Pair<FsVar, FsMemOps>], x: FsStat, id: int) -> FsStat {
	decs = filtermap(memops, \p ->
		if (p.second.dec) {
			Some(FsDecRc(FsVarUse(p.first, FsVarLocal(), false, -1), "", -1));
		} else {
			None();
		}
	);
	if (length(decs) == 0) x else {
		//FsSeq(concat(decs, fsUnwrapSeq(x)), id);
		FsSeq(concat(decs, fsUnwrapSeq(x)), -1);
	}
}

fsAddDecs1(memops: [Pair<FsVar, FsMemOps>], x: FsStat, id: int) -> FsStat {
	decs = filtermap(memops, \p ->
		if (p.second.dec) Some(FsDecRc(FsVarUse(p.first, FsVarLocal(), false, -1), "", -1)) else None()
	);
	if (length(decs) == 0) x else {
		seq1 = fsUnwrapSeq(x);
		ret = cast(seq1[length(seq1) - 1]: FsStat -> FsRet);
		non_ret = take(seq1, length(seq1) - 1);
		ret_var = FsVar("tmp_return_var", fsType(ret));
		fsWrapSeq(
			arrayPush(non_ret,
				FsLet(ret_var, ret.e,
					//FsSeq(arrayPush(decs, FsRet(FsVarUse(ret_var, FsVarLocal(), false, -1), -1)), id),
					FsSeq(arrayPush(decs, FsRet(FsVarUse(ret_var, FsVarLocal(), false, -1), -1)), -1),
					-1
				)
			)
		);
	}
}

fsExpVarIncs(e: FsExp, acc: Tree<FsVar, FsMemOps>, last: [Set<string>], ind: int, op: FsPrim) -> Tree<FsVar, FsMemOps> {
	switch (e) {
		FsClosure(closure, __,__): {
			fold(closure, acc, \ac, x -> fsExpVarIncs(x, ac, last, -1, FsOrPrim()));
		}
		FsCall(f, args,__,__): {
			fold(args, fsExpVarIncs(f, acc, last, -1, FsOrPrim()), \ac, x ->
				fsExpVarIncs(x, ac, last, -1, FsOrPrim())
			);
		}
		FsCallPrim(o, es,__,__): {
			foldi(es, acc, \i, ac, x -> fsExpVarIncs(x, ac, last, i, o));
		}
		FsCast(e1,__,__,__): {
			fsExpVarIncs(e1, acc, last, -1, FsOrPrim());
		}
		FsVarUse(x, kind, last1, id): {
			call_case = \-> if (fsContainsLast(e, last, id, x.name)) acc else {
				switch (lookupTree(acc, x)) {
					Some(p): setTree(acc, x, FsMemOps(p with incs = p.incs + 1));
					None(): setTree(acc, x, FsMemOps(x, 1, false));
				}
			}
			prim_case = \-> if (!fsContainsLast(e, last, id, x.name)) acc else {
				switch (lookupTree(acc, x)) {
					Some(p): setTree(acc, x, FsMemOps(p with dec = true));
					None(): setTree(acc, x, FsMemOps(x, 0, true));
				}
			}
			if (fiTypeIsScalar(x.type)) acc else {
				switch (kind) {
					FsVarGlobalFunc(): acc;
					FsVarUninit(): acc;
					default: {
						if (fs_fast_prim_ops) {
							switch (op) {
								FsGePrim(): prim_case();
								FsLePrim(): prim_case();
								FsGtPrim(): prim_case();
								FsLtPrim(): prim_case();
								FsEqPrim(): prim_case();
								FsNePrim(): prim_case();
								FsFieldPrim(__,__): prim_case();
								FsIndexPrim(): prim_case();
								FsDerefPrim(): prim_case();
								default: call_case();
							}
						} else {
							call_case();
						}
					}
				}
			}
		}
		FsConst(c, id): acc;
	}
}

fsAddExp2Mem(acc: FsMem, e: FsExp, last: [Set<string>], op: Maybe<FsPrim>) -> FsMem {
	switch (e) {
		FsClosure(closure, __,__): {
			fold(closure, acc, \ac, x -> fsAddExp2Mem(ac, x, last, None()));
		}
		FsCall(f, args,__,__): {
			fold(args, fsAddExp2Mem(acc, f, last, None()), \ac, x ->
				fsAddExp2Mem(ac, x, last, None())
			);
		}
		FsCallPrim(o, es,__,__): {
			fold(es, acc, \ac, x -> fsAddExp2Mem(ac, x, last, Some(o)));
		}
		FsCast(e1,__,__,__): {
			fsAddExp2Mem(acc, e1, last, None());
		}
		FsVarUse(x, kind, last1, id): {
			call_case = \-> if (fsContainsLast(e, last, id, x.name)) acc else {
				FsMem(acc with
					incs = setTree(acc.incs, x, lookupTreeDef(acc.incs, x, 0) + 1)
				);
			}
			prim_case = \-> if (!fsContainsLast(e, last, id, x.name)) acc else {
				FsMem(acc with decs = insertSet(acc.decs, x));
			}
			if (fiTypeIsScalar(x.type)) acc else {
				switch (kind) {
					FsVarGlobalFunc(): acc;
					FsVarUninit(): acc;
					default: {
						if (fs_fast_prim_ops) {
							switch (op) {
								Some(oper): {
									switch (oper) {
										FsGePrim(): prim_case();
										FsLePrim(): prim_case();
										FsGtPrim(): prim_case();
										FsLtPrim(): prim_case();
										FsEqPrim(): prim_case();
										FsNePrim(): prim_case();
										FsFieldPrim(__,__): prim_case();
										FsIndexPrim(): prim_case();
										FsDerefPrim(): prim_case();
										default: call_case();
									}
								}
								None(): call_case();
							}
						} else {
							call_case();
						}
					}
				}
			}
		}
		FsConst(c, id): acc;
	}
}

fsAddUnused2Mem(mem: FsMem, id: int, last: [Set<string>], name2var: Tree<string, FsVar>) -> FsMem {
	foldSet(last[id], mem, \acc, x ->
		FsMem(acc with unused = insertSet(acc.unused, lookupTreeDef(name2var, x, FsVar(x, FiTypeVoid()))))
	);
}

fsId2varsPre(s1: FsStat, num: int, debug: bool) -> [Set<string>] {
	id2vars = generate(0, num, \__ -> ref makeSet());
	fsFold2(s1, Cons(makeSet(), EmptyList()),
		\acc, x: FsAll -> {
			add_v = \ac, v -> if (fiTypeIsScalar(v.type)) ac else insertSet(ac, v.name);
			switch (x) {
				FsLambda(closure, args,__,__,id): {
					new_vars = fold(args, fold(closure, makeSet(), \ac, v -> add_v(ac, v)), \ac, v -> add_v(ac, v));
					id2vars[id] := new_vars;
					Cons(new_vars, acc);
				}
				FsLet(v,__,__,id): {
					id2vars[id] := acc.head;
					new_vars = add_v(acc.head, v);
					Cons(new_vars, acc.tail);
				}
				default: {
					if (x.id != -1) {
						id2vars[x.id] := acc.head;
					}
					acc;
				}
			}
		},
		\acc, x -> {
			switch (x) {
				FsLambda(__,__,__,__,id): {
					cast(acc.tail: List<Set<string>> -> Cons<Set<string>>);
				}
				default: acc;
			}
		},
		\args -> args,
		\p1, p2 -> Cons(mergeSets(p1.head, p2.head), p1.tail)
	);
	map(id2vars, \x -> ^x);
}

fsId2varsPreHash(s1: FsStat, num: int, debug: bool) -> [HashSet<string>] {
	id2vars = generate(0, num, \__ -> ref makeHashSet(fastHashString));
	fsFold2(s1, Cons(makeHashSet(fastHashString), EmptyList()),
		\acc, x: FsAll -> {
			add_v = \ac, v -> if (!fiTypeIsScalar(v.type)) insertHashSet(ac, v.name);
			switch (x) {
				FsLambda(closure, args,__,__,id): {
					new_vars = makeHashSet(fastHashString);
					iter(closure, \v -> add_v(new_vars, v));
					iter(args, \v -> add_v(new_vars, v));
					id2vars[id] := new_vars;
					Cons(new_vars, acc);
				}
				FsLet(v,__,__,id): {
					id2vars[id] := acc.head;
					new_vars = copyHashSet(acc.head);
					add_v(new_vars, v);
					Cons(new_vars, acc.tail);
				}
				default: {
					if (x.id != -1) {
						id2vars[x.id] := acc.head;
					}
					acc;
				}
			}
		},
		\acc, x -> {
			switch (x) {
				FsLambda(__,__,__,__,id): {
					cast(acc.tail: List<HashSet<string>> -> Cons<HashSet<string>>);
				}
				default: acc;
			}
		},
		\args -> args,
		\p1, p2 -> Cons(mergeHashSets(p1.head, p2.head), p1.tail)
	);
	map(id2vars, \x -> ^x);
}

fsPerceusShowStack(stack: List<Set<string>>) -> string {
	"[" + strGlue(fsPerceusDoShowStack(stack, []), ", ") + "]";
}

fsPerceusDoShowStack(stack: List<Set<string>>, acc: [string]) -> [string] {
	switch (stack) {
		Cons(s, t): {
			fsPerceusDoShowStack(t, arrayPush(acc, "{" +  strGlue(set2array(s), ", ") + "}"));
		}
		EmptyList(): acc;
	}
}


fsMergeSets(arr: [ref Set<string>], id: int, s: Set<string>) -> void {
	arr[id] := mergeSets(^(arr[id]), s);
}

fsId2varsPost(s1: FsStat, num: int, debug: bool) -> [Set<string>] {
	show_vars = \vs -> "[" + strGlue(set2array(vs), ", ") + "]";
	id2vars = generate(0, num, \__ -> ref makeSet());
	fsFold2(s1, Cons(makeSet(), EmptyList()),
		\acc, x -> {
			ret = switch (x) {
				FsLambda(__,__,__,__,id): {
					Cons(makeSet(), acc);
				}
				default: acc;
			}
			/*if (debug) {
				println(
					"(B) PRE id=" + i2s(x.id) + "\n" +
						"\tacc stack: " + fsPerceusShowStack(acc) + "\n" +
						"\tret stack: " + fsPerceusShowStack(ret) + "\n"
				);
			}*/
			ret;
		},
		\acc, x: FsAll -> {
			ret = switch (x) {
				FsLambda(__,__,__,__,id): {
					fsMergeSets(id2vars, id, acc.head);
					cast(acc.tail: List<Set<string>> -> Cons<Set<string>>);
				}
				FsVarUse(v, kind, last, id): {
					/*if (debug) {
						println("\t(B) id=" + i2s(id) + " var: " + toString(x) + "\n");
					}*/
					new_vars = switch (kind) {
						FsVarLocal(): {
							if (fiTypeIsScalar(v.type)) acc.head else insertSet(acc.head, v.name);
						}
						default: acc.head;
					}
					fsMergeSets(id2vars, id, acc.head);
					Cons(new_vars, acc.tail);
				}
				default: {
					if (x.id != -1) {
						fsMergeSets(id2vars, x.id, acc.head);
					}
					acc;
				}
			}
			/*if (debug) {
				println(
					"(B) POST id=" + i2s(x.id) + "\n" +
						"\tacc stack: " + fsPerceusShowStack(acc) + "\n" +
						"\tret stack: " + fsPerceusShowStack(ret) + "\n"
				);
			}*/
			ret;
		},
		\args -> reverseA(args),
		\p1, p2 -> Cons(mergeSets(p1.head, p2.head), p1.tail)
	);
	map(id2vars, \x -> ^x);
}

fsId2varsLast(s: FsStat, num: int, pre: [Set<string>], post: [Set<string>], debug: bool) -> [Set<string>] {
	show_hash_vars = \vs -> "[" + strGlue(hashSet2array(vs), ", ") + "]";
	show_set_vars = \vs -> "[" + strGlue(set2array(vs), ", ") + "]";
	id2vars = generate(0, num, \__ -> ref makeSet());
	t0 = ref 0.0;
	t1 = ref 0.0;
	t2 = ref 0.0;
	t3 = ref 0.0;
	t4 = ref 0.0;
	t5 = ref 0.0;
	hash2set = \x -> foldHashSet(x, makeSet(), \acc, v -> insertSet(acc, v));
	fsFold2(s, Cons(makeHashSet(fastHashString), makeList()),
		\acc: Cons<HashSet<string>>, x: FsAll -> {
			do_diff = \ -> {
				s0 = timestamp();
				diff = set2hashSet(pre[x.id], fastHashString);
				t0 := ^t0 + timestamp() - s0;

				s1 = timestamp();
				iterSet(post[x.id], \v -> removeHashSet(diff, v));
				t1 := ^t1 + timestamp() - s1;

				s2 = timestamp();
				iterHashSet(acc.head, \v -> removeHashSet(diff, v));
				t2 := ^t2 + timestamp() - s2;
				
				id2vars[x.id] := hash2set(diff);
				/*if (debug) {
					println(
						"(C) x.id: " + i2s(x.id) + "\n" +
						strIndent(
							"pre_vars: " + show_set_vars(pre[x.id]) + "\n" +
							"post_vars: " + show_set_vars(post[x.id]) + "\n" +
							"acc.head: " + show_hash_vars(acc.head) + "\n" //+
							"diff: " + show_hash_vars(diff) + "\n"
						)
					);
				}*/
				diff;
			}
			switch (x) {
				FsLambda(__,__,__,__,id): {
					/*if (debug) {
						println("(C) id=" + i2s(id) + " pushing stack: " + show_hash_vars(acc.head));
					}*/
					do_diff();
					Cons(makeHashSet(fastHashString), acc);
				}
				default: {
					if (x.id == -1) acc else {
						diff = do_diff();
						s3 = timestamp();
						new_head = mergeHashSets(acc.head, diff);
						t3 := ^t3 + timestamp() - s3;
						Cons(new_head, acc.tail);
					}
				}
			}
		},
		\acc, x -> {
			switch (x) {
				FsLambda(__,__,__,__,id): {
					cast(acc.tail: List<HashSet<string>> -> Cons<HashSet<string>>);
				}
				default: acc;
			}
		},
		\args -> args,
		\p1, p2 -> {
			s4 = timestamp();
			new_head = mergeHashSets(p1.head, p2.head);
			t4 := ^t4 + timestamp() - s4;
			Cons(new_head, p1.tail)
		}
	);
	fsShowTiming1("BBB: t0: ", ^t0);
	fsShowTiming1("BBB: t1: ", ^t1);
	fsShowTiming1("BBB: t2: ", ^t2);
	fsShowTiming1("BBB: t3: ", ^t3);
	fsShowTiming1("BBB: t4: ", ^t4);
	fsShowTiming1("BBB: t5: ", ^t5);
	map(id2vars, \x -> ^x);
}

fsId2varsLastHash(s: FsStat, num: int, pre: [HashSet<string>], post: [Set<string>], debug: bool) -> [Set<string>] {
	show_hash_vars = \vs -> "[" + strGlue(hashSet2array(vs), ", ") + "]";
	show_set_vars = \vs -> "[" + strGlue(set2array(vs), ", ") + "]";
	id2vars = generate(0, num, \__ -> ref makeSet());
	t0 = ref 0.0;
	t1 = ref 0.0;
	t2 = ref 0.0;
	t3 = ref 0.0;
	t4 = ref 0.0;
	t5 = ref 0.0;
	hash2set = \x -> foldHashSet(x, makeSet(), \acc, v -> insertSet(acc, v));
	fsFold2(s, Cons(makeHashSet(fastHashString), makeList()),
		\acc: Cons<HashSet<string>>, x: FsAll -> {
			do_diff = \ -> {
				s0 = timestamp();
				diff = copyHashSet(pre[x.id]);
				t0 := ^t0 + timestamp() - s0;

				s1 = timestamp();
				iterSet(post[x.id], \v -> removeHashSet(diff, v));
				t1 := ^t1 + timestamp() - s1;

				s2 = timestamp();
				iterHashSet(acc.head, \v -> removeHashSet(diff, v));
				t2 := ^t2 + timestamp() - s2;
				
				id2vars[x.id] := hash2set(diff);
				/*if (debug) {
					println(
						"(C) x.id: " + i2s(x.id) + "\n" +
						strIndent(
							"pre_vars: " + show_hash_vars(pre[x.id]) + "\n" +
							"post_vars: " + show_set_vars(post[x.id]) + "\n" +
							"acc.head: " + show_hash_vars(acc.head) + "\n" //+
							"diff: " + show_hash_vars(diff) + "\n"
						)
					);
				}*/
				diff;
			}
			switch (x) {
				FsLambda(__,__,__,__,id): {
					/*if (debug) {
						println("(C) id=" + i2s(id) + " pushing stack: " + show_hash_vars(acc.head));
					}*/
					do_diff();
					Cons(makeHashSet(fastHashString), acc);
				}
				default: {
					if (x.id == -1) acc else {
						diff = do_diff();
						s3 = timestamp();
						new_head = mergeHashSets(acc.head, diff);
						t3 := ^t3 + timestamp() - s3;
						Cons(new_head, acc.tail);
					}
				}
			}
		},
		\acc, x -> {
			switch (x) {
				FsLambda(__,__,__,__,id): {
					cast(acc.tail: List<HashSet<string>> -> Cons<HashSet<string>>);
				}
				default: acc;
			}
		},
		\args -> args,
		\p1, p2 -> {
			s4 = timestamp();
			new_head = mergeHashSets(p1.head, p2.head);
			t4 := ^t4 + timestamp() - s4;
			Cons(new_head, p1.tail)
		}
	);
	fsShowTiming1("BBB: t0: ", ^t0);
	fsShowTiming1("BBB: t1: ", ^t1);
	fsShowTiming1("BBB: t2: ", ^t2);
	fsShowTiming1("BBB: t3: ", ^t3);
	fsShowTiming1("BBB: t4: ", ^t4);
	fsShowTiming1("BBB: t5: ", ^t5);
	map(id2vars, \x -> ^x);
}

fsIds(new_id: () -> int) -> (FsAll) -> FsAll {
	\s -> switch(s) {
		FsIf(c,__,__,__):         FsIf(s with id = new_id(), cond = fsExpSetId(c, new_id()));
		FsSwitch(__,__,__,__):    FsSwitch(s with id = new_id());
		FsSeq(__, __):            FsSeq(s with id = new_id());
		FsWrapExp(e,__):          FsWrapExp(s with id = new_id(), e = fsExpSetId(e, new_id()));
		FsRet(e,__):              FsRet(s with id = new_id(), e = fsExpSetId(e, new_id()));
		FsAssign(e1, e2,__):      FsAssign(s with id = new_id(), to = fsExpSetId(e1, new_id()), what = fsExpSetId(e2, new_id()));
		FsLet(__,e,__,__):        FsLet(s with id = new_id(), e = fsExpSetId(e, new_id()));
		FsLambda(__,__,__,__,__): FsLambda(s with id = new_id());
		FsVarUse(__,__,__,__):    FsVarUse(s with id = new_id());
		default: s;
	}
}

fsCountId(s: FsAll) -> int {
	switch(s) {
		FsIf(c,__,__,__):         2;
		FsSwitch(__,__,__,__):    1;
		FsSeq(__, __):            1;
		FsWrapExp(e,__):          2;
		FsRet(e,__):              2;
		FsAssign(e1, e2,__):      3;
		FsLet(__,e,__,__):        2;
		FsLambda(__,__,__,__,__): 1;
		FsVarUse(__,__,__,__):    1;
		default:                  0;
	}
}


fsSetId(s: FsAll, x: int) -> FsAll {
	switch(s) {
		FsStat():  fsStatSetId(s, x);
		FsExp():   fsExpSetId(s, x);
		FsLambda(__,__,__,__,__): FsLambda(s with id = x);
	}
}

fsStatSetId(s: FsStat, x: int) -> FsStat {
	switch(s) {
		FsIf(__,__,__,__):     FsIf(s with id = x);
		FsSwitch(__,__,__,__): FsSwitch(s with id = x);
		FsSeq(__, __):         FsSeq(s with id = x);
		FsWrapExp(__,__):      FsWrapExp(s with id = x);
		FsRet(__,__):          FsRet(s with id = x);
		FsTailCall(__):        FsTailCall(e with id = x);
		FsAssign(__,__,__):    FsAssign(s with id = x);
		FsLet(__,__,__,__):    FsLet(s with id = x);
		FsIncRc(__,__,__):     FsIncRc(s with id = x);
		FsDecRc(__,__,__):     FsDecRc(s with id = x);
	}
}

fsExpSetId(e: FsExp, x: int) -> FsExp {
	switch(e) {
		FsVarUse(__,__,__,__):    FsVarUse(e with id = x);
		FsClosure(__,__,__):      FsClosure(e with id = x);
		FsCall(__,__,__,__):      FsCall(e with id = x);
		FsCallPrim(__,__,__,__):  FsCallPrim(e with id = x);
		FsCast(__,__,__,__):      FsCast(e with id = x);
		FsConst(__,__):           FsConst(e with id = x);
	}
}

/*
fsVerifyControlFlowPaths(s: FsAll, num_nodes: int, last: [Set<string>], name: string, debug: ref bool, crash: ref bool) -> void {
	num_paths = ref makeTree();
	fsNumControlFlowPaths(s, num_paths);
	total_paths = foldTree(^num_paths, 0.0, \__,n, acc -> acc + n);
	//println("\tnum paths:\n" + 
	//	superglue(tree2pairs(^num_paths), \p -> "\t\tid: " + i2s(p.first) + ", num paths: " + d2s(p.second), "\n")
	//);
	println("\tstat perceus: " + name + ", ids: " + i2s(num_nodes) + ", num paths: " + d2s(total_paths));

	id2node = generate(0, num_nodes, \__ -> ref FsConst(FiVoid(-1), -1));
	fsIter(s, \x -> if (x.id != -1) id2node[x.id] := x, true);


	if (total_paths < 1000000.0) {
		println("\t\tverifying Paths...");
		cmp_last_sets = \all_vars: Set<string>, last_vars: Set<string> -> if (sizeSet(all_vars) == sizeSet(last_vars)) true else {
			println(name + ": sizeSet(all_vars) != sizeSet(last_vars):\n" +
				i2s(sizeSet(all_vars)) + " != " + i2s(sizeSet(last_vars)) + "\n" +
				"all_vars: {" + strGlue(set2array(all_vars), ", ") + "}\n" +
				"last_vars: {" + strGlue(set2array(last_vars), ", ") + "}\n" +
				"missing: [" + strGlue(set2array(differenceSets(all_vars, last_vars)), ", ") + "]\n"
			);
			crash := true;
			debug := true;
			false;
		}
		cf_paths: ref Tree<int, [[int]]> = ref makeTree();
		fsControlFlowPaths(s, cf_paths);
		traverseInOrder(^cf_paths, \id, paths -> {
			num = lookupTreeDef(^num_paths, id, -1.0);
			if (i2d(length(paths)) != num) {
				println(name + ": length(paths) != num: " + i2s(length(paths)) + " != " + d2s(num));
				crash := true;
				debug := true;
			}
			lambda = cast(^(id2node[id]): FsAll -> FsLambda);
			if (^debug) {
				println("Lambda: " + i2s(id) + "\n" + 
					"CF paths:\n" + superglue(paths, \path -> "\t[" + superglue(path, i2s, ", ") + "]" , "\n") + "\n"
				)
			}
			iter(paths, \path -> {
				vars1 = fold(lambda.args, 
					fold(lambda.closure, 
						makeSet(), 
						\ac, v -> if (fiTypeIsScalar(v.type)) ac else insertSet(ac, v.name)
					), 
					\ac, arg -> if (fiTypeIsScalar(arg.type)) ac else insertSet(ac, arg.name)
				);
				vars = fold(path, vars1, \acc, i -> switch (^(id2node[i])) {
					FsLet(v,__,__,__,__): if (fiTypeIsScalar(v.type)) acc else insertSet(acc, v.name);
					default: acc;
				});
				last = fold(path, makeSet(), \acc, i -> if (i == -1) acc else mergeSets(acc, last[i]));
				if (!cmp_last_sets(vars, last)) {
					println(
						"id: " + i2s(id) + "\n" +
						"path: [" + superglue(path, i2s, ", ") + "]\n" + 
						"vars: {" + strGlue(set2array(vars), ", ") + "}\n" +
						"lasts: [\n" +
							superglue(path, \i -> "\t" +  i2s(i) + ": {" + strGlue(set2array(last[i]), ", ") + "}", "\n") +
						"\n]\n" +
						"lambda:\n" + strIndent(fs2s(^(id2node[id])))
					);
				}
			});
		});
		println("\t\t... verified " + d2s(total_paths) + " paths");
	}
}

fsControlFlowPaths(s: FsAll, acc: ref Tree<int, [[int]]>) -> [[int]] {
	check_single_branch = \branches -> {
		if (length(branches) > 1) {
			fail0("multy branches in:\n" + fs2s(s) + "\n" +
				"branches:\n" + superglue(branches, \branch -> "\t[" + superglue(branch, i2s, ", ") + "]", "\n")
			);
		} else if (length(branches) == 0) {
			fail0("no branches in:\n" + fs2s(s));
		} else {
			branches[0] 
		}
	}
	id_path = \id -> if (id == -1) [] else [id];
	switch (s) {
		FsIf(cond, s1, s2, id): {
			cond_cf = fsControlFlowPaths(cond, acc);
			s1_cf = fsControlFlowPaths(s1, acc);
			s2_cf = fsControlFlowPaths(s2, acc);
			mapConcat(cond_cf, \cond_path ->
				map(concat(s1_cf, s2_cf), \s_path ->
					concat3(id_path(id), cond_path, s_path),
				)
			);
		}
		FsSwitch(x,__, cs,id): {
			x_cf = fsControlFlowPaths(x, acc);
			forking = concatA(map(cs, \c ->
				map(fsControlFlowPaths(c.body, acc), \c_path ->
					concat(id_path(c.id), c_path)
				)
			));
			mapConcat(x_cf, \x_path ->
				map(forking, \c_path ->
					concat3(id_path(id), x_path, c_path)
				)
			);
		}
		FsSeq(ss, id): {
			fold(ss, [id_path(id)], \ac, x -> {
				x_cf = fsControlFlowPaths(x, acc);
				mapConcat(ac, \ac_path ->
					map(x_cf, \x_path ->
						concat(ac_path, x_path)
					)
				);
			});
		}
		FsLet(__, e1, s1, id): {
			e1_cf = fsControlFlowPaths(e1, acc);
			s1_cf = fsControlFlowPaths(s1, acc);
			mapConcat(e1_cf, \e1_path -> 
				map(s1_cf, \s1_path -> concat3(id_path(id), e1_path, s1_path))
			);
		}
		FsWrapExp(e1, id): {
			e1_cf = fsControlFlowPaths(e1, acc);
			map(e1_cf, \e1_path -> concat(id_path(id), e1_path));
		}
		FsRet(e1, id): {
			e1_cf = fsControlFlowPaths(e1, acc);
			map(e1_cf, \e1_path -> concat(id_path(id), e1_path));
		}
		FsTailCall(id): [id_path(id)];
		FsAssign(to, what, id): {
			to_cf = fsControlFlowPaths(to, acc);
			what_cf = fsControlFlowPaths(what, acc);
			mapConcat(to_cf, \to_path -> 
				map(what_cf, \what_path -> concat3(id_path(id), to_path, what_path))
			);
		}
		FsIncRc(__,e1,id): {
			e1_cf = fsControlFlowPaths(e1, acc);
			map(e1_cf, \e1_path -> concat(id_path(id), e1_path));
		}
		FsDecRc(e1, __, id): {
			e1_cf = fsControlFlowPaths(e1, acc);
			map(e1_cf, \e1_path -> concat(id_path(id), e1_path));
		}
		FsClosure(vs, lam, id): {
			vs_cf = map(vs, \v ->
				check_single_branch(fsControlFlowPaths(v, acc))
			);
			fsControlFlowPaths(lam, acc);
			[concatA(concat([id_path(id)], vs_cf))];
		}
		FsLambda(__,__,e1,__,id): {
			e1_cf = fsControlFlowPaths(e1, acc);
			acc := setTree(^acc, id, e1_cf);
			[id_path(id)];
		}
		FsCall(fn, args, __,id): {
			fn_cf = check_single_branch(fsControlFlowPaths(fn, acc));
			args_cf = map(args, \arg ->
				check_single_branch(fsControlFlowPaths(arg, acc))
			);
			[concatA(concat([id_path(id), fn_cf], args_cf))];
		}
		FsCallPrim(__,es,__,id): {
			es_cf = map(es, \x ->
				check_single_branch(fsControlFlowPaths(x, acc))
			);
			[concatA(concat([id_path(id)], es_cf))];
		}
		FsCast(e1,__,__,id): {
			e1_cf = fsControlFlowPaths(e1, acc);
			map(e1_cf, \e1_path -> concat(id_path(id), e1_path));
		}
		FsVarUse(__,__,__,id): [id_path(id)];
		FsConst(__,id): [id_path(id)];
	}
}

fsNumControlFlowPaths(s: FsAll, acc: ref Tree<int, double>) -> double {
	switch (s) {
		FsIf(cond, s1, s2, id): {
			fsNumControlFlowPaths(cond, acc) * (fsNumControlFlowPaths(s1, acc) + fsNumControlFlowPaths(s2, acc));
		}
		FsSwitch(x,__, cs,id): {
			fsNumControlFlowPaths(x, acc) * fold(cs, 0.0, \ac, c -> ac + fsNumControlFlowPaths(c.body, acc));
		}
		FsSeq(ss, id): {
			fold(ss, 1.0, \ac, x -> ac * fsNumControlFlowPaths(x, acc));
		}
		FsLet(__, e1, s1, id): {
			fsNumControlFlowPaths(e1, acc) * fsNumControlFlowPaths(s1, acc);
		}
		FsWrapExp(e1, id): {
			fsNumControlFlowPaths(e1, acc);
		}
		FsRet(e1, id): {
			fsNumControlFlowPaths(e1, acc);
		}
		FsTailCall(id): {
			1.0;
		}
		FsAssign(to, what, id): {
			fsNumControlFlowPaths(to, acc) * fsNumControlFlowPaths(what, acc);
		}
		FsIncRc(__,e1,id): {
			fsNumControlFlowPaths(e1, acc);
		}
		FsDecRc(e1, __, id): {
			fsNumControlFlowPaths(e1, acc);
		}
		FsClosure(vs, lam, id): {
			fsNumControlFlowPaths(lam, acc);
			1.0;
		}
		FsLambda(__,__,e1,__,id): {
			e1_num = fsNumControlFlowPaths(e1, acc);
			acc := setTree(^acc, id, e1_num);
			1.0;
		}
		FsCall(fn, args, __,id): {
			fold(args, fsNumControlFlowPaths(fn, acc), \ac, arg ->
				ac * fsNumControlFlowPaths(arg, acc)
			);
		}
		FsCallPrim(__,es,__,id): {
			fold(es, 1.0, \ac, x ->
				ac * fsNumControlFlowPaths(x, acc)
			);
		}
		FsCast(e1,__,__,id): {
			fsNumControlFlowPaths(e1, acc);
		}
		FsVarUse(__,__,__,id): 1.0;
		FsConst(__,id): 1.0;
	}
}

*/