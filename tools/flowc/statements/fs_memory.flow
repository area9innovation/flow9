import ds/array;
import ds/multiset;
import tools/flowc/incremental/fi_helpers;
import tools/flowc/statements/fs_transform;

export {
	fsStatPerceus(s: FsStat, names: FiGlobalNames) -> FsStat;
	fsExpPerceus(e: FsExp, names: FiGlobalNames) -> FsExp;
}

fsStatPerceus(s: FsStat, names: FiGlobalNames) -> FsStat {
	s1 = fsStatLastVarUsage(s, makeSet()).first;
	fsDoStatPerceus(s1, [], names).first;
	//fsStatMap(fsDoStatPerceus(s1, [], names).first, fsStatOptimize, idfn);
}

fsExpPerceus(e: FsExp, names: FiGlobalNames) -> FsExp {
	e1 = fsExpLastVarUsage(e, makeSet()).first;
	fsDoExpPerceus(e1, names);
	//fsExpMap(fsDoExpPerceus(e1, names), fsStatOptimize, idfn);
}

fsDoStatPerceus(s: FsStat, locals: [FsVar], names: FiGlobalNames) -> Pair<FsStat, [FsVar]> {
	remove_finalized = \x, locs -> filter(locs, \v -> 
		forall(fsExpVars(x, []), \w -> !(w.last && w.name == v.name))
	);
	switch (s) {
		FsIf(cond, s1, s2): {
			expOps = fsExpMemOps(cond, names);
			new_locals = remove_finalized(cond, locals);
			t_s1 = fsDoStatPerceus(s1, new_locals, names);
			t_s2 = fsDoStatPerceus(s2, new_locals, names);
			Pair(fsWrapSeq(concat(
				expOps,
				[FsIf(s with
					cond = fsDoExpPerceus(cond, names),
					s1 = fsWrapSeq(fsUnwrapSeq(fsInsertDecUnused(t_s1.first, new_locals))),
					s2 = fsWrapSeq(fsUnwrapSeq(fsInsertDecUnused(t_s2.first, new_locals)))
				)]
			)), new_locals);
		}
		FsSwitch(x, sw_type, cases): {
			xOps = fsExpMemOps(x, names);
			new_locals = remove_finalized(x, locals);
			Pair(fsWrapSeq(concat(
				xOps,
				[FsSwitch(s with 
					cases = map(cases, \c -> {
						c_m = fsDoStatPerceus(c.body, new_locals, names).first;
						FsCase(c with 
							body = fsWrapSeq(
								fsUnwrapSeq(fsInsertDecUnused(c_m, new_locals))
							)
						)
					})
				)]
			)), new_locals);
		}
		FsSeq(es): {
			p_es = fold(es, Pair([], locals), \acc, x -> {
				p_x = fsDoStatPerceus(x, acc.second, names);
				Pair(concat(acc.first, fsUnwrapSeq(p_x.first)), p_x.second);
			});
			Pair(fsWrapSeq(p_es.first), p_es.second);
		}
		FsLet(name, type, e1, s1): {
			expOps = fsExpMemOps(e1, names);
			new_locals = remove_finalized(e1, locals);
			t_s1 = fsDoStatPerceus(s1, new_locals, names);
			Pair(fsWrapSeq(concat(
				expOps,
				[FsLet(s with
					e = fsDoExpPerceus(e1, names),
					s = fsWrapSeq(fsUnwrapSeq(fsInsertDecUnused(t_s1.first, new_locals)))
				)]
			)), new_locals);
		}
		FsVarDef(v, e): {
			eOps = fsExpMemOps(e, names);
			Pair(
				fsWrapSeq(concat(
					eOps,
					[FsVarDef(s with e = fsDoExpPerceus(e, names))],
				)),
				concat(remove_finalized(e, locals), [v])
			);
		}
		FsWrapExp(e): {
			eOps = fsExpMemOps(e, names);
			Pair(
				fsWrapSeq(concatA([
					eOps, 
					[FsWrapExp(s with e = fsDoExpPerceus(e, names))],
					if (fsExpType(e) == FiTypeVoid()) [] else [FsMemory(FsDecRc(1), e)],
				])),
				remove_finalized(e, locals)
			);
		}
		FsRet(e): {
			Pair(
				FsRet(s with e = fsDoExpPerceus(e, names)),
				remove_finalized(e, locals)
			);
		}
		/*FsTailCall(args): {
			Pair(s, locals);
		}*/
		FsTailCall(): {
			Pair(s, locals);
		}
		FsVarDecl(var): {
			//Pair(s, concat(locals, [var]));
			Pair(s, locals);
		}
		FsAssign(to, what): {
			toOps = fsExpMemOps(to, names);
			whatOps = fsExpMemOps(what, names);
			Pair(
				fsWrapSeq(concat(
					concat(toOps, whatOps),
					[FsAssign(s with to = fsDoExpPerceus(to, names), what = fsDoExpPerceus(what, names))]
				)), 
				remove_finalized(what, remove_finalized(to, locals))
			);
		}
		FsMemory(op, e): {
			Pair(
				FsMemory(s with e = fsDoExpPerceus(e, names)),
				remove_finalized(e, locals)
			);
		}
	}
}

fsExpMemOps(ex: FsExp, names: FiGlobalNames) -> [FsMemory] {
	vars1 = fsExpVars(ex, []);
	vars2 = filter(vars1, \v -> !fiTypeIsScalar(v.type) && !fiIsGlobalFunction(v.name, names));
	filtermap(vars2, \v -> 
		if (v.last) None() else Some(FsMemory(FsIncRc(1), v))
	);
}

fsExpVars(ex: FsExp, vars: [FsVar]) -> [FsVar] {
	switch (ex) {
		FsCall(f, args, type): {
			fold(args, fsExpVars(f, vars), \acc, x -> fsExpVars(x, acc));
		}
		FsLambda(toplevel, closure, args, body, type): {
			fold(closure, vars, \acc, x -> concat(acc, [x]));
			// Maybe just vars?
		}
		FsCallPrim(op, es, type): {
			fold(es, vars, \acc, x -> fsExpVars(x, acc));
		}
		FsCast(e,__,__): {
			fsExpVars(e, vars);
		}
		FsVar(name,__,__): {
			concat(vars, [ex]);
		}
		FiString(s, __): vars;
		FiVoid(__):      vars;
		FiBool(b, __):   vars;
		FiInt(i, __):    vars;
		FiDouble(d, __): vars;
	}
}

fsStatVars(s: FsStat, vars: [FsVar]) -> [FsVar] {
	switch (s) {
		FsIf(cond, s1, s2): {
			fsStatVars(s2, fsStatVars(s1, fsExpVars(cond, vars)));
		}
		FsSwitch(x, sw_type, cases): {
			fold(cases, concat(vars, [x]), \acc, c -> fsStatVars(c.body, acc));
		}
		FsSeq(es): {
			fold(es, vars, \acc, x -> fsStatVars(x, acc));
		}
		FsLet(name, type, e1, s1): {
			fsStatVars(s1, fsExpVars(e1, vars));
		}
		FsVarDef(v, e): {
			fsExpVars(e, vars);
		}
		FsWrapExp(e): {
			fsExpVars(e, vars);
		}
		FsRet(e): {
			fsExpVars(e, vars);
		}
		/*FsTailCall(args): {
			fold(args, vars, \acc, arg -> fsExpVars(arg, acc));
		}*/
		FsTailCall(): {
			vars;
		}
		FsVarDecl(var): {
			vars;
		}
		FsAssign(to, what): {
			fsExpVars(what, fsExpVars(to, vars));
		}
		FsMemory(op, e): {
			fsExpVars(e, vars);
		}
	}
}

fsInsertDecUnused(s: FsStat, locals: [FsVar]) -> FsStat {
	s_vars = map(fsStatVars(s, []), \v -> v.name);
	unused_vars = filter(locals, \v -> !fiTypeIsScalar(v.type) && !contains(s_vars, v.name));
	if (length(unused_vars) == 0) s else {
		FsSeq(concat(
			map(unused_vars, \v -> 
				FsMemory(FsDecRc(1), v)
			),
			fsUnwrapSeq(s)
		));
	}
}

fsDoExpPerceus(ex: FsExp, names: FiGlobalNames) -> FsExp {
	switch (ex) {
		FsCall(f, args, type): {
			FsCall(ex with f = fsDoExpPerceus(f, names), args = map(args, \x -> fsDoExpPerceus(x, names)));
		}
		FsLambda(toplevel, closure, args, body, type): {
			arg_vars = map(args, \arg -> FsVar(arg.name, false, arg.type));
			FsLambda(ex with body = fsInsertDecUnused(fsDoStatPerceus(body, arg_vars, names).first, arg_vars));
		}
		FsCallPrim(op, es, type): {
			FsCallPrim(ex with es = map(es, \x -> fsDoExpPerceus(x, names)));
		}
		FsCast(e, from, type): {
			FsCast(ex with e = fsDoExpPerceus(e, names));
		}
		FsVar(name,__,__): ex;
		FiString(s, __): ex;
		FiVoid(__):      ex;
		FiBool(b, __):   ex;
		FiInt(i, __):    ex;
		FiDouble(d, __): ex;
	}
}

/*fsStatOptimize(s: FsStat) -> FsStat {
	switch (s) {
		FsSeq(ss): {
			equal_e = \e1, e2 -> switch (e1) {
				FsVar(name1,__,__):
					switch (e2) {
						FsVar(name2,__,__): name1 == name2;
						default: false;
					}
				default: false;
			}
			delta = \x1, x2 -> {
				switch (x1) {
					FsMemory(op1, e1): {
						switch (x2) {
							FsMemory(op2, e2): {
								if (!equal_e(e1, e2)) None() else {
									switch (op1) {
										FsIncRc(d1): 
											switch (op2) {
												FsDecRc(d2): Some(Pair(d1 - d2, e1));
												default: None();
											}
										default: None();
									}
								}
							}
							default: None();
						}
					}
					default: None();
				}
			}
			FsSeq(s with 
				ss = transformArrayPairs(
					mapConcat(ss, fsUnwrapSeq), 
					\x1, x2 -> maybeMap(delta(x1, x2), \p ->
						if (p.first == 0) [] else [FsMemory(FsRC(p.first), p.second)]
					)
				)
			);
		}
		default: s;
	}
}
*/

// Traverse the AST backwards and markup the first variable use as last

fsStatLastVarUsage(ex: FsStat, vars: Set<string>) -> Pair<FsStat, Set<string>> {
	switch(ex) {
		FsIf(cond, s1, s2): {
			p1 = fsStatLastVarUsage(s1, vars);
			p2 = fsStatLastVarUsage(s2, vars);
			c = fsExpLastVarUsage(cond, mergeSets(p1.second, p2.second));
			Pair(
				FsIf(ex with 
					cond = c.first,
					s1 = p1.first,
					s2 = p2.first
				),
				c.second
			);
		}
		FsSwitch(v, type, cases): {
			cases_ps = map(cases, \c -> {
				p = fsStatLastVarUsage(c.body, vars);
				Pair(FsCase(c with body = p.first), p.second);
			});
			vars1 = fold(cases_ps, vars, \acc, p -> mergeSets(acc, p.second));
			Pair(
				FsSwitch(ex with
					x = FsVar(v with last = !containsSet(vars1, v.name)),
					cases = map(cases_ps, \p -> p.first)
				),
				insertSet(vars1, v.name)
			);
		}
		FsSeq(ss): {
			ps = foldr(ss, Pair([], vars), \acc, x -> {
				p = fsStatLastVarUsage(x, acc.second);
				Pair(concat([p.first], acc.first), p.second);
			});
			Pair(
				FsSeq(ex with ss = ps.first),
				ps.second
			);
		}
		FsLet(__,__, e1, s1): {
			p1 = fsStatLastVarUsage(s1, vars);
			p2 = fsExpLastVarUsage(e1, p1.second);
			Pair(
				FsLet(ex with 
					e = p2.first,
					s = p1.first
				),
				p2.second
			);
		}
		FsAssign(to, what): {
			p1 = fsExpLastVarUsage(what, vars);
			p2 = fsExpLastVarUsage(to, p1.second);
			Pair(
				FsAssign(ex with
					to = p2.first,
					what = p1.first
				),
				p2.second
			);
		}
		FsMemory(op, e): {
			p = fsExpLastVarUsage(e, vars);
			Pair(FsMemory(ex with e = p.first), p.second);
		}
		FsWrapExp(e): {
			p = fsExpLastVarUsage(e, vars);
			Pair(FsWrapExp(ex with e = p.first), p.second);
		}
		FsRet(e): {
			p = fsExpLastVarUsage(e, vars);
			Pair(FsRet(ex with e = p.first), p.second);
		}
		FsVarDef(v, e): {
			p = fsExpLastVarUsage(e, vars);
			Pair(
				FsVarDef(ex with 
					var = FsVar(v with last = !containsSet(p.second, v.name)),
					e = p.first
				),
				insertSet(p.second, v.name)
			);
		}
		/*FsTailCall(args): {
			ps = foldr(args, Pair([], vars), \acc, x -> {
				p = fsExpLastVarUsage(x, acc.second);
				Pair(concat([p.first], acc.first), p.second);
			});
			Pair(FsTailCall(ps.first), ps.second);
		}*/
		FsTailCall(): {
			Pair(ex, vars);
		}
		FsVarDecl(var): {
			Pair(ex, vars);
		}
	}
}

fsExpLastVarUsage(ex: FsExp, vars: Set<string>) -> Pair<FsExp, Set<string>> {
	switch(ex) {
		FsLambda(toplevel, closure, args, body, __): {
			p = fsStatLastVarUsage(body, makeSet());
			Pair(FsLambda(ex with body = p.first), vars);
		}
		FsCall(fn, args, __): {
			ps = foldr(args, Pair([], vars), \acc, x -> {
				p = fsExpLastVarUsage(x, acc.second);
				Pair(concat([p.first], acc.first), p.second);
			});
			fp = fsExpLastVarUsage(fn, ps.second);
			Pair(
				FsCall(ex with
					f = fp.first,
					args = ps.first
				),
				fp.second
			);
		}
		FsCallPrim(op, es, __): {
			ps = foldr(es, Pair([], vars), \acc, x -> {
				p = fsExpLastVarUsage(x, acc.second);
				Pair(concat([p.first], acc.first), p.second);
			});
			Pair(FsCallPrim(ex with es = ps.first), ps.second);
		}
		FsVar(name, last,__): {
			Pair(
				FsVar(ex with last = !containsSet(vars, name)), 
				insertSet(vars, name)
			);
		}
		default: Pair(ex, vars);
	}
}
