import string_utils;
import tools/flowc/statements/fs_transform;
import tools/flowc/incremental/fi_helpers2;

export {
	fsInlineStat(s: FsStat, names: FiGlobalNames, stat_name: string, debug: bool) -> FsStat;
}

fsInlineStat(s: FsStat, names: FiGlobalNames, stat_name: string, debug: bool) -> FsStat {
	tmp_var_counter = ref 0;
	new_id = \-> {
		id = i2s(^tmp_var_counter);
		tmp_var_counter := ^tmp_var_counter + 1;
		id;
	}
	inlined = fsInlineStatInStat(s, names, new_id, makeTree(), debug);
	cast(fsRemoveUnusedVars(inlined): FsAll -> FsStat);
}

fsRemoveUnusedVars(s: FsAll) -> FsAll {
	fsMap(s, \x -> switch (x) {
		FsLet(v, e, s1,__,nx): {
			if (fsVarIsUsedInStat(v.name, s1)) x else {
				s1
			}
		}
		default: x;
	}, false);
}

fsInlineStatInStat(s: FsStat, names: FiGlobalNames, new_id: () -> string, locals: Tree<string, FsExp>, debug: bool) -> FsStat {
	s1 = switch (s) {
		FsLet(v, e, s0,__,__): {
			e1 = switch (e) {
				FsClosure(__,lambda,__,__): {
					FsClosure(e with
						lambda = FsLambda(lambda with
							body = fsInlineStatInStat(lambda.body, names, new_id, makeTree(), debug)
						)
					);
				}
				default: e;
			}
			s1 = FsLet(s with
				e = e1,
				s = fsInlineStatInStat(s0, names, new_id, setTree(locals, v.name, e1), debug)
			);
			switch (e1) {
				FsCall(fn, args, type,__): {
					if (fn.var.name == "fold") {
						arg_2 = args[2];
						switch (arg_2) {
							FsVarUse(fn_var,__,__): {
								switch (lookupTree(locals, fn_var.name)) {
									Some(fold_fn): {
										switch (fold_fn) {
											FsClosure(__,__,__,__): {
												fold_var = fiMakeNewVar("__fold", new_id(), makeTree(), names);
												arr_type = fiDearrayType(fsType(args[0]));
												arr_var = args[0];
												switch (arr_var) {
													FsVarUse(__,__,__): {
														fsInlineFold(v,
															FsVar(fold_var, arr_type),
															arr_var, args[1], fold_fn, s1.s, debug
														);
													}
													default: fail0("non-scalar argument must be a variable, got: " + fs2s(args[0]));
												}
											}
											default: s1;
										}
									}
									None(): s1;
								}
							}
							FsClosure(__,__,__,__): {
								fold_fn = arg_2;
								fold_var = fiMakeNewVar("__fold", new_id(), makeTree(), names);
								arr_type = fiDearrayType(fsType(args[0]));
								arr_var = args[0];
								switch (arr_var) {
									FsVarUse(__,__,__): {
										fsInlineFold(v,
											FsVar(fold_var, arr_type),
											arr_var, args[1], fold_fn, s1.s, debug
										);
									}
									default: fail0("non-scalar argument must be a variable, got: " + fs2s(args[0]));
								}
							}
							default: s1;
						}
					} else s1;
				}
				default: s1;
			}
		}
		FsIf(cond, s1, s2,__,nx): {
			FsIf(s with
				s1 = fsInlineStatInStat(s1, names, new_id, locals, debug),
				s2 = fsInlineStatInStat(s2, names, new_id, locals, debug),
			);
		}
		FsSwitch(__,__,cs,__,nx): {
			FsSwitch(s with
				cases = map(cs, \c ->
					FsCase(c with body = fsInlineStatInStat(c.body, names, new_id, locals, debug))
				),
			);
		}
		FsFor(v, arr, s1,__,__,nx): {
			FsFor(s with
				s = fsInlineStatInStat(s1, names, new_id, locals, debug),
			);
		}
		FsRet(e,__,__): {
			e1 = switch (e) {
				FsClosure(__,lambda,__,__): {
					FsClosure(e with
						lambda = FsLambda(lambda with
							body = fsInlineStatInStat(lambda.body, names, new_id, makeTree(), debug)
						)
					);
				}
				default: e;
			}
			FsRet(s with e = e1);
		}
		default: s;
	}
	switch (s1.next) {
		Some(nx): fsSetNext(s1, fsInlineStatInStat(nx, names, new_id, locals, debug));
		None(): s1;
	}
}

fsInlineFold(out_var: FsVar, fold_var: FsVar, arr_var: FsVarUse, init: FsExp, fn: FsClosure, s1: FsStat, debug: bool) -> FsStat {
	lambda_acc = fn.lambda.args[0].name;
	lambda_iter = fn.lambda.args[1].name;
	rename_var = \v -> if (v.name == lambda_acc) {
		out_var;
	} else if (v.name == lambda_iter) {
		fold_var;
	} else {
		v;
	}
	fn_inlined = cast(fsMap(fn, \x -> switch (x) {
		FsVarUse(v, info, id): {
			// Rename acc and x vars from lambda body
			FsVarUse(x with var = rename_var(v));
		}
		FsClosure(__,lambda,__,__): {
			FsClosure(x with lambda = FsLambda(lambda with closure = map(lambda.closure, rename_var)));
		}
		default: x;
	}, false): FsAll -> FsClosure);
	FsLet(out_var, init,
		FsFor(fold_var, arr_var,
			fsStatReplaceReturnOntoAssign(fn_inlined.lambda.body,
				FsVarUse(out_var, FsVarInfo(FsVarIntrinsic(), false, false), -1), false
			),
			filtermap(fn_inlined.vars, \v ->
				if (fiTypeIsScalar(v.var.type)) None() else Some(v.var)
			),
			-1, Some(s1)
		),
		-1, None()
	);
}
