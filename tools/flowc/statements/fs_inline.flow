import string_utils;
import tools/flowc/statements/fs_transform;
import tools/flowc/incremental/fi_helpers2;

export {
	fsInlineStat(s: FsStat, names: FiGlobalNames, stat_name: string, debug: bool) -> FsStat;
}

fsInlineStat(s: FsStat, names: FiGlobalNames, stat_name: string, debug: bool) -> FsStat {
	tmp_var_counter = ref 0;
	new_id = \-> {
		id = i2s(^tmp_var_counter);
		tmp_var_counter := ^tmp_var_counter + 1;
		id;
	}
	//println("inlining of: " + stat_name);
	inlined = fsInlineStatInStat(s, names, new_id, makeTree(), debug);
	//println("");
	cast(fsRemoveUnusedVars(inlined): FsAll -> FsStat);
	/*cast(fsMap(s, \x -> switch (x) {
		FsLet(v, e, s1,__,__): {
			switch (e) {
				FsCall(fn, args, type,__): {
					if (fn.var.name == "fold_xxx") {
						fold_fn = args[2];
						switch (fold_fn) {
							FsClosure(__,__,__,__): {
								fold_var = fiMakeNewVar("__fold_xxx", new_id(), makeTree(), names);
								arr_type = fiDearrayType(fsType(args[0]));
								arr_var = args[0];
								switch (arr_var) {
									FsVarUse(__,__,__): {
										fsInlineFold(v,
											FsVar(fold_var, arr_type),
											arr_var, args[1], fold_fn, s1, debug
										);
									}
									default: fail0("non-scalar argument must be a variable, got: " + fs2s(args[0]));
								}
							}
							default: {
								x;
							}
						}
					} else if (fn.var.name == "fold") {
						fold_fn = args[2];
						switch (fold_fn) {
							FsClosure(__,__,__,__): {
								fold_var = fiMakeNewVar("__fold", new_id(), makeTree(), names);
								arr_type = fiDearrayType(fsType(args[0]));
								arr_var = args[0];
								switch (arr_var) {
									FsVarUse(__,__,__): {
										fsInlineFold(v,
											FsVar(fold_var, arr_type),
											arr_var, args[1], fold_fn, s1, debug
										);
									}
									default: fail0("non-scalar argument must be a variable, got: " + fs2s(args[0]));
								}
							}
							default: {
								x;
							}
						}
					} else {
						x;
					}
				}
				default: x;
			}
		}
		default: x;
	}, false): FsAll -> FsStat);*/
	//s;
}

fsRemoveUnusedVars(s: FsAll) -> FsAll {
	fsMap(s, \x -> switch (x) {
		FsLet(v, e, s1,__,nx): {
			if (fsVarIsUsedInStat(v.name, s1)) x else {
				s1
			}
		}
		default: x;
	}, false);
}

fsInlineStatInStat(s: FsStat, names: FiGlobalNames, new_id: () -> string, locals: Tree<string, FsExp>, debug: bool) -> FsStat {
	s1 = switch (s) {
		FsLet(v, e, s0,__,__): {
			e1 = switch (e) {
				FsClosure(__,lambda,__,__): {
					FsClosure(e with
						lambda = FsLambda(lambda with
							body = fsInlineStatInStat(lambda.body, names, new_id, makeTree(), debug)
						)
					);
				}
				default: e;
			}
			s1 = FsLet(s with
				e = e1,
				s = fsInlineStatInStat(s0, names, new_id, setTree(locals, v.name, e1), debug)
			);
			switch (e1) {
				FsCall(fn, args, type,__): {
					if (fn.var.name == "fold") {
						arg_2 = args[2];
						switch (arg_2) {
							FsVarUse(fn_var,__,__): {
								switch (lookupTree(locals, fn_var.name)) {
									Some(fold_fn): {
										switch (fold_fn) {
											FsClosure(__,__,__,__): {
												fold_var = fiMakeNewVar("__fold", new_id(), makeTree(), names);
												arr_type = fiDearrayType(fsType(args[0]));
												arr_var = args[0];
												switch (arr_var) {
													FsVarUse(__,__,__): {
														fsInlineFold(v,
															FsVar(fold_var, arr_type),
															arr_var, args[1], fold_fn, s1.s, debug
														);
													}
													default: fail0("non-scalar argument must be a variable, got: " + fs2s(args[0]));
												}
											}
											default: {
												//println("fold_fn != FsClosure");
												s1;
											}
										}
									}
									None(): {
										/*println("lookupTree(locals, fn_var.name) == None()\n" +
											"locals: [" + strGlue(getTreeKeys(locals), ", ") + "]"
										);*/
										s1;
									}
								}
							}
							FsClosure(__,__,__,__): {
								fold_fn = arg_2;
								fold_var = fiMakeNewVar("__fold", new_id(), makeTree(), names);
								arr_type = fiDearrayType(fsType(args[0]));
								arr_var = args[0];
								switch (arr_var) {
									FsVarUse(__,__,__): {
										fsInlineFold(v,
											FsVar(fold_var, arr_type),
											arr_var, args[1], fold_fn, s1.s, debug
										);
									}
									default: fail0("non-scalar argument must be a variable, got: " + fs2s(args[0]));
								}
							}
							default: {
								//println("arg_2:\n" + toStringFormatted(arg_2));
								s1;
							}
						}
					} else {
						//println("fn.var.name: " + fn.var.name);
						s1;
					}
				}
				default: {
					//println("non-call: " + toStringFormatted(e));
					s1;
				}
			}
		}
		FsIf(cond, s1, s2,__,nx): {
			FsIf(s with
				s1 = fsInlineStatInStat(s1, names, new_id, locals, debug),
				s2 = fsInlineStatInStat(s2, names, new_id, locals, debug),
			);
		}
		FsSwitch(__,__,cs,__,nx): {
			FsSwitch(s with
				cases = map(cs, \c ->
					FsCase(c with body = fsInlineStatInStat(c.body, names, new_id, locals, debug))
				),
			);
		}
		FsFor(v, arr, s1,__,__,nx): {
			FsFor(s with
				s = fsInlineStatInStat(s1, names, new_id, locals, debug),
			);
		}
		FsRet(e,__,__): {
			e1 = switch (e) {
				FsClosure(__,lambda,__,__): {
					FsClosure(e with
						lambda = FsLambda(lambda with
							body = fsInlineStatInStat(lambda.body, names, new_id, makeTree(), debug)
						)
					);
				}
				default: e;
			}
			FsRet(s with e = e1);
		}
		default: s;
	}
	switch (s1.next) {
		Some(nx): fsSetNext(s1, fsInlineStatInStat(nx, names, new_id, locals, debug));
		None(): s1;
	}
}

/*fsInlineStatInExp(e: FsExp, names: FiGlobalNames, new_id: () -> string, locals: Tree<string, FsExp>, debug: bool) -> FsExp {
	switch (e) {
		FsClosure(__,lambda,__,__): {
			FsClosure(e with
				lambda = FsLambda(lambda with
					body = fsInlineStatInStat(lambda.body, names, new_id, makeTree(), debug)
				)
			);
		}
		FsCall(__,args,__,__): {
			FsCall(e with
				args = map(args, \arg ->
					fsInlineStatInExp(arg, names, new_id, locals, debug)
				)
			);
		}
		FsCallPrim(__,args,__,__): {
			FsCallPrim(e with
				es = map(args, \arg ->
					fsInlineStatInExp(arg, names, new_id, locals, debug)
				)
			);
		}
		FsInlineExp(__,args,__,__): {
			FsInlineExp(e with
				args = map(args, \arg ->
					fsInlineStatInExp(arg, names, new_id, locals, debug)
				)
			);
		}
		FsCast(e1,__,__,__): {
			FsCast(e with
				e = fsInlineStatInExp(e1, names, new_id, locals, debug)
			);
		}
		default: e;
	}
}*/

fsInlineFold(out_var: FsVar, fold_var: FsVar, arr_var: FsVarUse, init: FsExp, fn: FsClosure, s1: FsStat, debug: bool) -> FsStat {
	lambda_acc = fn.lambda.args[0].name;
	lambda_iter = fn.lambda.args[1].name;
	rename_var = \v -> if (v.name == lambda_acc) {
		out_var;
	} else if (v.name == lambda_iter) {
		fold_var;
	} else {
		v;
	}
	fn_inlined = cast(fsMap(fn, \x -> switch (x) {
		FsVarUse(v, info, id): {
			// Rename acc and x vars from lambda body
			FsVarUse(x with var = rename_var(v));
		}
		FsClosure(__,lambda,__,__): {
			FsClosure(x with lambda = FsLambda(lambda with closure = map(lambda.closure, rename_var)));
		}
		default: x;
	}, false): FsAll -> FsClosure);
	/*lambda_body = fsStatReplaceReturnOntoAssign(fn_inlined.lambda.body,
		FsVarUse(out_var, FsVarInfo(FsVarIntrinsic(), false, false), -1), true
	);
	cycle_freevars = filtermap(fn_inlined.vars, \v -> if (fiTypeIsScalar(v.var.type)) None() else Some(v.var));*/
	FsLet(out_var, init,
		FsFor(fold_var, arr_var,
			fsStatReplaceReturnOntoAssign(fn_inlined.lambda.body,
				FsVarUse(out_var, FsVarInfo(FsVarIntrinsic(), false, false), -1), true
			),
			filtermap(fn_inlined.vars, \v ->
				if (fiTypeIsScalar(v.var.type)) None() else Some(v.var)
			),
			-1, Some(s1)
		),
		-1, None()
	);
}


fsInlineFold2(out_var: FsVar, fold_var: FsVar, arr_var: FsVarUse, init: FsExp, fn: FsClosure, s1: FsStat, debug: bool) -> FsStat {
	lambda_acc = fn.lambda.args[0].name;
	lambda_iter = fn.lambda.args[1].name;
	rename_var = \v -> if (v.name == lambda_acc) {
		out_var;
	} else if (v.name == lambda_iter) {
		fold_var;
	} else {
		v;
	}
	fn_inlined = cast(fsMap(fn, \x -> switch (x) {
		FsVarUse(v, info, id): {
			// Rename acc and x vars from lambda body
			FsVarUse(x with var = rename_var(v));
		}
		FsClosure(__,lambda,__,__): {
			FsClosure(x with lambda = FsLambda(lambda with closure = map(lambda.closure, rename_var)));
		}
		default: x;
	}, false): FsAll -> FsClosure);
	lambda_body1 = fsStatReplaceReturnOntoAssign(fn_inlined.lambda.body,
		FsVarUse(out_var, FsVarInfo(FsVarIntrinsic(), false, false), -1), true
	);
	cycle_freevars = filter(fn_inlined.vars, \v -> !fiTypeIsScalar(v.var.type));
	//minc_closure = fold(cycle_freevars, None(), \acc, v -> Some(FsIncRc(v.var, 1, -1, acc)));
	ind_var = FsVar(fold_var.name + "_i", FiTypeInt());
	end_var = FsVar(fold_var.name + "_e", FiTypeInt());
	fs_one = FsConst(FiInt(1, -1), -1);
	tmp_var_info = FsVarInfo(FsVarIntrinsic(), false, false);
	ind_var_use = FsVarUse(ind_var, tmp_var_info, -1);
	lambda_body2 = fsAppendLast(lambda_body1,
		FsAssign(ind_var_use,
			FsCallPrim(FcPlusPrim(), [ind_var_use, fs_one], FiTypeInt(), -1),
			true, -1, None()
		)
	);
	cycle_body = fold(cycle_freevars, lambda_body2, \acc, v -> FsIncRc(v.var, 1, -1, Some(acc)));
	FsLet(out_var, init,
		FsLet(ind_var, FsConst(FiInt(0, -1), -1),
			FsLet(end_var,
				FsCallPrim(FcMinusPrim(), [
					FsInlineExp("length", [FsVarUse(arr_var.var, tmp_var_info, -1)], FiTypeInt(), -1),
					fs_one
				], FiTypeInt(), -1),
				FsFor(fold_var, arr_var, cycle_body,
					filtermap(fn_inlined.vars, \v -> if (fiTypeIsScalar(v.var.type)) None() else Some(v.var)),
					-1,
					//Some(s1)
					fold(cycle_freevars, Some(s1), \acc, v -> Some(FsDecRc(v.var, FsDecDirect(), -1, acc)))
				),
				-1, None()
			),
			-1, None()
		),
		-1, None()
	);
}

fsInlineFold1(out_var: FsVar, fold_var: FsVar, arr_var: FsVarUse, init: FsExp, fn: FsClosure, s1: FsStat, debug: bool) -> FsStat {
	lambda_acc = fn.lambda.args[0].name;
	lambda_iter = fn.lambda.args[1].name;
	rename_var = \v -> if (v.name == lambda_acc) {
		out_var;
	} else if (v.name == lambda_iter) {
		fold_var;
	} else {
		v;
	}
	fn_inlined = cast(fsMap(fn, \x -> switch (x) {
		FsVarUse(v, info, id): {
			// Rename acc and x vars from lambda body
			FsVarUse(x with var = rename_var(v));
		}
		FsClosure(__,lambda,__,__): {
			FsClosure(x with lambda = FsLambda(lambda with closure = map(lambda.closure, rename_var)));
		}
		default: x;
	}, false): FsAll -> FsClosure);
	lambda_body1 = fsStatReplaceReturnOntoAssign(fn_inlined.lambda.body,
		FsVarUse(out_var, FsVarInfo(FsVarIntrinsic(), false, false), -1), true
	);
	cycle_freevars = filter(fn_inlined.vars, \v -> !fiTypeIsScalar(v.var.type));
	minc_closure = fold(cycle_freevars, None(), \acc, v -> Some(FsIncRc(v.var, 1, -1, acc)));
	ind_var = FsVar(fold_var.name + "_i", FiTypeInt());
	end_var = FsVar(fold_var.name + "_e", FiTypeInt());
	fs_one = FsConst(FiInt(1, -1), -1);
	tmp_var_info = FsVarInfo(FsVarIntrinsic(), false, false);
	ind_var_use = FsVarUse(ind_var, tmp_var_info, -1);

	lambda_body2 = fsAppendLast(lambda_body1,
		FsAssign(ind_var_use,
			FsCallPrim(FcPlusPrim(), [ind_var_use, fs_one], FiTypeInt(), -1),
			true, -1, None()
		)
	);
	cycle_body = switch (minc_closure) {
		Some(inc_closure): {
			FsIf(
				FsCallPrim(FcNePrim(), [ind_var_use, FsVarUse(end_var, tmp_var_info, -1)], FiTypeBool(), -1),
				inc_closure,
				FsWrapExp(FsConst(FiVoid(-1), -1), -1, None()), -1,
				Some(lambda_body2)
			);
		}
		None(): {
			lambda_body2;
		}
	}
	FsLet(out_var, init,
		FsLet(ind_var, FsConst(FiInt(0, -1), -1),
			FsLet(end_var,
				FsCallPrim(FcMinusPrim(), [
					FsInlineExp("length", [FsVarUse(arr_var.var, tmp_var_info, -1)], FiTypeInt(), -1),
					fs_one
				], FiTypeInt(), -1),
				FsFor(fold_var, arr_var, cycle_body,
					filtermap(fn_inlined.vars, \v -> if (fiTypeIsScalar(v.var.type)) None() else Some(v.var)),
					-1,
					Some(s1)
				),
				-1, None()
			),
			-1, None()
		),
		-1, None()
	);
}
