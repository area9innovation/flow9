import tools/flowc/incremental/fiexp;
import ds/set;

export {
	// Supertype for all statements/expressions
	FsAll ::= FsStat, FsExp, FsLambda;

	// General control-flow statements
	FsStat ::= FsIf, FsSwitch, FsLet, FsFor, FsInlineStat, FsWrapExp, FsRet, FsTailCall, FsAssign, FsIncRc, FsDecRc;

		FsIf(cond: FsExp, s1: FsStat, s2: FsStat, id: int, next: Maybe<FsStat>);
		FsSwitch(x: FsVarUse, type: FiTypeName, cases: [FsCase], id: int, next: Maybe<FsStat>);
			FsCase(struct: string, args: [FsVar], body: FsStat, id: int);
		FsLet(var: FsVar, e: FsExp, s: FsStat, id: int, next: Maybe<FsStat>);
		FsFor(var: FsVar, e: FsExp, s: FsStat, id: int, next: Maybe<FsStat>); // The `for` cycle for arrays

		FsInlineStat(name: string, fn: string, args: [FsVarUse], return: FsVar, id: int, next: Maybe<FsStat>);
		FsWrapExp(e: FsExp, id: int, next: Maybe<FsStat>);
		FsRet(e: FsExp, id: int, next: Maybe<FsStat>);
		FsTailCall(id: int, next: Maybe<FsStat>);
		FsAssign(to: FsExp, what: FsExp, direct: bool, id: int, next: Maybe<FsStat>);

		FsIncRc(v: FsVar, delta: int, id: int, next: Maybe<FsStat>);
		FsDecRc(v: FsVar, mode: FsDecMode, id: int, next: Maybe<FsStat>);
			FsDecMode ::= FsDecDirect, FsDecReuse, FsDecFinish;
			FsDecDirect(); FsDecReuse(reuse: FsVar); FsDecFinish();

	// Expressions (returns value)
	FsExp ::= FsClosure, FsCall, FsInlineExp, FsCallPrim, FsCast, FsVarUse, FsString, FsConst;

		FsClosure(vars: [FsVarUse], lambda: FsLambda, info: FsMetaInfo, id: int);
			FsLambda(closure: [FsVar], args: [FsVar], body: FsStat, type: FiTypeFunction, id: int);
		FsCall(f: FsVarUse, args: [FsExp], type: FiType, id: int);
		FsInlineExp(fn: string, args: [FsExp], type: FiType, id: int);
		FsCallPrim(op: FsPrim, es: [FsExp], type: FiType, id: int);
		FsCast(e: FsExp, from: FiType, type: FiType, id: int);
		FsVarUse(var: FsVar, info: FsVarInfo, id: int);
			FsVarInfo(
				kind: FsVarKind,
				unique: bool,   // this variable is used only once
				isNotShared: bool // reference counter of this variable is never > 1
			);
			FsVarKind ::= FsVarLocal, FsVarGlobalVar, FsVarGlobalFunc, FsVarUninit, FsVarIntrinsic;
			FsVarLocal(); FsVarGlobalVar(); FsVarGlobalFunc(); FsVarUninit(); FsVarIntrinsic();
		FsString(s: string, info: FsMetaInfo, id: int);
		FsConst(c: FiScalar, id: int);
			FiScalar ::= FiVoid, FiInt, FiBool, FiDouble;

	FsVar(name: string, type: FiType);

	// Meta info for memory usage optimization
	FsMetaInfo(
		reuse: Maybe<FsVar>,
		isNotShared: bool // ref counter is never > 1, thus may be stored on stack
	);

	FsPrim ::= 
		FcOrPrim,    FcAndPrim,   FcNotPrim,   FcEqPrim,  FcNePrim,
		FcLePrim,    FcGePrim,    FcLtPrim,    FcGtPrim,  FcPlusPrim,
		FcMinusPrim, FcMulPrim,   FcDivPrim,   FcModPrim, FcNegPrim,
		FsArrayPrim, FcIndexPrim, FcDerefPrim, FsRefPrim, FsStructPrim,
		FsFieldPrim, FsPrimIntrinsic;
		
		FsArrayPrim(info: FsMetaInfo); FsRefPrim(info: FsMetaInfo);
		FsStructPrim(struct: string, info: FsMetaInfo);
		FsFieldPrim(field: string, ind: int);

	// Primitive oprations which don't occur in original program code.
	FsPrimIntrinsic ::= FsIsUnit, FsArrayPush, FsArrayReserve;
		FsIsUnit(); // check if there's only one reference to the value
		FsArrayPush(); // push a new value to array
		FsArrayReserve(); // make a new array with reserved capacity

	// Reference-counting operations, which correspond to an expression
	FsMem(
		incs: Tree<FsVar, int>,
		decs: Set<FsVar>,
		unused: Tree<FsVar, FsDecMode>,
	);
}
