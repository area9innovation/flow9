import tools/flowc/incremental/fiexp;

export {
	// Supertype for all statements/expressions
	FsAll ::= FsStat, FsExp, FsLambda;

	// General control-flow statements
	FsStat ::= FsIf, FsSwitch, FsSeq, FsLet, FsAtomic;

		FsIf(cond: FsExp, memops: [FsMemOps], s1: FsStat, s2: FsStat, id: int);
		FsSwitch(x: FsExp, memops: [FsMemOps], switchType: FiType, cases: [FsCase], id: int);
			FsCase(struct: string, args: [FsVar], body: FsStat, id: int);
		FsSeq(ss: [FsStat], id: int);
		FsLet(var: FsVar, e: FsExp, memops: [FsMemOps], s: FsStat, id: int);

	// Statements, which doesn't contain other statements
	FsAtomic ::= FsWrapExp, FsRet, FsAssign, FsIncRc, FsDecRc;

		FsWrapExp(e: FsExp, memops: [FsMemOps], id: int);
		FsRet(e: FsExp, memops: [FsMemOps], id: int);
		FsAssign(to: FsExp, what: FsExp, memops: [FsMemOps], id: int);
		FsIncRc(delta: int, e: FsExp, id: int);
		FsDecRc(e: FsExp, id: int);

	// Expression equipped with ref counter operations
	//FsExpMem(e: FsExp, ops: Tree<string, FsMemOps>, id: int);

	FsMemOps(
		var: FsVar,
		incs: int,  // How much we need to increment a RC of a var before evaluation of an expression
		dec: bool,  // Should we drop the var in the end of evaluation of an expression explicitly
	);

	// Expressions (returns value)
	FsExp ::= FsClosure, FsCall, FsCallPrim, FsTailCall, FsCast, FsVarUse, FsConst;

		FsClosure(vars: [FsVarUse], lambda: FsLambda, id: int);
			FsLambda(closure: [FsVar], args: [FsVar], body: FsStat, type: FiTypeFunction, id: int);
		FsCall(f: FsExp, args: [FsExp], type: FiType, id: int);
		FsCallPrim(op: FsPrim, es: [FsExp], type: FiType, id: int);
		FsTailCall(args: [FsVar], vals: [FsExp], type: FiType, id: int);
		FsCast(e: FsExp, from: FiType, type: FiType, id: int);
		FsVarUse(var: FsVar, kind: FsVarKind, mutable last: bool, id: int);
			FsVarKind ::= FsVarLocal, FsVarGlobalVar, FsVarGlobalFunc, FsVarUninit;
			FsVarLocal(); FsVarGlobalVar(); FsVarGlobalFunc(); FsVarUninit();
		FsConst(const: FiConst, id: int);

	FsVar(name: string, type: FiType);

	FsPrim ::= 
		FsOrPrim,    FsAndPrim,   FsNotPrim,   FsEqPrim,  FsNePrim,
		FsLePrim,    FsGePrim,    FsLtPrim,    FsGtPrim,  FsPlusPrim,
		FsMinusPrim, FsMulPrim,   FsDivPrim,   FsModPrim, FsNegPrim,
		FsArrayPrim, FsIndexPrim, FsDerefPrim, FsRefPrim, FsStructPrim,
		FsFieldPrim;
		
		FsOrPrim();    FsAndPrim();   FsNotPrim();   FsEqPrim();  FsNePrim();
		FsLePrim();    FsGePrim();    FsLtPrim();    FsGtPrim();  FsPlusPrim();
		FsMinusPrim(); FsMulPrim();   FsDivPrim();   FsModPrim(); FsNegPrim();
		FsArrayPrim(); FsIndexPrim(); FsDerefPrim(); FsRefPrim();

		FsStructPrim(struct: string);
		FsFieldPrim(field: string, ind: int);
}
