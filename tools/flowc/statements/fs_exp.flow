import tools/flowc/incremental/fiexp;
import ds/set;

export {
	// Supertype for all statements/expressions
	FsAll ::= FsStat, FsExp, FsLambda;

	// General control-flow statements
	FsStat ::= FsIf, FsSwitch, FsSeq, FsLet, FsAtomic;

		FsIf(cond: FsExp, s1: FsStat, s2: FsStat, id: int);
		FsSwitch(x: FsVarUse, type: FiTypeName, cases: [FsCase], id: int);
			FsCase(struct: string, args: [FsVar], body: FsStat, id: int);
		FsSeq(ss: [FsStat], id: int);
		FsLet(var: FsVar, e: FsExp, s: FsStat, id: int);

	// Statements, which doesn't contain other statements
	FsAtomic ::= FsWrapExp, FsRet, FsTailCall, FsAssign, FsIncRc, FsDecRc;

		FsWrapExp(e: FsExp, id: int);
		FsRet(e: FsExp, id: int);
		FsTailCall(id: int);
		FsAssign(to: FsExp, what: FsExp, id: int);

		FsIncRc(v: FsVar, delta: int, id: int);
		FsDecRc(v: FsVar, mutable mode: FsDecMode, id: int);
			FsDecMode ::= FsDecDirect, FsDecReuse, FsDecFinish;
			FsDecDirect(); FsDecReuse(reuse: string); FsDecFinish();

	// Expressions (returns value)
	FsExp ::= FsClosure, FsCall, FsCallPrim, FsCast, FsVarUse, FsConst;

		FsClosure(vars: [FsVarUse], lambda: FsLambda, id: int);
			FsLambda(closure: [FsVar], args: [FsVar], body: FsStat, type: FiTypeFunction, id: int);
		FsCall(f: FsExp, args: [FsExp], type: FiType, id: int);
		FsCallPrim(op: FsPrim, es: [FsExp], type: FiType, id: int);
		FsCast(e: FsExp, from: FiType, type: FiType, id: int);
		FsVarUse(var: FsVar, kind: FsVarKind, id: int);
			FsVarKind ::= FsVarLocal, FsVarGlobalVar, FsVarGlobalFunc, FsVarUninit;
			FsVarLocal(); FsVarGlobalVar(); FsVarGlobalFunc(); FsVarUninit();
		FsConst(const: FiConst, id: int);

	FsVar(name: string, type: FiType);

	FsPrim ::= 
		FsOrPrim,    FsAndPrim,   FsNotPrim,   FsEqPrim,  FsNePrim,
		FsLePrim,    FsGePrim,    FsLtPrim,    FsGtPrim,  FsPlusPrim,
		FsMinusPrim, FsMulPrim,   FsDivPrim,   FsModPrim, FsNegPrim,
		FsArrayPrim, FsIndexPrim, FsDerefPrim, FsRefPrim, FsStructPrim,
		FsFieldPrim;
		
		FsOrPrim();    FsAndPrim();   FsNotPrim();   FsEqPrim();  FsNePrim();
		FsLePrim();    FsGePrim();    FsLtPrim();    FsGtPrim();  FsPlusPrim();
		FsMinusPrim(); FsMulPrim();   FsDivPrim();   FsModPrim(); FsNegPrim();
		FsArrayPrim(); FsIndexPrim(); FsDerefPrim(); FsRefPrim();

		FsStructPrim(struct: string, mutable reuse: string);
		FsFieldPrim(field: string, ind: int);

	// Reference-counting operations, which correspond to an expression
	FsMem(
		incs: Tree<FsVar, int>,
		decs: Set<FsVar>,
		unused: Tree<FsVar, FsDecMode>,
	);
}
