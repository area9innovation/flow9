import tools/flowc/statements/fsexp;
import tools/flowc/incremental/fiprettyprint;
import tools/flowc/manipulation/effects;
import string_utils;

export {

	fsExpType(e: FsExp) -> FiType;
	fsStatType(s: FsStat) -> FiType;

	fsExp2s(e: FsExp) -> string;
	fsStat2s(s: FsStat) -> string;

	fsSetExpType(e : FsExp, t: FiType) -> FsExp;

	fsHasTailCall(s: FsStat) -> bool;

	fiExpIsFsExp(e: FiExp) -> bool;
	//fiExpHasEffects(e: FiExp, effects: FiEffects) -> bool;

	fsWrapSeq(stats: [FsStat]) -> FsStat;
	fsUnwrapSeq(stat: FsStat) -> [FsStat];

	fsStatFreevars(s : FsStat) -> Set<string>;
	fsExpFreevars(e : FsExp) -> Set<string>;

	fsVarIsInStat(v: string, s: FsStat) -> bool;
	fsVarIsInExp(v: string, e: FsExp) -> bool;

	fsStatLambda(s: FsStat) -> FsLambda;
}

fsExpType(e: FsExp) -> FiType {
	switch (e) {
		FsLambda(__,__,__,__, type,__): type;
		FsCall(__,__, type,__):         type;
		FsVar(__,__,type,__):           type;
		FsCallPrim(__,__,type,__):      type;
		FiVoid(__):       FiTypeVoid();
		FiDouble(__, __): FiTypeDouble();
		FiInt(__, __):    FiTypeInt();
		FiString(__, __): FiTypeString();
		FiBool(__, __):   FiTypeBool();
	}
}

fsStatType(s: FsStat) -> FiType {
	switch (s) {
		FsLet(__,__,__,type,__):     type;
		FsIf(__,__,__,type,__):      type;
		FsSwitch(__,__,__,type,__):  type;
		FsSeq(__, type,__):          type;
		FsWrapExp(e, start):         fsExpType(e);
		FsRet(e, start):             fsExpType(e);
		FsTailCall(start):           FiTypeVoid();
		FsVarDecl(v,start):          v.type;
		FsAssign(__,__,__):          FiTypeVoid();
		FsMemory(op,__,__): {
			switch (op) {
				FmIsUnique(): FiTypeBool();
				default:      FiTypeVoid();
			}
		}
	}
}

fsStat2s(s: FsStat) -> string {
	t2s = \t -> prettyFiType(dummyPretty, t, makeSet());
	switch (s) {
		FsLet(v, e, s1,__,__): {
			v.name + " : " + t2s(v.type) + " = " + ";\n" + fsStat2s(s1);
		}
		FsIf(e, s1, s2, __,__): {
			"if (" + ") " + fsStat2s(s1) + " else " + fsStat2s(s2);
		}
		FsSwitch(v,__, cases, __,__): {
			"switch (" + fsExp2s(v) + ") {\n" +
				strIndent(superglue(cases, \c -> {
					body_s = fsStat2s(c.body);
					body_s1 = if (strContains(body_s, "\n") || startsWith(body_s, "{")) body_s else body_s + ";";
					c.struct + "(" + superglue(c.args, \arg -> arg.name, ", ") + "): " + body_s1;
				}, "\n")) +
			"\n}";
		}
		FsSeq(ss,__,__): {
			if (length(ss) == 0) "{}" else
			if (length(ss) == 1) fsStat2s(ss[0]) else
			"{\n" + strIndent(superglue(ss, fsStat2s, ";\n")) + "\n}";
		}
		FsWrapExp(e,__): {
			fsExp2s(e);
		}
		FsRet(e,__): {
			"return ";
		}
		FsTailCall(__): {
			"tailcall";
		}
		FsVarDecl(var,__): {
			var.name + " : " + t2s(var.type);
		}
		FsAssign(to, what,__): {
			fsExp2s(to) + " := " +  fsExp2s(what);
		}
		FsMemory(op, e,__): {
			switch (op) {
				FmDup():      "dup(" + fsExp2s(e) + ");";
				FmDrop():     "drop(" + fsExp2s(e) + ");";
				FmReuse():    "reuse(" + fsExp2s(e) + ");";
				FmDispose():  "dispose(" + fsExp2s(e) + ");";
				FmIsUnique(): "is_unique(" + fsExp2s(e) + ");";
				FmDecRef():   "dec_ref(" + fsExp2s(e) + ")";
				FmNull():     "nullptr";
			}
		}
	}
}

fsExp2s(e: FsExp) -> string {
	t2s = \t -> prettyFiType(dummyPretty, t, makeSet());
	switch (e) {
		FsLambda(__,closure, args, body,__,__): {
			body_s = fsStat2s(body);
			closure_s = "[" + superglue(closure, \v -> v.name, ", ") + "]";
			header = closure_s + "\\" + superglue(args, \arg -> arg.name + ":" + t2s(arg.type), ", ") + " -> ";
			if (!strContains(body_s, "\n") || startsWith(body_s, "{")) header + body_s else header + "{\n" + strIndent(body_s) + "\n}";
		}
		FsCall(f, args,__,__): {
			fsExp2s(f) + "(" + superglue(args, fsExp2s, ", ") + ")";
		}
		FsCallPrim(__,__,__,__): {
			fsCallPrim2s(e);
		}
		FsVar(name,__,__,__): name;
		FiVoid(__):      "{}";
		FiDouble(d, __): d2s(d);
		FiInt(i, __):    i2s(i)
		FiString(s, __): "\"" + escapeStr(s) + "\"";
		FiBool(b, __):   b2s(b);
	}
}

fsCallPrim2s(call: FsCallPrim) -> string {
	t2s = \t -> prettyFiType(dummyPretty, t, makeSet());
	es = call.es;
	switch (call.op) {
		FmOrPrim():  "(" + fsExp2s(es[0]) + " || " + fsExp2s(es[1]) + ")";
		FmAndPrim(): "(" + fsExp2s(es[0]) + " && " + fsExp2s(es[1]) + ")";
		FmNotPrim(): "!" + fsExp2s(es[0]);
		FmEqPrim():  "(" + fsExp2s(es[0]) + " == " + fsExp2s(es[1]) + ")";
		FmNePrim():  "(" + fsExp2s(es[0]) + " != " + fsExp2s(es[1]) + ")";
		FmLePrim():  "(" + fsExp2s(es[0]) + " <= " + fsExp2s(es[1]) + ")";
		FmGePrim():  "(" + fsExp2s(es[0]) + " >= " + fsExp2s(es[1]) + ")";
		FmLtPrim():  "(" + fsExp2s(es[0]) + " < " + fsExp2s(es[1]) + ")";
		FmGtPrim():  "(" + fsExp2s(es[0]) + " > " + fsExp2s(es[1]) + ")";
		FmPlusPrim():  "(" + fsExp2s(es[0]) + " + " + fsExp2s(es[1]) + ")";
		FmMinusPrim(): "(" + fsExp2s(es[0]) + " - " + fsExp2s(es[1]) + ")"; 
		FmMulPrim():   "(" + fsExp2s(es[0]) + " * " + fsExp2s(es[1]) + ")";
		FmDivPrim():   "(" + fsExp2s(es[0]) + " / " + fsExp2s(es[1]) + ")";
		FmModPrim():   "(" + fsExp2s(es[0]) + " % " + fsExp2s(es[1]) + ")";
		FmNegPrim():   "-" + fsExp2s(es[0]);
		FmArrayPrim():   "[" + superglue(es, fsExp2s, ", ") + "]";
		FmIndexPrim():   fsExp2s(es[0]) + "[" + fsExp2s(es[1]) + "]";
		FmDerefPrim():   "(*" +fsExp2s(es[0]) + ")";
		FmRefPrim():     "ref " + fsExp2s(es[0]);
		FmStructPrim(struct_name): {
			struct_type = cast(call.type : FiType -> FiTypeName);
			typars = if (struct_type.typeparameters == []) "" else 
				"<" + superglue(struct_type.typeparameters, \tp -> t2s(tp), ", ") + ">";
			struct_name + typars + "(" + superglue(es, fsExp2s, ", ") + ")";
		}
		FmFieldPrim(name): fsExp2s(es[0]) + "." + name;
		FmRequirePrim(file): {
			"require " + file + " " + fsExp2s(es[0]);
		}
		FmUnsafePrim(name): {
			"unsafe " + name + " " + fsExp2s(es[0]);
		}
		FmCastPrim(from, to): {
			"(" + fsExp2s(es[0]) + " : " + t2s(from) + " -> " + t2s(to) + ")";
		}
		FmIfPrim(): {
			"(" + fsExp2s(es[0]) + " ? " + fsExp2s(es[1]) + " : " + fsExp2s(es[2]) + ")";
		}
		FmReusePrim(name, reuse): {
			struct_type = cast(call.type : FiType -> FiTypeName);
			typars = if (struct_type.typeparameters == []) "" else 
				"<" + superglue(struct_type.typeparameters, \tp -> t2s(tp), ", ") + ">";
			name + typars + "@" + reuse + "(" + superglue(es, fsExp2s, ", ") + ")";
		}
		
	}
}

fsSetExpType(e : FsExp, t: FiType) -> FsExp {
	switch(e) {
		FsLambda(__,__,__,__,__,__): FsLambda(e with type = cast(t: FiType -> FiTypeFunction));
		FsCall(__,__,__,__):         FsCall(e with type = t);
		FsCallPrim(__,__,__,__):     FsCallPrim(e with type = t);
		FsVar(__,__,__,__):          FsVar(e with type = t);
		default: e;
	}
}

fsHasTailCall(s: FsStat) -> bool {
	switch (s) {
		FsIf(e, s1, s2,__,__): fsHasTailCall(s1) || fsHasTailCall(s2);
		FsSwitch(v,__, cases, __,__): exists(cases, \c -> fsHasTailCall(c.body));
		FsSeq(ss,__,__): if (length(ss) == 0) false else fsHasTailCall(ss[length(ss) - 1]);
		FsTailCall(__):  true;
		FsLet(v, e, s1, __,__): fsHasTailCall(s1);
		default: false;
	}
}

fiExpIsFsExp(e: FiExp) -> bool {
	switch (e) {
		FiSeq(es, type,__): 
			if (length(es) == 0) true else	
			if (length(es) == 1) {
				fiExpIsFsExp(es[0]) && type != FiTypeVoid();
			} else false;
		FiCast(ex,__,__,__,__): fiExpIsFsExp(ex);
		FiCall(f, args,__,__): fiExpIsFsExp(f) && forall(args, fiExpIsFsExp);
		FiSwitch(__,__,__,__,__): false;
		FiLambda(__,__,__,__): true;
		FiLet(__,__,__,__,__, __): false;
		FiIf(e1, e2, e3,__, __): fiExpIsFsExp(e1) && fiExpIsFsExp(e2) && fiExpIsFsExp(e3);   
		FiCallPrim(op, es,__, __): forall(es, fiExpIsFsExp);
		FiRequire(__,__,__,__): false;
		FiUnsafe(__,__,__,__): false;
		default: true;
	}
}

fsWrapSeq(stats: [FsStat]) -> FsStat {
	if (length(stats) == 0) FsSeq([], FiTypeVoid(), -1) else 
	if (length(stats) == 1) stats[0] else {
		last = stats[length(stats) - 1];
		FsSeq(stats, fsStatType(last), last.start);
	}
}

fsUnwrapSeq(stat: FsStat) -> [FsStat] {
	switch (stat) {
		FsSeq(stats,__,__): stats; 
		default: [stat]; 
	}
}

fsStatFreevars(s : FsStat) -> Set<string> {
	fsStatFreevarsBoundFree(s, makeSet(), makeSet());
}

fsStatFreevarsBoundFree(s : FsStat, bound : Set<string>, free : Set<string>) -> Set<string> {
	switch (s) {
		FsLet(v, e, s1,__,__): {
			bound1 = insertSet(bound, v.name);
			free1 = fsExpFreevarsBoundFree(e, bound1, free);
			fsStatFreevarsBoundFree(s1, bound1, free1);
		}
		FsIf(e, s1, s2, __,__): {
			fsStatFreevarsBoundFree(s2, bound, 
				fsStatFreevarsBoundFree(s1, bound, 
					fsExpFreevarsBoundFree(e, bound, free)
				)
			);
		}
		FsSwitch(v,__, cases, __,__): {
			fold(cases, fsExpFreevarsBoundFree(v, bound, free), \acc, c -> 
				fsStatFreevarsBoundFree(c.body, bound, acc)
			);
		}
		FsSeq(ss,__,__): {
			fold(ss, free, \acc, x -> 
				fsStatFreevarsBoundFree(x, bound, acc)
			);
		}
		FsWrapExp(e,__): {
			fsExpFreevarsBoundFree(e, bound, free);
		}
		FsRet(e,__): {
			fsExpFreevarsBoundFree(e, bound, free);
		}
		FsAssign(to, what,__): {
			fsExpFreevarsBoundFree(to, bound, fsExpFreevarsBoundFree(what, bound, free));
		}
		FsMemory(__,__,__): free;
		FsTailCall(__): free;
		FsVarDecl(v,__): free;
	}
}

fsExpFreevars(e : FsExp) -> Set<string> {
	fsExpFreevarsBoundFree(e, makeSet(), makeSet());
}

fsExpFreevarsBoundFree(expr : FsExp, bound : Set<string>, free : Set<string>) -> Set<string> {
	switch (expr) {
		FsLambda(__,closure, args, body, __,__): {
			fsStatFreevarsBoundFree(body, 
				fold(args, bound, \acc, arg -> insertSet(acc, arg.name)),
				free
			);
		}
		FsCall(f, args,__,__): {
			fold(args, 
				fsExpFreevarsBoundFree(f, bound, free),
				\acc, arg -> fsExpFreevarsBoundFree(arg, bound, acc)
			);
		}
		FsCallPrim(__,es,__,__): {
			fold(es, bound, \acc, arg -> fsExpFreevarsBoundFree(arg, bound, acc));
		}
		FsVar(name,__,__,__): if (containsSet(bound, name)) free else insertSet(free, name);
		FiVoid(__):      free;
		FiDouble(d, __): free;
		FiInt(i, __):    free;
		FiString(s, __): free;
		FiBool(b, __):   free;
	}
}

fsVarIsInStat(v: string, s: FsStat) -> bool {
	switch(s) {
		FsLet(__, e, s1,__,__): fsVarIsInExp(v, e) || fsVarIsInStat(v, s1);
		FsIf(e, s1, s2, __,__): fsVarIsInExp(v, e) || fsVarIsInStat(v, s1) || fsVarIsInStat(v, s2);
		FsSwitch(__,__, cases, __,__): exists(cases, \c -> fsVarIsInStat(v, c.body));
		FsSeq(ss, __,__): exists(ss, \s1 -> fsVarIsInStat(v, s1));
		FsWrapExp(e,__): fsVarIsInExp(v, e);
		FsRet(e,__):  fsVarIsInExp(v, e);
		FsAssign(var, e,__): fsVarIsInExp(v, e);
		FsMemory(op, var,__): false;
		FsTailCall(__): false;
		FsVarDecl(var,__): false;
	}
}

fsVarIsInExp(v: string, e: FsExp) -> bool {
	switch(e) {
		FsLambda(__,__,__,body,__,__): fsVarIsInStat(v, body);
		FsCall(fn, args,__,__): fsVarIsInExp(v, fn) || exists(args, \arg -> fsVarIsInExp(v, arg));
		FsCallPrim(__,es,__,__): exists(es, \x -> fsVarIsInExp(v, x));
		FsVar(name,__,__,__): v == name;
		FiConst(): false;
	}
}

fsStatLambda(s: FsStat) -> FsLambda {
	do_ex = \ex -> switch (ex) {
		FsLambda(__,__,__,body,__,__): ex; 
		default: fail0("expected FsLambda got: " + fsExp2s(ex));
	}
	switch (s) {
		FsRet(ex,__): do_ex(ex);
		FsWrapExp(ex,__): do_ex(ex);
		default: fail0("expected FsRet or FsWrapExp got: " + fsStat2s(s));
	}
}
