import tools/flowc/incremental/fi_helpers;
import tools/flowc/statements/fs_exp;
import string_utils;

export {
	fsType(e: FsAll) -> FiType;
	fs2s(s: FsAll) -> string;
	fs2string(s: FsAll, depth: int) -> string;
	fsEqualExprs(x: FsAll, y: FsAll) -> bool;
	fsDiffExprs(x: FsAll, y: FsAll, acc: [Pair<FsAll, FsAll>]) -> [Pair<FsAll, FsAll>];

	fsHasTailCall(s: FsStat) -> bool;

	fsWrapSeq(stats: [FsStat]) -> FsStat;
	fsUnwrapSeq(stat: FsStat) -> [FsStat];

	fsStatReplaceReturnOntoAssign(s: FsStat, v: FsVarUse) -> FsStat;
}

fsType(x: FsAll) -> FiType {
	switch (x) {
		FsIf(__, s1,__,__):          fsType(s1);
		FsSwitch(__,__, cs,__):      if (length(cs) == 0) FiTypeVoid() else fsType(cs[0].body);
		FsSeq(ss,__):                if (length(ss) == 0) FiTypeVoid() else fsType(ss[length(ss) - 1]);
		FsWrapExp(e,__):             FiTypeVoid();
		FsRet(e,__):                 fsType(e);
		FsLet(__,__,s,__):           fsType(s);
		FsAssign(__,__,__):          FiTypeVoid();
		FsIncRc(__,__,__):           FiTypeVoid();
		FsDecRc(__,__,__):           FiTypeVoid();
		FsClosure(__,lambda,__):     lambda.type;
		FsLambda(__,__,__, type,__): type;
		FsCall(__,__, type,__):      type;
		FsVarUse(v,__,__,__):        v.type;
		FsCallPrim(__,__,type,__):   type;
		FsTailCall(__):              FiTypeVoid();
		FsCast(__,__,type,__):       type;
		FsConst(c,__): {
			switch (c) {
				FiVoid(__):       FiTypeVoid();
				FiDouble(__, __): FiTypeDouble();
				FiInt(__, __):    FiTypeInt();
				FiString(__, __): FiTypeString();
				FiBool(__, __):   FiTypeBool();
			}
		}
	}
}

fs2s(s: FsAll) -> string {
	fs2string(s, -1);
}

fs2string(s: FsAll, depth: int) -> string {
	if (depth == 0) "..." else {
		t2s = \t -> prettyFiType(dummyPretty, t, makeSet());
		x2s = \x -> fs2string(x, depth - 1);
		wrap_long = \x -> if (!strContains(x, "\n") && strlen(x) < 64) x else {
			"\n" + strIndent(x) + "\n"
		}
		/*incs2s = \t -> if (isEmptyTree(t)) "" else {
			"inc[" + superglue(tree2pairs(t), \p -> p.first.name + ": " + i2s(p.second), ", ") + "]";
		}
		decs2s = \x -> if (isEmptySet(x)) "" else {
			"dec[" + superglue(set2array(x), \v -> v.name, ", ") + "]";
		}
		mem2s = \mem: FsMem, x: string -> incs2s(mem.incs) + "{" + x + "}" + decs2s(mem.decs);*/
		body = switch (s) {
			FsIf(e, s1, s2,__): {
				"if (" + x2s(e) + "){" + wrap_long(x2s(s1)) + "} else {" + wrap_long(x2s(s2)) + "}";
			}
			FsSwitch(v, m, cases,__): {
				"switch (" + x2s(v) + ") {\n" +
					superglue(cases, \c -> {
						c.struct + "(" + superglue(c.args, \arg -> arg.name, ", ") + "): " + wrap_long(x2s(c.body));
					}, "\n") +
				"\n}";
			}
			FsSeq(ss,__): {
				"{" + i2s(length(ss)) + "[" + wrap_long(superglue(ss, x2s, "\n")) + "]}";
			}
			FsLet(var, e, stat,__): {
				"let1 " + var.name + " : " + t2s(var.type) + " = " + x2s(e) + ";\n" +
					strIndent(x2s(stat));
			}
			FsWrapExp(e,__): {
				x2s(e) + ";";
			}
			FsRet(e,__): {
				"return " + x2s(e) + ";";
			}
			FsAssign(to, what,__): {
				x2s(to) + " := " + x2s(what) + ";";
			}
			FsIncRc(delta, e,__): {
				"incRc(" + x2s(e) + (if (delta == 1) "" else ", " + i2s(delta)) + ");";
			}
			FsDecRc(e, reuse,__): {
				if (reuse == "") {
					"decRc(" + x2s(e) + ");";
				} else {
					t = fsType(e);
					"let " + reuse + " : " + pretFiType(t) + " = decRcReuse(" + x2s(e) + ");";
				}
			}
			FsClosure(vars, lambda, id): {
				"[" + superglue(vars, \v -> x2s(v), ", ") + "]" + x2s(lambda);
			}
			FsLambda(__,args, body,__, id): {
				"\\" + superglue(args, \arg -> arg.name + ":" + t2s(arg.type), ", ") + " -> " +
				"{" + wrap_long(x2s(body)) + "}";
			}
			FsCall(f, args,__, id): {
				x2s(f) + "(" + superglue(args, x2s, ", ") + ")";
			}
			FsCallPrim(op, es, type, id): {
				fsPrim2s(op, map(es, x2s), type);
			}
			FsTailCall(id): {
				"tailcall;";
			}
			FsCast(e1, from, to, id): {
				"cast(" + x2s(e1) + " : " + t2s(from) + " -> " + t2s(to) + ")";
			}
			FsVarUse(v,__,last,__): {
				v.name + if (last) "[LAST]" else "";
			}
			FsConst(c, id): {
				switch (c) {
					FiVoid(__):      "{}";
					FiDouble(d, __): d2s(d);
					FiInt(i, __):    i2s(i)
					FiString(st, __): "\"" + escapeStr(st) + "\"";
					FiBool(b, __):   b2s(b);
				}
			}
		}
		"<id=" + i2s(s.id) + ">" + body;
	}
}

fsEqualExprs(x: FsAll, y: FsAll) -> bool {
	switch (x) {
		FsIf(e1, s11, s12,__): switch (y) {
			FsIf(e2, s21, s22,__): {
				fsEqualExprs(e1, e2) && fsEqualExprs(s11, s21) && fsEqualExprs(s12, s22);
			}
			default: false;
		}
		FsSwitch(v1, __, cs1,__): switch (y) {
			FsSwitch(v2, __, cs2,__): {
				fsEqualExprs(v1, v2) && (length(cs1) == length(cs2)) &&
				all(mapi(cs1, \i, c1 -> fsEqualExprs(c1.body, cs2[i].body)));
			}
			default: false;
		}
		FsSeq(ss1,__): switch (y) {
			FsSeq(ss2,__): {
				(length(ss1) == length(ss2)) &&
				all(mapi(ss1, \i, s1 -> fsEqualExprs(s1, ss2[i])));
			}
			default: false;
		}
		FsLet(v1, e1, s1,__): switch (y) {
			FsLet(v2, e2, s2,__): v1.name == v2.name && fsEqualExprs(e1, e2) && fsEqualExprs(s1, s2);
			default: false;
		}
		FsWrapExp(e1,__): switch (y) {
			FsWrapExp(e2,__): fsEqualExprs(e1, e2);
			default: false;
		}
		FsRet(e1,__): switch (y) {
			FsRet(e2,__): fsEqualExprs(e1, e2);
			default: false;
		}
		FsAssign(to1, what1, __): switch (y) {
			FsAssign(to2, what2, __): fsEqualExprs(to1, to2) && fsEqualExprs(what1, what2);
			default: false;
		}
		FsIncRc(d1, e1,__): switch (y) {
			FsIncRc(d2, e2,__): d1 == d2 && fsEqualExprs(e1, e2);
			default: false;
		}
		FsDecRc(e1,__,__): switch (y) {
			FsDecRc(e2,__,__): fsEqualExprs(e1, e2);
			default: false;
		}
		FsClosure(vars1, lambda1,__): switch (y) {
			FsClosure(vars2, lambda2,__): {
				length(vars1) == length(vars2) &&
				all(mapi(vars1, \i, v1 -> fsEqualExprs(v1, vars2[i]))) &&
				fsEqualExprs(lambda1, lambda2);
			}
			default: false;
		}
		FsLambda(clos1, args1, body1,__,__): switch (y) {
			FsLambda(clos2, args2, body2,__,__): {
				length(clos1) == length(clos2) &&
				length(args1) == length(args2) &&
				all(mapi(clos1, \i, v1 -> v1.name == clos2[i].name)) &&
				all(mapi(args1, \i, v1 -> v1.name == args2[i].name)) &&
				fsEqualExprs(body1, body2);
			}
			default: false;
		}
		FsCall(f1, args1,__,__): switch (y) {
			FsCall(f2, args2,__,__): {
				length(args1) == length(args2) &&
				all(mapi(args1, \i, a1 -> fsEqualExprs(a1, args2[i]))) &&
				fsEqualExprs(f1, f2);
			}
			default: false;
		}
		FsCallPrim(op1, es1,__,__): switch (y) {
			FsCallPrim(op2, es2,__,__): {
				op1 == op2 &&
				length(es1) == length(es2) &&
				all(mapi(es1, \i, a1 -> fsEqualExprs(a1, es2[i])));
			}
			default: false;
		}
		FsTailCall(__): switch (y) {
			FsTailCall(__): true;
			default: false;
		}
		FsCast(e1, from1, to1,__): switch (y) {
			FsCast(e2, from2, to2,__): {
				fiEqualTypes(from1, from2) &&
				fiEqualTypes(to1, to2) &&
				fsEqualExprs(e1, e2);
			}
			default: false;
		}
		FsVarUse(v1, kind1, last1,__): switch (y) {
			FsVarUse(v2, kind2, last2,__): {
				v1.name == v2.name &&
				kind1 == kind2;
			}
			default: false;
		}
		FsConst(c1,__): switch (y) {
			FsConst(c2, __): {
				c1 == c2;
			}
			default: false;
		}
	}
}

fsPrim2s(op: FsPrim, es: [string], type: FiType) -> string {
	t2s = \t -> prettyFiType(dummyPretty, t, makeSet());
	switch (op) {
		FsOrPrim():  "(" + es[0] + " || " + es[1] + ")";
		FsAndPrim(): "(" + es[0] + " && " + es[1] + ")";
		FsNotPrim(): "!" + es[0];
		FsEqPrim():  "(" + es[0] + " == " + es[1] + ")";
		FsNePrim():  "(" + es[0] + " != " + es[1] + ")";
		FsLePrim():  "(" + es[0] + " <= " + es[1] + ")";
		FsGePrim():  "(" + es[0] + " >= " + es[1] + ")";
		FsLtPrim():  "(" + es[0] + " < " + es[1] + ")";
		FsGtPrim():  "(" + es[0] + " > " + es[1] + ")";
		FsPlusPrim():  "(" + es[0] + " + " + es[1] + ")";
		FsMinusPrim(): "(" + es[0] + " - " + es[1] + ")"; 
		FsMulPrim():   "(" + es[0] + " * " + es[1] + ")";
		FsDivPrim():   "(" + es[0] + " / " + es[1] + ")";
		FsModPrim():   "(" + es[0] + " % " + es[1] + ")";
		FsNegPrim():   "-" + es[0];
		FsArrayPrim():   "[" + strGlue(es,  ", ") + "]";
		FsIndexPrim():   es[0] + "[" + es[1] + "]";
		FsDerefPrim():   "(*" +es[0] + ")";
		FsRefPrim():     "ref " + es[0];
		FsStructPrim(name, reuse): {
			struct_type = cast(type : FiType -> FiTypeName);
			typars = if (struct_type.typeparameters == []) "" else 
				"<" + superglue(struct_type.typeparameters, \tp -> t2s(tp), ", ") + ">";
			name + typars + (if (reuse == "") "" else "[" + reuse + "]") + "(" + strGlue(es, ", ") + ")";
		}
		FsFieldPrim(name, ind): es[0] + "." + name + "/*" + i2s(ind) + "*/";
	}
}

fsHasTailCall(s: FsStat) -> bool {
	switch (s) {
		FsIf(e, s1, s2,__): {
			fsHasTailCall(s1) || fsHasTailCall(s2);
		}
		FsSwitch(v,__, cases,__): {
			exists(cases, \c -> fsHasTailCall(c.body));
		}
		FsSeq(ss,__): {
			if (length(ss) == 0) false else fsHasTailCall(ss[length(ss) - 1]);
		}
		FsRet(e,__): false;
		FsTailCall(__): true;
		FsLet(__,__, s1,__): {
			fsHasTailCall(s1);
		}
		default: false;
	}
}

fsWrapSeq(stats: [FsStat]) -> FsStat {
	if (length(stats) == 0) FsSeq([], -1) else 
	if (length(stats) == 1) stats[0] else {
		// Filter out intermediate const values
		stats1 = filter(stats, \s ->
			switch (s) {
				FsWrapExp(e,__): {
					switch (e) {
						FsConst(__,__): false;
						default: true;
					}
				}
				default: true;
			}
		);
		FsSeq(stats, -1);
	}
}

fsUnwrapSeq(stat: FsStat) -> [FsStat] {
	switch (stat) {
		FsSeq(stats,__): stats; 
		default: [stat]; 
	}
}

fsStatReplaceReturnOntoAssign(s: FsStat, v: FsVarUse) -> FsStat {
	switch (s) {
		FsRet(e, id): {
			FsAssign(v, e, -1);
		}
		FsSeq(ss,__): {
			FsSeq(s with ss = map(ss, \s1 -> fsStatReplaceReturnOntoAssign(s1, v)));
		}
		FsSwitch(__,__, cs,__): {
			FsSwitch(s with cases = map(cs, \c -> FsCase(c with body = fsStatReplaceReturnOntoAssign(c.body, v))));
		}
		FsIf(__, s1, s2,__): {
			FsIf(s with 
				s1 = fsStatReplaceReturnOntoAssign(s1, v),
				s2 = fsStatReplaceReturnOntoAssign(s2, v)
			);
		}
		FsLet(__,__, s1,__): {
			FsLet(s with s =  fsStatReplaceReturnOntoAssign(s1, v));
		}
		default: s;
	}
}

fsDiffExprs(x: FsAll, y: FsAll, acc: [Pair<FsAll, FsAll>]) -> [Pair<FsAll, FsAll>] {
	switch (x) {
		FsIf(e1, s11, s12,__): switch (y) {
			FsIf(e2, s21, s22,__): {
				fsDiffExprs(e1, e2, fsDiffExprs(s11, s21, fsDiffExprs(s12, s22, acc)));
			}
			default: arrayPush(acc, Pair(x, y));
		}
		FsSwitch(v1, __, cs1,__): switch (y) {
			FsSwitch(v2, __, cs2,__): {
				foldi(cs1, fsDiffExprs(v1, v2, acc), \i, ac, c1 ->
					if (i >= length(cs2)) {
						arrayPush(ac, Pair(FsConst(FiVoid(-1), -1), c1.body));
					} else {
						fsDiffExprs(c1.body, cs2[i].body, acc);
					}
				);
			}
			default: arrayPush(acc, Pair(x, y));
		}
		FsSeq(ss1,__): switch (y) {
			FsSeq(ss2,__): {
				foldi(ss1, acc, \i, ac, s1 ->
					if (i >= length(ss2)) {
						arrayPush(ac, Pair(FsConst(FiVoid(-1), -1), s1));
					} else {
						fsDiffExprs(s1, ss2[i], acc);
					}
				);
			}
			default: arrayPush(acc, Pair(x, y));
		}
		FsLet(v1, e1, s1,__): switch (y) {
			FsLet(v2, e2, s2,__): {
				if (v1.name != v2.name) {
					arrayPush(acc, Pair(x, y));
				} else {
					fsDiffExprs(e1, e2, fsDiffExprs(s1, s2, acc));
				}
			}
			default: arrayPush(acc, Pair(x, y));
		}
		FsWrapExp(e1,__): switch (y) {
			FsWrapExp(e2,__): fsDiffExprs(e1, e2, acc);
			default: arrayPush(acc, Pair(x, y));
		}
		FsRet(e1,__): switch (y) {
			FsRet(e2,__): fsDiffExprs(e1, e2, acc);
			default: arrayPush(acc, Pair(x, y));
		}
		FsAssign(to1, what1, __): switch (y) {
			FsAssign(to2, what2, __): fsDiffExprs(to1, to2, fsDiffExprs(what1, what2, acc));
			default: arrayPush(acc, Pair(x, y));
		}
		FsIncRc(d1, e1,__): switch (y) {
			FsIncRc(d2, e2,__): {
				if (d1 != d2) {
					arrayPush(acc, Pair(x, y));
				} else {
					fsDiffExprs(e1, e2, acc);
				}
			}
			default: arrayPush(acc, Pair(x, y));
		}
		FsDecRc(e1,__,__): switch (y) {
			FsDecRc(e2,__,__): fsDiffExprs(e1, e2, acc);
			default: arrayPush(acc, Pair(x, y));
		}
		FsClosure(vs1, l1,__): switch (y) {
			FsClosure(vs2, l2,__): {
				foldi(vs1, fsDiffExprs(l1, l2, acc), \i, ac, v1 ->
					if (i >= length(vs2)) {
						arrayPush(ac, Pair(FsConst(FiVoid(-1), -1), v1));
					} else {
						fsDiffExprs(v1, vs2[i], acc);
					}
				);
			}
			default: arrayPush(acc, Pair(x, y));
		}
		FsLambda(cs1, as1, b1,__,__): switch (y) {
			FsLambda(cs2, as2, b2,__,__): {
				foldi(as1,
					foldi(cs1, 
						fsDiffExprs(b1, b2, acc), 
						\i, ac, c1 -> if (i >= length(cs2)) {
							arrayPush(ac, Pair(FsConst(FiVoid(-1), -1), c1));
						} else {
							if (c1 == cs2[i]) acc else arrayPush(acc, Pair(x, y));
						}
					), \i, ac, a1 -> if (i >= length(as2)) {
						arrayPush(ac, Pair(FsConst(FiVoid(-1), -1), a1));
					} else {
						if (a1 == as2[i]) acc else arrayPush(acc, Pair(x, y));
					}
				);
			}
			default: arrayPush(acc, Pair(x, y));
		}
		FsCall(f1, as1,__,__): switch (y) {
			FsCall(f2, as2,__,__): {
				foldi(as1, fsDiffExprs(f1, f2, acc), \i, ac, a1 ->
					if (i >= length(as2)) {
						arrayPush(ac, Pair(FsConst(FiVoid(-1), -1), a1));
					} else {
						fsDiffExprs(a1, as2[i], acc);
					}
				);
			}
			default: arrayPush(acc, Pair(x, y));
		}
		FsCallPrim(op1, es1,__,__): switch (y) {
			FsCallPrim(op2, es2,__,__): {
				if (op1 != op2) {
					arrayPush(acc, Pair(x, y));
				} else {
					foldi(es1, acc, \i, ac, e1 ->
						if (i >= length(es2)) {
							arrayPush(ac, Pair(FsConst(FiVoid(-1), -1), e1));
						} else {
							fsDiffExprs(e1, es2[i], acc);
						}
					);
				}
			}
			default: arrayPush(acc, Pair(x, y));
		}
		FsTailCall(__): switch (y) {
			FsTailCall(__): acc;
			default: arrayPush(acc, Pair(x, y));
		}
		FsCast(e1, from1, to1,__): switch (y) {
			FsCast(e2, from2, to2,__): {
				if (!fiEqualTypes(from1, from2) || !fiEqualTypes(to1, to2)) {
					arrayPush(acc, Pair(x, y));
				} else {
					fsDiffExprs(e1, e2, acc);
				}
			}
			default: arrayPush(acc, Pair(x, y));
		}
		FsVarUse(v1, kind1, last1,__): switch (y) {
			FsVarUse(v2, kind2, last2,__): {
				if (v1.name != v2.name || kind1 != kind2) {
					arrayPush(acc, Pair(x, y));
				} else {
					acc;
				}
			}
			default: arrayPush(acc, Pair(x, y));
		}
		FsConst(c1,__): switch (y) {
			FsConst(c2, __): {
				if (c1 == c2) acc else arrayPush(acc, Pair(x, y));
			}
			default: arrayPush(acc, Pair(x, y));
		}
	}
}
