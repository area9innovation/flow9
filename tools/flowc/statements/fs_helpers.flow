//import ds/set;
import tools/flowc/incremental/fiprettyprint;
import tools/flowc/statements/fsexp;
import tools/flowc/manipulation/effects;
import string_utils;
//import tools/flowc/memory/fm_helpers;

export {

	fsExpType(e: FsExp) -> FiType;
	fsStatType(s: FsStat) -> FiType;

	fsExp2s(e: FsExp) -> string;
	fsStat2s(s: FsStat) -> string;

	fsSetExpType(e : FsExp, t: FiType) -> FsExp;

	fsHasTailCall(s: FsStat) -> bool;

	fiExpIsFsExp(e: FiExp) -> bool;

	fsWrapSeq(stats: [FsStat]) -> FsStat;
	fsUnwrapSeq(stat: FsStat) -> [FsStat];

	fsStatFreevars(s : FsStat) -> Set<string>;
	fsExpFreevars(e : FsExp) -> Set<string>;

	fsVarIsInStat(v: string, s: FsStat) -> bool;
	fsVarIsInExp(v: string, e: FsExp) -> bool;

	fsStatLambda(s: FsStat) -> FsLambda;

	// If e has statements, wrap it in lambda so that it doesn't
	fiExpMakeNoStatements(e: FiExp, effects: FiEffects) -> FiExp;

	fiExpHasNoStatements(e: FiExp, effects: FiEffects) -> bool;

	fiExpHasEffects(e: FiExp, effects: FiEffects) -> bool;

	fsStatUnwrapLastReturnLetVar(s: FsStat) -> FsStat;
	fsStatReplaceReturnOntoAssign(s: FsStat, v: FsVar) -> FsStat;
}

fsExpType(e: FsExp) -> FiType {
	switch (e) {
		FsLambda(__,__,__, type,__): type;
		FsCall(__,__, type,__):      type;
		FsVar(__,__,type,__):        type;
		FsCallPrim(__,__,type,__):   type;
		FsTailCall(__,type,__):      type;
		FsCast(__,__,type,__):       type;
		FsConst(c,__): {
			switch (c) {
				FiVoid(__):       FiTypeVoid();
				FiDouble(__, __): FiTypeDouble();
				FiInt(__, __):    FiTypeInt();
				FiString(__, __): FiTypeString();
				FiBool(__, __):   FiTypeBool();
			}
		}
	}
}

fsStatType(s: FsStat) -> FiType {
	switch (s) {
		FsIf(__,s1,__,__):       fsStatType(s1);
		FsSwitch(__,__,cs,__):   if (length(cs) == 0) FiTypeVoid() else fsStatType(cs[0].body);
		FsSeq(ss,__):            if (length(ss) == 0) FiTypeVoid() else fsStatType(ss[length(ss) - 1]);
		FsLet(__,__,__,body,__): fsStatType(body);
		FsWrapExp(e,__):         FiTypeVoid();
		FsRet(e,__):             fsExpType(e);
		FsVarDecl(v,__):         FiTypeVoid();
		FsLet1(__,__,__,__):     FiTypeVoid();
		FsVarDef(__,__,__):      FiTypeVoid();
		FsAssign(__,__,__):      FiTypeVoid();
		FsModRc(__,__,__):       FiTypeVoid();
	}
}

fsStat2s(s: FsStat) -> string {
	t2s = \t -> prettyFiType(dummyPretty, t, makeSet());
	switch (s) {
		FsIf(e, s1, s2,__): {
			"if (" + fsExp2s(e) + ")\n" + strIndent(fsStat2s(s1)) + "\nelse\n" + strIndent(fsStat2s(s2));
		}
		FsSwitch(v,__, cases,__): {
			"switch (" + fsExp2s(v) + ") {\n" +
				strIndent(superglue(cases, \c -> {
					body_s = fsStat2s(c.body);
					body_s1 = if (strContains(body_s, "\n") || startsWith(body_s, "{")) body_s else body_s + ";";
					c.struct + "(" + superglue(c.args, \arg -> arg.name, ", ") + "): " + body_s1;
				}, "\n")) +
			"\n}";
		}
		FsSeq(ss,__): {
			if (length(ss) == 0) "{}" else
			if (length(ss) == 1) fsStat2s(ss[0]) else
			"{\n" + strIndent(superglue(ss, fsStat2s, "\n")) + "\n}";
		}
		FsLet(name, type, def, body,__): {
			name + " : " + t2s(type) + " = " + fsExp2s(def) + ";\n" + strIndent(fsStat2s(body));
		}
		FsLet1(name, type, def,__): {
			name + " : " + t2s(type) + " = " + fsExp2s(def) + ";";
		}
		FsWrapExp(e,__): {
			fsExp2s(e) + ";";
		}
		FsRet(e,__): {
			"return " + fsExp2s(e) + ";";
		}
		FsVarDecl(var,__): {
			var.name + " : " + t2s(var.type) + ";";
		}
		FsVarDef(v, e,__): {
			v.name + " : " + t2s(v.type) + " = " + fsExp2s(e) + ";";
		}
		FsAssign(to, what,__): {
			fsExp2s(to) + " := " +  fsExp2s(what) + ";";
		}
		FsModRc(d, e,__): {
			if (d >= 0) {
				"incRc(" + fsExp2s(e) + (if (d == 1) "" else ", " + i2s(d)) + ");";
			} else {
				"decRc(" + fsExp2s(e) + (if (d == -1) "" else ", " + i2s(-d)) + ");";
			}
		}
	}
}

fsExp2s(e: FsExp) -> string {
	t2s = \t -> prettyFiType(dummyPretty, t, makeSet());
	switch (e) {
		FsLambda(closure, args, body,__, id): {
			body_s = fsStat2s(body);
			closure_s = "[" + superglue(closure, fsExp2s, ", ") + "]";
			header = closure_s + "\\" + superglue(args, \arg -> fsExp2s(arg) + ":" + t2s(arg.type), ", ") + " -> ";
			if (!strContains(body_s, "\n") || startsWith(body_s, "{")) header + body_s else header + "{\n" + strIndent(body_s) + "\n}";
		}
		FsCall(f, args,__, id): {
			fsExp2s(f) + "(" + superglue(args, fsExp2s, ", ") + ")";
		}
		FsCallPrim(op, es, type, id): {
			fsPrim2s(op, map(es, fsExp2s), type);
		}
		FsTailCall(args, type, id): {
			"tailcall(" + superglue(args, \a -> a.param.name + " = " + fsExp2s(a.value), ", ") + ");";
		}
		FsCast(e1, from, to, id): {
			"cast(" + fsExp2s(e1) + " : " + t2s(from) + " -> " + t2s(to) + ")";
		}
		FsVar(name, last, type, id): {
			name + (if (last && !fiTypeIsScalar(type)) "/*last*/" else "");
		}
		FsConst(c, id): {
			switch (c) {
				FiVoid(__):      "{}";
				FiDouble(d, __): d2s(d);
				FiInt(i, __):    i2s(i)
				FiString(s, __): "\"" + escapeStr(s) + "\"";
				FiBool(b, __):   b2s(b);
			}
		}
	}
}

fsPrim2s(op: FsPrim, es: [string], type: FiType) -> string {
	t2s = \t -> prettyFiType(dummyPretty, t, makeSet());
	switch (op) {
		FsOrPrim():  "(" + es[0] + " || " + es[1] + ")";
		FsAndPrim(): "(" + es[0] + " && " + es[1] + ")";
		FsNotPrim(): "!" + es[0];
		FsEqPrim():  "(" + es[0] + " == " + es[1] + ")";
		FsNePrim():  "(" + es[0] + " != " + es[1] + ")";
		FsLePrim():  "(" + es[0] + " <= " + es[1] + ")";
		FsGePrim():  "(" + es[0] + " >= " + es[1] + ")";
		FsLtPrim():  "(" + es[0] + " < " + es[1] + ")";
		FsGtPrim():  "(" + es[0] + " > " + es[1] + ")";
		FsPlusPrim():  "(" + es[0] + " + " + es[1] + ")";
		FsMinusPrim(): "(" + es[0] + " - " + es[1] + ")"; 
		FsMulPrim():   "(" + es[0] + " * " + es[1] + ")";
		FsDivPrim():   "(" + es[0] + " / " + es[1] + ")";
		FsModPrim():   "(" + es[0] + " % " + es[1] + ")";
		FsNegPrim():   "-" + es[0];
		FsArrayPrim():   "[" + strGlue(es,  ", ") + "]";
		FsIndexPrim():   es[0] + "[" + es[1] + "]";
		FsDerefPrim():   "(*" +es[0] + ")";
		FsRefPrim():     "ref " + es[0];
		FsStructPrim(struct_name): {
			struct_type = cast(type : FiType -> FiTypeName);
			typars = if (struct_type.typeparameters == []) "" else 
				"<" + superglue(struct_type.typeparameters, \tp -> t2s(tp), ", ") + ">";
			struct_name + typars + "(" + strGlue(es, ", ") + ")";
		}
		FsFieldPrim(name): es[0] + "." + name;
		FsRequirePrim(file): {
			"require " + file + " " + es[0];
		}
		FsUnsafePrim(name): {
			"unsafe " + name + " " + es[0];
		}
		FsIfPrim(): {
			"(" + es[0] + " ? " + es[1] + " : " + es[2] + ")";
		}
		FsReusePrim(name, reuse): {
			struct_type = cast(type : FiType -> FiTypeName);
			typars = if (struct_type.typeparameters == []) "" else 
				"<" + superglue(struct_type.typeparameters, \tp -> t2s(tp), ", ") + ">";
			name + typars + "@" + reuse + "(" + strGlue(es, ", ") + ")";
		}
	}
}

fsSetExpType(e : FsExp, t: FiType) -> FsExp {
	switch(e) {
		FsLambda(__,__,__,__,__): FsLambda(e with type = cast(t: FiType -> FiTypeFunction));
		FsCall(__,__,__,__):      FsCall(e with type = t);
		FsCallPrim(__,__,__,__):  FsCallPrim(e with type = t);
		FsTailCall(__,__,__):     FsTailCall(e with type = t);
		FsVar(__,__,__,__):       FsVar(e with type = t);
		default: e;
	}
}

fsHasTailCall(s: FsStat) -> bool {
	switch (s) {
		FsIf(e, s1, s2,__): {
			fsHasTailCall(s1) || fsHasTailCall(s2);
		}
		FsSwitch(v,__, cases,__): {
			exists(cases, \c -> fsHasTailCall(c.body));
		}
		FsSeq(ss,__): {
			if (length(ss) == 0) false else fsHasTailCall(ss[length(ss) - 1]);
		}
		FsLet(__,__,__,s1,__): {
			fsHasTailCall(s1);
		}
		FsRet(e,__): {
			switch (e) {
				FsTailCall(__,__,__): true;
				default: false;
			}
		}
		default: false;
	}
}

fiExpIsFsExp(e: FiExp) -> bool {
	switch (e) {
		FiSeq(es, type,__): 
			if (length(es) == 0) true else	
			if (length(es) == 1) {
				fiExpIsFsExp(es[0]) && type != FiTypeVoid();
			} else false;
		FiCast(ex,__,__,__,__): fiExpIsFsExp(ex);
		FiCall(f, args,__,__): fiExpIsFsExp(f) && forall(args, fiExpIsFsExp);
		FiSwitch(__,__,__,__,__): false;
		FiLambda(__,__,__,__): true;
		FiLet(__,__,__,__,__, __): false;
		FiIf(e1, e2, e3,__, __): fiExpIsFsExp(e1) && fiExpIsFsExp(e2) && fiExpIsFsExp(e3);   
		FiCallPrim(op, es,__, __): forall(es, fiExpIsFsExp);
		FiRequire(__,__,__,__): false;
		FiUnsafe(__,__,__,__): false;
		default: true;
	}
}

fsWrapSeq(stats: [FsStat]) -> FsStat {
	if (length(stats) == 0) FsSeq([], -1) else 
	if (length(stats) == 1) stats[0] else {
		// Filter out intermediate const values
		stats1 = filter(stats, \s ->
			switch (s) {
				FsWrapExp(e,__): {
					switch (e) {
						FsConst(__,__): false;
						default: true;
					}
				}
				default: true;
			}
		);
		FsSeq(stats, -1);
	}
}

fsUnwrapSeq(stat: FsStat) -> [FsStat] {
	switch (stat) {
		FsSeq(stats,__): stats; 
		default: [stat]; 
	}
}

fsStatFreevars(s : FsStat) -> Set<string> {
	fsStatFreevarsBoundFree(s, makeSet(), makeSet());
}

fsStatFreevarsBoundFree(s : FsStat, bound : Set<string>, free : Set<string>) -> Set<string> {
	switch (s) {
		FsIf(e, s1, s2,__): {
			fsStatFreevarsBoundFree(s2, bound, 
				fsStatFreevarsBoundFree(s1, bound, 
					fsExpFreevarsBoundFree(e, bound, free)
				)
			);
		}
		FsSwitch(v,__, cases,__): {
			fold(cases, fsExpFreevarsBoundFree(v, bound, free), \acc, c -> 
				fsStatFreevarsBoundFree(c.body, bound, acc)
			);
		}
		FsSeq(ss,__): {
			fold(ss, free, \acc, x -> 
				fsStatFreevarsBoundFree(x, bound, acc)
			);
		}
		FsLet(name,__, def, body,__): {
			fsStatFreevarsBoundFree(body, insertSet(bound, name), 
				fsExpFreevarsBoundFree(def, bound, free)
			);
		}
		FsWrapExp(e,__): {
			fsExpFreevarsBoundFree(e, bound, free);
		}
		FsRet(e,__): {
			fsExpFreevarsBoundFree(e, bound, free);
		}
		FsAssign(to, what,__): {
			fsExpFreevarsBoundFree(to, bound, fsExpFreevarsBoundFree(what, bound, free));
		}
		FsVarDef(v, e,__): {
			bound1 = insertSet(bound, v.name);
			fsExpFreevarsBoundFree(e, bound1, free);
		}
		FsLet1(v,__, e,__): {
			bound1 = insertSet(bound, v);
			fsExpFreevarsBoundFree(e, bound1, free);
		}
		FsModRc(__,e,__): {
			fsExpFreevarsBoundFree(e, bound, free);
		}
		FsVarDecl(v,__): {
			free;
		}
	}
}

fsExpFreevars(e : FsExp) -> Set<string> {
	fsExpFreevarsBoundFree(e, makeSet(), makeSet());
}

fsExpFreevarsBoundFree(expr : FsExp, bound : Set<string>, free : Set<string>) -> Set<string> {
	switch (expr) {
		FsLambda(closure, args, body, __,__): {
			fsStatFreevarsBoundFree(body, 
				fold(args, bound, \acc, arg -> insertSet(acc, arg.name)),
				free
			);
		}
		FsCall(f, args,__,__): {
			fold(args, 
				fsExpFreevarsBoundFree(f, bound, free),
				\acc, arg -> fsExpFreevarsBoundFree(arg, bound, acc)
			);
		}
		FsCallPrim(__,es,__,__): {
			fold(es, bound, \acc, arg -> fsExpFreevarsBoundFree(arg, bound, acc));
		}
		FsTailCall(args,__,__): {
			fold(args, free, \acc, x -> 
				fsExpFreevarsBoundFree(x.value, bound, acc)
			);
		}
		FsCast(e,__,__,__): {
			fsExpFreevarsBoundFree(e, bound, free);
		}
		FsVar(name,__,__,__): if (containsSet(bound, name)) free else insertSet(free, name);
		FsConst(c,__): free;
	}
}

fsVarIsInStat(v: string, s: FsStat) -> bool {
	switch(s) {
		FsIf(e, s1, s2,__):     fsVarIsInExp(v, e) || fsVarIsInStat(v, s1) || fsVarIsInStat(v, s2);
		FsSwitch(__,__, cs,__): exists(cs, \c -> fsVarIsInStat(v, c.body));
		FsSeq(ss,__):           exists(ss, \s1 -> fsVarIsInStat(v, s1));
		FsLet(__,__, d, b,__):  fsVarIsInExp(v, d) || fsVarIsInStat(v, b);
		FsWrapExp(e,__):        fsVarIsInExp(v, e);
		FsRet(e,__):            fsVarIsInExp(v, e);
		FsAssign(var, e,__):    fsVarIsInExp(v, e);
		FsVarDef(__, e,__):     fsVarIsInExp(v, e);
		FsLet1(__,__, e,__):    fsVarIsInExp(v, e);
		FsModRc(__, e,__):      fsVarIsInExp(v, e);
		FsVarDecl(var,__):      false;
	}
}

fsVarIsInExp(v: string, e: FsExp) -> bool {
	switch(e) {
		FsLambda(__,__,body,__,__): fsVarIsInStat(v, body);
		FsCall(fn, args,__,__):     fsVarIsInExp(v, fn) || exists(args, \arg -> fsVarIsInExp(v, arg));
		FsCallPrim(__,es,__,__):    exists(es, \x -> fsVarIsInExp(v, x));
		FsTailCall(args,__,__):     exists(args, \arg -> fsVarIsInExp(v, arg.value));
		FsCast(e1,__,__,__):        fsVarIsInExp(v, e1);
		FsVar(name,__,__,__):       v == name;
		FsConst(__,__):             false;
	}
}

fsStatLambda(s: FsStat) -> FsLambda {
	do_ex = \ex -> switch (ex) {
		FsLambda(__,__,body,__,__): ex; 
		default: fail0("expected FsLambda got: " + fsExp2s(ex));
	}
	switch (s) {
		FsRet(ex,__): do_ex(ex);
		FsWrapExp(ex,__): do_ex(ex);
		default: fail0("expected FsRet or FsWrapExp got: " + fsStat2s(s));
	}
}

fiExpHasNoStatements(e: FiExp, effects: FiEffects) -> bool {
	no_stats = \x -> fiExpHasNoStatements(x, effects);
	switch (e) {
		FiSeq(es, type,__): 
			if (length(es) == 0) true else	
			if (length(es) == 1) {
				no_stats(es[0]) && type != FiTypeVoid();
			} else false;
		FiCast(ex,__,__,__,__): no_stats(ex);
		FiCall(f, args,__,__): no_stats(f) && forall(args, no_stats);
		FiSwitch(__,__,__,__,__): false;
		FiLambda(__,__,__,__): true;
		FiLet(__,__,__,__,__, __): false;
		FiIf(e1, e2, e3,__, __): {
			no_stats1 = \x -> no_stats(x) && !fiExpHasEffects(x, effects);
			no_stats1(e1) && no_stats1(e2) && no_stats1(e3);
		}
		FiCallPrim(op, es,__, __): {
			switch (op) {
				FcAssignPrim(): false;
				FcSetMutablePrim(field): false;
				default: forall(es, no_stats);
			}
		}
		FiRequire(__,__,__,__): false;
		FiUnsafe(__,__,__,__): false;
		default: true;
	}
}

fiExpMakeNoStatements(e: FiExp, effects: FiEffects) -> FiExp {
	if (fiExpHasNoStatements(e, effects)) e else {
		tp = fiExpType(e);
		FiCall(
			FiLambda([], e, FiTypeFunction([], tp), e.start), [], tp, e.start
		);
	}
}

fiExpHasEffects(e: FiExp, effects: FiEffects) -> bool {
	switch (e) {
		FiSeq(es, type,__): exists(es, \x -> fiExpHasEffects(x, effects));
		FiCast(ex,__,__,__,__): fiExpHasEffects(ex, effects);
		FiCall(f, args,__,__): fiExpHasEffects(f, effects) || exists(args, \x -> fiExpHasEffects(x, effects));
		FiSwitch(__,__,cases,__,__): exists(cases, \c -> fiExpHasEffects(c.body, effects));
		FiLambda(__,body,__,__): fiExpHasEffects(body, effects);
		FiLet(__,__,e1,e2,__, __): fiExpHasEffects(e1, effects) || fiExpHasEffects(e2, effects);
		FiIf(e1, e2, e3,__, __): fiExpHasEffects(e1, effects) || fiExpHasEffects(e2, effects) || fiExpHasEffects(e3, effects);
		FiCallPrim(op, es,__, __): {
			exists(es, \x -> fiExpHasEffects(x, effects)) ||
			switch (op) {
				FcRefPrim(): true;
				default: false;
			}
		}
		FiRequire(__,ex,__,__): fiExpHasEffects(ex, effects);
		FiUnsafe(__,__,__,__): true;
		FiVar(name,__,__): containsSet(effects.hasEffects, name);
		default: false;
	}
}

fsStatUnwrapLastReturnLetVar(s: FsStat) -> FsStat {
	switch (s) {
		FsRet(ex,__): s;
		FsWrapExp(ex,__): s;
		FsLet(v,__, def, body,__): {
			body1 = fsStatUnwrapLastReturnLetVar(body);
			switch (body1) {
				FsRet(r,__): {
					switch (r) {
						FsVar(w,__,__,__): {
							if (v != w) s else {
								FsRet(def, -1);
							}
						}
						default: s;
					}
				}
				default: s;
			}
		}
		default: s;
	}
}

fsStatReplaceReturnOntoAssign(s: FsStat, v: FsVar) -> FsStat {
	switch (s) {
		FsRet(e, id): {
			FsAssign(v, e, -1);
		}
		FsLet(__,__,__, s1,__): {
			FsLet(s with s = fsStatReplaceReturnOntoAssign(s1, v));
		}
		FsSeq(ss,__): {
			FsSeq(s with ss = map(ss, \s1 -> fsStatReplaceReturnOntoAssign(s1, v)));
		}
		FsSwitch(__,__,cs,__): {
			FsSwitch(s with cases = map(cs, \c -> FsCase(c with body = fsStatReplaceReturnOntoAssign(c.body, v))));
		}
		FsIf(cond, s1, s2,__): {
			FsIf(s with 
				s1 = fsStatReplaceReturnOntoAssign(s1, v),
				s2 = fsStatReplaceReturnOntoAssign(s2, v)
			);
		}
		default: s;
	}
}
