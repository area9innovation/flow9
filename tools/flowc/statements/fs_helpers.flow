import tools/flowc/incremental/fi_helpers;
import tools/flowc/statements/fs_exp;
import string_utils;

export {
	fsType(e: FsAll) -> FiType;
	fs2s(s: FsAll) -> string;
	fsEqualExprs(x: FsAll, y: FsAll) -> bool;

	fsHasTailCall(s: FsStat) -> bool;

	fsWrapSeq(stats: [FsStat]) -> FsStat;
	fsUnwrapSeq(stat: FsStat) -> [FsStat];

	fsStatReplaceReturnOntoAssign(s: FsStat, v: FsVarUse) -> FsStat;
}

fsType(x: FsAll) -> FiType {
	switch (x) {
		FsIf(__, s1,__,__):          fsType(s1);
		FsSwitch(__,__,cs,__):       if (length(cs) == 0) FiTypeVoid() else fsType(cs[0].body);
		FsSeq(ss,__):                if (length(ss) == 0) FiTypeVoid() else fsType(ss[length(ss) - 1]);
		FsWrapExp(e,__):             FiTypeVoid();
		FsRet(e,__):                 fsType(e);
		FsLet(__,__, s,__):          fsType(s);
		FsAssign(__,__,__):          FiTypeVoid();
		FsIncRc(__,__,__):           FiTypeVoid();
		FsDecRc(__,__):              FiTypeVoid();
		FsClosure(__,lambda,__):     lambda.type;
		FsLambda(__,__,__, type,__): type;
		FsCall(__,__, type,__):      type;
		FsVarUse(v,__,__,__):        v.type;
		FsCallPrim(__,__,type,__):   type;
		FsTailCall(__,__,type,__):   type;
		FsCast(__,__,type,__):       type;
		FsConst(c,__): {
			switch (c) {
				FiVoid(__):       FiTypeVoid();
				FiDouble(__, __): FiTypeDouble();
				FiInt(__, __):    FiTypeInt();
				FiString(__, __): FiTypeString();
				FiBool(__, __):   FiTypeBool();
			}
		}
	}
}

fs2s(s: FsAll) -> string {
	t2s = \t -> prettyFiType(dummyPretty, t, makeSet());
	add_line = \x, y -> if (x == "") y else if (y == "") x else x + "\n" + y;
	body = switch (s) {
		FsIf(e, s1, s2,__): {
			"if (" + fs2s(e) + "){\n" +
				strIndent(fs2s(s1)) +
			"\n} else {\n" +
				strIndent(fs2s(s2)) +
			"\n}";
		}
		FsSwitch(v, __, cases,__): {
			"switch (" + fs2s(v) + ") {\n" +
				superglue(cases, \c -> {
					body_s = fs2s(c.body);
					body_s1 = if (strContains(body_s, "\n") || startsWith(body_s, "{")) body_s else body_s + ";";
					c.struct + "(" + superglue(c.args, \arg -> arg.name, ", ") + "): " + body_s1;
				}, "\n") +
			"\n}";
		}
		FsSeq(ss,__): {
			if (length(ss) == 0) "{0[]}" else
			if (length(ss) == 1) {
				ss_str = fs2s(ss[0]);
				if (strlen(ss_str) < 64 && !strContains(ss_str, "\n")) {
					"{1[" + ss_str + "]}";
				} else {
					"{1[\n" + strIndent(ss_str) + "\n]}";
				}
			} else {
				"{" + i2s(length(ss)) + "[\n" + strIndent(superglue(ss, fs2s, "\n")) + "\n]}";
			}
		}
		FsLet(var, e, stat,__): {
			"let1 " + var.name + " : " + t2s(var.type) + " = " + fs2s(e) + ";\n" +
				strIndent(fs2s(stat));
		}
		FsWrapExp(e,__): {
			fs2s(e) + ";";
		}
		FsRet(e,__): {
			"return " + fs2s(e) + ";";
		}
		FsAssign(to, what,__): {
			fs2s(to) + " := " +  fs2s(what) + ";";
		}
		FsIncRc(delta, e,__): {
			"incRc(" + fs2s(e) + (if (delta == 1) "" else ", " + i2s(delta)) + ");";
		}
		FsDecRc(e,__): {
			"decRc(" + fs2s(e) + ");";
		}
		FsClosure(vars, lambda, id): {
			"[" + superglue(vars, \v -> fs2s(v), ", ") + "]" + fs2s(lambda);
		}
		FsLambda(__,args, body,__, id): {
			body_s = fs2s(body);
			header = "\\" + superglue(args, \arg -> arg.name + ":" + t2s(arg.type), ", ") + " -> ";
			if (!strContains(body_s, "\n") || startsWith(trim2(body_s, " \n\r"), "{")) header + body_s else header + "{\n" + strIndent(body_s) + "\n}";
		}
		FsCall(f, args,__, id): {
			fs2s(f) + "(" + superglue(args, fs2s, ", ") + ")";
		}
		FsCallPrim(op, es, type, id): {
			fsPrim2s(op, map(es, fs2s), type);
		}
		FsTailCall(args, vals, type, id): {
			"tailcall(" + supergluei(args, \i, a -> a.name + " = " + fs2s(vals[i]), ", ") + ");";
		}
		FsCast(e1, from, to, id): {
			"cast(" + fs2s(e1) + " : " + t2s(from) + " -> " + t2s(to) + ")";
		}
		FsVarUse(v,__,last,__): {
			v.name + if (last) "[LAST]" else "";
		}
		FsConst(c, id): {
			switch (c) {
				FiVoid(__):      "{}";
				FiDouble(d, __): d2s(d);
				FiInt(i, __):    i2s(i)
				FiString(st, __): "\"" + escapeStr(st) + "\"";
				FiBool(b, __):   b2s(b);
			}
		}
	}
	"<id=" + i2s(s.id) + ">" + body;
}

fsEqualExprs(x: FsAll, y: FsAll) -> bool {
	switch (x) {
		FsIf(e1, s11, s12,__): switch (y) {
			FsIf(e2, s21, s22,__): {
				fsEqualExprs(e1, e2) && fsEqualExprs(s11, s21) && fsEqualExprs(s12, s22);
			}
			default: false;
		}
		FsSwitch(v1, __, cs1,__): switch (y) {
			FsSwitch(v2, __, cs2,__): {
				fsEqualExprs(v1, v2) && (length(cs1) == length(cs2)) &&
				all(mapi(cs1, \i, c1 -> fsEqualExprs(c1.body, cs2[i].body)));
			}
			default: false;
		}
		FsSeq(ss1,__): switch (y) {
			FsSeq(ss2,__): {
				(length(ss1) == length(ss2)) &&
				all(mapi(ss1, \i, s1 -> fsEqualExprs(s1, ss2[i])));
			}
			default: false;
		}
		FsLet(v1, e1, s1,__): switch (y) {
			FsLet(v2, e2, s2,__): v1.name == v2.name && fsEqualExprs(e1, e2) && fsEqualExprs(s1, s2);
			default: false;
		}
		FsWrapExp(e1, __): switch (y) {
			FsWrapExp(e2, __): fsEqualExprs(e1, e2);
			default: false;
		}
		FsRet(e1, __): switch (y) {
			FsRet(e2, __): fsEqualExprs(e1, e2);
			default: false;
		}
		FsAssign(to1, what1, __): switch (y) {
			FsAssign(to2, what2, __): fsEqualExprs(to1, to2) && fsEqualExprs(what1, what2);
			default: false;
		}
		FsIncRc(d1, e1,__): switch (y) {
			FsIncRc(d2, e2,__): d1 == d2 && fsEqualExprs(e1, e2);
			default: false;
		}
		FsDecRc(e1,__): switch (y) {
			FsDecRc(e2,__): fsEqualExprs(e1, e2);
			default: false;
		}
		FsClosure(vars1, lambda1,__): switch (y) {
			FsClosure(vars2, lambda2,__): {
				length(vars1) == length(vars2) &&
				all(mapi(vars1, \i, v1 -> fsEqualExprs(v1, vars2[i]))) &&
				fsEqualExprs(lambda1, lambda2);
			}
			default: false;
		}
		FsLambda(clos1, args1, body1,__,__): switch (y) {
			FsLambda(clos2, args2, body2,__,__): {
				length(clos1) == length(clos2) &&
				length(args1) == length(args2) &&
				all(mapi(clos1, \i, v1 -> v1.name == clos2[i].name)) &&
				all(mapi(args1, \i, v1 -> v1.name == args2[i].name)) &&
				fsEqualExprs(body1, body2);
			}
			default: false;
		}
		FsCall(f1, args1,__,__): switch (y) {
			FsCall(f2, args2,__,__): {
				length(args1) == length(args2) &&
				all(mapi(args1, \i, a1 -> fsEqualExprs(a1, args2[i]))) &&
				fsEqualExprs(f1, f2);
			}
			default: false;
		}
		FsCallPrim(op1, es1,__,__): switch (y) {
			FsCallPrim(op2, es2,__,__): {
				op1 == op2 &&
				length(es1) == length(es2) &&
				all(mapi(es1, \i, a1 -> fsEqualExprs(a1, es2[i])));
			}
			default: false;
		}
		FsTailCall(args1, vals1,__,__): switch (y) {
			FsTailCall(args2, vals2, __,__): {
				length(vals1) == length(vals2) &&
				length(args1) == length(args2) &&
				all(mapi(vals1, \i, v1 -> fsEqualExprs(v1, vals2[i]))) &&
				all(mapi(args1, \i, v1 -> v1.name == args2[i].name));
			}
			default: false;
		}
		FsCast(e1, from1, to1,__): switch (y) {
			FsCast(e2, from2, to2,__): {
				fiEqualTypes(from1, from2) &&
				fiEqualTypes(to1, to2) &&
				fsEqualExprs(e1, e2);
			}
			default: false;
		}
		FsVarUse(v1, kind1, last1,__): switch (y) {
			FsVarUse(v2, kind2, last2,__): {
				v1.name == v2.name &&
				kind1 == kind2;
			}
			default: false;
		}
		FsConst(c1,__): switch (y) {
			FsConst(c2, __): {
				c1 == c2;
			}
			default: false;
		}
	}
}

fsPrim2s(op: FsPrim, es: [string], type: FiType) -> string {
	t2s = \t -> prettyFiType(dummyPretty, t, makeSet());
	switch (op) {
		FsOrPrim():  "(" + es[0] + " || " + es[1] + ")";
		FsAndPrim(): "(" + es[0] + " && " + es[1] + ")";
		FsNotPrim(): "!" + es[0];
		FsEqPrim():  "(" + es[0] + " == " + es[1] + ")";
		FsNePrim():  "(" + es[0] + " != " + es[1] + ")";
		FsLePrim():  "(" + es[0] + " <= " + es[1] + ")";
		FsGePrim():  "(" + es[0] + " >= " + es[1] + ")";
		FsLtPrim():  "(" + es[0] + " < " + es[1] + ")";
		FsGtPrim():  "(" + es[0] + " > " + es[1] + ")";
		FsPlusPrim():  "(" + es[0] + " + " + es[1] + ")";
		FsMinusPrim(): "(" + es[0] + " - " + es[1] + ")"; 
		FsMulPrim():   "(" + es[0] + " * " + es[1] + ")";
		FsDivPrim():   "(" + es[0] + " / " + es[1] + ")";
		FsModPrim():   "(" + es[0] + " % " + es[1] + ")";
		FsNegPrim():   "-" + es[0];
		FsArrayPrim():   "[" + strGlue(es,  ", ") + "]";
		FsIndexPrim():   es[0] + "[" + es[1] + "]";
		FsDerefPrim():   "(*" +es[0] + ")";
		FsRefPrim():     "ref " + es[0];
		FsStructPrim(struct_name): {
			struct_type = cast(type : FiType -> FiTypeName);
			typars = if (struct_type.typeparameters == []) "" else 
				"<" + superglue(struct_type.typeparameters, \tp -> t2s(tp), ", ") + ">";
			struct_name + typars + "(" + strGlue(es, ", ") + ")";
		}
		FsFieldPrim(name, ind): es[0] + "." + name + "/*" + i2s(ind) + "*/";
	}
}

fsHasTailCall(s: FsStat) -> bool {
	switch (s) {
		FsIf(e, s1, s2,__): {
			fsHasTailCall(s1) || fsHasTailCall(s2);
		}
		FsSwitch(v,__, cases,__): {
			exists(cases, \c -> fsHasTailCall(c.body));
		}
		FsSeq(ss,__): {
			if (length(ss) == 0) false else fsHasTailCall(ss[length(ss) - 1]);
		}
		FsRet(e,__): {
			switch (e) {
				FsTailCall(__,__,__,__): true;
				default: false;
			}
		}
		FsLet(__,__, s1,__): {
			fsHasTailCall(s1);
		}
		default: false;
	}
}

fsWrapSeq(stats: [FsStat]) -> FsStat {
	if (length(stats) == 0) FsSeq([], -1) else 
	if (length(stats) == 1) stats[0] else {
		// Filter out intermediate const values
		stats1 = filter(stats, \s ->
			switch (s) {
				FsWrapExp(e,__): {
					switch (e) {
						FsConst(__,__): false;
						default: true;
					}
				}
				default: true;
			}
		);
		FsSeq(stats, -1);
	}
}

fsUnwrapSeq(stat: FsStat) -> [FsStat] {
	switch (stat) {
		FsSeq(stats,__): stats; 
		default: [stat]; 
	}
}

fsStatReplaceReturnOntoAssign(s: FsStat, v: FsVarUse) -> FsStat {
	switch (s) {
		FsRet(e, id): {
			FsAssign(v, e, -1);
		}
		FsSeq(ss,__): {
			FsSeq(s with ss = map(ss, \s1 -> fsStatReplaceReturnOntoAssign(s1, v)));
		}
		FsSwitch(__,__,cs,__): {
			FsSwitch(s with cases = map(cs, \c -> FsCase(c with body = fsStatReplaceReturnOntoAssign(c.body, v))));
		}
		FsIf(__,s1, s2,__): {
			FsIf(s with 
				s1 = fsStatReplaceReturnOntoAssign(s1, v),
				s2 = fsStatReplaceReturnOntoAssign(s2, v)
			);
		}
		FsLet(__,__, s1,__): {
			FsLet(s with s =  fsStatReplaceReturnOntoAssign(s1, v));
		}
		default: s;
	}
}
