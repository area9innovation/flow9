import tools/flowc/statements/env;
import tools/flowc/manipulation/freevars;
import tools/flowc/memory/fm_helpers;

export {
	fmExp2FsStat(e : FmExp, returns: FsReturnPolicy, env: FsEnv, fn: string) -> FsStat;
	fmExp2FsExp(e : FmExp, env: FsEnv) -> Pair<FsExp, [FsStat]>;
}

fmExp2FsStat(e : FmExp, returns: FsReturnPolicy, env: FsEnv, fn: string) -> FsStat {
	wrap = \x -> switch (returns) {
		FsReturnToOuter():  FsRet(x, x.start);
		FsReturnNowhere():  FsWrapExp(x, x.start);
		FsReturnToLocal(v): FsAssign(v, x, x.start);
	}
	do_exp = \x -> fmExp2FsExp(x, env);
	switch (e) {
		FmSeq(es, info): {
			fsWrapSeq(concatA(mapi(es, \i, x -> 
				fsUnwrapSeq(fmExp2FsStat(x, if (i + 1 == length(es)) returns else FsReturnNowhere(), env, fn))
			)));
		}
		FmCall(f, args, info): {
			args_pairs = map(args, do_exp);
			do_call = \ -> {
				f_pair = do_exp(f);
				fsWrapSeq(concat(
					concatA(concat(
						[f_pair.second], 
						map(args_pairs, \p -> p.second))
					), 
					[wrap(FsCall(f_pair.first, 
						map(args_pairs, \p -> p.first), info.type, info.start
					))]
				));
			}
			switch (f) {
				FmVar(nm,__,__): {
					if (nm != fn || returns != FsReturnToOuter()) do_call() else {
						switch (lookupTree(env.names.toplevel, fn)) {
							Some(func): {
								func_args = cast(func: FiDeclaration -> FiFunctionDec).lambda.args;
								assign_func_vars = filtermapi(args_pairs, \i, p -> {
									make_assign = \-> FsAssign(
										FsVar(func_args[i].name, true, func_args[i].type, info.start), 
										FsVar(func_args[i].name + "__tmp__", true, func_args[i].type, info.start), info.start
									);
									switch (p.first) {
										FsVar(name,__,__,__): if (name == env.args[i].name) None() else Some(make_assign());
										default: Some(make_assign());
									}
								});
								assing_and_tailcall = FsSeq(concat(assign_func_vars, [FsTailCall(info.start)]), FiTypeVoid(), info.start);
								fsWrapSeq(concat(
									concatA(map(args_pairs, \p -> p.second)),
									[foldi(args_pairs, assing_and_tailcall, \i, acc, p -> {
										make_let = \-> FsLet(
											FsVar(func_args[i].name + "__tmp__", true, func_args[i].type, info.start), 
											p.first, acc, info.type, info.start
										);
										switch (p.first) {
											FsVar(name,__,__,__): if (name == env.args[i].name) acc else make_let();
											default: make_let();
										}
									})]
								));
							}
							None(): fail0("function " + fn + " is not found");
						}
					}
				}
				default: do_call();
			}
		}
		FmSwitch(v, vtype, cs, info): {
			default_switch = \ -> FsSwitch(
				FsVar(v.name, true, v.info.type, v.info.start), vtype,
				map(cs, \c -> {
					// env locals are added by correspongind let statements in body
					struct_args = map(c.args, \arg -> FsVar(arg.name, true, arg.info.type, arg.info.start));
					FsCase(c.struct, struct_args, fmExp2FsStat(c.body, returns, env, fn), c.start);
				}), 
				info.type, info.start
			);
			switch (vtype) {
				FiTypeName(typename,__): {
					if (containsKeyTree(env.names.unions, typename)) {
						default_switch();
					} else {
						switch (find(cs, \c -> c.struct == typename)) {
							Some(c): {
								// env locals are added by correspongind let statements in body
								fmExp2FsStat(c.body, returns, env, fn);
							}
							None(): {
								fail0("unmatched struct type '" + typename + "' in switch:\n" + toString(e));
							}
						}
					}
				}
				FiTypeFlow(): {
					default_switch();
				}
				default: {
					fail0("non-struct|union|flow type " + prettyFiType(dummyPretty, v.info.type, makeSet()) + " in switch:\n" + toString(e));
				}
			}
		}
		FmLambda(toplevel, args, body, info): {
			free_vars = info.free;
			locals = buildSet(getTreeKeys(env.locals));
			closure = intersectSets(free_vars, locals);
			lambda_env = FsEnv(env with
				args = args,
				locals = foldSet(closure,
					fold(args, env.locals, \acc, arg -> 
						setTree(acc, arg.name, FsVar(arg.name, true, arg.type, info.start))
					),
					\acc, arg -> {
						v = lookupTreeDef(acc, arg, FsVar("", true, FiTypeVoid(), info.start));
						setTree(acc, arg, FsVar(arg, true, v.type, info.start));
					}
				)
			);
			closure_vars = map(set2array(closure), \name -> 
				switch (lookupTree(env.locals, name)) {
					Some(tp): tp;
					None(): fail0("can't find type of a var: " + name);
				}
			);
			wrap(FsLambda(
				toplevel, closure_vars, args, 
				fmExp2FsStat(body, FsReturnToOuter(), lambda_env, if (toplevel) fn else ""), info.type, info.start
			));
		}
		FmLet(v, e1, e2, info): {
			if (v.name == "__") {
				e1_p = fmExp2FsExp(e1, env);
				fsWrapSeq(concat3(
					e1_p.second,
					[FsWrapExp(e1_p.first, info.start)],
					fsUnwrapSeq(fmExp2FsStat(e2, returns, env, fn))
				));
			} else {
				let_var = FsVar(v.name, true, v.info.type, v.info.start);
				let_env = FsEnv(env with
					locals = setTree(env.locals, v.name, let_var)
				);
				e1_p = fmExp2FsExp(e1, let_env);
				fsWrapSeq(concat(
					e1_p.second,
					[FsLet(let_var, e1_p.first, fmExp2FsStat(e2, returns, let_env, fn), info.type, info.start)]
				));
				/*fsWrapSeq(concat3(
					[FsVarDecl(let_var, v.info.start)],
					fsUnwrapSeq(fmExp2FsStat(e1, FsReturnToLocal(let_var), let_env, fn)),
					fsUnwrapSeq(fmExp2FsStat(e2, returns, let_env, fn))
				));*/
			}
		}
		FmIf(e1, e2, e3, info): {
			e1_pair = do_exp(e1);
			fsWrapSeq(concat(e1_pair.second,
				[FsIf(
					e1_pair.first, 
					fmExp2FsStat(e2, returns, env, fn), 
					fmExp2FsStat(e3, returns, env, fn), 
					info.type, info.start
				)]
			));
		}
		FmCallPrim(op, es, info): {
			es_pairs = map(es, do_exp);
			fsWrapSeq(concat(
				concatA(map(es_pairs, \p -> p.second)), 
				[wrap(FsCallPrim(op, 
					map(es_pairs, \p -> p.first), info.type, info.start
				))]
			));
		}
		FmAssign(to, what, info): {
			to_p = do_exp(to);
			what_p = do_exp(what);
			fsWrapSeq(concat3(
				to_p.second, what_p.second, 
				[FsAssign(to_p.first, what_p.first, info.start), wrap(FiVoid(0))]
			));
		}
		FmMemory(op, ex, info): {
			ex_p = do_exp(ex);
			fsWrapSeq(concat(
				ex_p.second,
				[FsMemory(op, ex_p.first, info.start)]
			));
		}
		FmVar(name, local, info): wrap(FsVar(name, local, info.type, info.start));
		FiVoid(__):        wrap(e);
		FiDouble(__, __):  wrap(e);
		FiInt(__, __):     wrap(e);
		FiString(__, __):  wrap(e);
		FiBool(__, __):    wrap(e);
	}
}

fmExp2FsExp(e : FmExp, env: FsEnv) -> Pair<FsExp, [FsStat]> {
	do_exps = \x -> fmExp2FsExp(x, env);
	switch (e) {
		FmSeq(es, info): {
			if (length(es) == 0) {
				Pair(FiVoid(0), []);
			} else if (length(es) == 1) {
				do_exps(es[0]);
			} else {
				last = lastElement(es, FiVoid(0));
				other = take(es, length(es) - 1);
				last_p = do_exps(last);
				other_s = fsUnwrapSeq(fmExp2FsStat(FmSeq(other, info), FsReturnNowhere(), env, ""));
				Pair(
					last_p.first,
					concat(other_s, last_p.second)
				);
			}
		}
		FmCall(f, args, info): {
			args_pairs = map(args, do_exps);
			f_pair = do_exps(f);
			Pair(
				FsCall(f_pair.first, 
					map(args_pairs, \p -> p.first), info.type, info.start
				),
				concatA(concat(
					[f_pair.second], 
					map(args_pairs, \p -> p.second)
				)), 
			);
		}
		FmSwitch(v, vtype, cases, info): {
			default_switch_stat = \return -> {
				cases_stats = map(cases, \c -> {
					struct_args = map(c.args, \arg -> FsVar(arg.name, true, arg.info.type, arg.info.start));
					// env locals are added by correspongind let statements in body
					case_stat = fmExp2FsStat(c.body, return, env, "");
					FsCase(c.struct, struct_args, case_stat, c.start);
				});
				FsSwitch(
					FsVar(v.name, true, v.info.type, v.info.start), 
					vtype, cases_stats, info.type, info.start
				);
			}
			if (info.type == FiTypeVoid()) {
				switch (vtype) {
					FiTypeName(typename,__): {
						switch_stat = if (containsKeyTree(env.names.unions, typename)) {
							default_switch_stat(FsReturnNowhere());
						} else {
							switch (find(cases, \c -> c.struct == typename)) {
								Some(c): {
									// env locals are added by correspongind let statements in body
									fmExp2FsStat(c.body, FsReturnNowhere(), env, "");
								}
								None(): {
									fail0("unmatched struct type '" + typename + "' in switch:\n" + toString(e));
								}
							}
						}
						Pair(FiVoid(info.start), [switch_stat]);
					}
					FiTypeFlow(): {
						Pair(FiVoid(info.start), [default_switch_stat(FsReturnNowhere())]);
					}
					default: {
						fail0("non-struct|union|flow type " + prettyFiType(dummyPretty, v.info.type, makeSet()) + " in switch:\n" + toString(e));
					}
				}
			} else {
				tmp_var = FsVar("sw_" + v.name + (if (^(env.tmp_sw) == 0) "" else i2s(^(env.tmp_sw))), true, info.type, v.info.start);
				env.tmp_sw := ^(env.tmp_sw) + 1;
				switch (vtype) {
					FiTypeName(typename,__): {
						switch_stat = if (containsKeyTree(env.names.unions, typename)) {
							default_switch_stat(FsReturnToLocal(tmp_var));
						} else {
							switch (find(cases, \c -> c.struct == typename)) {
								Some(c): {
									fmExp2FsStat(c.body, FsReturnToLocal(tmp_var), env, "");
								}
								None(): {
									fail0("unmatched struct type '" + typename + "' in switch:\n" + toString(e));
								}
							}
						}
						Pair(tmp_var, [FsVarDecl(tmp_var, info.start), switch_stat]);
					}
					FiTypeFlow(): {
						Pair(tmp_var, [FsVarDecl(tmp_var, info.start), default_switch_stat(FsReturnToLocal(tmp_var))]);
					}
					default: {
						fail0("non-struct|union|flow type " + prettyFiType(dummyPretty, v.info.type, makeSet()) + " in switch:\n" + toString(e));
					}
				}
			}
		}
		FmLambda(toplevel, args, body, info): {
			free_vars = info.free;
			locals = buildSet(getTreeKeys(env.locals));
			closure = intersectSets(free_vars, locals);
			lambda_env = FsEnv(env with
				locals = foldSet(
					closure,
					fold(args, env.locals, \acc, arg -> 
						setTree(acc, arg.name, FsVar(arg.name, true, arg.type, info.start))
					), \acc, arg -> {
						v = lookupTreeDef(acc, arg, FsVar("", true, FiTypeVoid(), info.start));
						setTree(acc, arg, FsVar(arg, true, v.type, info.start));
					}
				)
			);
			closure_vars = map(set2array(closure), \name -> 
				switch (lookupTree(env.locals, name)) {
					Some(tp): tp;
					None(): fail0("can't find type of a var: " + name);
				}
			);
			Pair(FsLambda(toplevel, closure_vars, args, 
				fmExp2FsStat(body, FsReturnToOuter(), lambda_env, ""), 
				info.type, info.start
			), []);
		}
		FmLet(v, e1, e2, info): {
			e1_pair = do_exps(e1);
			let_var = FsVar(v.name, true, v.info.type, info.start);
			let_env = FsEnv(env with
				locals = setTree(env.locals, v.name, let_var)
			);
			e2_pair = fmExp2FsExp(e2, let_env);
			Pair(
				e2_pair.first,
				concat(
					e1_pair.second, 
					[FsLet(let_var, e1_pair.first, fsWrapSeq(e2_pair.second), info.type, info.start)]
				)
			);
		}
		FmIf(e1, e2, e3, info): {
			tmp_var = FsVar("if_" + (if (^(env.tmp_if) == 0) "" else i2s(^(env.tmp_if))), true, info.type, info.start);
			env.tmp_if := ^(env.tmp_if) + 1;
			e1_pair = do_exps(e1);
			e2_pair = do_exps(e2);
			e3_pair = do_exps(e3);
			Pair(
				tmp_var,
				concat(
					e1_pair.second,
					[FsVarDecl(tmp_var, info.start), FsIf(
						e1_pair.first,
						FsSeq(
							concat(e2_pair.second, [FsAssign(tmp_var, e2_pair.first, info.start)]), 
							info.type, info.start
						),
						FsSeq(
							concat(e3_pair.second, [FsAssign(tmp_var, e3_pair.first, info.start)]), 
							info.type, info.start
						),
						info.type, info.start
					)]
				)
			);
		}
		FmCallPrim(op, es, info): {
			es_pairs = map(es, do_exps);
			Pair(
				FsCallPrim(op,
					map(es_pairs, \p -> p.first), info.type, info.start
				),
				concatA(map(es_pairs, \p -> p.second))
			);
		}
		FmVar(name, local, info): Pair(FsVar(name, local, info.type, info.start), []);
		FmAssign(to, what, info): {
			to_p = do_exps(to);
			what_p = do_exps(what);
			Pair(
				FiVoid(info.start),
				concat3(
					to_p.second, what_p.second,
					[FsAssign(to_p.first, what_p.first, info.start)]
				)
			);
		}
		FmMemory(op, ex, info): {
			ex_p = do_exps(e);
			Pair(
				FiVoid(info.start),
				concat(ex_p.second, [FsMemory(op, ex_p.first, info.start)])
			);
		}
		FiVoid(__):        Pair(e, []);
		FiDouble(__, __):  Pair(e, []);
		FiInt(__, __):     Pair(e, []);
		FiString(__, __):  Pair(e, []);
		FiBool(__, __):    Pair(e, []);
	}
}
