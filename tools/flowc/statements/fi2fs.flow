import tools/flowc/statements/fs_helpers;

export {
	fiExp2FsStat(e : FiExp, returns: bool) -> FsStat;
	fsWrapSeq(stats: [FsStat]) -> FsStat;
	fiExp2FsExp(e : FiExp) -> Pair<FsExp, [FsStat]>;
	fsWrapCaseVarsWithCasts(e : FsStat, vars: [Pair<string, FiType>]) -> FsStat;
}

fsWrapSeq(stats: [FsStat]) -> FsStat {
	if (length(stats) == 0) FsSeq([], FiTypeVoid()) else 
	if (length(stats) == 1) stats[0] else 
	FsSeq(stats, fsStatType(stats[length(stats) - 1]));
}

fsUnwrapSeq(stat: FsStat) -> [FsStat] {
	switch (stat) {
		FsSeq(stats,__): stats; 
		default: [stat]; 
	}
}

fiExp2FsStat(e : FiExp, returns: bool) -> FsStat {
	wrap = \x -> if (returns) FsRet(x) else FsWrap(x); 
	switch (e) {
		FiSeq(es, __,__): {
			fsWrapSeq(concatA(mapi(es, \i, x -> 
				fsUnwrapSeq(fiExp2FsStat(x, returns && (i + 1 == length(es))))
			)));
		}
		FiCast(ex, from, to,__,__): {
			pair = fiExp2FsExp(ex);
			fsWrapSeq(concat(pair.second, [wrap(FsCast(pair.first, from, to))]));
		}
		FiCall(f, args, type, __): {
			f_pair = fiExp2FsExp(f);
			args_pairs = map(args, fiExp2FsExp);
			fsWrapSeq(concat(
				concatA(concat(
					[f_pair.second], 
					map(args_pairs, \p -> p.second))
				), 
				[wrap(FsCall(f_pair.first, 
					map(args_pairs, \p -> p.first), type
				))]
			));
		}
		FiSwitch(x, __, cs, type, __): {
			FsSwitch(
				FsVar(x.name, x.type), 
				map(cs, \c -> FsCase(c.struct, c.argNames, fiExp2FsStat(c.body, returns))), 
				type
			);
		}
		FiLambda(args, body, type,__): {
			wrap(FsLambda(args, fiExp2FsStat(body, true), type));
		}
		FiLet(name, vtype, e1, e2, type, __): {
			e1_pair = fiExp2FsExp(e1);
			fsWrapSeq(concat3(e1_pair.second,
				[FsLet(name, vtype, e1_pair.first)],
				fsUnwrapSeq(fiExp2FsStat(e2, returns))
			));
		}
		FiIf(e1, e2, e3, type, __): {
			e1_pair = fiExp2FsExp(e1);
			fsWrapSeq(concat(e1_pair.second,
				[FsIf(
					e1_pair.first, 
					fiExp2FsStat(e2, returns), 
					fiExp2FsStat(e3, returns), 
					type
				)]
			));
		}
		FiCallPrim(op, es, type, __): {
			es_pairs = map(es, fiExp2FsExp);
			fsWrapSeq(concat(
				concatA(map(es_pairs, \p -> p.second)), 
				[wrap(FsCallPrim(op, 
					map(es_pairs, \p -> p.first), type
				))]
			));
		}
		FiRequire(file, ex, type, __): {
			pair = fiExp2FsExp(ex);
			fsWrapSeq(concat(pair.second, [wrap(FsRequire(file, pair.first, type))]));
		}
		FiUnsafe(name, ex, type, __): {
			pair = fiExp2FsExp(ex);
			fsWrapSeq(concat(pair.second, [wrap(FsUnsafe(name, pair.first, type))]));
		}
		FiVar(name, type,__): wrap(FsVar(name, type));
		FiVoid(__):       wrap(e);
		FiDouble(__, __): wrap(e);
		FiInt(__, __):    wrap(e);
		FiString(__, __): wrap(e);
		FiBool(__, __):   wrap(e);
	}
}

fiExp2FsExp(e : FiExp) -> Pair<FsExp, [FsStat]> {
	switch (e) {
		FiSeq(es, type, __): {
			if (length(es) == 0) {
				Pair(FiVoid(0), []);
			} else {
				pairs = map(es, fiExp2FsExp);
				last = lastElement(pairs, Pair(FiVoid(0), []));
				Pair(
					last.first,
					concatA(map(pairs, \p -> p.second))
				);
			}
		}
		FiCast(ex, from, to,__,__): {
			pair = fiExp2FsExp(ex);
			Pair(FsCast(pair.first, from, to), pair.second);
		}
		FiCall(f, args, type, call_start): {
			f_pair = fiExp2FsExp(f);
			args_pairs = map(args, fiExp2FsExp);
			Pair(
				FsCall(f_pair.first, 
					map(args_pairs, \p -> p.first), type
				),
				concatA(concat(
					[f_pair.second], 
					map(args_pairs, \p -> p.second))
				), 
			);
		}
		FiSwitch(x, __, cases, type, __): {
			tmp_var = "_switch_" + x.name;
			cases_pairs = map(cases, \c -> fiExp2FsExp(c.body));
			cases_stats = mapi(cases_pairs, \i, c_pair -> {
				c = cases[i];
				FsCase(c.struct, c.argNames, 
					FsSeq(concat(c_pair.second, [FsAssign(tmp_var, type, c_pair.first)]), type)
				)
			});
			Pair(
				FsVar(tmp_var, type), 
				concat(
					[
						FsVarDecl(tmp_var, type), 
						FsSwitch(FsVar(x.name, x.type), cases_stats, type)
					],
					concatA(map(cases_pairs, \p -> p.second))
				)
			);
		}
		FiLambda(args, body, type,__): {
			Pair(FsLambda(args, fiExp2FsStat(body, true), type), []);
		}
		FiLet(name, vtype, e1, e2,__, __): {
			e1_pair = fiExp2FsExp(e1);
			e2_pair = fiExp2FsExp(e2);
			Pair(
				e2_pair.first,
				concat3(
					e1_pair.second, 
					[FsLet(name, vtype, e1_pair.first)],
					e2_pair.second
				)
			);
		}
		FiIf(e1, e2, e3, type, __): {
			e1_pair = fiExp2FsExp(e1);
			e2_pair = fiExp2FsExp(e2);
			e3_pair = fiExp2FsExp(e3);
			Pair(
				FsTernary( 
					e1_pair.first, 
					e2_pair.first, 
					e3_pair.first, type
				),
				concat3(e1_pair.second, e2_pair.second, e3_pair.second)
			);
		}
		FiCallPrim(op, es, type, __): {
			es_pairs = map(es, fiExp2FsExp);
			Pair(
				FsCallPrim(op,
					map(es_pairs, \p -> p.first), type
				),
				concatA(map(es_pairs, \p -> p.second))
			);
		}
		FiRequire(file, ex, type, __): {
			pair = fiExp2FsExp(ex);
			Pair(FsRequire(file, pair.first, type), pair.second);
		}
		FiUnsafe(name, ex, type, __): {
			pair = fiExp2FsExp(ex);
			Pair(FsUnsafe(name, pair.first, type), pair.second);
		}
		FiVar(name, type,__): Pair(FsVar(name, type), []);
		FiVoid(__):       Pair(e, []);
		FiDouble(__, __): Pair(e, []);
		FiInt(__, __):    Pair(e, []);
		FiString(__, __): Pair(e, []);
		FiBool(__, __):   Pair(e, []);
	}
}

fsWrapCaseVarsWithCasts(e : FsStat, vars: [Pair<string, FiType>]) -> FsStat {
	switch (e) {
		FsLet(v, type, ex): {
			switch (find(vars, \p -> p.first == v)) {
				Some(p): {
					ex_wrapped = FsCast(ex, fsExpType(ex), type);
					FsLet(e with e = ex_wrapped);
				}
				None(): e;
			}
		}
		FsSeq(ss, __): {
			FsSeq(e with ss = map(ss, \x -> fsWrapCaseVarsWithCasts(x, vars)));
		}
		default: e;
	}
}
