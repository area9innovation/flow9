import tools/flowc/statements/env;
import tools/flowc/manipulation/freevars;
import tools/flowc/manipulation/transform_exps;

export {
	//fiExp2FsStat(e : FiExp, fn: string, effects: FiEffects, names: FiGlobalNames) -> FsStat;
	//fiExp2FsExp(e : FiExp, fn: string, effects: FiEffects, names: FiGlobalNames) -> FsStat;

	//fiExp2FsStat1(e : FiExp, names: FiGlobalNames, returns: bool, locals: Tree<string, FiVar>) -> FsStat;
	//fiExp2FsExp1(e : FiExp, names: FiGlobalNames, locals: Tree<string, FiVar>) -> FsExp;

	fiExp2FsStat2(e : FiExp, names: FiGlobalNames, returns: bool, locals: Tree<string, FiVar>) -> FsStat;
	fiExp2FsExp2(e : FiExp, names: FiGlobalNames, locals: Tree<string, FiVar>) -> FsExp;
}
/*
fiExp2FsStat(e : FiExp, fn: string, effects: FiEffects, names: FiGlobalNames) -> FsStat {
	fiDoExp2FsStat(e, FsReturnToOuter(), FsEnv([], makeTree(), names, effects, ref 0, ref 0), fn, true);
}

fiExp2FsExp(e : FiExp, fn: string, effects: FiEffects, names: FiGlobalNames) -> FsStat {
	pair = fiDoExp2FsExp(e, FsEnv([], makeTree(), names, effects, ref 0, ref 0), fn, true);
	if (length(pair.second) > 0) {
		FsSeq(concat(pair.second, [FsRet(pair.first, -1)]), -1);
	} else {
		FsRet(pair.first, -1);
	}
}

fiDoExp2FsStat(e : FiExp, returns: FsReturnPolicy, env: FsEnv, fn: string, is_toplevel: bool) -> FsStat {
	wrap = \x -> switch (returns) {
		FsReturnToOuter():    FsRet(x, -1);
		FsReturnNowhere():    FsWrapExp(x, -1);
		FsReturnToAssign(v):  FsAssign(v, x, -1);
	}
	do_exp = \x -> fiDoExp2FsExp(x, env, fn, false);
	switch (e) {
		FiSeq(es, __, start): {
			fsWrapSeq(concatA(mapi(es, \i, x -> 
				fsUnwrapSeq(
					if (i + 1 == length(es)) fiDoExp2FsStat(x, returns, env, fn, false)
					else fiDoExp2FsStat(x, FsReturnNowhere(), env, "", false)
				)
			)));
		}
		FiCast(ex, from, to, type, start): {
			pair = do_exp(ex);
			fsWrapSeq(concat(pair.second, [wrap(
				FsCast(pair.first, from, type, -1)
			)]));
		}
		FiCall(f, args, type, start): {
			args_pairs = map(args, do_exp);
			do_call = \ -> {
				f_pair = do_exp(f);
				fsWrapSeq(concat(
					concatA(concat(
						[f_pair.second], 
						map(args_pairs, \p -> p.second))
					), 
					[wrap(FsCall(f_pair.first, 
						map(args_pairs, \p -> p.first), type, -1
					))]
				));
			}
			switch (f) {
				FiVar(nm,__,__): {
					if (nm != fn || returns != FsReturnToOuter()) do_call() else {
						switch (lookupTree(env.names.toplevel, fn)) {
							Some(func): {
								func_args = cast(func: FiDeclaration -> FiFunctionDec).lambda.args;
								tailcall_args = mapi(args_pairs, \i, p -> {
									fn_arg = func_args[i];
									FsVar(fn_arg.name, false, fn_arg.type, -1)
								});
								tailcall_vals = mapi(args_pairs, \i, p -> p.first);
								fsWrapSeq(concat(
									concatA(map(args_pairs, \p -> p.second)),
									[FsRet(FsTailCall(tailcall_args, tailcall_vals, type, -1), -1)]
								));
							}
							None(): fail0("function " + fn + " is not found");
						}
					}
				}
				default: do_call();
			}
		}
		FiSwitch(v, vtype, cs, type, start): {
			default_switch = \ -> FsSwitch(
				fiVar2FsVar(v.name, v.type, v.start, env), vtype,
				map(cs, \c -> {
					struct_args = fsCaseStructArgs(c, env.names);
					case_env = FsEnv(env with
						locals = fold(struct_args, env.locals, \acc, arg -> if (arg.name == "__") acc else 
							setTree(acc, arg.name, arg)
						)
					);
					FsCase(c.struct, struct_args, fiDoExp2FsStat(c.body, returns, case_env, fn, false), -1)
				}), -1
			);
			switch (vtype) {
				FiTypeName(typename,__): {
					if (containsKeyTree(env.names.unions, typename)) {
						default_switch();
					} else {
						switch (find(cs, \c -> c.struct == typename)) {
							Some(c): {
								case_env = FsEnv(env with
									locals = fold(fsCaseStructArgs(c, env.names), env.locals, \acc, arg -> if (arg.name == "__") acc else 
										setTree(acc, arg.name, arg)
									)
								);
								fiDoExp2FsStat(c.body, returns, case_env, fn, false);
							}
							None(): {
								fail0("unmatched struct type '" + typename + "' in switch:\n" + prettyFiExp(dummyPretty, e));
							}
						}
					}
				}
				FiTypeFlow(): {
					default_switch();
				}
				default: {
					fail0("non-struct|union|flow type " + prettyFiType(dummyPretty, v.type, makeSet()) + " in switch:\n" + prettyFiExp(dummyPretty, e));
				}
			}
		}
		FiLambda(args, body, type, start): {
			free_vars = fifreevars(e);
			locals = buildSet(getTreeKeys(env.locals));
			closure = intersectSets(free_vars, locals);
			fs_args = map(args, \arg -> FsVar(arg.name, false, arg.type, -1));
			lambda_env = FsEnv(env with
				args = args,
				locals = fold(fs_args, env.locals, \acc, arg -> setTree(acc, arg.name, arg)),
			);
			closure_vars = map(set2array(closure), \name -> 
				switch (lookupTree(env.locals, name)) {
					Some(tp): tp;
					None(): fail0("can't find type of a var: " + name);
				}
			);
			wrap(FsLambda(
				closure_vars, map(args, \arg -> FsVar(arg.name, false, arg.type, -1)), 
				fiDoExp2FsStat(body, FsReturnToOuter(), lambda_env, if (is_toplevel) fn else "", is_toplevel), 
				type, -1
			));
		}
		FiLet(name, vtype, e1, e2, type, start): {
			if (name == "__") {
				fiDoExp2FsStat(e2, returns, env, fn, false);
			} else {
				let_var = FsVar(name, false, vtype, -1);
				let_env = FsEnv(env with
					locals = setTree(env.locals, name, let_var)
				);
				e1_pair = do_exp(e1);
				fsWrapSeq(concat3(e1_pair.second,
					[FsVarDef(let_var, e1_pair.first, -1)],
					fsUnwrapSeq(fiDoExp2FsStat(e2, returns, let_env, fn, false))
				));
			}
		}
		FiIf(e1, e2, e3, type, start): {
			e1_pair = do_exp(e1);
			fsWrapSeq(concat(e1_pair.second,
				[FsIf(
					e1_pair.first, 
					fiDoExp2FsStat(e2, returns, env, fn, false), 
					fiDoExp2FsStat(e3, returns, env, fn, false), -1
				)]
			));
		}
		FiCallPrim(op, es, type, start): {
			es_pairs = map(es, do_exp);
			switch (op) {
				FcAssignPrim(): {
					fsWrapSeq(concat(
						concatA(map(es_pairs, \p -> p.second)), 
						[FsAssign(es_pairs[0].first, es_pairs[1].first, -1), wrap(FsConst(FiVoid(0), -1))]
					));
				}
				FcSetMutablePrim(name): {
					fsWrapSeq(concat(
						concatA(map(es_pairs, \p -> p.second)), 
						[FsAssign(
							FsCallPrim(FsFieldPrim(name), [es_pairs[0].first], fsExpType(es_pairs[1].first), -1), 
							es_pairs[1].first, -1
						), wrap(FsConst(FiVoid(0), -1))]
					));
				}
				default: {
					fsWrapSeq(concat(
						concatA(map(es_pairs, \p -> p.second)), 
						[wrap(FsCallPrim(fcPrim2FsPrim(op), 
							map(es_pairs, \p -> p.first), type, -1
						))]
					));
				}
			}
		}
		FiRequire(file, ex, type, start): {
			pair = do_exp(ex);
			fsWrapSeq(concat(pair.second, [wrap(
				FsCallPrim(FsRequirePrim(file), [pair.first], type, -1)
			)]));
		}
		FiUnsafe(name, ex, type, start): {
			pair = do_exp(ex);
			fsWrapSeq(concat(pair.second, [wrap(
				FsCallPrim(FsUnsafePrim(name), [pair.first], type, -1)
			)]));
		}
		FiVar(name, type, start): {
			wrap(fiVar2FsVar(name, type, start, env));
		}
		FiConst(): {
			wrap(FsConst(e, -1));
		}
	}
}

fiDoExp2FsExp(e : FiExp, env: FsEnv, fn: string, is_toplevel: bool) -> Pair<FsExp, [FsStat]> {
	do_exps = \x -> fiDoExp2FsExp(x, env, fn, false);
	switch (e) {
		FiSeq(es, type, start): {
			if (length(es) == 0) {
				Pair(FsConst(FiVoid(0), -1), []);
			} else if (length(es) == 1) {
				do_exps(es[0]);
			} else {
				last = lastElement(es, FiVoid(0));
				other = take(es, length(es) - 1);
				last_p = do_exps(last);
				other_s = fsUnwrapSeq(fiDoExp2FsStat(FiSeq(other, type, start), FsReturnNowhere(), env, "", false));
				Pair(
					last_p.first,
					concat(other_s, last_p.second)
				);
			}
		}
		FiCast(ex, from, to, type, start): {
			pair = do_exps(ex);
			Pair(
				FsCast(pair.first, from, type, -1),
				pair.second
			);
		}
		FiCall(f, args, type, start): {
			args_pairs = map(args, do_exps);
			f_pair = do_exps(f);
			Pair(
				FsCall(f_pair.first, 
					map(args_pairs, \p -> p.first), type, -1
				),
				concatA(concat(
					[f_pair.second], 
					map(args_pairs, \p -> p.second)
				)), 
			);
		}
		FiSwitch(v, vtype, cases, type, start): {
			default_switch_stat = \return -> {
				cases_stats = map(cases, \c -> {
					struct_args = fsCaseStructArgs(c, env.names);
					case_env = FsEnv(env with 
						locals = fold(struct_args, env.locals, \acc, arg -> if (arg.name == "__") acc else 
							setTree(acc, arg.name, arg)
						)
					);
					case_stat = fiDoExp2FsStat(c.body, return, case_env, "", false);
					FsCase(c.struct, struct_args, case_stat, -1);
				});
				FsSwitch(fiVar2FsVar(v.name, v.type, v.start, env), vtype, cases_stats, -1);
			}
			if (type == FiTypeVoid()) {
				switch (vtype) {
					FiTypeName(typename,__): {
						switch_stat = if (containsKeyTree(env.names.unions, typename)) {
							default_switch_stat(FsReturnNowhere());
						} else {
							switch (find(cases, \c -> c.struct == typename)) {
								Some(c): {
									case_env = FsEnv(env with
										locals = fold(fsCaseStructArgs(c, env.names), env.locals, \acc, arg -> if (arg.name == "__") acc else 
											setTree(acc, arg.name, arg)
										)
									);
									fiDoExp2FsStat(c.body, FsReturnNowhere(), case_env, "", false);
								}
								None(): {
									fail0("unmatched struct type '" + typename + "' in switch:\n" + prettyFiExp(dummyPretty, e));
								}
							}
						}
						Pair(FsConst(FiVoid(start), -1), [switch_stat]);
					}
					FiTypeFlow(): {
						Pair(FsConst(FiVoid(start), -1), [default_switch_stat(FsReturnNowhere())]);
					}
					default: {
						fail0("non-struct|union|flow type " + prettyFiType(dummyPretty, v.type, makeSet()) + " in switch:\n" + prettyFiExp(dummyPretty, e));
					}
				}
			} else {
				tmp_var = FsVar(
					"sw_" + v.name + (if (^(env.tmp_sw) == 0) "" else "_" + i2s(^(env.tmp_sw))), 
					false, 
					type, -1
				);
				env.tmp_sw := ^(env.tmp_sw) + 1;
				switch (vtype) {
					FiTypeName(typename,__): {
						switch_stat = if (containsKeyTree(env.names.unions, typename)) {
							default_switch_stat(FsReturnToAssign(tmp_var));
						} else {
							switch (find(cases, \c -> c.struct == typename)) {
								Some(c): {
									case_env = FsEnv(env with 
										locals = fold(fsCaseStructArgs(c, env.names), env.locals, \acc, arg -> if (arg.name == "__") acc else 
											setTree(acc, arg.name, arg)
										)
									);
									fiDoExp2FsStat(c.body, FsReturnToAssign(tmp_var), case_env, "", false);
								}
								None(): {
									fail0("unmatched struct type '" + typename + "' in switch:\n" + prettyFiExp(dummyPretty, e));
								}
							}
						}
						Pair(tmp_var, [FsVarDecl(tmp_var, -1), switch_stat]);
					}
					FiTypeFlow(): {
						Pair(tmp_var, [FsVarDecl(tmp_var, -1), default_switch_stat(FsReturnToAssign(tmp_var))]);
					}
					default: {
						fail0("non-struct|union|flow type " + prettyFiType(dummyPretty, v.type, makeSet()) + " in switch:\n" + prettyFiExp(dummyPretty, e));
					}
				}
			}
		}
		FiLambda(args, body, type, start): {
			free_vars = fifreevars(e);
			locals = buildSet(getTreeKeys(env.locals));
			closure = intersectSets(free_vars, locals);
			fs_args = map(args, \arg -> FsVar(arg.name, false, arg.type, -1));
			lambda_env = FsEnv(env with
				args = args,
				locals = fold(fs_args, env.locals, \acc, arg -> setTree(acc, arg.name, arg))
			);
			closure_vars = map(set2array(closure), \name -> 
				switch (lookupTree(env.locals, name)) {
					Some(tp): tp;
					None(): fail0("can't find type of a var: " + name);
				}
			);
			Pair(FsLambda(
				closure_vars, map(args, \arg -> FsVar(arg.name, false, arg.type, -1)), 
				fiDoExp2FsStat(body, FsReturnToOuter(), lambda_env, if (is_toplevel) fn else "", false), 
				type, -1
			), []);
		}
		FiLet(name, vtype, e1, e2, type, start): {
			if (name == "__") {
				do_exps(e2);
			} else {
				e1_pair = do_exps(e1);
				let_var = FsVar(name, false, vtype, -1);
				let_env = FsEnv(env with
					locals = setTree(env.locals, name, let_var)
				);
				e2_pair = fiDoExp2FsExp(e2, let_env, fn, false);
				Pair(
					e2_pair.first,
					concat3(
						e1_pair.second,
						[FsVarDef(let_var, e1_pair.first, -1)],
						e2_pair.second
					)
				);
			}
		}
		FiIf(e1, e2, e3, type, start): {
			good_exp = \x -> fiExpIsFsExp(x) && !fiExpHasEffects(x, env.effects);
			e1_pair = do_exps(e1);
			e2_pair = do_exps(e2);
			e3_pair = do_exps(e3);
			if (good_exp(e1) && good_exp(e2) && good_exp(e3)) {
				Pair(
					FsCallPrim(FsIfPrim(), [e1_pair.first, e2_pair.first, e3_pair.first], type, -1),
					concat3(e1_pair.second, e2_pair.second, e3_pair.second)
				);
			} else {
				tmp_var = FsVar(
					"if_" + (if (^(env.tmp_if) == 0) "" else "_" + i2s(^(env.tmp_if))),
					false, 
					type, -1
				);
				env.tmp_if := ^(env.tmp_if) + 1;
				Pair(
					tmp_var,
					concat(
						e1_pair.second,
						[FsVarDecl(tmp_var, -1), FsIf(
							e1_pair.first,
							FsSeq(concat(e2_pair.second, [FsAssign(tmp_var, e2_pair.first, -1)]), -1),
							FsSeq(concat(e3_pair.second, [FsAssign(tmp_var, e3_pair.first, -1)]), -1), -1
						)]
					)
				);
			}
		}
		FiCallPrim(op, es, type, start): {
			es_pairs = map(es, do_exps);
			switch (op) {
				FcAssignPrim(): {
					Pair(
						FsConst(FiVoid(start), -1),
						concat(
							concatA(map(es_pairs, \p -> p.second)),
							[FsAssign(es_pairs[0].first, es_pairs[1].first, -1)]
						)
					);
				}
				FcSetMutablePrim(name): {
					Pair(
						FsConst(FiVoid(start), -1),
						concat(
							concatA(map(es_pairs, \p -> p.second)),
							[FsAssign(
								FsCallPrim(FsFieldPrim(name), [es_pairs[0].first], fsExpType(es_pairs[1].first), -1),
								es_pairs[1].first, -1
							)]
						)
					);
				}
				default: {
					Pair(
						FsCallPrim(fcPrim2FsPrim(op),
							map(es_pairs, \p -> p.first), type, -1
						),
						concatA(map(es_pairs, \p -> p.second))
					);
				}
			}
		}
		FiRequire(file, ex, type, start): {
			pair = do_exps(ex);
			Pair(FsCallPrim(FsRequirePrim(file), [pair.first], type, -1), pair.second);
		}
		FiUnsafe(name, ex, type, start): {
			pair = do_exps(ex);
			Pair(FsCallPrim(FsUnsafePrim(name), [pair.first], type, -1), pair.second);
		}
		FiVar(name, type, start): {
			Pair(fiVar2FsVar(name, type, start, env), []);
		}
		FiConst(): {
			Pair(FsConst(e, -1), []);
		}
	}
}

fiVar2FsVar(name: string, type: FiType, start: int, env: FsEnv) -> FsVar {
	switch (lookupTree(env.locals, name)) {
		Some(v): v;
		None(): {
			FsVar(name, false, type, -1);
		}
	}
}

// New version

fiExp2FsStat1(e : FiExp, names: FiGlobalNames, returns: bool, locals: Tree<string, FiVar>) -> FsStat {
	wrap = \x -> if (returns) FsRet(x, -1) else FsWrapExp(x, -1);
	//println("going to fiExp2FsStat1:\n" + prettyFiExp(dummyPretty, e));
	switch (e) {
		FiSeq(es, __, start): {
			fsWrapSeq(concatA(mapi(es, \i, x -> 
				fsUnwrapSeq(
					if (i + 1 == length(es)) fiExp2FsStat1(x, names, returns, locals)
					else fiExp2FsStat1(x, names, false, locals)
				)
			)));
		}
		FiSwitch(v, vtype, cs, type, start): {
			FsSwitch(
				FsVar(v.name, false, v.type, -1), vtype,
				map(cs, \c ->
					FsCase(c.struct, fsCaseStructArgs(c, names), fiExp2FsStat1(c.body, names, returns, locals), -1)
				), -1
			);
		}
		FiLet(name, vtype, e1, e2, type, start): {
			FsLet(FsVar(name, false, vtype, -1), fiExp2FsExp1(e1, names, locals), 
				fiExp2FsStat1(e2, names, returns, setTree(locals, name, FiVar(name, vtype, start))), -1
			);
		}
		FiIf(e1, e2, e3, type, start): {
			FsIf(
				fiExp2FsExp1(e1, names, locals), 
				fiExp2FsStat1(e2, names, returns, locals), 
				fiExp2FsStat1(e3, names, returns, locals), -1
			);
		}
		FiCallPrim(op, es, type, start): {
			switch (op) {
				FcAssignPrim(): {
					s = FsAssign(
						fiExp2FsExp1(es[0], names, locals),
						fiExp2FsExp1(es[1], names, locals), -1
					);
					if (!returns) s else {
						FsSeq([s, FsRet(FsConst(FiVoid(start), -1), -1)], -1);
					}
				}
				FcSetMutablePrim(name): {
					s = FsAssign(
						FsCallPrim(FsFieldPrim(name), [fiExp2FsExp1(es[0], names, locals)], fiExpType(es[1]), -1), 
						fiExp2FsExp1(es[1], names, locals), -1
					);
					if (!returns) s else {
						FsSeq([s, FsRet(FsConst(FiVoid(start), -1), -1)], -1);
					}
				}
				default: {
					wrap(fiExp2FsExp1(e, names, locals));
				}
			}
		}
		default: {
			wrap(fiExp2FsExp1(e, names, locals));
		}
	}
}

fiExp2FsExp1(x : FiExp, names: FiGlobalNames, locals: Tree<string, FiVar>) -> FsExp {
	switch (x) {
		FiSeq(es, type, start): {
			fail("must not happen: expression expected, got: FiSeq " + prettyFiExp(dummyPretty, x));
			FsConst(FiVoid(0), -1);
		}
		FiCast(ex, from, to, type, start): {
			FsCast(fiExp2FsExp1(ex, names, locals), from, type, -1);
		}
		FiCall(fn, args, type, start): {
			FsCall(fiExp2FsExp1(fn, names, locals), map(args, \arg -> fiExp2FsExp1(arg, names, locals)), type, -1);
		}
		FiSwitch(v, vtype, cases, type, start): {
			fail("must not happen: expression expected, got: FiSwitch " + prettyFiExp(dummyPretty, x));
			FsConst(FiVoid(0), -1);
		}
		FiLambda(as, body, type, start): {
			free_vars = fifreevars(x);
			local_vars = buildSet(getTreeKeys(locals));
			closure = intersectSets(free_vars, local_vars);
			fs_args = map(as, \arg -> FsVar(arg.name, false, arg.type, -1));
			closure_vars = map(set2array(closure), \name -> 
				switch (lookupTree(locals, name)) {
					Some(v): FsVar(v.name, false, v.type, -1);
					None(): fail0("can't find type of a var: " + name);
				}
			);
			lambda_locals = fold(as, locals, \acc, arg -> setTree(acc, arg.name, FiVar(arg.name, arg.type, start)));
			FsLambda(closure_vars, fs_args, fiExp2FsStat1(body, names, true, lambda_locals), type, -1);
		}
		FiLet(name, vtype, e1, e2, type, start): {
			fail(
				"must not happen: expression expected, got:\n" + 
				"FiLet " + prettyFiExp(dummyPretty, x) + "\n" +
				toStringFormatted(x)
			);
			FsConst(FiVoid(0), -1);
		}
		FiIf(e1, e2, e3, type, start): {
			fail("must not happen: expression expected, got: FiIf " + prettyFiExp(dummyPretty, x));
			FsConst(FiVoid(0), -1);
		}
		FiCallPrim(op, es, type, start): {
			switch (op) {
				FcAssignPrim(): {
					fail("must not happen: expression expected, got: FiAssignPrim " + prettyFiExp(dummyPretty, x));
					FsConst(FiVoid(0), -1);
				}
				FcSetMutablePrim(name): {
					fail("must not happen: expression expected, got: FcSetMutablePrim " + prettyFiExp(dummyPretty, x));
					FsConst(FiVoid(0), -1);
				}
				default: {
					FsCallPrim(fcPrim2FsPrim(op), map(es, \e -> fiExp2FsExp1(e, names, locals)), type, -1);
				}
			}
		}
		FiRequire(file, ex, type, start): {
			fail("must not happen: expression expected, got: FiRequire " + prettyFiExp(dummyPretty, x));
			FsConst(FiVoid(0), -1);
		}
		FiUnsafe(name, ex, type, start): {
			fail("must not happen: expression expected, got: FiUnsafe " + prettyFiExp(dummyPretty, x));
			FsConst(FiVoid(0), -1);
		}
		FiVar(name, type, start): {
			FsVar(name, false, type, -1);
		}
		FiConst(): {
			FsConst(x, -1);
		}
	}
}
*/

// New version 2

fiExp2FsStat2(e : FiExp, names: FiGlobalNames, returns: bool, locals: Tree<string, FiVar>) -> FsStat {
	wrap = \x -> if (returns) FsRet(x, -1) else FsWrapExp(x, -1);
	//println("going to fiExp2FsStat2:\n" + prettyFiExp(dummyPretty, e));
	switch (e) {
		FiSeq(es, __, start): {
			fsWrapSeq(concatA(mapi(es, \i, x -> 
				fsUnwrapSeq(
					if (i + 1 == length(es)) fiExp2FsStat2(x, names, returns, locals)
					else fiExp2FsStat2(x, names, false, locals)
				)
			)));
		}
		FiSwitch(v, vtype, cs, type, start): {
			FsSwitch(
				FsVar(v.name, false, v.type, -1), vtype,
				map(cs, \c ->
					FsCase(c.struct, fsCaseStructArgs(c, names), fiExp2FsStat2(c.body, names, returns, locals), -1)
				), -1
			);
		}
		FiLet(name, vtype, e1, e2, type, start): {
			fsWrapSeq(concat(
				[FsLet1(FsVar(name, false, vtype, -1), fiExp2FsExp2(e1, names, locals), -1)], 
				fsUnwrapSeq(fiExp2FsStat2(e2, names, returns, setTree(locals, name, FiVar(name, vtype, start))))
			));
		}
		FiIf(e1, e2, e3, type, start): {
			FsIf(
				fiExp2FsExp2(e1, names, locals), 
				fiExp2FsStat2(e2, names, returns, locals), 
				fiExp2FsStat2(e3, names, returns, locals), -1
			);
		}
		FiCallPrim(op, es, type, start): {
			switch (op) {
				FcAssignPrim(): {
					s = FsAssign(
						fiExp2FsExp2(es[0], names, locals),
						fiExp2FsExp2(es[1], names, locals), -1
					);
					if (!returns) s else {
						FsSeq([s, FsRet(FsConst(FiVoid(start), -1), -1)], -1);
					}
				}
				FcSetMutablePrim(name): {
					s = FsAssign(
						FsCallPrim(FsFieldPrim(name), [fiExp2FsExp2(es[0], names, locals)], fiExpType(es[1]), -1), 
						fiExp2FsExp2(es[1], names, locals), -1
					);
					if (!returns) s else {
						FsSeq([s, FsRet(FsConst(FiVoid(start), -1), -1)], -1);
					}
				}
				default: {
					wrap(fiExp2FsExp2(e, names, locals));
				}
			}
		}
		default: {
			wrap(fiExp2FsExp2(e, names, locals));
		}
	}
}

fiExp2FsExp2(x : FiExp, names: FiGlobalNames, locals: Tree<string, FiVar>) -> FsExp {
	switch (x) {
		FiSeq(es, type, start): {
			fail("must not happen: expression expected, got: FiSeq " + prettyFiExp(dummyPretty, x));
			FsConst(FiVoid(0), -1);
		}
		FiCast(ex, from, to, type, start): {
			FsCast(fiExp2FsExp2(ex, names, locals), from, type, -1);
		}
		FiCall(fn, args, type, start): {
			FsCall(fiExp2FsExp2(fn, names, locals), map(args, \arg -> fiExp2FsExp2(arg, names, locals)), type, -1);
		}
		FiSwitch(v, vtype, cases, type, start): {
			fail("must not happen: expression expected, got: FiSwitch " + prettyFiExp(dummyPretty, x));
			FsConst(FiVoid(0), -1);
		}
		FiLambda(as, body, type, start): {
			free_vars = fifreevars(x);
			local_vars = buildSet(getTreeKeys(locals));
			closure = intersectSets(free_vars, local_vars);
			fs_args = map(as, \arg -> FsVar(arg.name, false, arg.type, -1));
			closure_vars = map(set2array(closure), \name -> 
				switch (lookupTree(locals, name)) {
					Some(v): FsVar(v.name, false, v.type, -1);
					None(): fail0("can't find type of a var: " + name);
				}
			);
			lambda_locals = fold(as, locals, \acc, arg -> setTree(acc, arg.name, FiVar(arg.name, arg.type, start)));
			FsLambda(closure_vars, fs_args, fiExp2FsStat2(body, names, true, lambda_locals), type, -1);
		}
		FiLet(name, vtype, e1, e2, type, start): {
			fail(
				"must not happen: expression expected, got:\n" + 
				"FiLet " + prettyFiExp(dummyPretty, x) + "\n" +
				toStringFormatted(x)
			);
			FsConst(FiVoid(0), -1);
		}
		FiIf(e1, e2, e3, type, start): {
			fail("must not happen: expression expected, got: FiIf " + prettyFiExp(dummyPretty, x));
			FsConst(FiVoid(0), -1);
		}
		FiCallPrim(op, es, type, start): {
			switch (op) {
				FcAssignPrim(): {
					fail("must not happen: expression expected, got: FiAssignPrim " + prettyFiExp(dummyPretty, x));
					FsConst(FiVoid(0), -1);
				}
				FcSetMutablePrim(name): {
					fail("must not happen: expression expected, got: FcSetMutablePrim " + prettyFiExp(dummyPretty, x));
					FsConst(FiVoid(0), -1);
				}
				default: {
					FsCallPrim(fcPrim2FsPrim(op), map(es, \e -> fiExp2FsExp2(e, names, locals)), type, -1);
				}
			}
		}
		FiRequire(file, ex, type, start): {
			fail("must not happen: expression expected, got: FiRequire " + prettyFiExp(dummyPretty, x));
			FsConst(FiVoid(0), -1);
		}
		FiUnsafe(name, ex, type, start): {
			fail("must not happen: expression expected, got: FiUnsafe " + prettyFiExp(dummyPretty, x));
			FsConst(FiVoid(0), -1);
		}
		FiVar(name, type, start): {
			FsVar(name, false, type, -1);
		}
		FiConst(): {
			FsConst(x, -1);
		}
	}
}

fcPrim2FsPrim(op: FcPrim) -> FsPrim {
	switch (op) {
		FcOrPrim():  FsOrPrim();
		FcAndPrim(): FsAndPrim();
		FcNotPrim(): FsNotPrim();

		FcEqPrim():  FsEqPrim();
		FcNePrim():  FsNePrim();
		FcLePrim():  FsLePrim();
		FcGePrim():  FsGePrim();
		FcLtPrim():  FsLtPrim();
		FcGtPrim():  FsGtPrim();

		FcPlusPrim():  FsPlusPrim();
		FcMinusPrim(): FsMinusPrim();
		FcMulPrim():   FsMulPrim();
		FcDivPrim():   FsDivPrim();
		FcModPrim():   FsModPrim();
		FcNegPrim():   FsNegPrim();
		FcArrayPrim(): FsArrayPrim();
		FcIndexPrim(): FsIndexPrim();
		FcDerefPrim(): FsDerefPrim();
		FcAssignPrim(): fail0("FcAssignPrim has no Fs counterpart");
		FcRefPrim(): FsRefPrim();
		FcStructPrim(s): FsStructPrim(s);
		FcFieldPrim(f): FsFieldPrim(f);
		FcSetMutablePrim(name): fail0("FcSetMutablePrim has no Fs counterpart");
		FcCreateClosurePrim(__,__): fail0("FcCreateClosurePrim has no Fs counterpart");
		FcQuote():   fail0("FcQuote has no Fs counterpart");
		FcUnquote(): fail0("FcUnquote has no Fs counterpart");
	}
}

fsCaseStructArgs(c: FiCase, names: FiGlobalNames) -> [FsVar] {
	struct = lookupTreeDef(names.structs, c.struct, FiTypeStruct("", [], [], 0));
	mapi(c.argNames, \i, arg_name -> 
		FsVar(arg_name, false, struct.args[i].type, -1)
	);
}
