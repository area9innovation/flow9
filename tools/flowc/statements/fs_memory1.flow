import ds/treeutils;
import tools/flowc/statements/fs_transform;

export {
	fsStatPerceus1(s: FsStat, debug: bool) -> FsStat;
}

fsStatPerceus1(s0: FsStat, debug: bool) -> FsStat {
	id_counter = ref 0;
	new_id = \-> {
		id = ^id_counter;
		id_counter := ^id_counter + 1;
		id;
	}
	s = cast(fsMap(s0, \s -> switch(s) {
		FsIf(__,__,__,__,__):     FsIf(s with id = new_id());
		FsSwitch(__,__,__,__,__): FsSwitch(s with id = new_id());
		FsSeq(__, __):            FsSeq(s with id = new_id());
		FsWrapExp(__,__,__):      FsWrapExp(s with id = new_id());
		FsRet(__,__,__):          FsRet(s with id = new_id());
		FsAssign(__,__,__,__):    FsAssign(s with id = new_id());
		FsIncRc(__,__,__):        FsIncRc(s with id = new_id());
		FsDecRc(__,__):           FsDecRc(s with id = new_id());
		FsLet(__,__,__,__,__):    FsLet(s with id = new_id());
		FsClosure(__,__,__):      FsClosure(s with id = new_id());
		FsLambda(__,__,__,__,__): FsLambda(s with id = new_id());
		FsCall(__,__,__,__):      FsCall(s with id = new_id());
		FsCallPrim(__,__,__,__):  FsCallPrim(s with id = new_id());
		FsCast(__,__,__,__):      FsCast(s with id = new_id());
		FsConst(__,__):           FsConst(s with id = new_id());
		FsTailCall(__,__,__,__):  FsTailCall(s with id = new_id());
		FsVarUse(__,__,__,__):    FsVarUse(s with id = new_id());
	}, false): FsAll -> FsStat);
	vars = ref makeTree();
	fsIter(s, \x -> switch (x) {
		FsVarUse(v, kind, last,__): {
			switch (kind) {
				FsVarLocal(): {
					x.last ::= true;
					switch (lookupTree(^vars, v.name)) {
						Some(prev): prev.last ::= false;
						None(): {}
					}
					vars := setTree(^vars, v.name, x);
				}
				default: {}
			}
		}
		default: {}
	}, false);
	/*
	FsVarMemOps1(
	incs: int,  // How much we need to increment a RC of a var before evaluation of an expression
	dec: bool,  // Should we drop the var in the end of evaluation of an expression explicitly
	kind: FsVarKind
);
	*/
	post_vars = fsId2varsPost1(s, debug);
	ret = fsMarkupStatMemOps(s, makeTree(), post_vars, debug).first;
	/*cast(fsMap2(s, makeTree(), \x, locals -> switch (x) {
		FsIf(cond,__, pos, neg, id):  {
			memops = fsGetMemops1(cond, debug);
			// Remove those locals, which are already dropped in memops
			locals1 = fold(memops, locals, \acc, p -> if (p.second.dec) removeFromTree(acc, p.first.name) else acc);
			fsAddIncs1(memops,
				FsIf(x with
					s1 = fsDecUnused1(pos.id, locals1, fsAddDecsx12(memops, pos, id), post_vars, debug),
					s2 = fsDecUnused1(neg.id, locals1, fsAddDecsx12(memops, neg, id), post_vars, debug)
				), id
			);
		};
		FsSwitch(v,__,__, cs, id): {
			memops = fsGetMemops1(v, debug);
			locals1 = fold(memops, locals, \acc, p -> if (p.second.dec) removeFromTree(acc, p.first.name) else acc);
			fsAddIncs1(memops,
				FsSwitch(x with
					cases = map(cs, \c ->
						FsCase(c with
							body = fsDecUnused1(c.body.id, locals1, fsAddDecsx12(memops, c.body, id), post_vars, debug)
						)
					)
				), id
			);
		}
		FsRet(e,__, id): {
			memops = fsGetMemops1(e, debug);
			fsAddDecsx11(memops, fsAddIncs1(memops, x, id), id);
		}
		FsWrapExp(e,__, id): {
			memops = fsGetMemops1(e, debug);
			x1 = if (fiTypeIsScalar(fsType(e))) x else {
				FsDecRc(e, -1);
			}
			fsAddIncs1(memops, fsAddDecsx1(memops, x1, id), id);
		}
		FsLet(__,e,__, s2, id): {
			memops = fsGetMemops1(e, debug);
			//fsAddIncs1(memops, fsAddDecsx1(memops, x, id), id);
			fsAddIncs1(memops, FsLet(x with s = fsAddDecsx12(memops, s2, s2.id)), id);
		}
		FsAssign(to, what,__, id): {
			memops = fsGetMemops12(to, what, debug);
			fsAddIncs1(memops, fsAddDecsx1(memops, x, id), id);
		}
		FsIncRc(__,__,__): fail0("FsIncRc met during memory operations markup");
		FsDecRc(__,__): fail0("FsDecRc met during memory operations markup");
		FsLambda(__,__, body,__,id): {
			FsLambda(x with body = fsDecUnused1(id, locals, body, post_vars, debug));
		}
		default: x;
	}, true): FsAll -> FsStat);*/

	if (debug) {
		println("perceus:\n" +
			//"s:\n" + fs2s(s) + "\n" +
			"last:\n" + fs2s(s) + "\n"
			//"s RAW:\n" + toStringFormatted(s1) + "\n"
		);
		/*set_tree2s = \st -> {
			superglue(tree2pairs(st), \p ->
				i2s(p.first) + ": " + "[" + superglue(set2array(p.second), \v -> v.name, ", ") + "]", "\n"
			);
		}*/
		//println("post_vars:\n" + set_tree2s(post_vars) + "\n");
		println("result:\n" + "ret:\n" + fs2s(ret) + "\n");
	}

	ret;
}

fsMarkupStatMemOps(s: FsStat, locals: Tree<string, FsVar>, post: Tree<int, Set<FsVar>>, debug: bool) -> Pair<FsStat, Tree<string, FsVar>> {
	switch (s) {
		FsIf(cond,__, pos, neg, id):  {
			cond1 = fsMarkupExpMemOps(cond, locals, post, debug);
			memops = fsGetMemops1(cond, debug);
			// Remove those locals, which are already dropped in memops
			locals1 = fold(memops, locals, \acc, p -> if (p.second.last) removeFromTree(acc, p.first.name) else acc);
			unused_pos = fsFindUnused(pos.id, locals1, post, debug);
			unused_neg = fsFindUnused(neg.id, locals1, post, debug);
			locals_pos = fold(unused_pos, locals1, \acc, v ->removeFromTree(acc, v.name));
			locals_neg = fold(unused_neg, locals1, \acc, v ->removeFromTree(acc, v.name));
			pos1 = fsMarkupStatMemOps(pos, locals_pos, post, debug).first;
			neg1 = fsMarkupStatMemOps(neg, locals_neg, post, debug).first;
			Pair(fsAddIncs1(memops,
				FsIf(s with
					cond = cond1,
					s1 = fsDecUnused1(unused_pos, fsAddDecsx12(memops, pos1, id)),
					s2 = fsDecUnused1(unused_neg, fsAddDecsx12(memops, neg1, id))
				), id
			), locals1);
		};
		FsSwitch(v,__,__, cs, id): {
			v1 = fsMarkupExpMemOps(v, locals, post, debug);
			memops = fsGetMemops1(v, debug);
			locals1 = fold(memops, locals, \acc, p -> if (p.second.last) removeFromTree(acc, p.first.name) else acc);
			cs1 = map(cs, \c -> {
				unused_case = fsFindUnused(c.body.id, locals1, post, debug);
				locals_case = fold(unused_case, locals1, \acc, w ->removeFromTree(acc, w.name));
				body1 = fsMarkupStatMemOps(c.body, locals_case, post, debug).first;
				FsCase(c with
					body = fsDecUnused1(unused_case, fsAddDecsx12(memops, body1, id))
				)
			});
			Pair(fsAddIncs1(memops,
				FsSwitch(s with
					x = v1,
					cases = cs1
				), id
			), locals1);
		}
		FsRet(e,__, id): {
			e1 = fsMarkupExpMemOps(e, locals, post, debug);
			memops = fsGetMemops1(e, debug);
			locals1 = fold(memops, locals, \acc, p -> if (p.second.last) removeFromTree(acc, p.first.name) else acc);
			Pair(fsAddDecsx11(memops, fsAddIncs1(memops, FsRet(s with e = e1), id), id), locals1);
		}
		FsWrapExp(e,__, id): {
			e1 = fsMarkupExpMemOps(e, locals, post, debug);
			memops = fsGetMemops1(e, debug);
			locals1 = fold(memops, locals, \acc, p -> if (p.second.last) removeFromTree(acc, p.first.name) else acc);
			Pair(fsAddIncs1(memops, fsAddDecsx1(memops, 
				if (fiTypeIsScalar(fsType(e1))) FsWrapExp(s with e = e1) else FsDecRc(e1, -1), 
			id), id), locals1);
		}
		FsLet(v, e,__, s1, id): {
			e1 = fsMarkupExpMemOps(e, locals, post, debug);
			var_is_initialized = switch (e) {
				FsConst(c,__): switch (c) {
					FiVoid(__): false;
					default: true;
				}
				default: true;
			}
			locals1 = if (var_is_initialized) setTree(locals, v.name, v) else locals;
			memops = fsGetMemops1(e, debug);
			locals2 = fold(memops, locals1, \acc, p -> if (p.second.last) removeFromTree(acc, p.first.name) else acc);
			if (debug) {
				memops_str = superglue(memops, \p ->
					p.first.name + ": inc(" + i2s(p.second.incs) + ")" + 
					(if (p.second.dec) " + dec(1)" else "") +
					(if (p.second.dec) " + LAST" else ""), 
					", "
				);
				println("LET <" + i2s(id) + ">\n" +
					"\tmemops: [" + memops_str + "]\n" + 
					"\tlocals:  <" + strGlue(getTreeKeys(locals), ", ") + ">\n" +
					"\tlocals1: <" + strGlue(getTreeKeys(locals1), ", ") + ">\n" +
					"\tlocals2: <" + strGlue(getTreeKeys(locals2), ", ") + ">"
				);
			}
			p = fsMarkupStatMemOps(s1, locals2, post, debug);
			s2 = p.first;
			Pair(fsAddIncs1(memops, FsLet(s with
				e = e1,
				s = fsAddDecsx12(memops, s2, s2.id)
			), id), p.second);
		}
		FsAssign(to, what,__, id): {
			to1 = fsMarkupExpMemOps(to, locals, post, debug);
			what1 = fsMarkupExpMemOps(what, locals, post, debug);
			memops = fsGetMemops12(to, what, debug);
			locals1 = fold(memops, locals, \acc, p -> if (p.second.last) removeFromTree(acc, p.first.name) else acc);
			Pair(fsAddIncs1(memops, fsAddDecsx1(memops, FsAssign(s with
				to = to1,
				what = what1
			), id), id), locals1);
		}
		FsSeq(ss,__): {
			p = fold(ss, Pair([], locals), \acc, x -> {
				p = fsMarkupStatMemOps(x, acc.second, post, debug);
				Pair(arrayPush(acc.first, p.first), p.second);
			});
			Pair(FsSeq(s with ss = p.first), p.second);
		}
		FsIncRc(__,__,__): fail0("FsIncRc met during memory operations markup");
		FsDecRc(__,__): fail0("FsDecRc met during memory operations markup");
	}
}

fsMarkupExpMemOps(e: FsExp, locals: Tree<string, FsVar>, post: Tree<int, Set<FsVar>>, debug: bool) -> FsExp {
	switch (e) {
		FsClosure(vars, lambda, id): {
			locals1 = fold(lambda.closure,
				fold(lambda.args, makeTree(), \acc, v -> setTree(acc, v.name, v)),
				\acc, v -> setTree(acc, v.name, v)
			);
			unused = fsFindUnused(lambda.id, locals1, post, debug);
			locals_body = fold(unused, locals1, \acc, w ->removeFromTree(acc, w.name));
			lambda2 = FsLambda(lambda with
				body = fsDecUnused1(unused,
					fsMarkupStatMemOps(lambda.body, locals_body, post, debug).first
				)
			);
			FsClosure(e with lambda = lambda2);
		}
		FsCall(f, args, type, id): {
			FsCall(e with
				f = fsMarkupExpMemOps(f, locals, post, debug),
				args = map(args, \arg -> fsMarkupExpMemOps(arg, locals, post, debug)),
			);
		}
		FsCallPrim(op, es, type, id): {
			FsCallPrim(e with
				es = map(es, \x -> fsMarkupExpMemOps(x, locals, post, debug))
			);
		}
		FsTailCall(args, vals, type, id): {
			FsTailCall(e with
				vals = map(vals, \val -> fsMarkupExpMemOps(val, locals, post, debug))
			);
		}
		FsCast(x, from, type, id): {
			FsCast(e with e = fsMarkupExpMemOps(x, locals, post, debug));
		} 
		FsVarUse(var, kind, last, id): e;
		FsConst(const, id): e;
	}
}

fsFindUnused(id: int, locals: Tree<string, FsVar>, post: Tree<int, Set<FsVar>>, debug: bool) -> [FsVar] {
	unused = foldTree(locals, [], \__,v, acc -> 
		if (fiTypeIsScalar(v.type)) acc else {
			switch (lookupTree(post, id)) {
				Some(vs): {
					if (containsSet(vs, v)) acc else arrayPush(acc, v);
				}
				None(): fail0("id: " + i2s(id) + " must be in a tree");
			}
		}
	);
	if (debug) {
		println("to dec <" + i2s(id) + ">\n" + 
			"\tunused: [" + superglue(unused, \v -> v.name, ", ") + "]\n" +
			"\tlocals: <" + strGlue(getTreeKeys(locals), ", ") + ">"
		);
	}
	unused;
}

fsDecUnused1(unused: [FsVar], x: FsStat) -> FsStat {
	if (length(unused) == 0) x else {
		FsSeq(concat(
			map(unused, \v -> FsDecRc(FsVarUse(v, FsVarLocal(), false, -1), -1)),
			fsUnwrapSeq(x)
		), -1);
	}
}

fsGetMemops1(e: FsExp, debug: bool) -> [Pair<FsVar, FsVarMemOps1>] {
	memops = tree2pairs(fsExpVarIncs1(e, makeTree(), None()));
	if (debug) {
		memops_str = superglue(memops, \p -> p.first.name + ": inc(" + i2s(p.second.incs) + ")" + if (p.second.dec) " + dec(1)" else "", ", ");
		println("memops for <" + i2s(e.id) + ">: [" + memops_str + "]");
	}
	memops;
}

fsGetMemops12(e1: FsExp, e2: FsExp, debug: bool) -> [Pair<FsVar, FsVarMemOps1>] {
	memops = tree2pairs(fsExpVarIncs1(e2, fsExpVarIncs1(e1, makeTree(), None()), None()));
	if (debug) {
		memops_str = superglue(memops, \p -> p.first.name + ": inc(" + i2s(p.second.incs) + ")" + if (p.second.dec) " + dec(1)" else "", ", ");
		println("memops for <" + i2s(e1.id) + ", " + i2s(e2.id) + ">: [" + memops_str + "]");
	}
	memops;
}

fsAddIncs1(memops: [Pair<FsVar, FsVarMemOps1>], x: FsStat, id: int) -> FsStat {
	incs = filtermap(memops, \p ->
		if (p.second.incs > 0) {
			Some(FsIncRc(p.second.incs, FsVarUse(p.first, p.second.kind, false, -1), -1));
		} else {
			None();
		}
	);
	if (length(incs) == 0) x else {
		FsSeq(concat(incs, fsUnwrapSeq(x)), id);
	}
}

fsAddDecsx1(memops: [Pair<FsVar, FsVarMemOps1>], x: FsStat, id: int) -> FsStat {
	decs = filtermap(memops, \p ->
		if (p.second.dec) {
			Some(FsDecRc(FsVarUse(p.first, p.second.kind, false, -1), -1));
		} else {
			None();
		}
	);
	if (length(decs) == 0) x else {
		FsSeq(concat(fsUnwrapSeq(x), decs), id);
	}
}


fsAddDecsx11(memops: [Pair<FsVar, FsVarMemOps1>], x: FsStat, id: int) -> FsStat {
	decs = filtermap(memops, \p ->
		if (p.second.dec) Some(FsDecRc(FsVarUse(p.first, p.second.kind, false, -1), -1)) else None()
	);
	if (length(decs) == 0) x else {
		seq1 = fsUnwrapSeq(x);
		ret = cast(seq1[length(seq1) - 1]: FsStat -> FsRet);
		switch (ret.e) {
			FsTailCall(__,__,__,__): {
				FsSeq(concat3(tail(seq1), decs, [ret]), id);
			}
			default: {
				ret_var = FsVar("tmp_return_var", fsType(ret));
				//seq2 = replace(seq1, length(seq1) - 1, FsLet(ret_var, ret.e, -1));
				//FsSeq(concat3(seq2, decs, [FsRet(FsVarUse(ret_var, FsVarLocal(), false, -1), -1)]), id);
				FsSeq(
					arrayPush(tail(seq1),
						FsLet(ret_var, ret.e, [],
							FsSeq(arrayPush(decs, FsRet(FsVarUse(ret_var, FsVarLocal(), false, -1), [], -1)), id),
							id
						)
					), id
				);
			}
		}
	}
}

fsAddDecsx12(memops: [Pair<FsVar, FsVarMemOps1>], x: FsStat, id: int) -> FsStat {
	decs = filtermap(memops, \p ->
		if (p.second.dec) {
			Some(FsDecRc(FsVarUse(p.first, p.second.kind, false, -1), -1));
		} else {
			None();
		}
	);
	if (length(decs) == 0) x else {
		FsSeq(concat(decs, fsUnwrapSeq(x)), id);
	}
}

FsVarMemOps1(
	incs: int,  // How much we need to increment a RC of a var before evaluation of an expression
	dec: bool,  // Should we drop the var in the end of evaluation of an expression explicitly
	last: bool, // Indicates the last use of a variable in a control flow
	kind: FsVarKind
);

fsExpVarIncs1(e: FsExp, acc: Tree<FsVar, FsVarMemOps1>, mop: Maybe<FsPrim>) -> Tree<FsVar, FsVarMemOps1> {
	switch (e) {
		FsClosure(closure, __,__): {
			fold(closure, acc, \ac, x -> fsExpVarIncs1(x, ac, None()));
		}
		FsCall(f, args,__,__): {
			fold(args, fsExpVarIncs1(f, acc, None()), \ac, x ->
				fsExpVarIncs1(x, ac, None())
			);
		}
		FsCallPrim(o, es,__,__): {
			foldi(es, acc, \i, ac, x -> fsExpVarIncs1(x, ac, Some(o)));
		}
		FsTailCall(args, vals, type, id): {
			fold(vals, acc, \ac, x -> fsExpVarIncs1(x, ac, None()));
		}
		FsCast(e1,__,__,__): {
			fsExpVarIncs1(e1, acc, None());
		}
		FsVarUse(x, kind, last, id): {
			call_case = \-> setTree(acc, x,
				switch (lookupTree(acc, x)) {
					Some(p): FsVarMemOps1(p.incs + if (last) 0 else 1, p.dec, last, kind);
					None(): FsVarMemOps1(if (last) 0 else 1, false, last, kind);
				}
			);
			prim_case = \-> setTree(acc, x,
				switch (lookupTree(acc, x)) {
					Some(p): FsVarMemOps1(p with dec = last, last = last);
					None(): FsVarMemOps1(0, last, last, kind);
				}
			);
			/*prim_case = \-> if (!last) {
				acc
			} else {
				switch (lookupTree(acc, x)) {
					Some(p): setTree(acc, x, FsVarMemOps1(p with dec = true));
					None(): setTree(acc, x, FsVarMemOps1(0, true, kind));
				}
			}*/
			if (fiTypeIsScalar(x.type)) acc else {
				switch (kind) {
					FsVarGlobalFunc(): acc;
					FsVarUninit(): acc;
					default: {
						switch (mop) {
							Some(op): {
								switch (op) {
									FsGePrim(): prim_case();
									FsLePrim(): prim_case();
									FsGtPrim(): prim_case();
									FsLtPrim(): prim_case();
									FsEqPrim(): prim_case();
									FsNePrim(): prim_case();
									FsFieldPrim(__,__): prim_case();
									FsIndexPrim(): prim_case();
									FsDerefPrim(): prim_case();
									default: call_case();
								}
							}
							None(): call_case();
						}
					}
				}
			}
		}
		FsConst(c, id): acc;
	}
}

FsPerceusAcc1(
	id2vars: Tree<int, Set<FsVar>>,
	vars: Set<FsVar>
);

fsMergeStacks1(l1: List<Set<FsVar>>, l2: List<Set<FsVar>>) -> List<Set<FsVar>> {
	switch (l1) {
		Cons(s1, t1): {
			switch (l2) {
				Cons(s2, t2): {
					Cons(mergeSets(s1, s2), fsMergeStacks1(t1, t2));
				}
				EmptyList(): l1;
			}
		}
		EmptyList(): l2;
	}
}

fsMergeVars1(p1: FsPerceusAcc1, p2: FsPerceusAcc1) -> FsPerceusAcc1 {
	FsPerceusAcc1(
		mergeTreeCustom(p1.id2vars, p2.id2vars, \id, x1, x2 -> mergeSets(x1, x2)),
		mergeSets(p1.vars, p2.vars)
	);
}

fsId2varsPost1(s1: FsStat, debug: bool) -> Tree<int, Set<FsVar>> {
	show_vars = \vs -> "[" + superglue(set2array(vs), \v -> v.name, ", ") + "]";
	fsFold2(s1, Pair(FsPerceusAcc1(makeTree(), makeSet()), makeList()),
		\acc, x -> {
			switch (x) {
				FsLambda(__,__,__,__,id): {
					if (debug) {
						st = switch (acc.second) {
							Cons(vars,__): show_vars(vars);
							EmptyList(): ""
						}
						println(
							"(B) id=" + i2s(id) + " pushing stack: [" + show_vars(acc.first.vars) + "]\n" +
							"\tacc.second: [" + st + "]\n"
						);
					}
					Pair(
						FsPerceusAcc1(setTree(acc.first.id2vars, x.id, makeSet()), makeSet()), 
						Cons(acc.first.vars, acc.second)
					);
				}
				default: acc;
			}
		},
		\acc, x: FsAll -> {
			add_v = \ac, v -> if (fiTypeIsScalar(v.type)) ac else insertSet(ac, v);
			switch (x) {
				FsLambda(__,__,__,__,__): {
					switch (acc.second) {
						Cons(new_vars, new_stack): {
							if (debug) {
								println("(B) id=" + i2s(x.id) + " poping stack: " + show_vars(new_vars));
							}
							Pair(FsPerceusAcc1(setTree(acc.first.id2vars, x.id, acc.first.vars), new_vars), new_stack);
						}
						default: fail0("empty stack pop");
					}
				}
				FsVarUse(v, kind, last, id): {
					new_vars = switch (kind) {
						FsVarLocal(): add_v(acc.first.vars, v);
						FsVarUninit(): add_v(acc.first.vars, v);
						default: acc.first.vars;
					}
					Pair(FsPerceusAcc1(setTree(acc.first.id2vars, x.id, acc.first.vars), new_vars), acc.second);
				}
				default: {
					Pair(FsPerceusAcc1(setTree(acc.first.id2vars, x.id, acc.first.vars), acc.first.vars), acc.second);
				}
			}
		},
		\args -> reverseA(args),
		\p1, p2 -> Pair(fsMergeVars1(p1.first, p2.first), fsMergeStacks1(p1.second, p2.second))
	).first.id2vars;
}
