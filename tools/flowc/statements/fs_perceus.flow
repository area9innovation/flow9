import ds/hashset;
import tools/flowc/statements/fs_transform;

export {
	// Markups the AST nodes, which are used in Perceus, with unique ids
	fsPerceusMarkup(s: FsStat) -> Pair<FsStat, int>;

	// Maps the node indexes to the set of ref-counter operations 
	fsPerceusCore(s: FsStat, num_ids: int, debug: bool, name: string) -> [FsMem];

	// Expands the AST with corresponding ref-counter operations
	fsPerceusExpand(s: FsStat, id2mem: [FsMem]) -> FsStat;
}

fsPerceusMarkup(s: FsStat) -> Pair<FsStat, int> {
	id_counter = ref 0;
	new_id = \-> {
		id = ^id_counter;
		id_counter := ^id_counter + 1;
		id;
	}
	s1 = cast(fsMap(s, \x -> switch(x) {
		FsIf(c,__,__,__):         FsIf(x with id = new_id(), cond = fsExpSetId(c, new_id()));
		FsSwitch(__,__,__,__):    FsSwitch(x with id = new_id());
		FsSeq(__, __):            FsSeq(x with id = new_id());
		FsWrapExp(e,__):          FsWrapExp(x with id = new_id(), e = fsExpSetId(e, new_id()));
		FsRet(e,__):              FsRet(x with id = new_id(), e = fsExpSetId(e, new_id()));
		FsAssign(e1, e2,__):      FsAssign(x with id = new_id(), to = fsExpSetId(e1, new_id()), what = fsExpSetId(e2, new_id()));
		FsLet(__,e,__,__):        FsLet(x with id = new_id(), e = fsExpSetId(e, new_id()));
		FsLambda(__,__,__,__,__): FsLambda(x with id = new_id());
		FsVarUse(__,__,__):       FsVarUse(x with id = new_id());
		default: x;
	}, false): FsAll -> FsStat);
	Pair(s1, ^id_counter);
}

fsPerceusCore(s: FsStat, num_ids: int, debug0: bool, name: string) -> [FsMem] {
	debug = ref debug0;
	add_var = \x, acc, v -> {
		switch (lookupTree(acc, v.name)) {
			Some(w): fail(
				"Duplicate variable: " + v.name + " of type: " + pretFiType(v.type) + ", already is of type: " + pretFiType(w.type) + " in:\n" + 
				fs2s(x) + "\n" +
				"IN:\n" + fs2s(s)
			);
			None(): { }
		}
		setTree(acc, v.name, v);
	}
	name2var = fsFold(s, makeTree(), \acc, x -> switch (x) {
		FsLet(v,__,__,__): add_var(x, acc, v);
		FsLambda(__,args,__,__,__): fold(args, acc, \ac, arg -> add_var(x, ac, arg));
		default: acc;
	}, true);
	t1 = timestamp();
	last = fsFindLast(s, num_ids, ^debug, name);
	fsShowTiming(name + ": fsFindLast(s1, num_ids, ^debug, name)", t1);
	crash = ref false;
	t2 = timestamp();
	id2mem = fsId2Mem(s, num_ids, last, name2var);
	if (^debug) {
		println("id2mem:\n" +
			supergluei(
				filter(id2mem, \mem -> sizeTree(mem.incs) > 0 || sizeSet(mem.decs) > 0 || sizeSet(mem.unused) > 0),
				\i, mem -> {
					mem_s = fsMem2string(mem);
					"\t" + i2s(i) + ": " + if (strContains(mem_s, "\n")) strIndent(strIndent(mem_s)) else mem_s;
				}, "\n"
			) 
		);
	}
	fsShowTiming(name + ": fsId2Mem(s1, num_ids, last, name2var)", t2);

	if (^crash) {
		println("s with ids:\n" +
			fs2s(s) + "\n"
			//"s RAW:\n" + toStringFormatted(s1) + "\n"
		);
		fsFindLast(s, num_ids, true, name);
		fail("CRAHS");
	}
	id2mem;
}

fsPerceusExpand(s: FsStat, id2mem: [FsMem]) -> FsStat {
	cast(fsMap(s, \x -> switch (x) {
		FsIf(cond, pos, neg, id):  {
			fsAppendFirst(
				fsExpandUnused(id2mem[id]),
				fsAppendFirst(
					fsExpandIncs(id2mem[id]),
					FsIf(x with
						s1 = fsAppendFirst(fsExpandDecs(id2mem[id]), pos),
						s2 = fsAppendFirst(fsExpandDecs(id2mem[id]), neg)
					)
				)
			);
		};
		FsSwitch(v, __, cs, id): {
			fsAppendFirst(
				fsExpandUnused(id2mem[id]),
				fsAppendFirst(
					fsExpandIncs(id2mem[id]),
					FsSwitch(x with
						cases = map(cs, \c -> 
							FsCase(c with
								body = fsAppendFirst(fsExpandDecs(id2mem[id]), c.body)
							)
						)
					)
				)
			);
		}
		FsSeq(ss, id): {
			fsAppendFirst(fsExpandUnused(id2mem[id]), x);
		}
		FsRet(e, id): {
			fsAppendFirst(
				fsExpandUnused(id2mem[id]),
				fsAppendFirst(
					fsExpandIncs(id2mem[id]),
					fsAppendReturn(x, fsExpandDecs(id2mem[id]))
				)
			);
		}
		FsWrapExp(e, id): {
			fsAppendFirst(
				fsExpandUnused(id2mem[id]),
				fsAppendFirst(
					fsExpandIncs(id2mem[id]),
					fsAppendLast(x, fsExpandDecs(id2mem[id]))
				)
			);
		}
		FsLet(__,e, s1, id): {
			fsAppendFirst(
				fsExpandUnused(id2mem[id]),
				fsAppendFirst(
					fsExpandIncs(id2mem[id]),
					FsLet(x with
						s = fsAppendFirst(fsExpandDecs(id2mem[id]), s1)
					)
				)
			);
		}
		FsAssign(to, what, id): {
			fsAppendFirst(
				fsExpandUnused(id2mem[id]),
				fsAppendFirst(
					fsExpandIncs(id2mem[id]),
					fsAppendLast(x, fsExpandDecs(id2mem[id]))
				)
			);
		}
		FsIncRc(__,__,__): fail0("FsIncRc met during memory operations markup");
		FsDecRc(__,__,__): fail0("FsDecRc met during memory operations markup");
		default: x;
	}, true): FsAll -> FsStat);
}


fsShowTiming(msg: string, start: double) -> void {
	fsShowTiming1(msg, timestamp() - start);
}

fsShowTiming1(msg: string, delta: double) -> void {
	/*t = delta / 1000.0;
	if (t > 0.1) {
		println("\nAAAA " + msg + " took " + d2st(t, 2) + "s.");
	}*/
}

fsId2Mem(s: FsStat, num: int, last: [Set<string>], name2var: Tree<string, FsVar>) -> [FsMem] {
	make_mem = \ -> FsMem(makeTree(), makeSet(), makeSet());
	id2mem = generate(0, num, \__ -> ref make_mem());
	fsIter(s, \x -> switch (x) {
		FsIf(cond, pos, neg, id):  {
			id2mem[id] := fsAddUnused2Mem(
				fsAddExp2Mem(make_mem(), cond, last, None()),
				id, last, name2var
			);
		};
		FsSwitch(v,__, cs, id): {
			id2mem[id] := fsAddUnused2Mem(
				fsAddExp2Mem(make_mem(), v, last, None()),
				id, last, name2var
			);
		}
		FsSeq(ss, id): {
			id2mem[id] := fsAddUnused2Mem(make_mem(), id, last, name2var);
		}
		FsRet(e, id): {
			id2mem[id] := fsAddUnused2Mem(
				fsAddExp2Mem(make_mem(), e, last, None()),
				id, last, name2var
			);
		}
		FsWrapExp(e, id): {
			id2mem[id] := fsAddUnused2Mem(
				fsAddExp2Mem(make_mem(), e, last, None()),
				id, last, name2var
			);
		}
		FsLet(__,e, __, id): {
			id2mem[id] := fsAddUnused2Mem(
				fsAddExp2Mem(make_mem(), e, last, None()),
				id, last, name2var
			);
		}
		FsAssign(to, what, id): {
			id2mem[id] := fsAddUnused2Mem(
				fsAddExp2Mem(
					fsAddExp2Mem(make_mem(), to, last, None()),
					what, last, None()
				),
				id, last, name2var
			);
		}
		FsIncRc(__,__,__): fail("FsIncRc met during memory operations markup");
		FsDecRc(__,__,__): fail("FsDecRc met during memory operations markup");
		default: {}
	}, true);
	map(id2mem, \m -> ^m);
}

fsAddUnused2Mem(mem: FsMem, id: int, last: [Set<string>], name2var: Tree<string, FsVar>) -> FsMem {
	foldSet(last[id], mem, \acc, x ->
		FsMem(acc with unused = insertSet(acc.unused, lookupTreeDef(name2var, x, FsVar(x, FiTypeVoid()))))
	);
}

fsAddExp2Mem(acc: FsMem, e: FsExp, last: [Set<string>], op: Maybe<FsPrim>) -> FsMem {
	switch (e) {
		FsClosure(closure, __,__): {
			fold(closure, acc, \ac, x -> fsAddExp2Mem(ac, x, last, None()));
		}
		FsCall(f, args,__,__): {
			fold(args, fsAddExp2Mem(acc, f, last, None()), \ac, x ->
				fsAddExp2Mem(ac, x, last, None())
			);
		}
		FsCallPrim(o, es,__,__): {
			fold(es, acc, \ac, x -> fsAddExp2Mem(ac, x, last, Some(o)));
		}
		FsCast(e1,__,__,__): {
			fsAddExp2Mem(acc, e1, last, None());
		}
		FsVarUse(x, kind, id): {
			call_case = \-> if (id == -1 || containsSet(last[id], x.name)) acc else {
				FsMem(acc with
					incs = setTree(acc.incs, x, lookupTreeDef(acc.incs, x, 0) + 1)
				);
			}
			prim_case = \-> if (id != -1 && !containsSet(last[id], x.name)) acc else {
				FsMem(acc with decs = insertSet(acc.decs, x));
			}
			if (fiTypeIsScalar(x.type)) acc else {
				switch (kind) {
					FsVarGlobalFunc(): acc;
					FsVarUninit(): acc;
					default: {
						switch (op) {
							Some(oper): {
								switch (oper) {
									FsGePrim(): prim_case();
									FsLePrim(): prim_case();
									FsGtPrim(): prim_case();
									FsLtPrim(): prim_case();
									FsEqPrim(): prim_case();
									FsNePrim(): prim_case();
									FsFieldPrim(__,__): prim_case();
									FsIndexPrim(): prim_case();
									FsDerefPrim(): prim_case();
									default: call_case();
								}
							}
							None(): call_case();
						}
					}
				}
			}
		}
		FsConst(c, id): acc;
	}
}

fsFindLast(s: FsStat, num: int, debug: bool, name: string) -> [Set<string>] {
	s1 = timestamp();
	pre = fsId2varsPre(s, num, debug);
	fsShowTiming(name + ": fsId2varsPre(s, num, debug)", s1);

	s2 = timestamp();
	post = fsId2varsPost(s, num, debug);
	fsShowTiming(name + ": fsId2varsPost(s, num, debug)", s2);

	s3 = timestamp();
	last = fsId2varsLast(s, num, pre, post, debug);
	fsShowTiming(name + ": fsId2varsLast(s, num, debug)", s2);

	if (debug) {
		set_tree2s1 = \st -> {
			superglue(
				filtermapi(st, \i, x -> if (isEmptySet(x)) None() else Some(Pair(i, x))), 
				\p -> "\t" + i2s(p.first) + ": " + "[" + strGlue(set2array(p.second), ", ") + "]", "\n"
			);
		}
		hashset_tree2s1 = \st -> {
			superglue(
				filtermapi(st, \i, x -> if (isEmptyHashSet(x)) None() else Some(Pair(i, x))),
				\p -> "\t" + i2s(p.first) + ": " + "[" + strGlue(hashSet2array(p.second), ", ") + "]", "\n"
			);
		}
		println(
			//"pre:\n" + hashset_tree2s1(pre) + "\n" +
			//"post:\n" + set_tree2s1(post) + "\n" +
			"last:\n" + set_tree2s1(last) + "\n" +
			""
		);
	}
	last;
}

fsId2varsPre(s: FsStat, num: int, debug: bool) -> [HashSet<string>] {
	id2vars = generate(0, num, \__ -> ref makeHashSet(fastHashString));
	fsFold2(s, Cons(makeHashSet(fastHashString), EmptyList()),
		\acc, x: FsAll -> {
			add_v = \ac, v -> if (!fiTypeIsScalar(v.type)) insertHashSet(ac, v.name);
			switch (x) {
				FsLambda(closure, args,__,__,id): {
					new_vars = makeHashSet(fastHashString);
					iter(closure, \v -> add_v(new_vars, v));
					iter(args, \v -> add_v(new_vars, v));
					id2vars[id] := new_vars;
					Cons(new_vars, acc);
				}
				FsLet(v,__,__,id): {
					id2vars[id] := acc.head;
					new_vars = copyHashSet(acc.head);
					add_v(new_vars, v);
					Cons(new_vars, acc.tail);
				}
				default: {
					if (x.id != -1) {
						id2vars[x.id] := acc.head;
					}
					acc;
				}
			}
		},
		\acc, x -> switch (x) {
			FsLambda(__,__,__,__,id): {
				cast(acc.tail: List<HashSet<string>> -> Cons<HashSet<string>>);
			}
			default: acc;
		},
		\args -> args,
		\p1, p2 -> Cons(mergeHashSets(p1.head, p2.head), p1.tail)
	);
	map(id2vars, \x -> ^x);
}

fsId2varsPost(s: FsStat, num: int, debug: bool) -> [Set<string>] {
	show_vars = \vs -> "[" + strGlue(set2array(vs), ", ") + "]";
	id2vars = generate(0, num, \__ -> ref makeSet());
	merge_sets = \id, x -> id2vars[id] := mergeSets(^(id2vars[id]), x);
	fsFold2(s, Cons(makeSet(), EmptyList()),
		\acc, x -> switch (x) {
			FsLambda(__,__,__,__,id): {
				Cons(makeSet(), acc);
			}
			default: acc;
		},
		\acc, x: FsAll -> {
			switch (x) {
				FsLambda(__,__,__,__,id): {
					merge_sets(id, acc.head);
					cast(acc.tail: List<Set<string>> -> Cons<Set<string>>);
				}
				FsVarUse(v, kind, id): {
					new_vars = switch (kind) {
						FsVarLocal(): {
							if (fiTypeIsScalar(v.type)) acc.head else insertSet(acc.head, v.name);
						}
						default: acc.head;
					}
					merge_sets(id, acc.head);
					Cons(new_vars, acc.tail);
				}
				default: {
					if (x.id != -1) {
						merge_sets(x.id, acc.head);
					}
					acc;
				}
			}
		},
		\args -> reverseA(args),
		\p1, p2 -> Cons(mergeSets(p1.head, p2.head), p1.tail)
	);
	map(id2vars, \x -> ^x);
}

fsId2varsLast(s: FsStat, num: int, pre: [HashSet<string>], post: [Set<string>], debug: bool) -> [Set<string>] {
	show_hash_vars = \vs -> "[" + strGlue(hashSet2array(vs), ", ") + "]";
	show_set_vars = \vs -> "[" + strGlue(set2array(vs), ", ") + "]";
	id2vars = generate(0, num, \__ -> ref makeSet());
	t0 = ref 0.0;
	t1 = ref 0.0;
	t2 = ref 0.0;
	t3 = ref 0.0;
	t4 = ref 0.0;
	t5 = ref 0.0;
	hash2set = \x -> foldHashSet(x, makeSet(), \acc, v -> insertSet(acc, v));
	fsFold2(s, Cons(makeHashSet(fastHashString), makeList()),
		\acc: Cons<HashSet<string>>, x: FsAll -> {
			do_diff = \ -> {
				s0 = timestamp();
				diff = copyHashSet(pre[x.id]);
				t0 := ^t0 + timestamp() - s0;

				s1 = timestamp();
				iterSet(post[x.id], \v -> removeHashSet(diff, v));
				t1 := ^t1 + timestamp() - s1;

				s2 = timestamp();
				iterHashSet(acc.head, \v -> removeHashSet(diff, v));
				t2 := ^t2 + timestamp() - s2;

				id2vars[x.id] := hash2set(diff);
				diff;
			}
			switch (x) {
				FsLambda(__,__,__,__,id): {
					do_diff();
					Cons(makeHashSet(fastHashString), acc);
				}
				default: {
					if (x.id == -1) acc else {
						diff = do_diff();
						s3 = timestamp();
						new_head = mergeHashSets(acc.head, diff);
						t3 := ^t3 + timestamp() - s3;
						Cons(new_head, acc.tail);
					}
				}
			}
		},
		\acc, x -> {
			switch (x) {
				FsLambda(__,__,__,__,id): {
					cast(acc.tail: List<HashSet<string>> -> Cons<HashSet<string>>);
				}
				default: acc;
			}
		},
		\args -> args,
		\p1, p2 -> {
			s4 = timestamp();
			new_head = mergeHashSets(p1.head, p2.head);
			t4 := ^t4 + timestamp() - s4;
			Cons(new_head, p1.tail)
		}
	);
	fsShowTiming1("BBB: t0: ", ^t0);
	fsShowTiming1("BBB: t1: ", ^t1);
	fsShowTiming1("BBB: t2: ", ^t2);
	fsShowTiming1("BBB: t3: ", ^t3);
	fsShowTiming1("BBB: t4: ", ^t4);
	fsShowTiming1("BBB: t5: ", ^t5);
	map(id2vars, \x -> ^x);
}
