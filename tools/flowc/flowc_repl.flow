import sys/system;
import string_utils;
import tools/flowc/flowc_helpers;
import tools/common/utils;

export {
	// Runs REPL loop for flow. Console help is available by 'help' command.
	fcReplLoop(config : CompilerConfig) -> void;
}

fcReplDebug(message : string, config : CompilerConfig) -> void {
	if (isConfigParameterTrue(config.config, "repl-debug")) {
		fcDebugLog(message, config);
	}
}

fcReplLoop(config : CompilerConfig) -> void {
	code = if (config.flowfile == "") "" else {
		getFcFileInfo(config.flowfile, config).content
	}
	fcReplDebug("REPL STARTED", config);
	println("Type 'help' and press enter to get more information about REPL mode in flowc.");
	println("A piece of code is input from a command line until an empty line (two enters pressed).");
	for(
		FcReplEnv(config, code, [], makeTree(), false),
		\env -> !env.exit,
		\env -> fcReplLoopStep(env)
	);
	fcReplDebug("REPL ENDED", config);
	quit(0);
}

FcReplCommand ::= FcReplEval, FcReplExec, FcReplCompile, FcReplAdd, FcReplDel, FcReplSave, FcReplImport, FcReplConfig, FcReplExit;
	FcReplEval(expr : string);
	FcReplExec(code : string);
	FcReplCompile(code : string, args : [string]);
	FcReplAdd(name : string, code : string);
	FcReplDel(name : string);
	FcReplSave(file : string);
	FcReplImport(file : string);
	FcReplConfig(opts : [string]);
	FcReplExit();

FcReplEnv(
	config : CompilerConfig,
	code : string,
	imports : [string],
	pieces : Tree<string, string>,
	exit : bool
);

fcReplReadCommand(env : FcReplEnv) -> FcReplCommand {
	print("> ");
	header = ltrim2(fcReadLine(), " \r\n\t");
	comm = trim2({
		i = strIndexOf(header, " ");
		if (i == -1) header else strLeft(header, i);
	}, " \r\n\t");
	args = filtermap(strSplit(trim2(header, " \r\t\n"), " "), \arg -> 
		if (isNotSpace(arg)) Some(trim2(arg, " \r\n\t")) else None()
	);
	fcReplDebug("REPL command name: " + comm + ", command args: " + strGlue(args, ", "), env.config);
	if (length(args) == 0) {
		fcReplReadCommand(env);
	} else {
		if (comm == "help") {
			details = if (length(args) == 1) "" else args[1];
			println(fcReplPrintHelp(details));
			fcReplReadCommand(env);
		} else if (comm == "exit") {
			println("Bye.");
			FcReplExit();
		} else if (comm == "show") {
			if (length(args) == 1) {
				println("show command must take an argument: the name of a code piece");
			} else {
				if (args[1] == "all") {
					println(fcReplJoinCode(env));
				} else {
					switch (lookupTree(env.pieces, args[1])) {
						Some(code): println(code);
						None(): println("There's no piece of code with the name " + args[1]);
					}
				}
			}
			fcReplReadCommand(env);
		} else if (comm == "eval") {
			FcReplEval(fcReadCode(env.config)); 
		} else if (comm == "exec") {
			FcReplExec(fcReadCode(env.config)); 
		} else if (comm == "compile") {
			FcReplCompile(fcReadCode(env.config), tail(args)); 
		} else if (comm == "add") {
			if (length(args) == 1) {
				println("add command must take an argument: the name of a code piece");
				fcReplReadCommand(env);
			} else {
				switch (lookupTree(env.pieces, args[1])) {
					Some(__): {
						if (length(args) == 2 || toLowerCase(args[2]) != "force") {
							println("A piece of code with the name " + args[1] + " already exists");
							fcReplReadCommand(env);
						} else { 
							FcReplAdd(args[1], fcReadCode(env.config)); 
						}
					}
					None(): FcReplAdd(args[1], fcReadCode(env.config)); 
				}
			}
		} else if (comm == "del") {
			if (length(args) == 1) {
				println("del command must take an argument: the name of a code piece");
				fcReplReadCommand(env);
			} else {
				switch (lookupTree(env.pieces, args[1])) {
					Some(__): FcReplDel(args[1]); 
					None(): {
						println("There's no piece of code with the name " + args[1]);
						fcReplReadCommand(env);
					}
				}
			}
		} else if (comm == "save") {
			if (length(args) == 1) {
				println("save command must take an argument: the name of a file");
				fcReplReadCommand(env);
			} else {
				FcReplSave(args[1]);
			}
		} else if (comm == "import") {
			if (length(args) == 1) {
				println("import command must take an argument: the name of a file");
				fcReplReadCommand(env);
			} else {
				FcReplImport(args[1]);
			}
		} else if (comm == "config") {
			if (length(args) == 0) {
				println("config command must take at least one argument");
				fcReplReadCommand(env);
			} else {
				FcReplConfig(tail(args));
			}
		} else {
			FcReplEval(fcReadLines(header, ""));
		}
	}
}

FcReplCode(
	imports : [string],
	source : string
);

fcReplSplitCode(config : CompilerConfig, src : string) -> FcReplCode {
	lines = filtermap(strSplit(src, "\n"), \l -> 
		if (isNotSpace(l)) Some(trim2(l, " \t\r")) else None()
	);
	FcReplCode(
		filtermap(lines, \line ->
			if (startsWith(line, "import ")) Some(rtrim2(strRight(line, 7), "; \t")) else None()
		),
		strGlue(filter(lines, \line -> !startsWith(line, "import")), "\n")
	);
}

fcReplLoopStep(env : FcReplEnv) -> FcReplEnv {
	command = fcReplReadCommand(env);
	fcReplDebug("REPL command: " + toString(command), env.config);
	switch (command) {
		FcReplEval(src): {
			code = fcReplSplitCode(env.config, src);
			expr = fcReplWrapExpr(code.source);
			fcReplRun( 
				FcReplEnv(env with imports = concat(env.imports, code.imports)), 
				expr
			);
			env;
		}
		FcReplExec(src): {
			code = fcReplSplitCode(env.config, src);
			fcReplRun(
				FcReplEnv(env with imports = concat(env.imports, code.imports)), 
				code.source
			);
			env;
		}
		FcReplCompile(src, args): {
			code = fcReplSplitCode(env.config, src);
			fcReplCompile(
				FcReplEnv(env with imports = concat(env.imports, code.imports)), 
				code.source, 
				args
			);
			env;
		}
		FcReplAdd(name, src): {
			code = fcReplSplitCode(env.config, src);
			env_added = FcReplEnv(env with 
				imports = concat(env.imports, code.imports),
				pieces = setTree(env.pieces, name, code.source)
			);
			if (fcReplRun(env_added, "")) env_added else env;
		}
		FcReplDel(name): {
			FcReplEnv(env with pieces = removeFromTree(env.pieces, name));
		}
		FcReplSave(file): {
			setFileContent(file, fcReplJoinCode(env));
			env;
		}
		FcReplImport(file): {
			FcReplEnv(env with imports = concat(env.imports, [file]));
		}
		FcReplConfig(opts): {
			// setConfigOptions(conf : CompilerConfig, opt_pairs : [Pair<string, string>]) -> CompilerConfig;
			FcReplEnv(env with 
				config = setConfigOptions(env.config, filtermap(opts, \opt0 -> {
					opt = trim2(opt0, " \t\r\n");
					if (opt == "") None() else 
					if (!strContains(opt, "=")) Some(Pair(opt, "")) else {
						splitted = strSplit(opt, "=");
						Some(Pair(splitted[0], splitted[1]))
					}
				}))
			);
		}
		FcReplExit(): {
			FcReplEnv(env with exit = true);
		}
	}
}

fcDeleteGently(file : string) -> void {
	if (fileExists(file)) {
		err = deleteFile(file);
		if (err != "") {
			println(err);
		}
	}
}

fcReplWrapExpr(expr : string) -> string {
	expr0 = trim2(expr, " \n\r\t");
	expr1 = if (!endsWith(expr0, ";")) expr0 else strLeft(expr0, strlen(expr0) - 1);
	expr2 = if (!startsWith(expr1, "println(")) expr1 else 
		strRight(strLeft(expr1, strlen(expr1) - 1), 8);
	expr3 = if (!startsWith(expr2, "print(")) expr2 else 
		strRight(strLeft(expr2, strlen(expr2) - 1), 6);
	expr3;
	"println(" + expr3 + ");";
}

fcReplPrepareSource(env : FcReplEnv, code0 : string, args : [string]) -> string {
	code = trim2(code0, " \t\n\r");
	prog_code = 
		"import string;\n" + 
		fcReplJoinCode(env) + "\n" + 
		"main() -> void {\n" + 
		strIndent(if (code != "" && !endsWith(code, ";")) code + ";" else code) + "\n" +
		(if (contains(args, "repl-no-quit=1")) "\t{}\n" else "\tquit(0);\n") + 
		"}\n\n";
	setFileContent("___tmp___.flow", prog_code);
	prog_code;
}

fcReplCompile(env : FcReplEnv, code0 : string, args : [string]) -> bool {
	prog_code = fcReplPrepareSource(env, code0, args);
	fcReplDebug("REPL compiling args: '" + strGlue(args, " ") + "'", env.config);
	fcReplDebug("REPL compiling code:\n" + prog_code, env.config);
	flowc = "flowc1" + (if (hasTargetName("windows")) ".bat" else "");
	err_count = ref 0;
	print_err = \out -> {
		if (out != "") {
			fcReplDebug("REPL err (fcReplRun):\n" + out + "\ncode:\n" + prog_code, env.config);
			if (strContains(toLowerCase(out), "error:")) {
				err_count := ^err_count + 1;
			}
		}
	}
	print_out = \o -> {
		out = trimFlowcHeaderFromOutput(o);
		if (out != "") {
			fcReplDebug("REPL out:\n" + out + "\ncode:\n" + prog_code, env.config);
			if (lookupTreeDef(env.config.config, "repl-compile-output", "") == "1") {
				println(out + "\ncode:\n" + prog_code);
			} else {
				println(out);
			}
		}
	}
	cmp_code = execSystemProcess(flowc, concat(args, ["___tmp___.flow"]), ".", print_err, print_out);
	fcDeleteGently("___tmp___.flow");
	(^err_count == 0) && (cmp_code == 0);
}

fcReplRun(env : FcReplEnv, code : string) -> bool {
	prog_code = fcReplPrepareSource(env, code, []);
	fcReplDebug("REPL running:\n" + prog_code, env.config);
	err_count = ref 0;
	print_err = \out -> {
		if (out != "") {
			fcReplDebug("REPL err (fcReplRun):\n" + out + "\ncode:\n" + prog_code, env.config);
			if (strContains(toLowerCase(out), "error:")) {
				err_count := ^err_count + 1;
			}
		}
	}
	print_out = \o -> {
		out = trimFlowcHeaderFromOutput(o);
		if (out != "") {
			fcReplDebug("REPL out:\n" + out + "\ncode:\n" + prog_code, env.config);
			if (lookupTreeDef(env.config.config, "repl-compile-output", "") == "1") {
				println(out + "\ncode:\n" + prog_code);
			} else {
				println(out);
			}
		}
	}
	engine = getConfigParameterDef(env.config.config, "repl-engine", "bc");
	flowc = "flowc1" + (if (hasTargetName("windows")) ".bat" else "");
	flowcpp = "flowcpp" + (if (hasTargetName("windows")) ".bat" else "");
	compile_code = 
		if (engine == "jar") {
			cmp_code = execSystemProcess(flowc, ["jar=1", "___tmp___.flow"], ".", print_err, println);
			if (cmp_code == 0) {
				execSystemProcess("java", ["-jar", "___tmp___.jar"], ".", print_out, print_out);
				{ }
			} 
			fcDeleteGently("___tmp___.jar");
			cmp_code
		} else if (engine == "js") {
			cmp_code = execSystemProcess(flowc, ["es6=___tmp___.js", "nodejs=1", "___tmp___.flow"], ".", print_err, println);
			if (cmp_code == 0) {
				execSystemProcess("js", ["___tmp___.js"], ".", print_out, print_out);
				{ }
			}
			fcDeleteGently("___tmp___.js");
			cmp_code
		} else if (engine == "bc") {
			cmp_code = execSystemProcess(flowc, ["bytecode=1", "___tmp___.flow"], ".", print_err, println);
			if (cmp_code == 0) {
				execSystemProcess(flowcpp, ["--batch", "___tmp___.bytecode"], ".", print_out, print_out);
				{ }
			}
			fcDeleteGently("___tmp___.bytecode");
			cmp_code
		} else {
			println("unknown execution engine: " + engine);
			-1;
		}
	fcDeleteGently("___tmp___.flow");
	(^err_count == 0) && (compile_code == 0);
}

fcReplJoinCode(env : FcReplEnv) -> string {
	(if (env.imports == []) "" else {
		strGlue(map(env.imports, \imp -> "import " + 
			(if (endsWith(imp, ";")) imp else imp + ";")
		), "\n") + "\n"
	}) +
	(if (env.code == "") "" else env.code + "\n\n") + 
	(if (sizeTree(env.pieces) == 0) "" else 
		concatStrings(map(tree2pairs(env.pieces), 
			\p -> "// " + p.first + "\n" + p.second
		))
	);
}

fcReplPrintHelp(details : string) -> string {
	if (details == "add") {
		"Adding a piece of code.\n" +
		"-----------------------\n" +
		"To add a piece of code enter the command:\n" +
		"\t> add <name> [force]\n" +
		"where <name> is the name of a function/variable/struct/union/etc.\n" + 
		"then press enter and start input of code. Add a 'force' parameter to overwrite the existing code.\n" + 
		"The empty line (double enter) will be considered the end of the code.\n";
	} else if (details == "del") {
		"Deleting a piece of code.\n" +
		"-------------------------\n" +
		"To delete a piece of code enter the command:\n" +
		"\t> del <name>\n" +
		"where <name> is the name of a function/variable/struct/union/etc. added at some previous steps\n";
	} else if (details == "eval") {
		"Evaluate an expression.\n" +
		"-----------------------\n" +
		"To evaluate an expression enter the command:\n" +
		"\t> eval \n" +
		"and press enter. After that the stage of code of the expression input begins.\n" +
		"The other way to enter an expression is just start typing it, so by default what is on\n"+
		"the console is considered an expression to evaluate\n" +
		"The empty line (double enter) means the end of the input.\n";
	} else if (details == "exec") {
		"Execute a code.\n" +
		"-----------------------\n" +
		"To execute a piece of code the command:\n" +
		"\t> exec \n" +
		"and press enter. After that the stage of code input begins.\n" +
		"The empty line (double enter) means the end of the input.\n";
	} else if (details == "save") {
		"Save entered code as a file.\n" +
		"----------------------------\n" +
		"To save all entered code use the command:\n" +
		"\t> save <file>\n" +
		"where <file> is the name of the file, where to the code is saved.\n";
	} else if (details == "show") {
		"Show a piece of code.\n" +
		"----------------------------\n" +
		"To show previously entered piece of code use the command:\n" +
		"\t> show <name>\n" +
		"where <name> is the name of a function/variable/struct/union/etc. added at some previous steps.\n" +
		"You can use 'show all' command to see the whole source code, including the original file source.\n";
	} else if (details == "import") {
		"Add an import.\n" +
		"----------------------------\n" +
		"To add an imported module use command:\n" +
		"\t> import <module>\n" +
		"where <module> is the name of a module.\n";
	} else if (details == "config") {
		"Set a config key-value pairs.\n" +
		"----------------------------\n" +
		"To set config options use a space separated key-value pairs (separated by =):\n" +
		"\t> config <key_1>=<val_1> <key_2>=<val_2> ... <key_n>=<val_n>\n";
	} else {
		"Flowc REPL commands:\n" +
		"--------------------\n" +
		"help            - print this message\n" +
		"help <command>  - print the help on a specific command\n" +
		"exit            - exit from the interpreter\n" +
		"eval            - eval an expression\n" +
		"exec            - execute some code\n" +
		"add <name>      - add a named code fragment \n" +
		"show <name>     - show a named code fragment \n" +
		"del <name>      - delete a named code fragment \n" +
		"save <file>     - save to a file \n" +
		"import <module> - add an import \n" +
		"config <pairs>  - set config key-value pairs \n";
	}
}

fcReadLine() -> string {
	readUntil("\n");
}

fcReadCode(config : CompilerConfig) -> string {
	code = fcReadLines("", "");
	fcReplDebug("REPL code:\n" + code, config);
	code;
}

fcReadLines(prev : string, acc : string) -> string {
	line = fcReadLine();
	two_lines = prev + line;
	if (endsWith(two_lines, "\n\n") || endsWith(two_lines, "\r\n\r\n")) {
		acc + two_lines
	} else {
		fcReadLines(line, acc + prev);
	}
}
