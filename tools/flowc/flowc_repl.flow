import sys/system;
import string_utils;
import tools/flowc/flowc_typecheck;
import tools/common/utils;
import tools/flowc/flow_parser;
import tools/flowc/eval;

export {
	// Runs REPL loop for flow. Console help is available by 'help' command.
	// Help on particular commands is available with 'help <command>'.
	fcReplLoop(config : CompilerConfig) -> void;
}

fcReplDebug(message : string, config : CompilerConfig, level : int) -> void {
	debug_level = s2i(getConfigParameterDef(config.config, "repl-debug", "0"));
	if (debug_level > level) {
		fcReplLog(message, config);
	}
}

fcReplLoop(config : CompilerConfig) -> void {
	code = if (config.flowfile == "") "" else {
		getFcFileInfo(config.flowfile, config).content
	}
	fcReplDebug("REPL STARTED", config, 0);
	fcReplPrintln("Type 'help' and press enter to get more information about REPL mode in flowc.", true, config);
	fcReplPrintln("A piece of code is input from a command line until an empty line (two enters pressed).", true, config);
	for(
		FcReplEnv(config, initFcTypeEnvGlobal(), code, [], makeTree(), false),
		\env -> !env.exit,
		\env -> fcReplLoopStep(env)
	);
	fcReplDebug("REPL ENDED", config, 0);
	quit(0);
}

FcReplPiece ::= FcReplDecls, FcReplStats, FcReplExp;
	FcReplDecls(name : string, code : string, program : Maybe<FiProgram>);
	FcReplStats(name : string, code : string, program : Maybe<FiProgram>);
	FcReplExp(name : string, code : string, program : Maybe<FiProgram>);

FcReplCommand ::= FcReplEval, FcReplExec, FcReplCompile, FcReplAdd, FcReplDel, FcReplSave, FcReplImport, FcReplConfig, FcReplExit;
	FcReplEval(expr : string);
	FcReplExec(piece : FcReplPiece);
	FcReplCompile(code : string, args : [string]);
	FcReplAdd(name : string, code : string);
	FcReplDel(name : string);
	FcReplSave(file : string);
	FcReplImport(file : string);
	FcReplConfig(opts : [string]);
	FcReplExit();

FcReplEnv(
	config : CompilerConfig,
	globEnv : FcTypeEnvGlobal,
	code : string,
	imports : [string],
	pieces : Tree<string, FcReplPiece>,
	exit : bool
);

fcReplPrint(str : string, config : CompilerConfig) -> void {
	print(str);
	fcReplDebug("REPL print: \n" + strIndent(str) + "\n", config, 3);
}

fcReplPrintln(str : string, success : bool, config : CompilerConfig) -> void {
	msg = (if (success) "" else "Error: ") + str;
	println(msg);
	fcReplDebug("REPL println: \n" + strIndent(msg) + "\n", config, 3);
}

fcReplReadCommand(env : FcReplEnv) -> FcReplCommand {
	fcReplPrint("> ", env.config);
	header = ltrim2(fcReadLine(), " \r\n\t");
	comm = trim2({
		i = strIndexOf(header, " ");
		if (i == -1) header else strLeft(header, i);
	}, " \r\n\t");
	splitted = filtermap(strSplit(trim2(header, " \r\t\n"), " "), \arg -> 
		if (isNotSpace(arg)) Some(trim2(arg, " \r\n\t")) else None()
	);
	args = tail(splitted);
	if (length(splitted) == 0) {
		fcReplReadCommand(env);
	} else {
		fcReplDebug("REPL have read command: " + comm + ", args: " + strGlue(args, ", "), env.config, 0);
		if (comm == "help") {
			details = if (length(args) == 0) "" else args[0];
			fcReplPrintln(fcReplPrintHelp(details), true, env.config);
			fcReplReadCommand(env);
		} else if (comm == "exit") {
			fcReplPrintln("Bye.", true, env.config);
			FcReplExit();
		} else if (comm == "show") {
			if (length(args) == 0) {
				fcReplPrintln("show command must take an argument: the name of a code piece", false, env.config);
			} else {
				if (args[0] == "all") {
					fcReplPrintln(fcReplJoinCode(env, true), true, env.config);
				} else {
					switch (lookupTree(env.pieces, args[0])) {
						Some(piece): fcReplPrintln(piece.code, true, env.config);
						None(): fcReplPrintln("There's no piece of code with the name " + args[0], false, env.config);
					}
				}
			}
			fcReplReadCommand(env);
		} else if (comm == "eval") {
			if (length(args) == 0) {
				FcReplEval(fcReadCode(env.config)); 
			} else {
				switch (lookupTree(env.pieces, args[0])) {
					Some(p): {
						FcReplExec(p); 
					}
					None(): {
						fcReplPrintln("No piece of code with the name " + args[0] + " is found", false, env.config);
						fcReplReadCommand(env);
					}
				}
			}
		} else if (comm == "exec") {
			if (length(args) == 0) {
				fcReplPrintln("show command must take an argument: the name of a code piece", false, env.config);
				fcReplReadCommand(env);
			} else {
				switch (lookupTree(env.pieces, args[0])) {
					Some(p): {
						FcReplExec(p); 
					}
					None(): {
						fcReplPrintln("No piece of code with the name " + args[0] + " is found", false, env.config);
						fcReplReadCommand(env);
					}
				}
			}
		} else if (comm == "compile") {
			FcReplCompile(fcReadCode(env.config), args); 
		} else if (comm == "add") {
			if (length(args) == 0) {
				fcReplPrintln("add command must take an argument: the name of a code piece", false, env.config);
				fcReplReadCommand(env);
			} else {
				switch (lookupTree(env.pieces, args[0])) {
					Some(__): {
						if (length(args) == 1 || toLowerCase(args[1]) != "force") {
							fcReplPrintln("A piece of code with the name " + args[0] + " already exists", false, env.config);
							fcReplReadCommand(env);
						} else { 
							FcReplAdd(args[0], fcReadCode(env.config)); 
						}
					}
					None(): {
						FcReplAdd(args[0], fcReadCode(env.config)); 
					}
				}
			}
		} else if (comm == "del") {
			if (length(args) == 0) {
				fcReplPrintln("del command must take an argument: the name of a code piece", false, env.config);
				fcReplReadCommand(env);
			} else {
				switch (lookupTree(env.pieces, args[0])) {
					Some(__): FcReplDel(args[0]); 
					None(): {
						fcReplPrintln("There's no piece of code with the name " + args[0], false, env.config);
						fcReplReadCommand(env);
					}
				}
			}
		} else if (comm == "save") {
			if (length(args) == 0) {
				fcReplPrintln("save command must take an argument: the name of a file", false, env.config);
				fcReplReadCommand(env);
			} else {
				FcReplSave(args[0]);
			}
		} else if (comm == "import") {
			if (length(args) == 0) {
				fcReplPrintln("import command must take an argument: the name of a file", false, env.config);
				fcReplReadCommand(env);
			} else {
				FcReplImport(args[0]);
			}
		} else if (comm == "config") {
			if (length(args) == 0) {
				fcReplPrintln("config command must take at least one argument", false, env.config);
				fcReplReadCommand(env);
			} else {
				FcReplConfig(args);
			}
		} else {
			FcReplEval(fcReadLines(header, ""));
		}
	}
}

FcReplCode(
	imports : [string],
	source : string
);

fcReplSplitCode(config : CompilerConfig, src : string) -> FcReplCode {
	lines = filtermap(strSplit(src, "\n"), \l -> 
		if (isNotSpace(l)) Some(rtrim2(l, " \t\r")) else None()
	);
	FcReplCode(
		filtermap(lines, \line ->
			if (startsWith(line, "import ")) Some(rtrim2(strRight(line, 7), "; \t")) else None()
		),
		strGlue(filter(lines, \line -> !startsWith(line, "import")), "\n")
	);
}

fcReplLoopStep(env : FcReplEnv) -> FcReplEnv {
	command = fcReplReadCommand(env);
	fcReplDebug("REPL command: " + fcReplCommand2s(command, true) + " have read", env.config, 0);
	run = \src -> {
		code = fcReplSplitCode(env.config, src);
		fcReplRun( 
			FcReplEnv(env with imports = concat(env.imports, code.imports)),
			code.source
		);
		env;
	}
	ret = switch (command) {
		FcReplEval(src): {
			run(src);
		}
		FcReplCompile(src, args): {
			code = fcReplSplitCode(env.config, src);
			fcReplCompile(
				FcReplEnv(env with imports = concat(env.imports, code.imports)), 
				code.source, 
				args
			);
			env;
		}
		FcReplExec(piece): {
			switch (piece) {
				FcReplDecls(name, code, program): {
					// evaluation of a declaration makes no effect
					env;
				}
				FcReplStats(name, src, program): {
					run(src);
				}
				FcReplExp(name, src, program): {
					run(src);
				}
			}
		}
		FcReplAdd(name, src): {
			code = fcReplSplitCode(env.config, src);
			fcReplAdd(
				FcReplEnv(env with imports = concat(env.imports, code.imports)), 
				name,
				code.source
			);
		}
		FcReplDel(name): {
			FcReplEnv(env with pieces = removeFromTree(env.pieces, name));
		}
		FcReplSave(file): {
			setFileContent(file, fcReplJoinCode(env, true));
			env;
		}
		FcReplImport(file): {
			FcReplEnv(env with imports = concat(env.imports, [file]));
		}
		FcReplConfig(opts): {
			FcReplEnv(env with 
				config = setConfigOptions(env.config, filtermap(opts, \opt0 -> {
					opt = trim2(opt0, " \t\r\n");
					if (opt == "") None() else 
					if (!strContains(opt, "=")) Some(Pair(opt, "")) else {
						splitted = strSplit(opt, "=");
						Some(Pair(splitted[0], splitted[1]))
					}
				}))
			);
		}
		FcReplExit(): {
			FcReplEnv(env with exit = true);
		}
	}
	fcReplDebug("REPL command: " + fcReplCommand2s(command, false) + " completed", env.config, 0);
	ret;
}

fcDeleteGently(file : string, config : CompilerConfig) -> void {
	if (fileExists(file) && getConfigParameterDef(config.config, "repl-save-tmp", "0") == "0") {
		err = deleteFile(file);
		if (err != "") {
			fcReplDebug("REPL error while deleting: " + file + "\n" + err, config, 0);
			fcReplPrintln(err, false, config);
		}
	}
}

fcReplUnwrapfcReplPrintln(expr : string) -> string {
	expr0 = trim2(expr, " \n\r\t");
	expr1 = if (!endsWith(expr0, ";")) expr0 else strLeft(expr0, strlen(expr0) - 1);
	expr2 = if (!startsWith(expr1, "println(")) expr1 else 
		strRight(strLeft(expr1, strlen(expr1) - 1), 8);
	expr3 = if (!startsWith(expr2, "print(")) expr2 else 
		strRight(strLeft(expr2, strlen(expr2) - 1), 6);
	expr3;
}

fcPrepareExpSource(env : FcReplEnv, code : string, args : [string]) -> string {
	blueprint("
		%env_code%

		main() -> void {
			tmp_var = %expr_code%;
			println2(tmp_var);
		}
		",
		[
			"env_code", fcReplJoinCode(env, false),
			"expr_code", code,
		]
	);
}

fcPrepareStatsSource(env : FcReplEnv, code : string, args : [string]) -> string {
	blueprint("
		%env_code%
		
		main() -> void {
			%main_code%
		}
		",
		[
			"env_code", fcReplJoinCode(env, false),
			"main_code", code
		]
	);
}

fcPrepareDeclsSource(env : FcReplEnv, code : string, args : [string]) -> string {
	main = if (strContains(code, "main()")) "" else 
	blueprint("
		main() -> void {
		}
		",
		["quit", (if (contains(args, "repl-no-quit=1")) "//" else "") + "quit(0);"]
	);
	blueprint("
		%env_code%

		%cur_code%
		
		%main%
		",
		[
			"env_code", fcReplJoinCode(env, false),
			"cur_code", code,
			"main", main
		]
	);
}

fcPreparePieceSource(env : FcReplEnv, piece : FcReplPiece, args : [string]) -> string {
	code = switch (piece) {
		FcReplDecls(name, code, prog): fcPrepareDeclsSource(env, code, args);
		FcReplStats(name, code, prog): fcPrepareStatsSource(env, code, args);
		FcReplExp(name, code, prog):   fcPrepareExpSource(env, code, args);
	}
	setFileContent("___tmp___.flow", code);
	code;
}

fcIsFlowProgram(src : string) -> bool {
	p = parse_flow(src);
	p.first.end == strlen(src);
}

fcReplMakePiece(env : FcReplEnv, name : string, code0 : string) -> Maybe<FcReplPiece> {
	env_code = fcReplJoinCode(env, false);
	code1 = trim2(code0, " \t\n\r");
	cur_code = if (code1 != "" && !endsWith(code1, ";")) code1 + ";" else code1;
	cur_unwrapped = fcReplUnwrapfcReplPrintln(cur_code);
	code_variants = [
		// At first, try to treat code as an expression
		FcReplExp(name, cur_unwrapped, None()),
		// Then, try to treat code as a set of statements
		FcReplStats(name, cur_code, None()),
		// At last, try to treat code as a set of toplevel definitions 
		FcReplDecls(name, cur_code, None()),
	];
	maybeBind(
		find(code_variants, \piece -> {
			code = fcPreparePieceSource(env, piece, []);
			fcReplDebug("REPL TRYING TO PARSE: \n" + piece.code + "\n\n" + code, env.config, 2);
			ret = fcIsFlowProgram(code);
			fcReplDebug("WAS PARSED: " + b2s(ret), env.config, 2);
			ret;
		}),
		\variant -> {
			code = fcPreparePieceSource(env, variant, []);
			fcReplDebug("REPL TRYING TO TYPECHECK: \n" + variant.code + "\n\n" + code, env.config, 2);
			pair = parseAndTypecheckProgram(env.config, initFcTypeEnvGlobal(), "___tmp___");
			if (pair.second == 0) {
				fcReplDebug("WAS TYPECHECKED", env.config, 2);
				Some(switch(variant) {
					FcReplExp(__, __, __): FcReplExp(variant with program = Some(pair.first));
					FcReplStats(__,__,__): FcReplStats(variant with program = Some(pair.first));
					FcReplDecls(__,__,__): FcReplDecls(variant with program = Some(pair.first));
				});
			} else {
				fcReplDebug("WAS NOT TYPECEHECKED", env.config, 2);
				None();
			}
		}
	);
}

fcReplAdd(env0 : FcReplEnv, name : string, code : string) -> FcReplEnv {
	env = FcReplEnv(env0 with 
		pieces = removeFromTree(env0.pieces, name)
	);
	switch (fcReplMakePiece(env, name, code)) {
		Some(piece): {
			fcReplDebug("REPL ADDED: \n" + toString(piece) + "\n\n", env.config, 1);
			FcReplEnv(env with 
				pieces = setTree(env.pieces, name, piece)
			);
		}
		None(): {
			fcReplDebug("REPL ERROR IN CODE:\n" + code, env.config, 0);
			fcReplPrintln("the entered code contains errors and cannot be compiled.", false, env.config);
			env;
		}
	}
}

fcReplCompile(env : FcReplEnv, code0 : string, args : [string]) -> bool {
	r = switch (fcReplMakePiece(env, "", code0)) {
		Some(piece): {
			code = fcPreparePieceSource(env, piece, args);
			fcReplDebug("REPL compiling args: '" + strGlue(args, " ") + "'", env.config, 1);
			fcReplDebug("REPL compiling code:\n" + code, env.config, 2);
			flowc = "flowc1" + (if (hasTargetName("windows")) ".bat" else "");
			output = FcReplOutput(ref [], ref [], ref []);
			print_out = fcReplOnOut(output, env);
			print_err = fcReplOnErr(output, env);
			compile_code = execSystemProcess(flowc, concat(args, ["___tmp___.flow"]), ".", print_out, print_err);
			ret = (length(^(output.errs)) == 0) && (compile_code == 0);
			if (getConfigParameterDef(env.config.config, "repl-output-imediately", "1") == "0") {
				fcReplPrintln(strGlue(^(output.all), "\n"), ret, env.config);
			}
			ret;
		}
		None(): {
			fcReplDebug("REPL ERROR IN CODE:\n" + code0, env.config, 0);
			fcReplPrintln("the entered code contains errors and cannot be compiled.", false, env.config);
			false;
		}
	}
	fcDeleteGently("___tmp___.js", env.config);
	r;
}

fcReplRun(env : FcReplEnv, code0 : string) -> bool {
	r = switch (fcReplMakePiece(env, "", code0)) {
		Some(piece): {
			run_external = \ -> {
				code = fcPreparePieceSource(env, piece, []);
				fcReplDebug("REPL running:\n" + code, env.config, 1);
				output = FcReplOutput(ref [], ref [], ref []);
				print_out = fcReplOnOut(output, env);
				print_err = fcReplOnErr(output, env);
				engine = getConfigParameterDef(env.config.config, "repl-engine", "bc");
				flowc = "flowc1" + (if (hasTargetName("windows")) ".bat" else "");
				flowcpp = "flowcpp" + (if (hasTargetName("windows")) ".bat" else "");
				compile_code = 
					if (engine == "jar") {
						cmp_code = execSystemProcess(flowc, ["jar=1", "___tmp___.flow"], ".", print_out, print_err);
						if (cmp_code == 0) {
							execSystemProcess("java", ["-jar", "___tmp___.jar"], ".", print_out, print_out);
							{ }
						} 
						fcDeleteGently("___tmp___.jar", env.config);
						cmp_code
					} else if (engine == "js") {
						cmp_code = execSystemProcess(flowc, ["es6=___tmp___.js", "nodejs=1", "___tmp___.flow"], ".", print_out, print_err);
						if (cmp_code == 0) {
							execSystemProcess("js", ["___tmp___.js"], ".", print_out, print_out);
							{ }
						}
						fcDeleteGently("___tmp___.js", env.config);
						cmp_code
					} else if (engine == "bc") {
						cmp_code = execSystemProcess(flowc, ["bytecode=1", "___tmp___.flow"], ".", print_out, print_err);
						if (cmp_code == 0) {
							execSystemProcess(flowcpp, ["--batch", "___tmp___.bytecode"], ".", print_out, print_out);
							{ }
						}
						fcDeleteGently("___tmp___.bytecode", env.config);
						cmp_code
					} else {
						fcReplPrintln("unknown execution engine: " + engine, false, env.config);
						-1;
					}
				ret = (length(^(output.errs)) == 0) && (compile_code == 0);
				if (getConfigParameterDef(env.config.config, "repl-output-imediately", "1") == "0") {
					fcReplPrintln(strGlue(^(output.all), "\n"), ret, env.config);
				}
				ret;
			}
			switch (piece.program) {
				Some(program): {
					// fcReplEval(prog : FiProgram, ex : FiExp, vars : Tree<string, FiVal>) -> Maybe<FiVal>
					/*switch (lookupTree(program.names.toplevel, "main")) {
						Some(main): {
							switch (main) {
								FiFunctionDec(__,lambda, type,__,__): {
									ret = fcReplEval(program, FiCall(FiVar()), makeTree());
									isSome(ret);
								}
								default: false;
							}
						}
						None(): {
							// No main function
							false;
						}
					}*/
					//println("CODE:\n" + piece.code);
					vals = fcInitEvalGlobals(program, env.globEnv);
					ret = fcCallFunction("main", [], vals);
					//println("RET: " + toString(ret));
					//maybeApply(ret, \v -> println("RET: " + fiVal2s(v)));
					isSome(ret);
				}
				None(): {
					run_external();
				}
			}
		}
		None(): {
			fcReplDebug("REPL ERROR IN CODE:\n" + code0, env.config, 0);
			fcReplPrintln("the entered code contains errors and cannot be compiled.", false, env.config);
			false;
		}
	}
	fcDeleteGently("___tmp___.js", env.config);
	r;
}

FcReplOutput(
	all  : ref [string],
	errs : ref [string],
	outs : ref [string]
);

fcReplOnErr(output : FcReplOutput, env : FcReplEnv) -> (string) -> void {
	\err -> {
		if (err != "") {
			refArrayPush(output.all, err);
			refArrayPush(output.errs, err);
			fcReplDebug("REPL err:\n" + err, env.config, 0);
			if (getConfigParameterDef(env.config.config, "repl-output-imediately", "1") == "1") {
				fcReplPrintln(err, false, env.config);
			}
		}
	}
}

fcReplOnOut(output : FcReplOutput, env : FcReplEnv) -> (string) -> void {
	\o -> {
		out = trimFlowcHeaderFromOutput(o);
		if (out != "") {
			refArrayPush(output.all, out);
			refArrayPush(output.outs, out);
			fcReplDebug("REPL out:\n" + out, env.config, 1);
			if (getConfigParameterDef(env.config.config, "repl-output-imediately", "1") == "1") {
				fcReplPrintln(out, true, env.config);
			}
		}
	}
}

fcReplJoinCode(env : FcReplEnv, all : bool) -> string {
	imports = uniq(concat(env.imports, ["string"]));
	strGlue(map(imports, \imp -> "import " + 
		(if (endsWith(imp, ";")) imp else imp + ";")
	), "\n") + "\n\n" +
	(if (sizeTree(env.pieces) == 0) "" else 
		concatStrings(map(
			sortCustom(tree2pairs(env.pieces), \p -> p.first, true), 
			\pair -> 
				switch (pair.second) {
					FcReplDecls(name, code, prog): "// " + name + "\n" + code + "\n";
					FcReplStats(name, code, prog): if (all) "// " + name + "\n/* \n" + strIndent(code) + "\n*/\n" else "";
					FcReplExp(name, code, prog):   if (all) "// " + name + "\n//" + strReplace(code, "\n", "\\n") + "\n" else "";
				}
		))
	) +
	(if (env.code == "") "" else env.code + "\n\n");
}

fcReplPrintHelp(details : string) -> string {
	if (details == "add") {
		"Adding a piece of code.\n" +
		"-----------------------\n" +
		"To add a piece of code enter the command:\n" +
		"\t> add <name> [force]\n" +
		"where <name> is the name of a function/variable/struct/union/etc.\n" + 
		"then press enter and start input of code. Add a 'force' parameter to overwrite the existing code.\n" + 
		"The empty line (double enter) will be considered the end of the code.\n";
	} else if (details == "del") {
		"Deleting a piece of code.\n" +
		"-------------------------\n" +
		"To delete a piece of code enter the command:\n" +
		"\t> del <name>\n" +
		"where <name> is the name of a function/variable/struct/union/etc. added at some previous steps\n";
	} else if (details == "eval") {
		"Evaluate an expression.\n" +
		"-----------------------\n" +
		"To evaluate an expression enter the command:\n" +
		"\t> eval \n" +
		"and press enter. After that the stage of code of the expression input begins.\n" +
		"The other way to enter an expression is just start typing it, so by default what is on\n"+
		"the console is considered an expression to evaluate\n" +
		"The empty line (double enter) means the end of the input.\n";
	} else if (details == "exec") {
		"Execute a named piece code.\n" +
		"-----------------------\n" +
		"To execute a piece of code the command:\n" +
		"\t> exec <name>\n" +
		"and press enter.\n";
	} else if (details == "save") {
		"Save entered code as a file.\n" +
		"----------------------------\n" +
		"To save all entered code use the command:\n" +
		"\t> save <file>\n" +
		"where <file> is the name of the file, where to the code is saved.\n";
	} else if (details == "show") {
		"Show a piece of code.\n" +
		"----------------------------\n" +
		"To show previously entered piece of code use the command:\n" +
		"\t> show <name>\n" +
		"where <name> is the name of a function/variable/struct/union/etc. added at some previous steps.\n" +
		"You can use 'show all' command to see the whole source code, including the original file source.\n";
	} else if (details == "import") {
		"Add an import.\n" +
		"----------------------------\n" +
		"To add an imported module use command:\n" +
		"\t> import <module>\n" +
		"where <module> is the name of a module.\n";
	} else if (details == "config") {
		"Set a config key-value pairs.\n" +
		"----------------------------\n" +
		"To set config options use a space separated key-value pairs (separated by =):\n" +
		"\t> config <key_1>=<val_1> <key_2>=<val_2> ... <key_n>=<val_n>\n";
	} else {
		"Flowc REPL commands:\n" +
		"--------------------\n" +
		"help            - print this message\n" +
		"help <command>  - print the help on a specific command\n" +
		"exit            - exit from the interpreter\n" +
		"eval            - eval an expression\n" +
		"exec            - execute a named code fragment\n" +
		"add <name>      - add a named code fragment \n" +
		"show <name>     - show a named code fragment \n" +
		"del <name>      - delete a named code fragment \n" +
		"save <file>     - save to a file \n" +
		"import <module> - add an import \n" +
		"config <pairs>  - set config key-value pairs \n";
	}
}

fcReadLine() -> string {
	readUntil("\n");
}

fcReadCode(config : CompilerConfig) -> string {
	code = fcReadLines("", "");
	fcReplDebug("REPL code:\n" + code, config, 3);
	code;
}

fcReadLines(prev : string, acc : string) -> string {
	line = fcReadLine();
	two_lines = prev + line;
	if (endsWith(two_lines, "\n\n") || endsWith(two_lines, "\r\n\r\n")) {
		acc + two_lines
	} else {
		fcReadLines(line, acc + prev);
	}
}

fcReplCommand2s(command : FcReplCommand, full : bool) -> string {
	switch (command) {
		FcReplEval(expr):          "eval" + if (full) " " + expr else "";
		FcReplExec(piece):         "exec " + fcReplPiece2s(piece, full);
		FcReplCompile(code, args): "compile" + if (full) " " + strGlue(args, " ") else "";
		FcReplAdd(name, code):     "add " + name + if (full) "\n" + code else "";
		FcReplDel(name):           "del " + name;
		FcReplSave(file):          "save " + file;
		FcReplImport(file):        "import " + file;
		FcReplConfig(opts):        "config " + strGlue(opts, " ");
		FcReplExit():              "exit";
	}
}

fcReplPiece2s(piece : FcReplPiece, full : bool) -> string {
	switch (piece) {
		FcReplDecls(name, code, prog): name + " decls" + (if (full) " \n" + code else ""); 
		FcReplStats(name, code, prog): name + " stats" + (if (full) " \n" + code else "");
		FcReplExp(name, code, prog):   name + " exp" + (if (full) " \n" + code else "");
	}
}

fcReplLog(message : string, conf : CompilerConfig) -> void {
	log_file = getConfigParameterDef(conf.config, "repl-log", getFlowDir() + "/.log/flowc_repl.log");
	log_dir = fcDirName(log_file);
	if (log_dir != "") {
		err = ensureDirectoryExists(log_dir);
		if (err != "") {
			fcPrintln(err, conf.threadId);
		}
	}
	if (log_file != "") {
		log_size = s2i(getConfigParameterDef(conf.config, "log-max-lines", "128"));
		message_size = getConfigParameterDef(conf.config, "log-max-message", "4096");
		if (isDigits(message_size)) {
			writeLogMessage(fcCutLongStringUpTo(message, s2i(message_size)), log_file, log_size);
		} else {
			writeLogMessage(message, log_file, log_size);
		}
	}
}


/*
trace = false;

fcReplEval(prog : FiProgram, ex : FiExp, vars : Tree<string, FiVal>) -> Maybe<FiVal> {
	a0 = ^aaa;
	aaa := ^aaa + "\t";
	ret = switch (ex) {
		FiLambda(args, body,__,__): {
			Some(FiFuncVal(\as ->
				fcReplEval(prog, body,
					foldi(args, vars, \i, acc, arg -> setTree(acc, args[i].name, as[i]))
				)
			));
		}
		FiCall(f, args,__,__): {
			maybeBind(fcReplEval(prog, f, vars),
				\f1 -> {
					switch (f1) {
						FiFuncVal(fn): {
							args1 = filtermap(args, \a -> fcReplEval(prog, a, vars));
							if (length(args) != length(args1)) None() else fn(args1);
						}
						default: None();
					}
				}
			);
		}
		FiVar(x,__,__): {
			switch (lookupTree(vars, x)) {
				Some(val): Some(val);
				None(): {
					maybeBind(lookupTree(prog.names.toplevel, x),
						\decl -> {
							switch (decl) {
								FiFunctionDec(__,lambda, __,__,__): {
									fcReplEval(prog, lambda, makeTree());
								}
								FiGlobalVar(__,value, __,__,__): {
									fcReplEval(prog, value, makeTree());
								}
								FiNativeDec(__,__,__,nativeName, fallback,__,__): {
									if (hostCallExists(nativeName, )) {
										//println("Creating native: " + nativeName);
										Some(FiFuncVal(\as -> {
											//println("Calling native: " + nativeName + 
											//	" with args: " + strGlue(map(as, fiVal2s), ", ") + 
											//	" unwrapped: " + strGlue(map(as, \a -> toString(fcUnwrapFiVal(a))), ", ")
											//);
											Some(fcWrapFiVal(hostCall(nativeName, map(as, \a -> 
												fcUnwrapFiVal(a)
											))));
										}));
									} else {
										fcReplEval(prog, fallback, makeTree());
									}
								}
							}
						}
					);
				}
			}
		}
		FiLet(x, __, e1, e2,__,__): {
			maybeBind(fcReplEval(prog, e1, vars),
				\v -> fcReplEval(prog, e2, setTree(vars, x, v))
			);
		}
		FiIf(e1, e2, e3, __,__): {
			maybeBind(fcReplEval(prog, e1, vars),
				\c -> switch (c) {
					FiBoolVal(v): {
						if (v) fcReplEval(prog, e2, vars) else fcReplEval(prog, e3, vars);
					}
					default: None();
				}
			);
		}
		FiSwitch(v,__,cs,__,__): {
			maybeBind(fcReplEval(prog, v, vars),
				\w -> {
					switch (w) {
						FiStructVal(n, fields): {
							maybeBind(
								find(cs, \c -> c.struct == n),
								\c : FiCase -> {
									fcReplEval(prog, c.body, 
										foldi(
											map(fields, fiFiledVal), 
											vars, 
											\i, acc, e -> setTree(acc, c.argNames[i], e)
										)
									)
								}
							);
						}
						default: None();
					}
				}
			);
		}
		FiCast(e, __,to,__,__): {
			maybeMap(fcReplEval(prog, e, vars), \ev -> 
				switch (ev) {
					FiIntVal(v): {
						switch (to) {
							FiTypeDouble(): FiDoubleVal(i2d(v));
							FiTypeString(): FiStringVal(i2s(v));
							default: ev; 
						}
					}
					FiDoubleVal(v): {
						switch (to) {
							FiTypeInt(): FiIntVal(round(v));
							FiTypeString(): FiStringVal(d2s(v));
							default: ev; 
						}
					}
					default: ev;
				}
			);
		}
		FiSeq(es,__,__): {
			ret : ref Maybe<FiVal> = ref Some(FiVoidVal());
			iter(es, \e -> ret := fcReplEval(prog, e, vars));
			^ret;
		}
		FiCallPrim(op, es, __,__): {
			fcReplEvalCallPrim(prog, ex, vars);
		}
		FiString(s,__): Some(FiStringVal(s));
		FiBool(b,__):   Some(FiBoolVal(b));
		FiDouble(d,__): Some(FiDoubleVal(d));
		FiVoid(__):     Some(FiVoidVal());
		FiInt(i,__):    Some(FiIntVal(i));
		FiRequire(flowfile, __,__,__): {
			None();
		}
		FiUnsafe(name, __,__,__): {
			None();
		}
	}
	aaa := a0;
	if (trace) {
		println2(^aaa + "ret (**): " + toString(ret));
	}
	ret;
}


FiVal ::= FiConstVal, FiStructVal, FiArrayVal, FiRefVal, FiNativeVal, FiFuncVal; 

	FiConstVal ::= FiVoidVal, FiBoolVal, FiIntVal, FiDoubleVal, FiStringVal;
	FiStructVal(name : string, fields : [FiFieldVal]);
		FiFieldVal ::= FiConstField, FiMutableField;
		FiConstField(name : string, val : FiVal);
		FiMutableField(name : string, val : ref FiVal);
	FiArrayVal(val : [FiVal]);
	FiRefVal(val : ref FiVal);
	FiNativeVal(val : native);
	FiFuncVal(fn : ([FiVal]) -> Maybe<FiVal>);

	FiVoidVal();
	FiBoolVal(val : bool);
	FiIntVal(val : int);
	FiDoubleVal(val : double);
	FiStringVal(val : string);

fiFiledVal(field : FiFieldVal) -> FiVal {
	switch (field) {
		FiConstField(__,val): val;
		FiMutableField(__,val): ^val;
	}
}

fiVal2s(v : FiVal) -> string {
	switch (v) {
		FiStructVal(name, fields): {
			name + "(" + 
			strGlue(map(fields, \field ->
				switch (field) {
					FiConstField(__, val): fiVal2s(val);
					FiMutableField(__, val): fiVal2s(^val);
				}
			), ", ")
			+ ")";
		}
		FiArrayVal(arr): "[" + strGlue(map(arr, fiVal2s), ", ") + "]";
		FiRefVal(val): "ref " + fiVal2s(^val);
		FiFuncVal(fn): "<func>";
		FiNativeVal(val): "<native>: " + toString(val);
		FiVoidVal(): "{void}";
		FiBoolVal(val): b2s(val);
		FiIntVal(val): i2s(val);
		FiDoubleVal(val): d2s(val);
		FiStringVal(val): "\"" + val + "\"";
	}
}


aaa = ref "";

fcReplEvalCallPrim(prog : FiProgram, call : FiCallPrim, vars : Tree<string, FiVal>) -> Maybe<FiVal> {

	args1 = map(call.es, \e -> {
		//println2(^aaa + "call.es, e: " + toString(e));
		//a0 = ^aaa;
		//aaa := ^aaa + "\t";
		ret = fcReplEval(prog, e, vars);
		//aaa := a0;
		//println2(^aaa + "ret (!!): " + toString(ret));
		ret;
	});
	//println2(^aaa + "args1 - done, len: " + i2s(length(call.es)) + " ?=" + i2s(length(args1)) + ": " + toString(args1));
	//println2(^aaa + "args1: ");
	//iter(args1, println);

	args = filtermap(args1, idfn);
	//println2(^aaa + "args done");
	ret = if (length(args) != length(call.es)) None() else {
		switch (call.op) {
			FcOrPrim(): {
				switch (args[0]) {
					FiBoolVal(b1): {
						switch (args[1]) {
							FiBoolVal(b2): {
								Some(FiBoolVal(b1 || b2));
							}
							default: None();
						}
					}
					default: None();
				}
			}
			FcAndPrim(): {
				switch (args[0]) {
					FiBoolVal(b1): {
						switch (args[1]) {
							FiBoolVal(b2): {
								Some(FiBoolVal(b1 && b2));
							}
							default: None();
						}
					}
					default: None();
				}
			}
			FcNotPrim(): {
				switch (args[0]) {
					FiBoolVal(b): {
						Some(FiBoolVal(!b));
					}
					default: None();
				}
			}
			FcEqPrim(): {
				Some(FiBoolVal(args[0] == args[1]));
			}
			FcNePrim(): {
				Some(FiBoolVal(args[0] != args[1]));
			}
			FcLePrim(): {
				Some(FiBoolVal(args[0] <= args[1]));
			}
			FcGePrim(): {
				Some(FiBoolVal(args[0] >= args[1]));
			}
			FcLtPrim(): {
				Some(FiBoolVal(args[0] < args[1]));
			}
			FcGtPrim(): {
				Some(FiBoolVal(args[0] > args[1]));
			}
			FcPlusPrim(): {
				switch (args[0]) {
					FiIntVal(i1): {
						switch (args[1]) {
							FiIntVal(i2): {
								Some(FiIntVal(i1 + i2));
							}
							default: None();
						}
					}
					FiDoubleVal(d1): {
						switch (args[1]) {
							FiDoubleVal(d2): {
								Some(FiDoubleVal(d1 + d2));
							}
							default: None();
						}
					}
					FiStringVal(s1): {
						switch (args[1]) {
							FiStringVal(s2): {
								Some(FiStringVal(s1 + s2));
							}
							default: None();
						}
					}
					default: None();
				}
			}
			FcMinusPrim(): {
				switch (args[0]) {
					FiIntVal(i1): {
						switch (args[1]) {
							FiIntVal(i2): {
								Some(FiIntVal(i1 - i2));
							}
							default: None();
						}
					}
					FiDoubleVal(d1): {
						switch (args[1]) {
							FiDoubleVal(d2): {
								Some(FiDoubleVal(d1 - d2));
							}
							default: None();
						}
					}
					default: None();
				}
			}
			FcMulPrim(): {
				switch (args[0]) {
					FiIntVal(i1): {
						switch (args[1]) {
							FiIntVal(i2): {
								Some(FiIntVal(i1 * i2));
							}
							default: None();
						}
					}
					FiDoubleVal(d1): {
						switch (args[1]) {
							FiDoubleVal(d2): {
								Some(FiDoubleVal(d1 * d2));
							}
							default: None();
						}
					}
					default: None();
				}
			}
			FcDivPrim(): {
				switch (args[0]) {
					FiIntVal(i1): {
						switch (args[1]) {
							FiIntVal(i2): {
								Some(FiIntVal(i1 / i2));
							}
							default: None();
						}
					}
					FiDoubleVal(d1): {
						switch (args[1]) {
							FiDoubleVal(d2): {
								Some(FiDoubleVal(d1 / d2));
							}
							default: None();
						}
					}
					default: None();
				}
			}
			FcModPrim(): {
				switch (args[0]) {
					FiIntVal(i1): {
						switch (args[1]) {
							FiIntVal(i2): {
								Some(FiIntVal(i1 % i2));
							}
							default: None();
						}
					}
					FiDoubleVal(d1): {
						switch (args[1]) {
							FiDoubleVal(d2): {
								Some(FiDoubleVal(d1 % d2));
							}
							default: None();
						}
					}
					default: None();
				}
			}
			FcNegPrim(): {
				switch (args[0]) {
					FiIntVal(i1): {
						Some(FiIntVal(-i1));
					}
					FiDoubleVal(d1): {
						Some(FiDoubleVal(-d1));
					}
					default: None();
				}
			}
			FcArrayPrim(): {
				Some(FiArrayVal(args));
			}
			FcIndexPrim(): {
				switch (args[0]) {
					FiArrayVal(arr): {
						switch (args[1]) {
							FiIntVal(i): {
								if (0 <= i && i + 1 <= length(arr)) {
									Some(arr[i]);
								} else {
									None();
								}
							}
							default: None();
						}
					}
					default: None();
				}
			}
			FcDerefPrim(): {
				switch (args[0]) {
					FiRefVal(rf): {
						Some(^rf);
					}
					default: None();
				}
			}
			FcAssignPrim(): {
				switch (args[0]) {
					FiRefVal(rf): {
						rf := args[1];
						Some(FiVoidVal());
					}
					default: None();
				}
			}
			FcRefPrim(): {
				Some(FiRefVal(ref args[0]));
			}
			FcStructPrim(struct_name): {
				maybeMap(lookupTree(prog.names.structs, struct_name),
					\struct -> FiStructVal(struct_name, mapi(struct.args, \i, arg -> 
						if (arg.ismutable) FiMutableField(arg.name, ref args[i]) else FiConstField(arg.name, args[i])
					))
				);
			}
			FcFieldPrim(name): {
				//println("Field: " + name + ", call: " + toString(call) + ", args: " + toString(args));
				switch (args[0]) {
					FiStructVal(str, fields): {
						findmap(fields, \field -> 
							if (field.name == name) {
								switch (field) {
									FiConstField(__,val): Some(val);
									FiMutableField(__,val): Some(^val);
								}
							} else None()
						);
					}
					default: None();
				}
			}
			FcSetMutablePrim(name): {
				switch (args[0]) {
					FiStructVal(str, fields): {
						findmap(fields, \field -> 
							if (field.name == name) {
								switch (field) {
									FiMutableField(__, val): {
										val := args[1];
										Some(FiVoidVal());
									}
									default: None();
								}
							} else {
								None()
							}
						);
					}
					default: None();
				}
			}
			// creates a closure explicitly - appears after lambda lifting
			FcCreateClosurePrim(structName, functionName): {
				// TODO
				None();
			}
			FcQuote(): {
				// TODO
				None();
			}
			FcUnquote(): {
				// TODO
				None();
			}
		}
	}
	//println2(^aaa + "ret: " + toString(ret));
	ret
}

fcUnwrapFiVal(ex : FiVal) -> flow {
	switch (ex) {
		FiStructVal(name, fields): {
			makeStructValue(
				name, 
				map(fields, \field -> fcUnwrapFiVal(fiFiledVal(field))), 
				IllegalStruct()
			);
		}
		FiArrayVal(val): map(val, fcUnwrapFiVal);
		FiRefVal(val): ref fcUnwrapFiVal(^val);
		FiFuncVal(fn): \as -> maybeMap(fn(map(as, fcWrapFiVal)), fcUnwrapFiVal);
		FiStringVal(s): s;
		FiBoolVal(b):   b;
		FiDoubleVal(d): d;
		FiVoidVal():    ex;
		FiIntVal(i):    i;
		FiNativeVal(v): v;
	}
}

fcWrapFiVal(v : flow) -> FiVal {
	// What is the type tag for this value? Supported only in cpp and java
	// 0: void, 1: bool, 2: int, 3: double, 4 : string, 5: array, 6: struct, 12: code pointer, 20: native function
	// 31: reference, 32: native value, 34: closure pointer, 48: captured frame
	type_tag = getDataTagForValue(v);
	if (type_tag == 0) {
		FiVoidVal();
	} else if (type_tag == 1) {
		FiBoolVal(cast(v : flow -> bool));
	} else if (type_tag == 2) {
		FiIntVal(cast(v : flow -> int));
	} else if (type_tag == 3) {
		FiDoubleVal(cast(v : flow -> double));
	} else if (type_tag == 4) {
		FiStringVal(cast(v : flow -> string));
	} else if (type_tag == 5) {
		FiArrayVal(map(cast(v : flow -> [flow]), fcWrapFiVal));
	} else if (type_tag == 6) {
		name = extractStructName(v);
		fields = structFieldNames(name);
		FiStructVal(
			name,
			mapi(extractStructArguments(v), \i, w -> 
				FiConstField(fields[i], fcWrapFiVal(w))
			)
		);
	} else if (type_tag == 31) {
		FiRefVal(
			ref fcWrapFiVal(^cast(v : flow -> ref flow))
		);
	} else if (type_tag == 34) {
		fn = cast(v : flow -> (([flow]) -> flow));
		FiFuncVal(\as -> {
			ret = fn(map(as, fcUnwrapFiVal));
			if (getDataTagForValue(ret) == 0) None() else {
				Some(fcWrapFiVal(ret));
			}
		});
	} else {
		FiNativeVal(v);
	}
}
*/
