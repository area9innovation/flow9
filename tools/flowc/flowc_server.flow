import server/http;
import tools/flowc/flowc_lsp;

export {
	// A language server working over http.
	fcHttpServer(config : CompilerConfig) -> void;

	// A language server using stdin/stdout to communicate. Usually is invoked as a child process of an IDE.
	fcProcServer(config : CompilerConfig) -> void;
}

fcDecodeConfigRequest(s : string) -> Maybe<CompilerConfig> {
	conf = deserialize(s, IllegalStruct());
	if (conf == IllegalStruct()) None() else {
		switch (conf) {
			CompilerConfig(__,__,__,__,__,__,__): {
				Some(CompilerConfig(conf with threadId = s2i(getThreadId())));
			}
			default: None();
		}
	}
}

fcProcessRequest(serverConf : CompilerConfig, env : FcTypeEnvGlobal, req : string, out_cb : (int, string) ->  void, loop_cb : () -> void, exit_cb : () -> void) -> void {
	if (startsWith(req, "config_")) {
		encoded_conf = substring(req, 7, strlen(req) - 7);
		switch (fcDecodeConfigRequest(encoded_conf)) {
			Some(config): {
				start_time = timestamp();
				pair = fcPrepareConfig(config);
				conf = pair.first;
				conf_callback = pair.second;
				conf_str = foldTree(compilerConfigToTree(conf), "",
					\key, val, acc -> acc + " " + key + (if (val != "") "=" + val else "")
				);
				if (isConfigParameterTrue(config.config, "server-shutdown")) {
					exit_cb();
				} else {
					fcServerLog("Processing http request: <" + conf_str + " >");
					fcPrintln("Processing '" + conf.flowfile + "' on http server.", config.threadId);
					runConfigLocally(conf, env, \code -> {
						fcServerLog("Request processing finished in " + d2st((timestamp() - start_time) / 1000.0, 2) + " s.");
						conf_callback();
						out = if (isConfigParameterTrue(conf.config, "dump-program") || isConfigParameterSet(conf.config, "compile-expression")) {
							fcBinary(conf.threadId);
						} else {
							fcOutput(conf.threadId);
						}
						out_cb(code, out);
						clearFcOutput(conf.threadId);
						clearTimePhases(conf.threadId);
						loop_cb();
					});
				}
			}
			None(): {
				out_cb(200, "WARNING: Illegal request.");
				loop_cb();
			}
		}
	} else {
		json = fcDecodeJsonRequest(req);
		if (json == JsonNull()) {
			out_cb(200, "WARNING: Illegal request.");
			loop_cb();
		} else {
			fcLspProcessRequest(serverConf, env, json, \msg -> out_cb(0, msg), loop_cb, exit_cb);
		}
	}
}

fcProcServer(config : CompilerConfig) -> void { 
	fcServerLog("Proc server started.");
	fcSetSkipPrinting(config.threadId, true);
	fcRunProcServer(initFcTypeEnvGlobal(), config);
}

	// Runs asynchronous task in a new thread passing it's ID as an argument as well as a callback
	// to return a result in the end. Will call onDone when task is finished and send result to the main thread.
	//native concurrentAsyncCallback : (task : (threadId : string, callback : (?) -> void) -> void, onDone : (?) -> void) -> void = Native.concurrentAsyncCallback;

fcRunProcServer(env : FcTypeEnvGlobal, config : CompilerConfig) -> void {
	switch (fcLspReadRequest()) {
		Some(req): {
			fcServerLog("Processing proc request: <" + strReplaces(req, ["\n", "", "\r", "", "\t", " "]) + " >");
			fcProcessRequest(config, env, req, 
				\__, msg -> println(msg),
				\-> fcRunProcServer(env, config),
				\-> {
					fcServerLog("Proc server stopped.");
					quit(0);
				}
			);
		}
		None(): {
			fcServerLog("Failed to read a request.");
			fcRunProcServer(env, config);
		}
	}
}

fcHttpServer(config : CompilerConfig) -> void {
	port = s2i(getConfigParameter(config.config, "server-port"));
	env = initFcTypeEnvGlobal();
	server = ref nop;
	server := createHttpServer(port,
		\-> {
			fcServerLog("Http server started.");
			fcPrintln("Http server started.", config.threadId)
		},
		\request, response -> {
			fcProcessRequest(config, env, request.body,
				\code, output -> HttpResponse(200 + code, output, []) |> response,
				nop,
				\-> {
					^server();
					fcPrintln("Http server stopped.", config.threadId);
					fcServerLog("Http server stopped.");
					quit(0);
				}
			)
		}
	);
}
