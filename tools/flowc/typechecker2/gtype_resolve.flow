import tools/flowc/typechecker2/gtype;
import text/blueprint;
import tools/flowc/typechecker2/gtype_util;
import tools/flowc/typechecker2/gsubtype_graph;
import tools/flowc/typechecker2/gbounds;
import tools/flowc/debug;
import tools/flowc/type_helpers;
import loop;

export {
	// Resolve the graph
	resolveGGraph(
		env : GEnv, 
		// The name of the function we are resolving (for debugging)
		name : string, 
		// Unify left vs. right for these positions
		unify : (GEnv, GType, GType, Set<int>, onError : (GEnv, FcError) -> void) -> GEnv, 
		// Given this error message and these positions, construct an FcError
		makeFcError : (string, Set<int>) -> FcError, 
		// When we see an error, report it like this
		onError : (GEnv, FcError) -> void
	) -> GEnv;
}

// TODO: findPotentialGSubtypes can be greatly optimized by having a subtype graph of structs and unions

// TODO: When doing field vs. union, we could potentially do prolog-style and check then for real instead
// of trying to filter

resolveGGraph(
		env : GEnv, 
		name : string, 
		unify : (GEnv, GType, GType, Set<int>, onError : (GEnv, FcError) -> void) -> GEnv, 
		makeFcError : (string, Set<int>) -> FcError, 
		onError : (GEnv, FcError) -> void
	) -> GEnv {
	grenv = GResolutionEnv(
		env, name, unify, makeFcError, onError, 0, GResolveSafeOnly(), false, 0
	);
	doResolveGGraph(grenv).env;
}

// When we are resolving the graph, we keep track of the progress with this structure
GResolutionEnv(
	env : GEnv, 
	name : string, 
	unify : (GEnv, GType, GType, Set<int>, onError : (GEnv, FcError) -> void) -> GEnv, 
	makeFcError : (string, Set<int>) -> FcError, 
	onError : (GEnv, FcError) -> void,
	iteration : int,
	stage : GResolutionStage,
	// If this is set, we stop
	abort : bool,
	speculation : int
);

doResolveGGraph(grenv : GResolutionEnv) -> GResolutionEnv {
	if (grenv.env.verbose >= 2) {
		printStay(grenv.env.env, "\nResolve tyvars: " + toString(set2array(grenv.env.unresolvedTyvars)) + " iteration " + i2s(grenv.iteration) + " in stage " + toString(grenv.stage) + " speculation depth " + i2s(grenv.speculation) + "\n");
	}
	nrenv = foldSet(grenv.env.unresolvedTyvars, grenv, \acc : GResolutionEnv, tv -> {
		// During the loop, we can resolve stuff, no need to redo that
		if (!acc.abort && containsSet(acc.env.unresolvedTyvars, tv)) {
			reqs = buildGTyvarRequirement(acc.env, tv);
			if (acc.env.verbose >= 2) {
				printIndent(acc.env.env, "Clarify " + gtyvarReqs2string(acc.env, reqs) + " {");
			}
			res = clarifyGTyvar(acc, reqs);
			if (res.env.verbose >= 2) {
				printDedent(res.env.env, "}");
			}
			res;
		} else acc;
	});

	if (nrenv.abort) {
		if (nrenv.env.verbose >= 4) {
			printStay(nrenv.env.env, "Aborted tyvars: " + toString(set2array(nrenv.env.unresolvedTyvars)) + " " +  toString(nrenv.stage));
		}
		nrenv
	} else {
		if (nrenv.env.verbose >= 4) {
			saveGDot(nrenv.env, nrenv.name + "_" + i2s(nrenv.iteration));
		}

		if (!isEmptySet(nrenv.env.unresolvedTyvars) && !equalSet(grenv.env.unresolvedTyvars, nrenv.env.unresolvedTyvars)) {
			// There were changes in some of the tyvars, so go again in a safe
			grnenv = GResolutionEnv(nrenv with 
				iteration = nrenv.iteration + 1,
				stage = GResolveSafeOnly()
			);
			doResolveGGraph(grnenv)
		} else {
			if (isEmptySet(nrenv.env.unresolvedTyvars) || nrenv.stage == GResolveTypars()) {
				// OK, we are done
				nrenv
			} else {
				// Do one more round
				grnenv = GResolutionEnv(nrenv with 
					iteration = nrenv.iteration + 1,
					stage = nextGResolutionStage(nrenv.stage)
				);
				doResolveGGraph(grnenv)
			}
		}
	}
}

// We implement a staged heuristic for solving things.
GResolutionStage ::= GResolveSafeOnly, GResolveSafeButAmbiguous, GResolveSpeculative, GResolveTypars;
	// 1. Resolve all unambigious cases
	GResolveSafeOnly();

	// 2. If there is multiple solutions that might work, just pick one.
	GResolveSafeButAmbiguous();

	// 3. If we only have unbound tyvars remaining as stoppers for making progress, just
	//    ignore those, and assume they will be fine
	GResolveSpeculative();

	// 4. Convert connected, unbound tyvars to type pars
	GResolveTypars();

nextGResolutionStage(stage : GResolutionStage) -> GResolutionStage {
	switch (stage) {
		GResolveSafeOnly(): GResolveSafeButAmbiguous();
		GResolveSafeButAmbiguous(): GResolveSpeculative();
		GResolveSpeculative(): GResolveTypars();
		GResolveTypars(): GResolveTypars();
	}
}


// We know this tyvar is unbound, and we know about all the bounds.
// See if we can solve it
clarifyGTyvar(grenv : GResolutionEnv, req : GTyvarRequirements) -> GResolutionEnv {
	lower = req.lower;
	upper = req.upper;

	// OK, check if it is fixed
	fixed = mergeSets(lower.fixedTypes, upper.fixedTypes);

	if (lower.hasFlow) {
		GResolutionEnv(grenv with env = setGTyvar(grenv.env, grenv.unify, req, GFlow(), grenv.onError));
	} else if (!isEmptySet(fixed) || upper.hasFlow) {
		// OK, we have something fixed. Let us go with that
		if (sizeSet(fixed) == 1 && !upper.hasFlow) {
			// OK, we have a unique, fixed type for our guy
			fixedType = set2array(fixed)[0];
			GResolutionEnv(grenv with env = setGTyvar(grenv.env, grenv.unify, req, fixedType, grenv.onError));
		} else if (upper.hasFlow && sizeSet(fixed) != 1) {
			// None or multiple, which do not agree, but we have flow, so I guess we go flow
			GResolutionEnv(grenv with env = setGTyvar(grenv.env, grenv.unify, req, GFlow(), grenv.onError));
		} else {
			if (grenv.env.verbose >= 3) {
				printIndent(grenv.env.env, "Fixed clarification: " + gtyvarReqs2string(grenv.env, req) + " {");
			}	

			// There are multiple solutions.
			pick = switch (grenv.stage) {
				GResolveSafeOnly(): false;
				GResolveSafeButAmbiguous(): false;
				GResolveSpeculative(): true;
				GResolveTypars(): true;
			}

			penv = if (grenv.stage == GResolveSafeOnly()) {
				// See if we can unpeel it
				//   Clarify { : [TextSize<>], [α40001] :  : } c= α40004 c= { :  :  : } {
				// is handled by setting α40004= [<tyvar>].
				rtype = restructureGType(grenv.env, fixed);
				switch (rtype) {
					None(): grenv.env;
					Some(rt): {
						setGTyvar(grenv.env, grenv.unify, req, rt, grenv.onError);
					}
				}
			} else grenv.env;

			renv = if (pick) {
				// There are multiple solutions. We just pick one
				fixedType = set2array(fixed)[0];
				// printStay(env.env, "Review: We picked " + gtype2string(env, fixedType) +
				//	" pick the smallest " + gtyvarReqs2string(env, req) + "");
				setGTyvar(penv, grenv.unify, req, fixedType, grenv.onError);
			} else {
				penv;
			}

			if (renv.verbose >= 3) {
				printDedent(renv.env, "} Fixed clarification: " + gtyvarReqs2string(renv, req) + " {");
			}

			GResolutionEnv(grenv with env = renv);
		}
	} else {
		// OK, no fixed. There can be tyvars and subtypes
		lowerOnlyTyvars = isGBoundsOnlyTyvars(grenv.env, lower);
		upperOnlyTyvars = isGBoundsOnlyTyvars(grenv.env, upper);

		if (lowerOnlyTyvars && upperOnlyTyvars) {
			// Only tyvars.
			switch (grenv.stage) {
				GResolveSafeOnly(): grenv;
				GResolveSafeButAmbiguous(): grenv;
				GResolveSpeculative(): grenv;
				GResolveTypars(): {
					// No constraints. All of these tyvars are all identical and should be bound
					// to the next free typar.
					tyvars = mergeSets(mergeSets(lower.tyvars, upper.tyvars), req.tyvars);
					GResolutionEnv(grenv with env = resolveGTypeVarToTyPar(grenv.env, tyvars));
				}
			}
		} else {
			// We have subtypes, either named or fields
			lowerSet : Set<GSubType> = getGSubTypes(lower.named, switch (grenv.stage) {
				GResolveSafeOnly(): makeSet();
				GResolveSafeButAmbiguous(): lower.fields;
				GResolveSpeculative(): lower.fields;
				GResolveTypars(): lower.fields;
			});
			ltypenames : [string] = findPotentialGSupertypes(grenv.env, lowerSet);

			upperSet : Set<GSubType> = getGSubTypes(upper.named, switch (grenv.stage) {
				GResolveSafeOnly(): makeSet();
				GResolveSafeButAmbiguous(): upper.fields;
				GResolveSpeculative(): upper.fields;
				GResolveTypars(): upper.fields;
			});

			// Something seems to imply that we should do union here. Test 148 as an example
			utypenames : [string] = findPotentialGSubtypes(grenv.env, upperSet);

 			possible = if (isEmptySet(lowerSet)) utypenames
				else if (isEmptySet(upperSet)) ltypenames
				else intersection(ltypenames, utypenames);

			// printStay(env.env, "Review " + toString(possible) + " l: " + toString(ltypenames) +" u: " + toString(utypenames) + " from req " + gtyvarReqs2string(env, req));

			if (length(possible) == 1) {
				// OK, lower and upper can agree on a named type. Construct it
				winner = possible[0];
				// Make this type with the typars
				winType = makeGNamedType(grenv.env, winner);

				if (grenv.env.verbose >= 3) {
					printStay(grenv.env.env, "Agreement : " + gtyvarReqs2string(grenv.env, req) + " {");
				}

				// And set ourselves to this
				GResolutionEnv(grenv with env = setGTyvar(grenv.env, grenv.unify, req, winType, grenv.onError));
			} else {
				if (grenv.stage == GResolveSpeculative()) {
					// Here we do prolog!

					// Find the best order. First, go by explicit names
					singleNamed = mapSet(mergeSets(lower.named, upper.named), \n -> n.name);
					posset = buildSet(possible);
					overlap = intersectSets(singleNamed, posset);

					remaining = differenceSets(posset, overlap);

					dosort = \s : Set<string> -> {
						scored = map(set2array(s), \sname -> Pair(getGNamedSize(grenv.env, sname), sname));
						map(sort(scored), secondOfPair);
					}

					// The priorized order: Known names in smallest first, then smallest unknown names
					cheapest = concat(dosort(overlap), dosort(remaining));

					if (grenv.env.verbose >= 4) {
						printIndent(grenv.env.env, "Speculation with " + toString(cheapest) + " {");
					}

					senv = findErrorFreeCandidate(grenv, cheapest, req);

					if (senv.env.verbose >= 4) {
						printDedent(senv.env.env, "} speculation " + if (senv.abort) " failed" else " succeeded");
					}

					senv;
				} else {
					if (grenv.stage == GResolveTypars()) {
						error = grenv.makeFcError("Add type annotation. Can not find type that is " + gtyvarReqs2stringNice(grenv.env, req), req.starts);
						grenv.onError(grenv.env, error);
					}
					grenv;
				}
			}
		}
	}
}

findErrorFreeCandidate(grenv : GResolutionEnv, candidates : [string], req : GTyvarRequirements) -> GResolutionEnv {
	if (candidates == []) {
		error = grenv.makeFcError("Add type annotation. Can not find type that is " + gtyvarReqs2stringNice(grenv.env, req), req.starts);
		grenv.onError(grenv.env, error);
		GResolutionEnv(grenv with abort = true);
	} else {
		type = makeGNamedType(grenv.env, candidates[0]);
		errors = ref false;
		// println("Speculating with " + candidates[0]);
		nenv = setGTyvar(grenv.env, grenv.unify, req, type, \__, __ -> {
			errors := true;
		});

		if (!^errors) {
			if (false) {
				// OK, run the rest of the algorithm against this one
				// to check if it works out
				renv = doResolveGGraph(
					GResolutionEnv(
						grenv with env = nenv,
						onError = \__, __ -> {
							errors := true;
						},
						speculation = grenv.speculation + 1
					)
				);
				
				if (!^errors) {
					if (renv.env.verbose >= 4) {
						printStay(renv.env.env, "Success with " + candidates[0]);
					}
					GResolutionEnv(
						renv with
						speculation = renv.speculation - 1
					);
				} else {
					// OK, did not work recursively. Let us try the next.
					findErrorFreeCandidate(grenv, tail(candidates), req);
				}
			} else {
				GResolutionEnv(
					grenv with env = nenv
				)
			}
		} else {
			//  println("Failure with " + candidates[0]);
			// OK, did not work. Let us try the next.
			findErrorFreeCandidate(grenv, tail(candidates), req);
		}
	}
}

// Set all these tyvars to the next free typar
resolveGTypeVarToTyPar(env : GEnv, tyvars : Set<int>) -> GEnv {
	// Find the next free type par
	typars = foldTree(env.tyvars, makeSet(), \tv, type, acc -> {
		extractGTypePars(env, type, acc)
	});
	mtypar = popMaxSet(typars);
	lasttypar = eitherMap(mtypar, \r -> r.value, "");
	typar = GTypePar(lasttypar + "?");

	// Now, set all tyvars to this typar		
	foldSet(tyvars, env, \acc, tv -> {
		if (env.verbose >= 2) {
			printStay(env.env, "α" + i2s(tv) + " = " + gtype2string(env, typar));
		}
		GEnv(
			acc with
			tyvars = setTree(acc.tyvars, tv, typar),
			unresolvedTyvars = removeSet(acc.unresolvedTyvars, tv)
		);
	});
}

// Does this only contain unresolved tyvars?
isGBoundsOnlyTyvars(env : GEnv, bounds : GBounds) -> bool {
	!bounds.hasFlow && isEmptySet(bounds.fixedTypes) && isEmptySet(bounds.named) && isEmptySet(bounds.fields)
}

// Is this bound a set of only known names?
isGBoundsKnownNames(env : GEnv, bounds : GBounds) -> bool {
	!bounds.hasFlow
	&& isEmptySet(bounds.fixedTypes)
	&& isEmptySet(bounds.tyvars) 
	// If the bound is a named type, we have better handle
	&& !isEmptySet(bounds.named)
	&& isEmptySet(bounds.fields)
	;
}

// Set this group of tyvars to this resolved type
setGTyvar(env : GEnv, unify : (GEnv, GType, GType, Set<int>, (GEnv, FcError) -> void) -> GEnv, req : GTyvarRequirements, type : GType, onError : (GEnv, FcError) -> void) -> GEnv {
	tyvars = req.tyvars;

	if (env.verbose >= 2) {
		printStay(env.env, superglue(set2array(tyvars), \tv -> "α" + i2s(tv), ", ") + " = " + gtype2string(env, type));
	}

	if (true) {
		// Set our friends
		nenv0 = foldSet(tyvars, env, \env0, tyvar -> {
			GEnv(
				env0 with
				tyvars = setTree(env0.tyvars, tyvar, type),
				unresolvedTyvars = removeSet(env0.unresolvedTyvars, tyvar)
			);
		});

		// Add the new unresolved
		tyvarsInType = extractGTypeVars(nenv0, type, makeSet());
		nenv1 = GEnv(
			nenv0 with
			unresolvedTyvars = mergeSets(nenv0.unresolvedTyvars, tyvarsInType)
		);

		// Then unify with relations
		foldSet(tyvars, nenv1, \nenv2, tyvar -> {
			gtype = GTypeVar(tyvar);

			uppers = getGUpperRelations(nenv2.grelations, gtype);
			nenv3 = foldSet(uppers, nenv2, \nenv4, to -> {
				if (!isGTypeVars(tyvars, to)) {
					unify(nenv4, type, to, req.starts, onError)
				} else nenv4;		
			});

			lowers = getGLowerRelations(nenv3.grelations, gtype);
			foldSet(lowers, nenv3, \nenv5, to -> {
				if (!isGTypeVars(tyvars, to)) {
					unify(nenv5, to, type, req.starts, onError)
				} else nenv5;
			});
		});
	} else {
		foldSet(tyvars, env, \env0, tyvar -> {
			nenv0 = GEnv(
				env0 with
				tyvars = setTree(env0.tyvars, tyvar, type),
				unresolvedTyvars = removeSet(env0.unresolvedTyvars, tyvar)
			);
			// Join with all lower fixed
			nenv1 = foldSet(req.lower.fixedTypes, nenv0, \acc, t -> unify(acc, t, type, req.starts, onError));
			// Join with all upper fixed
			nenv2 = foldSet(req.upper.fixedTypes, nenv1, \acc, t -> unify(acc, type, t, req.starts, onError));

			// Unify with subs
			nenv3 = foldSet(req.lower.named, nenv2, \acc, st -> unify(acc, st, type, req.starts, onError));
			nenv4 = foldSet(req.lower.fields, nenv3, \acc, st -> unify(acc, st, type, req.starts, onError));

			// Unify with supers
			nenv5 = foldSet(req.upper.named, nenv4, \acc, st -> unify(acc, type, st, req.starts, onError));
			nenv6 = foldSet(req.upper.fields, nenv5, \acc, st -> unify(acc, type, st, req.starts, onError));

			tyvarsInType = extractGTypeVars(nenv6, type, makeSet());
			GEnv(
				nenv6 with
				unresolvedTyvars = mergeSets(nenv6.unresolvedTyvars, tyvarsInType)
			);
		});
	}
}

isGTypeVars(tyvars : Set<int>, type : GType) -> bool {
	switch (type) {
		GTypeVar(id): containsSet(tyvars, id);
		default: false;
	}
}

// Given these constraints, what supertypes could meet all of these?
findPotentialGSupertypes(env : GEnv, types : Set<GSubType>) -> [string] {
	foldi(set2array(types), [], \i, acc, st -> {
		supers = findGSupertypes(env, st);
		if (i == 0) supers
		else intersection(supers, acc)
	});
}

// Find all types which type can be dominated by, including itself
findGSupertypes(env : GEnv, expr : GSubType) -> [string] {
	switch (expr) {
		GNamed(name, __): {
			superset = findGSupertypeFromName(env, name);
			arrayPush(superset, name);
		}
		GField(field, __): {
			findGSupertypeFromName(env, "." + field);
		}
	}
}

// Given these constraints, what subtypes could meet all of these?
findPotentialGSubtypes(env : GEnv, types : Set<GSubType>) -> [string] {
	foldi(set2array(types), [], \i, acc, st -> {
		subs = findGSubtypes(env, st);
		// println(gtype2string(env, st) + ": " + toString(subs));
		if (i == 0) subs
		else intersection(subs, acc)
	});
}


// Find all types which are subtypes of this constraint, including ourselves
findGSubtypes(env : GEnv, expr : GSubType) -> [string] {
	switch (expr) {
		GNamed(name, __): {
			mun = lookupTree(env.env.program.acc.names.unions, name);
			switch (mun) {
				None(): {
					// A struct: It can only be ourselves
					[name];
				}
				Some(un): {
					// A union: It can be ourselves, any subunion or the structs
					uniq(fold(un.typenames, [name], \acc, tn -> {
						concat(acc, findGSubtypes(env, GNamed(tn.name, [])))
					}));
				}
			}
		}
		GField(field, __): {
			// OK, here we filter the set to those names that appear in the environment
			possible = getTreeArrayValue(env.env.program.acc.names.field2structs, field);
			filtered = filter(possible, \p -> containsSet(env.namesSeen, p));
			// If the filter looses all, we do not filter after all
			if (filtered == []) possible else filtered;
		}
	}
}

// Given these exprs, and a desired type name, extract it, if we directly have it.
// If we do not, then we should construct the type ourselves with type-pars.
resolveGSubTypeToName(env : GEnv, name : string, types : Set<GNamed>) -> GType {
	result = foldSet(types, [], \acc, named : GNamed -> {
		if (named.name == name) arrayPush(acc, named) else acc;
	});

	if (result == []) {
		// OK, we could not find it, so we have to construct it
		makeGNamedType(env, name)
	} else {
/*		if (length(result) > 1) {
			printStay(env.env, "TODO: We need " + name + " and randomly pick the first here: " + toString(result));
		}*/
		// OK, pick one, but prefer one with some flesh on it
		preferWithoutTyvars(env, buildSet(result))[0];
	}
}

// Build a type with this name, and empty typars
makeGNamedType(env : GEnv, name : string) -> GType {
	mstruct = lookupTree(env.env.program.acc.names.structs, name);
	switch (mstruct) {
		None(): {
			munion = lookupTree(env.env.program.acc.names.unions, name);
			switch (munion) {
				None(): {
					// Not found.
					GNamed(name, []);
				}
				Some(union): {
					GNamed(name, map(union.typeparameters, \__ -> {
						mkGTypeVar(env)
					}))
				}
			}
		}
		Some(structdef): {
			GNamed(name, map(structdef.typars, \__ -> {
				mkGTypeVar(env)
			}))
		}
	}
}

findSmallestGSuperTypes2(env : GEnv, names : [string]) -> [string] {
	if (length(names) <= 1) names
	else {
		foldi(names, [], \i, acc, st -> {
			supers = arrayPush(findGSupertypeFromName(env, st), st);
			if (i == 0) supers
			else intersection(supers, acc)
		});
	}
}

findSmallestGSuperTypes(env : GEnv, names : Set<GNamed>) -> [GType] {
	if (isEmptySet(names)) []
	else {
		typeNames = mapSet(names, \s -> s.name);
		if (sizeSet(typeNames) == 1) {
			// They are all the same name, so pick any of them, prefing those without tyvars
			[preferWithoutTyvars(env, names)[0]];
		} else {
			// flow compiler is crazy, so we have to jump through hoops
			st : Set<GSubType> = getGSubTypes(names, makeSet());
			ltypenames : [string] = findPotentialGSupertypes(env, st);
			if (length(ltypenames) == 1) {
				winner = ltypenames[0];
				[resolveGSubTypeToName(env, winner, names)];
			} else {
				printStay(env.env, "TODO: We should pick the smallest supertype for " + toString(names));				
				// TODO: We could try to find the smallest supertype that covers all of these guys
				[];
			}
		}
	}
}

findBiggestGSubTypes2(env : GEnv, names : [string]) -> [string] {
	if (length(names) <= 1) names
	else {
		foldi(names, [], \i, acc, st -> {
			subs = findGSubtypes(env, GNamed(st, []));
			// println(st + ": " + toString(subs));
			if (i == 0) subs
			else intersection(subs, acc)
		});
	}
}


findBiggestGSubTypes(env : GEnv, names : Set<GNamed>) -> [GType] {
	if (isEmptySet(names)) []
	else {
		typeNames = mapSet(names, \s -> s.name);
		if (sizeSet(typeNames) == 1) {
			// They are all the same name, so pick any of them, prefing those without tyvars
			[preferWithoutTyvars(env, names)[0]];
		} else {
			st : Set<GSubType> = getGSubTypes(names, makeSet());
			ltypenames : [string] = findPotentialGSubtypes(env, st);
			if (length(ltypenames) == 1) {
				winner = ltypenames[0];
				[resolveGSubTypeToName(env, winner, names)];
			} else {
				printStay(env.env, "TODO: We should pick the biggest subtype for req " + toString(names));
				// TODO: We could try to find the biggest subtype that covers all of these guys
				[];
			}
		}
	}
}

// Extract a type of the correct shape to fit this monster
restructureGType(env : GEnv, types : Set<GType>) -> Maybe<GType> {
	foldSet(types, None(), \acc : Maybe<GType>, tt : GType -> {
		switch (acc) {
			None(): {
				switch (tt) {
					GFunction(args, rt): {
						gtype : GType = GFunction(map(args, \__ -> mkGTypeVar(env)), mkGTypeVar(env));
						Some(gtype)
					}
					GArray(atype): Some(GArray(mkGTypeVar(env)));
					GRef(rtype): Some(GRef(mkGTypeVar(env)));
					GBasicType(__): acc;
					GFlow(): acc;
					GTypePar(id): acc;
					GTypeVar(id): acc;
					GNamed(name, typars): acc;
					GField(name, type): acc;
				}
			}
			Some(t): acc;
		}
	})
}


// Get some kind of score for a name. Structs is the number of typars + fields. Unions is 10 * number of structs + number of fields in total
getGNamedSize(env : GEnv, name : string) -> int {
	mstruct = lookupTree(env.env.program.acc.names.structs, name);
	switch (mstruct) {
		None(): {
			munion = lookupTree(env.env.program.acc.names.unions, name);
			switch (munion) {
				None(): intMax;
				Some(union): {
					fold(union.typenames, 1 + length(union.typeparameters), \acc, tn -> {
						acc + 10 * getGNamedSize(env, tn.name)
					});
				}
			}
		}
		Some(structdef): 1 + length(structdef.typars) + length(structdef.args);
	}
}

// Given these types, filter those without tyvars, but otherwise, just give us what we have
preferWithoutTyvars(env : GEnv, types : Set<GNamed>) -> [GNamed] {
	hasTyvars = filterSet(types, \t -> {
		!isEmptySet(extractGTypeVars(env, t, makeSet()))
	});

	noTyvars = differenceSets(types, hasTyvars);

	l = set2array(noTyvars);
	if (l != []) l
	else set2array(hasTyvars)
}

gtyvarReqs2string(env : GEnv, req : GTyvarRequirements) -> string {
	gbounds2string(env, req.lower) + " c= " + superglue(set2array(req.tyvars), \tyvar -> "α" + i2s(tyvar), ", ") + " c= " + gbounds2string(env, req.upper);
}

gtyvarReqs2stringNice(env : GEnv, req : GTyvarRequirements) -> string {
	lb = gbounds2stringNice(env, req.lower);
	ub = gbounds2stringNice(env, req.upper);
	(if (lb == "") lb else "union of " + lb)
	+ (if (lb != "" && ub != "") " and " else "")
	+ (if (ub == "") ub else "subtype for " + ub)
}

gbounds2string(env : GEnv, g : GBounds) -> string {
	"{"
	+ (if (g.hasFlow) " flow " else "")
	+ superglue(set2array(g.tyvars), \tv -> "α" + i2s(tv), ", ")
	+ " : " + superglue(set2array(g.fixedTypes), \t -> gtype2string(env, t), ", ")
	+ " : " + superglue(set2array(g.named), \st -> gtype2string(env, st), ", ")
	+ " : " + superglue(set2array(g.fields), \st -> gtype2string(env, st), ", ")
	+ "}"
}

gbounds2stringNice(env : GEnv, g : GBounds) -> string {
	strGlue(concatA([
		if (g.hasFlow) ["flow"] else [],
		map(set2array(g.fixedTypes), \t -> gtype2string(env, t)),
		map(set2array(g.named), \st -> gtype2string(env, st)),
		map(set2array(g.fields), \st -> gtype2string(env, st))
		]
	), ", ")
}


getGSubTypes(names : Set<GNamed>, fields : Set<GField>) -> Set<GSubType> {
	// Only to get flow to compile. This is basically just mergeSets
	mergeSets(mapSet(names, \n : GSubType -> n), mapSet(fields, \f : GSubType -> f))
}