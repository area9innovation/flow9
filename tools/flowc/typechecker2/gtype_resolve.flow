import tools/flowc/typechecker2/gtype;
import text/blueprint;
import tools/flowc/typechecker2/gtype_util;
import tools/flowc/typechecker2/gsubtype_graph;
import tools/flowc/typechecker2/gbounds;
import tools/flowc/typechecker2/gresolution_stage;
import tools/flowc/debug;
import tools/flowc/type_helpers;
import loop;

/*
While unifying, we are building a graph, and can keep track of tyvars
which are unresolved with what stage of resolution they are in:

	tyvarsQueue : Set<GQueueItem(stage, tyvarid)>

So the loop is:

- Pick next tyvar from the queue. TODO: We could attempt to prioritize these
  based on constraints like fixed, names, fields, or something.

- Then resolve the tyvar. Once we resolve it, other tyvars has new info, and are reset in stage.

- For tyvars where there are multiple solutions, we try each to find one that works.

- If we can not clarify a tyvar in a given iteration, we push it to the next resolution stage

Whenever there is a change in the bounds for a tyvar, it is bumped back to
the initial stage.

Types:
- We should consider to convert types to ints, and use bitvectors for the type sets?

Todo:
- When there is a speculative error, the error is not placed on the right place. I.e. the
  last error position should be reported. We could recould the speculative assignments
  we made without speculative recursive check and use those when we fail.


Ideas:
- Fine-tune the queue priorities.
  - Invent some metric to see how we can improve. Test 103 is solved by the priorities

  - getColorNames takes 36s!

- Figure out the relation between speculative rules. Some are "inside" other rules, so a 
  different order might help.

  For a given tyvar, we could find the recursively dependent tyvars inside, and build a graph
  of these, so we can see what tyvars are part of what.

- Reduce size of speculation set:
	- Limit the number of types to test when speculating? Does not help much to speculate on Form.
	Might affect correctness?
	- Split speculation into two stages?: One with known types, and another with all.

- Track the speculation statistics so we can follow improvements in priorities, other things

- When speculating, should we consider to reset the queue, and only try to solve "related"
  tyvars instead of the full graph?

- Have special relation which is tight at the top, but directed below. Struct construction:
  We know what the top-level type is, but the typars/args can be subtyped.

- When ambigous, but all types share the same supertype, we can indeed unify the typars
  even if we do not know the specific type. That is the case when we have just one named
  restriction in the upper bound, and the typar mapping is trivial. Very special case,
  but could be helpful. "Maybe" is prime example.

- Do lazy speculation. I.e. save alternatives in a stack, but do not backtrack at the top,
  but from the bottom. The question is whther this effectively is the same as we do, is it not?
  It could be different if we do not speculate in the same order, but that is tricky, since we
  have to identify "independent" speculations

- Include source code in .dot

Failing test cases:

101: spec 1
test_lib: spec 1
*/

export {
	// Resolve the graph
	resolveGGraph(
		env : GEnv, 
		// The name of the function we are resolving (for debugging)
		name : string, 
		// Unify left vs. right for these positions
		unify : (GEnv, GType, GType, Set<int>, onError : (GEnv, FcError) -> void) -> GEnv, 
		// Given this error message and these positions, construct an FcError
		makeFcError : (string, Set<int>) -> FcError, 
		// When we see an error, report it like this
		onError : (GEnv, FcError) -> void
	) -> GEnv;
}

// TODO: findPotentialGSubtypes can be greatly optimized by having a subtype graph of structs and unions

// TODO: When doing field vs. union, we could potentially do prolog-style and check then for real instead
// of trying to filter

resolveGGraph(
		env : GEnv, 
		name : string, 
		unify : (GEnv, GType, GType, Set<int>, onError : (GEnv, FcError) -> void) -> GEnv, 
		makeFcError : (string, Set<int>) -> FcError, 
		onError : (GEnv, FcError) -> void
	) -> GEnv {
	grenv = GResolutionEnv(
		env, name, unify, makeFcError, onError, 0, false, 0
	);
	gresolution = doResolveGGraph(grenv);
	gresolution.env;
}

// When we are resolving the graph, we keep track of the progress with this structure
GResolutionEnv(
	env : GEnv, 
	name : string, 
	unify : (GEnv, GType, GType, Set<int>, onError : (GEnv, FcError) -> void) -> GEnv, 
	makeFcError : (string, Set<int>) -> FcError, 
	onError : (GEnv, FcError) -> void,
	iteration : int,
	// If this is set, we stop
	abort : bool,
	speculation : int
);

doResolveGGraph(grenv : GResolutionEnv) -> GResolutionEnv {
	if (grenv.abort) {
		grenv;
	} else {
		if (false) {
			printIndent(grenv.env.env, "Queue is {");
			dumpGTyvarQueue(grenv, grenv.env.grelations.tyvarQueue);
			printDedent(grenv.env.env, "}");
		}
		nextTyvar : Maybe<PopSetResult<GQueueItem>> = popMinSet(grenv.env.grelations.tyvarQueue);
		switch (nextTyvar) {
			Some(pop): {
				item = pop.value;
				if (containsKeyTree(grenv.env.tyvars, item.tyvar)) {
					// Already solved. We can ignore
					acc = GResolutionEnv(grenv 
						with env = GEnv(
							grenv.env
							with grelations = GRelations(
								grenv.env.grelations with tyvarQueue = pop.rest
							)
						)
					);
					doResolveGGraph(acc);
				} else {
					itemNow = makeGQueueItem(grenv.env, item.tyvar, item.stage);
					if (itemNow == item) {
						stage = int2gresolutionStage(item.stage);

						reqs = buildGTyvarRequirement(grenv.env, item.tyvar);
						if (grenv.env.verbose >= 2) {
							printIndent(grenv.env.env, "Clarify " + gtyvarReqs2string(grenv.env, reqs) + " at stage " + toString(stage) 
								+ " " + gpriority2string(item.priority) + " {");
						}

						acc = GResolutionEnv(grenv 
							with env = GEnv(
								grenv.env
								with grelations = GRelations(
									grenv.env.grelations with
									tyvarQueue = pop.rest
								)
							)
						);

						res = clarifyGTyvar(acc, reqs, stage);
						if (res.env.verbose >= 2) {
							printDedent(res.env.env, "}");
						}
						doResolveGGraph(res);
					} else {
						// The priority has changed, so we should requeue it, and retry
						if (grenv.env.verbose >= 2) {
							printStay(grenv.env.env, "Requeuing α" + i2s(itemNow.tyvar));
						}
						acc = GResolutionEnv(grenv 
							with env = GEnv(
								grenv.env
								with grelations = GRelations(
									grenv.env.grelations with
									tyvarQueue = insertSet(pop.rest, itemNow)
								)
							)
						);
						doResolveGGraph(acc);
					}
				}
			}
			None(): {
				// OK, we are done.
				grenv;
			}
		}
	}
}

dumpGTyvarQueue(grenv : GResolutionEnv, queue : Set<GQueueItem>) -> void {
	nextTyvar : Maybe<PopSetResult<GQueueItem>> = popMinSet(queue);
	switch (nextTyvar) {
		None(): {}
		Some(pop): {
			item = pop.value;
			printStay(grenv.env.env, i2s(item.tyvar) + " at stage " + toString(item.stage) 
				+ " " + gpriority2string(item.priority));
			dumpGTyvarQueue(grenv, pop.rest);
		}
	}
}

// We know this tyvar is unbound, and we know about all the bounds.
// See if we can solve it
clarifyGTyvar(grenv : GResolutionEnv, req : GTyvarRequirements, stage : GResolutionStage) -> GResolutionEnv {
	// In case we could not resolve, we requeue at the next stage
	requeue = \ -> {
		nextStageId = gresolutionStage2int(nextGResolutionStage(stage));
		newQueue = if (stage == GResolveTypars()) grenv.env.grelations.tyvarQueue else
			foldSet(req.tyvars, grenv.env.grelations.tyvarQueue, \acc, tyvar -> {
				enqueueGTyvarAtStage(grenv.env, acc, tyvar, nextStageId)
			});

		GResolutionEnv(grenv 
			with env = GEnv(
				grenv.env
				with grelations = GRelations(
					grenv.env.grelations with tyvarQueue = newQueue
				)
			)
		);
	}

	lower = req.lower;
	upper = req.upper;

	// OK, check if it is fixed
	fixed = mergeSets(lower.fixedTypes, upper.fixedTypes);

	if (lower.hasFlow) {
		GResolutionEnv(grenv with env = setGTyvar(grenv.env, grenv.unify, req, GFlow(), grenv.onError));
	} else if (!isEmptySet(fixed) || upper.hasFlow) {
		// OK, we have something fixed. Let us go with that
		if (sizeSet(fixed) == 1 && !upper.hasFlow) {
			// OK, we have a unique, fixed type for our guy
			fixedType = set2array(fixed)[0];
			GResolutionEnv(grenv with env = setGTyvar(grenv.env, grenv.unify, req, fixedType, grenv.onError));
		} else if (upper.hasFlow && sizeSet(fixed) != 1) {
			// None or multiple, which do not agree, but we have flow, so I guess we go flow
			GResolutionEnv(grenv with env = setGTyvar(grenv.env, grenv.unify, req, GFlow(), grenv.onError));
		} else {
			if (grenv.env.verbose >= 3) {
				printIndent(grenv.env.env, "Fixed clarification: " + gtyvarReqs2string(grenv.env, req) + " {");
			}	

			// There are multiple solutions.
			pick = switch (stage) {
				GResolveSafeOnly(): false;
				GResolveSafeButAmbiguous(): false;
				GResolveSpeculative(): true;
				GResolveTypars(): true;
			}

			penv = if (stage == GResolveSafeOnly()) {
				// See if we can unpeel it
				//   Clarify { : [TextSize<>], [α40001] :  : } c= α40004 c= { :  :  : } {
				// is handled by setting α40004= [<tyvar>].
				rtype = restructureGType(grenv.env, fixed);
				switch (rtype) {
					None(): grenv.env;
					Some(rt): {
						setGTyvar(grenv.env, grenv.unify, req, rt, grenv.onError);
					}
				}
			} else grenv.env;

			renv = if (pick) {
				// There are multiple solutions. We just pick one
				fixedType = set2array(fixed)[0];
				// printStay(env.env, "Review: We picked " + gtype2string(env, fixedType) +
				//	" pick the smallest " + gtyvarReqs2string(env, req) + "");
				setGTyvar(penv, grenv.unify, req, fixedType, grenv.onError);
			} else {
				penv;
			}

			if (renv.verbose >= 3) {
				printDedent(renv.env, "} Fixed clarification: " + gtyvarReqs2string(renv, req) + " {");
			}

			grenv0 = GResolutionEnv(grenv with env = renv);
			if (grenv0 == grenv) {
				// TODO: This can probably be tweaked
				requeue();
			} else grenv0
		}
	} else {
		// OK, no fixed. There can be tyvars and subtypes
		lowerOnlyTyvars = isGBoundsOnlyTyvars(grenv.env, lower);
		upperOnlyTyvars = isGBoundsOnlyTyvars(grenv.env, upper);

		if (lowerOnlyTyvars && upperOnlyTyvars) {
			// Only tyvars.
			switch (stage) {
				GResolveSafeOnly(): requeue();
				GResolveSafeButAmbiguous(): requeue();
				GResolveSpeculative(): requeue();
				GResolveTypars(): {
					// No constraints. All of these tyvars are all identical and should be bound
					// to the next free typar.
					tyvars = mergeSets(mergeSets(lower.tyvars, upper.tyvars), req.tyvars);
					GResolutionEnv(grenv with env = resolveGTypeVarToTyPar(grenv.env, tyvars));
				}
			}
		} else {
			// We have subtypes, either named or fields
			lowerSet : Set<GSubType> = getGSubTypes(lower.named, switch (stage) {
				GResolveSafeOnly(): makeSet();
				GResolveSafeButAmbiguous(): lower.fields;
				GResolveSpeculative(): lower.fields;
				GResolveTypars(): lower.fields;
			});
			ltypenames : [string] = findPotentialGSupertypes(grenv.env, lowerSet);

			upperSet : Set<GSubType> = getGSubTypes(upper.named, switch (stage) {
				GResolveSafeOnly(): makeSet();
				GResolveSafeButAmbiguous(): upper.fields;
				GResolveSpeculative(): upper.fields;
				GResolveTypars(): upper.fields;
			});

			// Something seems to imply that we should do union here. Test 148 as an example
			utypenames : [string] = findPotentialGSubtypes(grenv.env, upperSet);

 			possible = if (isEmptySet(lowerSet)) utypenames
				else if (isEmptySet(upperSet)) ltypenames
				else intersection(ltypenames, utypenames);

			// printStay(env.env, "Review " + toString(possible) + " l: " + toString(ltypenames) +" u: " + toString(utypenames) + " from req " + gtyvarReqs2string(env, req));

			if (length(possible) == 1) {
				// OK, lower and upper can agree on a named type. Construct it
				winner = possible[0];
				// Make this type with the typars
				winType = makeGNamedType(grenv.env, winner);

				if (grenv.env.verbose >= 3) {
					printStay(grenv.env.env, "Agreement : " + gtyvarReqs2string(grenv.env, req) + " {");
				}

				// And set ourselves to this
				GResolutionEnv(grenv with env = setGTyvar(grenv.env, grenv.unify, req, winType, grenv.onError));
			} else {
				if (stage == GResolveSpeculative() && possible == []) {
					error = grenv.makeFcError("Add type annotation. Can not find type that " + gtyvarReqs2stringNice(grenv.env, req), req.starts);
					grenv.onError(grenv.env, error);
					requeue();
				} else if (stage == GResolveSpeculative()) {
					// Here we do prolog!
					cheapest = sortGCandidates(grenv, possible, req);

					if (grenv.env.verbose >= 2) {
						printIndent(grenv.env.env, "Speculation " + i2s(grenv.speculation) + " with " + toString(cheapest) + " { " + gtyvarReqs2string(grenv.env, req));
					}

					senv = findErrorFreeCandidate(grenv, cheapest, 0, req);

					if (senv.env.verbose >= 2) {
						printDedent(senv.env.env, "} speculation " + if (senv.abort) " failed" else " succeeded");
					}

					senv;
				} else {
					if (stage == GResolveTypars()) {
						error = grenv.makeFcError("Add type annotation. Can not find type that " + gtyvarReqs2stringNice(grenv.env, req), req.starts);
						grenv.onError(grenv.env, error);
					}
					requeue();
				}
			}
		}
	}
}

sortGCandidates(env : GResolutionEnv, candidates : [string], req : GTyvarRequirements) -> [string] {
	lowers = mapSet(req.lower.named, \n -> n.name);
	uppers = mapSet(req.upper.named, \n -> n.name);

	sortCustom(candidates, \name -> {
		rank = if (containsSet(uppers, name)) 0
			else if (containsSet(lowers, name)) 1
			else if (containsSet(env.env.namesSeen, name)) 2
			else 3;
		Pair(rank, getGNamedSize(env.env, name));
	}, true);
}

findErrorFreeCandidate(grenv : GResolutionEnv, candidates : [string], index : int, req : GTyvarRequirements) -> GResolutionEnv {
	if (index >= length(candidates)) {
		error = grenv.makeFcError("Add type annotation. Tried " + strGlue(candidates, ", ") + ", but none worked. We sought type that " + gtyvarReqs2stringNice(grenv.env, req), req.starts);
		grenv.onError(grenv.env, error);
		GResolutionEnv(grenv with abort = true);
	} else {
		type = makeGNamedType(grenv.env, candidates[index]);
		errors = ref false;
		if (grenv.env.verbose >= 4) {
			printIndent(grenv.env.env, "Trying " + candidates[index]);
		}
		nenv = setGTyvar(grenv.env, grenv.unify, req, type, \__, __ -> {
			errors := true;
		});
		if (grenv.env.verbose >= 4) {
			printDedent(grenv.env.env, "Tried " + candidates[index] + " with error: " + b2s(^errors));
		}

		if (!^errors) {
			// We limit the speculation to 3 levels
			speclimit = getUrlParameter("speculation");
			limit = if (speclimit == "") 3 else s2i(speclimit);
			if (grenv.speculation < limit) {
				// OK, run the rest of the algorithm against this one
				// to check if it works out
				if (grenv.env.verbose >= 4) {
					printIndent(grenv.env.env, "Recursively speculating with " + candidates[index] + " {");
				}
				renv = doResolveGGraph(
					GResolutionEnv(
						grenv with env = nenv,
						onError = \__, __ -> {
							errors := true;
						},
						speculation = grenv.speculation + 1
					)
				);
				if (grenv.env.verbose >= 4) {
					printDedent(grenv.env.env, "} recursively speculated with " + candidates[index] + " with error: " + b2s(^errors));
				}
				
				if (!^errors) {
					if (renv.env.verbose >= 4) {
						printStay(renv.env.env, "Success with " + candidates[index]);
					}
					GResolutionEnv(
						renv with
						speculation = renv.speculation - 1
					);
				} else {
					// OK, did not work recursively. Let us try the next.
					findErrorFreeCandidate(grenv, candidates, index + 1, req);
				}
			} else {
				// OK, we accept it
				if (false) {
					// We set it with the real onError function
					GResolutionEnv(
						grenv with env =
							setGTyvar(grenv.env, grenv.unify, req, type, grenv.onError)
					);
				} else {
					// OK, we just accept this one
					GResolutionEnv(
						grenv with env = nenv
					)
				}
			}
		} else {
			//  println("Failure with " + candidates[0]);
			// OK, did not work. Let us try the next.
			findErrorFreeCandidate(grenv, candidates, index + 1, req);
		}
	}
}

// Set all these tyvars to the next free typar
resolveGTypeVarToTyPar(env : GEnv, tyvars : Set<int>) -> GEnv {
	// Find the next free type par
	typars = foldTree(env.tyvars, makeSet(), \tv, type, acc -> {
		extractGTypePars(env, type, acc)
	});
	mtypar = popMaxSet(typars);
	lasttypar = eitherMap(mtypar, \r -> r.value, "");
	typar = GTypePar(lasttypar + "?");

	// Now, set all tyvars to this typar		
	foldSet(tyvars, env, \acc, tv -> {
		if (env.verbose >= 2) {
			printStay(env.env, "α" + i2s(tv) + " = " + gtype2string(env, typar));
		}
		GEnv(
			acc with
			tyvars = setTree(acc.tyvars, tv, typar)
		);
	});
}

// Does this only contain unresolved tyvars?
isGBoundsOnlyTyvars(env : GEnv, bounds : GBounds) -> bool {
	!bounds.hasFlow && isEmptySet(bounds.fixedTypes) && isEmptySet(bounds.named) && isEmptySet(bounds.fields)
}

// Set this group of tyvars to this resolved type
setGTyvar(env : GEnv, unify : (GEnv, GType, GType, Set<int>, (GEnv, FcError) -> void) -> GEnv, req : GTyvarRequirements, 
		type : GType, onError : (GEnv, FcError) -> void) -> GEnv {
	tyvars = req.tyvars;

	if (env.verbose >= 2) {
		printStay(env.env, superglue(set2array(tyvars), \tv -> "α" + i2s(tv), ", ") + " = " + gtype2string(env, type));
	}

	// Set our friends
	nenv0 = foldSet(tyvars, env, \env0, tyvar -> {
		GEnv(
			env0 with
			tyvars = setTree(env0.tyvars, tyvar, type),
			tyvarOrder = arrayPush(env0.tyvarOrder, tyvar)
		);
	});

	// Add the new unresolved
	tyvarsInType = extractGTypeVars(nenv0, type, makeSet());
	// The neko compiler can not figure this out, so we have to help it
	grels : GRelations = nenv0.grelations;
	tyvarQueue = foldSet(tyvarsInType, grels.tyvarQueue, \acc, tv -> enqueueGTyvar(nenv0, acc, tv));
	nenv1 = 
		GEnv(
			nenv0 with 
			grelations = GRelations(
				grels with tyvarQueue = tyvarQueue
			)
		);

	// Then unify with relations
	foldSet(tyvars, nenv1, \nenv2, tyvar -> {
		gtype = GTypeVar(tyvar);

		uppers = getGUpperRelations(nenv2.grelations, gtype);
		nenv3 = foldSet(uppers, nenv2, \nenv4, to -> {
			if (!isGTypeVars(tyvars, to)) {
				unify(nenv4, type, to, req.starts, onError)
			} else nenv4;		
		});

		lowers = getGLowerRelations(nenv3.grelations, gtype);
		foldSet(lowers, nenv3, \nenv5, to -> {
			if (!isGTypeVars(tyvars, to)) {
				unify(nenv5, to, type, req.starts, onError)
			} else nenv5;
		});
	});
}

isGTypeVars(tyvars : Set<int>, type : GType) -> bool {
	switch (type) {
		GTypeVar(id): containsSet(tyvars, id);
		default: false;
	}
}

// Given these constraints, what supertypes could meet all of these?
findPotentialGSupertypes(env : GEnv, types : Set<GSubType>) -> [string] {
	foldi(set2array(types), [], \i, acc, st -> {
		supers = findGSupertypes(env, st);
		if (i == 0) supers
		else intersection(supers, acc)
	});
}

// Find all types which type can be dominated by, including itself
findGSupertypes(env : GEnv, expr : GSubType) -> [string] {
	switch (expr) {
		GNamed(name, __): {
			superset = findGSupertypeFromName(env, name);
			arrayPush(superset, name);
		}
		GField(field, __): {
			findGSupertypeFromName(env, "." + field);
		}
	}
}

// Given these constraints, what subtypes could meet all of these?
findPotentialGSubtypes(env : GEnv, types : Set<GSubType>) -> [string] {
	foldi(set2array(types), [], \i, acc, st -> {
		subs = findGSubtypes(env, st);
		// println(gtype2string(env, st) + ": " + toString(subs));
		if (i == 0) subs
		else intersection(subs, acc)
	});
}


// Find all types which are subtypes of this constraint, including ourselves
findGSubtypes(env : GEnv, expr : GSubType) -> [string] {
	switch (expr) {
		GNamed(name, __): {
			mun = lookupTree(env.env.program.acc.names.unions, name);
			switch (mun) {
				None(): {
					// A struct: It can only be ourselves
					[name];
				}
				Some(un): {
					// A union: It can be ourselves, any subunion or the structs
					uniq(fold(un.typenames, [name], \acc, tn -> {
						concat(acc, findGSubtypes(env, GNamed(tn.name, [])))
					}));
				}
			}
		}
		GField(field, __): {
			// OK, here we filter the set to those names that appear in the environment
			possible = getTreeArrayValue(env.env.program.acc.names.field2structs, field);
			if (false) {
				filtered = filter(possible, \p -> containsSet(env.namesSeen, p));
				// If the filter looses all, we do not filter after all
				if (filtered == []) possible else filtered;
			} else {
				possible;
			}
		}
	}
}

// Build a type with this name, and empty typars
makeGNamedType(env : GEnv, name : string) -> GType {
	mstruct = lookupTree(env.env.program.acc.names.structs, name);
	switch (mstruct) {
		None(): {
			munion = lookupTree(env.env.program.acc.names.unions, name);
			switch (munion) {
				None(): {
					// Not found.
					GNamed(name, []);
				}
				Some(union): {
					GNamed(name, map(union.typeparameters, \__ -> {
						mkGTypeVar(env)
					}))
				}
			}
		}
		Some(structdef): {
			GNamed(name, map(structdef.typars, \__ -> {
				mkGTypeVar(env)
			}))
		}
	}
}

// Extract a type of the correct shape to fit this monster
restructureGType(env : GEnv, types : Set<GType>) -> Maybe<GType> {
	foldSet(types, None(), \acc : Maybe<GType>, tt : GType -> {
		switch (acc) {
			None(): {
				switch (tt) {
					GFunction(args, rt): {
						gtype : GType = GFunction(map(args, \a -> decidedOrTyvar(env, a)), decidedOrTyvar(env, rt));
						Some(gtype)
					}
					GArray(atype): Some(GArray(decidedOrTyvar(env, atype)));
					GRef(rtype): Some(GRef(decidedOrTyvar(env, rtype)));
					GBasicType(__): Some(tt);
					GFlow(): acc;
					GTypePar(id): Some(tt);
					GTypeVar(id): acc;
					GNamed(name, typars): acc;
					GField(name, type): acc;
				}
			}
			Some(t): acc;
		}
	})
}

decidedOrTyvar(env : GEnv, type : GType) -> GType {
	if (isGTypeDecided(env, type)) {
		type;
	} else {
		mkGTypeVar(env)
	}
}

// Get some kind of score for a name. Structs is the number of typars + fields. Unions is 10 * number of structs + number of fields in total
getGNamedSize(env : GEnv, name : string) -> int {
	mstruct = lookupTree(env.env.program.acc.names.structs, name);
	switch (mstruct) {
		None(): {
			munion = lookupTree(env.env.program.acc.names.unions, name);
			switch (munion) {
				None(): intMax;
				Some(union): {
					fold(union.typenames, 1 + length(union.typeparameters), \acc, tn -> {
						acc + 10 * getGNamedSize(env, tn.name)
					});
				}
			}
		}
		Some(structdef): 1 + length(structdef.typars) + length(structdef.args);
	}
}

getGSubTypes(names : Set<GNamed>, fields : Set<GField>) -> Set<GSubType> {
	// Only to get flow to compile. This is basically just mergeSets
	mergeSets(mapSet(names, \n : GSubType -> n), mapSet(fields, \f : GSubType -> f))
}
