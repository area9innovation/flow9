import tools/flowc/fctypeenv;
import tools/flowc/typechecker2/gsubtype_graph_type;

export {
	GType ::=
		GBasicType, GFlow, GTypePar, GFunction, GArray, GRef,
		GTypeVar, GSubType;

		GBasicType(t : FcBaseType);
		GFlow();
		GTypePar(id : string);
		GFunction(args : [GType], rt : GType);
		GArray(type : GType);
		GRef(type : GType);
		GTypeVar(id : int);

	GSubType ::= GNamed, GField;

		// A struct type S<T> is represented as "S" with T
		// A union type U<T> is represented as "U" with T
		GNamed(name : string, typars : [GType]);

		// We know there is a field with a given type
		GField(name : string, type : GType);

	GEnv(
		// The normal environment
		env : FcTypeEnv,

		// The tyvar id group
		tyvarIdGroup : IdGroup,

		// The verbosity level for debugging
		verbose : int,

		// The binding of tyvars
		tyvars : Tree<int, GType>,

		// The subtyping relations we have seen to avoid infinite loops
		seen : Set<Pair<GType, GType>>,

		// Our unification relations graph
		grelations : GRelations,

		// A "static" graph of named subtypes, disregarding polymorphism.
		// We have a node between subtype and supertypes. The edge is true
		// if it is equivalence, like in U ::= S;
		subtypes : GSubtypeGraph,

		// The names we have seen in types, to help figure out what .field can resolve to
		namesSeen : Set<string>
	);

	GRelations(
		uppers : Tree<GType, Set<GType>>,
		lowers : Tree<GType, Set<GType>>,
		// What positions are we related to? (Both directions)
		positions : Tree<GType, Set<int>>,
		// The queue of tyvars to be resolved.
		tyvarQueue : Set<GQueueItem>
	);

	// To make these guys unique, we have to include the tyvar id in the key
	GQueueItem(stage : int, priority : int, tyvar : int);
}
