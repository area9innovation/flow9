import tools/flowc/fctypeenv;
import tools/flowc/manipulation/simplegraph;

export {
	GType ::=
		GBasicType, GFlow, GTypePar, GFunction, GArray, GRef,
		GTypeVar, GSubType;

		GBasicType(t : FcBaseType);
		GFlow();
		GTypePar(id : string);
		GFunction(args : [GType], rt : GType);
		GArray(type : GType);
		GRef(type : GType);
		GTypeVar(id : int);

	GSubType ::= GNamed, GField;

		// A struct type S<T> is represented as "S" with T
		// A union type U<T> is represented as "U" with T
		GNamed(name : string, typars : [GType]);

		// We know there is a field with a given type
		GField(name : string, type : GType);

	GEnv(
		// The normal environment
		env : FcTypeEnv,

		// The tyvar id group
		tyvarIdGroup : IdGroup,

		// The verbosity level for debugging
		verbose : int,

		// The binding of tyvars
		tyvars : Tree<int, GType>,

		// The subtyping relations we have seen to avoid infinite loops
		seen : Set<Pair<GType, GType>>,

		// The tyvars we have not resolved yet
		unresolvedTyvars : Set<int>,

		// Relations between tyvars we have seen
		relations : SimpleGraph<GType, bool>,

		// A "static" graph of named subtypes, disregarding polymorphism.
		// We have a node between subtype and supertypes. The edge is true
		// if it is equivalence, like in U ::= S;
		subtypes : GSubtypeGraph
	);

	GSubtypeGraph(
		// From name to supertypes
		supertypes : SimpleGraph<string, bool>,
		// From field name to supertypes
		fieldSupertypes : SimpleGraph<string, bool>,
		subtypes : EasyGraph<string, bool>
	);
}
