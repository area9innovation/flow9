import tools/flowc/typechecker2/gtype_util;
import tools/flowc/typechecker2/gtype_resolve;
import tools/flowc/typechecker2/fctype2gtype;
import tools/flowc/typechecker2/gtype2fctype;
import tools/flowc/typechecker/combine_types;
import tools/flowc/fcexp_description;
import tools/flowc/debug;
import tools/flowc/type_helpers;
import tools/flowc/typechecker/type_expect_helpers;
import ds/easygraph_utils;

import tools/flowc/typechecker/solve_expectations;

export {
	// This resolves the constraints
	gtypeSolve(name : string, tyvarIdGroup : IdGroup, pos : FcPosition, env : FcTypeEnv) -> GEnv;
}

/*
This works using a few passes algorithm:
First, recursively deconstruct all relations based on the expectations and build a graph
of requirements for each tyvar.
Then, for each tyvar, figure out how to resolve it.


Run with something like

	flowcpp tools/flowc/flowc.flow -- test=1 incremental=0 gtype=1 >out.flow

and then

	mkdot

to produce the graphviz relations.

TODO:
- Solve the tyvar graph
- Union vs union case
- Get rid of GAnd, GOr, GBounded
- Reconstruct struct defs with correct number of typars, and be smarter about
  implicit typars. (31, 37, 54, ..., 103, 114, 127)
*/

gtypeSolve(name : string, tyvarIdGroup : IdGroup, pos : FcPosition, env : FcTypeEnv) -> GEnv {
	expects = reverseList(^(env.local.expects));

	// Build a map from tyvar to typar
	typars : Tree<int, GType> = foldTree(^(env.local.typars), makeTree(), \typar, tyvar, acc : Tree<int, GType> -> {
		setTree(acc, tyvar.id, GTypePar(typar));
	});

	ge = GEnv(
		env, 
		tyvarIdGroup, 
		// While debugging, let us do this
		if (^(env.local.debugTyping) > 0 || getConfigParameter(env.program.acc.config.config, "verbose") == name) 3 else env.program.acc.config.verbose, 
		typars, 
		makeSet(), 
		makeSet(),
		makeSimpleGraph(),
		makeSimpleGraph(),
	);

	if (ge.verbose >= 2)  {
		fcPrintln("\nType " + name);
	}

	onError = \m, info, description -> {
		poss = FcPosition(pos.file, info.start, info.end);
		addFcTypeError(env.program, FcError(name + ": " + (if (description != "") description + ": " else "") + m, [poss]));
	};

	gunify = \genv : GEnv, output : FcType, input : FcType, info : FcInfo2, description : () -> string -> {
		ot = fctype2gtype(genv.env, tyvarIdGroup, output);
		it = fctype2gtype(genv.env, tyvarIdGroup, input);
		unifyGType(genv, ot, it, \m -> onError(m, info, description()));
	}

	ge1 = foldList(expects, ge, \acc, e -> {
		// If verbose is on, we keep track of what expects to debug
		solveDebug = (ge.verbose >= 1 && containsSet(^(env.local.debugExpects), e)) || ge.verbose >= 3;
		if (solveDebug) {
			env.local.debugTyping := 1;
		};
		if (solveDebug || ge.verbose >= 2) {
			fcPrintln("\n// " + strReplace(fcExpect2string(acc.env, e), "\n", " "));
		}

		re = switch (e : FcTypeExpect) {
			FcLessOrEqual(e1, e2, d, info, ex): {
				gunify(acc, e1, e2, info, \ -> d + ": " + fcexpDescription(ex));
			}
			FcVerifyType(e1, e2, info): {
				et1 = gunify(acc, e1, e2, info, \ -> "");
				gunify(et1, e2, e1, info, \ -> "");
			}
			FcExpectField(field, ftype, struct, info, ex): {
				st = fctype2gtype(env, tyvarIdGroup, struct);
				gfield = GSubType(GField(field, fctype2gtype(env, tyvarIdGroup, ftype)));
				unifyGType(acc, gfield, st, \m -> onError(m, info, ""));
			}
			FcSetMutableField(stype, field, ftype, info): {
				st = fctype2gtype(acc.env, tyvarIdGroup, stype);
				ft = fctype2gtype(acc.env, tyvarIdGroup, ftype);
				gfield = GSubType(GField(field, ft));
				unifyGType(acc, st, gfield, \m -> onError(m, info, "set mutable"));
			}
		}
		if (solveDebug) {
			env.local.debugTyping := 0;
		}
		re;
	});

	// OK, first remove cycles in the graph. We need the sources first
	sources = findEGRoots(ge1.relations.graph);
	loopFree = removeBackEGEdges(ge1.relations.graph, set2array(sources));
	// Then reduce to smallest graph
	reducedGraph = transitiveReduction(loopFree);
	ge1b = GEnv(
		ge1 with relations = SimpleGraph(ge1.relations with graph = reducedGraph)
	);

	// Now, we have loop-free graph with the same semantics as before, but fewer edges

	// Make sure all unresolve tyvars are in the graph 
	ge1c = GEnv(
		ge1b with relations = foldSet(ge1b.unresolvedTyvars, ge1b.relations, \acc, tv -> {
			if (containsKeyTree(ge1b.tyvars, tv)) {
				acc;
			} else {
				addSimpleNode(acc, GTypeVar(tv))
			}
		})
	);

	// Go ahead and resolve it
	ge2 = resolveGGraph(ge1c, name, \e, l, u -> {
		unifyGType(e, l, u, \err -> {
			// TODO: We could keep a map from tyvar to position and use that for
			// smarter error reporting based on tyvars
			addFcTypeError(env.program, FcError(name + ": " + err, [pos]));
		})
	});

	// Now, set the tyvars in the environment
	foldTree(ge2.tyvars, env, \tv, type, acc -> {
		setTyvar(acc, tv, gtype2fctype(ge2, type));
		acc;
	});

	if (ge2.verbose >= 2) {
		println("Tyvars: " + toString(set2array(ge2.unresolvedTyvars)));

		// Build the relation graph if there is one
		mroot = popMinSet(ge2.unresolvedTyvars);
		switch (mroot) {
			None(): {}
			Some(root): {
				dot = simpleGraph2dot(ge2.relations, GTypeVar(root.value), [], 
					\n -> [DotLabel(gtype2string(ge2, n))], 
					\e -> []
				);
				setFileContent(name + ".dot", dot);

				batch = getFileContent("mkdot.bat");
				batch0 = batch + "dot "+ name + ".dot -Tsvg -o" + name + ".svg\n";
				setFileContent("mkdot.bat", batch0);
				{}
			}
		}

	}

	// Run the final checks
	onError2 = \m, is -> {
		addFcTypeError(ge2.env.program, FcError(name + ": " + m, map(is, \i -> {
				FcPosition(pos.file, i.start, i.end)
			})
		));
	};
	applyList(^(ge2.env.local.checks), \e -> {
		checkFinalTypeExpect(ge2.env, e, onError2);
	});

	// And we have resolved all expectations
	ge2.env.local.expects := makeList();
	ge2.env.local.checks := makeList();

	ge2;
}

unifyGType(env : GEnv, output : GType, input : GType, onError : (string) -> void) -> GEnv {
	if (output == input) {
		env;
	} else {
		tr = Pair(output, input);
		if (containsSet(env.seen, tr)) {
			env;
		} else {
			// We set an entry in the cache to avoid infinite recursion
			seen = insertSet(env.seen, tr);
			if (env.verbose >= 3)  {
				pt = \t -> gtype2string(env, t);
				printIndent(env.env, "Unify " + gtype2string(env, output) + " c= " + gtype2string(env, input));
			}
			env2 = GEnv(env with seen = seen);
			env3 = unifyAndRecurseGType(env2, output, input, onError);

			if (env.verbose >= 3)  {
				printDedent(env.env, "Done " + gtype2string(env3, output) + " c= " + gtype2string(env3, input));
			}
			env3;
		}
	}
}

// Alright, these GTypes meet. We have to recursively spiral down on these guys
unifyAndRecurseGType(env : GEnv, left : GType, right : GType, onError : (string) -> void) -> GEnv {
	if (env.verbose >= 4)  {
		printIndent(env.env, "Unify  " + gtype2string(env, left) + " c= " + gtype2string(env, right));
	}

	todo = \ -> {
		printStay(env.env, "TODO: " + gtype2string(env, left) + " c= " + gtype2string(env, right));
		env;
	}

	error = \ -> {
		onError(gtype2string(env, left) + " != " + gtype2string(env, right));
		env;
	}

	rest = \ -> {
		switch (right) {
			GTypeVar(rid): gunifyTyvar(env, left, right, onError);
			GFlow(): {
				explicit_flow = isConfigParameterTrue(env.env.program.acc.config.config, "explicit-flow");
				switch (left) {
					GFlow(): env;
					GBasicType(bt): {
						if (explicit_flow) {
							switch (bt) {
								FcTypeNative(__): env;
								default: {
									// We require explicit casts to/from flow
									error();
								}
							}
						} else env;
					}
					GSubType(__): env;
					default: {
						todo();
					}
				}
			}
			default: {
/*
				if (left == GFlow()) {
					// OK, we find all unbound tyvars and bind them to flow!
					tyvars = extractFTypeVars(env, right, makeSet());
					acc2 = foldSet(tyvars, env, \acc, tv -> {
						if (containsKeyTree(acc.tyvars, tv)) acc
						else setFTypeVar(acc, tv, left);
					});
					FEnvType(acc2, 
						if (kind == FUnifyLeft() || kind == FReduceLeft()) left else right
					);
				} else {
					onError(ftype2string(env, left) + "   and   " + ftype2string(env, right) + " are incompatible");
						// we do not support toString(FType) at the moment
						// + (if (env.verbose > 1) "\n   " + toString(left) + "\nvs " + toString(right) else ""));
					simplest = switch (left) {
						FBasicType(__): left;
						default: right;
					}
					FEnvType(env, simplest);
				}*/
				todo();
			}
		}
	}

	nenv = switch (left) {
		GBasicType(ltype): {
			switch (right) {
				GBasicType(rtype): {
					if (isSameFcType(env.env, ltype, rtype, false)) {
						env;
					} else {
						error();
					}
				}
				default: rest();
			}
		}
		GFlow(): rest();
		GTypePar(lid): {
			switch (right) {
				GTypePar(rid): {
					if (lid == rid) {
						env;
					} else {
						strict = getConfigParameter(env.env.program.acc.config.config, "strict");
						if (strict == "1") {
							onError(lid + " and " + rid + " are distinct");
						}
						env;
					}
				}
				default: {
					rest();
				}
			}
		}
		GFunction(largs, lrt): {
			switch (right) {
				GFunction(rargs, rrt): {
					nenv = unifyGTypes(env, rargs, largs, \i, e -> {
						if (i == -1) {
							onError(e + " function args")
						} else {
							onError("Arg #" + i2s(i) + ": " + e)
						}
					});
					unifyGType(nenv, lrt, rrt, onError);
				}
				default: rest();
			}
		}
		GArray(ltype): {
			switch (right) {
				GArray(rtype): {
					unifyGType(env, ltype, rtype, onError);
				}
				default: rest();
			}
		}
		GRef(ltype): {
			switch (right) {
				GRef(rtype): {
					unifyGType(env, ltype, rtype, onError);
				}
				default: rest();
			}
		}
		GTypeVar(lid): {
			gunifyTyvar(env, left, right, onError);
		}
		GSubType(lexp): {
			switch (right) {
				GBasicType(t): error();
				GFlow(): rest();
				GTypePar(id): rest();
				GFunction(args, rt): error();
				GArray(type): error();
				GRef(type): error();
				GTypeVar(rid): {
					gunifyTyvar(env, left, right, onError);
				}
				GSubType(rexp): {
					gunifySubType(env, lexp, rexp, onError);
				}
			}
		}
	}

	if (env.verbose >= 4)  {
		printDedent(env.env, "Unify  " + gtype2string(env, left) + " c= " + gtype2string(env, right));
	}

	nenv;
}

unifyGTypes(env : GEnv, lefts : [GType], rights : [GType], onError : (int, string) -> void) -> GEnv {
	if (length(lefts) != length(rights)) {
		onError(-1, "Got " + i2s(length(lefts)) + ", but expected " + i2s(length(rights)));
		env;
	} else {
		foldi(lefts, env, \i, acc, l -> {
			unifyGType(acc, l, rights[i], \e -> onError(i + 1, e))
		})
	}
}

gunifyTyvar(env : GEnv, left : GType, right : GType, onError : (string) -> void) -> GEnv {
	addTyvars = \ut, t -> extractGTypeVars(env, t, ut);
	GEnv(
		env with 
		unresolvedTyvars = addTyvars(addTyvars(env.unresolvedTyvars, left), right),
		relations = addSimpleEdge(env.relations, left, right, true, 0)
	)
}

gunifySubType(env : GEnv, left : GSubTypeExpr, right : GSubTypeExpr, onError : (string) -> void) -> GEnv {
	todo = \ -> {
		printStay(env.env, "TODO: Subtype " + gtype2string(env, GSubType(left)) + " c= " + gtype2string(env, GSubType(right)));
		env;
	}
	switch (left) {
		GNamed(lname, ltypars): {
			switch (right) {
				GNamed(rname, rtypars): {
					if (lname == rname) {
						// Do the typars
						// TODO: We could extend based on implicit polymorphism
						// See test1.
						unifyGTypes(env, ltypars, rtypars, \i, e -> {
							if (i == -1) {
								onError(e + " type parameters")
							} else {
								onError("Type par #" + i2s(i) + ": " + e)
							}
						});
					} else {
						gunifyNamedTypes(env, left, right, onError);
					}
				}
				GField(rname, rtype): {
					unifyGNamedAgainstField(env, left, right, onError);
				}
				default: todo();
			}
		}
		GField(lname, ltype): {
			switch (right) {
				GNamed(rname, rtypars): {
					unifyGFieldAgainstName(env, left, right, onError);
				}
				default: {
					todo();
				}
			}
		}
		GAnd(lexprs): todo();
		GOr(lexprs): todo();
	}
}

// We know the names are different, and that the right name is supposed to be a union.
gunifyNamedTypes(env : GEnv, left : GNamed, right : GNamed, onError : (string) -> void) -> GEnv {
	// From the name of a union to the structs, uninstantiated
	typenames : [FcTypeName] = union2typenames(env.env, right.name);

	mstruct = find(typenames, \tn -> tn.name == left.name);
	switch (mstruct) {
		None(): {
			// TODO: It could be that the left is a union.
			onError("Expected " + gtype2string(env, GSubType(left)) + " to be part of " + gtype2string(env, GSubType(right)));			
			env;
		}
		Some(ustruct): {
			// The struct as it appears in the union. Let us remap typars from the union to the struct
			istruct = ginstantiateStructFromUnion(env, right, ustruct, onError);
			// And then subtype with our struct
			unifyAndRecurseGType(env, GSubType(left), istruct, onError);
		}
	}
}

// We known that master is a union, and we want the instantiated struct which we know is part of it
ginstantiateStructFromUnion(env : GEnv, master : GNamed, ustruct : FcTypeName, onError : (string) -> void) -> GType {
	munion = lookupTree(env.env.program.acc.names.unions, master.name);
	switch (munion) {
		None(): {
			onError("Expected " + master.name + " to be a union");
			GSubType(GNamed(ustruct.name, []));
		}
		Some(union): {
			// Take the union def and map the typars
			typars = foldi(union.typeparameters, makeTree(), \i, acc, tp -> {
				setTree(acc, strLeft("????????????", i + 1), tp)
			});
			// Now we make a struct with typar names that correspond to the unions
			instantiated = instantiateTyParsToTypes(env.env, typars, ustruct, onError);
			gtype = fctype2gtype(env.env, env.tyvarIdGroup, instantiated);

			// Now, instantiate the typars in this gtype
			gtypars = foldi(master.typars, makeTree(), \i, acc, tp -> {
				setTree(acc, strLeft("????????????", i + 1), tp)
			});
			instantiateGTypePars(env, gtypars, gtype, onError);
		}
	}
}

unifyGFieldAgainstName(env : GEnv, left : GField, right : GNamed, onError : (string) -> void) -> GEnv {
	fieldType = getInstantiatedGNamedField(env, right, left.name, onError);
	unifyAndRecurseGType(env, left.type, fieldType, onError);
}

unifyGNamedAgainstField(env : GEnv, left : GNamed, right : GField, onError : (string) -> void) -> GEnv {
	fieldType = getInstantiatedGNamedField(env, left, right.name, onError);
	unifyAndRecurseGType(env, fieldType, right.type, onError);
}

// Given a named structure, extract the instantiated type of a given field
getInstantiatedGNamedField(env : GEnv, named : GNamed, field : string, onError : (string) -> void) -> GType {
	error = \ -> {
		onError("Expected " + gtype2string(env, GSubType(named)) + " to have ." + field);
		GFlow();
	}
	mstruct = lookupTree(env.env.program.acc.names.structs, named.name);
	switch (mstruct) {
		None(): {
			munion = lookupTree(env.env.program.acc.names.unions, named.name);
			switch (munion) {
				None(): error();
				Some(union): {
					typenames : [FcTypeName] = union2typenames(env.env, named.name);
					instantiated = map(typenames, \tn -> {
						ginstantiateStructFromUnion(env, named, tn, onError);
					});
					fields = map(instantiated, \i : GType -> {
						switch (i) {
							GSubType(st): {
								switch (st) {
									GNamed(__, __): getInstantiatedGNamedField(env, st, field, onError);
									default: error();
								}
							}
							default: error();
						}
					});
					shared = uniq(fields);
					if (length(shared) != 1) {
						error();
					} else {
						shared[0];
					}
				}
			}
		}
		Some(struct): {
			sfield = find(struct.args, \a : FcStructArg -> {
				a.name == field;
			});
			switch (sfield) {
				None(): error();
				Some(stfield): {
					// OK, instantiate the struct typars from our named struct
					gtypars = foldi(named.typars, makeTree(), \i, acc, tp -> {
						setTree(acc, strLeft("????????????", i + 1), tp)
					});
					gfield = fctype2gtype(env.env, env.tyvarIdGroup, stfield.type);
					instantiateGTypePars(env, gtypars, gfield, onError);
				}
			}
		}
	}
}
