import tools/flowc/flowcacc;
import tools/flowc/typechecker/type_expect;
import tools/flowc/dependencies;

import tools/flowc/typechecker2/gsubtype_graph_type;

export {
	// The typing environment for the entire compilation process
	FcTypeEnv(
		global : FcTypeEnvGlobal,
		program : FcTypeEnvProgram,
		local : FcTypeEnvLocal
	);

	// A global environment for a batch compilation of several programs 
	FcTypeEnvGlobal(
		moduleCache : native,
		nameCache : native,
		sourceCache : native // Sources of files as strings
	);

	// A single program typing environment
	FcTypeEnvProgram(
		acc : FlowcAcc, 

		// The resolved type of functions and variables
		types : Tree<string, FcType>,

		// Function that prings an error, and increases the error count
		printError : (FcError) -> void,

		// Count of type errors
		errors : ref int,

		// Cache for fast resolving which structs constitute a union
		union2typenamesCache : ref Tree<string, [FcTypeName]>,

		// A graph of subtypes
		subtypeGraph : GSubtypeGraph
	);

	// Typing environment for a single module
	FcTypeEnvLocal(
		// Requirements for types.
		expects : ref List<FcTypeExpect>,
		// Final checks after type checking
		checks : ref List<FcTypeCheck>,
		// The resolved type of tyvars
		tyvars : ref Tree<int, FcType>,
		// The current type of type parameters
		typars : ref Tree<string, FcTypeVar>,
		// The local stack variables info, used for duplication checking
		varinfo : Tree<string, FcInfo>,

		// Which expectations are collected during debug?
		debugExpects : ref Set<FcTypeExpect>,

		// Are we debug typing?
		debugTyping : ref int,

		// Indentation for debug
		debugIndentation : ref string,
	);

	initFcTypeEnvLocal() -> FcTypeEnvLocal;
	initFcTypeEnvGlobal() -> FcTypeEnvGlobal;

	fcLoadFromCache(env : FcTypeEnvGlobal, name : string) -> Maybe<FcLoaded>;
	fcRemoveFromCache(env : FcTypeEnvGlobal, name : string) -> void;
	fcAddToCache(env : FcTypeEnvGlobal, name : string, loaded : FcLoaded) -> void;
	fcClearCache(env : FcTypeEnvGlobal) -> void;
	fcIterCache(env : FcTypeEnvGlobal, fn : (FiModule) -> void) -> void;

	FiNamed ::= FiDeclaration, FiStructOrUnion;

	// Cached toplevel entities, including struct/union names
	FcCacheNamed(
		named : FiNamed,
		module : string, // name of a module of origin
		exported : bool,
	);

	// Lookup a cached entity: a struct, union, global var, function or native.
	fcLookupNameInCache(env : FcTypeEnvGlobal, name : string) -> Maybe<FcCacheNamed>;
	fcFilterNameCacheList(env : FcTypeEnvGlobal, fn : (FcCacheNamed) -> bool) -> List<FcCacheNamed>;
	fcFilterNameCacheArray(env : FcTypeEnvGlobal, fn : (FcCacheNamed) -> bool) -> [FcCacheNamed];

	// Lookups a cached file source, if not found - loads and stores.
	fcFileSource(env : FcTypeEnvGlobal, path : string) -> string;
}

initFcTypeEnvLocal() -> FcTypeEnvLocal {
	FcTypeEnvLocal(ref makeList(), ref makeList(), ref makeTree(), ref makeTree(), makeTree(), ref makeSet(), ref 0, ref "")
}

initFcTypeEnvGlobal() -> FcTypeEnvGlobal {
	FcTypeEnvGlobal(initConcurrentHashMap(), initConcurrentHashMap(), initConcurrentHashMap());
}

fcLoadFromCache(env : FcTypeEnvGlobal, name : string) -> Maybe<FcLoaded> {
	getConcurrentHashMap(env.moduleCache, name, None());
}

fcRemoveFromCache(env : FcTypeEnvGlobal, name : string) -> void {
	removeConcurrentHashMap(env.moduleCache, name);
}

fcAddToCache(env : FcTypeEnvGlobal, name : string, loaded : FcLoaded) -> void {
	setConcurrentHashMap(env.moduleCache, name, Some(loaded));
	module = loaded.module;
	exports = buildSet(module.exports);
	wrap = \n -> Some(FcCacheNamed(n, module.fileinfo.flowfile, containsSet(exports, n.name)));
	iter(module.structs, \s -> setConcurrentHashMap(env.nameCache, s.name, wrap(s)));
	iter(module.unions, \u -> setConcurrentHashMap(env.nameCache, u.name, wrap(u)));
	iter(module.functions, \f -> setConcurrentHashMap(env.nameCache, f.name, wrap(f)));
	iter(module.globalVars, \v -> setConcurrentHashMap(env.nameCache, v.name, wrap(v)));
	iter(module.natives, \n -> setConcurrentHashMap(env.nameCache, n.name, wrap(n)));
}

fcClearCache(env : FcTypeEnvGlobal) -> void {
	clearConcurrentHashMap(env.moduleCache);
	clearConcurrentHashMap(env.nameCache);
}

fcIterCache(env : FcTypeEnvGlobal, fn : (FiModule) -> void) -> void {
	iter(valuesConcurrentHashMap(env.moduleCache), \m -> maybeApply(m, \loaded -> fn(loaded.module)));
}

fcLookupNameInCache(env : FcTypeEnvGlobal, name : string) -> Maybe<FcCacheNamed> {
	getConcurrentHashMap(env.nameCache, name, None());
}

fcFilterNameCacheList(env : FcTypeEnvGlobal, fn : (FcCacheNamed) -> bool) -> List<FcCacheNamed> {
	filtermapList(array2list(valuesConcurrentHashMap(env.nameCache)), \n -> 
		maybeBind(n, \cached -> if (fn(cached)) Some(cached) else None())
	);
}

fcFilterNameCacheArray(env : FcTypeEnvGlobal, fn : (FcCacheNamed) -> bool) -> [FcCacheNamed] {
	filtermap(valuesConcurrentHashMap(env.nameCache), \n -> 
		maybeBind(n, \cached -> if (fn(cached)) Some(cached) else None())
	);
}

fcFileSource(env : FcTypeEnvGlobal, path : string) -> string {
	if (!containsConcurrentHashMap(env.sourceCache, path)) {
		setConcurrentHashMap(env.sourceCache, path, getFileContent(path))
	}
	getConcurrentHashMap(env.sourceCache, path, "");
}
