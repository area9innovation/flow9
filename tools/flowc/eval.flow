import sys/system;
import string_utils;
import tools/flowc/flowc_typecheck;
import tools/common/utils;
import tools/flowc/flow_parser;
import fonts_repo;

export {

	// Union which represents values in a running program 
	FiVal ::= FiConstVal, FiStructVal, FiArrayVal, FiRefVal, FiNativeVal, FiFuncVal; 

		FiConstVal ::= FiVoidVal, FiBoolVal, FiIntVal, FiDoubleVal, FiStringVal;
		FiStructVal(name : string, fields : [FiFieldVal]);
			FiFieldVal(name : string, val : ref FiVal);
		FiArrayVal(val : [FiVal]);
		FiRefVal(val : ref FiVal);
		FiNativeVal(val : native);
		FiFuncVal(
			fn : ([FiVal]) -> Maybe<FiVal>, 
			arity : int,
			lambda : Maybe<FiLambda>, 
			nativeName : string
		);

		FiVoidVal();
		FiBoolVal(val : bool);
		FiIntVal(val : int);
		FiDoubleVal(val : double);
		FiStringVal(val : string);
		FiErrorVal(msg : string);

	// Setup the global variables and toplevel functions
	fcInitEvalEnv(program: FiProgram, onError : (string) -> void) -> Tree<string, FiVal>;

	// Perform the evaluation of function 'name'. 
	// 'None()' as a return value means a runtime error. Normally 'Some(retval)' is returned.
	fcCallFunction(name : string, args : [FiVal], vals : Tree<string, FiVal>) -> Maybe<FiVal>;

	// Convert any value to FiVal
	fcWrapFiVal(v : flow) -> FiVal;

	// Convert FiVal back to any value
	fcUnwrapFiVal(ex : FiVal) -> flow;

	fiVal2s(v : FiVal) -> string;
}

fcFuncArity(fn : FiType) -> int {
	switch (fn) {
		FiTypeFunction(args,__): length(args);
		default: -1;
	}
}

fcInitEvalEnv(prog: FiProgram, onError : (string) -> void) -> Tree<string, FiVal> {
	vals = ref makeTree();
	add_native = \nat : FiNativeDec -> {
		fn = if (hostCallExists(nat.nativeName)) {
			//println("Added native : " + nat.nativeName);
			FiFuncVal(
				\as -> {
					args = map(as, \a -> fcUnwrapFiVal(a));
					/*println("Calling native : " + nat.nativeName + ", args:\n" + concatStrings(map(as, \a -> "\t" + fiVal2s(a) + "\n")));
					if (nat.nativeName == "Native.fold") {
						a3 : (flow, flow) -> flow = cast(args[2] : flow -> (flow, flow) -> flow);
						t1 :Tree<string, FontFace> = makeTree();
						x1 : FontFace = FontFace("Roboto", "Roboto", FONT_WEIGHT_BOOK, FONT_SLOPE_NORMAL, ["Roboto"]);
						r = a3(t1, x1);
						println("r: " + toString(r));
					}

					r = hostCall(nat.nativeName, args);
					println("REsult : " + toString(r));
					ret = fcWrapFiVal(r);
					println("REsult : " + toString(ret));
					Some(ret);*/

					Some(fcWrapFiVal(hostCall(nat.nativeName, args)));
				},
				fcFuncArity(nat.type),
				None(),
				nat.nativeName
			);
		} else {
			//println("Added fallback for : " + nat.nativeName);
			switch (nat.fallbackLambda) {
				FiLambda(args, body,__,__): {
					FiFuncVal(
						\as -> fcReplEval(body,
							foldi(args, ^vals, \i, a, arg -> 
								setTree(a, args[i].name, as[i])
							), onError
						),
						length(args),
						Some(nat.fallbackLambda),
						""
					);
				}
				default: {
					println("NO native : " + nat.nativeName);
					FiFuncVal(\ __-> None(), -1, None(), "");
				}
			}
		}
		vals := setTree(^vals, nat.name, fn);
	}
	iter(prog.traversal, \mod_name ->
		switch (lookupTree(prog.modules, mod_name)) {
			Some(module): {
				iter(module.initOrder, \name ->
					maybeApply(lookupTree(prog.names.toplevel, name), \decl ->
						switch (decl) {
							FiFunctionDec(__, lambda, __,__,__): {
								//println("Added function : " + name);
								vals := setTree(^vals, name, FiFuncVal(
									\as -> fcReplEval(lambda.body,
										foldi(lambda.args, ^vals, \i, a, arg -> 
											setTree(a, lambda.args[i].name, as[i])
										), onError
									),
									length(lambda.args), Some(lambda), ""
								));
							}
							FiGlobalVar(__, value, __,__,__): {
								//println("Added global var : " + name);
								maybeApply(fcReplEval(value, ^vals, onError),
									\v -> vals := setTree(^vals, name, v)
								);
							}
							FiNativeDec(__,__,__, nativeName, fallback, __,__): {
								add_native(decl);
							}
						}
					)
				);
				iter(module.natives, \nat ->
					if (!containsKeyTree(^vals, nat.name)) {
						//println("native : " + nat.nativeName + " is missing in initOrder");
						add_native(nat);
					}
				)
			}
			None(): {
				// Never should be
			}
		}
	);
	^vals;
}

fcCallFunction(name : string, args : [FiVal], vals : Tree<string, FiVal>) ->  Maybe<FiVal> {
	maybeBind(lookupTree(vals, name), \val -> 
		switch (val) {
			FiFuncVal(fn,__,__,__): fn(args);
			default: None();
		}
	);
}

trace = false;

fcReplEval(ex : FiExp, vals : Tree<string, FiVal>, onError : (string) -> void) -> Maybe<FiVal> {
	if (trace) {
		println2(^aaa + "fcReplEval: " + toString(ex)
			//+ "\nvals:\n-------\n" +
			//concatStrings(map(tree2pairs(vals), \p -> "\t" + p.first + " => " + fiVal2s(p.second) + "\n")) + "\n--------\n"
		);
	}
	a0 = ^aaa;
	aaa := ^aaa + "\t";
	/*args1 = map(call.es, \e -> {
		println2(^aaa + "call.es, e: " + toString(e));
		a0 = ^aaa;
		aaa := ^aaa + "\t";
		ret = fcReplEval(prog, e, vals);
		aaa := a0;
		//println2(^aaa + "ret (!!): " + toString(ret));
		ret;
	});*/
	ret = switch (ex) {
		FiLambda(args, body,__,__): {
			Some(FiFuncVal(
				\as -> fcReplEval(body,
					foldi(args, vals, \i, acc, arg -> 
						setTree(acc, args[i].name, as[i])
					), onError
				),
				length(args), Some(ex), ""
			));
		}
		FiCall(f, args,__,__): {
			maybeBind(fcReplEval(f, vals, onError),
				\f1 -> {
					switch (f1) {
						FiFuncVal(fn,ari,__,__): {
							args1 = filtermap(args, \a -> fcReplEval(a, vals, onError));
							if (length(args) != length(args1)) None() else fn(args1);
						}
						default: {
							onError("not a function is called: " + fiVal2s(f1));
							None();
						}
					}
				}
			);
		}
		FiVar(x,__,__): {
			lookupTree(vals, x);
		}
		FiLet(x, __, e1, e2,__,__): {
			maybeBind(fcReplEval(e1, vals, onError),
				\v -> fcReplEval(e2, setTree(vals, x, v), onError)
			);
		}
		FiIf(e1, e2, e3, __,__): {
			maybeBind(fcReplEval(e1, vals, onError),
				\c -> switch (c) {
					FiBoolVal(v): {
						if (v) fcReplEval(e2, vals, onError) else fcReplEval(e3, vals, onError);
					}
					default: {
						onError("not a boolean condition: " + fiVal2s(c));
						None();
					}
				}
			);
		}
		FiSwitch(v,__,cs,__,__): {
			maybeBind(fcReplEval(v, vals, onError),
				\w -> {
					switch (w) {
						FiStructVal(n, fields): {
							maybeBind(
								find(cs, \c -> c.struct == n),
								\c : FiCase -> {
									fcReplEval(c.body, 
										foldi(
											map(fields, \field -> ^(field.val)), 
											vals, 
											\i, acc, e -> setTree(acc, c.argNames[i], e)
										), onError
									)
								}
							);
						}
						default: {
							onError("not a struct in switch: " + fiVal2s(w));
							None();
						}
					}
				}
			);
		}
		FiCast(e, __,to,__,__): {
			maybeMap(fcReplEval(e, vals, onError), \ev -> 
				switch (ev) {
					FiIntVal(v): {
						switch (to) {
							FiTypeDouble(): FiDoubleVal(i2d(v));
							FiTypeString(): FiStringVal(i2s(v));
							default: ev; 
						}
					}
					FiDoubleVal(v): {
						switch (to) {
							FiTypeInt(): FiIntVal(round(v));
							FiTypeString(): FiStringVal(d2s(v));
							default: ev; 
						}
					}
					default: ev;
				}
			);
		}
		FiSeq(es,__,__): {
			ret : ref Maybe<FiVal> = ref Some(FiVoidVal());
			iter(es, \e -> ret := fcReplEval(e, vals, onError));
			^ret;
		}
		FiCallPrim(op, es, __,__): {
			fcReplEvalCallPrim(ex, vals, onError);
		}
		FiString(s,__): Some(FiStringVal(s));
		FiBool(b,__):   Some(FiBoolVal(b));
		FiDouble(d,__): Some(FiDoubleVal(d));
		FiVoid(__):     Some(FiVoidVal());
		FiInt(i,__):    Some(FiIntVal(i));
		FiRequire(flowfile, __,__,__): {
			onError("FiRequire is not implemented yet");
			None();
		}
		FiUnsafe(name, __,__,__): {
			onError("FiUnsafe is not implemented yet");
			None();
		}
	}
	aaa := a0;
	if (trace) {
		maybeApply(ret,
			\r -> println2(^aaa + "ret (**): " + fiVal2s(r))
		);
	}
	ret;
}

fiVal2s(v : FiVal) -> string {
	switch (v) {
		FiStructVal(name, fields): name + "(" + strGlue(map(fields, \field ->  fiVal2s(^(field.val))), ", ")	+ ")";
		FiArrayVal(arr): "[" + strGlue(map(arr, fiVal2s), ", ") + "]";
		FiRefVal(val): "ref " + fiVal2s(^val);
		FiFuncVal(fn, __, ml, nat): {
			switch (ml) {
				Some(lambda): prettyFiExp(dummyPretty, lambda);
				None(): nat;
			}
		}
		FiNativeVal(val): "<native>: " + toString(val);
		FiVoidVal(): "{void}";
		FiBoolVal(val): b2s(val);
		FiIntVal(val): i2s(val);
		FiDoubleVal(val): d2s(val);
		FiStringVal(val): "\"" + val + "\"";
	}
}

aaa = ref "";

fcReplEvalCallPrim(call : FiCallPrim, vals : Tree<string, FiVal>, onError : (string) -> void) -> Maybe<FiVal> {
	/*println2(^aaa + "fcReplEvalCallPrim: " + toString(call)
		//+ "\nvals:\n-------\n" +
		//concatStrings(map(tree2pairs(vals), \p -> "\t" + p.first + " => " + fiVal2s(p.second) + "\n")) + "\n--------\n"
	);*/
	args1 = map(call.es, \e -> {
		//println2(^aaa + "call.es, e: " + toString(e));
		//a0 = ^aaa;
		//aaa := ^aaa + "\t";
		ret = fcReplEval(e, vals, onError);
		//aaa := a0;
		//println2(^aaa + "ret (!!): " + toString(ret));
		ret;
	});
	//println2(^aaa + "args1 - done, len: " + i2s(length(call.es)) + " ?=" + i2s(length(args1)) + ": " + toString(args1));
	//println2(^aaa + "args1: ");
	//iter(args1, println);
	/*	"[" + 
			strGlue(map(args1, \arg ->
				switch (arg) {
					Some(v): fiVal2s(v);
					None(): "<NONE>";
				}
			), ", ") + 
		"]"
	);*/

	args = filtermap(args1, idfn);
	/*args = filtermap(call.es, \e -> {
		println2(^aaa + "call.es, e: " + toString(e));
		a0 = ^aaa;
		aaa := ^aaa + "\t";
		ret = fcReplEval(prog, e, vals);
		aaa := a0;
		//println2(^aaa + "ret (!!): " + toString(ret));
		ret;
	});*/
	//println2(^aaa + "args done");
	ret = if (length(args) != length(call.es)) None() else {
		switch (call.op) {
			FcOrPrim(): {
				switch (args[0]) {
					FiBoolVal(b1): {
						switch (args[1]) {
							FiBoolVal(b2): {
								Some(FiBoolVal(b1 || b2));
							}
							default: {
								onError("not a boolen argument of ||: " + fiVal2s(args[1]));
								None();
							}
						}
					}
					default: {
						onError("not a boolean argument of ||: " + fiVal2s(args[0]));
						None();
					}
				}
			}
			FcAndPrim(): {
				switch (args[0]) {
					FiBoolVal(b1): {
						switch (args[1]) {
							FiBoolVal(b2): {
								Some(FiBoolVal(b1 && b2));
							}
							default: {
								onError("not a boolen argument of &&: " + fiVal2s(args[1]));
								None();
							}
						}
					}
					default: {
						onError("not a boolen argument of &&: " + fiVal2s(args[0]));
						None();
					}
				}
			}
			FcNotPrim(): {
				switch (args[0]) {
					FiBoolVal(b): {
						Some(FiBoolVal(!b));
					}
					default: {
						onError("not a boolen argument of !: " + fiVal2s(args[0]));
						None()
					}
				}
			}
			FcEqPrim(): {
				Some(FiBoolVal(args[0] == args[1]));
			}
			FcNePrim(): {
				Some(FiBoolVal(args[0] != args[1]));
			}
			FcLePrim(): {
				Some(FiBoolVal(args[0] <= args[1]));
			}
			FcGePrim(): {
				Some(FiBoolVal(args[0] >= args[1]));
			}
			FcLtPrim(): {
				Some(FiBoolVal(args[0] < args[1]));
			}
			FcGtPrim(): {
				Some(FiBoolVal(args[0] > args[1]));
			}
			FcPlusPrim(): {
				switch (args[0]) {
					FiIntVal(i1): {
						switch (args[1]) {
							FiIntVal(i2): {
								Some(FiIntVal(i1 + i2));
							}
							default: {
								onError("not an integer argument of +: " + fiVal2s(args[1]));
								None();
							}
						}
					}
					FiDoubleVal(d1): {
						switch (args[1]) {
							FiDoubleVal(d2): {
								Some(FiDoubleVal(d1 + d2));
							}
							default: {
								onError("not a double argument of +: " + fiVal2s(args[1]));
								None();
							}
						}
					}
					FiStringVal(s1): {
						switch (args[1]) {
							FiStringVal(s2): {
								Some(FiStringVal(s1 + s2));
							}
							default: {
								onError("not a string argument of +: " + fiVal2s(args[1]));
								None();
							}
						}
					}
					default: {
						onError("not an integer, double or string argument of +: " + fiVal2s(args[0]));
						None();
					}
				}
			}
			FcMinusPrim(): {
				switch (args[0]) {
					FiIntVal(i1): {
						switch (args[1]) {
							FiIntVal(i2): {
								Some(FiIntVal(i1 - i2));
							}
							default: {
								onError("not an integer argument of -: " + fiVal2s(args[1]));
								None();
							}
						}
					}
					FiDoubleVal(d1): {
						switch (args[1]) {
							FiDoubleVal(d2): {
								Some(FiDoubleVal(d1 - d2));
							}
							default: {
								onError("not a double argument of -: " + fiVal2s(args[1]));
								None();
							}
						}
					}
					default: {
						onError("not an integer or double argument of -: " + fiVal2s(args[0]));
						None();
					}
				}
			}
			FcMulPrim(): {
				switch (args[0]) {
					FiIntVal(i1): {
						switch (args[1]) {
							FiIntVal(i2): {
								Some(FiIntVal(i1 * i2));
							}
							default: {
								onError("not an integer argument of *: " + fiVal2s(args[1]));
								None();
							}
						}
					}
					FiDoubleVal(d1): {
						switch (args[1]) {
							FiDoubleVal(d2): {
								Some(FiDoubleVal(d1 * d2));
							}
							default: {
								onError("not a double argument of *: " + fiVal2s(args[1]));
								None();
							}
						}
					}
					default: {
						onError("not an integer or double argument of *: " + fiVal2s(args[0]));
						None();
					}
				}
			}
			FcDivPrim(): {
				switch (args[0]) {
					FiIntVal(i1): {
						switch (args[1]) {
							FiIntVal(i2): {
								Some(FiIntVal(i1 / i2));
							}
							default: {
								onError("not an integer argument of /: " + fiVal2s(args[1]));
								None();
							}
						}
					}
					FiDoubleVal(d1): {
						switch (args[1]) {
							FiDoubleVal(d2): {
								Some(FiDoubleVal(d1 / d2));
							}
							default: {
								onError("not a double argument of /: " + fiVal2s(args[1]));
								None();
							}
						}
					}
					default: {
						onError("not an integer or double argument of /: " + fiVal2s(args[0]));
						None();
					}
				}
			}
			FcModPrim(): {
				switch (args[0]) {
					FiIntVal(i1): {
						switch (args[1]) {
							FiIntVal(i2): {
								Some(FiIntVal(i1 % i2));
							}
							default: {
								onError("not an integer argument of %: " + fiVal2s(args[1]));
								None();
							}
						}
					}
					FiDoubleVal(d1): {
						switch (args[1]) {
							FiDoubleVal(d2): {
								Some(FiDoubleVal(d1 % d2));
							}
							default: {
								onError("not a double argument of %: " + fiVal2s(args[1]));
								None();
							}
						}
					}
					default: {
						onError("not an integer or double argument of %: " + fiVal2s(args[0]));
						None();
					}
				}
			}
			FcNegPrim(): {
				switch (args[0]) {
					FiIntVal(i1): {
						Some(FiIntVal(-i1));
					}
					FiDoubleVal(d1): {
						Some(FiDoubleVal(-d1));
					}
					default: {
						onError("not an integer or double argument of -: " + fiVal2s(args[0]));
						None();
					}
				}
			}
			FcArrayPrim(): {
				Some(FiArrayVal(args));
			}
			FcIndexPrim(): {
				switch (args[0]) {
					FiArrayVal(arr): {
						switch (args[1]) {
							FiIntVal(i): {
								if (0 <= i && i + 1 <= length(arr)) {
									Some(arr[i]);
								} else {
									onError("array index is out of bounds: " + i2s(i) + " not in [0 - " + i2s(length(arr) - 1) + "]");
									None();
								}
							}
							default: {
								onError("not an integer argument of array access: " + fiVal2s(args[1]));
								None();
							}
						}
					}
					default: {
						onError("not an array argument of array access: " + fiVal2s(args[0]));
						None();
					}
				}
			}
			FcDerefPrim(): {
				switch (args[0]) {
					FiRefVal(rf): {
						Some(^rf);
					}
					default: {
						onError("deref argument must be a ref, but is: " + fiVal2s(args[0]));
						None();
					}
				}
			}
			FcAssignPrim(): {
				switch (args[0]) {
					FiRefVal(rf): {
						rf := args[1];
						Some(FiVoidVal());
					}
					default: {
						onError("assign operator argument must be a ref, but is: " + fiVal2s(args[0]));
						None();
					}
				}
			}
			FcRefPrim(): {
				Some(FiRefVal(ref args[0]));
			}
			FcStructPrim(name): {
				//if (makeStructValue(name, ))
				fields = structFieldNames(name);
				if (length(fields) != length(args)) {
					onError("number " + i2s(length(fields)) + " of fields of struct " + name + " mismatch number of arguments " + i2s(length(args)));
					None();
				} else {
					Some(FiStructVal(name, mapi(args, \i, arg -> FiFieldVal(fields[i], ref arg))));
				}
			}
			FcFieldPrim(name): {
				switch (args[0]) {
					FiStructVal(str, fields): {
						findmap(fields, \field -> 
							if (field.name == name) Some(^(field.val)) else None()
						);
					}
					default: {
						onError("field access operator argument must be a struct, but is: " + fiVal2s(args[0]));
						None();
					}
				}
			}
			FcSetMutablePrim(name): {
				switch (args[0]) {
					FiStructVal(str, fields): {
						findmap(fields, \field -> 
							if (field.name == name) {
								field.val := args[1];
								Some(FiVoidVal());
							} else {
								onError("field " + name + " is not found in struct " + str);
								None()
							}
						);
					}
					default: {
						onError("field assignment operator argument must be a struct, but is: " + fiVal2s(args[0]));
						None();
					}
				}
			}
			// creates a closure explicitly - appears after lambda lifting
			FcCreateClosurePrim(structName, functionName): {
				onError("operator FcCreateClosurePrim is not implemented yet");
				// TODO
				None();
			}
			FcQuote(): {
				onError("operator FcQuote is not implemented yet");
				// TODO
				None();
			}
			FcUnquote(): {
				onError("operator FcUnquote is not implemented yet");
				// TODO
				None();
			}
		}
	}
	//println2(^aaa + "ret: " + toString(ret));
	ret
}

fcUnwrapFiVal(ex : FiVal) -> flow {
	switch (ex) {
		FiStructVal(name, fields): {
			makeStructValue(
				name, 
				map(fields, \field -> fcUnwrapFiVal(^(field.val))), 
				IllegalStruct()
			);
		}
		FiArrayVal(val): map(val, fcUnwrapFiVal);
		FiRefVal(val): ref fcUnwrapFiVal(^val);
		FiFuncVal(fn, arity, __,__): {
			//println("UNWRAPPING: " + fiVal2s(ex));
			unwrap_ret = \r -> switch (r) {
				Some(v): fcUnwrapFiVal(v);
				None(): {
					// Runtime error;
					IllegalStruct();
				}
			}
			if (arity == 0) {
				flow(\ -> unwrap_ret(fn([])));
			} else if (arity == 1) {
				flow(\a1 -> unwrap_ret(fn([fcWrapFiVal(a1)])));
			} else if (arity == 2) {
				flow(\a1, a2 -> unwrap_ret(fn([fcWrapFiVal(a1), fcWrapFiVal(a2)])));
			} else if (arity == 3) {
				flow(\a1, a2, a3 -> unwrap_ret(fn([fcWrapFiVal(a1), fcWrapFiVal(a2), fcWrapFiVal(a3)])));
			} else if (arity == 4) {
				flow(\a1, a2, a3, a4 -> unwrap_ret(fn([fcWrapFiVal(a1), fcWrapFiVal(a2), fcWrapFiVal(a3), fcWrapFiVal(a4)])));
			} else if (arity == 5) {
				flow(\a1, a2, a3, a4, a5 -> unwrap_ret(fn([fcWrapFiVal(a1), fcWrapFiVal(a2), fcWrapFiVal(a3), fcWrapFiVal(a4), fcWrapFiVal(a5)])));
			} else if (arity == 6) {
				flow(\a1, a2, a3, a4, a5, a6 -> unwrap_ret(fn([fcWrapFiVal(a1), fcWrapFiVal(a2), fcWrapFiVal(a3), fcWrapFiVal(a4), fcWrapFiVal(a5), fcWrapFiVal(a6)])));
			} else {
				flow(IllegalStruct());
			}
			/*func : ([flow]) -> flow = \as -> {
				println("CALLING UNWRAPPED: " + fiVal2s(ex));
				args = map(as, fcWrapFiVal);
				switch (fn(args)) {
					Some(v): fcUnwrapFiVal(v);
					None(): {
						// Runtime error;
						IllegalStruct();
					}
				}
			}
			func;*/
		}
		FiStringVal(s): s;
		FiBoolVal(b):   b;
		FiDoubleVal(d): d;
		FiVoidVal():    IllegalStruct();
		FiIntVal(i):    i;
		FiNativeVal(v): v;
	}
}

fcWrapFiVal(v : flow) -> FiVal {
	// What is the type tag for this value? Supported only in cpp and java
	// 0: void, 1: bool, 2: int, 3: double, 4 : string, 5: array, 6: struct, 12: code pointer, 20: native function
	// 31: reference, 32: native value, 34: closure pointer, 48: captured frame
	type_tag = getDataTagForValue(v);
	if (type_tag == 0) {
		FiVoidVal();
	} else if (type_tag == 1) {
		FiBoolVal(cast(v : flow -> bool));
	} else if (type_tag == 2) {
		FiIntVal(cast(v : flow -> int));
	} else if (type_tag == 3) {
		FiDoubleVal(cast(v : flow -> double));
	} else if (type_tag == 4) {
		FiStringVal(cast(v : flow -> string));
	} else if (type_tag == 5) {
		FiArrayVal(map(cast(v : flow -> [flow]), fcWrapFiVal));
	} else if (type_tag == 6) {
		name = extractStructName(v);
		fields = structFieldNames(name);
		FiStructVal(name,
			mapi(extractStructArguments(v), \i, w -> 
				FiFieldVal(fields[i], ref fcWrapFiVal(w))
			)
		);
	} else if (type_tag == 31) {
		FiRefVal(
			ref fcWrapFiVal(^cast(v : flow -> ref flow))
		);
	} else if (type_tag == 34) {
		arity = extractFuncArity(v);
		if (arity == 0) {
			fn = cast(v : flow -> (() -> flow));
			//println("WRAPPING: " + toString(fn));
			FiFuncVal(
				\__ -> {
					//println("CALLING WRAPPED: " + toString(fn));
					Some(fcWrapFiVal(fn()))
				},
				0, None(), toString(fn)
			);
		} else if (arity == 1) {
			fn = cast(v : flow -> ((flow) -> flow));
			//println("WRAPPING: " + toString(fn));
			FiFuncVal(
				\as -> {
					//println("CALLING WRAPPED: " + toString(fn));
					Some(fcWrapFiVal(fn(fcUnwrapFiVal(as[0]))));
				},
				1, None(), toString(fn)
			);
		} else if (arity == 2) {
			fn = cast(v : flow -> ((flow, flow) -> flow));
			//println("WRAPPING: " + toString(fn));
			FiFuncVal(
				\as -> {
					//println("CALLING WRAPPED: " + toString(fn));
					Some(fcWrapFiVal(fn(fcUnwrapFiVal(as[0]), fcUnwrapFiVal(as[1]))));
				},
				2, None(), toString(fn)
			);
		} else if (arity == 3) {
			fn = cast(v : flow -> ((flow, flow, flow) -> flow));
			//println("WRAPPING: " + toString(fn));
			FiFuncVal(
				\as -> {
					//println("CALLING WRAPPED: " + toString(fn));
					Some(fcWrapFiVal(fn(fcUnwrapFiVal(as[0]), fcUnwrapFiVal(as[1]), fcUnwrapFiVal(as[2]))));
				},
				3, None(), toString(fn)
			);
		} else if (arity == 4) {
			fn = cast(v : flow -> ((flow, flow, flow, flow) -> flow));
			//println("WRAPPING: " + toString(fn));
			FiFuncVal(
				\as -> {
					//println("CALLING WRAPPED: " + toString(fn));
					Some(fcWrapFiVal(fn(fcUnwrapFiVal(as[0]), fcUnwrapFiVal(as[1]), fcUnwrapFiVal(as[2]), fcUnwrapFiVal(as[3]))));
				},
				4, None(), toString(fn)
			);
		} else if (arity == 5) {
			fn = cast(v : flow -> ((flow, flow, flow, flow, flow) -> flow));
			println("WRAPPING: " + toString(fn));
			FiFuncVal(
				\as -> {
					//println("CALLING WRAPPED: " + toString(fn));
					Some(fcWrapFiVal(fn(fcUnwrapFiVal(as[0]), fcUnwrapFiVal(as[1]), fcUnwrapFiVal(as[2]), fcUnwrapFiVal(as[3]), fcUnwrapFiVal(as[4]))));
				},
				5, None(), toString(fn)
			);
		} else {
			// TODO: add more arities
			fail("unsupported arity " + i2s(arity));
			FiVoidVal();
		}
	} else {
		FiNativeVal(v);
	}
}
