import ds/hashmap;
import sys/system;
import math/hash;
import string_utils;

import tools/flowc/flowc_typecheck;
import tools/common/utils;
import tools/flowc/flow_parser;
import fonts_repo;

export {
	FcRuntimeError(message : string);
	// Struct which represents a void value.
	FcRuntimeVoid();

	// Setup the global variables and toplevel functions
	fcInitEvalEnv(program: FiProgram, onError : (string) -> void) -> HashMap<string, flow>;

	// Perform the evaluation of function 'name'. 
	// 'None()' as a return value means a runtime error. Normally 'Some(retval)' is returned.
	fcCallFunction(name : string, args : [flow], globals : HashMap<string, flow>) -> flow;
}

fcMakeFnFromLambda(
	lambda : FiLambda, 
	globals : HashMap<string, flow>, 
	closure : Maybe<HashMap<string, flow>>,
	onError : (string) -> void
) -> flow {
	arity = length(lambda.args);
	if (arity == 0) {
		flow(\ -> {
			locals = switch (closure) {
				None(): makeHashMap(fastHashString);
				Some(cl): copyHashMap(cl);
			}
			fcReplEval(lambda.body, globals, locals, onError)
		});
	} else if (arity == 1) {
		flow(\a0 -> {
			locals = switch (closure) {
				None(): makeHashMap(fastHashString);
				Some(cl): copyHashMap(cl);
			}
			setHashMap(locals, lambda.args[0].name, a0);
			fcReplEval(lambda.body, globals, locals, onError);
		});
	} else if (arity == 2) {
		flow(\a0, a1 -> {
			locals = switch (closure) {
				None(): makeHashMap(fastHashString);
				Some(cl): copyHashMap(cl);
			}
			setHashMap(locals, lambda.args[0].name, a0);
			setHashMap(locals, lambda.args[1].name, a1);
			fcReplEval(lambda.body, globals, locals, onError);
		});
	} else if (arity == 3) {
		flow(\a0, a1, a2 -> {
			locals = switch (closure) {
				None(): makeHashMap(fastHashString);
				Some(cl): copyHashMap(cl);
			}
			setHashMap(locals, lambda.args[0].name, a0);
			setHashMap(locals, lambda.args[1].name, a1);
			setHashMap(locals, lambda.args[2].name, a2);
			fcReplEval(lambda.body, globals, locals, onError);
		});
	} else if (arity == 4) {
		flow(\a0, a1, a2, a3 -> {
			locals = switch (closure) {
				None(): makeHashMap(fastHashString);
				Some(cl): copyHashMap(cl);
			}
			setHashMap(locals, lambda.args[0].name, a0);
			setHashMap(locals, lambda.args[1].name, a1);
			setHashMap(locals, lambda.args[2].name, a2);
			setHashMap(locals, lambda.args[3].name, a3);
			fcReplEval(lambda.body, globals, locals, onError);
		});
	} else if (arity == 5) {
		flow(\a0, a1, a2, a3, a4 -> {
			locals = switch (closure) {
				None(): makeHashMap(fastHashString);
				Some(cl): copyHashMap(cl);
			}
			setHashMap(locals, lambda.args[0].name, a0);
			setHashMap(locals, lambda.args[1].name, a1);
			setHashMap(locals, lambda.args[2].name, a2);
			setHashMap(locals, lambda.args[3].name, a3);
			setHashMap(locals, lambda.args[4].name, a4);
			fcReplEval(lambda.body, globals, locals, onError);
		});
	} else if (arity == 6) {
		flow(\a0, a1, a2, a3, a4, a5 -> {
			locals = switch (closure) {
				None(): makeHashMap(fastHashString);
				Some(cl): copyHashMap(cl);
			}
			setHashMap(locals, lambda.args[0].name, a0);
			setHashMap(locals, lambda.args[1].name, a1);
			setHashMap(locals, lambda.args[2].name, a2);
			setHashMap(locals, lambda.args[3].name, a3);
			setHashMap(locals, lambda.args[4].name, a4);
			setHashMap(locals, lambda.args[5].name, a5);
			fcReplEval(lambda.body, globals, locals, onError);
		});
	} else if (arity == 7) {
		flow(\a0, a1, a2, a3, a4, a5, a6 -> {
			locals = switch (closure) {
				None(): makeHashMap(fastHashString);
				Some(cl): copyHashMap(cl);
			}
			setHashMap(locals, lambda.args[0].name, a0);
			setHashMap(locals, lambda.args[1].name, a1);
			setHashMap(locals, lambda.args[2].name, a2);
			setHashMap(locals, lambda.args[3].name, a3);
			setHashMap(locals, lambda.args[4].name, a4);
			setHashMap(locals, lambda.args[5].name, a5);
			setHashMap(locals, lambda.args[6].name, a6);
			fcReplEval(lambda.body, globals, locals, onError);
		});
	} else if (arity == 8) {
		flow(\a0, a1, a2, a3, a4, a5, a6, a7 -> {
			locals = switch (closure) {
				None(): makeHashMap(fastHashString);
				Some(cl): copyHashMap(cl);
			}
			setHashMap(locals, lambda.args[0].name, a0);
			setHashMap(locals, lambda.args[1].name, a1);
			setHashMap(locals, lambda.args[2].name, a2);
			setHashMap(locals, lambda.args[3].name, a3);
			setHashMap(locals, lambda.args[4].name, a4);
			setHashMap(locals, lambda.args[5].name, a5);
			setHashMap(locals, lambda.args[6].name, a6);
			setHashMap(locals, lambda.args[7].name, a7);
			fcReplEval(lambda.body, globals, locals, onError);
		});
	} else if (arity == 8) {
		flow(\a0, a1, a2, a3, a4, a5, a6, a7 -> {
			locals = switch (closure) {
				None(): makeHashMap(fastHashString);
				Some(cl): copyHashMap(cl);
			}
			setHashMap(locals, lambda.args[0].name, a0);
			setHashMap(locals, lambda.args[1].name, a1);
			setHashMap(locals, lambda.args[2].name, a2);
			setHashMap(locals, lambda.args[3].name, a3);
			setHashMap(locals, lambda.args[4].name, a4);
			setHashMap(locals, lambda.args[5].name, a5);
			setHashMap(locals, lambda.args[6].name, a6);
			setHashMap(locals, lambda.args[7].name, a7);
			fcReplEval(lambda.body, globals, locals, onError);
		});
	} else if (arity == 9) {
		flow(\a0, a1, a2, a3, a4, a5, a6, a7, a8 -> {
			locals = switch (closure) {
				None(): makeHashMap(fastHashString);
				Some(cl): copyHashMap(cl);
			}
			setHashMap(locals, lambda.args[0].name, a0);
			setHashMap(locals, lambda.args[1].name, a1);
			setHashMap(locals, lambda.args[2].name, a2);
			setHashMap(locals, lambda.args[3].name, a3);
			setHashMap(locals, lambda.args[4].name, a4);
			setHashMap(locals, lambda.args[5].name, a5);
			setHashMap(locals, lambda.args[6].name, a6);
			setHashMap(locals, lambda.args[7].name, a7);
			setHashMap(locals, lambda.args[8].name, a8);
			fcReplEval(lambda.body, globals, locals, onError);
		});
	} else if (arity == 10) {
		flow(\a0, a1, a2, a3, a4, a5, a6, a7, a8, a9 -> {
			locals = switch (closure) {
				None(): makeHashMap(fastHashString);
				Some(cl): copyHashMap(cl);
			}
			setHashMap(locals, lambda.args[0].name, a0);
			setHashMap(locals, lambda.args[1].name, a1);
			setHashMap(locals, lambda.args[2].name, a2);
			setHashMap(locals, lambda.args[3].name, a3);
			setHashMap(locals, lambda.args[4].name, a4);
			setHashMap(locals, lambda.args[5].name, a5);
			setHashMap(locals, lambda.args[6].name, a6);
			setHashMap(locals, lambda.args[7].name, a7);
			setHashMap(locals, lambda.args[8].name, a8);
			setHashMap(locals, lambda.args[9].name, a9);
			fcReplEval(lambda.body, globals, locals, onError);
		});
	} else if (arity == 11) {
		flow(\a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10 -> {
			locals = switch (closure) {
				None(): makeHashMap(fastHashString);
				Some(cl): copyHashMap(cl);
			}
			setHashMap(locals, lambda.args[0].name, a0);
			setHashMap(locals, lambda.args[1].name, a1);
			setHashMap(locals, lambda.args[2].name, a2);
			setHashMap(locals, lambda.args[3].name, a3);
			setHashMap(locals, lambda.args[4].name, a4);
			setHashMap(locals, lambda.args[5].name, a5);
			setHashMap(locals, lambda.args[6].name, a6);
			setHashMap(locals, lambda.args[7].name, a7);
			setHashMap(locals, lambda.args[8].name, a8);
			setHashMap(locals, lambda.args[9].name, a9);
			setHashMap(locals, lambda.args[10].name, a10);
			fcReplEval(lambda.body, globals, locals, onError);
		});
	} else if (arity == 12) {
		flow(\a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11 -> {
			locals = switch (closure) {
				None(): makeHashMap(fastHashString);
				Some(cl): copyHashMap(cl);
			}
			setHashMap(locals, lambda.args[0].name, a0);
			setHashMap(locals, lambda.args[1].name, a1);
			setHashMap(locals, lambda.args[2].name, a2);
			setHashMap(locals, lambda.args[3].name, a3);
			setHashMap(locals, lambda.args[4].name, a4);
			setHashMap(locals, lambda.args[5].name, a5);
			setHashMap(locals, lambda.args[6].name, a6);
			setHashMap(locals, lambda.args[7].name, a7);
			setHashMap(locals, lambda.args[8].name, a8);
			setHashMap(locals, lambda.args[9].name, a9);
			setHashMap(locals, lambda.args[10].name, a10);
			setHashMap(locals, lambda.args[11].name, a11);
			fcReplEval(lambda.body, globals, locals, onError);
		});
	} else {
		onError("unsupproted arity: " + i2s(arity) + " for lambda\n" + prettyFiExp(dummyPretty, lambda));
		flow(\ -> FcRuntimeError("unsupproted arity: " + i2s(arity) + " for lambda\n" + prettyFiExp(dummyPretty, lambda)))
	}
}

fcMakeFnFromNative(nat : FiNativeDec, onError : (string) -> void) -> flow {
	arity = switch (nat.type) {
		FiTypeFunction(arg_types,__): {
			length(arg_types);
		}
		default: -1;
	}
	if (arity == 0) {
		flow(\ -> hostCall(nat.nativeName, []));
	} else if (arity == 1) {
		flow(\a1 -> hostCall(nat.nativeName, [a1]));
	} else if (arity == 2) {
		flow(\a1, a2 -> hostCall(nat.nativeName, [a1, a2]));
	} else if (arity == 3) {
		flow(\a1, a2, a3 -> hostCall(nat.nativeName, [a1, a2, a3]));
	} else if (arity == 4) {
		flow(\a1, a2, a3, a4 -> hostCall(nat.nativeName, [a1, a2, a3, a4]));
	} else if (arity == 5) {
		flow(\a1, a2, a3, a4, a5 -> hostCall(nat.nativeName, [a1, a2, a3, a4, a5]));
	} else if (arity == 6) {
		flow(\a1, a2, a3, a4, a5, a6 -> hostCall(nat.nativeName, [a1, a2, a3, a4, a5, a6]));
	} else if (arity == 7) {
		flow(\a1, a2, a3, a4, a5, a6, a7 -> hostCall(nat.nativeName, [a1, a2, a3, a4, a5, a6, a7]));
	} else if (arity == 8) {
		flow(\a1, a2, a3, a4, a5, a6, a7, a8 -> hostCall(nat.nativeName, [a1, a2, a3, a4, a5, a6, a7, a8]));
	} else if (arity == 9) {
		flow(\a1, a2, a3, a4, a5, a6, a7, a8, a9 -> hostCall(nat.nativeName, [a1, a2, a3, a4, a5, a6, a7, a8, a9]));
	} else if (arity == 10) {
		flow(\a1, a2, a3, a4, a5, a6, a7, a8, a9, a10 -> hostCall(nat.nativeName, [a1, a2, a3, a4, a5, a6, a7, a8, a9, a10]));
	} else if (arity == 11) {
		flow(\a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11 -> hostCall(nat.nativeName, [a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11]));
	} else if (arity == 12) {
		flow(\a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12 -> hostCall(nat.nativeName, [a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12]));
	} else {
		onError("unsupproted arity: " + i2s(arity) + " for native " + nat.nativeName);
		flow(\ -> FcRuntimeError("unsupproted arity: " + i2s(arity) + " for native " + nat.nativeName))
	}
}

fcInitEvalEnv(prog: FiProgram, onError : (string) -> void) -> HashMap<string, flow> {
	globals = makeHashMap(fastHashString);
	iter(prog.traversal, \mod_name ->
		switch (lookupTree(prog.modules, mod_name)) {
			Some(module): {
				iter(module.natives, \nat : FiNativeDec -> {
					fn = if (hostCallExists(nat.nativeName)) {
						fcMakeFnFromNative(nat, onError);
					} else {
						switch (nat.fallbackLambda) {
							FiLambda(args, body, type,__): {
								fcMakeFnFromLambda(nat.fallbackLambda, globals, None(), onError);
							}
							default: {
								onError("NO native : " + nat.nativeName);
								flow(\ __-> FcRuntimeError("NO native : " + nat.nativeName))
							}
						}
					}
					setHashMap(globals, nat.name, fn);
				});
				iter(module.initOrder, \name ->
					maybeApply(lookupTree(prog.names.toplevel, name), \decl ->
						switch (decl) {
							FiFunctionDec(__, lambda, type,__,__): {
								fn = fcMakeFnFromLambda(lambda, globals, None(), onError);
								setHashMap(globals, name, fn);
							}
							FiGlobalVar(__, value, __,__,__): {
								gv = fcReplEval(value, globals, makeHashMap(fastHashString), onError); 
								setHashMap(globals, name, gv);
							}
							FiNativeDec(__,__,__, nativeName, fallback, __,__): { }
						}
					)
				);
			}
			None(): {
				// Never should be
			}
		}
	);
	globals;
}

fcCallFunction(name : string, args : [flow], globals : HashMap<string, flow>) -> flow {
	switch (lookupHashMap(globals, name)) {
		Some(fv): {
			if (getDataTagForValue(fv) != 34) {
				FcRuntimeError("not a function is called: " + toString(fv));
			} else {
				arity = extractFuncArity(fv);
				if (arity == 0) {
					cast(fv : flow -> (() -> flow))();
				} else if (arity == 1) {
					cast(fv : flow -> ((flow) -> flow))(args[0]);
				} else if (arity == 2) {
					cast(fv : flow -> ((flow, flow) -> flow))(args[0], args[1]);
				} else if (arity == 3) {
					cast(fv : flow -> ((flow, flow, flow) -> flow))(args[0], args[1], args[2]);
				} else if (arity == 4) {
					cast(fv : flow -> ((flow, flow, flow, flow) -> flow))(args[0], args[1], args[2], args[3]);
				} else if (arity == 5) {
					cast(fv : flow -> ((flow, flow, flow, flow, flow) -> flow))(args[0], args[1], args[2], args[3], args[4]);
				} else if (arity == 6) {
					cast(fv : flow -> ((flow, flow, flow, flow, flow, flow) -> flow))(args[0], args[1], args[2], args[3], args[4], args[5]);
				} else if (arity == 7) {
					cast(fv : flow -> ((flow, flow, flow, flow, flow, flow, flow) -> flow))(args[0], args[1], args[2], args[3], args[4], args[5], args[6]);
				} else if (arity == 8) {
					cast(fv : flow -> ((flow, flow, flow, flow, flow, flow, flow, flow) -> flow))(args[0], args[1], args[2], args[3], args[4], args[5], args[6], args[7]);
				} else if (arity == 9) {
					cast(fv : flow -> ((flow, flow, flow, flow, flow, flow, flow, flow, flow) -> flow))(args[0], args[1], args[2], args[3], args[4], args[5], args[6], args[7], args[8]);
				} else if (arity == 10) {
					cast(fv : flow -> ((flow, flow, flow, flow, flow, flow, flow, flow, flow, flow) -> flow))(args[0], args[1], args[2], args[3], args[4], args[5], args[6], args[7], args[8], args[9]);
				} else if (arity == 11) {
					cast(fv : flow -> ((flow, flow, flow, flow, flow, flow, flow, flow, flow, flow, flow) -> flow))(args[0], args[1], args[2], args[3], args[4], args[5], args[6], args[7], args[8], args[9], args[10]);
				} else if (arity == 12) {
					cast(fv : flow -> ((flow, flow, flow, flow, flow, flow, flow, flow, flow, flow, flow, flow) -> flow))(args[0], args[1], args[2], args[3], args[4], args[5], args[6], args[7], args[8], args[9], args[10], args[11]);
				} else {
					// TODO: add more arities
					FcRuntimeError("unsupported arity " + i2s(arity));
				}
			}
		}
		None(): {
			FcRuntimeError("function " + name + " is not found");
		}
	};
}

trace = false;

trace_list : ref List<FiExp> = ref makeList();

printTrace() -> void {
	dpPrintTrace(10, ^trace_list);
}

dpPrintTrace(c : int, l : List<FiExp>) -> void {
	if (c > 0) {
		switch (l) {
			Cons(ex, t): {
				//println(fcShortFiExp(ex));
				println(prettyFiExp(dummyPretty, ex));
				dpPrintTrace(c - 1, t);
			}
			EmptyList(): {}
		}
	}
}

fcReplEval(ex : FiExp, globals : HashMap<string, flow>, locals : HashMap<string, flow>, onError : (string) -> void) -> flow {
	if (trace) {
		rlistPush(trace_list, ex);
	}
	make_err = \msg -> {
		onError(msg);
		flow(FcRuntimeError(msg));
	}
	ret = switch (ex) {
		FiLambda(args, body,__,__): {
			arity = length(args);
			closure = copyHashMap(locals);
			fcMakeFnFromLambda(ex, globals, Some(closure), onError);
		}
		FiCall(f, args,__,__): {
			fv = fcReplEval(f, globals, locals, onError);
			if (getDataTagForValue(fv) != 34) {
				make_err("not a function is called: " + toString(fv));
			} else {
				arity = length(args);
				argsv = map(args, \a -> fcReplEval(a, globals, locals, onError));
				if (arity == 0) {
					cast(fv : flow -> (() -> flow))();
				} else if (arity == 1) {
					cast(fv : flow -> ((flow) -> flow))(argsv[0]);
				} else if (arity == 2) {
					cast(fv : flow -> ((flow, flow) -> flow))(argsv[0], argsv[1]);
				} else if (arity == 3) {
					cast(fv : flow -> ((flow, flow, flow) -> flow))(argsv[0], argsv[1], argsv[2]);
				} else if (arity == 4) {
					cast(fv : flow -> ((flow, flow, flow, flow) -> flow))(argsv[0], argsv[1], argsv[2], argsv[3]);
				} else if (arity == 5) {
					cast(fv : flow -> ((flow, flow, flow, flow, flow) -> flow))(argsv[0], argsv[1], argsv[2], argsv[3], argsv[4]);
				} else if (arity == 6) {
					cast(fv : flow -> ((flow, flow, flow, flow, flow, flow) -> flow))(argsv[0], argsv[1], argsv[2], argsv[3], argsv[4], argsv[5]);
				} else if (arity == 7) {
					cast(fv : flow -> ((flow, flow, flow, flow, flow, flow, flow) -> flow))(argsv[0], argsv[1], argsv[2], argsv[3], argsv[4], argsv[5], argsv[6]);
				} else if (arity == 8) {
					cast(fv : flow -> ((flow, flow, flow, flow, flow, flow, flow, flow) -> flow))(argsv[0], argsv[1], argsv[2], argsv[3], argsv[4], argsv[5], argsv[6], argsv[7]);
				} else if (arity == 9) {
					cast(fv : flow -> ((flow, flow, flow, flow, flow, flow, flow, flow, flow) -> flow))(argsv[0], argsv[1], argsv[2], argsv[3], argsv[4], argsv[5], argsv[6], argsv[7], argsv[8]);
				} else if (arity == 10) {
					cast(fv : flow -> ((flow, flow, flow, flow, flow, flow, flow, flow, flow, flow) -> flow))(argsv[0], argsv[1], argsv[2], argsv[3], argsv[4], argsv[5], argsv[6], argsv[7], argsv[8], argsv[9]);
				} else if (arity == 11) {
					cast(fv : flow -> ((flow, flow, flow, flow, flow, flow, flow, flow, flow, flow, flow) -> flow))(argsv[0], argsv[1], argsv[2], argsv[3], argsv[4], argsv[5], argsv[6], argsv[7], argsv[8], argsv[9], argsv[10]);
				} else if (arity == 12) {
					cast(fv : flow -> ((flow, flow, flow, flow, flow, flow, flow, flow, flow, flow, flow, flow) -> flow))(argsv[0], argsv[1], argsv[2], argsv[3], argsv[4], argsv[5], argsv[6], argsv[7], argsv[8], argsv[9], argsv[10], argsv[11]);
				} else {
					// TODO: add more arities
					make_err("unsupported arity " + i2s(arity));
				}
			}
		}
		FiVar(x,__,__): {
			switch (lookupHashMap(locals, x)) {
				Some(v): v;
				None(): {
					switch (lookupHashMap(globals, x)) {
						Some(v): v;
						None(): {
							printTrace();
							fail("variable " + x + " is not defined");
							make_err("variable " + x + " is not defined");
						}
					}
				}
			}
		}
		FiLet(x, __, e1, e2,__,__): {
			xv = fcReplEval(e1, globals, locals, onError);
			setHashMap(locals, x, xv);
			ret = fcReplEval(e2, globals, locals, onError);
			removeFromHashMap(locals, x);
			ret;
		}
		FiIf(e1, e2, e3, __,__): {
			if (cast(fcReplEval(e1, globals, locals, onError) : flow -> bool)) {
				fcReplEval(e2, globals, locals, onError);
			} else {
				fcReplEval(e3, globals, locals, onError);
			}
		}
		FiSwitch(v,__,cs,__,__): {
			w = fcReplEval(v, globals, locals, onError);
			name = extractStructName(w);
			switch (find(cs, \c -> c.struct == name|| c.struct == "default")) {
				Some(case): {
					args = extractStructArguments(w);
					if (case.struct != "default") {
						iteri(case.argNames, \i, arg -> 
							setHashMap(locals, arg, args[i])
						);
					}
					ret = fcReplEval(case.body, globals, locals, onError);
					if (case.struct != "default") {
						iter(case.argNames, \arg -> 
							removeFromHashMap(locals, arg)
						);
					}
					ret;
				}
				None(): {
					make_err("case " + name + " is not found in switch:\n" + prettyFiExp(dummyPretty, ex) +  "\nswitch value: " + toString(w));
				}
			}
		}
		FiCast(e, __,to,__,__): {
			ev = fcReplEval(e, globals, locals, onError);
			if (getDataTagForValue(ev) == 2) {
				// int case
				switch (to) {
					FiTypeDouble(): flow(i2d(cast(ev : flow -> int)));
					FiTypeString(): flow(i2s(cast(ev : flow -> int)));
					default: ev; 
				}
			} else if (getDataTagForValue(ev) == 3) {
				// double case
				switch (to) {
					FiTypeInt(): flow(round(cast(ev : flow -> double)));
					FiTypeString(): flow(d2s(cast(ev : flow -> double)));
					default: ev; 
				}
			} else {
				ev;
			}
		}
		FiSeq(es,__,__): {
			ret : ref flow = ref flow(FcRuntimeVoid());
			iter(es, \e -> ret := fcReplEval(e, globals, locals, onError));
			^ret;
		}
		FiCallPrim(op, es, __,__): {
			fcReplEvalCallPrim(ex, es, globals, locals, onError);
		}
		FiString(s,__): flow(s);
		FiBool(b,__):   flow(b);
		FiDouble(d,__): flow(d);
		FiVoid(__):     flow(FcRuntimeVoid());
		FiInt(i,__):    flow(i);
		FiRequire(flowfile, __,__,__): {
			make_err("FiRequire is not implemented yet");
		}
		FiUnsafe(name, __,__,__): {
			make_err("FiUnsafe is not implemented yet");
		}
	}
	if (trace) {
		trace_list := tailList(^trace_list);
	}
	ret;
}

fcReplEvalCallPrim(call : FiCallPrim, es : [FiExp], globals : HashMap<string, flow>, locals : HashMap<string, flow>, onError : (string) -> void) -> flow {
	make_err = \msg -> {
		onError(msg);
		flow(FcRuntimeError(msg));
	}
	switch (call.op) {
		FcOrPrim(): {
			a0 = fcReplEval(es[0], globals, locals, onError);
			a1 = fcReplEval(es[1], globals, locals, onError);
			flow(cast(a0 : flow -> bool) || cast(a1 : flow -> bool));
		}
		FcAndPrim(): {
			a0 = fcReplEval(es[0], globals, locals, onError);
			if (!cast(a0 : flow -> bool)) flow(false) else {
				fcReplEval(es[1], globals, locals, onError);
			}
		}
		FcNotPrim(): {
			a0 = fcReplEval(es[0], globals, locals, onError);
			flow(!cast(a0 : flow -> bool));
		}
		FcEqPrim(): {
			a0 = fcReplEval(es[0], globals, locals, onError);
			a1 = fcReplEval(es[1], globals, locals, onError);
			flow(a0 == a1);
		}
		FcNePrim(): {
			a0 = fcReplEval(es[0], globals, locals, onError);
			a1 = fcReplEval(es[1], globals, locals, onError);
			flow(a0 != a1);
		}
		FcLePrim(): {
			a0 = fcReplEval(es[0], globals, locals, onError);
			a1 = fcReplEval(es[1], globals, locals, onError);
			flow(a0 <= a1);
		}
		FcGePrim(): {
			a0 = fcReplEval(es[0], globals, locals, onError);
			a1 = fcReplEval(es[1], globals, locals, onError);
			flow(a0 >= a1);
		}
		FcLtPrim(): {
			a0 = fcReplEval(es[0], globals, locals, onError);
			a1 = fcReplEval(es[1], globals, locals, onError);
			flow(a0 < a1);
		}
		FcGtPrim(): {
			a0 = fcReplEval(es[0], globals, locals, onError);
			a1 = fcReplEval(es[1], globals, locals, onError);
			flow(a0 > a1);
		}
		FcPlusPrim(): {
			a0 = fcReplEval(es[0], globals, locals, onError);
			a1 = fcReplEval(es[1], globals, locals, onError);
			if (getDataTagForValue(a0) == 2) {
				// int case
				flow(cast(a0 : flow -> int) + cast(a1 : flow -> int));
			} else if (getDataTagForValue(a0) == 3) {
				// double case
				flow(cast(a0 : flow -> double) + cast(a1 : flow -> double));
			} else if (getDataTagForValue(a0) == 4) {
				// string case
				flow(cast(a0 : flow -> string) + cast(a1 : flow -> string));
			} else {
				make_err("not an integer, double or string argument of +: " + toString(a0));
			}
		}
		FcMinusPrim(): {
			a0 = fcReplEval(es[0], globals, locals, onError);
			a1 = fcReplEval(es[1], globals, locals, onError);
			if (getDataTagForValue(a0) == 2) {
				// int case
				flow(cast(a0 : flow -> int) - cast(a1 : flow -> int));
			} else if (getDataTagForValue(a0) == 3) {
				// double case
				flow(cast(a0 : flow -> double) - cast(a1 : flow -> double));
			} else {
				make_err("not an integer or double argument of -: " + toString(a0));
			}
		}
		FcMulPrim(): {
			a0 = fcReplEval(es[0], globals, locals, onError);
			a1 = fcReplEval(es[1], globals, locals, onError);
			if (getDataTagForValue(a0) == 2) {
				// int case
				flow(cast(a0 : flow -> int) * cast(a1 : flow -> int));
			} else if (getDataTagForValue(a0) == 3) {
				// double case
				flow(cast(a0 : flow -> double) * cast(a1 : flow -> double));
			} else {
				make_err("not an integer or double argument of *: " + toString(a0));
			}
		}
		FcDivPrim(): {
			a0 = fcReplEval(es[0], globals, locals, onError);
			a1 = fcReplEval(es[1], globals, locals, onError);
			if (getDataTagForValue(a0) == 2) {
				// int case
				d = cast(a1 : flow -> int);
				if (d == 0) {
					printTrace();
					make_err("division by zero");
				} else {
 					flow(cast(a0 : flow -> int) / d);
				}
			} else if (getDataTagForValue(a0) == 3) {
				// double case
				d = cast(a1 : flow -> double);
				if (d == 0.0) {
					printTrace();
					make_err("division by zero");
				} else {
					flow(cast(a0 : flow -> double) / d);
				}
			} else {
				make_err("not an integer or double argument of /: " + toString(a0));
			}
		}
		FcModPrim(): {
			a0 = fcReplEval(es[0], globals, locals, onError);
			a1 = fcReplEval(es[1], globals, locals, onError);
			if (getDataTagForValue(a0) == 2) {
				// int case
				d = cast(a1 : flow -> int);
				if (d == 0) {
					printTrace();
					make_err("division by zero");
				} else {
 					flow(cast(a0 : flow -> int) % d);
				}
			} else if (getDataTagForValue(a0) == 3) {
				// double case
				d = cast(a1 : flow -> double);
				if (d == 0.0) {
					printTrace();
					make_err("division by zero");
				} else {
					flow(cast(a0 : flow -> double) % d);
				}
			} else {
				make_err("not an integer or double argument of %: " + toString(a0));
			}
		}
		FcNegPrim(): {
			a0 = fcReplEval(es[0], globals, locals, onError);
			if (getDataTagForValue(a0) == 2) {
				// int case
				flow(-cast(a0 : flow -> int));
			} else if (getDataTagForValue(a0) == 3) {
				// double case
				flow(-cast(a0 : flow -> double));
			} else {
				make_err("not an integer or double argument of -: " + toString(a0));
			}
		}
		FcArrayPrim(): {
			args = map(es, \e -> fcReplEval(e, globals, locals, onError));
			flow(args);
		}
		FcIndexPrim(): {
			a0 = fcReplEval(es[0], globals, locals, onError);
			a1 = fcReplEval(es[1], globals, locals, onError);
			cast(a0 : flow -> [flow])[cast(a1 : flow -> int)];
		}
		FcDerefPrim(): {
			a0 = fcReplEval(es[0], globals, locals, onError);
			flow(^cast(a0 : flow -> ref flow));
		}
		FcAssignPrim(): {
			a0 = fcReplEval(es[0], globals, locals, onError);
			a1 = fcReplEval(es[1], globals, locals, onError);
			cast(a0 : flow -> ref flow) := a1;
			flow(FcRuntimeVoid());
		}
		FcRefPrim(): {
			a0 = fcReplEval(es[0], globals, locals, onError);
			ref a0;
		}
		FcStructPrim(name): {
			args = map(es, \e -> fcReplEval(e, globals, locals, onError));
			makeStructValue(name, args, FcRuntimeError("Struct " + name + " is not found"));
		}
		FcFieldPrim(field): {
			struct = fcReplEval(es[0], globals, locals, onError);
			name = extractStructName(struct); 
			fields = structFieldNames(name);
			i = elemIndex(fields, field, -1);
			if (i == -1) {
				printTrace();
				fail("field " + field + " is not found in struct '" + name + "' " + toString(struct) + "\n" +
				toString(es));
				make_err("field " + field + " is not found in struct '" + name + "' " + toString(struct));
			} else {
				struct_args = extractStructArguments(struct);
				struct_args[i];
			}
		}
		FcSetMutablePrim(field): {
			a0 = fcReplEval(es[0], globals, locals, onError);
			a1 = fcReplEval(es[1], globals, locals, onError);
			setMutableField(a0, field, a1);
			flow(FcRuntimeVoid());
		}
		// creates a closure explicitly - appears after lambda lifting
		FcCreateClosurePrim(structName, functionName): {
			make_err("operator FcCreateClosurePrim is not implemented yet");
			// TODO
		}
		FcQuote(): {
			make_err("operator FcQuote is not implemented yet");
			// TODO
		}
		FcUnquote(): {
			make_err("operator FcUnquote is not implemented yet");
			// TODO
		}
	}
}
