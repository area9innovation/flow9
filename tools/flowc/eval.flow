import ds/hashmap;
import sys/system;
import math/hash;
import string_utils;

import tools/flowc/flowc_typecheck;
import tools/common/utils;
import tools/flowc/flow_parser;
import fonts_repo;

export {

	// Union which represents values in a running program 
	FiVal ::= FiConstVal, FiStructVal, FiArrayVal, FiRefVal, FiNativeVal, FiFuncVal; 

		FiConstVal ::= FiVoidVal, FiBoolVal, FiIntVal, FiDoubleVal, FiStringVal;
		FiStructVal(name : string, fields : [FiFieldVal]);
			FiFieldVal(name : string, val : ref FiVal);
		FiArrayVal(val : [FiVal]);
		FiRefVal(val : ref FiVal);
		FiNativeVal(val : native);
		FiFuncVal(
			fn : ([FiVal]) -> Maybe<FiVal>, 
			arity : int,
			lambda : Maybe<FiLambda>, 
			nativeName : string
		);

		FiVoidVal();
		FiBoolVal(val : bool);
		FiIntVal(val : int);
		FiDoubleVal(val : double);
		FiStringVal(val : string);
		FiErrorVal(msg : string);

	// Setup the global variables and toplevel functions
	fcInitEvalEnv(program: FiProgram, onError : (string) -> void) -> HashMap<string, FiVal>;

	// Perform the evaluation of function 'name'. 
	// 'None()' as a return value means a runtime error. Normally 'Some(retval)' is returned.
	fcCallFunction(name : string, args : [FiVal], globals : HashMap<string, FiVal>) -> Maybe<FiVal>;

	// Convert any value to FiVal
	fcWrapFiVal(v : flow) -> FiVal;

	// Convert FiVal back to any value
	fcUnwrapFiVal(ex : FiVal) -> flow;

	fiVal2s(v : FiVal) -> string;
}

fcFuncArity(fn : FiType) -> int {
	switch (fn) {
		FiTypeFunction(args,__): length(args);
		default: -1;
	}
}

fcFiValIllegal(v : FiVal) -> bool {
	switch (v) {
		FiStructVal(name, as): {
			name == "IllegalStruct";
		}
		default: false;
	}
}

fcInitEvalEnv(prog: FiProgram, onError : (string) -> void) -> HashMap<string, FiVal> {
	globals = makeHashMap(fastHashString);
	add_native = \nat : FiNativeDec -> {
		fn = if (hostCallExists(nat.nativeName)) {
			//println("Added native : " + nat.nativeName);
			FiFuncVal(
				\as -> {
					if (nat.nativeName != "Native.makeStructValue" && nat.nativeName != "Native.fromBinary" && exists(as, fcFiValIllegal)) {
						println("Calling native : " + nat.nativeName + ", args:\n" + concatStrings(map(as, \a -> "\t" + fiVal2s(a) + "\n")));
						printCallstack();
					}
					args = map(as, \a -> fcUnwrapFiVal(a));
					/*println("Calling native : " + nat.nativeName + ", args:\n" + concatStrings(map(as, \a -> "\t" + fiVal2s(a) + "\n")));
					if (nat.nativeName == "Native.fold") {
						a3 : (flow, flow) -> flow = cast(args[2] : flow -> (flow, flow) -> flow);
						t1 :Tree<string, FontFace> = makeTree();
						x1 : FontFace = FontFace("Roboto", "Roboto", FONT_WEIGHT_BOOK, FONT_SLOPE_NORMAL, ["Roboto"]);
						r = a3(t1, x1);
						println("r: " + toString(r));
					}

					r = hostCall(nat.nativeName, args);
					println("REsult : " + toString(r));
					ret = fcWrapFiVal(r);
					println("REsult : " + toString(ret));
					Some(ret);*/

					Some(fcWrapFiVal(hostCall(nat.nativeName, args)));
				},
				fcFuncArity(nat.type),
				None(),
				nat.nativeName
			);
		} else {
			//println("Added fallback for : " + nat.nativeName);
			switch (nat.fallbackLambda) {
				FiLambda(args, body,__,__): {
					FiFuncVal(
						\as -> fcReplEval(body, globals, fcEvalCallLocals(args, as, None()), onError),
						length(args),
						Some(nat.fallbackLambda),
						""
					);
				}
				default: {
					println("NO native : " + nat.nativeName);
					FiFuncVal(\ __-> None(), -1, None(), "");
				}
			}
		}
		setHashMap(globals, nat.name, fn);
	}
	iter(prog.traversal, \mod_name ->
		switch (lookupTree(prog.modules, mod_name)) {
			Some(module): {
				iter(module.natives, add_native);
				iter(module.initOrder, \name ->
					maybeApply(lookupTree(prog.names.toplevel, name), \decl ->
						switch (decl) {
							FiFunctionDec(__, lambda, __,__,__): {
								setHashMap(globals, name, FiFuncVal(
									\as -> fcReplEval(lambda.body, globals, fcEvalCallLocals(lambda.args, as, None()), onError),
									length(lambda.args), 
									Some(lambda), 
									""
								));
							}
							FiGlobalVar(__, value, __,__,__): {
								maybeApply(fcReplEval(value,  globals, makeHashMap(fastHashString), onError),
									\v -> setHashMap(globals, name, v)
								);
							}
							FiNativeDec(__,__,__, nativeName, fallback, __,__): {
								//add_native(decl);
							}
						}
					)
				);
			}
			None(): {
				// Never should be
			}
		}
	);
	globals;
}

fcCallFunction(name : string, args : [FiVal], globals : HashMap<string, FiVal>) ->  Maybe<FiVal> {
	maybeBind(lookupHashMap(globals, name), \val -> 
		switch (val) {
			FiFuncVal(fn,__,__,__): fn(args);
			default: None();
		}
	);
}

trace = false;

fcEvalCallLocals(args : [FiFunArg], vals : [FiVal], closure : Maybe<HashMap<string, FiVal>>) -> HashMap<string, FiVal> {
	locals = switch (closure) {
		Some(cl): copyHashMap(cl);
		None(): makeHashMap(fastHashString);
	}
	iteri(args, \i, arg -> setHashMap(locals, arg.name, vals[i]));
	locals;
}

fcReplEval(ex : FiExp, globals : HashMap<string, FiVal>, locals : HashMap<string, FiVal>, onError : (string) -> void) -> Maybe<FiVal> {
	if (trace) {
		println2(^aaa + "fcReplEval: " + toString(ex)
			//+ "\nvals:\n-------\n" +
			//concatStrings(map(tree2pairs(vals), \p -> "\t" + p.first + " => " + fiVal2s(p.second) + "\n")) + "\n--------\n"
		);
	}
	a0 = ^aaa;
	aaa := ^aaa + "\t";
	/*args1 = map(call.es, \e -> {
		println2(^aaa + "call.es, e: " + toString(e));
		a0 = ^aaa;
		aaa := ^aaa + "\t";
		ret = fcReplEval(prog, e, vals);
		aaa := a0;
		//println2(^aaa + "ret (!!): " + toString(ret));
		ret;
	});*/
	ret = switch (ex) {
		FiLambda(args, body,__,__): {
			closure = copyHashMap(locals);
			Some(FiFuncVal(
				\as -> fcReplEval(body, globals, fcEvalCallLocals(args, as, Some(closure)), onError),
				length(args), 
				Some(ex), 
				""
			));
		}
		FiCall(f, args,__,__): {
			maybeBind(fcReplEval(f, globals, locals, onError),
				\f1 -> {
					switch (f1) {
						FiFuncVal(fn,ari,__,__): {
							args1 = filtermap(args, \a -> fcReplEval(a, globals, locals, onError));
							if (length(args) != length(args1)) None() else {
								ret = fn(args1);
								if (isNone(ret)) {
									onError("error while applying function:\n" + fiVal2s(f1) + "\nto args:\n" + strGlue(map(args1, fiVal2s), "\n") + "\n");
								}
								ret;
							}
						}
						default: {
							onError("not a function is called: " + fiVal2s(f1));
							None();
						}
					}
				}
			);
		}
		FiVar(x,__,__): {
			switch (lookupHashMap(globals, x)) {
				Some(v): Some(v);
				None(): {
					switch (lookupHashMap(locals, x)) {
						Some(v): Some(v);
						None(): {
							onError("variable " + x + " is not defined");
							None();
						}
					}
				}
			}
		}
		FiLet(x, __, e1, e2,__,__): {
			maybeBind(fcReplEval(e1, globals, locals, onError),
				\v -> {
					setHashMap(locals, x, v);
					ret = fcReplEval(e2, globals, locals, onError);
					removeFromHashMap(locals, x);
					ret;
				}
			);
		}
		FiIf(e1, e2, e3, __,__): {
			maybeBind(fcReplEval(e1, globals, locals, onError),
				\c -> switch (c) {
					FiBoolVal(v): {
						if (v) fcReplEval(e2, globals, locals, onError) else fcReplEval(e3, globals, locals, onError);
					}
					default: {
						onError("not a boolean condition: " + fiVal2s(c));
						None();
					}
				}
			);
		}
		FiSwitch(v,__,cs,__,__): {
			maybeBind(fcReplEval(v, globals, locals, onError),
				\w -> {
					switch (w) {
						FiStructVal(n, fields): {
							case = find(cs, \c -> c.struct == n || c.struct == "default");
							if (isNone(case)) {
								onError("case " + n + " is not found in switch:\n" + prettyFiExp(dummyPretty, ex) +  "\nswitch value: " + fiVal2s(w));
							}
							maybeBind(case,
								\c : FiCase -> {
									if (c.struct != "default" && length(fields) != length(c.argNames)) {
										onError("number of fields " + i2s(length(fields)) + " in struct " + n + " misfits the number of argument in case: " + i2s(length(c.argNames)) + ", switch:\n" + prettyFiExp(dummyPretty, ex) +  "\nswitch value: " + fiVal2s(w));
										None();
									} else {
										/*case_locals = if (c.struct == "default") locals else {
											foldi(
												map(fields, \field -> ^(field.val)), 
												globals, locals, 
												\i, acc, e -> setTree(acc, c.argNames[i], e)
											);
										}*/
										if (c.struct != "default") {
											iteri(fields, \i, field -> 
												setHashMap(locals, c.argNames[i], ^(field.val))
											);
										}
										ret = fcReplEval(c.body, globals, locals, onError);
										if (c.struct != "default") {
											iteri(fields, \i, field -> 
												removeFromHashMap(locals, c.argNames[i])
											);
										}
										ret;
									}
								}
							);
						}
						default: {
							onError("not a struct in switch: " + fiVal2s(w));
							None();
						}
					}
				}
			);
		}
		FiCast(e, __,to,__,__): {
			maybeMap(fcReplEval(e, globals, locals, onError), \ev -> 
				switch (ev) {
					FiIntVal(v): {
						switch (to) {
							FiTypeDouble(): FiDoubleVal(i2d(v));
							FiTypeString(): FiStringVal(i2s(v));
							default: ev; 
						}
					}
					FiDoubleVal(v): {
						switch (to) {
							FiTypeInt(): FiIntVal(round(v));
							FiTypeString(): FiStringVal(d2s(v));
							default: ev; 
						}
					}
					default: ev;
				}
			);
		}
		FiSeq(es,__,__): {
			ret : ref Maybe<FiVal> = ref Some(FiVoidVal());
			iter(es, \e -> ret := fcReplEval(e, globals, locals, onError));
			^ret;
		}
		FiCallPrim(op, es, __,__): {
			args = filtermap(es, \e -> fcReplEval(e, globals, locals, onError));
			if (length(args) != length(es)) None() else {
				fcReplEvalCallPrim(ex, args, onError);
			}
		}
		FiString(s,__): Some(FiStringVal(s));
		FiBool(b,__):   Some(FiBoolVal(b));
		FiDouble(d,__): Some(FiDoubleVal(d));
		FiVoid(__):     Some(FiVoidVal());
		FiInt(i,__):    Some(FiIntVal(i));
		FiRequire(flowfile, __,__,__): {
			onError("FiRequire is not implemented yet");
			None();
		}
		FiUnsafe(name, __,__,__): {
			onError("FiUnsafe is not implemented yet");
			None();
		}
	}
	aaa := a0;
	if (trace) {
		maybeApply(ret,
			\r -> println2(^aaa + "ret (**): " + fiVal2s(r))
		);
	}
	ret;
}

fiVal2s(v : FiVal) -> string {
	switch (v) {
		FiStructVal(name, fields): name + "(" + strGlue(map(fields, \field ->  fiVal2s(^(field.val))), ", ")	+ ")";
		FiArrayVal(arr): "[" + strGlue(map(arr, fiVal2s), ", ") + "]";
		FiRefVal(val): "ref " + fiVal2s(^val);
		FiFuncVal(fn, __, ml, nat): {
			switch (ml) {
				Some(lambda): prettyFiExp(dummyPretty, lambda);
				None(): nat;
			}
		}
		FiNativeVal(val): "<native>: " + toString(val);
		FiVoidVal(): "{void}";
		FiBoolVal(val): b2s(val);
		FiIntVal(val): i2s(val);
		FiDoubleVal(val): d2s(val);
		FiStringVal(val): "\"" + val + "\"";
	}
}

aaa = ref "";

fcReplEvalCallPrim(call : FiCallPrim, args : [FiVal], onError : (string) -> void) -> Maybe<FiVal> {
	switch (call.op) {
		FcOrPrim(): {
			switch (args[0]) {
				FiBoolVal(b1): {
					switch (args[1]) {
						FiBoolVal(b2): {
							Some(FiBoolVal(b1 || b2));
						}
						default: {
							onError("not a boolen argument of ||: " + fiVal2s(args[1]));
							None();
						}
					}
				}
				default: {
					onError("not a boolean argument of ||: " + fiVal2s(args[0]));
					None();
				}
			}
		}
		FcAndPrim(): {
			switch (args[0]) {
				FiBoolVal(b1): {
					switch (args[1]) {
						FiBoolVal(b2): {
							Some(FiBoolVal(b1 && b2));
						}
						default: {
							onError("not a boolen argument of &&: " + fiVal2s(args[1]));
							None();
						}
					}
				}
				default: {
					onError("not a boolen argument of &&: " + fiVal2s(args[0]));
					None();
				}
			}
		}
		FcNotPrim(): {
			switch (args[0]) {
				FiBoolVal(b): {
					Some(FiBoolVal(!b));
				}
				default: {
					onError("not a boolen argument of !: " + fiVal2s(args[0]));
					None()
				}
			}
		}
		FcEqPrim(): {
			Some(FiBoolVal(args[0] == args[1]));
		}
		FcNePrim(): {
			Some(FiBoolVal(args[0] != args[1]));
		}
		FcLePrim(): {
			Some(FiBoolVal(args[0] <= args[1]));
		}
		FcGePrim(): {
			Some(FiBoolVal(args[0] >= args[1]));
		}
		FcLtPrim(): {
			Some(FiBoolVal(args[0] < args[1]));
		}
		FcGtPrim(): {
			Some(FiBoolVal(args[0] > args[1]));
		}
		FcPlusPrim(): {
			switch (args[0]) {
				FiIntVal(i1): {
					switch (args[1]) {
						FiIntVal(i2): {
							Some(FiIntVal(i1 + i2));
						}
						default: {
							onError("not an integer argument of +: " + fiVal2s(args[1]));
							None();
						}
					}
				}
				FiDoubleVal(d1): {
					switch (args[1]) {
						FiDoubleVal(d2): {
							Some(FiDoubleVal(d1 + d2));
						}
						default: {
							onError("not a double argument of +: " + fiVal2s(args[1]));
							None();
						}
					}
				}
				FiStringVal(s1): {
					switch (args[1]) {
						FiStringVal(s2): {
							Some(FiStringVal(s1 + s2));
						}
						default: {
							onError("not a string argument of +: " + fiVal2s(args[1]));
							None();
						}
					}
				}
				default: {
					onError("not an integer, double or string argument of +: " + fiVal2s(args[0]));
					None();
				}
			}
		}
		FcMinusPrim(): {
			switch (args[0]) {
				FiIntVal(i1): {
					switch (args[1]) {
						FiIntVal(i2): {
							Some(FiIntVal(i1 - i2));
						}
						default: {
							onError("not an integer argument of -: " + fiVal2s(args[1]));
							None();
						}
					}
				}
				FiDoubleVal(d1): {
					switch (args[1]) {
						FiDoubleVal(d2): {
							Some(FiDoubleVal(d1 - d2));
						}
						default: {
							onError("not a double argument of -: " + fiVal2s(args[1]));
							None();
						}
					}
				}
				default: {
					onError("not an integer or double argument of -: " + fiVal2s(args[0]));
					None();
				}
			}
		}
		FcMulPrim(): {
			switch (args[0]) {
				FiIntVal(i1): {
					switch (args[1]) {
						FiIntVal(i2): {
							Some(FiIntVal(i1 * i2));
						}
						default: {
							onError("not an integer argument of *: " + fiVal2s(args[1]));
							None();
						}
					}
				}
				FiDoubleVal(d1): {
					switch (args[1]) {
						FiDoubleVal(d2): {
							Some(FiDoubleVal(d1 * d2));
						}
						default: {
							onError("not a double argument of *: " + fiVal2s(args[1]));
							None();
						}
					}
				}
				default: {
					onError("not an integer or double argument of *: " + fiVal2s(args[0]));
					None();
				}
			}
		}
		FcDivPrim(): {
			switch (args[0]) {
				FiIntVal(i1): {
					switch (args[1]) {
						FiIntVal(i2): {
							Some(FiIntVal(i1 / i2));
						}
						default: {
							onError("not an integer argument of /: " + fiVal2s(args[1]));
							None();
						}
					}
				}
				FiDoubleVal(d1): {
					switch (args[1]) {
						FiDoubleVal(d2): {
							Some(FiDoubleVal(d1 / d2));
						}
						default: {
							onError("not a double argument of /: " + fiVal2s(args[1]));
							None();
						}
					}
				}
				default: {
					onError("not an integer or double argument of /: " + fiVal2s(args[0]));
					None();
				}
			}
		}
		FcModPrim(): {
			switch (args[0]) {
				FiIntVal(i1): {
					switch (args[1]) {
						FiIntVal(i2): {
							Some(FiIntVal(i1 % i2));
						}
						default: {
							onError("not an integer argument of %: " + fiVal2s(args[1]));
							None();
						}
					}
				}
				FiDoubleVal(d1): {
					switch (args[1]) {
						FiDoubleVal(d2): {
							Some(FiDoubleVal(d1 % d2));
						}
						default: {
							onError("not a double argument of %: " + fiVal2s(args[1]));
							None();
						}
					}
				}
				default: {
					onError("not an integer or double argument of %: " + fiVal2s(args[0]));
					None();
				}
			}
		}
		FcNegPrim(): {
			switch (args[0]) {
				FiIntVal(i1): {
					Some(FiIntVal(-i1));
				}
				FiDoubleVal(d1): {
					Some(FiDoubleVal(-d1));
				}
				default: {
					onError("not an integer or double argument of -: " + fiVal2s(args[0]));
					None();
				}
			}
		}
		FcArrayPrim(): {
			Some(FiArrayVal(args));
		}
		FcIndexPrim(): {
			switch (args[0]) {
				FiArrayVal(arr): {
					switch (args[1]) {
						FiIntVal(i): {
							if (0 <= i && i + 1 <= length(arr)) {
								Some(arr[i]);
							} else {
								onError("array index is out of bounds: " + i2s(i) + " not in [0 - " + i2s(length(arr) - 1) + "]");
								None();
							}
						}
						default: {
							onError("not an integer argument of array access: " + fiVal2s(args[1]));
							None();
						}
					}
				}
				default: {
					onError("not an array argument of array access: " + fiVal2s(args[0]));
					None();
				}
			}
		}
		FcDerefPrim(): {
			switch (args[0]) {
				FiRefVal(rf): {
					Some(^rf);
				}
				default: {
					onError("deref argument must be a ref, but is: " + fiVal2s(args[0]));
					None();
				}
			}
		}
		FcAssignPrim(): {
			switch (args[0]) {
				FiRefVal(rf): {
					rf := args[1];
					Some(FiVoidVal());
				}
				default: {
					onError("assign operator argument must be a ref, but is: " + fiVal2s(args[0]));
					None();
				}
			}
		}
		FcRefPrim(): {
			Some(FiRefVal(ref args[0]));
		}
		FcStructPrim(name): {
			//if (makeStructValue(name, ))
			fields = structFieldNames(name);
			if (length(fields) != length(args)) {
				onError("number " + i2s(length(fields)) + " of fields of struct " + name + " mismatch number of arguments " + i2s(length(args)));
				None();
			} else {
				Some(FiStructVal(name, mapi(args, \i, arg -> FiFieldVal(fields[i], ref arg))));
			}
		}
		FcFieldPrim(name): {
			switch (args[0]) {
				FiStructVal(str, fields): {
					val = findmap(fields, \field -> 
						if (field.name == name) Some(^(field.val)) else None()
					);
					if (isNone(val)) {
						onError("field " + name + " is not found in struct " + str);
					}
					val;
				}
				default: {
					onError("field access operator argument must be a struct, but is: " + fiVal2s(args[0]));
					None();
				}
			}
		}
		FcSetMutablePrim(name): {
			switch (args[0]) {
				FiStructVal(str, fields): {
					val = findmap(fields, \field -> 
						if (field.name == name) {
							field.val := args[1];
							Some(FiVoidVal());
						} else {
							None()
						}
					);
					if (isNone(val)) {
						onError("field " + name + " is not found in struct " + str);
					}
					val;
				}
				default: {
					onError("field assignment operator argument must be a struct, but is: " + fiVal2s(args[0]));
					None();
				}
			}
		}
		// creates a closure explicitly - appears after lambda lifting
		FcCreateClosurePrim(structName, functionName): {
			onError("operator FcCreateClosurePrim is not implemented yet");
			// TODO
			None();
		}
		FcQuote(): {
			onError("operator FcQuote is not implemented yet");
			// TODO
			None();
		}
		FcUnquote(): {
			onError("operator FcUnquote is not implemented yet");
			// TODO
			None();
		}
	}
}

fcUnwrapFiVal(ex : FiVal) -> flow {
	switch (ex) {
		FiStructVal(name, fields): {
			ret = makeStructValue(
				name, 
				map(fields, \field -> fcUnwrapFiVal(^(field.val))), 
				IllegalStruct()
			);
			if (name != "IllegalStruct" && ret == IllegalStruct()) {
				println("Runtime error: cannot create struct " + fiVal2s(ex));
			}
			ret;
		}
		FiArrayVal(val): map(val, fcUnwrapFiVal);
		FiRefVal(val): ref fcUnwrapFiVal(^val);
		FiFuncVal(fn, arity, __,__): {
			//println("UNWRAPPING: " + fiVal2s(ex));
			unwrap_ret = \r -> switch (r) {
				Some(v): fcUnwrapFiVal(v);
				None(): {
					println("Runtime error while calling " + fiVal2s(ex));
					// Runtime error;
					IllegalStruct();
				}
			}
			if (arity == 0) {
				flow(\ -> unwrap_ret(fn([])));
			} else if (arity == 1) {
				flow(\a1 -> unwrap_ret(fn([fcWrapFiVal(a1)])));
			} else if (arity == 2) {
				flow(\a1, a2 -> unwrap_ret(fn([fcWrapFiVal(a1), fcWrapFiVal(a2)])));
			} else if (arity == 3) {
				flow(\a1, a2, a3 -> unwrap_ret(fn([fcWrapFiVal(a1), fcWrapFiVal(a2), fcWrapFiVal(a3)])));
			} else if (arity == 4) {
				flow(\a1, a2, a3, a4 -> unwrap_ret(fn([fcWrapFiVal(a1), fcWrapFiVal(a2), fcWrapFiVal(a3), fcWrapFiVal(a4)])));
			} else if (arity == 5) {
				flow(\a1, a2, a3, a4, a5 -> unwrap_ret(fn([fcWrapFiVal(a1), fcWrapFiVal(a2), fcWrapFiVal(a3), fcWrapFiVal(a4), fcWrapFiVal(a5)])));
			} else if (arity == 6) {
				flow(\a1, a2, a3, a4, a5, a6 -> unwrap_ret(fn([fcWrapFiVal(a1), fcWrapFiVal(a2), fcWrapFiVal(a3), fcWrapFiVal(a4), fcWrapFiVal(a5), fcWrapFiVal(a6)])));
			} else {
				println("Runtime error: arity " + i2s(arity) + " is not supported yet");
				flow(IllegalStruct());
			}
			/*func : ([flow]) -> flow = \as -> {
				println("CALLING UNWRAPPED: " + fiVal2s(ex));
				args = map(as, fcWrapFiVal);
				switch (fn(args)) {
					Some(v): fcUnwrapFiVal(v);
					None(): {
						// Runtime error;
						IllegalStruct();
					}
				}
			}
			func;*/
		}
		FiStringVal(s): s;
		FiBoolVal(b):   b;
		FiDoubleVal(d): d;
		FiVoidVal():    IllegalStruct();
		FiIntVal(i):    i;
		FiNativeVal(v): v;
	}
}

fcWrapFiVal(v : flow) -> FiVal {
	// What is the type tag for this value? Supported only in cpp and java
	// 0: void, 1: bool, 2: int, 3: double, 4 : string, 5: array, 6: struct, 12: code pointer, 20: native function
	// 31: reference, 32: native value, 34: closure pointer, 48: captured frame
	type_tag = getDataTagForValue(v);
	if (type_tag == 0) {
		FiVoidVal();
	} else if (type_tag == 1) {
		FiBoolVal(cast(v : flow -> bool));
	} else if (type_tag == 2) {
		FiIntVal(cast(v : flow -> int));
	} else if (type_tag == 3) {
		FiDoubleVal(cast(v : flow -> double));
	} else if (type_tag == 4) {
		FiStringVal(cast(v : flow -> string));
	} else if (type_tag == 5) {
		FiArrayVal(map(cast(v : flow -> [flow]), fcWrapFiVal));
	} else if (type_tag == 6) {
		name = extractStructName(v);
		fields = structFieldNames(name);
		FiStructVal(name,
			mapi(extractStructArguments(v), \i, w -> 
				FiFieldVal(fields[i], ref fcWrapFiVal(w))
			)
		);
	} else if (type_tag == 31) {
		FiRefVal(
			ref fcWrapFiVal(^cast(v : flow -> ref flow))
		);
	} else if (type_tag == 34) {
		arity = extractFuncArity(v);
		if (arity == 0) {
			fn = cast(v : flow -> (() -> flow));
			//println("WRAPPING: " + toString(fn));
			FiFuncVal(
				\__ -> {
					//println("CALLING WRAPPED: " + toString(fn));
					Some(fcWrapFiVal(fn()))
				},
				0, None(), "<func>" //, toString(fn)
			);
		} else if (arity == 1) {
			fn = cast(v : flow -> ((flow) -> flow));
			//println("WRAPPING: " + toString(fn));
			FiFuncVal(
				\as -> {
					//println("CALLING WRAPPED: " + toString(fn));
					Some(fcWrapFiVal(fn(fcUnwrapFiVal(as[0]))));
				},
				1, None(), "<func>" //, toString(fn)
			);
		} else if (arity == 2) {
			fn = cast(v : flow -> ((flow, flow) -> flow));
			//println("WRAPPING: " + toString(fn));
			FiFuncVal(
				\as -> {
					//println("CALLING WRAPPED: " + toString(fn));
					Some(fcWrapFiVal(fn(fcUnwrapFiVal(as[0]), fcUnwrapFiVal(as[1]))));
				},
				2, None(), "<func>" //, toString(fn)
			);
		} else if (arity == 3) {
			fn = cast(v : flow -> ((flow, flow, flow) -> flow));
			//println("WRAPPING: " + toString(fn));
			FiFuncVal(
				\as -> {
					//println("CALLING WRAPPED: " + toString(fn));
					Some(fcWrapFiVal(fn(fcUnwrapFiVal(as[0]), fcUnwrapFiVal(as[1]), fcUnwrapFiVal(as[2]))));
				},
				3, None(), "<func>" //, toString(fn)
			);
		} else if (arity == 4) {
			fn = cast(v : flow -> ((flow, flow, flow, flow) -> flow));
			//println("WRAPPING: " + toString(fn));
			FiFuncVal(
				\as -> {
					//println("CALLING WRAPPED: " + toString(fn));
					Some(fcWrapFiVal(fn(fcUnwrapFiVal(as[0]), fcUnwrapFiVal(as[1]), fcUnwrapFiVal(as[2]), fcUnwrapFiVal(as[3]))));
				},
				4, None(), "<func>" //, toString(fn)
			);
		} else if (arity == 5) {
			fn = cast(v : flow -> ((flow, flow, flow, flow, flow) -> flow));
			//println("WRAPPING: " + toString(fn));
			FiFuncVal(
				\as -> {
					//println("CALLING WRAPPED: " + toString(fn));
					Some(fcWrapFiVal(fn(fcUnwrapFiVal(as[0]), fcUnwrapFiVal(as[1]), fcUnwrapFiVal(as[2]), fcUnwrapFiVal(as[3]), fcUnwrapFiVal(as[4]))));
				},
				5, None(), "<func>" //, toString(fn)
			);
		} else {
			// TODO: add more arities
			fail("unsupported arity " + i2s(arity));
			FiVoidVal();
		}
	} else {
		FiNativeVal(v);
	}
}
