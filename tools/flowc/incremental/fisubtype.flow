import tools/flowc/incremental/fitype;
import ds/array;
import runtime;

import tools/flowc/flowcacc;

export {
	isFiSubType(env : FcGlobalNames, small : FiType, big : FiType, allowFlow : bool) -> bool;

	// Would we be able to find some super type to make these two types compatible?
	fiSuperTypeExists(env : FcGlobalNames, t1 : FiType, t2 : FiType, allowFlow : bool) -> bool;
}

isFiSubType(env : FcGlobalNames, small : FiType, big : FiType, allowFlow : bool) -> bool {
    flowok = \ -> {
        (allowFlow && small == FiTypeFlow()) || small == big;
    }
	switch (big) {
		FiTypeVoid(): small == big;
		FiTypeBool(): flowok();
		FiTypeInt(): flowok();
		FiTypeDouble(): flowok();
		FiTypeString(): flowok();
		FiTypeArray(bt): switch (small) {
			FiTypeArray(st): isFiSubType(env, st, bt, allowFlow); // We could do false here
			default: flowok();
		}
		FiTypeFlow(): true;
		FiTypeNative(): small == big;
		FiTypeFunction(bargs, breturnType): {
			switch (small) {
				FiTypeFunction(sargs, sreturnType): {
					isFiSubType(env, sreturnType, breturnType, allowFlow)
					// Here, we reverse
					&& areFiSubTypes(env, map(bargs, \ba -> ba.type), map(sargs, \sa -> sa.type), allowFlow)
				}
				default: flowok();
			}
		}
		FiTypeRef(bt): switch (small) {
			FiTypeRef(st): {
				isFiSubType(env, st, bt, false)
			}
			default: false;
		}
		FiTypeParameter(bn): {
			switch (small) {
				// We just accept this
				FiTypeParameter(sn): true;
				default: flowok();
			}
		}
		FiTypeName(bname, btypeparameters): {
			switch (small) {
				FiTypeName(sname, stypeparameters): {
					if (sname == bname) {
                        // This is required for some cases, like switch, where we do not have typars
                        // as well as for implicit polymorphism due to polymorphic unions
                        stypeparameters == [] 
                        || btypeparameters == [] 
						|| areFiSubTypes(env, stypeparameters, btypeparameters, allowFlow)
					} else {
						relation = getFiTypenameRelation(env, sname, bname);
						switch (relation) {
							FiRelationEqual(): true;
							FiName2Supertype(): true;
							FiName1Supertype(): {
								// TODO: We are not ready for this, but that would be best
								if (false) {
									println(sname + ">=" + bname + " but expected the opposite");
									false;
								} else true
							}
							FiCommonSupertype(): true;
							FiNotRelated(): false;
						}
					}
				}
				default: flowok();
			}
		} 
	}
}

areFiSubTypes(env : FcGlobalNames, small : [FiType], big : [FiType], allowflow : bool) -> bool {
	length(small) == length(big)
	&& foldi(small, true, \i, acc, sa -> {
		acc && isFiSubType(env, sa, big[i], allowflow)
	})
}

fiSuperTypeExists(env : FcGlobalNames, t1 : FiType, t2 : FiType, allowFlow : bool) -> bool {
    flowok = \ -> {
        (allowFlow && t1 == FiTypeFlow()) 
		|| switch (t1) {
			FiTypeParameter(bn): {
				// We just accept this
				true;
			}
			default: t1 == t2;
		}
    };
	switch (t2) {
		FiTypeVoid(): t1 == t2;
		FiTypeBool(): flowok();
		FiTypeInt(): flowok();
		FiTypeDouble(): flowok();
		FiTypeString(): flowok();
		FiTypeArray(bt): switch (t1) {
			FiTypeArray(st): fiSuperTypeExists(env, st, bt, allowFlow);
			default: flowok();
		}
		FiTypeFlow(): true;
		FiTypeNative(): t1 == t2;
		FiTypeFunction(bargs, breturnType): {
			switch (t1) {
				FiTypeFunction(sargs, sreturnType): {
					fiSuperTypeExists(env, sreturnType, breturnType, allowFlow)
					// Here, we reverse
					&& fiSuperTypesExists(env, map(bargs, \ba -> ba.type), map(sargs, \sa -> sa.type), allowFlow)
				}
				default: flowok();
			}
		}
		FiTypeRef(bt): switch (t1) {
			FiTypeRef(st): {
				fiSuperTypeExists(env, st, bt, false)
			}
			default: false;
		}
		FiTypeParameter(bn): {
			// We just accept this
			true;
		}
		FiTypeName(bname, btypeparameters): {
			switch (t1) {
				FiTypeName(sname, stypeparameters): {
					if (sname == bname) {
                        // This is required for some cases, like switch, where we do not have typars
                        // as well as for implicit polymorphism due to polymorphic unions
                        stypeparameters == [] 
                        || btypeparameters == [] 
						|| fiSuperTypesExists(env, stypeparameters, btypeparameters, allowFlow)
					} else {
						// println("TODO: Check that " + sname + " compatible with " + bname);
						true;
					}
				}
				default: flowok();
			}
		} 
	}
}

fiSuperTypesExists(env : FcGlobalNames, small : [FiType], big : [FiType], allowflow : bool) -> bool {
	length(small) == length(big)
	&& foldi(small, true, \i, acc, sa -> {
		acc && fiSuperTypeExists(env, sa, big[i], allowflow)
	})
}


// How are these names related? 

FiTypeRelation ::= FiRelationEqual, FiName2Supertype, FiName1Supertype, FiCommonSupertype, FiNotRelated;
	FiRelationEqual();
	FiName2Supertype();
	FiName1Supertype();
	FiCommonSupertype();
	FiNotRelated();

getFiTypenameRelation(env : FcGlobalNames, name1 : string, name2 : string) -> FiTypeRelation {
	if (name1 == name2) FiRelationEqual()
	else {
		union1 = lookupTree(env.unions, name1);
		union2 = lookupTree(env.unions, name2);

		unions1 = getTreeArrayValue(env.struct2unions, name1);
		unions2 = getTreeArrayValue(env.struct2unions, name2);

		switch (union1) {
			None(): {
				// name1 is a struct.
				// Check if name2 is a struct as well
				switch (union2) {
					None(): {
						// name2 is also a struct.
						// They need a shared unions
						shared = intersection(unions1, unions2);
						if (shared != []) {
							FiCommonSupertype();
						} else {
							// Not related!
							FiNotRelated();
						}
					}
					Some(u2): {
						// name2 is a union.
						// See if name1 is part of that union
						if (contains(unions1, name2)) {
							// name2 is a supertype of name1
							FiName2Supertype();
						} else {
							// name2 is a union, but name1 is not part of it. They are NOT related
							FiNotRelated();
						}
					}
				}
			}
			Some(u1): {
				switch (union2) {
					None(): {
						// name1 is a union, but name2 is a struct
						if (contains(unions2, name1)) {
							// name1 is a supertype of name2
							FiName1Supertype()
						} else {
							// name1 is a union, but name2 is not part of it. They are NOT related
							FiNotRelated();
						}
					}
					Some(u2): {
						// OK, both are unions.
						rel = getFiUnionRelation(env, u1, u2);
						rel;
					}
				}
			}
		}
	}
}

getFiUnionRelation(env : FcGlobalNames, union1 : FcTypeUnion, union2 : FcTypeUnion) -> FiTypeRelation {
	seenRelations = fold(union1.typenames, makeSet(), \seen : Set<FiTypeRelation>, tn : FcTypeName -> {
		rel = getFiTypenameRelation(env, tn.name, union2.name);
		insertSet(seen, rel);
	});

	seen = set2array(seenRelations);
	if (length(seen) == 1) seen[0]
	else if (seen == sort([FiNotRelated(), FiRelationEqual()])) {
		FiName2Supertype();
	} else if (seen == sort([FiName2Supertype(), FiNotRelated()])) {
		FiName2Supertype();
	} else {
		println("Resolve if this is possible for " + union1.name + " vs " + union2.name);
		println(set2array(seenRelations));
		FiNotRelated();
	}
}
