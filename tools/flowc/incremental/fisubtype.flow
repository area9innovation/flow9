import tools/flowc/incremental/fitype;
import ds/array;
import runtime;

export {
	isFiSubType(small : FiType, big : FiType) -> bool;
}

isFiSubType(small : FiType, big : FiType) -> bool {
    flowok = \ -> {
        small == FiTypeFlow() || small == big;
    }
	switch (big) {
		FiTypeVoid(): small == big;
		FiTypeBool(): flowok();
		FiTypeInt(): flowok();
		FiTypeDouble(): flowok();
		FiTypeString(): flowok();
		FiTypeArray(bt): switch (small) {
			FiTypeArray(st): isFiSubType(st, bt);
			default: flowok();
		}
		FiTypeFlow(): true;
		FiTypeNative(): small == big;
		FiTypeFunction(bargs, breturnType): {
			switch (small) {
				FiTypeFunction(sargs, sreturnType): {
					isFiSubType(sreturnType, breturnType)
					// Here, we reverse
					&& areFiSubTypes(map(bargs, \ba -> ba.type), map(sargs, \sa -> sa.type))
				}
				default: flowok();
			}
		}
		FiTypeRef(bt): switch (small) {
			FiTypeRef(st): {
				isFiSubType(st, bt)
			}
			default: false;
		}
		FiTypeParameter(bn): {
			switch (small) {
				// We just accept this
				FiTypeParameter(sn): true;
				default: flowok();
			}
		}
		FiTypeName(bname, btypeparameters): {
			switch (small) {
				FiTypeName(sname, stypeparameters): {
					if (sname == bname) {
						areFiSubTypes(stypeparameters, btypeparameters)
					} else {
						//println("TODO: Check that " + sname + " <= " + bname);
						true;
					}
				}
				default: flowok();
			}
		} 
	}
}

areFiSubTypes(small : [FiType], big : [FiType]) -> bool {
	length(small) == length(big)
	&& foldi(small, true, \i, acc, sa -> {
		acc && isFiSubType(sa, big[i])
	})
}
