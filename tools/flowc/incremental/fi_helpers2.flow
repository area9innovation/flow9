import tools/flowc/incremental/fi_helpers;
import tools/flowc/incremental/fi_type_unify;

export {
	// Use type parameters of type name in struct s (substitute into arguments)
	fiSpecializeStruct(tn: FiTypeName, s: FiTypeStruct) -> FiTypeStruct;

	// Use type parameters of type name in union s (substitute into all typenames of a union)
	fiSpecializeUnion(tn: FiTypeName, u: FiTypeUnion) -> FiTypeUnion;

	// Transform typename to FiTypeStruct with type parameters substituted
	fiTypeName2Struct(tn: FiTypeName, names: FiGlobalNames) -> FiTypeStruct;

	// Examine two cases of a typename: a struct and a union
	fiConsiderTypeName(tn: FiTypeName, names: FiGlobalNames, fn_struct: (FiTypeStruct) -> void, fn_union: (FiTypeUnion) -> void, err: (FiTypeName) -> void) -> void;

	// Map two cases of a typename: a struct and a union
	fiMapTypeName(tn: FiTypeName, names: FiGlobalNames, fn_struct: (FiTypeStruct) -> ?, fn_union: (FiTypeUnion) -> ?, err: (FiTypeName) -> ?) -> ?;

	// Get all typenames used in a struct or union definition
	fiStructOrUnionTypenames(tp: FiStructOrUnion, acc: Set<FiTypeName>) -> Set<FiTypeName>;

	// Get all typenames used in a type
	fiTypeTypenames(tp: FiType, acc: Set<FiTypeName>) -> Set<FiTypeName>;

	// Check if an expression is like:  `x.f1.f2.f3`
	fiExpIsNestedField(e: FiExp) -> bool;

	// Convert types to type parameters. Used to take typars of FiTypeStruct/FiTypeUnion.
	fiTypes2typars(ts: [FiType]) -> [FiTypeParameter];
}

fiSpecializeStruct(tn: FiTypeName, s: FiTypeStruct) -> FiTypeStruct {
	if (length(tn.typeparameters) != length(s.typars)) {
		fail0("length of struct typeparameters mismatch with length of typename typeparameters: " + i2s(length(s.typars)) + " != " + i2s(length(tn.typeparameters)) + " (length(tn.typeparameters))\n" +
			"struct: " + pretFiStructOrUnion(s) + ", typename: " + pretFiType(tn)
		);
	}
	typars_subst = foldi(s.typars, makeTree(), \i, acc, tp -> 
		switch (tp) {
			FiTypeParameter(nm): setTree(acc, nm, tn.typeparameters[i]);
			default: fail0("must be FiTypeParameter, got: " + toString(tp));
		}
	);
	FiTypeStruct(s with typars = tn.typeparameters,
		args = map(s.args, \arg ->
			FiStructArg(arg with type = fiApplyTypeSubstitution(typars_subst, arg.type))
		)
	);
}

fiSpecializeUnion(tn: FiTypeName, u: FiTypeUnion) -> FiTypeUnion {
	typars_subst = foldi(u.typeparameters, makeTree(), \i, acc, tp -> 
		switch (tp) {
			FiTypeParameter(nm): setTree(acc, nm, tn.typeparameters[i]);
			default: fail0("must be FiTypeParameter, got: " + toString(tp) + ", union: " + u.name);
		}
	);
	FiTypeUnion(u with typeparameters = tn.typeparameters,
		typenames = map(u.typenames, \t ->
			FiTypeName(t with 
				typeparameters = map(t.typeparameters, \x -> fiApplyTypeSubstitution(typars_subst, x))
			)
		)
	);
}

fiTypeName2Struct(tn: FiTypeName, names: FiGlobalNames) -> FiTypeStruct {
	switch (lookupTree(names.structs, tn.name)) {
		Some(struct): {
			fiSpecializeStruct(tn, struct);
		}
		None(): {
			fail0("struct expected, but " + tn.name + " is not found among structs");
		}
	}
}

fiConsiderTypeName(tn: FiTypeName, names: FiGlobalNames, fn_struct: (FiTypeStruct) -> void, fn_union: (FiTypeUnion) -> void, err: (FiTypeName) -> void) -> void {
	switch (lookupTree(names.structs, tn.name)) {
		Some(struct): {
			fn_struct(fiSpecializeStruct(tn, struct));
		}
		None(): {
			switch (lookupTree(names.unions, tn.name)) {
				Some(union): {
					fn_union(fiSpecializeUnion(tn, union));
				}
				None(): {
					err(tn);
				}
			}
		}
	}
}

fiMapTypeName(tn: FiTypeName, names: FiGlobalNames, fn_struct: (FiTypeStruct) -> ?, fn_union: (FiTypeUnion) -> ?, err: (FiTypeName) -> ?) -> ? {
	switch (lookupTree(names.structs, tn.name)) {
		Some(struct): {
			fn_struct(fiSpecializeStruct(tn, struct));
		}
		None(): {
			switch (lookupTree(names.unions, tn.name)) {
				Some(union): {
					fn_union(fiSpecializeUnion(tn, union));
				}
				None(): {
					err(tn);
				}
			}
		}
	}
}

fiStructOrUnionTypenames(type: FiStructOrUnion, acc: Set<FiTypeName>) -> Set<FiTypeName> {
	switch (type) {
		FiTypeUnion(__, typars, typenames,__): {
			fold(typenames,
				fold(typars, acc, \ac, tp -> fiTypeTypenames(tp, ac)),
				\ac, tn -> insertSet(ac, tn)
			);
		}
		FiTypeStruct(__, typars, args, __): {
			fold(args, 
				fold(typars, acc, \ac, tp -> fiTypeTypenames(tp, ac)), 
				\ac, arg -> fiTypeTypenames(arg.type, ac)
			);
		} 
	}
}

fiTypeTypenames(type: FiType, acc: Set<FiTypeName>) -> Set<FiTypeName> {
	switch (type) {
		FiTypeRef(rt): {
			fiTypeTypenames(rt, acc);
		}
		FiTypeArray(at): {
			fiTypeTypenames(at, acc);
		}
		FiTypeName(id, tp): {
			fold(tp, insertSet(acc, type), \ac, t -> fiTypeTypenames(t, ac));
		}
		FiTypeFunction(args, rt): {
			fiTypeTypenames(rt, fold(args, acc, \ac, arg -> fiTypeTypenames(arg.type, ac)));
		}
		FiTypeParameter(n): acc;
		FiTypeVoid():       acc;
		FiTypeBool():       acc;
		FiTypeInt():        acc;
		FiTypeDouble():     acc;
		FiTypeString():     acc;
		FiTypeFlow():       acc;
		FiTypeNative():     acc;
	}
}

fiExpIsNestedField(e: FiExp) -> bool {
	switch (e) {
		FiVar(__,__,__): true;
		FiCallPrim(op, es,__,__): {
			switch (op) {
				FcFieldPrim(__): fiExpIsNestedField(es[0]);
				default: false;
			}
		}
		default: false;
	}
}

fiTypes2typars(ts: [FiType]) -> [FiTypeParameter] {
	map(ts, \t -> switch (t) {
		FiTypeParameter(__): t;
		default: fail0("must be a type parameter, got: " + pretFiType(t));
	})
}