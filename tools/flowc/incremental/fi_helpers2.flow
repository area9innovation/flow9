import tools/flowc/incremental/fi_helpers;
import tools/flowc/incremental/fi_type_unify;

export {
	// Use type parameters of type name in struct s (substitute into arguments)
	fiSpecializeStruct(tn: FiTypeName, s: FiTypeStruct) -> FiTypeStruct;

	// Use type parameters of type name in union s (substitute into all typenames of a union)
	fiSpecializeUnion(tn: FiTypeName, u: FiTypeUnion) -> FiTypeUnion;

	// Transform typename to FiTypeStruct with type parameters substituted
	fiTypeName2Struct(tn: FiTypeName, names: FiGlobalNames) -> FiTypeStruct;

	// Examine two cases of a typename: a struct and a union
	fiConsiderTypeName(tn: FiTypeName, names: FiGlobalNames, fn_struct: (FiTypeStruct) -> void, fn_union: (FiTypeUnion) -> void, err: (FiTypeName) -> void) -> void;

	// Map two cases of a typename: a struct and a union
	fiMapTypeName(tn: FiTypeName, names: FiGlobalNames, fn_struct: (FiTypeStruct) -> ?, fn_union: (FiTypeUnion) -> ?, err: (FiTypeName) -> ?) -> ?;

	// Same as fiMapTypeName, but don't consider type parameters - use default from definition
	fiMapTypeWithName(name: string, names: FiGlobalNames, fn_struct: (FiTypeStruct) -> ?, fn_union: (FiTypeUnion) -> ?, err: (string) -> ?) -> ? ;

	// Get all typenames used in a struct or union definition
	fiStructOrUnionTypenames(tp: FiStructOrUnion, acc: Set<FiTypeName>) -> Set<FiTypeName>;

	// Get all typenames used in a type
	fiTypeTypenames(tp: FiType, acc: Set<FiTypeName>) -> Set<FiTypeName>;

	// Check if an expression is like:  `x.f1.f2.f3`
	fiExpIsNestedField(e: FiExp) -> bool;

	// Convert types to type parameters. Used to take typars of FiTypeStruct/FiTypeUnion.
	fiTypes2typars(ts: [FiType]) -> [FiTypeParameter];

	// Create a new variable with a given prefix not occurring in global names
	fiMakeNewVar(pref: string, v: string, locals: Tree<string, FiVar>, names: FiGlobalNames) -> string;

	// Create a new variable with a given prefix not occurring in global names starting with index i
	fiMakeNewVari(pref: string, v: string, locals: Tree<string, FiVar>, names: FiGlobalNames, i: int) -> string;

	// Sets a `start` field of an expression.
	fiSetExpStart(e : FiExp, s: int) -> FiExp;

	// Check if a struct belongs to switch case, recursively examining all union-cases.
	fiStructMatchesSwitchCase(struct: string, case: string, unions: Tree<string, FiTypeUnion>) -> bool;
}

fiSpecializeStruct(tn: FiTypeName, s: FiTypeStruct) -> FiTypeStruct {
	if (length(tn.typeparameters) != length(s.typars)) {
		fail("length of struct typeparameters mismatch with length of typename typeparameters: " + i2s(length(s.typars)) + " != " + i2s(length(tn.typeparameters)) + " (length(tn.typeparameters))\n" +
			"struct: " + pretFiStructOrUnion(s) + ", typename: " + pretFiType(tn)
		);
	}
	typars_subst = foldi(s.typars, makeTree(), \i, acc, tp -> 
		switch (tp) {
			FiTypeParameter(nm): setTree(acc, nm, tn.typeparameters[i]);
			default: fail0("must be FiTypeParameter, got: " + toString(tp));
		}
	);
	FiTypeStruct(s with typars = tn.typeparameters,
		args = map(s.args, \arg ->
			FiStructArg(arg with type = fiApplyTypeSubstitution(typars_subst, arg.type))
		)
	);
}

fiSpecializeUnion(tn: FiTypeName, u: FiTypeUnion) -> FiTypeUnion {
	typars_subst = foldi(u.typeparameters, makeTree(), \i, acc, tp -> 
		switch (tp) {
			FiTypeParameter(nm): setTree(acc, nm, tn.typeparameters[i]);
			default: fail0("must be FiTypeParameter, got: " + toString(tp) + ", union: " + u.name);
		}
	);
	FiTypeUnion(u with typeparameters = tn.typeparameters,
		typenames = map(u.typenames, \t ->
			FiTypeName(t with 
				typeparameters = map(t.typeparameters, \x -> fiApplyTypeSubstitution(typars_subst, x))
			)
		)
	);
}

fiTypeName2Struct(tn: FiTypeName, names: FiGlobalNames) -> FiTypeStruct {
	switch (lookupTree(names.structs, tn.name)) {
		Some(struct): {
			fiSpecializeStruct(tn, struct);
		}
		None(): {
			fail0("struct expected, but " + tn.name + " is not found among structs");
		}
	}
}

fiConsiderTypeName(tn: FiTypeName, names: FiGlobalNames, fn_struct: (FiTypeStruct) -> void, fn_union: (FiTypeUnion) -> void, err: (FiTypeName) -> void) -> void {
	switch (lookupTree(names.structs, tn.name)) {
		Some(struct): {
			fn_struct(fiSpecializeStruct(tn, struct));
		}
		None(): {
			switch (lookupTree(names.unions, tn.name)) {
				Some(union): {
					fn_union(fiSpecializeUnion(tn, union));
				}
				None(): {
					err(tn);
				}
			}
		}
	}
}

fiMapTypeName(tn: FiTypeName, names: FiGlobalNames, fn_struct: (FiTypeStruct) -> ?, fn_union: (FiTypeUnion) -> ?, err: (FiTypeName) -> ?) -> ? {
	switch (lookupTree(names.structs, tn.name)) {
		Some(struct): {
			fn_struct(fiSpecializeStruct(tn, struct));
		}
		None(): {
			switch (lookupTree(names.unions, tn.name)) {
				Some(union): {
					fn_union(fiSpecializeUnion(tn, union));
				}
				None(): {
					err(tn);
				}
			}
		}
	}
}

fiMapTypeWithName(name: string, names: FiGlobalNames, fn_struct: (FiTypeStruct) -> ?, fn_union: (FiTypeUnion) -> ?, err: (string) -> ?) -> ? {
	switch (lookupTree(names.structs, name)) {
		Some(struct): {
			fn_struct(struct);
		}
		None(): {
			switch (lookupTree(names.unions, name)) {
				Some(union): {
					fn_union(union);
				}
				None(): {
					err(name);
				}
			}
		}
	}
}

fiStructOrUnionTypenames(type: FiStructOrUnion, acc: Set<FiTypeName>) -> Set<FiTypeName> {
	switch (type) {
		FiTypeUnion(__, typars, typenames,__): {
			fold(typenames,
				fold(typars, acc, \ac, tp -> fiTypeTypenames(tp, ac)),
				\ac, tn -> insertSet(ac, tn)
			);
		}
		FiTypeStruct(__, typars, args, __): {
			fold(args, 
				fold(typars, acc, \ac, tp -> fiTypeTypenames(tp, ac)), 
				\ac, arg -> fiTypeTypenames(arg.type, ac)
			);
		} 
	}
}

fiTypeTypenames(type: FiType, acc: Set<FiTypeName>) -> Set<FiTypeName> {
	switch (type) {
		FiTypeRef(rt): {
			fiTypeTypenames(rt, acc);
		}
		FiTypeArray(at): {
			fiTypeTypenames(at, acc);
		}
		FiTypeName(id, tp): {
			fold(tp, insertSet(acc, type), \ac, t -> fiTypeTypenames(t, ac));
		}
		FiTypeFunction(args, rt): {
			fiTypeTypenames(rt, fold(args, acc, \ac, arg -> fiTypeTypenames(arg.type, ac)));
		}
		FiTypeParameter(n): acc;
		FiTypeVoid():       acc;
		FiTypeBool():       acc;
		FiTypeInt():        acc;
		FiTypeDouble():     acc;
		FiTypeString():     acc;
		FiTypeFlow():       acc;
		FiTypeNative():     acc;
	}
}

fiExpIsNestedField(e: FiExp) -> bool {
	switch (e) {
		FiVar(__,__,__): true;
		FiCallPrim(op, es,__,__): {
			switch (op) {
				FcFieldPrim(__): fiExpIsNestedField(es[0]);
				default: false;
			}
		}
		default: false;
	}
}

fiTypes2typars(ts: [FiType]) -> [FiTypeParameter] {
	map(ts, \t -> switch (t) {
		FiTypeParameter(__): t;
		default: fail0("must be a type parameter, got: " + pretFiType(t));
	})
}

fiMakeNewVar(pref: string, v: string, locals: Tree<string, FiVar>, names: FiGlobalNames) -> string {
	fiMakeNewVari(pref, v, locals, names, 0);
}

fiMakeNewVari(pref: string, v: string, locals: Tree<string, FiVar>, names: FiGlobalNames, i: int) -> string {
	w = pref + v + "_" + i2s(i);
	if (!containsKeyTree(locals, w) && !containsKeyTree(names.toplevel, w)) w else fiMakeNewVari(pref, v, locals, names, i + 1);
}

fiSetExpStart(e : FiExp, s: int) -> FiExp {
	switch(e) {
		FiLambda(__,__,__, __):   FiLambda(e with start = s);
		FiCall(__,__,__,__):      FiCall(e with start = s);
		FiLet(__,__,__,__,__,__): FiLet(e with start = s);
		FiIf(__,__,__,__, __):    FiIf(e with start = s);
		FiSwitch(__,__,__,__,__): FiSwitch(e with start = s);
		FiCast(__,__,__,__,__):   FiCast(e with start = s);
		FiSeq(__,__,__):          FiSeq(e with start = s);
		FiCallPrim(__,__,__,__):  FiCallPrim(e with start = s);
		FiRequire(__,__,__,__):   FiRequire(e with start = s);
		FiUnsafe(__,__,__,__):    FiUnsafe(e with start = s);
		FiVar(__,__,__):          FiVar(e with start = s);
		FiVoid(__):       FiVoid(e with start = s);
		FiDouble(__,__):  FiDouble(e with start = s);
		FiInt(__,__):     FiInt(e with start = s);
		FiString(__,__):  FiString(e with start = s);
		FiBool(__,__):    FiBool(e with start = s);
	}
}

fiStructMatchesSwitchCase(struct: string, case: string, unions: Tree<string, FiTypeUnion>) -> bool {
	(struct == case) || switch (lookupTree(unions, case)) {
		Some(union): {
			exists(union.typenames, \tn -> fiStructMatchesSwitchCase(struct, tn.name, unions));
		}
		None(): false;
	}
}
