import tools/flowc/flowc_typecheck;

export {
	fcPrintOutline(config : CompilerConfig, globEnv : FcTypeEnvGlobal, showStopper : (int) -> void) -> void;
}

fcPrintOutline(config : CompilerConfig, globEnv : FcTypeEnvGlobal, showStopper : (int) -> void) -> void {
	parsed = parseFlowFileOrLoadCached(config, globEnv, config.flowfile, "", 0, 0);
	fcacc = prepareInitialFlowcAcc(config);
	if (parsed.second == dummyFcError) {
		switch (parsed.first) {
			FcParsed(fileinfo, syntaxtree, __, __, __): {
				fcmodule = desugarFcModule(fcacc, initFcTypeEnvLocal(), fileinfo, syntaxtree);
				fcPrintOutlineOfFcModule(config, globEnv, fcmodule);
			}
			FcLoaded(fimodule, __): {
				fcPrintOutlineOfFiModule(config, globEnv, fimodule);
			}
		}
	} else {
		printFcError(fcacc, globEnv, parsed.second);
	}
	// Deferred task to load and typecheck file. The main goal is to store it in the cache, so result is ignored.
	deferred(\-> { parseAndTypecheckProgram(config, globEnv, config.flowfile); {} });
	showStopper(0)
}

fcPrintOutlineOfFiModule(config : CompilerConfig, env : FcTypeEnvGlobal, module : FiModule) -> void {
	fileinfo = module.fileinfo;
	code = fcFileSource(env, fileinfo.fullpath);
	declStarts =
	fold(module.functions,
		fold(module.globalVars,
			fold(module.natives,
				makeTree(),
				\acc, nat -> setTree(acc, nat.name, nat.declStart)
			),
			\acc, var -> setTree(acc, var.name, var.declStart)
		),
		\acc, fun -> setTree(acc, fun.name, fun.declStart)
	);
	print_id = \pos, msg -> {
		switch (getFcInfo2ByPos(pos + 7, code)) {
			Some(i): printLocation(config, env, fileinfo, i.start, i.end, msg);
			None():  printLocation(config, env, fileinfo, pos, -1, msg);
		}
	};
	print_path = \pos, msg -> {
		switch (getFcInfo2ByPos2(pos, "/\\.-", code)) {
			Some(i): printLocation(config, env, fileinfo, i.start, i.end, msg);
			None():  printLocation(config, env, fileinfo, pos, -1, msg);
		}
	};
	iter(module.imports, \imp -> print_path(imp.start, "import " + imp.flowfile));
	iter(module.forbids, \fbd -> print_path(fbd.start, "forbid " + fbd.flowfile));
	iter(module.structs, \str -> print_id(str.start, "struct " + str.name));
	iter(module.unions,  \uni -> print_id(uni.start, "union " + uni.name));

	iter(module.functions, \fun -> {
		print_id(fun.defiStart, "fundef " + fun.name);
		if (fun.declStart != fun.defiStart) {
			print_id(fun.declStart, "fundecl " + fun.name);
		}
	});

	iter(module.globalVars, \var -> {
		print_id(var.defiStart, "vardef " + var.name);
		if (var.declStart != var.defiStart) {
			print_id(var.declStart, "vardecl " + var.name);
		}
	});

	iter(module.natives, \nat -> {
		print_id(nat.defiStart, "natdef " + nat.name);
		if (nat.declStart != nat.defiStart) {
			print_id(nat.declStart, "natdecl " + nat.name);
		}
	});
}

fcPrintOutlineOfFcModule(config : CompilerConfig, env : FcTypeEnvGlobal, module : FcModule) -> void {
	fileinfo = fcfileinfo2fi(module.fileinfo);
	code = fcFileSource(env, fileinfo.fullpath);
	declStarts =
	foldTree(module.functions,
		foldTree(module.globalVars,
			foldTree(module.natives,
				makeTree(),
				\name, nat, acc -> setTree(acc, name, nat.info.start)
			),
			\name, var, acc -> setTree(acc, name, var.declInfo.start)
		),
		\name, fun, acc -> setTree(acc, name, fun.declInfo.start)
	);
	print_id = \pos, msg -> {
		switch (getFcInfo2ByPos(pos, code)) {
			Some(i): printLocation(config, env, fileinfo, i.start, i.end, msg);
			None():  printLocation(config, env, fileinfo, pos, -1, msg);
		}
	};
	print_path = \pos, msg -> {
		switch (getFcInfo2ByPos2(pos, "/\\.-", code)) {
			Some(i): printLocation(config, env, fileinfo, i.start, i.end, msg);
			None():  printLocation(config, env, fileinfo, pos, -1, msg);
		}
	};
	iter(module.imports, \imp -> print_path(imp.start, "import " + imp.flowfile));
	iter(module.forbids, \fbd -> print_path(fbd.start, "forbid " + fbd.flowfile));
	traverseInOrder(module.structs, \name, str -> print_id(str.info.start, "struct " + name));
	traverseInOrder(module.unions, \name, uni -> print_id(uni.info.start, "union " + name));

	traverseInOrder(module.functions, \name, fun -> {
		print_id(fun.defiInfo.start, "fundef " + name);
		if (fun.declInfo.start != fun.defiInfo.start) {
			print_id(fun.declInfo.start, "fundecl " + name);
		}
	});

	traverseInOrder(module.globalVars, \name, var -> {
		print_id(var.bodyInfo.start, "vardef " + name);
		if (var.declInfo.start != var.bodyInfo.start) {
			print_id(var.declInfo.start, "vardecl " + name);
		}
	});

	traverseInOrder(module.natives, \name, nat -> {
		print_id(nat.info.start, "natdecl " + name);
		switch (nat.flowfallback) {
			Some(func): {
				print_id(func.defiInfo.start, "natdef " + name);
			}
			None(): { }
		}
	});
}
