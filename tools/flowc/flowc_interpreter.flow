import tools/flowc/eval;
import tools/flowc/flowc_typecheck;
import tools/flowc/manipulation/deadcode;
import tools/flowc/manipulation/compile_time;
import tools/flowc/manipulation/tail_call;

export {
	fcInterpret(config : CompilerConfig) -> void;
}

fcInterpret(conf : CompilerConfig) -> void {
	working_dir = getConfigParameter(conf.config, "working-dir");
	run_file = getConfigParameter(conf.config, "run");
	run_flowfile = trimFlowfile(findFlowPath(run_file, true, conf.includes, working_dir), conf.includes, working_dir);

	run_config = CompilerConfig(conf with 
		config = setTree(conf.config, "file", run_file),
		flowfile = run_flowfile
	);
	globEnv = initFcTypeEnvGlobal();
	pair = parseAndTypecheckProgram(run_config, globEnv, run_config.flowfile);
	program1 = substituteCompileTimeValues(pair.first, \err -> printFcError(run_config, globEnv, err));
	program = deadFiCode(program1, collectFiEffects(program1), makeSet1("for"), makeSet(), false, true, conf.verbose);
	optimzied = fcOptimizeTailCalls(program);
	if (pair.second == 0) {
		globals = fcInitEvalGlobals(optimzied, fail, globEnv);
		ret = fcCallFunctionByName("main", [], globals);
		if (getDataTagForValue(ret) == string_data_tag) {
			err = cast(ret : flow -> string);
			fcPrintln("Runtime error occured: " + err, conf.threadId);
			quit(1);
		} else if (getDataTagForValue(ret) == void_data_tag) {
			// Normal exit status
		} else {
			fcPrintln("main function must return void, but returned '" + toString(ret) + "'", conf.threadId);
			quit(1);
		}
	} else {
		// Some errors in a code
		quit(1);
	}
}