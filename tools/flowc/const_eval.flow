import tools/flowc/eval;
import tools/flowc/manipulation/common;
import tools/flowc/manipulation/freevars;
import tools/flowc/manipulation/effects;
import tools/flowc/manipulation/tail_call;

export {
	FcConstEvalVal(
		val: flow,  // The value of a constant
		exp: FiExp, // Corresponding expression
		plain: bool // Indicates, that this value was directly constructed from arguments, not really computed
	);

	FcConstEvalEnv(
		structs: HashMap<string, FiTypeStruct>,
		unions:  HashMap<string, FiTypeUnion>,
		consts:  Tree<string, FcConstEvalVal>,
		globals: HashMap<string, FcEvalGlobal>,
		effects: FiEffects,
		errors: ref [Pair<string, [int]>]
	);

	// Setup the global variables and toplevel functions for the evaluation of compile time constants.
	fcInitConstEvalEnv(program: FiProgram, on_err: (FcError) -> void) -> FcConstEvalEnv;

	// Try to compute a compile-time value of an expression.
	fcConstEval(ex : FiExp,
		env: FcConstEvalEnv,
		cache: HashMap<int, Maybe<FcConstEvalVal>>,
		locals: Set<string>,
		on_err: (string, [int]) -> void,
		on_msg: (string) -> void,
		debug: bool
	) -> Maybe<FcConstEvalVal>;

	// Remove all speculative compile-time function wrappers: `outputCompileTimeEval`,`forbidCompileTimeEval` and `forceCompileTimeEval`.
	fcEliminateCompileTimeFns(prog: FiProgram) -> FiProgram;
}

fcConstEvalPureToplevels(prog: FiProgram, effects: FiEffects) -> FiProgram {
	exclude = getConfigParameter(prog.config.config, "do-not-const-eval");
	exclude_set = if (exclude == "") makeSet() else buildSet(strSplit(exclude, ","));
	fiMapProgramToplevel(prog, \toplevel, m, p ->
		if (toplevel.name == "main" || containsSet(exclude_set, toplevel.name)) [] else {
			switch (toplevel) {
				FiTypeStruct(name,__,fields,__): {
					if (exists(fields, \f -> f.ismutable)) [] else [toplevel];
				}
				FiTypeUnion(__,__,__,__): {
					[toplevel];
				}
				FiGlobalVar(name,__,__,__,__): {
					if (containsSet(effects.hasEffects, name)) [] else [toplevel];
				}
				FiFunctionDec(name,__,__,__,__): {
					if (containsSet(effects.hasEffects, name)) [] else [toplevel];
				}
				FiNativeDec(name, io,__,nativeName,__,__,__): {
					if (io || !(hostCallExists(nativeName) || hostCallExists(name))) [] else [toplevel];
				}
			}
		}, fcParallelOn(prog.config)
	);
}

fcEliminateCompileTimeFns(prog: FiProgram) -> FiProgram {
	fiMapProgramExp(prog, \x, __,__,__ ->
		mapFiExp(x, \e -> switch (e) {
			FiCall(f, args,__,__): {
				switch (f) {
					FiVar(fn_name,__,__): {
						if (fn_name == "outputCompileTimeEval") args[1] else
						if (fn_name == "forbidCompileTimeEval" || fn_name == "forceCompileTimeEval") args[0] else
						e;
					}
					default: e;
				}
			}
			default: e;
		}
	), fcParallelOn(prog.config));
}

fcInitConstEvalEnv(prog: FiProgram, on_err: (FcError) -> void) -> FcConstEvalEnv {
	effects = collectFiEffectsPrecisely(prog);
	const_prog = fcOptimizeTailCalls(fcConstEvalPureToplevels(prog, effects));
	if (isConfigParameterTrue(const_prog.config.config, "dump-pure-toplevels")) {
		pure_toplevels = list2array(fiFoldProgramToplevel(const_prog, makeList(), \top,__,__,acc -> switch (top) {
			FiDeclaration(): Cons(top.name, acc);
			default: acc;
		}));
		fcPrintln("Pure toplevels:\n" + strIndent(strGlue(pure_toplevels, "\n")), const_prog.config.threadId);
	}
	if (isConfigParameterTrue(const_prog.config.config, "dump-pure-natives")) {
		pure_natives = list2array(fiFoldProgramToplevel(const_prog, makeList(), \top,__,__,acc -> switch (top) {
			FiNativeDec(__,__,__,__,__,__,__): Cons(top.name + ": " + top.nativeName, acc);
			default: acc;
		}));
		fcPrintln("Pure natives:\n" + strIndent(strGlue(pure_natives, "\n")), const_prog.config.threadId);
	}
	errors = ref [];
	on_msg = \msg -> fcPrintln(msg, const_prog.config.threadId);
	optimzie_debug = getConfigParameter(const_prog.config.config, "optimize-debug");
	fold(const_prog.traversal,
		FcConstEvalEnv(
			tree2hashMap(const_prog.names.structs, fastHashString),
			tree2hashMap(const_prog.names.unions, fastHashString),
			makeTree(), fcInitEvalGlobals(const_prog, Some(prog), nop1), effects,
			errors
		),
		\acc, mod_name -> eitherMap(lookupTree(const_prog.modules, mod_name),
			\m -> {
				m_on_err = \msg, ps -> {
					err = FcError(msg, map(ps, \p -> FcPosition(m.fileinfo.flowfile, p, p)));
					refArrayPush(errors, Pair(msg, ps));
					on_err(err);
				}
				fold(m.initOrder, acc,
					\ac, name -> eitherMap(lookupTree(const_prog.names.toplevel, name), \decl ->
						switch (decl) {
							FiGlobalVar(__, value, type,__,pos): {
								switch (fcConstEval(value, ac, makeHashMap(idfn), makeSet(), m_on_err, on_msg, decl.name == optimzie_debug)) {
									Some(cv): {
										if (decl.name == optimzie_debug) {
											fcPrintln(
												"Optimization of global variable:\n" +
													strIndent(pretFiExp(value)) + "\n" +
												"ended up with:\n" + 
													strIndent(pretFiExp(cv.exp)),
												const_prog.config.threadId
											);
										}
										FcConstEvalEnv(ac with
											consts = setTree(ac.consts, name,
												if (fiTypeIsFunction(type)) cv else
												FcConstEvalVal(cv with exp = FiVar(name, type, pos), plain = true)
											)
										);
									}
									None(): ac;
								}
							}
							default: ac;
						}, ac
					)
				)
			}, acc
		)
	);
}

fiComplexConstant2flow(ex : FiExp, env: FcConstEvalEnv, on_err: (string, [int]) -> void) -> Maybe<flow> {
	switch (ex) {
		FiVoid(__):       Some(flow(voidValue()));
		FiBool(b1, __):   Some(flow(b1));
		FiInt(i1, __):    Some(flow(i1));
		FiDouble(d1, __): Some(flow(d1));
		FiString(s1, __): Some(flow(s1));
		FiCallPrim(op, es,__,s): {
			switch (op) {
				FcArrayPrim(): {
					arr = filtermap(es, \x -> fiComplexConstant2flow(x, env, on_err));
					if (length(arr) != length(es)) None() else Some(flow(arr));
				}
				FcStructPrim(name): {
					fields = filtermap(es, \x -> fiComplexConstant2flow(x, env, on_err));
					if (length(fields) != length(es) || !containsKeyHashMap(env.structs, name)) None() else {
						fcEvalMakeStruct(name, fields, IllegalStruct(), env.structs);
					}
				}
				default: None();
			}
		}
		FiLambda(args, body,__,__): {
			fcMakeFnFromLambda(ex, env.structs, env.globals, None(), on_err);
		}
		default: None();
	}
}

fiflow2ComplexConstant(v : flow, env: FcConstEvalEnv) -> Maybe<FiExp> {
	v_tag = getDataTagForValue(v);
	if (v_tag == void_data_tag) Some(FiVoid(-1)) else
	if (v_tag == bool_data_tag) Some(FiBool(cast(v: flow -> bool), -1)) else
	if (v_tag == int_data_tag) Some(FiInt(cast(v: flow -> int), -1)) else
	if (v_tag == double_data_tag) Some(FiDouble(cast(v: flow -> double), -1)) else
	if (v_tag == string_data_tag) Some(FiString(cast(v: flow -> string), -1)) else
	if (v_tag == array_data_tag) {
		arr_f = cast(v: flow -> [flow]);
		arr = filtermap(arr_f, \x -> fiflow2ComplexConstant(x, env));
		if (length(arr_f) != length(arr)) None() else {
			Some(FiCallPrim(FcArrayPrim(), arr, FiTypeVoid(), -1));
		}
	} else 
	if (v_tag == struct_data_tag) {
		maybeBind(fcEvalDecomposeStruct(v), \p -> {
			name = p.first;
			if (name == "" || !containsKeyHashMap(env.structs, name)) None() else {
				fields_f = p.second;
				fields = filtermap(fields_f, \x -> fiflow2ComplexConstant(x, env));
				if (length(fields_f) != length(fields)) None() else {
					Some(FiCallPrim(FcStructPrim(name), fields, FiTypeVoid(), -1));
				}
			}
		});
	} else {
		None();
	}
}

fiCompleteType(e: FiExp, hint: Maybe<FiType>, env: FcConstEvalEnv) -> Maybe<FiExp> {
	switch (e) {
		FiCallPrim(op, as,__,s): {
			switch (op) {
				FcArrayPrim(): {
					do_flow = \ -> {
						as1 = filtermap(as, \a -> fiCompleteType(a, None(), env));
						if (length(as1) == 0 || length(as1) != length(as)) None() else {
							at = fiExpType(as1[0]);
							if (exists(tail(as1), \x -> !fiEqualTypes(at, fiExpType(x)))) None() else {
								Some(FiCallPrim(e with type = FiTypeArray(at), es = as1));
							}
						}
					}
					switch (hint) {
						Some(t): {
							switch (t) {
								FiTypeArray(at): {
									es1 = filtermap(as, \a -> fiCompleteType(a, Some(at), env));
									if (length(es1) != length(as)) None() else {
										Some(FiCallPrim(e with type = t, es = es1));
									}
								}
								FiTypeFlow(): do_flow();
								default: None();
							}
						}
						None(): do_flow();
					}
				}
				FcStructPrim(name): {
					do_flow = \ -> {
						maybeBind(lookupHashMap(env.structs, name), \struct -> {
							as1 = filtermap(as, \a -> fiCompleteType(a, None(), env));
							if (length(as1) != length(struct.args)) None() else {
								sub = foldi(struct.args, makeTree(), \i, acc, arg ->
									fiMatchTypars(arg.type, fiExpType(as1[i]), acc)
								);
								Some(FiCallPrim(e with
									type = FiTypeName(name, map(struct.typars, \tp ->
										fiSubstituteTypars(tp, sub)
									)),
									es = as1
								));
							}
						});
					}
					switch (hint) {
						Some(t): {
							switch (t) {
								FiTypeName(type_name, typars): {
									do_struct = \tn -> maybeBind(lookupHashMap(env.structs, tn.name), \struct ->  {
										sub = fiMatchTyparsArr(struct.typars, tn.typeparameters, makeTree());
										es1 = filtermapi(as, \i, a ->
											fiCompleteType(a, Some(fiSubstituteTypars(struct.args[i].type, sub)), env)
										);
										if (length(es1) != length(as)) None() else {
											Some(FiCallPrim(e with type = tn, es = es1));
										}
									});
									if (name == type_name) do_struct(t) else {
										maybeBind(lookupHashMap(env.unions, type_name), \union -> {
											maybeBind(find(union.typenames, \tn -> tn.name == name), \tn -> {
												sub = fiMatchTyparsArr(union.typeparameters, typars, makeTree());
												tn_spec = FiTypeName(tn with typeparameters = map(tn.typeparameters, \tp ->
													fiSubstituteTypars(tp, sub)
												));
												do_struct(tn_spec);
											})
										});
									}
								}
								FiTypeFlow(): do_flow();
								default: None();
							}
						}
						None(): do_flow();
					}
				}
				default: Some(e);
			}
		}
		default: Some(e);
	}
}

fcConstEval(ex : FiExp,
	env: FcConstEvalEnv,
	cache: HashMap<int, Maybe<FcConstEvalVal>>,
	locals: Set<string>,
	on_err: (string, [int]) -> void,
	on_msg: (string) -> void,
	debug: bool
) -> Maybe<FcConstEvalVal> {
	switch (lookupHashMap(cache, ex.start)) {
		Some(x): x;
		None(): {
			ret = fcDoConstEval(ex, env, cache, locals, on_err, on_msg, debug);
			if (ex.start >= 0) {
				setHashMap(cache, ex.start, ret);
			}
			ret;
		}
	}
}

const_eval_debug_counter = ref 0;

fcConstEvalUnwrapLambda(x: FiExp) -> Maybe<FiLambda> {
	switch (x) {
		FiLambda(__,__,__,__): Some(x);
		FiLet(__,__,__,e,__,__): fcConstEvalUnwrapLambda(e);
		default: None();
	}
}

fcDoConstEval(ex : FiExp,
	env: FcConstEvalEnv,
	cache: HashMap<int, Maybe<FcConstEvalVal>>,
	locals: Set<string>,
	on_err: (string, [int]) -> void,
	on_msg: (string) -> void,
	debug: bool
) -> Maybe<FcConstEvalVal> {
	if (debug) {
		const_eval_debug_counter := ^const_eval_debug_counter + 1;
	}
	rec = \x -> fcConstEval(x, env, cache, locals, on_err, on_msg, debug);
	ret = switch (ex) {
		FiLambda(args, body,__,__): {
			free = filter(set2array(fifreevars(ex)), \v -> !containsKeyHashMap(env.globals, v));
			const_closure = filtermap(free, \v ->
				maybeBind(lookupTree(env.consts, v), \c ->
					fiflow2ComplexConstant(c.val, env)
				)
			);
			if (length(const_closure) != length(free) || hasFiSideEffects(env.effects, body)) None() else {
				ex_c = FiLambda(ex with
					body = foldi(free, body, \i, acc, x ->
						if (fiTypeIsFunction(fiExpType(const_closure[i]))) acc else
						fiReplaceVar(acc, x, const_closure[i]))
				);
				maybeMap(fcMakeFnFromLambda(ex_c, env.structs, env.globals, None(), on_err),
					\fn -> FcConstEvalVal(fn, ex_c, false)
				);
			}
		}
		FiCall(f, args, type, pos): {
			do_job = \ -> {
				r_args = map(args, rec);
				c_args = filtermap(r_args, idfn);
				if (length(c_args) != length(args)) {
					switch (f) {
						FiVar(x,__,__): {
							if (x == "outputCompileTimeEval") {
								// Output the result of non-successfull compile-time computation
								msg = eitherMap(r_args[0], \arg -> switch (arg.exp) {
									FiString(msg,__): msg;
									default: pretFiExp(arg.exp);
								}, pretFiExp(args[0]));
								val = eitherMap(r_args[1],
									\arg -> either(fiflow2ComplexConstant(arg.val, env), arg.exp),
									args[1]
								);
								on_msg(msg + pretFiExp(val));
							} else if (x == "forceCompileTimeEval") {
								// raise an error
								on_err(
									"Expression was not computed at compile-time:\n" + pretFiExp(args[0]),
									//+ "\nconsts:\n" + strIndent(superglue(tree2pairs(env.consts), \p -> p.first + " => " + pretFiExp(p.second.exp) + " == " + toString(p.second.val), "\n")),
									[pos]
								);
							}
						}
						default: { }
					}
					None();
				} else {
					do_call = \fn -> maybeBind(fn, \cf -> 
						maybeBind(fcConstEvalUnwrapLambda(cf.exp), \lambda ->
							fcConstEval(
								lambda.body,
								FcConstEvalEnv(env with
									consts = foldi(c_args, env.consts, \i, acc, x -> setTree(acc, lambda.args[i].name, x))
								),
								makeHashMap(idfn),
								fold(lambda.args, locals, \acc, arg -> insertSet(acc, arg.name)),
								on_err, on_msg, debug
							)
						)
					);
					switch (f) {
						FiVar(x,__,__): {
							if (x == "outputCompileTimeEval") {
								msg = switch (c_args[0].exp) {
									FiString(m,__): m;
									default: pretFiExp(c_args[0].exp);
								}
								val = either(fiflow2ComplexConstant(c_args[1].val, env), c_args[1].exp);
								on_msg(msg + pretFiExp(val));
								Some(c_args[1]);
							} else {
								if (containsKeyHashMap(env.globals, x) && !containsSet(locals, x)) {
									env.errors := [];
									f_args = map(c_args, \arg -> arg.val);
									maybeBind(
										fcCallFunctionByName(x, f_args, env.structs, env.globals, \err, ps -> 
											refArrayPush(env.errors, Pair(err, arrayPush(ps, pos)))
										),
										\val -> if (length(^(env.errors)) == 0) {
											// No errors - ok.
											maybeBind(fiflow2ComplexConstant(val, env), \v ->
												maybeMap(
													fiCompleteType(v, Some(type), env),
													\e -> FcConstEvalVal(val, e, false)
												)
											);
										} else {
											// Some errors - not ok.
											//iter(^(env.errors), \p -> on_err("AAA: " + p.first, p.second));
											None();
										}
									);
								} else {
									do_call(lookupTree(env.consts, x));
								}
							}
						}
						default: do_call(rec(f));
					}
				}
			}
			switch (f) {
				FiVar(x,__,__): {
					if (x == "forbidCompileTimeEval") {
						if (args[0].start >= 0) {
							setHashMap(cache, args[0].start, None());
						}
						None();
					} else {
						do_job();
					}
				}
				default: do_job();
			}
		}
		FiVar(x, type, pos): {
			switch (type) {
				FiTypeFunction(__,__): None();
				default: lookupTree(env.consts, x);
			}
		}
		FiLet(x, type, e1, e2, type2, pos): {
			maybeBind(rec(e1), \ce1 ->
				maybeMap(
					fcConstEval(e2,
						FcConstEvalEnv(env with
							consts = setTree(env.consts, x,
								if (fiTypeIsFunction(type)) ce1 else
								FcConstEvalVal(ce1 with exp = FiVar(x, type, pos), plain = true)
							)
						),
						cache,
						insertSet(locals, x),
						on_err, on_msg, debug
					),
					\ce2 -> FcConstEvalVal(ce2 with exp = FiLet(ex with e1 = ce1.exp, e2 = ce2.exp))
				)
			);
		}
		FiIf(e1, e2, e3, __,__): {
			maybeBind(rec(e1), \ce1 -> if (getDataTagForValue(ce1.val) != bool_data_tag) None() else {
				if (cast(ce1.val: flow -> bool)) rec(e2) else rec(e3);
			});
		}
		FiSwitch(v,__,cs,__,pos): {
			maybeBind(rec(v), \cs1 -> switch (cs1.exp) {
				FiCallPrim(op, fields_exps, type, s): {
					switch (op) {
						FcStructPrim(name): {
							switch (find(cs, \c -> c.struct == name)) {
								Some(case): {
									field_vals = fcEvalExtractStructArguments(cs1.val); 
									fcConstEval(case.body,
										FcConstEvalEnv(env with
											consts = foldi(case.argNames, env.consts, \i, acc, arg ->
												if (arg != "__") setTree(acc, arg, FcConstEvalVal(field_vals[i], fields_exps[i], false)) else acc
											)
										),
										cache,
										fold(case.argNames, locals, \acc, arg -> insertSet(acc, arg)),
										on_err, on_msg, debug
									);
								}
								None(): {
									switch (find(cs, \c -> c.struct == "default")) {
										Some(def): rec(def.body);
										None(): None();
									}
								}
							}
						}
						default: None();
					}
				}
				default: None();
			});
		}
		FiCast(e, from, to,__,__): {
			maybeBind(rec(e), \ce ->
				if (fiEqualTypes(from, to)) Some(ce) else fcConstEvalCast(ce, from, to)
			);
		}
		FiSeq(es,__,__): {
			iter(es, \x -> ignore(rec(x)));
			if (length(es) != 1) None() else rec(es[0]);
		}
		FiCallPrim(op, es, __,__): {
			args = filtermap(es, rec);
			if (length(args) != length(es)) None() else {
				fcConstEvalCallPrim(ex, args, env, on_err, cache);
			}
		}
		FiBool(v,__): Some(FcConstEvalVal(v, ex, true));
		FiInt(v,__): Some(FcConstEvalVal(v, ex, true));
		FiDouble(v,__): Some(FcConstEvalVal(v, ex, true));
		FiString(v,__): Some(FcConstEvalVal(v, ex, true));
		default: None();
	}
	/**if (debug) {
		println(i2s(^const_eval_debug_counter) + ") const-eval of:\n" + strIndent(pretFiExp(ex)) + "\n" +
			"ended with:\n" + strIndent(eitherMap(ret, \r -> pretFiExp(r.exp), "NONE")) + "\n"
		);
	}*/
	ret;
}

fcConstEvalCast(ce: FcConstEvalVal, from: FiType, to: FiType) -> Maybe<FcConstEvalVal> {
	switch (ce.exp) {
		FiBool(b, s): {
			switch (to) {
				FiTypeInt(): {
					v = b2i(b);
					Some(FcConstEvalVal(flow(v), FiInt(v, s), false));
				}
				FiTypeDouble(): {
					v = b2d(b);
					Some(FcConstEvalVal(flow(v), FiDouble(v, s), false));
				}
				FiTypeString(): {
					v = b2s(b);
					Some(FcConstEvalVal(flow(v), FiString(v, s), false));
				}
				default: None();
			}
		}
		FiInt(i, s): {
			switch (to) {
				FiTypeBool(): {
					v = i2b(i);
					Some(FcConstEvalVal(flow(v), FiBool(v, s), false));
				}
				FiTypeDouble(): {
					v = i2d(i);
					Some(FcConstEvalVal(flow(v), FiDouble(v, s), false));
				}
				FiTypeString(): {
					v = i2s(i);
					Some(FcConstEvalVal(flow(v), FiString(v, s), false));
				}
				default: None();
			}
		}
		FiDouble(d, s): {
			switch (to) {
				FiTypeBool(): {
					v = d != 0.0;
					Some(FcConstEvalVal(flow(v), FiBool(v, s), false));
				}
				FiTypeInt(): {
					v = round(d);
					Some(FcConstEvalVal(flow(v), FiInt(v, s), false));
				}
				FiTypeString(): {
					v = d2s(d);
					Some(FcConstEvalVal(flow(v), FiString(v, s), false));
				}
				default: None();
			}
		}
		FiString(x, s): {
			switch (to) {
				FiTypeBool(): {
					v = s2b(x);
					Some(FcConstEvalVal(flow(v), FiBool(v, s), false));
				}
				FiTypeInt(): {
					v = s2i(x);
					Some(FcConstEvalVal(flow(v), FiInt(v, s), false));
				}
				FiTypeDouble(): {
					v = s2d(x);
					Some(FcConstEvalVal(flow(v), FiDouble(v, s), false));
				}
				default: None();
			}
		}
		FiCallPrim(op, es, type, s): {
			switch (op) {
				FcArrayPrim(): {
					switch (to) {
						FiTypeArray(arr_to): {
							arr_from_t = fiDearrayType(type);
							v = cast(ce.val: flow -> [flow]);
							if (length(v) != length(es)) None() else {
								arr_cast = filtermapi(es, \i, x ->
									fcConstEvalCast(FcConstEvalVal(flow(v)[i], x, false), arr_from_t, arr_to)
								);
								if (length(arr_cast) != length(es)) None() else {
									Some(FcConstEvalVal(v,
										FiCallPrim(FcArrayPrim(), map(arr_cast, \x -> x.exp), to, s), false
									));
								}
							}
						}
						default: None();
					}
				}
				FcStructPrim(name): {
					switch (to) {
						FiTypeName(name1, typars1): Some(ce);
						default: None();
					}
				}
				default: None();
			}
		}
		default: None();
	}
}

fcConstEvalCallPrim(call : FiCallPrim, args : [FcConstEvalVal], env : FcConstEvalEnv, on_err: (string, [int]) -> void, cache: HashMap<int, Maybe<FcConstEvalVal>>) -> Maybe<FcConstEvalVal> {
	make_err = \msg -> {
		on_err(msg, map(args, \arg -> arg.exp.start));
		None(); 
	}
	start = call.start;
	switch (call.op) {
		FcOrPrim(): {
			v = cast(args[0].val: flow -> bool) || cast(args[1].val: flow -> bool);
			Some(FcConstEvalVal(flow(v), FiBool(v, start), false));
		}
		FcAndPrim(): {
			v = cast(args[0].val: flow -> bool) && cast(args[1].val: flow -> bool);
			Some(FcConstEvalVal(flow(v), FiBool(v, start), false));
		}
		FcNotPrim(): {
			v = !cast(args[0].val: flow -> bool);
			Some(FcConstEvalVal(flow(v), FiBool(v, start), false));
		}
		FcEqPrim(): {
			switch (args[0].exp) {
				FiLambda(__,__,__,__): None();
				default: {
					v = fcEvalGenericCompare(args[0].val, args[1].val) == 0;
					Some(FcConstEvalVal(flow(v), FiBool(v, start), false));
				}
			}
		}
		FcNePrim(): {
			switch (args[0].exp) {
				FiLambda(__,__,__,__): None();
				default: {
					v = fcEvalGenericCompare(args[0].val, args[1].val) != 0;
					Some(FcConstEvalVal(flow(v), FiBool(v, start), false));
				}
			}
		}
		FcLePrim(): {
			switch (args[0].exp) {
				FiLambda(__,__,__,__): None();
				default: {
					v = fcEvalGenericCompare(args[0].val, args[1].val) <= 0;
					Some(FcConstEvalVal(flow(v), FiBool(v, start), false));
				}
			}
		}
		FcGePrim(): {
			switch (args[0].exp) {
				FiLambda(__,__,__,__): None();
				default: {
					v = fcEvalGenericCompare(args[0].val, args[1].val) >= 0;
					Some(FcConstEvalVal(flow(v), FiBool(v, start), false));
				}
			}
		}
		FcLtPrim(): {
			switch (args[0].exp) {
				FiLambda(__,__,__,__): None();
				default: {
					v = fcEvalGenericCompare(args[0].val, args[1].val) < 0;
					Some(FcConstEvalVal(flow(v), FiBool(v, start), false));
				}
			}
		}
		FcGtPrim(): {
			switch (args[0].exp) {
				FiLambda(__,__,__,__): None();
				default: {
					v = fcEvalGenericCompare(args[0].val, args[1].val) > 0;
					Some(FcConstEvalVal(flow(v), FiBool(v, start), false));
				}
			}
		}
		FcPlusPrim(): {
			type_tag = getDataTagForValue(args[0].val);
			if (type_tag == int_data_tag) {
				// int case
				v = cast(args[0].val : flow -> int) + cast(args[1].val : flow -> int);
				Some(FcConstEvalVal(flow(v), FiInt(v, start), false));
			} else if (type_tag == double_data_tag) {
				// double case
				v = cast(args[0].val : flow -> double) + cast(args[1].val : flow -> double);
				Some(FcConstEvalVal(flow(v), FiDouble(v, start), false));
			} else if (type_tag == string_data_tag) {
				// string case
				v = cast(args[0].val : flow -> string) + cast(args[1].val : flow -> string);
				Some(FcConstEvalVal(flow(v), FiString(v, start), false));
			} else {
				None();
			}
		}
		FcMinusPrim(): {
			type_tag = getDataTagForValue(args[0].val);
			if (type_tag == int_data_tag) {
				// int case
				v = cast(args[0].val : flow -> int) - cast(args[1].val : flow -> int);
				Some(FcConstEvalVal(flow(v), FiInt(v, start), false));
			} else if (type_tag == double_data_tag) {
				// double case
				v = cast(args[0].val : flow -> double) - cast(args[1].val : flow -> double);
				Some(FcConstEvalVal(flow(v), FiDouble(v, start), false));
			} else {
				None();
			}
		}
		FcMulPrim(): {
			type_tag = getDataTagForValue(args[0].val);
			if (type_tag == int_data_tag) {
				// int case
				v = cast(args[0].val : flow -> int) * cast(args[1].val : flow -> int);
				Some(FcConstEvalVal(flow(v), FiInt(v, start), false));
			} else if (type_tag == double_data_tag) {
				// double case
				v = cast(args[0].val : flow -> double) * cast(args[1].val : flow -> double);
				Some(FcConstEvalVal(flow(v), FiDouble(v, start), false));
			} else {
				None();
			}
		}
		FcDivPrim(): {
			type_tag = getDataTagForValue(args[0].val);
			if (type_tag == int_data_tag) {
				// int case
				divisor = cast(args[1].val : flow -> int);
				if (divisor == 0) {
					make_err("division by zero");
				} else {
					v = cast(args[0].val : flow -> int) / divisor;
					Some(FcConstEvalVal(flow(v), FiInt(v, start), false));
				}
			} else if (type_tag == double_data_tag) {
				// double case
				v = cast(args[0].val : flow -> double) / cast(args[1].val : flow -> double);
				Some(FcConstEvalVal(flow(v), FiDouble(v, start), false));
			} else {
				None();
			}
		}
		FcModPrim(): {
			type_tag = getDataTagForValue(args[0].val);
			if (type_tag == int_data_tag) {
				// int case
				divisor = cast(args[1].val : flow -> int);
				if (divisor == 0) {
					make_err("division by zero");
				} else {
					v = cast(args[0].val : flow -> int) % divisor;
					Some(FcConstEvalVal(flow(v), FiInt(v, start), false));
				}
			} else if (type_tag == double_data_tag) {
				// double case
				v = cast(args[0].val : flow -> double) % cast(args[1].val : flow -> double);
				Some(FcConstEvalVal(flow(v), FiDouble(v, start), false));
			} else {
				None();
			}
		}
		FcNegPrim(): {
			type_tag = getDataTagForValue(args[0].val);
			if (type_tag == int_data_tag) {
				// int case
				v = -cast(args[0].val : flow -> int);
				Some(FcConstEvalVal(flow(v), FiInt(v, start), false));
			} else if (type_tag == double_data_tag) {
				// double case
				v = -cast(args[0].val : flow -> double);
				Some(FcConstEvalVal(flow(v), FiDouble(v, start), false));
			} else {
				None();
			}
		}
		FcArrayPrim(): {
			Some(FcConstEvalVal(
				map(args, \arg -> arg.val), 
				FiCallPrim(FcArrayPrim(), map(args, \arg -> arg.exp), call.type, call.start),
				forall(args, \arg -> arg.plain)
			));
		}
		FcIndexPrim(): {
			arr_v = cast(args[0].val : flow -> [flow]);
			i = cast(args[1].val : flow -> int);
			if (0 <= i && i < length(arr_v)) {
				switch (args[0].exp) {
					FiCallPrim(op, arr_exp,__, s1): {
						switch (op) {
							FcArrayPrim(): {
								Some(FcConstEvalVal(arr_v[i], arr_exp[i], false));
							}
							default: None();
						}
					}
					default: None();
				}
			} else {
				make_err("index " + i2s(i) + " is out of bounds, array length: " + i2s(length(arr_v)));
			}
		}
		FcStructPrim(name): {
			if (containsKeyHashMap(env.structs, name)) {
				maybeMap(fcEvalMakeStruct(name, map(args, \arg -> arg.val), IllegalStruct(), env.structs),
					\v -> FcConstEvalVal(v,
						FiCallPrim(FcStructPrim(name), map(args, \arg -> arg.exp), call.type, call.start),
						forall(args, \arg -> arg.plain)
					)
				);
			} else {
				None();
			}
		}
		FcFieldPrim(field): {
			ok = ref true;
			v = fcEvalGetField(field, args[0].val, \__ -> { ok := false; 0});
			if (!^ok) None() else {
				switch (args[0].exp) {
					FiCallPrim(op, fields, type, __): {
						switch (op) {
							FcStructPrim(name): {
								if (field == "structname") {
									Some(FcConstEvalVal(flow(name), FiString(name, start), false))
								} else {
									struct = lookupHashMapDef(env.structs, name, FiTypeStruct("", [], [], 0));
									i = findiDef(struct.args, \arg -> arg.name == field, -1);
									if (i == -1) {
										make_err("unknown field " + field + " in struct " + name);
									} else {
										Some(FcConstEvalVal(flow(v), fields[i], false));
									}
								}
							}
							default: None();
						}
					}
					default: None();
				}
			}
		}
		default: {
			None();
		}
	}
}

fiConstExpTypeId(e: FiExp) -> int {
	switch (e) {
		FiVoid(__): 0;
		FiInt(__,__): 1;
		FiBool(__,__): 2;
		FiDouble(__,__): 3;
		FiString(__,__): 4;
		FiCallPrim(op,__,__,__): {
			switch (op) {
				FcArrayPrim(): 6;
				FcRefPrim(): 7;
				FcStructPrim(__): 9;
				default: -1;
			}
		}
		FiLambda(__,__,__,__): 8;
		default: -1;
	}
}

fiConstExpCompare(e1: FiExp, e2: FiExp) -> int {
	switch (e1) {
		FiCallPrim(op1, es1,__,__): {
			switch (e2) {
				FiCallPrim(op2, es2,__,__): {
					switch (op1) {
						FcArrayPrim(): {
							switch (op2) {
								FcArrayPrim(): {
									if (length(es1) != length(es1)) {
										length(es1) - length(es1);
									} else {
										fold(
											zipWith(es1, es2, \x, y -> Pair(x, y)), 0,
											\acc, p -> {
												if (acc != 0) acc else fiConstExpCompare(p.first, p.second)
											}
										);
									}
								}
								default: fiConstExpTypeId(e1) - fiConstExpTypeId(e2);
							}
						}
						FcStructPrim(name1): {
							switch (op2) {
								FcStructPrim(name2): {
									if (name1 != name2) {
										genericCompare(name1, name2);
									} else if (length(es1) != length(es1)) {
										length(es1) - length(es1);
									} else {
										fold(
											zipWith(es1, es2, \x, y -> Pair(x, y)), 0,
											\acc, p -> {
												if (acc != 0) acc else fiConstExpCompare(p.first, p.second)
											}
										);
									}
								}
								default: fiConstExpTypeId(e1) - fiConstExpTypeId(e2);
							}
						}
						default: -1;
					}
				}
				default: fiConstExpTypeId(e1) - fiConstExpTypeId(e2);
			}
		}
		FiVoid(__): {
			switch (e2) {
				FiVoid(__): 0;
				default: fiConstExpTypeId(e1) - fiConstExpTypeId(e2);
			}
		}
		FiBool(b1,__): {
			switch (e2) {
				FiBool(b2,__): b2i(b1) - b2i(b2);
				default: fiConstExpTypeId(e1) - fiConstExpTypeId(e2);
			}
		}
		FiInt(i1,__): {
			switch (e2) {
				FiInt(i2,__): i1 - i2;
				default: fiConstExpTypeId(e1) - fiConstExpTypeId(e2);
			}
		}
		FiDouble(d1,__): {
			switch (e2) {
				FiDouble(d2,__): if (d1 < d2) -1 else if (d1 > d2) 1 else 0;
				default: fiConstExpTypeId(e1) - fiConstExpTypeId(e2);
			}
		}
		FiString(s1,__): {
			switch (e2) {
				FiString(s2,__): genericCompare(s1, s2);
				default: fiConstExpTypeId(e1) - fiConstExpTypeId(e2);
			}
		}
		FiLambda(__,__,__,__): {
			// All compile-time lambdas are considered non-equal
			-1;
		}
		default: -1;
	}
}

