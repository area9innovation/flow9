import tools/flowc/eval;
import tools/flowc/manipulation/common;
import tools/flowc/manipulation/freevars;
import tools/flowc/manipulation/effects;

export {
	// Setup the global variables and toplevel functions for the evaluation of compile time constants.
	fcInitConstEvalEnv(program: FiProgram, on_err: (FcError) -> void) -> FcConstEvalEnv;

	// Try to compute a compile-time value of an expression.
	fcConstEval(ex : FiExp, consts : Tree<string, FiExp>, env: FcConstEvalEnv, on_err: (string, [int]) -> void) -> Maybe<FiExp>;
}

fcExtractPureToplevels(prog: FiProgram) -> FiProgram {
	effects = collectFiEffectsPrecisely(prog);
	fiMapProgramToplevel(prog, \toplevel, m, p -> switch (toplevel) {
		FiStructOrUnion(): {
			[toplevel];
		}
		FiGlobalVar(name,__,__,__,__): {
			if (containsSet(effects.hasEffects, name)) [] else [toplevel];
		}
		FiFunctionDec(name,__,__,__,__): {
			if (containsSet(effects.hasEffects, name)) [] else [toplevel];
		}
		FiNativeDec(__,io,__,__,__,__,__): {
			if (io) [] else [toplevel];
		}
	});
}

FcConstEvalEnv(
	structs: Tree<string, FiTypeStruct>,
	unions: Tree<string, FiTypeUnion>,
	consts: Tree<string, FiExp>,
	globals:  HashMap<string, FcEvalGlobal>,
	errors: ref [FcError]
);

fcInitConstEvalEnv(prog0: FiProgram, on_err: (FcError) -> void) -> FcConstEvalEnv {
	prog = fcExtractPureToplevels(prog0);
	pure_toplevels = list2array(fiFoldProgramToplevel(prog, makeList(), \top,__,__,acc -> switch (top) {
		FiDeclaration(): Cons(top.name, acc);
		default: acc;
	}));
	effects = collectFiEffects(prog0);
	errors = ref [];
	fold(prog.traversal, 
		FcConstEvalEnv(prog.names.structs, prog.names.unions, makeTree(), fcInitEvalGlobals(prog, on_err), errors),
		\acc, mod_name -> eitherMap(lookupTree(prog.modules, mod_name),
			\m -> {
				m_on_err = \msg, ps -> {
					err = FcError(msg, map(ps, \p -> FcPosition(m.fileinfo.flowfile, p, p)));
					refArrayPush(errors, err);
					on_err(err);
				}
				fold(m.initOrder, acc,
					\ac, name -> eitherMap(lookupTree(prog.names.toplevel, name), \decl ->
						switch (decl) {
							FiGlobalVar(__, value, type,__,__): {
								switch (fcConstEval(value, ac.consts, ac, m_on_err)) {
									Some(cv): {
										FcConstEvalEnv(ac with consts = setTree(ac.consts, name, cv));
									}
									None(): ac
								}
							}
							default: ac;
						}, ac
					)
				)
			}, acc
		)
	);
}

fiComplexConstant2flow(ex : FiExp) -> Maybe<flow> {
	switch (ex) {
		FiVoid(__):       Some(flow(voidValue()));
		FiBool(b1, __):   Some(flow(b1));
		FiInt(i1, __):    Some(flow(i1));
		FiDouble(d1, __): Some(flow(d1));
		FiString(s1, __): Some(flow(s1));
		FiCallPrim(op, es,__,__): {
			switch (op) {
				FcArrayPrim(): {
					arr = filtermap(es, fiComplexConstant2flow);
					if (length(arr) != length(es)) None() else Some(flow(arr));
				}
				FcStructPrim(name): {
					fields = filtermap(es, fiComplexConstant2flow);
					if (length(fields) != length(es)) None() else {
						Some(flow(makeStructValue(name, fields, IllegalStruct())));
					}
				}
				default: None();
			}
		}
		default: None();
	}
}

fiflow2ComplexConstant(v : flow) -> Maybe<FiExp> {
	if (getDataTagForValue(v) == void_data_tag) Some(FiVoid(-1)) else
	if (getDataTagForValue(v) == bool_data_tag) Some(FiBool(cast(v: flow -> bool), -1)) else
	if (getDataTagForValue(v) == int_data_tag) Some(FiInt(cast(v: flow -> int), -1)) else
	if (getDataTagForValue(v) == double_data_tag) Some(FiDouble(cast(v: flow -> double), -1)) else
	if (getDataTagForValue(v) == string_data_tag) Some(FiString(cast(v: flow -> string), -1)) else
	if (getDataTagForValue(v) == array_data_tag) {
		arr_f = cast(v: flow -> [flow]);
		arr = filtermap(arr_f, fiflow2ComplexConstant);
		if (length(arr_f) != length(arr)) None() else {
			Some(FiCallPrim(FcArrayPrim(), arr, FiTypeVoid(), -1));
		}
	} else 
	if (getDataTagForValue(v) == struct_data_tag) {
		name = extractStructName(v);
		fields_f = extractStructArguments(v);
		fields = filtermap(fields_f, fiflow2ComplexConstant);
		if (length(fields_f) != length(fields)) None() else {
			Some(FiCallPrim(FcStructPrim(name), fields, FiTypeVoid(), -1));
		}
	} else {
		None();
	}
}

fiCompleteType(e: FiExp, t: FiType, structs: Tree<string, FiTypeStruct>, unions: Tree<string, FiTypeUnion>) -> Maybe<FiExp> {
	switch (e) {
		FiCallPrim(op, as,__,s): {
			switch (op) {
				FcArrayPrim(): {
					switch (t) {
						FiTypeArray(at): {
							es1 = filtermap(as, \a -> fiCompleteType(a, at, structs, unions));
							if (length(es1) != length(as)) None() else {
								Some(FiCallPrim(e with type = t, es = es1));
							}
						}
						default: None();
					}
				}
				FcStructPrim(name): {
					switch (t) {
						FiTypeName(type_name, typars): {
							do_struct = \tn -> maybeBind(lookupTree(structs, tn.name), \struct ->  {
								sub = fiMatchTyparsArr(struct.typars, tn.typeparameters, makeTree());
								es1 = filtermapi(as, \i, a ->
									fiCompleteType(a, fiSubstituteTypars(struct.args[i].type, sub), structs, unions)
								);
								if (length(es1) != length(as)) {
									None()
								} else {
									Some(FiCallPrim(e with type = tn, es = es1));
								}
							});
							if (name == type_name) do_struct(t) else {
								maybeBind(lookupTree(unions, type_name), \union -> {
									maybeBind(find(union.typenames, \tn -> tn.name == name), \tn -> {
										sub = fiMatchTyparsArr(union.typeparameters, typars, makeTree());
										tn_spec = FiTypeName(tn with typeparameters = map(tn.typeparameters, \tp ->
											fiSubstituteTypars(tp, sub)
										));
										do_struct(tn_spec);
									})
								});
							}
						}
						default: None();
					}
				}
				default: Some(e);
			}
		}
		default: Some(e);
	}
}

fcConstEval(ex : FiExp, consts : Tree<string, FiExp>, env: FcConstEvalEnv, on_err: (string, [int]) -> void) -> Maybe<FiExp> {
	switch (ex) {
		FiLambda(args, body,__,__): {
			free = set2array(fifreevars(ex));
			closure = filtermap(free, \v -> lookupTree(consts, v));
			if (length(closure) != length(free)) None() else {
				Some(FiLambda(ex with
					body = foldi(free, body, \i, acc, x -> fiReplaceVar(acc, x, closure[i]))
				));
			}
		}
		FiCall(f, args, type, pos): {
			do_call = \-> maybeBind(fcConstEval(f, consts, env, on_err), \cf -> {
				switch (cf) {
					FiLambda(cf_args, cf_body,__,__): {
						c_args = filtermap(args, \arg -> fcConstEval(arg, consts, env, on_err));
						if (length(c_args) != length(args)) None() else {
							fcConstEval(
								foldi(c_args, cf_body, \i, acc, x -> fiReplaceVar(acc, cf_args[i].name, x)),
								consts, env, on_err
							);
						}
					}
					default: None();
				}
			});
			switch (f) {
				FiVar(x,__,__): {
					switch (lookupTree(consts, x)) {
						Some(__): do_call();
						None(): {
							f_args = filtermap(args, fiComplexConstant2flow);
							if (length(f_args) != length(args)) None() else {
								env.errors := [];
								val = fcCallFunctionByName(x, f_args, env.globals, \err -> refArrayPush(env.errors, err));
								if (length(^(env.errors)) == 0) {
									// No errors - ok.
									maybeBind(fiflow2ComplexConstant(val), \v ->
										fiCompleteType(v, type, env.structs, env.unions)
									);
								} else {
									// Some errors - not ok.
									None();
								}
							}
						}
					}
				}
				default: do_call();
			}
			
		}
		FiVar(x, type, pos): lookupTree(consts, x);
		FiLet(x, __, e1, e2,__,__): {
			maybeBind(fcConstEval(e1, consts, env, on_err), \ce1 -> {
				setTree(consts, x, ce1);
				ret = fcConstEval(e2, consts, env, on_err);
				removeFromTree(consts, x);
				ret;
			});
		}
		FiIf(e1, e2, e3, __,__): {
			maybeBind(fcConstEval(e1, consts, env, on_err), \ce1 -> switch (ce1) {
				FiBool(v,__): {
					if (v) fcConstEval(e2, consts, env, on_err) else fcConstEval(e3, consts, env, on_err);
				}
				default: None();
			});
		}
		FiSwitch(v,__,cs,__,pos): {
			maybeBind(fcConstEval(v, consts, env, on_err), \cs1 -> switch (cs1) {
				FiCallPrim(op, fields, type, s): {
					switch (op) {
						FcStructPrim(name): {
							switch (find(cs, \c -> c.struct == name)) {
								Some(case): {
									fcConstEval(case.body,
										foldi(case.argNames, consts, \i, acc, arg ->
											if (arg != "__") setTree(acc, arg, fields[i]) else acc
										), env, on_err
									);
								}
								None(): {
									switch (find(cs, \c -> c.struct == "default")) {
										Some(def): fcConstEval(def.body, consts, env, on_err);
										None(): None();
									}
								}
							}
						}
						default: None();
					}
				}
				default: None();
			});
		}
		FiCast(e, from, to,__,__): {
			maybeBind(fcConstEval(e, consts, env, on_err), \ce ->
				if (fiEqualTypes(from, to)) Some(ce) else fcConstEvalCast(ce, from, to)
			);
		}
		FiSeq(es,__,__): {
			if (length(es) != 1) None() else {
				fcConstEval(es[0], consts, env, on_err);
			}
		}
		FiCallPrim(op, es, __,__): {
			args = filtermap(es, \x -> fcConstEval(x, consts, env, on_err));
			if (length(args) != length(es)) None() else {
				fcConstEvalCallPrim(ex, args, env, on_err);
			}
		}
		FiConst(): Some(ex);
		default: None();
	}
}

fcConstEvalCast(ce: FiExp, from: FiType, to: FiType) -> Maybe<FiExp> {
	switch (ce) {
		FiVoid(s): None();
		FiBool(b, s): {
			switch (to) {
				FiTypeInt():    Some(FiInt(b2i(b), s));
				FiTypeDouble(): Some(FiDouble(b2d(b), s));
				FiTypeString(): Some(FiString(b2s(b), s));
				default: None();
			}
		}
		FiInt(i, s): {
			switch (to) {
				FiTypeBool():   Some(FiBool(i2b(i), s));
				FiTypeDouble(): Some(FiDouble(i2d(i), s));
				FiTypeString(): Some(FiString(i2s(i), s));
				default: None();
			}
		}
		FiDouble(d, s): {
			switch (to) {
				FiTypeBool():   Some(FiBool(d != 0.0, s));
				FiTypeInt():    Some(FiInt(round(d), s));
				FiTypeString(): Some(FiString(d2s(d), s));
				default: None();
			}
		}
		FiString(x, s): {
			switch (to) {
				FiTypeBool():   Some(FiBool(s2b(x), s));
				FiTypeInt():    Some(FiInt(s2i(x), s));
				FiTypeDouble(): Some(FiDouble(s2d(x), s));
				default: None();
			}
		}
		FiCallPrim(op, es, type, s): {
			switch (op) {
				FcArrayPrim(): {
					switch (to) {
						FiTypeArray(arr_to): {
							arr_from_t = fiDearrayType(type);
							arr_cast = filtermap(es, \x -> fcConstEvalCast(x, arr_from_t, arr_to));
							if (length(arr_cast) != length(es)) None() else 
							Some(FiCallPrim(FcArrayPrim(), arr_cast, to, s));
						}
						default: None();
					}
				}
				FcStructPrim(name): {
					switch (to) {
						FiTypeName(name1, typars1): Some(ce);
						default: None();
					}
				}
				default: None();
			}
		}
		FiLambda(args, body, type, s): {
			switch (to) {
				FiTypeFunction(toArgs, toRet): {
					println("TODO: const eval cast of functions");
					None();
				}
				default: None();
			}
		}
		default: None();
	}
}

fcConstEvalCallPrim(call : FiCallPrim, args : [FiExp], env : FcConstEvalEnv, on_err: (string, [int]) -> void) -> Maybe<FiExp> {
	make_err = \msg, pos -> { on_err(msg, pos); None(); }
	switch (call.op) {
		FcOrPrim(): {
			a1 = cast(args[0]: FiExp -> FiBool);
			a2 = cast(args[1]: FiExp -> FiBool);
			Some(FiBool(a1.b || a2.b, a1.start));
		}
		FcAndPrim(): {
			a1 = cast(args[0]: FiExp -> FiBool);
			a2 = cast(args[1]: FiExp -> FiBool);
			Some(FiBool(a1.b && a2.b, a1.start));
		}
		FcNotPrim(): {
			a1 = cast(args[0]: FiExp -> FiBool);
			Some(FiBool(!a1.b, a1.start));
		}
		FcEqPrim(): {
			switch (args[0]) {
				FiLambda(__,__,__,__): None();
				default: Some(FiBool(fiConstExpCompare(args[0], args[1]) == 0, args[0].start));
			}
		}
		FcNePrim(): {
			switch (args[0]) {
				FiLambda(__,__,__,__): None();
				default: Some(FiBool(fiConstExpCompare(args[0], args[1]) != 0, args[0].start));
			}
		}
		FcLePrim(): {
			switch (args[0]) {
				FiLambda(__,__,__,__): None();
				default: Some(FiBool(fiConstExpCompare(args[0], args[1]) <= 0, args[0].start));
			}
		}
		FcGePrim(): {
			switch (args[0]) {
				FiLambda(__,__,__,__): None();
				default: Some(FiBool(fiConstExpCompare(args[0], args[1]) >= 0, args[0].start));
			}
		}
		FcLtPrim(): {
			switch (args[0]) {
				FiLambda(__,__,__,__): None();
				default: Some(FiBool(fiConstExpCompare(args[0], args[1]) < 0, args[0].start));
			}
		}
		FcGtPrim(): {
			switch (args[0]) {
				FiLambda(__,__,__,__): None();
				default: Some(FiBool(fiConstExpCompare(args[0], args[1]) > 0, args[0].start));
			}
		}
		FcPlusPrim(): {
			switch (args[0]) {
				FiInt(__,__): {
					a1 = cast(args[0]: FiExp -> FiInt);
					a2 = cast(args[1]: FiExp -> FiInt);
					Some(FiInt(a1.i + a2.i, a1.start));
				}
				FiDouble(__,__): {
					a1 = cast(args[0]: FiExp -> FiDouble);
					a2 = cast(args[1]: FiExp -> FiDouble);
					Some(FiDouble(a1.d + a2.d, a1.start));
				}
				FiString(__,__): {
					a1 = cast(args[0]: FiExp -> FiString);
					a2 = cast(args[1]: FiExp -> FiString);
					Some(FiString(a1.s + a2.s, a1.start));
				}
				default: None();
			}
		}
		FcMinusPrim(): {
			switch (args[0]) {
				FiInt(__,__): {
					a1 = cast(args[0]: FiExp -> FiInt);
					a2 = cast(args[1]: FiExp -> FiInt);
					Some(FiInt(a1.i - a2.i, a1.start));
				}
				FiDouble(__,__): {
					a1 = cast(args[0]: FiExp -> FiDouble);
					a2 = cast(args[1]: FiExp -> FiDouble);
					Some(FiDouble(a1.d - a2.d, a1.start));
				}
				default: None();
			}
		}
		FcMulPrim(): {
			switch (args[0]) {
				FiInt(__,__): {
					a1 = cast(args[0]: FiExp -> FiInt);
					a2 = cast(args[1]: FiExp -> FiInt);
					Some(FiInt(a1.i * a2.i, a1.start));
				}
				FiDouble(__,__): {
					a1 = cast(args[0]: FiExp -> FiDouble);
					a2 = cast(args[1]: FiExp -> FiDouble);
					Some(FiDouble(a1.d * a2.d, a1.start));
				}
				default: None();
			}
		}
		FcDivPrim(): {
			switch (args[0]) {
				FiInt(__,__): {
					a1 = cast(args[0]: FiExp -> FiInt);
					a2 = cast(args[1]: FiExp -> FiInt);
					if (a2.i == 0) {
						make_err("division by zero", [a1.start, a2.start]);
					} else {
						Some(FiInt(a1.i / a2.i, a1.start));
					}
				}
				FiDouble(__,__): {
					a1 = cast(args[0]: FiExp -> FiDouble);
					a2 = cast(args[1]: FiExp -> FiDouble);
					if (a2.d == 0.0) {
						make_err("division by zero", [a1.start, a2.start]);
					} else {
						Some(FiDouble(a1.d / a2.d, a1.start));
					}
				}
				default: None();
			}
		}
		FcModPrim(): {
			switch (args[0]) {
				FiInt(__,__): {
					a1 = cast(args[0]: FiExp -> FiInt);
					a2 = cast(args[1]: FiExp -> FiInt);
					if (a2.i == 0) {
						make_err("division by zero", [a1.start, a2.start]);
					} else {
						Some(FiInt(a1.i % a2.i, a1.start));
					}
				}
				FiDouble(__,__): {
					a1 = cast(args[0]: FiExp -> FiDouble);
					a2 = cast(args[1]: FiExp -> FiDouble);
					if (a2.d == 0.0) {
						make_err("division by zero", [a1.start, a2.start]);
					} else {
						Some(FiDouble(a1.d % a2.d, a1.start));
					}
				}
				default: None();
			}
		}
		FcNegPrim(): {
			switch (args[0]) {
				FiInt(i, s): {
					Some(FiInt(-i, s));
				}
				FiDouble(d, s): {
					Some(FiDouble(-d, s));
				}
				default: None();
			}
		}
		FcArrayPrim(): {
			Some(FiCallPrim(FcArrayPrim(), args, call.type, call.start));
		}
		FcIndexPrim(): {
			switch (args[0]) {
				FiCallPrim(op, arr,__, s1): {
					switch (op) {
						FcArrayPrim(): {
							switch (args[1]) {
								FiInt(i, s2): {
									if (0 <= i && i < length(arr)) {
										Some(arr[i]);
									} else {
										make_err(
											"index " + i2s(i) + " is out of bounds, array length: " + i2s(length(arr)),
											[s1, s2]
										);
									}
								}
								default: None();
							}
						}
						default: None();
					}
				}
				default: None();
			}
		}
		FcStructPrim(name): {
			Some(FiCallPrim(FcStructPrim(name), args, call.type, call.start));
		}
		FcFieldPrim(field): {
			switch (args[0]) {
				FiCallPrim(op, fields, type, start): {
					switch (op) {
						FcStructPrim(name): {
							if (field == "structname") {
								Some(FiString(name, call.start));
							} else {
								struct = lookupTreeDef(env.structs, name, FiTypeStruct("", [], [], 0));
								i = findiDef(struct.args, \arg -> arg.name == field, -1);
								if (i == -1) {
									make_err("unknown field " + field + " in struct " + name, [call.start]);
								} else {
									Some(fields[i]);
								}
							}
						}
						default: None();
					}
				}
				default: None();
			}
		}
		default: {
			None();
		}
	}
}

fiConstExpTypeId(e: FiExp) -> int {
	switch (e) {
		FiVoid(__): 0;
		FiInt(__,__): 1;
		FiBool(__,__): 2;
		FiDouble(__,__): 3;
		FiString(__,__): 4;
		FiCallPrim(op,__,__,__): {
			switch (op) {
				FcArrayPrim(): 6;
				FcRefPrim(): 7;
				FcStructPrim(__): 9;
				default: -1;
			}
		}
		FiLambda(__,__,__,__): 8;
		default: -1;
	}
}

fiConstExpCompare(e1: FiExp, e2: FiExp) -> int {
	switch (e1) {
		FiCallPrim(op1, es1,__,__): {
			switch (e2) {
				FiCallPrim(op2, es2,__,__): {
					switch (op1) {
						FcArrayPrim(): {
							switch (op2) {
								FcArrayPrim(): {
									if (length(es1) != length(es1)) {
										length(es1) - length(es1);
									} else {
										fold(
											zipWith(es1, es2, \x, y -> Pair(x, y)), 0,
											\acc, p -> {
												if (acc != 0) acc else fiConstExpCompare(p.first, p.second)
											}
										);
									}
								}
								default: fiConstExpTypeId(e1) - fiConstExpTypeId(e2);
							}
						}
						FcStructPrim(name1): {
							switch (op2) {
								FcStructPrim(name2): {
									if (name1 != name2) {
										genericCompare(name1, name2);
									} else if (length(es1) != length(es1)) {
										length(es1) - length(es1);
									} else {
										fold(
											zipWith(es1, es2, \x, y -> Pair(x, y)), 0,
											\acc, p -> {
												if (acc != 0) acc else fiConstExpCompare(p.first, p.second)
											}
										);
									}
								}
								default: fiConstExpTypeId(e1) - fiConstExpTypeId(e2);
							}
						}
						default: -1;
					}
				}
				default: fiConstExpTypeId(e1) - fiConstExpTypeId(e2);
			}
		}
		FiVoid(__): {
			switch (e2) {
				FiVoid(__): 0;
				default: fiConstExpTypeId(e1) - fiConstExpTypeId(e2);
			}
		}
		FiBool(b1,__): {
			switch (e2) {
				FiBool(b2,__): b2i(b1) - b2i(b2);
				default: fiConstExpTypeId(e1) - fiConstExpTypeId(e2);
			}
		}
		FiInt(i1,__): {
			switch (e2) {
				FiInt(i2,__): i1 - i2;
				default: fiConstExpTypeId(e1) - fiConstExpTypeId(e2);
			}
		}
		FiDouble(d1,__): {
			switch (e2) {
				FiDouble(d2,__): if (d1 < d2) -1 else if (d1 > d2) 1 else 0;
				default: fiConstExpTypeId(e1) - fiConstExpTypeId(e2);
			}
		}
		FiString(s1,__): {
			switch (e2) {
				FiString(s2,__): genericCompare(s1, s2);
				default: fiConstExpTypeId(e1) - fiConstExpTypeId(e2);
			}
		}
		FiLambda(__,__,__,__): {
			// All compile-time lambdas are considered non-equal
			-1;
		}
		default: -1;
	}
}

