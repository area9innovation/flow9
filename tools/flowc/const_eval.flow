import tools/flowc/eval;
import tools/flowc/manipulation/common;
import tools/flowc/manipulation/freevars;
import tools/flowc/manipulation/effects;
import tools/flowc/manipulation/tail_call;

export {
	FcConstEvalEnv(
		structs: HashMap<string, FiTypeStruct>,
		unions:  HashMap<string, FiTypeUnion>,
		consts:  Tree<string, FiExp>,
		globals: HashMap<string, FcEvalGlobal>,
		effects: FiEffects,
		errors: ref [FcError]
	);

	// Setup the global variables and toplevel functions for the evaluation of compile time constants.
	fcInitConstEvalEnv(program: FiProgram, on_err: (FcError) -> void) -> FcConstEvalEnv;

	// Try to compute a compile-time value of an expression.
	fcConstEval(ex : FiExp,
		env: FcConstEvalEnv,
		cache: HashMap<int, Maybe<FiExp>>,
		on_err: (string, [int]) -> void,
		on_msg: (string) -> void,
		debug: bool
	) -> Maybe<FiExp>;

	// Remove all speculative compile-time function wrappers: `outputCt`,`forbidCt` and `assertCt`.
	fcEliminateCompileTimeFns(prog: FiProgram) -> FiProgram;
}

fcConstEvalPureToplevels(prog: FiProgram, effects: FiEffects) -> FiProgram {
	exclude = getConfigParameter(prog.config.config, "do-not-const-eval");
	exclude_set = if (exclude == "") makeSet() else buildSet(strSplit(exclude, ","));
	fiMapProgramToplevel(prog, \toplevel, m, p ->
		if (toplevel.name == "main" || containsSet(exclude_set, toplevel.name)) [] else {
			switch (toplevel) {
				FiTypeStruct(name,__,fields,__): {
					if (exists(fields, \f -> f.ismutable)) [] else [toplevel];
				}
				FiTypeUnion(__,__,__,__): {
					[toplevel];
				}
				FiGlobalVar(name,__,__,__,__): {
					if (containsSet(effects.hasEffects, name)) [] else [toplevel];
				}
				FiFunctionDec(name,__,__,__,__): {
					if (containsSet(effects.hasEffects, name)) [] else [toplevel];
				}
				FiNativeDec(name, io,__,__,__,__,__): {
					if (io) [] else [toplevel];
				}
			}
		}, fcParallelOn(prog.config)
	);
}

fcEliminateCompileTimeFns(prog: FiProgram) -> FiProgram {
	fiMapProgramExp(prog, \x, __,__,__ ->
		mapFiExp(x, \e -> switch (e) {
			FiCall(f, args,__,__): {
				switch (f) {
					FiVar(fn_name,__,__): {
						if (fn_name == "outputCt") args[1] else
						if (fn_name == "forbidCt" || fn_name == "assertCt") args[0] else
						e;
					}
					default: e;
				}
			}
			default: e;
		}
	), fcParallelOn(prog.config));
}

fcInitConstEvalEnv(prog0: FiProgram, on_err: (FcError) -> void) -> FcConstEvalEnv {
	effects = collectFiEffectsPrecisely(prog0);
	prog = fcOptimizeTailCalls(fcConstEvalPureToplevels(prog0, effects));
	if (isConfigParameterTrue(prog.config.config, "show-pure-toplevels")) {
		pure_toplevels = list2array(fiFoldProgramToplevel(prog, makeList(), \top,__,__,acc -> switch (top) {
			FiDeclaration(): Cons(top.name, acc);
			default: acc;
		}));
		fcPrintln("Pure toplevels:\n" + strIndent(strGlue(pure_toplevels, "\n")), prog.config.threadId);
	}
	errors = ref [];
	on_msg = \msg -> fcPrintln(msg, prog.config.threadId);
	optimzie_debug = getConfigParameter(prog.config.config, "optimize-debug");
	fold(prog.traversal, 
		FcConstEvalEnv(
			tree2hashMap(prog.names.structs, fastHashString),
			tree2hashMap(prog.names.unions, fastHashString),
			makeTree(), fcInitEvalGlobals(prog, on_err), effects,
			errors
		),
		\acc, mod_name -> eitherMap(lookupTree(prog.modules, mod_name),
			\m -> {
				m_on_err = \msg, ps -> {
					err = FcError(msg, map(ps, \p -> FcPosition(m.fileinfo.flowfile, p, p)));
					refArrayPush(errors, err);
					on_err(err);
				}
				fold(m.initOrder, acc,
					\ac, name -> eitherMap(lookupTree(prog.names.toplevel, name), \decl ->
						switch (decl) {
							FiGlobalVar(__, value, type,__,__): {
								switch (fcConstEval(value, ac, makeHashMap(idfn), m_on_err, on_msg, decl.name == optimzie_debug)) {
									Some(cv): {
										if (decl.name == optimzie_debug) {
											fcPrintln(
												"Optimization of global variable:\n" + pretFiExp(value) + "\nended up with:\n" + pretFiExp(cv),
												prog.config.threadId
											);
										}
										FcConstEvalEnv(ac with consts = setTree(ac.consts, name, cv));
									}
									None(): ac;
								}
							}
							default: ac;
						}, ac
					)
				)
			}, acc
		)
	);
}

fiComplexConstant2flow(ex : FiExp, env: FcConstEvalEnv, on_err: (string, [int]) -> void) -> Maybe<flow> {
	switch (ex) {
		FiVoid(__):       Some(flow(voidValue()));
		FiBool(b1, __):   Some(flow(b1));
		FiInt(i1, __):    Some(flow(i1));
		FiDouble(d1, __): Some(flow(d1));
		FiString(s1, __): Some(flow(s1));
		FiCallPrim(op, es,__,s): {
			switch (op) {
				FcArrayPrim(): {
					arr = filtermap(es, \x -> fiComplexConstant2flow(x, env, on_err));
					if (length(arr) != length(es)) None() else Some(flow(arr));
				}
				FcStructPrim(name): {
					fields = filtermap(es, \x -> fiComplexConstant2flow(x, env, on_err));
					if (length(fields) != length(es) || !containsKeyHashMap(env.structs, name)) None() else {
						fcEvalMakeStruct(name, fields, IllegalStruct(), env.structs);
					}
				}
				default: None();
			}
		}
		FiLambda(args, body,__,__): {
			fcMakeFnFromLambda(ex, env.structs, env.globals, None(), on_err);
		}
		default: None();
	}
}

fiflow2ComplexConstant(v : flow, env: FcConstEvalEnv) -> Maybe<FiExp> {
	v_tag = getDataTagForValue(v);
	if (v_tag == void_data_tag) Some(FiVoid(-1)) else
	if (v_tag == bool_data_tag) Some(FiBool(cast(v: flow -> bool), -1)) else
	if (v_tag == int_data_tag) Some(FiInt(cast(v: flow -> int), -1)) else
	if (v_tag == double_data_tag) Some(FiDouble(cast(v: flow -> double), -1)) else
	if (v_tag == string_data_tag) Some(FiString(cast(v: flow -> string), -1)) else
	if (v_tag == array_data_tag) {
		arr_f = cast(v: flow -> [flow]);
		arr = filtermap(arr_f, \x -> fiflow2ComplexConstant(x, env));
		if (length(arr_f) != length(arr)) None() else {
			Some(FiCallPrim(FcArrayPrim(), arr, FiTypeVoid(), -1));
		}
	} else 
	if (v_tag == struct_data_tag) {
		maybeBind(fcEvalDecomposeStruct(v), \p -> {
			name = p.first;
			if (name == "" || !containsKeyHashMap(env.structs, name)) None() else {
				fields_f = p.second;
				fields = filtermap(fields_f, \x -> fiflow2ComplexConstant(x, env));
				if (length(fields_f) != length(fields)) None() else {
					Some(FiCallPrim(FcStructPrim(name), fields, FiTypeVoid(), -1));
				}
			}
		});
	} else {
		None();
	}
}

fiCompleteType(e: FiExp, hint: Maybe<FiType>, env: FcConstEvalEnv) -> Maybe<FiExp> {
	switch (e) {
		FiCallPrim(op, as,__,s): {
			switch (op) {
				FcArrayPrim(): {
					do_flow = \ -> {
						as1 = filtermap(as, \a -> fiCompleteType(a, None(), env));
						if (length(as1) == 0 || length(as1) != length(as)) None() else {
							at = fiExpType(as1[0]);
							if (exists(tail(as1), \x -> !fiEqualTypes(at, fiExpType(x)))) None() else {
								Some(FiCallPrim(e with type = FiTypeArray(at), es = as1));
							}
						}
					}
					switch (hint) {
						Some(t): {
							switch (t) {
								FiTypeArray(at): {
									es1 = filtermap(as, \a -> fiCompleteType(a, Some(at), env));
									if (length(es1) != length(as)) None() else {
										Some(FiCallPrim(e with type = t, es = es1));
									}
								}
								FiTypeFlow(): do_flow();
								default: None();
							}
						}
						None(): do_flow();
					}
				}
				FcStructPrim(name): {
					do_flow = \ -> {
						maybeBind(lookupHashMap(env.structs, name), \struct -> {
							as1 = filtermap(as, \a -> fiCompleteType(a, None(), env));
							if (length(as1) != length(struct.args)) None() else {
								sub = foldi(struct.args, makeTree(), \i, acc, arg ->
									fiMatchTypars(arg.type, fiExpType(as1[i]), acc)
								);
								Some(FiCallPrim(e with
									type = FiTypeName(name, map(struct.typars, \tp ->
										fiSubstituteTypars(tp, sub)
									)),
									es = as1
								));
							}
						});
					}
					switch (hint) {
						Some(t): {
							switch (t) {
								FiTypeName(type_name, typars): {
									do_struct = \tn -> maybeBind(lookupHashMap(env.structs, tn.name), \struct ->  {
										sub = fiMatchTyparsArr(struct.typars, tn.typeparameters, makeTree());
										es1 = filtermapi(as, \i, a ->
											fiCompleteType(a, Some(fiSubstituteTypars(struct.args[i].type, sub)), env)
										);
										if (length(es1) != length(as)) None() else {
											Some(FiCallPrim(e with type = tn, es = es1));
										}
									});
									if (name == type_name) do_struct(t) else {
										maybeBind(lookupHashMap(env.unions, type_name), \union -> {
											maybeBind(find(union.typenames, \tn -> tn.name == name), \tn -> {
												sub = fiMatchTyparsArr(union.typeparameters, typars, makeTree());
												tn_spec = FiTypeName(tn with typeparameters = map(tn.typeparameters, \tp ->
													fiSubstituteTypars(tp, sub)
												));
												do_struct(tn_spec);
											})
										});
									}
								}
								FiTypeFlow(): do_flow();
								default: None();
							}
						}
						None(): do_flow();
					}
				}
				default: Some(e);
			}
		}
		default: Some(e);
	}
}

fcConstEval(ex : FiExp,
	env: FcConstEvalEnv,
	cache: HashMap<int, Maybe<FiExp>>,
	on_err: (string, [int]) -> void,
	on_msg: (string) -> void,
	debug: bool
) -> Maybe<FiExp> {
	switch (lookupHashMap(cache, ex.start)) {
		Some(x): x;
		None(): {
			ret = fcDoConstEval(ex, env, cache, on_err, on_msg, debug);
			setHashMap(cache, ex.start, ret);
			ret;
		}
	}
}


fcDoConstEval(ex : FiExp,
	env: FcConstEvalEnv,
	cache: HashMap<int, Maybe<FiExp>>,
	on_err: (string, [int]) -> void,
	on_msg: (string) -> void,
	debug: bool
) -> Maybe<FiExp> {
	rec = \x -> fcConstEval(x, env, cache, on_err, on_msg, debug);
	switch (ex) {
		FiLambda(args, body,__,__): {
			free = filter(set2array(fifreevars(ex)), \v -> !containsKeyHashMap(env.globals, v));
			const_closure = filtermap(free, \v -> lookupTree(env.consts, v));
			if (length(const_closure) != length(free) /*|| hasFiSideEffects(env.effects, body)*/) None() else {
				Some(FiLambda(ex with
					body = foldi(free, body, \i, acc, x ->
						if (fiTypeIsFunction(fiExpType(const_closure[i]))) acc else
						fiReplaceVar(acc, x, const_closure[i]))
				));
			}
		}
		FiCall(f, args, type, pos): {
			do_job = \ -> {
				r_args = map(args, rec);
				c_args = filtermap(r_args, idfn);
				if (length(c_args) != length(args)) {
					switch (f) {
						FiVar(x,__,__): {
							if (x == "outputCt") {
								// Output the result of non-successfull compile-time computation
								msg = eitherMap(r_args[0], \m -> switch (m) {
									FiString(msg,__): msg;
									default: pretFiExp(m);
								}, pretFiExp(args[0]));
								val = either(r_args[1], args[1]);
								on_msg(msg + pretFiExp(val));
							} else if (x == "assertCt") {
								// raise an error
								on_err(
									"Expression was not computed at compile-time:\n" + pretFiExp(args[0]) + "\n" + 
									"consts:\n" + strIndent(superglue(tree2pairs(env.consts), \p -> p.first + " => " + pretFiExp(p.second), "\n")),
									[pos]
								);
							}
						}
						default: { }
					}
					None();
				} else {
					do_call = \fn -> maybeBind(fn, \cf -> switch (cf) {
						FiLambda(cf_args, cf_body,__,__): {
							fcConstEval(
								cf_body,
								FcConstEvalEnv(env with
									consts = foldi(c_args, env.consts, \i, acc, x -> setTree(acc, cf_args[i].name, x))
								),
								makeHashMap(idfn), on_err, on_msg, debug
							);
						}
						default: None();
					});
					switch (f) {
						FiVar(x,__,__): {
							if (x == "outputCt") {
								msg = switch (c_args[0]) {
									FiString(m,__): m;
									default: pretFiExp(c_args[0]);
								};
								on_msg(msg + pretFiExp(c_args[1]));
								Some(c_args[1]);
							} else {
								if (containsKeyHashMap(env.globals, x)) {
									f_args = filtermap(c_args, \arg -> fiComplexConstant2flow(arg, env, on_err));
									if (length(f_args) != length(args)) None() else {
										env.errors := [];
										maybeBind(
											fcCallFunctionByName(x, f_args, env.globals, \err -> refArrayPush(env.errors, err)),
											\val -> if (length(^(env.errors)) == 0) {
												// No errors - ok.
												maybeBind(fiflow2ComplexConstant(val, env), \v ->
													fiCompleteType(v, Some(type), env)
												);
											} else {
												// Some errors - not ok.
												None();
											}
										);
									}
								} else {
									do_call(lookupTree(env.consts, x));
								}
							}
						}
						default: do_call(rec(f));
					}
				}
			}
			switch (f) {
				FiVar(x,__,__): {
					if (x == "forbidCt") {
						setHashMap(cache, args[0].start, None());
						None();
					} else {
						do_job();
					}
				}
				default: do_job();
			}
		}
		FiVar(x, type, pos): {
			switch (type) {
				FiTypeFunction(__,__): None();
				default: lookupTree(env.consts, x);
			}
		}
		FiLet(x, __, e1, e2,__,__): {
			maybeBind(rec(e1), \ce1 ->
				fcConstEval(e2, FcConstEvalEnv(env with consts = setTree(env.consts, x, ce1)), cache, on_err, on_msg, debug)
			);
		}
		FiIf(e1, e2, e3, __,__): {
			maybeBind(rec(e1), \ce1 -> switch (ce1) {
				FiBool(v,__): {
					if (v) rec(e2) else rec(e3);
				}
				default: None();
			});
		}
		FiSwitch(v,__,cs,__,pos): {
			maybeBind(rec(v), \cs1 -> switch (cs1) {
				FiCallPrim(op, fields, type, s): {
					switch (op) {
						FcStructPrim(name): {
							switch (find(cs, \c -> c.struct == name)) {
								Some(case): {
									fcConstEval(case.body,
										FcConstEvalEnv(env with
											consts = foldi(case.argNames, env.consts, \i, acc, arg ->
												if (arg != "__") setTree(acc, arg, fields[i]) else acc
											)
										),
										cache, on_err, on_msg, debug
									);
								}
								None(): {
									switch (find(cs, \c -> c.struct == "default")) {
										Some(def): rec(def.body);
										None(): None();
									}
								}
							}
						}
						default: None();
					}
				}
				default: None();
			});
		}
		FiCast(e, from, to,__,__): {
			maybeBind(rec(e), \ce ->
				if (fiEqualTypes(from, to)) Some(ce) else fcConstEvalCast(ce, from, to)
			);
		}
		FiSeq(es,__,__): {
			iter(es, \x -> ignore(rec(x)));
			if (length(es) == 0) Some(ex) else
			if (length(es) != 1) None() else rec(es[0]);
		}
		FiCallPrim(op, es, __,__): {
			args = filtermap(es, rec);
			if (length(args) != length(es)) None() else {
				fcConstEvalCallPrim(ex, args, env, on_err);
			}
		}
		FiConst(): Some(ex);
		default: None();
	}
}

fcConstEvalCast(ce: FiExp, from: FiType, to: FiType) -> Maybe<FiExp> {
	switch (ce) {
		FiVoid(s): None();
		FiBool(b, s): {
			switch (to) {
				FiTypeInt():    Some(FiInt(b2i(b), s));
				FiTypeDouble(): Some(FiDouble(b2d(b), s));
				FiTypeString(): Some(FiString(b2s(b), s));
				default: None();
			}
		}
		FiInt(i, s): {
			switch (to) {
				FiTypeBool():   Some(FiBool(i2b(i), s));
				FiTypeDouble(): Some(FiDouble(i2d(i), s));
				FiTypeString(): Some(FiString(i2s(i), s));
				default: None();
			}
		}
		FiDouble(d, s): {
			switch (to) {
				FiTypeBool():   Some(FiBool(d != 0.0, s));
				FiTypeInt():    Some(FiInt(round(d), s));
				FiTypeString(): Some(FiString(d2s(d), s));
				default: None();
			}
		}
		FiString(x, s): {
			switch (to) {
				FiTypeBool():   Some(FiBool(s2b(x), s));
				FiTypeInt():    Some(FiInt(s2i(x), s));
				FiTypeDouble(): Some(FiDouble(s2d(x), s));
				default: None();
			}
		}
		FiCallPrim(op, es, type, s): {
			switch (op) {
				FcArrayPrim(): {
					switch (to) {
						FiTypeArray(arr_to): {
							arr_from_t = fiDearrayType(type);
							arr_cast = filtermap(es, \x -> fcConstEvalCast(x, arr_from_t, arr_to));
							if (length(arr_cast) != length(es)) None() else 
							Some(FiCallPrim(FcArrayPrim(), arr_cast, to, s));
						}
						default: None();
					}
				}
				FcStructPrim(name): {
					switch (to) {
						FiTypeName(name1, typars1): Some(ce);
						default: None();
					}
				}
				default: None();
			}
		}
		default: None();
	}
}

fcConstEvalCallPrim(call : FiCallPrim, args : [FiExp], env : FcConstEvalEnv, on_err: (string, [int]) -> void) -> Maybe<FiExp> {
	make_err = \msg, pos -> { on_err(msg, pos); None(); }
	switch (call.op) {
		FcOrPrim(): {
			a1 = cast(args[0]: FiExp -> FiBool);
			a2 = cast(args[1]: FiExp -> FiBool);
			Some(FiBool(a1.b || a2.b, a1.start));
		}
		FcAndPrim(): {
			a1 = cast(args[0]: FiExp -> FiBool);
			a2 = cast(args[1]: FiExp -> FiBool);
			Some(FiBool(a1.b && a2.b, a1.start));
		}
		FcNotPrim(): {
			a1 = cast(args[0]: FiExp -> FiBool);
			Some(FiBool(!a1.b, a1.start));
		}
		FcEqPrim(): {
			switch (args[0]) {
				FiLambda(__,__,__,__): None();
				default: Some(FiBool(fiConstExpCompare(args[0], args[1]) == 0, args[0].start));
			}
		}
		FcNePrim(): {
			switch (args[0]) {
				FiLambda(__,__,__,__): None();
				default: Some(FiBool(fiConstExpCompare(args[0], args[1]) != 0, args[0].start));
			}
		}
		FcLePrim(): {
			switch (args[0]) {
				FiLambda(__,__,__,__): None();
				default: Some(FiBool(fiConstExpCompare(args[0], args[1]) <= 0, args[0].start));
			}
		}
		FcGePrim(): {
			switch (args[0]) {
				FiLambda(__,__,__,__): None();
				default: Some(FiBool(fiConstExpCompare(args[0], args[1]) >= 0, args[0].start));
			}
		}
		FcLtPrim(): {
			switch (args[0]) {
				FiLambda(__,__,__,__): None();
				default: Some(FiBool(fiConstExpCompare(args[0], args[1]) < 0, args[0].start));
			}
		}
		FcGtPrim(): {
			switch (args[0]) {
				FiLambda(__,__,__,__): None();
				default: Some(FiBool(fiConstExpCompare(args[0], args[1]) > 0, args[0].start));
			}
		}
		FcPlusPrim(): {
			switch (args[0]) {
				FiInt(__,__): {
					a1 = cast(args[0]: FiExp -> FiInt);
					a2 = cast(args[1]: FiExp -> FiInt);
					Some(FiInt(a1.i + a2.i, a1.start));
				}
				FiDouble(__,__): {
					a1 = cast(args[0]: FiExp -> FiDouble);
					a2 = cast(args[1]: FiExp -> FiDouble);
					Some(FiDouble(a1.d + a2.d, a1.start));
				}
				FiString(__,__): {
					a1 = cast(args[0]: FiExp -> FiString);
					a2 = cast(args[1]: FiExp -> FiString);
					Some(FiString(a1.s + a2.s, a1.start));
				}
				default: None();
			}
		}
		FcMinusPrim(): {
			switch (args[0]) {
				FiInt(__,__): {
					a1 = cast(args[0]: FiExp -> FiInt);
					a2 = cast(args[1]: FiExp -> FiInt);
					Some(FiInt(a1.i - a2.i, a1.start));
				}
				FiDouble(__,__): {
					a1 = cast(args[0]: FiExp -> FiDouble);
					a2 = cast(args[1]: FiExp -> FiDouble);
					Some(FiDouble(a1.d - a2.d, a1.start));
				}
				default: None();
			}
		}
		FcMulPrim(): {
			switch (args[0]) {
				FiInt(__,__): {
					a1 = cast(args[0]: FiExp -> FiInt);
					a2 = cast(args[1]: FiExp -> FiInt);
					Some(FiInt(a1.i * a2.i, a1.start));
				}
				FiDouble(__,__): {
					a1 = cast(args[0]: FiExp -> FiDouble);
					a2 = cast(args[1]: FiExp -> FiDouble);
					Some(FiDouble(a1.d * a2.d, a1.start));
				}
				default: None();
			}
		}
		FcDivPrim(): {
			switch (args[0]) {
				FiInt(__,__): {
					a1 = cast(args[0]: FiExp -> FiInt);
					a2 = cast(args[1]: FiExp -> FiInt);
					if (a2.i == 0) {
						make_err("division by zero", [a1.start, a2.start]);
					} else {
						Some(FiInt(a1.i / a2.i, a1.start));
					}
				}
				FiDouble(__,__): {
					a1 = cast(args[0]: FiExp -> FiDouble);
					a2 = cast(args[1]: FiExp -> FiDouble);
					if (a2.d == 0.0) {
						make_err("division by zero", [a1.start, a2.start]);
					} else {
						Some(FiDouble(a1.d / a2.d, a1.start));
					}
				}
				default: None();
			}
		}
		FcModPrim(): {
			switch (args[0]) {
				FiInt(__,__): {
					a1 = cast(args[0]: FiExp -> FiInt);
					a2 = cast(args[1]: FiExp -> FiInt);
					if (a2.i == 0) {
						make_err("division by zero", [a1.start, a2.start]);
					} else {
						Some(FiInt(a1.i % a2.i, a1.start));
					}
				}
				FiDouble(__,__): {
					a1 = cast(args[0]: FiExp -> FiDouble);
					a2 = cast(args[1]: FiExp -> FiDouble);
					if (a2.d == 0.0) {
						make_err("division by zero", [a1.start, a2.start]);
					} else {
						Some(FiDouble(a1.d % a2.d, a1.start));
					}
				}
				default: None();
			}
		}
		FcNegPrim(): {
			switch (args[0]) {
				FiInt(i, s): {
					Some(FiInt(-i, s));
				}
				FiDouble(d, s): {
					Some(FiDouble(-d, s));
				}
				default: None();
			}
		}
		FcArrayPrim(): {
			Some(FiCallPrim(FcArrayPrim(), args, call.type, call.start));
		}
		FcIndexPrim(): {
			switch (args[0]) {
				FiCallPrim(op, arr,__, s1): {
					switch (op) {
						FcArrayPrim(): {
							switch (args[1]) {
								FiInt(i, s2): {
									if (0 <= i && i < length(arr)) {
										Some(arr[i]);
									} else {
										make_err(
											"index " + i2s(i) + " is out of bounds, array length: " + i2s(length(arr)),
											[s1, s2]
										);
									}
								}
								default: None();
							}
						}
						default: None();
					}
				}
				default: None();
			}
		}
		FcStructPrim(name): {
			if (containsKeyHashMap(env.structs, name)) {
				Some(FiCallPrim(FcStructPrim(name), args, call.type, call.start));
			} else {
				None();
			}
		}
		FcFieldPrim(field): {
			switch (args[0]) {
				FiCallPrim(op, fields, type, start): {
					switch (op) {
						FcStructPrim(name): {
							if (field == "structname") {
								Some(FiString(name, call.start));
							} else {
								struct = lookupHashMapDef(env.structs, name, FiTypeStruct("", [], [], 0));
								i = findiDef(struct.args, \arg -> arg.name == field, -1);
								if (i == -1) {
									make_err("unknown field " + field + " in struct " + name, [call.start]);
								} else {
									Some(fields[i]);
								}
							}
						}
						default: None();
					}
				}
				default: None();
			}
		}
		default: {
			None();
		}
	}
}

fiConstExpTypeId(e: FiExp) -> int {
	switch (e) {
		FiVoid(__): 0;
		FiInt(__,__): 1;
		FiBool(__,__): 2;
		FiDouble(__,__): 3;
		FiString(__,__): 4;
		FiCallPrim(op,__,__,__): {
			switch (op) {
				FcArrayPrim(): 6;
				FcRefPrim(): 7;
				FcStructPrim(__): 9;
				default: -1;
			}
		}
		FiLambda(__,__,__,__): 8;
		default: -1;
	}
}

fiConstExpCompare(e1: FiExp, e2: FiExp) -> int {
	switch (e1) {
		FiCallPrim(op1, es1,__,__): {
			switch (e2) {
				FiCallPrim(op2, es2,__,__): {
					switch (op1) {
						FcArrayPrim(): {
							switch (op2) {
								FcArrayPrim(): {
									if (length(es1) != length(es1)) {
										length(es1) - length(es1);
									} else {
										fold(
											zipWith(es1, es2, \x, y -> Pair(x, y)), 0,
											\acc, p -> {
												if (acc != 0) acc else fiConstExpCompare(p.first, p.second)
											}
										);
									}
								}
								default: fiConstExpTypeId(e1) - fiConstExpTypeId(e2);
							}
						}
						FcStructPrim(name1): {
							switch (op2) {
								FcStructPrim(name2): {
									if (name1 != name2) {
										genericCompare(name1, name2);
									} else if (length(es1) != length(es1)) {
										length(es1) - length(es1);
									} else {
										fold(
											zipWith(es1, es2, \x, y -> Pair(x, y)), 0,
											\acc, p -> {
												if (acc != 0) acc else fiConstExpCompare(p.first, p.second)
											}
										);
									}
								}
								default: fiConstExpTypeId(e1) - fiConstExpTypeId(e2);
							}
						}
						default: -1;
					}
				}
				default: fiConstExpTypeId(e1) - fiConstExpTypeId(e2);
			}
		}
		FiVoid(__): {
			switch (e2) {
				FiVoid(__): 0;
				default: fiConstExpTypeId(e1) - fiConstExpTypeId(e2);
			}
		}
		FiBool(b1,__): {
			switch (e2) {
				FiBool(b2,__): b2i(b1) - b2i(b2);
				default: fiConstExpTypeId(e1) - fiConstExpTypeId(e2);
			}
		}
		FiInt(i1,__): {
			switch (e2) {
				FiInt(i2,__): i1 - i2;
				default: fiConstExpTypeId(e1) - fiConstExpTypeId(e2);
			}
		}
		FiDouble(d1,__): {
			switch (e2) {
				FiDouble(d2,__): if (d1 < d2) -1 else if (d1 > d2) 1 else 0;
				default: fiConstExpTypeId(e1) - fiConstExpTypeId(e2);
			}
		}
		FiString(s1,__): {
			switch (e2) {
				FiString(s2,__): genericCompare(s1, s2);
				default: fiConstExpTypeId(e1) - fiConstExpTypeId(e2);
			}
		}
		FiLambda(__,__,__,__): {
			// All compile-time lambdas are considered non-equal
			-1;
		}
		default: -1;
	}
}

