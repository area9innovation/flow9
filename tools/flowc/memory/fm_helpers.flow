import ds/array;
import tools/flowc/memory/fmexp;

export {
	fmWrapExp(es: [FmExp]) -> FmExp;
	fmUnwrapExp(e: FmExp) -> [FmExp];

	fmExpType(e: FmExp) -> FiType;
}

// FmSeq(es: [FmExp], type : FmType, start : int);

fmWrapExp(es: [FmExp]) -> FmExp {
	if (length(es) == 0) FmSeq([], FiTypeVoid(), 0) else
	if (length(es) == 0) es[0] else {
		last = es[length(es) - 1];
		FmSeq(es, fmExpType(last), last.start);
	}
}

fmUnwrapExp(e: FmExp) -> [FmExp] {
	switch (e) {
		FmSeq(es,__,__): es;
		default: [e];
	}
}

fmExpType(e: FmExp) -> FiType {
	switch(e) {
		FmLambda(__, __, type, __) : type;
		FmCall(__, __, type, __) : type;
		FmLet(__, __, __, __, type2, __) : type2;
		FmIf(__, __, __, type, __) : type;
		FmSwitch(__, __, __, type, __) : type;
		FmCast(__, __, __, type, __) : type;
		FmSeq(__, type, __) : type;
		FmCallPrim(__, __, type, __) : type;
		FmRequire(__, __, type, __) : type;
		FmUnsafe(__, __, type, __) : type;
		FmMemory(__, ex,__): fmExpType(ex);
		FiVar(__, type, __) : type;
		FiVoid(__) : FiTypeVoid();
		FiDouble(__, __) : FiTypeDouble();
		FiInt(__, __) : FiTypeInt();
		FiString(__, __) : FiTypeString();
		FiBool(__, __) : FiTypeBool();
	}
}