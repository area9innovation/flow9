import tools/flowc/memory/fmexp;
import tools/flowc/manipulation/effects;
import string_utils;

export {
	fmExpInfo(fm: FmExp) -> FmInfo;

	fmWrapExp(es: [FmExp]) -> FmExp;
	fmUnwrapExp(e: FmExp) -> [FmExp];

	// Checks that there's no statement constructions: switch, if, let and sequence of length > 1
	fiExpHasNoStatements(e: FiExp) -> bool;

	fiExpHasEffects(e: FiExp, effects: FiEffects) -> bool;

	// Prettyprinters for expressions
	fmPrim2s(op: FmPrim, es: [string], type: FiType) -> string;
	fmExp2s(ex: FmExp) -> string;
}

fmExpInfo(fm: FmExp) -> FmInfo {
	switch(fm) {
		FmLambda(__,__,__,info): info;
		FmCall(__,__,info):      info;
		FmLet(__,__,__,info):    info;
		FmIf(__,__,__,info):     info;
		FmSwitch(__,__,__,info): info;
		FmSeq(__,info):          info;
		FmCallPrim(__,__,info):  info;
		FmMemory(__,__,info):    info;
		FmVar(__,__,info):       info;
		FmAssign(__,__,info):    info;
		FiVoid(start):      FmInfo(makeSet(), FiTypeVoid(), start);
		FiDouble(__,start): FmInfo(makeSet(), FiTypeDouble(), start);
		FiInt(__,start):    FmInfo(makeSet(), FiTypeInt(), start);
		FiString(__,start): FmInfo(makeSet(), FiTypeString(), start);
		FiBool(__,start):   FmInfo(makeSet(), FiTypeBool(), start);
	}
}

fmWrapExp(es: [FmExp]) -> FmExp {
	if (length(es) == 0) FmSeq([], FmInfo(makeSet(), FiTypeVoid(), 0)) else
	if (length(es) == 0) es[0] else {
		last = es[length(es) - 1];
		free = fold(es, makeSet(), \acc, fm -> mergeSets(acc, fmExpInfo(fm).free));
		info = fmExpInfo(last);
		FmSeq(es, FmInfo(info with free = free));
	}
}

fmUnwrapExp(e: FmExp) -> [FmExp] {
	switch (e) {
		FmSeq(es,__): es;
		default: [e];
	}
}

fiExpHasNoStatements(e: FiExp) -> bool {
	switch (e) {
		FiSeq(es, type,__): 
			if (length(es) == 0) true else	
			if (length(es) == 1) {
				fiExpHasNoStatements(es[0]) && type != FiTypeVoid();
			} else false;
		FiCast(ex,__,__,__,__): fiExpHasNoStatements(ex);
		FiCall(f, args,__,__): fiExpHasNoStatements(f) && forall(args, fiExpHasNoStatements);
		FiSwitch(__,__,__,__,__): false;
		FiLambda(__,__,__,__): true;
		FiLet(__,__,__,__,__, __): false;
		FiIf(e1, e2, e3,__, __): fiExpHasNoStatements(e1) && fiExpHasNoStatements(e2) && fiExpHasNoStatements(e3);   
		FiCallPrim(op, es,__, __): {
			switch (op) {
				FcAssignPrim(): false;
				FcSetMutablePrim(field): false;
				default: forall(es, fiExpHasNoStatements);
			}
		}
		FiRequire(__,__,__,__): false;
		FiUnsafe(__,__,__,__): false;
		default: true;
	}
}

fiExpHasEffects(e: FiExp, effects: FiEffects) -> bool {
	switch (e) {
		FiSeq(es, type,__): exists(es, \x -> fiExpHasEffects(x, effects));
		FiCast(ex,__,__,__,__): fiExpHasEffects(ex, effects);
		FiCall(f, args,__,__): fiExpHasEffects(f, effects) || exists(args, \x -> fiExpHasEffects(x, effects));
		FiSwitch(__,__,cases,__,__): exists(cases, \c -> fiExpHasEffects(c.body, effects));
		FiLambda(__,body,__,__): fiExpHasEffects(body, effects);
		FiLet(__,__,e1,e2,__, __): fiExpHasEffects(e1, effects) || fiExpHasEffects(e2, effects);
		FiIf(e1, e2, e3,__, __): fiExpHasEffects(e1, effects) || fiExpHasEffects(e2, effects) || fiExpHasEffects(e3, effects);
		FiCallPrim(op, es,__, __): {
			exists(es, \x -> fiExpHasEffects(x, effects)) ||
			switch (op) {
				FcRefPrim(): true;
				default: false;
			}
		}
		FiRequire(__,ex,__,__): fiExpHasEffects(ex, effects);
		FiUnsafe(__,__,__,__): true;
		FiVar(name,__,__): containsSet(effects.hasEffects, name);
		default: false;
	}
}

fmPrim2s(op: FmPrim, es: [string], type: FiType) -> string {
	t2s = \t -> prettyFiType(dummyPretty, t, makeSet());
	switch (op) {
		FmOrPrim():  "(" + es[0] + " || " + es[1] + ")";
		FmAndPrim(): "(" + es[0] + " && " + es[1] + ")";
		FmNotPrim(): "!" + es[0];
		FmEqPrim():  "(" + es[0] + " == " + es[1] + ")";
		FmNePrim():  "(" + es[0] + " != " + es[1] + ")";
		FmLePrim():  "(" + es[0] + " <= " + es[1] + ")";
		FmGePrim():  "(" + es[0] + " >= " + es[1] + ")";
		FmLtPrim():  "(" + es[0] + " < " + es[1] + ")";
		FmGtPrim():  "(" + es[0] + " > " + es[1] + ")";
		FmPlusPrim():  "(" + es[0] + " + " + es[1] + ")";
		FmMinusPrim(): "(" + es[0] + " - " + es[1] + ")"; 
		FmMulPrim():   "(" + es[0] + " * " + es[1] + ")";
		FmDivPrim():   "(" + es[0] + " / " + es[1] + ")";
		FmModPrim():   "(" + es[0] + " % " + es[1] + ")";
		FmNegPrim():   "-" + es[0];
		FmArrayPrim():   "[" + strGlue(es,  ", ") + "]";
		FmIndexPrim():   es[0] + "[" + es[1] + "]";
		FmDerefPrim():   "(*" +es[0] + ")";
		FmRefPrim():     "ref " + es[0];
		FmStructPrim(struct_name): {
			struct_type = cast(type : FiType -> FiTypeName);
			typars = if (struct_type.typeparameters == []) "" else 
				"<" + superglue(struct_type.typeparameters, \tp -> t2s(tp), ", ") + ">";
			struct_name + typars + "(" + strGlue(es, ", ") + ")";
		}
		FmFieldPrim(name): es[0] + "." + name;
		FmRequirePrim(file): {
			"require " + file + " " + es[0];
		}
		FmUnsafePrim(name): {
			"unsafe " + name + " " + es[0];
		}
		FmCastPrim(from, to): {
			"(" + es[0] + " : " + t2s(from) + " -> " + t2s(to) + ")";
		}
		FmIfPrim(): {
			"(" + es[0] + " ? " + es[1] + " : " + es[2] + ")";
		}
		FmReusePrim(name, reuse): {
			struct_type = cast(type : FiType -> FiTypeName);
			typars = if (struct_type.typeparameters == []) "" else 
				"<" + superglue(struct_type.typeparameters, \tp -> t2s(tp), ", ") + ">";
			name + typars + "@" + reuse + "(" + strGlue(es, ", ") + ")";
		}
	}
}

fmExp2s(ex: FmExp) -> string {
	t2s = \t -> prettyFiType(dummyPretty, t, makeSet());
	switch (ex) {
		FmLet(v, e1, e2,__): {
			v.name + " : " + t2s(v.info.type) + " = " + fmExp2s(e1) + ";\n" + fmExp2s(e2);
		}
		FmIf(e, s1, s2, __): {
			"if (" + fmExp2s(e) + ") " + fmExp2s(s1) + " else " + fmExp2s(s2);
		}
		FmSwitch(v,__, cases, __): {
			"switch (" + fmExp2s(v) + ") {\n" +
				strIndent(superglue(cases, \c -> {
					body_s = fmExp2s(c.body);
					body_s1 = if (strContains(body_s, "\n") || startsWith(body_s, "{")) body_s else body_s + ";";
					c.struct + "(" + superglue(c.args, \arg -> arg.name, ", ") + "): " + body_s1;
				}, "\n")) +
			"\n}";
		}
		FmSeq(ss,__): {
			if (length(ss) == 0) "{}" else
			if (length(ss) == 1) fmExp2s(ss[0]) else
			"{\n" + strIndent(superglue(ss, fmExp2s, ";\n")) + "\n}";
		}
		FmAssign(to, what,__): {
			fmExp2s(to) + " := " +  fmExp2s(what);
		}
		FmMemory(op, e,__): {
			switch (op) {
				FmDup():      "dup(" + fmExp2s(e) + ");";
				FmDrop():     "drop(" + fmExp2s(e) + ");";
				FmReuse():    "reuse(" + fmExp2s(e) + ");";
				FmDispose():  "dispose(" + fmExp2s(e) + ");";
				FmIsUnique(): "is_unique(" + fmExp2s(e) + ");";
				FmDecRef():   "dec_ref(" + fmExp2s(e) + ")";
				FmNull():     "nullptr";
			}
		}
		FmLambda(__, args, body,__): {
			body_s = fmExp2s(body);
			header = "\\" + superglue(args, \arg -> arg.name + ":" + t2s(arg.type), ", ") + " -> ";
			if (!strContains(body_s, "\n") || startsWith(body_s, "{")) header + body_s else header + "{\n" + strIndent(body_s) + "\n}";
		}
		FmCall(f, args,__): {
			fmExp2s(f) + "(" + superglue(args, fmExp2s, ", ") + ")";
		}
		FmCallPrim(op, es, info): {
			fmPrim2s(op, map(es, fmExp2s), info.type);
		}
		FmVar(name,__,__): name;
		FiVoid(__):      "{}";
		FiDouble(d, __): d2s(d);
		FiInt(i, __):    i2s(i)
		FiString(s, __): "\"" + escapeStr(s) + "\"";
		FiBool(b, __):   b2s(b);
	}
}
