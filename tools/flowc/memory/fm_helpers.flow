import tools/flowc/memory/fmexp;
import tools/flowc/manipulation/effects;

export {
	fmFreeVars(fm: FmExp) -> [FmVar];
	fmExpType(e: FmExp) -> FiType;
	fmExpStart(e: FmExp) -> int;

	fmWrapExp(es: [FmExp]) -> FmExp;
	fmUnwrapExp(e: FmExp) -> [FmExp];

	// Checks that there's no statement constructions: switch, if, let and sequence of length > 1
	fiExpHasNoStatements(e: FiExp) -> bool;

	fiExpHasEffects(e: FiExp, effects: FiEffects) -> bool;
}

fmFreeVars(fm: FmExp) -> [FmVar] {
	switch(fm) {
		FmLambda(__,__,info):    info.free;
		FmCall(__,__,info):      info.free;
		FmLet(__,__,__,info):    info.free;
		FmIf(__,__,__,info):     info.free;
		FmSwitch(__,__,__,info): info.free;
		FmSeq(__,info):          info.free;
		FmCallPrim(__,__,info):  info.free;
		FmMemory(__,__,x):       fmFreeVars(x);
		FmVar(__,local,__):      if (local) [fm] else [];
		default: [];
	}
}

fmExpType(e: FmExp) -> FiType {
	switch(e) {
		FmLambda(__,__,info):    info.type;
		FmCall(__,__,info):      info.type;
		FmLet(__,__,__,info):    info.type;
		FmIf(__,__,__,info):     info.type;
		FmSwitch(__,__,__,info): info.type;
		FmSeq(__,info):          info.type;
		FmCallPrim(__,__,info):  info.type;
		FmAssign(__,__,info):    info.type;
		FmMemory(__,__,x):       fmExpType(x);
		FmVar(__,__,info):       info.type;
		FiVoid(__):      FiTypeVoid();
		FiDouble(__,__): FiTypeDouble();
		FiInt(__,__):    FiTypeInt();
		FiString(__,__): FiTypeString();
		FiBool(__,__):   FiTypeBool();
	}
}

fmExpStart(e: FmExp) -> int {
	switch(e) {
		FmLambda(__,__,info):    info.start;
		FmCall(__,__,info):      info.start;
		FmLet(__,__,__,info):    info.start;
		FmIf(__,__,__,info):     info.start;
		FmSwitch(__,__,__,info): info.start;
		FmSeq(__,info):          info.start;
		FmCallPrim(__,__,info):  info.start;
		FmAssign(__,__,info):    info.start;
		FmMemory(__,__,x):       fmExpStart(x);
		FmVar(__,__,info):       info.start;
		FiVoid(start):      start;
		FiDouble(__,start): start;
		FiInt(__,start):    start;
		FiString(__,start): start;
		FiBool(__,start):   start;
	}
}

fmWrapExp(es: [FmExp]) -> FmExp {
	if (length(es) == 0) FmSeq([], FmInfo([], FiTypeVoid(), 0)) else
	if (length(es) == 0) es[0] else {
		last = es[length(es) - 1];
		free = fold(es, [], \acc, fm -> concat(acc, fmFreeVars(fm)));
		FmSeq(es, FmInfo(free, fmExpType(last), fmExpStart(last)));
	}
}

fmUnwrapExp(e: FmExp) -> [FmExp] {
	switch (e) {
		FmSeq(es,__): es;
		default: [e];
	}
}

fiExpHasNoStatements(e: FiExp) -> bool {
	switch (e) {
		FiSeq(es, type,__): 
			if (length(es) == 0) true else	
			if (length(es) == 1) {
				fiExpHasNoStatements(es[0]) && type != FiTypeVoid();
			} else false;
		FiCast(ex,__,__,__,__): fiExpHasNoStatements(ex);
		FiCall(f, args,__,__): fiExpHasNoStatements(f) && forall(args, fiExpHasNoStatements);
		FiSwitch(__,__,__,__,__): false;
		FiLambda(__,__,__,__): true;
		FiLet(__,__,__,__,__, __): false;
		FiIf(e1, e2, e3,__, __): fiExpHasNoStatements(e1) && fiExpHasNoStatements(e2) && fiExpHasNoStatements(e3);   
		FiCallPrim(op, es,__, __): forall(es, fiExpHasNoStatements);
		FiRequire(__,__,__,__): false;
		FiUnsafe(__,__,__,__): false;
		default: true;
	}
}

fiExpHasEffects(e: FiExp, effects: FiEffects) -> bool {
	switch (e) {
		FiSeq(es, type,__): exists(es, \x -> fiExpHasEffects(x, effects));
		FiCast(ex,__,__,__,__): fiExpHasEffects(ex, effects);
		FiCall(f, args,__,__): fiExpHasEffects(f, effects) || exists(args, \x -> fiExpHasEffects(x, effects));
		FiSwitch(__,__,cases,__,__): exists(cases, \c -> fiExpHasEffects(c.body, effects));
		FiLambda(__,body,__,__): fiExpHasEffects(body, effects);
		FiLet(__,__,e1,e2,__, __): fiExpHasEffects(e1, effects) || fiExpHasEffects(e2, effects);
		FiIf(e1, e2, e3,__, __): fiExpHasEffects(e1, effects) || fiExpHasEffects(e2, effects) || fiExpHasEffects(e3, effects);
		FiCallPrim(op, es,__, __): {
			exists(es, \x -> fiExpHasEffects(x, effects)) ||
			switch (op) {
				FcRefPrim(): true;
				default: false;
			}
		}
		FiRequire(__,ex,__,__): fiExpHasEffects(ex, effects);
		FiUnsafe(__,__,__,__): true;
		FiVar(name,__,__): containsSet(effects.hasEffects, name);
		default: false;
	}
}
