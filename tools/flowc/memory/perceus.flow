import ds/multiset;
import tools/flowc/incremental/fiprettyprint;
import tools/flowc/memory/fm_helpers;
import tools/flowc/manipulation/freevars;

export {
	fmPerceus(e: FmExp, names: FiGlobalNames) -> FmExp;
	perceus_debug_flag = ref false;
}

PerceusContext(
	borrowed: MultiSet<string>, 
	linear: MultiSet<string>,
	locals: Tree<string, FmVar>,
	names: FiGlobalNames
);

fmPerceus(e: FmExp, names: FiGlobalNames) -> FmExp {
	perceus_debug_exp := e;
	fmDoPerceus(e, PerceusContext(makeMultiSet(), makeMultiSet(), makeTree(), names));
}

perceus_debug_exp : ref FmExp = ref FiVoid(0);

perceusEnv2s(e: FmExp, ctx: PerceusContext) -> string {
	v2s = \v -> (if (v.local) "local " else "global ") + prettyFiType(dummyPretty, v.info.type, makeSet());
	"Borrowed: [" + multiSet2string(ctx.borrowed) +  "]\n" +
	"Linear: [" + multiSet2string(ctx.linear) +  "]\n" +
	"Locals: [" + superglue(tree2pairs(ctx.locals), \p -> p.first + " -> " + v2s(p.second) , ", ") +  "]\n" +
	"exp.free: [" + strGlue(set2array(fmExpInfo(e).free), ", ") + "]\n" + 
	"exp: `" + fmExp2s(e) + "`\n" + 
	"in expression: \n" + fmExp2s(^perceus_debug_exp) + "\n";
}

checkPerceusInvariants(e: FmExp, ctx: PerceusContext) -> void {
	contex_exp2s = \-> perceusEnv2s(e, ctx);

	// Δ∩Γ = ∅
	traverseInOrder(ctx.borrowed.tree, \v, i -> {
		if (containsKeyTree(ctx.linear.tree, v)) {
			println("Borrowed and linear variables intersects with: `" + v + "`\n" + contex_exp2s());
			fail("perceus invariants are violated");
		}
	});
	// multiplicity of each member in Δ, Γ is 1
	traverseInOrder(ctx.borrowed.tree, \v, i -> {
		if (i > 1) {
			println("Multiplicity of borrowed variable: `" + v + "` has multiplicity: " + i2s(i) + "\n" + contex_exp2s());
			fail("perceus invariants are violated");
		}
	});
	// multiplicity of each member in Δ, Γ is 1
	traverseInOrder(ctx.linear.tree, \v, i -> {
		if (i > 1) {
			println("Multiplicity of linear variable: `" + v + "` has multiplicity: " + i2s(i) + "\n" + contex_exp2s());
			fail("perceus invariants are violated");
		}
	});
	fv = fmExpInfo(e).free;
	// Γ ⊆ fv(e)
	traverseInOrder(ctx.linear.tree, \v, i -> {
		if (!containsSet(fv, v)) {
			println("Variable: `" + v + "` from linear context is not found in expression:" + "\n" + contex_exp2s());
			fail("perceus invariants are violated");
		}
	});
	// fv(e) ⊆ Δ, Γ
	iterSet(fv, \v -> {
		if (!(containsKeyTree(ctx.borrowed.tree, v) || containsKeyTree(ctx.linear.tree, v))) {
			println("Free variable: `" + v + "` from expression: \n" + fmExp2s(e) + "\nis not found in linear or borrowed context" + "\n" + contex_exp2s());
			fail("perceus invariants are violated");
		}
	});
}

//FmInfo(free: Set<string>, type: FiType, start: int);

fmPerceusMakeDrops(vars: [string], ctx: PerceusContext) -> [FmExp] {
	filtermap(vars, \n ->
		switch (lookupTree(ctx.locals, n)) {
			Some(w): 
				if (fiTypeIsScalar(fmExpInfo(w).type)) None()
				else Some(FmMemory(FmDrop(), w, FmInfo(makeSet(), FiTypeVoid(), w.info.start)));
			None(): fail0("linear variable: " + n + " is not found");
		}
	);
}

fmPerceusToDrop(e: FmExp, ctx: PerceusContext) -> [FmExp] {
	info = fmExpInfo(e);
	vars_to_drop = multiSet2array(diffMultiSets(ctx.linear, set2multiSet(info.free)));
	fmPerceusMakeDrops(vars_to_drop, ctx);
}

fmDoPerceus(ex: FmExp, ctx: PerceusContext) -> FmExp {
	checkPerceusInvariants(ex, ctx);
	switch (ex) {
		FmSeq(es, info): {
			if (length(es) == 0) FmSeq([], info) else
			if (length(es) == 1) {
				fmWrapExp(concat(
					fmPerceusToDrop(es[0], ctx),
					[fmDoPerceus(es[0], ctx)]
				));
			} else {
				infos = map(es, fmExpInfo);
				all_frees_upto = mapi(es, \i, __ -> 
					foldi(infos, makeSet(), \j, acc, inf ->
						if (j < i) acc else mergeSets(acc, inf.free)
					)
				);
				to_free = mapi(all_frees_upto, \i, vars -> 
					set2array(if (i + 1 == length(all_frees_upto)) all_frees_upto[i] else
					differenceSets(all_frees_upto[i], all_frees_upto[i + 1]))
				);
				es_p = fmDoPerceusExps(es, ctx);
				FmSeq(concatA(mapi(es_p.first, \i, x -> 
						concat(fmPerceusMakeDrops(to_free[i], ctx), [x])
					)), info
				);
			}
		}
		FmCall(f, args, info): {
			pargs = fmDoPerceusExps(args, ctx);
			FmCall(fmDoPerceus(f, pargs.second), pargs.first, info);
		}
		FmSwitch(v, vtype, cases, info): {
			/*if (!containsKeyTree(ctx.linear.tree, v.name)) {
				println(
					"Linear context doesn't contain a switch variable: " + v.name + ",\n" +
					"linear: [" + strGlue(getTreeKeys(ctx.linear.tree), ", ") + "]\n" + 
					"borrowed: [" + strGlue(getTreeKeys(ctx.borrowed.tree), ", ") + "]\n" +
					"locals: [" + strGlue(getTreeKeys(ctx.locals), ", ") + "]\n" +
					"in expression: \n" + fmExp2s(^perceus_debug_exp) + "\n"
				);
				fail("AAA");
			}*/
			sw = FmSwitch(v, vtype,
				map(cases, \c -> {
					//linear0 = ctx.linear;
					c_freevars = set2multiSet(fmExpInfo(c.body).free);
					//linear1 = linear0;
					linear2 = intersectMultiSets(ctx.linear, c_freevars);
					//linear3 = diffMultiSets(ctx.linear, c_freevars);
					//c_body = ;
					//c_locals = fold(c.args, ctx.locals, \acc, w -> setTree(acc, w.name, w));
					/*if (^perceus_debug_flag) {
						println("AAA:\n"
							"c.body: " + fmExp2s(c.body) + "\n" +
							"linear0: [" + multiSet2string(linear0) + "]\n" + 
							"c_freevars: [" + multiSet2string(c_freevars) + "]\n" + 
							"linear1: [" + multiSet2string(linear1) + "]\n" + 
							"linear2: [" + multiSet2string(linear2) + "]\n" + 
							"linear3: [" + multiSet2string(linear3) + "]\n" +
							"c_body: " + fmExp2s(c_body) + "\n"
						);
					}*/
					FmCase(c.struct, c.args, 
						fmWrapExp(concat(
							fmPerceusToDrop(c.body, ctx),
							[fmDoPerceus(c.body, PerceusContext(ctx with linear = linear2))]
						)),
						c.start
					);
				}),
				info
			);
			if (!v.local || fiTypeIsScalar(v.info.type) || containsMultiSet(ctx.linear, v.name)) sw else {
				FmSeq([FmMemory(FmDup(), v, info), sw], info);
			}
		}
		FmLambda(toplevel, args, body, info): {
			ys = set2multiSet(fmExpInfo(ex).free);
			body_free = fmExpInfo(body).free;
			delta1 = diffMultiSets(ys, ctx.linear);
			lambda_locals = fold(args, ctx.locals, \acc, arg -> 
				setTree(acc, arg.name, FmVar(arg.name, true, FmInfo(makeSet1(arg.name), arg.type, info.start)))
			);
			p_body = fmDoPerceus(body, 
				PerceusContext(
					makeMultiSet(), 
					uniteMultiSets(ys,
						buildMultiSet(filtermap(args, \arg -> 
							if (containsSet(body_free, arg.name)) Some(Pair(arg.name, 1)) else None()
						))
					),
					lambda_locals,
					ctx.names
				)
			);
			fmWrapExp(concat(
				filtermap(multiSet2array(delta1), \v -> 
					switch (lookupTree(lambda_locals, v)) {
						Some(w): {
							if (fiTypeIsScalar(fmExpInfo(w).type)) None()
							else Some(FmMemory(FmDup(), w, FmInfo(makeSet1(v), FiTypeVoid(), info.start)));
						}
						None(): fail0("variable " + v  + " is not found in locals: [" + 
							strGlue(getTreeKeys(ctx.locals), ", ") + "]"
						);
					}
				),
				[FmLambda(toplevel, args, p_body, info)]
			))
		}
		FmLet(var, e1, e2, info): {
			fv_e2 = set2multiSet(fmExpInfo(e2).free);
			if (containsMultiSet(fv_e2, var.name)) {
				linear2 = intersectMultiSets(ctx.linear, removeMultiSet(fv_e2, var.name));
				FmLet(var,
					fmDoPerceus(e1, PerceusContext(ctx with
						borrowed = uniteMultiSets(ctx.borrowed, linear2),
						linear = diffMultiSets(ctx.linear, linear2)
					)),
					fmDoPerceus(e2, PerceusContext(ctx with 
						linear = insertMultiSet(linear2, var.name),
						locals = setTree(ctx.locals, var.name, var)
					)),
					info
				);
			} else {
				p2 = fmDoPerceusExp(e2, ctx);
				FmLet(var,
					fmDoPerceus(e1, p2.second),
					p2.first, info
				);
			}
		}
		FmIf(e1, e2, e3, info): {
			p1 = fmDoPerceusExp(e1, ctx);
			FmIf(p1.first, 
				fmWrapExp(concat(
					fmPerceusToDrop(e2, p1.second),
					[fmDoPerceus(e2, PerceusContext(p1.second with 
						linear = intersectMultiSets(p1.second.linear, set2multiSet(fmExpInfo(e2).free))
					))]
				)),
				fmWrapExp(concat(
					fmPerceusToDrop(e3, p1.second),
					[fmDoPerceus(e3, PerceusContext(p1.second with 
						linear = intersectMultiSets(p1.second.linear, set2multiSet(fmExpInfo(e3).free))
					))]
				)), 
				info
			);
		}
		FmCallPrim(op, es, info): {
			FmCallPrim(op, fmDoPerceusExps(es, ctx).first, info);
		}
		FmAssign(to, what, info): {
			p1 = fmDoPerceusExp(to, ctx);
			if (fiTypeIsScalar(fmExpInfo(to).type)) {
				FmAssign(p1.first, fmDoPerceus(what, p1.second), info);
			} else {
				FmSeq([FmMemory(FmDrop(), p1.first, info), FmAssign(p1.first, fmDoPerceus(what, p1.second), info)], info);
			}
		}
		FmVar(name, local, info): {
			if (!local || fiTypeIsScalar(info.type) || containsMultiSet(ctx.linear, name)) ex else {
				FmSeq([FmMemory(FmDup(), ex, info), ex], ex.info);
			}
		}
		FmMemory(op, e, info): ex;
		FiString(__,__): ex;
		FiInt(__,__): ex;
		FiDouble(__,__): ex;
		FiBool(__,__): ex;
		FiVoid(__): ex;
	}
}

fmDoPerceusExp(e: FmExp, ctx: PerceusContext) -> Pair<FmExp, PerceusContext> {
	fv = set2multiSet(fmExpInfo(e).free);
	linear2 = intersectMultiSets(ctx.linear, fv);
	Pair(
		fmDoPerceus(e, PerceusContext(ctx with linear = linear2)),
		PerceusContext(ctx with
			borrowed = uniteMultiSets(ctx.borrowed, linear2),
			linear = diffMultiSets(ctx.linear, linear2)
		)
	);
}

fmDoPerceusExps(es: [FmExp], ctx: PerceusContext) -> Pair<[FmExp], PerceusContext> {
	foldr(es, Pair([], ctx), \acc, e -> {
		p = fmDoPerceusExp(e, acc.second);
		Pair(concat([p.first], acc.first), p.second);
	});
}

isGlobalVar(name: string, names: FiGlobalNames) -> bool {
	switch (lookupTree(names.toplevel, name)) {
		Some(dec): {
			switch (dec) {
				FiGlobalVar(__,__,__,__,__): true;
				default: false;
			}
		}
		None(): false;
	}
}
