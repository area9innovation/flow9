import ds/multiset;
import tools/flowc/incremental/fiprettyprint;
import tools/flowc/memory/fm_helpers;
import tools/flowc/manipulation/freevars;

export {
	PerceusContext(
		borrowed: MultiSet<string>, 
		linear: MultiSet<string>,
		locals: Tree<string, FmVar>
	);
	fmPerceus(e: FmExp, ctx: PerceusContext) -> FmExp;
}

checkPerceusInvariants(e: FmExp, ctx: PerceusContext) -> void {
	// Δ∩Γ = ∅
	traverseInOrder(ctx.borrowed.tree, \v, i -> {
		if (containsKeyTree(ctx.linear.tree, v)) {
			println("Borrowed and linear variables intersects with: " + v);
		}
	});
	// multiplicity of each member in Δ, Γ is 1
	traverseInOrder(ctx.borrowed.tree, \v, i -> {
		if (i > 1) {
			println("Multiplicity of borrowed variable: " + v + " has multiplicity: " + i2s(i));
		}
	});
	// multiplicity of each member in Δ, Γ is 1
	traverseInOrder(ctx.linear.tree, \v, i -> {
		if (i > 1) {
			println("Multiplicity of linear variable: " + v + " has multiplicity: " + i2s(i));
		}
	});
	fv = fmExpInfo(e).free;
	// Γ ⊆ fv(e)
	traverseInOrder(ctx.linear.tree, \v, i -> {
		if (!containsSet(fv, v)) {
			println("Variable: " + v + " from linear context is not found in expression:\n" + fmExp2s(e));
		}
	});
	// fv(e) ⊆ Δ, Γ
	iterSet(fv, \v -> {
		if (!(containsKeyTree(ctx.borrowed.tree, v) || containsKeyTree(ctx.linear.tree, v))) {
			println("Freee variable: " + v + " from expression: +\n`" + fmExp2s(e) + " is not found in linear or borrowed context");
		}
	});
}

fmPerceus(ex: FmExp, ctx: PerceusContext) -> FmExp {
	checkPerceusInvariants(ex, ctx);
	switch (ex) {
		FmSeq(es, info): {
			if (length(es) == 0) FmSeq([], info) else
			if (length(es) == 1) fmPerceus(es[0], ctx) else {
				FmSeq(fmPerceusExps(es, ctx).first, info);
			}
		}
		FmCall(f, args, info): {
			pargs = fmPerceusExps(args, ctx);
			FmCall(fmPerceus(f, pargs.second), pargs.first, info);
		}
		FmSwitch(v, vtype, cases, info): {
			if (!containsKeyTree(ctx.linear.tree, v.name)) {
				println("Linear context doesn't contain a switch variable: " + v.name);
			}
			FmSwitch(v, vtype,
				map(cases, \c -> {
					c_boundvars = buildMultiSet(filtermap(c.args, \n -> if (n.name == "__") None() else Some(Pair(n.name, 1))));
					c_freevars = set2multiSet(fmExpInfo(c.body).free);
					linear1 = uniteMultiSets(ctx.linear, c_boundvars);
					linear2 = intersectMultiSets(linear1, c_freevars);
					linear3 = diffMultiSets(linear1, linear2);
					c_body = fmPerceus(c.body, PerceusContext(ctx with linear = linear2));
					c_locals = fold(c.args, ctx.locals, \acc, w -> setTree(acc, w.name, w));
					FmCase(c.struct, c.args, 
						fmWrapExp(concat(
							foldMultiSet(linear3, [], \acc, n, __ ->
								switch (lookupTree(c_locals, n)) {
									Some(w): concat(acc, [FmMemory(FmDrop(), w, info)]);
									None(): fail0("linear variable: " + n + " is not found");
								}
							),
							[c_body]
						)),
						/*foldMultiSet(linear3, c_body, \acc, n, __ ->
							FmMemory(FmDrop(), acc, info)
						),*/
						c.start
					);
				}),
				info
			);
		}
		FmLambda(toplevel, args, body, infos): {
			fv_body = fmExpInfo(body).free;
			// TODO
			ex;
		}
		FmLet(var, e1, e2, info): {
			fv_e2 = set2multiSet(fmExpInfo(e2).free);
			if (containsMultiSet(fv_e2, var.name)) {
				linear2 = intersectMultiSets(ctx.linear, removeMultiSet(fv_e2, var.name));
				FmLet(var,
					fmPerceus(e1, PerceusContext(
						uniteMultiSets(ctx.borrowed, linear2),
						diffMultiSets(ctx.linear, linear2),
						ctx.locals
					)),
					fmPerceus(e2, PerceusContext(ctx with 
						linear = insertMultiSet(linear2, var.name),
						locals = setTree(ctx.locals, var.name, var)
					)),
					info
				);
			} else {
				p2 = fmPerceusExp(e2, ctx);
				FmLet(var,
					fmPerceus(e1, p2.second),
					p2.first, info
				);
			}
		}
		FmIf(e1, e2, e3, info): {
			FiVoid(0);
		}
		FmCallPrim(op, es, info): {
			FmCallPrim(op, fmPerceusExps(es, ctx).first, info);
		}
		FmAssign(to, what, start): {
			ex;
		}
		FmVar(name, local, info): {
			if (containsMultiSet(ctx.linear, name)) ex else {
				FmSeq(
					[FmMemory(FmDup(), ex, info), ex], ex.info
				);
			}
		}
		FmMemory(op, e, info): {
			ex;
		}
		FiString(__,__): ex;
		FiInt(__,__): ex;
		FiDouble(__,__): ex;
		FiBool(__,__): ex;
		FiVoid(__): ex;
	}
}

fmPerceusExp(e: FmExp, ctx: PerceusContext) -> Pair<FmExp, PerceusContext> {
	fv = set2multiSet(fmExpInfo(e).free);
	linear2 = intersectMultiSets(ctx.linear, fv);
	Pair(
		fmPerceus(e, PerceusContext(ctx with linear = linear2)),
		PerceusContext(
			uniteMultiSets(ctx.borrowed, linear2),
			diffMultiSets(ctx.linear, linear2),
			ctx.locals
		)
	);
}

fmPerceusExps(es: [FmExp], ctx: PerceusContext) -> Pair<[FmExp], PerceusContext> {
	foldr(es, Pair([], ctx), \acc, e -> {
		p = fmPerceusExp(e, acc.second);
		Pair(concat([p.first], acc.first), p.second);
	});
}
