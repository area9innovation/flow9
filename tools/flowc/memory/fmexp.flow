import ds/set;
import tools/flowc/incremental/fiexp;

export {
	FmExp ::= FmLet, FmIf, FmSwitch, FmSeq, FmAssign, FmMemory, FmTerm;
		FmLet(var: FmVar, e1: FmExp, e2: FmExp, info: FmInfo);
		FmIf(e1: FmExp, e2: FmExp, e3: FmExp, info: FmInfo);
		FmSwitch(x: FmVar, switchType : FiType, cases: [FmCase], info: FmInfo);
			FmCase(struct: string, argNames : [string], body: FmExp, start : int);
		FmSeq(es: [FmExp], info: FmInfo);
		FmAssign(to: FmExp, what: FmExp, info: FmInfo);

	FmTerm ::= FmLambda, FmCall, FmCallPrim, FmVar, FiConst;
		FmLambda(args: [FiFunArg], body: FmExp, info: FmInfo);
		FmCall(f: FmExp, args: [FmExp], info: FmInfo);
		FmCallPrim(op: FmPrim, es: [FmExp], info: FmInfo);
		FmVar(name: string, local: bool, info: FmInfo);


		// Memory bookkeeping operations
		// Uses Preceus algorithm: https://www.microsoft.com/en-us/research/uploads/prod/2020/11/perceus-tr-v1.pdf
		FmMemory(op : FmMemoryOp, var: string, e : FmExp);
			FmMemoryOp ::= FmDup, FmDrop, FmReuse, FmDispose, FmIsUnique, FmDecRef, FmNull;
			FmDup(); FmDrop(); FmReuse(); FmDispose(); FmIsUnique(); FmDecRef(); FmNull();

	FmInfo(free: Set<string>, type: FiType, start: int);

	FmPrim ::= 
		FmOrPrim,    FmAndPrim,   FmNotPrim,   FmEqPrim,      FmNePrim, 
		FmLePrim,    FmGePrim,    FmLtPrim,    FmGtPrim,      FmPlusPrim, 
		FmMinusPrim, FmMulPrim,   FmDivPrim,   FmModPrim,     FmNegPrim,
		FmArrayPrim, FmIndexPrim, FmDerefPrim, FmRefPrim,     FmStructPrim, 
		FmFieldPrim, FmReusePrim, FmCastPrim,  FmRequirePrim, FmUnsafePrim,
		FmIfPrim;

		FmOrPrim();    FmAndPrim();   FmNotPrim();   FmEqPrim();  FmNePrim(); 
		FmLePrim();    FmGePrim();    FmLtPrim();    FmGtPrim();  FmPlusPrim(); 
		FmMinusPrim(); FmMulPrim();   FmDivPrim();   FmModPrim(); FmNegPrim();
		FmArrayPrim(); FmIndexPrim(); FmDerefPrim(); FmRefPrim(); FmIfPrim();

		FmStructPrim(struct: string); FmFieldPrim(field: string);
		FmCastPrim(from : FiType, to : FiType);
		FmRequirePrim(flowfile : string);
		FmUnsafePrim(name : string);

		FmReusePrim(struct: string, reuse: string);
}
