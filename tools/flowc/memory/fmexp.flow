import tools/flowc/incremental/fiexp;

export {
	FmExp ::= FmLambda, FmCall, FmLet, FmIf, FmSwitch, FmSeq, FmCallPrim, FmAssign, FmMemory, FiVar, FiConst;
		FmLambda(args: [FiFunArg], body: FmExp, type : FiTypeFunction, start : int);
		FmCall(f: FmExp, args: [FmExp], type : FiType, start : int);
		FmLet(var: FiVar, e1: FmExp, e2: FmExp, type2 : FiType, start : int);
		FmIf(e1: FmExp, e2: FmExp, e3: FmExp, type : FiType, start : int);
		FmSwitch(x: FiVar, switchType : FiType, cases: [FmCase], type : FiType, start : int);
			FmCase(struct: string, argNames : [string], body: FmExp, start : int);
		FmSeq(es: [FmExp], type : FiType, start : int);
		FmCallPrim(op: FmPrim, es: [FmExp], type : FiType, start : int);
		FmAssign(to: FmExp, what: FmExp, start: int);

		// Memory bookkeeping operations
		// Uses Preceus algorithm: https://www.microsoft.com/en-us/research/uploads/prod/2020/11/perceus-tr-v1.pdf
		FmMemory(op : FmMemoryOp, var: string, e : FmExp, start : int);
			FmMemoryOp ::= FmDup, FmDrop, FmReuse, FmDispose, FmIsUnique, FmDecRef, FmNull;
			FmDup(); FmDrop(); FmReuse(); FmDispose(); FmIsUnique(); FmDecRef(); FmNull();

	FmPrim ::= FmOrPrim, FmAndPrim, FmNotPrim,
		FmEqPrim, FmNePrim, FmLePrim, FmGePrim, FmLtPrim, FmGtPrim,
		FmPlusPrim, FmMinusPrim, FmMulPrim, FmDivPrim, FmModPrim, FmNegPrim,
		FmArrayPrim, FmIndexPrim,
		FmDerefPrim, FmRefPrim,
		FmStructPrim, FmFieldPrim, FmReuseStructPrim,
		FmCastPrim, FmRequirePrim, FmUnsafePrim;

		FmOrPrim(); FmAndPrim(); FmNotPrim();
		FmEqPrim(); FmNePrim(); FmLePrim(); FmGePrim(); FmLtPrim(); FmGtPrim();
		FmPlusPrim(); FmMinusPrim(); FmMulPrim(); FmDivPrim(); FmModPrim(); FmNegPrim();
		FmArrayPrim(); FmIndexPrim();
		FmDerefPrim(); FmRefPrim();
		FmStructPrim(struct: string); FmFieldPrim(field: string);
		FmCastPrim(from : FiType, to : FiType);
		FmRequirePrim(flowfile : string);
		FmUnsafePrim(name : string);

		FmReuseStructPrim(struct: string, reuse: string);
}
