import ds/hashset;
import math/hash;
import math/stringmath;

checkTreeAndHashMapEqual(tree : Tree<?, ??>, hashMap : HashMap<?, ??>) -> bool {
	result = ref true;
	if (sizeHashMap(hashMap) != sizeTree(tree)) {
		println("Hash map size: " + i2s(sizeHashMap(hashMap)) + " != tree size: "  + i2s(sizeTree(tree)));
		result := false;
	}
	iterHashMap(hashMap, \k1,v1 -> {
			switch (lookupTree(tree, k1)) {
				Some(v2): {
					if (v1 != v2) {
						println("values differ: ");
						println("key:");
						println(k1);
						println("hash map value:");
						println(v1);
						println("tree value:");
						println(v2);
						result := false;
					}
				}
				None(): {
					println("tree doesn't have a key:");
					println(k1);
					result := false;
				}
			}
		}
	);
	traverseInOrder(tree, \k1,v1 -> {
			switch (lookupHashMap(hashMap, k1)) {
				Some(v2): {
					if (v1 != v2) {
						println("values differ: ");
						println("key:");
						println(k1);
						println("hash map value:");
						println(v2);
						println("tree value:");
						println(v1);
						result := false;
					}
				}
				None(): {
					println("hash map doesn't have a key:");
					println(k1);
					result := false;
				}
			}
		}
	);
	^result
}

// dump
dumpHashMap(m : HashMap<?, ??>) -> string {
	dumpHashMapExt(m, toString, toString);
}

dumpHashMapExt(m : HashMap<?, ??>, fn1 : (?) -> string, fn2 : (??) -> string) -> string {
	strGlue(getHashMapValues(mapHashMap(m, \k,v -> fn1(k) + " |-> " + fn2(v))), "\n")
}

dumpHashMapComplete(m : HashMap<int, int>) -> string {
	"size=" + i2s(sizeHashMap(m)) + "\n" + 
	"capacity=" + i2s(length(m.data)) + "\n" + 
	strGlue(map(m.data, \tree -> {
		"  [" + foldTree(^tree, "", \key, value, acc ->
				acc  + i2s(key) + " |-> " + i2s(value) + ", "
		) + "]"
	}),  "\n");
}

testArrayOfPairs(testPairs : [Pair<?, ??>], removeKeys : [?], hash : (?) -> int, descr : string) -> bool {
	println("---------------------");
	test_size = length(testPairs);
	println("TEST: " + descr + " OF SIZE: " + i2s(test_size));
	tree_time_start1 = timestamp();
	tree = pairs2tree(testPairs);
	tree_time1 = (timestamp() - tree_time_start1) / 1000.0;

	//loadFactor = 0.75;
	loadFactor = 0.75;
	hash_time_start1 = timestamp();
	hashMap = pairs2hashMapWithLoadFactor(testPairs, hash, loadFactor);
	hash_time1 = (timestamp() - hash_time_start1) / 1000.0;
	if (hash_time1 > 0.1 || tree_time1 > 0.1) {
		//println("BUILDING TREE OF SIZE: " + i2s(test_size) + " DONE IN: " + d2st(tree_time1, 2) + "s");
		//println("BUILDING HASH MAP OF SIZE: " + i2s(test_size) + ", LOAD FACTOR: " + d2s(loadFactor) + " DONE IN: " + d2st(hash_time1, 2) + "s");
		println("HASH ADDING IS FASTER: " + d2s(tree_time1 / hash_time1) + " TIMES");
	}
	if (!checkTreeAndHashMapEqual(tree, hashMap)) {
		println("FAILED");
		false
	} else {
		if (test_size < 10000) {
			testPopHashMap(copyHashMap(hashMap), buildSet(testPairs));
		}

		tree_time_start2 = timestamp();
		tree1 = fold(removeKeys, tree, \acc, toRemove -> removeFromTree(acc, toRemove));
		tree_time2 = (timestamp() - tree_time_start2) / 1000.0;
		
		hash_time_start2 = timestamp();
		hashMap1 = fold(removeKeys, hashMap, \acc, toRemove -> removeFromHashMap(acc, toRemove));
		hash_time2 = (timestamp() - hash_time_start2) / 1000.0;
		
		if (hash_time2 > 0.1 || tree_time2 > 0.1) {
			//println("REMOVING FROM TREE OF SIZE: " + i2s(test_size) + " DONE IN: " + d2st(tree_time2, 2) + "s");
			//println("REMOVING FROM HASH MAP OF SIZE: " + i2s(test_size) + ", LOAD FACTOR: " + d2s(loadFactor) + " DONE IN: " + d2st(hash_time2, 2) + "s");
			println("HASH REMOVING IS FASTER: " + d2s(tree_time2 / hash_time2) + " TIMES");
		}
		
		if (!checkTreeAndHashMapEqual(tree1, hashMap1)) {
			println("FAILED AFTER REMOVE");
			false
		} else {
			println("PASSED");
			true
		}
	}
}

testPopHashMap(m : HashMap<?, ??>, test : Set<Pair<?, ??>>) -> void {
	doTestPopHashMap(m, test, sizeSet(test));
}


doTestPopHashMap(m : HashMap<?, ??>, test : Set<Pair<?, ??>>, i : int) -> void {
	if (i == 0) {
		if (sizeHashMap(m) == 0) {
			println("POP HASH MAP - PASSED");
		} else {
			println("POP HASH MAP FAILED: A)");
		}
	} else if (sizeHashMap(m) == 0) {
		println("POP HASH MAP FAILED: B)");
	} else {
		switch (popHashMap(m)) {
			Some(pair): {
					if (!containsSet(test, pair)) {
						println("POP HASH MAP FAILED: C)");
					} else {
						test1 = removeSet(test, pair);
						doTestPopHashMap(m, test, i - 1);
					}
				}
			None(): {
				println("POP HASH MAP FAILED: D)");
			}
		}
	}
}

random_string() -> string {
	len = cast(random() * 20.0 : double -> int) + 1;
	symbs = arrayRepeatDeferred(\ -> 
		33 + cast(cast((126 - 33) : int -> double) * random() : double -> int),
		len
	);
	fold(symbs, "", \acc, code -> acc + fromCharCode(code))
}

main() -> int {
	testPassed = ref true;

	// Test 1
	// with a hand-written key-value pairs
	if (!testArrayOfPairs([Pair(1, 5), Pair(3, 6), Pair(92, -6), Pair(34, -9), Pair(18, 6)], [3, 18], idfn, "HAND WRITTEN 1")) {
		testPassed := false;
	}
	
	// Test 2
	// with a hand-written key-value pairs
	if (!testArrayOfPairs([Pair(1, 5), Pair(3, 6), Pair(92, -6), Pair(34, -9), Pair(18, 6)], [3, 18, 92, 45, 1], idfn, "HAND WRITTEN 2")) {
		testPassed := false;
	}
	
	// Test 3
	// with a hand-written key-value pairs
	if (!testArrayOfPairs([Pair(1, 5), Pair(-3, 6), Pair(-92, -6), Pair(34, -9), Pair(18, 6)], [3, 18, 92, -92, -3, 45, 1], idfn, "HAND WRITTEN 3")) {
		testPassed := false;
	}
	
	// Test 4
	// failed test
	failedPairs = [Pair(-1041393, -15773548),Pair(-17206635, -32378919),Pair(-33250064, -6983416)];
	failedRemove = [-1041393];
	if (!testArrayOfPairs(failedPairs, failedRemove, idfn, "HAND WRITTEN 4")) {
		testPassed := false;
	}
	
	random_int = \-> {
		cast(random() * 100000000.0 - 50000000.0 : double -> int);
	}

	// Test 5
	// with a large randomly generated integer key-value pairs
	int_test_size = 2000000;
	int_testPairs = map(enumFromTo(1, int_test_size), \__ ->
		Pair(random_int(), random_int())
	);
	int_removeSize = 200000;
	int_toRemovePairs = fold(enumFromTo(0, int_removeSize - 1), [], \acc, i ->
		concat(acc, [int_testPairs[(int_test_size / int_removeSize) * i].first])
	);
	
	if (!testArrayOfPairs(int_testPairs, int_toRemovePairs, idfn, "RANDOMLY GENERATED INTEGER KEYS")) {
		testPassed := false;
	}
	
	// Test 6
	// with a large randomly generated string key-value pairs
	string_test_size = 2000000;
	string_testPairs = map(enumFromTo(1, string_test_size), \__ ->
		Pair(random_string(), random_int())
	);
	string_removeSize = 200000;
	string_toRemovePairs = fold(enumFromTo(0, string_removeSize - 1), [], \acc, i ->
		concat(acc, [string_testPairs[(string_test_size / string_removeSize) * i].first])
	);
	
	if (!testArrayOfPairs(string_testPairs, string_toRemovePairs, 
			\str -> fastHashStringWithCutoff(str, 4),
			"RANDOMLY GENERATED STRING KEYS")
		) {
		testPassed := false;
	}
	
	println("=========================");
	if (^testPassed) {
		println("ALL HASH MAP TESTS PASSED");
	} else {
		println("SOME HASH MAP TEST FAILED");
	}
	0
}
