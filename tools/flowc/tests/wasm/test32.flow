// testing natives from array.flow

import ds/array;
import string;
import ds/list;
import expect;

// native printd : (double) -> void = host.printd;
// native printa : ([?], [??]) -> void = host.printa;
// native printb : (bool) -> void = host.printi;


//TODO Array Natives:
// map/mapi: doesn't work for structs. Not tested for flow/ref/unions yet.
// 	Map only works with lambda functions. Check if case is the same for other array natives as well

// filter: shrink array after filter finished? 
// 		method 1: update size in header, and insert the remainder of the block into the list of free blocks
//		method 2: dynamically build the array, e.g. list2array. 
//		method 3(very bad): run filter without saving result, only length. Then alloc length and run again. This will double runtime, and is therefore bad.

// fold: We cannot have the init value, or the return value to be double atm. Since function signatures 
//		in wasm_natives_native doesn't seem to work with '?' 
//		 

// subrange, concat, replace: How do we get the element type of the array? we need to know if it's [double], or something else. 

// TODO: order of work
// fold/foldi:
// 	- we cannot have the init value of type double, or return type double, because of function signature
// 	in wasm_natives_native. putting '?' as type in the signature does not work. 

// filter:
// 	- shrink array size after looping over elements, OR build array dynamically and save in the end. E.g. list2array.

// concat/subrange/replace:
// 	+ get type of the array, so we can have the right elemsize. 
// 	- These functions work for all other cases than double. 


Foo(n : int);
Bar(m : double);
Baz(o : Foo);
Sbar(s : string);
Abar(a : [?]);

foo2bar(x : Foo) -> Bar {
	Bar(cast(x.n : int -> double));
}

// expect2(a : int, b : bool) -> void {}

testSubrange() {
	arr = [1, 2, 3, 4];

	res0 = subrange(arr, 1, 2);
	expect2(101, res0 == [2 , 3]);

	res1 = subrange(arr, 0, 4);
	expect2(102, res1 == arr);

	res2 = subrange(arr, 0, 0);
	expect2(103, res2 == []);

	res3 = subrange(arr, 3, 2);
	expect2(104, res3 == [4]);

	res4 = subrange(arr, 4, 1);
	expect2(105, res4 == []);

	arr1 = [1.0, 2.0, 3.0, 4.0];
	res5 = subrange(arr1, 1, 2);
	expect2(106, res5 == [2.0, 3.0]);

	res6 = subrange([MyStructA(111), MyStructB(222), MyStructC(333), MyStructD(444)], 1, 2);
	expect2(107, res6 == [MyStructB(222), MyStructC(333)]);

	res7 = subrange(["H", "e", "l", "l", "o"], 1, 3);
	expect2(108, res7 == ["e", "l", "l"]);
}

testReplace() {
	arr = [1, 2, 3, 4];
	arrd = [1.0, 2.0, 3.0, 4.0];

	res0 = replace(arr, 0, 2);
	expect2(201, res0 == [2, 2, 3, 4]);

	res1 = replace(arr, 4, 5);
	expect2(202, res1 == [1, 2, 3, 4, 5]);

	res2 = replace(arr, 0, arr[0]);
	expect2(203, res2 == arr);

	res3 = replace(arrd, 2, 2.0);
	expect2(204, res3 == [1.0, 2.0, 2.0, 4.0]);

	res4 = replace(arrd, 4, 5.0);
	expect2(205, res4 == [1.0, 2.0, 3.0, 4.0, 5.0]);

	res5 = replace(["H", "e", "k", "l", "o"], 2, "l");
	expect2(206, res5 == ["H", "e", "l", "l", "o"]);

	arr1 : [int] = [];
	res6 = replace(arr1, 0, 1);
	expect2(207, res6 == [1]);

	arr2 = [1,2,3];
	res7 = replace(arr2, 1, 5);
	expect2(208, res7 == [1,5,3]);

	arr3 = [1.2,2.3,3.4];
	res8 = replace(arr3, 1, 4.5);
	expect2(209, res8 == [1.2,4.5,3.4]);

	arr4 : [MyUnion] = [MyStructA(111), MyStructB(222), MyStructC(333)];
	res9 = replace(arr4, 1, MyStructD(444));
	expect2(210, res9 == [MyStructA(111), MyStructD(444), MyStructC(333)]);
}

testConcat() {
	a0 : [int] = [];
	expect2v(301, [1, 2, 3, 4, 5, 6], concat([1, 2, 3], [4, 5, 6]));
	expect2v(302, [4, 5, 6], concat(a0, [4, 5, 6]));
	expect2v(303, [1, 2, 3], concat([1, 2, 3], a0));
	expect2v(304, [], concat(a0, a0));
	expect2v(305, [4, 5, 6], concat([], [4, 5, 6]));
	expect2v(306, [1, 2, 3], concat([1, 2, 3], []));
	expect2v(308, [1,2,3,4,5,6], concat3([1,2],[3,4],[5,6]));

	// [double]
	res8 = concat([1.0, 2.0, 3.0], [4.0, 5.0, 6.0]);
	expect2(309, res8 == [1.0, 2.0, 3.0, 4.0, 5.0, 6.0]);

	// [string]
	res9 = concat(["1", "2", "3"], ["4", "5", "6"]);
	// iter(res9, \s -> printss(s));
	// prints(toString(res9));
	expect2(310, res9 == ["1", "2", "3", "4", "5", "6"]);
	
	// array of arrays
	expect2v(311, [[1],[2],[3]], concat([[1]], [[2],[3]]));
}


testMap() {
	arr = [1, 2, 3, 4];

	res0 = map(arr, \a -> a * a);
	expect2(401, res0 == [1, 4, 9, 16]);

	res1 = map(arr, \a -> [a]);
	expect2(402, res1 == [[1], [2], [3], [4]]);

	res2 = map(["H", "e", "l", "l", "o"], \c -> getCharCodeAt(c, 0));
	expect2(403, res2 == [72, 101, 108, 108, 111]);

	res3 = map([1.0, 2.0, 3.0], \a -> a * a);
	expect2(404, res3 == [1.0, 4.0, 9.0]);

	res4 = map(arr, \a -> 1.0);
	expect2(405, res4 == [1.0, 1.0, 1.0, 1.0]);

	a0 : [int] = [];
	res5 = map(a0, \a -> a);
	expect2(406, res5 == []);

	res6 = map(arr, \a -> cast(a : int -> double));
	expect2(407, res6 == [1.0, 2.0, 3.0, 4.0]);

	res7 = map([1.0, 2.0, 3.0], \a -> a * a);
	expect2(408, res7 == [1.0, 4.0, 9.0]);

	res8 = map([Foo(1), Foo(2), Foo(3)], \a -> Bar(cast(a.n : int -> double)));	
	expect2(409, res8 == [Bar(1.0), Bar(2.0), Bar(3.0)]);
	
	// res8 = map([Foo(1), Foo(2), Foo(3)], foo2bar);			// Not working with first-class functions. TODO: fix it later!
	// expect2(409, res8 == [Bar(1.0), Bar(2.0), Bar(3.0)]);
	// res9 = map(arr, doubleInt);
	// expect2(410, res9 == [2, 4, 6, 8]);
	
	res9 = map([Foo(1), Foo(2), Foo(3)], \a -> Baz(a));
	expect2(410, res9 == [Baz(Foo(1)), Baz(Foo(2)), Baz(Foo(3))]);

	res10 = map(arr, \a -> cast(a : int -> flow));
	expect2(411, res10 == [cast(1 : int -> flow), cast(2 : int -> flow), cast(3 : int -> flow), cast(4 : int -> flow)]);

	res11 = map([cast(1 : int -> flow), cast(2 : int -> flow), cast(3 : int -> flow)], \a -> cast(a : flow -> int));
	expect2(412, res11 == [1,2,3]);

	res12 = map([1.0, 2.0, 3.0, 4.0], \a -> cast(a : double -> int));
	expect2(413, res12 == [1,2,3,4]);

}

testMapi() {
	arr = [1, 2, 3, 4];

	res0 = mapi(arr, \i, a -> a + i);
	expect2(501, res0 == [1, 3, 5, 7]);

	res1 = mapi(arr, \i, a -> i);
	expect2(502, res1 == [0, 1, 2, 3]);

	res2 = mapi(["H", "e", "l", "l", "o"], \i, c -> getCharCodeAt(c, 0) + i);
	expect2(503, res2 == [72, 102, 110, 111, 115]);


	res3 = mapi(arr, \i, a -> cast((a + i) : int -> double));
	expect2(504, res3 == [1.0, 3.0, 5.0, 7.0]);

	res4 = mapi([1.0, 2.0, 3.0], \i, a -> cast(i : int -> double) + a);
	expect2(505, res4 == [1.0, 3.0, 5.0]);

	res5 = mapi([Foo(1), Foo(2), Foo(3)], \i, a -> Bar(cast((a.n + i) : int -> double)));
	expect2(506, res5 == [Bar(1.0), Bar(3.0), Bar(5.0)]);

}

myConcat(a : [?], b : [?]) -> [?] { 
	concat(a, b); // workaround
}

MyUnion ::= MyStructA, MyStructB, MyStructC, MyStructD;
	MyStructA(a : int); MyStructB(b : int); MyStructC(c : int); MyStructD(d : int); 

testFold() {
	arrb = [true, true, false, false, true];
	arri = [1, 2, 3, 4];
	arrd = [1.0, 2.0, 3.0, 4.0];
	arrs = ["H", "e", "l", "l", "o"];
	arra = [[1], [2,1], [3,2,1], [4,3,2,1]];
	arrstruct = [Foo(1), Foo(2), Foo(3), Foo(4)];

	expect2(601, fold(arrb, false, \a, b -> a == b) == false);
	expect2(602, fold(arrb, 0, \a, b -> if (b) a + 1 else a) == 3);
	expect2(603, fold(arrb, 0.0, \a, b -> if (b) a + 1.0 else a) == 3.0);
	expect2(604, fold(arrb, "", \a, b -> if (b) "true" else "false") == "true");
	expect2(605, fold(arrb, [], \a, b -> if (b) myConcat(a, [1]) else myConcat(a, [0])) == [1,1,0,0,1]);
	expect2(606, fold(arrb, [[]], \a, b -> [[b]]) == [[true]]);
	expect2(607, fold(arrb, Foo(2), \a, b -> if (b) Foo(a.n * 2) else a) == Foo(16));

	expect2(608, fold([1, 3, 5, 7, 8, 9], false, \a, b -> b % 2 == 0 || a) == true);
	expect2(609, fold(arri, 5, \a, b -> a + b) == 15);
	expect2(610, fold(arri, 5.0, \a, b -> cast(b : int -> double) + a) == 15.0);
	expect2(611, fold([101, 108, 108, 111], "H", \a, b -> list2string(Cons(fromCharCode(b), Cons(a, EmptyList())))) == "Hello");
	expect2(612, fold(arri, [0], \a, b -> myConcat(a, [b])) == [0,1,2,3,4]);
	expect2(613, fold(arri, [[0]], \a, b -> [myConcat(a[0], [b])]) == [[0,1,2,3,4]]);
	expect2(614 ,fold(arri, Foo(5), \a, b -> Foo(a.n + b)) == Foo(15));
	
	expect2(615, fold(arrd, false, \a, b -> b == 3.0 || a) == true);
	expect2(616, fold(arrd, 5, \a, b, -> a + cast(b : double -> int)) == 15);
	expect2(617, fold(arrd, 5.0, \a, b -> a + b) == 15.0);
	expect2(618, fold(arrd, "", \a, b -> if (b % 2.0 == 0.0) "even" else "odd") == "even");
	expect2(619, fold(arrd, [0.0], \a, b -> myConcat(a, [b])) == [0.0, 1.0, 2.0, 3.0, 4.0]);
	expect2(620, fold(arrd, [[]], \a, b -> [myConcat(a[0], [b])]) == [arrd]);
	expect2(621, fold(arrd, Bar(5.0), \a, b -> Bar(a.m + b)) == Bar(15.0));

	expect2(622, fold(arrs, false, \a, b -> a || b == "e") == true);
	expect2(623, fold(arrs, 0, \a, b -> a + getCharCodeAt(b, 0)) == 500);
	expect2(624, fold(arrs, 0.0, \a, b -> a + cast(getCharCodeAt(b, 0) : int -> double)) == 500.0);
	expect2(625, fold(arrs, "A", \a, b -> b) == "o");
	expect2(626, fold(arrs, [], \a, b -> myConcat(a, [b])) == arrs);
	expect2(627, fold(arrs, [[]], \a, b -> [myConcat(a[0], [b])]) == [arrs]);
	expect2(628, fold(arrs, Sbar(""), \a, b -> Sbar(b)) == Sbar("o"));

	expect2(629, fold(arra, false, \a, b -> a || myLength(b) == 3) == true);
	expect2(630, fold(arra, 0, \a, b -> a + myLength(b)) == 10);
	expect2(631, fold(arra, 5.0, \a, b -> a + cast(b[0] : int -> double)) == 15.0);
	expect2(632, fold(arra, "", \a, b -> if (b[0] % 2 == 0) "even" else "odd") == "even");
	expect2(633, fold(arra, [], \a, b -> myConcat(a, b)) == [1,2,1,3,2,1,4,3,2,1]);
	expect2(634, fold(arra, [[]], \a, b -> [myConcat(a[0], b)]) == [[1,2,1,3,2,1,4,3,2,1]]);
	expect2(635, fold(arra, Abar([]), \a, b -> Abar(myConcat(a.a, b))) == Abar([1,2,1,3,2,1,4,3,2,1]));

	expect2(636, fold(arrstruct, false, \a, b -> b.n % 2 == 0) == true);
	expect2(637, fold(arrstruct, 5, \a, b -> a + b.n) == 15);
	expect2(638, fold(arrstruct, 5.0, \a, b -> a + cast(b.n : int -> double)) == 15.0);
	expect2(639, fold(arrstruct, "", \a, b -> if (b.n % 2 == 0) "even" else "odd") == "even");
	expect2(640, fold(arrstruct, [], \a, b -> myConcat(a, [b])) == arrstruct);
	expect2(641, fold(arrstruct, [[]], \a, b -> [myConcat(a[0], [b])]) == [arrstruct]);
	expect2(642, fold(arrstruct, Baz(Foo(0)), \a, b -> Baz(b)) == Baz(Foo(4)));
	
	a : [MyUnion] = [MyStructA(111), MyStructB(222), MyStructC(333)];
	s = fold(a, "", \acc, u : MyUnion -> {
		acc + switch (u) {
			MyStructA(__): "a" + cast(u.a : int -> string);
			MyStructB(__): "b" + cast(u.b : int -> string);
			MyStructC(__): "c" + cast(u.c : int -> string);
			MyStructD(__): "d" + cast(u.d : int -> string);
		}
	});
	expect2v(643, "a111b222c333", s);

	arrf = [\->"a1", \->"b2", \->"c3"];
	sf = fold(arrf, "", \acc, f -> {
		acc + f()
	});

	expect2v(644, "a1b2c3", sf);
}

testFoldi() {
	arr = [1, 2, 3, 4];

	res0 = foldi(arr, 9, \i, a, b -> a + i + b);
	expect2(701, res0 == 25);

	res1 = foldi([101, 107, 106, 108], "H", \i, a, b -> 
										list2string(Cons(fromCharCode(b+i), Cons(a, EmptyList())))
									);
	expect2(702, res1 == "Hello");
	
	res2 = foldi([1.0, 2.0, 3.0, 4.0], 9.0, \i, a, b -> a + cast(i : int -> double) + b);
	expect2(703, res2 == 25.0);

	res3 = foldi(arr, 9.0, \i, a, b -> a + cast((i + b) : int -> double));
	expect2(704, res3 == 25.0);

	res4 = foldi(arr , false, \i, a, b -> a || b == 10 || i == 2);
	expect2(705, res4 == true);

	res5 = foldi([Foo(1), Foo(2), Foo(3), Foo(4)], 5, \i, a, b -> i + a + b.n);
	expect2(706, res5 == 21);

	res6 = foldi(["H", "e", "l", "l", "o"], false, \i, a, b -> a || b == "z" || i == 10);
	expect2(707, res6 == false);
}

testFilter() {
	res0 = filter([1, 2, 3, 4], \a -> a % 2 == 0);
	expect2(801, res0 == [2, 4]);

	res1 = filter([1.0, 2.0, 3.0, 4.0], \a -> a % 2.0 == 1.0);
	expect2(802, res1 == [1.0, 3.0]);

	res2 = filter(["H", "e", "l", "l", "o"], \c -> getCharCodeAt(c, 0) == 108);
	expect2(803, res2 == ["l", "l"]);

	res3 = filter([MyStructA(111), MyStructB(222), MyStructC(333)], \s -> isSameStructType(s, MyStructB(0)));
	expect2(804, res3 == [MyStructB(222)]);
}

testIteriUntil() {
	res0 = iteriUntil([1, 2, 3, 4], \i, a -> a > 2);
	expect2(901, res0 == 2);

	res1 = iteriUntil([1.0, 2.0, 3.0, 4.0], \i, a -> a > 2.7);
	expect2(902, res1 == 2);

	res2 = iteriUntil(["H", "e", "l", "l", "o"], \i, c -> c == "l" || i == 80);
	expect2(903, res2 == 2);

	res3 = iteriUntil([1, 2, 3, 4], \i, a -> a > 4 || i == 2);
	expect2(904, res3 == 2);

	res4 = iteriUntil([1, 2, 3, 4], \i, a -> a - i == 0);
	expect2(905, res4 == 4);

	res5 = iteriUntil([Foo(1), Foo(2), Foo(3), Foo(4)], \i, a -> a.n > 2);
	expect2(906, res5 == 2);

	res6 = iteriUntil([[0], [1,2], [3,4,5], [6,7,8,9]], \i, a -> a[i] == 5);
	expect2(907, res6 == 2);

	res7 = iteriUntil([cast(1 : int -> flow), cast(2 : int -> flow), cast(3 : int -> flow)], \i, a -> cast(a : flow -> int) == 2);
	expect2(908, res7 == 1);

	res8 = iteriUntil([true, false, false, true, true], \i, a -> a && i != 0);
	expect2(909, res8 == 3);

}

S10i(x : int);

testElemIndex() {
	ai = [1,2,3];
	expect2(1001, elemIndex(ai, 2, -1) == 1);
	expect2(1002, elemIndex(ai, 4, 666) == 666);

	af = [1.0,2.0,3.0];
	expect2(1003, elemIndex(af, 2.0, -1) == 1);
	expect2(1004, elemIndex(af, 4.0, 666) == 666);

	as = [S10i(1),S10i(2),S10i(3)];
	expect2(1005, elemIndex(as, S10i(2), -1) == 1);
	expect2(1006, elemIndex(as, S10i(4), 666) == 666);

	astr = ["1","2","3"];
	expect2(1007, elemIndex(astr, "2", -1) == 1);
	expect2(1008, elemIndex(astr, "4", 666) == 666);
}

testCallbacksApply(a : ?, cb : (?) -> ??) -> ?? {
	cb(a)
}

myLength(a : [?]) -> int {
	length(a)
}

testCallbacks(base : int) {
	a = [1,2,3];
	expect2(base + 0, 3 == myLength(a)); 
	expect2(base + 1, 3 == testCallbacksApply(a, myLength));
	// expect2(base + 2, 3 == testCallbacksApply(a, length)); // TODO: Cannot resolve variable in WasmVar: length___c1aii yet
	
	myLength2 = \aa : [int] -> { myLength(aa) };
	expect2(base + 3, 3 == testCallbacksApply(a, myLength2)); 
	
	// myLength3 = \aa : [int] -> { length(aa) };	// TODO: Cannot resolve variable in WasmVar: length___c1aii yet
	// expect2(base + 4, 3 == myLength3(a)); 
	// expect2(base + 5, 3 == testCallbacksApply(a, myLength2)); 
	
	s = "123";
	expect2(base + 10, 3 == testCallbacksApply(s, strlen));
	
	myStrlen = \ss -> strlen(s);
	expect2(base + 11, 3 == testCallbacksApply(s, myStrlen));
}

testList2array() {
	l0 = EmptyList();
	l1 = Cons(111, l0);
	li = Cons(l1, Cons(l0, EmptyList()));
	a = list2array(li);
	expect2(1201, isSameObj(a[0], l0));
	expect2(1202, isSameObj(a[1], l1));
}

main() {
	// expectVerbose();
	testSubrange();
	testReplace();
	testConcat();
	testMap();
	testMapi();
	testFold();
	testFoldi();
	testIteriUntil();
	testElemIndex();
	testCallbacks(1100);
	testList2array();
	testFilter();
	
	expectFinish();
}