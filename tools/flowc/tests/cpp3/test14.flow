//import ds/array;
//import runtime;

native println2 : io (flow) -> void = Native.println;
native quit : io (code : int) -> void = Native.quit;
native toString : io (v : ?) -> string = Native.toString;

native replace : ([?], int, ?) -> [?] = Native.replace;
native subrange : (a : [?], index : int, length : int) -> [?] = Native.subrange;
native length : ([?]) -> int = Native.length;
native concat : ([?], [?]) -> [?] = Native.concat;
native map : ([?], (?) -> ??) -> [??] = Native.map;
native mapi : ([?], (int, ?) -> ??) -> [??] = Native.mapi;
native fold : (xs : [?], init : ??, fn : (??, ?)->??) -> ?? = Native.fold;
native foldi : (xs : [?], init : ??, fn : (int, ??, ?)->??) -> ?? = Native.foldi;
native enumFromTo : (start : int, end : int) -> [int] = Native.enumFromTo;
native iter : ([?], (?)->void) -> void = Native.iter;
native iteri : ([?], (int, ?)->void) -> void = Native.iteri;
native iteriUntil : ([?], (int, ?)->bool) -> int = Native.iteriUntil;
native filter : (a : [?], test : (?) -> bool) -> [?] = Native.filter;
//native filtermapi : (a : [?], test : (int, ?) -> Maybe<??>) -> [??] = Native.filtermapi;

native i2s : (int) -> string = Native.i2s;
native d2s : (double) -> string = Native.d2s;
native strlen : (string) -> int = Native.strlen;
native strIndexOf : (str : string, substr : string) -> int = Native.strIndexOf;
native substring : (s : string, start : int, length : int) -> string = Native.substring;
native toLowerCase : (string) -> string = Native.toLowerCase;
native toUpperCase : (string) -> string = Native.toUpperCase;
native getCharAt : (string, int) -> string = Native.getCharAt;
native string2utf8 : (s : string) -> [int] = Native.string2utf8;
native s2a : (string) -> [int] = Native.s2a;
native fromCharCode : (charCode: int) -> string = Native.fromCharCode;
native getCharCodeAt : (s : string, i : int) -> int = Native.getCharCodeAt;

Maybe<?> ::= None, Some<?>;
	None();
	Some(value : ?);
Pair(first: ?, second: ??);

fn(i: int, acc: Pair<string, int>, s: ref string) -> Pair<string, int> {
	if (i == 0) acc else {
		s := acc.first + "+" + i2s(i);
		s := ^s + "AAA";
		fn(i - 1, Pair(acc.first + " " + i2s(i), acc.second + 1), s);
	}
}

fn1(i: int, s: ref string) -> string {
	if (i == 0) ^s else {
		s := "+" + i2s(i) + ^s;
		s := ^s + "AAA";
		fn1(i - 1, s);
	}
}

TestStruct(s1: string, s2: string, s3: string);

main() {
	s = ref "abc";
	s := "x";
	s := "y";
	println2(fn1(3, s));
	println2(^s);
	strs = ["a", "b", "c", "XXX"];
	println2(strs);
	iter(strs, println2);

	println2(fn(3, Pair("C", 1), s));
	iter(strs, println2);
	iteri(strs, \i, x -> println2(i2s(i) + x));
	println2(filter(strs, \x -> strlen(x) < 3));
	if (None() == None()) {
		println2("None() == None()!");
	}
	if (TestStruct("a", "b", "c") == TestStruct("a1", "b1", "c1")) {
		println2("NEVER: " + toString(TestStruct("a", "b", "c")));
	}
	if (TestStruct("a", "b", "c") == TestStruct("a", "b", "c")) {
		println2("FOREVER: " + toString(TestStruct("a", "b", "c")));
	}
	x = cast(TestStruct("a", "b", "c"): TestStruct -> flow);
	println2(cast(x: flow -> TestStruct).s1);
	println2(^s);
	quit(0);
}