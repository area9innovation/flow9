import text/binary;
import math/stringmath;
import ds/tree;
import compile_time;
import net/url_parameter;

euler1(limit : int) -> int {
    foldRange(1, limit - 1, 0, \acc, i -> {
        if (i % 3 == 0 || i % 5 == 0) {
            acc + i;
        } else acc;
    });
}

euler2(a : double, b : double, sum : double) -> double {
    fib = a + b;
    nsum = if (fib % 2.0 == 0.0) sum + fib else sum;
    if (fib < 4000000.0) {
        euler2(b, fib, nsum)
    } else {
        nsum;
    }
}

biggestFactor(factor : double, limit : double, biggest : double, n : double) -> double {
	if (factor < limit) {
		if (n % factor == 0.0) {
			biggestFactor(factor, limit, factor, n / factor);
		} else {
			biggestFactor(if (factor == 2.0) 3.0 else factor + 2.0, limit, biggest, n)
		}
	} else {
		biggest;
	}
}

findBiggestDivisor(n : double) -> double {
	biggestFactor(2.0, sqrt(n), 1.0, n);
}

isPalindromic(s : string) -> bool {
	l = strlen(s);
    l <= 1 || {
		first = strLeft(s, 1);
		last = strRight(s, l - 1);
        first == last && isPalindromic(strsubsmart(s, 1, -1));
    }
}

euler4() -> int {
    foldRange(100, 999, 0, \acc, a -> {
        foldRange(100, 999, acc, \acc2, b -> {
        	p = a * b;
	        if (p < acc2 || !isPalindromic(i2s(p))) acc2 else p;
        })
    });
}

euler5(limit : int) -> int {
    foldRange(1, limit, 1, \acc, n -> {
        if (acc % n == 0) {
            // We already are a factor
            acc;
        } else {
            // We are not a factor. Figure out what
            // factors are missing, and add those
            required = n / gcd(acc, n);
            acc * required;
        }
    })
}

euler6(limit : int) -> double {
    sumsquares = foldRange(1, limit, 0.0, \acc, n -> acc + i2d(n * n));
    natsum = foldRange(1, limit, 0.0, \acc, n -> acc + i2d(n));
	natsum * natsum - sumsquares
}

showTime(fn: () -> string) -> void {
	if (getUrlParameter("determ") == "") {
		t = timestamp();
		println(fn() + " in " + d2st((timestamp() - t) / 1000.0, 6) + ".s");
	} else {
		println(fn());
	}
}

mutRecFn1(a: int, b: int) -> string {
	if (a == 0) "A" else {
		mutRecFn2(a, b - 1);
	}
}

mutRecFn2(a: int, b: int) -> string {
	if (b == 0) "B" else {
		mutRecFn1(a - 1, b);
	}
}


test1(M: int) -> double {
	foldTree(
		pairs2tree(generate(0, M, \i -> Pair(i + 3, i * 2))),
		0.0, \key, val, acc -> messageCompileTime("unsuccessfull CT: ", acc + i2d(key + val))
	);
}

fn(i: int) -> int {
	(5 + i * 7  + 3 * i * i - 2 * i * i * i) % 100000;
}

gn(i: int) -> int {
	(7 - i * 2  + 5 * i * i +  i * i * i) % 1000000;
}

fromBinaryToFlow(v : string) -> flow {
	deserializeBinary(v, None())
}

main() {
	m = Some([Some("bla"), None(), Some("")]);
	mb = toBinary(m);
	println(mb);
	println("Struct " + toString(m) + ":");

	x0 = "12.4";
	xb = messageCompileTime("toBinary(x): ", toBinary(x0));
	printlnCompileTime("toBinary(x) : '  " + toBinary(x0) + "'");
	x1 = compileTime(toBinary(x0));
	printlnCompileTime("compileTime(toBinary(x0)) : '  " + x1 + "'");
	x2 = forbidCompileTime(toBinary(x0));
	printlnCompileTime("x2 = forbidCompileTime(toBinary(x0)) : '  " + x2 + "'");
	x3 = compileTime({v = toBinary(x0); println("toBinary(x0): ''  " + v + " ''"); v});
	println("x3 = '' " + x3 + " '' ");

	/*xxx = compileTime({
		prog = hostCall("parse_flow", ["import runtime; main() { println(\"HW\"); quit(0); }"]);
		println(prog.second);
		prog;
	});*/

	printlnCompileTime("forbidCompileTime(toBinary(x0)) : '  " + forbidCompileTime(toBinary(x0)) + "'");

	println("String " + x0 + ":");
	println(s2a(xb));
	xr = messageCompileTime("deserializeBinary(xb, None()): ", deserializeBinary(xb, None()));
	xr1 = messageCompileTime("fromBinaryToFlow(xb): ", fromBinaryToFlow(xb));
	println("x.type: " + runtimeValueType(messageCompileTime("xr: ", xr)));

	enclosed_callback = \x -> {
		z = messageCompileTime("z = x * 2: ", messageCompileTime("x: ", x) * 2);
		\ -> messageCompileTime("z + 1: ", messageCompileTime("z: ", z) + 1)
	};
	println("enclosed_callback(2)(): " + i2s(compileTime(enclosed_callback(2)())));

	println("mutRecFn1(5, 8): " + messageCompileTime("mutRecFn1(5, 8) = ", compileTime(mutRecFn1(5, 8))));
	println("mutRecFn1(5, 3): " + messageCompileTime("mutRecFn1(5, 3) = ", compileTime(mutRecFn1(5, 3))));
	println("mutRecFn2(5, 8): " + messageCompileTime("mutRecFn2(5, 8) = ", compileTime(mutRecFn2(5, 8))));
	println("mutRecFn2(5, 3): " + messageCompileTime("mutRecFn2(5, 3) = ", compileTime(mutRecFn2(5, 3))));

	N = 10;
	arr1 = messageCompileTime("arr1 (CT " + i2s(N) + "): ", compileTime(enumFromTo(0, N)));
	println("arr1 (RT " + i2s (N) + "): " + compileTime(toString(arr1)));
	messageCompileTime("t0: ", fold(arr1, makeTree(), \acc, i ->
		setTree(acc, i2s(gn(i)), i2s(fn(i)))
	));
	t0 = messageCompileTime("t0: ", fold(arr1, makeTree(), \acc, i ->
		setTree(acc, i2s(gn(i)), i2s(fn(i)))
	));
	start0 = timestamp();
	t1 = messageCompileTime("t0: ", fold(enumFromTo(0, N), makeTree(), \acc, i ->
		setTree(acc, i2s(gn(i)), i2s(fn(i)))
	));

	println("enumFromTo(1, 5): " + toString(messageCompileTime("enumFromTo(1, 5) = ", enumFromTo(1, 5))));
	println("generate(0, 5, \\i -> i + 1)): " +
		toString(messageCompileTime("enumFromTo(1, 5) = ", generate(0, 5, \i -> i + 1)))
	);
	println("generate(0, 5, \\i -> Pair(i, i)): " +
		toString(messageCompileTime("enumFromTo(1, 5) = ", generate(0, 5, \i -> Pair(i, i))))
	);
	println("generate(0, 5, \\i -> Pair(i + 3, i * 2)): " +
		toString(messageCompileTime("enumFromTo(1, 5) = ", generate(0, 5, \i -> Pair(i + 3, i * 2))))
	);

	println("tree (1): " + toString(messageCompileTime("tree (CT 1): ", fold(enumFromTo(0, N), makeTree(), \acc, i ->
		setTree(acc, i2s(gn(i)), i2s(fn(i)))
	))));
	tree = messageCompileTime("tree (CT 2): ", fold(enumFromTo(0, N), makeTree(), \acc, i ->
		setTree(acc, i2s(gn(i)), i2s(fn(i)))
	));
	println("tree (2): " + toString(messageCompileTime("tree (CT 3): ", tree)));

	M = 362893;
	showTime(\ -> "A big num(1): " + messageCompileTime("d2s(test1(" + i2s(M) + ")) = ", d2s(test1(M))));
	showTime(\ -> "A big num(2): " + messageCompileTime("d2s(foldTree(
		pairs2tree(generate(0, 362893, \\i -> Pair(i + 3, i * 2))),
		0.0, \\key, val, acc -> acc + i2d(key + val)
	)) = \n", d2s(foldTree(
			pairs2tree(
				generate(0, M, \i -> Pair(i + 3, i * 2))
			),
		0.0, \key, val, acc -> acc + i2d(key + val)
	))));
	showTime(\ -> "A big num(3): " + messageCompileTime("d2s(foldTree(
		pairs2tree(generate(0, 362893, \\i -> Pair(i + 3, i * 2))),
		0.0, \\key, val, acc -> acc + i2d(key + val)
	)) = \n", d2s(foldTree(
		pairs2tree(generate(0, M, \i -> Pair(i + 3, i * 2))),
		0.0, \key, val, acc -> acc + i2d(key + val)
	))));

	showTime(\ -> "(CT) euler1: " + i2s(messageCompileTime("euler1(1000) = ", compileTime(euler1(1000)))) + " (must be 233168)"); // Correct: 233168
	showTime(\ -> "(CT) euler2: " + d2s(messageCompileTime("euler2(0.0, 1.0, 0.0) = ", compileTime(euler2(0.0, 1.0, 0.0)))) + " (must be 4613732)"); // Correct: 461373
	showTime(\ -> "(CT) euler3: " + d2s(messageCompileTime("findBiggestDivisor(600851475143.0)) = ", compileTime(findBiggestDivisor(600851475143.0)))) + " (must be 6857)"); // Correct: 6857
	showTime(\ -> "(CT) euler4: " + i2s(messageCompileTime("euler4() = ", compileTime(euler4()))) + " (must be 906609)"); // 906609
	showTime(\ -> "(CT) euler5: " + i2s(messageCompileTime("euler5(20) = ", compileTime(euler5(20)))) + " (must be 232792560)"); // Correct: 232792560
	showTime(\ -> "(CT) euler6: " + d2s(messageCompileTime("euler6(100) = ", compileTime(euler6(100)))) + " (must be 25164150)"); // Correct: 25164150

	showTime(\ -> "(RT) euler1: " + i2s(forbidCompileTime(euler1(1000))) + " (must be 233168)"); // Correct: 233168
	showTime(\ -> "(RT) euler2: " + d2s(forbidCompileTime(euler2(0.0, 1.0, 0.0))) + " (must be 4613732)"); // Correct: 461373
	showTime(\ -> "(RT) euler3: " + d2s(forbidCompileTime(findBiggestDivisor(600851475143.0))) + " (must be 6857)"); // Correct: 6857
	showTime(\ -> "(RT) euler4: " + i2s(forbidCompileTime(euler4())) + " (must be 906609)"); // 906609
	showTime(\ -> "(RT) euler5: " + i2s(forbidCompileTime(euler5(20))) + " (must be 232792560)"); // Correct: 232792560
	showTime(\ -> "(RT) euler6: " + d2s(forbidCompileTime(euler6(100))) + " (must be 25164150)"); // Correct: 25164150

	obj_arr = [1, 2, 3];
	obj_arr1 = obj_arr;
	println("isSameObj(obj_arr, obj_arr1): " + b2s(isSameObj(forbidCompileTime(obj_arr), forbidCompileTime(obj_arr1))));
	//println("isSameObj([1, 2, 3], [1, 2, 3]): " + b2s(forbidCompileTime(isSameObj([1, 2, 3], [1, 2, 3]))));

	//println("must fail at compile time: " + compileTime("param: " + getUrlParameter("param")));

	arr_1 = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];
	arr_2 = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];
	arr_3 = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];
	println("concat with CSE: " + toString(forbidCompileTime(concat3(arr_1, arr_2, arr_3))));

	p1 = Pair([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], "abcdefgh");
	p2 = Pair([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], "abcdefgh");
	p3 = Pair([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], "abcdefgh");
	println("CSE (1): " + forbidCompileTime(toString(p1)));
	println("CSE (2): " + forbidCompileTime(toString(p2)));
	println("CSE (3): " + forbidCompileTime(toString(p3)));

	quit(0);
}