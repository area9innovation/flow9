import math/stringmath;
import ds/tree;
import compile_time;

euler1(limit : int) -> int {
    foldRange(1, limit - 1, 0, \acc, i -> {
        if (i % 3 == 0 || i % 5 == 0) {
            acc + i;
        } else acc;
    });
}

euler2(a : double, b : double, sum : double) -> double {
    fib = a + b;
    nsum = if (fib % 2.0 == 0.0) sum + fib else sum;
    if (fib < 4000000.0) {
        euler2(b, fib, nsum)
    } else {
        nsum;
    }
}

biggestFactor(factor : double, limit : double, biggest : double, n : double) -> double {
	if (factor < limit) {
		if (n % factor == 0.0) {
			biggestFactor(factor, limit, factor, n / factor);
		} else {
			biggestFactor(if (factor == 2.0) 3.0 else factor + 2.0, limit, biggest, n)
		}
	} else {
		biggest;
	}
}

findBiggestDivisor(n : double) -> double {
	biggestFactor(2.0, sqrt(n), 1.0, n);
}

isPalindromic(s : string) -> bool {
	l = strlen(s);
    l <= 1 || {
		first = strLeft(s, 1);
		last = strRight(s, l - 1);
        first == last && isPalindromic(strsubsmart(s, 1, -1));
    }
}

euler4() -> int {
    foldRange(100, 999, 0, \acc, a -> {
        foldRange(100, 999, acc, \acc2, b -> {
        	p = a * b;
	        if (p < acc2 || !isPalindromic(i2s(p))) acc2 else p;
        })
    });
}

euler5(limit : int) -> int {
    foldRange(1, limit, 1, \acc, n -> {
        if (acc % n == 0) {
            // We already are a factor
            acc;
        } else {
            // We are not a factor. Figure out what
            // factors are missing, and add those
            required = n / gcd(acc, n);
            acc * required;
        }
    })
}

euler6(limit : int) -> double {
    sumsquares = foldRange(1, limit, 0.0, \acc, n -> acc + i2d(n * n));
    natsum = foldRange(1, limit, 0.0, \acc, n -> acc + i2d(n));
	natsum * natsum - sumsquares
}

showTime(fn: () -> string) -> void {
	t = timestamp();
	println(fn() + " in " + d2st((timestamp() - t) / 1000.0, 4) + ".s");
}

mutRecFn1(a: int, b: int) -> string {
	if (a == 0) "A" else {
		mutRecFn2(a, b - 1);
	}
}

mutRecFn2(a: int, b: int) -> string {
	if (b == 0) "B" else {
		mutRecFn1(a - 1, b);
	}
}


test1() -> double {
	foldTree(
		pairs2tree(generate(0, 362893, \i -> Pair(i + 3, i * 2))),
		0.0, \key, val, acc -> acc + i2d(key + val)
	);
}

main() {
	println("mutRecFn1(5, 8): " + outputCt("mutRecFn1(5, 8) = ", mutRecFn1(5, 8)));
	println("mutRecFn1(5, 3): " + outputCt("mutRecFn1(5, 3) = ", mutRecFn1(5, 3)));
	println("mutRecFn2(5, 8): " + outputCt("mutRecFn2(5, 8) = ", mutRecFn2(5, 8)));
	println("mutRecFn2(5, 3): " + outputCt("mutRecFn2(5, 3) = ", mutRecFn2(5, 3)));

	println("enumFromTo(1, 5): " + toString(outputCt("enumFromTo(1, 5) = ", enumFromTo(1, 5))));
	println("generate(0, 5, \\i -> i + 1)): " +
		toString(outputCt("enumFromTo(1, 5) = ", generate(0, 5, \i -> i + 1)))
	);
	println("generate(0, 5, \\i -> Pair(i, i)): " +
		toString(outputCt("enumFromTo(1, 5) = ", generate(0, 5, \i -> Pair(i, i))))
	);
	println("generate(0, 5, \\i -> Pair(i + 3, i * 2)): " +
		toString(outputCt("enumFromTo(1, 5) = ", generate(0, 5, \i -> Pair(i + 3, i * 2))))
	);

	showTime(\ -> "A big num(1): " + outputCt("d2s(test1()) = ", d2s(test1())));
	showTime(\ -> "A big num(2): " + outputCt("d2s(foldTree(
		pairs2tree(generate(0, 362893, \\i -> Pair(i + 3, i * 2))),
		0.0, \\key, val, acc -> acc + i2d(key + val)
	)) = \n", d2s(foldTree(
			pairs2tree(
				generate(0, 362893, \i -> Pair(i + 3, i * 2))
			),
		0.0, \key, val, acc -> acc + i2d(key + val)
	))));
	showTime(\ -> "A big num(2): " + outputCt("d2s(foldTree(
		pairs2tree(generate(0, 362893, \\i -> Pair(i + 3, i * 2))),
		0.0, \\key, val, acc -> acc + i2d(key + val)
	)) = \n", d2s(foldTree(
		pairs2tree(generate(0, 362893, \i -> Pair(i + 3, i * 2))),
		0.0, \key, val, acc -> acc + i2d(key + val)
	))));

	showTime(\ -> "euler1: " + i2s(outputCt("euler1(1000) = ", euler1(1000))) + " (must be 233168)"); // Correct: 233168
	showTime(\ -> "euler2: " + d2s(outputCt("euler2(0.0, 1.0, 0.0) = ", euler2(0.0, 1.0, 0.0))) + " (must be 4613732)"); // Correct: 461373
	showTime(\ -> "euler3: " + d2s(outputCt("findBiggestDivisor(600851475143.0)) = ", findBiggestDivisor(600851475143.0))) + " (must be 6857)"); // Correct: 6857
	showTime(\ -> "euler4: " + i2s(outputCt("euler4() = ", euler4())) + " (must be 906609)"); // 906609
	showTime(\ -> "euler5: " + i2s(outputCt("euler5(20) = ", euler5(20))) + " (must be 232792560)"); // Correct: 232792560
	showTime(\ -> "euler6: " + d2s(outputCt("euler6(100) = ", euler6(100))) + " (must be 25164150)"); // Correct: 25164150
	quit(0);
}