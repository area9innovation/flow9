import text/binary;
import math/stringmath;
import ds/tree;
import compile_time;
import net/url_parameter;

euler1(limit : int) -> int {
    foldRange(1, limit - 1, 0, \acc, i -> {
        if (i % 3 == 0 || i % 5 == 0) {
            acc + i;
        } else acc;
    });
}

euler2(a : double, b : double, sum : double) -> double {
    fib = a + b;
    nsum = if (fib % 2.0 == 0.0) sum + fib else sum;
    if (fib < 4000000.0) {
        euler2(b, fib, nsum)
    } else {
        nsum;
    }
}

biggestFactor(factor : double, limit : double, biggest : double, n : double) -> double {
	if (factor < limit) {
		if (n % factor == 0.0) {
			biggestFactor(factor, limit, factor, n / factor);
		} else {
			biggestFactor(if (factor == 2.0) 3.0 else factor + 2.0, limit, biggest, n)
		}
	} else {
		biggest;
	}
}

findBiggestDivisor(n : double) -> double {
	biggestFactor(2.0, sqrt(n), 1.0, n);
}

isPalindromic(s : string) -> bool {
	l = strlen(s);
    l <= 1 || {
		first = strLeft(s, 1);
		last = strRight(s, l - 1);
        first == last && isPalindromic(strsubsmart(s, 1, -1));
    }
}

euler4() -> int {
    foldRange(100, 999, 0, \acc, a -> {
        foldRange(100, 999, acc, \acc2, b -> {
        	p = a * b;
	        if (p < acc2 || !isPalindromic(i2s(p))) acc2 else p;
        })
    });
}

euler5(limit : int) -> int {
    foldRange(1, limit, 1, \acc, n -> {
        if (acc % n == 0) {
            // We already are a factor
            acc;
        } else {
            // We are not a factor. Figure out what
            // factors are missing, and add those
            required = n / gcd(acc, n);
            acc * required;
        }
    })
}

euler6(limit : int) -> double {
    sumsquares = foldRange(1, limit, 0.0, \acc, n -> acc + i2d(n * n));
    natsum = foldRange(1, limit, 0.0, \acc, n -> acc + i2d(n));
	natsum * natsum - sumsquares
}

showTime(fn: () -> string) -> void {
	if (getUrlParameter("determ") == "") {
		t = timestamp();
		println(fn() + " in " + d2st((timestamp() - t) / 1000.0, 6) + ".s");
	} else {
		println(fn());
	}
}

mutRecFn1(a: int, b: int) -> string {
	if (a == 0) "A" else {
		mutRecFn2(a, b - 1);
	}
}

mutRecFn2(a: int, b: int) -> string {
	if (b == 0) "B" else {
		mutRecFn1(a - 1, b);
	}
}


test1(M: int) -> double {
	foldTree(
		pairs2tree(generate(0, M, \i -> Pair(i + 3, i * 2))),
		0.0, \key, val, acc -> outputCompileTimeEval("unsuccessfull CT: ", acc + i2d(key + val))
	);
}

fn(i: int) -> int {
	(5 + i * 7  + 3 * i * i - 2 * i * i * i) % 100000;
}

gn(i: int) -> int {
	(7 - i * 2  + 5 * i * i +  i * i * i) % 1000000;
}

fromBinaryToFlow(v : string) -> flow {
	deserializeBinary(v, None())
}

main() {
	m = Some([Some("bla"), None(), Some("")]);
	mb = toBinary(m);
	println(mb);
	println("Struct " + toString(m) + ":");

	x0 = "12.4";
	xb = outputCompileTimeEval("toBinary(x): ", toBinary(x0));
	println("String " + x0 + ":");
	println(s2a(xb));
	xr = outputCompileTimeEval("deserializeBinary(xb, None()): ", deserializeBinary(xb, None()));
	xr1 = outputCompileTimeEval("fromBinaryToFlow(xb): ", fromBinaryToFlow(xb));
	println("x.type: " + runtimeValueType(outputCompileTimeEval("xr: ", xr)));

	enclosed_callback = \x -> {
		z = outputCompileTimeEval("z = x * 2: ", outputCompileTimeEval("x: ", x) * 2);
		\ -> outputCompileTimeEval("z + 1: ", outputCompileTimeEval("z: ", z) + 1)
	};
	println("enclosed_callback(2)(): " + i2s(forceCompileTimeEval(enclosed_callback(2)())));

	println("mutRecFn1(5, 8): " + outputCompileTimeEval("mutRecFn1(5, 8) = ", forceCompileTimeEval(mutRecFn1(5, 8))));
	println("mutRecFn1(5, 3): " + outputCompileTimeEval("mutRecFn1(5, 3) = ", forceCompileTimeEval(mutRecFn1(5, 3))));
	println("mutRecFn2(5, 8): " + outputCompileTimeEval("mutRecFn2(5, 8) = ", forceCompileTimeEval(mutRecFn2(5, 8))));
	println("mutRecFn2(5, 3): " + outputCompileTimeEval("mutRecFn2(5, 3) = ", forceCompileTimeEval(mutRecFn2(5, 3))));

	N = 10;
	arr1 = outputCompileTimeEval("arr1 (CT " + i2s(N) + "): ", forceCompileTimeEval(enumFromTo(0, N)));
	println("arr1 (RT " + i2s (N) + "): " + forceCompileTimeEval(toString(arr1)));
	outputCompileTimeEval("t0: ", fold(arr1, makeTree(), \acc, i ->
		setTree(acc, i2s(gn(i)), i2s(fn(i)))
	));
	t0 = outputCompileTimeEval("t0: ", fold(arr1, makeTree(), \acc, i ->
		setTree(acc, i2s(gn(i)), i2s(fn(i)))
	));
	start0 = timestamp();
	t1 = outputCompileTimeEval("t0: ", fold(enumFromTo(0, N), makeTree(), \acc, i ->
		setTree(acc, i2s(gn(i)), i2s(fn(i)))
	));

	println("enumFromTo(1, 5): " + toString(outputCompileTimeEval("enumFromTo(1, 5) = ", enumFromTo(1, 5))));
	println("generate(0, 5, \\i -> i + 1)): " +
		toString(outputCompileTimeEval("enumFromTo(1, 5) = ", generate(0, 5, \i -> i + 1)))
	);
	println("generate(0, 5, \\i -> Pair(i, i)): " +
		toString(outputCompileTimeEval("enumFromTo(1, 5) = ", generate(0, 5, \i -> Pair(i, i))))
	);
	println("generate(0, 5, \\i -> Pair(i + 3, i * 2)): " +
		toString(outputCompileTimeEval("enumFromTo(1, 5) = ", generate(0, 5, \i -> Pair(i + 3, i * 2))))
	);

	println("tree (1): " + toString(outputCompileTimeEval("tree (CT 1): ", fold(enumFromTo(0, N), makeTree(), \acc, i ->
		setTree(acc, i2s(gn(i)), i2s(fn(i)))
	))));
	tree = outputCompileTimeEval("tree (CT 2): ", fold(enumFromTo(0, N), makeTree(), \acc, i ->
		setTree(acc, i2s(gn(i)), i2s(fn(i)))
	));
	println("tree (2): " + toString(outputCompileTimeEval("tree (CT 3): ", tree)));

	M = 362893;
	showTime(\ -> "A big num(1): " + outputCompileTimeEval("d2s(test1(" + i2s(M) + ")) = ", d2s(test1(M))));
	showTime(\ -> "A big num(2): " + outputCompileTimeEval("d2s(foldTree(
		pairs2tree(generate(0, 362893, \\i -> Pair(i + 3, i * 2))),
		0.0, \\key, val, acc -> acc + i2d(key + val)
	)) = \n", d2s(foldTree(
			pairs2tree(
				generate(0, M, \i -> Pair(i + 3, i * 2))
			),
		0.0, \key, val, acc -> acc + i2d(key + val)
	))));
	showTime(\ -> "A big num(3): " + outputCompileTimeEval("d2s(foldTree(
		pairs2tree(generate(0, 362893, \\i -> Pair(i + 3, i * 2))),
		0.0, \\key, val, acc -> acc + i2d(key + val)
	)) = \n", d2s(foldTree(
		pairs2tree(generate(0, M, \i -> Pair(i + 3, i * 2))),
		0.0, \key, val, acc -> acc + i2d(key + val)
	))));

	showTime(\ -> "(CT) euler1: " + i2s(outputCompileTimeEval("euler1(1000) = ", forceCompileTimeEval(euler1(1000)))) + " (must be 233168)"); // Correct: 233168
	showTime(\ -> "(CT) euler2: " + d2s(outputCompileTimeEval("euler2(0.0, 1.0, 0.0) = ", forceCompileTimeEval(euler2(0.0, 1.0, 0.0)))) + " (must be 4613732)"); // Correct: 461373
	showTime(\ -> "(CT) euler3: " + d2s(outputCompileTimeEval("findBiggestDivisor(600851475143.0)) = ", forceCompileTimeEval(findBiggestDivisor(600851475143.0)))) + " (must be 6857)"); // Correct: 6857
	showTime(\ -> "(CT) euler4: " + i2s(outputCompileTimeEval("euler4() = ", forceCompileTimeEval(euler4()))) + " (must be 906609)"); // 906609
	showTime(\ -> "(CT) euler5: " + i2s(outputCompileTimeEval("euler5(20) = ", forceCompileTimeEval(euler5(20)))) + " (must be 232792560)"); // Correct: 232792560
	showTime(\ -> "(CT) euler6: " + d2s(outputCompileTimeEval("euler6(100) = ", forceCompileTimeEval(euler6(100)))) + " (must be 25164150)"); // Correct: 25164150

	showTime(\ -> "(RT) euler1: " + i2s(forbidCompileTimeEval(euler1(1000))) + " (must be 233168)"); // Correct: 233168
	showTime(\ -> "(RT) euler2: " + d2s(forbidCompileTimeEval(euler2(0.0, 1.0, 0.0))) + " (must be 4613732)"); // Correct: 461373
	showTime(\ -> "(RT) euler3: " + d2s(forbidCompileTimeEval(findBiggestDivisor(600851475143.0))) + " (must be 6857)"); // Correct: 6857
	showTime(\ -> "(RT) euler4: " + i2s(forbidCompileTimeEval(euler4())) + " (must be 906609)"); // 906609
	showTime(\ -> "(RT) euler5: " + i2s(forbidCompileTimeEval(euler5(20))) + " (must be 232792560)"); // Correct: 232792560
	showTime(\ -> "(RT) euler6: " + d2s(forbidCompileTimeEval(euler6(100))) + " (must be 25164150)"); // Correct: 25164150

	obj_arr = [1, 2, 3];
	obj_arr1 = obj_arr;
	println("isSameObj(obj_arr, obj_arr1): " + b2s(isSameObj(forbidCompileTimeEval(obj_arr), forbidCompileTimeEval(obj_arr1))));
	//println("isSameObj([1, 2, 3], [1, 2, 3]): " + b2s(forbidCompileTimeEval(isSameObj([1, 2, 3], [1, 2, 3]))));

	//println("must fail at compile time: " + forceCompileTimeEval("param: " + getUrlParameter("param")));

	arr_1 = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];
	arr_2 = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];
	arr_3 = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];
	println("concat with CSE: " + toString(forbidCompileTimeEval(concat3(arr_1, arr_2, arr_3))));

	p1 = Pair([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], "abcdefgh");
	p2 = Pair([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], "abcdefgh");
	p3 = Pair([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], "abcdefgh");
	println("CSE (1): " + forbidCompileTimeEval(toString(p1)));
	println("CSE (2): " + forbidCompileTimeEval(toString(p2)));
	println("CSE (3): " + forbidCompileTimeEval(toString(p3)));

	quit(0);
}