import tools/flowc/fctypeenv;
import tools/flowc/manipulation/freevars;
import tools/flowc/flowc_println;

export {
	// Given an order of global vars and functions, find an initialization order
	// which respects internal dependencies. They come in batches that can be
	// run in parallel
	makeInitOrder(config : CompilerConfig, module : FcModule, initOrder : [string]) -> [[string]];
}

makeInitOrder(config : CompilerConfig, module : FcModule, initOrder : [string]) -> [[string]] {
	names = buildSet(initOrder);
	track = fold(initOrder, makeDependencyTracker(), \acc, o -> {
		gvar = lookupTree(module.globalVars, o);
		mexp : Maybe<FcExp> = switch (gvar) {
			None(): {
				gfn = lookupTree(module.functions, o);
				switch (gfn) {
					None(): None();
					Some(fn): eitherMap(fn.lambda, \l : FcLambda -> {
									ll : FcExp = l;
									Some(ll)
								}, None());
				}
			}
			Some(gv): gv.value;
		}
		fv = switch (mexp) {
			Some(e): fcfreevars(e);
			None(): makeSet();
		}

		// We filter this to only the names amongst our selves
		internalFv = intersectSets(fv, names);
		// Also, remove direct recursion to ourselves
		norec = removeSet(internalFv, o);

		addDependencies(acc, o, set2array(norec));
	});

	order = makeOrder(config, module, track, []);
	order;
}

makeOrder(config : CompilerConfig, module : FcModule, d : DependencyTracker<string>, acc : [[string]]) -> [[string]] {
	n = extractNonDependent(d);
	resolved = set2array(n.second);
	if (resolved == []) {
		// OK, we might have a group of names we can not resolve
		unresolved = getTreeKeys(d.fileRequires);
		if (unresolved != [] && getConfigParameter(config.config, "verbose") >= "2") {
			// TODO: Check that these have reasonable types declared
			fcPrintln("There is a loop amongst these names: " + strGlue(unresolved, ", "), config.threadId);
		}
		// When there is a loop, we will have to do them one by one to avoid any problems,
		// but we have to put:
		//  1) all variables before functions.
		//  2) in each group (vars and funcs) order names by dependency relation
		vars_funcs = unzip(unresolved, \nm -> containsKeyTree(module.globalVars, nm));
		vars = vars_funcs.first;
		funcs = vars_funcs.second;
		if (length(vars) == 0) {
			concat(acc, map(unresolved, \fn -> [fn]));
		} else {
			concat3(acc,
				makeInitOrder(config, module, vars),
				if (length(funcs) == 0) [] else makeInitOrder(config, module, funcs)
			);
		}
	} else {
		nacc = arrayPush(acc, resolved);
		nd = fold(resolved, n.first, \acc2, res -> {
			resolveDependency(acc2, res);
		});
		makeOrder(config, module, nd, nacc)
	}
}
