import tools/flowc/incremental/fiprogram;
import tools/flowc/incremental/fiprettyprint;
import tools/flowc/incremental/fi_helpers;
import tools/flowc/flowc_helpers;

export {
	codeCompletion(config : CompilerConfig, globEnv : FcTypeEnvGlobal, linetext : string, line : int, character : int) -> void;
}

/*
TODO:
- Function/struct arguments
- import paths
- export section can complete functions in the body
- switch can expand to cases
- local variables
- types
*/

codeCompletion(config : CompilerConfig, globEnv : FcTypeEnvGlobal, linetext : string, line : int, character : int) -> void {
	fcDebugLog("completion prefix: " + fcCompletionContext2s(fcGetCompletionContext(character, linetext, config)), config);
	switch (fcGetCompletionContext(character, linetext, config)) {
		FcCompletionPrefix(prefix, postfix): {
			completions = codeCompletePrefix(config, globEnv, prefix, makeList());
			printCodeCompletions(config, completions, line, character, strlen(postfix));
		}
		FcCompletionField(field, prefix, postfix): {
			completions = codeCompleteField(config, globEnv, field, prefix, makeList());
			printCodeCompletions(config, completions, line, character, strlen(postfix))
		}
		FcCompletionNone(): { }
	}
}

FcCompletionContext ::= FcCompletionPrefix, FcCompletionField, FcCompletionNone;
	FcCompletionField (
		field : string, // in case of struct field completion
		prefix : string,
		postfix : string
	);
	FcCompletionPrefix(
		prefix : string,
		postfix : string
	);
	FcCompletionNone();

fcCompletionContext2s(context : FcCompletionContext) -> string {
	switch (context) {
		FcCompletionField(field, prefix, postfix):
			"field: '" + field + ", prefix: " + prefix + ", postfix: " + postfix;
		FcCompletionPrefix(prefix, postfix):
			"prefix: " + prefix + ", postfix: " + postfix;
		FcCompletionNone():
			"no completion";
	}
}

fcGetCompletionContext(col : int, linetext : string, config : CompilerConfig) -> FcCompletionContext {
	if (col < 0 || col > strlen(linetext)) FcCompletionNone() else {
		pref = for(col,
			\i -> if (i <= 0) false else fcIsIdChar(getCharAt(linetext, i - 1)), 
			\i -> i - 1
		);
		prefix = substring(linetext, pref, col - pref);
		if (prefix == "" || isDigit(getCharAt(prefix, 0))) FcCompletionNone() else {
			end = for(col, 
				\i -> if (i + 1 >= strlen(linetext)) false else fcIsIdChar(getCharAt(linetext, i + 1)), 
				\i -> i + 1
			);
			postfix = substring(linetext, col, end - col);
			if (pref > 1 && getCharAt(linetext, pref - 1) == "." && fcIsIdChar(getCharAt(linetext, pref - 2))) { 
				field_start = for(pref - 2,
					\i -> if (i <= 0) false else fcIsIdChar(getCharAt(linetext, i - 1)), 
					\i -> i - 1
				);
				field = substring(linetext, field_start, pref - field_start - 1);
				FcCompletionField(field, prefix, postfix);
			} else {
				FcCompletionPrefix(prefix, postfix);
			}
		}
	}
}

codeCompleteField(config : CompilerConfig, globEnv : FcTypeEnvGlobal, field : string, prefix : string, acc : List<CodeCompletion>) -> List<CodeCompletion> {
	makeList(); // TODO: implement
}

codeCompletePrefix(config : CompilerConfig, globEnv : FcTypeEnvGlobal, prefix : string, acc : List<CodeCompletion>) -> List<CodeCompletion> {
	conf = FcPretty(true, true, makeTree(), makeTree());
	file = trimFlowfile(config.flowfile, config.includes, getConfigParameterDef(config.config, "working-dir", ""));
	reduce_name = \nm -> substring(nm, strlen(prefix), strlen(nm) - strlen(prefix));
	mapList(
		fcFilterNameCacheList(globEnv, \cached -> 
			startsWith(cached.named.name, prefix) && (cached.exported || cached.module == file)
		),
		\cached : FcCacheNamed -> {
			named = cached.named;
			switch (named) {
				FiTypeStruct(nm,__,__,__): 
					CodeCompletion(
						nm,
						CompletionConstructor(),
						prettyFiStructOrUnion(conf, named, makeSet()),
						"struct",
						reduce_name(nm),
					);
				FiTypeUnion(nm,__,__,__): 
					CodeCompletion(
						nm,
						CompletionConstructor(),
						prettyFiStructOrUnion(conf, named, makeSet()),
						"union",
						reduce_name(nm)
					);
				FiFunctionDec(nm,__,type,__,__): 
					CodeCompletion(
						nm,
						CompletionFunction(),
						prettyFiType(conf, type, makeSet()),
						"function",
						reduce_name(nm)
					);
				FiGlobalVar(nm,__,type,__,__):
					CodeCompletion(
						nm,
						CompletionVariable(),
						prettyFiType(conf, type, makeSet()),
						"variable",
						reduce_name(nm)
					);
				FiNativeDec(nm,__,type,__,__,__,__): 
					CodeCompletion(
						nm,
						CompletionFunction(),
						prettyFiType(conf, type, makeSet()),
						"native",
						reduce_name(nm)
					);
			}
		}
	);
}

codeCompleteType(config : CompilerConfig, globEnv : FcTypeEnvGlobal, type : FiType, acc : List<CodeCompletion>) -> List<CodeCompletion> {
	conf = FcPretty(true, true, makeTree(), makeTree());
	switch (type) {
		FiTypeArray(t): {acc}
		FiTypeFunction(args, returnType): {acc}
		FiTypeRef(t): {acc}
		FiTypeParameter(n): {acc}
		FiTypeBool(): {acc}
		FiTypeInt(): {acc}
		FiTypeDouble(): {acc}
		FiTypeString(): {acc}
		FiTypeFlow(): {acc}
		FiTypeVoid(): {acc}
		FiTypeNative(): {acc}
		FiTypeName(name, typeparameters): {
			switch (fcLookupNameInCache(globEnv, name)) {
				Some(cached):  {
					switch (cast(cached.named : FiNamed -> FiStructOrUnion)) {
						FiTypeStruct(__,__, args,__): {
							fold(args, acc, \ac, arg ->
								Cons(
									CodeCompletion(
										arg.name,
										CompletionField(),
										prettyFiType(conf, arg.type, makeSet()),
										"field", // Maybe have the entire struct here?
										"." + arg.name,
									),
									ac
								)
							);
						}
						FiTypeUnion(__,__,__,__): {
							// TODO: Here we can traverse the structs and find the fields that all have in common
							acc;
						}
					}
				}
				None(): acc;
			}
		}
	}
}



CodeCompletion(
	// What is to be inserted
	label : string,
	// What kind of completion is this?
	kind : CodeCompletionKind,
	// What type or symbol information
	detail : string,
	// Any documentation we would want
	documentation : string,
	// What is actually be inserted at the cursor position
	insertText : string
);

CodeCompletionKind ::= CompletionText, 
	CompletionFunction, CompletionConstructor, CompletionField,
	CompletionVariable, CompletionFolder;

	CompletionText();
	CompletionFunction();
	CompletionConstructor();
	CompletionField();
	CompletionVariable();
	CompletionFolder();

/*
	export const Method = 2;
	export const Class = 7;
	export const Interface = 8;
	export const Module = 9;
	export const Property = 10;
	export const Unit = 11;
	export const Value = 12;
	export const Enum = 13;
	export const Keyword = 14;
	export const Snippet = 15;
	export const Color = 16;
	export const File = 17;
	export const Reference = 18;
	export const EnumMember = 20;
	export const Constant = 21;
	export const Struct = 22;
	export const Event = 23;
	export const Operator = 24;
	export const TypeParameter = 25;
*/

codeCompletion2json(c : CodeCompletion, line : int, character : int, len : int) -> Json {
	JsonObject([
		Pair("label", JsonString(c.label)),
		Pair("textEdit", JsonObject([
			Pair("range", JsonObject([
				Pair("start", JsonObject([
					Pair("line", JsonDouble(i2d(line))),
					Pair("character", JsonDouble(i2d(character))),
				])),
				Pair("end", JsonObject([
					Pair("line", JsonDouble(i2d(line))),
					Pair("character", JsonDouble(i2d(character + len))),
				])),
			])),
			Pair("newText", JsonString(c.insertText))
		])),
		//Pair("documentation", JsonString(c.documentation)),
		Pair("kind", JsonDouble(i2d(switch (c.kind) {
			CompletionText(): 1;
			CompletionFunction(): 3;
			CompletionConstructor(): 4;
			CompletionField(): 5;
			CompletionVariable(): 6;
			CompletionFolder(): 19;
		}))),
		// TODO: Define a fixed priority for types, and then the string
		Pair("sortText", JsonString(c.label)),
		Pair("detail", JsonString(c.detail)),
		Pair("insertText", JsonString(c.insertText)),
	])
}

printCodeCompletions(config : CompilerConfig, c : List<CodeCompletion>, line : int, character : int, len : int) -> void {
	allCompletions = list2array(c);
	completions = subrange(allCompletions, 0, 100);
	result = JsonObject([
		Pair("isIncomplete", JsonBool(length(completions) != length(allCompletions))),
		Pair("items", JsonArray(
			map(completions, \cm -> codeCompletion2json(cm, line, character, len))
		))
	]);

	fcPrintln("completion[" + json2string(result) + "]completion", config.threadId);
}

