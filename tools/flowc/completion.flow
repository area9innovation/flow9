import tools/flowc/incremental/fiprogram;
import tools/flowc/incremental/fiprettyprint;
import tools/flowc/incremental/fi_helpers;
import tools/flowc/flowc_helpers;

export {
	codeCompletion(config : CompilerConfig, globEnv : FcTypeEnvGlobal, e : FiExp, line : int, character : int) -> void;
	codeCompletePrefix(config : CompilerConfig, globEnv : FcTypeEnvGlobal, linetext : string, line : int, character : int) -> void;
}

/*
TODO:
- Function/struct arguments
- import paths
- export section can complete functions in the body
- switch can expand to cases
- local variables
- types
*/

codeCompletion(config : CompilerConfig, globEnv : FcTypeEnvGlobal, e : FiExp, line : int, character : int) -> void {
	completions = doCodeCompletion(config, globEnv, e, makeList());
	printCodeCompletions(config, completions, line, character, 1);
}

codeCompletePrefix(config : CompilerConfig, globEnv : FcTypeEnvGlobal, linetext : string, line : int, character : int) -> void {
	prefix = trimCompletionPrefix(character, linetext, config);
	if (prefix.first != "") {
		completions = doCodeCompletePrefix(config, globEnv, prefix.first, makeList());
		printCodeCompletions(config, completions, line, character, prefix.second);
	}
}

trimCompletionPrefix(col : int, linetext : string, config : CompilerConfig) -> Pair<string, int> {
	if (col < 0 || col > strlen(linetext)) Pair("", 0) else {
		start = for(col,
			\i -> if (i <= 0) false else fcIsIdChar(getCharAt(linetext, i - 1)), 
			\i -> i - 1
		);
		end = for(col, 
			\i -> if (i + 1 >= strlen(linetext)) false else fcIsIdChar(getCharAt(linetext, i + 1)), 
			\i -> i + 1
		);
		if (isDigit(getCharAt(linetext, start))) Pair("", 0) else {
			Pair(substring(linetext, start, col - start), end - col + 1);
		}
	}
}

doCodeCompletion(config : CompilerConfig, globEnv : FcTypeEnvGlobal, ex : FiExp, acc : List<CodeCompletion>) -> List<CodeCompletion> {
	def = \ -> {
		fcPrintln("TODO: Complete " + prettyFiExp(FcPretty(true, true, makeTree(), makeTree()), ex), config.threadId);
		println(ex);
		acc;
	}
	acc2 = switch (ex) {
		FiLambda(args, body, type, start): def();
		FiCall(f, args, type, start): {
			doCodeCompletion(config, globEnv, f, acc);
		}
		FiVar(name, type, start): {
			doCodeCompletePrefix(config, globEnv, name, acc);
		}
		FiLet(name, type, e1, e2, type2, start): def();
		FiIf(e1, e2, e3, type, start): def();
		FiSwitch(x, switchType, cases, type, start): def();
		FiCast(e, tFrom, tTo, type, start): def();
		FiSeq(es, type, start): def();
		FiCallPrim(op, es, type, start): def();
		FiVoid(start): def();
		FiDouble(d, start): def();
		FiInt(i, start): def();
		FiString(s, start): def();
		FiBool(b, start): def();
		FiRequire(flowfile, e, type, start): def();
		FiUnsafe(name, fallback, type, start): def();
	}

	codeCompleteType(config, globEnv, fiExpType(ex), acc2);
}

doCodeCompletePrefix(config : CompilerConfig, globEnv : FcTypeEnvGlobal, prefix : string, acc : List<CodeCompletion>) -> List<CodeCompletion> {
	conf = FcPretty(true, true, makeTree(), makeTree());
	file = trimFlowfile(config.flowfile, config.includes, getConfigParameterDef(config.config, "working-dir", ""));
	reduce_name = \nm -> substring(nm, strlen(prefix), strlen(nm) - strlen(prefix));
	mapList(
		fcFilterNameCacheList(globEnv, \cached -> 
			startsWith(cached.named.name, prefix) && (cached.exported || cached.module == file)
		),
		\cached : FcCacheNamed -> {
			named = cached.named;
			switch (named) {
				FiTypeStruct(nm,__,__,__): 
					CodeCompletion(
						nm,
						CompletionConstructor(),
						prettyFiStructOrUnion(conf, named, makeSet()),
						"struct",
						reduce_name(nm),
					);
				FiTypeUnion(nm,__,__,__): 
					CodeCompletion(
						nm,
						CompletionConstructor(),
						prettyFiStructOrUnion(conf, named, makeSet()),
						"union",
						reduce_name(nm)
					);
				FiFunctionDec(nm,__,type,__,__): 
					CodeCompletion(
						nm,
						CompletionFunction(),
						prettyFiType(conf, type, makeSet()),
						"function",
						reduce_name(nm)
					);
				FiGlobalVar(nm,__,type,__,__):
					CodeCompletion(
						nm,
						CompletionVariable(),
						prettyFiType(conf, type, makeSet()),
						"variable",
						reduce_name(nm)
					);
				FiNativeDec(nm,__,type,__,__,__,__): 
					CodeCompletion(
						nm,
						CompletionFunction(),
						prettyFiType(conf, type, makeSet()),
						"native",
						reduce_name(nm)
					);
			}
		}
	);
}

codeCompleteType(config : CompilerConfig, globEnv : FcTypeEnvGlobal, type : FiType, acc : List<CodeCompletion>) -> List<CodeCompletion> {
	conf = FcPretty(true, true, makeTree(), makeTree());
	switch (type) {
		FiTypeArray(t): {acc}
		FiTypeFunction(args, returnType): {acc}
		FiTypeRef(t): {acc}
		FiTypeParameter(n): {acc}
		FiTypeBool(): {acc}
		FiTypeInt(): {acc}
		FiTypeDouble(): {acc}
		FiTypeString(): {acc}
		FiTypeFlow(): {acc}
		FiTypeVoid(): {acc}
		FiTypeNative(): {acc}
		FiTypeName(name, typeparameters): {
			switch (fcLookupNameInCache(globEnv, name)) {
				Some(cached):  {
					switch (cast(cached.named : FiNamed -> FiStructOrUnion)) {
						FiTypeStruct(__,__, args,__): {
							fold(args, acc, \ac, arg ->
								Cons(
									CodeCompletion(
										arg.name,
										CompletionField(),
										prettyFiType(conf, arg.type, makeSet()),
										"field", // Maybe have the entire struct here?
										"." + arg.name,
									),
									ac
								)
							);
						}
						FiTypeUnion(__,__,__,__): {
							// TODO: Here we can traverse the structs and find the fields that all have in common
							acc;
						}
					}
				}
				None(): acc;
			}
		}
	}
}



CodeCompletion(
	// What is to be inserted
	label : string,
	// What kind of completion is this?
	kind : CodeCompletionKind,
	// What type or symbol information
	detail : string,
	// Any documentation we would want
	documentation : string,
	// What is actually be inserted at the cursor position
	insertText : string
);

CodeCompletionKind ::= CompletionText, 
	CompletionFunction, CompletionConstructor, CompletionField,
	CompletionVariable, CompletionFolder;

	CompletionText();
	CompletionFunction();
	CompletionConstructor();
	CompletionField();
	CompletionVariable();
	CompletionFolder();

/*
	export const Method = 2;
	export const Class = 7;
	export const Interface = 8;
	export const Module = 9;
	export const Property = 10;
	export const Unit = 11;
	export const Value = 12;
	export const Enum = 13;
	export const Keyword = 14;
	export const Snippet = 15;
	export const Color = 16;
	export const File = 17;
	export const Reference = 18;
	export const EnumMember = 20;
	export const Constant = 21;
	export const Struct = 22;
	export const Event = 23;
	export const Operator = 24;
	export const TypeParameter = 25;
*/

codeCompletion2json(c : CodeCompletion, line : int, character : int, len : int) -> Json {
	JsonObject([
		Pair("label", JsonString(c.label)),
		Pair("textEdit", JsonObject([
			Pair("range", JsonObject([
				Pair("start", JsonObject([
					Pair("line", JsonDouble(i2d(line))),
					Pair("character", JsonDouble(i2d(character))),
				])),
				Pair("end", JsonObject([
					Pair("line", JsonDouble(i2d(line))),
					Pair("character", JsonDouble(i2d(character + len))),
				])),
			])),
			Pair("newText", JsonString(c.insertText))
		])),
		Pair("documentation", JsonString(c.documentation)),
		Pair("kind", JsonDouble(i2d(switch (c.kind) {
			CompletionText(): 1;
			CompletionFunction(): 3;
			CompletionConstructor(): 4;
			CompletionField(): 5;
			CompletionVariable(): 6;
			CompletionFolder(): 19;
		}))),
		// TODO: Define a fixed priority for types, and then the string
		Pair("sortText", JsonString(c.label)),
		Pair("detail", JsonString(c.detail)),
		Pair("insertText", JsonString(c.insertText)),
	])
}

printCodeCompletions(config : CompilerConfig, c : List<CodeCompletion>, line : int, character : int, len : int) -> void {
	allCompletions = list2array(c);
	completions = subrange(allCompletions, 0, 100);
	result = JsonObject([
		Pair("isIncomplete", JsonBool(length(completions) != length(allCompletions))),
		Pair("items", JsonArray(
			map(completions, \cm -> codeCompletion2json(cm, line, character, len))
		))
	]);

	fcPrintln("completion[" + json2string(result) + "]completion", config.threadId);
}

