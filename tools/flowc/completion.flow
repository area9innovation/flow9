import tools/flowc/incremental/fiprogram;
import tools/flowc/incremental/fiprettyprint;
import tools/flowc/incremental/fi_helpers;
import tools/flowc/flowc_helpers;
import tools/flowc/symbol_nature;

export {
	// Output a set of suggestions for auto completion at given position.
	fcFindCompletion(config: CompilerConfig, globEnv : FcTypeEnvGlobal, file : string, line : int, col : int, kind : int, char : string) -> void;
}

/*
TODO:
- Function/struct arguments
- import paths
- export section can complete functions in the body
- switch can expand to cases
- local variables
- types
*/

fcFindCompletion(config: CompilerConfig, globEnv : FcTypeEnvGlobal, file : string, line : int, col : int, kind : int, char : string) -> void {
	workingDir = getConfigParameterDef(config.config, "working-dir", "");
	filepath = findFlowPath(file, true, config.includes, workingDir);
	code = fcFileSource(globEnv, filepath);
	resolver = makeLineResolver(code);
	index = findLineIndex(resolver, line, col);
	switch (fcGetCompletionContext(code, index, config)) {
		Some(context): {
			fcDebugLog("completion context: " + fcCompletionContext2s(context), config);
			completions = switch (context.kind) {
				FcCompletionName(): {
					codeCompleteName(config, globEnv, context.prefix);
				}
				FcCompletionField(): {
					codeCompleteField(config, globEnv, context, file);
				}
				FcCompletionImport(): {
					dir_path = strGlue(map(context.components, \cmp -> cmp.name), "/");
					fold(config.includes, makeList(), \acc, inc -> {
						path = (if (endsWith(inc, "/")) inc else inc + "/") + dir_path;
						codeCompleteImport(config, globEnv, path, context.prefix, acc)
					});
				}
			}
			printCodeCompletions(config, completions, line, col, strlen(context.prefix), strlen(context.postfix));
		}
		None(): { }
	}
}

FcCompletionKind ::= FcCompletionName, FcCompletionField, FcCompletionImport;
	FcCompletionName();
	FcCompletionField();
	FcCompletionImport();

FcCompletionComponent(
	name : string,
	start : int
);

FcCompletionContext(
	components : [FcCompletionComponent], // in case of struct field completion
	prefix : string,
	postfix : string,
	kind : FcCompletionKind
);

fcCompletionContext2s(context : FcCompletionContext) -> string {
	"kind=" + (switch (context.kind) {
		FcCompletionName(): "name";
		FcCompletionField(): "field";
		FcCompletionImport(): "import";
	}) +
	", components=[" + strGlue(map(context.components, \f -> f.name), ".") + "], prefix='" + context.prefix + "', postfix='" + context.postfix + "'";
}

fcGetCompletionContext(code : string, index : int, config : CompilerConfig) -> Maybe<FcCompletionContext> {
	if (index < 0 || index > strlen(code)) None() else {
		pref = for(index,
			\i -> if (i <= 0) false else fcIsIdChar(getCharAt(code, i - 1)), 
			\i -> i - 1
		);
		prefix = substring(code, pref, index - pref);
		if ((prefix == ""  && getCharAt(code, index - 1) != "." && getCharAt(code, index - 1) != "/") || isDigit(getCharAt(prefix, 0))) None() else {
			end = for(index, 
				\i -> if (i + 1 >= strlen(code)) false else fcIsIdChar(getCharAt(code, i + 1)), 
				\i -> i + 1
			);
			postfix = substring(code, index, end - index);
			fields = fcGetCompletionComponents(pref, code, [], config, ".");
			if (fields != []) {
				Some(FcCompletionContext(fields, prefix, postfix, FcCompletionField()));
			} else {
				check_import_kw = \ind -> {
					keyword_end = backwardUntil(code, ind - 1, fcIsIdChar);
					keyword_beg = backwardWhile(code, keyword_end, fcIsIdChar);
					keyword_end != -1 && keyword_beg != -1 && substring(code, keyword_beg, keyword_end - keyword_beg + 1) == "import";
				}
				imports = fcGetCompletionComponents(pref, code, [], config, "/");
				if (imports != []) {
					if (check_import_kw(imports[0].start - 1)) {
						Some(FcCompletionContext(imports, prefix, postfix, FcCompletionImport()));
					} else {
						None();
					}
				} else {
					if (check_import_kw(pref)) {
						Some(FcCompletionContext([], prefix, postfix, FcCompletionImport()));
					} else {
						if (prefix == "") None() else {
							Some(FcCompletionContext([], prefix, postfix, FcCompletionName()));
						}
					}
				}
			}
		}
	}
}

fcGetCompletionComponents(index : int, code : string, acc : [FcCompletionComponent], config : CompilerConfig, delim : string) -> [FcCompletionComponent] {
	if (index > 1 && getCharAt(code, index - 1) == delim && fcIsIdChar(getCharAt(code, index - 2))) { 
		field_start = for(index - 2,
			\i -> if (i <= 0) false else fcIsIdChar(getCharAt(code, i - 1)), 
			\i -> i - 1
		);
		field = substring(code, field_start, index - field_start - 1);
		fcGetCompletionComponents(field_start, code, concat([FcCompletionComponent(field, field_start)], acc), config, delim);
	} else {
		acc;
	}
}

codeCompleteField(config : CompilerConfig, globEnv : FcTypeEnvGlobal, context : FcCompletionContext, file : string) -> List<CodeCompletion> {
	 switch (fcLoadFromCache(globEnv, getTargetModuleName(config))) {
		Some(cached): {
			module = cached.loaded.module;
			var_index = context.components[0].start;
			src = fcFileSource(globEnv, module.fileinfo.fullpath);
			switch(find(tree2pairs(fcApproxToplevels(src)), \p -> p.second.first < var_index && var_index < p.second.second)) {
				Some(scope): {
					name = scope.first;
					switch (fcLookupNameInCache(globEnv, name)) {
						Some(cached_): {
							toplevel = switch (cached_.named) {
								FiTypeStruct(__,__,__,__): FiVoid(-1);
								FiTypeUnion(__,__,__,__): FiVoid(-1);
								FiFunctionDec(__,fn,__,__,__): fn;
								FiGlobalVar(__,val,__,__,__): val;
								FiNativeDec(__,__,__,__,fb,__,__): fb;
							}
							mapping = fcLocalVars2types(toplevel, globEnv);
							switch (lookupTree(mapping, context.components[0].name)) {
								Some(types): {
									fcDebugLog("codeCompleteField: X, types=" + i2s(sizeSet(types)), config);
									foldSet(types, makeList(), \acc, type -> {
										fcDebugLog("type=" + prettyFiType(dummyPretty, type, makeSet()), config);
										fcCompleteFieldViaType(config, globEnv, type, context, 1, acc)
									});
								}
								None(): {
									fcDebugLog("codeCompleteField: variable '" + context.components[0].name + "' is not found", config);
									makeList();
								}
							}
						}
						None(): {
							fcDebugLog("codeCompleteField: toplevel '" + name + "' is not found in cache", config);
							makeList();
						}
					}
				}
				None(): {
					fcDebugLog("codeCompleteField: toplevel for variable is not found", config);
					makeList();
				}
			}
		}
		None(): {
 			fcDebugLog("codeCompleteField: No module with name: " + getTargetModuleName(config), config);
			makeList();
		}
	}
}

fcCompleteFieldViaType(config : CompilerConfig, env : FcTypeEnvGlobal, type : FiType, context : FcCompletionContext, i : int, acc : List<CodeCompletion>) -> List<CodeCompletion> {
	conf = FcPretty(true, true, makeTree(), makeTree());
	proc_struct = \ac, struct -> {
		if (i < length(context.components)) {
			field = context.components[i].name;
			switch (find(struct.args, \arg -> arg.name == field)) {
				Some(arg): fcCompleteFieldViaType(config, env, arg.type, context, i + 1, ac);
				None(): ac;
			}
		} else {
			fold(struct.args, ac, \a, arg ->
				if (!startsWith(arg.name, context.prefix)) a else 
				Cons(
					CodeCompletion(
						arg.name,
						CompletionField(),
						prettyFiType(conf, arg.type, makeSet()),
						"field", // Maybe have the entire struct here?
					),
					a
				)
			);
		}
	}
	switch (type) {
		FiTypeStruct(name, typars, args, __): proc_struct(acc, type);
		FiTypeName(name,__): {
			switch (fcLookupNameInCache(env, name)) {
				Some(str): {
					struct = cast(str.named : FiNamed -> FiTypeStruct);
					proc_struct(acc, struct);
				}
				None(): acc;
			}
		}
		default: acc;
	}
}

fcLocalVars2types(ex : FiExp, env : FcTypeEnvGlobal) -> Tree<string, Set<FiType>> {
	fcDoLocalVars2types(ex, env, makeTree());
}

fcDoLocalVars2types(ex : FiExp, env : FcTypeEnvGlobal, acc : Tree<string, Set<FiType>>) -> Tree<string, Set<FiType>> {
	add_type = \ac, n, t -> setTree(ac, n, insertSet(lookupTreeDef(ac, n, makeSet()), t));
	rec = \ac, e -> fcDoLocalVars2types(e, env, ac);
	switch (ex) {
		FiLambda(args, body, __,__):   fold(args, rec(acc, body), \ac, arg -> add_type(ac, arg.name, arg.type));
		FiCall(f, args, __,__):        fold(args, rec(acc, f), rec);
		FiLet(n, type, e1, e2, __,__): rec(rec(add_type(acc, n, type), e2), e1);
		FiIf(e1, e2, e3, __,__):       rec(rec(rec(acc, e3), e2), e1);
		FiSwitch(v, __, cs, __,__): {
			fold(cs, rec(acc, v), \ac, c ->
				switch (fcLookupNameInCache(env, c.struct)) {
					Some(str): {
						struct = cast(str.named : FiNamed -> FiTypeStruct);
						foldi(c.argNames, ac, \i, a, arg -> add_type(a, arg, struct.args[i].type))
					}
					None(): ac;
				}
			);
		}
		FiCast(e0, __, __, __,__):     rec(acc, e0);
		FiSeq(es, __, s):              fold(es, acc, rec);
		FiCallPrim(__, es, __,__):     fold(es, acc, rec);
		FiRequire(__, e, __,__):       rec(acc, e);
		FiUnsafe(__, fb, __,__):       rec(acc, fb);
		FiVar(n, type,__):             add_type(acc, n, type);
		default: acc;
	}
}

codeCompleteName(config : CompilerConfig, globEnv : FcTypeEnvGlobal, prefix : string) -> List<CodeCompletion> {
	conf = FcPretty(true, true, makeTree(), makeTree());
	file = trimFlowfile(config.flowfile, config.includes, getConfigParameterDef(config.config, "working-dir", ""));
	mapList(
		fcFilterNameCacheList(globEnv, \cached -> 
			startsWith(cached.named.name, prefix) && (cached.exported || cached.module == file)
		),
		\cached : FcCacheNamed -> {
			named = cached.named;
			switch (named) {
				FiTypeStruct(nm,__,__,__): 
					CodeCompletion(
						nm,
						CompletionConstructor(),
						prettyFiStructOrUnion(conf, named, makeSet()),
						"struct"
					);
				FiTypeUnion(nm,__,__,__): 
					CodeCompletion(
						nm,
						CompletionConstructor(),
						prettyFiStructOrUnion(conf, named, makeSet()),
						"union"
					);
				FiFunctionDec(nm,__,type,__,__): 
					CodeCompletion(
						nm,
						CompletionFunction(),
						prettyFiType(conf, type, makeSet()),
						"function"
					);
				FiGlobalVar(nm,__,type,__,__):
					CodeCompletion(
						nm,
						CompletionVariable(),
						prettyFiType(conf, type, makeSet()),
						"variable"
					);
				FiNativeDec(nm,__,type,__,__,__,__): 
					CodeCompletion(
						nm,
						CompletionFunction(),
						prettyFiType(conf, type, makeSet()),
						"native"
					);
			}
		}
	);
}

fcDirectoryContainsFlowSources(d : string) -> bool {
	dir = if (endsWith(d, "/")) d else d + "/";
	if (!isDirectory(dir)) false else {
		exists(readDirectory(dir), \nm -> {
				name = dir + nm;
				if (isDirectory(name)) {
					fcDirectoryContainsFlowSources(name);
				} else {
					endsWith(name, ".flow");
				}
			}
		);
	} 
}

codeCompleteImport(config : CompilerConfig, globEnv : FcTypeEnvGlobal, path : string, prefix : string, acc : List<CodeCompletion>) -> List<CodeCompletion> {
	if (!isDirectory(path)) acc else {
		fold(readDirectory(path), acc, \ac, nm ->
			if (!startsWith(nm, prefix)) ac else {
				name = (if (endsWith(path, "/")) path else path + "/") + nm;
				if (fcDirectoryContainsFlowSources(name)) {
					Cons(CodeCompletion(nm, CompletionFolder(), "directory", "folder"), ac)
				} else if (fileExists(name) && endsWith(name, ".flow")) {
					Cons(CodeCompletion(strLeft(nm, strlen(nm) - 5) + ";", CompletionModule(), "module", "module"), ac)
				} else {
					ac;
				}
			}
		);
	} 
}

CodeCompletion(
	// What is to be inserted
	label : string,
	// What kind of completion is this?
	kind : CodeCompletionKind,
	// What type or symbol information
	detail : string,
	// Any documentation we would want
	documentation : string
);

CodeCompletionKind ::= CompletionText, 
	CompletionFunction, CompletionConstructor, CompletionField,
	CompletionVariable, CompletionFolder, CompletionModule;

	CompletionText();
	CompletionFunction();
	CompletionConstructor();
	CompletionField();
	CompletionVariable();
	CompletionFolder();
	CompletionModule();

/*
	export const Method = 2;
	export const Class = 7;
	export const Interface = 8;
	export const Property = 10;
	export const Unit = 11;
	export const Value = 12;
	export const Enum = 13;
	export const Keyword = 14;
	export const Snippet = 15;
	export const Color = 16;
	export const File = 17;
	export const Reference = 18;
	export const EnumMember = 20;
	export const Constant = 21;
	export const Struct = 22;
	export const Event = 23;
	export const Operator = 24;
	export const TypeParameter = 25;
*/

codeCompletion2json(c : CodeCompletion, line : int, character : int, prefix_len : int, postfix_len : int) -> Json {
	JsonObject([
		Pair("label", JsonString(c.label)),
		Pair("textEdit", JsonObject([
			Pair("range", JsonObject([
				Pair("start", JsonObject([
					Pair("line", JsonDouble(i2d(line))),
					Pair("character", JsonDouble(i2d(character - prefix_len))),
				])),
				Pair("end", JsonObject([
					Pair("line", JsonDouble(i2d(line))),
					Pair("character", JsonDouble(i2d(character + postfix_len))),
				])),
			])),
			Pair("newText", JsonString(c.label))
		])),
		//Pair("documentation", JsonString(c.documentation)),
		Pair("kind", JsonDouble(i2d(switch (c.kind) {
			CompletionText(): 1;
			CompletionFunction(): 3;
			CompletionConstructor(): 4;
			CompletionField(): 5;
			CompletionVariable(): 6;
			CompletionFolder(): 19;
			CompletionModule(): 9;
		}))),
		// TODO: Define a fixed priority for types, and then the string
		Pair("sortText", JsonString(c.label)),
		Pair("detail", JsonString(c.detail)),
		Pair("insertText", JsonString(c.label)),
	])
}

printCodeCompletions(config : CompilerConfig, c : List<CodeCompletion>, line : int, character : int, prefix_len : int, postfix_len : int) -> void {
	allCompletions = list2array(c);
	completions = subrange(allCompletions, 0, 100);
	result = JsonObject([
		Pair("isIncomplete", JsonBool(length(completions) != length(allCompletions))),
		Pair("items", JsonArray(
			map(completions, \cm -> codeCompletion2json(cm, line, character, prefix_len, postfix_len))
		))
	]);

	fcPrintln("completion[" + json2string(result) + "]completion", config.threadId);
}
