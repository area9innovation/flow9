import tools/flowc/manipulation/countvars;
import tools/flowc/preload_modules;
import tools/flowc/completion;
import tools/flowc/find_occurrences;
import lingo/linecolumn;

export {
	handleFindOptions(flowfile : string, prog : FiProgram) -> void;
	findDefDecl(config : CompilerConfig, globEnv : FcTypeEnvGlobal, file : string, symbol : string) -> void;

	// Prints all locations of a symbol. In case symbol is local or struct field, line number and column are used to identify it.
	fcFindUses(config: CompilerConfig, globEnv : FcTypeEnvGlobal, symbol : string, showStopper : (int) -> void) -> void;

	// Uses global cache for lookups.
	fcFastFindUses(config: CompilerConfig, globEnv : FcTypeEnvGlobal, name : string, line : int, col : int) -> void;

	// Find a type info for a symbol at given position.
	fcSymbolInfo(config: CompilerConfig, globEnv : FcTypeEnvGlobal, name : string, line : int, col : int) -> void;
}

handleFindOptions(file : string, prog : FiProgram) -> void {
	config = prog.config;

	dumpIds = getConfigParameter(config.config, "dump-ids");
	if (dumpIds != "") {
		dumpFcProgramIds(prog, dumpIds);
	}

	if (getConfigParameter(config.config, "dump-counts") != "") {
		dumpProgramCounts(prog);
	}

	line = getConfigParameter(config.config, "exp-line");
	col = getConfigParameter(config.config, "exp-column");
	if (isAnyConfigParametersSet(config.config, ["find-type", "find-definition", "find-declaration", "find-uses"])) {
		if (line != "" && col != "") {
			findDefDeclByLineCol(file, prog, s2i(line) - 1, s2i(col) - 1);
		} else {
			fcPrintln("Expect exp-line and exp-column arguments", config.threadId);
		}
	}

	if (isConfigParameterTrue(config.config, "complete")) {
		if (line != "" && col != "") {
			findCompletion(prog, file, s2i(line) - 1, s2i(col) - 1);
		} else {
			fcPrintln("Expect exp-line and exp-column arguments", config.threadId);
		}
	}
}

findDefDeclByLineCol(file : string, prog : FiProgram, line : int, col : int) -> void {
	config = prog.config;
	found = findFiExpInProgramAtLineCol(prog, file, line, col, true);
	switch (found.first) {
		Some(e):
			if (isConfigParameterTrue(config.config, "find-type")) {
				fcPrintln("Type=" + prettyFiType(FcPretty(false, true, makeTree(), makeTree()), fiExpType(e), makeSet()), config.threadId);
			} else {
				switch (e) {
					FiVar(name, type, start): {
						module = name2FimoduleInFiProgram(prog, file, name);
						if (isConfigParameterTrue(config.config, "find-definition")) {
							switch (lookupTree(prog.names.toplevel, name)) {
								Some(decl): printLocation(config, module.fileinfo.fullpath, decl.defiStart, decl.defiStart + strlen(name), "");
								None(): {
									fcPrintln("Could not find global name in " + file + " at line " + i2s(line + 1) + " col " + i2s(col + 1), config.threadId);
								}
							}
						} else if (isConfigParameterTrue(config.config, "find-declaration")) {
							switch (lookupTree(prog.names.toplevel, name)) {
								Some(decl): printLocation(config, module.fileinfo.fullpath, decl.declStart, decl.declStart + strlen(name), "");
								None(): {
									fcPrintln("Could not find global name in " + file + " at line " + i2s(line + 1) + " col " + i2s(col + 1), config.threadId);
								}
							}
						} else if (isConfigParameterTrue(config.config, "find-uses")) {
							//findLocalExpType(prog, flowfile, s2i(line) - 1, s2i(column) - 1);
						}
					}
					default: {
						fcPrintln("Entity in " + file + " at line " + i2s(line + 1) + " col " + i2s(col + 1) + " is not named", config.threadId);
					}
				}
			}
		None(): {
			fcPrintln("Could not find anything in " + file + " at line " + i2s(line + 1) + " col " + i2s(col + 1), config.threadId);
		}
	}
}

findLocalExpType(prog : FiProgram, file : string, line : int, col : int) -> void {
	mexp : Maybe<FiExp> = findFiExpInProgramAtLineCol(prog, file, line, col, true).first;
	switch (mexp) {
		Some(e): fcPrintln("Type=" + prettyFiType(FcPretty(false, true, makeTree(), makeTree()), fiExpType(e), makeSet()), prog.config.threadId);
		None(): {
			fcPrintln("Could not find type in " + file + " at line " + i2s(line) + " col " + i2s(col), prog.config.threadId);
		}
	}
}

findFiExpInProgramAtLineCol(prog : FiProgram, file : string, line : int, col : int, wantType : bool) -> Pair<Maybe<FiExp>, string> {
	workingDir = getConfigParameterDef(prog.config.config, "working-dir", "");
	filepath = findFlowPath(file, true, prog.config.includes, workingDir);
	code = getFileContent(filepath);
	resolver = makeLineResolver(code);

	linestart = findLineIndex(resolver, line, 0);
	linetext = findLine(resolver, linestart).line;
	charsToColumn = goToColumn(linetext, col);
	// This is the text before the point
	text = strLeft(linetext, charsToColumn);

	mfiexp = switch (lookupTree(prog.modules, strReplace(file, ".flow", ""))) {
		Some(module): {
			index = linestart + charsToColumn;

			starts2types = fold(
				module.globalVars,
				fold(
					module.natives,
					fold(
						module.functions, 
						makeTree(), 
						\acc, fun -> start2ExpForTypes(fun.lambda, acc, wantType)
					),
					\acc, nat -> start2ExpForTypes(nat.fallbackLambda, acc, wantType)
				),
				\acc, gv -> start2ExpForTypes(gv.value, acc, wantType)
			);
			/*
			println("Looking for " + i2s(index));
			println(text);
			traverseInOrder(starts2types, \k, v -> {
				if (iabs(k - index) < 10) {
					println("At " + i2s(k) + " we have semantically");
					println(prettyFiExp(FcPretty(false, true, makeTree(), makeTree()), v));
					codeline = substring(code, k, k + 10);
					println("from code '" + takeBefore(codeline, "\n", codeline) + "'");
				}
			});*/
			treeIntervalSearch(starts2types, index);
		}
		None(): {
			None();
		}
	}
	Pair(mfiexp, text);
}

// Given this line, find the index of this column (considering 4-char tab indentation)
goToColumn(line : string, col : int) -> int {
	leadingTabs = countLineIndentation(line);
	if (col < 4 * leadingTabs) col / 4
	else col - 3 * leadingTabs;
}

// Here some starts are shifted, because we need to extract info about variable types, i.e. types of corresponding expressions
start2ExpForTypes(e : FiExp, acc : Tree<int, FiExp>, wantType : bool) -> Tree<int, FiExp> {
	switch (e) {
		FiLambda(__, body, __, s):    setTree(start2ExpForTypes(body, acc, wantType), s, e);
		FiCall(f, args, __, s):       setTree(start2ExpForTypes(f, fold(args, acc, \a, arg -> start2ExpForTypes(arg, a, wantType)), wantType), s, e);
		FiLet(__, __, e1, e2, __, s): {
			// NOTE! Here we use e1, not e, because otherwise we'll get void!
			setTree(start2ExpForTypes(e1, start2ExpForTypes(e2, acc, wantType), wantType), s, if (wantType) e1 else e); 
		}
		FiIf(e1, e2, e3, __, s):      setTree(start2ExpForTypes(e1, start2ExpForTypes(e2, start2ExpForTypes(e3, acc, wantType), wantType), wantType), s, e);
		FiSwitch(v, __, cs, __, s):   setTree(start2ExpForTypes(v, fold(cs, acc, \a, c -> start2ExpForTypes(c.body, a, wantType)), wantType), s, e);
		FiCast(e0, __, __, __, s):    setTree(start2ExpForTypes(e0, acc, wantType), s, e);
		FiSeq(es, __, s):             setTree(fold(es, acc, \a, ex -> start2ExpForTypes(ex, a, wantType)), s, e);
		FiCallPrim(op, es, __, s):
			switch (op) {
				// NOTE! Here we use es[1], not e, because otherwise we'll get void!
				FcAssignPrim(): setTree(fold(es, acc, \a, ex -> start2ExpForTypes(ex, a, wantType)), s, if (wantType) es[1] else e);
				default: setTree(fold(es, acc, \a, ex -> start2ExpForTypes(ex, a, wantType)), s, e);
			}
		FiRequire(__, ex, __, s):     setTree(start2ExpForTypes(ex, acc, wantType), s, e);
		FiUnsafe(__, fb, __, s):      setTree(start2ExpForTypes(fb, acc, wantType), s, e);
		FiVar(__, __, s): setTree(acc, s, e);
		FiString(__, s):  setTree(acc, s, e);
		FiBool(__, s):    setTree(acc, s, e);
		FiDouble(__, s):  setTree(acc, s, e);
		FiVoid(s):        setTree(acc, s, e);
		FiInt(__, s):     setTree(acc, s, e);
	}
}

nameAndFcType(name : string, type : FcType) -> string {
	name + " : " + prettyFcType(
		FcPretty(false, true, makeTree(), makeTree()),
		type,
		makeSet()
	)
}

dumpFcProgramIds(prog : FiProgram, file : string) -> void {
	ids = foldTree(prog.modules, [], \modname, module : FiModule, acc -> {
		pc = FcPretty(true, true, makeTree(), makeTree());
		pt = \t -> prettyFiType(pc, t, makeSet());
		psu = \t -> prettyFiStructOrUnion(pc, t, makeSet());
		allIds = isConfigParameterTrue(prog.config.config, "dump-ids-all");

		pathParts = ["file " + module.fileinfo.flowfile]; //], strSplit(module.flowfile, "/")));
		content = getFileContent(module.fileinfo.fullpath);
		resolver = makeLineResolver(content);

		fl = \pos -> {
			i2s(findLine(resolver, pos).lineno);
		}

		imports = map(module.imports, \im -> "import " + im.flowfile);
		module_exports = buildSet(module.exports);

		structs = fold(module.structs, [], \acc2, s ->
			if (allIds || containsSet(module_exports, s.name)) {
				// TODO: We should expand the struct fields here
				// struct Text(text : string, style : [CharacterStyle])
				arrayPush(acc2, "struct " + psu(s) + ";");
			} else acc2
		);
		unions = fold(module.unions, [], \acc2, u -> 
			if (allIds || containsSet(module_exports, u.name)) {
				// TODO: We should expand the union structs here
				// union Form ::= Text, ...;
				arrayPush(acc2, "union " + trim2(psu(u), "()") + ";");
			} else acc2

		);

		natives = fold(module.natives, [], \acc2, na : FiNativeDec -> 
			if (allIds || containsSet(module_exports, na.name)) {
				arrayPush(acc2, "native " + na.name + " : " + pt(na.type) + " = " + na.nativeName + ";");
			} else acc2
		);

		functions = fold(module.functions, [], \acc2, fn : FiFunctionDec ->
			if (allIds || containsSet(module_exports, fn.name)) {
				arrayPush(acc2, "function " + fn.name + pt(fn.type) + ";");
			} else acc2
		);

		vars = fold(module.globalVars, [], \acc2, gv ->
			if (allIds || containsSet(module_exports, gv.name)) {
				arrayPush(acc2, "global " + gv.name + " : " + pt(gv.type) + ";");
			} else acc2
		);

		strings = concatA([pathParts, imports, structs, unions, natives, functions, vars]);
		arrayPush(acc, strings)
	});
	allstrings = concatA(ids);
	text = strGlue(allstrings, "\n");
	setFileContent(file, text);
	{}
}

findDefDecl(config : CompilerConfig, globEnv : FcTypeEnvGlobal, file : string, name : string) -> void {
	switch (fcLookupNameInCache(globEnv, name)) {
		Some(symbol): {
			switch (fcLoadFromCache(globEnv, symbol.module)) {
				Some(loaded): {
					path = loaded.module.fileinfo.fullpath;
					proc_decl = \dec, def -> {
						if (getConfigParameter(config.config, "find-definition") != "") {
							printLocation(config, path, def, def + strlen(name), "");
						} else if (getConfigParameter(config.config, "find-declaration") != "") {
							printLocation(config, path, dec, dec + strlen(name), "");
						} else if (getConfigParameter(config.config, "find-defdecl") != "") {
							printLocation(config, path, def, def + strlen(name), "");
							if (dec != def) {
								printLocation(config, path, dec, dec + strlen(name), "");
							}
						}
					}
					switch (symbol.named) {
						FiTypeStruct(__,__,__, start): printLocation(config, path, start, start + strlen(name), "");
						FiTypeUnion(__,__,__, start):  printLocation(config, path, start, start + strlen(name), "");
						FiFunctionDec(__,__,__, dec, def): proc_decl(dec, def);
						FiGlobalVar(__,__,__, dec, def): proc_decl(dec, def);
						FiNativeDec(__,__,__,__,__, dec, def): proc_decl(dec, def);
					}
				}
				None(): { 
					fcPrintln(file + ": Could not find " + name, config.threadId);
				}
			}
		}
		None(): {
			errors = ref [];
			tenv1 = FcTypeEnvProgram(
				prepareInitialFlowcAcc(config),
				makeTree(),
				\err -> refArrayPush(errors, err),
				ref 0, ref makeTree(), 
				emptyGSubtypeGraph()
			);
			modules = preloadModules(config, globEnv, file, \err -> refArrayPush(errors, err)); // Skip error messages
			tenv2 = findDefinitionInFcModules(tenv1, globEnv, modules, name, file);
			iter(^errors, \err -> printFcError(tenv2.acc, err))
		}
	}
}

// Here we don't use typechecking because desugaring is enough to find a symbol definition
findDefinitionInFcModules(tenv : FcTypeEnvProgram, globEnv : FcTypeEnvGlobal, preloadedModules : Tree<string, FcPreloadedModule>, symbol : string, file : string) -> FcTypeEnvProgram {
	readyForProcessing : [FcPreloadedModule] = filtermap(tree2pairs(preloadedModules), 
		\p : Pair<string, FcPreloadedModule> ->
			if (!containsKeyTree(tenv.acc.modules, preloadedFiFileInfo(p.second).flowfile) && forall(preloadedFcImports(p.second), 
				\im : FcImport -> containsKeyTree(tenv.acc.modules, im.flowfile))) Some(p.second) else None()
	);
	if (readyForProcessing == []) {
		// we are done, everything is processed - nothing is found
		fcPrintln(file + ": Could not find " + symbol, tenv.acc.config.threadId);
		tenv
	} else {
		fromCache : [FiModule] = filtermap(readyForProcessing, \preloaded ->
			switch (preloaded : FcPreloadedModule) {
				FcLoaded(module, __, ): Some(module);
				default: None();
			}
		);
		tenv1 = fold(fromCache, tenv, \acc, module : FiModule -> {
			mergeIncremental2TypeEnvProgram(acc, globEnv, module)
		});

		if (!findDefDeclInFlowcAcc(tenv1.acc, file, symbol)) {

			// proceed with modules that are ready 
			parsed : [FcParsed] = filtermap(readyForProcessing, \preloaded -> 
				switch (preloaded : FcPreloadedModule) {
					FcParsed(__, __, __, __, __): Some(preloaded);
					default: None();
				}
			);
			// now process parsed modules
			desugared : [FcModule] = concurrent(true, map(parsed, \p -> \ -> desugarFcModule(tenv1.acc, initFcTypeEnvLocal(), p.fileinfo, p.syntaxtree)));
			tenv2 = fold(desugared, tenv1, \acc, module -> addFictiveFiModuleFromFcModule(addDesugaredModuleToGlobal(acc, module), module));

			if (!findDefDeclInFlowcAcc(tenv2.acc, file, symbol)) {
				findDefinitionInFcModules(tenv2, globEnv, preloadedModules, symbol, file)
			} else {
				tenv2
			}
		} else {
			tenv1
		}
	}
}

findDefDeclInFlowcAcc(prog : FlowcAcc, flowfile : string, definition : string) -> bool {
	config = prog.config;
	module = name2FimoduleInFlowcAcc(prog, flowfile, definition);
	switch (lookupTree(prog.names.toplevel, definition)) {
		Some(d): {
			switch (d) {
				FcFunctionDec(__, __, __, declInfo, defiInfo): 
					printDefDeclLocation(config, module, definition, declInfo, defiInfo, "");
				FcGlobalVar(__, value, declInfo, defiInfo): {
					printDefDeclLocation(config, module, definition, declInfo, defiInfo, eitherMap(value, \e -> " = " + prettyFcExp(dummyPretty, e), ""));
				}
				FcNativeDec(__, __, __, __, __, info): 
					printDefDeclLocation(config, module, definition, info, info, "");
			}
			true
		}
		None(): {

			pt = \t -> {
				prettyFcType(
					FcPretty(true, true, makeTree(), makeTree()),
					t,
					makeSet()
				)
			}

			switch (lookupTree(prog.names.structs, definition)) {
				Some(struct): {
					printLocation(config, module.fileinfo.fullpath, struct.info.start, struct.info.start + strlen(definition), pt(struct)); 
					true
				}
				None(): {
					switch (lookupTree(prog.names.unions, definition)) {
						Some(union): {
							printLocation(config, module.fileinfo.fullpath, union.info.start, union.info.start + strlen(definition), pt(union)); 
							true
						}
						None(): 
							false;
					}
				}
			}
		}
	}
}

printDefDeclLocation(config : CompilerConfig, module : FiModule, symbol : string, declInfo : FcInfo, defiInfo : FcInfo, details : string) -> void {
	typeMessage = nameAndFcType(symbol, either(^(defiInfo.type), either(^(declInfo.type), dummyType))) + details;
	if (getConfigParameter(config.config, "find-definition") != "") {
		printLocation(config, module.fileinfo.fullpath, defiInfo.start, defiInfo.start + strlen(symbol), typeMessage);
	} else if (getConfigParameter(config.config, "find-declaration") != "") {
		printLocation(config, module.fileinfo.fullpath, declInfo.start, declInfo.start + strlen(symbol), typeMessage);
	} else if (getConfigParameter(config.config, "find-defdecl") != "") {
		printLocation(config, module.fileinfo.fullpath, defiInfo.start, defiInfo.start + strlen(symbol), typeMessage);
		if (defiInfo.start != declInfo.start) {
			printLocation(config, module.fileinfo.fullpath, declInfo.start, declInfo.start + strlen(symbol), typeMessage);
		}
	} else { 
		fcPrintln("Something went wrong: this should never happen", config.threadId);
	}
}

// Here we add FiModule for some FcModule, but only fileinfo is actual - all other fields are empty.
// We do this, because while looking for symbols we don't need complete FiModule structures in
// FlowcAcc.modules tree field.
addFictiveFiModuleFromFcModule(env : FcTypeEnvProgram, module : FcModule) -> FcTypeEnvProgram {
	acc = env.acc;
	info = module.fileinfo;
	FcTypeEnvProgram(
		env with acc = FlowcAcc(
			acc with modules = setTree(acc.modules, module.fileinfo.flowfile,
				FiModule(dummyFiModule with fileinfo = FiFileInfo(info.flowfile, info.trampstamp, info.fullpath, info.md5sum, info.filesize, timestamp()))
			)
		)
	)
}

findCompletion(prog : FiProgram, file : string, line : int, col : int) -> void {
	context = findFiExpInProgramAtLineCol(prog, file, line, col, false);
	mexp : Maybe<FiExp> = context.first;
	switch (mexp) {
		Some(e): {
			codeCompletion(prog, e, line, col);
		}
		None(): {
			before = trim2(context.second, " \t\n;");
			codeCompleteName(prog, before, line, col);
		}
	}
}

fcFindUses(config: CompilerConfig, globEnv : FcTypeEnvGlobal, symbol : string, showStopper : (int) -> void) -> void {
	switch (symbolNature(config, globEnv, symbol)) {
		Some(nature): {
			switch (nature.scope) {
				FcGlobalScope(): {
					// Symbol is global: a toplevel and is exported
					fcFindGlobalUses(config, globEnv, symbol, nature.module, nature.kind);
				}
				FcModuleScope(): {
					// Symbol is toplevel, but not exported, i.e. module-scope
					fcFindModuleUses(config, globEnv, symbol, nature.kind);
				}
				FcLocalScope(): {
					// Symbol is local: not a toplevel
					fcFindLocalUses(config, globEnv, symbol, nature.kind);
				}
			}
		}
		None(): {
			fcPrintln(symbol + " is not found", config.threadId);
		}
	}
	showStopper(0);
}

fcFindGlobalUses(config : CompilerConfig, globEnv : FcTypeEnvGlobal, symbol : string, defModulePath : string, kind : FcSymbolKind) -> void  {
	ensureIncrementalDirectoryExists(config);

	compute_reacheable = \ -> {
		// Skip all error messages at parsing/typechecking, because 
		// occasionaly we can process old/broken/erraneous files.
		fcSetSkipPrinting(config.threadId, true);
		fcSetSkipBuffering(config.threadId, true);

		// Find all sources, containing symbol
		workingDir = getConfigParameterDef(config.config, "working-dir", ".");
		all_sources = findAllSourcesContainingStr(workingDir, symbol, []);

		// Extract those sources, who have a definition module inside inclusions.
		filterSourcesWhichImportDefinitionModule(config, all_sources, defModulePath)
	}
	
	reacheable_sources = if (isConfigParameterSet(config.config, "project")) {
		project = getConfigParameter(config.config, "project");
		if (project == "0") {
			compute_reacheable()
		} else {
			strSplit(project, ",")
		}
	} else {
		compute_reacheable()
	}

	// Produce programs for sources, which contain symbol
	programs = fold(reacheable_sources, Pair(makeTree(), makeSet()),
		\ac, src ->
			if (containsSet(ac.second, src)) {
				// Already inside of typechecked programs
				ac 
			} else {
				prog_error = parseAndTypecheckProgram(CompilerConfig(config with flowfile = src), globEnv, src);
				prog = prog_error.first;
				error = prog_error.second;
				if (error == 0)
					Pair(
						setTree(ac.first, src, prog),
						foldTree(
							prog.modules,
							ac.second,
							\__, module, a -> insertSet(a, module.fileinfo.fullpath)
						)
					)
				else ac
			}
	).first;

	// Return the normal output mode.
	fcSetSkipPrinting(config.threadId, false);
	fcSetSkipBuffering(config.threadId, false);

	locations = foldTree(programs, Pair(makeSet(), makeSet()), \file, prog, ac -> {
			if (containsSet(ac.first, prog.config.flowfile)) ac else {
				processed = foldTree(findOccurencesInFiProgram(prog, symbol, kind, ac.first), ac, \module, occurrences, a ->
					if (containsSet(a.first, module.fileinfo.flowfile)) a else {
						locations = foldSet(occurrences, a.second, \aa, occ -> 
							insertSet(aa, makeLocation(config, module.fileinfo.fullpath, occ, occ + strlen(symbol)))
						);
						Pair(insertSet(a.first, module.fileinfo.flowfile), locations)
					}
				);
				Pair(insertSet(processed.first, prog.config.flowfile), processed.second)
			}
		}
	).second;
	iterSet(locations, \location -> fcPrintln(location + " uses " + symbol, config.threadId));
}

fcFindModuleUses(config : CompilerConfig, globEnv : FcTypeEnvGlobal, symbol : string, kind : FcSymbolKind) -> void {
	prog_error = parseAndTypecheckProgram(config, globEnv, config.flowfile);
	prog = prog_error.first;
	error = prog_error.second;
	if (error == 0) {
		module = lookupTreeDef(prog.modules, getTargetModuleName(config), dummyFiModule);
		iterSet(
			findOccurencesInFiModule(module, symbol, kind), 
			\pos -> printLocation(config, module.fileinfo.fullpath, pos, pos + strlen(symbol), " uses " + symbol)
		);
	}
}

fcFindLocalUses(config : CompilerConfig, globEnv : FcTypeEnvGlobal, symbol : string, kind : FcSymbolKind) -> void {
	line_str = getConfigParameter(config.config, "exp-line");
	column_str = getConfigParameter(config.config, "exp-column");
	if (line_str != "" && column_str != "") {
		line = s2i(line_str) - 1;
		col  = s2i(column_str) - 1;
		file = config.flowfile;
		prog = parseAndDesugarProgram(config, globEnv, file);
		workingDir = getConfigParameterDef(config.config, "working-dir", "");
		relative = trimFlowfile(file, config.includes, workingDir);
		switch (lookupTree(prog.modules, relative)) {
			Some(module): {
				code = getFileContent(module.fileinfo.fullpath);
				resolver = makeLineResolver(code);
				iterSet(
					fcFindLocalOccurrences(module, line, col, symbol, kind),
					\pos -> printLocation(config, module.fileinfo.fullpath, pos, pos + strlen(symbol), " uses " + symbol)
				);
			}
			None(): {
				fcPrintln("module = " + relative + " not found", config.threadId);
			}
		}
	}
}

fcFastFindUses(config: CompilerConfig, globEnv : FcTypeEnvGlobal, name : string, line : int, col : int) -> void {
	print_location = \module, nature, pos -> 
		printLocation(config, module.fileinfo.fullpath, pos, pos + strlen(nature.name), " uses " + nature.name);
	module_uses = \module, nature -> 
		iterSet(
			fcFastFindOccurrencesInFiModule(config, globEnv, module, nature),
			\pos -> print_location(module, nature, pos)
		);
	switch (fastSymbolNature(config, globEnv, name, line, col)) {
		Some(nature): {
			switch (nature.scope) {
				FcGlobalScope(): {
					fcIterCache(globEnv, \m -> module_uses(m, nature));
				}
				FcModuleScope(): {
					maybeApply(
						fcLoadFromCache(globEnv, nature.module), 
						\loaded -> module_uses(loaded.module, nature)
					);
				}
				FcLocalScope(): {
					maybeApply(
						fcLoadFromCache(globEnv, getTargetModuleName(config)), 
						\loaded -> iterSet(
							fcFindLocalOccurrences(loaded.module, line, col, nature.name, nature.kind), 
							\pos -> print_location(loaded.module, nature, pos)
						)
					);
				}
			}
		}
		None(): { }
	}
}

fcSymbolInfo(config: CompilerConfig, globEnv : FcTypeEnvGlobal, name : string, line : int, col : int) -> void {
	switch (fastSymbolNature(config, globEnv, name, line, col)) {
		Some(nature): {
			switch (nature.cached) {
				Some(cached): {
					fcPrintln(fcCacheNamed2s(cached), config.threadId);
				}
				None(): {
					maybeApply(
						fcLoadFromCache(globEnv, getTargetModuleName(config)), 
						\loaded ->
							maybeApply(findFiExpInModuleAtLineCol(loaded.module, line, col, true), 
								\e -> fcPrintln(prettyFiType(dummyPretty, fiExpType(e), makeSet()), config.threadId)
							)
					);
				}
			}
		}
		None(): { }
	}
}

findFiExpInModuleAtLineCol(module : FiModule, line : int, col : int, wantType : bool) -> Maybe<FiExp> {
	code = getFileContent(module.fileinfo.fullpath);
	resolver = makeLineResolver(code);
	index = findLineIndex(resolver, line, col);
	starts2types = fold(
		module.globalVars,
		fold(
			module.natives,
			fold(
				module.functions, 
				makeTree(), 
				\acc, fun -> start2ExpForTypes(fun.lambda, acc, wantType)
			),
			\acc, nat -> start2ExpForTypes(nat.fallbackLambda, acc, wantType)
		),
		\acc, gv -> start2ExpForTypes(gv.value, acc, wantType)
	);
	treeIntervalSearch(starts2types, index);
}

fcCacheNamed2s(cached : FcCacheNamed) -> string {
	symbol = cached.named;
	decl = switch (symbol) {
		FiStructOrUnion(): prettyFiStructOrUnion(FcPretty(true, true, makeTree(), makeTree()), symbol, makeSet());
		FiDeclaration(): prettyFiDeclaration(dummyPretty, symbol, makeSet());
	};
	(if (cached.exported) "exported in" else "local in") + " module " + cached.module + "\n\n" + decl;
}
