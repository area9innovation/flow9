import tools/flowc/manipulation/deadcode;
import tools/flowc_lsp/lsp_utils;
import tools/flowc/symbol_nature;

export {
	// Print a callgraph in format:
	//
	// *** file: algorithms.flow
	// arrayPushSortedWithLimit: length mergeArrays subrange
	// binarySearch: binarySearchInternal genericCompare length
	// binarySearch2: binarySearchInternal length
	// binarySearchEx: binarySearchInternal genericCompare
	// ....
	printCallGraph(filename : string, prog : FiProgram) -> void;

	// Prints all paths from the one function to another.
	// Default value for 'func_to' is "main". 
	// max_num is a limit on the number of reported paths (there may be too much paths).
	pathInCallGraph(func_from : string, func_to : string, max_num : int, prog : FiProgram) -> void;

	// Execute following LSP methods:
	// - textDocument/callHierarchy 
	// - callHierarchy/incomingCalls
	// - callHierarchy/outgoingCalls
	// Output is made in LSP format (JSON).
	lspCallHierarchyMethods(prog : FiProgram, globEnv : FcTypeEnvGlobal) -> void;
}

printCallGraph(filename : string, prog : FiProgram) -> void {
	lines = concatA(map(getTreeValues(prog.modules), \module -> {
		config = prog.config.config;
		useFullPath = isConfigParameterTrue(config, "callgraph-fullpath");

		heading = "*** file: " + (if (useFullPath) module.fileinfo.fullpath else {module.fileinfo.flowfile + ".flow"});
		functions = map(module.functions, \f : FiFunctionDec ->
			Pair(f.name, fifreevars(f.lambda))
		);
		natives = map(module.natives, \f : FiNativeDec ->
			Pair(f.name,
				switch (f.fallbackLambda) {
					FiLambda(__, __, __, __): fifreevars(f.fallbackLambda);
					FiVoid(__): makeSet();
					default: {
						fcPrintln("fallbackLambda in FiNativeDec must be FiLambda or FiVoid, but is: " + prettyFiExp(dummyPretty, f.fallbackLambda), prog.config.threadId);
						makeSet()
					}
				}
			)
		);
		lines2 = map(concat(natives, functions), \p : Pair<string, Set<string>> ->
			p.first + ": " + strGlue(set2array(p.second), " ")
		);
		concat([heading], lines2)
	}));
	if (setFileContent(filename, strGlue(map(lines, \l -> l + "\n"), ""))) {
		if (prog.config.verbose > 0) {
			fcPrintln("Callgraph was successfully written to file '" + filename + "'", prog.config.threadId);	
		}
	} else {
		fcPrintln("Cannot write callgraph to file '" + filename + "'", prog.config.threadId);
	}
}

pathInCallGraph(func_from : string, func_to : string, max_num : int, prog : FiProgram) -> void {
	// Uses - inversed dependencies
	uses = fold(getTreeValues(prog.modules), makeTree(), \acc, module -> {
		acc1 = fold(module.functions, acc, \ac, fn ->
			foldSet(fifreevars(fn.lambda), ac, \a, free ->
				setTree(a, free, insertSet(lookupTreeDef(a, free, makeSet()), fn.name))
			)
		);
		fold(module.natives, acc1, \ac, nat ->
			switch (nat.fallbackLambda) {
				FiLambda(__, __, __, __): {
					foldSet(fifreevars(nat.fallbackLambda), ac, \a, free ->
						setTree(a, free, insertSet(lookupTreeDef(a, free, makeSet()), nat.name))
					);
				}
				FiVoid(__): ac;
				default: {
					fcPrintln("fallbackLambda in FiNativeDec must be FiLambda or FiVoid, but is: " + prettyFiExp(dummyPretty, nat.fallbackLambda), prog.config.threadId);
					ac;
				}
			}
		);
	});
	paths = findAllPathsToMain(mapTree(uses, set2array), [[func_from]], [], func_to, max_num);
	fcPrintln(
		"Call paths from '" + func_from + "' to '" + func_to + "':\n" + 
		concatStrings(map(paths, \path -> "\t" + strGlue(path, " -> ") + "\n")) +
		(if (length(paths) > max_num) "\n  ... \n" else ""), 
		prog.config.threadId
	);
}

findAllPathsToMain(uses : Tree<string, [string]>, paths : [[string]], acc : [[string]], func_to : string, max_num : int) -> [[string]] {
	frontier = filter(paths, \path -> length(path) == sizeSet(buildSet(path)));
	if (frontier == [] || length(acc) > max_num) acc else {
		new_paths = mapConcat(frontier, \path -> 
			map(lookupTreeDef(uses, lastElement(path, ""), []), \last -> concat(path, [last]))
		);
		new_acc = concat(acc, filter(new_paths, \path -> lastElement(path, "") == func_to));
		findAllPathsToMain(uses, new_paths, new_acc, func_to, max_num);
	}
}

nature2kind(nature : FcSymbolNature) -> string {
	switch (nature.kind) {
		FcVarSymbol(type): {
			"fundef";
		}
		FcTypeSymbol(type): {
			"struct";
		}
		FcFieldSymbol(type_name, field_type): {
			"field";
		}
	}
}

pos2LspPosition(pos : int, resolver : LineResolver) -> LspPosition {
	linecol = findLine(resolver, pos);
	LspPosition(linecol.lineno - 1, linecol.column - 1);
}

range2LspRange(range : FcInfo2, resolver : LineResolver) -> LspRange {
	LspRange(
		pos2LspPosition(range.start, resolver),
		pos2LspPosition(range.end, resolver),
	);
}

lspCallHierarchyMethods(prog : FiProgram, env : FcTypeEnvGlobal) -> void {
	config = prog.config;
	if (isConfigParameterSet(config.config, "calls-info")) {
		file = config.flowfile;
		line = s2i(getConfigParameterDef(config.config, "exp-line", "-1"));
		col = s2i(getConfigParameterDef(config.config, "exp-column", "-1"));

		// findFlowPath(flowfile : string, flowsuffix : bool, imports : [string], workingDir : string) -> string;

		path = findFlowPath(config.flowfile, true, config.includes, lookupTreeDef(config.config, "working-dir", ""));


		src = fcFileSource(env, path);
		resolver = makeLineResolver(src);
		name = getNameByLineCol(line, col, src);

		// fastSymbolNature(config : CompilerConfig, globEnv : FcTypeEnvGlobal, name : string, line : int, col : int) -> Maybe<FcSymbolNature>;

		/*
		LspCallHierarchyItem : (
			name : string,
			kind : int,
			tags : [int], // DiagnosticTag: Unnecessary = 1, Deprecated = 2
			detail : string,
			uri : URI,
			range: LspRange,
			selectionRange: LspRange,
			data : Json
		);
		*/
		// string2LspSymbolKind(s : string) -> int

		// getFcInfo2ByLineCol(line : int, col : int, src : string) -> Maybe<FcInfo2>
		maybeApply(getFcInfo2ByLineCol(line, col, src), \fc_range ->
			maybeApply(fastSymbolNature(config, env, name, line, col), \nature -> {
				kind = string2LspSymbolKind(nature2kind(nature));
				range = range2LspRange(fc_range, resolver);
				item = LspCallHierarchyItem(
					name, kind, 
					[], // no tags yet
					"", // no details yet
					URI("file", URIAuthority("", "", ""), path, "", ""),
					range, range, JsonNull()
				);
				fcPrintln(json2string(lspCallHierarchyItem2Json(item)), config.threadId);
			})
		);
	}
	if (isConfigParameterSet(config.config, "calls-from")) {
		name = getConfigParameter(config.config, "calls-from");
	}
	if (isConfigParameterSet(config.config, "calls-to")) {
		name = getConfigParameter(config.config, "calls-from");
	}
}