import tools/flowc/manipulation/deadcode;
import tools/flowc_lsp/lsp_utils;
import tools/flowc/symbol_nature;

export {
	// Print a callgraph in format:
	//
	// *** file: algorithms.flow
	// arrayPushSortedWithLimit: length mergeArrays subrange
	// binarySearch: binarySearchInternal genericCompare length
	// binarySearch2: binarySearchInternal length
	// binarySearchEx: binarySearchInternal genericCompare
	// ....
	printCallGraph(filename : string, prog : FiProgram) -> void;

	// Prints all paths from the one function to another.
	// Default value for 'func_to' is "main". 
	// max_num is a limit on the number of reported paths (there may be too much paths).
	pathInCallGraph(func_from : string, func_to : string, max_num : int, prog : FiProgram) -> void;

	// Execute following LSP methods:
	// - textDocument/callHierarchy 
	// - callHierarchy/incomingCalls
	// - callHierarchy/outgoingCalls
	// Output is made in LSP format (JSON).
	lspCallHierarchyMethods(prog : FiProgram, globEnv : FcTypeEnvGlobal) -> void;
}

printCallGraph(filename : string, prog : FiProgram) -> void {
	lines = concatA(map(getTreeValues(prog.modules), \module -> {
		config = prog.config.config;
		useFullPath = isConfigParameterTrue(config, "callgraph-fullpath");

		heading = "*** file: " + (if (useFullPath) module.fileinfo.fullpath else {module.fileinfo.flowfile + ".flow"});
		functions = map(module.functions, \f : FiFunctionDec ->
			Pair(f.name, fifreevars(f.lambda))
		);
		natives = map(module.natives, \f : FiNativeDec ->
			Pair(f.name,
				switch (f.fallbackLambda) {
					FiLambda(__, __, __, __): fifreevars(f.fallbackLambda);
					FiVoid(__): makeSet();
					default: {
						fcPrintln("fallbackLambda in FiNativeDec must be FiLambda or FiVoid, but is: " + prettyFiExp(dummyPretty, f.fallbackLambda), prog.config.threadId);
						makeSet()
					}
				}
			)
		);
		lines2 = map(concat(natives, functions), \p : Pair<string, Set<string>> ->
			p.first + ": " + strGlue(set2array(p.second), " ")
		);
		concat([heading], lines2)
	}));
	if (setFileContent(filename, strGlue(map(lines, \l -> l + "\n"), ""))) {
		if (prog.config.verbose > 0) {
			fcPrintln("Callgraph was successfully written to file '" + filename + "'", prog.config.threadId);	
		}
	} else {
		fcPrintln("Cannot write callgraph to file '" + filename + "'", prog.config.threadId);
	}
}

// A tree, which juxtaposes a set of all symbols, which uses a given name to a given name.
symbolUses(prog : FiProgram) -> Tree<string, Set<string>> {
	// Uses - inversed dependencies
	fold(getTreeValues(prog.modules), makeTree(), \acc, module -> {
		acc1 = fold(module.functions, acc, \ac, fn ->
			foldSet(fifreevars(fn.lambda), ac, \a, free ->
				setTree(a, free, insertSet(lookupTreeDef(a, free, makeSet()), fn.name))
			)
		);
		fold(module.natives, acc1, \ac, nat ->
			switch (nat.fallbackLambda) {
				FiLambda(__, __, __, __): {
					foldSet(fifreevars(nat.fallbackLambda), ac, \a, free ->
						setTree(a, free, insertSet(lookupTreeDef(a, free, makeSet()), nat.name))
					);
				}
				FiVoid(__): ac;
				default: {
					fcPrintln("fallbackLambda in FiNativeDec must be FiLambda or FiVoid, but is: " + prettyFiExp(dummyPretty, nat.fallbackLambda), prog.config.threadId);
					ac;
				}
			}
		);
	});
}

symbolDependencies(prog : FiProgram) -> Tree<string, Set<string>> {
	fold(getTreeValues(prog.modules), makeTree(), \acc, module -> {
		acc1 = fold(module.functions, acc, \ac, fn ->
			setTree(ac, fn.name, fifreevars(fn.lambda))
		);
		fold(module.natives, acc1, \ac, nat ->
			switch (nat.fallbackLambda) {
				FiLambda(__, __, __, __): {
					setTree(ac, nat.name, fifreevars(nat.fallbackLambda));
				}
				FiVoid(__): ac;
				default: {
					fcPrintln("fallbackLambda in FiNativeDec must be FiLambda or FiVoid, but is: " + prettyFiExp(dummyPretty, nat.fallbackLambda), prog.config.threadId);
					ac;
				}
			}
		);
	});
}

pathInCallGraph(func_from : string, func_to : string, max_num : int, prog : FiProgram) -> void {
	// Uses - inversed dependencies
	uses = symbolUses(prog);
	paths = findAllPathsToMain(mapTree(uses, set2array), [[func_from]], [], func_to, max_num);
	fcPrintln(
		"Call paths from '" + func_from + "' to '" + func_to + "':\n" + 
		concatStrings(map(paths, \path -> "\t" + strGlue(path, " -> ") + "\n")) +
		(if (length(paths) > max_num) "\n  ... \n" else ""), 
		prog.config.threadId
	);
}

findAllPathsToMain(uses : Tree<string, [string]>, paths : [[string]], acc : [[string]], func_to : string, max_num : int) -> [[string]] {
	frontier = filter(paths, \path -> length(path) == sizeSet(buildSet(path)));
	if (frontier == [] || length(acc) > max_num) acc else {
		new_paths = mapConcat(frontier, \path -> 
			map(lookupTreeDef(uses, lastElement(path, ""), []), \last -> concat(path, [last]))
		);
		new_acc = concat(acc, filter(new_paths, \path -> lastElement(path, "") == func_to));
		findAllPathsToMain(uses, new_paths, new_acc, func_to, max_num);
	}
}

/*
lspSymbolKindName2id = pairs2tree([
	Pair("File", 1),       Pair("Module", 2),      Pair("Namespace", 3), Pair("Package", 4),     Pair("Class", 5),
	Pair("Method", 6),     Pair("Property", 7),    Pair("Field", 8),     Pair("Constructor", 9), Pair("Enum", 10),
	Pair("Interface", 11), Pair("Function", 12),   Pair("Variable", 13), Pair("Constant", 14),   Pair("String", 15),
	Pair("Number", 16),    Pair("Boolean", 17),    Pair("Array", 18),    Pair("Object", 19),     Pair("Key", 20),
	Pair("Null", 21),      Pair("EnumMember", 22), Pair("Struct", 23),   Pair("Event", 24),      Pair("Operator", 25),
	Pair("TypeParameter", 26),
]);
*/

type2LspSymbolkind(type : FiType, names : FiGlobalNames) -> int {
	switch (type) {
		FiTypeArray(__): lookupTreeDef(lspSymbolKindName2id, "Array", 0);
		FiTypeFunction(args, retType): lookupTreeDef(lspSymbolKindName2id, "Function", 0);
		FiTypeInt(): lookupTreeDef(lspSymbolKindName2id, "Number", 0);
		FiTypeBool(): lookupTreeDef(lspSymbolKindName2id, "Boolean", 0);
		FiTypeDouble(): lookupTreeDef(lspSymbolKindName2id, "Number", 0);
		FiTypeString(): lookupTreeDef(lspSymbolKindName2id, "String", 0);
		FiTypeFlow(): lookupTreeDef(lspSymbolKindName2id, "Object", 0);
		FiTypeVoid(): lookupTreeDef(lspSymbolKindName2id, "Object", 0);
		FiTypeNative(): lookupTreeDef(lspSymbolKindName2id, "Object", 0);
		FiTypeName(name, typars): {
			if (containsKeyTree(names.structs, name)) {
				lookupTreeDef(lspSymbolKindName2id, "Struct", 0);
			} else {
				lookupTreeDef(lspSymbolKindName2id, "Enum", 0);
			}
		}
		FiTypeRef(t): type2LspSymbolkind(t, names);
		FiTypeParameter(n): lookupTreeDef(lspSymbolKindName2id, "TypeParameter", 0);
	}
}

nature2LspSymbolkind(nature : FcSymbolNature, names : FiGlobalNames) -> int {
	switch (nature.kind) {
		FcVarSymbol(type): type2LspSymbolkind(type, names);
		FcTypeSymbol(type): type2LspSymbolkind(type, names);
		FcFieldSymbol(type_name, field_name, field_type): type2LspSymbolkind(field_type, names);
	}
}

pos2LspPosition(pos : int, resolver : LineResolver) -> LspPosition {
	linecol = findLine(resolver, pos);
	LspPosition(linecol.lineno - 1, linecol.column - 1);
}

info2LspRange(range : FcInfo2, resolver : LineResolver) -> LspRange {
	LspRange(
		pos2LspPosition(range.start, resolver),
		pos2LspPosition(range.end, resolver),
	);
}

lspCallHierarchyMethods(prog : FiProgram, env : FcTypeEnvGlobal) -> void {
	config = prog.config;
	if (isConfigParameterSet(config.config, "calls-info")) {
		line = s2i(getConfigParameterDef(config.config, "exp-line", "-1"));
		col = s2i(getConfigParameterDef(config.config, "exp-column", "-1"));
		lspPrepareCallHierarchy(prog, line, col, env);
	}
	if (isConfigParameterSet(config.config, "calls-incoming")) {
		json = getConfigParameter(config.config, "calls-incoming");
		lspCallHierarchyIncoming(prog, json, env);
	}
	if (isConfigParameterSet(config.config, "calls-outgoing")) {
		json = getConfigParameter(config.config, "calls-outgoing");
		lspCallHierarchyOutgoing(prog, json, env);
	}
}

lspPrepareCallHierarchy(prog : FiProgram, line : int, col : int, env : FcTypeEnvGlobal) -> void {
	config = prog.config;
	file = config.flowfile;

	// findFlowPath(flowfile : string, flowsuffix : bool, imports : [string], workingDir : string) -> string;

	path = findFlowPath(config.flowfile, true, config.includes, lookupTreeDef(config.config, "working-dir", ""));


	src = fcFileSource(env, path);
	resolver = makeLineResolver(src);
	name = getNameByLineCol(line, col, src);

	// fastSymbolNature(config : CompilerConfig, globEnv : FcTypeEnvGlobal, name : string, line : int, col : int) -> Maybe<FcSymbolNature>;

	/*
	LspCallHierarchyItem : (
		name : string,
		kind : int,
		tags : [int], // DiagnosticTag: Unnecessary = 1, Deprecated = 2
		detail : string,
		uri : URI,
		range: LspRange,
		selectionRange: LspRange,
		data : Json
	);
	*/
	// string2LspSymbolKind(s : string) -> int

	// getFcInfo2ByLineCol(line : int, col : int, src : string) -> Maybe<FcInfo2>
	maybeApply(getFcInfo2ByLineCol(line, col, src), \fc_range ->
		maybeApply(fastSymbolNature(config, env, name, line, col), \nature -> {
			kind = nature2LspSymbolkind(nature, prog.names);
			range = info2LspRange(fc_range, resolver);
			item = LspCallHierarchyItem(
				name, kind, 
				[], // no tags yet
				"", // no details yet
				URI("file", URIAuthority("", "", ""), path, "", ""),
				range, range, JsonNull()
			);
			fcPrintln(json2string(lspCallHierarchyItem2Json(item)), config.threadId);
		})
	);
}

/*
LspCallHierarchyItem : (
	name : string,
	kind : int,
	tags : [int], // DiagnosticTag: Unnecessary = 1, Deprecated = 2
	detail : string,
	uri : URI,
	range: LspRange,
	selectionRange: LspRange,
	data : Json
);
*/

// LspCallHierarchyIncomingCall : (from: LspCallHierarchyItem, fromRanges: [LspRange]);

//symbolIcomingCalls(prog : FiProgram, name : string, env : FcTypeEnvGlobal) -> [LspCallHierarchyIncomingCall]

lspCallHierarchyIncoming(prog : FiProgram, json : string, env : FcTypeEnvGlobal) -> void {
	config = prog.config;
	file = config.flowfile;
	maybeApply(json2LspCallHierarchyItem(parseJsonSafe(json)), \item -> {
		//all_deps = symbolDependenciesOccurs(prog, env);
		//name_deps = lookupTreeDef(all_deps, item.name, makeTree());
		calls = map(symbolIcomingCalls(prog, item.name, env), lspCallHierarchyIncomingCall2Json);
		fcPrintln(json2string(JsonArray(calls)), config.threadId);
	});
}

// LspCallHierarchyOutgoingCall : (from: LspCallHierarchyItem, fromRanges: [LspRange]);

lspCallHierarchyOutgoing(prog : FiProgram, json : string, env : FcTypeEnvGlobal) -> void {
	config = prog.config;
	file = config.flowfile;
	maybeApply(json2LspCallHierarchyItem(parseJsonSafe(json)), \item -> {
		/*all_deps = symbolDependenciesOccurs(prog, env);
		name_deps = lookupTreeDef(all_deps, item.name, makeTree());
		calls = map(getTreeValues(name_deps), \occurs -> {
			fromRanges = map(set2array(occurs), \occur -> fiSymbolOccur2LspLocation(occur, env).range);
			incoming = LspCallHierarchyIncomingCall(item, fromRanges);
			lspCallHierarchyIncomingCall2Json(incoming);
		});
		fcPrintln(json2string(JsonArray(calls)), config.threadId);*/
	});
}

FiSymbolOccurrence(
	path : string, // path to the file
	info : FcInfo2 // start/end positions
);

fiSymbolOccur2LspLocation(occur : FiSymbolOccurrence, env : FcTypeEnvGlobal) -> LspLocation {
	src = fcFileSource(env, occur.path);
	resolver = makeLineResolver(src);
	LspLocation(
		URI("file", URIAuthority("", "", ""), occur.path, "", ""),
		info2LspRange(occur.info, resolver)
	);
}

fifreevarsOccurs(e : FiExp, path : string, src : string, threadId : int) -> Tree<string, Set<FiSymbolOccurrence>> {
	fifreevarsOccursBoundFree(e, path, src, threadId, makeSet(), makeTree());
}

// getFcInfo2ByPos(pos : int, src : string) -> Maybe<FcInfo2>

fifreevarsOccursBoundFree(expr : FiExp, path : string, src : string, threadId : int, bound : Set<string>, free : Tree<string, Set<FiSymbolOccurrence>>) -> Tree<string, Set<FiSymbolOccurrence>> {
	fold_freevars = \es, b, f -> 
		fold(es, f, \acc, e -> fifreevarsOccursBoundFree(e, path, src, threadId, b, acc));
	switch (expr) {
		FiLambda(args, e, __, __):    fifreevarsOccursBoundFree(e, path, src, threadId, fold(args, bound, \acc, arg -> insertSet(acc, arg.name)), free);
		FiCall(f, es, __, __):        fold_freevars(es, bound, fifreevarsOccursBoundFree(f, path, src, threadId, bound, free));
		FiVar(x, __, beg):             if (containsSet(bound, x)) free else {
			switch (getFcInfo2ByPos(beg, src)) {
				Some(info2): {
					setTree(free, x, insertSet(lookupTreeDef(free, x, makeSet()), 
						FiSymbolOccurrence(path, info2)
					));
				}
				None(): {
					fcPrintln("Couldn't find a symbol boundaries - an error", threadId);
					free;
				}
			}
		}
		FiLet(x, __, e1, e2, __, __): fifreevarsOccursBoundFree(e2, path, src, threadId, insertSet(bound, x), fifreevarsOccursBoundFree(e1, path, src, threadId, bound, free));
		FiIf(e1, e2, e3, __, __):     fold_freevars([e1, e2, e3], bound, free);
		FiSwitch(e, __, cs, __, __):  fold(cs, fifreevarsOccursBoundFree(e, path, src, threadId, bound, free), \acc, c -> fifreevarsOccursBoundFree(c.body, path, src, threadId, bound, acc));
		FiCast(e, __, __, __, __):    fifreevarsOccursBoundFree(e, path, src, threadId, bound, free);
		FiSeq(es, __, __):            fold_freevars(es, bound, free);
		FiCallPrim(__, es, __, __):   fold_freevars(es, bound, free);
		FiString(__, __):             free; // here I would want to match simply on union FcConst
		FiBool(__, __):               free;
		FiDouble(__, __):             free;
		FiVoid(__):                   free;
		FiInt(__, __):                free;
        FiRequire(__, e, __, __):     fifreevarsOccursBoundFree(e, path, src, threadId, bound, free);
        FiUnsafe(__, fb, __, __):     fifreevarsOccursBoundFree(fb, path, src, threadId, bound, free);
	}
}

symbolFuncIcomingCalls(
	path : string, name : string, src : string, threadId : int, 
	fn_name : string, fn_pos : int, fn_body : FiExp, env : FcTypeEnvGlobal
) -> [LspCallHierarchyIncomingCall] {
	freeOccurs = fifreevarsOccurs(fn_body, path, src, threadId);
	fromRanges = map(set2array(lookupTreeDef(freeOccurs, name, makeSet())), \occur -> 
		fiSymbolOccur2LspLocation(occur, env).range
	);
	if (fromRanges == []) [] else {
		switch (getFcInfo2ByPos(fn_pos, src)) {
			Some(info2): {
				resolver = makeLineResolver(src);
				range = info2LspRange(info2, resolver);
				item = LspCallHierarchyItem(
					fn_name, lookupTreeDef(lspSymbolKindName2id, "Function", 0), 
					[], // no tags yet
					"", // no details yet
					URI("file", URIAuthority("", "", ""), path, "", ""),
					range, range, JsonNull()
				);
				[LspCallHierarchyIncomingCall(item, fromRanges)];
			}
			None(): {
				[];
			}
		}
	}
}

symbolIcomingCalls(prog : FiProgram, name : string, env : FcTypeEnvGlobal) -> [LspCallHierarchyIncomingCall] {
	fold(getTreeValues(prog.modules), [], \acc, module -> {
		path = module.fileinfo.fullpath;
		src = fcFileSource(env, path);
		acc1 = fold(module.functions, acc, \ac, fn ->
			concat(ac, 
				symbolFuncIcomingCalls(
					path, name, src, prog.config.threadId, 
					fn.name, fn.defiStart, fn.lambda, env
				)
			)
		);
		fold(module.natives, acc1, \ac, nat ->
			switch (nat.fallbackLambda) {
				FiLambda(__, __, __, __): {
					concat(ac, 
						symbolFuncIcomingCalls(
							path, name, src, prog.config.threadId, 
							nat.name, nat.defiStart, nat.fallbackLambda, env
						)
					);
				}
				FiVoid(__): ac;
				default: {
					fcPrintln("fallbackLambda in FiNativeDec must be FiLambda or FiVoid, but is: " + prettyFiExp(dummyPretty, nat.fallbackLambda), prog.config.threadId);
					ac;
				}
			}
		);
	});
}
