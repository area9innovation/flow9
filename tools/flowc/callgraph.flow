import tools/flowc/manipulation/deadcode;

export {
	// Print a callgraph in format:
	//
	// *** file: algorithms.flow
	// arrayPushSortedWithLimit: length mergeArrays subrange
	// binarySearch: binarySearchInternal genericCompare length
	// binarySearch2: binarySearchInternal length
	// binarySearchEx: binarySearchInternal genericCompare
	// ....
	printCallGraph(filename : string, prog : FiProgram) -> void;

	// Prints all paths from the one function to another.
	// Default value for 'func_to' is "main". 
	// max_num is a limit on the number of reported paths (there may be too much paths).
	pathInCallGraph(func_from : string, func_to : string, max_num : int, prog : FiProgram) -> void;
}

printCallGraph(filename : string, prog : FiProgram) -> void {
	lines = concatA(map(getTreeValues(prog.modules), \module -> {
		config = prog.config.config;
		useFullPath = isConfigParameterTrue(config, "callgraph-fullpath");

		heading = "*** file: " + (if (useFullPath) module.fileinfo.fullpath else {module.fileinfo.flowfile + ".flow"});
		functions = map(module.functions, \f : FiFunctionDec ->
			Pair(f.name, fifreevars(f.lambda))
		);
		natives = map(module.natives, \f : FiNativeDec ->
			Pair(f.name,
				switch (f.fallbackLambda) {
					FiLambda(__, __, __, __): fifreevars(f.fallbackLambda);
					FiVoid(__): makeSet();
					default: {
						fcPrintln("fallbackLambda in FiNativeDec must be FiLambda or FiVoid, but is: " + prettyFiExp(dummyPretty, f.fallbackLambda), prog.config.threadId);
						makeSet()
					}
				}
			)
		);
		lines2 = map(concat(natives, functions), \p : Pair<string, Set<string>> ->
			p.first + ": " + strGlue(set2array(p.second), " ")
		);
		concat([heading], lines2)
	}));
	if (setFileContent(filename, strGlue(map(lines, \l -> l + "\n"), ""))) {
		if (prog.config.verbose > 0) {
			fcPrintln("Callgraph was successfully written to file '" + filename + "'", prog.config.threadId);	
		}
	} else {
		fcPrintln("Cannot write callgraph to file '" + filename + "'", prog.config.threadId);
	}
}

pathInCallGraph(func_from : string, func_to : string, max_num : int, prog : FiProgram) -> void {
	// Uses - inversed dependencies
	uses = fold(getTreeValues(prog.modules), makeTree(), \acc, module -> {
		acc1 = fold(module.functions, acc, \ac, fn ->
			foldSet(fifreevars(fn.lambda), ac, \a, free ->
				setTree(a, free, insertSet(lookupTreeDef(a, free, makeSet()), fn.name))
			)
		);
		fold(module.natives, acc1, \ac, nat ->
			switch (nat.fallbackLambda) {
				FiLambda(__, __, __, __): {
					foldSet(fifreevars(nat.fallbackLambda), ac, \a, free ->
						setTree(a, free, insertSet(lookupTreeDef(a, free, makeSet()), nat.name))
					);
				}
				FiVoid(__): ac;
				default: {
					fcPrintln("fallbackLambda in FiNativeDec must be FiLambda or FiVoid, but is: " + prettyFiExp(dummyPretty, nat.fallbackLambda), prog.config.threadId);
					ac;
				}
			}
		);
	});
	paths = findAllPathsToMain(mapTree(uses, set2array), [[func_from]], [], func_to, max_num);
	fcPrintln(
		"Call paths from '" + func_from + "' to '" + func_to + "':\n" + 
		concatStrings(map(paths, \path -> "\t" + strGlue(path, " -> ") + "\n")) +
		(if (length(paths) > max_num) "\n  ... \n" else ""), 
		prog.config.threadId
	);
}

findAllPathsToMain(uses : Tree<string, [string]>, paths : [[string]], acc : [[string]], func_to : string, max_num : int) -> [[string]] {
	frontier = filter(paths, \path -> length(path) == sizeSet(buildSet(path)));
	if (frontier == [] || length(acc) > max_num) acc else {
		new_paths = mapConcat(frontier, \path -> 
			map(lookupTreeDef(uses, lastElement(path, ""), []), \last -> concat(path, [last]))
		);
		new_acc = concat(acc, filter(new_paths, \path -> lastElement(path, "") == func_to));
		findAllPathsToMain(uses, new_paths, new_acc, func_to, max_num);
	}
}
