import string;
import math/md5;
import ds/tree;
import ds/dlist;

export {
	// Do a replacement "\n" to "\\n" and so on
	fcEscapeString(s : string) -> string;

	// Do a backwards replacement "\\n" to "\n" and so on
	fcUnescapeString(str : string) -> string;

	setFileContentIfChanged(filename : string, data : string) -> bool;
}

fcEscapeString(s : string) -> string {
	// We use Cons() concatenation instead of string concatenation,
	// because structures creation and list2string() call is
	// much cheaper than usual string concatenation.
	f = stringFold(s, makeList(), \acc, code ->
		Cons(if (code < 0x20) {
				if (code == 0x09) "\\t"
				else if (code == 0x0a) "\\n"
				else if (code == 0x0d) "\\r"
				else "\\u"+lpad(formatHex(code), "0", 4);
			} else if (code >= 0x80) {
				"\\u"+lpad(formatHex(code), "0", 4)
			} else {
				if (code == 0x22) "\\\""
				else if (code == 0x5c) "\\\\"
				else fromCharCode(code);
			}, acc)
	);
	list2string(f);
}

// Do a replacement "\\n" to "\n" and so on
fcUnescapeString(s : string) -> string {
	//strReplaces(str, ["\\n", "\n", "\\r", "\r", "\\t", "\t"]);
	f = stringFoldi(s, makeList(), \i, acc, code ->
		Cons(
			// it's a "\\x" situation
			if (i > 1 && getCharCodeAt(s, i - 1) == 0x5c && getCharCodeAt(s, i - 2) == 0x5c) {
				if (code == 0x6e) "\n" else
				if (code == 0x74) "\t" else
				if (code == 0x72) "\r" else 
				// TODO: fix for UTF encoding proper decoding
				//if (code == 0x75) "\\u" else 
				fromCharCode(code);
			} else {
				fromCharCode(code);
			}
		, acc)
	);
	list2string(f);
}

setFileContentIfChanged(filename : string, data : string) {
	v = getFileContent(filename);
	if (v == "") {
		setFileContent(filename, data);
	} else {
		mv = md5(v);
		md = md5(data);
		if (mv != md) {
			setFileContent(filename, data);
		} else {
			true
		}
	}
}
