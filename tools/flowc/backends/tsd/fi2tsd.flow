import tools/flowc/backends/common;
import tools/flowc/incremental/fiprogram;
import tools/flowc/incremental/fimodule;
import text/blueprint;
import ds/tree;

export {
	fi2tsd(f : FiProgram, cfg : FiTsdConfig, callback : () -> void) -> void;
}

fi2tsd(p : FiProgram, cfg : FiTsdConfig, callback : () -> void) -> void {
	folder = if (cfg.outputfolder == "1") "types/" else cfg.outputfolder;

	if (isEmptySet(cfg.jslibrary) || cfg.jslibraryObject == "") {
		// Generate comprehensive TypeScript definitions for each module
		traverseInOrder(p.modules, \path, module -> {
			modul = fimodule2tsd(p, cfg, module);

			file = pathCombine(folder, path) + ".d.ts";
			ensureDirectoryExists(dirName(file));
			setFileContent(file, modul);
			
			if (cfg.verbose > 0) {
				fcPrintln("Generated TypeScript definitions: " + file, cfg.threadId);
			}
		});
		
		// Generate a main index file that re-exports everything
		indexContent = generateIndexTsd(p, cfg);
		indexFile = pathCombine(folder, "index.d.ts");
		setFileContent(indexFile, indexContent);
		
		if (cfg.verbose > 0) {
			fcPrintln("Generated TypeScript index: " + indexFile, cfg.threadId);
		}
	} else {
		// Generate namespace wrapper definitions for jslibrary exports
		// First, collect all types used by the exported functions
		exportedTypes = fold(set2array(cfg.jslibrary), [], \acc, name -> {
			mdec = lookupTree(p.names.toplevel, name);
			switch (mdec) {
				None(): acc;
				Some(dec): concat(acc, extractReferencedTypes(dec));
			}
		});
		
		// Generate type definitions for referenced types
		typeDefinitions = generateTypeDefinitionsForNames(p, uniq(exportedTypes));
		
		// Generate the namespace object definition
		modul = "// TypeScript definitions for " + cfg.jslibraryObject + "\n"
			+ "// Auto-generated by Flow compiler\n\n"
			+ typeDefinitions
			+ (if (typeDefinitions != "") "\n" else "")
			+ "export declare const Flow: {\n"
			+ superglue(set2array(cfg.jslibrary), \name -> {
				"  " + finame2tsNamespaceProperty(p, name);
			}, "\n")
			+ "\n};";

		file = pathCombine(folder, cfg.jslibraryObject) + ".d.ts";
		ensureDirectoryExists(dirName(file));
		setFileContent(file, modul);
		
		if (cfg.verbose > 0) {
			fcPrintln("Generated TypeScript namespace definitions: " + file, cfg.threadId);
		}
	};

	callback();
}


generateIndexTsd(p : FiProgram, cfg : FiTsdConfig) -> string {
	"// TypeScript definitions index file for Flow program\n"
	+ "// Auto-generated by Flow compiler\n\n"
	+ superglue(getTreeKeys(p.modules), \path -> {
		"export * from './" + path + "';";
	}, "\n")
	+ "\n";
}

fimodule2tsd(p : FiProgram, cfg : FiTsdConfig, m : FiModule) -> string {
	imports = generateModuleImports(p, m);
	types = generateModuleTypes(p, m);
	exports = generateModuleExports(p, m);
	
	"// TypeScript definitions for " + m.fileinfo.flowfile + "\n"
	+ "// Auto-generated by Flow compiler\n\n"
	+ imports
	+ (if (imports != "" && (types != "" || exports != "")) "\n" else "")
	+ types
	+ (if (types != "" && exports != "") "\n" else "")
	+ exports;
}

generateModuleImports(p : FiProgram, m : FiModule) -> string {
	importTypes = fold(m.imports, [], \acc, im -> {
		// Check what types from this import are actually used in our exports
		usedTypes = fold(m.exports, [], \acc2, exportName -> {
			mdec = lookupTree(p.names.toplevel, exportName);
			switch (mdec) {
				None(): {
					// Check if it's a struct or union
					if (containsKeyTree(p.names.structs, exportName) || containsKeyTree(p.names.unions, exportName)) {
						acc2;
					} else {
						acc2;
					}
				}
				Some(dec): {
					// Extract referenced types from this declaration
					referencedTypes = extractReferencedTypes(dec);
					concat(acc2, filter(referencedTypes, \typeName -> {
						// Check if this type comes from the import module
						lookupTree(p.names.struct2module, typeName) == Some(im.flowfile) ||
						lookupTree(p.names.union2module, typeName) == Some(im.flowfile)
					}));
				}
			}
		});
		
		if (usedTypes != []) {
			arrayPush(acc, Pair(im.flowfile, uniq(usedTypes)));
		} else {
			acc;
		}
	});
	
	superglue(importTypes, \pair -> {
		"import { " + strGlue(pair.second, ", ") + " } from './" + pair.first + "';";
	}, "\n");
}

generateModuleTypes(p : FiProgram, m : FiModule) -> string {
	// Generate type definitions for structs and unions defined in this module
	structDefs = fold(m.structs, [], \acc, struct -> {
		if (contains(m.exports, struct.name)) {
			arrayPush(acc, generateStructTsd(struct));
		} else {
			acc;
		}
	});
	
	unionDefs = fold(m.unions, [], \acc, union -> {
		if (contains(m.exports, union.name)) {
			arrayPush(acc, generateUnionTsd(p, union));
		} else {
			acc;
		}
	});
	
	strGlue(concat(structDefs, unionDefs), "\n\n");
}

generateModuleExports(p : FiProgram, m : FiModule) -> string {
	functionExports = filtermap(m.exports, \ex -> {
		mdec = lookupTree(p.names.toplevel, ex);
		switch (mdec) {
			None(): None();
			Some(dec): Some(finame2ts(p, ex));
		}
	});
	
	strGlue(functionExports, "\n");
}

generateStructTsd(struct : FiTypeStruct) -> string {
	typeParams = if (struct.typars != []) {
		"<" + strGlue(map(struct.typars, \tp -> {
			switch (tp) {
				FiTypeParameter(name): {
					// Map Flow's ? and ?? type parameters to proper TypeScript generic names
					if (name == "?") "T"
					else if (name == "??") "U" 
					else if (name == "???") "V"
					else if (name == "????") "W"
					else tsReserved(name);
				}
				default: "T";
			}
		}), ", ") + ">"
	} else {
		""
	};
	
	"export interface " + tsReserved(struct.name) + typeParams + " {\n"
	+ superglue(struct.args, \arg -> {
		"  " + (if (arg.ismutable) "/* mutable */ " else "") + tsReserved(arg.name) + ": " + fitype2ts(arg.type) + ";"
	}, "\n")
	+ "\n}";
}

generateUnionTsd(p : FiProgram, union : FiTypeUnion) -> string {
	typeParams = if (union.typeparameters != []) {
		"<" + strGlue(map(union.typeparameters, \tp -> {
			switch (tp) {
				FiTypeParameter(name): {
					// Map Flow's ? and ?? type parameters to proper TypeScript generic names
					if (name == "?") "T"
					else if (name == "??") "U" 
					else if (name == "???") "V"
					else if (name == "????") "W"
					else tsReserved(name);
				}
				default: "T";
			}
		}), ", ") + ">"
	} else {
		""
	};
	
	"export type " + tsReserved(union.name) + typeParams + " = "
	+ superglue(union.typenames, fitype2ts, " | ")
	+ ";";
}

extractReferencedTypes(dec : FiDeclaration) -> [string] {
	switch (dec) {
		FiFunctionDec(name, lambda, type, declStart, defiStart): {
			extractTypesFromFiType(type);
		}
		FiGlobalVar(name, value, type, declStart, defiStart): {
			extractTypesFromFiType(type);
		}
		FiNativeDec(name, io, type, nativeName, fallbackLambda, declStart, defiStart): {
			extractTypesFromFiType(type);
		}
	}
}

extractTypesFromFiType(ty : FiType) -> [string] {
	switch (ty) {
		FiTypeVoid(): [];
		FiTypeArray(t): extractTypesFromFiType(t);
		FiTypeFunction(args, returnType): {
			concat(
				fold(args, [], \acc, arg -> concat(acc, extractTypesFromFiType(arg.type))),
				extractTypesFromFiType(returnType)
			);
		}
		FiTypeRef(t): extractTypesFromFiType(t);
		FiTypeParameter(n): [];
		FiTypeBool(): [];
		FiTypeInt(): [];
		FiTypeDouble(): [];
		FiTypeString(): [];
		FiTypeFlow(): [];
		FiTypeNative(): [];
		FiTypeName(name, typeparameters): {
			concat([name], fold(typeparameters, [], \acc, tp -> concat(acc, extractTypesFromFiType(tp))));
		}
	}
}

generateTypeDefinitionsForNames(p : FiProgram, typeNames : [string]) -> string {
	// Generate TypeScript definitions for the given type names
	typeDefinitions = filtermap(typeNames, \typeName -> {
		// Check if it's a struct
		structDef = lookupTree(p.names.structs, typeName);
		switch (structDef) {
			Some(struct): Some(generateStructTsd(struct));
			None(): {
				// Check if it's a union
				unionDef = lookupTree(p.names.unions, typeName);
				switch (unionDef) {
					Some(union): Some(generateUnionTsd(p, union));
					None(): None();
				}
			}
		}
	});
	
	strGlue(typeDefinitions, "\n\n");
}

finame2tsNamespaceProperty(p : FiProgram, e : string) -> string {
	mdec = lookupTree(p.names.toplevel, e);
	switch (mdec) {
		None(): {
			"// Unknown export: " + e;
		}
		Some(dec): {
			switch (dec) {
				FiFunctionDec(name, lambda, type, declStart, defiStart): {
					tsReserved(name) + ": " + 
					"(" + superglue(type.args, \arg -> {
						tsReserved(if (arg.name != "") arg.name else "arg") + ": " + fitype2ts(arg.type)
					}, ", ") + ") => " + fitype2ts(type.returnType) + ";";
				}
				FiGlobalVar(name, value, type, declStart, defiStart): {
					tsReserved(name) + ": " + fitype2ts(type) + ";";
				}
				FiNativeDec(name, io, type, nativeName, fallbackLambda, declStart, defiStart): {
					switch (type) {
						FiTypeFunction(args, returnType): {
							tsReserved(name) + ": " + 
							"(" + superglue(args, \arg -> {
								tsReserved(if (arg.name != "") arg.name else "arg") + ": " + fitype2ts(arg.type)
							}, ", ") + ") => " + fitype2ts(returnType) + ";";
						}
						default: {
							tsReserved(name) + ": " + fitype2ts(type) + ";";
						}
					}
				}
			}
		}
	}	
}

finame2ts(p : FiProgram, e : string) -> string {
	mdec = lookupTree(p.names.toplevel, e);
	switch (mdec) {
		None(): {
			"// Unknown export: " + e;
		}
		Some(dec): {
			switch (dec) {
				FiFunctionDec(name, lambda, type, declStart, defiStart): {
					"export function " + tsReserved(name) + 
					"(" + superglue(type.args, \arg -> {
						tsReserved(if (arg.name != "") arg.name else "arg") + ": " + fitype2ts(arg.type)
					}, ", ") + "): " + fitype2ts(type.returnType) + ";";
				}
				FiGlobalVar(name, value, type, declStart, defiStart): {
					"export const " + tsReserved(name) + ": " + fitype2ts(type) + ";";
				}
				FiNativeDec(name, io, type, nativeName, fallbackLambda, declStart, defiStart): {
					switch (type) {
						FiTypeFunction(args, returnType): {
							"export function " + tsReserved(name) + 
							"(" + superglue(args, \arg -> {
								tsReserved(if (arg.name != "") arg.name else "arg") + ": " + fitype2ts(arg.type)
							}, ", ") + "): " + fitype2ts(returnType) + ";";
						}
						default: {
							"export const " + tsReserved(name) + ": " + fitype2ts(type) + ";";
						}
					}
				}
			}
		}
	}	
}

tsReserved(name : string) -> string {
	// https://github.com/Microsoft/TypeScript/issues/2536
	if (contains(["break", "case", "catch", "class", "const", "continue", "debugger", "default", "delete", "do", "else", "enum", "export", 
		"extends", "false", "finally", "for", "function", "if", "import", "in", "instanceof", "new", "null", "return", "super",
		"switch", "this", "throw", "true", "try", "typeof", "var", "void", "while", "with",
		
		"as", "implements", "interface", "let", "package", "private", "protected", "public", "static", "yield",

		"any", "boolean", "constructor", "declare", "get", "module", "require", "number", "set", "string", "symbol", "type", "from", "of",
		], name)) {
		name + "_"
	} else name;
}

fitype2ts(ty : FiType) -> string {
	switch (ty) {
		FiTypeVoid(): "void";
		FiTypeArray(t): "Array<" + fitype2ts(t) + ">";
		FiTypeFunction(args, returnType): {
			"(" + supergluei(args, \i, arg -> {
				(if (arg.name != "") tsReserved(arg.name) + ": " else "arg" + i2s(i) + ": ") + fitype2ts(arg.type)
			}, ", ") + ") => " + fitype2ts(returnType);
		}
		FiTypeRef(t): "{ value: " + fitype2ts(t) + " }"; // Reference type
		FiTypeParameter(n): {
			// Map Flow's ? and ?? type parameters to proper TypeScript generic names
			if (n == "?") "T"
			else if (n == "??") "U" 
			else if (n == "???") "V"
			else if (n == "????") "W"
			else if (n == "?????") "X"
			else if (n == "??????") "Y"
			else if (n == "???????") "Z"
			else tsReserved(n);
		}
		FiTypeBool(): "boolean";
		FiTypeInt(): "number"; // TypeScript doesn't distinguish int from double
		FiTypeDouble(): "number";
		FiTypeString(): "string";
		FiTypeFlow(): "any"; // Flow's universal type
		FiTypeNative(): "any"; // Platform-specific types
		FiTypeName(name, typeparameters): {
			// Handle built-in Flow types
			if (name == "Maybe") {
				if (length(typeparameters) == 1) {
					fitype2ts(typeparameters[0]) + " | null";
				} else {
					"any | null";
				}
			} else if (name == "List") {
				if (length(typeparameters) == 1) {
					"Array<" + fitype2ts(typeparameters[0]) + ">";
				} else {
					"Array<any>";
				}
			} else if (name == "Tree") {
				if (length(typeparameters) == 2) {
					"Map<" + fitype2ts(typeparameters[0]) + ", " + fitype2ts(typeparameters[1]) + ">";
				} else {
					"Map<any, any>";
				}
			} else if (name == "Set") {
				if (length(typeparameters) == 1) {
					"Set<" + fitype2ts(typeparameters[0]) + ">";
				} else {
					"Set<any>";
				}
			} else if (name == "Pair") {
				if (length(typeparameters) == 2) {
					"[" + fitype2ts(typeparameters[0]) + ", " + fitype2ts(typeparameters[1]) + "]";
				} else {
					"[any, any]";
				}
			} else if (name == "Triple") {
				if (length(typeparameters) == 3) {
					"[" + fitype2ts(typeparameters[0]) + ", " + fitype2ts(typeparameters[1]) + ", " + fitype2ts(typeparameters[2]) + "]";
				} else {
					"[any, any, any]";
				}
			} else if (name == "Quadruple") {
				if (length(typeparameters) == 4) {
					"[" + fitype2ts(typeparameters[0]) + ", " + fitype2ts(typeparameters[1]) + ", " + fitype2ts(typeparameters[2]) + ", " + fitype2ts(typeparameters[3]) + "]";
				} else {
					"[any, any, any, any]";
				}
			} else {
				// User-defined or other types
				tsReserved(name) + (if (typeparameters != []) {
					"<" + superglue(typeparameters, fitype2ts, ", ") + ">"
				} else {
					""
				});
			}
		}
	}
}
