import tools/flowc/backends/common;
import tools/flowc/incremental/fiprogram;
import tools/flowc/incremental/fimodule;
import text/blueprint;
import ds/tree;
import algorithms;

export {
	fi2tsd(f : FiProgram, cfg : FiTsdConfig, callback : () -> void) -> void;
}

fi2tsd(p : FiProgram, cfg : FiTsdConfig, callback : () -> void) -> void {
	// Check if we're in wrapper mode (tsd=filename) vs directory mode (tsd=1)
	isWrapperMode = cfg.outputfolder != "1" && !endsWith(cfg.outputfolder, "/");
	wrapperFile = cfg.outputfolder;
	folder = if (isWrapperMode) "" else cfg.outputfolder;

	if (isEmptySet(cfg.jslibrary)) {
		// Generate TypeScript definitions for each module
		traverseInOrder(p.modules, \path, module : FiModule -> {
			// In wrapper mode, all modules export directly (no Flow namespace)
			// In directory mode, use original logic
			isMainModule = if (isWrapperMode) {
				false; // Force all modules to export directly in wrapper mode
			} else if (isEmptySet(cfg.jslibrary)) {
				// When no jslibrary is specified, treat root-level modules with exports as main modules
				!strContains(path, "/") && length(module.exports) > 0;
			} else {
				// When jslibrary is specified, check if any exports are in the jslibrary set
				exists(module.exports, \exportName -> containsSet(cfg.jslibrary, exportName));
			};
			
			modul = if (isMainModule) {
				// Get all exported types for type definitions
				exportedTypes = fold(module.exports, [], \acc, name -> {
					mdec = lookupTree(p.names.toplevel, name);
					switch (mdec) {
						None(): acc;
						Some(dec): concat(acc, extractReferencedTypesForTsd(dec));
					}
				});
				
				// Add struct types that are directly exported
				structTypes = filter(module.exports, \name -> containsKeyTree(p.names.structs, name));
				allTypes = uniq(concat(exportedTypes, structTypes));
				
				// Generate type definitions for referenced types
				definedHere = filter(allTypes, \typeName -> {
					contains(module.exports, typeName)
				});
				typeDefinitions = generateTypeDefinitionsForNames(p, definedHere);
				
				// Generate imports for standard library types
				imports = generateJsLibraryImports(p, module, allTypes);
				
				// Generate the Flow object export pattern
				"// TypeScript definitions for " + path + "\n"
					+ "// Auto-generated by Flow compiler\n\n"
					+ imports
					+ (if (imports != "") "\n\n" else "")
					+ typeDefinitions
					+ (if (typeDefinitions != "") "\n\n" else "")
					+ "export declare const Flow: {\n"
					+ superglue(module.exports, \name -> {
						"  " + finame2tsNamespaceProperty(p, name);
					}, "\n")
					+ "\n};";
			} else {
				// Generate regular module TypeScript definitions (without Flow namespace)
				fimodule2tsd(p, cfg, module);
			};

			file = pathCombine(folder, path) + ".d.ts";
			if (fileNameOnly(file) != dirName(file)) {
				ensureDirectoryExists(dirName(file));
				{}
			}
			if (setFileContent(file, modul)) {
				fcPrintln("Wrote TypeScript definitions to " + file, cfg.threadId);
			} else {
				fcPrintln("Error writing TypeScript definitions to " + file, cfg.threadId);
			}
			
			if (cfg.verbose > 0) {
				if (isMainModule) {
					fcPrintln("Generated TypeScript Flow object definitions: " + file, cfg.threadId);
				} else {
					fcPrintln("Generated TypeScript definitions: " + file, cfg.threadId);
				}
			}
		});
		
		if (isWrapperMode) {
			// Generate wrapper file that imports everything and exports under Flow namespace
			wrapperContent = generateWrapperTsd(p, cfg);
			if (fileNameOnly(wrapperFile) != dirName(wrapperFile)) {
				ensureDirectoryExists(dirName(wrapperFile));
				{}
			}
			if (setFileContent(wrapperFile, wrapperContent)) {
				fcPrintln("Wrote Flow namespace wrapper to " + wrapperFile, cfg.threadId);
			} else {
				fcPrintln("Error writing Flow namespace wrapper to " + wrapperFile, cfg.threadId);
			}
		} else {
			// Generate a main index file that re-exports everything
			indexContent = generateIndexTsd(p, cfg);
			indexFile = pathCombine(folder, "index.d.ts");
			setFileContent(indexFile, indexContent);
			
			if (cfg.verbose > 0) {
				fcPrintln("Generated TypeScript index: " + indexFile, cfg.threadId);
			}
		}
	} else {

		// Generate namespace wrapper definitions for jslibrary exports
		// First, collect all types used by the exported functions
		exportedTypes = fold(set2array(cfg.jslibrary), [], \acc, name -> {
			mdec = lookupTree(p.names.toplevel, name);
			switch (mdec) {
				None(): acc;
				Some(dec): concat(acc, extractReferencedTypesForTsd(dec));
			}
		});
		
		// Automatically include struct constructors for referenced types
		structConstructors = fold(uniq(exportedTypes), [], \acc, typeName -> {
			structDef = lookupTree(p.names.structs, typeName);
			switch (structDef) {
				Some(struct): arrayPush(acc, typeName);
				None(): acc;
			}
		});
		
		// Combine exported functions and struct constructors
		allExports = concat(set2array(cfg.jslibrary), structConstructors);
		
		// Generate type definitions for referenced types
		typeDefinitions = generateTypeDefinitionsForNames(p, uniq(exportedTypes));
		
		// Generate the simple export pattern: top-level types + Flow object
		objectName = if (cfg.jslibraryObject != "") cfg.jslibraryObject else "flow_export";
		modul = "// TypeScript definitions for " + objectName + "\n"
			+ "// Auto-generated by Flow compiler\n\n"
			+ typeDefinitions
			+ (if (typeDefinitions != "") "\n\n" else "")
			+ "export declare const Flow: {\n"
			+ superglue(allExports, \name -> {
				"  " + finame2tsNamespaceProperty(p, name);
			}, "\n")
			+ "\n};";

		fileName = if (cfg.jslibraryObject != "") cfg.jslibraryObject else "flow_export";
		file = pathCombine(folder, fileName) + ".d.ts";

		if (fileNameOnly(file) != dirName(file)) {
			ensureDirectoryExists(dirName(file));
			{}
		}
		if (setFileContent(file, modul)) {
			fcPrintln("Wrote TypeScript definitions to " + file, cfg.threadId);
		} else {
			fcPrintln("Error writing TypeScript definitions to " + file, cfg.threadId);
		}
		
		if (cfg.verbose > 0) {
			fcPrintln("Generated TypeScript namespace definitions: " + file, cfg.threadId);
		}
	};

	callback();
}


generateIndexTsd(p : FiProgram, cfg : FiTsdConfig) -> string {
	"// TypeScript definitions index file for Flow program\n"
	+ "// Auto-generated by Flow compiler\n\n"
	+ superglue(getTreeKeys(p.modules), \path -> {
		"export * from './" + path + "';";
	}, "\n")
	+ "\n";
}

fimodule2tsd(p : FiProgram, cfg : FiTsdConfig, m : FiModule) -> string {
	imports = generateModuleImports(p, m);
	types = generateModuleTypes(p, m);
	exports = generateModuleExports(p, m);
	"// TypeScript definitions for " + m.fileinfo.flowfile + "\n"
	+ "// Auto-generated by Flow compiler\n\n"
	+ imports
	+ (if (imports != "" && (types != "" || exports != "")) "\n" else "")
	+ types
	+ (if (types != "" && exports != "") "\n" else "")
	+ exports;
}

generateWrapperTsd(p : FiProgram, cfg : FiTsdConfig) -> string {
	// Get the wrapper filename without extension
	wrapperBaseName = fileNameOnly(cfg.outputfolder);
	wrapperNameWithoutExt = if (endsWith(wrapperBaseName, ".d.ts")) {
		strLeft(wrapperBaseName, strlen(wrapperBaseName) - 5);
	} else {
		wrapperBaseName;
	};
	
	// Collect all exports from all modules
	allExports = fold(getTreeKeys(p.modules), [], \acc, path -> {
		module = lookupTree(p.modules, path);
		switch (module) {
			None(): acc;
			Some(m): concat(acc, map(m.exports, \name -> Pair(path, name)));
		}
	});
	
	// Collect all type names used across all modules
	allTypes = fold(allExports, [], \acc, pair -> {
		name = pair.second;
		mdec = lookupTree(p.names.toplevel, name);
		switch (mdec) {
			None(): acc;
			Some(dec): concat(acc, extractReferencedTypesForTsd(dec));
		}
	});
	
	// Add struct types that are directly exported
	structTypes = fold(allExports, [], \acc, pair -> {
		name = pair.second;
		if (containsKeyTree(p.names.structs, name)) {
			arrayPush(acc, name);
		} else {
			acc;
		}
	});
	
	uniqueTypes = uniq(concat(allTypes, structTypes));
	
	// Generate imports for each module
	moduleNames = uniq(map(allExports, \pair -> pair.first));
	imports = superglue(moduleNames, \moduleName -> {
		module = lookupTree(p.modules, moduleName);
		switch (module) {
			None(): "";
			Some(m): {
				if (length(m.exports) > 0) {
					"import { " + strGlue(map(m.exports, tsReserved), ", ") + " } from './" + moduleName + ".d.ts';"
				} else {
					"";
				}
			}
		}
	}, "\n");
	
	// Generate type imports using FiGlobalNames - find all structs and unions
	allStructNames = getTreeKeys(p.names.structs);
	allUnionNames = getTreeKeys(p.names.unions);
	allTypeNames = concat(allStructNames, allUnionNames);
	
	// Group types by module using the global names mapping
	typeImports = fold(allTypeNames, makeTree(), \acc, typeName -> {
		// Check struct2module first, then union2module
		moduleForType = switch (lookupTree(p.names.struct2module, typeName)) {
			Some(moduleName): Some(moduleName);
			None(): lookupTree(p.names.union2module, typeName);
		};
		
		switch (moduleForType) {
			None(): acc;
			Some(moduleName): {
				// Skip if this is the wrapper module itself
				if (moduleName == wrapperNameWithoutExt) {
					acc;
				} else {
					existing = getTreeArrayValue(acc, moduleName);
					setTree(acc, moduleName, arrayPush(existing, typeName));
				}
			}
		}
	});
	
	typeImportLines = foldTree(typeImports, [], \moduleName, types, acc -> {
		if (length(types) > 0) {
			line = "import type { " + strGlue(types, ", ") + " } from './" + moduleName + ".d.ts';";
			arrayPush(acc, line);
		} else {
			acc;
		}
	});
	
	allImports = concat([imports], typeImportLines);
	importsSection = strGlue(filter(allImports, \line -> line != ""), "\n");
	
	// Generate Flow namespace with all exports
	flowNamespaceContent = superglue(allExports, \pair -> {
		name = pair.second;
		"  " + finame2tsNamespaceProperty(p, name);
	}, "\n");
	
	"// TypeScript definitions with Flow namespace wrapper\n"
	+ "// Auto-generated by Flow compiler\n\n"
	+ importsSection
	+ (if (importsSection != "") "\n\n" else "")
	+ "export declare const Flow: {\n"
	+ flowNamespaceContent
	+ "\n};\n"
	+ "\n// Re-export all types\n"
	+ superglue(foldTree(typeImports, [], \moduleName, types, acc -> {
		if (length(types) > 0) {
			line = "export type { " + strGlue(types, ", ") + " } from './" + moduleName + ".d.ts';";
			arrayPush(acc, line);
		} else {
			acc;
		}
	}), \line -> line, "\n");
}

calculateRelativeImportPath(fromModule : string, toModule : string) -> string {
	// Split paths into directory parts
	fromParts = strSplit(fromModule, "/");
	toParts = strSplit(toModule, "/");
	
	// Remove filename from 'from' path to get directory parts only
	fromDirParts = if (length(fromParts) > 1) {
		subrange(fromParts, 0, length(fromParts) - 1);
	} else {
		[];
	};
	
	// Calculate relative path
	if (fromDirParts == []) {
		// From module is in root, so just prefix with ./
		"./" + toModule;
	} else {
		// From module is in subdirectory, need to go up
		upLevels = length(fromDirParts);
		relativePath = strGlue(generate(0, upLevels, \__ -> ".."), "/");
		if (relativePath == "") {
			"./" + toModule;
		} else {
			relativePath + "/" + toModule;
		}
	}
}

generateModuleImports(p : FiProgram, m : FiModule) -> string {
	importTypes = fold(m.imports, [], \acc, im -> {
		// Check what types from this import are actually used in our exports
		usedTypes = fold(m.exports, [], \acc2, exportName -> {
			mdec = lookupTree(p.names.toplevel, exportName);
			switch (mdec) {
				None(): {
					// Check if it's a struct or union
					if (containsKeyTree(p.names.structs, exportName) || containsKeyTree(p.names.unions, exportName)) {
						acc2;
					} else {
						acc2;
					}
				}
				Some(dec): {
					// Extract referenced types from this declaration
					referencedTypes = extractReferencedTypesForTsd(dec);
					concat(acc2, filter(referencedTypes, \typeName -> {
						// Check if this type comes from the import module
						lookupTree(p.names.struct2module, typeName) == Some(im.flowfile) ||
						lookupTree(p.names.union2module, typeName) == Some(im.flowfile)
					}));
				}
			}
		});
		
		if (usedTypes != []) {
			arrayPush(acc, Pair(im.flowfile, uniq(usedTypes)));
		} else {
			acc;
		}
	});
	
	superglue(importTypes, \pair -> {
		relativePath = calculateRelativeImportPath(m.fileinfo.flowfile, pair.first);
		"import { " + strGlue(pair.second, ", ") + " } from '" + relativePath + "';";
	}, "\n");
}

generateJsLibraryImports(p : FiProgram, m : FiModule, referencedTypes : [string]) -> string {
	// Group referenced types by their source modules
	importTypes = fold(referencedTypes, [], \acc, typeName -> {
		// Check if this type comes from an imported module (standard library)
		structModuleOpt = lookupTree(p.names.struct2module, typeName);
		unionModuleOpt = lookupTree(p.names.union2module, typeName);
		
		moduleOpt = switch (structModuleOpt) {
			Some(moduleName): Some(moduleName);
			None(): unionModuleOpt;
		};
		
		switch (moduleOpt) {
			None(): acc; // Type is defined locally, no import needed
			Some(moduleName): {
				// Skip if this type is defined in the current module
				if (moduleName == m.fileinfo.flowfile) {
					acc;
				} else {
					// Check if we already have this module in our imports
					existing = find(acc, \pair -> pair.first == moduleName);
					switch (existing) {
						None(): arrayPush(acc, Pair(moduleName, [typeName]));
						Some(pair): {
							// Update existing entry
							map(acc, \entry -> if (entry.first == moduleName) {
								Pair(entry.first, arrayPush(entry.second, typeName))
							} else entry)
						}
					}
				}
			}
		}
	});
	
	superglue(importTypes, \pair -> {
		relativePath = calculateRelativeImportPath(m.fileinfo.flowfile, pair.first);
		"import { " + strGlue(uniq(pair.second), ", ") + " } from '" + relativePath + "';";
	}, "\n");
}

generateModuleTypes(p : FiProgram, m : FiModule) -> string {
	// Generate type definitions for structs and unions defined in this module
	structDefs = fold(m.structs, [], \acc, struct -> {
		if (contains(m.exports, struct.name)) {
			arrayPush(acc, generateStructTsd(struct));
		} else {
			acc;
		}
	});
	
	unionDefs = fold(m.unions, [], \acc, union -> {
		if (contains(m.exports, union.name)) {
			arrayPush(acc, generateUnionTsd(p, union));
		} else {
			acc;
		}
	});
	
	strGlue(concat(structDefs, unionDefs), "\n\n");
}

generateModuleExports(p : FiProgram, m : FiModule) -> string {
	// Export regular functions and variables
	functionExports = filtermap(m.exports, \ex -> {
		mdec = lookupTree(p.names.toplevel, ex);
		switch (mdec) {
			None(): None();
			Some(dec): Some(finame2ts(p, ex));
		}
	});
	
	// Also export struct constructors for any exported structs
	structConstructorExports = filtermap(m.exports, \ex -> {
		// Check if this export is a struct type
		structDef = lookupTree(p.names.structs, ex);
		switch (structDef) {
			Some(struct): {
				// Generate constructor function export with "create" prefix
				constructorName = "create" + ex;
				// Extract type parameters from the struct
				typeParams = if (struct.typars != []) {
					"<" + strGlue(map(struct.typars, \tp -> {
						switch (tp) {
							FiTypeParameter(name): {
								// Map Flow's ? and ?? type parameters to proper TypeScript generic names
								if (name == "?") "T"
								else if (name == "??") "U" 
								else if (name == "???") "V"
								else if (name == "????") "W"
								else tsReserved(name);
							}
							default: "T";
						}
					}), ", ") + ">"
				} else "";
				returnType = tsReserved(ex) + (if (struct.typars != []) {
					"<" + strGlue(map(struct.typars, \tp -> {
						switch (tp) {
							FiTypeParameter(name): {
								if (name == "?") "T"
								else if (name == "??") "U" 
								else if (name == "???") "V"
								else if (name == "????") "W"
								else tsReserved(name);
							}
							default: "T";
						}
					}), ", ") + ">"
				} else "");
				
				if (length(struct.args) == 0) {
					// Singleton struct - export as a constant
					Some("export const " + tsReserved(constructorName) + ": " + returnType + ";");
				} else {
					// Constructor function - export as a function that returns the struct type
					Some("export function " + tsReserved(constructorName) + typeParams +
						"(" + superglue(struct.args, \arg -> {
							tsReserved(arg.name) + ": " + fitype2ts(arg.type)
						}, ", ") + "): " + returnType + ";");
				}
			}
			None(): None();
		}
	});
	
	strGlue(concat(functionExports, structConstructorExports), "\n");
}

generateStructTsd(struct : FiTypeStruct) -> string {
	typeParams = if (struct.typars != []) {
		"<" + strGlue(map(struct.typars, \tp -> {
			switch (tp) {
				FiTypeParameter(name): {
					// Map Flow's ? and ?? type parameters to proper TypeScript generic names
					if (name == "?") "T"
					else if (name == "??") "U" 
					else if (name == "???") "V"
					else if (name == "????") "W"
					else tsReserved(name);
				}
				default: "T";
			}
		}), ", ") + ">"
	} else {
		""
	};
	
	"export interface " + tsReserved(struct.name) + typeParams + " {\n"
	+ "  readonly kind: number;\n"  // Add the runtime discriminant field
	+ superglue(struct.args, \arg -> {
		"  " + (if (arg.ismutable) "" else "readonly ") + tsReserved(arg.name) + ": " + fitype2ts(arg.type) + ";"
	}, "\n")
	+ "\n}";
}

generateUnionTsd(p : FiProgram, union : FiTypeUnion) -> string {
	typeParams = if (union.typeparameters != []) {
		"<" + strGlue(map(union.typeparameters, \tp -> {
			switch (tp) {
				FiTypeParameter(name): {
					// Map Flow's ? and ?? type parameters to proper TypeScript generic names
					if (name == "?") "T"
					else if (name == "??") "U" 
					else if (name == "???") "V"
					else if (name == "????") "W"
					else tsReserved(name);
				}
				default: "T";
			}
		}), ", ") + ">"
	} else {
		""
	};
	
	"export type " + tsReserved(union.name) + typeParams + " = "
	+ superglue(union.typenames, fitype2ts, " | ")
	+ ";";
}

extractReferencedTypesForTsd(dec : FiDeclaration) -> [string] {
	switch (dec) {
		FiFunctionDec(name, lambda, type, declStart, defiStart): {
			extractTypesFromFiTypeForTsd(type);
		}
		FiGlobalVar(name, value, type, declStart, defiStart): {
			extractTypesFromFiTypeForTsd(type);
		}
		FiNativeDec(name, io, type, nativeName, fallbackLambda, declStart, defiStart): {
			extractTypesFromFiTypeForTsd(type);
		}
	}
}

extractTypesFromFiTypeForTsd(ty : FiType) -> [string] {
	switch (ty) {
		FiTypeVoid(): [];
		FiTypeArray(t): extractTypesFromFiTypeForTsd(t);
		FiTypeFunction(args, returnType): {
			concat(
				fold(args, [], \acc, arg -> concat(acc, extractTypesFromFiTypeForTsd(arg.type))),
				extractTypesFromFiTypeForTsd(returnType)
			);
		}
		FiTypeRef(t): extractTypesFromFiTypeForTsd(t);
		FiTypeParameter(n): [];
		FiTypeBool(): [];
		FiTypeInt(): [];
		FiTypeDouble(): [];
		FiTypeString(): [];
		FiTypeFlow(): [];
		FiTypeNative(): [];
		FiTypeName(name, typeparameters): {
			concat([name], fold(typeparameters, [], \acc, tp -> concat(acc, extractTypesFromFiTypeForTsd(tp))));
		}
	}
}

extractTypeParametersFromFiType(ty : FiType) -> [string] {
	switch (ty) {
		FiTypeVoid(): [];
		FiTypeArray(t): extractTypeParametersFromFiType(t);
		FiTypeFunction(args, returnType): {
			concat(
				fold(args, [], \acc, arg -> concat(acc, extractTypeParametersFromFiType(arg.type))),
				extractTypeParametersFromFiType(returnType)
			);
		}
		FiTypeRef(t): extractTypeParametersFromFiType(t);
		FiTypeParameter(n): [n];
		FiTypeBool(): [];
		FiTypeInt(): [];
		FiTypeDouble(): [];
		FiTypeString(): [];
		FiTypeFlow(): [];
		FiTypeNative(): [];
		FiTypeName(name, typeparameters): {
			fold(typeparameters, [], \acc, tp -> concat(acc, extractTypeParametersFromFiType(tp)));
		}
	}
}

typeParametersToTsGeneric(typeParams : [string]) -> string {
	if (typeParams == []) {
		""
	} else {
		uniqueParams = uniq(typeParams);
		tsParams = map(uniqueParams, \param -> {
			// Map Flow's ? and ?? type parameters to proper TypeScript generic names
			if (param == "?") "T"
			else if (param == "??") "U" 
			else if (param == "???") "V"
			else if (param == "????") "W"
			else if (param == "?????") "X"
			else if (param == "??????") "Y"
			else if (param == "???????") "Z"
			else tsReserved(param);
		});
		"<" + strGlue(tsParams, ", ") + ">";
	}
}

generateTypeDefinitionsForNames(p : FiProgram, typeNames : [string]) -> string {
	// Generate TypeScript definitions for the given type names
	typeDefinitions = filtermap(typeNames, \typeName -> {
		// Check if it's a struct
		structDef = lookupTree(p.names.structs, typeName);
		switch (structDef) {
			Some(struct): Some(generateStructTsd(struct));
			None(): {
				// Check if it's a union
				unionDef = lookupTree(p.names.unions, typeName);
				switch (unionDef) {
					Some(union): Some(generateUnionTsd(p, union));
					None(): None();
				}
			}
		}
	});
	
	strGlue(typeDefinitions, "\n\n");
}

generateTypeDefinitionsForNamespace(p : FiProgram, typeNames : [string]) -> string {
	// Generate TypeScript definitions for the given type names, formatted for namespace inclusion
	typeDefinitions = filtermap(typeNames, \typeName -> {
		// Check if it's a struct
		structDef = lookupTree(p.names.structs, typeName);
		switch (structDef) {
			Some(struct): Some(generateStructTsdForNamespace(struct));
			None(): {
				// Check if it's a union
				unionDef = lookupTree(p.names.unions, typeName);
				switch (unionDef) {
					Some(union): Some(generateUnionTsdForNamespace(p, union));
					None(): None();
				}
			}
		}
	});
	
	strGlue(typeDefinitions, "\n\n");
}

generateStructTsdForNamespace(struct : FiTypeStruct) -> string {
	typeParams = if (struct.typars != []) {
		"<" + strGlue(map(struct.typars, \tp -> {
			switch (tp) {
				FiTypeParameter(name): {
					// Map Flow's ? and ?? type parameters to proper TypeScript generic names
					if (name == "?") "T"
					else if (name == "??") "U" 
					else if (name == "???") "V"
					else if (name == "????") "W"
					else tsReserved(name);
				}
				default: "T";
			}
		}), ", ") + ">"
	} else {
		""
	};
	
	"  interface " + tsReserved(struct.name) + typeParams + " {\n"
	+ "    readonly kind: number;\n"  // Add the runtime discriminant field
	+ superglue(struct.args, \arg -> {
		"    " + (if (arg.ismutable) "" else "readonly ") + tsReserved(arg.name) + ": " + fitype2ts(arg.type) + ";"
	}, "\n")
	+ "\n  }";
}

generateUnionTsdForNamespace(p : FiProgram, union : FiTypeUnion) -> string {
	typeParams = if (union.typeparameters != []) {
		"<" + strGlue(map(union.typeparameters, \tp -> {
			switch (tp) {
				FiTypeParameter(name): {
					// Map Flow's ? and ?? type parameters to proper TypeScript generic names
					if (name == "?") "T"
					else if (name == "??") "U" 
					else if (name == "???") "V"
					else if (name == "????") "W"
					else tsReserved(name);
				}
				default: "T";
			}
		}), ", ") + ">"
	} else {
		""
	};
	
	"  type " + tsReserved(union.name) + typeParams + " = "
	+ superglue(union.typenames, fitype2ts, " | ")
	+ ";";
}

generateTypeDefinitionsForJsLibrary(p : FiProgram, typeNames : [string]) -> string {
	// Generate TypeScript definitions for the given type names without export keywords
	typeDefinitions = filtermap(typeNames, \typeName -> {
		// Check if it's a struct
		structDef = lookupTree(p.names.structs, typeName);
		switch (structDef) {
			Some(struct): Some(generateStructTsdForJsLibrary(struct));
			None(): {
				// Check if it's a union
				unionDef = lookupTree(p.names.unions, typeName);
				switch (unionDef) {
					Some(union): Some(generateUnionTsdForJsLibrary(p, union));
					None(): None();
				}
			}
		}
	});
	
	strGlue(typeDefinitions, "\n\n");
}

generateStructTsdForJsLibrary(struct : FiTypeStruct) -> string {
	typeParams = if (struct.typars != []) {
		"<" + strGlue(map(struct.typars, \tp -> {
			switch (tp) {
				FiTypeParameter(name): {
					// Map Flow's ? and ?? type parameters to proper TypeScript generic names
					if (name == "?") "T"
					else if (name == "??") "U" 
					else if (name == "???") "V"
					else if (name == "????") "W"
					else tsReserved(name);
				}
				default: "T";
			}
		}), ", ") + ">"
	} else {
		""
	};
	
	"export interface " + tsReserved(struct.name) + typeParams + " {\n"
	+ "  readonly kind: number;\n"  // Add the runtime discriminant field
	+ superglue(struct.args, \arg -> {
		"  " + (if (arg.ismutable) "" else "readonly ") + tsReserved(arg.name) + ": " + fitype2ts(arg.type) + ";"
	}, "\n")
	+ "\n}";
}

generateUnionTsdForJsLibrary(p : FiProgram, union : FiTypeUnion) -> string {
	typeParams = if (union.typeparameters != []) {
		"<" + strGlue(map(union.typeparameters, \tp -> {
			switch (tp) {
				FiTypeParameter(name): {
					// Map Flow's ? and ?? type parameters to proper TypeScript generic names
					if (name == "?") "T"
					else if (name == "??") "U" 
					else if (name == "???") "V"
					else if (name == "????") "W"
					else tsReserved(name);
				}
				default: "T";
			}
		}), ", ") + ">"
	} else {
		""
	};
	
	"export type " + tsReserved(union.name) + typeParams + " = "
	+ superglue(union.typenames, fitype2ts, " | ")
	+ ";";
}

finame2tsNamespaceProperty(p : FiProgram, e : string) -> string {
	mdec = lookupTree(p.names.toplevel, e);
	switch (mdec) {
		None(): {
			// Check if it's a struct constructor
			structDef = lookupTree(p.names.structs, e);
			switch (structDef) {
				Some(struct): {
					constructorName = "create" + e;
					// Extract type parameters from the struct
					typeParams = if (struct.typars != []) {
						"<" + strGlue(map(struct.typars, \tp -> {
							switch (tp) {
								FiTypeParameter(name): {
									// Map Flow's ? and ?? type parameters to proper TypeScript generic names
									if (name == "?") "T"
									else if (name == "??") "U" 
									else if (name == "???") "V"
									else if (name == "????") "W"
									else tsReserved(name);
								}
								default: "T";
							}
						}), ", ") + ">"
					} else "";
					returnType = tsReserved(e) + (if (struct.typars != []) {
						"<" + strGlue(map(struct.typars, \tp -> {
							switch (tp) {
								FiTypeParameter(name): {
									if (name == "?") "T"
									else if (name == "??") "U" 
									else if (name == "???") "V"
									else if (name == "????") "W"
									else tsReserved(name);
								}
								default: "T";
							}
						}), ", ") + ">"
					} else "");
					
					if (length(struct.args) == 0) {
						// Singleton struct - export as a constant
						tsReserved(constructorName) + ": " + returnType + ";";
					} else {
						// Constructor function - export as a function that returns the struct type
						tsReserved(constructorName) + ": " + typeParams + 
						"(" + superglue(struct.args, \arg -> {
							tsReserved(arg.name) + ": " + fitype2ts(arg.type)
						}, ", ") + ") => " + returnType + ";";
					}
				}
				None(): {
					"// Unknown export: " + e;
				}
			}
		}
		Some(dec): {
			switch (dec) {
				FiFunctionDec(name, lambda, type, declStart, defiStart): {
					// Extract type parameters from the function type
					typeParams = extractTypeParametersFromFiType(FiTypeFunction(type.args, type.returnType));
					tsTypeParams = typeParametersToTsGeneric(typeParams);
					
					tsReserved(name) + ": " + tsTypeParams + 
					"(" + superglue(type.args, \arg -> {
						tsReserved(if (arg.name != "") arg.name else "arg") + ": " + fitype2ts(arg.type)
					}, ", ") + ") => " + fitype2ts(type.returnType) + ";";
				}
				FiGlobalVar(name, value, type, declStart, defiStart): {
					tsReserved(name) + ": " + fitype2ts(type) + ";";
				}
				FiNativeDec(name, io, type, nativeName, fallbackLambda, declStart, defiStart): {
					switch (type) {
						FiTypeFunction(args, returnType): {
							// Extract type parameters from the function type
							typeParams = extractTypeParametersFromFiType(FiTypeFunction(args, returnType));
							tsTypeParams = typeParametersToTsGeneric(typeParams);
							
							tsReserved(name) + ": " + tsTypeParams + 
							"(" + superglue(args, \arg -> {
								tsReserved(if (arg.name != "") arg.name else "arg") + ": " + fitype2ts(arg.type)
							}, ", ") + ") => " + fitype2ts(returnType) + ";";
						}
						default: {
							tsReserved(name) + ": " + fitype2ts(type) + ";";
						}
					}
				}
			}
		}
	}	
}

finame2tsNamespaceDeclaration(p : FiProgram, e : string) -> string {
	mdec = lookupTree(p.names.toplevel, e);
	switch (mdec) {
		None(): {
			// Check if it's a struct constructor
			structDef = lookupTree(p.names.structs, e);
			switch (structDef) {
				Some(struct): {
					constructorName = "create" + e;
					// Extract type parameters from the struct
					typeParams = if (struct.typars != []) {
						"<" + strGlue(map(struct.typars, \tp -> {
							switch (tp) {
								FiTypeParameter(name): {
									// Map Flow's ? and ?? type parameters to proper TypeScript generic names
									if (name == "?") "T"
									else if (name == "??") "U" 
									else if (name == "???") "V"
									else if (name == "????") "W"
									else tsReserved(name);
								}
								default: "T";
							}
						}), ", ") + ">"
					} else "";
					returnType = tsReserved(e) + (if (struct.typars != []) {
						"<" + strGlue(map(struct.typars, \tp -> {
							switch (tp) {
								FiTypeParameter(name): {
									if (name == "?") "T"
									else if (name == "??") "U" 
									else if (name == "???") "V"
									else if (name == "????") "W"
									else tsReserved(name);
								}
								default: "T";
							}
						}), ", ") + ">"
					} else "");
					
					if (length(struct.args) == 0) {
						// Singleton struct - export as a constant
						"const " + tsReserved(constructorName) + ": " + returnType + ";";
					} else {
						// Constructor function - export as a function that returns the struct type
						"function " + tsReserved(constructorName) + typeParams +
						"(" + superglue(struct.args, \arg -> {
							tsReserved(arg.name) + ": " + fitype2ts(arg.type)
						}, ", ") + "): " + returnType + ";";
					}
				}
				None(): {
					"// Unknown export: " + e;
				}
			}
		}
		Some(dec): {
			switch (dec) {
				FiFunctionDec(name, lambda, type, declStart, defiStart): {
					// Extract type parameters from the function type
					typeParams = extractTypeParametersFromFiType(FiTypeFunction(type.args, type.returnType));
					tsTypeParams = typeParametersToTsGeneric(typeParams);
					
					"function " + tsReserved(name) + tsTypeParams +
					"(" + superglue(type.args, \arg -> {
						tsReserved(if (arg.name != "") arg.name else "arg") + ": " + fitype2ts(arg.type)
					}, ", ") + "): " + fitype2ts(type.returnType) + ";";
				}
				FiGlobalVar(name, value, type, declStart, defiStart): {
					"const " + tsReserved(name) + ": " + fitype2ts(type) + ";";
				}
				FiNativeDec(name, io, type, nativeName, fallbackLambda, declStart, defiStart): {
					switch (type) {
						FiTypeFunction(args, returnType): {
							// Extract type parameters from the function type
							typeParams = extractTypeParametersFromFiType(FiTypeFunction(args, returnType));
							tsTypeParams = typeParametersToTsGeneric(typeParams);
							
							"function " + tsReserved(name) + tsTypeParams +
							"(" + superglue(args, \arg -> {
								tsReserved(if (arg.name != "") arg.name else "arg") + ": " + fitype2ts(arg.type)
							}, ", ") + "): " + fitype2ts(returnType) + ";";
						}
						default: {
							"const " + tsReserved(name) + ": " + fitype2ts(type) + ";";
						}
					}
				}
			}
		}
	}	
}

finame2ts(p : FiProgram, e : string) -> string {
	mdec = lookupTree(p.names.toplevel, e);
	switch (mdec) {
		None(): {
			"// Unknown export: " + e;
		}
		Some(dec): {
			switch (dec) {
				FiFunctionDec(name, lambda, type, declStart, defiStart): {
					// Extract type parameters from the function type
					typeParams = extractTypeParametersFromFiType(FiTypeFunction(type.args, type.returnType));
					tsTypeParams = typeParametersToTsGeneric(typeParams);
					
					"export function " + tsReserved(name) + tsTypeParams +
					"(" + superglue(type.args, \arg -> {
						tsReserved(if (arg.name != "") arg.name else "arg") + ": " + fitype2ts(arg.type)
					}, ", ") + "): " + fitype2ts(type.returnType) + ";";
				}
				FiGlobalVar(name, value, type, declStart, defiStart): {
					"export const " + tsReserved(name) + ": " + fitype2ts(type) + ";";
				}
				FiNativeDec(name, io, type, nativeName, fallbackLambda, declStart, defiStart): {
					switch (type) {
						FiTypeFunction(args, returnType): {
							// Extract type parameters from the function type
							typeParams = extractTypeParametersFromFiType(FiTypeFunction(args, returnType));
							tsTypeParams = typeParametersToTsGeneric(typeParams);
							
							"export function " + tsReserved(name) + tsTypeParams +
							"(" + superglue(args, \arg -> {
								tsReserved(if (arg.name != "") arg.name else "arg") + ": " + fitype2ts(arg.type)
							}, ", ") + "): " + fitype2ts(returnType) + ";";
						}
						default: {
							"export const " + tsReserved(name) + ": " + fitype2ts(type) + ";";
						}
					}
				}
			}
		}
	}	
}

tsReserved(name : string) -> string {
	// https://github.com/Microsoft/TypeScript/issues/2536
	if (contains(["break", "case", "catch", "class", "const", "continue", "debugger", "default", "delete", "do", "else", "enum", "export", 
		"extends", "false", "finally", "for", "function", "if", "import", "in", "instanceof", "new", "null", "return", "super",
		"switch", "this", "throw", "true", "try", "typeof", "var", "void", "while", "with",
		
		"as", "implements", "interface", "let", "package", "private", "protected", "public", "static", "yield",

		"any", "boolean", "constructor", "declare", "get", "module", "require", "number", "set", "string", "symbol", "type", "from", "of",
		], name)) {
		name + "_"
	} else name;
}

fitype2ts(ty : FiType) -> string {
	switch (ty) {
		FiTypeVoid(): "void";
		FiTypeArray(t): "Array<" + fitype2ts(t) + ">";
		FiTypeFunction(args, returnType): {
			"(" + supergluei(args, \i, arg -> {
				(if (arg.name != "") tsReserved(arg.name) + ": " else "arg" + i2s(i) + ": ") + fitype2ts(arg.type)
			}, ", ") + ") => " + fitype2ts(returnType);
		}
		FiTypeRef(t): "{ value: " + fitype2ts(t) + " }"; // Reference type
		FiTypeParameter(n): {
			// Map Flow's ? and ?? type parameters to proper TypeScript generic names
			if (n == "?") "T"
			else if (n == "??") "U" 
			else if (n == "???") "V"
			else if (n == "????") "W"
			else if (n == "?????") "X"
			else if (n == "??????") "Y"
			else if (n == "???????") "Z"
			else tsReserved(n);
		}
		FiTypeBool(): "boolean";
		FiTypeInt(): "number"; // TypeScript doesn't distinguish int from double
		FiTypeDouble(): "number";
		FiTypeString(): "string";
		FiTypeFlow(): "any"; // Flow's universal type
		FiTypeNative(): "any"; // Platform-specific types
		FiTypeName(name, typeparameters): {
			// User-defined or other types
			tsReserved(name) + (if (typeparameters != []) {
				"<" + superglue(typeparameters, fitype2ts, ", ") + ">"
			} else {
				""
			});
		}
	}
}
