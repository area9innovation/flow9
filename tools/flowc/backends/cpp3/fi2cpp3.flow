import tools/flowc/backends/cpp3/fi2cpp3_compile;
import tools/flowc/manipulation/tail_call;
import tools/flowc/manipulation/flatten_unions;
//import promise;
import sys/process;

export {
	fi2cpp3(program : FiProgram, cfg : FiCpp3Config, callback : (int) -> void) -> void;
}

fi2cpp3(program0 : FiProgram, cfg : FiCpp3Config, callback : (int) -> void) -> void {
	if (cfg.config.verbose > 0) {
		fcPrintln("Building a cpp3 '" + cfg.config.flowfile + "' application ...", cfg.config.threadId);
	}
	setImplicitTypars = \prog -> fiSetImplicitStructTypars(prog, FiTypeVoid());
	program = program0 |> 
		fcOptimizeTailCalls |>
		fiFlattenUnions |> 
		fiCompleteStructTypars |> 
		setImplicitTypars;
	package_path = pathCombineMany(concat([cfg.outputdir], strSplit(cfg.namespace, ".")));
	ensureDirectoryExists(package_path);
	structs2ids = foldi(getTreeValues(program.names.structs), makeTree(), \i, acc, struct -> setTree(acc, struct.name, i));
	vars = filtermap(getTreeValues(program.names.toplevel), \decl -> 
		switch (decl) {
			FiGlobalVar(__,__,__,__,__): Some(decl);
			default: None();
		}
	);
	var_deps = varsDependencies(program);
	volatile_vars = filter(vars, \v -> 
		exists(cfg.volatile, \name -> v.name == name || containsSet(lookupTreeDef(var_deps, v.name, makeSet()), name))
	);
	gctx0 = Cpp3GlobalContext(cfg, program, package_path,
		structs2ids,
		\t -> "T" + i2s(strlen(t.n)),
		\name -> "F_" + name,
		\name -> "f_" + name,
		fiCpp3InitNativeFuncs(cfg),
		fiCpp3InitRuntimeParts(cfg),
		buildSet(map(volatile_vars, \v -> v.name)),
		ref [], ref []
	);
	gctx = Cpp3GlobalContext(gctx0 with 
		runtimeParts = setTree(gctx0.runtimeParts, "struct_defs", cpp3StructDefsRuntimePart(gctx0))
	);
	sources = fi2cpp3Translate(gctx);
	if (^(gctx.errors) != []) callback(5) else {
		fi2cpp3Build(gctx, sources, callback);
	}
}

fi2cpp3RuntimeParts(gctx: Cpp3GlobalContext) -> [Cpp3RuntimePart] {
	parts = set2array(foldTree(gctx.program.names.toplevel, makeSet(), \name, __, acc ->
		switch (lookupTree(gctx.natives, name)) {
			Some(nat): fold(nat.runtimeParts, acc, \ac, dep -> insertSet(ac, dep));
			None(): acc;
		}
	));
	filtermap(parts, \p -> 
		switch (lookupTree(gctx.runtimeParts, p)) {
			Some(part): {
				Some(part);
			}
			None(): {
				refArrayPush(gctx.errors, "unknown runtime part: " + p);
				None();
			}
		}
	);
}

fi2cpp3Translate(gctx: Cpp3GlobalContext) -> [string] {
	save_file = \file, content -> {
		path = pathCombine(gctx.packagePath, file);
		ensureDirectoryExists(dirName(path));
		if (!setFileContent(path, content)) {
			fcPrintln("Failed to save " + file, gctx.config.config.threadId);
		}
	}
	// The runtime fragents, which are used in a program
	runtime_parts = fi2cpp3RuntimeParts(gctx);
	save_file("__flow_runtime.hpp", fiCpp3Runtime(gctx, runtime_parts));

	compiled = fold(gctx.program.traversal, makeTree(), \acc, name -> {
		if (gctx.config.config.verbose > 1) {
			fcPrintln("Compiling to cpp3: " + name, gctx.config.config.threadId);
		}
		module = lookupTreeDef(gctx.program.modules, name, dummyFiModule);
		setTree(acc, name, fiModule2cpp3(module, gctx));
	});

	sources = list2array(foldTree(compiled, makeList1("__flow_runtime.hpp"), \name, cpp3_module, srcs -> {
		cpp3_src = fiCompiledModule2cpp3(cpp3_module, gctx, runtime_parts);
		cpp3_path = strReplace(changeFileExt(name, if (!cpp3_module.isMain) ".hpp" else ".cpp"), "/", "_");
		//if (cpp3_src == "") srcs else {
			save_file(cpp3_path, cpp3_src);
			Cons(cpp3_path, srcs);
		//}
	}));
	save_file(gctx.config.config.flowfile + "_sources", concatStrings(map(sources, \src -> src + "\n")));
	filter(sources, \path -> endsWith(path, ".cpp"));
}

fi2cpp3Build(gctx: Cpp3GlobalContext, sources: [string], callback : (int) -> void) -> void {
	debug_param = getConfigParameterDef(gctx.program.config.config, "cpp-debug", "");
	debug = if (debug_param == "") [] else {
		["-O0", "-ggdb" + debug_param]
	}
	opt_param = getConfigParameterDef(gctx.program.config.config, "cpp-optimize", "");
	optimize = if (opt_param == "" || debug_param != "") [] else {
		["-O" + opt_param]
	}
	args = concatA([sources, debug, optimize, ["-std=c++20", "-o", changeFileExt(gctx.config.config.flowfile, ".exe")]]);
	if (gctx.config.config.verbose > 0) {
		fcPrintln("Compiling with cpp3: 'g++ " + strGlue(args, " ") + "', dir: " + gctx.packagePath + "...", gctx.config.config.threadId);
	}
	result = execSystemProcessOutput("g++", args, gctx.packagePath);
	remove_no_cast_needed = \ -> {
		counter = ref 0;
		remove_pred = \line -> {
			strContains(line, "no cast needed") ||
			(strContains(line, "warning: parameter '") && strContains(line, "' is never used"))
		}
		// After any warning string with "no cast needed" and "warning: parameter '?' is never used" 
		// remove this and two following lines
		strGlue(filter(strSplit(result.stdall, "\n"), \line -> {
			if (remove_pred(line)) {
				counter := 3;
			}
			if (^counter == 0) true else {
				counter := ^counter - 1;
				false;
			}

		}), "\n");
	}
	if (gctx.config.config.verbose > 0 || result.exitCode != 0) {
		msg = remove_no_cast_needed();
		if (!isSpace(msg)) {
			fcPrintln(remove_no_cast_needed(), gctx.program.config.threadId);
		}
	}
	if (result.exitCode == 0) callback(0) else callback(5);	
}
