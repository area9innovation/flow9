import tools/flowc/backends/cpp3/fi2cpp3_compile;
import promise;
import sys/process;

export {
	fi2cpp3(program : FiProgram, cfg : FiCpp3Config, callback : (int) -> void) -> void;
}

fi2cpp3(program0 : FiProgram, cfg : FiCpp3Config, callback : (int) -> void) -> void {
	if (cfg.verbose > 0) {
		fcPrintln("Building a cpp3 '" + cfg.flowfile + "' application ...", cfg.threadId);
	}
	setImplicitTypars = \prog -> fiSetImplicitStructTypars(prog, FiTypeVoid());
	program = program0 |> 
		fiProgramGetRidOfFLow |> 
		fiFlattenUnions |> 
		fiCompleteStructTypars |> 
		setImplicitTypars;
	package_path = pathCombineMany(concat([cfg.outputdir], strSplit(cfg.namespace, ".")));
	ensureDirectoryExists(package_path);
	structs2ids = foldi(getTreeValues(program.names.structs), makeTree(), \i, acc, struct -> setTree(acc, struct.name, i));
	vars = filtermap(getTreeValues(program.names.toplevel), \decl -> 
		switch (decl) {
			FiGlobalVar(__,__,__,__,__): Some(decl);
			default: None();
		}
	);
	var_deps = varsDependencies(program);
	volatile_vars = filter(vars, \v -> 
		exists(cfg.volatile, \name -> containsSet(lookupTreeDef(var_deps, v.name, makeSet()), name))
	);
	gctx = Cpp3GlobalContext(cfg, program, package_path,
		structs2ids,
		buildSet(map(volatile_vars, \v -> v.name)),
		ref [], ref []
	);
	sources = fi2cpp3Translate(gctx);
	if (^(gctx.errors) != []) callback(5) else {
		fi2cpp3Build(gctx, sources, callback);
	}
}

fi2cpp3Translate(gctx: Cpp3GlobalContext) -> [string] {
	save_file = \file, content -> {
		path = pathCombine(gctx.packagePath, file);
		ensureDirectoryExists(dirName(path));
		if (!setFileContent(path, content)) {
			fcPrintln("Failed to save " + file, gctx.config.threadId);
		}
	}
	sources = if (!gctx.config.monolith) {
		save_file("flow_runtime.hpp", fiCpp3Runtime(gctx.config));
		sources = list2array(fold(gctx.program.traversal, makeList1("flow_runtime.hpp"), \srcs, name -> {
			if (gctx.config.verbose > 1) {
				fcPrintln("Compiling to cpp3: " + name, gctx.config.threadId);
			}
			module = lookupTreeDef(gctx.program.modules, name, dummyFiModule);
			cpp3_module = fiModule2cpp3(module, gctx);
			is_main = exists(module.functions, \fn -> fn.name == "main");
			cpp3_src = cpp3_module + if (!is_main) "" else "\n" + cpp3MainFunc(gctx);
			cpp3_path = strReplace(changeFileExt(name, if (!is_main) ".hpp" else ".cpp"), "/", "_");
			//if (cpp3_src == "") srcs else {
				save_file(cpp3_path, cpp3_src);
				Cons(cpp3_path, srcs);
			//}
		}));
		sources;
	} else {
		cpp3_modules = fold(gctx.program.traversal,
			makeList1(fiCpp3Runtime(gctx.config)),
			\acc, name -> {
				module = lookupTreeDef(gctx.program.modules, name, dummyFiModule);
				Cons(fiModule2cpp3(module, gctx), acc);
			}
		);
		cpp3_src = list2string(Cons(cpp3MainFunc(gctx), cpp3_modules));
		cpp3_path = strReplace(changeFileExt(gctx.config.flowfile, ".cpp"), "/", "_");
		save_file(cpp3_path, cpp3_src);
		[cpp3_path];
	}
	save_file(gctx.config.flowfile + "_sources", concatStrings(map(sources, \src -> src + "\n")));
	filter(sources, \path -> endsWith(path, ".cpp"));
}

fi2cpp3Build(gctx: Cpp3GlobalContext, sources: [string], callback : (int) -> void) -> void {
	debug = if (getConfigParameterDef(gctx.program.config.config, "cpp-debug", "") != "1") [] else {
		["-O0", "-ggdb3"]
	}
	args = concat3(sources, debug, ["-std=c++20", "-o", changeFileExt(gctx.config.flowfile, ".exe")]);
	if (gctx.config.verbose > 0) {
		fcPrintln("Compiling with cpp3: 'g++ " + strGlue(args, " ") + "', dir: " + gctx.packagePath + "...", gctx.config.threadId);
	}
	result = execSystemProcessOutput("g++", args, gctx.packagePath);
	remove_no_cast_needed = \ -> {
		counter = ref 0;
		remove_pred = \line -> {
			strContains(line, "no cast needed") ||
			(strContains(line, "warning: parameter '") && strContains(line, "' is never used"))
		}
		// After any warning string with "no cast needed" and "warning: parameter '?' is never used" 
		// remove this and two following lines
		strGlue(filter(strSplit(result.stdall, "\n"), \line -> {
			if (remove_pred(line)) {
				counter := 3;
			}
			if (^counter == 0) true else {
				counter := ^counter - 1;
				false;
			}

		}), "\n");
	}
	if (gctx.config.verbose > 0 || result.exitCode != 0) {
		msg = remove_no_cast_needed();
		if (!isSpace(msg)) {
			fcPrintln(remove_no_cast_needed(), gctx.program.config.threadId);
		}
	}
	if (result.exitCode == 0) callback(0) else callback(5);	
}
