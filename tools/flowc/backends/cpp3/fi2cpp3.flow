import tools/flowc/backends/cpp3/fi2cpp3_compile;
import tools/flowc/backends/cpp3/fi2cpp3_build;
import tools/flowc/manipulation/tail_call;
import tools/flowc/manipulation/flatten_unions;
import tools/flowc/manipulation/wrap_funcs_as_args;
import tools/flowc/manipulation/transform_decls;
import tools/flowc/manipulation/eliminate_union_fields;

export {
	fi2cpp3(program : FiProgram, globEnv : FcTypeEnvGlobal, cfg : FiCpp3Config, callback : (int) -> void) -> void;
}

fi2cpp3(program : FiProgram, globEnv : FcTypeEnvGlobal, cfg : FiCpp3Config, callback : (int) -> void) -> void {
	if (cfg.config.verbose > 0) {
		fcPrintln("Building a cpp3 '" + cfg.outfile + "' in '" + cfg.outputdir + "', application ...", cfg.config.threadId);
	}
	compiled = fi2cpp3Compile(program, globEnv, cfg);
	if (length(compiled.errors) > 0) {
		fcPrintln(strGlue(compiled.errors, "\n"), cfg.config.threadId);
		callback(5);
	} else {
		fi2cpp3Build(cfg, compiled.name, compiled.sources, compiled.qtDeps, callback);
	}
}

fi2cpp3Compile(program0 : FiProgram, globEnv : FcTypeEnvGlobal, cfg : FiCpp3Config) -> Cpp3CompiledProgram {
	// fiToplevelResolveNatives
	cpp_natives = fiCpp3InitNativeFuncs(cfg);
	prog_natives = buildSet(filtermap(getTreeValues(program0.names.toplevel), \decl -> switch (decl) {
		FiNativeDec(name,__,__,__,__,__,__): Some(name);
		default: None();
	}));
	uniformFuncs = \prog -> fiMapProgramToplevel(prog, \toplevel, __,__ -> fiToplevelGlobalVar2Function(toplevel));
	program = program0
		|> (\p -> fiAddMandatoryNatives(p, cpp3MandatoryNatives))
		|> (\p -> fiMapProgramToplevel(p, \x,__,__ ->
			mapConcat(
				fiToplevelGlobalVar2Function(x), \y -> 
				fiToplevelResolveNatives(y, 
					\name -> containsKeyTree(cpp_natives, name),
					\name -> containsSet(prog_natives, name)
				)
			)
		))
		|> fiFlattenUnions
		|> fiRemoveImplicitStructTypars
		|> (\p -> fiSetImplicitStructTypars(p, FiTypeFlow()))
		|> fiWasmWrapFuncArgs
		|> fiProgramAddPolymorphicStructsCasts
		//|> uniformFuncs
		|> fiRemoveSigletonSeqences
		//|> fiExtractCallNonScalarProgram
	;
	ensureDirectoryExists(cfg.outputdir);
	structs = getTreeValues(program.names.structs);
	/*
	maximum non-struct type id is 8
	enum Type {
		VOID = 0,
		INT = 1,   BOOL = 2, DOUBLE = 3, STRING = 4, NATIVE = 5, // primary types
		ARRAY = 6, REF = 7,  FUNC = 8,   STRUCT = 9,             // complex types
		UNKNOWN = -1
	};
	*/
	structs2cpp = foldi(structs, makeTree(), \i, acc, struct -> 
		setTree(acc, struct.name, 
			Cpp3Struct(i + 9, struct, 
				foldi(struct.args, makeTree(), \j, ac, arg -> 
					setTree(ac, arg.name, Cpp3StructArg(j, arg.type))
				)
			)
		)
	);
	vars = filtermap(getTreeValues(program.names.toplevel), \decl -> 
		switch (decl) {
			FiGlobalVar(__,__,__,__,__): Some(decl);
			default: None();
		}
	);
	var_deps = varsDependencies(program);
	volatile_vars = filter(vars, \v -> 
		exists(cfg.volatile, \name -> v.name == name || containsSet(lookupTreeDef(var_deps, v.name, makeSet()), name))
	);
	gctx = Cpp3GlobalContext(globEnv, cfg, program, 
		collectFiEffects(program),
		structs,
		structs2cpp,
		\name -> eitherMap(lookupTree(structs2cpp, name), \str -> i2s(str.id), ""),
		cpp_natives,
		fiCpp3InitRuntimeParts(cfg),
		buildSet(map(volatile_vars, \v -> v.name)),
		ref [], ref [], "", None(), makeSet(), ""
	);
	fi2cpp3Translate(gctx);
}

fi2cpp3Translate(gctx: Cpp3GlobalContext) -> Cpp3CompiledProgram {
	// The runtime fragents, which are used in a program
	runtime_parts = fi2cpp3RuntimeParts(gctx);
	src_path = \name, ext -> pathCombine(gctx.config.outputdir, changeFileExt(name, ext));
	fi2cpp3SaveFile(src_path("__flow_includes", ".hpp"), fiCpp3RuntimeIncludes(gctx, runtime_parts), gctx.config);
	fi2cpp3SaveFile(src_path("__flow_runtime", ".hpp"), fiCpp3RuntimeHeader(gctx, runtime_parts), gctx.config);
	fi2cpp3SaveFile(src_path("__flow_runtime", ".cpp"), fiCpp3RuntimeSource(gctx, runtime_parts), gctx.config);

	compiled0 = fold(gctx.program.traversal, makeTree(), \acc, name -> {
		if (gctx.config.config.verbose > 0) {
			fcPrintln("Compiling to cpp3: " + name, gctx.config.config.threadId);
		}
		module = lookupTreeDef(gctx.program.modules, name, dummyFiModule);
		cpp_module = fiModule2cpp3(module, gctx);
		setTree(acc, name, cpp_module);
	});
	main_name = either(findInOrder(compiled0, \__, module -> if (module.isMain) Some(module.name) else None()), "");
	compiled = if (!gctx.config.monolith) compiled0 else fi2cpp3Monolith(main_name, compiled0, gctx);
	sources = list2array(fold(gctx.program.traversal, 
		array2list([
			changeFileExt("__flow_includes", ".hpp"),
			changeFileExt("__flow_runtime", ".hpp"),
			changeFileExt("__flow_runtime", ".cpp")
		]), 
		\srcs, module_name -> {
			switch (lookupTree(compiled, module_name)) {
				Some(module): {
					name = module.name;
					mod_gctx = Cpp3GlobalContext(gctx with currentModule = name);
					header = fiCompiledModule2cpp3header(module, mod_gctx, runtime_parts);
					header_path = src_path(name, ".hpp");
					fi2cpp3SaveFile(header_path, header, mod_gctx.config);
					srcs1 = Cons(changeFileExt(name, ".hpp"), srcs);
					sources = fiCompiledModule2cpp3sources(module, mod_gctx, runtime_parts);
					if (length(sources) == 0) srcs1 else {
						foldi(sources, srcs, \i, acc, source -> {
							src_name = if (i == 0) name else name + "_" + i2s(i);
							source_path = src_path(src_name, ".cpp");
							fi2cpp3SaveFile(source_path, source, mod_gctx.config);
							Cons(changeFileExt(src_name, ".cpp"), acc);
						});
					}
				}
				None(): {
					println("module: " + module_name + " is not found among compiled, compiled:\n" +
						strGlue(getTreeKeys(compiled), ", ")
					);
					srcs;
				}
			}
		}
	));
	fi2cpp3SaveFile(src_path(fileNameOnly(gctx.config.outfile) + "_sources", ""), concatStrings(map(sources, \src -> src + "\n")), gctx.config);
	Cpp3CompiledProgram(
		main_name,
		sources, 
		fi2cpp3QtDeps(compiled, gctx),
		^(gctx.errors)
	);
}

cpp3MainFunc(gctx: Cpp3GlobalContext, runtime_parts: [Cpp3RuntimePart]) -> string {
	init = strGlue(^(gctx.volatileInit), "\n");
	non_scalar_vars = filtermap(getTreeValues(gctx.program.names.toplevel), \decl ->
		switch (decl) {
			FiGlobalVar(__,__,type,__,__): if (fiTypeIsScalar(type)) None() else Some(decl);
			default: None();
		}
	);
	show_vars = \header -> superglue(non_scalar_vars, \var -> 
		"std::cout << \"" + header + " " + var.name + "->rc_ = \" << " + fi2cpp3varname2cpp(var.name) + "->rc_ << std::endl;",
		"\n"
	);
	inc_vars = superglue(non_scalar_vars, \var -> "incRc(" + fi2cpp3varname2cpp(var.name) + ");", "\n");
	mainInits = superglue(runtime_parts, \part -> part.mainInit, "\n");
	mainTerms = superglue(runtime_parts, \part -> part.mainTerm, "\n");
	dec_vars = superglue(non_scalar_vars, \var -> "decRc(" + fi2cpp3varname2cpp(var.name) + ");", "\n");
	sources = superglue(filter(runtime_parts, \part -> part.staysInMain), \part -> part.source, "\n");

	struct_names = "string struct_names[] = {\n" + 
		strIndent(strArrayWrap(map(gctx.structs, \s -> "u\"" + s.name + "\""), 128, false, ", "))  + 
	"\n};\nInt struct_count = " + i2s(length(gctx.structs)) + ";\n\n";

	struct_defs = cpp3StructDefs(gctx);
	cleanup = "void flow::cleanupAtExit() {" + ("\t" + if (dec_vars == "") " " else "\n" + strIndent(dec_vars) + "\n") + "}\n\n";

"
using namespace flow;
using namespace std::string_literals;
using namespace " + gctx.config.namespace + ";\n\n" +
(if (sources == "") "" else sources + "\n") +
//struct_names + 
struct_defs +
cleanup + 
"int main(int argc, const char* argv[]) {\n" +
"\tRTTI::initStructMap();\n" + 
//"\talloc_stats = new AllocStats();\n" + 
//"\tinitMaxHeapSize(argc, argv);\n" +
(if (mainInits == "") "" else strIndent(mainInits) + "\n") +
(if (init == "") "" else strIndent(init) + "\n") +

	//strIndent(show_vars("(A-)")) + "\n" +

//(if (inc_vars == "") "" else strIndent(inc_vars) + "\n") +
//strIndent(show_vars("(A+")) + "\n" +
"\t" + fi2cpp3varname2cpp("main") + "();\n" +
(if (mainTerms == "") "" else strIndent(mainTerms) + "\n") +

	//strIndent(show_vars("(B+)")) + "\n" +

"\tcleanupAtExit();\n" + 
//strIndent(show_vars("(B-)")) + "\n" +
//"\talloc_stats->print();\n" + 
//"\tstd::cout << \" TERMINATION \" << std::endl;\n" + 
"\treturn 0;\n}\n";
}

cpp3StructDefs(gctx: Cpp3GlobalContext) -> string {
	type2id = \tp -> {
		/*
		enum TypeFx {
			VOID = 0, // special void type - technically it is nullptr_t
			INT = 1,   BOOL = 2, DOUBLE = 3, STRING = 4, NATIVE = 5, // primary types
			ARRAY = 6, REF = 7,  FUNC = 8,   STRUCT = 9,             // complex types
			UNKNOWN = -1
		};
		*/
		switch (tp) {
			FiTypeVoid(): 0;
			FiTypeInt(): 1;
			FiTypeBool(): 2;
			FiTypeDouble(): 3;
			FiTypeString(): 4;
			FiTypeNative(): 5;
			FiTypeArray(__): 6;
			FiTypeRef(__): 7;
			FiTypeFunction(__,__): 8;
			FiTypeName(name,__): {
				eitherMap(lookupTree(gctx.structs2cpp, name), \str -> str.id, -1);
			}
			FiTypeFlow(): -2;
			FiTypeParameter(__): -3;
		}
	}
	struct_arg = \arg -> "FieldDef{u\"" + arg.name + "\", " + i2s(type2id(arg.type)) + "}";
	struct_fields = \s -> "{" + superglue(s.args, struct_arg, ", ") + "}";
	struct_constructor = \s -> {
		make_arg = \i, arg: FiStructArg -> {
			getter = "args->get(" + i2s(i) + ")";
			caster = if (arg.type == FiTypeFlow()) {
				getter;
			} else {
				"castRc<Flow*, " + fiType2cpp3(arg.type, gctx) + ">(" + getter + ")";
			};
			"incRc(" + caster + ")";
		}
		check_arity = "if (args->size() != " + i2s(length(s.args)) + ") {\n" +
		"\tfail(\"Struct " + s.name + " arity mismatch: expected " + i2s(length(s.args)) + " arguments, " +
		"got: \" + string2std(int2string(args->size())) + \"  \");\n}";
		"[](Vec<Flow*>* args){\n" + strIndent(
			check_arity + "\n" +
			"Flow* ret = static_cast<Flow*>(" +
			fiStructName2cpp3(FiTypeName(s.name, s.typars), gctx) + "::make(\n" +
				strIndent(strGlue(mapi(s.args, make_arg), ",\n")) +
			"\n));\n" +
			"decRc(args);\n" +
			"return ret;"
		) + "\n}";
	}
	"std::vector<StructDef> RTTI::struct_defs = {\n" +
		strIndent(strGlue(mapi(gctx.structs, \i, s ->
			"StructDef{\n" + strIndent(
				"u\"" + s.name + "\", " + i2s(i + 9) + ",\n" +
				struct_fields(s) + ",\n" +
				struct_constructor(s)
			 ) + "\n}"
		), ",\n")) +
	"\n};\n\n";
}

fiCompiledModule2cpp3header(module: Cpp3CompiledModule, gctx: Cpp3GlobalContext, runtime_parts: [Cpp3RuntimePart]) -> string {
	includes = superglue(
		fiCpp3DependenciesIncludes(map(module.natives, \nat -> nat.dependencies)), 
		\inc -> "#inc" + "lude " + inc, 
		"\n"
	);
	forward_decls = map(module.decls, \decl -> decl.forward);
	header_defs = filtermap(module.decls, \decl -> if (decl.headerOnly) Some(decl.definition) else None());
	"#pragma once\n" +
	(if (includes == "") "" else includes + "\n") +
	"#inc" + "lude \"__flow_runtime.hpp\"\n" +
	"// Module " + module.name + "\n\n" + 
	(if (gctx.config.monolith) "" else concatStrings(map(module.imports, \imp -> "#inc" + "lude \"" + strReplace(imp, "/", "_") + ".hpp\"\n")) + "\n") +
	"namespace " + gctx.config.namespace + " {\n" +
	"using namespace std::string_literals;\n" +
	"using namespace flow;\n\n" + 
	concatStrings(forward_decls) + "\n" + 
	concatStrings(header_defs) + "\n" + 
	"}\n";
}

fiCompiledModule2cpp3sources(module: Cpp3CompiledModule, gctx: Cpp3GlobalContext, runtime_parts: [Cpp3RuntimePart]) -> [string] {
	all_source_defs = filtermap(module.decls, \decl -> if (!decl.headerOnly) Some(decl.definition) else None());
	max_cpp_source = s2i(lookupTreeDef(gctx.program.config.config, "cpp-max-source", "100000"));
	// Cut all definition into parts, not exceeding max-cpp-source kb
	source_defs_cut = list2array(fold(all_source_defs, Pair(makeList(), 0), \acc, def -> 
		if (acc.second + strlen(def) < max_cpp_source) {
			switch (acc.first) {
				Cons(arr, tail_): Pair(Cons(concat(arr, [def]), tail_), acc.second + strlen(def));
				EmptyList(): Pair(makeList1([def]), strlen(def));
			}
		} else {
			Pair(Cons([def], acc.first), strlen(def));
		}
	).first);
	if (length(source_defs_cut) == 0) {
		if (!module.isMain) [] else 
		["#inc" + "lude \"" + module.name + ".hpp\"\n" +
		"namespace " + gctx.config.namespace + " {\n" +
		"using namespace std::string_literals;\n" +
		"using namespace flow;\n\n" +
		"}\n" + cpp3MainFunc(gctx, runtime_parts)];
	} else {
		mapi(source_defs_cut, \i, source_defs ->
			if (length(source_defs) == 0 && !module.isMain) "" else {
				"#inc" + "lude \"" + module.name + ".hpp\"\n" +
				"namespace " + gctx.config.namespace + " {\n" +
				"using namespace std::string_literals;\n" +
				"using namespace flow;\n\n" + 
				concatStrings(source_defs) + "\n" +
				"}\n" +
				if (i == 0 && module.isMain) cpp3MainFunc(gctx, runtime_parts) else "";
			}
		);
	}
}

fi2cpp3Monolith(main_name: string, compiled: Tree<string, Cpp3CompiledModule>, gctx: Cpp3GlobalContext) -> Tree<string, Cpp3CompiledModule> {
	all_decls = concatA(list2array(fold(gctx.program.traversal, makeList(), \acc, module_name -> 
		switch (lookupTree(compiled, module_name)) {
			Some(module): Cons(module.decls, acc);
			None(): acc;
		}
	)));
	all_natives = concatA(list2array(fold(gctx.program.traversal, makeList(), \acc, module_name ->
		switch (lookupTree(compiled, module_name)) {
			Some(module): Cons(module.natives, acc);
			None(): acc;
		}
	)));
	makeTree1(
		main_name, 
		Cpp3CompiledModule(main_name, true, all_decls, [], all_natives)
	);
}

fi2cpp3QtDeps(modules: Tree<string, Cpp3CompiledModule>, gctx: Cpp3GlobalContext) -> [Cpp3Qt] {
	list2array(foldTree(modules, makeList(), \__,m, acc -> 
		fold(m.natives, acc, \ac, nat -> {
			runtime_deps = fold(nat.runtimeParts, [], \a, part_name -> 
				switch (lookupTree(gctx.runtimeParts, part_name)) {
					Some(part): {
						concat(a, part.dependencies);
					}
					None(): {
						refArrayPush(gctx.errors, "unkonwn runtime part: " + part_name);
						a;
					}
				}
			);
			fold(concat(nat.dependencies, runtime_deps), ac, \a, dep ->
				switch (dep) {
					Cpp3Qt(__,__): Cons(dep, a);
					default: a;
				}
			)
		})
	));
}

fi2cpp3RuntimeParts(gctx: Cpp3GlobalContext) -> [Cpp3RuntimePart] {
	parts = set2array(foldTree(gctx.program.names.toplevel, makeSet(), \name, __, acc ->
		switch (lookupTree(gctx.natives, name)) {
			Some(nat): fold(nat.runtimeParts, acc, \ac, dep -> insertSet(ac, dep));
			None(): acc;
		}
	));
	filtermap(parts, \p -> 
		switch (lookupTree(gctx.runtimeParts, p)) {
			Some(part): {
				Some(part);
			}
			None(): {
				refArrayPush(gctx.errors, "unknown runtime part: " + p);
				None();
			}
		}
	);
}
