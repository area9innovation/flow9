import tools/flowc/backends/cpp3/fi2cpp3_compile;
import tools/flowc/backends/cpp3/fi2cpp3_build;
import tools/flowc/backends/cpp3/fi2cpp3_transform;
import tools/flowc/manipulation/tail_call;
import tools/flowc/manipulation/flatten_unions;
import tools/flowc/manipulation/wrap_funcs_as_args;
import tools/flowc/manipulation/transform_decls;
import tools/flowc/manipulation/eliminate_union_fields;

export {
	fi2cpp3(program : FiProgram, globEnv : FcTypeEnvGlobal, cfg : FiCpp3Config, callback : (int) -> void) -> void;
}

fi2cpp3(program : FiProgram, globEnv : FcTypeEnvGlobal, cfg : FiCpp3Config, callback : (int) -> void) -> void {
	if (cfg.config.verbose > 0) {
		fcPrintln("Building a cpp3 '" + cfg.outfile + "' application in directory '" + cfg.outputdir + "' ...", cfg.config.threadId);
	}
	compiled = fi2cpp3Compile(program, globEnv, cfg);
	if (compiled.success) {
		fi2cpp3Build(cfg, compiled.sources, compiled.qtDeps, callback);
	} else {
		callback(5);
	}
}

fi2cpp3Compile(program0 : FiProgram, globEnv : FcTypeEnvGlobal, cfg : FiCpp3Config) -> Cpp3CompiledProgram {
	cpp_natives = fiCpp3InitNativeFuncs(cfg);
	prog_natives = buildSet(filtermap(getTreeValues(program0.names.toplevel), \decl -> switch (decl) {
		FiNativeDec(name,__,__,__,__,__,__): Some(name);
		default: None();
	}));
	uniformFuncs = \prog -> fiMapProgramToplevel(prog, \toplevel, __,__ -> fiToplevelGlobalVar2Function(toplevel));
	program = program0
		|> (\p -> fiAddMandatoryNatives(p, cpp3MandatoryNatives))
		|> (\p -> fiMapProgramToplevel(p, \x,__,__ ->
			mapConcat(
				fiToplevelGlobalVar2Function(x), \y -> 
				fiToplevelResolveNatives(y, 
					\name -> containsKeyTree(cpp_natives, name),
					\name -> containsSet(prog_natives, name)
				)
			)
		))
		|> fiFlattenUnions
		|> fiRemoveImplicitStructTypars
		|> (\p -> fiSetImplicitStructTypars(p, FiTypeFlow()))
		|> fiWasmWrapFuncArgs
		|> fiProgramAddPolymorphicStructsCasts
		|> fiRemoveSigletonSeqences
	;
	ensureDirectoryExists(cfg.outputdir);
	structs = getTreeValues(program.names.structs);
	structs2cpp = foldi(structs, makeTree(), \i, acc, struct -> 
		setTree(acc, struct.name, 
			Cpp3Struct(i + 9, struct, 
				foldi(struct.args, makeTree(), \j, ac, arg -> 
					setTree(ac, arg.name, Cpp3StructArg(j, arg.type))
				)
			)
		)
	);
	vars = filtermap(getTreeValues(program.names.toplevel), \decl -> 
		switch (decl) {
			FiGlobalVar(__,__,__,__,__): Some(decl);
			default: None();
		}
	);
	var_deps = varsDependencies(program);
	volatile_vars = filter(vars, \v -> 
		exists(cfg.volatile, \name -> v.name == name || containsSet(lookupTreeDef(var_deps, v.name, makeSet()), name))
	);
	gctx = Cpp3GlobalContext(globEnv, cfg, program, 
		collectFiEffects(program),
		structs,
		structs2cpp,
		\name -> eitherMap(lookupTree(structs2cpp, name), \str -> i2s(str.id), ""),
		cpp_natives,
		fiCpp3InitRuntimeParts(cfg),
		buildSet(map(volatile_vars, \v -> v.name)),
		ref true, "", None(), makeSet(), ""
	);
	fi2cpp3Translate(gctx);
}

fi2cpp3Translate(gctx: Cpp3GlobalContext) -> Cpp3CompiledProgram {
	// The runtime fragments, which are used in a program
	runtime_parts = fi2cpp3RuntimeParts(gctx);
	src_path = \name, ext -> pathCombine(gctx.config.outputdir, changeFileExt(name, ext));
	fi2cpp3SaveFile(src_path("__flow_includes", ".hpp"), fiCpp3RuntimeIncludes(gctx, runtime_parts), gctx.config);
	fi2cpp3SaveFile(src_path("__flow_runtime", ".hpp"), fiCpp3RuntimeHeader(gctx, runtime_parts), gctx.config);
	fi2cpp3SaveFile(src_path("__flow_runtime", ".cpp"), fiCpp3RuntimeSource(gctx, runtime_parts), gctx.config);

	do_compile_modules =  map(gctx.program.traversal, \name -> { 
		module = lookupTreeDef(gctx.program.modules, name, dummyFiModule);
		\ -> {
			start = fi2cpp3StartOperationMessage(gctx.config, 1, "compiling module", name);
			fs_module = fi2cpp3TransformModule(module, gctx);
			cpp_module = fiModule2cpp3(fs_module, gctx);
			fi2cpp3EndOperationMessage(gctx.config, 1, "compiling module", name, start);
			cpp_module
		}
	});
	compiled0 = if (isConfigParameterFalse(gctx.program.config.config, "parallel")) {
		sequential(true, do_compile_modules);
	} else {
		concurrent(true, do_compile_modules);
	}
	init_strings = list2array(fold(compiled0, makeList(), \acc, module ->
		fold(module.decls, acc, \ac, decl -> if (decl.init == "") ac else Cons(decl.init, ac))
	));
	main_name = eitherMap(find(compiled0, \module -> module.isMain), \module -> module.name, "");
	compiled = if (!gctx.config.monolith) compiled0 else [fi2cpp3Monolith(main_name, compiled0, gctx)];
	sources = list2array(fold(compiled0, 
		array2list([
			changeFileExt("__flow_includes", ".hpp"),
			changeFileExt("__flow_runtime", ".hpp"),
			changeFileExt("__flow_runtime", ".cpp")
		]), 
		\srcs, module -> {
			name = module.name;
			mod_gctx = Cpp3GlobalContext(gctx with currentModule = name);
			header = fiCompiledModule2cpp3header(module, mod_gctx, runtime_parts);
			header_path = src_path(name, ".hpp");
			fi2cpp3SaveFile(header_path, header, mod_gctx.config);
			srcs1 = Cons(changeFileExt(name, ".hpp"), srcs);
			sources = fiCompiledModule2cpp3sources(module, mod_gctx, init_strings, runtime_parts);
			if (length(sources) == 0) srcs1 else {
				foldi(sources, srcs, \i, acc, source -> {
					src_name = if (i == 0) name else name + "_" + i2s(i);
					source_path = src_path(src_name, ".cpp");
					fi2cpp3SaveFile(source_path, source, mod_gctx.config);
					Cons(changeFileExt(src_name, ".cpp"), acc);
				});
			}
		}
	));
	fi2cpp3SaveFile(src_path(fileNameOnly(gctx.config.outfile) + "_sources", ""), concatStrings(map(sources, \src -> src + "\n")), gctx.config);
	Cpp3CompiledProgram(
		main_name,
		sources, 
		fi2cpp3QtDeps(compiled, gctx),
		^(gctx.success)
	);
}

cpp3MainFunc(gctx: Cpp3GlobalContext, init_strings: [string], runtime_parts: [Cpp3RuntimePart]) -> string {
	init = strGlue(init_strings, "\n");
	non_scalar_vars = filtermap(getTreeValues(gctx.program.names.toplevel), \decl ->
		switch (decl) {
			FiGlobalVar(__,__,type,__,__): if (fiTypeIsScalar(type)) None() else Some(decl);
			default: None();
		}
	);
	show_vars = \header -> superglue(non_scalar_vars, \var -> 
		"std::cout << \"" + header + " " + var.name + "->rc_ = \" << " + fi2cpp3varname2cpp(var.name) + "->rc_ << std::endl;",
		"\n"
	);
	inc_vars = superglue(non_scalar_vars, \var -> "incRc(" + fi2cpp3varname2cpp(var.name) + ");", "\n");
	mainInits = superglue(runtime_parts, \part -> part.mainInit, "\n");
	mainTerms = superglue(runtime_parts, \part -> part.mainTerm, "\n");
	dec_vars = superglue(non_scalar_vars, \var -> "decRc(" + fi2cpp3varname2cpp(var.name) + ");", "\n");
	sources = superglue(filter(runtime_parts, \part -> part.staysInMain), \part -> part.source, "\n");

	struct_defs = cpp3StructDefs(gctx);
	cleanup = "void flow::cleanupAtExit() {" + ("\t" + if (dec_vars == "") " " else "\n" + strIndent(dec_vars) + "\n") + "}\n\n";

"
using namespace flow;
using namespace std::string_literals;
using namespace " + gctx.config.namespace + ";\n\n" +
(if (sources == "") "" else sources + "\n") +
struct_defs +
cleanup + 
"int main(int argc, const char* argv[]) {\n" +
"\tRTTI::initStructMap();\n" + 
(if (mainInits == "") "" else strIndent(mainInits) + "\n") +
(if (init == "") "" else strIndent(init) + "\n") +
"\t" + fi2cpp3varname2cpp("main") + "();\n" +
(if (mainTerms == "") "" else strIndent(mainTerms) + "\n") +
"\tcleanupAtExit();\n" +
"\treturn 0;\n}\n";
}

cpp3StructDefs(gctx: Cpp3GlobalContext) -> string {
	type2id = \tp -> {
		switch (tp) {
			FiTypeVoid(): 0;
			FiTypeInt(): 1;
			FiTypeBool(): 2;
			FiTypeDouble(): 3;
			FiTypeString(): 4;
			FiTypeNative(): 5;
			FiTypeArray(__): 6;
			FiTypeRef(__): 7;
			FiTypeFunction(__,__): 8;
			FiTypeName(name,__): {
				eitherMap(lookupTree(gctx.structs2cpp, name), \str -> str.id, -1);
			}
			FiTypeFlow(): -2;
			FiTypeParameter(__): -3;
		}
	}
	struct_arg = \arg -> "FieldDef{u\"" + arg.name + "\", " + i2s(type2id(arg.type)) + "}";
	struct_fields = \s -> "{" + superglue(s.args, struct_arg, ", ") + "}";
	struct_constructor = \s -> {
		make_arg = \i, arg: FiStructArg -> {
			getter = "args->getRc1(" + i2s(i) + ")";
			if (arg.type == FiTypeFlow()) {
				getter;
			} else {
				"castRc<Flow*, " + fiType2cpp3(arg.type, gctx) + ">(" + getter + ")";
			};
		}
		check_arity = "if (args->size() != " + i2s(length(s.args)) + ") {\n" +
		"\tfail(\"Struct " + s.name + " arity mismatch: expected " + i2s(length(s.args)) + " arguments, " +
		"got: \" + string2std(int2string(args->size())) + \"  \");\n}";
		struct_type = FiTypeName(s.name, s.typars);
		"[](Vec<Flow*>* args){\n" + strIndent(
			check_arity + "\n" +
			"Flow* ret = static_cast<Flow*>(new " +
			fiStructName2cpp3(struct_type, gctx) + "(\n" +
				strIndent(strGlue(mapi(s.args, make_arg), ",\n")) +
			"\n));\n" +
			"decRc(args);\n" +
			"return ret;"
		) + "\n}";
	}
	"std::vector<StructDef> RTTI::struct_defs = {\n" +
		strIndent(strGlue(mapi(gctx.structs, \i, s ->
			"StructDef{\n" + strIndent(
				"u\"" + s.name + "\", " + i2s(i + 9) + ",\n" +
				struct_fields(s) + ",\n" +
				struct_constructor(s)
			 ) + "\n}"
		), ",\n")) +
	"\n};\n\n";
}

fiCompiledModule2cpp3header(module: Cpp3CompiledModule, gctx: Cpp3GlobalContext, runtime_parts: [Cpp3RuntimePart]) -> string {
	includes = superglue(
		fiCpp3DependenciesIncludes(map(module.natives, \nat -> nat.dependencies)), 
		\inc -> "#inc" + "lude " + inc, 
		"\n"
	);
	forwards = map(module.decls, \decl -> decl.forward);
	traits = map(module.decls, \decl -> decl.traits);
	decls = map(module.decls, \decl -> decl.declaration);
	defs = filtermap(module.decls, \decl -> if (decl.headerOnly) Some(decl.definition) else None());
	decl_defs = concat(decls, defs);

	wrap_with_namespace = \ns, using, contents -> {
		"namespace " + ns + " {\n" +
			concatStrings(map(using, \us -> "using namespace " + us + ";\n")) +
			strIndent(trim2(contents, "\n")) + "\n" +
		"}\n"
	}
	"#pragma once\n" +
	(if (includes == "") "" else includes + "\n") +
	"#inc" + "lude \"__flow_runtime.hpp\"\n" +
	"// Module " + module.name + "\n\n" + 
	(if (gctx.config.monolith || length(module.imports) == 0) "" else concatStrings(map(module.imports, \imp -> "#inc" + "lude \"" + strReplace(imp, "/", "_") + ".hpp\"\n")) + "\n") +
	(if (length(forwards) == 0) "" else wrap_with_namespace(gctx.config.namespace, [], concatStrings(forwards)) + "\n") + 
	(if (length(traits) == 0) "" else wrap_with_namespace("flow::traits", [], concatStrings(traits)) + "\n") +
	(if (length(decl_defs) == 0) "\n" else 
		wrap_with_namespace(gctx.config.namespace, ["std::string_literals", "flow"], concatStrings(decl_defs))  + "\n"
	);
}

fiCompiledModule2cpp3sources(module: Cpp3CompiledModule, gctx: Cpp3GlobalContext, init: [string], runtime_parts: [Cpp3RuntimePart]) -> [string] {
	all_source_defs = filtermap(module.decls, \decl -> if (!decl.headerOnly) Some(decl.definition) else None());
	max_cpp_source = s2i(lookupTreeDef(gctx.program.config.config, "cpp-max-source", "100000"));
	// Cut all definition into parts, not exceeding max-cpp-source kb
	source_defs_cut = list2array(fold(all_source_defs, Pair(makeList(), 0), \acc, def -> 
		if (acc.second + strlen(def) < max_cpp_source) {
			switch (acc.first) {
				Cons(arr, tail_): Pair(Cons(concat(arr, [def]), tail_), acc.second + strlen(def));
				EmptyList(): Pair(makeList1([def]), strlen(def));
			}
		} else {
			Pair(Cons([def], acc.first), strlen(def));
		}
	).first);
	if (length(source_defs_cut) == 0) {
		if (!module.isMain) [] else 
		["#inc" + "lude \"" + module.name + ".hpp\"\n" +
		"namespace " + gctx.config.namespace + " {\n" +
		"using namespace std::string_literals;\n" +
		"using namespace flow;\n\n" +
		"}\n" + cpp3MainFunc(gctx, init, runtime_parts)];
	} else {
		mapi(source_defs_cut, \i, source_defs ->
			if (length(source_defs) == 0 && !module.isMain) "" else {
				"#inc" + "lude \"" + module.name + ".hpp\"\n" +
				"namespace " + gctx.config.namespace + " {\n" +
				"using namespace std::string_literals;\n" +
				"using namespace flow;\n\n" + 
				concatStrings(source_defs) + "\n" +
				"}\n" +
				if (i == 0 && module.isMain) cpp3MainFunc(gctx, init, runtime_parts) else "";
			}
		);
	}
}

fi2cpp3Monolith(main_name: string, compiled: [Cpp3CompiledModule], gctx: Cpp3GlobalContext) -> Cpp3CompiledModule {
	all_decls = concatA(list2array(fold(compiled, makeList(), \acc, module -> 
		Cons(module.decls, acc)
	)));
	all_natives = concatA(list2array(fold(compiled, makeList(), \acc, module ->
		Cons(module.natives, acc)
	)));
	Cpp3CompiledModule(main_name, true, all_decls, [], all_natives);
}

fi2cpp3QtDeps(modules: [Cpp3CompiledModule], gctx: Cpp3GlobalContext) -> [Cpp3Qt] {
	list2array(fold(modules, makeList(), \acc, m -> 
		fold(m.natives, acc, \ac, nat -> {
			runtime_deps = fold(nat.runtimeParts, [], \a, part_name -> 
				switch (lookupTree(gctx.runtimeParts, part_name)) {
					Some(part): {
						concat(a, part.dependencies);
					}
					None(): {
						gctx.success := false;
						fcPrintln("unkonwn runtime part: " + part_name, gctx.config.threadId);
						a;
					}
				}
			);
			fold(concat(nat.dependencies, runtime_deps), ac, \a, dep ->
				switch (dep) {
					Cpp3Qt(__,__): Cons(dep, a);
					default: a;
				}
			)
		})
	));
}

fi2cpp3RuntimeParts(gctx: Cpp3GlobalContext) -> [Cpp3RuntimePart] {
	parts = set2array(foldTree(gctx.program.names.toplevel, makeSet(), \name, __, acc ->
		switch (lookupTree(gctx.natives, name)) {
			Some(nat): fold(nat.runtimeParts, acc, \ac, dep -> insertSet(ac, dep));
			None(): acc;
		}
	));
	filtermap(parts, \p -> 
		switch (lookupTree(gctx.runtimeParts, p)) {
			Some(part): {
				Some(part);
			}
			None(): {
				gctx.success := false;
				fcPrintln("unkonwn runtime part: " + p, gctx.config.threadId);
				None();
			}
		}
	);
}
