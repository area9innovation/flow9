import sys/process;
import fs/filesystem;

main() {
	exclude = filter(strSplit(getUrlParameter("exclude"), ","), isNotSpace);
	tests_param = filter(strSplit(getUrlParameter("test"), ","), isNotSpace);
	tests = if (tests_param == []) {
		sort(filter(readDirectory("."), \file ->
			endsWith(file, ".flow") && file != "test_runner.flow" && !exists(exclude, \exc -> startsWith(file, exc))
		));
	} else {
		map(tests_param, \file -> changeFileExt(file, ".flow"));
	}
	println("Going to run tests: [" + strGlue(tests, ", ") + "]");
	iter(tests, \test -> {
		// flowc1 server=0 cpp3=1 cpp-debug=1 test4.flow debug-cpp3=np > out.txt
		compile_out = execSystemProcessOutput("flowc1", ["server=0", "cpp3=1", "cpp-debug=1", test], ".");
		if (strlen(compile_out.stdall) > 50 || compile_out.exitCode != 0) {
			println("some troubles with compilation of test " + test + ":\n" + compile_out.stdall);
		} else {
			//valgrind --tool=memcheck --leak-check=full --show-leak-kinds=all  ./test4
			valgrind_out = execSystemProcessOutput(
				"valgrind", [
					"--tool=memcheck",
					"--leak-check=full",
					"--show-leak-kinds=all",
					"./" + changeFileExt(test, ""), 
					"aaa"
				], "."
			);
			if (valgrind_out.exitCode != 0 ||
				!strContains(valgrind_out.stdall, "All heap blocks were freed -- no leaks are possible") ||
				!strContains(valgrind_out.stdall, "in use at exit: 0 bytes in 0 blocks") ||
				!strContains(valgrind_out.stdall, "ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)")
			) {
				println("Running test " + test + ": memory errors are found:\n" + valgrind_out.stdall);
			} else {
				println("Running test  " + test + ": successfully completed - no memory leaks/errors.");
			}
		}
	});
	quit(0);
}
