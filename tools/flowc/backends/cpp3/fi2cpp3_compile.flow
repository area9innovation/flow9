import tools/flowc/backends/cpp3/fi2cpp3_runtime;
import tools/flowc/backends/cpp3/fi2cpp3_compile_struct;
import tools/flowc/statements/fs_tailcall;
import tools/flowc/statements/fs_memory;
import tools/flowc/statements/fs_transform;
import tools/flowc/statements/fi2fs;
//import tools/flowc/manipulation/eliminate_union_fields;
import tools/flowc/manipulation/transform_exps;

export {
	fiModule2cpp3(module : FiModule, gctx: Cpp3GlobalContext) -> Cpp3CompiledModule;
}

fiModule2cpp3(module : FiModule, gctx0: Cpp3GlobalContext) -> Cpp3CompiledModule {
	gctx = Cpp3GlobalContext(gctx0 with currentModule = module.fileinfo.flowfile);
	names = gctx.program.names;
	compiled_structs = map(fiOrderStructs(module.structs, fail), \struct -> 
		Cpp3CompiledDeclaration(struct.name, true, 
			fiStruct2cpp3_new(struct, gctx, false),
			"", //fiStruct2cpp3_new(struct, gctx, false)
		)
	);
	decls = concat(
		module.natives,
		filtermap(module.initOrder, \name -> {
			switch (find(module.globalVars, \gv -> gv.name == name)) {
				Some(globalVar): Some(globalVar);
				None(): find(module.functions, \fn -> fn.name == name);
			}
		})
	);
	compiled_decls = filtermap(decls, \decl -> fiDeclaration2cpp3(decl, gctx));
	is_main = exists(module.functions, \fn -> fn.name == "main");
	Cpp3CompiledModule(
		gctx.flowfile2cpp(module.fileinfo.flowfile),
		is_main,
		concat(compiled_structs, compiled_decls),
		map(module.imports, \imp -> imp.flowfile),
		fiModuleNatives2cpp3(module, gctx)
	);
}

fiModuleNatives2cpp3(module: FiModule, gctx: Cpp3GlobalContext) -> [Cpp3Native] {
	missing_natives = ref [];
	natives = filtermap(module.natives, \nat -> {
		if (!fiCpp3IsNative(nat.name, gctx) && !contains(module.initOrder, nat.name)) {
			refArrayPush(missing_natives, nat.name);
		}
		lookupTree(gctx.natives, nat.name);
	});
	if (^missing_natives != []) {
		err = "Module " + module.fileinfo.flowfile + ": following native functions are not implemented in cpp3 runtime and doesn't have a flow fallbacks:\n" +
			strIndent(superglue(^missing_natives, \name -> "\t" + name, "\n"));
		refArrayPush(gctx.errors, err);
		fcPrintln(err, gctx.config.config.threadId);
	}
	natives;
}

cpp3InlineFunction(fn: FiFunctionDec) -> bool {
	if (!isEmptySet(fiCollectTypars(fn.type, makeSet()))) true else {
		if (!fiExpIsSimple(fn.lambda.body)) false else {
			fiExpAstNodesCount(fn.lambda.body) < 9;
		}
	}
}

fiDeclaration2cpp3(decl: FiDeclaration, gctx: Cpp3GlobalContext) -> Maybe<Cpp3CompiledDeclaration> {
	switch (decl) {
		FiGlobalVar(name, value, type,__,__): {
			Some(fiGlobalVar2cpp3(decl, gctx));
		}
		FiFunctionDec(name, lambda, type,__,__): {
			if (fiCpp3IsNative(name, gctx)) None() else {
				Some(fiFunc2cpp3(decl, gctx));
			}
		}
		FiNativeDec(name, __,type,__, fallback,__,__):
			maybeMap(lookupTree(gctx.natives, name), \nat -> 
				nat.declaration(gctx.typename2cpp, gctx.varname2cpp, gctx.structid2cpp)
			);
	}
}

fiGlobalVar2cpp3(globalVar : FiGlobalVar, gctx0: Cpp3GlobalContext) -> Cpp3CompiledDeclaration {
	names = gctx0.program.names;
	name = globalVar.name;
	type = globalVar.type;
	gctx = Cpp3GlobalContext(gctx0 with 
		currentToplevel = Some(globalVar),
		toplevelTypars = fiCollectTypars(type, makeSet())
	);
	value1 = fiPrepareFiExp2cpp3(globalVar.value, type, gctx, name);
	value2 = fiPrepareFsExp2cpp3(value1, gctx, name);
	value3 = fsStatUnwrapLastReturnLetVar(value2);
	init = switch (value3) {
		FsRet(e,__): {
			gctx.varname2cpp(name) + " = " + fsExp2cpp3(e, gctx) + ";";
		}
		default: {
			value4 = fsStatReplaceReturnOntoAssign(value3, FsVar(name, false, type, -1));
			"{\n" + strIndent(fsStat2cpp3(value4, gctx)) + "\n}";
		}
	}
	gctx.volatileInit := concat(^(gctx.volatileInit), [init]);
	var_decl = fiType2cpp3(type, gctx) + " " + gctx.varname2cpp(name) + ";\n\n";
	Cpp3CompiledDeclaration(name, false, "extern " + var_decl, var_decl);
}

fiFunc2cpp3(fun: FiFunctionDec, gctx0: Cpp3GlobalContext) -> Cpp3CompiledDeclaration {
	name = fun.name;
	fn_type = fun.type;
	gctx = Cpp3GlobalContext(
		gctx0 with currentToplevel = Some(fun),
		toplevelTypars = fiCollectTypars(fn_type, makeSet())
	);
	fun_typars = map(set2array(fiCollectTypars(fn_type, makeSet())), \n -> FiTypeParameter(n));
	decl_typars = fiDeclTypars2cpp3(fun_typars, gctx);
	headerOnly = cpp3InlineFunction(fun);
	lambda1 = fiPrepareFiExp2cpp3(fun.lambda, fn_type, gctx, name);
	lambda_stat = fiPrepareFsExp2cpp3(lambda1, gctx, name);
	lambda_exp = switch (lambda_stat) {
		FsRet(e,__): e;
		default: fail0("value of '" + name + "' function must be FsRet, got:\n" + fsStat2s(lambda_stat));
	}
	// unwrap lambda from cast
	stat_lambda = switch (lambda_exp) {
		FsLambda(__,__,__,__,__): lambda_exp;
		FsCast(e,__,__,__): {
			switch (e) {
				FsLambda(__,__,__,__,__): e;
				default: fail0("must be lambda or cast to lambda");
			}
		}
		default: fail0("must be lambda or cast to lambda");
	}
	fun_signature =
		(if (headerOnly) "inline " else "") + fiType2cpp3(fn_type.returnType, gctx) + " " + 
		gctx.varname2cpp(name) + fsArgs2cpp(stat_lambda.args, gctx);
	forward_decl = decl_typars + fun_signature + ";\n\n";
	cpp_body = fsStat2cpp3(stat_lambda.body, gctx);
	cpp_fun = if (!fsHasTailCall(stat_lambda.body)) cpp_body else {
		"while (true) " + fiWrapWithBraces(cpp_body);
	}
	definition = decl_typars + fun_signature + " " + fiWrapWithBraces(cpp_fun) + "\n\n";
	Cpp3CompiledDeclaration(name, headerOnly, forward_decl, definition);
}

fiPrepareFiExp2cpp3(e: FiExp, type: FiType, gctx: Cpp3GlobalContext, name: string) -> FiExp {
	names = gctx.program.names;
	show = name == getUrlParameter("debug-cpp3"); //setCommonXField
	transforms = [
		// fiRemoveUnusedVars
		Pair("fiExpChangeAndOr2If", \x -> fiExpChangeAndOr2If(x)),
		Pair("fiTransEliminateUnionFields", \x -> fiTransEliminateUnionFields(x, names)),
		Pair("fiExpShortcutTrivialSwitch", \x -> fiExpShortcutTrivialSwitch(x, names)),
		Pair("fiExplicitCastInSwitch1", \x -> fiExplicitCastInSwitch1(x, names)),
		Pair("fiFixVarInSameStructType1", \x -> fiFixVarInSameStructType1(x)),
		Pair("fiExpRenameRecurringVars1", \x -> fiExpRenameRecurringVars1(x, names)),
		Pair("fiExpMakeVarsUnique", \x -> fiExpMakeVarsUnique(x)),
		Pair("fiExpInterpolateTypars", \x -> fiExpInterpolateTypars(x, names)),
		Pair("fiExpMakeCastsExplicit", \x -> fiExpMakeCastsExplicit(x, type, names)),
		//Pair("fiRemoveImplicitCasts", \x -> fiRemoveImplicitCasts(x)),
		Pair("fiExpNormalizeSeqences", \x -> fiExpNormalizeSeqences(x)),
		Pair("fiRemoveUnusedVars", \x -> fiRemoveUnusedVars(x, gctx.effects)),
		
		Pair("fiExtractCallNonScalarExp", \x -> fiExtractCallNonScalarExp(x, names)),
		Pair("fiExpShortcutIf", \x -> fiExpShortcutIf(x)),
		Pair("fiExpReduceChainLets", \x -> fiExpReduceChainLets(x)),
		//Pair("fiExpReturnVars", \x -> fiExpReturnVars(x)),
		//Pair("fiExpMakeNoStatements", \x -> fiExpMakeNoStatements(x, gctx.effects)),
	];
	fold(transforms, e, \acc, tr -> {
		new_acc = tr.second(acc);
		if (show) {
			println(tr.first + ":\n" + fiExp2stringFull(new_acc) + "\n");
		}
		new_acc;
	});
}

fiPrepareFsExp2cpp3(e: FiExp, gctx: Cpp3GlobalContext, name: string) -> FsStat {
	show = name == getUrlParameter("debug-cpp3"); //name == "main"; //setCommonXField
	names = gctx.program.names;
	if (true) {

		e1 = fiPullStatementsUp(e);
		if (show) {
			//println("original expression:\n" + fiExp2stringFull(e));
			//println("pulled and original are equal: " + b2s(e == e1));
			println("statements are pulled:\n" + fiExp2stringFull(e1));
		}

		s1 = fiExp2FsStat2(e1, names, true, makeTree());
		if (show) {
			println("FS RAW:\n" + fsStat2s(s1));
		}
		decl = lookupTreeDef(gctx.program.names.toplevel, name, FiGlobalVar("", FiVoid(0), FiTypeVoid(), 0, 0));
		s2 = switch (decl) {
			FiFunctionDec(__,__,__,__,__): {
				// Make a tailcall optimization, if applicable
				fsStatTailcall(s1, decl, names);
			}
			default: s1;
		}
		if (show) {
			//println("FS TAILCALL:\n" + fsStat2s(s2));
			debug_perceus := true;
		}
		// Memory: ref-counting operations are inserted
		//s3 = fsStatPerceus(s2, names);
		s3 = fsStatPerceus1(s2, names);
		if (show) {
			debug_perceus := false;
			println("MEM RAW:\n" + fsStat2s(s3));
		}
		s3;
	} else {
		s1 = fiExp2FsExp(e, name, gctx.effects, names);
		if (show) {
			println("FS RAW:\n" + fsStat2s(s1));
		}
		// Memory: ref-counting operations are inserted
		s2 = fsStatPerceus1(s1, names);
		if (show) {
			println("MEM RAW:\n" + fsStat2s(s2));
		}
		s2;
	}
}

fsArgs2cpp(args: [FsVar], gctx: Cpp3GlobalContext) -> string {
	arg2cpp = \i, arg -> {
		fiType2cpp3(arg.type, gctx) + " " + (if (arg.name == "__") arg.name + i2s(i) else gctx.varname2cpp(arg.name))
	};
	"(" + strGlue(mapi(args, arg2cpp), ", ") + ")";
}

fsStat2cpp3(stat : FsStat, gctx: Cpp3GlobalContext) -> string {
	switch (stat) {
		FsIf(cond, pos, neg,__): {
			cond_cpp = fsExp2cpp3(cond, gctx);
			pos_cpp = fsStat2cpp3(pos, gctx);
			neg_cpp = fsStat2cpp3(neg, gctx);
			if (pos_cpp != "") {
				if (neg_cpp != "") {
					"if " + fiWrapWithPars(cond_cpp) + " " + 
						fiWrapWithBraces(pos_cpp) +
					" else " + 
						fiWrapWithBraces(neg_cpp);
				} else {
					"if " + fiWrapWithPars(cond_cpp) + " " + 
						fiWrapWithBraces(pos_cpp);
				}
			} else {
				if (neg_cpp != "") {
					"if (!" + cond_cpp + ") " + 
						fiWrapWithBraces(neg_cpp);
				} else {
					"";
				}
			}
		}
		FsSwitch(x, sw_type, cases,__): {
			fsSwitch2cpp3(stat, fsExp2cpp3(x, gctx) + "->typeIdRc()/*" + fiType2cpp3(fsExpType(x), gctx) + "*/", gctx);
		}
		FsSeq(es,__): {
			if (length(es) == 0) "" else
			if (length(es) == 1) fsStat2cpp3(es[0], gctx) else {
				strGlue(filter(map(es, \x -> fsStat2cpp3(x, gctx)), \s -> s != ""), "\n");
			}
		}
		FsLet(v, e, s,__): {
			e_cpp = fsExp2cpp3(e, gctx);
			s_cpp = fsStat2cpp3(s, gctx);
			fiType2cpp3(v.type, gctx) + " " + gctx.varname2cpp(v.name) + " = " + e_cpp + ";" +
			(if (s_cpp == "") "" else "\n" + s_cpp);
		}
		FsAtomic(): {
			fsAtomic2cpp3(stat, gctx);
		}
	}
}

fsAtomic2cpp3(a : FsAtomic, gctx: Cpp3GlobalContext) -> string {
	switch (a) {
		FsWrapExp(e,__): {
			e_cpp = fsExp2cpp3(e, gctx);
			if (e_cpp == "") "" else {
				e_cpp + ";";
			}
		}
		FsRet(e,__): {
			switch (e) {
				FsTailCall(__,__,__,__): {
					fsStat2cpp3(fsTailCallExpansion(e), gctx) + "\n" +
					"continue;";
				}
				default: {
					"return " + fsExp2cpp3(e, gctx) + ";"
				}
			}
		}
		FsVarDecl(var,__): {
			fiType2cpp3(var.type, gctx) + " " + fsExp2cpp3(var, gctx) + ";";
		}
		FsVarDef(v, e,__): {
			if (v.name == "__") "" else {
				fiType2cpp3(v.type, gctx) + " " + gctx.varname2cpp(v.name) + " = " + fsExp2cpp3(e, gctx) + ";";
			}
		}
		FsLet1(v, e,__): {
			if (v.name == "__") {
				fsExp2cpp3(e, gctx) + ";";
			} else {
				fiType2cpp3(v.type, gctx) + " " + gctx.varname2cpp(v.name) + " = " + fsExp2cpp3(e, gctx) + ";";
			}
		}
		FsAssign(to, what,__): {
			switch (fsExpType(to)) {
				FiTypeRef(__): {
					switch (fsExpType(what)) {
						FiTypeRef(__):
							fsExp2cpp3(to, gctx) + " = " + fsExp2cpp3(what, gctx) + ";";
						FiTypeFlow(): 
							fsExp2cpp3(to, gctx) + "->setFlowRc(0, " + fsExp2cpp3(what, gctx) + ");";
						default:
							fsExp2cpp3(to, gctx) + "->setRc(" + fsExp2cpp3(what, gctx) + ");";
					}
				}
				default:
					fsExp2cpp3(to, gctx) + " = " + fsExp2cpp3(what, gctx) + ";";
			}
		}
		FsModRc(delta, ex,__): {
			if (delta >= 0) {
				"incRc<" + fiType2cpp3(fsExpType(ex), gctx) + ">(" + 
						fsExp2cpp3(ex, gctx) + (if (delta == 1) "" else ", " + i2s(delta)) + 
				");";
			} else {
				"decRc<" + fiType2cpp3(fsExpType(ex), gctx) + ">(" + 
						fsExp2cpp3(ex, gctx) + (if (delta == -1) "" else ", " + i2s(-delta)) + 
				");";
			}
		}
		FsDecRc(ex,__): {
			"decRc<" + fiType2cpp3(fsExpType(ex), gctx) + ">(" + fsExp2cpp3(ex, gctx) + ");";
		}
	}
}

fsSwitch2cpp3(sw: FsSwitch, sw_cond: string, gctx: Cpp3GlobalContext) -> string {
	nondef_cases = filtermap(sw.cases, \c ->
		if (c.struct == "default") None() else Some(fsCase2cpp3(c, gctx))
	);
	all_cases = switch (find(sw.cases, \case -> case.struct == "default")) {
		Some(def_case): {
			concat(nondef_cases, [fsCase2cpp3(def_case, gctx)]);
		}
		None(): {
			path = findFlowPath(gctx.currentModule, true, gctx.config.config.includes, ".");
			//println("looking for a source of module: '" + gctx.currentModule + "' = " + path);
			src = fcFileSource(gctx.globEnv, path);
			//println("src:\n" + src + "\n");
			//line_resolver = makeLineResolver(src);
			//line_col = findLine(line_resolver, sw.start);
			concat(nondef_cases, [
				"default: " + fiWrapWithBraces(
					"std::cerr << \"unexpected case: \" << " + sw_cond + " << \" of type \" << string2std(RTTI::typeName(" + sw_cond + ")) << \" = '" + sw_cond + "' in switch\" << std::endl;\n" +
					//"std::cerr << \"module: " + gctx.currentModule + ", line: " + i2s(line_col.lineno) + ", col: " + i2s(line_col.column) + "\" << std::endl;\n" +
					//"std::cerr << \"Value:\\n\" << flow2string(Cast<" + fiType2cpp3(sw.switchType, gctx) + ">::template To<Flow>::conv(" + sw_var  +"))->toStd() << std::endl;\n" +
					//"std::cerr << R\"FLOW_LITERAL(\n" + toStringFormatted(sw)+ "\n)FLOW_LITERAL\" << std::endl;\n" +
					"exit(1);\n" +
					"break;"
				)
			]);
		}
	}
	"switch (" + sw_cond + ") {\n" +
		superglue(all_cases, \case -> strIndent(case), "\n") +
	"\n}";
}

fsCase2cpp3(c: FsCase, gctx: Cpp3GlobalContext) -> string {
	switch (lookupTree(gctx.program.names.structs, c.struct)) {
		Some(struct): {
			body = fsStat2cpp3(c.body, gctx);
			id = eitherMap(lookupTree(gctx.structs2cpp, c.struct), \str -> str.id, -1);
			"case " + i2s(id) + " /*" + c.struct + "*/: " +
				fiWrapWithBraces(fiUnwrap(body, "{", "}") + "\nbreak;");
		}
		None(): {
			// default case
			if (c.struct != "default") fail0("struct is not found") else {
				body = fsStat2cpp3(c.body, gctx);
				"default: " + fiWrapWithBraces(body);
			}
		}
	}
}

fsExp2cpp3(e : FsExp, gctx: Cpp3GlobalContext) -> string {
	switch (e) {
		FsConst(x,__): {
			switch (x) {
				FiVoid(__):      "void_value";
				FiBool(b, __):   b2s(b);
				FiInt(i, __):    i2s(i);
				FiDouble(d, __): { 
					s = d2s(d);
					if (strContains(s, ".") || strContains(s, "e")) s else s + ".0";
				}
				FiString(s, __): {
					if (s == "") "String::make()" else {
						codes = s2a(s);
						if (exists(codes, \code -> 0xD800 <= code && code <= 0xDFFF)) {
							"String::make(std::vector<char16_t>{" + superglue(codes, i2s, ", ") + "})";
						} else {
							s1 = concatStrings(mapi(codes, \i, code ->
								if (code == 0x09) "\\t" else
								if (code == 0x0a) "\\n" else
								if (code == 0x0d) "\\r" else
								if (code == 0x22) "\\\"" else
								if (code == 0x5c) "\\\\" else
								if (0 < code && code < 0x80) fromCharCode(code) else
								"\\u" + lpad(formatHex(code), "0", 4)
							));
							"String::make(\"" + s1 + "\"s)";
						}
					}
				}
			}
		}
		FsCall(f, args, type,__): {
			f_type = cast(fsExpType(f): FiType -> FiTypeFunction);
			s_args = map(args, \arg -> fsExp2cpp3(arg, gctx));
			s_args_len = fold(s_args, 0, \acc, s_arg -> acc + strlen(s_arg) + 2);
			s_args_all = if (length(args) > 7 || s_args_len > 64 || exists(s_args, \s_arg -> strContains(s_arg, "\n"))) {
				strGlue(s_args, ",\n");
			} else {
				strGlue(s_args, ", ");
			}
			call_args = fiWrapWithPars(s_args_all);
			switch(f) {
				FsVar(name, last,__,__): {
					toplevel: Maybe<FiDeclaration> = lookupTree(gctx.program.names.toplevel, name);
					typars = switch (toplevel) {
						Some(fn): {
							typars_instances = fiMatchTyparsOrdered(fn.type, f_type);
							if (length(typars_instances) == 0) "" else {
								"<" + superglue(typars_instances, \tp -> fiType2cpp3(tp, gctx), ", ") + ">";
							}
						}
						None(): "";
					}
					switch (lookupTree(gctx.natives, name)) {
						Some(nat): {
							switch (nat.inline) {
								Some(inline): inline.def(s_args);
								None(): gctx.varname2cpp(name) + typars + call_args;
							}
						}
						None(): {
							if (fiIsGlobalFunction(name, gctx.program.names)) {
								gctx.varname2cpp(name) + typars + call_args;
							} else {
								gctx.varname2cpp(name) + typars + "->callRc" + call_args;
							}
						}
					}
				}
				default: {
					fsExp2cpp3(f, gctx) + "->callRc" + call_args;
				}
			};
		}
		FsLambda(closure, args, body, type,__): {
			ref_counted_closure = filter(closure, \v -> !fiTypeIsScalar(v.type));
			"Fun<" + fiType2cpp3(type.returnType, gctx) + concatStrings(map(type.args, \arg -> ", " + fiType2cpp3(arg.type, gctx))) + ">::make" +
			"([" + superglue(closure, \v -> gctx.varname2cpp(v.name), ", ") + "] " + fsArgs2cpp(args, gctx) +
			" " + fiWrapWithBraces(fsStat2cpp3(body, gctx)) + 
				", Vec<Flow*>({" + superglue(ref_counted_closure, \v -> gctx.varname2cpp(v.name), ", ") + "})" +
			")";
		}
		FsCallPrim(op, es, type,__): {
			fsCallPrim2cpp3(e, gctx);
		}
		FsTailCall(__,__,__,__): {
			fail0("is done not here");
		}
		FsCast(e1, from, to,__): {
			e1_cpp = fsExp2cpp3(e1, gctx);
			"castRc<" + fiType2cpp3(from, gctx) + ", " + fiType2cpp3(to, gctx) + ">(" + e1_cpp + ")";
		}
		FsIncRc(ex, type,__): {
			"incRc<" + fiType2cpp3(type, gctx) + ">(" + fsExp2cpp3(ex, gctx) + ")";
		}
		FsVar(name, last, type,__): {
			var_name = gctx.varname2cpp(name);
			//if (fiIsGlobalFunction(name, gctx.program.names)) {
			//	var_name;
			//} else {
			//	var_name + (if (last && !fiTypeIsScalar(type) && !fiIsGlobalFunction(name, gctx.program.names)) "/*last*/" else "");
			///}
			if (last) var_name else "incRc<" + fiType2cpp3(type, gctx) + ">(" + var_name + ")";
		}
	}
}

fsCallPrimPlus2cpp3(es : [FsExp], gctx : Cpp3GlobalContext, acc: [FsExp]) -> [FsExp] {
	fold(es, acc, \ac, e -> {
		switch (e) {
			FsCallPrim(op, es1, __,__): {
				switch (e.op) {
					FsPlusPrim(): fsCallPrimPlus2cpp3(es1, gctx, ac);
					default: concat(ac, [e]);
				}
			}
			default: concat(ac, [e]);
		}
	});
}

fsCallPrimMult2cpp3(es : [FsExp], gctx : Cpp3GlobalContext, acc: [FsExp]) -> [FsExp] {
	fold(es, acc, \ac, e -> {
		switch (e) {
			FsCallPrim(op, es1, __,__): {
				switch (e.op) {
					FsMulPrim(): fsCallPrimMult2cpp3(es1, gctx, ac);
					default: concat(ac, [e]);
				}
			}
			default: concat(ac, [e]);
		}
	});
}

fsCallPrim2cpp3(e : FsCallPrim, gctx : Cpp3GlobalContext) -> string {
	e2k = \x -> fsExp2cpp3(x, gctx);
	arg_type = if (length(e.es) > 0) fsExpType(e.es[0]) else FiTypeVoid();
	switch (e.op) {
		FsOrPrim():  "(" + e2k(e.es[0]) + " || " + e2k(e.es[1]) + ")";
		FsAndPrim(): "(" + e2k(e.es[0]) + " && " + e2k(e.es[1]) + ")";
		FsNotPrim(): "!" + e2k(e.es[0]);

		FsEqPrim():  "(compareRc<" + fiType2cpp3(arg_type, gctx) + ">(" + e2k(e.es[0]) + ", " + e2k(e.es[1]) + ") == 0)";
		FsNePrim():  "(compareRc<" + fiType2cpp3(arg_type, gctx) + ">(" + e2k(e.es[0]) + ", " + e2k(e.es[1]) + ") != 0)";
		FsLePrim():  "(compareRc<" + fiType2cpp3(arg_type, gctx) + ">(" + e2k(e.es[0]) + ", " + e2k(e.es[1]) + ") <= 0)";
		FsGePrim():  "(compareRc<" + fiType2cpp3(arg_type, gctx) + ">(" + e2k(e.es[0]) + ", " + e2k(e.es[1]) + ") >= 0)";
		FsLtPrim():  "(compareRc<" + fiType2cpp3(arg_type, gctx) + ">(" + e2k(e.es[0]) + ", " + e2k(e.es[1]) + ") < 0)";
		FsGtPrim():  "(compareRc<" + fiType2cpp3(arg_type, gctx) + ">(" + e2k(e.es[0]) + ", " + e2k(e.es[1]) + ") > 0)";

		FsPlusPrim():  {
			plus_args = fsCallPrimPlus2cpp3(e.es, gctx, []);
			if (e.type == FiTypeString()) {
				fold(tail(plus_args), e2k(plus_args[0]), \acc, arg ->
					"concatStringsRc(" + acc + ", " + e2k(arg) + ")"
				);
			} else {
				"(" + superglue(plus_args, e2k, " + ") + ")";
			}
		}
		FsMinusPrim(): "(" + e2k(e.es[0]) + " - " + e2k(e.es[1]) + ")"; 
		FsMulPrim(): {
			mult_args = fsCallPrimMult2cpp3(e.es, gctx, []);
			"(" + superglue(mult_args, e2k, " * ") + ")";
		}
		FsDivPrim():   "(" + e2k(e.es[0]) + " / " + e2k(e.es[1]) + ")";
		FsModPrim(): {
			if (e.type == FiTypeDouble()) {
				"fmod(" + e2k(e.es[0]) + ", " + e2k(e.es[1]) + ")";
			} else {
				"(" + e2k(e.es[0]) + " % " + e2k(e.es[1]) + ")";
			}
		}
		FsNegPrim():   "-" + e2k(e.es[0]);
		FsArrayPrim(): {
			arr_type = fiDearrayType(e.type);
			if (length(e.es) == 0) {
				"Vec<" + fiType2cpp3(arr_type, gctx) + ">::make()";
			} else {
				arr_s = map(e.es, e2k);
				s1 = strGlue(arr_s, ", ");
				if (strlen(s1) < 64 && !strContains(s1, "\n")) {
					"Vec<" + fiType2cpp3(arr_type, gctx) + ">::make({" + s1 + "})";
				} else {
					"Vec<" + fiType2cpp3(arr_type, gctx) + ">::make({\n" + strIndent(strGlue(arr_s, ",\n")) + "\n})";
				}
			}
		}
		FsIndexPrim(): {
			switch (arg_type) {
				FiTypeFlow(): {
					e2k(e.es[0]) + "->getFlowRc(" + e2k(e.es[1]) + ")";
				}
				default:
					e2k(e.es[0]) + "->getRc(" + e2k(e.es[1]) + ")";
			}
		}
		FsDerefPrim(): {
			switch (arg_type) {
				FiTypeFlow(): {
					e2k(e.es[0]) + "->getFlowRc(0)";
				}
				default: {
					e2k(e.es[0]) + "->getRc()";
				}
			}
		}
		FsRefPrim(): {
			ref_type = fiDerefType(e.type);
			"Ref<" + fiType2cpp3(ref_type, gctx) + ">::make(" + e2k(e.es[0]) + ")";
		}
		FsStructPrim(__): {
			struct_type = cast(e.type : FiType -> FiTypeName);
			fiStructName2cpp3(struct_type, gctx) + "::make(" + strGlue(map(e.es, e2k), ", ") + ")";
		}
		FsFieldPrim(field_name): {
			if (field_name == "structname") {
				switch (arg_type) {
					FiTypeName(struct_name, params): {
						if (containsKeyTree(gctx.program.names.structs, struct_name)) {
							"String::make(\"" + struct_name + "\")";
						} else {
							"String::make(RTTI::typeName(" + e2k(e.es[0]) + "->typeIdRc()))";
						}
					}
					FiTypeFlow(): {
						"String::make(RTTI::typeName(" + e2k(e.es[0]) + "->typeIdRc()))";
					}
					default: fail0("accees to field '" + field_name + "' of non-struct: " + fsExp2s(e.es[0]) + " of type: " + prettyFiType(dummyPretty, arg_type, makeSet()));
				}
			} else {
				switch (arg_type) {
					FiTypeFlow(): {
						e2k(e.es[0]) + "->getFlowRc(String::make(\"" + field_name + "\"))";
					}
					FiTypeName(struct_name,__): {
						field_ind = eitherMap(lookupTree(gctx.structs2cpp, struct_name), 
							\str -> eitherMap(lookupTree(str.argInds, field_name), \arg -> arg.ind, -1),
							-1
						);
						if (field_ind == -1) {
							fail("unknown field name '" + field_name + "' of struct: '" + struct_name + "'");
						}
						e2k(e.es[0]) + "->template getRc<" + i2s(field_ind) + ">()";
					}
					default: {
						fail0("accees to field '" + field_name + "' of non-struct: " + fsExp2s(e.es[0]) + " of type: " + prettyFiType(dummyPretty, arg_type, makeSet()));
					}
				}
			}
		}
		FsIfPrim(): {
			"(" + fsExp2cpp3(e.es[0], gctx) + " ? \n" + 
				strIndent(fsExp2cpp3(e.es[1], gctx)) + 
			"\n : \n" + 
				strIndent(fsExp2cpp3(e.es[2], gctx)) + 
			")";
		}
		FsRequirePrim(flowfile): fail0("//TODO: FsRequire is not implemented in cpp3 backend" + flowfile);
		FsUnsafePrim(name): fail0("//TODO: FsUnsafe is not implemented in cpp3 backend" + name);
		FsReusePrim(__, reuse): {
			struct_type = cast(e.type : FiType -> FiTypeName);
			fiStructName2cpp3(struct_type, gctx) + "::makeReuse(" + reuse + ", " + strGlue(map(e.es, e2k), ", ") + ")";
		}
	}
}

/*
fsCast2cpp(e: string, from: FiType, to: FiType, gctx: Cpp3GlobalContext) -> string {
	def_case = \-> "cast<" + fiType2cpp3(from, gctx) + ", " + fiType2cpp3(to, gctx) + ">(" + e + ")";
	fail_case = \-> fail0("illegal cast from " + prettyFiType(dummyPretty, from, makeSet()) + " to " + prettyFiType(dummyPretty, to, makeSet()));
	switch (from) {
		FiTypeArray(from_arr): {
			switch (to) {
				FiTypeArray(to_arr): def_case();
				FiTypeParameter(to_typar): def_case();
				FiTypeNative(): def_case();
				FiTypeFlow(): e;
				default: fail_case();
			}
		}
		FiTypeFunction(from_args, from_retType): {
			switch (to) {
				FiTypeFunction(to_args, to_retType): def_case();
				FiTypeParameter(to_typar): def_case();
				FiTypeNative(): def_case();
				FiTypeFlow(): e;
				default: fail_case();
			}
		}
		FiTypeRef(from_ref): {
			switch (to) {
				FiTypeRef(to_ref): def_case();
				FiTypeParameter(to_typar): def_case();
				FiTypeNative(): def_case();
				FiTypeFlow(): def_case();
				default: fail_case();
			}
		}
		FiTypeParameter(from_typar):  {
			def_case();	
		}
		FiTypeName(from_name, from_typars):  {
			switch (to) {
				FiTypeName(to_name, to_typars): def_case();
				FiTypeNative(): def_case();
				FiTypeFlow(): def_case();
				default: fail_case();
			}
		}
		FiTypeVoid(): {
			switch (to) {
				FiTypeVoid(): e;
				default: fail_case();
			}
		}
		FiTypeBool(): {
			switch (to) {
				FiTypeBool():   e;
				FiTypeInt():    "bool2int(" + e + ")";
				FiTypeDouble(): "bool2double(" + e + ")";
				FiTypeString(): "bool2string(" + e + ")";
				FiTypeFlow():   def_case();
				default:        fail_case();
			}
		}
		FiTypeInt(): {
			switch (to) {
				FiTypeBool():   "int2bool(" + e + ")";
				FiTypeInt():    e;
				FiTypeDouble(): "int2double(" + e + ")";
				FiTypeString(): "int2string(" + e + ")";
				FiTypeFlow():   def_case();
				default:        fail_case();
			}
		}
		FiTypeDouble(): {
			switch (to) {
				FiTypeBool():   "double2bool(" + e + ")";
				FiTypeInt():    "double2int(" + e + ")";
				FiTypeDouble(): e;
				FiTypeString(): "double2string(" + e + ")";
				FiTypeFlow():   def_case();
				default:        fail_case();
			}
		}
		FiTypeString(): {
			switch (to) {
				FiTypeBool():   "string2bool(" + e + ")";
				FiTypeInt():    "string2int(" + e + ")";
				FiTypeDouble(): "string2double(" + e + ")";
				FiTypeString(): e;
				FiTypeFlow():   def_case();
				default:        fail_case();
			}
		}
		FiTypeNative(): {
			switch (to) {
				FiTypeNative(): def_case();
				FiTypeFlow():   def_case();
				default:        fail_case();
			}
		}
		FiTypeFlow(): {
			switch (to) {
				FiTypeArray(to_arr): def_case();
				FiTypeFunction(to_args, to_retType): def_case();
				FiTypeRef(to_ref): def_case();
				FiTypeParameter(to_typar): def_case();
				FiTypeName(to_name, to_typars): def_case();
				FiTypeVoid(): def_case();
				FiTypeBool(): def_case();
				FiTypeInt(): def_case();
				FiTypeDouble(): def_case();
				FiTypeString(): def_case();
				FiTypeNative(): def_case();
				FiTypeFlow(): e;
			}
		}
	}
}
*/

