import tools/flowc/backends/cpp3/fi2cpp3_runtime;
import tools/flowc/statements/fi2fs;
import tools/flowc/statements/fs_utils;
import tools/flowc/manipulation/eliminate_union_fields;

export {
	fiModule2cpp3(module : FiModule, gctx: Cpp3GlobalContext) -> Cpp3CompiledModule;
}

fiModule2cpp3(module : FiModule, gctx: Cpp3GlobalContext) -> Cpp3CompiledModule {
	names = gctx.program.names;
	compiled_structs = map(module.structs, \struct -> 
		Cpp3CompiledDeclaration(struct.name, true, 
			fiStruct2cpp3(struct, gctx, true),
			fiStruct2cpp3(struct, gctx, false)
		)
	);
	decls = concat(
		module.natives,
		filtermap(module.initOrder, \name -> {
			switch (find(module.globalVars, \gv -> gv.name == name)) {
				Some(globalVar): Some(globalVar);
				None(): find(module.functions, \fn -> fn.name == name);
			}
		})
	);
	compiled_decls = filtermap(decls, \decl -> fiDeclaration2cpp3(decl, gctx));
	is_main = exists(module.functions, \fn -> fn.name == "main");
	Cpp3CompiledModule(
		gctx.flowfile2cpp(module.fileinfo.flowfile),
		is_main,
		concat(compiled_structs, compiled_decls),
		map(module.imports, \imp -> imp.flowfile),
		fiModuleNatives2cpp3(module, gctx)
	);
}

fiModuleNatives2cpp3(module: FiModule, gctx: Cpp3GlobalContext) -> [Cpp3Native] {
	missing_natives = ref [];
	natives = filtermap(module.natives, \nat -> {
		if (!fiCpp3IsNative(nat.name, gctx) && !contains(module.initOrder, nat.name)) {
			refArrayPush(missing_natives, nat.name);
		}
		lookupTree(gctx.natives, nat.name);
	});
	if (^missing_natives != []) {
		err = "Module " + module.fileinfo.flowfile + ": following native functions are not implemented in cpp3 runtime and doesn't have a flow fallbacks:\n" +
			strIndent(superglue(^missing_natives, \name -> "\t" + name, "\n"));
		refArrayPush(gctx.errors, err);
		fcPrintln(err, gctx.config.config.threadId);
	}
	natives;
}

cpp3InlineFunction(fn: FiFunctionDec) -> bool {
	if (!isEmptySet(fiCollectTypars(fn.type, makeSet()))) true else {
		if (!fiExpIsSimple(fn.lambda.body)) false else {
			fiExpAstNodesCount(fn.lambda.body) < 8;
		}
	}
}

fiDeclaration2cpp3(decl: FiDeclaration, gctx: Cpp3GlobalContext) -> Maybe<Cpp3CompiledDeclaration> {
	switch (decl) {
		FiGlobalVar(name, value, type,__,__): {
			Some(fiGlobalVar2cpp3(decl, gctx));
		}
		FiFunctionDec(name, lambda, type,__,__): {
			if (fiCpp3IsNative(name, gctx)) None() else {
				Some(fiFunc2cpp3(decl, gctx));
			}
		}
		FiNativeDec(name, __,type,__, fallback,__,__):
			maybeMap(lookupTree(gctx.natives, name), \nat -> 
				nat.declaration(gctx.typename2cpp, gctx.varname2cpp)
			);
	}
}

fiStructName2cpp3(tn : FiTypeName, gctx: Cpp3GlobalContext) -> string {
	gctx.typename2cpp(tn.name) + if (tn.typeparameters == []) "" else "<" + superglue(tn.typeparameters, \tp -> fiType2cpp3(tp, gctx), ", ") + ">";
}

fiDeclTypars2cpp3(types : [FiType], gctx : Cpp3GlobalContext) -> string {
	typars_names = sort(set2array(fold(types, makeSet(), \acc, type -> fiCollectTypars(type, acc))));
	typars = map(typars_names, \n -> FiTypeParameter(n));
	if (typars == []) "" else "template <" + superglue(typars, \tp -> "typename " + gctx.typar2cpp(tp), ", ") + ">\n";
}

fiStruct2cpp3(struct: FiTypeStruct, gctx0: Cpp3GlobalContext, only_decl: bool) -> string {
	gctx = Cpp3GlobalContext(
		gctx0 with currentToplevel = Some(struct),
		toplevelTypars = fold(struct.typars, makeSet(), \acc, tp -> fiCollectTypars(tp, acc))
	);
	struct_name = gctx.typename2cpp(struct.name);
	struct_id = i2s(lookupTreeDef(gctx.structs2id, struct.name, -1));
	names = gctx.program.names;
	typars = struct.typars;
	decl_typars = fiDeclTypars2cpp3(typars, gctx);
	if (only_decl) {
		decl_typars + "struct " + struct_name + ";\n\n";
	} else {
		static_id = "enum { ID = " + struct_id + ", SIZE = " + i2s(length(struct.args)) + " };"; 
		field_types = supergluei(struct.args, 
			\i, arg -> "typedef " + fiType2cpp3(arg.type, gctx) + " " + "FieldType_" + i2s(i) + ";",
			"\n"
		);
		getter = \union, field -> 
			"\t" + fiType2cpp3(field.type, gctx) + " get_" + union + "_" + field.name + "() override { return " + gctx.varname2cpp(field.name) + "; }\n";
		setter = \union, field -> 
			"\tvoid set_" + union + "_" + field.name + "(" + fiType2cpp3(field.type, gctx) + " ___x___) override { " + gctx.varname2cpp(field.name) + " = ___x___; }\n";
		field_interface = \union, field -> getter(union, field) + if (!field.ismutable) "" else setter(union, field);

		static_instance = if (length(struct.args) > 0) "" else {
			"static Str<" + struct_name + "> instance() {\n" +
				"\tstatic Str<" + struct_name + "> inst(makePtr<" + struct_name + ">());\n" +
				"\treturn inst;\n" +
			"}";
		}

		constructor_init = if (length(struct.args) == 0) "" else {
			": " + superglue(struct.args, \arg -> gctx.varname2cpp(arg.name) + "(__" + gctx.varname2cpp(arg.name) + ")", ", ");
		}
		constructor = "\t" + struct_name + 
		"(" + 
			superglue(struct.args, \arg -> fiType2cpp3(arg.type, gctx) + " __" + gctx.varname2cpp(arg.name), ", " ) + 
		") " + constructor_init + " { }\n";

		abstract_constructor =
		"\tstatic Str<" + struct_name + "> fromAStruct(Ptr<AStruct> p) {\n" + 
			"\t\treturn makePtr<" + struct_name + ">(" + 
				superglue(struct.args, \arg -> 
					"Cast<Flow>::template To<" + fiType2cpp3(arg.type, gctx) + ">::conv(p->field(makeString(u\"" + arg.name + "\")))", ", "
				) + 
			");\n" +
		"\t}\n";
		flow_constructor = 
		"\tstatic Str<" + struct_name + "> fromFlowArgs(Arr<Flow> fs) {\n" + 
			"\t\treturn makePtr<" + struct_name + ">(" + 
				supergluei(struct.args, \i, arg -> 
					"Cast<Flow>::template To<" + fiType2cpp3(arg.type, gctx) + ">::conv(fs->vect.at(" + i2s(i) + "))", ", "
				) + 
			");\n" +
		"\t}\n";
		move_constructor = if (length(struct.args) == 0) "" else 
		"\t" + struct_name + "(" + struct_name + "&& s): " + 
			superglue(struct.args, \arg -> gctx.varname2cpp(arg.name) + "(std::move(s." + gctx.varname2cpp(arg.name) + "))", ", " ) + 
		" { }\n";

		assignment_operator = if (length(struct.args) == 0) "" else 
		"\t" + struct_name + "& operator = (const " + struct_name + "& s) { " + 
			superglue(struct.args, \arg -> gctx.varname2cpp(arg.name) + " = s." + gctx.varname2cpp(arg.name) + ";", " " ) + 
		" return *this; }\n";
		assignment_move = if (length(struct.args) == 0) "" else 
		"\t" + struct_name + "& operator = (" + struct_name + "&& s) { " + 
			superglue(struct.args, \arg -> gctx.varname2cpp(arg.name) + " = std::move(s." + gctx.varname2cpp(arg.name) + ");", " " ) + 
		" return *this; }\n";

		fields = concatStrings(map(struct.args, \arg -> 
			"\t" + (if (arg.ismutable) "mutable " else "") + fiType2cpp3(arg.type, gctx) + " " + gctx.varname2cpp(arg.name) + ";\n"));
		compare1 = "Int compare(const AStruct& s) const override {\n" +
			"\tInt c = name()->compare(*s.name());\n" + 
			"\treturn (c != 0) ? c : compare(dynamic_cast<const " + struct_name + "&>(s));\n" + 
		"\n}";
		compare2 = "Int compare(const " + struct_name + "& s) const {\n" +
			concatStrings(mapi(struct.args, \i, arg ->
				"\tInt c" + i2s(i) + " = Compare<" + fiType2cpp3(arg.type, gctx) + ">::cmp(" + gctx.varname2cpp(arg.name) + ", s." + gctx.varname2cpp(arg.name) + "); " + 
				"if (c" + i2s(i) + " != 0) return c" + i2s(i) + ";\n",
			)) + 
			"\treturn 0;"
		"\n}";

		get_field = "Flow field(String name) const override {\n" +
			(if (length(struct.args) == 0) {
				"\tstd::cerr << \"unknown field \" << toStdString(name) << \" in struct '" + struct_name +"'\" << std::endl;\n" + 
				"\texit(1);\n" +
				"\treturn Flow();";
			} else {
				strIndent(
					supergluei(struct.args, 
						\i, arg -> {
							if (i == 0) {
								"if (*name == u\"" + arg.name + "\") {\n" +
									"\treturn Cast<Flow>::template From<" + fiType2cpp3(arg.type, gctx) + ">::conv(" + gctx.varname2cpp(arg.name) + ");" +
								"\n} "
							} else {
								"else if (*name == u\"" + arg.name + "\") {\n" +
									"\treturn Cast<Flow>::template From<" + fiType2cpp3(arg.type, gctx) + ">::conv(" + gctx.varname2cpp(arg.name) + ");" +
								"\n} "
							}
						}, "\n"
					) + "else {\n" +
						"\tstd::cerr << \"unknown field \" << toStdString(name) << \" in struct '" + struct_name +"'\" << std::endl;\n" + 
						"\texit(1);\n" +
						"\treturn Flow();"
					"\n}"
				);
			}) +
		"\n}";

		mutable_fields = filter(struct.args, \arg -> arg.ismutable);
		set_field = "void setField(String name, Flow val) const override {\n" +
			(if (length(mutable_fields) == 0) {
				"\tstd::cerr << \"unknown field \" << toStdString(name) << \" in struct '" + struct_name +"'\" << std::endl;\n" + 
				"\texit(1);\n"
			} else {
				strIndent(
					supergluei(mutable_fields, 
						\i, arg -> {
							if (i == 0) {
								"if (*name == u\"" + arg.name + "\") {\n" +
									"\t" + gctx.varname2cpp(arg.name) + " = " + "Cast<Flow>::template To<" + fiType2cpp3(arg.type, gctx) + ">::conv(val);" +
								"\n} "
							} else {
								"else if (*name == u\"" + arg.name + "\") {\n" +
									"\t" + gctx.varname2cpp(arg.name) + " = " + "Cast<Flow>::template To<" + fiType2cpp3(arg.type, gctx) + ">::conv(val);" +
								"\n} "
							}
						}, "\n"
					) + "else {\n" +
						"\tstd::cerr << \"unknown field \" << toStdString(name) << \" in struct '" + struct_name +"'\" << std::endl;\n" + 
						"\texit(1);\n"
					"\n}"
				);
			}) +
		"\n}";
		flow_fields = "Arr<Flow> fields() const override { return " + 
			(if (length(struct.args) == 0) "Arr<Flow>::makeEmpty()" else
			"Arr<Flow>{" + superglue(struct.args, \arg -> "Cast<Flow>::template From<" + fiType2cpp3(arg.type, gctx) + ">::conv(" + gctx.varname2cpp(arg.name) + ")", ", ") + "}") 
			+ "; }";
		cast_to = "template<typename N>\n" +
		"Ptr<N> cast() {\n" +
			"\treturn makePtr<N>(\n" + 
				supergluei(struct.args, \i, field -> "\t\tCast<FieldType_" + i2s(i) + ">::template To<typename N::FieldType_" + i2s(i) + ">::conv(" + gctx.varname2cpp(field.name) + ")", ",\n") + 
			"\n\t);\n" +
		"}";

		struct_def = "static StructDef def() {\n" + strIndent(fiStruct2DefCpp3(struct, gctx)) + "\n}";

		decl_typars + "struct " + struct_name + ": public AStruct {\n" +
		strIndent(static_id) + "\n" +
		strIndent(field_types) + "\n" +
		(if (static_instance == "") "" else strIndent(static_instance) + "\n") +
		constructor + 
		(if (move_constructor == "") "" else move_constructor) +
		(if (abstract_constructor == "") "" else abstract_constructor) +
		flow_constructor + 
		strIndent(struct_def) + "\n" + 
		"\tInt type() const override { return ID; }\n" +
		"\tString name() const override { return makeString(\"" + struct.name + "\"); }\n" +
		"\tInt size() const override { return SIZE; }\n" +
		strIndent(flow_fields) + "\n" +
		strIndent(get_field) + "\n" +
		strIndent(set_field) + "\n" +
		strIndent(compare1) + "\n" + 
		strIndent(compare2) + "\n" + 
		strIndent(cast_to) + "\n" +
		(if (fields == "") "" else fields) +
		"};\n\n";
	}
}

fiStruct2DefCpp3(struct : FiTypeStruct, gctx0: Cpp3GlobalContext) -> string {
	typars = if (struct.typars == []) "" else "<" + superglue(struct.typars, \__ -> "Flow", ", ") + ">";
	gctx = Cpp3GlobalContext(
		gctx0 with currentToplevel = Some(struct),
		toplevelTypars = buildSet(filtermap(struct.typars, \tp ->
			switch (tp) {
				FiTypeParameter(nm): Some(nm);
				default: None();
			}
		))
	);
	struct_name = gctx.typename2cpp(struct.name) + typars;
	constructor = "[](Arr<Flow> args) { return " + struct_name + "::fromFlowArgs(args); }";
	fields = if (struct.args == []) "std::vector<FieldDef>()" else {
		"std::vector" + fiWrapWithBraces(
			superglue(struct.args, \arg  -> 
				"FieldDef{u\"" + arg.name + "\", u\"" + fiType2cpp3(arg.type, gctx) +"\", " + b2s(arg.ismutable) + "}", 
				", "
			)
		);
	}
	"return StructDef { ID,\n" +
		strIndent(constructor) + ",\n" +
		strIndent(fields) +
	"\n};";
}

fiGlobalVar2cpp3(globalVar : FiGlobalVar, gctx0: Cpp3GlobalContext) -> Cpp3CompiledDeclaration {
	names = gctx0.program.names;
	name = globalVar.name;
	gctx = Cpp3GlobalContext(gctx0 with 
		currentToplevel = Some(globalVar),
		toplevelTypars = fiCollectTypars(globalVar.type, makeSet())
	);
	value0 = fiEliminateUnionFields(globalVar.value, names, 0);
	value1 = fiExplicitCastInSwitch(value0, names);
	value2 = fiFixVarInSameStructType(value1, makeTree(), names);
	value = value2;
	pair0 = fiExp2FsExp(value, makeSet(), gctx.effects, ref 0);
	pair1 = Pair(
		fsMakeExpCastsExplicit(pair0.first, globalVar.type, names, true),
		map(pair0.second, \s -> fsMakeStatCastsExplicit(s, FiTypeVoid(), names))
	);
	pair2 = fold(pair1.second, Pair([], makeTree()), \acc, s -> {
		p = fsStatSSA(s, acc.second);
		stat = fsInterpolateTyparsStat(p.first, names);
		Pair(concat(acc.first, [stat]), p.second);
	});
	value3 = fsExpSSA(pair1.first, pair2.second);
	value4 = fsInterpolateTyparsExp(value3, names);
	pair = Pair(value4, pair2.first);

	value_exp = if (pair.second == []) pair.first else {
		FsCall(FsLambda([], [], 
			fsWrapSeq(concat(pair.second, [FsRet(pair.first)])), 
			FiTypeFunction([], globalVar.type
			)
		), [], globalVar.type);
	}

	init = gctx.varname2cpp(name) + " = " + fsExp2cpp3(value_exp, gctx) + ";";
	if (containsSet(gctx.volatileVars, name)) {
		// Volatile variable
		gctx.volatileInit := concat(^(gctx.volatileInit), [init]);
		var_decl = fiType2cpp3(globalVar.type, gctx) + " " + gctx.varname2cpp(name) + ";\n\n";
		Cpp3CompiledDeclaration(name, false, "extern " + var_decl, var_decl);
	} else {
		// Constant variable
		var_def = "const " + fiType2cpp3(globalVar.type, gctx) + " " + init + "\n\n";
		Cpp3CompiledDeclaration(name, true, "", var_def);
	}
}

fiFunc2cpp3(fun: FiFunctionDec, gctx0: Cpp3GlobalContext) -> Cpp3CompiledDeclaration {
	name = fun.name;
	fn_type = fun.type;
	gctx = Cpp3GlobalContext(
		gctx0 with currentToplevel = Some(fun),
		toplevelTypars = fiCollectTypars(fn_type, makeSet())
	);
	fun_args = fun.lambda.args;
	headerOnly = cpp3InlineFunction(fun);
	fun_name = gctx.varname2cpp(name);
	fun_typars = set2array(fiTypeTypars(makeSet(), fn_type));
	decl_typars = fiDeclTypars2cpp3(fun_typars, gctx);
	fun_signature = (if (headerOnly) "inline " else "") + fiType2cpp3(fn_type.returnType, gctx) + " " + fun_name + fiFunArgs2cpp(fun_args, gctx);
	forward_decl = decl_typars + fun_signature + ";\n\n";
	fun_locals = fold(fun_args, makeSet(), \acc, arg -> if (arg.name == "__") acc else insertSet(acc, arg.name));
	
	names = gctx.program.names;
	lambda0 = fiEliminateUnionFields(fun.lambda, names, 0);
	lambda1 = fiExplicitCastInSwitch(lambda0, names);
	lambda3 = fiFixVarInSameStructType(
		lambda1, 
		fold(fn_type.args, makeTree(), \acc, arg -> 
			setTree(acc, arg.name, FiVar(arg.name, arg.type, 0))
		), 
		names
	);
	lambda4 = cast(lambda3: FiExp -> FiLambda);
	lambda5_body = fiExpRenameRecurringVars(lambda4.body, fun_locals);

	fun_stat0 = fiExp2FsStat(lambda5_body, FsReturnToOuter(), fun_locals, gctx.effects, ref 0, name);
	fun_stat1 = fsStatSSA(fun_stat0, makeTree()).first;
	fun_stat2 = fsInterpolateTyparsStat(fun_stat1, names);
	fun_stat = fsMakeStatCastsExplicit(fun_stat2, fn_type.returnType, names);
	body = fsStat2cpp3(fun_stat, gctx);
	fun_cpp = if (!fsHasTailCall(fun_stat)) body else {
		"while (true) " + fiWrapWithBraces(body);
	}
	definition = decl_typars + fun_signature + " " + fiWrapWithBraces(fun_cpp) + "\n\n";
	Cpp3CompiledDeclaration(name, headerOnly, forward_decl, definition);
}

fiFunArgs2cpp(args: [FiFunArg], gctx: Cpp3GlobalContext) -> string {
	arg2cpp = \i, arg -> {
		fiType2cpp3(arg.type, gctx) + " " + (if (arg.name == "__") arg.name + i2s(i) else gctx.varname2cpp(arg.name))
	};
	"(" + strGlue(mapi(args, arg2cpp), ", ") + ")";
}

fiType2cpp3(t : FiType, gctx: Cpp3GlobalContext) -> string {
	switch (t) {
		FiTypeArray(arr): {
			"Arr<" + fiType2cpp3(arr, gctx) + ">";
		}
		FiTypeFunction(args, retType): {
			"Fun<" + superglue(concat([retType], map(args, \arg -> arg.type)), \tp -> fiType2cpp3(tp, gctx) , ", ") + ">";
		}
		FiTypeRef(tp): {
			"Ref<" + fiType2cpp3(tp, gctx) + ">";
		}
		FiTypeParameter(nm):  {
			if (!containsSet(gctx.toplevelTypars, nm)) {
				// Stray type parameters are considered flow
				"Flow";
			} else {
				"T" + i2s(strlen(nm));
			}
		}
		FiTypeName(name, typars):  {
			if (containsKeyTree(gctx.program.names.structs, name)) {
				"Str<" + fiStructName2cpp3(t, gctx) + ">";
			} else {
				// Union case
				"Flow";
			}
		}
		FiTypeBool():   "Bool";
		FiTypeInt():    "Int";
		FiTypeDouble(): "Double";
		FiTypeString(): "String";
		FiTypeFlow():   "Flow";
		FiTypeVoid():   "Void";
		FiTypeNative(): "Flow";
	}
}

fsStat2cpp3(stat : FsStat, gctx: Cpp3GlobalContext) -> string {
	switch (stat) {
		FsLet(name, vtype, e): {
			if (name == "__") "" else {
				fiType2cpp3(vtype, gctx) + " " + gctx.varname2cpp(name) + " = " + fsExp2cpp3(e, gctx) + ";";
			}
		}
		FsIf(cond, pos, neg, type): {
			cond_cpp = fsExp2cpp3(cond, gctx);
			pos_cpp = fsStat2cpp3(pos, gctx);
			neg_cpp = fsStat2cpp3(neg, gctx);
			if (pos_cpp != "") {
				if (neg_cpp != "") {
					"if " + fiWrapWithPars(cond_cpp) + " " + 
						fiWrapWithBraces(pos_cpp) +
					" else " + 
						fiWrapWithBraces(neg_cpp);
				} else {
					"if " + fiWrapWithPars(cond_cpp) + " " + 
						fiWrapWithBraces(pos_cpp);
				}
			} else {
				if (neg_cpp != "") {
					"if (!" + cond_cpp + ") " + 
						fiWrapWithBraces(neg_cpp);
				} else {
					"";
				}
			}
		}
		FsSwitch(x, sw_type, cases, type): {
			switch (x.type) {
				FiTypeName(typename,__): {
					switch (lookupTree(gctx.program.names.unions, typename)) {
						Some(__): {
							fsSwitch2cpp3(stat, gctx.varname2cpp(x.name) + "->type()/*" + typename + "*/", gctx);
						}
						None(): {
							fsStructSwitch2cpp3(stat, typename, gctx);
						}
					}			
				}
				FiTypeFlow(): {
					fsSwitch2cpp3(stat, gctx.varname2cpp(x.name) + "->type()/*Flow*/", gctx);
				}
				default:
					fail0("must be struct or union or flow type, got: " + prettyFiType(dummyPretty, x.type, makeSet()));
			}
		}
		FsSeq(es, type): {
			if (length(es) == 0) "" else
			if (length(es) == 1) fsStat2cpp3(es[0], gctx) else {
				es_cpp = filter(map(es, \x -> fsStat2cpp3(x, gctx)), \s -> s != "");
				fiWrapWithBraces(strGlue(es_cpp, "\n"));
			}
		}
		FsWrapExp(e): {
			e_cpp = fsExp2cpp3(e, gctx);
			if (e_cpp != "") e_cpp + ";" else "";
		}
		FsRet(e): {
			e_s = fsExp2cpp3(e, gctx);
			if (fsExpType(e) == FiTypeVoid()) {
				if (e_s == "") "return;" else e_s + ";\nreturn;";
			} else {
				"return " + e_s + ";"
			}
		}
		FsTailCall(type): {
			"continue;";
		}
		FsVarDecl(var): {
			fiType2cpp3(var.type, gctx) + " " + gctx.varname2cpp(var.name) + ";";
		}
		FsAssign(var, e): {
			gctx.varname2cpp(var.name) + " = " + fsExp2cpp3(e, gctx) + ";";
		}
	}
}

fsSwitch2cpp3(sw: FsSwitch, sw_cond: string, gctx: Cpp3GlobalContext) -> string {
	nondef_cases = filtermap(sw.cases, \c ->
		if (c.struct == "default") None() else Some(fsCase2cpp3(c, gctx))
	);
	all_cases = switch (find(sw.cases, \case -> case.struct == "default")) {
		Some(def_case): {
			concat(nondef_cases, [fsCase2cpp3(def_case, gctx)]);
		}
		None(): {
			concat(nondef_cases, [
				"default: " + fiWrapWithBraces(
					"std::cerr << \"unexpected case: \" << " + sw_cond + " << \" in switch\" << std::endl;\n" +
					"exit(1);\n" +
					"break;"
				)
			]);
		}
	}
	"switch (" + sw_cond + ") {\n" +
		superglue(all_cases, \case -> strIndent(case), "\n") +
	"\n}";
}

fsCase2cpp3(c: FsCase, gctx: Cpp3GlobalContext) -> string {
	switch (lookupTree(gctx.program.names.structs, c.struct)) {
		Some(struct): {
			args_to_wrap = filtermapi(c.args, \i, arg -> {
				arg_type = struct.args[i].type;
				arg_typars = set2array(fiTypeTypars(makeSet(), arg_type));
				if (arg_typars == []) None() else Some(Pair(arg, arg_type));
			});
			vars_wrapped = if (args_to_wrap == []) c.body else fsWrapCaseVarsWithCasts(c.body, args_to_wrap);
			body = fsStat2cpp3(vars_wrapped, gctx);
			id = lookupTreeDef(gctx.structs2id, c.struct, -1);
			"case " + i2s(id) + " /*" + c.struct + "*/: " +
				fiWrapWithBraces(fiUnwrap(body, "{", "}") + "\nbreak;");

		}
		None(): {
			// default case
			if (c.struct != "default") fail0("struct is not found") else {
				body = fsStat2cpp3(c.body, gctx);
				strIndent("default: " + fiWrapWithBraces(body));
			}
		}
	}
}

fsStructSwitch2cpp3(sw: FsSwitch, typename: string, gctx: Cpp3GlobalContext) -> string {
	switch (lookupTree(gctx.program.names.structs, typename)) {
		Some(struct): {
			switch (find(sw.cases, \case -> case.struct == typename)) {
				Some(c): {
					args_to_wrap = filtermapi(c.args, \i, arg -> {
						arg_type = struct.args[i].type;
						arg_typars = set2array(fiTypeTypars(makeSet(), arg_type));
						if (arg_typars == []) None() else Some(Pair(arg, arg_type));
					});
					vars_wrapped = if (args_to_wrap == []) c.body else fsWrapCaseVarsWithCasts(c.body, args_to_wrap);
					fsStat2cpp3(vars_wrapped, gctx);
				}
				None(): {
					fail0("struct case is not found");
				}
			}
		}
		None(): {
			fail0("must be struct or union (type name): " + typename);
		}
	}
}

fsExp2cpp3(e : FsExp, gctx: Cpp3GlobalContext) -> string {
	switch (e) {
		FiVoid(__):      "";
		FiBool(b, __):   b2s(b);
		FiInt(i, __):    i2s(i);
		FiDouble(d, __): { 
			s = d2s(d);
			if (strContains(s, ".") || strContains(s, "e")) s else s + ".0";
		}
		FiString(s, __): {
			if (s == "") "makeString()" else {
				codes = s2a(s);
				if (exists(codes, \code -> 0xD800 <= code && code <= 0xDFFF)) {
					"makeString(std::vector<char16_t>{" + superglue(codes, i2s, ", ") + "})";
				} else {
					s1 = concatStrings(mapi(codes, \i, code ->
						if (code == 0x09) "\\t" else
						if (code == 0x0a) "\\n" else
						if (code == 0x0d) "\\r" else
						if (code == 0x22) "\\\"" else
						if (code == 0x5c) "\\\\" else
						if (0 < code && code < 0x80) fromCharCode(code) else
						"\\u" + lpad(formatHex(code), "0", 4)
					));
					"makeString(\"" + s1 + "\"s)";
				}
			}
		}
		FsCast(ex, from, to): {
			s = fsExp2cpp3(ex, gctx);
			fiCpp3Cast(from, to, s, gctx);
		}
		FsCall(f, args, type): {
			f_type = cast(fsExpType(f): FiType -> FiTypeFunction);
			s_args = map(args, \arg -> fsExp2cpp3(arg, gctx));
			s_args_len = fold(s_args, 0, \acc, s_arg -> acc + strlen(s_arg) + 2);
			s_args_all = if (length(args) > 7 || s_args_len > 64 || exists(s_args, \s_arg -> strContains(s_arg, "\n"))) {
				strGlue(s_args, ",\n");
			} else {
				strGlue(s_args, ", ");
			}
			s_args_wrapped = fiWrapWithPars(s_args_all);
			switch(f) {
				FsVar(name,__,__): {
					toplevel: Maybe<FiDeclaration> = lookupTree(gctx.program.names.toplevel, name);
					typars = switch (toplevel) {
						Some(fn): {
							typars_instances = fiMatchTyparsOrdered(fn.type, f_type);
							if (length(typars_instances) == 0) "" else {
								"<" + superglue(typars_instances, \tp -> fiType2cpp3(tp, gctx), ", ") + ">";
							}
						}
						None(): "";
					}
					switch (lookupTree(gctx.natives, name)) {
						Some(nat): {
							switch (nat.inline) {
								Some(inline): inline.def(s_args);
								None(): gctx.varname2cpp(name) + typars + s_args_wrapped;
							}
						}
						None(): gctx.varname2cpp(name) + typars + s_args_wrapped;
					}
				}
				default: {
					fsExp2cpp3(f, gctx) + s_args_wrapped;
				}
			};
		}
		FsLambda(closure, args, body, type): {
			fiType2cpp3(type, gctx) + "([" + superglue(closure, gctx.varname2cpp, ", ") + "] " + fiFunArgs2cpp(args, gctx) +
			" " + fiWrapWithBraces(fsStat2cpp3(body, gctx)) + ")";
		}
		FsTernaryIf(e1, e2, e3, type): {
			"(" + fsExp2cpp3(e1, gctx) + " ? \n" + 
				strIndent(fsExp2cpp3(e2, gctx)) + 
			"\n : \n" + 
				strIndent(fsExp2cpp3(e3, gctx)) + 
			")";
		}
		FsCallPrim(op, es, type): fsCallPrim2cpp3(e, gctx);
		FsVar(name, type, local): {
			var = gctx.varname2cpp(name);
			if (local) var else {
				switch (lookupTree(gctx.program.names.toplevel, name)) {
					Some(decl): {
						external_func_var = \fn_type -> {
							switch (type) {
								FiTypeFunction(args, ret_type): {
									typars_instances = fiMatchTyparsOrdered(fn_type, type);
									typars = if (length(typars_instances) == 0) "" else {
										"<" + superglue(typars_instances, \tp -> fiType2cpp3(tp, gctx), ", ") + ">";
									}
									wrap = "std::function<" + fiType2cpp3(ret_type, gctx) + "(" + 
									superglue(args, \t -> fiType2cpp3(t.type, gctx), ", ") + ")>(" + var + typars + ")";
									fun = fiType2cpp3(type, gctx);
									fun + "(" + wrap + ")";
								}
								default: {
									fail0(
										"non-func type:\n" + toStringFormatted(type) + "\n" +
										"for func type:\n" + toStringFormatted(fn_type) + "\n" +
										"expr:\n" + toStringFormatted(e) + "\n"
									);
								}
							}
						}
						switch (decl) {
							FiFunctionDec(__,__, fn_type, __,__): {
								external_func_var(fn_type);
							}
							FiNativeDec(__,__, fn_type, __,__,__,__): {
								switch (fn_type) {
									FiTypeFunction(as, ret): {
										external_func_var(fn_type);
									}
									default: var;
								}
							}
							default: var;
						}
					}
					None(): var;
				}
			}
		}
		FsRequire(flowfile, ex, type): fail0("//TODO: FsRequire is not implemented in cpp3 backend" + flowfile);
		FsUnsafe(name, fallback, type): fail0("//TODO: FsUnsafe is not implemented in cpp3 backend" + name);
	}
}

fsCallPrimPlus2cpp3(es : [FsExp], gctx : Cpp3GlobalContext, acc: [FsExp]) -> [FsExp] {
	fold(es, acc, \ac, e -> {
		switch (e) {
			FsCallPrim(op, es1, __): {
				switch (e.op) {
					FcPlusPrim(): fsCallPrimPlus2cpp3(es1, gctx, ac);
					default: concat(ac, [e]);
				}
			}
			default: concat(ac, [e]);
		}
	});
}

fsCallPrimMult2cpp3(es : [FsExp], gctx : Cpp3GlobalContext, acc: [FsExp]) -> [FsExp] {
	fold(es, acc, \ac, e -> {
		switch (e) {
			FsCallPrim(op, es1, __): {
				switch (e.op) {
					FcMulPrim(): fsCallPrimMult2cpp3(es1, gctx, ac);
					default: concat(ac, [e]);
				}
			}
			default: concat(ac, [e]);
		}
	});
}

fsCallPrim2cpp3(e : FsCallPrim, gctx : Cpp3GlobalContext) -> string {
	e2k = \x -> fsExp2cpp3(x, gctx);
	arg_type = if (length(e.es) > 0) fsExpType(e.es[0]) else FiTypeVoid();
	switch (e.op) {
		FcOrPrim():  "(" + e2k(e.es[0]) + " || " + e2k(e.es[1]) + ")";
		FcAndPrim(): "(" + e2k(e.es[0]) + " && " + e2k(e.es[1]) + ")";
		FcNotPrim(): "!" + e2k(e.es[0]);

		FcEqPrim():  "(Compare<" + fiType2cpp3(arg_type, gctx) + ">::cmp(" + e2k(e.es[0]) + ", " + e2k(e.es[1]) + ") == 0)";
		FcNePrim():  "(Compare<" + fiType2cpp3(arg_type, gctx) + ">::cmp(" + e2k(e.es[0]) + ", " + e2k(e.es[1]) + ") != 0)";
		FcLePrim():  "(Compare<" + fiType2cpp3(arg_type, gctx) + ">::cmp(" + e2k(e.es[0]) + ", " + e2k(e.es[1]) + ") <= 0)";
		FcGePrim():  "(Compare<" + fiType2cpp3(arg_type, gctx) + ">::cmp(" + e2k(e.es[0]) + ", " + e2k(e.es[1]) + ") >= 0)";
		FcLtPrim():  "(Compare<" + fiType2cpp3(arg_type, gctx) + ">::cmp(" + e2k(e.es[0]) + ", " + e2k(e.es[1]) + ") < 0)";
		FcGtPrim():  "(Compare<" + fiType2cpp3(arg_type, gctx) + ">::cmp(" + e2k(e.es[0]) + ", " + e2k(e.es[1]) + ") > 0)";

		FcPlusPrim():  {
			plus_args = fsCallPrimPlus2cpp3(e.es, gctx, []);
			if (e.type == FiTypeString()) {
				"makeString(" + superglue(plus_args, \x -> "*" +e2k(x), " + ") + ")";
			} else {
				"(" + superglue(plus_args, e2k, " + ") + ")";
			}
		}
		FcMinusPrim(): "(" + e2k(e.es[0]) + " - " + e2k(e.es[1]) + ")"; 
		FcMulPrim(): {
			mult_args = fsCallPrimMult2cpp3(e.es, gctx, []);
			"(" + superglue(mult_args, e2k, " * ") + ")";
		}
		FcDivPrim():   "(" + e2k(e.es[0]) + " / " + e2k(e.es[1]) + ")";
		FcModPrim(): {
			if (e.type == FiTypeDouble()) {
				"fmod(" + e2k(e.es[0]) + ", " + e2k(e.es[1]) + ")";
			} else {
				"(" + e2k(e.es[0]) + " % " + e2k(e.es[1]) + ")";
			}
		}
		FcNegPrim():   "-" + e2k(e.es[0]);
		FcArrayPrim(): {
			arr_type = fiDearrayType(e.type);
			if (length(e.es) == 0) {
				"Arr<" + fiType2cpp3(arr_type, gctx) + ">::makeEmpty()";
			} else {
				arr_s = map(e.es, e2k);
				if (length(arr_s) < 8 && !exists(arr_s, \s -> strContains(s, "\n"))) {
					"Arr<" + fiType2cpp3(arr_type, gctx) + ">{" + strGlue(arr_s, ", ") + "}";
				} else {
					"Arr<" + fiType2cpp3(arr_type, gctx) + ">{\n" + strIndent(strGlue(arr_s, ",\n")) + "\n}";
				}
			}
		}
		FcIndexPrim(): {
			switch (arg_type) {
				FiTypeFlow(): {
					e2k(e.es[0]) + "->toArray()->element(" + e2k(e.es[1]) + ")";
				}
				default:
					"(" + e2k(e.es[0]) + "->vect.at(" + e2k(e.es[1]) + "))";
			}
		}
		FcDerefPrim(): {
			switch (arg_type) {
				FiTypeFlow(): {
					e2k(e.es[0]) + "->toReference()->reference()";
				}
				default: {
					"(*" +e2k(e.es[0]) + "->val)";
				}
			}
		}
		FcAssignPrim(): {
			switch (arg_type) {
				FiTypeFlow(): {
					e2k(e.es[0]) + "->toReference()->set(" + e2k(e.es[1]) + ")";
				}
				default: {
					"(*" + e2k(e.es[0]) + "->val = " + e2k(e.es[1]) + ")";
				}
			}
		}
		FcRefPrim(): {
			ref_type = fiDerefType(e.type);
			"Ref<" + fiType2cpp3(ref_type, gctx) + ">(" + e2k(e.es[0]) + ")";
		}
		FcStructPrim(struct_name): {
			struct_type = cast(e.type : FiType -> FiTypeName);
			struct_full_name = fiStructName2cpp3(struct_type, gctx);
			"Str<" + struct_full_name + ">(makePtr<" + struct_full_name + ">(" + strGlue(map(e.es, e2k), ", ") + "))";
		}
		FcFieldPrim(name): {
			if (name == "structname") {
				switch (arg_type) {
					FiTypeName(typename, params): {
						if (containsKeyTree(gctx.program.names.structs, typename)) {
							"makeString(\"" + typename + "\")";
						} else {
							e2k(e.es[0]) + ".toAStruct()->name()";
						}
					}
					FiTypeFlow(): {
						e2k(e.es[0]) + ".toAStruct()->name()";
					}
					default: fail0("accees to field '" + name + "' of non-field: " + fsExp2s(e.es[0]));
				}
			} else {
				switch (arg_type) {
					FiTypeFlow(): {
						e2k(e.es[0]) + ".toAStruct()->field(makeString(\"" + name + "\"))";
					}
					default: e2k(e.es[0]) + "->" + gctx.varname2cpp(name);
				}
			}
		}
		FcSetMutablePrim(name): {
			switch (arg_type) {
				FiTypeFlow(): {
					e2k(e.es[0]) + ".toAStruct()->setField(" + gctx.varname2cpp(name) + ", " + e2k(e.es[1]) + ")";
				}
				default: e2k(e.es[0]) + "->" + gctx.varname2cpp(name) + " = " + e2k(e.es[1]);
			}
		}
		FcCreateClosurePrim(structName, functionName): fail0("// TODO: FcCreateClosurePrim");
		FcQuote():   fail0("// TODO: implement FcQuote in cpp3 backend");
		FcUnquote(): fail0("// TODO: implement FcUnquote in cpp3 backend");
	}
}

fiCpp3Cast(from: FiType, to: FiType, s: string, gctx: Cpp3GlobalContext) -> string {
	if (fiEqualTypes(from, to)) s else
	"Cast<" + fiType2cpp3(from, gctx) + ">::template To<" + fiType2cpp3(to, gctx) + ">::conv(" + s + ")";
}
