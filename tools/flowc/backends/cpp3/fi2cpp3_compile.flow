import tools/flowc/backends/cpp3/fi2cpp3_runtime;
import tools/flowc/statements/fi2fs;
import tools/flowc/manipulation/eliminate_union_fields;

export {
	cpp3MainFunc(gctx: Cpp3GlobalContext) -> string;
	fiModule2cpp3(module : FiModule, gctx: Cpp3GlobalContext) -> string;
}

cpp3MainFunc(gctx: Cpp3GlobalContext) -> string {
	init = strGlue(^(gctx.volatileInit), "\n");
	struct_defs = fiCpp3StructDefs(gctx);
	blueprint("

using namespace flow;
using namespace %prog_namespace%;

%struct_defs%

int main(int argc, const char* argv[]) {
	for (int i = 1; i < argc; ++ i) {
		std::string arg(argv[i]);
		int eq_ind = arg.find(\"=\");
		if (eq_ind == std::string::npos) {
			command_args[fromStdString(arg)] = fromStdString(\"\");
		} else {
			std::string key = arg.substr(0, eq_ind);
			std::string val = arg.substr(eq_ind + 1, arg.size() - eq_ind - 1);
			command_args[fromStdString(key)] = fromStdString(val);
		}
	}
	init_struct_defs();
	%init%
	%main%();
	return exit_code;
}

", [
	"init", init, 
	"struct_defs", struct_defs,
	"main", gctx.varname2cpp("main"),
	"prog_namespace", gctx.config.namespace
]);
}

fiModule2cpp3(module : FiModule, gctx: Cpp3GlobalContext) -> string {
	names = gctx.program.names;
	structs_decls = map(module.structs, \struct -> fiStruct2cpp3(struct, gctx, true));
	structs_defs = map(module.structs, \struct -> fiStruct2cpp3(struct, gctx, false));
	defs1 = \only_decls -> filtermap(module.initOrder, \name -> {
		switch (find(module.globalVars, \gv -> gv.name == name)) {
			Some(globalVar): {
				if (only_decls) None() else Some(fiGlobalVar2cpp3(globalVar, gctx));
			}
			None(): {
				maybeBind(find(module.functions, \fn -> fn.name == name), \fun ->
					if (fiCpp3IsNative(name)) None() else Some(fiFunc2cpp3(fun, gctx, only_decls))
				);
			}
		}
	});
	missing_natives = ref [];
	defs2 = filtermap(module.natives, \nat -> {
		if (nat.name == "for") {
			// 'for' is a special native, used in tail call optimization, i.e. it is moved to main runtime
			None();
		} else {
			cpp3_nat = lookupTree(fiCpp3NativeFuncs, nat.name);
			if (!fiCpp3IsNative(nat.name) && !contains(module.initOrder, nat.name)) {
				refArrayPush(missing_natives, nat.name);
			}
			maybeMap(cpp3_nat, \nat_fn -> nat_fn(gctx));
		}
	});
	if (^missing_natives != []) {
		err = "Module " + module.fileinfo.flowfile + ": following native functions are not implemented in cpp3 runtime and doesn't have a flow fallbacks:\n" +
			strIndent(superglue(^missing_natives, \name -> "\t" + name, "\n"));
		gctx.errors := concat(^(gctx.errors), [err]);
		fcPrintln(err, gctx.config.threadId);
	}
	all = concatA([structs_decls, structs_defs, defs2, defs1(true), defs1(false)]);
	(if (exists(module.functions, \fn -> fn.name == "main")) "" else "#pragma once\n") +
	"#inc" + "lude \"flow_runtime.hpp\"\n" +
	"// Module " + module.fileinfo.flowfile + "\n\n" + 
	(if (gctx.config.monolith) "" else concatStrings(map(module.imports, \imp -> "#inc" + "lude \"" + strReplace(imp.flowfile, "/", "_") + ".hpp\"\n")) + "\n") +
	"namespace " + gctx.config.namespace + " {\n" +
	"using namespace flow;\n\n" + 
	concatStrings(all) + "\n}\n";
}

fiStructName2cpp3(tn : FiTypeName, gctx: Cpp3GlobalContext) -> string {
	gctx.typename2cpp(tn.name) + if (tn.typeparameters == []) "" else "<" + superglue(tn.typeparameters, \tp -> fiType2cpp3(tp, gctx), ", ") + ">";
}

fiDeclTypars2cpp3(types : [FiType], gctx : Cpp3GlobalContext) -> string {
	typars_names = sort(set2array(fold(types, makeSet(), \acc, type -> fiCollectTypars(type, acc))));
	typars = map(typars_names, \n -> FiTypeParameter(n));
	if (typars == []) "" else "template <" + superglue(typars, \tp -> "typename " + gctx.typar2cpp(tp), ", ") + ">\n";
}

fiStruct2cpp3(struct: FiTypeStruct, gctx: Cpp3GlobalContext, only_decl: bool) -> string {
	struct_name = gctx.typename2cpp(struct.name);
	names = gctx.program.names;
	typars = struct.typars;
	decl_typars = fiDeclTypars2cpp3(typars, gctx);
	if (only_decl) {
		decl_typars + "struct " + struct_name + ";\n\n";
	} else {
		getter = \union, field -> 
			"\t" + fiType2cpp3(field.type, gctx) + " get_" + union + "_" + field.name + "() override { return " + gctx.varname2cpp(field.name) + "; }\n";
		setter = \union, field -> 
			"\tvoid set_" + union + "_" + field.name + "(" + fiType2cpp3(field.type, gctx) + " ___x___) override { " + gctx.varname2cpp(field.name) + " = ___x___; }\n";
		field_interface = \union, field -> getter(union, field) + if (!field.ismutable) "" else setter(union, field);

		constructor_init = if (struct.args == []) "" else {
			": " + superglue(struct.args, \arg -> gctx.varname2cpp(arg.name) + "(__" + gctx.varname2cpp(arg.name) + ")", ", ");
		}
		constructor = "\t" + struct_name + 
		"(" + 
			superglue(struct.args, \arg -> fiType2cpp3(arg.type, gctx) + " __" + gctx.varname2cpp(arg.name), ", " ) + 
		") " + constructor_init + " { }\n";

		copy_constructor = if (struct.args == []) "" else 
		"\t" + struct_name + "(const " + struct_name + "& s): " + 
			superglue(struct.args, \arg -> gctx.varname2cpp(arg.name) + "(s." + gctx.varname2cpp(arg.name) + ")", ", " ) + 
		" { }\n";
		move_constructor = if (struct.args == []) "" else 
		"\t" + struct_name + "(" + struct_name + "&& s): " + 
			superglue(struct.args, \arg -> gctx.varname2cpp(arg.name) + "(std::move(s." + gctx.varname2cpp(arg.name) + "))", ", " ) + 
		" { }\n";

		assignment_operator = if (struct.args == []) "" else 
		"\t" + struct_name + "& operator = (const " + struct_name + "& s) { " + 
			superglue(struct.args, \arg -> gctx.varname2cpp(arg.name) + " = s." + gctx.varname2cpp(arg.name) + ";", " " ) + 
		" return *this; }\n";
		assignment_move = if (struct.args == []) "" else 
		"\t" + struct_name + "& operator = (" + struct_name + "&& s) { " + 
			superglue(struct.args, \arg -> gctx.varname2cpp(arg.name) + " = std::move(s." + gctx.varname2cpp(arg.name) + ");", " " ) + 
		" return *this; }\n";

		fields = concatStrings(map(struct.args, \arg -> 
			"\t" + fiType2cpp3(arg.type, gctx) + " " + gctx.varname2cpp(arg.name) + ";\n"));
		compare1 = "Int compare(const Struct& s) const override {\n" +
			"\tInt c = name()->compare(*s.name());\n" + 
			"\treturn (c != 0) ? c : compare(dynamic_cast<const " + struct_name + "&>(s));\n" + 
		"\n}";
		compare2 = "Int compare(const " + struct_name + "& s) const {\n" +
			concatStrings(mapi(struct.args, \i, arg ->
				"\tInt c" + i2s(i) + " = Compare<" + fiType2cpp3(arg.type, gctx) + ">::cmp(" + gctx.varname2cpp(arg.name) + ", " + gctx.varname2cpp(arg.name) + "); " + 
				"if (c" + i2s(i) + " != 0) return c" + i2s(i) + ";\n",
			)) + 
			"\treturn 0;"
		"\n}";

		decl_typars + "struct " + struct_name + ": public Struct {\n" +
		constructor + 
		//(if (copy_constructor == "") "" else copy_constructor) +
		(if (move_constructor == "") "" else move_constructor) +
		//(if (assignment_operator == "") "" else assignment_operator) +
		//(if (assignment_move == "") "" else assignment_move) +
		"\tInt id() const override { return " + i2s(lookupTreeDef(gctx.structs2id, struct.name, -1)) + "; }\n" +
		"\tString name() const override { return makeString(\"" + struct.name + "\"); }\n" +
		"\tInt size() const override { return " + i2s(length(struct.args)) + "; }\n" +
		"\tstd::vector<Flow> fields() override { return std::vector<Flow>{" + superglue(struct.args, \arg -> "ToFlow<" + fiType2cpp3(arg.type, gctx) + ">::conv(" + gctx.varname2cpp(arg.name) + ")", ", ") + "}; }\n" +
		strIndent(compare1) + "\n" + 
		strIndent(compare2) + "\n" + 
		(if (fields == "") "" else fields) +
		"};\n\n";
	}
}

fiGlobalVar2cpp3(globalVar : FiGlobalVar, gctx: Cpp3GlobalContext) -> string {
	names = gctx.program.names;
	value0 = fiEliminateUnionFields(globalVar.value, names, 0);
	value1 = fiExpSSA(value0);
	value2 = fiExplisitCastInSwitch(value1, names);
	value = fiFixVarInSameStructType(value2, makeTree(), names);
	pair = fiExp2FsExp(value, makeSet(), names);

	value_exp = if (pair.second == []) pair.first else {
		FsCall(FsLambda([], [], 
			fsWrapSeq(concat(pair.second, [FsRet(pair.first)])), 
			FiTypeFunction([], globalVar.type
			)
		), [], globalVar.type);
	}
	init = gctx.varname2cpp(globalVar.name) + " = " + fsExp2cpp3(value_exp, gctx) + ";";
	if (containsSet(gctx.volatileVars, globalVar.name)) {
		gctx.volatileInit := concat(^(gctx.volatileInit), [init]);
	}
	fiType2cpp3(globalVar.type, gctx) + " " + init + ";\n\n";
}

fiFunc2cpp3(fun: FiFunctionDec, gctx: Cpp3GlobalContext, only_decl: bool) -> string {
	name = fun.name;
	fn_type = fun.type;
	names = gctx.program.names;
	lambda0 = fiEliminateUnionFields(fun.lambda, gctx.program.names, 0);
	lambda1 = fiExplisitCastInSwitch(lambda0, gctx.program.names);
	lambda2 = fiEliminateUnionFields(lambda1, gctx.program.names, 0);
	lambda3 = fiExpSSA(lambda2);
	lambda4 = fiFixVarInSameStructType(
		lambda3, 
		fold(fn_type.args, makeTree(), \acc, arg -> 
			setTree(acc, arg.name, FiVar(arg.name, arg.type, 0))
		), 
		names
	);
	lambda5 = cast(lambda4: FiExp -> FiLambda);
	lambda = if (fiEqualTypes(fun.type.returnType, lambda5.type.returnType)) lambda5 else {
		FiLambda(lambda5 with 
			body = FiCast(lambda5.body, lambda5.type.returnType, fun.type.returnType, fun.type.returnType, lambda4.start)
		);
	}
	fun_typars = set2array(fiTypeTypars(makeSet(), fn_type));
	decl_typars = fiDeclTypars2cpp3(fun_typars, gctx);
	fun_stat = fiExp2FsStat(
		lambda.body, FsReturnToOuter(), 
		fold(lambda.args, makeSet(), \acc, arg -> 
			if (arg.name == "__") acc else insertSet(acc, arg.name)
		),
		names
	);
	fun_body = " " + fiWrapWithBraces(fsStat2cpp3(fun_stat, gctx));
	fun_name = gctx.varname2cpp(name);
	fun_signature = fiType2cpp3(fn_type.returnType, gctx) + " " + fun_name + "(" + 
		superglue(lambda.args, \arg -> fiType2cpp3(arg.type, gctx) + " " + gctx.varname2cpp(arg.name), ", ") + 
	")";
	decl_typars + fun_signature + (if (only_decl) ";" else fun_body) + "\n\n";
}

fiType2cpp3(t : FiType, gctx: Cpp3GlobalContext) -> string {
	switch (t) {
		FiTypeArray(arr): {
			"Arr<" + fiType2cpp3(arr, gctx) + ">";
		}
		FiTypeFunction(args, retType): {
			"Fun<" + superglue(concat([retType], map(args, \arg -> arg.type)), \tp -> fiType2cpp3(tp, gctx) , ", ") + ">";
		}
		FiTypeRef(tp):        "Ref<" + fiType2cpp3(tp, gctx) + ">";
		FiTypeParameter(nm):  "T" + i2s(strlen(nm));
		FiTypeBool():         "Bool";
		FiTypeInt():          "Int";
		FiTypeDouble():       "Double";
		FiTypeString():       "String";
		FiTypeFlow():         "Flow";
		FiTypeVoid():         "Void";
		FiTypeNative():       "Nat<void>";
		FiTypeName(name, typars):  {
			if (containsKeyTree(gctx.program.names.structs, name)) {
				"Str<" + fiStructName2cpp3(t, gctx) + ">";
			} else {
				"Union";
			}
		}
	}
}

fsStat2cpp3(stat : FsStat, gctx: Cpp3GlobalContext) -> string {
	switch (stat) {
		FsLet(name, vtype, e): {
			if (name == "__") "" else {
				fiType2cpp3(vtype, gctx) + " " + gctx.varname2cpp(name) + " = " + fsExp2cpp3(e, gctx) + ";";
			}
		}
		FsIf(cond, pos, neg, type): {
			"if " + fiWrapWithPars(fsExp2cpp3(cond, gctx)) + " {\n" + 
				strIndent(fsStat2cpp3(pos, gctx)) + 
			"\n} else {\n" + 
				strIndent(fsStat2cpp3(neg, gctx)) + 
			"\n}";
		}
		FsSwitch(x, cases, type): {
			typename = getFiTypeName(x.type);
			switch (lookupTree(gctx.program.names.unions, typename)) {
				Some(union): {
					case2k = \c -> {
						switch (lookupTree(gctx.program.names.structs, c.struct)) {
							Some(struct): {
								typars = if (length(struct.typars) == 0) "" else 
									"<" + superglue(struct.typars, \typar-> fiType2cpp3(typar, gctx), ", ") + ">";
								name = gctx.typename2cpp(c.struct) + typars;
								args_to_wrap = filtermapi(c.args, \i, arg -> {
									arg_type = struct.args[i].type;
									arg_typars = set2array(fiTypeTypars(makeSet(), arg_type));
									if (arg_typars == []) None() else Some(Pair(arg, arg_type));
								});
								vars_wrapped = if (args_to_wrap == []) c.body else fsWrapCaseVarsWithCasts(c.body, args_to_wrap);
								body1 = fsStat2cpp3(vars_wrapped, gctx);
								id = lookupTreeDef(gctx.structs2id, c.struct, -1);
								"case " + i2s(id) + " /*" + c.struct + "*/: {\n" +
									strIndent(body1) + "\n\tbreak;"
								"\n}";

							}
							None(): {
								// default case
								if (c.struct != "default") fail0("struct is not found") else {
									body1 = fsStat2cpp3(c.body, gctx);
									strIndent("default: {\n" + strIndent(body1)) + "\n}";
								}
							}
						}
					}
					nondef_cases = filtermap(cases, \c ->
						if (c.struct == "default") None() else Some(case2k(c))
					);
					all_cases = switch (find(cases, \case -> case.struct == "default")) {
						Some(def_case): {
							concat(nondef_cases, [case2k(def_case)]);
						}
						None(): {
							redundant_defcase = if (gctx.config.monolith) [] else 
								["default: {\n" + 
									strIndent("assert(false && \"unexpected case in switch\");\nbreak;") + 
								"\n}"];
							concat(nondef_cases, redundant_defcase);
							//nondef_cases;
						}
					}
					"switch (" + gctx.varname2cpp(x.name) + "->id()) {\n" +
						superglue(all_cases, \case -> strIndent(case), "\n") +
					"\n}";
				}
				None(): {
					switch (lookupTree(gctx.program.names.structs, typename)) {
						Some(struct): {
							switch (find(cases, \case -> case.struct == typename)) {
								Some(c): {
									typars = if (length(struct.typars) == 0) "" else 
										"<" + superglue(struct.typars, \typar-> fiType2cpp3(typar, gctx), ", ") + ">";
									name = gctx.typename2cpp(c.struct) + typars;
									args_to_wrap = filtermapi(c.args, \i, arg -> {
										arg_type = struct.args[i].type;
										arg_typars = set2array(fiTypeTypars(makeSet(), arg_type));
										if (arg_typars == []) None() else Some(Pair(arg, arg_type));
									});
									vars_wrapped = if (args_to_wrap == []) c.body else fsWrapCaseVarsWithCasts(c.body, args_to_wrap);
									body1 = fsStat2cpp3(vars_wrapped, gctx);
									body1;
								}
								None(): {
									fail0("struct case is not found");
								}
							}
						}
						None(): {
							fail0("must be struct or union (type name)");
						}
					}
				}
			}			
		}
		FsSeq(es, type): {
			if (length(es) == 0) "" else
			if (length(es) == 1) fsStat2cpp3(es[0], gctx) else 
			fiWrapWithBraces(superglue(es, \x -> fsStat2cpp3(x, gctx), "\n"));
		}
		FsWrap(e): fsExp2cpp3(e, gctx) + ";";
		FsRet(e): {
			e_s = fsExp2cpp3(e, gctx);
			(if (fsExpType(e) == FiTypeVoid()) e_s else "return " + e_s) + ";"
		}
		FsVarDecl(var): {
			fiType2cpp3(var.type, gctx) + " " + gctx.varname2cpp(var.name) + ";";
		}
		FsAssign(var, e): {
			gctx.varname2cpp(var.name) + " = " + fsExp2cpp3(e, gctx) + ";";
		}
	};
}

fsExp2cpp3(e : FsExp, gctx: Cpp3GlobalContext) -> string {
	switch (e) {
		FiVoid(__):      "";
		FiBool(b, __):   b2s(b);
		FiInt(i, __):    i2s(i);
		FiDouble(d, __): { 
			s = d2s(d);
			if (strContains(s, ".")) s else s + ".0";
		}
		FiString(s, __): "makeString(\"" + escapeStr(s) + "\")";
		FsCast(ex, from, to): {
			s = fsExp2cpp3(ex, gctx);
			fiCpp3Cast(from, to, s, gctx);
		}
		FsCall(f, args, type): {
			f_type = cast(fsExpType(f): FiType -> FiTypeFunction);
			s_args = mapi(args, \i, arg -> {
				arg_type = fsExpType(arg);
				call_type = f_type.args[i].type;
				arg_s = fsExp2cpp3(arg, gctx);
				fiCpp3Cast(arg_type, call_type, arg_s, gctx);
			});
			switch(f) {
				FiVar(name, __,__): {
					toplevel: Maybe<FiDeclaration> = lookupTree(gctx.program.names.toplevel, name);
					typars = switch (toplevel) {
						Some(fn): {
							typars_instances = fiMatchTyparsOrdered(fn.type, f_type);
							if (length(typars_instances) == 0) "" else {
								"<" + superglue(typars_instances, \tp -> fiType2cpp3(tp, gctx), ", ") + ">";
							}
						}
						None(): "";
					}
					switch (lookupTree(fiCpp3NativeInlines, name)) {
						Some(inline): inline(s_args, f_type);
						None(): gctx.varname2cpp(name) + typars + "(" + strGlue(s_args, ", ") + ")";
					}
				}
				default: {
					fsExp2cpp3(f, gctx) + "(" + strGlue(s_args, ", ") + ")";
				}
			};
		}
		FsLambda(closure, args, body, type): {
			fun = fiType2cpp3(type, gctx);
			fun + "([" + superglue(closure, gctx.varname2cpp, ", ") + "] " + 
			"(" + superglue(args, \arg -> fiType2cpp3(arg.type, gctx) + " " + gctx.varname2cpp(arg.name), ", ") + ") " + 
			"{\n" + strIndent(fsStat2cpp3(body, gctx)) + "\n})";
		}
		FsTernary(e1, e2, e3, type): {
			"(" + fsExp2cpp3(e1, gctx) + " ? \n" + 
				strIndent(fsExp2cpp3(e2, gctx)) + 
			"\n : \n" + 
				strIndent(fsExp2cpp3(e3, gctx)) + 
			")";
		}
		FsCallPrim(op, es, type): fsCallPrim2cpp3(op, es, type, gctx);
		FiVar(name, type,__): {
			var = gctx.varname2cpp(name);
			switch (type) {
				FiTypeFunction(argts, rt): {
					if (fiIsGlobalFunction(name, gctx.program.names)) {
						"std::function<" + fiType2cpp3(rt, gctx) + "(" + 
						superglue(argts, \t -> fiType2cpp3(t.type, gctx), ", ") + ")>(" + var + ")";
					} else {
						var;
					}
				}
				default: var;
			}
		}
		FsRequire(flowfile, ex, type): fail0("//TODO: FiRequire " + flowfile);
		FsUnsafe(name, fallback, type): fail0("//TODO: FiUnsafe " + name);
	};
}

fsCallPrim2cpp3(op : FcPrim, es : [FsExp], type : FiType, gctx : Cpp3GlobalContext) -> string {
	e2k = \e -> fsExp2cpp3(e, gctx);
	arg_type = if (length(es) > 0) fsExpType(es[0]) else FiTypeVoid();
	switch (op) {
		FcOrPrim():  "(" + e2k(es[0]) + " || " + e2k(es[1]) + ")";
		FcAndPrim(): "(" + e2k(es[0]) + " && " + e2k(es[1]) + ")";
		FcNotPrim(): "!" + e2k(es[0]);

		FcEqPrim():  "(Compare<" + fiType2cpp3(arg_type, gctx) + ">::cmp(" + e2k(es[0]) + ", " + e2k(es[1]) + ") == 0)";
		FcNePrim():  "(Compare<" + fiType2cpp3(arg_type, gctx) + ">::cmp(" + e2k(es[0]) + ", " + e2k(es[1]) + ") != 0)";
		FcLePrim():  "(Compare<" + fiType2cpp3(arg_type, gctx) + ">::cmp(" + e2k(es[0]) + ", " + e2k(es[1]) + ") <= 0)";
		FcGePrim():  "(Compare<" + fiType2cpp3(arg_type, gctx) + ">::cmp(" + e2k(es[0]) + ", " + e2k(es[1]) + ") >= 0)";
		FcLtPrim():  "(Compare<" + fiType2cpp3(arg_type, gctx) + ">::cmp(" + e2k(es[0]) + ", " + e2k(es[1]) + ") < 0)";
		FcGtPrim():  "(Compare<" + fiType2cpp3(arg_type, gctx) + ">::cmp(" + e2k(es[0]) + ", " + e2k(es[1]) + ") > 0)";

		FcPlusPrim():  {
			if (type == FiTypeString()) {
				"makeString(*" + e2k(es[0]) + " + *" + e2k(es[1]) + ")";
			} else {
				"(" + e2k(es[0]) + " + " + e2k(es[1]) + ")";
			}
		}
		FcMinusPrim(): "(" + e2k(es[0]) + " - " + e2k(es[1]) + ")"; 
		FcMulPrim():   "(" + e2k(es[0]) + " * " + e2k(es[1]) + ")";
		FcDivPrim():   "(" + e2k(es[0]) + " / " + e2k(es[1]) + ")";
		FcModPrim(): {
			if (type == FiTypeDouble()) {
				"fmod(" + e2k(es[0]) + ", " + e2k(es[1]) + ")";
			} else {
				"(" + e2k(es[0]) + " % " + e2k(es[1]) + ")";
			}
		}
		FcNegPrim():   "-" + e2k(es[0]);
		FcArrayPrim(): {
			arr_type = fiDearrayType(type);
			"Arr<" + fiType2cpp3(arr_type, gctx) + ">{" + superglue(es, e2k, ", ") + "}";
		}
		FcIndexPrim(): {
			"(*" + e2k(es[0]) + ".arr)[" + e2k(es[1]) + "]";
		}
		FcDerefPrim():   "(*" +e2k(es[0]) + ".ref)";
		FcAssignPrim(): {
			ref_tp = fiDerefType(fsExpType(es[0]));
			val_tp = fsExpType(es[1]);
			"(*" + e2k(es[0]) + ".ref = " + fiCpp3Cast(val_tp, ref_tp, e2k(es[1]), gctx) + ")";
		}
		FcRefPrim(): {
			ref_type = fiDerefType(type);
			"Ref<" + fiType2cpp3(ref_type, gctx) + ">(" + e2k(es[0]) + ")";
		}
		FcStructPrim(struct_name): {
			struct_type = cast(type : FiType -> FiTypeName);
			struct_full_name = fiStructName2cpp3(struct_type, gctx);
			struct = lookupTreeDef(gctx.program.names.structs, struct_name, FiTypeStruct("", [], [], 0));
			s_args = mapi(es, \i, arg -> {
				sarg_type = fsExpType(arg);
				call_type = struct.args[i].type;
				arg_s = e2k(arg);
				fiCpp3Cast(sarg_type, call_type, arg_s, gctx);
			});
			"Str<" + struct_full_name + ">(new " + struct_full_name + "(" + strGlue(s_args, ", ") + "))";
		}
		FcFieldPrim(name): {
			if (name == "structname") {
				switch (arg_type) {
					FiTypeName(typename, params): {
						if (containsKeyTree(gctx.program.names.structs, typename)) {
							"makeString(\"" + typename + "\")";
						} else {
							e2k(es[0]) + "->name()";
						}
					}
					FiTypeFlow(): {
						"std::get<Ptr<Struct>>(" + e2k(es[0]) + ".val)->name()";
					}
					default: fail0("accees to field '" + name + "' of non-field: " + fsExp2s(es[0]));
				}
			} else {
				e2k(es[0]) + "->" + gctx.varname2cpp(name);
			}
		}
		FcSetMutablePrim(name): {
			e2k(es[0]) + "->" + gctx.varname2cpp(name) + " = " + e2k(es[1]);
		}
		FcCreateClosurePrim(structName, functionName): fail0("// TODO: FcCreateClosurePrim");
		FcQuote():   fail0("// TODO: FcQuote");
		FcUnquote(): fail0("// TODO: FcUnquote");
	}
}

fiCpp3StructDefs(gctx : Cpp3GlobalContext) -> string {
	struct_arg = \i, arg -> {
		arg_val = "__args.arr->at(" + i2s(i) + ")";
		arg_type = fiType2cpp3(fiTransformTypars(arg.type, \__ -> FiTypeFlow()), gctx);
		"FromFlow<" + arg_type + ">::conv(" + arg_val + ")";
	}
	struct_defs = map(getTreeValues(gctx.program.names.structs), \struct -> {
		typars = if (struct.typars == []) "" else "<" + superglue(struct.typars, \__ -> "Flow", ", ") + ">";
		struct_name = gctx.typename2cpp(struct.name) + typars;
		args = "(" + strGlue(mapi(struct.args, \i, arg -> struct_arg(i, arg)), ", ") + ")";
		wrapper = "Str<" + struct_name + ">";
		constructor = "[](Arr<Flow> __args) { return ToFlow<" + wrapper + ">::conv(" + wrapper + "(new " + struct_name + args + ")); }";
		fields = if (struct.args == []) "std::vector<FieldDef>()" else {
			"std::vector{" + 
				superglue(struct.args, \arg  -> 
					"FieldDef{fromStdString(\"" + arg.name + "\"), fromStdString(\"" + fiType2cpp3(arg.type, gctx) +"\"), " + b2s(arg.ismutable) + "}", 
					", "
				) + 
			"}";
		}
		struct_def = "StructDef{" + 
			i2s(lookupTreeDef(gctx.structs2id, struct.name, -1)) + ", " +
			constructor + ", " +
			fields +
		"}";
		"\tstruct_defs[fromStdString(\"" + struct.name + "\")] = " + struct_def + ";\n";
	});
"
void init_struct_defs() {\n" + 
	concatStrings(struct_defs) + 
"\n}\n";

}

fiCpp3Cast(from: FiType, to: FiType, s: string, gctx: Cpp3GlobalContext) -> string {
	if (fiEqualTypes(from, to)) s else 
	if (from == FiTypeFlow()) {
		to_typars = fiCollectTypars(to, makeSet());
		if (isEmptySet(to_typars)) {
			"FromFlow<" + fiType2cpp3(to, gctx) + ">::conv(" + s + ")";
		} else {
			s;
		}
	} else {
		static_cast = \s1 -> "static_cast<" + fiType2cpp3(to, gctx) + ">(" + s1 + ")";
		switch (to) {
			FiTypeVoid():       fail0("cast to void");
			FiTypeBool():       static_cast(s);
			FiTypeInt():        static_cast(s);
			FiTypeDouble():     static_cast(s);
			FiTypeString():     static_cast(s);
			FiTypeFlow():       "ToFlow<" + fiType2cpp3(from, gctx) + ">::conv(" + s + ")";
			FiTypeNative(): {
				s + ".cast<void>()";
			}
			FiTypeParameter(n): {
				/**switch (from) {
					FiTypeParameter(m): "struct2struct<" + fiType2cpp3(from, gctx) + ", " + fiType2cpp3(to, gctx) + ">(" + s + ")";
					default: s;
				}*/
				s;
			}
			FiTypeRef(rt): {
				s + ".cast<" + fiType2cpp3(rt, gctx)+  ">()";
			}
			FiTypeArray(at): {
				s + ".cast<" + fiType2cpp3(at, gctx)+  ">()";
			}
			FiTypeName(id_to, tp_to): {
				to_is_union = containsKeyTree(gctx.program.names.unions, id_to);
				switch (from) {
					FiTypeName(id_from, tp_from): {
						from_is_union = containsKeyTree(gctx.program.names.unions, id_from);
						if (to_is_union) {
							if (from_is_union) {
								s 
							} else {
								"struct2union<" + fiType2cpp3(from, gctx) + ">(" + s + ")";
							}
						} else {
							if (from_is_union) {
								"union2struct<" + fiType2cpp3(to, gctx) + ">(" + s + ")";
							} else {
								"struct2struct<" + fiType2cpp3(from, gctx) + ", " + fiType2cpp3(to, gctx) + ">(" + s + ")";
							}
						}
					}
					default: fail0("illegal case to struct");
				}
			}
			FiTypeFunction(args, rt): {
				signature = superglue(concat([rt], map(args, \arg -> arg.type)), \tp -> fiType2cpp3(tp, gctx) , ", ");
				s + ".template cast<" + signature+  ">()";
			}
		}
	}
}
