import tools/flowc/backends/cpp3/fi2cpp3_runtime;
import tools/flowc/statements/fi2fs;
import tools/flowc/statements/fs_utils;
import tools/flowc/manipulation/eliminate_union_fields;

export {
	fiModule2cpp3(module : FiModule, gctx: Cpp3GlobalContext) -> Cpp3CompiledModule;
	fiCompiledModule2cpp3header(module: Cpp3CompiledModule, gctx: Cpp3GlobalContext, runtime_parts: [Cpp3RuntimePart]) -> string;
	fiCompiledModule2cpp3source(module: Cpp3CompiledModule, gctx: Cpp3GlobalContext, runtime_parts: [Cpp3RuntimePart]) -> string;
	cpp3StructDefsRuntimePart(gctx: Cpp3GlobalContext) -> Cpp3RuntimePart;
}

fiModule2cpp3(module : FiModule, gctx: Cpp3GlobalContext) -> Cpp3CompiledModule {
	names = gctx.program.names;
	compiled_structs = map(module.structs, \struct -> 
		Cpp3CompiledDeclaration(struct.name, true, 
			fiStruct2cpp3(struct, gctx, true),
			fiStruct2cpp3(struct, gctx, false)
		)
	);
	//vars = filtermap(module.initOrder, \name -> find(module.globalVars, \gv -> gv.name == name));
	//funcs = filtermap(module.initOrder, \name -> find(module.functions, \fn -> fn.name == name));
	decls = concat(
		module.natives,
		filtermap(module.initOrder, \name -> {
			switch (find(module.globalVars, \gv -> gv.name == name)) {
				Some(globalVar): Some(globalVar);
				None(): find(module.functions, \fn -> fn.name == name);
			}
		})
	);
	compiled_decls = filtermap(decls, \decl -> fiDeclaration2cpp3(decl, gctx));
	is_main = exists(module.functions, \fn -> fn.name == "main");
	Cpp3CompiledModule(
		gctx.flowfile2cpp(module.fileinfo.flowfile),
		is_main,
		concat(compiled_structs, compiled_decls),
		map(module.imports, \imp -> imp.flowfile),
		fiModuleNatives2cpp3(module, gctx)
	);
}


fiModuleNatives2cpp3(module: FiModule, gctx: Cpp3GlobalContext) -> [Cpp3Native] {
	missing_natives = ref [];
	natives = filtermap(module.natives, \nat -> {
		if (nat.name == "for") {
			// 'for' is a special native, used in tail call optimization, i.e. it is moved to main runtime
			None();
		} else {
			if (!fiCpp3IsNative(nat.name, gctx) && !contains(module.initOrder, nat.name)) {
				refArrayPush(missing_natives, nat.name);
			}
			lookupTree(gctx.natives, nat.name);
		}
	});
	if (^missing_natives != []) {
		err = "Module " + module.fileinfo.flowfile + ": following native functions are not implemented in cpp3 runtime and doesn't have a flow fallbacks:\n" +
			strIndent(superglue(^missing_natives, \name -> "\t" + name, "\n"));
		refArrayPush(gctx.errors, err);
		fcPrintln(err, gctx.config.config.threadId);
	}
	natives;
}

cpp3InlineFunction(fn: FiFunctionDec) -> bool {
	if (!isEmptySet(fiCollectTypars(fn.type, makeSet()))) true else {
		if (!fiExpIsSimple(fn.lambda.body)) false else {
			fiExpAstNodesCount(fn.lambda.body) < 8;
		}
	}
}

fiDeclaration2cpp3(decl: FiDeclaration, gctx: Cpp3GlobalContext) -> Maybe<Cpp3CompiledDeclaration> {
	switch (decl) {
		FiGlobalVar(name, value, type,__,__): {
			Some(fiGlobalVar2cpp3(decl, gctx));
		}
		FiFunctionDec(name, lambda, type,__,__): {
			if (fiCpp3IsNative(name, gctx)) None() else {
				Some(fiFunc2cpp3(decl, gctx));
			}
		}
		FiNativeDec(name, __,type,__, fallback,__,__): {
			if (name == "for") None() else {
				maybeMap(lookupTree(gctx.natives, name), \nat -> 
					nat.declaration(gctx.typename2cpp, gctx.varname2cpp)
				);
			}
		}
	}
}

cpp3MainFunc(gctx: Cpp3GlobalContext, runtime_parts: [Cpp3RuntimePart]) -> string {
	init = strGlue(^(gctx.volatileInit), "\n");
	mainInits = superglue(runtime_parts, \part -> part.mainInit, "\n");
	mainTerms = superglue(runtime_parts, \part -> part.mainTerm, "\n");
	sources = superglue(runtime_parts, \part -> part.source, "\n");
"using namespace flow;
using namespace " + gctx.config.namespace + ";\n\n" +
(if (sources == "") "" else sources + "\n") +
"int main(int argc, const char* argv[]) {\n" +
(if (mainInits == "") "" else strIndent(mainInits) + "\n") +
(if (init == "") "" else strIndent(init) + "\n") +
"\t" + gctx.varname2cpp("main") + "();\n" +
(if (mainTerms == "") "" else strIndent(mainTerms) + "\n") +
"\treturn 0;\n}\n";
}

fiCompiledModule2cpp3header(module: Cpp3CompiledModule, gctx: Cpp3GlobalContext, runtime_parts: [Cpp3RuntimePart]) -> string {
	includes = superglue(
		fiCpp3DependenciesIncludes(map(module.natives, \nat -> nat.dependencies)), 
		\inc -> "#inc" + "lude " + inc, 
		"\n"
	);
	forward_decls = map(module.decls, \decl -> decl.forward);
	header_defs = filtermap(module.decls, \decl -> if (decl.headerOnly) Some(decl.definition) else None());
	"#pragma once\n" +
	(if (includes == "") "" else includes + "\n") +
	"#inc" + "lude \"__flow_runtime.hpp\"\n" +
	"// Module " + module.name + "\n\n" + 
	(if (gctx.config.monolith) "" else concatStrings(map(module.imports, \imp -> "#inc" + "lude \"" + strReplace(imp, "/", "_") + ".hpp\"\n")) + "\n") +
	"namespace " + gctx.config.namespace + " {\n" +
	"using namespace flow;\n\n" + 
	concatStrings(forward_decls) + "\n" + 
	concatStrings(header_defs) + "\n" + 
	"}\n";
}

fiCompiledModule2cpp3source(module: Cpp3CompiledModule, gctx: Cpp3GlobalContext, runtime_parts: [Cpp3RuntimePart]) -> string {
	source_defs = filtermap(module.decls, \decl -> if (!decl.headerOnly) Some(decl.definition) else None());
	if (length(source_defs) == 0 && !module.isMain) "" else {
		"#inc" + "lude \"" + module.name + ".hpp\"\n" +
		"namespace " + gctx.config.namespace + " {\n" +
		"using namespace flow;\n\n" + 
		concatStrings(source_defs) + "\n" +
		"}\n" +
		if (module.isMain) cpp3MainFunc(gctx, runtime_parts) else "";
	}
}

fiStructName2cpp3(tn : FiTypeName, gctx: Cpp3GlobalContext) -> string {
	gctx.typename2cpp(tn.name) + if (tn.typeparameters == []) "" else "<" + superglue(tn.typeparameters, \tp -> fiType2cpp3(tp, gctx), ", ") + ">";
}

fiDeclTypars2cpp3(types : [FiType], gctx : Cpp3GlobalContext) -> string {
	typars_names = sort(set2array(fold(types, makeSet(), \acc, type -> fiCollectTypars(type, acc))));
	typars = map(typars_names, \n -> FiTypeParameter(n));
	if (typars == []) "" else "template <" + superglue(typars, \tp -> "typename " + gctx.typar2cpp(tp), ", ") + ">\n";
}

fiStruct2cpp3(struct: FiTypeStruct, gctx0: Cpp3GlobalContext, only_decl: bool) -> string {
	gctx = Cpp3GlobalContext(
		gctx0 with currentToplevel = struct.name,
		toplevelTypars = fold(struct.typars, makeSet(), \acc, tp -> fiCollectTypars(tp, acc))
	);
	struct_name = gctx.typename2cpp(struct.name);
	names = gctx.program.names;
	typars = struct.typars;
	decl_typars = fiDeclTypars2cpp3(typars, gctx);
	if (only_decl) {
		decl_typars + "struct " + struct_name + ";\n\n";
	} else {
		getter = \union, field -> 
			"\t" + fiType2cpp3(field.type, gctx) + " get_" + union + "_" + field.name + "() override { return " + gctx.varname2cpp(field.name) + "; }\n";
		setter = \union, field -> 
			"\tvoid set_" + union + "_" + field.name + "(" + fiType2cpp3(field.type, gctx) + " ___x___) override { " + gctx.varname2cpp(field.name) + " = ___x___; }\n";
		field_interface = \union, field -> getter(union, field) + if (!field.ismutable) "" else setter(union, field);

		constructor_init = if (struct.args == []) "" else {
			": " + superglue(struct.args, \arg -> gctx.varname2cpp(arg.name) + "(__" + gctx.varname2cpp(arg.name) + ")", ", ");
		}
		constructor = "\t" + struct_name + 
		"(" + 
			superglue(struct.args, \arg -> fiType2cpp3(arg.type, gctx) + " __" + gctx.varname2cpp(arg.name), ", " ) + 
		") " + constructor_init + " { }\n";

		copy_constructor = if (struct.args == []) "" else 
		"\t" + struct_name + "(const " + struct_name + "& s): " + 
			superglue(struct.args, \arg -> gctx.varname2cpp(arg.name) + "(s." + gctx.varname2cpp(arg.name) + ")", ", " ) + 
		" { }\n";
		move_constructor = if (struct.args == []) "" else 
		"\t" + struct_name + "(" + struct_name + "&& s): " + 
			superglue(struct.args, \arg -> gctx.varname2cpp(arg.name) + "(std::move(s." + gctx.varname2cpp(arg.name) + "))", ", " ) + 
		" { }\n";

		assignment_operator = if (struct.args == []) "" else 
		"\t" + struct_name + "& operator = (const " + struct_name + "& s) { " + 
			superglue(struct.args, \arg -> gctx.varname2cpp(arg.name) + " = s." + gctx.varname2cpp(arg.name) + ";", " " ) + 
		" return *this; }\n";
		assignment_move = if (struct.args == []) "" else 
		"\t" + struct_name + "& operator = (" + struct_name + "&& s) { " + 
			superglue(struct.args, \arg -> gctx.varname2cpp(arg.name) + " = std::move(s." + gctx.varname2cpp(arg.name) + ");", " " ) + 
		" return *this; }\n";

		fields = concatStrings(map(struct.args, \arg -> 
			"\t" + (if (arg.ismutable) "mutable " else "") + fiType2cpp3(arg.type, gctx) + " " + gctx.varname2cpp(arg.name) + ";\n"));
		compare1 = "Int compare(const AStruct& s) const override {\n" +
			"\tInt c = name()->compare(*s.name());\n" + 
			"\treturn (c != 0) ? c : compare(dynamic_cast<const " + struct_name + "&>(s));\n" + 
		"\n}";
		compare2 = "Int compare(const " + struct_name + "& s) const {\n" +
			concatStrings(mapi(struct.args, \i, arg ->
				"\tInt c" + i2s(i) + " = Compare<" + fiType2cpp3(arg.type, gctx) + ">::cmp(" + gctx.varname2cpp(arg.name) + ", " + gctx.varname2cpp(arg.name) + "); " + 
				"if (c" + i2s(i) + " != 0) return c" + i2s(i) + ";\n",
			)) + 
			"\treturn 0;"
		"\n}";

		get_field = "Flow field(String name) override {\n" +
			(if (length(struct.args) == 0) {
				"\tassert(false && \"unkown field in struct\");\n" +
				"\treturn Flow();";
			} else {
				strIndent(
					supergluei(struct.args, 
						\i, arg -> {
							if (i == 0) {
								"if (toStdString(name) == \"" + arg.name + "\") {\n" +
									"\treturn ToFlow<" + fiType2cpp3(arg.type, gctx) + ">::conv(" + gctx.varname2cpp(arg.name) + ");" +
								"\n} "
							} else {
								"else if (toStdString(name) == \"" + arg.name + "\") {\n" +
									"\treturn ToFlow<" + fiType2cpp3(arg.type, gctx) + ">::conv(" + gctx.varname2cpp(arg.name) + ");" +
								"\n} "
							}
						}, "\n"
					) + "else {\n" +
						"\tassert(false && \"unkown field in struct\");\n" +
						"\treturn Flow();"
					"\n}"
				);
			}) +
		"\n}";

		set_field = "void setField(String name, Flow val) override {\n" +
			(if (length(struct.args) == 0) {
				"\tassert(false && \"unkown field in struct\");"
			} else {
				strIndent(
					supergluei(struct.args, 
						\i, arg -> {
							if (i == 0) {
								"if (toStdString(name) == \"" + arg.name + "\") {\n" +
									"\t" + gctx.varname2cpp(arg.name) + " = " + "FromFlow<" + fiType2cpp3(arg.type, gctx) + ">::conv(val);" +
								"\n} "
							} else {
								"else if (toStdString(name) == \"" + arg.name + "\") {\n" +
									"\t" + gctx.varname2cpp(arg.name) + " = " + "FromFlow<" + fiType2cpp3(arg.type, gctx) + ">::conv(val);" +
								"\n} "
							}
						}, "\n"
					) + "else {\n" +
						"\tassert(false && \"unkown field in struct\");" +
					"\n}"
				);
			}) +
		"\n}";

		decl_typars + "struct " + struct_name + ": public AStruct {\n" +
		constructor + 
		//(if (copy_constructor == "") "" else copy_constructor) +
		(if (move_constructor == "") "" else move_constructor) +
		//(if (assignment_operator == "") "" else assignment_operator) +
		//(if (assignment_move == "") "" else assignment_move) +
		"\tInt id() const override { return " + i2s(lookupTreeDef(gctx.structs2id, struct.name, -1)) + "; }\n" +
		"\tString name() const override { return makeString(\"" + struct.name + "\"); }\n" +
		"\tInt size() const override { return " + i2s(length(struct.args)) + "; }\n" +
		"\tstd::vector<Flow> fields() override { return std::vector<Flow>{" + superglue(struct.args, \arg -> "ToFlow<" + fiType2cpp3(arg.type, gctx) + ">::conv(" + gctx.varname2cpp(arg.name) + ")", ", ") + "}; }\n" +
		strIndent(get_field) + "\n" +
		strIndent(set_field) + "\n" +
		strIndent(compare1) + "\n" + 
		strIndent(compare2) + "\n" + 
		(if (fields == "") "" else fields) +
		"};\n\n";
	}
}

fiGlobalVar2cpp3(globalVar : FiGlobalVar, gctx0: Cpp3GlobalContext) -> Cpp3CompiledDeclaration {
	names = gctx0.program.names;
	name = globalVar.name;
	gctx = Cpp3GlobalContext(gctx0 with 
		currentToplevel = name,
		toplevelTypars = fiCollectTypars(globalVar.type, makeSet())
	);
	value0 = fiEliminateUnionFields(globalVar.value, names, 0);
	value1 = fiExplicitCastInSwitch(value0, names);
	value2 = fiFixVarInSameStructType(value1, makeTree(), names);
	value = value2;
	pair0 = fiExp2FsExp(value, makeSet(), names, ref 0);
	pair1 = Pair(
		fsMakeExpCastsExplicit(pair0.first, globalVar.type, names, true),
		map(pair0.second, \s -> fsMakeStatCastsExplicit(s, FiTypeVoid(), names))
	);
	pair2 = fold(pair1.second, Pair([], makeTree()), \acc, s -> {
		p = fsStatSSA(s, acc.second);
		stat = fsInterpolateTyparsStat(p.first, names);
		Pair(concat(acc.first, [stat]), p.second);
	});
	value3 = fsExpSSA(pair1.first, pair2.second);
	value4 = fsInterpolateTyparsExp(value3, names);
	pair = Pair(value4, pair2.first);

	value_exp = if (pair.second == []) pair.first else {
		/*if (name == "defaultPegActions") {
			println(
				//"globalVar.value:\n" + toStringFormatted(globalVar.value) +"\n----------\n" + 
				//"value3:\n" + toStringFormatted(value3) +"\n----------\n" + 
				//"value4:\n" + toStringFormatted(value4) +"\n----------\n" +
				"value:\n" + toStringFormatted(value) +"\n----------\n" + 
				"pair0:\n" + toStringFormatted(pair0) +"\n----------\n"
				//"pair1:\n" + toStringFormatted(pair1) +"\n----------\n" +
				//"pair2:\n" + toStringFormatted(pair2) +"\n----------\n" +
				//"pair.second:\n" + toStringFormatted(pair.second) +"\n----------\n"
			);
		}*/
		FsCall(FsLambda([], [], 
			fsWrapSeq(concat(pair.second, [FsRet(pair.first)])), 
			FiTypeFunction([], globalVar.type
			)
		), [], globalVar.type);
	}

	init = gctx.varname2cpp(name) + " = " + fsExp2cpp3(value_exp, gctx) + ";";
	if (containsSet(gctx.volatileVars, name)) {
		// Volatile variable
		gctx.volatileInit := concat(^(gctx.volatileInit), [init]);
		var_decl = fiType2cpp3(globalVar.type, gctx) + " " + gctx.varname2cpp(name) + ";\n\n";
		Cpp3CompiledDeclaration(name, false, "extern " + var_decl, var_decl);
	} else {
		// Constant variable
		var_def = "const " + fiType2cpp3(globalVar.type, gctx) + " " + init + ";\n\n";
		Cpp3CompiledDeclaration(name, true, "", var_def);
	}
}

fiFunc2cpp3(fun: FiFunctionDec, gctx0: Cpp3GlobalContext) -> Cpp3CompiledDeclaration {
	name = fun.name;
	fn_type = fun.type;
	gctx = Cpp3GlobalContext(
		gctx0 with currentToplevel = name,
		toplevelTypars = fiCollectTypars(fn_type, makeSet())
	);
	//debug_typars_interpolation := 
	debug_typars_interpolation := name == "fctypeenv2fi";
	fun_args = fun.lambda.args;
	headerOnly = cpp3InlineFunction(fun);
	fun_name = gctx.varname2cpp(name);
	fun_typars = set2array(fiTypeTypars(makeSet(), fn_type));
	decl_typars = fiDeclTypars2cpp3(fun_typars, gctx);
	fun_signature = (if (headerOnly) "inline " else "") + fiType2cpp3(fn_type.returnType, gctx) + " " + fun_name + fiFunArgs2cpp(fun_args, gctx);
	forward_decl = decl_typars + fun_signature + ";\n\n";
	fun_locals = fold(fun_args, makeSet(), \acc, arg -> if (arg.name == "__") acc else insertSet(acc, arg.name));
	
	names = gctx.program.names;
	lambda0 = fiEliminateUnionFields(fun.lambda, names, 0);
	lambda1 = fiExplicitCastInSwitch(lambda0, names);
	lambda3 = fiFixVarInSameStructType(
		lambda1, 
		fold(fn_type.args, makeTree(), \acc, arg -> 
			setTree(acc, arg.name, FiVar(arg.name, arg.type, 0))
		), 
		names
	);
	lambda4 = cast(lambda3: FiExp -> FiLambda);
	lambda5_body = fiExpRenameRecurringVars(lambda4.body, fun_locals);
	fun_cpp = tryCatch(
		\-> {
			fun_stat0 = fiExp2FsStat(lambda5_body, FsReturnToOuter(), fun_locals, names, ref 0);
			fun_stat1 = fsStatSSA(fun_stat0, makeTree()).first;
			// fsInterpolateTyparsStat(s : FsStat, type: FiType, names: FiGlobalNames) -> FsStat;
			// fsInterpolateTyparsExp(e : FsExp, type: FiType, names: FiGlobalNames, do: bool) -> FsExp;
			fun_stat2 = fsInterpolateTyparsStat(fun_stat1, names);
			fun_stat = fsMakeStatCastsExplicit(fun_stat2, fn_type.returnType, names);
			/*if (name == "fctypeenv2fi") {
				println("fun.lambda:\n" + toStringFormatted(fun.lambda) +"\n----------\n");
				//println("lambda0:\n" + toStringFormatted(lambda0) +"\n----------\n");
				//println("fun_stat0:\n" + toStringFormatted(fun_stat0) +"\n----------\n");
				//println("lambda1:\n" + toStringFormatted(lambda1) +"\n----------\n");
				//println("fun_stat1:\n" + toStringFormatted(fun_stat1) +"\n----------\n");
				println("fun_stat2:\n" + toStringFormatted(fun_stat2) +"\n----------\n");
				println("fun_stat:\n" + toStringFormatted(fun_stat) +"\n----------\n");
			}*/
			fsStat2cpp3(fun_stat, gctx);
		},
		\msg  -> {
			println(
				msg + "\nin: " + name + "\n" + 
				prettyFiExp(dummyPretty, fun.lambda) + "\n"// + 
				//toStringFormatted(fun.lambda)
			);
			fail0(msg);
		}
	);
	definition = decl_typars + fun_signature + " " + fiWrapWithBraces(fun_cpp) + "\n\n";
	debug_typars_interpolation := false;
	Cpp3CompiledDeclaration(name, headerOnly, forward_decl, definition);
}

fiFunArgs2cpp(args: [FiFunArg], gctx: Cpp3GlobalContext) -> string {
	arg2cpp = \i, arg -> {
		fiType2cpp3(arg.type, gctx) + " " + (if (arg.name == "__") arg.name + i2s(i) else gctx.varname2cpp(arg.name))
	};
	"(" + strGlue(mapi(args, arg2cpp), ", ") + ")";
}

fiType2cpp3(t : FiType, gctx: Cpp3GlobalContext) -> string {
	switch (t) {
		FiTypeArray(arr): {
			"Arr<" + fiType2cpp3(arr, gctx) + ">";
		}
		FiTypeFunction(args, retType): {
			"Fun<" + superglue(concat([retType], map(args, \arg -> arg.type)), \tp -> fiType2cpp3(tp, gctx) , ", ") + ">";
		}
		FiTypeRef(tp):        "Ref<" + fiType2cpp3(tp, gctx) + ">";
		FiTypeParameter(nm):  if (containsSet(gctx.toplevelTypars, nm)) "T" + i2s(strlen(nm)) else "Flow";
		FiTypeBool():         "Bool";
		FiTypeInt():          "Int";
		FiTypeDouble():       "Double";
		FiTypeString():       "String";
		FiTypeFlow():         "Flow";
		FiTypeVoid():         "Void";
		FiTypeNative():       "Flow";
		FiTypeName(name, typars):  {
			if (containsKeyTree(gctx.program.names.structs, name)) {
				"Str<" + fiStructName2cpp3(t, gctx) + ">";
			} else {
				"Union";
			}
		}
	}
}

fsStat2cpp3(stat : FsStat, gctx: Cpp3GlobalContext) -> string {
	do = \-> switch (stat) {
		FsLet(name, vtype, e): {
			if (name == "__") "" else {
				fiType2cpp3(vtype, gctx) + " " + gctx.varname2cpp(name) + " = " + fsExp2cpp3(e, gctx) + ";";
			}
		}
		FsIf(cond, pos, neg, type): {
			"if " + fiWrapWithPars(fsExp2cpp3(cond, gctx)) + " {\n" + 
				strIndent(fsStat2cpp3(pos, gctx)) + 
			"\n} else {\n" + 
				strIndent(fsStat2cpp3(neg, gctx)) + 
			"\n}";
		}
		FsSwitch(x, cases, type): {
			switch (x.type) {
				FiTypeName(typename,__): {
					switch (lookupTree(gctx.program.names.unions, typename)) {
						Some(__): {
							fsSwitch2cpp3(stat, gctx.varname2cpp(x.name) + "->id()", gctx);
						}
						None(): {
							fsStructSwitch2cpp3(stat, typename, gctx);
						}
					}			
				}
				FiTypeFlow(): {
					fsSwitch2cpp3(stat, gctx.varname2cpp(x.name) + ".toStruct()->id()", gctx);
				}
				default:
					throw("must be struct or union or flow type, got: " + prettyFiType(dummyPretty, x.type, makeSet()));
			}
		}
		FsSeq(es, type): {
			if (length(es) == 0) "" else
			if (length(es) == 1) fsStat2cpp3(es[0], gctx) else 
			fiWrapWithBraces(superglue(es, \x -> fsStat2cpp3(x, gctx), "\n"));
		}
		FsWrap(e): fsExp2cpp3(e, gctx) + ";";
		FsRet(e): {
			e_s = fsExp2cpp3(e, gctx);
			(if (fsExpType(e) == FiTypeVoid()) e_s else "return " + e_s) + ";"
		}
		FsVarDecl(var): {
			fiType2cpp3(var.type, gctx) + " " + gctx.varname2cpp(var.name) + ";";
		}
		FsAssign(var, e): {
			gctx.varname2cpp(var.name) + " = " + fsExp2cpp3(e, gctx) + ";";
		}
	};
	tryCatch(do, \msg -> {
		println("in: " + toStringFormatted(stat));
		throw(msg);
	});
}

fsSwitch2cpp3(sw: FsSwitch, sw_cond: string, gctx: Cpp3GlobalContext) -> string {
	nondef_cases = filtermap(sw.cases, \c ->
		if (c.struct == "default") None() else Some(fsCase2cpp3(c, gctx))
	);
	all_cases = switch (find(sw.cases, \case -> case.struct == "default")) {
		Some(def_case): {
			concat(nondef_cases, [fsCase2cpp3(def_case, gctx)]);
		}
		None(): {
			redundant_defcase = if (gctx.config.monolith) [] else 
				["default: {\n" + 
					strIndent("assert(false && \"unexpected case in switch\");\nbreak;") + 
				"\n}"];
			concat(nondef_cases, redundant_defcase);
			//nondef_cases;
		}
	}
	"switch (" + sw_cond + ") {\n" +
		superglue(all_cases, \case -> strIndent(case), "\n") +
	"\n}";
}

fsCase2cpp3(c: FsCase, gctx: Cpp3GlobalContext) -> string {
	switch (lookupTree(gctx.program.names.structs, c.struct)) {
		Some(struct): {
			typars = if (length(struct.typars) == 0) "" else 
				"<" + superglue(struct.typars, \typar-> fiType2cpp3(typar, gctx), ", ") + ">";
			name = gctx.typename2cpp(c.struct) + typars;
			args_to_wrap = filtermapi(c.args, \i, arg -> {
				arg_type = struct.args[i].type;
				arg_typars = set2array(fiTypeTypars(makeSet(), arg_type));
				if (arg_typars == []) None() else Some(Pair(arg, arg_type));
			});
			vars_wrapped = if (args_to_wrap == []) c.body else fsWrapCaseVarsWithCasts(c.body, args_to_wrap);
			body1 = fsStat2cpp3(vars_wrapped, gctx);
			id = lookupTreeDef(gctx.structs2id, c.struct, -1);
			"case " + i2s(id) + " /*" + c.struct + "*/: {\n" +
				strIndent(body1) + "\n\tbreak;"
			"\n}";

		}
		None(): {
			// default case
			if (c.struct != "default") throw("struct is not found") else {
				body1 = fsStat2cpp3(c.body, gctx);
				strIndent("default: {\n" + strIndent(body1)) + "\n}";
			}
		}
	}
}

fsStructSwitch2cpp3(sw: FsSwitch, typename: string, gctx: Cpp3GlobalContext) -> string {
	switch (lookupTree(gctx.program.names.structs, typename)) {
		Some(struct): {
			switch (find(sw.cases, \case -> case.struct == typename)) {
				Some(c): {
					typars = if (length(struct.typars) == 0) "" else 
						"<" + superglue(struct.typars, \typar-> fiType2cpp3(typar, gctx), ", ") + ">";
					name = gctx.typename2cpp(c.struct) + typars;
					args_to_wrap = filtermapi(c.args, \i, arg -> {
						arg_type = struct.args[i].type;
						arg_typars = set2array(fiTypeTypars(makeSet(), arg_type));
						if (arg_typars == []) None() else Some(Pair(arg, arg_type));
					});
					vars_wrapped = if (args_to_wrap == []) c.body else fsWrapCaseVarsWithCasts(c.body, args_to_wrap);
					body1 = fsStat2cpp3(vars_wrapped, gctx);
					body1;
				}
				None(): {
					throw("struct case is not found");
				}
			}
		}
		None(): {
			throw("must be struct or union (type name): " + typename);
		}
	}
}

fsExp2cpp3(e : FsExp, gctx: Cpp3GlobalContext) -> string {
	do = \-> switch (e) {
		FiVoid(__):      "";
		FiBool(b, __):   b2s(b);
		FiInt(i, __):    i2s(i);
		FiDouble(d, __): { 
			s = d2s(d);
			if (strContains(s, ".")) s else s + ".0";
		}
		FiString(s, __): "makeString(u\"" + escapeStr(toAsciiString(s)) + "\")";
		FsCast(ex, from, to): {
			s = fsExp2cpp3(ex, gctx);
			//fiCpp3Cast(fsExpType(ex), to, s, gctx);
			fiCpp3Cast(from, to, s, gctx);
		}
		FsCall(f, args, type): {
			f_type = cast(fsExpType(f): FiType -> FiTypeFunction);
			s_args = map(args, \arg -> fsExp2cpp3(arg, gctx));
			s_args_len = fold(s_args, 0, \acc, s_arg -> acc + strlen(s_arg) + 2);
			s_args_wrapped = if (length(args) > 7 || s_args_len > 64 || exists(s_args, \s_arg -> strContains(s_arg, "\n"))) {
				"(\n" + strIndent(strGlue(s_args, ",\n")) + "\n)";
			} else {
				"(" + strGlue(s_args, ", ") + ")";
			}
			switch(f) {
				FsVar(name,__,__): {
					toplevel: Maybe<FiDeclaration> = lookupTree(gctx.program.names.toplevel, name);
					typars = switch (toplevel) {
						Some(fn): {
							typars_instances = fiMatchTyparsOrdered(fn.type, f_type);
							if (length(typars_instances) == 0) "" else {
								"<" + superglue(typars_instances, \tp -> fiType2cpp3(tp, gctx), ", ") + ">";
							}
						}
						None(): "";
					}
					switch (lookupTree(gctx.natives, name)) {
						Some(nat): {
							switch (nat.inline) {
								Some(inline): inline.def(s_args);
								None(): gctx.varname2cpp(name) + typars + s_args_wrapped;
							}
						}
						None(): gctx.varname2cpp(name) + typars + s_args_wrapped;
					}
				}
				default: {
					fsExp2cpp3(f, gctx) + s_args_wrapped;
				}
			};
		}
		FsLambda(closure, args, body, type): {
			fun = fiType2cpp3(type, gctx);
			body_s = fsStat2cpp3(body, gctx);
			header = fun + "([" + superglue(closure, gctx.varname2cpp, ", ") + "] " + fiFunArgs2cpp(args, gctx);
			if (strlen(body_s) > 64 || strContains(body_s, "\n")) {
				header + " mutable {\n" + strIndent(fsStat2cpp3(body, gctx)) + "\n})";
			} else {
				header + " mutable { " + fsStat2cpp3(body, gctx) + " })";
			}
		}
		FsTernary(e1, e2, e3, type): {
			"(" + fsExp2cpp3(e1, gctx) + " ? \n" + 
				strIndent(fsExp2cpp3(e2, gctx)) + 
			"\n : \n" + 
				strIndent(fsExp2cpp3(e3, gctx)) + 
			")";
		}
		FsCallPrim(op, es, type): fsCallPrim2cpp3(e, gctx);
		FsVar(name, type, local): {
			var = gctx.varname2cpp(name);
			if (local) var else {
				switch (lookupTree(gctx.program.names.toplevel, name)) {
					Some(decl): {
						external_func_var = \fn_type -> {
							switch (type) {
								FiTypeFunction(args, ret_type): {
									typars_instances = fiMatchTyparsOrdered(fn_type, type);
									typars = if (length(typars_instances) == 0) "" else {
										"<" + superglue(typars_instances, \tp -> fiType2cpp3(tp, gctx), ", ") + ">";
									}
									wrap = "std::function<" + fiType2cpp3(ret_type, gctx) + "(" + 
									superglue(args, \t -> fiType2cpp3(t.type, gctx), ", ") + ")>(" + var + typars + ")";
									fun = fiType2cpp3(type, gctx);
									fun + "(" + wrap + ")";
								}
								default: {
									throw(
										"non-func type:\n" + toStringFormatted(type) + "\n" +
										"for func type:\n" + toStringFormatted(fn_type) + "\n" +
										"expr:\n" + toStringFormatted(e) + "\n"
									);
								}
							}
						}
						switch (decl) {
							FiFunctionDec(__,__, fn_type, __,__): {
								external_func_var(fn_type);
							}
							FiNativeDec(__,__, fn_type, __,__,__,__): {
								switch (fn_type) {
									FiTypeFunction(as, ret): {
										external_func_var(fn_type);
									}
									default: var;
								}
							}
							default: var;
						}
					}
					None(): var;
				}
			}
		}
		FsRequire(flowfile, ex, type): throw("//TODO: FiRequire " + flowfile);
		FsUnsafe(name, fallback, type): throw("//TODO: FiUnsafe " + name);
	};
	tryCatch(do, \msg -> {
		println("in: " + toStringFormatted(e));
		throw(msg);
	});
}

fsCallPrim2cpp3(e : FsCallPrim, gctx : Cpp3GlobalContext) -> string {
	e2k = \x -> fsExp2cpp3(x, gctx);
	arg_type = if (length(e.es) > 0) fsExpType(e.es[0]) else FiTypeVoid();
	switch (e.op) {
		FcOrPrim():  "(" + e2k(e.es[0]) + " || " + e2k(e.es[1]) + ")";
		FcAndPrim(): "(" + e2k(e.es[0]) + " && " + e2k(e.es[1]) + ")";
		FcNotPrim(): "!" + e2k(e.es[0]);

		FcEqPrim():  "(Compare<" + fiType2cpp3(arg_type, gctx) + ">::cmp(" + e2k(e.es[0]) + ", " + e2k(e.es[1]) + ") == 0)";
		FcNePrim():  "(Compare<" + fiType2cpp3(arg_type, gctx) + ">::cmp(" + e2k(e.es[0]) + ", " + e2k(e.es[1]) + ") != 0)";
		FcLePrim():  "(Compare<" + fiType2cpp3(arg_type, gctx) + ">::cmp(" + e2k(e.es[0]) + ", " + e2k(e.es[1]) + ") <= 0)";
		FcGePrim():  "(Compare<" + fiType2cpp3(arg_type, gctx) + ">::cmp(" + e2k(e.es[0]) + ", " + e2k(e.es[1]) + ") >= 0)";
		FcLtPrim():  "(Compare<" + fiType2cpp3(arg_type, gctx) + ">::cmp(" + e2k(e.es[0]) + ", " + e2k(e.es[1]) + ") < 0)";
		FcGtPrim():  "(Compare<" + fiType2cpp3(arg_type, gctx) + ">::cmp(" + e2k(e.es[0]) + ", " + e2k(e.es[1]) + ") > 0)";

		FcPlusPrim():  {
			if (e.type == FiTypeString()) {
				"makeString(*" + e2k(e.es[0]) + " + *" + e2k(e.es[1]) + ")";
			} else {
				"(" + e2k(e.es[0]) + " + " + e2k(e.es[1]) + ")";
			}
		}
		FcMinusPrim(): "(" + e2k(e.es[0]) + " - " + e2k(e.es[1]) + ")"; 
		FcMulPrim():   "(" + e2k(e.es[0]) + " * " + e2k(e.es[1]) + ")";
		FcDivPrim():   "(" + e2k(e.es[0]) + " / " + e2k(e.es[1]) + ")";
		FcModPrim(): {
			if (e.type == FiTypeDouble()) {
				"fmod(" + e2k(e.es[0]) + ", " + e2k(e.es[1]) + ")";
			} else {
				"(" + e2k(e.es[0]) + " % " + e2k(e.es[1]) + ")";
			}
		}
		FcNegPrim():   "-" + e2k(e.es[0]);
		FcArrayPrim(): {
			arr_type = fiDearrayType(e.type);
			if (length(e.es) == 0) {
				"Arr<" + fiType2cpp3(arr_type, gctx) + ">::makeEmpty()";
			} else {
				arr_s = map(e.es, e2k);
				if (length(arr_s) < 8 && !exists(arr_s, \s -> strContains(s, "\n"))) {
					"Arr<" + fiType2cpp3(arr_type, gctx) + ">{" + strGlue(arr_s, ", ") + "}";
				} else {
					"Arr<" + fiType2cpp3(arr_type, gctx) + ">{\n" + strIndent(strGlue(arr_s, ",\n")) + "\n}";
				}
			}
		}
		FcIndexPrim(): {
			switch (arg_type) {
				FiTypeFlow(): {
					e2k(e.es[0]) + ".toArray()->element(" + e2k(e.es[1]) + ")";
				}
				default:
					"(" + e2k(e.es[0]) + "->vect.at(" + e2k(e.es[1]) + "))";
			}
		}
		FcDerefPrim(): {
			switch (arg_type) {
				FiTypeFlow(): {
					e2k(e.es[0]) + ".toReference()->reference()";
				}
				default:
					"(*" +e2k(e.es[0]) + ".ref)";

			}
		}
		FcAssignPrim(): {
			"(*" + e2k(e.es[0]) + ".ref = " + e2k(e.es[1]) + ")";
		}
		FcRefPrim(): {
			ref_type = fiDerefType(e.type);
			"Ref<" + fiType2cpp3(ref_type, gctx) + ">(" + e2k(e.es[0]) + ")";
		}
		FcStructPrim(struct_name): {
			struct_type = cast(e.type : FiType -> FiTypeName);
			struct_full_name = fiStructName2cpp3(struct_type, gctx);
			"Str<" + struct_full_name + ">(new " + struct_full_name + "(" + strGlue(map(e.es, e2k), ", ") + "))";
		}
		FcFieldPrim(name): {
			if (name == "structname") {
				switch (arg_type) {
					FiTypeName(typename, params): {
						if (containsKeyTree(gctx.program.names.structs, typename)) {
							"makeString(\"" + typename + "\")";
						} else {
							e2k(e.es[0]) + "->name()";
						}
					}
					FiTypeFlow(): {
						e2k(e.es[0]) + ".toStruct()->name()";
					}
					default: throw("accees to field '" + name + "' of non-field: " + fsExp2s(e.es[0]));
				}
			} else {
				switch (arg_type) {
					FiTypeFlow(): {
						e2k(e.es[0]) + ".toStruct()->field(makeString(\"" + name + "\"))";
					}
					default: e2k(e.es[0]) + "->" + gctx.varname2cpp(name);
				}
			}
		}
		FcSetMutablePrim(name): {
			switch (arg_type) {
				FiTypeFlow(): {
					e2k(e.es[0]) + ".toStruct()->setField(" + gctx.varname2cpp(name) + ", " + e2k(e.es[1]) + ")";
				}
				default: e2k(e.es[0]) + "->" + gctx.varname2cpp(name) + " = " + e2k(e.es[1]);
			}
		}
		FcCreateClosurePrim(structName, functionName): throw("// TODO: FcCreateClosurePrim");
		FcQuote():   throw("// TODO: FcQuote");
		FcUnquote(): throw("// TODO: FcUnquote");
	}
}

fiCpp3Cast(from: FiType, to: FiType, s: string, gctx: Cpp3GlobalContext) -> string {
	if (fiEqualTypes(from, to)) s else {
		switch (from) {
			FiTypeParameter(__): s;
			FiTypeFlow():   "FromFlow<" + fiType2cpp3(to, gctx) + ">::conv(" + s + ")";
			FiTypeNative(): "FromFlow<" + fiType2cpp3(to, gctx) + ">::conv(" + s + ")";
			default: {
				static_cast = \s1 -> "static_cast<" + fiType2cpp3(to, gctx) + ">(" + s1 + ")";
				switch (to) {
					FiTypeVoid():       throw("cast to void");
					FiTypeBool():       static_cast(s);
					FiTypeInt():        static_cast(s);
					FiTypeDouble():     static_cast(s);
					FiTypeString(): {
						switch (from) {
							FiTypeVoid():   "makeString(\"{}\")";
							FiTypeBool():   "makeString(std::to_string(" + s + "))";
							FiTypeInt():    "makeString(std::to_string(" + s + "))";
							FiTypeDouble(): "makeString(std::to_string(" + s + "))";
							FiTypeString(): s;
							default:        "flow2string(Flow(" + s + "))";
						}
					}
					FiTypeFlow(): {
						"ToFlow<" + fiType2cpp3(from, gctx) + ">::conv(" + s + ")";
					}
					FiTypeNative(): {
						"ToFlow<" + fiType2cpp3(from, gctx) + ">::conv(" + s + ")";
					}
					FiTypeParameter(n): {
						/**switch (from) {
							FiTypeParameter(m): "struct2struct<" + fiType2cpp3(from, gctx) + ", " + fiType2cpp3(to, gctx) + ">(" + s + ")";
							default: s;
						}*/
						s;
					}
					FiTypeRef(rt): {
						s + ".template cast<" + fiType2cpp3(rt, gctx)+  ">()";
					}
					FiTypeArray(at): {
						s + ".template cast<" + fiType2cpp3(at, gctx)+  ">()";
					}
					FiTypeName(id_to, tp_to): {
						to_is_union = containsKeyTree(gctx.program.names.unions, id_to);
						switch (from) {
							FiTypeName(id_from, tp_from): {
								from_is_union = containsKeyTree(gctx.program.names.unions, id_from);
								if (to_is_union) {
									if (from_is_union) {
										s 
									} else {
										"struct2union<" + fiType2cpp3(from, gctx) + ">(" + s + ")";
									}
								} else {
									if (from_is_union) {
										"union2struct<" + fiType2cpp3(to, gctx) + ">(" + s + ")";
									} else {
										"struct2struct<" + fiType2cpp3(from, gctx) + ", " + fiType2cpp3(to, gctx) + ">(" + s + ")";
									}
								}
							}
							FiTypeParameter(__): s;
							default: throw("illegal cast to struct from: " + prettyFiType(dummyPretty, from, makeSet()));
						}
					}
					FiTypeFunction(args, rt): {
						signature = superglue(concat([rt], map(args, \arg -> arg.type)), \tp -> fiType2cpp3(tp, gctx) , ", ");
						s + ".template cast<" + signature+  ">()";
					}
				}
			}
		}
	}
}

fiCpp3StructDefs(gctx0 : Cpp3GlobalContext) -> string {
	struct_defs = map(getTreeValues(gctx0.program.names.structs), \struct -> {
		tryCatch(
			\-> {
				typars = if (struct.typars == []) "" else "<" + superglue(struct.typars, \__ -> "Flow", ", ") + ">";
				gctx = Cpp3GlobalContext(
					gctx0 with currentToplevel = struct.name,
					toplevelTypars = buildSet(filtermap(struct.typars, \tp ->
						switch (tp) {
							FiTypeParameter(nm): Some(nm);
							default: None();
						}
					))
				);
				struct_arg = \i, arg -> {
					arg_val = "__args->vect.at(" + i2s(i) + ")";
					arg_type = fiType2cpp3(fiTransformTypars(arg.type, \__ -> FiTypeFlow()), gctx);
					"FromFlow<" + arg_type + ">::conv(" + arg_val + ")";
				}
				struct_name = gctx.typename2cpp(struct.name) + typars;
				args = "(" + strGlue(mapi(struct.args, \i, arg -> struct_arg(i, arg)), ", ") + ")";
				wrapper = "Str<" + struct_name + ">";
				constructor = "[](Arr<Flow> __args) { return ToFlow<" + wrapper + ">::conv(" + wrapper + "(new " + struct_name + args + ")); }";
				fields = if (struct.args == []) "std::vector<FieldDef>()" else {
					"std::vector{" + 
						superglue(struct.args, \arg  -> 
							"FieldDef{fromStdString(\"" + arg.name + "\"), fromStdString(\"" + fiType2cpp3(arg.type, gctx) +"\"), " + b2s(arg.ismutable) + "}", 
							", "
						) + 
					"}";
				}
				struct_def = "StructDef{" + 
					i2s(lookupTreeDef(gctx.structs2id, struct.name, -1)) + ", " +
					constructor + ", " +
					fields +
				"}";
				"\tdefs[fromStdString(\"" + struct.name + "\")] = " + struct_def + ";\n";
			},
			\err -> {
				println("struct: " + toString(struct) + "\nerr: " + toString(err));
				throw(err);
			}
		);
	});
"
std::map<string, StructDef> StructDefs::defs;
void StructDefs::init() {\n" + 
	concatStrings(struct_defs) + 
"\n}\n";

}

cpp3StructDefsRuntimePart(gctx: Cpp3GlobalContext) -> Cpp3RuntimePart {
Cpp3RuntimePart("struct_defs", 
"
struct FieldDef {
	string name;
	string type;
	bool isMutable;
};

struct StructDef {
	typedef std::function<Flow(Arr<Flow>)> Constructor;
	Int id;
	Constructor make;
	std::vector<FieldDef> fields;
};

struct StructDefs {
	static void init();
	static std::map<string, StructDef> defs;
};
", 
fiCpp3StructDefs(gctx), 
"StructDefs::init();", "", 
[Cpp3Std(["<map>"], [])]
);
}
