import tools/flowc/backends/cpp3/fi2cpp3_runtime;
import tools/flowc/statements/fs_utils;
import tools/flowc/manipulation/eliminate_union_fields;
import tools/flowc/memory/fi2fm;
import tools/flowc/memory/perceus;
import tools/flowc/statements/fm2fs;

export {
	fiModule2cpp3(module : FiModule, gctx: Cpp3GlobalContext) -> Cpp3CompiledModule;
}

fiModule2cpp3(module : FiModule, gctx0: Cpp3GlobalContext) -> Cpp3CompiledModule {
	gctx = Cpp3GlobalContext(gctx0 with currentModule = module.fileinfo.flowfile);
	names = gctx.program.names;
	compiled_structs = map(module.structs, \struct -> 
		Cpp3CompiledDeclaration(struct.name, true, 
			fiStruct2cpp3(struct, gctx, true),
			fiStruct2cpp3(struct, gctx, false)
		)
	);
	decls = concat(
		module.natives,
		filtermap(module.initOrder, \name -> {
			switch (find(module.globalVars, \gv -> gv.name == name)) {
				Some(globalVar): Some(globalVar);
				None(): find(module.functions, \fn -> fn.name == name);
			}
		})
	);
	compiled_decls = filtermap(decls, \decl -> fiDeclaration2cpp3(decl, gctx));
	is_main = exists(module.functions, \fn -> fn.name == "main");
	Cpp3CompiledModule(
		gctx.flowfile2cpp(module.fileinfo.flowfile),
		is_main,
		concat(compiled_structs, compiled_decls),
		map(module.imports, \imp -> imp.flowfile),
		fiModuleNatives2cpp3(module, gctx)
	);
}

fiModuleNatives2cpp3(module: FiModule, gctx: Cpp3GlobalContext) -> [Cpp3Native] {
	missing_natives = ref [];
	natives = filtermap(module.natives, \nat -> {
		if (!fiCpp3IsNative(nat.name, gctx) && !contains(module.initOrder, nat.name)) {
			refArrayPush(missing_natives, nat.name);
		}
		lookupTree(gctx.natives, nat.name);
	});
	if (^missing_natives != []) {
		err = "Module " + module.fileinfo.flowfile + ": following native functions are not implemented in cpp3 runtime and doesn't have a flow fallbacks:\n" +
			strIndent(superglue(^missing_natives, \name -> "\t" + name, "\n"));
		refArrayPush(gctx.errors, err);
		fcPrintln(err, gctx.config.config.threadId);
	}
	natives;
}

cpp3InlineFunction(fn: FiFunctionDec) -> bool {
	if (!isEmptySet(fiCollectTypars(fn.type, makeSet()))) true else {
		if (!fiExpIsSimple(fn.lambda.body)) false else {
			fiExpAstNodesCount(fn.lambda.body) < 8;
		}
	}
}

fiDeclaration2cpp3(decl: FiDeclaration, gctx: Cpp3GlobalContext) -> Maybe<Cpp3CompiledDeclaration> {
	switch (decl) {
		FiGlobalVar(name, value, type,__,__): {
			Some(fiGlobalVar2cpp3(decl, gctx));
		}
		FiFunctionDec(name, lambda, type,__,__): {
			if (fiCpp3IsNative(name, gctx)) None() else {
				Some(fiFunc2cpp3(decl, gctx));
			}
		}
		FiNativeDec(name, __,type,__, fallback,__,__):
			maybeMap(lookupTree(gctx.natives, name), \nat -> 
				nat.declaration(gctx.typename2cpp, gctx.varname2cpp, gctx.structid2cpp)
			);
	}
}

fiStructName2cpp3(tn : FiTypeName, gctx: Cpp3GlobalContext) -> string {
	gctx.typename2cpp(tn.name) + if (tn.typeparameters == []) "" else "<" + superglue(tn.typeparameters, \tp -> fiType2cpp3(tp, gctx), ", ") + ">";
}

fiDeclTypars2cpp3(types : [FiType], gctx : Cpp3GlobalContext) -> string {
	typars_names = sort(set2array(fold(types, makeSet(), \acc, type -> fiCollectTypars(type, acc))));
	typars = map(typars_names, \n -> FiTypeParameter(n));
	if (typars == []) "" else "template <" + superglue(typars, \tp -> "typename " + gctx.typar2cpp(tp), ", ") + ">\n";
}

fiStruct2cpp3(struct: FiTypeStruct, gctx0: Cpp3GlobalContext, only_decl: bool) -> string {
	gctx = Cpp3GlobalContext(
		gctx0 with currentToplevel = Some(struct),
		toplevelTypars = fold(struct.typars, makeSet(), \acc, tp -> fiCollectTypars(tp, acc))
	);
	struct_name = gctx.typename2cpp(struct.name);
	struct_id = i2s(lookupTreeDef(gctx.structs2id, struct.name, -1));
	names = gctx.program.names;
	typars = struct.typars;
	decl_typars = fiDeclTypars2cpp3(typars, gctx);
	if (only_decl) {
		decl_typars + "struct " + struct_name + ";\n\n";
	} else {
		static_id = "enum { ID = " + struct_id + ", SIZE = " + i2s(length(struct.args)) + " };"; 
		field_types = supergluei(struct.args, 
			\i, arg -> "typedef " + fiType2cpp3(arg.type, gctx) + " " + "FieldType_" + i2s(i) + ";",
			"\n"
		);
		static_instance = if (length(struct.args) > 0) "" else {
			"static Str<" + struct_name + "> instance() {\n" +
				"\tstatic Str<" + struct_name + "> inst = Str<" + struct_name + ">::make();\n" +
				"\treturn inst;\n" +
			"}";
		}

		constructor_init = if (length(struct.args) == 0) "" else {
			": " + superglue(struct.args, \arg -> gctx.varname2cpp(arg.name) + "(__" + gctx.varname2cpp(arg.name) + ")", ", ");
		}
		constructor = "\t" + struct_name + 
		"(" + 
			superglue(struct.args, \arg -> fiType2cpp3(arg.type, gctx) + " __" + gctx.varname2cpp(arg.name), ", " ) + 
		") " + constructor_init + " { }\n";

		abstract_constructor =
		"\tstatic Str<" + struct_name + "> fromAStr(PStr p) {\n" + 
			"\t\treturn Str<" + struct_name + ">::make(" + 
				supergluei(struct.args, \i, arg -> 
					"Cast<Flow>::template To<" + fiType2cpp3(arg.type, gctx) + ">::conv(p->getFlowField(" + i2s(i) + "))", ", "
				) + 
			");\n" +
		"\t}\n";
		flow_constructor = 
		"\tstatic Str<" + struct_name + "> fromFlowArgs(Vec<Flow> fs) {\n" + 
			"\t\treturn Str<" + struct_name + ">::make(" + 
				supergluei(struct.args, \i, arg -> 
					"Cast<Flow>::template To<" + fiType2cpp3(arg.type, gctx) + ">::conv(fs->getItem(" + i2s(i) + "))", ", "
				) + 
			");\n" +
		"\t}\n";
		move_constructor = if (length(struct.args) == 0) "" else 
		"\t" + struct_name + "(" + struct_name + "&& s): " + 
			superglue(struct.args, \arg -> gctx.varname2cpp(arg.name) + "(std::move(s." + gctx.varname2cpp(arg.name) + "))", ", " ) + 
		" { }\n";

		assignment_operator = if (length(struct.args) == 0) "" else 
		"\t" + struct_name + "& operator = (const " + struct_name + "& s) { " + 
			superglue(struct.args, \arg -> gctx.varname2cpp(arg.name) + " = s." + gctx.varname2cpp(arg.name) + ";", " " ) + 
		" return *this; }\n";
		assignment_move = if (length(struct.args) == 0) "" else 
		"\t" + struct_name + "& operator = (" + struct_name + "&& s) { " + 
			superglue(struct.args, \arg -> gctx.varname2cpp(arg.name) + " = std::move(s." + gctx.varname2cpp(arg.name) + ");", " " ) + 
		" return *this; }\n";

		fields = concatStrings(map(struct.args, \arg -> 
			"\t" + (if (arg.ismutable) "mutable " else "") + fiType2cpp3(arg.type, gctx) + " " + gctx.varname2cpp(arg.name) + ";\n"
		));
		compare = "Int compare(Str<" + struct_name + "> s) const {\n" +
			concatStrings(mapi(struct.args, \i, arg ->
				"\tInt c" + i2s(i) + " = Compare<" + fiType2cpp3(arg.type, gctx) + ">::cmp(" + 
					gctx.varname2cpp(arg.name) + ", " + 
					"s->" + gctx.varname2cpp(arg.name) + 
				"); " + 
				"if (c" + i2s(i) + " != 0) return c" + i2s(i) + ";\n",
			)) + 
			"\treturn 0;"
		"\n}";

		get_field_1 = "Flow getFlowField(String name) const override {\n" +
			(if (length(struct.args) == 0) {
				"\tstd::cerr << \"unknown field \" << name->toStd() << \" in struct '" + struct_name +"'\" << std::endl;\n" + 
				"\texit(1);\n" +
				"\treturn nullptr;";
			} else {
				strIndent(
					supergluei(struct.args, 
						\i, arg -> {
							getter = gctx.varname2cpp(arg.name);
							if (i == 0) {
								"if (name->str == u\"" + arg.name + "\") {\n" +
									"\treturn Cast<Flow>::template From<" + fiType2cpp3(arg.type, gctx) + ">::conv(" + getter + ");" +
								"\n} "
							} else {
								"else if (name->str == u\"" + arg.name + "\") {\n" +
									"\treturn Cast<Flow>::template From<" + fiType2cpp3(arg.type, gctx) + ">::conv(" + getter + ");" +
								"\n} "
							}
						}, "\n"
					) + "else {\n" +
						"\tstd::cerr << \"unknown field \" << name->toStd() << \" in struct '" + struct_name +"'\" << std::endl;\n" + 
						"\texit(1);\n" +
						"\treturn nullptr;"
					"\n}"
				);
			}) +
		"\n}";
		get_field_2= "Flow getFlowField(Int i) const override {\n" +
			(if (length(struct.args) == 0) {
				"\tstd::cerr << \"illegal field index \" << i << \" in struct '" + struct_name +"'\" << std::endl;\n" + 
				"\texit(1);\n" +
				"\treturn nullptr;";
			} else {
				strIndent(
					supergluei(struct.args, 
						\i, arg -> {
							getter = gctx.varname2cpp(arg.name);
							if (i == 0) {
								"if (i == " + i2s(i) + ") {\n" +
									"\treturn Cast<Flow>::template From<" + fiType2cpp3(arg.type, gctx) + ">::conv(" + getter + ");" +
								"\n} "
							} else {
								"else if (i == " + i2s(i) + ") {\n" +
									"\treturn Cast<Flow>::template From<" + fiType2cpp3(arg.type, gctx) + ">::conv(" + getter + ");" +
								"\n} "
							}
						}, "\n"
					) + "else {\n" +
						"\tstd::cerr << \"illegal field index \" << i << \" in struct '" + struct_name +"'\" << std::endl;\n" + 
						"\texit(1);\n" +
						"\treturn nullptr;"
					"\n}"
				);
			}) +
		"\n}";


		mutable_fields = filter(struct.args, \arg -> arg.ismutable);
		set_field_1 = "void setFlowField(String name, Flow val) const override {\n" +
			(if (length(mutable_fields) == 0) {
				"\tstd::cerr << \"unknown field \" << name->toStd() << \" in struct '" + struct_name +"'\" << std::endl;\n" + 
				"\texit(1);\n"
			} else {
				strIndent(
					supergluei(mutable_fields, 
						\i, arg -> {
							setter = gctx.varname2cpp(arg.name) + " = Cast<Flow>::template To<" + fiType2cpp3(arg.type, gctx) + ">::conv(val);";
							if (i == 0) {
								"if (name->str == u\"" + arg.name + "\") {\n" +
									"\t" + setter +
								"\n} "
							} else {
								"else if (name->str == u\"" + arg.name + "\") {\n" +
									"\t" + setter +
								"\n} "
							}
						}, "\n"
					) + "else {\n" +
						"\tstd::cerr << \"unknown field \" << name->toStd() << \" in struct '" + struct_name +"'\" << std::endl;\n" + 
						"\texit(1);\n"
					"\n}"
				);
			}) +
		"\n}";
		set_field_2 = "void setFlowField(Int i, Flow val) const override {\n" +
			(if (length(mutable_fields) == 0) {
				"\tstd::cerr << \"illegal mutable field index \" << i << \" in struct '" + struct_name +"'\" << std::endl;\n" + 
				"\texit(1);\n"
			} else {
				strIndent(
					supergluei(struct.args, 
						\i, arg -> {
							setter = gctx.varname2cpp(arg.name) + " = Cast<Flow>::template To<" + fiType2cpp3(arg.type, gctx) + ">::conv(val);";
							if (arg.ismutable) {
								if (i == 0) {
									"if (i == " + i2s(i) + ") {\n" +
										"\t" + setter +
									"\n} "
								} else {
									"else if (i == " + i2s(i) + ") {\n" +
										"\t" + setter +
									"\n} "
								}
							} else {
								"if (i == " + i2s(i) + ") {\n" +
									"\tstd::cerr << i << \" field is immutable in struct '" + struct_name +"'\" << std::endl;\n" + 
									"\texit(1);\n"
								"\n} "
							}
						}, "\n"
					) + "else {\n" +
						"\tstd::cerr << \"illegal field index \" << i << \" in struct '" + struct_name +"'\" << std::endl;\n" + 
						"\texit(1);\n"
					"\n}"
				);
			}) +
		"\n}";

		cast_to = "template<typename N>\n" +
		"Str<N> cast() {\n" +
			"\treturn Str<N>::make(\n" + 
				supergluei(struct.args, \i, field -> "\t\tCast<FieldType_" + i2s(i) + ">::template To<typename N::FieldType_" + i2s(i) + ">::conv(" + gctx.varname2cpp(field.name) + ")", ",\n") + 
			"\n\t);\n" +
		"}";

		struct_def = "static StructDef def() {\n" + strIndent(fiStruct2DefCpp3(struct, gctx)) + "\n}";

		decl_typars + "struct " + struct_name + ": public AStr {\n" +
		"\tenum { TYPE = Type::STRUCT };\n" +
		strIndent(static_id) + "\n" +
		strIndent(field_types) + "\n" +
		(if (static_instance == "") "" else strIndent(static_instance) + "\n") +
		constructor + 
		(if (move_constructor == "") "" else move_constructor) +
		(if (abstract_constructor == "") "" else abstract_constructor) +
		flow_constructor + 
		strIndent(struct_def) + "\n" + 
		"\tInt type() const override { return ID; }\n" +
		"\tString name() const override { return String::make(\"" + struct.name + "\"); }\n" +
		"\tInt size() const override { return SIZE; }\n" +
		strIndent(get_field_1) + "\n" +
		strIndent(get_field_2) + "\n" +
		strIndent(set_field_1) + "\n" +
		strIndent(set_field_2) + "\n" +
		strIndent(compare) + "\n" + 
		strIndent(cast_to) + "\n" +
		(if (fields == "") "" else fields) +
		"};\n\n";
	}
}

fiStruct2DefCpp3(struct : FiTypeStruct, gctx0: Cpp3GlobalContext) -> string {
	gctx = Cpp3GlobalContext(
		gctx0 with currentToplevel = Some(struct),
		toplevelTypars = buildSet(filtermap(struct.typars, \tp ->
			switch (tp) {
				FiTypeParameter(nm): Some(nm);
				default: None();
			}
		))
	);
	struct_name = fiStructName2cpp3(FiTypeName(struct.name, struct.typars), gctx);
	constructor = "[](Vec<Flow> args) { return " + struct_name + "::fromFlowArgs(args); }";
	fields = if (struct.args == []) "std::vector<FieldDef>()" else {
		"std::vector" + fiWrapWithBraces(
			superglue(struct.args, \arg  -> 
				"FieldDef{u\"" + arg.name + "\", u\"" + fiType2cpp3(arg.type, gctx) +"\", " + b2s(arg.ismutable) + "}", 
				", "
			)
		);
	}
	"return StructDef { ID,\n" +
		strIndent(constructor) + ",\n" +
		strIndent(fields) +
	"\n};";
}

fiGlobalVar2cpp3(globalVar : FiGlobalVar, gctx0: Cpp3GlobalContext) -> Cpp3CompiledDeclaration {
	names = gctx0.program.names;
	name = globalVar.name;
	gctx = Cpp3GlobalContext(gctx0 with 
		currentToplevel = Some(globalVar),
		toplevelTypars = fiCollectTypars(globalVar.type, makeSet())
	);
	value0 = fiEliminateUnionFields(globalVar.value, names, 0);
	value1 = fiExplicitCastInSwitch(value0, names);
	value2 = fiFixVarInSameStructType(value1, makeTree(), names);
	value = value2;

	mem_1 = fiExp2fmExp(value, makeSet(), gctx.effects, true, names);
	mem_2 = mem_1; //fmPerceus(mem_1, PerceusContext(makeMultiSet(), makeMultiSet(), makeTree()));

	pair0 = fmExp2FsExp(mem_2, FsEnv([], makeTree(), names, 0));
	pair1 = Pair(
		fsMakeExpCastsExplicit(pair0.first, globalVar.type, names, true),
		map(pair0.second, \s -> {
			s1 = fsMakeStatCastsExplicit(s, FiTypeVoid(), names);
			fsWrapCaseVarsWithCasts(s1, names);
		})
	);
	pair2 = pair1;
	pair3 = fold(pair2.second, Pair([], makeTree()), \acc, s -> {
		p = fsStatSSA(s, acc.second);
		stat = fsInterpolateTyparsStat(p.first, names);
		Pair(concat(acc.first, [stat]), p.second);
	});
	value3 = fsExpSSA(pair2.first, pair3.second);
	value4 = fsInterpolateTyparsExp(value3, names);
	pair = Pair(value4, pair3.first);

	value_exp = if (pair.second == []) pair.first else {
		ret_var = FsVar("__ret_var__", true, globalVar.type, globalVar.value.start);
		FsCall(FsLambda(false, [], [], 
			fsWrapSeq(concat(pair.second, [
				FsLet(ret_var, pair.first, FsRet(ret_var, globalVar.value.start), globalVar.type, globalVar.value.start)
			])), 
			FiTypeFunction([], globalVar.type), globalVar.value.start
		), [], globalVar.type, globalVar.value.start);
	}
	value_cpp = fsExp2cpp3(value_exp, gctx);

	init = gctx.varname2cpp(name) + " = " + value_cpp + ";";
	if (containsSet(gctx.volatileVars, name)) {
		// Volatile variable
		gctx.volatileInit := concat(^(gctx.volatileInit), [init]);
		var_decl = fiType2cpp3(globalVar.type, gctx) + " " + gctx.varname2cpp(name) + ";\n\n";
		Cpp3CompiledDeclaration(name, false, "extern " + var_decl, var_decl);
	} else {
		// Constant variable
		var_def = "const " + fiType2cpp3(globalVar.type, gctx) + " " + init + "\n\n";
		Cpp3CompiledDeclaration(name, true, "", var_def);
	}
}

fiFunc2cpp3(fun: FiFunctionDec, gctx0: Cpp3GlobalContext) -> Cpp3CompiledDeclaration {
	name = fun.name;
	fn_type = fun.type;
	gctx = Cpp3GlobalContext(
		gctx0 with currentToplevel = Some(fun),
		toplevelTypars = fiCollectTypars(fn_type, makeSet())
	);
	fun_args = fun.lambda.args;
	headerOnly = cpp3InlineFunction(fun);
	fun_name = gctx.varname2cpp(name);
	fun_typars = map(set2array(fiCollectTypars(fn_type, makeSet())), \n -> FiTypeParameter(n));
	decl_typars = fiDeclTypars2cpp3(fun_typars, gctx);
	
	names = gctx.program.names;
	lambda0 = fiEliminateUnionFields(fun.lambda, names, 0);
	lambda1 = fiExplicitCastInSwitch(lambda0, names);
	lambda3 = fiFixVarInSameStructType(
		lambda1, 
		fold(fn_type.args, makeTree(), \acc, arg -> 
			setTree(acc, arg.name, FiVar(arg.name, arg.type, 0))
		), 
		names
	);
	lambda4 = lambda3;
	lambda5 = fiExpRenameRecurringVars(lambda4, makeSet());

	mem_1 = fiExp2fmExp(lambda5, makeSet(), gctx.effects, true, names);
	mem_2 = mem_1; //fmPerceus(mem_1, PerceusContext(makeMultiSet(), makeMultiSet(), makeTree()));

	fun_stat0 = fmExp2FsStat(mem_2, FsReturnToOuter(), FsEnv([], makeTree(), names, 0), name);
	fun_stat1 = fsStatSSA(fun_stat0, makeTree()).first;
	fun_stat2 = fsInterpolateTyparsStat(fun_stat1, names);
	fun_stat3 = fsMakeStatCastsExplicit(fun_stat2, fn_type, names);
	fun_stat4 = fun_stat3;
	fun_stat5 = fsWrapCaseVarsWithCasts(fun_stat4, names);

	stat_lambda = fsStatLambda(fun_stat5);
	cpp_body = fsStat2cpp3(stat_lambda.body, gctx);
	fun_cpp = if (!fsHasTailCall(stat_lambda.body)) cpp_body else {
		"while (true) " + fiWrapWithBraces(cpp_body);
	}
	fun_signature =
		(if (headerOnly) "inline " else "") + fiType2cpp3(fn_type.returnType, gctx) + " " + 
		fun_name + fiFunArgs2cpp(stat_lambda.args, gctx);
	forward_decl = decl_typars + fun_signature + ";\n\n";

	definition = decl_typars + fun_signature + " " + fiWrapWithBraces(fun_cpp) + "\n\n";
	Cpp3CompiledDeclaration(name, headerOnly, forward_decl, definition);
}

fiFunArgs2cpp(args: [FiFunArg], gctx: Cpp3GlobalContext) -> string {
	arg2cpp = \i, arg -> {
		fiType2cpp3(arg.type, gctx) + " " + (if (arg.name == "__") arg.name + i2s(i) else gctx.varname2cpp(arg.name))
	};
	"(" + strGlue(mapi(args, arg2cpp), ", ") + ")";
}

fiType2cpp3(t : FiType, gctx: Cpp3GlobalContext) -> string {
	switch (t) {
		FiTypeArray(arr): {
			"Vec<" + fiType2cpp3(arr, gctx) + ">";
		}
		FiTypeFunction(args, retType): {
			"Fun<" + superglue(concat([retType], map(args, \arg -> arg.type)), \tp -> fiType2cpp3(tp, gctx) , ", ") + ">";
		}
		FiTypeRef(tp): {
			"Ref<" + fiType2cpp3(tp, gctx) + ">";
		}
		FiTypeParameter(nm):  {
			if (!containsSet(gctx.toplevelTypars, nm)) {
				// Stray type parameters are considered flow by default
				"Flow";
			} else {
				"T" + i2s(strlen(nm));
			}
		}
		FiTypeName(name, typars):  {
			if (containsKeyTree(gctx.program.names.structs, name)) {
				"Str<" + fiStructName2cpp3(t, gctx) + ">";
			} else {
				union = lookupTreeDef(gctx.program.names.unions, name, FiTypeUnion("", [], [], 0));
				"Union<" + superglue(union.typenames, \tn -> i2s(lookupTreeDef(gctx.structs2id, tn.name, -1)), ", ") + ">";
			}
		}
		FiTypeBool():   "Bool";
		FiTypeInt():    "Int";
		FiTypeDouble(): "Double";
		FiTypeString(): "String";
		FiTypeFlow():   "Flow";
		FiTypeVoid():   "Void";
		FiTypeNative(): "Native";
	}
}

fsStat2cpp3(stat : FsStat, gctx: Cpp3GlobalContext) -> string {
	switch (stat) {
		FsIf(cond, pos, neg,__,__): {
			cond_cpp = fsExp2cpp3(cond, gctx);
			pos_cpp = fsStat2cpp3(pos, gctx);
			neg_cpp = fsStat2cpp3(neg, gctx);
			if (pos_cpp != "") {
				if (neg_cpp != "") {
					"if " + fiWrapWithPars(cond_cpp) + " " + 
						fiWrapWithBraces(pos_cpp) +
					" else " + 
						fiWrapWithBraces(neg_cpp);
				} else {
					"if " + fiWrapWithPars(cond_cpp) + " " + 
						fiWrapWithBraces(pos_cpp);
				}
			} else {
				if (neg_cpp != "") {
					"if (!" + cond_cpp + ") " + 
						fiWrapWithBraces(neg_cpp);
				} else {
					"";
				}
			}
		}
		FsSwitch(x, sw_type, cases,__,__): {
			switch (x.type) {
				FiTypeName(typename,__): {
					switch (lookupTree(gctx.program.names.unions, typename)) {
						Some(__): {
							fsSwitch2cpp3(stat, gctx.varname2cpp(x.name), gctx.varname2cpp(x.name) + "->type()/*" + typename + "*/", gctx);
						}
						None(): {
							fsStructSwitch2cpp3(stat, typename, gctx);
						}
					}			
				}
				FiTypeFlow(): {
					fsSwitch2cpp3(stat, gctx.varname2cpp(x.name), gctx.varname2cpp(x.name) + "->type()/*Flow*/", gctx);
				}
				default:
					fail0("must be struct or union or flow type, got: " + prettyFiType(dummyPretty, x.type, makeSet()));
			}
		}
		FsSeq(es, type,__): {
			if (length(es) == 0) "" else
			if (length(es) == 1) fsStat2cpp3(es[0], gctx) else {
				strGlue(filter(map(es, \x -> fsStat2cpp3(x, gctx)), \s -> s != ""), "\n");
			}
		}
		FsLet(v, e, s,__,__): {
			if (v.name == "__") "" else {
				fiType2cpp3(v.type, gctx) + " " + gctx.varname2cpp(v.name) + " = " + 
				fsExp2cpp3(e, gctx) + ";\n" + 
				fsStat2cpp3(s, gctx);
			}
		}
		FsAtomic(): {
			fsAtomic2cpp3(stat, gctx);
		}
	}
}

fsAtomic2cpp3(a : FsAtomic, gctx: Cpp3GlobalContext) -> string {
	switch (a) {
		FsWrapExp(e, __): {
			e_cpp = fsExp2cpp3(e, gctx);
			if (e_cpp == "") "" else {
				e_cpp + ";";
			}
		}
		FsRet(e, __): {
			e_s = fsExp2cpp3(e, gctx);
			if (fsExpType(e) == FiTypeVoid()) {
				if (e_s == "") "return;" else e_s + ";\nreturn;";
			} else {
				"return " + e_s + ";"
			}
		}
		FsTailCall(__): {
			"continue;";
		}
		FsVarDecl(var, __): {
			fiType2cpp3(var.type, gctx) + " " + gctx.varname2cpp(var.name) + ";";
		}
		FsAssign(to, what, __): {
			switch (fsExpType(to)) {
				FiTypeRef(__): {
					switch (fsExpType(what)) {
						FiTypeRef(__):
							fsExp2cpp3(to, gctx) + " = " + fsExp2cpp3(what, gctx) + ";";
						FiTypeFlow(): 
							fsExp2cpp3(to, gctx) + "->setFlowRef(" + fsExp2cpp3(what, gctx) + ");";
						default:
							fsExp2cpp3(to, gctx) + "->setRef(" + fsExp2cpp3(what, gctx) + ");";
					}
				}
				default:
					fsExp2cpp3(to, gctx) + " = " + fsExp2cpp3(what, gctx) + ";";
			}
		}
		FsMemory(op, ex, __): {
			switch (op) {
				FmDup():      "perceus_dup(" + fsExp2cpp3(ex, gctx) + ");";
				FmDrop():     "perceus_drop(" + fsExp2cpp3(ex, gctx) + ");";
				FmReuse():    "perceus_reuse(" + fsExp2cpp3(ex, gctx) + ");";
				FmDispose():  "perceus_dispose(" + fsExp2cpp3(ex, gctx) + ");";
				FmIsUnique(): "perceus_is_unique(" + fsExp2cpp3(ex, gctx) + ");";
				FmDecRef():   "perceus_dec_ref(" + fsExp2cpp3(ex, gctx) + ");";
				FmNull():     "nullptr";
			}
		}
	}
}

fsSwitch2cpp3(sw: FsSwitch, sw_var: string, sw_cond: string, gctx: Cpp3GlobalContext) -> string {
	nondef_cases = filtermap(sw.cases, \c ->
		if (c.struct == "default") None() else Some(fsCase2cpp3(c, gctx))
	);
	all_cases = switch (find(sw.cases, \case -> case.struct == "default")) {
		Some(def_case): {
			concat(nondef_cases, [fsCase2cpp3(def_case, gctx)]);
		}
		None(): {
			path = findFlowPath(gctx.currentModule, true, gctx.config.config.includes, ".");
			//println("looking for a source of module: '" + gctx.currentModule + "' = " + path);
			src = fcFileSource(gctx.globEnv, path);
			//println("src:\n" + src + "\n");
			line_resolver = makeLineResolver(src);
			line_col = findLine(line_resolver, sw.start);
			concat(nondef_cases, [
				"default: " + fiWrapWithBraces(
					"std::cerr << \"unexpected case: \" << " + sw_cond + " << \" of type \" << string2std(type2s(" + sw_cond + ")) << \" = '" + sw_cond + "' in switch\" << std::endl;\n" +
					"std::cerr << \"module: " + gctx.currentModule + ", line: " + i2s(line_col.lineno) + ", col: " + i2s(line_col.column) + "\" << std::endl;\n" +
					//"std::cerr << \"Value:\\n\" << flow2string(Cast<" + fiType2cpp3(sw.switchType, gctx) + ">::template To<Flow>::conv(" + sw_var  +"))->toStd() << std::endl;\n" +
					//"std::cerr << R\"FLOW_LITERAL(\n" + toStringFormatted(sw)+ "\n)FLOW_LITERAL\" << std::endl;\n" +
					"exit(1);\n" +
					"break;"
				)
			]);
		}
	}
	"switch (" + sw_cond + ") {\n" +
		superglue(all_cases, \case -> strIndent(case), "\n") +
	"\n}";
}

fsCase2cpp3(c: FsCase, gctx: Cpp3GlobalContext) -> string {
	switch (lookupTree(gctx.program.names.structs, c.struct)) {
		Some(struct): {
			body = fsStat2cpp3(c.body, gctx);
			id = lookupTreeDef(gctx.structs2id, c.struct, -1);
			"case " + i2s(id) + " /*" + c.struct + "*/: " +
				fiWrapWithBraces(fiUnwrap(body, "{", "}") + "\nbreak;");

		}
		None(): {
			// default case
			if (c.struct != "default") fail0("struct is not found") else {
				body = fsStat2cpp3(c.body, gctx);
				"default: " + fiWrapWithBraces(body);
			}
		}
	}
}

fsStructSwitch2cpp3(sw: FsSwitch, typename: string, gctx: Cpp3GlobalContext) -> string {
	switch (lookupTree(gctx.program.names.structs, typename)) {
		Some(struct): {
			switch (find(sw.cases, \case -> case.struct == typename)) {
				Some(c): {
					fsStat2cpp3(c.body, gctx);
				}
				None(): {
					fail0("struct case is not found");
				}
			}
		}
		None(): {
			fail0("must be struct or union (type name): " + typename);
		}
	}
}

fsExp2cpp3(e : FsExp, gctx: Cpp3GlobalContext) -> string {
	switch (e) {
		FiVoid(__):      "";
		FiBool(b, __):   b2s(b);
		FiInt(i, __):    i2s(i);
		FiDouble(d, __): { 
			s = d2s(d);
			if (strContains(s, ".") || strContains(s, "e")) s else s + ".0";
		}
		FiString(s, __): {
			if (s == "") "String::make()" else {
				codes = s2a(s);
				if (exists(codes, \code -> 0xD800 <= code && code <= 0xDFFF)) {
					"String::make(std::vector<char16_t>{" + superglue(codes, i2s, ", ") + "})";
				} else {
					s1 = concatStrings(mapi(codes, \i, code ->
						if (code == 0x09) "\\t" else
						if (code == 0x0a) "\\n" else
						if (code == 0x0d) "\\r" else
						if (code == 0x22) "\\\"" else
						if (code == 0x5c) "\\\\" else
						if (0 < code && code < 0x80) fromCharCode(code) else
						"\\u" + lpad(formatHex(code), "0", 4)
					));
					"String::make(\"" + s1 + "\"s)";
				}
			}
		}
		FsCall(f, args, type, __): {
			f_type = cast(fsExpType(f): FiType -> FiTypeFunction);
			s_args = map(args, \arg -> fsExp2cpp3(arg, gctx));
			s_args_len = fold(s_args, 0, \acc, s_arg -> acc + strlen(s_arg) + 2);
			s_args_all = if (length(args) > 7 || s_args_len > 64 || exists(s_args, \s_arg -> strContains(s_arg, "\n"))) {
				strGlue(s_args, ",\n");
			} else {
				strGlue(s_args, ", ");
			}
			call_args = fiWrapWithPars(s_args_all);
			switch(f) {
				FsVar(name,__, kind, __): {
					toplevel: Maybe<FiDeclaration> = lookupTree(gctx.program.names.toplevel, name);
					typars = switch (toplevel) {
						Some(fn): {
							typars_instances = fiMatchTyparsOrdered(fn.type, f_type);
							if (length(typars_instances) == 0) "" else {
								"<" + superglue(typars_instances, \tp -> fiType2cpp3(tp, gctx), ", ") + ">";
							}
						}
						None(): "";
					}
					switch (lookupTree(gctx.natives, name)) {
						Some(nat): {
							switch (nat.inline) {
								Some(inline): inline.def(s_args);
								None(): gctx.varname2cpp(name) + typars + call_args;
							}
						}
						None(): {
							if (fiIsGlobalFunction(name, gctx.program.names)) {
								gctx.varname2cpp(name) + typars + call_args;
							} else {
								gctx.varname2cpp(name) + typars + "->call" + call_args;
							}
						}
					}
				}
				default: {
					fsExp2cpp3(f, gctx) + "->call" + call_args;
				}
			};
		}
		FsLambda(toplevel, closure, args, body, type, __): {
			fiType2cpp3(type, gctx) + "::make" +
			"([" + superglue(closure, \v -> gctx.varname2cpp(v.name), ", ") + "] " + fiFunArgs2cpp(args, gctx) +
			" " + fiWrapWithBraces(fsStat2cpp3(body, gctx)) +
			")";
		}
		FsCallPrim(op, es, type, __): fsCallPrim2cpp3(e, gctx);
		FsVar(name, type, kind, __):  gctx.varname2cpp(name);
	}
}

fsCallPrimPlus2cpp3(es : [FsExp], gctx : Cpp3GlobalContext, acc: [FsExp]) -> [FsExp] {
	fold(es, acc, \ac, e -> {
		switch (e) {
			FsCallPrim(op, es1, __, __): {
				switch (e.op) {
					FmPlusPrim(): fsCallPrimPlus2cpp3(es1, gctx, ac);
					default: concat(ac, [e]);
				}
			}
			default: concat(ac, [e]);
		}
	});
}

fsCallPrimMult2cpp3(es : [FsExp], gctx : Cpp3GlobalContext, acc: [FsExp]) -> [FsExp] {
	fold(es, acc, \ac, e -> {
		switch (e) {
			FsCallPrim(op, es1, __, __): {
				switch (e.op) {
					FmMulPrim(): fsCallPrimMult2cpp3(es1, gctx, ac);
					default: concat(ac, [e]);
				}
			}
			default: concat(ac, [e]);
		}
	});
}

fsCallPrim2cpp3(e : FsCallPrim, gctx : Cpp3GlobalContext) -> string {
	e2k = \x -> fsExp2cpp3(x, gctx);
	arg_type = if (length(e.es) > 0) fsExpType(e.es[0]) else FiTypeVoid();
	switch (e.op) {
		FmOrPrim():  "(" + e2k(e.es[0]) + " || " + e2k(e.es[1]) + ")";
		FmAndPrim(): "(" + e2k(e.es[0]) + " && " + e2k(e.es[1]) + ")";
		FmNotPrim(): "!" + e2k(e.es[0]);

		FmEqPrim():  "(Compare<" + fiType2cpp3(arg_type, gctx) + ">::cmp(" + e2k(e.es[0]) + ", " + e2k(e.es[1]) + ") == 0)";
		FmNePrim():  "(Compare<" + fiType2cpp3(arg_type, gctx) + ">::cmp(" + e2k(e.es[0]) + ", " + e2k(e.es[1]) + ") != 0)";
		FmLePrim():  "(Compare<" + fiType2cpp3(arg_type, gctx) + ">::cmp(" + e2k(e.es[0]) + ", " + e2k(e.es[1]) + ") <= 0)";
		FmGePrim():  "(Compare<" + fiType2cpp3(arg_type, gctx) + ">::cmp(" + e2k(e.es[0]) + ", " + e2k(e.es[1]) + ") >= 0)";
		FmLtPrim():  "(Compare<" + fiType2cpp3(arg_type, gctx) + ">::cmp(" + e2k(e.es[0]) + ", " + e2k(e.es[1]) + ") < 0)";
		FmGtPrim():  "(Compare<" + fiType2cpp3(arg_type, gctx) + ">::cmp(" + e2k(e.es[0]) + ", " + e2k(e.es[1]) + ") > 0)";

		FmPlusPrim():  {
			plus_args = fsCallPrimPlus2cpp3(e.es, gctx, []);
			if (e.type == FiTypeString()) {
				fold(tail(plus_args), e2k(plus_args[0]), \acc, arg ->
					"concatStrings(" + acc + ", " + e2k(arg) + ")"
				);
			} else {
				"(" + superglue(plus_args, e2k, " + ") + ")";
			}
		}
		FmMinusPrim(): "(" + e2k(e.es[0]) + " - " + e2k(e.es[1]) + ")"; 
		FmMulPrim(): {
			mult_args = fsCallPrimMult2cpp3(e.es, gctx, []);
			"(" + superglue(mult_args, e2k, " * ") + ")";
		}
		FmDivPrim():   "(" + e2k(e.es[0]) + " / " + e2k(e.es[1]) + ")";
		FmModPrim(): {
			if (e.type == FiTypeDouble()) {
				"fmod(" + e2k(e.es[0]) + ", " + e2k(e.es[1]) + ")";
			} else {
				"(" + e2k(e.es[0]) + " % " + e2k(e.es[1]) + ")";
			}
		}
		FmNegPrim():   "-" + e2k(e.es[0]);
		FmArrayPrim(): {
			arr_type = fiDearrayType(e.type);
			if (length(e.es) == 0) {
				"Vec<" + fiType2cpp3(arr_type, gctx) + ">::make()";
			} else {
				arr_s = map(e.es, e2k);
				if (length(arr_s) < 8 && !exists(arr_s, \s -> strContains(s, "\n"))) {
					"Vec<" + fiType2cpp3(arr_type, gctx) + ">::make({" + strGlue(arr_s, ", ") + "})";
				} else {
					"Vec<" + fiType2cpp3(arr_type, gctx) + ">::make({\n" + strIndent(strGlue(arr_s, ",\n")) + "\n})";
				}
			}
		}
		FmIndexPrim(): {
			switch (arg_type) {
				FiTypeFlow(): {
					e2k(e.es[0]) + "->toAArr()->getFlowItem(" + e2k(e.es[1]) + ")";
				}
				default:
					e2k(e.es[0]) + "->getItem(" + e2k(e.es[1]) + ")";
			}
		}
		FmDerefPrim(): {
			switch (arg_type) {
				FiTypeFlow(): {
					e2k(e.es[0]) + "->toARef()->getFlowRef()";
				}
				default: {
					e2k(e.es[0]) + "->getRef()";
				}
			}
		}
		FmRefPrim(): {
			ref_type = fiDerefType(e.type);
			"Ref<" + fiType2cpp3(ref_type, gctx) + ">::make(" + e2k(e.es[0]) + ")";
		}
		FmStructPrim(__): {
			struct_type = cast(e.type : FiType -> FiTypeName);
			"Str<" + fiStructName2cpp3(struct_type, gctx) + ">::make(" + strGlue(map(e.es, e2k), ", ") + ")";
		}
		FmFieldPrim(name): {
			if (name == "structname") {
				switch (arg_type) {
					FiTypeName(typename, params): {
						if (containsKeyTree(gctx.program.names.structs, typename)) {
							"String::make(\"" + typename + "\")";
						} else {
							e2k(e.es[0]) + "->toAStr()->name()";
						}
					}
					FiTypeFlow(): {
						e2k(e.es[0]) + "->toAStr()->name()";
					}
					default: fail0("accees to field '" + name + "' of non-field: " + fsExp2s(e.es[0]));
				}
			} else {
				switch (arg_type) {
					FiTypeFlow(): {
						e2k(e.es[0]) + "->toAStr()->getFlowField(String::make(\"" + name + "\"))";
					}
					default: e2k(e.es[0]) + "->" + gctx.varname2cpp(name);
				}
			}
		}
		FmCastPrim(from, to): {
			s = fsExp2cpp3(e.es[0], gctx);
			fiCpp3Cast(from, to, s, gctx);
		}
		FmIfPrim(): {
			"(" + fsExp2cpp3(e.es[0], gctx) + " ? \n" + 
				strIndent(fsExp2cpp3(e.es[1], gctx)) + 
			"\n : \n" + 
				strIndent(fsExp2cpp3(e.es[2], gctx)) + 
			")";
		}
		FmRequirePrim(flowfile): fail0("//TODO: FmRequire is not implemented in cpp3 backend" + flowfile);
		FmUnsafePrim(name): fail0("//TODO: FmUnsafe is not implemented in cpp3 backend" + name);
		FmReusePrim(__, reuse): {
			struct_type = cast(e.type : FiType -> FiTypeName);
			"Str<" + fiStructName2cpp3(struct_type, gctx) + ">::makeReuse(" + reuse + ", " + strGlue(map(e.es, e2k), ", ") + ")";
		}
	}
}

fiCpp3Cast(from: FiType, to: FiType, s: string, gctx: Cpp3GlobalContext) -> string {
	if (fiEqualTypes(from, to)) s else
	"Cast<" + fiType2cpp3(from, gctx) + ">::template To<" + fiType2cpp3(to, gctx) + ">::conv(" + s + ")";
}
