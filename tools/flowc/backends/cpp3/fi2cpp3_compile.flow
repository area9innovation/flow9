import tools/flowc/backends/cpp3/fi2cpp3_runtime;
import tools/flowc/backends/cpp3/fi2cpp3_compile_struct;
import tools/flowc/statements/fs_utils;
import tools/flowc/statements/fs_memory;
import tools/flowc/statements/fi2fs;
import tools/flowc/manipulation/eliminate_union_fields;

export {
	fiModule2cpp3(module : FiModule, gctx: Cpp3GlobalContext) -> Cpp3CompiledModule;
}

fiModule2cpp3(module : FiModule, gctx0: Cpp3GlobalContext) -> Cpp3CompiledModule {
	gctx = Cpp3GlobalContext(gctx0 with currentModule = module.fileinfo.flowfile);
	names = gctx.program.names;
	compiled_structs = map(module.structs, \struct -> 
		Cpp3CompiledDeclaration(struct.name, true, 
			fiStruct2cpp3(struct, gctx, true),
			fiStruct2cpp3(struct, gctx, false)
		)
	);
	decls = concat(
		module.natives,
		filtermap(module.initOrder, \name -> {
			switch (find(module.globalVars, \gv -> gv.name == name)) {
				Some(globalVar): Some(globalVar);
				None(): find(module.functions, \fn -> fn.name == name);
			}
		})
	);
	compiled_decls = filtermap(decls, \decl -> fiDeclaration2cpp3(decl, gctx));
	is_main = exists(module.functions, \fn -> fn.name == "main");
	Cpp3CompiledModule(
		gctx.flowfile2cpp(module.fileinfo.flowfile),
		is_main,
		concat(compiled_structs, compiled_decls),
		map(module.imports, \imp -> imp.flowfile),
		fiModuleNatives2cpp3(module, gctx)
	);
}

fiModuleNatives2cpp3(module: FiModule, gctx: Cpp3GlobalContext) -> [Cpp3Native] {
	missing_natives = ref [];
	natives = filtermap(module.natives, \nat -> {
		if (!fiCpp3IsNative(nat.name, gctx) && !contains(module.initOrder, nat.name)) {
			refArrayPush(missing_natives, nat.name);
		}
		lookupTree(gctx.natives, nat.name);
	});
	if (^missing_natives != []) {
		err = "Module " + module.fileinfo.flowfile + ": following native functions are not implemented in cpp3 runtime and doesn't have a flow fallbacks:\n" +
			strIndent(superglue(^missing_natives, \name -> "\t" + name, "\n"));
		refArrayPush(gctx.errors, err);
		fcPrintln(err, gctx.config.config.threadId);
	}
	natives;
}

cpp3InlineFunction(fn: FiFunctionDec) -> bool {
	if (!isEmptySet(fiCollectTypars(fn.type, makeSet()))) true else {
		if (!fiExpIsSimple(fn.lambda.body)) false else {
			fiExpAstNodesCount(fn.lambda.body) < 9;
		}
	}
}

fiDeclaration2cpp3(decl: FiDeclaration, gctx: Cpp3GlobalContext) -> Maybe<Cpp3CompiledDeclaration> {
	switch (decl) {
		FiGlobalVar(name, value, type,__,__): {
			Some(fiGlobalVar2cpp3(decl, gctx));
		}
		FiFunctionDec(name, lambda, type,__,__): {
			if (fiCpp3IsNative(name, gctx)) None() else {
				Some(fiFunc2cpp3(decl, gctx));
			}
		}
		FiNativeDec(name, __,type,__, fallback,__,__):
			maybeMap(lookupTree(gctx.natives, name), \nat -> 
				nat.declaration(gctx.typename2cpp, gctx.varname2cpp, gctx.structid2cpp)
			);
	}
}

fiGlobalVar2cpp3(globalVar : FiGlobalVar, gctx0: Cpp3GlobalContext) -> Cpp3CompiledDeclaration {
	names = gctx0.program.names;
	name = globalVar.name;
	gctx = Cpp3GlobalContext(gctx0 with 
		currentToplevel = Some(globalVar),
		toplevelTypars = fiCollectTypars(globalVar.type, makeSet())
	);
	value_cpp = fsExp2cpp3(fiPrepareExp2cpp3(globalVar.value, globalVar.type, gctx, ""), gctx);
	init = gctx.varname2cpp(name) + " = " + value_cpp + ";";
	if (containsSet(gctx.volatileVars, name)) {
		// Volatile variable
		gctx.volatileInit := concat(^(gctx.volatileInit), [init]);
		var_decl = fiType2cpp3(globalVar.type, gctx) + " " + gctx.varname2cpp(name) + ";\n\n";
		Cpp3CompiledDeclaration(name, false, "extern " + var_decl, var_decl);
	} else {
		// Constant variable
		var_def = "const " + fiType2cpp3(globalVar.type, gctx) + " " + init + "\n\n";
		Cpp3CompiledDeclaration(name, true, "", var_def);
	}
}

fiFunc2cpp3(fun: FiFunctionDec, gctx0: Cpp3GlobalContext) -> Cpp3CompiledDeclaration {
	name = fun.name;
	fn_type = fun.type;
	gctx = Cpp3GlobalContext(
		gctx0 with currentToplevel = Some(fun),
		toplevelTypars = fiCollectTypars(fn_type, makeSet())
	);
	fun_typars = map(set2array(fiCollectTypars(fn_type, makeSet())), \n -> FiTypeParameter(n));
	decl_typars = fiDeclTypars2cpp3(fun_typars, gctx);
	headerOnly = cpp3InlineFunction(fun);
	lambda_exp = fiPrepareExp2cpp3(fun.lambda, fn_type, gctx, name);
	//if (extractStructName(lambda_exp) != "FsLambda") {
	//	fail("in function " + fun.name + " expected FsLambda, got:\n" + fsExp2s(lambda_exp));
	//}
	// unwrap lambda from cast
	stat_lambda = switch (lambda_exp) {
		FsLambda(__,__,__,__,__,__): lambda_exp;
		FsCallPrim(op, es,__,__): {
			switch (op) {
				FsCastPrim(__,__): cast(es[0]: FsExp -> FsLambda);
				default: fail0("must be lambda or cast to lambda");
			}
		}
		default: fail0("must be lambda or cast to lambda");
	}
	fun_signature =
		(if (headerOnly) "inline " else "") + fiType2cpp3(fn_type.returnType, gctx) + " " + 
		gctx.varname2cpp(name) + fiFunArgs2cpp(stat_lambda.args, gctx);
	forward_decl = decl_typars + fun_signature + ";\n\n";
	cpp_body = fsStat2cpp3(stat_lambda.body, gctx);
	cpp_fun = if (!fsHasTailCall(stat_lambda.body)) cpp_body else {
		"while (true) " + fiWrapWithBraces(cpp_body);
	}
	definition = decl_typars + fun_signature + " " + fiWrapWithBraces(cpp_fun) + "\n\n";
	Cpp3CompiledDeclaration(name, headerOnly, forward_decl, definition);
}

fiPrepareExp2cpp3(e: FiExp, type: FiType, gctx: Cpp3GlobalContext, name: string) -> FsExp {
	names = gctx.program.names;
	/*if (name == "tryExtractStruct") {
		println("type: " + prettyFiType(dummyPretty, type, makeSet()));
	}*/
	show = false; //name == "main"; //setCommonXField
	pr = \x, i -> if (show) {
		println("e" + i2s(i) + ":\n" + prettyFiExp(dummyPretty, x));
	}
	// First phase: do some preparation steps
	e0 = fiEliminateUnionFields(e, names, 0);
	pr(e0, 0);
	e1 = fiExplicitCastInSwitch(e0, names);
	pr(e1, 1);
	e2 = fiFixVarInSameStructType(e1, makeTree(), names);
	pr(e2, 2);
	e3 = fiExpRenameRecurringVars(e2, makeSet());
	pr(e3, 3);
	e4 = fiExpMakeNoStatements(e3, gctx.effects);
	pr(e4, 4);

	pr2 = \x, i -> if (show) {
		println("x" + i2s(i) + ":\n" + fsExp2s(x));
	}

	// Second phase: transform to FsExp and do type interpolation/explicit casts
	x0 = fiExp2FsExp(e4, name, gctx.effects, names);
	pr2(x0, 0);
	x1 = fsExpSSA(x0, makeTree());
	pr2(x1, 1);
	x2 = fsInterpolateTyparsExp(x1, names);
	pr2(x2, 2);
	x3 = fsMakeExpCastsExplicit(x2, type, names, true);
	pr2(x3, 3);
	x4 = fsWrapExpCaseVarsWithCasts(x3, names);
	pr2(x4, 4);
	x5 = fsExpReturnVars(x4);
	pr2(x5, 5);

	// Memory: ref-counting operations are inserted
	x6 = fsExpPerceus(x5, name);
	x6;
}

fiFunArgs2cpp(args: [FiFunArg], gctx: Cpp3GlobalContext) -> string {
	arg2cpp = \i, arg -> {
		fiType2cpp3(arg.type, gctx) + " " + (if (arg.name == "__") arg.name + i2s(i) else gctx.varname2cpp(arg.name))
	};
	"(" + strGlue(mapi(args, arg2cpp), ", ") + ")";
}

fsStat2cpp3(stat : FsStat, gctx: Cpp3GlobalContext) -> string {
	switch (stat) {
		FsIf(cond, pos, neg,__,__): {
			cond_cpp = fsExp2cpp3(cond, gctx);
			pos_cpp = fsStat2cpp3(pos, gctx);
			neg_cpp = fsStat2cpp3(neg, gctx);
			if (pos_cpp != "") {
				if (neg_cpp != "") {
					"if " + fiWrapWithPars(cond_cpp) + " " + 
						fiWrapWithBraces(pos_cpp) +
					" else " + 
						fiWrapWithBraces(neg_cpp);
				} else {
					"if " + fiWrapWithPars(cond_cpp) + " " + 
						fiWrapWithBraces(pos_cpp);
				}
			} else {
				if (neg_cpp != "") {
					"if (!" + cond_cpp + ") " + 
						fiWrapWithBraces(neg_cpp);
				} else {
					"";
				}
			}
		}
		FsSwitch(x, sw_type, cases,__,__): {
			switch (x.type) {
				FiTypeName(typename,__): {
					switch (lookupTree(gctx.program.names.unions, typename)) {
						Some(__): {
							fsSwitch2cpp3(stat, gctx.varname2cpp(x.name), gctx.varname2cpp(x.name) + "->type()/*" + typename + "*/", gctx);
						}
						None(): {
							fsStructSwitch2cpp3(stat, typename, gctx);
						}
					}			
				}
				FiTypeFlow(): {
					fsSwitch2cpp3(stat, gctx.varname2cpp(x.name), gctx.varname2cpp(x.name) + "->type()/*Flow*/", gctx);
				}
				default:
					fail0("must be struct or union or flow type, got: " + prettyFiType(dummyPretty, x.type, makeSet()));
			}
		}
		FsSeq(es, type,__): {
			if (length(es) == 0) "" else
			if (length(es) == 1) fsStat2cpp3(es[0], gctx) else {
				strGlue(filter(map(es, \x -> fsStat2cpp3(x, gctx)), \s -> s != ""), "\n");
			}
		}
		FsLet(v, e, s,__,__): {
			if (v.name == "__") "" else {
				fiType2cpp3(v.type, gctx) + " " + gctx.varname2cpp(v.name) + " = " + 
				fsExp2cpp3(e, gctx) + ";\n" + 
				fsStat2cpp3(s, gctx);
			}
		}
		FsAtomic(): {
			fsAtomic2cpp3(stat, gctx);
		}
	}
}

fsAtomic2cpp3(a : FsAtomic, gctx: Cpp3GlobalContext) -> string {
	switch (a) {
		FsWrapExp(e, __): {
			e_cpp = fsExp2cpp3(e, gctx);
			if (e_cpp == "") "" else {
				e_cpp + ";";
			}
		}
		FsRet(e, __): {
			e_s = fsExp2cpp3(e, gctx);
			"return " + e_s + ";"
			/*if (fsExpType(e) == FiTypeVoid()) {
				if (e_s == "") "return;" else e_s + ";\nreturn;";
			} else {
				"return " + e_s + ";"
			}*/
		}
		FsTailCall(__): {
			"continue;";
		}
		FsVarDecl(var, __): {
			fiType2cpp3(var.type, gctx) + " " + fsExp2cpp3(var, gctx) + ";";
		}
		FsAssign(to, what, __): {
			switch (fsExpType(to)) {
				FiTypeRef(__): {
					switch (fsExpType(what)) {
						FiTypeRef(__):
							fsExp2cpp3(to, gctx) + " = " + fsExp2cpp3(what, gctx) + ";";
						FiTypeFlow(): 
							fsExp2cpp3(to, gctx) + "->setFlowRef(" + fsExp2cpp3(what, gctx) + ");";
						default:
							fsExp2cpp3(to, gctx) + "->setRef(" + fsExp2cpp3(what, gctx) + ");";
					}
				}
				default:
					fsExp2cpp3(to, gctx) + " = " + fsExp2cpp3(what, gctx) + ";";
			}
		}
		FsMemory(op, ex, __): {
			tp = fsExpType(ex);
			switch (op) {
				FsIncRC():   "RefCount<" + fiType2cpp3(tp, gctx) + ">::inc(" + fsExp2cpp3(ex, gctx) + ");";
				FsDecRC():   "RefCount<" + fiType2cpp3(tp, gctx) + ">::dec(" + fsExp2cpp3(ex, gctx) + ");";
				FsCheckRC(): "RefCount<" + fiType2cpp3(tp, gctx) + ">::check(" + fsExp2cpp3(ex, gctx) + ");";
				default:  fail0("memory operation: " + toString(op) + " is not implemented yet");
			}
			/*switch (tp) {
				FiTypeParameter(n): {
					switch (op) {
						FsDup():  "RefCount<" + fiType2cpp3(tp, gctx) + ">::inc(" + fsExp2cpp3(ex, gctx) + ");";
						FsDrop(): "RefCount<" + fiType2cpp3(tp, gctx) + ">::dec(" + fsExp2cpp3(ex, gctx) + ");";
						default:  fail0("memory operation: " + toString(op) + " is not implemented yet");
					}
				}
				default: {
					switch (op) {
						FsDup():  fsExp2cpp3(ex, gctx) + "->incRefs();";
						FsDrop(): fsExp2cpp3(ex, gctx) + "->decRefs();";
						default:  fail0("memory operation: " + toString(op) + " is not implemented yet");
					}
				}
			}*/
		}
	}
}

fsSwitch2cpp3(sw: FsSwitch, sw_var: string, sw_cond: string, gctx: Cpp3GlobalContext) -> string {
	nondef_cases = filtermap(sw.cases, \c ->
		if (c.struct == "default") None() else Some(fsCase2cpp3(c, gctx))
	);
	all_cases = switch (find(sw.cases, \case -> case.struct == "default")) {
		Some(def_case): {
			concat(nondef_cases, [fsCase2cpp3(def_case, gctx)]);
		}
		None(): {
			path = findFlowPath(gctx.currentModule, true, gctx.config.config.includes, ".");
			//println("looking for a source of module: '" + gctx.currentModule + "' = " + path);
			src = fcFileSource(gctx.globEnv, path);
			//println("src:\n" + src + "\n");
			line_resolver = makeLineResolver(src);
			line_col = findLine(line_resolver, sw.start);
			concat(nondef_cases, [
				"default: " + fiWrapWithBraces(
					"std::cerr << \"unexpected case: \" << " + sw_cond + " << \" of type \" << string2std(type2s(" + sw_cond + ")) << \" = '" + sw_cond + "' in switch\" << std::endl;\n" +
					"std::cerr << \"module: " + gctx.currentModule + ", line: " + i2s(line_col.lineno) + ", col: " + i2s(line_col.column) + "\" << std::endl;\n" +
					//"std::cerr << \"Value:\\n\" << flow2string(Cast<" + fiType2cpp3(sw.switchType, gctx) + ">::template To<Flow>::conv(" + sw_var  +"))->toStd() << std::endl;\n" +
					//"std::cerr << R\"FLOW_LITERAL(\n" + toStringFormatted(sw)+ "\n)FLOW_LITERAL\" << std::endl;\n" +
					"exit(1);\n" +
					"break;"
				)
			]);
		}
	}
	"switch (" + sw_cond + ") {\n" +
		superglue(all_cases, \case -> strIndent(case), "\n") +
	"\n}";
}

fsCase2cpp3(c: FsCase, gctx: Cpp3GlobalContext) -> string {
	switch (lookupTree(gctx.program.names.structs, c.struct)) {
		Some(struct): {
			body = fsStat2cpp3(c.body, gctx);
			id = lookupTreeDef(gctx.structs2id, c.struct, -1);
			"case " + i2s(id) + " /*" + c.struct + "*/: " +
				fiWrapWithBraces(fiUnwrap(body, "{", "}") + "\nbreak;");
		}
		None(): {
			// default case
			if (c.struct != "default") fail0("struct is not found") else {
				body = fsStat2cpp3(c.body, gctx);
				"default: " + fiWrapWithBraces(body);
			}
		}
	}
}

fsStructSwitch2cpp3(sw: FsSwitch, typename: string, gctx: Cpp3GlobalContext) -> string {
	switch (lookupTree(gctx.program.names.structs, typename)) {
		Some(struct): {
			switch (find(sw.cases, \case -> case.struct == typename)) {
				Some(c): {
					fsStat2cpp3(c.body, gctx);
				}
				None(): {
					fail0("struct case is not found");
				}
			}
		}
		None(): {
			fail0("must be struct or union (type name): " + typename);
		}
	}
}

fsExp2cpp3(e : FsExp, gctx: Cpp3GlobalContext) -> string {
	switch (e) {
		FiVoid(__):      "void_value";
		FiBool(b, __):   b2s(b);
		FiInt(i, __):    i2s(i);
		FiDouble(d, __): { 
			s = d2s(d);
			if (strContains(s, ".") || strContains(s, "e")) s else s + ".0";
		}
		FiString(s, __): {
			if (s == "") "String::make()" else {
				codes = s2a(s);
				if (exists(codes, \code -> 0xD800 <= code && code <= 0xDFFF)) {
					"String::make(std::vector<char16_t>{" + superglue(codes, i2s, ", ") + "})";
				} else {
					s1 = concatStrings(mapi(codes, \i, code ->
						if (code == 0x09) "\\t" else
						if (code == 0x0a) "\\n" else
						if (code == 0x0d) "\\r" else
						if (code == 0x22) "\\\"" else
						if (code == 0x5c) "\\\\" else
						if (0 < code && code < 0x80) fromCharCode(code) else
						"\\u" + lpad(formatHex(code), "0", 4)
					));
					"String::make(\"" + s1 + "\"s)";
				}
			}
		}
		FsCall(f, args, type, __): {
			f_type = cast(fsExpType(f): FiType -> FiTypeFunction);
			s_args = map(args, \arg -> fsExp2cpp3(arg, gctx));
			s_args_len = fold(s_args, 0, \acc, s_arg -> acc + strlen(s_arg) + 2);
			s_args_all = if (length(args) > 7 || s_args_len > 64 || exists(s_args, \s_arg -> strContains(s_arg, "\n"))) {
				strGlue(s_args, ",\n");
			} else {
				strGlue(s_args, ", ");
			}
			call_args = fiWrapWithPars(s_args_all);
			switch(f) {
				FsVar(name, traits,__,__): {
					toplevel: Maybe<FiDeclaration> = lookupTree(gctx.program.names.toplevel, name);
					typars = switch (toplevel) {
						Some(fn): {
							typars_instances = fiMatchTyparsOrdered(fn.type, f_type);
							if (length(typars_instances) == 0) "" else {
								"<" + superglue(typars_instances, \tp -> fiType2cpp3(tp, gctx), ", ") + ">";
							}
						}
						None(): "";
					}
					switch (lookupTree(gctx.natives, name)) {
						Some(nat): {
							switch (nat.inline) {
								Some(inline): inline.def(s_args);
								None(): gctx.varname2cpp(name) + typars + call_args;
							}
						}
						None(): {
							if (fsVarIsGlobalFunc(traits)) {
								gctx.varname2cpp(name) + typars + call_args;
							} else {
								gctx.varname2cpp(name) + typars + "->call" + call_args;
							}
						}
					}
				}
				default: {
					fsExp2cpp3(f, gctx) + "->call" + call_args;
				}
			};
		}
		FsLambda(toplevel, closure, args, body, type, __): {
			//ref_counted_closure = filter(closure, \v -> !fiTypeIsScalar(v.type));
			fiType2cpp3(type, gctx) + "::make" +
			"([" + superglue(closure, \v -> gctx.varname2cpp(v.name), ", ") + "] " + fiFunArgs2cpp(args, gctx) +
			" " + fiWrapWithBraces(fsStat2cpp3(body, gctx)) + 
				//", Vector<Flow>({" + superglue(ref_counted_closure, \v -> gctx.varname2cpp(v.name), ", ") + "})" +
			")";
		}
		FsCallPrim(op, es, type, __): fsCallPrim2cpp3(e, gctx);
		FsVar(name, traits, type,__): {
			if (fsVarIsGlobalFunc(traits)) gctx.varname2cpp(name) else 
			gctx.varname2cpp(name) + "/* first: " + b2s(traits.firstUse) + ", last: " + b2s(traits.lastUse) + ", kind: " + toString(traits.kind) + "*/";
		}
	}
}

fsCallPrimPlus2cpp3(es : [FsExp], gctx : Cpp3GlobalContext, acc: [FsExp]) -> [FsExp] {
	fold(es, acc, \ac, e -> {
		switch (e) {
			FsCallPrim(op, es1, __, __): {
				switch (e.op) {
					FsPlusPrim(): fsCallPrimPlus2cpp3(es1, gctx, ac);
					default: concat(ac, [e]);
				}
			}
			default: concat(ac, [e]);
		}
	});
}

fsCallPrimMult2cpp3(es : [FsExp], gctx : Cpp3GlobalContext, acc: [FsExp]) -> [FsExp] {
	fold(es, acc, \ac, e -> {
		switch (e) {
			FsCallPrim(op, es1, __, __): {
				switch (e.op) {
					FsMulPrim(): fsCallPrimMult2cpp3(es1, gctx, ac);
					default: concat(ac, [e]);
				}
			}
			default: concat(ac, [e]);
		}
	});
}

fsCallPrim2cpp3(e : FsCallPrim, gctx : Cpp3GlobalContext) -> string {
	e2k = \x -> fsExp2cpp3(x, gctx);
	arg_type = if (length(e.es) > 0) fsExpType(e.es[0]) else FiTypeVoid();
	switch (e.op) {
		FsOrPrim():  "(" + e2k(e.es[0]) + " || " + e2k(e.es[1]) + ")";
		FsAndPrim(): "(" + e2k(e.es[0]) + " && " + e2k(e.es[1]) + ")";
		FsNotPrim(): "!" + e2k(e.es[0]);

		FsEqPrim():  "(Compare<" + fiType2cpp3(arg_type, gctx) + ">::cmp(" + e2k(e.es[0]) + ", " + e2k(e.es[1]) + ") == 0)";
		FsNePrim():  "(Compare<" + fiType2cpp3(arg_type, gctx) + ">::cmp(" + e2k(e.es[0]) + ", " + e2k(e.es[1]) + ") != 0)";
		FsLePrim():  "(Compare<" + fiType2cpp3(arg_type, gctx) + ">::cmp(" + e2k(e.es[0]) + ", " + e2k(e.es[1]) + ") <= 0)";
		FsGePrim():  "(Compare<" + fiType2cpp3(arg_type, gctx) + ">::cmp(" + e2k(e.es[0]) + ", " + e2k(e.es[1]) + ") >= 0)";
		FsLtPrim():  "(Compare<" + fiType2cpp3(arg_type, gctx) + ">::cmp(" + e2k(e.es[0]) + ", " + e2k(e.es[1]) + ") < 0)";
		FsGtPrim():  "(Compare<" + fiType2cpp3(arg_type, gctx) + ">::cmp(" + e2k(e.es[0]) + ", " + e2k(e.es[1]) + ") > 0)";

		FsPlusPrim():  {
			plus_args = fsCallPrimPlus2cpp3(e.es, gctx, []);
			if (e.type == FiTypeString()) {
				fold(tail(plus_args), e2k(plus_args[0]), \acc, arg ->
					"concatStrings(" + acc + ", " + e2k(arg) + ")"
				);
			} else {
				"(" + superglue(plus_args, e2k, " + ") + ")";
			}
		}
		FsMinusPrim(): "(" + e2k(e.es[0]) + " - " + e2k(e.es[1]) + ")"; 
		FsMulPrim(): {
			mult_args = fsCallPrimMult2cpp3(e.es, gctx, []);
			"(" + superglue(mult_args, e2k, " * ") + ")";
		}
		FsDivPrim():   "(" + e2k(e.es[0]) + " / " + e2k(e.es[1]) + ")";
		FsModPrim(): {
			if (e.type == FiTypeDouble()) {
				"fmod(" + e2k(e.es[0]) + ", " + e2k(e.es[1]) + ")";
			} else {
				"(" + e2k(e.es[0]) + " % " + e2k(e.es[1]) + ")";
			}
		}
		FsNegPrim():   "-" + e2k(e.es[0]);
		FsArrayPrim(): {
			arr_type = fiDearrayType(e.type);
			if (length(e.es) == 0) {
				"Vec<" + fiType2cpp3(arr_type, gctx) + ">::make()";
			} else {
				arr_s = map(e.es, e2k);
				if (length(arr_s) < 8 && !exists(arr_s, \s -> strContains(s, "\n"))) {
					"Vec<" + fiType2cpp3(arr_type, gctx) + ">::make({" + strGlue(arr_s, ", ") + "})";
				} else {
					"Vec<" + fiType2cpp3(arr_type, gctx) + ">::make({\n" + strIndent(strGlue(arr_s, ",\n")) + "\n})";
				}
			}
		}
		FsIndexPrim(): {
			switch (arg_type) {
				FiTypeFlow(): {
					e2k(e.es[0]) + "->toAArr()->getFlowItem(" + e2k(e.es[1]) + ")";
				}
				default:
					e2k(e.es[0]) + "->getItem(" + e2k(e.es[1]) + ")";
			}
		}
		FsDerefPrim(): {
			switch (arg_type) {
				FiTypeFlow(): {
					e2k(e.es[0]) + "->toARef()->getFlowRef()";
				}
				default: {
					e2k(e.es[0]) + "->getRef()";
				}
			}
		}
		FsRefPrim(): {
			ref_type = fiDerefType(e.type);
			"Ref<" + fiType2cpp3(ref_type, gctx) + ">::make(" + e2k(e.es[0]) + ")";
		}
		FsStructPrim(__): {
			struct_type = cast(e.type : FiType -> FiTypeName);
			"Str<" + fiStructName2cpp3(struct_type, gctx) + ">::make(" + strGlue(map(e.es, e2k), ", ") + ")";
		}
		FsFieldPrim(name): {
			if (name == "structname") {
				switch (arg_type) {
					FiTypeName(typename, params): {
						if (containsKeyTree(gctx.program.names.structs, typename)) {
							"String::make(\"" + typename + "\")";
						} else {
							e2k(e.es[0]) + "->toAStr()->name()";
						}
					}
					FiTypeFlow(): {
						e2k(e.es[0]) + "->toAStr()->name()";
					}
					default: fail0("accees to field '" + name + "' of non-field: " + fsExp2s(e.es[0]));
				}
			} else {
				switch (arg_type) {
					FiTypeFlow(): {
						e2k(e.es[0]) + "->toAStr()->getFlowField(String::make(\"" + name + "\"))";
					}
					default: e2k(e.es[0]) + "->" + gctx.varname2cpp(name);
				}
			}
		}
		FsCastPrim(from, to): {
			s = fsExp2cpp3(e.es[0], gctx);
			fiCpp3Cast(from, to, s, gctx);
		}
		FsIfPrim(): {
			"(" + fsExp2cpp3(e.es[0], gctx) + " ? \n" + 
				strIndent(fsExp2cpp3(e.es[1], gctx)) + 
			"\n : \n" + 
				strIndent(fsExp2cpp3(e.es[2], gctx)) + 
			")";
		}
		FsRequirePrim(flowfile): fail0("//TODO: FsRequire is not implemented in cpp3 backend" + flowfile);
		FsUnsafePrim(name): fail0("//TODO: FsUnsafe is not implemented in cpp3 backend" + name);
		FsReusePrim(__, reuse): {
			struct_type = cast(e.type : FiType -> FiTypeName);
			"Str<" + fiStructName2cpp3(struct_type, gctx) + ">::makeReuse(" + reuse + ", " + strGlue(map(e.es, e2k), ", ") + ")";
		}
	}
}

fiCpp3Cast(from: FiType, to: FiType, s: string, gctx: Cpp3GlobalContext) -> string {
	if (fiEqualTypes(from, to)) s else
	"Cast<" + fiType2cpp3(from, gctx) + ">::template To<" + fiType2cpp3(to, gctx) + ">::conv(" + s + ")";
}
