import tools/flowc/backends/cpp3/fi2cpp3_runtime;
import tools/flowc/backends/cpp3/fi2cpp3_types;
import tools/flowc/backends/cpp3/fi2cpp3_structs;
import tools/flowc/statements/fs_tailcall;
import tools/flowc/statements/fs_module;

export {
	fiModule2cpp3(module : FsModule, gctx: Cpp3GlobalContext) -> Cpp3CompiledModule;
}

fiModule2cpp3(module : FsModule, gctx0: Cpp3GlobalContext) -> Cpp3CompiledModule {
	gctx = Cpp3GlobalContext(gctx0 with currentModule = module.fileinfo.flowfile);
	names = gctx.program.names;
	compiled_structs = fiStructs2cpp3(module.structs, gctx);
	decls = concat(
		module.natives,
		filtermap(module.initOrder, \name -> {
			switch (find(module.globalVars, \gv -> gv.name == name)) {
				Some(globalVar): Some(globalVar);
				None(): find(module.functions, \fn -> fn.name == name);
			}
		})
	);
	compiled_decls = filtermap(decls, \decl -> {
		start = fi2cpp3StartOperationMessage(gctx.config, 2, "compiling", decl.name);
		ret = fsDeclaration2cpp3(decl, gctx);
		fi2cpp3EndOperationMessage(gctx.config, 2, "compilation of", decl.name, start);
		ret;
	});
	is_main = exists(module.functions, \fn -> fn.name == "main");
	Cpp3CompiledModule(
		fi2cpp3flowfile2cpp(module.fileinfo.flowfile),
		is_main,
		concat(compiled_structs, compiled_decls),
		map(module.imports, \imp -> imp.flowfile),
		fiModuleNatives2cpp3(module, gctx),
	);
}

fiModuleNatives2cpp3(module: FsModule, gctx: Cpp3GlobalContext) -> [Cpp3Native] {
	missing_natives = ref [];
	natives = filtermap(module.natives, \nat -> {
		if (!fiCpp3IsNative(nat.name, gctx) && !contains(module.initOrder, nat.name)) {
			refArrayPush(missing_natives, nat.name);
		}
		lookupTree(gctx.natives, nat.name);
	});
	if (^missing_natives != []) {
		gctx.success := false;
		fcPrintln(
			"Module " + module.fileinfo.flowfile + ": following native functions are not implemented in cpp3 runtime and doesn't have a flow fallbacks:\n" +
			strIndent(superglue(^missing_natives, \name -> "\t" + name, "\n")), 
			gctx.config.threadId
		);
	}
	natives;
}

cpp3InlineFunction(fn: FsFunctionDec) -> bool {
	if (!isEmptySet(fiCollectTypars(fn.type, makeSet()))) true else {
		if (!fsIsSimple(fn.lambda.body)) false else {
			fsAstNodesCount(fn.lambda.body) < 9;
		}
	}
}

fsDeclaration2cpp3(decl: FsDeclaration, gctx: Cpp3GlobalContext) -> Maybe<Cpp3CompiledDeclaration> {
	switch (decl) {
		FsGlobalVar(name, value, type,__,__): {
			Some(fiGlobalVar2cpp3(decl, gctx));
		}
		FsFunctionDec(name, lambda, type,__,__): {
			if (fiCpp3IsNative(name, gctx)) None() else {
				Some(fiFunc2cpp3(decl, gctx));
			}
		}
		FsNativeDec(name, __,type,__,__,__):
			maybeMap(lookupTree(gctx.natives, name), \nat -> 
				nat.declaration(fi2cpp3typename2cpp, fi2cpp3varname2cpp, gctx.structid2cpp)
			);
	}
}

fiGlobalVar2cpp3(globalVar : FsGlobalVar, gctx0: Cpp3GlobalContext) -> Cpp3CompiledDeclaration {
	names = gctx0.program.names;
	name = globalVar.name;
	type = globalVar.type;
	gctx = Cpp3GlobalContext(gctx0 with 
		currentToplevel = None(),
		toplevelTypars = fiCollectTypars(type, makeSet()),
		currentToplevelName = name
	);
	init = switch (globalVar.value) {
		FsRet(e,__): {
			fi2cpp3varname2cpp(name) + " = " + fsExp2cpp3(e, gctx) + ";";
		}
		default: {
			value4 = fsStatReplaceReturnOntoAssign(globalVar.value, FsVarUse(FsVar(name, type), FsVarGlobalVar(), false, -1));
			"{\n" + strIndent(fsStat2cpp3(value4, gctx)) + "\n}";
		}
	}
	var_decl = fiType2cpp3(type, gctx) + " " + fi2cpp3varname2cpp(name) + ";\n\n";
	Cpp3CompiledDeclaration(name, false, "", "", "extern " + var_decl, var_decl, init);
}

fiFunc2cpp3(fun: FsFunctionDec, gctx0: Cpp3GlobalContext) -> Cpp3CompiledDeclaration {
	name = fun.name;
	fn_type = fun.type;
	gctx = Cpp3GlobalContext(
		gctx0 with currentToplevel = None(),
		toplevelTypars = fiCollectTypars(fn_type, makeSet()),
		currentToplevelName = name
	);
	fun_typars = map(set2array(fiCollectTypars(fn_type, makeSet())), \n -> FiTypeParameter(n));
	decl_typars = fiDeclTypars2cpp3(fun_typars, gctx);
	headerOnly = cpp3InlineFunction(fun);
	fun_signature =
		(if (headerOnly) "inline " else "") + fiType2cpp3(fn_type.returnType, gctx) + " " + 
		fi2cpp3varname2cpp(name) + fsArgs2cpp(fun.lambda.args, gctx);
	forward_decl = decl_typars + fun_signature + ";\n\n";
	cpp_body = fsStat2cpp3(fun.lambda.body, gctx);
	cpp_fun = if (!fsHasTailCall(fun.lambda.body)) cpp_body else {
		"while (true) " + fiWrapWithBraces(cpp_body, gctx.config);
	}
	definition = decl_typars + fun_signature + " " + fiWrapWithBraces(cpp_fun, gctx.config) + "\n\n";
	Cpp3CompiledDeclaration(name, headerOnly, "", "", forward_decl, definition, "");
}

fsArgs2cpp(args: [FsVar], gctx: Cpp3GlobalContext) -> string {
	arg2cpp = \i, arg -> {
		if (arg.name == "" || arg.name == "__") {
			fail("anonymous argument is met: '" + arg.name + "', must be prohibited");
		}
		fiType2cpp3(arg.type, gctx) + " " + fi2cpp3varname2cpp(arg.name)
	};
	"(" + strGlue(mapi(args, arg2cpp), ", ") + ")";
}

fsAppendIncs2cpp3(s: string, mem: FsMem, gctx: Cpp3GlobalContext) -> string {
	incs = superglue(tree2pairs(mem.incs),
		\p -> "incRc<" + fiType2cpp3(p.first.type, gctx) + ">(" + fi2cpp3varname2cpp(p.first.name) + ", " + i2s(p.second) + ");",
	"\n");
	if (incs == "") s else incs + "\n" + s;
}

fsAppendDecs2cpp3(s: string, mem: FsMem, gctx: Cpp3GlobalContext) -> string {
	decs = superglue(set2array(mem.decs),
		\v -> "decRc<" + fiType2cpp3(v.type, gctx) + ">(" + fi2cpp3varname2cpp(v.name) + ");",
	"\n");
	if (decs == "") s else decs + "\n" + s;
}

fsStat2cpp3(stat : FsStat, gctx: Cpp3GlobalContext) -> string {
	switch (stat) {
		FsIf(cond, pos, neg,__): {
			cond_cpp = fsExp2cpp3(cond, gctx);
			pos_cpp = fsStat2cpp3(pos, gctx);
			neg_cpp = fsStat2cpp3(neg, gctx);
			if (pos_cpp != "") {
				if (neg_cpp != "") {
					"if " + fiWrapWithPars(cond_cpp, gctx.config) + " " + 
						fiWrapWithBraces(pos_cpp, gctx.config) +
					" else " + 
						fiWrapWithBraces(neg_cpp, gctx.config);
				} else {
					"if " + fiWrapWithPars(cond_cpp, gctx.config) + " " + 
						fiWrapWithBraces(pos_cpp, gctx.config);
				}
			} else {
				if (neg_cpp != "") {
					"if (!" + cond_cpp + ") " + 
						fiWrapWithBraces(neg_cpp, gctx.config);
				} else {
					"";
				}
			}
		}
		FsSwitch(x, sw_type, cases,__): {
			fsSwitch2cpp3(stat, fsExp2cpp3(x, gctx) + "->typeIdRc()/*" + fiType2cpp3(fsType(x), gctx) + "*/", gctx);
		}
		FsSeq(es,__): {
			if (length(es) == 0) "" else
			if (length(es) == 1) fsStat2cpp3(es[0], gctx) else {
				strGlue(filter(map(es, \x -> fsStat2cpp3(x, gctx)), \s -> s != ""), "\n");
			}
		}
		FsLet(v, e, s,__): {
			if (v.name == "__") {
				fail0("definition of anonymous variable");
			} else {
				// `FiVoid` definition of a variable means that it is a forward declaration,
				// so the variable is not initialized at this place, but somewhere later
				init = switch (e) {
					FsConst(c,__): switch (c) {
						FiVoid(__): {
							switch (v.type) {
								FiTypeVoid(): "void_value";
								FiTypeBool(): "false";
								FiTypeInt(): "0";
								FiTypeDouble(): "0.0";
								FiTypeParameter(__): "makeDefInit<" + fiType2cpp3(v.type, gctx) + ">()";
								default: "nullptr";
							}
						}
						default: fsExp2cpp3(e, gctx);
					}
					default: fsExp2cpp3(e, gctx);
				}
				fiType2cpp3(v.type, gctx) + " " + fi2cpp3varname2cpp(v.name) + " = " + init + ";\n" +
				fsStat2cpp3(s, gctx);
			}
		}
		FsAtomic(): {
			fsAtomic2cpp3(stat, gctx);
		}
	}
}

fsAtomic2cpp3(a : FsAtomic, gctx: Cpp3GlobalContext) -> string {
	switch (a) {
		FsWrapExp(e, __): {
			e_cpp = fsExp2cpp3(e, gctx);
			if (e_cpp == "") "" else {
				tp = fsType(e);
				if (fiTypeIsScalar(tp)) {
					e_cpp + ";";
				} else {
					"decRc<" + fiType2cpp3(tp, gctx) + ">(" + e_cpp + ");";
				}
			}
		}
		FsRet(e,__): {
			"return " + fsExp2cpp3(e, gctx) + ";"
		}
		FsTailCall(id): {
			"continue;";
		}
		FsAssign(to, what,__): {
			to_type = fsType(to);
			make_assignment = \-> switch (to) {
				FsVarUse(v, kind,__,__): {
					switch (kind) {
						FsVarUninit(): fsExp2cpp3(to, gctx) + " = " + fsExp2cpp3(what, gctx) + ";";
						default: "assignRc<" + fiType2cpp3(to_type, gctx) + " >(" + fsExp2cpp3(to, gctx) + ", " + fsExp2cpp3(what, gctx) + ");";
					}
				}
				default:  fail0("assignment to non-var:\n" + fs2s(to));
			}
			switch (to_type) {
				FiTypeRef(__): {
					switch (fsType(what)) {
						FiTypeRef(__): {
							make_assignment();
						}
						FiTypeFlow():
							fsExp2cpp3(to, gctx) + "->setFlowRc(0, " + fsExp2cpp3(what, gctx) + ");";
						default:
							fsExp2cpp3(to, gctx) + "->setRc(" + fsExp2cpp3(what, gctx) + ");";
					}
				}
				default: {
					switch (to) {
						FsCallPrim(op, as,__,__): {
							switch (op) {
								FsFieldPrim(field, field_ind): {
									fsExp2cpp3(as[0], gctx) + "->setRc1<" + i2s(field_ind) + ">(" + fsExp2cpp3(what, gctx) + ");";
								}
								default: {
									fail0("assignment to non-var:\n" + fs2s(to));
								}
							}
						}
						default: {
							make_assignment();
						}
					}
				}
			}
		}
		FsIncRc(v, delta,__): {
			if (delta == 0) "" else {
				"incRc<" + fiType2cpp3(v.type, gctx) + ">(" + fi2cpp3varname2cpp(v.name) + (if (delta == 1) "" else ", " + i2s(delta)) + ");";
			}
		}
		FsDecRc(v, reuse,__): {
			if (reuse == "") {
				"decRc<" + fiType2cpp3(v.type, gctx) + ">(" + fi2cpp3varname2cpp(v.name) + ");";
			} else {
				fiType2cpp3(v.type, gctx) + " " + fi2cpp3varname2cpp(reuse) + " = decRcReuse<" + fiType2cpp3(v.type, gctx) + ">(" + fi2cpp3varname2cpp(v.name) + ");";
			}
		}
	}
}

fsSwitch2cpp3(sw: FsSwitch, sw_cond: string, gctx: Cpp3GlobalContext) -> string {
	nondef_cases = filtermap(sw.cases, \c ->
		if (c.struct == "default") None() else Some(fsCase2cpp3(c, gctx))
	);
	all_cases = switch (find(sw.cases, \case -> case.struct == "default")) {
		Some(def_case): {
			concat(nondef_cases, [fsCase2cpp3(def_case, gctx)]);
		}
		None(): {
			path = findFlowPath(gctx.currentModule, true, gctx.config.config.includes, ".");
			src = fcFileSource(gctx.globEnv, path);
			concat(nondef_cases, [
				"default: " + fiWrapWithBraces(
					"std::cerr << \"unexpected case: \" << " + sw_cond + " << \" of type \" << string2std(RTTI::typeName(" + sw_cond + ")) << \" = '" + sw_cond + "' in switch\" << std::endl;\n" +
					"exit(1);\n" +
					"break;", gctx.config
				)
			]);
		}
	}
	"switch (" + sw_cond + ") {\n" +
		superglue(all_cases, \case -> strIndent(case), "\n") +
	"\n}";
}

fsCase2cpp3(c: FsCase, gctx: Cpp3GlobalContext) -> string {
	switch (lookupTree(gctx.program.names.structs, c.struct)) {
		Some(struct): {
			body = fsStat2cpp3(c.body, gctx);
			id = eitherMap(lookupTree(gctx.structs2cpp, c.struct), \str -> str.id, -1);
			"case " + i2s(id) + " /*" + c.struct + "*/: " +
				fiWrapWithBraces(fiUnwrap(body, "{", "}") + "\nbreak;", gctx.config);
		}
		None(): {
			// default case
			if (c.struct != "default") fail0("struct is not found") else {
				body = fsStat2cpp3(c.body, gctx);
				"default: " + fiWrapWithBraces(body, gctx.config);
			}
		}
	}
}

fsExp2cpp3(e : FsExp, gctx: Cpp3GlobalContext) -> string {
	switch (e) {
		FsConst(x,__): {
			switch (x) {
				FiVoid(__):      "void_value";
				FiBool(b, __):   b2s(b);
				FiInt(i, __):    i2s(i);
				FiDouble(d, __): { 
					s = d2s(d);
					if (strContains(s, ".") || strContains(s, "e")) s else s + ".0";
				}
				FiString(s, __): {
					if (s == "") "String::make()" else {
						codes = s2a(s);
						if (exists(codes, \code -> 0xD800 <= code && code <= 0xDFFF)) {
							"String::make(std::vector<char16_t>{" + superglue(codes, i2s, ", ") + "})";
						} else {
							s1 = concatStrings(mapi(codes, \i, code ->
								if (code == 0x09) "\\t" else
								if (code == 0x0a) "\\n" else
								if (code == 0x0d) "\\r" else
								if (code == 0x22) "\\\"" else
								if (code == 0x5c) "\\\\" else
								if (0 < code && code < 0x80) fromCharCode(code) else
								"\\u" + lpad(formatHex(code), "0", 4)
							));
							"String::make(\"" + s1 + "\"s)";
						}
					}
				}
			}
		}
		FsCall(f, args, type,__): {
			f_raw_type = fsType(f);
			f_type = switch (f_raw_type) {
				FiTypeFunction(__,__): f_raw_type;
				default: fail0("call first argument must have a functional type, got: \n" + 
					pretFiType(f_raw_type) + "\n" +
					"while compiling: " + gctx.currentToplevelName + "\n" +
					"expression:\n" + fs2s(e)
				);
			}
			s_args = map(args, \arg -> fsExp2cpp3(arg, gctx));
			s_args_len = fold(s_args, 0, \acc, s_arg -> acc + strlen(s_arg) + 2);
			s_args_all = if (gctx.config.debug || length(args) > 7 || s_args_len > 64 || exists(s_args, \s_arg -> strContains(s_arg, "\n"))) {
				strGlue(s_args, ",\n");
			} else {
				strGlue(s_args, ", ");
			}
			call_args = fiWrapWithPars(s_args_all, gctx.config);
			switch(f) {
				FsVarUse(v, kind,__,__): {
					toplevel: Maybe<FiDeclaration> = lookupTree(gctx.program.names.toplevel, v.name);
					typars = switch (toplevel) {
						Some(fn): {
							typars_instances = fiMatchTyparsOrdered(fn.type, f_type);
							if (length(typars_instances) == 0) "" else {
								"<" + superglue(typars_instances, \tp -> fiType2cpp3(tp, gctx), ", ") + ">";
							}
						}
						None(): "";
					}
					switch (lookupTree(gctx.natives, v.name)) {
						Some(nat): {
							switch (nat.inline) {
								Some(inline): inline.def(s_args);
								None(): fi2cpp3varname2cpp(v.name) + typars + call_args;
							}
						}
						None(): {
							switch (kind) {
								FsVarGlobalFunc(): {
									fi2cpp3varname2cpp(v.name) + typars + call_args;
								}
								default: {
									fi2cpp3varname2cpp(v.name) + typars + "->callRc" + call_args;
								}
							}
						}
					}
				}
				default: {
					fsExp2cpp3(f, gctx) + "->callRc" + call_args;
				}
			};
		}
		FsClosure(closure, lambda,__): {
			ref_counted_closure = filter(closure, \v -> !fiTypeIsScalar(v.var.type));
			closure_vars_1 = "[" + superglue(closure, \v -> fi2cpp3varname2cpp(v.var.name), ", ") + "]";
			closure_vars_2 = superglue(ref_counted_closure, \v -> fi2cpp3varname2cpp(v.var.name), ", ");
			"Fun<" + fiType2cpp3(lambda.type.returnType, gctx) + concatStrings(map(lambda.type.args, \arg -> ", " + fiType2cpp3(arg.type, gctx))) + ">::make" +
			"(" + closure_vars_1 + " " + fsArgs2cpp(lambda.args, gctx) +
			" " + fiWrapWithBraces(fsStat2cpp3(lambda.body, gctx), gctx.config) +
				(if (closure_vars_2 == "") "" else ", " + closure_vars_2) +
			")";
		}
		FsCallPrim(op, es, type,__): {
			fsCallPrim2cpp3(e, gctx);
		}
		FsCast(e1, from, to,__): {
			from_cpp = fiType2cpp3(from, gctx);
			to_cpp = fiType2cpp3(to, gctx);
			e1_cpp = fsExp2cpp3(e1, gctx);
			if (from_cpp == to_cpp) e1_cpp else {
				"castRc<" + from_cpp + ", " + to_cpp + ">(" + e1_cpp + ")";
			}
		}
		FsVarUse(v,__,__,__): {
			fi2cpp3varname2cpp(v.name);
		}
	}
}

fsCallPrimPlus2cpp3(es : [FsExp], gctx : Cpp3GlobalContext, acc: [FsExp]) -> [FsExp] {
	fold(es, acc, \ac, e -> {
		switch (e) {
			FsCallPrim(op, es1, __,__): {
				switch (e.op) {
					FsPlusPrim(): fsCallPrimPlus2cpp3(es1, gctx, ac);
					default: concat(ac, [e]);
				}
			}
			default: concat(ac, [e]);
		}
	});
}

fsCallPrimMult2cpp3(es : [FsExp], gctx : Cpp3GlobalContext, acc: [FsExp]) -> [FsExp] {
	fold(es, acc, \ac, e -> {
		switch (e) {
			FsCallPrim(op, es1, __,__): {
				switch (e.op) {
					FsMulPrim(): fsCallPrimMult2cpp3(es1, gctx, ac);
					default: concat(ac, [e]);
				}
			}
			default: concat(ac, [e]);
		}
	});
}

fsCallPrim2cpp3(e : FsCallPrim, gctx : Cpp3GlobalContext) -> string {
	e2k = \x -> fsExp2cpp3(x, gctx);
	arg_type = if (length(e.es) > 0) fsType(e.es[0]) else FiTypeVoid();
	switch (e.op) {
		FsOrPrim():  "(" + e2k(e.es[0]) + " || " + e2k(e.es[1]) + ")";
		FsAndPrim(): "(" + e2k(e.es[0]) + " && " + e2k(e.es[1]) + ")";
		FsNotPrim(): "!" + e2k(e.es[0]);

		FsEqPrim():  "(compare<" + fiType2cpp3(arg_type, gctx) + ">(" + e2k(e.es[0]) + ", " + e2k(e.es[1]) + ") == 0)";
		FsNePrim():  "(compare<" + fiType2cpp3(arg_type, gctx) + ">(" + e2k(e.es[0]) + ", " + e2k(e.es[1]) + ") != 0)";
		FsLePrim():  "(compare<" + fiType2cpp3(arg_type, gctx) + ">(" + e2k(e.es[0]) + ", " + e2k(e.es[1]) + ") <= 0)";
		FsGePrim():  "(compare<" + fiType2cpp3(arg_type, gctx) + ">(" + e2k(e.es[0]) + ", " + e2k(e.es[1]) + ") >= 0)";
		FsLtPrim():  "(compare<" + fiType2cpp3(arg_type, gctx) + ">(" + e2k(e.es[0]) + ", " + e2k(e.es[1]) + ") < 0)";
		FsGtPrim():  "(compare<" + fiType2cpp3(arg_type, gctx) + ">(" + e2k(e.es[0]) + ", " + e2k(e.es[1]) + ") > 0)";

		FsPlusPrim():  {
			plus_args = fsCallPrimPlus2cpp3(e.es, gctx, []);
			if (e.type == FiTypeString()) {
				fold(tail(plus_args), e2k(plus_args[0]), \acc, arg ->
					"concatStringsRc(" + acc + ", " + e2k(arg) + ")"
				);
			} else {
				"(" + superglue(plus_args, e2k, " + ") + ")";
			}
		}
		FsMinusPrim(): "(" + e2k(e.es[0]) + " - " + e2k(e.es[1]) + ")"; 
		FsMulPrim(): {
			mult_args = fsCallPrimMult2cpp3(e.es, gctx, []);
			"(" + superglue(mult_args, e2k, " * ") + ")";
		}
		FsDivPrim():   "(" + e2k(e.es[0]) + " / " + e2k(e.es[1]) + ")";
		FsModPrim(): {
			if (e.type == FiTypeDouble()) {
				"fmod(" + e2k(e.es[0]) + ", " + e2k(e.es[1]) + ")";
			} else {
				"(" + e2k(e.es[0]) + " % " + e2k(e.es[1]) + ")";
			}
		}
		FsNegPrim():   "-" + e2k(e.es[0]);
		FsArrayPrim(): {
			arr_type = fiDearrayType(e.type);
			if (length(e.es) == 0) {
				"Vec<" + fiType2cpp3(arr_type, gctx) + ">::make()";
			} else {
				arr_s = map(e.es, e2k);
				s1 = strGlue(arr_s, ", ");
				if (!gctx.config.debug && strlen(s1) < 64 && !strContains(s1, "\n")) {
					"Vec<" + fiType2cpp3(arr_type, gctx) + ">::make({" + s1 + "})";
				} else {
					"Vec<" + fiType2cpp3(arr_type, gctx) + ">::make({\n" + strIndent(strGlue(arr_s, ",\n")) + "\n})";
				}
			}
		}
		FsIndexPrim(): {
			switch (arg_type) {
				FiTypeFlow(): {
					e2k(e.es[0]) + "->getFlowRc1(" + e2k(e.es[1]) + ")";
				}
				default:
					e2k(e.es[0]) + "->getRc1(" + e2k(e.es[1]) + ")";
			}
		}
		FsDerefPrim(): {
			switch (arg_type) {
				FiTypeFlow(): {
					e2k(e.es[0]) + "->getFlowRc1(0)";
				}
				default: {
					e2k(e.es[0]) + "->getRc1()";
				}
			}
		}
		FsRefPrim(): {
			ref_type = fiDerefType(e.type);
			"Ref<" + fiType2cpp3(ref_type, gctx) + ">::make(" + e2k(e.es[0]) + ")";
		}
		FsStructPrim(__, reuse): {
			struct_type = cast(e.type : FiType -> FiTypeName);
			struct_name = fiStructName2cpp3(struct_type, gctx);
			if (reuse == "") {
				args = map(e.es, e2k);
				struct_name + "::template make<" + struct_name + "*>(" + strGlue(args, ", ") + ")";
			} else {
				args = concat([fi2cpp3varname2cpp(reuse)], map(e.es, e2k));
				struct_name + "::template makeOrReuse<" + struct_name + "*>(" + strGlue(args, ", ") + ")";
			}
		}
		FsFieldPrim(field_name, field_ind): {
			if (field_name == "structname") {
				switch (arg_type) {
					FiTypeName(struct_name, params): {
						if (containsKeyTree(gctx.program.names.structs, struct_name)) {
							"String::make(\"" + struct_name + "\")";
						} else {
							"String::make(RTTI::typeName(" + e2k(e.es[0]) + "->typeId()))";
						}
					}
					FiTypeFlow(): {
						"String::make(RTTI::typeName(" + e2k(e.es[0]) + "->typeId()))";
					}
					default: fail0("accees to field '" + field_name + "' of non-struct: " + fs2s(e.es[0]) + " of type: " + prettyFiType(dummyPretty, arg_type, makeSet()));
				}
			} else {
				switch (arg_type) {
					FiTypeFlow(): {
						e2k(e.es[0]) + "->getFlowRc1(String::make(\"" + field_name + "\"))";
					}
					FiTypeName(struct_name,__): {
						e2k(e.es[0]) + "->template getRc1<" + i2s(field_ind) + ">()";
					}
					default: {
						fail0("accees to field '" + field_name + "' of non-struct: " + fs2s(e.es[0]) + " of type: " + prettyFiType(dummyPretty, arg_type, makeSet()));
					}
				}
			}
		}
	}
}
