import tools/flowc/backends/common;
import tools/flowc/backends/cpp3/fi2cpp3_util;

export {
	CppNative(
		name: string,
		def: ((string) -> string, (string) -> string) -> string,
		from: string
	);

	fiCpp3Runtime(type_nm: (string) -> string, var_nm: (string) -> string, cfg : FiCpp3Config) -> string;
	fiCpp3IsNative(name : string) -> bool;
	fiCpp3NativeFuncs : Tree<string, ((string) -> string, (string) -> string) -> string>;
	fiCpp3NativeInlines : Tree<string, ([string], FiTypeFunction) -> string>;
}

fiCpp3Runtime(type_nm: (string) -> string, var_nm: (string) -> string, cfg : FiCpp3Config) -> string {
"#include tools/flowc/backends/cpp3/flow_runtime.hpp" + "\n" +
"namespace flow {
template<typename T>
T " + var_nm("for") + "(T v, Fun<Bool, T> p, Fun<T, T> fn) {
	while (p(v)) v = fn(v);
	return v;
}

}\n";
}

fiCpp3IsNative(name : string) -> bool {
	name == "for" ||
	containsKeyTree(fiCpp3NativeFuncs, name) ||
	containsKeyTree(fiCpp3NativeInlines, name)
}

fiCpp3NativeInlines = pairs2tree([
/*	Pair("length", \args, __ -> args[0] + ".size"),
	Pair("concat", \args, __ -> args[0] + ".plus(" + args[1] + ").toCollection(ArrayList())"),
	Pair("fold", \args, __ -> args[0] + ".fold(" + args[1] + ", " + args[2] + ")"),
	Pair("foldi", \args, __ -> args[0] + ".foldIndexed(" + args[1] + ", " + args[2] + ")"),
	Pair("map", \args, f_type ->
		args[0] + ".map(" + args[1] + ").toCollection(ArrayList())"
	),
	Pair("mapi", \args, f_type -> 
		args[0] + ".mapIndexed(" + args[1] + ").toCollection(ArrayList())"
	),
	Pair("filter", \args, f_type -> 
		args[0] + ".filter(" + args[1] + ").toCollection(ArrayList())"
	),
	Pair("isSameStructType", \args, __ -> "(" + args[0] + "::class == " + args[1] + "::class)"),
	Pair("quit", \args, __ -> "cpp3.system.exitProcess(" + args[0] + ")"),
	Pair("println2", \args, f_type -> {
		switch (f_type.args[0].type) {
			FiTypeString(): "println(" + args[0] + ")";
			default: "println(toString(" + args[0] + "))";
		}
	}),
	Pair("i2s", \args, __ -> args[0] + ".toString()"),
	Pair("d2s", \args, __ -> args[0] + ".toString()"),
	Pair("i2d", \args, __ -> args[0] + ".toDouble()"),
	Pair("exp", \args, __ -> "cpp3.math.exp(" + args[0] + ")"),
	Pair("log", \args, __ -> "cpp3.math.ln(" + args[0] + ")"),
	Pair("trunc", \args, __ -> "cpp3.math.truncate(" + args[0] + ").toInt()"),
	Pair("strlen", \args, __ -> args[0] + ".length"),
	//Pair("s2a", \args, __ -> args[0] + ".toCharArray().map({___char___ -> ___char___.toInt()}).toTypedArray()"),
	Pair("bitAnd", \args, __ -> "(" + args[0] + " and " + args[1] + ")"),
	Pair("bitOr", \args, __ -> "(" + args[0] + " or " + args[1] + ")"),
	Pair("bitXor", \args, __ -> "(" + args[0] + " xor " + args[1] + ")"),
	Pair("bitNot", \args, __ -> args[0] + ".inv()"),
	Pair("bitShl", \args, __ -> "(" + args[0] + " shl " + args[1] + ")"),
	Pair("bitUshr", \args, __ -> "(" + args[0] + " ushr " + args[1] + ")"),
	Pair("getCharCodeAt", \args, __ -> args[0] + ".codePointAt(" + args[1] + ")"),
	Pair("getCharAt", \args, __ -> args[0] + ".get(" + args[1] + ").toString()"),
	Pair("fromCharCode", \args, __ -> "String(charArrayOf(" + args[0] + ".toChar()))"),
	Pair("toString2", \args, __ -> "toString(" + args[0] + ")"),
	Pair("toLowerCase", \args, __ -> args[0] + ".lowercase()"), 
	Pair("toUpperCase", \args, __ -> args[0] + ".uppercase()"),
	Pair("strIndexOf", \args, __ -> args[0] + ".indexOf(" + args[1] + ")"),
	Pair("getKeyValueN", \args, __ -> args[1]),
	Pair("fail", \args, __ -> "assert(false, { -> " + args[0] + "})"),

	Pair("flow2i", \args, __ -> "fflow2i(" + args[0] + ")"),
	Pair("flow2d", \args, __ -> "fflow2d(" + args[0] + ")"),
	Pair("flow2b", \args, __ -> "fflow2b(" + args[0] + ")"),
	Pair("flow2s", \args, __ -> "fflow2s(" + args[0] + ")"),
	Pair("timer", \args, __ -> "timer(" + args[0] +  ", " + args[1] + ")"),

	/*
native makeNativeHashMap : (hash :(?) -> int, cap : int, load : double) -> native = NativeHashMap.init;
native setNativeHashMap : (m : native, key : ?, value : ??) -> void = NativeHashMap.set;
native getNativeHashMap : (m : native, key : ?) -> Maybe<??> = NativeHashMap.get;
native removeNativeHashMap : (m : native, key : ?) -> void = NativeHashMap.remove;
native containsNativeHashMap : (m : native, key : ?) -> bool = NativeHashMap.contains;
native sizeNativeHashMap : (m : native) -> int = NativeHashMap.size;
native clearNativeHashMap : (m : native) -> void = NativeHashMap.clear;
native cloneNativeHashMap : (m : native) -> native = NativeHashMap.clone;
native iterNativeHashMap : (m : native, f : (?, ??) -> void) -> void = NativeHashMap.iter;
native funcNativeHashMap : (m : native) -> (?) -> int = NativeHashMap.hash;
* /

	//Pair("makeNativeHashMap")
*/
]);

fiCpp3NativeFuncs = pairs2tree([

Pair("length", \type_nm, var_nm -> 
"template<typename T>
inline Int " + var_nm("length") + "(Arr<T> a) { 
	return a.arr->size(); 
}\n"),
Pair("concat", \type_nm, var_nm -> 
"template<typename T>
inline Arr<T> " + var_nm("concat") + "(Arr<T> a1, Arr<T> a2) {
	Arr<T> ret = Arr<T>(a1.arr->size() + a2.arr->size());
	for(T x : *a1.arr) ret.arr->push_back(x);
	for(T x : *a2.arr) ret.arr->push_back(x);
	return ret;
}\n"),
Pair("fold", \type_nm, var_nm -> 
"template<typename T, typename V>
inline V " + var_nm("fold") + "(Arr<T> a, V v, Fun<V, V, T> fn) {
	for (T x : *a.arr) v = fn(v, x);
	return v;
}\n"),
Pair("foldi", \type_nm, var_nm -> 
"template<typename T, typename V>
inline V " + var_nm("foldi") + "(Arr<T> a, V v, Fun<V, Int, V, T> fn) {
	Int i = 0;
	for (T x : *a.arr) v = fn(i++, v, x);
	return v;
}\n"),
Pair("map", \type_nm, var_nm -> 
"template<typename T, typename V>
inline Arr<V> " + var_nm("map") + "(Arr<T> a, Fun<V, T> fn) {
	Arr<V> ret(a.arr->size());
	for (T x : *a.arr) ret.arr->push_back(fn(x));
	return ret;
}\n"),
Pair("
mapi", \type_nm, var_nm -> 
"template<typename T, typename V>
inline Arr<V> " + var_nm("mapi") + "(Arr<T> a, Fun<V, Int, T> fn) {
	Arr<V> ret(a.arr->size());
	Int i = 0;
	for (T x : *a.arr) ret.arr->push_back(fn(i++, x));
	return ret;
}\n"),
Pair("filter", \type_nm, var_nm -> 
"template<typename T>
inline Arr<T> " + var_nm("filter") + "(Arr<T> a, Fun<Bool, T> fn) {
	Arr<T> ret(a.arr->size());
	for (T x : *a.arr) if (fn(x)) ret.arr->push_back(x);
	return ret;
}\n"),
Pair("isSameStructType", \type_nm, var_nm -> 
"inline Bool " + var_nm("isSameStructType") + "(Flow o1, Flow o2) {
	if (o1.index() != Type::STRUCT || o2.index() != Type::STRUCT) {
		return false;
	} else {
		return std::get<Ptr<Struct>>(o1)->name() == std::get<Ptr<Struct>>(o2)->name();
	}
}\n"),
Pair("quit", \type_nm, var_nm -> "void " + var_nm("quit") + "(Int code) { exit(code); }\n\n"),
Pair("println2", \type_nm, var_nm -> 
"void " + var_nm("println2") + "(Flow x) { 
	flow2string(x, std::cout); std::cout << std::endl; 
}\n"),
Pair("i2s", \type_nm, var_nm -> "String " + var_nm("i2s") + "(Int x) { return makeString(std::to_string(x)); }\n\n"),
Pair("d2s", \type_nm, var_nm -> "String " + var_nm("d2s") + "(Double x) { std::ostringstream os; os << x; return makeString(os.str()); }\n\n"),
Pair("i2d", \type_nm, var_nm -> "Double " + var_nm("i2d") + "(Int x) { return x; }\n\n"),
Pair("exp", \type_nm, var_nm -> "Double " + var_nm("exp") + "(Double x) { return exp(x); }\n\n"),
Pair("log", \type_nm, var_nm -> "Double " + var_nm("log") + "(Double x) { return log(x); }\n\n"),
Pair("trunc", \type_nm, var_nm -> "Int " + var_nm("trunc") + "(Double x) { return trunc(x); } \n\n"),
Pair("strlen", \type_nm, var_nm -> "Int " + var_nm("strlen") + "(String s) { return s->size(); }\n\n"),
//Pair("s2a", \type_nm, var_nm ->args[0] + ".toCharArray().map({___char___ -> ___char___.toInt()}).toTypedArray()"),
Pair("bitAnd", \type_nm, var_nm -> "Int " + var_nm("bitAnd") + "(Int x, Int y) { return x & y; }\n\n"),
Pair("bitOr", \type_nm, var_nm -> "Int " + var_nm("bitOr") + "(Int x, Int y) { return x | y; }\n\n"),
Pair("bitXor", \type_nm, var_nm -> "Int " + var_nm("bitXor") + "(Int x, Int y) { return x ^ y; }\n\n"),
Pair("bitNot", \type_nm, var_nm -> "Int " + var_nm("bitNot") + "(Int x) { return ~x; }\n\n"),
Pair("bitShl", \type_nm, var_nm -> "Int " + var_nm("bitShl") + "(Int x, Int y) { return x << y; }\n\n"),
Pair("bitUshr", \type_nm, var_nm -> "Int " + var_nm("bitUshr") + "(Int x, Int y) { return x >> y; }\n\n"),
Pair("getCharCodeAt", \type_nm, var_nm -> "Int " + var_nm("getCharCodeAt") + "(String s, Int i) { return s->at(i); }\n\n"),
Pair("getCharAt", \type_nm, var_nm -> "String " + var_nm("getCharAt") + "(String s, Int i) { return makeString(s->at(i)); }\n\n"),
Pair("fromCharCode", \type_nm, var_nm -> "String " + var_nm("fromCharCode") + "(Int code) { return makeString(code); }\n\n"),
Pair("toString2", \type_nm, var_nm -> 
"String " + var_nm("toString2") + "(Flow x) {
	std::ostringstream os;
	flow2string(x, os);
	return makeString(os.str());
}\n"),
Pair("toLowerCase", \type_nm, var_nm -> 
"String " + var_nm("toLowerCase") + "(String s) {
	String lower = makeString(s);
	std::transform(lower->begin(), lower->end(), lower->begin(), [](auto c){ return std::tolower(c); });
	return lower;
}\n"), 
Pair("toUpperCase", \type_nm, var_nm -> 
"String " + var_nm("toUpperCase") + "(String s) {
	String upper = makeString(s);
	std::transform(upper->begin(), upper->end(), upper->begin(), [](auto c){ return std::toupper(c); });
	return upper;
}\n"),
Pair("strIndexOf", \type_nm, var_nm -> 
"Int " + var_nm("strIndexOf") + "(String s, String p) {
	auto i = s->find(*p);
	return (i == string::npos) ? -1 : i;
}\n"),
Pair("getKeyValueN", \type_nm, var_nm -> "String " + var_nm("getKeyValueN") + "(String key, String defval) { return defval; }\n\n"),
Pair("fail", \type_nm, var_nm -> "Void " + var_nm("fail") + "(String msg) { std::cerr << toStdString(msg); assert(false); }\n\n"),

Pair("timer", \type_nm, var_nm -> "fun " + var_nm("timer") + "(delay: Int, cb: () -> Unit): Unit = timer(delay, cb)\n\n"),


Pair("for", \type_nm, var_nm -> 
"template<typename T>
T " + var_nm("for") + "(T v, Fun<Bool, T> p, Fun<T, T> fn) {
	while (p(v)) v = fn(v);
	return v;
}\n"),

Pair("replace", \type_nm, var_nm -> 
"template<typename T>
Arr<T> " + var_nm("replace") + "(Arr<T> a, Int i, T v) {
	Arr<T> ret(*a.arr);
	(*ret.arr)[i] = v; 
	return ret; 
}\n"),

Pair("subrange", \type_nm, var_nm -> 
"template<typename T>
Arr<T> " + var_nm("subrange") + "(Arr<T> a, Int i, Int len) {
	Arr<T> ret(len);
	for (Int j = 0; j < len; ++ j) ret.arr->push_back(a.arr->at(i + j));
	return ret;
}\n"),

Pair("enumFromTo", \type_nm, var_nm -> 
"Arr<Int> " + var_nm("enumFromTo") + "(Int beg, Int end) {
	if (beg > end) {
		return Arr<Int>();
	} else {
		Arr<Int> ret(end - beg + 1);
		for (Int i = 0; i < end - beg + 1; ++i) {
			ret.arr->push_back(beg + i);
		}
		return ret;
	}
}\n"),

Pair("iter", \type_nm, var_nm -> 
"template<typename T>
Void " + var_nm("iter") + "(Arr<T> a, Fun<Void, T> fn) { 
	for (T x : *a.arr) fn(x);
}\n"),

Pair("iteri", \type_nm, var_nm -> 
"template<typename T>
Void " + var_nm("iteri") + "(Arr<T> a, Fun<Void, Int, T> fn) {
	Int i = 0;
	for (T x : *a.arr) fn(i++, x);
}\n"),

Pair("iteriUntil", \type_nm, var_nm -> 
"template<typename T>
Int " + var_nm("iteriUntil") + "(Arr<T> a, Fun<Bool, Int, T> fn) {
	for (Int i = 0; i < a.arr->size(); ++ i) {
		if (fn(i, a.arr->at(i))) return i;
	}
	return a.arr->size();
}\n"),
	
Pair("iterUntil", \type_nm, var_nm -> 
"template<typename T>
Int " + var_nm("iterUntil") + "(Arr<T> a, Fun<Bool, T> fn) {
	for (Int i = 0; i < a.arr->size(); ++ i)) {
		if (fn(a.arr->at(i))) return i;
	}
	return a.arr->size();
}
"),

Pair("substring", \type_nm, var_nm -> 
"String " + var_nm("substring") + "(String str, Int i, Int l) {
	Int strlen = str->size();
	Int start = i;
	Int len = l;
	if (len < 0) {
		if (start < 0) {
			len = 0;
		} else {
			Int smartLen1 = len + start;
			if (smartLen1 >= 0) {
				len = 0;
			} else {
				Int smartLen2 = smartLen1 + strlen;
				if (smartLen2 <= 0) len = 0;
				else len = smartLen2;
			}
		}
	}
	if (start < 0) {
		Int smartStart = start + strlen;
		if (smartStart > 0) {
			start = smartStart;
		} else {
			start = 0;
		}
	} else if (start >= strlen) {
		len = 0;
	}

	if (len < 1) {
		return makeString();
	} else {
		//len = clipLenToRange(start, len, strlen);
		Int end = start + len;
		if (end > strlen || end  < 0) {
			len = strlen - start;
		}
		return makeString(str->substr(start, len));
	}
}\n"),

Pair("getUrlParameterNative", \type_nm, var_nm -> 
"String " + var_nm("getUrlParameterNative") + "(String n) {
	if (command_args.find(*n) == command_args.end()) {
		std::cout << \"param not found\" << std::endl;
		return makeString();
	} else {
		std::cout << \"param IS found\" << std::endl;
		return makeString(command_args.at(*n));
	}
}\n"),

Pair("list2array", \type_nm, var_nm -> 
"template<typename T>
Arr<T> " + var_nm("list2array") + "(Union list) {
	Int count = 0;
	Struct* l = list.get();
	while (l->size() > 0) {
		" + type_nm("Cons") + "<T>* cons = dynamic_cast<" + type_nm("Cons") + "<T>*>(l);
		++count;
		l = cons->" + var_nm("tail") + ".get();  
	}
	Arr<T> ret(new std::vector<T>(count));
	l = list.get();
	while (l->size() > 0) {
		" + type_nm("Cons") + "<T>* cons = dynamic_cast<" + type_nm("Cons") + "<T>*>(l);
		(*ret.arr)[--count] = cons->" + var_nm("head") + ";
		l = cons->" + var_nm("tail") + ".get();  
	}
	return ret;
}\n"),

Pair("list2string", \type_nm, var_nm -> 
"String " + var_nm("list2string") + "(Union list) {
	Int len = 0;
	Int count = 0;
	String rv = makeString();
	Struct* l = list.get();
	while (l->size() > 0) {
		" + type_nm("Cons") + "<String>* cons = dynamic_cast<" + type_nm("Cons") + "<String>*>(l);
		len += cons->" + var_nm("head") + "->size();
		++count;
		l = cons->" + var_nm("tail") + ".get();  
	}
	String strings[count];
	l = list.get();
	Int i = count;
	while (l->size() > 0) {
		" + type_nm("Cons") + "<String>* cons = dynamic_cast<" + type_nm("Cons") + "<String>*>(l);
		strings[--i] = cons->" + var_nm("head") + ";
		l = cons->" + var_nm("tail") + ".get();  
	}
	std::ostringstream os;
	for (int i = 0; i < count; i++) {
		os << toStdString(strings[i]);
	}
	return makeString(os.str());
}\n"),

Pair("getAllUrlParametersArray", \type_nm, var_nm -> 
"Arr<Arr<String>> " + var_nm("getAllUrlParametersArray") + "() {
	Arr<Arr<String>> params(command_args.size());
	for (auto p : command_args) {
		Arr<String> param(2);
		param.arr->push_back(makeString(p.first));
		if (p.second.size() == 0) {
			param.arr->push_back(makeString());
		} else {
			param.arr->push_back(makeString(p.second));
		}
		params.arr->push_back(param);
	}
	return params;
}
"),

Pair("makeStructValue", \type_nm, var_nm -> "
Flow " + var_nm("makeStructValue") + "(String name, Arr<Flow> args, Flow defval) {
	if (struct_defs.find(*name) == struct_defs.end()) {
		return defval;
	} else {
		return struct_defs.at(*name).make(args);
	}
}\n"),

Pair("isSameObj", \type_nm, var_nm -> 
"Bool " + var_nm("isSameObj") + "(Flow a, Flow b) {
	if (a.index() != b.index()) {
		return false;
	} else {
		switch (a.index()) {
			case Type::INT:    return std::get<Int>(a) == std::get<Int>(b);
			case Type::BOOL:   return std::get<Bool>(a) == std::get<Bool>(b);
			case Type::DOUBLE: return std::get<Double>(a) == std::get<Double>(b);
			case Type::STRING: return *std::get<String>(a) == *std::get<String>(b);
			case Type::STRUCT: return std::get<Ptr<Struct>>(a).get() == std::get<Ptr<Struct>>(b).get();
			case Type::ARRAY:  return std::get<Ptr<Array>>(a).get() == std::get<Ptr<Array>>(b).get();
			case Type::REF:    return std::get<Ptr<Reference>>(a).get() == std::get<Ptr<Reference>>(b).get();
			case Type::FUNC:   return std::get<Ptr<Function>>(a).get() == std::get<Ptr<Function>>(b).get();
			case Type::NATIVE: return std::get<Ptr<Native>>(a).get() == std::get<Ptr<Native>>(b).get();
		}
	}
}\n"),

Pair("isStructName", \type_nm, var_nm -> 
"Bool " + var_nm("isStructName") + "(String name) {
	return (struct_defs.find(*name) != struct_defs.end());
}\n"),

Pair("voidValue", \type_nm, var_nm -> "
struct RuntimeVoid : public Native { 
	String name() const override { return makeString(\"runtime void\"); }
	String toString() const override { return makeString(\"runtime void\"); }
};
Flow " + var_nm("voidValue") + "() {
	return std::makeShared<RuntimeVoid>();
}\n"),

Pair("isArray", \type_nm, var_nm -> 
"Bool " + var_nm("isArray") + "(Flow f) {
	return f.index() == Type::ARRAY;
}\n"),

Pair("loaderUrl", \type_nm, var_nm -> "String " + var_nm("loaderUrl") + "() { return makeString(\"\"); }\n\n"),

// TODO: complete getTargetName
Pair("getTargetName", \type_nm, var_nm -> 
"String " + var_nm("getTargetName") + "() {
	return makeString(\"unknown in cpp3 baclkend\");
}\n"),

Pair("timestamp", \type_nm, var_nm -> 
"Double " + var_nm("timestamp") + "() {
	return std::chrono::duration_cast<std::chrono::milliseconds>(
		std::chrono::system_clock::now().time_since_epoch()
	).count();
}\n"),

Pair("string2time", \type_nm, var_nm -> 
"
Double " + var_nm("string2time") + "(String s) {
	const std::time_get<char>& time_get = std::use_facet<std::time_get<char>>(std::locale());
	std::ios::iostate state;
	std::istringstream iss(toStdString(s));
	std::tm when;
  	time_get.get(iss, std::time_get<char>::iter_type(), iss, state, &when,
		date_time_format.data(), date_time_format.data() + date_time_format.length()
	);
	if (!(state & std::ios::ios_base::failbit)) {
		return mktime(&when);
	} else {
		return 0.0;
	}
}\n"),

Pair("time2string", \type_nm, var_nm -> "
String " + var_nm("time2string") + "(Double t) {
	const std::time_put<char>& time_put = std::use_facet <std::time_put<char>>(std::locale());
  	std::time_t timestamp = t;
	std::tm* time = std::localtime(&timestamp);
	std::ostringstream out;
	time_put.put(out, out, ' ', time, date_time_format.data(), date_time_format.data() + date_time_format.length());
	return makeString(out.str());
}\n"),

Pair("gc", \type_nm, var_nm -> "Void " + var_nm("gc") + "() { }\n\n"),

Pair("fail", \type_nm, var_nm -> "Void " + var_nm("fail") + "(String msg) {
	std::cerr << msg << std::flush;
	assert(false);
}\n"),

Pair("fail0", \type_nm, var_nm -> "
template<typename T>
T " + var_nm("fail0") + "(String msg) {
	std::cerr << msg << std::flush;
	assert(false);
	return reinterpret_cast<T>(0);
}\n"),

Pair("hostCall", \type_nm, var_nm -> "Flow " + var_nm("hostCall") + "(String name, Arr<Flow> args) {
	std::cerr << \"hostCall is not yet implemented in cpp3 backend\" << std::endl;
	assert(false);
	return 0;
}\n"),

Pair("getApplicationPath", \type_nm, var_nm -> "String " + var_nm("getApplicationPath") + "() {
	return makeString(std::filesystem::current_path().u16string());
}\n"),

Pair("getFileContent", \type_nm, var_nm -> "String " + var_nm("getFileContent") + "(String path) {
	string line;
	std::ifstream is(toStdString(path));
	if (is.is_open()) {
		std::stringstream buffer;
		buffer << is.rdbuf();
		if (is.good()) {
			return makeString(buffer.str());
		} else {
			return makeString();
		}
	} else {
		return makeString();
	}
}\n"),

Pair("setFileContent", \type_nm, var_nm -> "Bool " + var_nm("setFileContent") + "(String path, String content) {
	std::ofstream os(toStdString(path));
    os << toStdString(content);
	return os.good();
}\n"),

Pair("printCallstack", \type_nm, var_nm -> "Void " + var_nm("printCallstack") + "() {
	//std::cout << std::basic_stacktrace() << std::endl;
	std::cout << \"printCallstack is not yet implemented\" << std::endl;
}\n"),

Pair("random", \type_nm, var_nm -> "Double " + var_nm("random") + "() {
	return static_cast<Double>(rand()) / (static_cast<Double>(RAND_MAX) + 1.0);
}\n"),

Pair("srand", \type_nm, var_nm -> "Void " + var_nm("random") + "(Int seed) {
	srand(seed);
}\n"),

Pair("randomGenerator", \type_nm, var_nm -> "Fun<Double> " + var_nm("randomGenerator") + "(Int seed) {
}\n"),

Pair("s2a", \type_nm, var_nm -> "Arr<Int> " + var_nm("s2a") + "(String s) {
	Arr<Int> ret(s->size());
	for (Int c : *s) {
		ret.arr->push_back(c);
	}
	return ret;
}\n"),

Pair("string2utf8", \type_nm, var_nm -> "Arr<Int> " + var_nm("string2utf8") + "(String str) {
	std::string s = toStdString(str);
	Arr<Int> ret(s.size());
	for (Int c : s) {
		ret.arr->push_back(c);
	}
	return ret;
}\n"),

Pair("createDirectory", \type_nm, var_nm -> "String " + var_nm("createDirectory") + "(String path) {
	std::error_code err;
	Bool ret = std::filesystem::create_directory(*path, err);
	if (ret) {
		return makeString();
	} else {
		return makeString(err.message());
	}
}\n"),

Pair("fileExists", \type_nm, var_nm -> "Bool " + var_nm("fileExists") + "(String path) {
	return std::filesystem::exists(*path);
}\n"),

Pair("isDirectory", \type_nm, var_nm -> "Bool " + var_nm("isDirectory") + "(String path) {
	return std::filesystem::is_directory(std::filesystem::status(*path));
}
"),

Pair("deleteDirectory", \type_nm, var_nm -> "String " + var_nm("deleteDirectory") + "(String path) {
	std::error_code err;
	Bool ret = std::filesystem::remove(*path, err);
	if (ret) {
		return makeString();
	} else {
		return makeString(err.message());
	}
}\n"),

Pair("deleteFile", \type_nm, var_nm -> "String " + var_nm("deleteFile") + "(String path) {
	std::error_code err;
	Bool ret = std::filesystem::remove(*path, err);
	if (ret) {
		return makeString();
	} else {
		return makeString(err.message());
	}
}\n"),

Pair("readDirectory", \type_nm, var_nm -> "Arr<String> " + var_nm("readDirectory") + "(String path) {
	std::filesystem::directory_iterator dir_iterator(*path);
	Arr<String> dir_contents;
	for (auto& f : dir_iterator) {
		dir_contents.arr->push_back(makeString(f.path().u16string()));
	}
	return dir_contents;
}\n"),

Pair("renameFile", \type_nm, var_nm -> "String " + var_nm("renameFile") + "(String old, String _new) {
	std::error_code err;
	std::filesystem::rename(*old, *_new, err);
	return makeString(err.message());
}\n"),

Pair("resolveRelativePath", \type_nm, var_nm -> "String " + var_nm("resolveRelativePath") + "(String path) {
	return makeString(std::filesystem::absolute(*path));
}\n"),

Pair("fileModified", \type_nm, var_nm -> "Double " + var_nm("fileModified") + "(String path) {
	return std::chrono::time_point_cast<std::chrono::milliseconds>(std::filesystem::last_write_time(*path)).time_since_epoch().count();
	//return std::chrono::duration_cast<std::chrono::milliseconds>(std::filesystem::last_write_time(*path)).count();
}\n"),

Pair("fileSize", \type_nm, var_nm -> "Double " + var_nm("fileSize") + "(String path) {
	return std::filesystem::file_size(*path);
}\n"),

Pair("stringbytes2int", \type_nm, var_nm -> "Int " + var_nm("stringbytes2int") + "(String s) {
	return *(s->data());
}\n"),

Pair("stringbytes2double", \type_nm, var_nm -> "Double " + var_nm("stringbytes2double") + "(String s) {
	return *(s->data());
}\n"),

Pair("fromBinary", \type_nm, var_nm -> 
"Flow " + var_nm("fromBinary") + "(String s, Flow defval, Fun<Union, String> fixup) {
	return s;
}\n"),

Pair("toBinary", \type_nm, var_nm -> "
Void writeCharValue(Int c, std::ostringstream& os) {
	os << (c & 0xffff);
}
Void writeBinaryInt32(Int i, std::ostringstream& os) {
	Int low = (i & 0xffff);
	Int high = (i >> 16);
	os << low << high;
}
Void writeIntValue(Int value, std::ostringstream& os) {
	if ((value & 0xFFFF8000) != 0) {
		writeCharValue(0xFFF5, os);
		writeBinaryInt32(value, os);
	} else {
		writeCharValue(value, os);
	}
}
Void writeBooleanValue(Bool value, std::ostringstream& os) {
	writeCharValue(value ? 0xFFFE : 0xFFFD, os);
}
Void writeDoubleValue(Double value, std::ostringstream& os) {
	writeCharValue(0xFFFC, os);
	os << value;
	/*val bb = java.nio.ByteBuffer.allocate(8).order(java.nio.ByteOrder.LITTLE_ENDIAN)
	bb.putDouble(value)
	for (i in 0..3) {
		writeCharValue(bb.getShort(i + i).toInt(), os)
	}*/
}
Void writeStringValue(String value, std::ostringstream& os) {
	Int str_len = value->size();
	if (str_len > 65535) {
		writeCharValue(0xFFFB, os);
		writeBinaryInt32(str_len, os);
	} else {
		writeCharValue(0xFFFA, os);
		writeCharValue(str_len, os);
	}
	for (auto c : *value) {
		writeCharValue(c, os);
	}
}
Void writeBinaryValue(Flow value, std::ostringstream& os, std::unordered_map<string, Int>& structIdxs, std::vector<Ptr<Struct>>& structDefs) {
	switch (value.index()) {
		case Type::STRING: {
			writeStringValue(std::get<String>(value), os);
			break;
		}
		case Type::DOUBLE: {
			writeDoubleValue(std::get<Double>(value), os);
			break;
		}
		case Type::INT: {
			writeIntValue(std::get<Int>(value), os);
			break;
		}
		case Type::BOOL: {
			writeBooleanValue(std::get<Bool>(value), os);
			break;
		}
		case Type::STRUCT: {
			Ptr<Struct> s = std::get<Ptr<Struct>>(value); 
			//writeStructValue(std::get<Ptr<Struct>>(value), os, structIdxs, structDefs);
			String struct_id = s->name();
			if (structIdxs.find(*struct_id) == structIdxs.end()) {
				structIdxs[*struct_id] = structDefs.size();
				structDefs.push_back(s);
			}
			Int struct_idx = structIdxs.at(*struct_id);
			writeCharValue(0xFFF4, os);
			writeCharValue(struct_idx, os);
			for (Flow w : s->fields())  {
				writeBinaryValue(w, os, structIdxs, structDefs);
			}
			break;
		}
		case Type::ARRAY: {
			Ptr<Array> a = std::get<Ptr<Array>>(value);
			Int l = a->size();
			if (l == 0) {
				writeCharValue(0xFFF7, os);
			} else {
				if (l > 65535) {
					writeCharValue(0xFFF9, os);
					writeBinaryInt32(l, os);
				} else {
					writeCharValue(0xFFF8, os);
					writeCharValue(l, os);
				}
				for (Flow v : a->elements()) {
					writeBinaryValue(v, os, structIdxs, structDefs);
				}
			}
			break;
		}
		default: {
			std::cerr << \"Not implemented: toBinary of \" << " + var_nm("toString") + "(value) << std::endl;
			break;
		}
	}
}
String " + var_nm("toBinary") + "(Flow value) {
	std::unordered_map<string, Int> structIdxs;
	std::vector<Ptr<Struct>> structDefs;

	std::ostringstream os;
	writeBinaryValue(value, os, structIdxs, structDefs);
	//os.seekg(0, std::ios::end);
	Int size = os.tellp();
	//Int size = os.pcount();

	if (structDefs.size() == 0) {
		writeCharValue(0xFFF7, os);
	} else {
		if (structDefs.size() > 65535) {
			writeCharValue(0xFFF9, os);
			writeBinaryInt32(structDefs.size(), os);
		} else {
			writeCharValue(0xFFF8, os);
			writeCharValue(structDefs.size(), os);
		}
	}
	for (Ptr<Struct> struct_def : structDefs) {
		writeCharValue(0xFFF8, os);
		writeCharValue(0x0002, os);
		writeCharValue(struct_def->size(), os);

		String s = struct_def->name();
		writeCharValue(0xFFFA, os);
		writeCharValue(s->size(), os);
		for (auto c : *s) {
			writeCharValue(c, os);
		}
	}
	return makeString(std::to_string(size + 2) + os.str());
}\n"),

Pair("createHttpServerNative", \type_nm, var_nm -> "fun " + var_nm("createHttpServerNative") + "(
	port: Int,
	isHttps: Boolean,
	pfxPath: String,
	pfxPassword: String,
	onOpen: () -> Unit,
	onMessage: (
		String,
		String,
		String,
		ArrayList<ArrayList<String>>,
		() -> Unit,
		(String) -> String,
		(Int, Boolean) -> String,
		(String, ArrayList<String>) -> Unit
	) -> Unit
): Any {
	if (flowc_target_language == \"java\") {
		assert(false, { -> \"createHttpServerNative native is not providede for platform \" + flowc_target_language})
		try {
			val server = com.sun.net.httpserver.HttpsServer.create()
			server.bind(java.net.InetSocketAddress(port), 0)
			//server.createContext(\"/\", ChunkedHandler(onMessage))
			server.start()
			onOpen.invoke()
			throw Exception(\"createHttpServerNative is not functional\")
			return server
		} catch (e: java.lang.Exception) {
			System.out.println(e)
			System.out.println(\"Failed to create HTTP server\")
			return null
		}
	} else {
		assert(false, { -> \"createHttpServerNative native is not providede for platform \" + flowc_target_language})
		return 0
	}
}
"),

Pair("closeHttpServerNative", \type_nm, var_nm -> "fun " + var_nm("closeHttpServerNative") + "(server: Any): Unit {
	(server as com.sun.net.httpserver.HttpServer).stop(0)
}
"),

Pair("makeHttpRequest", \type_nm, var_nm -> "fun " + var_nm("makeHttpRequest") + "(
	url: String, 
	post: Boolean,
	headers: ArrayList<ArrayList<String>>,
	params: ArrayList<ArrayList<String>>,
	onData: (String) -> Unit,
	onError: (String) -> Unit, 
	onStatus: (Int) -> Unit): Unit {
	assert(false, { -> \"makeHttpRequest native is not providede for platform \" + flowc_target_language})
}
"),

Pair("httpCustomRequestNative", \type_nm, var_nm -> "fun " + var_nm("httpCustomRequestNative") + "(
	url: String,
	method: String,
	headers: ArrayList<ArrayList<String>>,
	parameters: ArrayList<ArrayList<String>>,
	data: String,
	responseEncoding: String,
	onResponse: (Int, String, ArrayList<ArrayList<String>>) -> Unit,
	async: Boolean
) -> Unit {
	assert(false, { -> \"httpCustomRequestNative native is not providede for platform \" + flowc_target_language})
}
"),

Pair("print", \type_nm, var_nm -> "fun " + var_nm("print") + "(s: String): Unit {
	System.out.print(s)
	/*try{
		synchronized (System.out) {
			PrintStream out = new PrintStream(System.out, true, \"UTF-8\");
			out.print(s);
			out.flush();
		}
	} catch (e: UnsupportedEncodingException) {
		e.printStackTrace();
	}
	return null;*/
}
"),

Pair("readUntil", \type_nm, var_nm -> "fun " + var_nm("readUntil") + "(str_pattern: String): String {
	val pattern = str_pattern.getBytes()
	val line = ArrayList<Byte>()
	var pos = 0
		while (true) {
			val ch = System.in.read()
			line.add(ch.toByte())
			if (ch == pattern[pos]) {
				pos += 1
				if (pos == pattern.length) {
					return line.toString()
				}
			} else {
				pos = 0
			}
		}
}
"),

Pair("getFileContentBinary", \type_nm, var_nm -> "fun " + var_nm("getFileContentBinary") + "(name: String): String {
	try {
		val bytes = java.nio.file.Files.readAllBytes(java.nio.file.Paths.get(name))
		return bytes.toString(Charsets.ISO_8859_1)
	} catch (e: java.io.IOException) {
		return \"\"
	}
}
"),

Pair("setFileContentBytes", \type_nm, var_nm -> "fun " + var_nm("setFileContentBytes") + "(name: String, data: String): Boolean {
	java.io.Writer? writer = null;
	try {
		writer = java.io.BufferedWriter(java.io.OutputStreamWriter(
			java.io.FileOutputStream(name), Charsets.ISO_8859_1)
		);
		val chars = CharArray(data.length, {i -> data.codePointAt(i).toChar() })
		writer.write(chars);
	} catch (ex: java.io.IOException) {
	} finally {
		try {
			writer.close();
			return true;
		} catch (_: java.lang.Exception) {
		}
	}
	return false
}
"),

Pair("execSystemProcess", \type_nm, var_nm -> "fun " + var_nm("execSystemProcess") + "(command: String, args: ArrayList<String>, cwd: String, onOut: (String) -> Unit, onErr: (String) -> Unit): Int {
	val cmd = arrayOf(*arrayOf(command), *args.toTypedArray())
	val runner = ProcessStarter(cmd, cwd, onOut, onErr, {_ -> })
	runner.run()
	return runner.waitFor()
}
"),

Pair("startProcess", \type_nm, var_nm -> "fun " + var_nm("startProcess") + "(command: String, args: ArrayList<String>, cwd: String, stdin: string, onExit: (int, String, String) -> Unit): Unit {
	val cmd = arrayOf(*arrayOf(command), *args.toTypedArray())
	var stdout = ""
	var stderr = ""
	val runner = ProcessStarter(cmd, cwd, 
		{out -> stdout = stdout + out}, 
		{err -> stderr = stderr + err}, 
		{code -> onExit(code, stdout, stderr)}
	)
	flow_threadpool.submit(runner)
	runner.writeStdin(stdin)
}
"),

Pair("runSystemProcess", \type_nm, var_nm -> "fun " + var_nm("runSystemProcess") + "(command: String, args: ArrayList<String>, cwd: String, onOut: (String) -> Unit, onErr: (String) -> Unit, onExit: (Int) -> Unit): ProcessStarter {
	val cmd = arrayOf(*arrayOf(command), *args.toTypedArray())
	val runner = ProcessStarter(cmd, cwd, onOut, onErr, onExit)
	flow_threadpool.submit(runner)
	return runner
}
"),

Pair("writeProcessStdin", \type_nm, var_nm -> "fun " + var_nm("writeProcessStdin") + "(proc: Any, arg: String): Unit {
	(proc as ProcessStarter).writeStdin(arg);
}
"),

Pair("availableProcessors", \type_nm, var_nm -> "fun " + var_nm("availableProcessors") + "(): Int {
	return java.lang.Runtime.getRuntime().availableProcessors()
}
"),

Pair("setThreadPoolSize", \type_nm, var_nm -> "fun " + var_nm("setThreadPoolSize") + "(threads: Int): Unit {
	flow_threadpool = java.util.concurrent.Executors.newFixedThreadPool(threads);
}
"),

]);

