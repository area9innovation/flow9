import tools/flowc/backends/common;
import tools/flowc/backends/cpp3/fi2cpp3_util;
import tools/flowc/backends/cpp3/fi2cpp3_defines;

export {
	fiCpp3Runtime(gctx: Cpp3GlobalContext) -> string;
	fiCpp3IsNative(name : string, gctx: Cpp3GlobalContext) -> bool;
	fiCpp3InitNativeFuncs() -> Tree<string, CppNative>;
}

fiCpp3Runtime(gctx: Cpp3GlobalContext) -> string {
"#include tools/flowc/backends/cpp3/flow_runtime.hpp" + "\n" +
"namespace flow {
template<typename T>
T " + gctx.varname2cpp("for") + "(T v, Fun<Bool, T> p, Fun<T, T> fn) {
	while (p(v)) v = fn(v);
	return v;
}

}\n";
}

fiCpp3IsNative(name : string, gctx: Cpp3GlobalContext) -> bool {
	name == "for" || containsKeyTree(gctx.natives, name);
}

fiCpp3InitNativeFuncs() -> Tree<string, CppNative> {
values2tree([

CppNative("length", \gctx -> 
"template<typename T>
inline Int " + gctx.varname2cpp("length") + "(Arr<T> a) { 
	return a.arr->size(); 
}\n",
Some(CppInline(\args, __ -> args[0] + ".arr->size()")), []
),

CppNative("concat", \gctx -> 
"template<typename T>
inline Arr<T> " + gctx.varname2cpp("concat") + "(Arr<T> a1, Arr<T> a2) {
	Arr<T> ret = Arr<T>(a1.arr->size() + a2.arr->size());
	for(T x : *a1.arr) ret.arr->push_back(x);
	for(T x : *a2.arr) ret.arr->push_back(x);
	return ret;
}\n", None(), []),

CppNative("fold", \gctx -> 
"template<typename T, typename V>
inline V " + gctx.varname2cpp("fold") + "(Arr<T> a, V v, Fun<V, V, T> fn) {
	for (T x : *a.arr) v = fn(v, x);
	return v;
}\n", None(), []),

CppNative("foldi", \gctx -> 
"template<typename T, typename V>
inline V " + gctx.varname2cpp("foldi") + "(Arr<T> a, V v, Fun<V, Int, V, T> fn) {
	Int i = 0;
	for (T x : *a.arr) v = fn(i++, v, x);
	return v;
}\n", None(), []),

CppNative("map", \gctx -> 
"template<typename T, typename V>
inline Arr<V> " + gctx.varname2cpp("map") + "(Arr<T> a, Fun<V, T> fn) {
	Arr<V> ret(a.arr->size());
	for (T x : *a.arr) ret.arr->push_back(fn(x));
	return ret;
}\n", None(), []),

CppNative("mapi", \gctx -> 
"template<typename T, typename V>
inline Arr<V> " + gctx.varname2cpp("mapi") + "(Arr<T> a, Fun<V, Int, T> fn) {
	Arr<V> ret(a.arr->size());
	Int i = 0;
	for (T x : *a.arr) ret.arr->push_back(fn(i++, x));
	return ret;
}\n", None(), []),

CppNative("filter", \gctx -> 
"template<typename T>
inline Arr<T> " + gctx.varname2cpp("filter") + "(Arr<T> a, Fun<Bool, T> fn) {
	Arr<T> ret(a.arr->size());
	for (T x : *a.arr) if (fn(x)) ret.arr->push_back(x);
	return ret;
}\n", None(), []),

CppNative("isSameStructType", \gctx -> 
"inline Bool " + gctx.varname2cpp("isSameStructType") + "(Flow o1, Flow o2) {
	if (o1.type() != Type::STRUCT || o2.type() != Type::STRUCT) {
		return false;
	} else {
		return std::get<Ptr<Struct>>(o1.val)->name() == std::get<Ptr<Struct>>(o2.val)->name();
	}
}\n", None(), []),

CppNative("quit", \gctx -> 
"void " + gctx.varname2cpp("quit") + "(Int code) { exit(code); }\n\n", Some(CppInline(\as,__ -> "exit(" + as[0] + ")")), ["<cstdlib>"]),

CppNative("println2", \gctx -> 
"void " + gctx.varname2cpp("println2") + "(Flow x) { 
	flow2string(x, std::cout); std::cout << std::endl; 
}\n", None(), [""]),

CppNative("i2s", \gctx -> "String " + gctx.varname2cpp("i2s") + "(Int x) { return makeString(std::to_string(x)); }\n\n", None(), []),
CppNative("d2s", \gctx -> "String " + gctx.varname2cpp("d2s") + "(Double x) { std::ostringstream os; os << x; return makeString(os.str()); }\n\n", None(), []),
CppNative("i2d", \gctx -> "Double " + gctx.varname2cpp("i2d") + "(Int x) { return x; }\n\n", Some(CppInline(\as,__-> as[0])), []),
CppNative("exp", \gctx -> "Double " + gctx.varname2cpp("exp") + "(Double x) { return exp(x); }\n\n", Some(CppInline(\as,__-> "exp(" + as[0] + ")")), ["<cmath>"]),
CppNative("log", \gctx -> "Double " + gctx.varname2cpp("log") + "(Double x) { return log(x); }\n\n", Some(CppInline(\as,__-> "log(" + as[0] + ")")), ["<cmath>"]),
CppNative("trunc", \gctx -> "Int " + gctx.varname2cpp("trunc") + "(Double x) { return trunc(x); } \n\n", Some(CppInline(\as,__-> "trunc(" + as[0] + ")")), ["<cmath>"]),
CppNative("strlen", \gctx -> "Int " + gctx.varname2cpp("strlen") + "(String s) { return s->size(); }\n\n", Some(CppInline(\as,__-> as[0] + "->size()")), []),
CppNative("bitAnd", \gctx -> "Int " + gctx.varname2cpp("bitAnd") + "(Int x, Int y) { return x & y; }\n\n", Some(CppInline(\as,__-> "(" + as[0] + " & " + as[1] + ")")), []),
CppNative("bitOr", \gctx -> "Int " + gctx.varname2cpp("bitOr") + "(Int x, Int y) { return x | y; }\n\n", Some(CppInline(\as,__-> "(" + as[0] + " | " + as[1] + ")")), []),
CppNative("bitXor", \gctx -> "Int " + gctx.varname2cpp("bitXor") + "(Int x, Int y) { return x ^ y; }\n\n", Some(CppInline(\as,__-> "(" + as[0] + " ^ " + as[1] + ")")), []),
CppNative("bitNot", \gctx -> "Int " + gctx.varname2cpp("bitNot") + "(Int x) { return ~x; }\n\n", Some(CppInline(\as,__-> "~" + as[0])), []),
CppNative("bitShl", \gctx -> "Int " + gctx.varname2cpp("bitShl") + "(Int x, Int y) { return x << y; }\n\n", Some(CppInline(\as,__-> "(" + as[0] + " << " + as[1] + ")")), []),
CppNative("bitUshr", \gctx -> "Int " + gctx.varname2cpp("bitUshr") + "(Int x, Int y) { return x >> y; }\n\n", Some(CppInline(\as,__-> "(" + as[0] + " >> " + as[1] + ")")), []),
CppNative("getCharCodeAt", \gctx -> "Int " + gctx.varname2cpp("getCharCodeAt") + "(String s, Int i) { return s->at(i); }\n\n", Some(CppInline(\as,__-> as[0] + "->at(" + as[1] + ")")), []),
CppNative("getCharAt", \gctx -> "String " + gctx.varname2cpp("getCharAt") + "(String s, Int i) { return makeString(s->at(i)); }\n\n", Some(CppInline(\as,__-> "makeString(" + as[0] + "->at(" + as[1] + "))")), []),
CppNative("fromCharCode", \gctx -> "String " + gctx.varname2cpp("fromCharCode") + "(Int code) { return makeString(code); }\n\n", Some(CppInline(\as,__-> "makeString(" + as[0] + ")")), []),

CppNative("toString2", \gctx -> 
"String " + gctx.varname2cpp("toString2") + "(Flow x) {
	std::ostringstream os;
	flow2string(x, os, false);
	return makeString(os.str());
}\n", None(), []),

CppNative("toLowerCase", \gctx -> 
"String " + gctx.varname2cpp("toLowerCase") + "(String s) {
	String lower = makeString(s);
	std::transform(lower->begin(), lower->end(), lower->begin(), [](auto c){ return std::tolower(c); });
	return lower;
}\n", None(), []),

CppNative("toUpperCase", \gctx -> 
"String " + gctx.varname2cpp("toUpperCase") + "(String s) {
	String upper = makeString(s);
	std::transform(upper->begin(), upper->end(), upper->begin(), [](auto c){ return std::toupper(c); });
	return upper;
}\n", None(), []),

CppNative("strIndexOf", \gctx -> 
"Int " + gctx.varname2cpp("strIndexOf") + "(String s, String p) {
	auto i = s->find(*p);
	return (i == string::npos) ? -1 : i;
}\n", None(), []),

CppNative("getKeyValueN", \gctx -> 
"String " + gctx.varname2cpp("getKeyValueN") + "(String key, String defval) { return defval; }\n\n", Some(CppInline(\as,__ -> as[1])), []),

CppNative("fail", \gctx -> 
"Void " + gctx.varname2cpp("fail") + "(String msg) { std::cerr << toStdString(msg); assert(false); }\n
\n", None(), []),

CppNative("timer", \gctx -> "Void " + gctx.varname2cpp("timer") + "(Int delay, Fun<Void> cb) {
	// TODO: implement
}\n", None(), []),


CppNative("for", \gctx -> 
"template<typename T>
T " + gctx.varname2cpp("for") + "(T v, Fun<Bool, T> p, Fun<T, T> fn) {
	while (p(v)) v = fn(v);
	return v;
}\n", None(), []),

CppNative("replace", \gctx -> 
"template<typename T>
Arr<T> " + gctx.varname2cpp("replace") + "(Arr<T> a, Int i, T v) {
	Arr<T> ret(*a.arr);
	(*ret.arr)[i] = v; 
	return ret; 
}\n", None(), []),

CppNative("subrange", \gctx -> 
"template<typename T>
Arr<T> " + gctx.varname2cpp("subrange") + "(Arr<T> a, Int i, Int len) {
	Arr<T> ret(len);
	for (Int j = 0; j < len; ++ j) {
		ret.arr->push_back(a.arr->at(i + j));
	}
	return ret;
}\n", None(), []),

CppNative("enumFromTo", \gctx -> 
"Arr<Int> " + gctx.varname2cpp("enumFromTo") + "(Int beg, Int end) {
	if (beg > end) {
		return Arr<Int>();
	} else {
		Arr<Int> ret(end - beg + 1);
		for (Int i = 0; i < end - beg + 1; ++i) {
			ret.arr->push_back(beg + i);
		}
		return ret;
	}
}\n", None(), []),

CppNative("iter", \gctx -> 
"template<typename T>
Void " + gctx.varname2cpp("iter") + "(Arr<T> a, Fun<Void, T> fn) { 
	for (T x : *a.arr) fn(x);
}\n", None(), []),

CppNative("iteri", \gctx -> 
"template<typename T>
Void " + gctx.varname2cpp("iteri") + "(Arr<T> a, Fun<Void, Int, T> fn) {
	Int i = 0;
	for (T x : *a.arr) fn(i++, x);
}\n", None(), []),

CppNative("iteriUntil", \gctx -> 
"template<typename T>
Int " + gctx.varname2cpp("iteriUntil") + "(Arr<T> a, Fun<Bool, Int, T> fn) {
	for (Int i = 0; i < a.arr->size(); ++ i) {
		if (fn(i, a.arr->at(i))) return i;
	}
	return a.arr->size();
}\n", None(), []),
	
CppNative("iterUntil", \gctx -> 
"template<typename T>
Int " + gctx.varname2cpp("iterUntil") + "(Arr<T> a, Fun<Bool, T> fn) {
	for (Int i = 0; i < a.arr->size(); ++ i)) {
		if (fn(a.arr->at(i))) return i;
	}
	return a.arr->size();
}\n", None(), []),

CppNative("substring", \gctx -> 
"String " + gctx.varname2cpp("substring") + "(String str, Int i, Int l) {
	Int strlen = str->size();
	Int start = i;
	Int len = l;
	if (len < 0) {
		if (start < 0) {
			len = 0;
		} else {
			Int smartLen1 = len + start;
			if (smartLen1 >= 0) {
				len = 0;
			} else {
				Int smartLen2 = smartLen1 + strlen;
				if (smartLen2 <= 0) len = 0;
				else len = smartLen2;
			}
		}
	}
	if (start < 0) {
		Int smartStart = start + strlen;
		if (smartStart > 0) {
			start = smartStart;
		} else {
			start = 0;
		}
	} else if (start >= strlen) {
		len = 0;
	}

	if (len < 1) {
		return makeString();
	} else {
		//len = clipLenToRange(start, len, strlen);
		Int end = start + len;
		if (end > strlen || end  < 0) {
			len = strlen - start;
		}
		return makeString(str->substr(start, len));
	}
}\n", None(), []),

CppNative("getUrlParameterNative", \gctx -> 
"String " + gctx.varname2cpp("getUrlParameterNative") + "(String n) {
	if (command_args.find(*n) == command_args.end()) {
		std::cout << \"param not found\" << std::endl;
		return makeString();
	} else {
		std::cout << \"param IS found\" << std::endl;
		return makeString(command_args.at(*n));
	}
}\n", None(), []),

CppNative("list2array", \gctx -> 
"template<typename T>
Arr<T> " + gctx.varname2cpp("list2array") + "(Union list) {
	Int count = 0;
	Struct* l = list.get();
	while (l->size() > 0) {
		" + gctx.typename2cpp("Cons") + "<T>* cons = dynamic_cast<" + gctx.typename2cpp("Cons") + "<T>*>(l);
		++count;
		l = cons->" + gctx.varname2cpp("tail") + ".get();  
	}
	Arr<T> ret(new std::vector<T>(count));
	l = list.get();
	while (l->size() > 0) {
		" + gctx.typename2cpp("Cons") + "<T>* cons = dynamic_cast<" + gctx.typename2cpp("Cons") + "<T>*>(l);
		(*ret.arr)[--count] = cons->" + gctx.varname2cpp("head") + ";
		l = cons->" + gctx.varname2cpp("tail") + ".get();  
	}
	return ret;
}\n", None(), []),

CppNative("list2string", \gctx -> 
"String " + gctx.varname2cpp("list2string") + "(Union list) {
	Int len = 0;
	Int count = 0;
	String rv = makeString();
	Struct* l = list.get();
	while (l->size() > 0) {
		" + gctx.typename2cpp("Cons") + "<String>* cons = dynamic_cast<" + gctx.typename2cpp("Cons") + "<String>*>(l);
		len += cons->" + gctx.varname2cpp("head") + "->size();
		++count;
		l = cons->" + gctx.varname2cpp("tail") + ".get();  
	}
	String strings[count];
	l = list.get();
	Int i = count;
	while (l->size() > 0) {
		" + gctx.typename2cpp("Cons") + "<String>* cons = dynamic_cast<" + gctx.typename2cpp("Cons") + "<String>*>(l);
		strings[--i] = cons->" + gctx.varname2cpp("head") + ";
		l = cons->" + gctx.varname2cpp("tail") + ".get();  
	}
	std::ostringstream os;
	for (int i = 0; i < count; i++) {
		os << toStdString(strings[i]);
	}
	return makeString(os.str());
}\n", None(), []),

CppNative("getAllUrlParametersArray", \gctx -> 
"Arr<Arr<String>> " + gctx.varname2cpp("getAllUrlParametersArray") + "() {
	Arr<Arr<String>> params(command_args.size());
	for (auto p : command_args) {
		Arr<String> param(2);
		param.arr->push_back(makeString(p.first));
		if (p.second.size() == 0) {
			param.arr->push_back(makeString());
		} else {
			param.arr->push_back(makeString(p.second));
		}
		params.arr->push_back(param);
	}
	return params;
}\n", None(), []),

CppNative("makeStructValue", \gctx -> "
Flow " + gctx.varname2cpp("makeStructValue") + "(String name, Arr<Flow> args, Flow defval) {
	if (struct_defs.find(*name) == struct_defs.end()) {
		return defval;
	} else {
		return struct_defs.at(*name).make(args);
	}
}\n", None(), []),

CppNative("isSameObj", \gctx -> 
"Bool " + gctx.varname2cpp("isSameObj") + "(Flow a, Flow b) {
	if (a.type() != b.type()) {
		return false;
	} else {
		switch (a.type()) {
			case Type::INT:    return std::get<Int>(a.val) == std::get<Int>(b.val);
			case Type::BOOL:   return std::get<Bool>(a.val) == std::get<Bool>(b.val);
			case Type::DOUBLE: return std::get<Double>(a.val) == std::get<Double>(b.val);
			case Type::STRING: return *std::get<String>(a.val) == *std::get<String>(b.val);
			case Type::STRUCT: return std::get<Ptr<Struct>>(a.val).get() == std::get<Ptr<Struct>>(b.val).get();
			case Type::ARRAY:  return std::get<Ptr<Array>>(a.val).get() == std::get<Ptr<Array>>(b.val).get();
			case Type::REF:    return std::get<Ptr<Reference>>(a.val).get() == std::get<Ptr<Reference>>(b.val).get();
			case Type::FUNC:   return std::get<Ptr<Function>>(a.val).get() == std::get<Ptr<Function>>(b.val).get();
			case Type::NATIVE: return std::get<Ptr<Native>>(a.val).get() == std::get<Ptr<Native>>(b.val).get();
		}
	}
}\n", None(), []),

CppNative("isStructName", \gctx -> 
"Bool " + gctx.varname2cpp("isStructName") + "(String name) {
	return (struct_defs.find(*name) != struct_defs.end());
}\n", None(), []),

CppNative("voidValue", \gctx -> "
struct RuntimeVoid : public Native { 
	String name() const override { return makeString(\"runtime void\"); }
	String toString() const override { return makeString(\"runtime void\"); }
};
Flow " + gctx.varname2cpp("voidValue") + "() {
	return std::makeShared<RuntimeVoid>();
}\n", None(), []),

CppNative("isArray", \gctx -> 
"Bool " + gctx.varname2cpp("isArray") + "(Flow f) {
	return f.type() == Type::ARRAY;
}\n", None(), []),

CppNative("loaderUrl", \gctx -> "String " + gctx.varname2cpp("loaderUrl") + "() { return makeString(\"\"); }\n\n", None(), []),

// TODO: complete getTargetName
CppNative("getTargetName", \gctx -> 
"String " + gctx.varname2cpp("getTargetName") + "() {
	return makeString(\"unknown in cpp3 baclkend\");
}\n", None(), []),

CppNative("timestamp", \gctx -> 
"Double " + gctx.varname2cpp("timestamp") + "() {
	return std::chrono::duration_cast<std::chrono::milliseconds>(
		std::chrono::system_clock::now().time_since_epoch()
	).count();
}\n", None(), []),

CppNative("string2time", \gctx -> 
"
Double " + gctx.varname2cpp("string2time") + "(String s) {
	const std::time_get<char>& time_get = std::use_facet<std::time_get<char>>(std::locale());
	std::ios::iostate state;
	std::istringstream iss(toStdString(s));
	std::tm when;
  	time_get.get(iss, std::time_get<char>::iter_type(), iss, state, &when,
		date_time_format.data(), date_time_format.data() + date_time_format.length()
	);
	if (!(state & std::ios::ios_base::failbit)) {
		return mktime(&when) * 1000.0;
	} else {
		return 0.0;
	}
}\n", None(), []),

CppNative("time2string", \gctx -> "
String " + gctx.varname2cpp("time2string") + "(Double t) {
	const std::time_put<char>& time_put = std::use_facet <std::time_put<char>>(std::locale());
  	std::time_t timestamp = t / 1000.0;
	std::tm* time = std::localtime(&timestamp);
	std::ostringstream out;
	time_put.put(out, out, ' ', time, date_time_format.data(), date_time_format.data() + date_time_format.length());
	return makeString(out.str());
}\n", None(), []),

CppNative("gc", \gctx -> "Void " + gctx.varname2cpp("gc") + "() { }\n\n", None(), []),

CppNative("fail", \gctx -> "Void " + gctx.varname2cpp("fail") + "(String msg) {
	std::cerr << msg << std::flush;
	assert(false);
}\n", None(), []),

CppNative("fail0", \gctx -> "
template<typename T>
T " + gctx.varname2cpp("fail0") + "(String msg) {
	std::cerr << msg << std::flush;
	assert(false);
	return reinterpret_cast<T>(0);
}\n", None(), []),

CppNative("hostCall", \gctx -> "Flow " + gctx.varname2cpp("hostCall") + "(String name, Arr<Flow> args) {
	std::cerr << \"hostCall is not yet implemented in cpp3 backend\" << std::endl;
	assert(false);
	return 0;
}\n", None(), []),

CppNative("getApplicationPath", \gctx -> "String " + gctx.varname2cpp("getApplicationPath") + "() {
	return makeString(std::filesystem::current_path().u16string());
}\n", None(), []),

CppNative("getFileContent", \gctx -> "String " + gctx.varname2cpp("getFileContent") + "(String path) {
	string line;
	std::ifstream is(toStdString(path));
	if (is.is_open()) {
		std::stringstream buffer;
		buffer << is.rdbuf();
		if (is.good()) {
			return makeString(buffer.str());
		} else {
			return makeString();
		}
	} else {
		return makeString();
	}
}\n", None(), []),

CppNative("setFileContent", \gctx -> "Bool " + gctx.varname2cpp("setFileContent") + "(String path, String content) {
	std::ofstream os(toStdString(path));
    os << toStdString(content);
	return os.good();
}\n", None(), []),

CppNative("printCallstack", \gctx -> "Void " + gctx.varname2cpp("printCallstack") + "() {
	//std::cout << std::basic_stacktrace() << std::endl;
	std::cout << \"printCallstack is not yet implemented\" << std::endl;
}\n", None(), []),

CppNative("random", \gctx -> "Double " + gctx.varname2cpp("random") + "() {
	return static_cast<Double>(rand()) / (static_cast<Double>(RAND_MAX) + 1.0);
}\n", None(), []),

CppNative("srand", \gctx -> "Void " + gctx.varname2cpp("random") + "(Int seed) {
	srand(seed);
}\n", None(), []),

CppNative("randomGenerator", \gctx -> "Fun<Double> " + gctx.varname2cpp("randomGenerator") + "(Int seed) {
}\n", None(), []),

CppNative("s2a", \gctx -> "Arr<Int> " + gctx.varname2cpp("s2a") + "(String s) {
	Arr<Int> ret(s->size());
	for (Int c : *s) {
		ret.arr->push_back(c);
	}
	return ret;
}\n", None(), []),

CppNative("string2utf8", \gctx -> "Arr<Int> " + gctx.varname2cpp("string2utf8") + "(String str) {
	std::string s = toStdString(str);
	Arr<Int> ret(s.size());
	for (Int c : s) {
		ret.arr->push_back(c);
	}
	return ret;
}\n", None(), []),

CppNative("createDirectory", \gctx -> "String " + gctx.varname2cpp("createDirectory") + "(String path) {
	std::error_code err;
	Bool ret = std::filesystem::create_directory(*path, err);
	if (ret) {
		return makeString();
	} else {
		return makeString(err.message());
	}
}\n", None(), []),

CppNative("fileExists", \gctx -> "Bool " + gctx.varname2cpp("fileExists") + "(String path) {
	return std::filesystem::exists(*path);
}\n", None(), []),

CppNative("isDirectory", \gctx -> "Bool " + gctx.varname2cpp("isDirectory") + "(String path) {
	return std::filesystem::is_directory(std::filesystem::status(*path));
}\n", None(), []),

CppNative("deleteDirectory", \gctx -> "String " + gctx.varname2cpp("deleteDirectory") + "(String path) {
	std::error_code err;
	Bool ret = std::filesystem::remove(*path, err);
	if (ret) {
		return makeString();
	} else {
		return makeString(err.message());
	}
}\n", None(), []),

CppNative("deleteFile", \gctx -> "String " + gctx.varname2cpp("deleteFile") + "(String path) {
	std::error_code err;
	Bool ret = std::filesystem::remove(*path, err);
	if (ret) {
		return makeString();
	} else {
		return makeString(err.message());
	}
}\n", None(), []),

CppNative("readDirectory", \gctx -> "Arr<String> " + gctx.varname2cpp("readDirectory") + "(String path) {
	std::filesystem::directory_iterator dir_iterator(*path);
	Arr<String> dir_contents;
	for (auto& f : dir_iterator) {
		dir_contents.arr->push_back(makeString(f.path().u16string()));
	}
	return dir_contents;
}\n", None(), []),

CppNative("renameFile", \gctx -> "String " + gctx.varname2cpp("renameFile") + "(String old, String _new) {
	std::error_code err;
	std::filesystem::rename(*old, *_new, err);
	return makeString(err.message());
}\n", None(), []),

CppNative("resolveRelativePath", \gctx -> "String " + gctx.varname2cpp("resolveRelativePath") + "(String path) {
	return makeString(std::filesystem::absolute(*path));
}\n", None(), []),

CppNative("fileModified", \gctx -> "Double " + gctx.varname2cpp("fileModified") + "(String path) {
	std::filesystem::file_time_type mod1 = std::filesystem::last_write_time(*path);
	auto mod2 = std::chrono::file_clock::to_sys(mod1);
	auto mod3 = std::chrono::duration_cast<std::chrono::milliseconds>(mod2.time_since_epoch());
	return mod3.count();
}\n", None(), []),

CppNative("fileSize", \gctx -> "Double " + gctx.varname2cpp("fileSize") + "(String path) {
	return std::filesystem::file_size(*path);
}\n", None(), []),

CppNative("stringbytes2int", \gctx -> "Int " + gctx.varname2cpp("stringbytes2int") + "(String s) {
	IntOrChars i(s->at(0), s->at(1));
	return i.int_;
}\n", None(), []),

CppNative("stringbytes2double", \gctx -> "Double " + gctx.varname2cpp("stringbytes2double") + "(String s) {
	DoubleOrChars d(s->at(0), s->at(1), s->at(2), s->at(3));
	return d.double_;
}\n", None(), []),

CppNative("fromBinary", \gctx -> 
"Flow " + gctx.varname2cpp("fromBinary") + "(String s, Flow defval, Fun<Union, String> fixup) {
	return s;
}\n", None(), []),

CppNative("toBinary", \gctx -> "
Void writeCharValue(Int c, std::vector<char16_t>& os) {
	os.push_back(c & 0xffff);
}
Void writeBinaryInt32(Int value, std::vector<char16_t>& os) {
	IntOrChars i(value);
	writeCharValue(i.chars.c0, os);
	writeCharValue(i.chars.c1, os);
}
Void writeIntValue(Int value, std::vector<char16_t>& os) {
	if ((value & 0xFFFF8000) != 0) {
		writeCharValue(0xFFF5, os);
		writeBinaryInt32(value, os);
	} else {
		writeCharValue(value, os);
	}
}
Void writeBooleanValue(Bool value, std::vector<char16_t>& os) {
	writeCharValue(value ? 0xFFFE : 0xFFFD, os);
}
Void writeDoubleValue(Double value, std::vector<char16_t>& os) {
	writeCharValue(0xFFFC, os);
	DoubleOrChars d(value);
	writeCharValue(d.chars.c0, os);
	writeCharValue(d.chars.c1, os);
	writeCharValue(d.chars.c2, os);
	writeCharValue(d.chars.c3, os);
}
Void writeStringValue(String value, std::vector<char16_t>& os) {
	Int str_len = value->size();
	if (str_len > 65535) {
		writeCharValue(0xFFFB, os);
		writeBinaryInt32(str_len, os);
	} else {
		writeCharValue(0xFFFA, os);
		writeCharValue(str_len, os);
	}
	for (auto c : *value) {
		writeCharValue(c, os);
	}
}
Void writeBinaryValue(Flow value, std::vector<char16_t>& os, std::unordered_map<string, Int>& structIdxs, std::vector<Ptr<Struct>>& structDefs) {
	switch (value.type()) {
		case Type::STRING: {
			writeStringValue(std::get<String>(value.val), os);
			break;
		}
		case Type::DOUBLE: {
			writeDoubleValue(std::get<Double>(value.val), os);
			break;
		}
		case Type::INT: {
			writeIntValue(std::get<Int>(value.val), os);
			break;
		}
		case Type::BOOL: {
			writeBooleanValue(std::get<Bool>(value.val), os);
			break;
		}
		case Type::STRUCT: {
			Ptr<Struct> s = std::get<Ptr<Struct>>(value.val); 
			//writeStructValue(std::get<Ptr<Struct>>(value.val), os, structIdxs, structDefs);
			String struct_id = s->name();
			if (structIdxs.find(*struct_id) == structIdxs.end()) {
				structIdxs[*struct_id] = structDefs.size();
				structDefs.push_back(s);
			}
			Int struct_idx = structIdxs.at(*struct_id);
			writeCharValue(0xFFF4, os);
			writeCharValue(struct_idx, os);
			for (Flow w : s->fields())  {
				writeBinaryValue(w, os, structIdxs, structDefs);
			}
			break;
		}
		case Type::ARRAY: {
			Ptr<Array> a = std::get<Ptr<Array>>(value.val);
			Int l = a->size();
			if (l == 0) {
				writeCharValue(0xFFF7, os);
			} else {
				if (l > 65535) {
					writeCharValue(0xFFF9, os);
					writeBinaryInt32(l, os);
				} else {
					writeCharValue(0xFFF8, os);
					writeCharValue(l, os);
				}
				for (Flow v : a->elements()) {
					writeBinaryValue(v, os, structIdxs, structDefs);
				}
			}
			break;
		}
		default: {
			std::cerr << \"Not implemented: toBinary of \" << " + gctx.varname2cpp("toString") + "(value) << std::endl;
			break;
		}
	}
}
String " + gctx.varname2cpp("toBinary") + "(Flow value) {
	std::unordered_map<string, Int> structIdxs;
	std::vector<Ptr<Struct>> structDefs;

	std::vector<char16_t> os;
	// Placeholders for size of values - 32 bit int
	os.push_back(0);
	os.push_back(0);
	writeBinaryValue(value, os, structIdxs, structDefs);
	Int len = os.size();
	// Set length at the beginning
	os[0] = len & 0xffff;
	os[1] = len >> 16;

	if (structDefs.size() == 0) {
		writeCharValue(0xFFF7, os);
	} else {
		if (structDefs.size() > 65535) {
			writeCharValue(0xFFF9, os);
			writeBinaryInt32(structDefs.size(), os);
		} else {
			writeCharValue(0xFFF8, os);
			writeCharValue(structDefs.size(), os);
		}
	}
	for (Ptr<Struct> struct_def : structDefs) {
		writeCharValue(0xFFF8, os);
		writeCharValue(0x0002, os);
		writeCharValue(struct_def->size(), os);

		String s = struct_def->name();
		writeCharValue(0xFFFA, os);
		writeCharValue(s->size(), os);
		for (auto c : *s) {
			writeCharValue(c, os);
		}
	}
	return makeString(os.data(), os.size());
}\n", None(), []),

CppNative("createHttpServerNative", \gctx -> 
"Void " + gctx.varname2cpp("createHttpServerNative") + "(
	Int port,
	Bool isHttps,
	String pfxPath,
	String pfxPassword,
	Fun<Void> onOpen,
	Fun<
		String,
		String,
		String,
		Arr<Arr<String>>,
		Fun<Unit>,
		Fun<String, String>,
		Fun<String, Int, Bool>,
		Fun<Void, String, Arr<String>>
	> onMessage
): Nat<void> {
	// TODO: fill in the stub
	return Nat<void>();
}\n", None(), []),

CppNative("closeHttpServerNative", \gctx -> 
"Void " + gctx.varname2cpp("closeHttpServerNative") + "(Native server) {
	// TODO: fill in the stub
}\n", None(), []),

CppNative("makeHttpRequest", \gctx -> 
"Void " + gctx.varname2cpp("makeHttpRequest") + "(
	String url, 
	Bool post,
	Arr<Arr<String>> headers,
	Arr<Arr<String>> params,
	Fun<Void, String> onData,
	Fun<Void, String> onError, 
	Fun<Void, Int> onStatus) {
	// TODO: fill in the stub
	onStatus(500);
}\n", None(), []),

CppNative("httpCustomRequestNative", \gctx -> 
"Void " + gctx.varname2cpp("httpCustomRequestNative") + "(
	String url,
	String method,
	Arr<Arr<String>> headers,
	Arr<Arr<String>> parameters,
	String data,
	String responseEncoding,
	Fun<Int, String, Arr<Arr<String>>> onResponse,
	Bool async
) {
	// TODO: fill in the stub
}\n", None(), []),

CppNative("print", \gctx -> 
"Void " + gctx.varname2cpp("print") + "(String s) {
	std::cout << toStdString(*s);
}\n", None(), []),

CppNative("readUntil", \gctx -> 
"String " + gctx.varname2cpp("readUntil") + "(String str_pattern) {
	const char* pattern = toStdString(str_pattern).c_str();
	Int len = strlen(pattern);
	std::vector<char> line;
	char ch = '';
	Int pos = 0;
	while (cin.get(ch)) {
		line.push_back(ch);
		if (ch == pattern[pos]) {
			pos += 1;
			if (pos == len) {
				return makeString(std::string(line.data(), line.size());
			}
		} else {
			pos = 0;
		}
	}
}\n", None(), []),

CppNative("getFileContentBinary", \gctx -> "fun " + gctx.varname2cpp("getFileContentBinary") + "(name: String): String {
	try {
		val bytes = java.nio.file.Files.readAllBytes(java.nio.file.Paths.get(name))
		return bytes.toString(Charsets.ISO_8859_1)
	} catch (e: java.io.IOException) {
		return \"\"
	}
}\n", None(), []),

CppNative("setFileContentBytes", \gctx -> "fun " + gctx.varname2cpp("setFileContentBytes") + "(name: String, data: String): Boolean {
	java.io.Writer? writer = null;
	try {
		writer = java.io.BufferedWriter(java.io.OutputStreamWriter(
			java.io.FileOutputStream(name), Charsets.ISO_8859_1)
		);
		val chars = CharArray(data.length, {i -> data.codePointAt(i).toChar() })
		writer.write(chars);
	} catch (ex: java.io.IOException) {
	} finally {
		try {
			writer.close();
			return true;
		} catch (_: java.lang.Exception) {
		}
	}
	return false
}\n", None(), []),

CppNative("execSystemProcess", \gctx -> "fun " + gctx.varname2cpp("execSystemProcess") + "(command: String, args: ArrayList<String>, cwd: String, onOut: (String) -> Unit, onErr: (String) -> Unit): Int {
	val cmd = arrayOf(*arrayOf(command), *args.toTypedArray())
	val runner = ProcessStarter(cmd, cwd, onOut, onErr, {_ -> })
	runner.run()
	return runner.waitFor()
}\n", None(), []),

CppNative("startProcess", \gctx -> "fun " + gctx.varname2cpp("startProcess") + "(command: String, args: ArrayList<String>, cwd: String, stdin: string, onExit: (int, String, String) -> Unit): Unit {
	val cmd = arrayOf(*arrayOf(command), *args.toTypedArray())
	var stdout = ""
	var stderr = ""
	val runner = ProcessStarter(cmd, cwd, 
		{out -> stdout = stdout + out}, 
		{err -> stderr = stderr + err}, 
		{code -> onExit(code, stdout, stderr)}
	)
	flow_threadpool.submit(runner)
	runner.writeStdin(stdin)
}\n", None(), []),

CppNative("runSystemProcess", \gctx -> "fun " + gctx.varname2cpp("runSystemProcess") + "(command: String, args: ArrayList<String>, cwd: String, onOut: (String) -> Unit, onErr: (String) -> Unit, onExit: (Int) -> Unit): ProcessStarter {
	val cmd = arrayOf(*arrayOf(command), *args.toTypedArray())
	val runner = ProcessStarter(cmd, cwd, onOut, onErr, onExit)
	flow_threadpool.submit(runner)
	return runner
}\n", None(), []),

CppNative("writeProcessStdin", \gctx -> "fun " + gctx.varname2cpp("writeProcessStdin") + "(proc: Any, arg: String): Unit {
	(proc as ProcessStarter).writeStdin(arg);
}\n", None(), []),

CppNative("availableProcessors", \gctx -> "fun " + gctx.varname2cpp("availableProcessors") + "(): Int {
	return java.lang.Runtime.getRuntime().availableProcessors()
}\n", None(), []),

CppNative("setThreadPoolSize", \gctx -> "fun " + gctx.varname2cpp("setThreadPoolSize") + "(threads: Int): Unit {
	flow_threadpool = java.util.concurrent.Executors.newFixedThreadPool(threads);
}\n", None(), []),

], \nat -> nat.name);

}
