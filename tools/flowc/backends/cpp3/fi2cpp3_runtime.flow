import tools/flowc/backends/common;
import tools/flowc/backends/cpp3/fi2cpp3_util;

export {
	CppNative(
		name: string,
		def: ((string) -> string, (string) -> string) -> string,
		from: string
	);

	fiCpp3Runtime(type_nm: (string) -> string, var_nm: (string) -> string, cfg : FiCpp3Config) -> string;
	fiCpp3IsNative(name : string) -> bool;
	fiCpp3NativeFuncs : Tree<string, ((string) -> string, (string) -> string) -> string>;
	fiCpp3NativeInlines : Tree<string, ([string], FiTypeFunction) -> string>;
}

fiCpp3Runtime(type_nm: (string) -> string, var_nm: (string) -> string, cfg : FiCpp3Config) -> string {
"#include tools/flowc/backends/cpp3/flow_runtime.hpp" + "\n" +
"namespace flow {
template<typename T>
T " + var_nm("for") + "(T v, Fun<Bool, T> p, Fun<T, T> fn) {
	while (p(v)) v = fn(v);
	return v;
}
}
";
}

fiCpp3IsNative(name : string) -> bool {
	name == "for" ||
	containsKeyTree(fiCpp3NativeFuncs, name) ||
	containsKeyTree(fiCpp3NativeInlines, name)
}

fiCpp3NativeInlines = pairs2tree([
/*	Pair("length", \args, __ -> args[0] + ".size"),
	Pair("concat", \args, __ -> args[0] + ".plus(" + args[1] + ").toCollection(ArrayList())"),
	Pair("fold", \args, __ -> args[0] + ".fold(" + args[1] + ", " + args[2] + ")"),
	Pair("foldi", \args, __ -> args[0] + ".foldIndexed(" + args[1] + ", " + args[2] + ")"),
	Pair("map", \args, f_type ->
		args[0] + ".map(" + args[1] + ").toCollection(ArrayList())"
	),
	Pair("mapi", \args, f_type -> 
		args[0] + ".mapIndexed(" + args[1] + ").toCollection(ArrayList())"
	),
	Pair("filter", \args, f_type -> 
		args[0] + ".filter(" + args[1] + ").toCollection(ArrayList())"
	),
	Pair("isSameStructType", \args, __ -> "(" + args[0] + "::class == " + args[1] + "::class)"),
	Pair("quit", \args, __ -> "cpp3.system.exitProcess(" + args[0] + ")"),
	Pair("println2", \args, f_type -> {
		switch (f_type.args[0].type) {
			FiTypeString(): "println(" + args[0] + ")";
			default: "println(toString(" + args[0] + "))";
		}
	}),
	Pair("i2s", \args, __ -> args[0] + ".toString()"),
	Pair("d2s", \args, __ -> args[0] + ".toString()"),
	Pair("i2d", \args, __ -> args[0] + ".toDouble()"),
	Pair("exp", \args, __ -> "cpp3.math.exp(" + args[0] + ")"),
	Pair("log", \args, __ -> "cpp3.math.ln(" + args[0] + ")"),
	Pair("trunc", \args, __ -> "cpp3.math.truncate(" + args[0] + ").toInt()"),
	Pair("strlen", \args, __ -> args[0] + ".length"),
	//Pair("s2a", \args, __ -> args[0] + ".toCharArray().map({___char___ -> ___char___.toInt()}).toTypedArray()"),
	Pair("bitAnd", \args, __ -> "(" + args[0] + " and " + args[1] + ")"),
	Pair("bitOr", \args, __ -> "(" + args[0] + " or " + args[1] + ")"),
	Pair("bitXor", \args, __ -> "(" + args[0] + " xor " + args[1] + ")"),
	Pair("bitNot", \args, __ -> args[0] + ".inv()"),
	Pair("bitShl", \args, __ -> "(" + args[0] + " shl " + args[1] + ")"),
	Pair("bitUshr", \args, __ -> "(" + args[0] + " ushr " + args[1] + ")"),
	Pair("getCharCodeAt", \args, __ -> args[0] + ".codePointAt(" + args[1] + ")"),
	Pair("getCharAt", \args, __ -> args[0] + ".get(" + args[1] + ").toString()"),
	Pair("fromCharCode", \args, __ -> "String(charArrayOf(" + args[0] + ".toChar()))"),
	Pair("toString2", \args, __ -> "toString(" + args[0] + ")"),
	Pair("toLowerCase", \args, __ -> args[0] + ".lowercase()"), 
	Pair("toUpperCase", \args, __ -> args[0] + ".uppercase()"),
	Pair("strIndexOf", \args, __ -> args[0] + ".indexOf(" + args[1] + ")"),
	Pair("getKeyValueN", \args, __ -> args[1]),
	Pair("fail", \args, __ -> "assert(false, { -> " + args[0] + "})"),

	Pair("flow2i", \args, __ -> "fflow2i(" + args[0] + ")"),
	Pair("flow2d", \args, __ -> "fflow2d(" + args[0] + ")"),
	Pair("flow2b", \args, __ -> "fflow2b(" + args[0] + ")"),
	Pair("flow2s", \args, __ -> "fflow2s(" + args[0] + ")"),
	Pair("timer", \args, __ -> "timer(" + args[0] +  ", " + args[1] + ")"),

	/*
native makeNativeHashMap : (hash :(?) -> int, cap : int, load : double) -> native = NativeHashMap.init;
native setNativeHashMap : (m : native, key : ?, value : ??) -> void = NativeHashMap.set;
native getNativeHashMap : (m : native, key : ?) -> Maybe<??> = NativeHashMap.get;
native removeNativeHashMap : (m : native, key : ?) -> void = NativeHashMap.remove;
native containsNativeHashMap : (m : native, key : ?) -> bool = NativeHashMap.contains;
native sizeNativeHashMap : (m : native) -> int = NativeHashMap.size;
native clearNativeHashMap : (m : native) -> void = NativeHashMap.clear;
native cloneNativeHashMap : (m : native) -> native = NativeHashMap.clone;
native iterNativeHashMap : (m : native, f : (?, ??) -> void) -> void = NativeHashMap.iter;
native funcNativeHashMap : (m : native) -> (?) -> int = NativeHashMap.hash;
* /

	//Pair("makeNativeHashMap")
*/
]);

fiCpp3NativeFuncs = pairs2tree([

Pair("length", \type_nm, var_nm -> 
"template<typename T>
inline Int " + var_nm("length") + "(Arr<T> a) { 
	return a.arr->size(); 
}\n"),
Pair("concat", \type_nm, var_nm -> 
"template<typename T>
inline Arr<T> " + var_nm("concat") + "(Arr<T> a1, Arr<T> a2) {
	Arr<T> ret = Arr<T>(a1.arr->size() + a2.arr->size());
	for(T x : *a1.arr) ret.arr->push_back(x);
	for(T x : *a2.arr) ret.arr->push_back(x);
	return ret;
}\n"),
Pair("fold", \type_nm, var_nm -> 
"template<typename T, typename V>
inline V " + var_nm("fold") + "(Arr<T> a, V v, Fun<V, V, T> fn) {
	for (T x : *a.arr) v = fn(v, x);
	return v;
}\n"),
Pair("foldi", \type_nm, var_nm -> 
"template<typename T, typename V>
inline V " + var_nm("foldi") + "(Arr<T> a, V v, Fun<V, Int, V, T> fn) {
	Int i = 0;
	for (T x : *a.arr) v = fn(i++, v, x);
	return v;
}\n"),
Pair("map", \type_nm, var_nm -> 
"template<typename T, typename V>
inline Arr<V> " + var_nm("map") + "(Arr<T> a, Fun<V, T> fn) {
	Arr<V> ret(a.arr->size());
	for (T x : *a.arr) ret.arr->push_back(fn(x));
	return ret;
}\n"),
Pair("
mapi", \type_nm, var_nm -> 
"template<typename T, typename V>
inline Arr<V> " + var_nm("mapi") + "(Arr<T> a, Fun<V, Int, T> fn) {
	Arr<V> ret(a.arr->size());
	Int i = 0;
	for (T x : *a.arr) ret.arr->push_back(fn(i++, x));
	return ret;
}\n"),
Pair("filter", \type_nm, var_nm -> 
"template<typename T>
inline Arr<T> " + var_nm("filter") + "(Arr<T> a, Fun<Bool, T> fn) {
	Arr<T> ret(a.arr->size());
	for (T x : *a.arr) if (fn(x)) ret.arr->push_back(x);
	return ret;
}\n"),
Pair("isSameStructType", \type_nm, var_nm -> 
"inline Bool " + var_nm("isSameStructType") + "(Flow o1, Flow o2) {
	if (o1.index() != Type::STRUCT || o2.index() != Type::STRUCT) {
		return false;
	} else {
		return std::get<Ptr<Struct>>(o1)->name() == std::get<Ptr<Struct>>(o2)->name();
	}
}\n"),
Pair("quit", \type_nm, var_nm -> "void " + var_nm("quit") + "(Int code) { exit(code); }\n\n"),
Pair("println2", \type_nm, var_nm -> 
"void " + var_nm("println2") + "(Flow x) { 
	flow2string(x, std::cout); std::cout << std::endl; 
}\n"),
Pair("i2s", \type_nm, var_nm -> "String " + var_nm("i2s") + "(Int x) { return makeString(std::to_string(x)); }\n\n"),
Pair("d2s", \type_nm, var_nm -> "String " + var_nm("d2s") + "(Double x) { std::ostringstream os; os << x; return makeString(os.str()); }\n\n"),
Pair("i2d", \type_nm, var_nm -> "Double " + var_nm("i2d") + "(Int x) { return x; }\n\n"),
Pair("exp", \type_nm, var_nm -> "Double " + var_nm("exp") + "(Double x) { return exp(x); }\n\n"),
Pair("log", \type_nm, var_nm -> "Double " + var_nm("log") + "(Double x) { return log(x); }\n\n"),
Pair("trunc", \type_nm, var_nm -> "Int " + var_nm("trunc") + "(Double x) { return trunc(x); } \n\n"),
Pair("strlen", \type_nm, var_nm -> "Int " + var_nm("strlen") + "(String s) { return s->size(); }\n\n"),
//Pair("s2a", \type_nm, var_nm ->args[0] + ".toCharArray().map({___char___ -> ___char___.toInt()}).toTypedArray()"),
Pair("bitAnd", \type_nm, var_nm -> "Int " + var_nm("bitAnd") + "(Int x, Int y) { return x & y; }\n\n"),
Pair("bitOr", \type_nm, var_nm -> "Int " + var_nm("bitOr") + "(Int x, Int y) { return x | y; }\n\n"),
Pair("bitXor", \type_nm, var_nm -> "Int " + var_nm("bitXor") + "(Int x, Int y) { return x ^ y; }\n\n"),
Pair("bitNot", \type_nm, var_nm -> "Int " + var_nm("bitNot") + "(Int x) { return ~x; }\n\n"),
Pair("bitShl", \type_nm, var_nm -> "Int " + var_nm("bitShl") + "(Int x, Int y) { return x << y; }\n\n"),
Pair("bitUshr", \type_nm, var_nm -> "Int " + var_nm("bitUshr") + "(Int x, Int y) { return x >> y; }\n\n"),
Pair("getCharCodeAt", \type_nm, var_nm -> "Int " + var_nm("getCharCodeAt") + "(String s, Int i) { return s->at(i); }\n\n"),
Pair("getCharAt", \type_nm, var_nm -> "String " + var_nm("getCharAt") + "(String s, Int i) { return makeString(s->at(i)); }\n\n"),
Pair("fromCharCode", \type_nm, var_nm -> "String " + var_nm("fromCharCode") + "(Int code) { return makeString(code); }\n\n"),
Pair("toString2", \type_nm, var_nm -> 
"String " + var_nm("toString2") + "(Flow x) {
	std::ostringstream os;
	flow2string(x, os);
	return makeString(os.str());
}\n"),
Pair("toLowerCase", \type_nm, var_nm -> 
"String " + var_nm("toLowerCase") + "(String s) {
	String lower = makeString(s);
	std::transform(lower->begin(), lower->end(), lower->begin(), [](char16_t c){ return std::tolower(c); });
	return lower;
}\n"), 
Pair("toUpperCase", \type_nm, var_nm -> 
"String " + var_nm("toUpperCase") + "(String s) {
	String upper = makeString(s);
	std::transform(upper->begin(), upper->end(), upper->begin(), [](char16_t c){ return std::toupper(c); });
	return upper;
}\n"),
Pair("strIndexOf", \type_nm, var_nm -> 
"Int " + var_nm("strIndexOf") + "(String s, String p) {
	auto i = s->find(*p);
	return (i == string::npos) ? -1 : i;
}\n"),
Pair("getKeyValueN", \type_nm, var_nm -> "String " + var_nm("getKeyValueN") + "(String key, String defval) { return defval; }\n\n"),
Pair("fail", \type_nm, var_nm -> "Void " + var_nm("fail") + "(String msg) { std::cerr << toStdString(msg); assert(false); }\n\n"),

Pair("flow2i", \type_nm, var_nm -> "Int " + var_nm("flow2i") + "(Flow f) { return std::get<Int>(f); }\n\n"),
Pair("flow2d", \type_nm, var_nm -> "Double " + var_nm("flow2d") + "(Flow f) { return std::get<Double>(f); }\n\n"),
Pair("flow2b", \type_nm, var_nm -> "Bool " + var_nm("flow2b") + "(Flow f) { return std::get<Bool>(f); }\n\n"),
Pair("flow2s", \type_nm, var_nm -> "String " + var_nm("flow2s") + "(Flow f) { return std::get<String>(f); }\n\n"),
Pair("timer", \type_nm, var_nm -> "fun " + var_nm("timer") + "(delay: Int, cb: () -> Unit): Unit = timer(delay, cb)\n\n"),


Pair("for", \type_nm, var_nm -> 
"template<typename T>
T " + var_nm("for") + "(T v, Fun<Bool, T> p, Fun<T, T> fn) {
	while (p(v)) v = fn(v);
	return v;
}\n"),

Pair("replace", \type_nm, var_nm -> 
"template<typename T>
Arr<T> " + var_nm("replace") + "(Arr<T> a, Int i, T v) {
	Arr<T> ret(*a.arr);
	(*ret.arr)[i] = v; 
	return ret; 
}\n"),

Pair("subrange", \type_nm, var_nm -> 
"template<typename T>
Arr<T> " + var_nm("subrange") + "(Arr<T> a, Int i, Int len) {
	Arr<T> ret(len);
	for (Int j = 0; j < len; ++ j) ret.arr->push_back(a.arr->at(i + j));
	return ret;
}\n"),

Pair("enumFromTo", \type_nm, var_nm -> 
"Arr<Int> " + var_nm("enumFromTo") + "(Int beg, Int end) {
	if (beg > end) {
		return Arr<Int>();
	} else {
		Arr<Int> ret(end - beg + 1);
		for (Int i = 0; i < end - beg + 1; ++i) {
			ret.arr->push_back(beg + i);
		}
		return ret;
	}
}\n"),

Pair("iter", \type_nm, var_nm -> 
"template<typename T>
Void " + var_nm("iter") + "(Arr<T> a, Fun<Void, T> fn) { 
	for (T x : *a.arr) fn(x);
}\n"),

Pair("iteri", \type_nm, var_nm -> 
"template<typename T>
Void " + var_nm("iteri") + "(Arr<T> a, Fun<Void, Int, T> fn) {
	Int i = 0;
	for (T x : *a.arr) fn(i++, x);
}\n"),

Pair("iteriUntil", \type_nm, var_nm -> 
"template<typename T>
Int " + var_nm("iteriUntil") + "(Arr<T> a, Fun<Bool, Int, T> fn) {
	for (Int i = 0; i < a.arr->size(); ++ i) {
		if (fn(i, a.arr->at(i))) return i;
	}
	return a.arr->size();
}\n"),
	
Pair("iterUntil", \type_nm, var_nm -> 
"template<typename T>
Int " + var_nm("iterUntil") + "(Arr<T> a, Fun<Bool, T> fn) {
	for (Int i = 0; i < a.arr->size(); ++ i)) {
		if (fn(a.arr->at(i))) return i;
	}
	return a.arr->size();
}
"),

Pair("substring", \type_nm, var_nm -> 
"String " + var_nm("substring") + "(String str, Int i, Int l) {
	Int strlen = str->size();
	Int start = i;
	Int len = l;
	if (len < 0) {
		if (start < 0) {
			len = 0;
		} else {
			Int smartLen1 = len + start;
			if (smartLen1 >= 0) {
				len = 0;
			} else {
				Int smartLen2 = smartLen1 + strlen;
				if (smartLen2 <= 0) len = 0;
				else len = smartLen2;
			}
		}
	}
	if (start < 0) {
		Int smartStart = start + strlen;
		if (smartStart > 0) {
			start = smartStart;
		} else {
			start = 0;
		}
	} else if (start >= strlen) {
		len = 0;
	}

	if (len < 1) {
		return makeString();
	} else {
		//len = clipLenToRange(start, len, strlen);
		Int end = start + len;
		if (end > strlen || end  < 0) {
			len = strlen - start;
		}
		return makeString(str->substr(start, len));
	}
}\n"),

Pair("getUrlParameterNative", \type_nm, var_nm -> 
"String " + var_nm("getUrlParameterNative") + "(String n) {
	if (command_args.find(*n) == command_args.end()) {
		std::cout << \"param not found\" << std::endl;
		return makeString();
	} else {
		std::cout << \"param IS found\" << std::endl;
		return makeString(command_args.at(*n));
	}
}\n"),

Pair("list2array", \type_nm, var_nm -> 
"
template<typename T>
Arr<T> " + var_nm("list2array") + "(Union list) {
	Int count = 0;
	Struct* l = list.get();
	while (l->size() > 0) {
		" + type_nm("Cons") + "<T>* cons = dynamic_cast<" + type_nm("Cons") + "<T>*>(l);
		++count;
		l = cons->" + var_nm("tail") + ".get();  
	}
	Arr<T> ret(new std::vector<T>(count));
	l = list.get();
	while (l->size() > 0) {
		" + type_nm("Cons") + "<T>* cons = dynamic_cast<" + type_nm("Cons") + "<T>*>(l);
		(*ret.arr)[--count] = cons->" + var_nm("head") + ";
		l = cons->" + var_nm("tail") + ".get();  
	}
	return ret;
}\n"),

Pair("list2string", \type_nm, var_nm -> 
"String " + var_nm("list2string") + "(Union list) {
	Int len = 0;
	Int count = 0;
	String rv = makeString();
	Struct* l = list.get();
	while (l->size() > 0) {
		" + type_nm("Cons") + "<String>* cons = dynamic_cast<" + type_nm("Cons") + "<String>*>(l);
		len += cons->" + var_nm("head") + "->size();
		++count;
		l = cons->" + var_nm("tail") + ".get();  
	}
	String strings[count];
	l = list.get();
	Int i = count;
	while (l->size() > 0) {
		" + type_nm("Cons") + "<String>* cons = dynamic_cast<" + type_nm("Cons") + "<String>*>(l);
		strings[--i] = cons->" + var_nm("head") + ";
		l = cons->" + var_nm("tail") + ".get();  
	}
	std::ostringstream os;
	for (int i = 0; i < count; i++) {
		os << toStdString(strings[i]);
	}
	return makeString(os.str());
}\n"),

Pair("getAllUrlParametersArray", \type_nm, var_nm -> 
"Arr<Arr<String>> " + var_nm("getAllUrlParametersArray") + "() {
	Arr<Arr<String>> params(command_args.size());
	for (auto p : command_args) {
		Arr<String> param(2);
		param.arr->push_back(makeString(p.first));
		if (p.second.size() == 0) {
			param.arr->push_back(makeString());
		} else {
			param.arr->push_back(makeString(p.second));
		}
		params.arr->push_back(param);
	}
	return params;
}
"),

Pair("makeStructValue", \type_nm, var_nm -> "
Flow " + var_nm("makeStructValue") + "(String name, Arr<Flow> args, Flow defval) {
	if (struct_defs.find(*name) == struct_defs.end()) {
		return defval;
	} else {
		return struct_defs.at(*name).make(args);
	}
}\n"),

Pair("isSameObj", \type_nm, var_nm -> 
"Bool " + var_nm("isSameObj") + "(Flow a, Flow b) {
	if (a.index() != b.index()) {
		return false;
	} else {
		switch (a.index()) {
			case Type::INT:    return std::get<Int>(a) == std::get<Int>(b);
			case Type::BOOL:   return std::get<Bool>(a) == std::get<Bool>(b);
			case Type::DOUBLE: return std::get<Double>(a) == std::get<Double>(b);
			case Type::STRING: return *std::get<String>(a) == *std::get<String>(b);
			case Type::STRUCT: return std::get<Ptr<Struct>>(a).get() == std::get<Ptr<Struct>>(b).get();
			case Type::ARRAY:  return std::get<Ptr<Array>>(a).get() == std::get<Ptr<Array>>(b).get();
			case Type::REF:    return std::get<Ptr<Reference>>(a).get() == std::get<Ptr<Reference>>(b).get();
			case Type::FUNC:   return std::get<Ptr<Function>>(a).get() == std::get<Ptr<Function>>(b).get();
			case Type::NATIVE: return std::get<Ptr<Native>>(a).get() == std::get<Ptr<Native>>(b).get();
		}
	}
}\n"),

Pair("isStructName", \type_nm, var_nm -> 
"Bool " + var_nm("isStructName") + "(String name) {
	return (struct_defs.find(*name) != struct_defs.end());
}\n"),

Pair("voidValue", \type_nm, var_nm -> "
struct RuntimeVoid : public Native { 
	String name() const override { return makeString(\"runtime void\"); }
	String toString() const override { return makeString(\"runtime void\"); }
};
Flow " + var_nm("voidValue") + "() {
	return std::makeShared<RuntimeVoid>();
}\n"),

Pair("isArray", \type_nm, var_nm -> 
"Bool " + var_nm("isArray") + "(Flow f) {
	return f.index() == Type::ARRAY;
}\n"),

Pair("loaderUrl", \type_nm, var_nm -> "String " + var_nm("loaderUrl") + "() { return makeString(\"\"); }\n\n"),

// TODO: complete getTargetName
Pair("getTargetName", \type_nm, var_nm -> 
"String " + var_nm("getTargetName") + "() {
	return makeString(\"unknown in cpp3 baclkend\");
}\n"),

Pair("timestamp", \type_nm, var_nm -> 
"Double " + var_nm("timestamp") + "() {
	return std::chrono::duration_cast<std::chrono::milliseconds>(
		std::chrono::system_clock::now().time_since_epoch()
	).count();
}\n"),

Pair("string2time", \type_nm, var_nm -> 
"
Double " + var_nm("string2time") + "(String s) {
	const std::time_get<char>& time_get = std::use_facet<std::time_get<char>>(std::locale());
	std::ios::iostate state;
	std::istringstream iss(toStdString(s));
	std::tm when;
  	time_get.get(iss, std::time_get<char>::iter_type(), iss, state, &when,
		date_time_format.data(), date_time_format.data() + date_time_format.length()
	);
	if (!(state & std::ios::ios_base::failbit)) {
		return mktime(&when);
	} else {
		return 0.0;
	}
}\n"),

Pair("time2string", \type_nm, var_nm -> "
String " + var_nm("time2string") + "(Double t) {
	const std::time_put<char>& time_put = std::use_facet <std::time_put<char>>(std::locale());
  	std::time_t timestamp = t;
	std::tm* time = std::localtime(&timestamp);
	std::ostringstream out;
	time_put.put(out, out, ' ', time, date_time_format.data(), date_time_format.data() + date_time_format.length());
	return makeString(out.str());
}\n"),

Pair("gc", \type_nm, var_nm -> "Void " + var_nm("gc") + "() { }\n\n"),

Pair("fail", \type_nm, var_nm -> "Void " + var_nm("fail") + "(String msg) {
	std::cerr << msg << std::flush;
	assert(false);
}\n"),

Pair("fail0", \type_nm, var_nm -> "
template<typename T>
T " + var_nm("fail0") + "(String msg) {
	std::cerr << msg << std::flush;
	assert(false);
	return reinterpret_cast<T>(0);
}\n"),

Pair("hostCall", \type_nm, var_nm -> "Flow " + var_nm("hostCall") + "(String name, Arr<Flow> args) {
	std::cerr << \"hostCall is not yet implemented in cpp3 backend\" << std::endl;
	assert(false);
	return 0;
}\n"),

Pair("getApplicationPath", \type_nm, var_nm -> "fun " + var_nm("getApplicationPath") + "(): String {
	if (flowc_target_language == \"java\") {
		val currentJavaJarFile = Struct::class.java.getProtectionDomain().getCodeSource().getLocation().getPath()
		return java.io.File(currentJavaJarFile).getAbsolutePath()
	} else {
		assert(false, { -> \"getApplicationPath native is not providede for platform \" + flowc_target_language})
		return \"\"
	}
}
"),

Pair("getFileContent", \type_nm, var_nm -> "fun " + var_nm("getFileContent") + "(path: String): String {
	if (flowc_target_language == \"java\") {
		try {
			val bytes = java.nio.file.Files.readAllBytes(java.nio.file.Paths.get(path))
			return bytes.toString(Charsets.UTF_8)
			//return java.io.File(path).inputStream().readBytes().toString(Charsets.UTF_8)
		} catch (_: java.lang.Exception) {
			return \"\"
		}
	} else {
		assert(false, { -> \"getFileContent native is not providede for platform \" + flowc_target_language})
		return \"\"
	}
}
"),

Pair("setFileContent", \type_nm, var_nm -> "fun " + var_nm("setFileContent") + "(path: String, content: String): Boolean {
	if (flowc_target_language == \"java\") {
		try {
			val bytes = content.toByteArray(Charsets.UTF_8)
			java.nio.file.Files.write(
				java.nio.file.Paths.get(path), 
				bytes, 
				java.nio.file.StandardOpenOption.CREATE, 
				java.nio.file.StandardOpenOption.TRUNCATE_EXISTING
			)
			return true
		} catch (_: java.io.IOException) {
			return false
		}
	} else {
		assert(false, { -> \"setFileContent native is not providede for platform \" + flowc_target_language})
		return false
	}
}
"),

Pair("printCallstack", \type_nm, var_nm -> "fun " + var_nm("printCallstack") + "(): Unit {
	if (flowc_target_language == \"java\") {
		java.lang.Thread.dumpStack();
	} else {
		assert(false, { -> \"printCallstack native is not providede for platform \" + flowc_target_language})
	}
}
"),

Pair("random", \type_nm, var_nm -> "fun " + var_nm("random") + "(): Double {
	if (flowc_target_language == \"java\") {
		return java.lang.Math.random()
	} else {
		assert(false, { -> \"random native is not providede for platform \" + flowc_target_language})
		return 0.0
	}
}
"),

Pair("randomGenerator", \type_nm, var_nm -> "fun " + var_nm("randomGenerator") + "(seed: Int): () -> Double {
	if (flowc_target_language == \"java\") {
		val generator = java.util.Random(seed.toLong())
		return { -> generator.nextDouble() }
	} else {
		assert(false, { -> \"randomGenerator native is not providede for platform \" + flowc_target_language})
		return { -> 0.0 }
	}
}
"),

Pair("s2a", \type_nm, var_nm -> "fun " + var_nm("s2a") + "(s: String): ArrayList<Int> {
	if (flowc_target_language == \"java\") {
		return Array<Int>(s.length, {i -> s.codePointAt(i)}).toCollection(ArrayList())
	} else {
		assert(false, { -> \"s2a native is not providede for platform \" + flowc_target_language})
		return arrayListOf<Int>()
	}
}
"),

Pair("string2utf8", \type_nm, var_nm -> "fun " + var_nm("string2utf8") + "(str: String): ArrayList<Int> {
	if (flowc_target_language == \"java\") {
		val bytes = str.toByteArray(Charsets.UTF_8)
		return Array<Int>(bytes.size, {i -> bytes[i].toUByte().toInt()}).toCollection(ArrayList())
	} else {
		assert(false, { -> \"string2utf8 native is not providede for platform \" + flowc_target_language})
		return arrayListOf<Int>()
	}
}
"),

Pair("createDirectory", \type_nm, var_nm -> "fun " + var_nm("createDirectory") + "(path: String): String {
	if (flowc_target_language == \"java\") {
		try {
			val file = java.io.File(path)
			if (file.mkdirs()) {
				return \"\"
			} else {
				return \"Could not make \" + path
			}
		} catch (_: java.lang.SecurityException) {
			return \"Security exception when making \" + path
		}
	} else {
		assert(false, { -> \"createDirectory native is not providede for platform \" + flowc_target_language})
		return \"\"
	}
}
"),

Pair("fileExists", \type_nm, var_nm -> "fun " + var_nm("fileExists") + "(path: String): Boolean {
	if (flowc_target_language == \"java\") {
		return java.io.File(path).exists()
	} else {
		assert(false, { -> \"fileExists native is not providede for platform \" + flowc_target_language})
		return false
	}
}
"),

Pair("isDirectory", \type_nm, var_nm -> "fun " + var_nm("isDirectory") + "(path: String): Boolean {
	if (flowc_target_language == \"java\") {
		return java.io.File(path).isDirectory()
	} else {
		assert(false, { -> \"isDirectory native is not providede for platform \" + flowc_target_language})
		return false
	}
}
"),

Pair("deleteDirectory", \type_nm, var_nm -> "fun " + var_nm("deleteDirectory") + "(path: String): String {
	if (flowc_target_language == \"java\") {
		val file = java.io.File(path)
		if (file.delete()) {
			return \"\"
		} else {
			return \"Could not delete \" + path
		}
	} else {
		assert(false, { -> \"deleteDirectory native is not providede for platform \" + flowc_target_language})
		return \"\"
	}
}
"),

Pair("deleteFile", \type_nm, var_nm -> "fun " + var_nm("deleteFile") + "(path: String): String {
	if (flowc_target_language == \"java\") {
		val file = java.io.File(path)
		if (file.delete()) {
			return \"\"
		} else {
			return \"Could not delete \" + path;
		}
	} else {
		assert(false, { -> \"deleteFile native is not providede for platform \" + flowc_target_language})
		return \"\"
	}
}
"),

Pair("readDirectory", \type_nm, var_nm -> "fun " + var_nm("readDirectory") + "(path: String): ArrayList<String> {
	if (flowc_target_language == \"java\") {
		val file = java.io.File(path)
		return file.list().toCollection(ArrayList())
	} else {
		assert(false, { -> \"readDirectory native is not providede for platform \" + flowc_target_language})
		return arrayListOf<String>()
	}
}
"),

Pair("renameFile", \type_nm, var_nm -> "fun " + var_nm("renameFile") + "(old: String, new: String): String {
	if (flowc_target_language == \"java\") {
		val file = java.io.File(old)
		val newfile = java.io.File(new)
		if (file.renameTo(newfile)) {
			return \"\"
		} else {
			return \"Could not rename \" + old + \" to \" + new
		}
	} else {
		assert(false, { -> \"renameFile native is not providede for platform \" + flowc_target_language})
		return \"\"
	}
}
"),

Pair("resolveRelativePath", \type_nm, var_nm -> "fun " + var_nm("resolveRelativePath") + "(path: String): String {
	if (flowc_target_language == \"java\") {
		val file = java.io.File(path)
		try {
			return file.getCanonicalPath()
		} catch (_: java.lang.Exception) {
			return \"\";
		}
	} else {
		assert(false, { -> \"resolveRelativePath native is not providede for platform \" + flowc_target_language})
		return \"\"
	}
}
"),

Pair("fileModified", \type_nm, var_nm -> "fun " + var_nm("fileModified") + "(path: String): Double {
	if (flowc_target_language == \"java\") {
		val file = java.io.File(path)
		val d = file.lastModified().toDouble() / 1000.0
		return java.lang.Math.round(d).toDouble() * 1000.0
	} else {
		assert(false, { -> \"fileModified native is not providede for platform \" + flowc_target_language})
		return 0.0
	}
}
"),

Pair("fileSize", \type_nm, var_nm -> "fun " + var_nm("fileSize") + "(path: String): Double {
	if (flowc_target_language == \"java\") {
		val file = java.io.File(path)
		return file.length().toDouble()
	} else {
		assert(false, { -> \"fileSize native is not providede for platform \" + flowc_target_language})
		return 0.0
	}
}
"),

Pair("stringbytes2int", \type_nm, var_nm -> "Int " + var_nm("stringbytes2int") + "(String s) {
	if (flowc_target_language == \"java\") {
		Int l = min(s.length, 2);
		var bb = java.nio.ByteBuffer.allocate(4);
		for (i in 0..l - 1) {
			val v = s.get(i).code
			val b0 = (v and 0xff).toByte()
			val b1 = (v shr 8).toByte()
			bb.put(2 * i, b0);
			bb.put((2 * i) + 1, b1);
		}
		return bb.order(java.nio.ByteOrder.LITTLE_ENDIAN).getInt(0);
	} else {
		assert(false, { -> \"stringbytes2int native is not providede for platform \" + flowc_target_language})
		return 0
	}
}
"),

Pair("stringbytes2double", \type_nm, var_nm -> "fun " + var_nm("stringbytes2double") + "(s: String): Double {
	if (flowc_target_language == \"java\") {
		val l = java.lang.Math.min(s.length, 4);
		var bb = java.nio.ByteBuffer.allocate(8);
		for (i in 0..l - 1) {
			val v = s.get(i).code
			val b0 = (v and 0xff).toByte()
			val b1 = (v shr 8).toByte()
			bb.put(2 * i, b0);
			bb.put((2 * i) + 1, b1);
		}
		return bb.order(java.nio.ByteOrder.LITTLE_ENDIAN).getDouble(0);
	} else {
		assert(false, { -> \"stringbytes2double native is not providede for platform \" + flowc_target_language})
		return 0.0
	}
}
"),

Pair("fromBinary", \type_nm, var_nm -> "fun " + var_nm("fromBinary") + "(s: String, defval: Any, fixup: Any): Any {
	return s
}
"),

Pair("toBinary", \type_nm, var_nm -> "
fun " + var_nm("toBinary") + "(value: Any): String {
	var structIdxs = HashMap<String, Int>()
	var structDefs = ArrayList<Struct>()

	val buf = StringBuilder()
	writeBinaryValue(value, buf, structIdxs, structDefs)
	val buf2 = StringBuilder()
	writeBinaryInt32(buf.length + 2, buf2)

	if (structDefs.size == 0) {
		writeCharValue(0xFFF7, buf)
	} else {
		if (structDefs.size > 65535) {
			writeCharValue(0xFFF9, buf)
			writeBinaryInt32(structDefs.size, buf)
		} else {
			writeCharValue(0xFFF8, buf)
			writeCharValue(structDefs.size, buf)
		}
	}
	for (struct_def in structDefs) {
		writeCharValue(0xFFF8, buf)
		writeCharValue(0x0002, buf)
		writeCharValue(struct_def.fields().size, buf)

		val s = struct_def.name()
		writeCharValue(0xFFFA, buf)
		writeCharValue(s.length, buf)
		for (c in s) {
			writeCharValue(c.code, buf)
		}
	}
	return buf2.toString() + buf.toString()
}

fun writeCharValue(c: Int, buf: StringBuilder): Unit {
	buf.append(java.lang.Character.toChars(c and 0xffff))
}

fun writeBinaryInt32(i: Int, buf: StringBuilder): Unit {
	val low = (i and 0xffff)
	val high = (i shr 16)
	writeCharValue(low, buf)
	writeCharValue(high, buf)
}

fun writeIntValue(value: Int, buf: StringBuilder): Unit {
	if ((value and 0xFFFF8000.toInt()) != 0) {
		writeCharValue(0xFFF5, buf)
		writeBinaryInt32(value, buf)
	} else {
		writeCharValue(value, buf)
	}
}

fun writeStringValue(value: String, buf: StringBuilder): Unit {
	val str_len = value.length
	if (str_len > 65535) {
		writeCharValue(0xFFFB, buf)
		writeBinaryInt32(str_len, buf)
	} else {
		writeCharValue(0xFFFA, buf)
		writeCharValue(str_len, buf)
	}
	for (c in value) {
		writeCharValue(c.code, buf)
	}
}

fun writeDoubleValue(value: Double, buf: StringBuilder): Unit {
	writeCharValue(0xFFFC, buf)
	val bb = java.nio.ByteBuffer.allocate(8).order(java.nio.ByteOrder.LITTLE_ENDIAN)
	bb.putDouble(value)
	for (i in 0..3) {
		writeCharValue(bb.getShort(i + i).toInt(), buf)
	}
}

fun writeBooleanValue(value: Boolean, buf: StringBuilder): Unit {
	writeCharValue(if (value) 0xFFFE else 0xFFFD, buf);
}

fun writeStructValue(value: Struct, buf: StringBuilder, structIdxs: HashMap<String, Int>, structDefs: ArrayList<Struct>): Unit {
	val struct_id = value.name();
	var struct_idx = structIdxs.get(struct_id);
	if (struct_idx == null) {
		struct_idx = structDefs.size;
		structIdxs.put(struct_id, struct_idx);
		structDefs.add(value);
	}
	writeCharValue(0xFFF4, buf);
	writeCharValue(struct_idx, buf);
	for (w in value.values())  {
		writeBinaryValue(w, buf, structIdxs, structDefs);
	}
}

fun writeBinaryValue(value: Any?, buf: StringBuilder, structIdxs: HashMap<String, Int>, structDefs: ArrayList<Struct>): Unit {
	when (value) {
		is String -> writeStringValue(value, buf)
		is Double -> writeDoubleValue(value, buf)
		is Int -> writeIntValue(value, buf)
		is Boolean -> writeBooleanValue(value, buf)
		is Struct -> writeStructValue(value, buf, structIdxs, structDefs)
		is ArrayList<*> -> {
			val l = value.size;
			if (l == 0) {
				writeCharValue(0xFFF7, buf);
			} else {
				if (l > 65535) {
					writeCharValue(0xFFF9, buf);
					writeBinaryInt32(l, buf);
				} else {
					writeCharValue(0xFFF8, buf);
					writeCharValue(l, buf);
				}
				for (v in value) {
					writeBinaryValue(v, buf, structIdxs, structDefs);
				}
			}
		}
		else -> {
			System.out.println(\"Not implemented: toBinary of \" + value);
		}
	}
}
"),

Pair("createHttpServerNative", \type_nm, var_nm -> "fun " + var_nm("createHttpServerNative") + "(
	port: Int,
	isHttps: Boolean,
	pfxPath: String,
	pfxPassword: String,
	onOpen: () -> Unit,
	onMessage: (
		String,
		String,
		String,
		ArrayList<ArrayList<String>>,
		() -> Unit,
		(String) -> String,
		(Int, Boolean) -> String,
		(String, ArrayList<String>) -> Unit
	) -> Unit
): Any {
	if (flowc_target_language == \"java\") {
		assert(false, { -> \"createHttpServerNative native is not providede for platform \" + flowc_target_language})
		try {
			val server = com.sun.net.httpserver.HttpsServer.create()
			server.bind(java.net.InetSocketAddress(port), 0)
			//server.createContext(\"/\", ChunkedHandler(onMessage))
			server.start()
			onOpen.invoke()
			throw Exception(\"createHttpServerNative is not functional\")
			return server
		} catch (e: java.lang.Exception) {
			System.out.println(e)
			System.out.println(\"Failed to create HTTP server\")
			return null
		}
	} else {
		assert(false, { -> \"createHttpServerNative native is not providede for platform \" + flowc_target_language})
		return 0
	}
}
"),

Pair("closeHttpServerNative", \type_nm, var_nm -> "fun " + var_nm("closeHttpServerNative") + "(server: Any): Unit {
	(server as com.sun.net.httpserver.HttpServer).stop(0)
}
"),

Pair("makeHttpRequest", \type_nm, var_nm -> "fun " + var_nm("makeHttpRequest") + "(
	url: String, 
	post: Boolean,
	headers: ArrayList<ArrayList<String>>,
	params: ArrayList<ArrayList<String>>,
	onData: (String) -> Unit,
	onError: (String) -> Unit, 
	onStatus: (Int) -> Unit): Unit {
	assert(false, { -> \"makeHttpRequest native is not providede for platform \" + flowc_target_language})
}
"),

Pair("httpCustomRequestNative", \type_nm, var_nm -> "fun " + var_nm("httpCustomRequestNative") + "(
	url: String,
	method: String,
	headers: ArrayList<ArrayList<String>>,
	parameters: ArrayList<ArrayList<String>>,
	data: String,
	responseEncoding: String,
	onResponse: (Int, String, ArrayList<ArrayList<String>>) -> Unit,
	async: Boolean
) -> Unit {
	assert(false, { -> \"httpCustomRequestNative native is not providede for platform \" + flowc_target_language})
}
"),

Pair("print", \type_nm, var_nm -> "fun " + var_nm("print") + "(s: String): Unit {
	System.out.print(s)
	/*try{
		synchronized (System.out) {
			PrintStream out = new PrintStream(System.out, true, \"UTF-8\");
			out.print(s);
			out.flush();
		}
	} catch (e: UnsupportedEncodingException) {
		e.printStackTrace();
	}
	return null;*/
}
"),

Pair("readUntil", \type_nm, var_nm -> "fun " + var_nm("readUntil") + "(str_pattern: String): String {
	val pattern = str_pattern.getBytes()
	val line = ArrayList<Byte>()
	var pos = 0
		while (true) {
			val ch = System.in.read()
			line.add(ch.toByte())
			if (ch == pattern[pos]) {
				pos += 1
				if (pos == pattern.length) {
					return line.toString()
				}
			} else {
				pos = 0
			}
		}
}
"),

Pair("getFileContentBinary", \type_nm, var_nm -> "fun " + var_nm("getFileContentBinary") + "(name: String): String {
	try {
		val bytes = java.nio.file.Files.readAllBytes(java.nio.file.Paths.get(name))
		return bytes.toString(Charsets.ISO_8859_1)
	} catch (e: java.io.IOException) {
		return \"\"
	}
}
"),

Pair("setFileContentBytes", \type_nm, var_nm -> "fun " + var_nm("setFileContentBytes") + "(name: String, data: String): Boolean {
	java.io.Writer? writer = null;
	try {
		writer = java.io.BufferedWriter(java.io.OutputStreamWriter(
			java.io.FileOutputStream(name), Charsets.ISO_8859_1)
		);
		val chars = CharArray(data.length, {i -> data.codePointAt(i).toChar() })
		writer.write(chars);
	} catch (ex: java.io.IOException) {
	} finally {
		try {
			writer.close();
			return true;
		} catch (_: java.lang.Exception) {
		}
	}
	return false
}
"),

Pair("execSystemProcess", \type_nm, var_nm -> "fun " + var_nm("execSystemProcess") + "(command: String, args: ArrayList<String>, cwd: String, onOut: (String) -> Unit, onErr: (String) -> Unit): Int {
	val cmd = arrayOf(*arrayOf(command), *args.toTypedArray())
	val runner = ProcessStarter(cmd, cwd, onOut, onErr, {_ -> })
	runner.run()
	return runner.waitFor()
}
"),

Pair("startProcess", \type_nm, var_nm -> "fun " + var_nm("startProcess") + "(command: String, args: ArrayList<String>, cwd: String, stdin: string, onExit: (int, String, String) -> Unit): Unit {
	val cmd = arrayOf(*arrayOf(command), *args.toTypedArray())
	var stdout = ""
	var stderr = ""
	val runner = ProcessStarter(cmd, cwd, 
		{out -> stdout = stdout + out}, 
		{err -> stderr = stderr + err}, 
		{code -> onExit(code, stdout, stderr)}
	)
	flow_threadpool.submit(runner)
	runner.writeStdin(stdin)
}
"),

Pair("runSystemProcess", \type_nm, var_nm -> "fun " + var_nm("runSystemProcess") + "(command: String, args: ArrayList<String>, cwd: String, onOut: (String) -> Unit, onErr: (String) -> Unit, onExit: (Int) -> Unit): ProcessStarter {
	val cmd = arrayOf(*arrayOf(command), *args.toTypedArray())
	val runner = ProcessStarter(cmd, cwd, onOut, onErr, onExit)
	flow_threadpool.submit(runner)
	return runner
}
"),

Pair("writeProcessStdin", \type_nm, var_nm -> "fun " + var_nm("writeProcessStdin") + "(proc: Any, arg: String): Unit {
	(proc as ProcessStarter).writeStdin(arg);
}
"),

Pair("availableProcessors", \type_nm, var_nm -> "fun " + var_nm("availableProcessors") + "(): Int {
	return java.lang.Runtime.getRuntime().availableProcessors()
}
"),

Pair("setThreadPoolSize", \type_nm, var_nm -> "fun " + var_nm("setThreadPoolSize") + "(threads: Int): Unit {
	flow_threadpool = java.util.concurrent.Executors.newFixedThreadPool(threads);
}
"),

]);

