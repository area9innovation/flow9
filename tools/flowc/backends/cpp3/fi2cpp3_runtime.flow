import text/serialize;
import tools/flowc/backends/common;
import tools/flowc/backends/cpp3/fi2cpp3_util;
import tools/flowc/backends/cpp3/fi2cpp3_defines;

export {
	fiCpp3Runtime(gctx: Cpp3GlobalContext, runtime_parts: [CppRuntimePart]) -> string;
	fiCpp3IsNative(name : string, gctx: Cpp3GlobalContext) -> bool;
	fiCpp3InitNativeFuncs(cfg: FiCpp3Config) -> Tree<string, CppNative>;
	fiCpp3InitRuntimeParts(cfg: FiCpp3Config) -> Tree<string, CppRuntimePart>;
}

fiCpp3Runtime(gctx: Cpp3GlobalContext, runtime_parts: [CppRuntimePart]) -> string {
all_includes = set2array(fold(runtime_parts, makeSet(), \acc, part -> fold(part.include, acc, \ac, inc -> insertSet(ac, inc))));
includes = superglue(all_includes, \inc -> "#inc" + "lude " + inc, "\n");
(if (includes == "") "" else includes + "\n") +
"#include tools/flowc/backends/cpp3/flow_runtime.hpp" + "\n" +
"namespace flow {\n" +
"template<typename T>
T " + gctx.varname2cpp("for") + "(T v, Fun<Bool, T> p, Fun<T, T> fn) {
	while (p(v)) v = fn(v);
	return v;
}
" +
concatStrings(map(runtime_parts, \part -> "// Runtime part: " + part.name + "\n" + part.header + "\n\n")) +
"}\n";
}

fiCpp3IsNative(name : string, gctx: Cpp3GlobalContext) -> bool {
	name == "for" || containsKeyTree(gctx.natives, name);
}

fiCpp3InitRuntimeParts(cfg: FiCpp3Config) -> Tree<string, CppRuntimePart> {
	runtime_files = fold(cfg.nativeDirs, [], \acc, dir -> 
		fold(readDirectory(dir), acc, \ac, file ->
			if (!endsWith(file, ".cpp.runtime")) ac else {
				concat(ac, [pathCombine(dir, file)]);
			}
		)
	);
	fold(runtime_files, makeTree(), \acc, runtime_file ->
		if (!fileExists(runtime_file)) {
			fcPrintln("runtime parts file: " + runtime_file + " is not found", cfg.config.threadId);
			acc;
		} else {
			runtime_parts = deserialize(getFileContent(runtime_file), IllegalStruct());
			if (!isArray(runtime_parts)) {
				fcPrintln("runtime parts file: " + runtime_file + " has broken format", cfg.config.threadId);
				acc;
			} else {
				mergeTree(acc, values2tree(runtime_parts, \part -> part.name));
			}
		}
	);
}

cppNativePlain2CppNative(n: CppNativePlain) -> CppNative {
	CppNative(
		n.name,
		\type2cpp, var2cpp -> strApplyFns(n.def)([type2cpp, var2cpp]),
		if (n.inline == "") None() else Some(CppInline(
			\as -> strSubstituteArgs(n.inline)(as)
		)),
		n.include, n.depends
	);
}

fiCpp3InitNativeFuncs(cfg: FiCpp3Config) -> Tree<string, CppNative> {
	native_files = fold(cfg.nativeDirs, [], \acc, dir -> 
		fold(readDirectory(dir), acc, \ac, file ->
			if (!endsWith(file, ".cpp.natives")) ac else {
				concat(ac, [pathCombine(dir, file)]);
			}
		)
	);
	fold(native_files, makeTree(), \acc, natives_file ->
		if (!fileExists(natives_file)) {
			fcPrintln("runtime natives file: " + natives_file + " is not found", cfg.config.threadId);
			acc;
		} else {
			defs = deserialize(getFileContent(natives_file), IllegalStruct());
			if (!isArray(defs)) {
				fcPrintln("runtime natives file: " + natives_file + " has broken format", cfg.config.threadId);
				acc;
			} else {
				natives = map(defs, cppNativePlain2CppNative);
				mergeTree(acc, values2tree(natives, \nat -> nat.name));
			}
		}
	);
}
