import tools/flowc/backends/cpp3/fi2cpp3_runtime;
import tools/flowc/backends/cpp3/fi2cpp3_types;
import tools/flowc/statements/fs_tailcall;
import tools/flowc/statements/fs_module;

export {
	fiStructs2cpp3(structs : [FiTypeStruct], gctx: Cpp3GlobalContext) -> [Cpp3CompiledDeclaration];
}

fiStructs2cpp3(structs : [FiTypeStruct], gctx: Cpp3GlobalContext) -> [Cpp3CompiledDeclaration] {
	/*struct_decls = map(structs,
		\s -> Cpp3CompiledDeclaration(s.name, true, fiStructForward2cpp3(s, gctx), "")
	);
	ordered = fiOrderStructs(structs, fail);
	struct_defs = fold(ordered,
		Pair([], buildSet(map(structs, \s -> s.name))),
		\acc, s -> {
			decl = Cpp3CompiledDeclaration(s.name, true, fiStruct2cpp3(s, gctx, acc.second), "");
			Pair(arrayPush(acc.first, decl), removeSet(acc.second, s.name));
		}
	).first;
	concat(struct_decls, struct_defs);*/
	map(structs, \s ->
		Cpp3CompiledDeclaration(s.name, true,
			fiStructForward2cpp3(s, gctx),
			fiStructTraits2cpp3(s, gctx),
			fiStructDecl2cpp3(s, gctx), ""
		)
	);
}

fiOrderStructs(structs: [FiTypeStruct], err: (string) -> void) -> [FiTypeStruct] {
	fiDoOrderStructs(structs, [], \str ->
		err(str + "\nstructs: " + superglue(structs, \s -> s.name, ", "))
	);
}

fiStructDependencies(s: FiTypeStruct) -> [string] {
	set2array(fold(s.args, makeSet(), \acc, arg ->
		extractTypeNames(acc, arg.type)
	));
}

fiDoOrderStructs(left: [FiTypeStruct], ordered: [FiTypeStruct], err: (string) -> void) -> [FiTypeStruct] {
	if (length(left) == 0) ordered else {
		do_job = \ready -> {
			new_left = filter(left, \s1 -> forall(ready, \s2 -> s1.name != s2.name));
			new_ordered = concat(ordered, ready);
			fiDoOrderStructs(new_left, new_ordered, err);
		}
		ready = filter(left, \s1 -> forall(fiStructDependencies(s1), \n ->
			n == s1.name || forall(left, \s2 -> n != s2.name))
		);
		if (length(ready) == 0) {
			// Approximate the order by finding the struct with least number of dependencies
			least = fold(tail(left),
				Pair(left[0], buildSet(fiStructDependencies(left[0]))),
				\acc, x -> {
					deps = buildSet(fiStructDependencies(x));
					if (sizeSet(deps) >= sizeSet(acc.second)) acc else {
						Pair(x, deps);
					}
				}
			).first;
			do_job([least]);
		} else {
			do_job(ready);
		}
	}
}

fiStructTraits2cpp3(struct: FiTypeStruct, gctx: Cpp3GlobalContext) -> string {
	struct_name = gctx.config.namespace + "::" + fi2cpp3typename2cpp(struct.name);
	struct_id = eitherMap(lookupTree(gctx.structs2cpp, struct.name), \str -> i2s(str.id), "");
	if (length(struct.typars) == 0) {
		"template<> struct get_type_id<" + struct_name + "> { enum { result = " + struct_id + " }; };\n";
	} else {
		template_header = fiDeclTypars2cpp3(struct.typars, gctx);
		struct_typars = superglue(struct.typars, \tp -> switch (tp) {
				FiTypeParameter(__): fi2cpp3typar2cpp(tp);
				default: fail0("must be a type parameter, got: " + pretFiType(tp));
			}, 
			", "
		);
		struct_type = struct_name + "<" + struct_typars + ">";
		template_header + "struct get_type_id<" + struct_type + "> { enum { result = " + struct_id + " }; };\n";
	}
}

fiStructDecl2cpp3(struct: FiTypeStruct, gctx0: Cpp3GlobalContext) -> string {
	gctx = Cpp3GlobalContext(
		gctx0 with currentToplevel = Some(struct),
		toplevelTypars = fold(struct.typars, makeSet(), \acc, tp -> fiCollectTypars(tp, acc))
	);
	struct_name = fi2cpp3typename2cpp(struct.name);
	template_header = fiDeclTypars2cpp3(struct.typars, gctx);
	struct_id = eitherMap(lookupTree(gctx.structs2cpp, struct.name), \str -> i2s(str.id), "");
	str_params = concat([struct_id], map(struct.args, \arg -> fiType2cpp3(arg.type, gctx)));
	struct_type = "Str<" + strGlue(str_params, ", ") + ">";
	constructor = struct_name + "(" + 
		supergluei(struct.args, \i, arg -> fiType2cpp3(arg.type, gctx) + " a_" + i2s(i), ", ") + 
	"): " +
	struct_type + "(" +
		supergluei(struct.args, \i, arg -> "a_" + i2s(i), ", ") +
	") { }";
	template_header + "struct " + struct_name + ": public " + struct_type + " {\n" + 
		"\t" + constructor +
	"\n};\n";
}

fiStructForward2cpp3(struct: FiTypeStruct, gctx: Cpp3GlobalContext) -> string {
	struct_name = fi2cpp3typename2cpp(struct.name);
	template_header = fiDeclTypars2cpp3(struct.typars, gctx);
	template_header + "struct " + struct_name + ";\n";
}
