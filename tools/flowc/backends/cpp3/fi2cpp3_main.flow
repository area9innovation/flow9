import math/hash;
import tools/flowc/backends/common;
import tools/flowc/backends/cpp3/fi2cpp3_compile;

export {
	generateCpp3MainClass(gctx : Cpp3GlobalContext) -> void;
	generateCpp3SingletonStructs(gctx : Cpp3GlobalContext) -> void;
	generateCpp3Structs(gctx : Cpp3GlobalContext) -> void;
	generateCpp3Wrappers(gctx : Cpp3GlobalContext) -> void;
}

generateCpp3MainClass(gctx : Cpp3GlobalContext) -> void {
	main_file_text = gctx.header_generator(timestamp());
	pushstr = \s -> rlistPush(main_file_text, s);
	config = gctx.program.config;
	if (config.verbose > 0) {
		fcPrintln("Generating the main cpp3 module '" + gctx.config.flowfile + "'", config.threadId);
	}

	pushstr("@SuppressWarnings(\"unchecked\")\npublic final class " + gctx.config.flowfile + " extends FlowRuntime {\n");

	// Init hosts
	generateCpp3MainInitHosts(gctx, pushstr);

	// Init modules
	generateCpp3MainInitModules(gctx, pushstr);

	// General init function
	pushstr("\tprivate static final void init() {\n");
	pushstr("\t\tStructs.init();\n");
	pushstr("\t\tinit_hosts();\n");
	pushstr("\t\tinit_modules();\n");
	pushstr("\t}\n");

	generateCpp3MainFunction(gctx, pushstr);

	main_fname = pathCombine(gctx.config.namespace, gctx.config.flowfile + ".cpp3");
	writeCpp3Source(gctx, main_fname, javaList2String(main_file_text, "}\n"));
}

generateCpp3MainInitHosts(gctx : Cpp3GlobalContext, pushstr : (string) -> void) -> void {
	host_inits = list2array(foldTree(gctx.uses_host, makeList(), \host, v, acc -> {
		if (containsKeyTree(gctx.host_natives, host)) {
			Cons("\t\tFlowRuntime.registerNativeHost(" + host + ".class);\n", acc);
		} else {
			acc;
		}
	}));
	pushstr("\n\t// Init hosts: " + i2s(length(host_inits)) + "\n");
	if (length(host_inits) < 512) {
		pushstr("\tprivate static final void init_hosts() {\n");
		pushstr(concatStrings(host_inits));
		pushstr("\t}\n");
	} else {
		host_init_chuncks = splitByNumber(host_inits, 512);
		iteri(host_init_chuncks, \i, chunk -> {
			pushstr("\tprivate static final void init_hosts_" + i2s(i) + "() {\n");
			pushstr(concatStrings(chunk));
			pushstr("\t}\n");
		});
		pushstr("\tprivate static final void init_hosts() {\n");
		iteri(host_init_chuncks, \i, __ ->
			pushstr("\t\tinit_hosts_" + i2s(i) + "();\n")
		);
		pushstr("\t}\n");
	}
}

generateCpp3MainInitModules(gctx : Cpp3GlobalContext, pushstr : (string) -> void) -> void {
	config = gctx.program.config;
	init_code = list2array(^(gctx.init_code));
	pushstr("\n\t// Init modules: " + i2s(length(init_code)) + "\n");
	if (length(init_code) < 512) {
		pushstr("\tprivate static final void init_modules() {\n");
		pushstr(concatStrings(init_code));
		pushstr("\t}\n");
	} else {
		init_code_chuncks = splitByNumber(init_code, 512);
		iteri(init_code_chuncks, \i, chunk -> {
			pushstr("\tprivate static final void init_modules_" + i2s(i) + "() {\n");
			pushstr(concatStrings(chunk));
			pushstr("\t}\n");
		});
		pushstr("\tprivate static final void init_modules() {\n");
		iteri(init_code_chuncks, \i, __ ->
			pushstr("\t\tinit_modules_" + i2s(i) + "();\n")
		);
		pushstr("\t}\n");
		if (isConfigParameterTrue(config.config, "cpp3-main-size-stats")) {
			fcPrintln(gctx.config.flowfile + " init_modules chunks: " + i2s(length(init_code_chuncks)), config.threadId);
		}
	}
}
generateCpp3MainFunction(gctx : Cpp3GlobalContext, pushstr : (string) -> void) -> void {
	//if (isEmptySet(gctx.config.cpp3Library)) {
		// main function
		switch (lookupTree(gctx.globalFuncs, "main")) {
			Some(main): {
				// program entry point
				pushstr("\tpublic static void main(String[] args) {\n");
				// init program args
				pushstr("\t\tFlowRuntime.program_args = args;\n");
				// init all internal stuff
				pushstr("\t\t" + gctx.config.flowfile + ".init();\n");
				// run a compiled main function
				pushstr("\t\t" + "Module_" + main.csmodule.id + "." + main.name + "();\n");
				pushstr("\t}\n");
			}
			None(): {
				fail0("No main function");
			}
		}
	/*} else {
		iterSet(gctx.config.cpp3Library, \name ->
			switch (lookupTree(gctx.globalFuncs, name)) {
				Some(finfo): pushstr(cpp3InterfaceWrapper(name, gctx, finfo));
				None(): fail0("No function " + name);
			}
		);

		// program initialization
		pushstr("\tpublic static void init(String[] args) {\n");
		// init program args
		pushstr("\t\tFlowRuntime.program_args = args;\n");
		// init all internal stuff
		pushstr("\t\t" + gctx.config.flowfile + ".init();\n");
		pushstr("\t}\n");
	}*/
}

cpp3InterfaceWrapper(name : string, gctx : Cpp3GlobalContext, finfo : Cpp3GlobalInfo) -> string {
	switch (finfo.type) {
		FiTypeFunction(arg_types, ret_type): {
			arg_names = mapi(arg_types, \j, t -> type2cpp3ObjType(gctx, t.type, false, false, false) + " a" + i2s(j));
			arg_uses = mapi(arg_types, \j, t -> "a" + i2s(j));
			ret_typestr = type2cpp3ObjType(gctx, ret_type, false, false, false);
			"\tstatic public " + ret_typestr + " " + name + "(" + strGlue(arg_names, ", ") + ") {\n" +
			"\t\treturn " + gctx.config.flowfile + ".m_" + finfo.csmodule.id + "." + finfo.name + "(" + strGlue(arg_uses, ", ") + ")" + ";\n" +
			"\t}\n";
		}
		default: fail0(name + "must be a function");
	}
}

generateCpp3SingletonStructs(gctx : Cpp3GlobalContext) -> void {
	code = gctx.header_generator(timestamp());
	pushstr = \s -> rlistPush(code, s);
	config = gctx.program.config;

	pushstr("@SuppressWarnings(\"unchecked\")\npublic final class SingletonStructs {\n");

	pushstr("\n\t// Singleton structs\n");
	pushstr("\tstatic final Object[] arr_empty = new Object[0];\n");
	num_singleton_structs = foldTree(gctx.cstructs, 0, \sname, struct : Cpp3Struct, acc ->
		if (length(struct.fields) != 0) acc else {
			pushstr("\tstatic final SingletonStruct str_" + sname + " = SingletonStruct.make(" + i2s(struct.id) + ",\"" + sname + "\");\n");
			acc + 1
		}
	);
	if (isConfigParameterTrue(config.config, "cpp3-main-size-stats")) {
		fcPrintln("Singleton structs: " + i2s(num_singleton_structs), config.threadId);
	}
	fname = pathCombine(gctx.config.namespace, "SingletonStructs.cpp3");
	writeCpp3Source(gctx, fname, javaList2String(code, "}\n"));
}

generateCpp3Structs(gctx : Cpp3GlobalContext) -> void {
	code = gctx.header_generator(timestamp());
	pushstr = \s -> rlistPush(code, s);
	config = gctx.program.config;

	struct_list = foldTree(gctx.cstructs, [], \sname, sdata : Cpp3Struct,acc -> {
		if (length(sdata.fields) == 0) {
			arrayPush(acc, "\t\tSingletonStructs.str_" + sname);
		} else {
			arrayPush(acc, "\t\tnew Struct_" + sdata.cpp3Name + "()");
		}
	});
	if (isConfigParameterTrue(config.config, "cpp3-main-size-stats")) {
		fcPrintln("Structs: " + i2s(length(struct_list)), config.threadId);
	}
	pushstr("import cpp3.util.concurrent.ConcurrentHashMap;\n\n");
	pushstr("@SuppressWarnings(\"unchecked\")\npublic final class Structs {\n\n");
	pushstr("\t// Structs array\n");
	if (length(struct_list) < 512) {
		pushstr("\tstatic final private Struct[] struct_list = {\n");
		pushstr(strGlue(struct_list, ",\n") + "\n");
		pushstr("\t};\n");
		pushstr("\tpublic static final void init() {\n");
		pushstr("\t\tFlowRuntime.struct_prototypes = struct_list;\n");
	} else {
		pushstr("\tpublic static final void init() {\n");
		struct_list_chunks = splitByNumber(struct_list, 512);
		iteri(struct_list_chunks, \i, chunk -> generateCpp3StructsChunk(gctx, chunk, i));
		pushstr("\t\tFlowRuntime.struct_prototypes = new Struct[" + i2s(length(struct_list)) + "];\n");
		pushstr("\t\tint k = 0;\n");
		iteri(struct_list_chunks, \i, __ ->
			pushstr("\t\tfor (Struct s : Structs_" + i2s(i) +  ".structList()) FlowRuntime.struct_prototypes[k++] = s;\n")
		);
	}
	pushstr("\t\tfor (int i = 0; i < FlowRuntime.struct_prototypes.length; i++) {\n");
	pushstr("\t\t\tFlowRuntime.struct_ids.put(FlowRuntime.struct_prototypes[i].getTypeName(), i);\n");
	pushstr("\t\t}\n");
	pushstr("\t}\n");
	fname = pathCombine(gctx.config.namespace, "Structs.cpp3");
	writeCpp3Source(gctx, fname, javaList2String(code, "}\n"));
}

generateCpp3StructsChunk(gctx : Cpp3GlobalContext, chunk : [string], i : int) -> void {
	code = gctx.header_generator(timestamp());
	pushstr = \s -> rlistPush(code, s);
	pushstr("@SuppressWarnings(\"unchecked\")\npublic final class Structs_" + i2s(i) + " {\n");
	pushstr("\n\t// Structs array - " + i2s(i) + "th part \n");
	pushstr("\tstatic final private Struct[] struct_list = {\n");
	pushstr(strGlue(chunk, ",\n") + "\n");
	pushstr("\t};\n");
	pushstr("\tstatic final Struct[] structList() {\n");
	pushstr("\t\treturn struct_list;\n");
	pushstr("\t}\n");
	fname = pathCombine(gctx.config.namespace, "Structs_" + i2s(i) + ".cpp3");
	writeCpp3Source(gctx, fname, javaList2String(code, "}\n"));
}

generateCpp3Wrappers(gctx : Cpp3GlobalContext) -> void {
	code = gctx.header_generator(timestamp());
	pushstr = \s -> rlistPush(code, s);
	config = gctx.program.config;
	wrappers = list2array(^(gctx.wrapper_code));
	if (isConfigParameterTrue(config.config, "cpp3-main-size-stats")) {
		fcPrintln("Wrappers: " + i2s(length(wrappers)), config.threadId);
	}
	pushstr("@SuppressWarnings(\"unchecked\")\npublic final class Wrappers {\n\n");
	pushstr("\t// Functional wrappers for methods: " + i2s(length(wrappers)) + "\n");
	iter(wrappers, \wr -> pushstr("\tstatic " + wr.type + " " + wr.name + " = " + wr.code + ";\n"));
	fname = pathCombine(gctx.config.namespace, "Wrappers.cpp3");
	writeCpp3Source(gctx, fname, javaList2String(code, "}\n"));
}
