[
Cpp3RuntimePart("hash_map", 
"template<typename K, typename T>
struct FlowHashMap {
	struct Hash {
		Hash(Fun<Int, K>* h): hash(h) { }
		Int operator() (K k) const {
			incRc(k);
			return hash->callRc1(k);
		}
		Fun<Int, K>* hash;
	};
	struct Equal {
		bool operator() (K k1, K k2) const {
			incRc(k1);
			incRc(k2);
			return equalRc(k1, k2);
		}
		Fun<Int, K>* hash;
	};
	FlowHashMap(Int capacity, Fun<Int, K>* h):
		m(capacity, Hash(h)),
		hash(h) //,is_shared(false)
		{ }
	~FlowHashMap() {
		decRc(hash);
		for (auto p : m) {
			decRc(p.first);
			decRc(p.second);
		}
	}

	void makeShared() {
		if constexpr (ATOMIC_RC_SMART) {
			//if (!is_shared) {
				if constexpr (is_flow_ancestor_v<K>) {
					if constexpr (is_flow_ancestor_v<T>) {
						for (auto p: m) {
							p.first->makeShared();
							p.second->makeShared();
						}
					} else {
						for (auto p: m) {
							p.first->makeShared();
						}
					}
				} else {
					if constexpr (is_flow_ancestor_v<T>) {
						for (auto p: m) {
							p.second->makeShared();
						}
					} else {
						// nothing to do
					}
				}
				//is_shared = true;
			//}
		}
	}
	std::unordered_map<K, T, Hash, Equal> m;
	Fun<Int, K>* hash;
	//bool is_shared;
};\n",
"",
"", "", [Cpp3Std(["<unordered_map>"], [])], false
)
]