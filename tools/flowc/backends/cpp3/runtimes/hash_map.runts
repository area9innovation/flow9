[
Cpp3RuntimePart("hash_map", 
"template<typename K, typename T>
struct FlowHashMap {
	FlowHashMap(Int capacity, Fun<Int, K>* h):
		m(capacity, Hash<std::size_t, K>()),
		hash(h), is_shared(false) { }
	~FlowHashMap() {
		decRc(hash);
		for (auto p : m) {
			decRc(p.first);
			decRc(p.second);
		}
	}

	void makeShared() {
		if constexpr (ATOMIC_RC_SMART) {
			if (!is_shared) {
				hash->makeShared();
				if constexpr (is_flow_ancestor_v<K>) {
					if constexpr (is_flow_ancestor_v<T>) {
						for (auto p: m) {
							p.first->makeShared();
							p.second->makeShared();
						}
					} else {
						for (auto p: m) {
							p.first->makeShared();
						}
					}
				} else {
					if constexpr (is_flow_ancestor_v<T>) {
						for (auto p: m) {
							p.second->makeShared();
						}
					} else {
						// nothing to do
					}
				}
				is_shared = true;
			}
		}
	}
	std::unordered_map<K, T, Hash<std::size_t, K>, Equal<K>> m;
	Fun<Int, K>* hash;
	bool is_shared;
};\n",
"",
"", "", [Cpp3Std(["<unordered_map>"], [])], false
)
]