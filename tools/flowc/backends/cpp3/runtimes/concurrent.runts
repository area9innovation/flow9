[

Cpp3RuntimePart("concurrent", 
"
extern QThreadPool thread_pool;
extern std::unordered_map<const Flow*, std::mutex> mutex_map;

/*
template<typename R, typename... As>
struct SyncFun : public Fun<R, As...> {
	SyncFun(): Fun<R, As...>() {}
	SyncFun(Fun<R, As...>::Fn&& f): Fun<R, As...>(std::move(f)) { }
	SyncFun(const Fun<R, As...>::Fn& f): Fun<R, As...>(f) { }
	SyncFun(const Fun<R, As...>::Fn1& f): Fun<R, As...>(f) { }
	template<typename... Cs>
	SyncFun(Fun<R, As...>::Fn&& f, Cs... cl): Fun<R, As...>(std::move(f), std::move(cl)...) { }
	SyncFun(const SyncFun& f): Fun<R, As...>(f) { }
	SyncFun(SyncFun&& f): Fun<R, As...>(std::move(f)) { }

	SyncFun& operator = (SyncFun&& r) = delete;
	SyncFun& operator = (const SyncFun& r) = delete;
	R call(As... as) override {
		std::lock_guard<std::mutex> lock(mx);
		return Fun<R, As...>::call(as...);
	}
private:
	std::mutex mx;
};
*/

",
"
QThreadPool thread_pool;
std::unordered_map<const Flow*, std::mutex> mutex_map;
",
"thread_pool.setMaxThreadCount(std::thread::hardware_concurrency());", "",
[Cpp3Qt(["<QtConcurrent>"], []), Cpp3Std(["<thread>", "<unordered_map>", "<mutex>"], [])], false
)

]