[

Cpp3RuntimePart("concurrent", 
"extern QThreadPool thread_pool;",
"QThreadPool thread_pool;",
"thread_pool.setMaxThreadCount(std::thread::hardware_concurrency());", "",
[Cpp3Qt(["<QtConcurrent>"], []), Cpp3Std(["<thread>"], [])], false
),

Cpp3RuntimePart("synchronized", 
"struct FlowWithMutex {
	FlowWithMutex(Flow v): value(v) { }
	Flow value;
	std::mutex m;
};
template<typename R, typename... As> 
struct SyncFunction : public Function<R, As...> {
	SyncFunction(Flow lock, Function<R, As...>&& f): 
		Function<R, As...>(f), 
		mv(lock.toNative<FlowWithMutex>()) { }
	SyncFunction(Flow lock, const Function<R, As...>& f): 
		Function<R, As...>(f),
		mv(lock.toNative<FlowWithMutex>()) { }

	SyncFunction(const SyncFunction& f): Function<R, As...>(f), mv(f.mv) { }
	SyncFunction(SyncFunction&& f): Function<R, As...>(f), mv(std::move(f.mv)) { }

	R call(As... as) const override { 
		const std::lock_guard<std::mutex> lock(mv->m);
		return Function<R, As...>::call(as...); 
	}
	mutable Ptr<FlowWithMutex> mv;
};
", "", "", "",
[Cpp3Std(["<mutex>"], [])], false
)


]