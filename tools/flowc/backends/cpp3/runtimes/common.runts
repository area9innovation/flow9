[

Cpp3RuntimePart("command_args", 
"
struct CommandArgs {
	static void init(int argc, const char* argv[]);
	static std::map<string, string> args;
};
",
"
std::map<string, string> CommandArgs::args;
void CommandArgs::init(int argc, const char* argv[]) {
	for (int i = 1; i < argc; ++ i) { 
		std::string arg(argv[i]);
		std::size_t eq_ind = arg.find(\"=\");
		if (eq_ind == std::string::npos) {
			CommandArgs::args[fromStdString(arg)] = fromStdString(\"\");
		} else {
			std::string key = arg.substr(0, eq_ind);
			std::string val = arg.substr(eq_ind + 1, arg.size() - eq_ind - 1);
			CommandArgs::args[fromStdString(key)] = fromStdString(val);
		}
	}
}
",
"CommandArgs::init(argc, argv);", "",
[Cpp3Std(["<map>"], [])]
),

Cpp3RuntimePart("date_time_format", 
"const std::string date_time_format(\"%Y-%m-%d %H:%M:%S\");",
"", "", "", []),

Cpp3RuntimePart("void_value", 
"struct RuntimeVoid { };
const Flow void_value(std::make_shared<RuntimeVoid>());
","", "", "", []),

Cpp3RuntimePart("to_binary", 
"
inline Void writeCharValue(Int c, std::vector<char16_t>& os) {
	os.push_back(c & 0xffff);
}
inline Void writeBinaryInt32(Int value, std::vector<char16_t>& os) {
	IntOrChars i(value);
	writeCharValue(i.chars.c0, os);
	writeCharValue(i.chars.c1, os);
}
inline Void writeIntValue(Int value, std::vector<char16_t>& os) {
	if ((value & 0xFFFF8000) != 0) {
		writeCharValue(0xFFF5, os);
		writeBinaryInt32(value, os);
	} else {
		writeCharValue(value, os);
	}
}
inline Void writeBooleanValue(Bool value, std::vector<char16_t>& os) {
	writeCharValue(value ? 0xFFFE : 0xFFFD, os);
}
inline Void writeDoubleValue(Double value, std::vector<char16_t>& os) {
	writeCharValue(0xFFFC, os);
	DoubleOrChars d(value);
	writeCharValue(d.chars.c0, os);
	writeCharValue(d.chars.c1, os);
	writeCharValue(d.chars.c2, os);
	writeCharValue(d.chars.c3, os);
}
inline Void writeStringValue(String value, std::vector<char16_t>& os) {
	Int str_len = value->size();
	if (str_len > 65535) {
		writeCharValue(0xFFFB, os);
		writeBinaryInt32(str_len, os);
	} else {
		writeCharValue(0xFFFA, os);
		writeCharValue(str_len, os);
	}
	for (auto c : *value) {
		writeCharValue(c, os);
	}
}
inline Void writeBinaryValue(Flow value, std::vector<char16_t>& os, std::unordered_map<string, Int>& structIdxs, std::vector<Ptr<AStruct>>& structDefs) {
	switch (value.type()) {
		case Type::STRING: {
			writeStringValue(std::get<String>(value.val), os);
			break;
		}
		case Type::DOUBLE: {
			writeDoubleValue(std::get<Double>(value.val), os);
			break;
		}
		case Type::INT: {
			writeIntValue(std::get<Int>(value.val), os);
			break;
		}
		case Type::BOOL: {
			writeBooleanValue(std::get<Bool>(value.val), os);
			break;
		}
		case Type::STRUCT: {
			Ptr<AStruct> s = std::get<Ptr<AStruct>>(value.val);
			String struct_id = s->name();
			if (structIdxs.find(*struct_id) == structIdxs.end()) {
				structIdxs[*struct_id] = structDefs.size();
				structDefs.push_back(s);
			}
			Int struct_idx = structIdxs.at(*struct_id);
			writeCharValue(0xFFF4, os);
			writeCharValue(struct_idx, os);
			Arr<Flow> fields = s->fields();
			for (Flow w : fields->vect)  {
				writeBinaryValue(w, os, structIdxs, structDefs);
			}
			break;
		}
		case Type::ARRAY: {
			Ptr<AArray> a = std::get<Ptr<AArray>>(value.val);
			Int l = a->size();
			if (l == 0) {
				writeCharValue(0xFFF7, os);
			} else {
				if (l > 65535) {
					writeCharValue(0xFFF9, os);
					writeBinaryInt32(l, os);
				} else {
					writeCharValue(0xFFF8, os);
					writeCharValue(l, os);
				}
				Arr<Flow> elements = a->elements();
				for (Flow v : elements->vect) {
					writeBinaryValue(v, os, structIdxs, structDefs);
				}
			}
			break;
		}
		default: {
			std::cerr << \"Not implemented: toBinary of \";
			flow2string(value, std::cerr, false); 
			std::cerr << std::endl;
			break;
		}
	}
}
",
"", "", "",
[Cpp3Std(["<unordered_map>"], [])]
)

]