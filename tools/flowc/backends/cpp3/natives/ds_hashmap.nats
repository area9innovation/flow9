[

Cpp3NativePlain("makeNativeHashMap", true,
"template<typename K, typename T> Flow $F_1(makeNativeHashMap)(Fun<Int, K>* hash, Int capacity, Double load, Arr<$F_0(Pair)<K, T>> dummy);\n",
"template<typename K, typename T>
Native* $F_1(makeNativeHashMap)(Fun<Int, K>* hash, Int capacity, Double load, Arr<$F_0(Pair)<K, T>>* dummy) {
	FlowHashMap<K, T>* m = new FlowHashMap<K, T>(capacity, hash->fn);
	m->max_load_factor(static_cast<float>(load));
	return new Native(m, [](void* x) { delete static_cast<new FlowHashMap<K, T>*>(x); } );
}\n", "", [Cpp3Std(["<unordered_map>"], [])], ["hash_map"]),

Cpp3NativePlain("setNativeHashMap", true,
"template<typename K, typename T> Void $F_1(setNativeHashMap)(Native* m, Traits<K>::RVal key, Traits<T>::RVal val);\n",
"template<typename K, typename T>
Void $F_1(setNativeHashMap)(Native* m, Traits<K>::RVal key, Traits<T>::RVal val) {
	m.cast<FlowHashMap<K, T>>()->insert_or_assign(key, val);
}\n", "", [Cpp3Std(["<unordered_map>"], [])], ["hash_map"]),

Cpp3NativePlain("getNativeHashMap", true,
"template<typename K, typename T> Traits<T>::RVal $F_1(getNativeHashMap)(Native* m, Traits<K>::RVal key, Arr<$F_0(Pair)<K, T>>* dummy);\n",
"template<typename K, typename T>
$F_0(Some)<Traits<T>::RVal>* $F_1(getNativeHashMap)(Native* m, Traits<K>::RVal key, Arr<$F_0(Pair)<K, T>>* dummy) {
	FlowHashMap<K, T>* map = m->cast<FlowHashMap<K, T>>();
	if (map->contains(key)) {
		Traits<T>::RVal ret = map->at(key);
		return new $F_0(Some)<Traits<T>::RVal>>(ret);
	} else {
		return new $F_0(None)<Traits<T>::RVal>>();
	}
}\n", "", [Cpp3Std(["<unordered_map>"], [])], ["hash_map"]),

Cpp3NativePlain("removeNativeHashMap", true,
"template<typename K, typename T> Void $F_1(removeNativeHashMap)(Native* m, Traits<K>::RVal key, Arr<$F_0(Pair)<K, T>>* dummy);\n",
"template<typename K, typename T>
Void $F_1(removeNativeHashMap)(Native* m, Traits<K>::RVal key, Arr<$F_0(Pair)<K, T>>* dummy) {
	m->cast<FlowHashMap<K, T>>()->erase(key);
}\n", "", [Cpp3Std(["<unordered_map>"], [])], ["hash_map"]),

Cpp3NativePlain("containsNativeHashMap", true,
"template<typename K, typename T> Bool $F_1(containsNativeHashMap)(Native* m, Traits<K>::RVal key, Arr<$F_0(Pair)<K, T>>* dummy);\n",
"template<typename K, typename T>
Bool $F_1(containsNativeHashMap)(Native* m, Traits<K>::RVal key, Arr<$F_0(Pair)<K, T>>* dummy) {
	return m->cast<FlowHashMap<K, T>>()->contains(key);
}\n", "", [Cpp3Std(["<unordered_map>"], [])], ["hash_map"]),

Cpp3NativePlain("sizeNativeHashMap", true,
"template<typename K, typename T> Int $F_1(sizeNativeHashMap)(Native* m, Arr<$F_0(Pair)<K, T>>* dummy);\n",
"template<typename K, typename T>
Int $F_1(sizeNativeHashMap)(Native* m, Arr<$F_0(Pair)<K, T>>* dummy) {
	return m->cast<FlowHashMap<K, T>>()->size();
}\n", "", [Cpp3Std(["<unordered_map>"], [])], ["hash_map"]),

Cpp3NativePlain("clearNativeHashMap", true,
"template<typename K, typename T> Void $F_1(clearNativeHashMap)(Native* m, Arr<$F_0(Pair)<K, T>>* dummy);\n",
"template<typename K, typename T>
Void $F_1(clearNativeHashMap)(Native* m, Arr<$F_0(Pair)<K, T>>* dummy) {
	m->cast<FlowHashMap<K, T>>()->clear();
}\n", "", [Cpp3Std(["<unordered_map>"], [])], ["hash_map"]),

Cpp3NativePlain("cloneNativeHashMap", true,
"template<typename K, typename T> Native* $F_1(cloneNativeHashMap)(Native* m, Arr<$F_0(Pair)<K, T>>* dummy);\n",
"template<typename K, typename T>
Native* $F_1(cloneNativeHashMap)(Native* m, Arr<$F_0(Pair)<K, T>>* dummy) {
	return new FlowHashMap<K, T>(m->cast<FlowHashMap<K, T>>());
}\n", "", [Cpp3Std(["<unordered_map>"], [])], ["hash_map"]),

Cpp3NativePlain("iterNativeHashMap", true,
"template<typename K, typename T> Void $F_1(iterNativeHashMap)(Native* m, Fun<Void, K, T>* fn, Arr<$F_0(Pair)<K, T>>* dummy);\n",
"template<typename K, typename T>
Void $F_1(iterNativeHashMap)(Native* m, Fun<Void, K, T>* fn, Arr<$F_0(Pair)<K, T>>* dummy) {
	for (auto p : m->cast<FlowHashMap<K, T>>()) {
		fn->cast(p.first, p.second);
	}
}\n", "", [Cpp3Std(["<unordered_map>"], [])], ["hash_map"]),

Cpp3NativePlain("funcNativeHashMap", true,
"template<typename K, typename T> Fun<Int, K>* $F_1(funcNativeHashMap)(Native* m, Arr<$F_0(Pair)<K, T>>* dummy);\n",
"template<typename K, typename T>
Fun<Int, K>* $F_1(funcNativeHashMap)(Native* m, Arr<$F_0(Pair)<K, T>>* dummy) {
	return new Fun<Int, K>(m->cast<FlowHashMap<K, T>>()->hash_function());
}\n", "", [Cpp3Std(["<unordered_map>"], [])], ["hash_map"])

]