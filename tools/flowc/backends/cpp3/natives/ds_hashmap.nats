[

Cpp3NativePlain("makeNativeHashMap", true,
"template<typename K, typename T> Native* $F_1(makeNativeHashMap)(Fun<Int, K>* hash, Int capacity, Double load, Vec<$F_0(Pair)<K, T>*>* dummy);\n",
"template<typename K, typename T>
Native* $F_1(makeNativeHashMap)(Fun<Int, K>* hash, Int capacity, Double load, Vec<$F_0(Pair)<K, T>*>* dummy) {
	decRc(dummy);
	FlowHashMap<K, T>* map = new FlowHashMap<K, T>(capacity, hash);
	map->m.max_load_factor(static_cast<float>(load));
	return Native::make(map);
}\n", "", [Cpp3Std(["<unordered_map>"], [])], ["hash_map"]),

Cpp3NativePlain("setNativeHashMap", true,
"template<typename K, typename T> Void $F_1(setNativeHashMap)(Native* m, K key, T val);\n",
"template<typename K, typename T>
Void $F_1(setNativeHashMap)(Native* m, K key, T val) {
	FlowHashMap<K, T>* map = m->get<FlowHashMap<K, T>*>();
	auto p = map->m.find(key);
	if (p != map->m.end()) {
		decRc(p->second);
		map->m.insert_or_assign(key, val);
		decRc(key);
	} else {
		map->m.insert_or_assign(key, val);
	}
	decRc(m);
	return void_value;
}\n", "", [Cpp3Std(["<unordered_map>"], [])], ["hash_map"]),

Cpp3NativePlain("getNativeHashMap", true,
"template<typename K, typename T> Union* $F_1(getNativeHashMap)(Native* m, K key, Vec<$F_0(Pair)<K, T>*>* dummy);\n",
"template<typename K, typename T>
Union* $F_1(getNativeHashMap)(Native* m, K key, Vec<$F_0(Pair)<K, T>*>* dummy) {
	decRc(dummy);
	FlowHashMap<K, T>* map = m->get<FlowHashMap<K, T>*>();
	auto p = map->m.find(key);
	decRc(key);
	if (p != map->m.end()) {
		incRc(p->second);
		Union* ret = $F_0(Some)<T>::template make<$F_0(Some)<T>*>(p->second);
		decRc(m);
		return ret;
	} else {
		decRc(m);
		return $F_0(None)::template make<$F_0(None)*>();
	}
}\n", "", [Cpp3Std(["<unordered_map>"], [])], ["hash_map"]),

Cpp3NativePlain("removeNativeHashMap", true,
"template<typename K, typename T> Void $F_1(removeNativeHashMap)(Native* m, K key, Vec<$F_0(Pair)<K, T>*>* dummy);\n",
"template<typename K, typename T>
Void $F_1(removeNativeHashMap)(Native* m, K key, Vec<$F_0(Pair)<K, T>*>* dummy) {
	decRc(dummy);
	FlowHashMap<K, T>* map = m->get<FlowHashMap<K, T>*>();
	auto p = map->m.find(key);
	if (p != map->m.end()) {
		decRc(p->first);
		decRc(p->second);
		map->m.erase(p);
	}
	decRc(key);
	decRc(m);
	return void_value;
}\n", "", [Cpp3Std(["<unordered_map>"], [])], ["hash_map"]),

Cpp3NativePlain("containsNativeHashMap", true,
"template<typename K, typename T> Bool $F_1(containsNativeHashMap)(Native* m, K key, Vec<$F_0(Pair)<K, T>*>* dummy);\n",
"template<typename K, typename T>
Bool $F_1(containsNativeHashMap)(Native* m, K key, Vec<$F_0(Pair)<K, T>*>* dummy) {
	decRc(dummy);
	Bool ret = m->get<FlowHashMap<K, T>*>()->m.contains(key);
	decRc(m);
	decRc(key);
	return ret;
}\n", "", [Cpp3Std(["<unordered_map>"], [])], ["hash_map"]),

Cpp3NativePlain("sizeNativeHashMap", true,
"template<typename K, typename T> Int $F_1(sizeNativeHashMap)(Native* m, Vec<$F_0(Pair)<K, T>*>* dummy);\n",
"template<typename K, typename T>
Int $F_1(sizeNativeHashMap)(Native* m, Vec<$F_0(Pair)<K, T>*>* dummy) {
	decRc(dummy);
	Int ret = m->get<FlowHashMap<K, T>*>()->m.size();
	decRc(m);
	return ret;
}\n", "", [Cpp3Std(["<unordered_map>"], [])], ["hash_map"]),

Cpp3NativePlain("clearNativeHashMap", true,
"template<typename K, typename T> Void $F_1(clearNativeHashMap)(Native* m, Vec<$F_0(Pair)<K, T>*>* dummy);\n",
"template<typename K, typename T>
Void $F_1(clearNativeHashMap)(Native* m, Vec<$F_0(Pair)<K, T>*>* dummy) {
	decRc(dummy);
	FlowHashMap<K, T>* map = m->get<FlowHashMap<K, T>*>();
	for (auto p : map->m) {
		decRc(p.first);
		decRc(p.second);
	}
	map->m.clear();
	decRc(m);
	return void_value;
}\n", "", [Cpp3Std(["<unordered_map>"], [])], ["hash_map"]),

Cpp3NativePlain("cloneNativeHashMap", true,
"template<typename K, typename T> Native* $F_1(cloneNativeHashMap)(Native* m, Vec<$F_0(Pair)<K, T>*>* dummy);\n",
"template<typename K, typename T>
Native* $F_1(cloneNativeHashMap)(Native* m, Vec<$F_0(Pair)<K, T>*>* dummy) {
	decRc(dummy);
	FlowHashMap<K, T>* map = m->get<FlowHashMap<K, T>*>();
	incRc(map->hash);
	FlowHashMap<K, T>* clone = new FlowHashMap<K, T>(map->m.size(), map->hash);
	for (auto p : map->m) {
		clone->m[p.first] = p.second;
		incRc(p.first);
		incRc(p.second);
	}
	decRc(m);
	return Native::make(clone);
}\n", "", [Cpp3Std(["<unordered_map>"], [])], ["hash_map"]),

Cpp3NativePlain("iterNativeHashMap", true,
"template<typename K, typename T> Void $F_1(iterNativeHashMap)(Native* m, Fun<Void, K, T>* fn, Vec<$F_0(Pair)<K, T>*>* dummy);\n",
"template<typename K, typename T>
Void $F_1(iterNativeHashMap)(Native* m, Fun<Void, K, T>* fn, Vec<$F_0(Pair)<K, T>*>* dummy) {
	decRc(dummy);
	FlowHashMap<K, T>* map = m->get<FlowHashMap<K, T>*>();
	for (auto p : map->m) {
		incRc(p.first);
		incRc(p.second);
		fn->callRc1(p.first, p.second);
	}
	decRc(m);
	decRc(fn);
	return void_value;
}\n", "", [Cpp3Std(["<unordered_map>"], [])], ["hash_map"]),

Cpp3NativePlain("funcNativeHashMap", true,
"template<typename K, typename T> Fun<Int, K>* $F_1(funcNativeHashMap)(Native* m, Vec<$F_0(Pair)<K, T>*>* dummy);\n",
"template<typename K, typename T>
Fun<Int, K>* $F_1(funcNativeHashMap)(Native* m, Vec<$F_0(Pair)<K, T>*>* dummy) {
	decRc(dummy);
	FlowHashMap<K, T>* map = m->get<FlowHashMap<K, T>*>();
	Fun<Int, K>* ret = map->hash;
	decRc(m);
	return ret;
}\n", "", [Cpp3Std(["<unordered_map>"], [])], ["hash_map"])

]