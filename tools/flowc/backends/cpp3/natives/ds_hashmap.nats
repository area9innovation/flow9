[

Cpp3NativePlain("makeNativeHashMap", true,
"template<typename K, typename T> Native $F_1(makeNativeHashMap)(Fun<Int, K> hash, Int capacity, Double load, Vec<Str<$F_0(Pair)<K, T>>> dummy);\n",
"template<typename K, typename T>
Native $F_1(makeNativeHashMap)(Fun<Int, K> hash, Int capacity, Double load, Vec<Str<$F_0(Pair)<K, T>>> dummy) {
	dummy->decRC();
	FlowHashMap<K, T>* m = new FlowHashMap<K, T>(capacity, *hash);
	hash->decRC();
	m->max_load_factor(static_cast<float>(load));
	return Native::make(m, [](void* x) { delete static_cast<FlowHashMap<K, T>*>(x); } );
}\n", "", [Cpp3Std(["<unordered_map>"], [])], ["hash_map"]),

Cpp3NativePlain("setNativeHashMap", true,
"template<typename K, typename T> Void $F_1(setNativeHashMap)(Native m, K key, T val);\n",
"template<typename K, typename T>
Void $F_1(setNativeHashMap)(Native m, K key, T val) {
	RefCount<K>::inc(key);
	RefCount<T>::inc(val);
	m->cast<FlowHashMap<K, T>>()->insert_or_assign(key, val);
	m->decRC();
	return void_value;
}\n", "", [Cpp3Std(["<unordered_map>"], [])], ["hash_map"]),

Cpp3NativePlain("getNativeHashMap", true,
"template<typename K, typename T> Union<$F_2(Some), $F_2(None)> $F_1(getNativeHashMap)(Native m, K key, Vec<Str<$F_0(Pair)<K, T>>> dummy);\n",
"template<typename K, typename T>
Union<$F_2(Some), $F_2(None)> $F_1(getNativeHashMap)(Native m, K key, Vec<Str<$F_0(Pair)<K, T>>> dummy) {
	dummy->decRC();
	FlowHashMap<K, T>* map = m->cast<FlowHashMap<K, T>>();
	if (map->contains(key)) {
		T ret = map->at(key);
		RefCount<K>::keep(key);
		m->decRC();
		return Str<$F_0(Some)<T>>::make(ret);
	} else {
		RefCount<K>::keep(key);
		m->decRC();
		return Str<$F_0(None)<T>>::make();
	}
}\n", "", [Cpp3Std(["<unordered_map>"], [])], ["hash_map"]),

Cpp3NativePlain("removeNativeHashMap", true,
"template<typename K, typename T> Void $F_1(removeNativeHashMap)(Native m, K key, Vec<Str<$F_0(Pair)<K, T>>> dummy);\n",
"template<typename K, typename T>
Void $F_1(removeNativeHashMap)(Native m, K key, Vec<Str<$F_0(Pair)<K, T>>> dummy) {
	dummy->decRC();
	if (map->contains(key)) {
		T val = map->at(key);
		m->cast<FlowHashMap<K, T>>()->erase(key);
		RefCount<K>::dec(key);
		RefCount<T>::dec(val);
		m->decRC();
	} else {
		RefCount<K>::keep(key);
		m->decRC();
	}
	return void_value;
}\n", "", [Cpp3Std(["<unordered_map>"], [])], ["hash_map"]),

Cpp3NativePlain("containsNativeHashMap", true,
"template<typename K, typename T> Bool $F_1(containsNativeHashMap)(Native m, K key, Vec<Str<$F_0(Pair)<K, T>>> dummy);\n",
"template<typename K, typename T>
Bool $F_1(containsNativeHashMap)(Native m, K key, Vec<Str<$F_0(Pair)<K, T>>> dummy) {
	dummy->decRC();
	Bool ret = m->cast<FlowHashMap<K, T>>()->contains(key);
	m->decRC();
	RefCount<K>::check(key);
	return ret;
}\n", "", [Cpp3Std(["<unordered_map>"], [])], ["hash_map"]),

Cpp3NativePlain("sizeNativeHashMap", true,
"template<typename K, typename T> Int $F_1(sizeNativeHashMap)(Native m, Vec<Str<$F_0(Pair)<K, T>>> dummy);\n",
"template<typename K, typename T>
Int $F_1(sizeNativeHashMap)(Native m, Vec<Str<$F_0(Pair)<K, T>>> dummy) {
	dummy->decRC();
	Int ret = m->cast<FlowHashMap<K, T>>()->size();
	m->decRC();
	return ret;
}\n", "", [Cpp3Std(["<unordered_map>"], [])], ["hash_map"]),

Cpp3NativePlain("clearNativeHashMap", true,
"template<typename K, typename T> Void $F_1(clearNativeHashMap)(Native m, Vec<Str<$F_0(Pair)<K, T>>> dummy);\n",
"template<typename K, typename T>
Void $F_1(clearNativeHashMap)(Native m, Vec<Str<$F_0(Pair)<K, T>>> dummy) {
	dummy->decRC();
	for (auto p : *(m->cast<FlowHashMap<K, T>>())) {
		RefCount<K>::dec(p.first);
		RefCount<T>::dec(p.second);
	}
	m->cast<FlowHashMap<K, T>>()->clear();
	m->decRC();
	return void_value;
}\n", "", [Cpp3Std(["<unordered_map>"], [])], ["hash_map"]),

Cpp3NativePlain("cloneNativeHashMap", true,
"template<typename K, typename T> Native $F_1(cloneNativeHashMap)(Native m, Vec<Str<$F_0(Pair)<K, T>>> dummy);\n",
"template<typename K, typename T>
Native $F_1(cloneNativeHashMap)(Native m, Vec<Str<$F_0(Pair)<K, T>>> dummy) {
	dummy->decRC();
	FlowHashMap<K, T>* clone = new FlowHashMap<K, T>(*m->cast<FlowHashMap<K, T>>());
	Native ret = Native::make(clone, [](void* x) { delete static_cast<FlowHashMap<K, T>*>(x); } );
	if (m->refs > 0) {
		// m was not deleted - so increment all refs to pairs in m
		for (auto p : *clone) {
			RefCount<K>::inc(p.first);
			RefCount<T>::inc(p.second);
		}
	}
	m->decRC();
	return ret;
}\n", "", [Cpp3Std(["<unordered_map>"], [])], ["hash_map"]),

Cpp3NativePlain("iterNativeHashMap", true,
"template<typename K, typename T> Void $F_1(iterNativeHashMap)(Native m, Fun<Void, K, T> fn, Vec<Str<$F_0(Pair)<K, T>>> dummy);\n",
"template<typename K, typename T>
Void $F_1(iterNativeHashMap)(Native m, Fun<Void, K, T> fn, Vec<Str<$F_0(Pair)<K, T>>> dummy) {
	dummy->decRC();
	for (auto p : *(m->cast<FlowHashMap<K, T>>())) {
		fn->call(p.first, p.second);
	}
	m->decRC();
	fn-decRC();
	return void_value;
}\n", "", [Cpp3Std(["<unordered_map>"], [])], ["hash_map"]),

Cpp3NativePlain("funcNativeHashMap", true,
"template<typename K, typename T> Fun<Int, K> $F_1(funcNativeHashMap)(Native m, Vec<Str<$F_0(Pair)<K, T>>> dummy);\n",
"template<typename K, typename T>
Fun<Int, K> $F_1(funcNativeHashMap)(Native m, Vec<Str<$F_0(Pair)<K, T>>> dummy) {
	Fun<Int, K> ret = new Fun<Int, K>(m->cast<FlowHashMap<K, T>>()->hash_function());
	m->decRC();
	return ret;
}\n", "", [Cpp3Std(["<unordered_map>"], [])], ["hash_map"])

]