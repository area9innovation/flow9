[

Cpp3NativePlain("makeNativeHashMap", true,
"template<typename K, typename T> Flow $F_1(makeNativeHashMap)(Fun<Int, K> hash, Int capacity, Double load, Vec<$F_0(Pair)<K, T>> dummy);\n",
"template<typename K, typename T>
Native $F_1(makeNativeHashMap)(Fun<Int, K> hash, Int capacity, Double load, Vec<$F_0(Pair)<K, T>> dummy) {
	FlowHashMap<K, T>* m = new FlowHashMap<K, T>(capacity, hash->fn);
	m->max_load_factor(static_cast<float>(load));
	return Native::make(m, [](void* x) { delete static_cast<new FlowHashMap<K, T>*>(x); } );
}\n", "", [Cpp3Std(["<unordered_map>"], [])], ["hash_map"]),

Cpp3NativePlain("setNativeHashMap", true,
"template<typename K, typename T> Void $F_1(setNativeHashMap)(Native m, K key, T val);\n",
"template<typename K, typename T>
Void $F_1(setNativeHashMap)(Native m, K key, T val) {
	m->cast<FlowHashMap<K, T>>()->insert_or_assign(key, val);
}\n", "", [Cpp3Std(["<unordered_map>"], [])], ["hash_map"]),

Cpp3NativePlain("getNativeHashMap", true,
"template<typename K, typename T> Union $F_1(getNativeHashMap)(Native m, K key, Vec<$F_0(Pair)<K, T>> dummy);\n",
"template<typename K, typename T>
Union $F_1(getNativeHashMap)(Native m, K key, Vec<$F_0(Pair)<K, T>> dummy) {
	FlowHashMap<K, T>* map = m->cast<FlowHashMap<K, T>>();
	if (map->contains(key)) {
		T ret = map->at(key);
		return Str<$F_0(Some)<T>>::make(ret);
	} else {
		return Str<$F_0(None)<T>>::make();
	}
}\n", "", [Cpp3Std(["<unordered_map>"], [])], ["hash_map"]),

Cpp3NativePlain("removeNativeHashMap", true,
"template<typename K, typename T> Void $F_1(removeNativeHashMap)(Native m, K key, Vec<$F_0(Pair)<K, T>> dummy);\n",
"template<typename K, typename T>
Void $F_1(removeNativeHashMap)(Native m, K key, Vec<$F_0(Pair)<K, T>> dummy) {
	m->cast<FlowHashMap<K, T>>()->erase(key);
}\n", "", [Cpp3Std(["<unordered_map>"], [])], ["hash_map"]),

Cpp3NativePlain("containsNativeHashMap", true,
"template<typename K, typename T> Bool $F_1(containsNativeHashMap)(Native m, K key, Vec<$F_0(Pair)<K, T>> dummy);\n",
"template<typename K, typename T>
Bool $F_1(containsNativeHashMap)(Native m, K key, Vec<$F_0(Pair)<K, T>> dummy) {
	return m->cast<FlowHashMap<K, T>>()->contains(key);
}\n", "", [Cpp3Std(["<unordered_map>"], [])], ["hash_map"]),

Cpp3NativePlain("sizeNativeHashMap", true,
"template<typename K, typename T> Int $F_1(sizeNativeHashMap)(Native m, Vec<$F_0(Pair)<K, T>> dummy);\n",
"template<typename K, typename T>
Int $F_1(sizeNativeHashMap)(Native m, Vec<$F_0(Pair)<K, T>> dummy) {
	return m->cast<FlowHashMap<K, T>>()->size();
}\n", "", [Cpp3Std(["<unordered_map>"], [])], ["hash_map"]),

Cpp3NativePlain("clearNativeHashMap", true,
"template<typename K, typename T> Void $F_1(clearNativeHashMap)(Native m, Vec<$F_0(Pair)<K, T>> dummy);\n",
"template<typename K, typename T>
Void $F_1(clearNativeHashMap)(Native m, Vec<$F_0(Pair)<K, T>> dummy) {
	m->cast<FlowHashMap<K, T>>()->clear();
}\n", "", [Cpp3Std(["<unordered_map>"], [])], ["hash_map"]),

Cpp3NativePlain("cloneNativeHashMap", true,
"template<typename K, typename T> Native $F_1(cloneNativeHashMap)(Native m, Vec<$F_0(Pair)<K, T>> dummy);\n",
"template<typename K, typename T>
Native $F_1(cloneNativeHashMap)(Native m, Vec<$F_0(Pair)<K, T>> dummy) {
	return new FlowHashMap<K, T>(m->cast<FlowHashMap<K, T>>());
}\n", "", [Cpp3Std(["<unordered_map>"], [])], ["hash_map"]),

Cpp3NativePlain("iterNativeHashMap", true,
"template<typename K, typename T> Void $F_1(iterNativeHashMap)(Native m, Fun<Void, K, T> fn, Vec<$F_0(Pair)<K, T>> dummy);\n",
"template<typename K, typename T>
Void $F_1(iterNativeHashMap)(Native m, Fun<Void, K, T> fn, Vec<$F_0(Pair)<K, T>> dummy) {
	for (auto p : m->cast<FlowHashMap<K, T>>()) {
		fn->cast(p.first, p.second);
	}
}\n", "", [Cpp3Std(["<unordered_map>"], [])], ["hash_map"]),

Cpp3NativePlain("funcNativeHashMap", true,
"template<typename K, typename T> Fun<Int, K> $F_1(funcNativeHashMap)(Native m, Vec<$F_0(Pair)<K, T>> dummy);\n",
"template<typename K, typename T>
Fun<Int, K> $F_1(funcNativeHashMap)(Native m, Vec<$F_0(Pair)<K, T>> dummy) {
	return new Fun<Int, K>(m->cast<FlowHashMap<K, T>>()->hash_function());
}\n", "", [Cpp3Std(["<unordered_map>"], [])], ["hash_map"])

]