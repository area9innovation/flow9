[

Cpp3Native("connectDb", false,
"Native* $F_1(connectDb)(String* host, Int port, String* socket, String* user, String* pwd, String* database);\n",
"Native* $F_1(connectDb)(String* host, Int port, String* socket, String* user, String* pwd, String* database) {
	if (socket->size() == 0) {
		MysqlDbCon* db = new MysqlDbCon(host->toStd(), user->toStd(), pwd->toStd(), database->toStd(), port);
		decRc(host);
		decRc(socket);
		decRc(user);
		decRc(pwd);
		decRc(database);
		return Native::make<MysqlDbCon*>(db, [db]() { delete db; });
	} else {
		fail(\"Connection to UNIX socket is not implemented yet\");
		return Native::make(0, []() { });
	}
}\n\n",
"", [], ["mysql"]),

Cpp3Native("closeDb", false,
"Void $F_1(closeDb)(Native* nat);\n",
"Void $F_1(closeDb)(Native* nat) {
	nat->get<MysqlDbCon*>()->close();
	decRc(nat);
	return void_value;
}\n\n",
"", [], ["mysql"]),

Cpp3Native("connectExceptionDb", false,
"String* $F_1(connectExceptionDb)(Native* nat);\n",
"String* $F_1(connectExceptionDb)(Native* nat) {
	String* err = String::make(nat->get<MysqlDbCon*>()->err);
	decRc(nat);
	return err;
}\n\n",
"", [], ["mysql"]),

Cpp3Native("hasNextResultDb", false,
"Bool $F_1(hasNextResultDb)(Native* nat);\n",
"Bool $F_1(hasNextResultDb)(Native* nat) {
	Bool ret = nat->get<MysqlDbRes*>()->hasNext();
	decRc(nat);
	return ret;
}\n\n",
"", [], ["mysql"]),

Cpp3Native("nextResultDb", false,
"
Vec<Union*>* $F_1(nextResultDb)(Native* nat);
Union* makeMysqlDbField(const daotk::mysql::field&, const std::string&, const std::string&, std::set<std::string>&);
",
"

Union* makeMysqlDbField(
	const daotk::mysql::field& field, const std::string& val,
	const std::string& date_time_format,
	std::set<std::string>& int_overflow_fields
) {
	switch (field.type) {
		case MYSQL_TYPE_NULL: {
			return $F_0(DbNullField)::make<$F_0(DbNullField)*>(String::make(field.name));
		}
		case MYSQL_TYPE_SHORT:
		case MYSQL_TYPE_TINY:
		case MYSQL_TYPE_INT24: {
			try {
				return $F_0(DbIntField)::make<$F_0(DbIntField)*>(String::make(field.name), std::stoi(val));
			} catch (std::exception& e) {
				return $F_0(DbNullField)::make<$F_0(DbNullField)*>(String::make(field.name));
			}
		}
		case MYSQL_TYPE_DOUBLE:
		case MYSQL_TYPE_DECIMAL:
		case MYSQL_TYPE_FLOAT: {
			try {
				return $F_0(DbDoubleField)::make<$F_0(DbDoubleField)*>(String::make(field.name), std::stod(val));
			} catch (std::exception& e) {
				return $F_0(DbNullField)::make<$F_0(DbNullField)*>(String::make(field.name));
			}
		}
		case MYSQL_TYPE_TIMESTAMP: {
			try {
				const std::time_put<char>& time_put = std::use_facet<std::time_put<char>>(std::locale());
				std::time_t timestamp = std::stol(val) / 1000.0;
				std::tm* time = std::localtime(&timestamp);
				std::ostringstream out;
				time_put.put(out, out, ' ', time, date_time_format.data(), date_time_format.data() + date_time_format.length());
				return $F_0(DbStringField)::make<$F_0(DbStringField)*>(String::make(field.name), String::make(out.str()));
			} catch (std::exception& e) {
				return $F_0(DbNullField)::make<$F_0(DbNullField)*>(String::make(field.name));
			}
		}
		case MYSQL_TYPE_LONG:
		case MYSQL_TYPE_LONGLONG: {
			try {
				long l_val = std::stol(val);
				int i_val = static_cast<int>(l_val);
				if (l_val == static_cast<long>(i_val)) {
					// use int type if the value fits in 32 bit integer
					return $F_0(DbIntField)::make<$F_0(DbIntField)*>(String::make(field.name), i_val);
				} else {
					int_overflow_fields.insert(field.name);
					if ((l_val & 0xFFFF000000000000L) == 0L) {
						// if the value fits in double type
						// in double 52 bits are used for the mantissa (15-16 decimal digits)
						// We support 48 bit non-negative integers as double (14 decimal digits)
						try {
							return $F_0(DbDoubleField)::make<$F_0(DbDoubleField)*>(String::make(field.name), std::stod(val));
						} catch (std::exception& e) {
							return $F_0(DbNullField)::make<$F_0(DbNullField)*>(String::make(field.name));
						}
					} else {
						// otherwise use string
						return $F_0(DbStringField)::make<$F_0(DbStringField)*>(String::make(field.name), String::make(val));
					}
				}
			} catch (std::exception& e) {
				return $F_0(DbNullField)::make<$F_0(DbNullField)*>(String::make(field.name));
			}
		}
		default: {
			return $F_0(DbStringField)::make<$F_0(DbStringField)*>(String::make(field.name), String::make(val));
		}
	}
}

Vec<Union*>* $F_1(nextResultDb)(Native* nat) {
	MysqlDbRes* r = nat->get<MysqlDbRes*>();
	Vec<Union*>* ret = r->nextResult(makeMysqlDbField);
	decRc(nat);
	return ret;
}\n\n",
"", [], ["mysql"]),

Cpp3Native("requestDb", false,
"Native* $F_1(requestDb)(Native* nat, String* query);\n",
"Native* $F_1(requestDb)(Native* nat, String* query) {
	MysqlDbResDirect* res = new MysqlDbResDirect(nat, query->toStd());
	decRc(query);
	if (res->err.size() > 0) {
		std::cout << \"Error on request db: \" << res->err << std::endl;
	}
	return Native::make<MysqlDbRes*>(res, [res]() { delete res; });
}\n\n",
"", [], ["mysql"]),

Cpp3Native("requestExceptionDb", false,
"String* $F_1(requestExceptionDb)(Native* nat);\n",
"String* $F_1(requestExceptionDb)(Native* nat) {
	String* err = String::make(nat->get<MysqlDbCon*>()->err);
	decRc(nat);
	return err;
}\n\n",
"", [], ["mysql"]),

Cpp3Native("requestDbMulti", false,
"Vec<Vec<Vec<Union*>*>*>* $F_1(requestDbMulti)(Native* nat, Vec<String*>* queries);\n",
"Vec<Vec<Vec<Union*>*>*>* $F_1(requestDbMulti)(Native* nat, Vec<String*>* queries) {
	std::string query;
	for (String* s : *queries) {
		if (query.size() > 0) {
			query += \"; \";
		}
		query += s->toStd();
	}
	decRc(queries);
	MysqlDbCon* c = nat->get<MysqlDbCon*>();
	c->con->set_server_option(MYSQL_OPTION_MULTI_STATEMENTS_ON);
	std::vector<daotk::mysql::result> results = std::move(c->con->mquery(query));
	if (c->err.size() > 0) {
		std::cout << \"Error on request db: \" << c->err << std::endl;
	}
	Vec<Vec<Vec<Union*>*>*>* ret = Vec<Vec<Vec<Union*>*>*>::make(results.size());
	for (auto& res : results) {
		int num_rows = res.count();
		Vec<Vec<Union*>*>* table = Vec<Vec<Union*>*>::make(num_rows);
		const std::vector<daotk::mysql::field>& fields = res.fields();
		for (int i = 0; i < num_rows; ++ i) {
			Vec<Union*>* row = Vec<Union*>::make(fields.size());
			for (Int i = 0; i < fields.size(); ++ i) {
				daotk::mysql::field field = fields.at(i);
				row->pushBack(makeMysqlDbField(
					fields.at(i), res.get_field(i),
					c->date_time_format,
					c->int_overflow_fields
				));
			}
			table->pushBack(row);
			res.next();
		}
		ret->pushBack(table);
	}
	c->checkIntOverflow();
	decRc(nat);
	return ret;
}\n\n",
"", [], ["mysql"]),

Cpp3Native("requestDbWithQueryParams", false,
"Native* $F_1(requestDbWithQueryParams)(Native* nat, String* q, Vec<String*>* ps);\n",
"Native* $F_1(requestDbWithQueryParams)(Native* nat, String* q, Vec<String*>* ps) {
	MysqlDbCon* db = nat->get<MysqlDbCon*>();
	std::string query = q->toStd();
	decRc(q);
	std::vector<std::string> params;
	params.reserve(ps->size());
	for (String* s : *ps) {
		params.push_back(s->toStd());
	}
	decRc(ps);
	try {
		MysqlDbResPrep* res = new MysqlDbResPrep(nat, query, params);
		return Native::make<MysqlDbRes*>(res, [res]() { delete res; });
	} catch (std::exception& e) {
		std::cout << e.what() << std::endl;
		fail(e.what());
	}
}\n\n",
"", [], ["mysql"])

]