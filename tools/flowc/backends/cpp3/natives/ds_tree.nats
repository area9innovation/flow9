[

Cpp3NativePlain("lookupTree", true,
"template<typename T1, typename T2> Union* $F_1(lookupTree)(Union* tree, T1 key);\n",
"template <typename T1, typename T2>
Union* $F_1(lookupTree)(Union* tree, T1 key) {
	Union* tree0 = tree;
	while (true) {
		if (tree->structId() == $F_2(TreeNode)) {
			$F_0(TreeNode)<T1, T2>* node = static_cast<$F_0(TreeNode)<T1, T2>*>(tree);
			T1 k = node->template get<0>();
			T2 v = node->template get<1>();
			Union* l = node->template get<2>();
			Union* r = node->template get<3>();
			Int c = compare(key, k);
			if (c < 0) {
				tree = l;
				continue;
			} else {
				if (c == 0) {
					decRc<Union*>(tree0);
					decRc<T1>(key);
					incRc<T2>(v);
					return $F_0(Some)<T2>::template make<$F_0(Some)<T2>*>(v);
				} else {
					tree = r;
					continue;
				}
			}
		} else {
			decRc<Union*>(tree0);
			decRc<T1>(key);
			return $F_0(None)::template make<$F_0(None)*>();
		}
	}
}",
"", [], []
),

Cpp3NativePlain("treeDepth1", true,
"template<typename T1, typename T2> Int $F_1(treeDepth1)(Union* tree);\n",
"template <typename T1, typename T2>
inline Int $F_1(treeDepth1)(Union* tree) {
	Int depth = (tree->structId() == $F_2(TreeNode)) ? static_cast<$F_0(TreeNode)<T1, T2>*>(tree)->template get<4>() : 0;
	decRc<Union*>(tree);
	return depth;
}",
"", [], ["tree_util"]
),

Cpp3NativePlain("treeLeftRotation1", true,
"template<typename T1, typename T2> Union* $F_1(treeLeftRotation1)(Union* tree);\n",
"

template <typename T1, typename T2>
inline Int treeDepth(Union* tree) {
	return (tree->structId() == $F_2(TreeNode)) ? static_cast<$F_0(TreeNode)<T1, T2>*>(tree)->template get<4>() : 0;
}

template <typename T1, typename T2>
inline Union* $F_1(treeLeftRotation1)(Union* tree) {
	using Node = $F_0(TreeNode)<T1, T2>;
	Node* node = static_cast<Node*>(tree);
	T1 k = node->template get<0>();
	T2 v = node->template get<1>();
	Union* left = node->template get<2>();
	Union* right = node->template get<3>();
	if (right->structId() != $F_2(TreeNode)) {
		/*
		std::cout << 
		\"to rotate LEFT: NOT NEEDED \\n\" << 
		\"\\t\" << tree2string<T1, T2>(node) << \"\\n\" << std::endl;
		//tree2string<T1, T2>(ret) << \"\\n\" << std::endl;
		*/
		return node;
	} else {
		Node* node_right = static_cast<Node*>(right);
		T1 ck = node_right->template get<0>();
		T2 cv = node_right->template get<1>();
		Union* cleft = node_right->template get<2>();
		Union* cright = node_right->template get<3>();

		Int new_right_depth = std::max(treeDepth<T1, T2>(left), treeDepth<T1, T2>(cleft)) + 1;
		Int ret_depth = std::max(new_right_depth, treeDepth<T1, T2>(cright)) + 1;

		Node* new_right = nullptr;
		/*if (node->isUnit()) {
			Node* new_right = node;
			new_right->template set<3>(cleft);
			new_right->template set<4>(new_right_depth);
		} else {*/
			incRc<Union*>(left);
			incRc<Union*>(cleft);
			incRc<T1>(k);
			incRc<T2>(v);
			decRc(node);
			new_right = Node::template make<Node*>(k, v, left, cleft, new_right_depth);
		//}
		/*if (node_right->isUnit()) {	
			Node* ret = node_right;
			ret->template set<2>(new_right);
			ret->template set<4>(ret_depth);
			return ret;
		} else {*/
			incRc<Union*>(cright);
			incRc<T1>(ck);
			incRc<T2>(cv);
			Node* ret = Node::template make<Node*>(ck, cv, new_right, cright, ret_depth);
			/*
			std::cout << 
				\"to rotate LEFT: \\n\" << 
				\"\\t\" << tree2string<T1, T2>(node) << \"\\n\" <<
				\"\\t\" << tree2string<T1, T2>(ret) << \"\\n\" << std::endl;
			*/
			return ret;
		//}
	}
}
", "", [], []
),


Cpp3NativePlain("treeRightRotation1", true,
"template<typename T1, typename T2> Union* $F_1(treeRightRotation1)(Union* tree);\n",
"

template <typename T1, typename T2>
inline Int treeDepth1(Union* tree) {
	return (tree->structId() == $F_2(TreeNode)) ? static_cast<$F_0(TreeNode)<T1, T2>*>(tree)->template get<4>() : 0;
}

template <typename T1, typename T2>
inline Union* $F_1(treeRightRotation1)(Union* tree) {
	using Node = $F_0(TreeNode)<T1, T2>;
	Node* node = static_cast<Node*>(tree);
	T1 k = node->template get<0>();
	T2 v = node->template get<1>();
	Union* left = node->template get<2>();
	Union* right = node->template get<3>();
	if (left->structId() != $F_2(TreeNode)) {
		return node;
	} else {
		Node* node_left = static_cast<Node*>(left);
		T1 ck = node_left->template get<0>();
		T2 cv = node_left->template get<1>();
		Union* cleft = node_left->template get<2>();
		Union* cright = node_left->template get<3>();

		Int new_left_depth = std::max(treeDepth1<T1, T2>(cright), treeDepth1<T1, T2>(right)) + 1;
		Int ret_depth = std::max(treeDepth1<T1, T2>(cleft), new_left_depth) + 1;

		Node* new_left = nullptr;
		/*if (node->isUnit()) {
			Node* new_left = node;
			new_left->template set<2>(cright);
			new_left->template set<4>(new_left_depth);
		} else {*/
			incRc<Union*>(right);
			incRc<Union*>(cright);
			incRc<T1>(k);
			incRc<T2>(v);
			decRc(node);
			new_left = Node::template make<Node*>(k, v, cright, right, new_left_depth);
		//}
		/*if (node_left->isUnit()) {	
			Node* ret = node_left;
			ret->template set<3>(new_left);
			ret->template set<4>(ret_depth);
			return ret;
		} else {*/
			incRc<Union*>(cleft);
			incRc<T1>(ck);
			incRc<T2>(cv);
			Node* ret = Node::template make<Node*>(ck, cv, cleft, new_left, ret_depth);
			return ret;
		//}
	}
}
", "", [], []
),



Cpp3NativePlain("setTree1", true,
"template<typename T1, typename T2> Union* $F_1(setTree1)(Union* tree, T1 key, T2 val);\n",
"

template <typename T1, typename T2>
inline Int treeDepth(Union* tree) {
	return (tree->structId() == $F_2(TreeNode)) ? static_cast<$F_0(TreeNode)<T1, T2>*>(tree)->template get<4>() : 0;
}

template <typename T1, typename T2> std::string tree2string(Union* tree);

template <typename T1, typename T2>
inline $F_0(TreeNode)<T1, T2>* treeLeftRotation($F_0(TreeNode)<T1, T2>* node) {
	using Node = $F_0(TreeNode)<T1, T2>;
	T1 k = node->template get<0>();
	T2 v = node->template get<1>();
	Union* left = node->template get<2>();
	Union* right = node->template get<3>();
	if (right->structId() != $F_2(TreeNode)) {
		std::cout << 
		\"to rotate LEFT: NOT NEEDED \\n\" << 
		\"\\t\" << tree2string<T1, T2>(node) << \"\\n\" << std::endl;
		//tree2string<T1, T2>(ret) << \"\\n\" << std::endl;
		return node;
	} else {
		Node* node_right = static_cast<Node*>(right);
		T1 ck = node_right->template get<0>();
		T2 cv = node_right->template get<1>();
		Union* cleft = node_right->template get<2>();
		Union* cright = node_right->template get<3>();

		Int new_right_depth = std::max(treeDepth<T1, T2>(left), treeDepth<T1, T2>(cleft)) + 1;
		Int ret_depth = std::max(new_right_depth, treeDepth<T1, T2>(cright)) + 1;

		Node* new_right = nullptr;
		/*if (node->isUnit()) {
			Node* new_right = node;
			new_right->template set<3>(cleft);
			new_right->template set<4>(new_right_depth);
		} else {*/
			incRc<Union*>(left);
			incRc<Union*>(cleft);
			incRc<T1>(k);
			incRc<T2>(v);
			decRc(node);
			new_right = Node::template make<Node*>(k, v, left, cleft, new_right_depth);
		//}
		/*if (node_right->isUnit()) {	
			Node* ret = node_right;
			ret->template set<2>(new_right);
			ret->template set<4>(ret_depth);
			return ret;
		} else {*/
			incRc<Union*>(cright);
			incRc<T1>(ck);
			incRc<T2>(cv);
			Node* ret = Node::template make<Node*>(ck, cv, new_right, cright, ret_depth);
			std::cout << 
				\"to rotate LEFT: \\n\" << 
				\"\\t\" << tree2string<T1, T2>(node) << \"\\n\" <<
				\"\\t\" << tree2string<T1, T2>(ret) << \"\\n\" << std::endl;
			return ret;
		//}
		}
}

template <typename T1, typename T2>
inline $F_0(TreeNode)<T1, T2>* treeRightRotation($F_0(TreeNode)<T1, T2>* node) {
	using Node = $F_0(TreeNode)<T1, T2>;
	T1 k = node->template get<0>();
	T2 v = node->template get<1>();
	Union* left = node->template get<2>();
	Union* right = node->template get<3>();
	//std::cout << \"to rotate RIGHT: \" << tree2string<T1, T2>(node) << std::endl;
	if (left->structId() != $F_2(TreeNode)) {
		std::cout << 
		\"to rotate RIGHT: NOT NEEDED \\n\" << 
		\"\\t\" << tree2string<T1, T2>(node) << \"\\n\" << std::endl;
		//tree2string<T1, T2>(ret) << \"\\n\" << std::endl;
		return node;
	} else {
		Node* ____reuse_node = decRcReuse<Node*>(node);
		Node* node_left = static_cast<Node*>(left);
		T1 ck = node_left->template get<0>();
		T2 cv = node_left->template get<1>();
		Union* cleft = node_left->template get<2>();
		Union* cright = node_left->template get<3>();

		Int new_left_depth = std::max(treeDepth<T1, T2>(cright), treeDepth<T1, T2>(right)) + 1;
		Int ret_depth = std::max(treeDepth<T1, T2>(cleft), new_left_depth) + 1;

		Node* new_left = nullptr;
		/*if (node->isUnit()) {
			Node* new_left = node;
			new_left->template set<2>(cright);
			new_left->template set<4>(new_left_depth);
		} else {*/
			incRc<Union*>(right);
			incRc<Union*>(cright);
			incRc<T1>(k);
			incRc<T2>(v);
			decRc(node);
			new_left = Node::template make<Node*>(k, v, cright, right, new_left_depth);
		//}
		/*if (node_left->isUnit()) {	
			Node* ret = node_left;
			ret->template set<3>(new_left);
			ret->template set<4>(ret_depth);
			return ret;
		} else {*/
			incRc<Union*>(cleft);
			incRc<T1>(ck);
			incRc<T2>(cv);
			Node* ret = Node::template make<Node*>(ck, cv, cleft, new_left, ret_depth);
			std::cout << 
				\"to rotate RIGHT: \\n\" << 
				\"\\t\" << tree2string<T1, T2>(node) << \"\\n\" <<
				\"\\t\" << tree2string<T1, T2>(ret) << \"\\n\" << std::endl;
			return ret;
		//}
	}
}

template <typename T1, typename T2>
inline $F_0(TreeNode)<T1, T2>* rebalanceTree($F_0(TreeNode)<T1, T2>* n) {
	using Node = $F_0(TreeNode)<T1, T2>;
	T1 k = n->template get<0>();
	T2 v = n->template get<1>();
	Union* left = n->template get<2>();
	Union* right = n->template get<3>();
	Int orig_depth = n->template get<4>();
	Int leftDepth = treeDepth<T1, T2>(left);
	Int rightDepth = treeDepth<T1, T2>(right);
	Int balance = (leftDepth - rightDepth);
	Int calc_depth = std::max(leftDepth, rightDepth) + 1;
	std::cout << \"TO REBALANCE: leftDepth: \" << leftDepth << \", rightDepth: \" << rightDepth << \", balance: \" << balance << \", orig_depth: \" << orig_depth << \", calc_depth: \" << calc_depth << std::endl;
	if (balance == -1 || balance == 0 || balance == 1) {
		if (calc_depth == orig_depth) {
			return n;
		} /*else if (n->isUnit()) {
			n->template set<4>(calc_depth);
			return n;
		} */else {
			incRc<T1>(k);
			incRc<T2>(v);
			incRc<Union*>(left);
			incRc<Union*>(right);
			decRc<Node*>(n);
			std::cout << \"\\t(A)\" << std::endl;
			return Node::template make<Node*>(k, v, left, right, calc_depth);
		}
	} else {
		if (balance < 0) {
			if (right->structId() == $F_2(TreeEmpty)) {
				if (calc_depth == orig_depth) {
					return n;
				} /*else if (n->isUnit()) {
					n->template set<4>(calc_depth);
					return n;
				} */else {
					incRc<T1>(k);
					incRc<T2>(v);
					incRc<Union*>(left);
					incRc<Union*>(right);
					decRc<Node*>(n);
					std::cout << \"\\t(B)\" << std::endl;
					return Node::template make<Node*>(k, v, left, right, calc_depth);
				}
			} else {
				Node* node_right = static_cast<Node*>(right);
				Union* rl = node_right->template get<2>();
				Union* rr = node_right->template get<3>();
				if (treeDepth<T1, T2>(rl) < treeDepth<T1, T2>(rr)) {
					if (calc_depth == orig_depth) {
						return n;
					} /*else if (n->isUnit()) {
						n->template set<4>(calc_depth);
						return n;
					} */else {
						incRc<T1>(k);
						incRc<T2>(v);
						incRc<Union*>(left);
						incRc<Union*>(right);
						decRc<Node*>(n);
						std::cout << \"\\t(C): treeDepth<T1, T2>(rl) < treeDepth<T1, T2>(rr): \" << treeDepth<T1, T2>(rl) << \" < \" << treeDepth<T1, T2>(rr) << std::endl;
						return Node::template make<Node*>(k, v, left, right, calc_depth);
					}
				} else {
					Union* rotated = treeRightRotation<T1, T2>(node_right);
					Int depth_rebalanced = std::max(treeDepth<T1, T2>(left), treeDepth<T1, T2>(rotated)) + 1;
					/*if (n->isUnit()) {
						n->template set<3>(rotated);
						n->template set<4>(depth_rebalanced);
						return n;
					} else {*/
						incRc<T1>(k);
						incRc<T2>(v);
						incRc<Union*>(left);
						decRc<Node*>(n);
						std::cout << \"\\t(D)\" << std::endl;
						return treeLeftRotation<T1, T2>(
							 Node::template make<Node*>(k, v, left, rotated, depth_rebalanced)
						);
					//}
				}
			}
		} else {
			if (left->structId() == $F_2(TreeEmpty)) {
				if (calc_depth == orig_depth) {
					return n;
				} /*else if (n->isUnit()) {
					n->template set<4>(calc_depth);
					return n;
				} */else {
					incRc<T1>(k);
					incRc<T2>(v);
					incRc<Union*>(left);
					incRc<Union*>(right);
					decRc<Node*>(n);
					std::cout << \"\\t(E)\" << std::endl;
					return Node::template make<Node*>(k, v, left, right, calc_depth);
				}
			} else {
				Node* node_left = static_cast<Node*>(left);
				Union* ll = node_left->template get<2>();
				Union* lr = node_left->template get<3>();
				if (treeDepth<T1, T2>(ll) < treeDepth<T1, T2>(lr)) {
					Union* rotated = treeLeftRotation<T1, T2>(node_left);
					Int depth_rebalanced = std::max(treeDepth<T1, T2>(rotated), treeDepth<T1, T2>(right)) + 1;
					/*if (n->isUnit()) {
						n->template set<2>(rotated);
						n->template set<4>(depth_rebalanced);
						return n;
					} else {*/
						incRc<T1>(k);
						incRc<T2>(v);
						incRc<Union*>(right);
						decRc<Node*>(n);
						std::cout << \"\\t(F)\" << std::endl;
						return treeRightRotation<T1, T2>(
							 Node::template make<Node*>(k, v, rotated, right, depth_rebalanced)
						);
					//}
				} else {
					if (calc_depth == orig_depth) {
						return n;
					} /*else if (n->isUnit()) {
						n->template set<4>(calc_depth);
						return n;
					} */else {
						incRc<T1>(k);
						incRc<T2>(v);
						incRc<Union*>(left);
						incRc<Union*>(right);
						decRc<Node*>(n);
						std::cout << \"\\t(G)\" << std::endl;
						return Node::template make<Node*>(k, v, left, right, calc_depth);
					}
				}
			}
		}
	}
}


template <typename T1, typename T2>
Union* $F_1(setTree1)(Union* tree, T1 key, T2 val) {
	Union* tree0 = tree;
	using Node = $F_0(TreeNode)<T1, T2>;
	$F_0(TreeEmpty)* emptytree = $F_0(TreeEmpty)::template make<$F_0(TreeEmpty)*>();
	std::pair<Int, Node*> path[64];
	Int path_len = 0;
	std::cout << \"SET TREE: \" << toStdString(key) << \" => \" << toStdString(val) << \"\\n\" << tree2string<T1, T2>(tree) << std::endl;
	while (true) {
		if (path_len >= 64) {
			fail(\"path_len >= 64, size tree: \" + std::to_string($F_1(sizeTree)<T1, T2>(tree)) + \"\\n\" +
				\"tree->structId(): \" + std::to_string(tree->structId()) + \"\\n\" +
				\"path_len: \" + std::to_string(path_len) + \"\\n\"
				\"TreeEmpty: \" + std::to_string($F_2(TreeEmpty)) + \"\\n\"
				\"TreeNode: \" + std::to_string($F_2(TreeNode)) + \"\\n\"
			);
		}
		if (tree->structId() == $F_2(TreeNode)) {
			$F_0(TreeNode)<T1, T2>* node = static_cast<$F_0(TreeNode)<T1, T2>*>(tree);
			T1 k = node->template get<0>();
			T2 v = node->template get<1>();
			Union* l = node->template get<2>();
			Union* r = node->template get<3>();
			Int c = compare(key, k);
			if (c < 0) {
				std::cout << \"path_len: \" << path_len << \": tree->structId() == $F_2(TreeNode) && c < 0\" << std::endl;
				tree = l;
				path[path_len++] = std::pair(c, node);
				continue;
			} else {
				if (c == 0) {
					std::cout << \"path_len: \" << path_len << \": tree->structId() == $F_2(TreeNode) && c == 0\" << std::endl;
					path[path_len++] = std::pair(c, Node::template make<Node*>(key, val, emptytree, emptytree, 1));
					break;
				} else {
					std::cout << \"path_len: \" << path_len << \": tree->structId() == $F_2(TreeNode) && c > 0\" << std::endl;
					tree = r;
					path[path_len++] = std::pair(c, node);
					continue;
				}
			}
		} else {
			std::cout << \"path_len: \" << path_len << \": tree->structId() != $F_2(TreeNode)\" << std::endl;
			path[path_len++] = std::pair(0, Node::template make<Node*>(key, val, emptytree, emptytree, 1));
			break;
		}
	}
	Node* ret = path[--path_len].second;
	while (path_len-- > 0) {
		Node* n = path[path_len].second;
		Int c = path[path_len].first;
		if (c == 0) {
			ret = n;
		} else if (c < 0) {
			Node* x = nullptr;
			/*if (n->isUnit()) {
				n->template set<2>(ret);
				x = n;
			} else {*/
				T1 k = n->template get<0>();
				T2 v = n->template get<1>();
				Union* r = n->template get<3>();
				incRc<T1>(k);
				incRc<T2>(v);
				incRc<Union*>(r);
				x = Node::template make<Node*>(k, v, ret, r, n->template get<4>());
			//}
			ret = rebalanceTree(x);
		} else {
			Node* x = nullptr;
			/*if (n->isUnit()) {
				n->template set<3>(ret);
				x = n;
			} else {*/
				T1 k = n->template get<0>();
				T2 v = n->template get<1>();
				Union* l = n->template get<2>();
				incRc<T1>(k);
				incRc<T2>(v);
				incRc<Union*>(l);
				x = Node::template make<Node*>(k, v, l, ret, n->template get<4>());
			//}
			ret = rebalanceTree(x);
		}
	}
	return ret;
}

template <typename T1, typename T2>
std::string tree2string(Union* tree) {
	using Node = $F_0(TreeNode)<T1, T2>;
	if (tree->structId() == $F_2(TreeNode)) {
		Node* node = static_cast<Node*>(tree);
		T1 k = node->template get<0>();
		T2 v = node->template get<1>();
		Union* l = node->template get<2>();
		Union* r = node->template get<3>();
		return std::string(\"[\") + toStdString(k) + \" => \" + toStdString(v) + \", L: \" + tree2string<T1, T2>(l) + \", R: \" + tree2string<T1, T2>(r) + \"]\";
	} else {
		return \"empty\";
	}
}

",
"", [], ["tree_util"])

]