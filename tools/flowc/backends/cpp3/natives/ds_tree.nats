[

Cpp3NativePlain("lookupTree", true,
"template<typename T1, typename T2> Union* $F_1(lookupTree)(Union* tree, T1 key);\n",
"template <typename T1, typename T2>
Union* $F_1(lookupTree)(Union* tree, T1 key) {
	Union* tree0 = tree;
	while (true) {
		if (tree->structId() == $F_2(TreeNode)) {
			$F_0(TreeNode)<T1, T2>* node = static_cast<$F_0(TreeNode)<T1, T2>*>(tree);
			T1 k = node->template get<0>();
			T2 v = node->template get<1>();
			Union* l = node->template get<2>();
			Union* r = node->template get<3>();
			Int c = compare(key, k);
			if (c < 0) {
				tree = l;
				continue;
			} else {
				if (c == 0) {
					decRc<Union*>(tree0);
					decRc<T1>(key);
					incRc<T2>(v);
					return $F_0(Some)<T2>::template make<$F_0(Some)<T2>*>(v);
				} else {
					tree = r;
					continue;
				}
			}
		} else {
			decRc<Union*>(tree0);
			decRc<T1>(key);
			return $F_0(None)::template make<$F_0(None)*>();
		}
	}
}",
"", [], []
),

Cpp3NativePlain("treeDepth", true,
"template<typename T1, typename T2> Int $F_1(treeDepth)(Union* tree);\n",
"template <typename T1, typename T2>
inline Int $F_1(treeDepth)(Union* tree) {
	Int depth = (tree->structId() == $F_2(TreeNode)) ? static_cast<$F_0(TreeNode)<T1, T2>*>(tree)->template get<4>() : 0;
	decRc<Union*>(tree);
	return depth;
}",
"", [], ["tree_util"]
),

Cpp3NativePlain("treeLeftRotation1", true,
"template<typename T1, typename T2> Union* $F_1(treeLeftRotation1)(Union* tree);\n",
"

template <typename T1, typename T2>
inline Int treeDepth(Union* tree) {
	return (tree->structId() == $F_2(TreeNode)) ? static_cast<$F_0(TreeNode)<T1, T2>*>(tree)->template get<4>() : 0;
}

template <typename T1, typename T2>
inline Union* $F_1(treeLeftRotation1)(Union* tree) {
	using Node = $F_0(TreeNode)<T1, T2>;
	Node* node = static_cast<Node*>(tree);
	T1 k = node->template get<0>();
	T2 v = node->template get<1>();
	Union* left = node->template get<2>();
	Union* right = node->template get<3>();
	if (right->structId() != $F_2(TreeNode)) {
		return node;
	} else {
		Node* node_right = static_cast<Node*>(right);
		T1 ck = node_right->template get<0>();
		T2 cv = node_right->template get<1>();
		Union* cleft = node_right->template get<2>();
		Union* cright = node_right->template get<3>();
		Int new_right_depth = std::max(treeDepth<T1, T2>(left), treeDepth<T1, T2>(cleft)) + 1;
		Int ret_depth = std::max(new_right_depth, treeDepth<T1, T2>(cright)) + 1;
		if (node->isUnit()) {
			if (node_right->isUnit()) {
				incRc(cleft);
				// here we use plain set, because otherwise `setRc1` destroys the `node_right` itself
				node->template set<3>(cleft);
				node->template set<4>(new_right_depth);
				node_right->template setRc1<2>(node);
				node_right->template setRc1<4>(ret_depth);
				return node_right;
			} else {
				incRc<Union*>(cleft);
				incRc<Union*>(cright);
				node->template setRc1<3>(cleft);
				node->template set<4>(new_right_depth);
				incRc<T1>(ck);
				incRc<T2>(cv);
				return Node::template make<Node*>(ck, cv, node, cright, ret_depth);
			}
		} else {
			incRc<Union*>(cleft);
			incRc<Union*>(left);
			incRc<T1>(k);
			incRc<T2>(v);
			Node* new_right = Node::template make<Node*>(k, v, left, cleft, new_right_depth);
			incRc<Union*>(cright);
			incRc<T1>(ck);
			incRc<T2>(cv);
			decRc<Node*>(node);
			return Node::template make<Node*>(ck, cv, new_right, cright, ret_depth);
		}
	}
}
", "", [], []
),

Cpp3NativePlain("treeRightRotation1", true,
"template<typename T1, typename T2> Union* $F_1(treeRightRotation1)(Union* tree);\n",
"

template <typename T1, typename T2>
inline Int treeDepth1(Union* tree) {
	return (tree->structId() == $F_2(TreeNode)) ? static_cast<$F_0(TreeNode)<T1, T2>*>(tree)->template get<4>() : 0;
}

template <typename T1, typename T2>
inline Union* $F_1(treeRightRotation1)(Union* tree) {
	using Node = $F_0(TreeNode)<T1, T2>;
	Node* node = static_cast<Node*>(tree);
	T1 k = node->template get<0>();
	T2 v = node->template get<1>();
	Union* left = node->template get<2>();
	Union* right = node->template get<3>();
	if (left->structId() != $F_2(TreeNode)) {
		return node;
	} else {
		Node* node_left = static_cast<Node*>(left);
		T1 ck = node_left->template get<0>();
		T2 cv = node_left->template get<1>();
		Union* cleft = node_left->template get<2>();
		Union* cright = node_left->template get<3>();
		Int new_left_depth = std::max(treeDepth1<T1, T2>(cright), treeDepth1<T1, T2>(right)) + 1;
		Int ret_depth = std::max(treeDepth1<T1, T2>(cleft), new_left_depth) + 1;
		Node* new_left = nullptr;
		if (node->isUnit()) {
			if (node_left->isUnit()) {
				incRc(cright);
				// here we use plain set, because otherwise `setRc1` destroys the `node_left` itself
				node->template set<2>(cright);
				node->template set<4>(new_left_depth);
				node_left->template setRc1<3>(node);
				node_left->template setRc1<4>(ret_depth);
				return node_left;
			} else {
				incRc<Union*>(cleft);
				incRc<Union*>(cright);
				node->template setRc1<2>(cright);
				node->template set<4>(new_left_depth);
				incRc<T1>(ck);
				incRc<T2>(cv);
				return Node::template make<Node*>(ck, cv, cleft, node, ret_depth);
			}
		} else {
			incRc<Union*>(right);
			incRc<Union*>(cright);
			incRc<T1>(k);
			incRc<T2>(v);
			new_left = Node::template make<Node*>(k, v, cright, right, new_left_depth);
			incRc<Union*>(cleft);
			incRc<T1>(ck);
			incRc<T2>(cv);
			decRc(node);
			return Node::template make<Node*>(ck, cv, cleft, new_left, ret_depth);
		}
	}
}
", "", [], []
),

Cpp3NativePlain("rebalanceTree1", true,
"template<typename T1, typename T2> inline Union* $F_1(rebalanceTree1)(Union* tree);\n",
"

template <typename T1, typename T2>
inline Int treeDepth2(Union* tree) {
	return (tree->structId() == $F_2(TreeNode)) ? static_cast<$F_0(TreeNode)<T1, T2>*>(tree)->template get<4>() : 0;
}

template <typename T1, typename T2>
inline Union* $F_1(rebalanceTree1)(Union* tree) {
	using Node = $F_0(TreeNode)<T1, T2>;
	Node* n = static_cast<Node*>(tree);
	T1 k = n->template get<0>();
	T2 v = n->template get<1>();
	Union* left = n->template get<2>();
	Union* right = n->template get<3>();
	Int orig_depth = n->template get<4>();
	Int leftDepth = treeDepth2<T1, T2>(left);
	Int rightDepth = treeDepth2<T1, T2>(right);
	Int balance = (leftDepth - rightDepth);
	Int calc_depth = std::max(leftDepth, rightDepth) + 1;
	if (balance == -1 || balance == 0 || balance == 1) {
		if (calc_depth == orig_depth) {
			return n;
		} else if (n->isUnit()) {
			n->template set<4>(calc_depth);
			return n;
		} else {
			incRc<T1>(k);
			incRc<T2>(v);
			incRc<Union*>(left);
			incRc<Union*>(right);
			decRc<Node*>(n);
			return Node::template make<Node*>(k, v, left, right, calc_depth);
		}
	} else {
		if (balance < 0) {
			if (right->structId() == $F_2(TreeEmpty)) {
				if (calc_depth == orig_depth) {
					return n;
				} else if (n->isUnit()) {
					n->template set<4>(calc_depth);
					return n;
				} else {
					incRc<T1>(k);
					incRc<T2>(v);
					incRc<Union*>(left);
					incRc<Union*>(right);
					decRc<Node*>(n);
					return Node::template make<Node*>(k, v, left, right, calc_depth);
				}
			} else {
				Node* node_right = static_cast<Node*>(right);
				Union* rl = node_right->template get<2>();
				Union* rr = node_right->template get<3>();
				Node* n1 = nullptr;
				if (treeDepth2<T1, T2>(rl) < treeDepth2<T1, T2>(rr)) {
					if (n->isUnit()) {
						n->template set<4>(calc_depth);
						n1 = n;
					} else {
						incRc<T1>(k);
						incRc<T2>(v);
						incRc<Union*>(left);
						incRc<Union*>(right);
						decRc<Node*>(n);
						n1 = Node::template make<Node*>(k, v, left, right, calc_depth);
					}
				} else {
					incRc<Union*>(right);
					Union* rotated = $F_1(treeRightRotation1)<T1, T2>(node_right);
					Int depth_rebalanced = std::max(treeDepth2<T1, T2>(left), treeDepth2<T1, T2>(rotated)) + 1;
					if (n->isUnit()) {
						n->template setRc1<3>(rotated);
						n->template set<4>(depth_rebalanced);
						n1 = n;
					} else {
						incRc<T1>(k);
						incRc<T2>(v);
						incRc<Union*>(left);
						decRc<Node*>(n);
						n1 = Node::template make<Node*>(k, v, left, rotated, depth_rebalanced);
					}
				}
				return $F_1(treeLeftRotation1)<T1, T2>(n1);
			}
		} else {
			if (left->structId() == $F_2(TreeEmpty)) {
				if (calc_depth == orig_depth) {
					return n;
				} else if (n->isUnit()) {
					n->template set<4>(calc_depth);
					return n;
				} else {
					incRc<T1>(k);
					incRc<T2>(v);
					incRc<Union*>(left);
					incRc<Union*>(right);
					decRc<Node*>(n);
					return Node::template make<Node*>(k, v, left, right, calc_depth);
				}
			} else {
				Node* node_left = static_cast<Node*>(left);
				Union* ll = node_left->template get<2>();
				Union* lr = node_left->template get<3>();
				Node* n1 = nullptr;
				if (treeDepth2<T1, T2>(ll) < treeDepth2<T1, T2>(lr)) {
					incRc<Union*>(left);
					Union* rotated = $F_1(treeLeftRotation1)<T1, T2>(node_left);
					Int depth_rebalanced = std::max(treeDepth2<T1, T2>(rotated), treeDepth2<T1, T2>(right)) + 1;
					if (n->isUnit()) {
						n->template setRc1<2>(rotated);
						n->template set<4>(depth_rebalanced);
						n1 = n;
					} else {
						incRc<T1>(k);
						incRc<T2>(v);
						incRc<Union*>(right);
						decRc<Node*>(n);
						n1 = Node::template make<Node*>(k, v, rotated, right, depth_rebalanced);
					}
				} else {
					 if (n->isUnit()) {
						n->template set<4>(calc_depth);
						n1 = n;
					} else {
						incRc<T1>(k);
						incRc<T2>(v);
						incRc<Union*>(left);
						incRc<Union*>(right);
						decRc<Node*>(n);
						n1 = Node::template make<Node*>(k, v, left, right, calc_depth);
					}
				}
				return $F_1(treeRightRotation1)<T1, T2>(n1);
			}
		}
	}
}
", "", [], []
),

Cpp3NativePlain("setTree", true,
"template<typename T1, typename T2> Union* $F_1(setTree)(Union* tree, T1 key, T2 val);\n",
"

template <typename T1, typename T2>
inline Int treeDepth(Union* tree) {
	return (tree->structId() == $F_2(TreeNode)) ? static_cast<$F_0(TreeNode)<T1, T2>*>(tree)->template get<4>() : 0;
}

template <typename T1, typename T2>
inline $F_0(TreeNode)<T1, T2>* treeLeftRotation($F_0(TreeNode)<T1, T2>* node) {
	using Node = $F_0(TreeNode)<T1, T2>;
	T1 k = node->template get<0>();
	T2 v = node->template get<1>();
	Union* left = node->template get<2>();
	Union* right = node->template get<3>();

	Node* node_right = static_cast<Node*>(right);
	T1 ck = node_right->template get<0>();
	T2 cv = node_right->template get<1>();
	Union* cleft = node_right->template get<2>();
	Union* cright = node_right->template get<3>();
	Int new_right_depth = std::max(treeDepth<T1, T2>(left), treeDepth<T1, T2>(cleft)) + 1;
	Int ret_depth = std::max(new_right_depth, treeDepth<T1, T2>(cright)) + 1;
	if (node->isUnit()) {
		if (node_right->isUnit()) {
			incRc(cleft);
			// here we use plain set, because otherwise `setRc1` destroys the `node_right` itself
			node->template set<3>(cleft);
			node->template set<4>(new_right_depth);
			node_right->template setRc1<2>(node);
			node_right->template setRc1<4>(ret_depth);
			return node_right;
		} else {
			incRc<Union*>(cleft);
			incRc<Union*>(cright);
			node->template setRc1<3>(cleft);
			node->template set<4>(new_right_depth);
			incRc<T1>(ck);
			incRc<T2>(cv);
			return Node::template make<Node*>(ck, cv, node, cright, ret_depth);
		}
	} else {
		incRc<Union*>(cleft);
		incRc<Union*>(left);
		incRc<T1>(k);
		incRc<T2>(v);
		Node* new_right = Node::template make<Node*>(k, v, left, cleft, new_right_depth);
		incRc<Union*>(cright);
		incRc<T1>(ck);
		incRc<T2>(cv);
		decRc<Node*>(node);
		return Node::template make<Node*>(ck, cv, new_right, cright, ret_depth);
	}
}

template <typename T1, typename T2>
inline $F_0(TreeNode)<T1, T2>* treeRightRotation($F_0(TreeNode)<T1, T2>* node) {
	using Node = $F_0(TreeNode)<T1, T2>;
	T1 k = node->template get<0>();
	T2 v = node->template get<1>();
	Union* left = node->template get<2>();
	Union* right = node->template get<3>();

	Node* node_left = static_cast<Node*>(left);
	T1 ck = node_left->template get<0>();
	T2 cv = node_left->template get<1>();
	Union* cleft = node_left->template get<2>();
	Union* cright = node_left->template get<3>();
	Int new_left_depth = std::max(treeDepth<T1, T2>(cright), treeDepth<T1, T2>(right)) + 1;
	Int ret_depth = std::max(treeDepth<T1, T2>(cleft), new_left_depth) + 1;
	Node* new_left = nullptr;
	if (node->isUnit()) {
		if (node_left->isUnit()) {
			incRc(cright);
			// here we use plain set, because otherwise `setRc1` destroys the `node_left` itself
			node->template set<2>(cright);
			node->template set<4>(new_left_depth);
			node_left->template setRc1<3>(node);
			node_left->template setRc1<4>(ret_depth);
			return node_left;
		} else {
			incRc<Union*>(cleft);
			incRc<Union*>(cright);
			node->template setRc1<2>(cright);
			node->template set<4>(new_left_depth);
			incRc<T1>(ck);
			incRc<T2>(cv);
			return Node::template make<Node*>(ck, cv, cleft, node, ret_depth);
		}
	} else {
		incRc<Union*>(right);
		incRc<Union*>(cright);
		incRc<T1>(k);
		incRc<T2>(v);
		new_left = Node::template make<Node*>(k, v, cright, right, new_left_depth);
		incRc<Union*>(cleft);
		incRc<T1>(ck);
		incRc<T2>(cv);
		decRc(node);
		return Node::template make<Node*>(ck, cv, cleft, new_left, ret_depth);
	}
}

template <typename T1, typename T2>
inline $F_0(TreeNode)<T1, T2>* rebalanceTree($F_0(TreeNode)<T1, T2>* n) {
	using Node = $F_0(TreeNode)<T1, T2>;
	T1 k = n->template get<0>();
	T2 v = n->template get<1>();
	Union* left = n->template get<2>();
	Union* right = n->template get<3>();
	Int orig_depth = n->template get<4>();
	Int leftDepth = treeDepth<T1, T2>(left);
	Int rightDepth = treeDepth<T1, T2>(right);
	Int balance = (leftDepth - rightDepth);
	Int calc_depth = std::max(leftDepth, rightDepth) + 1;
	if (balance == -1 || balance == 0 || balance == 1) {
		if (calc_depth == orig_depth) {
			return n;
		} else if (n->isUnit()) {
			n->template set<4>(calc_depth);
			return n;
		} else {
			incRc<T1>(k);
			incRc<T2>(v);
			incRc<Union*>(left);
			incRc<Union*>(right);
			decRc<Node*>(n);
			return Node::template make<Node*>(k, v, left, right, calc_depth);
		}
	} else {
		if (balance < 0) {
			if (right->structId() == $F_2(TreeEmpty)) {
				if (calc_depth == orig_depth) {
					return n;
				} else if (n->isUnit()) {
					n->template set<4>(calc_depth);
					return n;
				} else {
					incRc<T1>(k);
					incRc<T2>(v);
					incRc<Union*>(left);
					incRc<Union*>(right);
					decRc<Node*>(n);
					return Node::template make<Node*>(k, v, left, right, calc_depth);
				}
			} else {
				Node* node_right = static_cast<Node*>(right);
				Union* rl = node_right->template get<2>();
				Union* rr = node_right->template get<3>();
				Node* n1 = nullptr;
				if (treeDepth<T1, T2>(rl) < treeDepth<T1, T2>(rr)) {
					if (n->isUnit()) {
						n->template set<4>(calc_depth);
						n1 = n;
					} else {
						incRc<T1>(k);
						incRc<T2>(v);
						incRc<Union*>(left);
						incRc<Union*>(right);
						decRc<Node*>(n);
						n1 = Node::template make<Node*>(k, v, left, right, calc_depth);
					}
				} else {
					incRc<Union*>(right);
					Union* rotated = treeRightRotation<T1, T2>(node_right);
					Int depth_rebalanced = std::max(treeDepth<T1, T2>(left), treeDepth<T1, T2>(rotated)) + 1;
					if (n->isUnit()) {
						n->template setRc1<3>(rotated);
						n->template set<4>(depth_rebalanced);
						n1 = n;
					} else {
						incRc<T1>(k);
						incRc<T2>(v);
						incRc<Union*>(left);
						decRc<Node*>(n);
						n1 = Node::template make<Node*>(k, v, left, rotated, depth_rebalanced);
					}
				}
				return treeLeftRotation<T1, T2>(n1);
			}
		} else {
			if (left->structId() == $F_2(TreeEmpty)) {
				if (calc_depth == orig_depth) {
					return n;
				} else if (n->isUnit()) {
					n->template set<4>(calc_depth);
					return n;
				} else {
					incRc<T1>(k);
					incRc<T2>(v);
					incRc<Union*>(left);
					incRc<Union*>(right);
					decRc<Node*>(n);
					return Node::template make<Node*>(k, v, left, right, calc_depth);
				}
			} else {
				Node* node_left = static_cast<Node*>(left);
				Union* ll = node_left->template get<2>();
				Union* lr = node_left->template get<3>();
				Node* n1 = nullptr;
				if (treeDepth<T1, T2>(ll) < treeDepth<T1, T2>(lr)) {
					incRc<Union*>(left);
					Union* rotated = treeLeftRotation<T1, T2>(node_left);
					Int depth_rebalanced = std::max(treeDepth<T1, T2>(rotated), treeDepth<T1, T2>(right)) + 1;
					if (n->isUnit()) {
						n->template setRc1<2>(rotated);
						n->template set<4>(depth_rebalanced);
						n1 = n;
					} else {
						incRc<T1>(k);
						incRc<T2>(v);
						incRc<Union*>(right);
						decRc<Node*>(n);
						n1 = Node::template make<Node*>(k, v, rotated, right, depth_rebalanced);
					}
				} else {
					 if (n->isUnit()) {
						n->template set<4>(calc_depth);
						n1 = n;
					} else {
						incRc<T1>(k);
						incRc<T2>(v);
						incRc<Union*>(left);
						incRc<Union*>(right);
						decRc<Node*>(n);
						n1 = Node::template make<Node*>(k, v, left, right, calc_depth);
					}
				}
				return treeRightRotation<T1, T2>(n1);
			}
		}
	}
}

template <typename T1, typename T2>
Union* $F_1(setTree)(Union* tree, T1 key, T2 val) {
	bool is_unit = true;
	Union* tree0 = tree;
	using Node = $F_0(TreeNode)<T1, T2>;
	$F_0(TreeEmpty)* emptytree = $F_0(TreeEmpty)::template make<$F_0(TreeEmpty)*>();
	// Depth of 32 is enough to store up to 4 billion elements.
	std::pair<Int, Node*> path[32];
	Int path_len = 0;
	while (true) {
		is_unit = is_unit && tree->isUnit();
		if (tree->structId() == $F_2(TreeNode)) {
			$F_0(TreeNode)<T1, T2>* node = static_cast<$F_0(TreeNode)<T1, T2>*>(tree);
			T1 k = node->template get<0>();
			T2 v = node->template get<1>();
			Union* l = node->template get<2>();
			Union* r = node->template get<3>();
			Int depth = node->template get<4>();
			Int c = compare(key, k);
			if (c < 0) {
				tree = l;
				path[path_len++] = std::pair(c, node);
				continue;
			} else {
				if (c == 0) {
					if (is_unit) {
						decRc(key);
						node->template setRc1<1>(val);
						// No need to rebalance, we may just return
						return tree0;
					} else {
						incRc<Union*>(l);
						incRc<Union*>(r);
						path[path_len++] = std::pair(c, Node::template make<Node*>(key, val, l, r, depth));
					}
					break;
				} else {
					tree = r;
					path[path_len++] = std::pair(c, node);
					continue;
				}
			}
		} else {
			path[path_len++] = std::pair(0, Node::template make<Node*>(key, val, emptytree, emptytree, 1));
			break;
		}
	}
	Node* ret = path[--path_len].second;
	if (is_unit) {
		while (path_len-- > 0) {
			Node* n = path[path_len].second;
			Int c = path[path_len].first;
			if (c == 0) {
				ret = n;
			} else if (c < 0) {
				n->template set<2>(ret);
				ret = rebalanceTree<T1, T2>(n);
			} else {
				n->template set<3>(ret);
				ret = rebalanceTree<T1, T2>(n);
			}
		}
	} else {
		while (path_len-- > 0) {
			Node* n = path[path_len].second;
			Int c = path[path_len].first;
			if (c == 0) {
				ret = n;
			} else if (c < 0) {
				T1 k = n->template getRc1<0>();
				T2 v = n->template getRc1<1>();
				Union* r = n->template getRc1<3>();
				ret = rebalanceTree<T1, T2>(Node::template make<Node*>(k, v, ret, r, n->template get<4>()));
			} else {
				T1 k = n->template getRc1<0>();
				T2 v = n->template getRc1<1>();
				Union* l = n->template getRc1<2>();
				ret = rebalanceTree<T1, T2>(Node::template make<Node*>(k, v, l, ret, n->template get<4>()));
			}
		}
		decRc<Union*>(tree0);
	}
	return ret;
}

",
"", [], ["tree_util"])

]