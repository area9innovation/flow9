[

Cpp3NativePlain("stringbytes2int", false,
"Int $F_1(stringbytes2int)(String* s);\n",
"Int $F_1(stringbytes2int)(String* s) {
	IntOrChars i(s->str.at(0), s->str.at(1));
	s->decRc();
	return i.int_;
}\n", "", [], []),

Cpp3NativePlain("stringbytes2double", false,
"Double $F_1(stringbytes2double)(String* s);\n",
"Double $F_1(stringbytes2double)(String* s) {
	DoubleOrChars d(s->str.at(0), s->str.at(1), s->str.at(2), s->str.at(3));
	s->decRc();
	return d.double_;
}\n", "", [], []),

Cpp3NativePlain("fromBinary", true,
"inline Flow $F_1(fromBinary)(String* s, Flow* defval, Fun<Flow*, String*>* fixup);\n",
"inline Flow $F_1(fromBinary)(String* s, Flow* defval, Fun<Flow*, String*>* fixup) {
	defval->decRc();
	fixup->decRc();
	return s;
}\n", "$A_0", [], []),

Cpp3NativePlain("toBinary", false,
"String* $F_1(toBinary)(Flow* value);\n",
"String* $F_1(toBinary)(Flow* value) {
	std::unordered_map<Int, Int> structIdxs;
	std::vector<Int> structDefs;

	string s;
	// Placeholders for size of values - 32 bit int
	s.push_back(0);
	s.push_back(0);
	appendBinaryValue(value, s, structIdxs, structDefs);
	value->decRc();
	Int len = s.size();
	// Set length at the beginning
	s[0] = len & 0xffff;
	s[1] = len >> 16;

	if (structDefs.size() == 0) {
		appendCharValue(0xFFF7, s);
	} else {
		if (structDefs.size() > 65535) {
			appendCharValue(0xFFF9, s);
			appendBinaryInt32(structDefs.size(), s);
		} else {
			appendCharValue(0xFFF8, s);
			appendCharValue(structDefs.size(), s);
		}
	}
	for (Int struct_id : structDefs) {
		appendCharValue(0xFFF8, s);
		appendCharValue(0x0002, s);
		StructDef struct_def = RTTI::structDef(struct_id)
		appendCharValue(struct_def->args.size(), s);

		appendCharValue(0xFFFA, s);
		appendCharValue(struct_def->name.size(), s);
		for (auto c : struct_def->name->str) {
			appendCharValue(c, s);
		}
	}
	return String::make(std::move(s));
}\n", "", [Cpp3Std(["<unordered_map>"], [])], ["to_binary"])

]