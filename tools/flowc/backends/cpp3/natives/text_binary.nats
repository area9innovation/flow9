[

Cpp3Native("stringbytes2int", false,
"Int $F_1(stringbytes2int)(String* s);\n",
"Int $F_1(stringbytes2int)(String* s) {
	IntOrChars i(s->getChar(0), s->getChar(1));
	decRc(s);
	return i.int_;
}\n", Cpp3Inline(true, ""), [], ["to_binary"]),

Cpp3Native("stringbytes2double", false,
"Double $F_1(stringbytes2double)(String* s);\n",
"Double $F_1(stringbytes2double)(String* s) {
	DoubleOrChars d(s->getChar(0), s->getChar(1), s->getChar(2), s->getChar(3));
	decRc(s);
	return d.double_;
}\n", Cpp3Inline(true, ""), [], ["to_binary"]),

Cpp3Native("fromBinary", true,
"inline Flow* $F_1(fromBinary)(String* s, Flow* defval, Fun<Union*, String*>* fixup);\n",
"inline Flow* $F_1(fromBinary)(String* s, Flow* defval, Fun<Union*, String*>* fixup) {
	decRc(defval);
	decRc(fixup);
	return s;
}\n", Cpp3Inline(true, ""), [], []),

Cpp3Native("toBinary", false,
"String* $F_1(toBinary)(Flow* value);\n",
"String* $F_1(toBinary)(Flow* value) {
	std::unordered_map<Int, Int> structIdxs;
	std::vector<Int> structDefs;

	string s;
	// Placeholders for size of values - 32 bit int
	s.push_back(0);
	s.push_back(0);
	appendBinaryValue(value, s, structIdxs, structDefs);
	Int len = s.size();
	// Set length at the beginning
	s[0] = len & 0xffff;
	s[1] = len >> 16;

	if (structDefs.size() == 0) {
		appendCharValue(0xFFF7, s);
	} else {
		if (structDefs.size() > 65535) {
			appendCharValue(0xFFF9, s);
			appendBinaryInt32(structDefs.size(), s);
		} else {
			appendCharValue(0xFFF8, s);
			appendCharValue(structDefs.size(), s);
		}
	}
	for (Int struct_id : structDefs) {
		appendCharValue(0xFFF8, s);
		appendCharValue(0x0002, s);
		const StructDef& struct_def = RTTI::structDef(struct_id);
		appendCharValue(struct_def.args.size(), s);

		appendCharValue(0xFFFA, s);
		appendCharValue(struct_def.name.size(), s);
		for (auto c : struct_def.name) {
			appendCharValue(c, s);
		}
	}
	return String::make(std::move(s));
}\n", Cpp3Inline(true, ""), [Cpp3Std(["<unordered_map>"], [])], ["to_binary"])

]