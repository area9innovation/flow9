[

Cpp3NativePlain("length", true, 
"template<typename T> Int $F_1(length)(Vec<T> a);\n",
"template<typename T>
Int $F_1(length)(Vec<T> a) {
	Int ret = static_cast<Int>(a->vect.size());
	a->checkRefs();
	return ret;
}\n", "", [], []
),

Cpp3NativePlain("concat", true,
"template<typename T> Vec<T> $F_1(concat)(Vec<T> a1, Vec<T> a2);\n",
"template<typename T>
inline Vec<T> $F_1(concat)(Vec<T> v1, Vec<T> v2) {
	//if (v1->refs > 2) {
		//std::cout << \"concatVecs, v1->refs=\" << v1->refs << std::endl;
		std::vector<T> ret;
		ret.reserve(v1->size() + v2->size());
		for(T x : *v1) ret.push_back(x);
		v1->checkRefs(); 
		for(T x : *v2) ret.push_back(x);
		v2->checkRefs(); 
		return new Vector<T>(std::move(ret));
	/*} else {
		//std::cout << \"Shortcut for concatVecs\" << std::endl;
		//std::cout << \"concatVecs, v1->refs=\" << v1->refs << std::endl;
		//std::cout << \"v1->size()=\" << v1->vect.size() << \", v2->size()=\" << v2->vect.size() << std::endl;
		std::vector<T>& ret = const_cast<std::vector<T>&>(v1->vect);
		for(T x : *v2) ret.push_back(x);
		//std::cout << \"Resulting v1->size()=\" << v1->vect.size() << \", ret.size()=\" << ret.size() << std::endl;
		return v1;
	}*/
}\n", "", [], []),

Cpp3NativePlain("fold", true,
"template<typename T, typename V> V $F_1(fold)(Vec<T> a, V v, Fun<V, V, T> fn);\n",
"template<typename T, typename V>
V $F_1(fold)(Vec<T> a, V v, Fun<V, V, T> fn) {
	for (T x : *a) {
		v = fn->call(v, x);
	}
	fn->checkRefs();
	return v;
}\n", "", [], []),

Cpp3NativePlain("foldi", true,
"template<typename T, typename V> V $F_1(foldi)(Vec<T> a, V v, Fun<V, Int, V, T> fn);\n",
"template<typename T, typename V>
V $F_1(foldi)(Vec<T> a, V v, Fun<V, Int, V, T> fn) {
	Int i = 0;
	for (T x : *a) {
		v = fn->call(i++, v, x);
	}
	fn->checkRefs();
	return v;
}\n", "", [Cpp3Std(["<typeinfo>"], [])], []),

Cpp3NativePlain("map", true,
"template<typename T, typename V> Vec<V> $F_1(map)(Vec<T> a, Fun<V, T> fn);\n",
"template<typename T, typename V>
Vec<V> $F_1(map)(Vec<T> a, Fun<V, T> fn) {
	Int s = a->size();
	std::vector<V> ret;
	ret.reserve(a->size());
	for (T x : *a) {
		ret.push_back(fn->call(x));
	}
	a->checkRefs();
	fn->checkRefs();
	return Vec<V>::make(std::move(ret));
}\n", "", [], []),

Cpp3NativePlain("mapi", true,
"template<typename T, typename V> Vec<V> $F_1(mapi)(Vec<T> a, Fun<V, Int, T> fn);\n",
"template<typename T, typename V>
Vec<V> $F_1(mapi)(Vec<T> a, Fun<V, Int, T> fn) {
	std::vector<V> ret;
	ret.reserve(a->size());
	Int i = 0;
	for (T x : *a) {
		ret.push_back(fn->call(i++, x));
	}
	a->checkRefs();
	fn->checkRefs();
	return Vec<V>::make(std::move(ret));
}\n", "", [], []),

Cpp3NativePlain("filter", true,
"template<typename T> Vec<T> $F_1(filter)(Vec<T> a, Fun<Bool, T> fn);\n",
"template<typename T>
Vec<T> $F_1(filter)(Vec<T> a, Fun<Bool, T> fn) {
	std::vector<T> ret;
	ret.reserve(a->size());
	for (T x : *a) {
		if (fn->call(x)) {
			ret.push_back(x);
		}
	}
	a->checkRefs();
	fn->checkRefs();
	ret.shrink_to_fit();
	return Vec<T>::make(std::move(ret));
}\n", "", [], []),

Cpp3NativePlain("replace", true,
"template<typename T> Vec<T> $F_1(replace)(Vec<T> a, Int i, T v);\n",
"template<typename T>
Vec<T> $F_1(replace)(Vec<T> a, Int i, T v) {
	std::vector<T> ret(a->vect);
	if (i < a->size()) {
		ret[i] = v; 
	} else if (i == a->size()) {
		ret.push_back(v);
	}
	a->checkRefs();
	return Vec<T>::make(std::move(ret));
}\n", "", [], []),

Cpp3NativePlain("subrange", true,
"template<typename T> Vec<T> $F_1(subrange)(Vec<T> a, Int i, Int len);\n",
"template<typename T>
Vec<T> $F_1(subrange)(Vec<T> a, Int i, Int len) {
	if (len < 0) {
		a->checkRefs();
		return Vec<T>::make();
	} else {
		std::vector<T> ret;
		ret.reserve(len);
		for (Int j = 0; j < len; ++ j) {
			ret.push_back(a->getItem(i + j));
		}
		a->checkRefs();
		return Vec<T>::make(std::move(ret));
	}
}\n", "", [], []),

Cpp3NativePlain("enumFromTo", false,
"Vec<Int> $F_1(enumFromTo)(Int beg, Int end);\n",
"Vec<Int> $F_1(enumFromTo)(Int beg, Int end) {
	if (beg > end) {
		return Vec<Int>::make();
	} else {
		std::vector<Int> ret;
		ret.reserve(end - beg + 1);
		for (Int i = 0; i < end - beg + 1; ++i) {
			ret.push_back(beg + i);
		}
		return Vec<Int>::make(std::move(ret));
	}
}\n", "", [], []),

Cpp3NativePlain("iter", true,
"template<typename T> Void $F_1(iter)(Vec<T> a, Fun<Void, T> fn);\n",
"template<typename T>
Void $F_1(iter)(Vec<T> a, Fun<Void, T> fn) { 
	for (T x : *a) {
		fn->call(x);
	}
	a->checkRefs();
	fn->checkRefs();
	return void_value;
}\n", "", [], []),

Cpp3NativePlain("iteri", true,
"template<typename T> Void $F_1(iteri)(Vec<T> a, Fun<Void, Int, T> fn);\n",
"template<typename T>
Void $F_1(iteri)(Vec<T> a, Fun<Void, Int, T> fn) {
	Int i = 0;
	for (T x : *a) {
		fn->call(i++, x);
	}
	a->checkRefs();
	fn->checkRefs();
	return void_value;
}\n", "", [], []),

Cpp3NativePlain("iteriUntil", true,
"template<typename T> Int $F_1(iteriUntil)(Vec<T> a, Fun<Bool, Int, T> fn);\n",
"template<typename T>
Int $F_1(iteriUntil)(Vec<T> a, Fun<Bool, Int, T> fn) {
	for (Int i = 0; i < static_cast<Int>(a->size()); ++ i) {
		if (fn->call(i, a->getItem(i))) {
			return i;
		}
	}
	a->checkRefs();
	fn->checkRefs();
	return static_cast<Int>(a->size());
}\n", "", [], []),
	
Cpp3NativePlain("iterUntil", true,
"template<typename T> Int $F_1(iterUntil)(Vec<T> a, Fun<Bool, T> fn);\n",
"template<typename T>
Int $F_1(iterUntil)(Vec<T> a, Fun<Bool, T> fn) {
	for (Int i = 0; i < static_cast<Int>(a->size()); ++ i)) {
		if (fn->call(a->getItem(i))) {
			return i;
		}
	}
	a->checkRefs();
	fn->checkRefs();
	return static_cast<Int>(a->size());
}\n", "", [], [])

]