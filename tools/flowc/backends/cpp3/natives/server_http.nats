[

Cpp3Native("createHttpServer", false,
"Fun<Void>* $F_1(createHttpServer)(
	Int port,
	Fun<Void>* onOpen,
	Fun<Void, $F_0(HttpRequest)*, Fun<Void, $F_0(HttpResponse)*>*>* onMessage
);
",
"Fun<Void>* $F_1(createHttpServer)(
	Int port,
	Fun<Void>* onOpen,
	Fun<Void, $F_0(HttpRequest)*, Fun<Void, $F_0(HttpResponse)*>*>* onMessage
) {
	fv::HttpServer* server = new fv::HttpServer();
	std::cout << \"Going to init a server task...\" << std::endl;
	HttpSupport::start();
	HttpSupport::registerServer(server);
	fv::Tasks::RunAsync([server, port, onOpen, onMessage]() -> Task<void> {
		server->SetHttpHandler1 (\"/\", [onMessage] (fv::Request& req, std::function<Task<void>(fv::Response&)> on_resp) -> Task<void> {
			std::cout << \"\tReceived: '\" << req.Content << \"'\" << std::endl;
			onMessage->callRc1(
				$F_0(HttpRequest)::make<$F_0(HttpRequest)*>(
					String::make(req.Url),
					String::make(req.Content),
					Vec<$F_0(KeyValue)*>::make(),
					$F_0(None)::make<$F_0(None)*>()
				),
				Fun<Void, $F_0(HttpResponse)*>::make([on_resp]($F_0(HttpResponse)* resp) -> Void {
					//std::cout << \"\t$F_0(HttpResponse)* resp =: '\" << toString(resp)->toStd() << \"'\" << std::endl;
					fv::Response response;
					response.HttpCode = resp->get<0>();
					response.Content = resp->get<1>()->toStd();
					decRc(resp);
					asio::io_context ctx;
					asio::co_spawn(
						ctx.get_executor(),
						on_resp(response),
						[](std::exception_ptr ptr) { if (ptr) std::rethrow_exception(ptr); }
					);
					ctx.run();
					if (ctx.stopped()) {
						std::cout << \"CTX STOPPED\" << std::endl;
					} else {
						std::cout << \"CTX (NOT!!!!) STOPPED\" << std::endl;
					}
					return void_value;
				})
			);
			co_return;
		});
		onOpen->callRc();
		co_await server->Run(port);
	});
	std::cout << \"Returning a server shutdown...\" << std::endl;
	return Fun<Void>::make([server, onMessage]() -> Void {
		std::this_thread::sleep_for(std::chrono::milliseconds(250));
		std::cout << \"Going to: server->Stop();...\" << std::endl;
		server->Stop();
		std::cout << \"Going to: decRc(onMessage);...\" << std::endl;
		decRc(onMessage);
		std::cout << \"Returning from:Fun<Void>::make([server, onMessage]() -> Void {...\" << std::endl;
		return void_value;
	});
}\n", "", [], ["http"]),

Cpp3Native("createHttpServerNative", false,
"Native* $F_1(createHttpServerNative)(
	Int port,
	Bool isHttps,
	String* pfxPath,
	String* pfxPassword,
	Fun<Void>* onOpen,
	Fun<
		Void,
		String*,
		String*,
		String*,
		Vec<Vec<String*>*>*,
		Fun<Void, String*>*,
		Fun<Void, String*, Vec<String*>*>*,
		Fun<Void, Int>*
	>* onMessage
);\n",
"Native* $F_1(createHttpServerNative)(
	Int port,
	Bool isHttps,
	String* pfxPath,
	String* pfxPassword,
	Fun<Void>* onOpen,
	Fun<
		Void,
		String*,
		String*,
		String*,
		Vec<Vec<String*>*>*,
		Fun<Void, String*>*,
		Fun<Void, String*, Vec<String*>*>*,
		Fun<Void, Int>*
	>* onMessage
) {
	// TODO: fill in the stub
	decRc(pfxPath);
	decRc(pfxPassword);
	decRc(onOpen);
	decRc(onMessage);
	return Native::make(0, [](){});
}\n", "", [], []),

Cpp3Native("closeHttpServerNative", false,
"Void $F_1(closeHttpServerNative)(Native* server);\n",
"Void $F_1(closeHttpServerNative)(Native* server) {
	// TODO: fill in the stub
	decRc(server);
	return void_value;
}\n", "", [], [])

]