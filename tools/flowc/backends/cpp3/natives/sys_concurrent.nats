[
Cpp3NativePlain("availableProcessors", true,
"inline Int $F_1(availableProcessors)();\n",
"inline Int $F_1(availableProcessors)() {
	return std::thread::hardware_concurrency();
}\n", "", 
[Cpp3Std(["<thread>"], [])], []),

Cpp3NativePlain("setThreadPoolSize", true,
"inline Void $F_1(setThreadPoolSize)(Int threads);\n",
"inline Void $F_1(setThreadPoolSize)(Int threads) {
	thread_pool.setMaxThreadCount(threads);
	return void_value;
}\n", "", [], ["concurrent"]),

Cpp3NativePlain("concurrent", true,
"template<typename T> Vec<T> $F_1(concurrent)(Bool fine, Vec<Fun<T>> tasks);\n",
"template<typename T> Vec<T> $F_1(concurrent)(Bool fine, Vec<Fun<T>> tasks) {
	/*std::vector<T> ret = QtConcurrent::blockingMapped<
		std::vector<T>, 
		std::vector<Fun<T>>, 
		std::function<T(Fun<T>)>
	>(tasks->vect, [](Fun<T> task) { return task->call(); });
	return Vec<T>::make(std::move(ret));*/
	std::vector<T> ret;
	ret.reserve(tasks->vect.size());
	for (auto& f : tasks->vect) {
		ret.push_back(f->call());
	}
	tasks->checkRefs();
	return Vec<T>::make(std::move(ret));
}\n", "", 
[], ["concurrent"]),

Cpp3NativePlain("synchronizedConstFn", true,
"template<typename T> Fun<T> $F_1(synchronizedConstFn)(Flow lock, Fun<T> fn);\n",
"template<typename T> Fun<T> $F_1(synchronizedConstFn)(Flow lock, Fun<T> fn) {
	return Fun<T>::make([lock, fn]() mutable { 
		static std::mutex mx;
		const std::lock_guard<std::mutex> l(mx);
		return (*fn)();
	});
}\n", "", 
[], ["concurrent"]),

Cpp3NativePlain("synchronizedUnaryFn", true,
"template<typename A, typename T> Fun<T, A> $F_1(synchronizedUnaryFn)(Flow lock, Fun<T, A> fn);\n",
"template<typename A, typename T> Fun<T, A> $F_1(synchronizedUnaryFn)(Flow lock, Fun<T, A> fn) {
	return Fun<T, A>::make([fn](A a) { 
		static std::mutex mx;
		const std::lock_guard<std::mutex> l(mx);
		return (*fn)(a);
	});
}\n", "", 
[], ["concurrent"]),

Cpp3NativePlain("synchronizedBinaryFn", true,
"template<typename A1, typenama A2, typename T> Fun<T, A1, A2> $F_1(synchronizedBinaryFn)(Flow lock, Fun<T, A1, A2> fn);\n",
"template<typename A1, typename A2, typename T> Fun<T, A1, A2>* $F_1(synchronizedBinaryFn)(Flow lock, Fun<T, A1, A2> fn) {
	return Fun<T, A1, A2>::make([lock, fn](A1 a1, A2 a2) mutable { 
		static std::mutex mx;
		const std::lock_guard<std::mutex> l(mx);
		return (*fn)(a1, a2);
	});
}\n", "", 
[], ["concurrent"]),

Cpp3NativePlain("synchronizedTernaryFn", true,
"template<typename A1, typenama A2, typename A3, typename T> Fun<T, A1, A2, A3> $F_1(synchronizedTernaryFn)(Flow lock, Fun<T, A1, A2, A3> fn);\n",
"template<typename A1, typename A2, typename A3, typename T> Fun<T, A1, A2, A3> $F_1(synchronizedTernaryFn)(Flow lock, Fun<T, A1, A2, A3> fn) {
	return Fun<T, A1, A2, A3>::make([lock, fn](A1 a1, A2 a2, A3 a3) mutable { 
		static std::mutex mx;
		const std::lock_guard<std::mutex> l(mx);
		return (*fn)(a1, a2, a3);
	});
}\n", "", 
[], ["concurrent"]),

Cpp3NativePlain("concurrentAsyncCallback", true,
"template<typename T> Void $F_1(concurrentAsyncCallback)(Fun<Void, String, Fun<T>> task, Fun<Void, T> onDone, Fun<Void, String> onFail);\n",
"template<typename T> Void $F_1(concurrentAsyncCallback)(Fun<Void, String, Fun<T>> task, Fun<Void, T> onDone, Fun<Void, String> onFail) {
	// TODO
	return void_value;
}\n", "", 
[], [])

]