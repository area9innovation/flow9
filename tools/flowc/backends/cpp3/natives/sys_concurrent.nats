[
Cpp3NativePlain("availableProcessors", true,
"inline Int $F_1(availableProcessors)();\n",
"inline Int $F_1(availableProcessors)() {
	return std::thread::hardware_concurrency();
}\n", "", 
[Cpp3Std(["<thread>"], [])], []),

Cpp3NativePlain("setThreadPoolSize", true,
"inline Void $F_1(setThreadPoolSize)(Int threads);\n",
"inline Void $F_1(setThreadPoolSize)(Int threads) {
	thread_pool.setMaxThreadCount(threads);
}\n", "", [], ["concurrent"]),

Cpp3NativePlain("concurrent", true,
"template<typename T> Arr<T>* $F_1(concurrent)(Bool fine, Arr<Fun<T>>* tasks);\n",
"template<typename T> Arr<T>* $F_1(concurrent)(Bool fine, Arr<Fun<T>>* tasks) {
	std::vector<typename Traits<T>::LVal> ret = QtConcurrent::blockingMapped<
		std::vector<typename Traits<T>::LVal>, 
		typename Arr<Fun<T>>::Vect, 
		std::function<typename Traits<T>::RVal(Ptr<Fun<typename Traits<T>::RVal>>)>
	>(tasks->vect, [](Ptr<Fun<T>> task) { return task->call(); });
	return new Arr<T>(std::move(ret));
}\n", "", 
[Cpp3Qt(["<QtConcurrent>"], [])], ["concurrent"]),

Cpp3NativePlain("synchronizedConstFn", true,
"template<typename T> Fun<T>* $F_1(synchronizedConstFn)(Flow* lock, Fun<T>* fn);\n",
"template<typename T> Fun<T>* $F_1(synchronizedConstFn)(Flow* lock, Fun<T>* fn) {
	return new SyncFun<T>(lock, fn);
}\n", "", 
[], ["synchronized"]),

Cpp3NativePlain("synchronizedUnaryFn", true,
"template<typename A, typename T> Fun<T, A>* $F_1(synchronizedUnaryFn)(Flow* lock, Fun<T, A>* fn);\n",
"template<typename A, typename T> Fun<T, A>* $F_1(synchronizedUnaryFn)(Flow* lock, Fun<T, A>* fn) {
	return new SyncFun<T, A>(lock, fn);
}\n", "", 
[], ["synchronized"]),

Cpp3NativePlain("synchronizedBinaryFn", true,
"template<typename A1, typenama A2, typename T> Fun<T, A1, A2>* $F_1(synchronizedBinaryFn)(Flow* lock, Fun<T, A1, A2>* fn);\n",
"template<typename A1, typename A2, typename T> Fun<T, A1, A2>* $F_1(synchronizedBinaryFn)(Flow* lock, Fun<T, A1, A2>* fn) {
	return new SyncFun<T, A1, A2>(lock, fn);
}\n", "", 
[], ["synchronized"]),

Cpp3NativePlain("synchronizedTernaryFn", true,
"template<typename A1, typenama A2, typename A3, typename T> Fun<T, A1, A2, A3>* $F_1(synchronizedTernaryFn)(Flow* lock, Fun<T, A1, A2, A3>* fn);\n",
"template<typename A1, typename A2, typename A3, typename T> Fun<T, A1, A2, A3>* $F_1(synchronizedTernaryFn)(Flow* lock, Fun<T, A1, A2, A3>* fn) {
	return new SyncFun<T, A1, A2, A3>(lock, fn);
}\n", "", 
[], ["synchronized"]),

Cpp3NativePlain("concurrentAsyncCallback", true,
"template<typename T> Void $F_1(concurrentAsyncCallback)(Fun<Void, String, Fun<T>>* task, Fun<Void, T>* onDone, Fun<Void, String>* onFail);\n",
"template<typename T> Void $F_1(concurrentAsyncCallback)(Fun<Void, String, Fun<T>>* task, Fun<Void, T>* onDone, Fun<Void, String>* onFail) {
	// TODO
}\n", "", 
[], [])

]