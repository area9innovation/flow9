[
Cpp3NativePlain("availableProcessors", true,
"inline Int $F_1(availableProcessors)();\n",
"inline Int $F_1(availableProcessors)() {
	return std::thread::hardware_concurrency();
}\n", "", 
[Cpp3Std(["<thread>"], [])], []),

Cpp3NativePlain("setThreadPoolSize", true,
"inline Void $F_1(setThreadPoolSize)(Int threads);\n",
"inline Void $F_1(setThreadPoolSize)(Int threads) {
	thread_pool.setMaxThreadCount(threads);
}\n", "", [], ["concurrent"]),

Cpp3NativePlain("concurrent", true,
"template<typename T> Arr<T> $F_1(concurrent)(Bool fine, Arr<Fun<T>> tasks);\n",
"template<typename T> Arr<T> $F_1(concurrent)(Bool fine, Arr<Fun<T>> tasks) {
	QVector<Fun<T>> qt_tasks;
	qt_tasks.reserve(tasks->size());
	for (Fun<T> f : tasks->vect) {
		qt_tasks.push_back(f);
	}
	QVector<T> mapped = 
		QtConcurrent::blockingMapped<
			QVector<T>, 
			QVector<Fun<T>>, 
			std::function<T(Fun<T>)>
		>
		(qt_tasks, [](Fun<T> task) { return task(); });
	Arr<T> ret(mapped.size());
	for (T x : mapped) {
		ret->vect.push_back(x);
	}
	return ret;
}\n", "", 
[Cpp3Qt(["<QtConcurrent>"], [])], ["concurrent"])


]