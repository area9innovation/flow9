[

Cpp3NativePlain("toString2", true,
"String $F_1(toString2)(Flow x);\n",
"inline String $F_1(toString2)(Flow x) { 
	String ret = x->toString();
	x->decRefs();
	return ret;
}\n", "", [], []),

Cpp3NativePlain("isSameStructType", true,
"template<typename T1, typename T2> Bool $F_1(isSameStructType)(T1 o1, T2 o2);\n",
"template<typename T1, typename T2> Bool $F_1(isSameStructType)(T1 o1, T2 o2) { 
	Bool ret = o1->type() == o2->type(); 
	RefCount<T1>::dec(o1);
	RefCount<T2>::dec(o2);
	return ret;
}
template<> inline Bool $F_1(isSameStructType)(Int x, Int y) { return false; }
template<> inline Bool $F_1(isSameStructType)(Bool x, Bool y) { return false; }
template<> inline Bool $F_1(isSameStructType)(Double x, Double y) { return false; }
template<> inline Bool $F_1(isSameStructType)(String x, String y) { x->decRefs(); y->decRefs(); return false; }
template<> inline Bool $F_1(isSameStructType)(Native x, Native y) { x->decRefs(); y->decRefs(); return false; }
\n", "", [], []),

Cpp3NativePlain("makeStructValue", false,
"Flow $F_1(makeStructValue)(String name, Vec<Flow> args, Flow defval);\n",
"Flow $F_1(makeStructValue)(String name, Vec<Flow> args, Flow defval) {
	if (StructDefs::defs.find(name->str) == StructDefs::defs.end()) {
		name->decRefs();
		args->decRefs();
		return defval;
	} else {
		Flow ret = StructDefs::defs.at(name->str).make(args);
		name->decRefs();
		args->decRefs();
		defval->decRefs();
		return ret;
	}
}\n", "", [], ["struct_defs"]),

Cpp3NativePlain("isSameObj", true,
"template<typename T> Bool $F_1(isSameObj)(T x, T y);\n",
"template<typename T> inline Bool $F_1(isSameObj)(T x, T y) { 
	Bool ret = x.get() == y.get();
	RefCount<T>::dec(x);
	RefCount<T>::dec(y);
	return ret;
}
template<> inline Bool $F_1(isSameObj)(Int x, Int y) { return x == y; }
template<> inline Bool $F_1(isSameObj)(Bool x, Bool y) { return x == y; }
template<> inline Bool $F_1(isSameObj)(Double x, Double y) { return x == y; }
template<> inline Bool $F_1(isSameObj)(String x, String y) { x->decRefs(); y->decRefs(); return x->str == y->str; }
template<> inline Bool $F_1(isSameObj)(Native x, Native y) { x->decRefs(); y->decRefs(); return x->nat == y->nat; }
\n", 
"", [], []),

Cpp3NativePlain("isStructName", true,
"inline Bool $F_1(isStructName)(String name);\n",
"inline Bool $F_1(isStructName)(String name) {
	Bool ret = (StructDefs::defs.find(name->str) != StructDefs::defs.end());
	name->decRefs();
	return ret;
}\n", "", [], ["struct_defs"]),

Cpp3NativePlain("voidValue", true,
"inline Flow $F_1(voidValue)();\n",
"inline Flow $F_1(voidValue)() {
	return void_value;
}\n", "", [], []),

Cpp3NativePlain("isArray", true,
"Bool $F_1(isArray)(Flow f);\n",
"inline Bool $F_1(isArray)(Flow f) {
	Bool ret = f->type() == Type::ARRAY;
	f->decRefs();
	return ret;
}\n", "", [], []),

Cpp3NativePlain("extractStructArguments", true,
"Vec<Flow> $F_1(extractStructArguments)(Flow f);\n",
"inline Vec<Flow> $F_1(extractStructArguments)(Flow f) {
	if (f->isStruct()) {
		PStr str = f->toAStr();
		std::vector<Flow> ret;
		ret.reserve(str->size());
		for (Int i = 0; i < str->size(); ++ i) {
			Flow field = str->getFlowField(i);
			field->incRefs();
			ret.push_back(field);
		}
		f->decRefs();
		return Vec<Flow>::make(std::move(ret));
	} else {
		f->decRefs();
		return Vec<Flow>::make();
	}
}\n", "", [], []),

Cpp3NativePlain("extractStructName", true,
"String $F_1(extractStructName)(Flow f);\n",
"inline String $F_1(extractStructName)(Flow f) {
	if (f->isStruct()) {
		String name = f->toAStr()->name();
		f->decRefs();
		return name;
	} else {
		f->decRefs();
		return String::make();
	}
}\n", "", [], []),

Cpp3NativePlain("runtimeValueType", true,
"String $F_1(runtimeValueType)(Flow f);\n",
"inline String $F_1(runtimeValueType)(Flow f) {
	switch (f->type()) {
		case Type::INT:    f->decRefs(); return String::make(u\"int\");
		case Type::BOOL:   f->decRefs(); return String::make(u\"bool\");
		case Type::DOUBLE: f->decRefs(); return String::make(u\"double\");
		case Type::STRING: f->decRefs(); return String::make(u\"string\");
		case Type::ARRAY:  f->decRefs(); return String::make(u\"array\");
		case Type::REF:    f->decRefs(); return String::make(u\"ref\");
		case Type::FUNC:   f->decRefs(); return String::make(u\"function\");
		case Type::NATIVE: f->decRefs(); return String::make(u\"native\");
		default:           f->decRefs(); return f->toAStr()->name();
	}
}\n", "", [], []),

Cpp3NativePlain("getDataTagForValue", true,
"Int $F_1(getDataTagForValue)(Flow f);\n",
"inline Int $F_1(getDataTagForValue)(Flow f) {
	switch (f->type()) {
		case Type::INT:    f->decRefs(); return 2;
		case Type::BOOL:   f->decRefs(); return 1;
		case Type::DOUBLE: f->decRefs(); return 3;
		case Type::STRING: f->decRefs(); return 4;
		case Type::ARRAY:  f->decRefs(); return 5;
		case Type::REF:    f->decRefs(); return 31;
		case Type::FUNC:   f->decRefs(); return 34;
		case Type::NATIVE: f->decRefs(); return 32;
		default:           f->decRefs(); return 6;
	}
}\n", "", [], [])

]