[

Cpp3NativePlain("toString", true,
"template<typename T> String* $F_1(toString)(T x);\n",
"template<typename T> inline String* $F_1(toString)(T x) { 
	return toStringRc(x);
}\n", "toStringRc($A_0)", [], []),

Cpp3NativePlain("toString2", true,
"String* $F_1(toString2)(Flow* x);\n",
"inline String* $F_1(toString2)(Flow* x) {
	return flow2stringRc(x);
}\n", "flow2stringRc($A_0)", [], []),

Cpp3NativePlain("isSameStructType", true,
"template<typename T1, typename T2> Bool $F_1(isSameStructType)(T1 x, T2 y);\n",
"template<typename T1, typename T2> Bool $F_1(isSameStructType)(T1 x, T2 y) {
	if constexpr (is_struct_v<T1> && is_struct_v<T2>) {
		return (x->typeIdRc() == y->typeIdRc());
	} else {
		decRc(x); decRc(y);
		return false;
	}
}
\n", "", [], []),

Cpp3NativePlain("makeStructValue", false,
"Flow* $F_1(makeStructValue)(String* name, Vec<Flow*>* args, Flow* defval);\n",
"Flow* $F_1(makeStructValue)(String* name, Vec<Flow*>* args, Flow* defval) {
	if (StructDefs::defs.find(name->str) == StructDefs::defs.end()) {
		return defval;
	} else {
		return StructDefs::defs.at(name->str).make(args);
	}
}\n", "", [], ["struct_defs"]),

Cpp3NativePlain("isSameObj", true,
"template<typename T> Bool $F_1(isSameObj)(T x, T y);\n",
"template<typename T> inline Bool $F_1(isSameObj)(T x, T y) {
	Bool ret = false;
	if constexpr (std::is_same_v<T, String*>) {
		ret = (x->str == y->str);
	} else {
		ret = (x == y);
	}
	decRc(x); decRc(y);
	return ret;
}
\n", 
"", [], []),

Cpp3NativePlain("isStructName", true,
"inline Bool $F_1(isStructName)(String* name);\n",
"inline Bool $F_1(isStructName)(String* name) {
	Bool ret = (StructDefs::defs.find(name->str) != StructDefs::defs.end());
	decRc(name);
	return ret;
}\n", "", [], ["struct_defs"]),

Cpp3NativePlain("voidValue", true,
"inline Flow $F_1(voidValue)();\n",
"inline Flow $F_1(voidValue)() {
	return void_value;
}\n", "", [], []),

Cpp3NativePlain("isArray", true,
"Bool $F_1(isArray)(Flow* f);\n",
"inline Bool $F_1(isArray)(Flow* f) {
	return f->typeIdRc() == TypeFx::ARRAY;
}\n", "", [], []),

Cpp3NativePlain("extractStructArguments", true,
"Vec<Flow*>* $F_1(extractStructArguments)(Flow* f);\n",
"inline Vec<Flow*>* $F_1(extractStructArguments)(Flow* f) {
	if (f->typeId()) {
		Vec<Flow*>* ret = Vec<Flow*>::make(str->size());
		for (Int i = 0; i < str->size(); ++ i) {
			Flow* field = str->getFlow(i);
			ret->push_back(field);
			rc(field, -1);
		}
		decRc(f);
		return ret;
	} else {
		decRc(f);
		return Vec<Flow>::make();
	}
}\n", "", [], []),

Cpp3NativePlain("extractStructName", true,
"String* $F_1(extractStructName)(Flow* f);\n",
"inline String* $F_1(extractStructName)(Flow* f) {
	if (f->isStruct()) {
		String name = f->toAStr()->name();
		decRc(f);
		return name;
	} else {
		decRc(f);
		return String::make();
	}
}\n", "", [], []),

Cpp3NativePlain("runtimeValueType", true,
"String* $F_1(runtimeValueType)(Flow* f);\n",
"inline String* $F_1(runtimeValueType)(Flow* f) {
	return String::make(RTTI::typeName(f->typeIdRc()));
}\n", "", [], []),

Cpp3NativePlain("getDataTagForValue", true,
"Int $F_1(getDataTagForValue)(Flow* f);\n",
"inline Int $F_1(getDataTagForValue)(Flow* f) {
	switch (f->typeIdRc()) {
		case TypeFx::INT:    return 2;
		case TypeFx::BOOL:   return 1;
		case TypeFx::DOUBLE: return 3;
		case TypeFx::STRING: return 4;
		case TypeFx::ARRAY:  return 5;
		case TypeFx::REF:    return 31;
		case TypeFx::FUNC:   return 34;
		case TypeFx::NATIVE: return 32;
		default:             return 6;
	}
}\n", "", [], [])

]