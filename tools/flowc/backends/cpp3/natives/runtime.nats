[

Cpp3NativePlain("for", true,
"template<typename T> T $F_1(for)(T v, Fun<Bool, T>* p, Fun<T, T>* fn);\n",
"template<typename T> T $F_1(for)(T v, Fun<Bool, T>* p, Fun<T, T>* fn) { 
	while (true) {
		incRc(v);
		if (!p->call(v)) {
			break;
		}
		incRc(v);
		v = fn->call(v);
	}
	decRc(p);
	decRc(fn);
	return v;
}\n\n", "", [], []),

Cpp3NativePlain("bitAnd", true,
"inline Int $F_1(bitAnd)(Int x, Int y);\n",
"inline Int $F_1(bitAnd)(Int x, Int y) { return x & y; }\n\n", 
"($A_0 & $A_1)", 
[], []),

Cpp3NativePlain("bitOr", true,
"inline Int $F_1(bitOr)(Int x, Int y);\n", 
"inline Int $F_1(bitOr)(Int x, Int y) { return x | y; }\n\n", 
"($A_0 | $A_1)", 
[], []),

Cpp3NativePlain("bitXor", true,
"inline Int $F_1(bitXor)(Int x, Int y);\n",
"inline Int $F_1(bitXor)(Int x, Int y) { return x ^ y; }\n\n", 
"($A_0 ^ $A_1)", 
[], []),

Cpp3NativePlain("bitNot", true,
"inline Int $F_1(bitNot)(Int x);\n",
"inline Int $F_1(bitNot)(Int x) { return ~x; }\n\n", 
"~$A_0", 
[], []),

Cpp3NativePlain("random", false,
"Double $F_1(random)();\n",
"Double $F_1(random)() {
	return static_cast<Double>(rand()) / (static_cast<Double>(RAND_MAX) + 1.0);
}\n", "", 
[Cpp3Std(["<cstdlib>"], [])], []),

Cpp3NativePlain("srand", true,
"inline Void $F_1(srand)(Int seed);\n",
"inline Void $F_1(srand)(Int seed) { srand(seed); return void_value; }\n\n", 
"", [Cpp3Std(["<cstdlib>"], [])], []),

Cpp3NativePlain("gc", true,
"inline Void $F_1(gc)();\n",
"inline Void $F_1(gc)() { return void_value; }\n\n", 
"", [], []),

Cpp3NativePlain("fail", false,
"Void $F_1(fail)(String* msg);\n",
"Void $F_1(fail)(String* msg) {
	std::cerr << msg->toStd() << std::endl;
	decRc(msg);
	exit(1);
	return void_value;
}\n", "", [], []),

Cpp3NativePlain("fail0", true,
"template<typename T> T $F_1(fail0)(String* msg);\n",
"template<typename T>
T $F_1(fail0)(String* msg) {
	std::cerr << msg->toStd() << std::endl;
	decRc(msg);
	exit(1);
}\n", "", [], []),

Cpp3NativePlain("quit", true,
"inline Void $F_1(quit)(Int code);\n",
"inline Void $F_1(quit)(Int code) { exit(code); return void_value; }\n\n", 
"", [Cpp3Std(["<cstdlib>"], [])], []),

Cpp3NativePlain("println2", false,
"Void $F_1(println2)(Flow* x);\n",
"Void $F_1(println2)(Flow* x) {
	if (x->typeId() == TypeFx::STRING) {
		std::string s = x->get<String*>()->toStd();
		decRc(x);
		std::cout << s << std::endl; 
	} else {
		String* s = flow2stringRc(x);
		std::cout << s->toStd() << std::endl;
		decRc(s);
	}
	return void_value;
}\n", "", [], []),

Cpp3NativePlain("hostCall", false,
"Flow* $F_1(hostCall)(String* name, Vec<Flow>* args);\n",
"Flow* $F_1(hostCall)(String* name, Vec<Flow>* args) {
	std::cerr << \"hostCall of '\" << name->toStd() <<  \"' is not yet implemented in cpp3 backend\" << std::endl;
	decRc(name); 
	decRc(args);
	//exit(1);
	return new FInt(0);
}\n", "", [], []),

Cpp3NativePlain("getFileContent", false,
"String* $F_1(getFileContent)(String* path);\n",
"String* $F_1(getFileContent)(String* path) {
	std::ifstream is(path->toStd(), std::ios::binary|std::ios::ate);
	decRc(path);
	if (is.is_open()) {
		std::size_t file_size = is.tellg();
		std::string buffer(file_size, '\0');
		is.seekg(0);
		if (is.read(&buffer[0], file_size)) {
			return String::make(buffer);
		} else {
			return String::make();
		}
	} else {
		return String::make();
	}
}\n", "", [Cpp3Std(["<fstream>"], [])], []),

Cpp3NativePlain("setFileContent", false,
"Bool $F_1(setFileContent)(String* path, String* content);\n",
"Bool $F_1(setFileContent)(String* path, String* content) {
	std::ofstream os(path->toStd(), std::ios::binary);
	decRc(path);
	std::string to_write = content->toStd();
	decRc(content);
	os.write(to_write.data(), to_write.size());
	return os.good();
}\n", "", [Cpp3Std(["<fstream>"], [])], []),

Cpp3NativePlain("timestamp", false,
"Double $F_1(timestamp)();\n",
"Double $F_1(timestamp)() {
	return std::chrono::duration_cast<std::chrono::milliseconds>(
		std::chrono::system_clock::now().time_since_epoch()
	).count();
}\n", "", [Cpp3Std(["<chrono>", "<ctime>"], [])], []),

Cpp3NativePlain("string2time", false,
"Double $F_1(string2time)(String* s);\n",
"Double $F_1(string2time)(String* s) {
	const std::time_get<char>& time_get = std::use_facet<std::time_get<char>>(std::locale());
	std::ios::iostate state;
	std::istringstream iss(s->toStd());
	decRc(s);
	const time_t rawtime = std::time(0);
	std::tm* when = localtime(&rawtime);
  	time_get.get(iss, std::time_get<char>::iter_type(), iss, state, when,
		date_time_format.data(), date_time_format.data() + date_time_format.length()
	);
	if (!(state & std::ios::ios_base::failbit)) {
		return mktime(when) * 1000.0;
	} else {
		return 0.0;
	}
}\n", "", [Cpp3Std(["<chrono>", "<ctime>"], [])], ["date_time_format"]),

Cpp3NativePlain("time2string", false,
"String* $F_1(time2string)(Double t);\n",
"String* $F_1(time2string)(Double t) {
	const std::time_put<char>& time_put = std::use_facet <std::time_put<char>>(std::locale());
  	std::time_t timestamp = t / 1000.0;
	std::tm* time = std::localtime(&timestamp);
	std::ostringstream out;
	time_put.put(out, out, ' ', time, date_time_format.data(), date_time_format.data() + date_time_format.length());
	return String::make(out.str());
}\n", "", [Cpp3Std(["<chrono>", "<ctime>"], [])], ["date_time_format"]),

Cpp3NativePlain("getApplicationPath", true,
"inline String* $F_1(getApplicationPath)();\n",
"inline String* $F_1(getApplicationPath)() {
	return String::make(std::filesystem::current_path().u16string());
}\n", "", [Cpp3Std(["<filesystem>"], [])], []),

Cpp3NativePlain("printCallstack", false,
"Void $F_1(printCallstack)();\n",
"Void $F_1(printCallstack)() {
	//std::cout << std::basic_stacktrace() << std::endl;
	std::cout << \"printCallstack is not yet implemented\" << std::endl;
	return void_value;
}\n", "", [], []),

Cpp3NativePlain("getKeyValueN", true,
"inline String* $F_1(getKeyValueN)(String* key, String* defval);\n",
"inline String* $F_1(getKeyValueN)(String* key, String* defval) { 
	decRc(key);
	return defval;
}\n\n", 
"", [], [])

]