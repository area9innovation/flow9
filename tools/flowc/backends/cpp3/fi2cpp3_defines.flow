import tools/flowc/manipulation/effects;
import tools/flowc/backends/common;

export {

Cpp3GlobalContext(
	config: FiCpp3Config,
	program: FiProgram,
	effects: FiEffects,
	// Transform a flow file name into a cpp3 file name
	flowfile2cpp: (string) -> string,
	// Index of all structs
	structs2id: Tree<string, int>,
	// type parameter representation in c++ source
	typar2cpp: (FiTypeParameter) -> string,
	// type name representation in c++ source
	typename2cpp: (string) -> string,
	// global name (function or variable) representation in c++ source
	varname2cpp: (string) -> string,
	// Native functions definition and other information
	natives: Tree<string, Cpp3Native>,
	// Parts of a shared runtime code
	runtimeParts: Tree<string, Cpp3RuntimePart>,
	// Variables, which initialization happens in main function (i.e. cannot be static)
	volatileVars: Set<string>,
	// Code of volatile variables initialization
	volatileInit: ref [string],
	// Error. Just error messages. Supposed to be empty.
	errors: ref [string],
	// Currently translated funciton/global variable. Used for debugging
	currentToplevel: Maybe<FiToplevel>,
	// Type parameters of a current toplevel. Used to replace implicit (dummy) typars
	toplevelTypars: Set<string>
);

Cpp3CompiledProgram(
	name: string, // main module name
	sources: [string], // names of all generated files
	qtDeps:  [Cpp3Qt], // Qt dependencies, used in program
	errors:  [string]
);

Cpp3CompiledModule(
	name: string,
	isMain: bool,      // indicates the module with main funciton
	decls: [Cpp3CompiledDeclaration], // the main contents of a compiled module
	imports: [string], // imports from flow module
	natives: [Cpp3Native] // natives, occured in module. Used to build and link with external dependencies
);

Cpp3CompiledDeclaration(
	name: string,
	headerOnly : bool, // whether this definition should be placed in *.hpp or in *.cpp
	forward: string,   // forward declaration
	definition: string // main contents - c++ code of definition
);

Cpp3Native(
	name: string,
	// Definition of native - it's c++ function implementation.
	// Arguments: first - type encoding (typename2cpp), second - var encoding (varname2cpp)
	declaration: ((string) -> string, (string) -> string) -> Cpp3CompiledDeclaration,
	// Possible inlining
	inline: Maybe<Cpp3Inline>,
	// External dependencies like <cmath>, which should be included like #include <cmath>
	dependencies: [Cpp3Dependency],
	// Runtime dependencies on the common parts of runtime (i.e. Cpp3RuntimePart)
	runtimeParts: [string]
);

Cpp3Inline(
	// construction of an inlined native call, first arg - call arguments, second arg - the type of a call
	def: ([string]) -> string,
);

Cpp3RuntimePart(
	// The name of a runtime part - some natives may share the same parts,
	// so they depend on a name, rather then on a source itself
	name: string,
	// Global definitions of a runtime part
	header: string,
	// A code, which is put in the main .cpp file (i.e. may use anything)
	source: string,
	// Possible initialization calls in main function
	mainInit: string,
	// Possible terminalization calls in main function
	mainTerm: string,
	// External dependencies like <cmath>, which should be included like #include <cmath>
	dependencies: [Cpp3Dependency],
	// If true, the source of the part goes into main module.
	staysInMain: bool
);

Cpp3NativePlain(
	name: string,
	// whether this definition should be placed in *.hpp or in *.cpp
	headerOnly : bool,
	// forward declaration
	forward: string,
	// Definition of native - it's c++ function implementation.
	// Arguments: first - type encoding (typename2cpp), second - var encoding (varname2cpp)
	definition: string,
	// Possible inlining
	inline: string,
	// External dependencies like <cmath>, which should be included like #include <cmath>
	dependencies: [Cpp3Dependency],
	// Runtime dependencies on the common parts of runtime (i.e. Cpp3RuntimePart)
	runtimeParts: [string]
);

Cpp3Dependency ::= Cpp3Std, Cpp3Qt;
	// Default dependency on stadard library
	Cpp3Std(
		includes: [string], // like <cmath>, etc.
		libs: [string]      // like -lglu32, etc.
	);
	// Dependency on some Qt entity
	Cpp3Qt(
		includes: [string], // like <QProcess>
		opts: [Cpp3QtOpt]
	);
	// Example of Qt option:
	// win32:contains(QMAKE_TARGET.arch, x86_64) {
    //    CONFIG += use_jit
    // }
	//
	Cpp3QtOpt(
		condition: string, // Like: win32:contains(QMAKE_TARGET.arch, x86_64)
		name: string,      // Like: QT, LIBS, CONFIG, etc.
		sign: string,      // Like +=, -=, =, etc.
		value: [string]    // Like use_jit
	);
}
