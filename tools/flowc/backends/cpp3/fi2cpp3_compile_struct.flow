import tools/flowc/backends/cpp3/fi2cpp3_compile_type;

export {
	fiStruct2cpp3(struct: FiTypeStruct, gctx0: Cpp3GlobalContext, only_decl: bool) -> string;
	fiStruct2cpp3_new(struct: FiTypeStruct, gctx0: Cpp3GlobalContext, only_decl: bool) -> string;
}

fiStruct2cpp3_new(struct: FiTypeStruct, gctx0: Cpp3GlobalContext, only_decl: bool) -> string {
	gctx = Cpp3GlobalContext(
		gctx0 with currentToplevel = Some(struct),
		toplevelTypars = fold(struct.typars, makeSet(), \acc, tp -> fiCollectTypars(tp, acc))
	);
	struct_name = gctx.typename2cpp(struct.name);
	struct_id = eitherMap(lookupTree(gctx.structs2cpp, struct.name), \str -> i2s(str.id), "");
	fiDeclTypars2cpp3(struct.typars, gctx) + 
	"using " + struct_name + " = Str<" + struct_id + ", " + superglue(struct.args, \arg -> fiType2cpp3(arg.type, gctx), ", ") + ">;\n\n";
}

fiStruct2cpp3(struct: FiTypeStruct, gctx0: Cpp3GlobalContext, only_decl: bool) -> string {
	gctx = Cpp3GlobalContext(
		gctx0 with currentToplevel = Some(struct),
		toplevelTypars = fold(struct.typars, makeSet(), \acc, tp -> fiCollectTypars(tp, acc))
	);
	struct_name = gctx.typename2cpp(struct.name);
	struct_id = eitherMap(lookupTree(gctx.structs2cpp, struct.name), \str -> i2s(str.id), "");
	names = gctx.program.names;
	typars = struct.typars;
	decl_typars = fiDeclTypars2cpp3(typars, gctx);
	if (only_decl) {
		decl_typars + "struct " + struct_name + ";\n\n";
	} else {
		static_id = "enum { ID = " + struct_id + ", SIZE = " + i2s(length(struct.args)) + " };"; 
		field_types = supergluei(struct.args, 
			\i, arg -> "typedef " + fiType2cpp3(arg.type, gctx) + " " + "FieldType_" + i2s(i) + ";",
			"\n"
		);
		static_instance = if (length(struct.args) > 0) "" else {
			"static Str<" + struct_name + "> instance() {\n" +
				"\tstatic Str<" + struct_name + "> inst = Str<" + struct_name + ">::make();\n" +
				"\treturn inst;\n" +
			"}";
		}

		constructor_init = if (length(struct.args) == 0) "" else {
			": " + superglue(struct.args, \arg -> gctx.varname2cpp(arg.name) + "(__" + gctx.varname2cpp(arg.name) + ")", ", ");
		}
		inc_fields = filtermap(struct.args, \arg ->
			if (fiTypeIsScalar(arg.type)) None() else {
				Some("RefCount<" + fiType2cpp3(arg.type, gctx) + ">::inc(" + gctx.varname2cpp(arg.name) + ");");
				/*switch (arg.type) {
					FiTypeParameter(__):
						Some("RefCount<" + fiType2cpp3(arg.type, gctx) + ">::dec(" + gctx.varname2cpp(arg.name) + ");");
					default:
						Some(gctx.varname2cpp(arg.name) + "->decRefs();");
				}*/
			}
		);
		constructor = struct_name + 
		"(" + 
			superglue(struct.args, \arg -> fiType2cpp3(arg.type, gctx) + " __" + gctx.varname2cpp(arg.name), ", " ) + 
		") " + constructor_init + " {" + 
			(if (length(inc_fields) == 0) " " else
				"\n" +
					strIndent(strGlue(inc_fields, "\n")) +
				"\n"
			) + 
		"}";
		dec_fields = filtermap(struct.args, \arg ->
			if (fiTypeIsScalar(arg.type)) None() else {
				Some("RefCount<" + fiType2cpp3(arg.type, gctx) + ">::dec(" + gctx.varname2cpp(arg.name) + ");");
				/*switch (arg.type) {
					FiTypeParameter(__):
						Some("RefCount<" + fiType2cpp3(arg.type, gctx) + ">::dec(" + gctx.varname2cpp(arg.name) + ");");
					default:
						Some(gctx.varname2cpp(arg.name) + "->decRefs();");
				}*/
			}
		);
		destructor = if (length(dec_fields) == 0) "" else "~" + struct_name + "() {\n" +
			strIndent(strGlue(dec_fields, "\n")) +
		"\n}";

		abstract_constructor =
		"\tstatic Str<" + struct_name + "> fromAStr(PStr p) {\n" + 
			"\t\treturn Str<" + struct_name + ">::make(" + 
				supergluei(struct.args, \i, arg -> 
					"Cast<Flow>::template To<" + fiType2cpp3(arg.type, gctx) + ">::conv(p->getFlowField(" + i2s(i) + "))", ", "
				) + 
			");\n" +
		"\t}\n";
		flow_constructor = 
		"\tstatic Str<" + struct_name + "> fromFlowArgs(Vec<Flow> fs) {\n" + 
			"\t\treturn Str<" + struct_name + ">::make(" + 
				supergluei(struct.args, \i, arg -> 
					"Cast<Flow>::template To<" + fiType2cpp3(arg.type, gctx) + ">::conv(fs->getItem(" + i2s(i) + "))", ", "
				) + 
			");\n" +
		"\t}\n";
		move_constructor = if (length(struct.args) == 0) "" else 
		"\t" + struct_name + "(" + struct_name + "&& s): " + 
			superglue(struct.args, \arg -> gctx.varname2cpp(arg.name) + "(std::move(s." + gctx.varname2cpp(arg.name) + "))", ", " ) + 
		" { }\n";

		assignment_operator = if (length(struct.args) == 0) "" else 
		"\t" + struct_name + "& operator = (const " + struct_name + "& s) { " + 
			superglue(struct.args, \arg -> gctx.varname2cpp(arg.name) + " = s." + gctx.varname2cpp(arg.name) + ";", " " ) + 
		" return *this; }\n";
		assignment_move = if (length(struct.args) == 0) "" else 
		"\t" + struct_name + "& operator = (" + struct_name + "&& s) { " + 
			superglue(struct.args, \arg -> gctx.varname2cpp(arg.name) + " = std::move(s." + gctx.varname2cpp(arg.name) + ");", " " ) + 
		" return *this; }\n";

		fields = concatStrings(map(struct.args, \arg -> 
			"\t" + (if (arg.ismutable) "mutable " else "") + fiType2cpp3(arg.type, gctx) + " " + gctx.varname2cpp(arg.name) + ";\n"
		));
		compare = "Int compare(Str<" + struct_name + "> s) const {\n" +
			concatStrings(mapi(struct.args, \i, arg ->
				"\tInt c" + i2s(i) + " = Compare<" + fiType2cpp3(arg.type, gctx) + ">::cmp(" + 
					gctx.varname2cpp(arg.name) + ", " + 
					"s->" + gctx.varname2cpp(arg.name) + 
				"); " + 
				"if (c" + i2s(i) + " != 0) return c" + i2s(i) + ";\n",
			)) + 
			"\treturn 0;"
		"\n}";

		get_field_1 = "Flow getFlowField(String name) const override {\n" +
			(if (length(struct.args) == 0) {
				"\tstd::cerr << \"unknown field \" << name->toStd() << \" in struct '" + struct_name +"'\" << std::endl;\n" + 
				"\texit(1);\n" +
				"\treturn nullptr;";
			} else {
				strIndent(
					supergluei(struct.args, 
						\i, arg -> {
							getter = gctx.varname2cpp(arg.name);
							if (i == 0) {
								"if (name->str == u\"" + arg.name + "\") {\n" +
									"\treturn Cast<Flow>::template From<" + fiType2cpp3(arg.type, gctx) + ">::conv(" + getter + ");" +
								"\n} "
							} else {
								"else if (name->str == u\"" + arg.name + "\") {\n" +
									"\treturn Cast<Flow>::template From<" + fiType2cpp3(arg.type, gctx) + ">::conv(" + getter + ");" +
								"\n} "
							}
						}, "\n"
					) + "else {\n" +
						"\tstd::cerr << \"unknown field \" << name->toStd() << \" in struct '" + struct_name +"'\" << std::endl;\n" + 
						"\texit(1);\n" +
						"\treturn nullptr;"
					"\n}"
				);
			}) +
		"\n}";
		get_field_2= "Flow getFlowField(Int i) const override {\n" +
			(if (length(struct.args) == 0) {
				"\tstd::cerr << \"illegal field index \" << i << \" in struct '" + struct_name +"'\" << std::endl;\n" + 
				"\texit(1);\n" +
				"\treturn nullptr;";
			} else {
				strIndent(
					supergluei(struct.args, 
						\i, arg -> {
							getter = gctx.varname2cpp(arg.name);
							if (i == 0) {
								"if (i == " + i2s(i) + ") {\n" +
									"\treturn Cast<Flow>::template From<" + fiType2cpp3(arg.type, gctx) + ">::conv(" + getter + ");" +
								"\n} "
							} else {
								"else if (i == " + i2s(i) + ") {\n" +
									"\treturn Cast<Flow>::template From<" + fiType2cpp3(arg.type, gctx) + ">::conv(" + getter + ");" +
								"\n} "
							}
						}, "\n"
					) + "else {\n" +
						"\tstd::cerr << \"illegal field index \" << i << \" in struct '" + struct_name +"'\" << std::endl;\n" + 
						"\texit(1);\n" +
						"\treturn nullptr;"
					"\n}"
				);
			}) +
		"\n}";


		mutable_fields = filter(struct.args, \arg -> arg.ismutable);
		set_field_1 = "void setFlowField(String name, Flow val) const override {\n" +
			(if (length(mutable_fields) == 0) {
				"\tstd::cerr << \"unknown field \" << name->toStd() << \" in struct '" + struct_name +"'\" << std::endl;\n" + 
				"\texit(1);\n"
			} else {
				strIndent(
					supergluei(mutable_fields, 
						\i, arg -> {
							setter = gctx.varname2cpp(arg.name) + " = Cast<Flow>::template To<" + fiType2cpp3(arg.type, gctx) + ">::conv(val);";
							if (i == 0) {
								"if (name->str == u\"" + arg.name + "\") {\n" +
									"\t" + setter +
								"\n} "
							} else {
								"else if (name->str == u\"" + arg.name + "\") {\n" +
									"\t" + setter +
								"\n} "
							}
						}, "\n"
					) + "else {\n" +
						"\tstd::cerr << \"unknown field \" << name->toStd() << \" in struct '" + struct_name +"'\" << std::endl;\n" + 
						"\texit(1);\n"
					"\n}"
				);
			}) +
		"\n}";
		set_field_2 = "void setFlowField(Int i, Flow val) const override {\n" +
			(if (length(mutable_fields) == 0) {
				"\tstd::cerr << \"illegal mutable field index \" << i << \" in struct '" + struct_name +"'\" << std::endl;\n" + 
				"\texit(1);\n"
			} else {
				strIndent(
					supergluei(struct.args, 
						\i, arg -> {
							setter = gctx.varname2cpp(arg.name) + " = Cast<Flow>::template To<" + fiType2cpp3(arg.type, gctx) + ">::conv(val);";
							if (arg.ismutable) {
								if (i == 0) {
									"if (i == " + i2s(i) + ") {\n" +
										"\t" + setter +
									"\n} "
								} else {
									"else if (i == " + i2s(i) + ") {\n" +
										"\t" + setter +
									"\n} "
								}
							} else {
								"if (i == " + i2s(i) + ") {\n" +
									"\tstd::cerr << i << \" field is immutable in struct '" + struct_name +"'\" << std::endl;\n" + 
									"\texit(1);\n"
								"\n} "
							}
						}, "\n"
					) + "else {\n" +
						"\tstd::cerr << \"illegal field index \" << i << \" in struct '" + struct_name +"'\" << std::endl;\n" + 
						"\texit(1);\n"
					"\n}"
				);
			}) +
		"\n}";

		cast_to = "template<typename N>\n" +
		"Str<N> cast() {\n" +
			"\treturn Str<N>::make(\n" + 
				supergluei(struct.args, \i, field -> "\t\tCast<FieldType_" + i2s(i) + ">::template To<typename N::FieldType_" + i2s(i) + ">::conv(" + gctx.varname2cpp(field.name) + ")", ",\n") + 
			"\n\t);\n" +
		"}";

		struct_def = "static StructDef def() {\n" + strIndent(fiStruct2DefCpp3(struct, gctx)) + "\n}";

		decl_typars + "struct " + struct_name + ": public AStr {\n" +
		"\tenum { TYPE = Type::STRUCT };\n" +
		strIndent(static_id) + "\n" +
		strIndent(field_types) + "\n" +
		(if (static_instance == "") "" else strIndent(static_instance) + "\n") +
		(if (constructor == "") "" else strIndent(constructor)) + "\n" +
		(if (move_constructor == "") "" else move_constructor) +
		(if (abstract_constructor == "") "" else abstract_constructor) +
		flow_constructor + 
		strIndent(struct_def) + "\n" + 
		(if (destructor == "") "" else strIndent(destructor)) + "\n" +
		"\tInt type() const override { return ID; }\n" +
		"\tString name() const override { return String::make(\"" + struct.name + "\"); }\n" +
		"\tInt size() const override { return SIZE; }\n" +
		strIndent(get_field_1) + "\n" +
		strIndent(get_field_2) + "\n" +
		strIndent(set_field_1) + "\n" +
		strIndent(set_field_2) + "\n" +
		strIndent(compare) + "\n" + 
		strIndent(cast_to) + "\n" +
		(if (fields == "") "" else fields) +
		"};\n\n";
	}
}

fiStruct2DefCpp3(struct : FiTypeStruct, gctx0: Cpp3GlobalContext) -> string {
	gctx = Cpp3GlobalContext(
		gctx0 with currentToplevel = Some(struct),
		toplevelTypars = buildSet(filtermap(struct.typars, \tp ->
			switch (tp) {
				FiTypeParameter(nm): Some(nm);
				default: None();
			}
		))
	);
	struct_name = fiStructName2cpp3(FiTypeName(struct.name, struct.typars), gctx);
	constructor = "[](Vec<Flow> args) { return " + struct_name + "::fromFlowArgs(args); }";
	fields = if (struct.args == []) "std::vector<FieldDef>()" else {
		"std::vector" + fiWrapWithBraces(
			superglue(struct.args, \arg  -> 
				"FieldDef{u\"" + arg.name + "\", u\"" + fiType2cpp3(arg.type, gctx) +"\", " + b2s(arg.ismutable) + "}", 
				", "
			)
		);
	}
	"return StructDef { ID,\n" +
		strIndent(constructor) + ",\n" +
		strIndent(fields) +
	"\n};";
}
