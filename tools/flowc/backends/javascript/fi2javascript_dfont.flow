import tools/flowc/backends/common;
import formats/json/json;
import formats/uri2/uri2;

export {
	FiDFontConfig(
		name : string,
		url : string,
		embed : bool,
		path : string,
		baseurl : string);
	fiParseDFontConfigJson(dfontJson : Json) -> FiDFontConfig;
	fiEmbedDFont(dfont : FiDFontConfig, resourceprefix : string, resourcesuffix : string, includes : [string]) -> Pair<string,string>;
	fiPrepareDFonts(cfg : FiJsConfig) -> Pair<[string], [string]>;
}

fiParseDFontConfigJson(dfontJson : Json) {
	name = getJsonStringField(dfontJson, "name", "");
	url = getJsonStringField(dfontJson, "url", "");
	embed = getJsonBoolField(dfontJson, "embed", false);
	baseurl = getJsonStringField(dfontJson, "baseurl", "");
	path = getJsonStringField(dfontJson, "path", "");

	FiDFontConfig(name, url, embed, path, baseurl);
}

searchInDirs(relpath : string, dirs : [string]) {
        if (fileExists(relpath)) relpath
        else {
                dir = findDef(dirs, \dirname -> fileExists(pathCombine(dirname, relpath)), "");
                if (dir != "") pathCombine(dir, relpath) else "";
        }
}

fiEmbedDFont(dfont : FiDFontConfig, resourceprefix : string, resourcesuffix : string, includes : [string]) {
	// TODO: stub, formats/uri/uri forbidden via grammar2codes
	content =
	if (dfont.path != "") {
		path = searchInDirs(dfont.path, includes);
		if (path != "")	getFileContent(path) else "";
	} else {
		// TODO: Download file if it's a url
		// content = downloadFile(dfont.url);
		""
	}

	if (content != "") {
		indexjson = parseJson(content);

		basepath =
		if (dfont.baseurl != "") {
			dfont.baseurl
		} else {
			// strip off any file, query string and fragment from the font url
			uri = parseURI(dfont.url);
			uri2string(URI(uri.scheme, uri.authority, dirName(uri.path) + "/", "", ""))
		}

		// Save the json to a temp file
		basefn = dfont.name + "_index";
		tmpfile = resourceprefix + basefn + resourcesuffix;

		setJsonField(indexjson, "basepath", JsonString(basepath))
		|> (\json -> setJsonField(json, "crossOrigin", JsonBool(false)))
		|> (\json -> saveFileContent(tmpfile, json2string(json)));

		Pair(tmpfile, "@" + dfont.name);
	} else {
		fcPrintln("WARNING: Could not read font file: " + dfont.path);
		Pair("","");
	}
}

fiPrepareDFonts(cfg : FiJsConfig) {
	fontSetup = [
		Pair("dfonts", "@dfonts"),
		Pair("styles", "@fontstyles"),
		Pair("webfontconfig", "@webfontconfig")
	];

	resourcesuffix = "_tmp.json";
	resourceprefix = "_";

	jf = getFileContent(cfg.fontconfig);
	if (jf == "") {
		fcPrintln("WARNING: Could not read font config file: " + cfg.fontconfig);
	}
	jsn = parseJson(jf);

	res1 = fold(fontSetup, [], \acc, e -> {
		v = getJsonFieldValue(jsn, e.first, JsonNull());
		if (v != JsonNull()) {
			fl_name = resourceprefix + e.first + resourcesuffix;
			saveFileContent(fl_name, json2string(v));
			arrayPush(acc, Pair(fl_name, e.second));
		} else acc
	});

	// Embed the dfont index files
	dfontsJson = getJsonArrayValue(getJsonFieldValue(jsn, "dfonts", JsonNull()), []);
	res2 = fold(dfontsJson, [], \acc, dfontJson -> {
		dfont = fiParseDFontConfigJson(dfontJson);
		if (dfont.embed) {
			p = fiEmbedDFont(dfont, resourceprefix, resourcesuffix, cfg.includes);
			if (p.first != "") arrayPush(acc, p) else acc
		} else
			acc;
	});

	res = concat(res1, res2);
	tmpfiles = map(res, \p -> p.first);
	args = concatA(map(res, \p -> ["-resource " + p.first + p.second]));

	Pair(tmpfiles, args);
}
