import tools/flowc/backends/javascript/fi2javascript_utils;
import string_utils;
import sys/process;

export {
	fiLinkExternalJsDependencies(program : FiProgram, cfg : FiJsConfig, ovl : FiJsOverlayGroup, programCode : string) -> bool;
}

fiLinkExternalJsDependencies(program : FiProgram, cfg : FiJsConfig, ovl : FiJsOverlayGroup, programCode : string) -> bool {
	hasRequire = ovl.requireList != [];
	outfile = (if (hasRequire) cfg.modules + "/" else "") + cfg.outputfile;
	dir = if (strContains(outfile, "/")) dirName(outfile) else ".";
	success = ref true;
	saved_ok = \msg -> {
		fcVerbose(cfg, 1, "File saved." + (if (msg == "") "" else "\n" + msg));
		jsmode = fiJavascriptMode(cfg);
		fcVerbose(cfg, 0, "Javascript (" + jsmode+ ") '" + resolveRelativePath(cfg.outputfile) + "' saved.");
	}
	saved_failed = \msg -> {
		fcPrintln("Javascript (" + fiJavascriptMode(cfg)+ ") '" + resolveRelativePath(cfg.outputfile) + "' was NOT saved:\n" + msg, cfg.threadId);
		success := false;
	}

	extern_deps = filter(cfg.dependencies, \p -> containsSet(ovl.nativeClasses, p.host));

	if (length(extern_deps) == 0) {
		// Just save a resulting file.
		fcVerbose(cfg, 1, "Saving output file...");
		saveFileContent(outfile, programCode, cfg.threadId);
		saved_ok("");
	} else {
		conf_dir = lookupTreeDef(program.config.config, "confdir", "");
		if (!checkProvidersAreInstalled(cfg, conf_dir)) {
			saved_failed("Cannot bundle dependencies.");
			success := false;
		} else {
			fcVerbose(cfg, 1, "Linking output file...");

			extern_imports = map(extern_deps, \dep -> {
				// In case some dependencies are missing - get it, install and use.
				ensurePackageIsLoaded(program, dep, dir, cfg, success, conf_dir);
				"import * as " + dep.host + " from '" + dep.package + "';\n"
			});
			if (^success) {
				imports = concatStrings(extern_imports);
				js_file = changeFileExt(outfile, "") + "__1.js";
				saveFileContent(js_file, imports + programCode, cfg.threadId);
				args0 = ["--bundle", "--outfile=" + outfile,
					// this option is added to suppress warnings about using 'this' in ECMAScript module
					"--define:this=undefined",
					js_file];
				args = if (cfg.jsmode != NODEJS_MODE) args0 else concat(args0, ["--platform=node"]);
				fcVerbose(cfg, 0, "Linking the package with esbuild ...");
				result = execSystemCommandOutput(cfg, "esbuild", args, dir);
				if (fileExists(js_file)) {
					err = deleteFile(js_file);
					if (err != "") {
						fcPrintln(err, cfg.threadId);
					}
				}
				if (result.exitCode != 0) {
					saved_failed(result.stdall);
				} else {
					saved_ok(result.stdall);
				}
			}
		}
	}
	^success;
}

ensurePackageIsLoaded(program : FiProgram, dep : FiJsDependency, dir : string, cfg : FiJsConfig, success : ref bool, conf_dir : string) -> void {
	provider_list = execSystemCommandOutput(cfg, dep.provider, ["list"], dir);
	if (provider_list.exitCode != 0) {
		fcPrintln("Failed to run '" + dep.provider + " list'. Check that " + dep.provider + " is installed:\n" + provider_list.stdall, cfg.threadId);
		success := false;
	} else {
		if (strContains(provider_list.stdout, dep.package)) {
			fcVerbose(cfg, 1, "Package " + dep.package + " is already installed.");
		} else {
			if (dep.provider != "file") {
				// Install an external dependency via a package manager
				fcVerbose(cfg, 0, "Package " + dep.package + " is not yet installed. Going to install it.");
				install_command = if (dep.provider == "npm") "install" else if (dep.provider == "yarn") "add" else "";
				provider_install = execSystemCommandOutput(cfg, dep.provider, [install_command, dep.package], dir);
				if (provider_install.exitCode != 0) {
					fcPrintln("Failed to run '" + dep.provider + " " + install_command + " " + dep.package + "'. Check that " + dep.provider + " is installed:\n" + provider_install.stdall, cfg.threadId);
					success := false;
				} else {
					fcVerbose(cfg, 0, "Package " + dep.package + " is successfully installed.\n" + provider_install.stdout);
				}
			} else {
				dep_file = relatingPath(dep.package, conf_dir);
				if (!fileExists(dep.package)) {
					fcPrintln("File with natives definitions: '" + dep.package + "' doesn't exist", cfg.threadId);
					success := false;
				} else {
					ts_natives = getFileContent(dep.package);
					switch (findModuleWithNativeHost(program, dep.host)) {
						Some(natives_module): {
							// Save the *.d.ts - definitions of TypeSctipt types, corresponding to flow types in natives_module.
							ts_d_file = changeFileExt(dep_file, "-types.d.ts");
							struct_unions = fiStructOrUnionsInNatives(program, natives_module);
							if (!setFileContent(ts_d_file, fiStructOrUnions2Ts(struct_unions))) {
								success := false;
								fcPrintln("Failed to save file: '" + ts_d_file + "'", cfg.threadId);
							} else {
								fcVerbose(cfg, 1, "File '" + ts_d_file + "' is saved.");
							}
							if (^success) {
								// Insert the import of *.d.ts into the native host sources.
								import_str = "import * as typenames from \"" + fileNameOnly(changeFileExt(ts_d_file, "")) + "\";\n";
								if (!startsWith(ts_natives, import_str)) {
									if (!setFileContent(dep.package, import_str + ts_natives)) {
										fcPrintln("Failed to update file '" + dep.package + "' with '" + import_str + "'", cfg.threadId);
										success := false;
									} else {
										fcVerbose(cfg, 1, "File '" + dep.package + "' is updated with '" + import_str + "'");
									}
								}
								if (^success) {
									// Check typescript files with tsc compiler
									if (endsWith(dep.package, ".ts")) {
										tsc_check = execSystemCommandOutput(cfg, "tsc", ["--noEmit", "-t", "es6", dep.package], dir);
										if (tsc_check.exitCode != 0) {
											fcPrintln("Failed to check types in '" + dep.package + "':\n" + tsc_check.stdall, cfg.threadId);
											success := false;
										} else {
											fcVerbose(cfg, 0, "Types in '" + dep.package + "' are checked successfully.");
										}
									}
									if (^success) {
										// Installing a local dependency from file with yarn
										args = ["add", "file:" + dirName(dep.package)];
										file_install = execSystemCommandOutput(cfg, "yarn", args, dir);
										if (file_install.exitCode != 0) {
											success := false;
											fcPrintln(
												"Failed to run 'yarn " + strGlue(args, " ") + "'. Check that yarn is installed:\n" +
												strIndent(file_install.stdall),
												cfg.threadId
											);
										} else {
											fcVerbose(cfg, 0, "Package " + dep.package + " is successfully installed.\n" + file_install.stdout);
										}
									}
								}
							}
						}
						None(): {
							fcPrintln("No natives flow module for native host '" + dep.host + " are found.", cfg.threadId);
							success := false;
						}
					}
				}
			}
		}
	}
}

findModuleWithNativeHost(prog: FiProgram, host : string) -> Maybe<FiModule> {
	find(getTreeValues(prog.modules), \module ->
		exists(module.natives, \nat -> startsWith(nat.nativeName, host + "."))
	);
}

// Checks if a string has a form of groups of digits, separated by dots like: 8.1.2 or 0.13.13
stringIsVersion(v0 : string) -> bool {
	v1 = trim2(toLowerCase(v0), " \n\r\t");
	ver = if (startsWith(v1, "version")) trim2(substring(v1, 7, strlen(v1) - 7), " \n\r\t") else v1;
	ver != "" && stringCharsFold(ver, true, \acc, char ->
		if (!acc) acc else isDigit(char) || char == "."
	);
}

checkProgramIsInstalled(cfg : FiJsConfig, prog : string) -> bool {
	prog_version = execSystemCommandOutput(cfg, prog, ["--version"], ".");
	if (prog_version.exitCode == 0 && prog_version.stderr == "" && stringIsVersion(prog_version.stdout)) {
		fcVerbose(cfg, 1, prog + " version is: " + prog_version.stdout);
		true
	} else {
		fcPrintln("Seems that '" + prog + "' is not installed. Please install it.", cfg.threadId);
		false;
	}
}

execSystemCommandOutput(cfg : FiJsConfig, command : string, args : [string], currentWorkingDirectory : string) -> SystemProcessOutput {
	result = if (windows()) {
		execSystemProcessOutput("cmd", concat(["/c", command], args), currentWorkingDirectory);
	} else {
		execSystemProcessOutput(command, args, currentWorkingDirectory);
	}
	if (result.exitCode != 0 || result.stderr != "") {
		fcPrintln(
			"error code: " + i2s(result.exitCode) + "\n"
			"stdout: " + result.stdout + "\n"
			"stderr: " + result.stderr,
			cfg.threadId
		);
	}
	result;
}

checkProvidersAreInstalled(cfg : FiJsConfig, conf_dir : string) -> bool {
	providers = uniq(map(cfg.dependencies, \dep -> dep.provider));
	all(map(providers, \provider -> {
		if (provider == "file") true else
		if (provider == "yarn") {
			if (!checkProgramIsInstalled(cfg, provider)) false else {
				if (fileExists(pathCombine(conf_dir, "yarn.lock"))) true else {
					/*
					Make a package.json with a format like that: (no repository)
					{
						"name": "my-existing-package",
						"version": "0.1",
						"description": "I exist therefore I am.",
						"license": "BSD-2-Clause"
						}
					*/
					package_json = JsonObject([
						Pair("name", JsonString(cfg.flowfile)),
						Pair("version", JsonString("0.0.1")),
						Pair("description", JsonString(cfg.flowfile)),
						Pair("license", JsonString("MIT"))
					]);
					setFileContent(pathCombine(conf_dir, "package.json"), json2string(package_json));
					yarn_install = execSystemCommandOutput(cfg, "yarn", ["install"], conf_dir);
					ret = yarn_install.exitCode == 0;
					if (!ret) {
						fcPrintln("Failed to run 'yarn install':\n" + yarn_install.stdall, cfg.threadId);
					}
					fcVerbose(cfg, 1, "Command 'yarn install' is completed.");
					ret;
				}
			}
		} else {
			checkProgramIsInstalled(cfg, provider);
		}
	})) && checkProgramIsInstalled(cfg, "esbuild");
}


fiType2TsType(type : FiType) -> string {
	switch (type) {
		FiTypeArray(t): {
			fiType2TsType(t) + "[]";
		}
		FiTypeFunction(args, rt): {
			"(" + superglue(args, \arg -> fiType2TsType(arg.type), ", ") + ") => " + fiType2TsType(rt);
		}
		FiTypeRef(t): {
			"Ref<" + fiType2TsType(t) + ">";
		}
		FiTypeParameter(n): "P_" + i2s(strlen(n));
		FiTypeBool():    "boolean";
		FiTypeInt():     "number";
		FiTypeDouble():  "number";
		FiTypeString():  "string";
		FiTypeFlow():    "any";
		FiTypeVoid():    "void";
		FiTypeNative():  "any";
		FiTypeName(n, typars): {
			n + fiTypars2Ts(typars);
		}
	}
}

fiTypars2Ts(typars : [FiType]) -> string {
	if (length(typars) == 0) "" else
		"<" + superglue(typars, \t -> fiType2TsType(t), ", ") + ">";
}

fiTypeStruct2Ts(type : FiTypeStruct) -> string {
	"type " + type.name + fiTypars2Ts(type.typars) + " = {\n" +
	"\tname: string;\n" +
	"\t_id: number;\n" +
	concatStrings(map(type.args, \arg -> "\t" + arg.name + ": " + fiType2TsType(arg.type) + ";\n")) +
	"}\n";
}

fiTypeUnion2Ts(type : FiTypeUnion) -> string {
	"type " + type.name + fiTypars2Ts(type.typeparameters) + " = " +
	superglue(type.typenames, \tn -> fiType2TsType(tn), " | ") +
	";";
}

fiStructOrUnionsInNatives(program : FiProgram, module : FiModule) -> [FiStructOrUnion] {
	map(
		list2array(fold(module.natives, makeList(), \acc, nat ->
			fiTypenamesInType(acc, nat.type)
		)),
		\name -> {
			switch (lookupTree(program.names.structs, name)) {
				Some(str): str;
				None():
					switch (lookupTree(program.names.unions, name)) {
						Some(un): un;
						None(): {
							fail("never must happen");
							dummyFiTypeStruct;
						}
					}
			}
		}
	);
}

fiTypenamesInType(acc : List<string>, tp : FiType) -> List<string> {
	switch (tp) {
		FiTypeArray(t):
			fiTypenamesInType(acc, t);
		FiTypeFunction(args, rt):
			fold(args, fiTypenamesInType(acc, rt), \ac, arg -> fiTypenamesInType(ac, arg.type));
		FiTypeRef(t):
			fiTypenamesInType(acc, t);
		FiTypeName(name, typars):
			fold(typars, Cons(name, acc), fiTypenamesInType);
		default:
			acc;
	}
}

fiStructOrUnions2Ts(types : [FiStructOrUnion]) -> string {
	structs = filtermap(types, \tp -> switch (tp) {
		FiTypeStruct(__,__,__,__): Some(tp);
		FiTypeUnion(__,__,__,__): None();
	});
	unions = filtermap(types, \tp -> switch (tp) {
		FiTypeStruct(__,__,__,__): None();
		FiTypeUnion(__,__,__,__): Some(tp);
	});
	ts_structs = superglue(structs,
		\struct -> "export " + fiTypeStruct2Ts(struct),
		"\n"
	);
	ts_unions = superglue(unions,
		\union -> "export " + fiTypeUnion2Ts(union),
		"\n"
	);
	"export type Ref<T> = {\n" +
	"\t __v: T;\n" +
	"}\n" +
	ts_structs + (if (ts_unions == "") "" else "\n\n" + ts_unions);
}
