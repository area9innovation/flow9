//import lingo/pegcode/driver;
import lingo/pegcode/pegcode;
import lingo/compiler/syntaxtree_util;
import tools/flowc/backends/common;
import tools/flowc/backends/java/parser/java_parser;
import tools/flowc/backends/java/parser/java_ast;

export {
	// Parse all java files with classes derived from 'NativeHost' from config and find all their public methods.
	fi2javaNatives(cfg : FiJavaConfig) -> Tree<string, Set<string>>;
}

fi2javaNatives(cfg : FiJavaConfig) -> Tree<string, Set<string>> {
	flow_dir = getFlowDir();
	lib_natives = pathCombineMany([flow_dir, "platforms", "java", "com", "area9innovation", "flow"]);
	extern_native_dirs = filtermap(cfg.externNatives, \nat -> {
		native_path = resolveRelativePath(nat);
		if (isDirectory(native_path)) {
			Some(native_path);
		} else {
			fcPrintln("Java external native directory '" + nat + "' does't exist", cfg.threadId);
			None();
		}
	});
	native_dirs = concat([lib_natives], extern_native_dirs);
	fold(extern_native_dirs, makeTree(), \acc, native_dir ->
		fold(readDirectory(native_dir), acc, \ac, file ->
			if (!endsWith(file, ".java")) ac else {
				path = pathCombine(native_dir, file);
				code = getFileContent(path);
				name = changeFileExt(fileNameOnly(file), "");
				if (code == "") {
					fcPrintln("empty source code for file: " + path, cfg.threadId);
					ac;
				} else {
					if (name == "NativeHost" || !strContains(code, "NativeHost")) ac else {
						//natives = fi2javaNativesFromCode(code, file, cfg);
						res = parse_Compilation(code);
						ast = res.first;
						err = res.second;
						if (ast.rule == -1) {
							println(
								"Error wile parsing file: '" + file + "', pos: " + i2s(err.pos) + ", met: '" + err.met + "', expected: '" + strGlue(err.expected, ", ") + "' in:\n" +
								fi2javaShowPos(code, err.pos)
							);
							ac;
						} else {
							natives = fi2javaNativesFromAst(ast, code);
							if (length(natives) == 0) ac else {
								setTree(ac, name, buildSet(natives));
							}
						}
					}
				}
			}
		)
	);
}

fi2javaShowPos(code : string, pos : int) -> string {
	begin = for(pos, 
		\p -> p > 0 && (getCharAt(code, p - 1) != "\n"),
		\p -> p - 1
	);
	end = for(pos, 
		\p -> p + 1 < strlen(code) && (getCharAt(code, p + 1) != "\n"),
		\p -> p + 1
	);
	err_str = strReplace(substring(code, begin, end - begin), "\t", " ");
	err_pointer = strRepeat(" ", pos - begin) + "^" + strRepeat(" ", end - pos);
	err_str + "\n" + err_pointer;
}

fi2javaNativesFromAst(ast : SyntaxTree, code : string) -> [string] {
	unit = get_Compilation_CompilationUnit(ast);
	type_decls = get_Compilation_TypeDeclaration_s(unit);
	concatA(filtermap(type_decls, \class_decl ->
		if (class_decl.rule != st_NormalClassDeclaration) None() else {
			class_header = get_Compilation_NormalClassHeader(class_decl);
			superclass = get_Compilation_Superclass_s(class_header);
			if (length(superclass) == 0) None() else {
				extends = trim2(grabSTText(get_Compilation_ClassType(superclass[0]), code), " \t\n\r");
				if (extends != "NativeHost") None() else {
					body = get_Compilation_ClassBody(class_decl);
					members = get_Compilation_ClassBodyDeclaration_s(body);
					Some(filtermap(members, \member ->
						if (member.rule != st_MethodDeclaration) None() else {
							method_modifiers = map(get_Compilation_MethodModifier_s(member), \modifier ->
								trim2(grabSTText(modifier, code), " \t\n\r")
							);
							if (!contains(method_modifiers, "public")) None() else {
								method_header = get_Compilation_MethodHeader(member);
								method_declarator = get_Compilation_MethodDeclarator(method_header);
								identificator = trim2(grabSTText(get_Compilation_Identifier(method_declarator), code), " \t\n\r");
								Some(identificator);
							}
						}
					));
				}
			}
		}
	));
}
/*
fi2java_natives_parser : ref Maybe<[PegOp]> = ref None();

fi2javaNativesFromCode(code : string, file : string, cfg : FiJavaConfig) -> [string] {
	depth = ref 0;
	natives = ref [];
	is_host = ref false;
	ret = parsic3(
		onlyOnce(fi2java_natives_parser, \->
			compilePegGrammar("#include tools/flowc/backends/java/java_natives.lingo")
		), 
		code, 
		SemanticActions(mergeTree(defaultPegActions.t, 
			pairs2tree([
				Pair("pushClass", \xs : [flow] -> {
					extends = if (length(xs[0]) == 0) "" else trim2(xs[0][0], " \n\t\r");
					if (extends == "NativeHost") {
						is_host := true;
					}
					depth := ^depth + 1;
					IllegalStruct();
				}),
				Pair("pushNewClass", \xs : [flow] -> {
					depth := ^depth + 1;
					IllegalStruct();
				}),
				Pair("popClass", \xs : [flow] -> {
					depth := ^depth - 1;
					IllegalStruct();
				}),
				Pair("registerMethod", \xs : [flow] -> {
					modifiers = filtermap(xs[0], \m -> {
						m1 = trim2(m, " \t\n\r");
						if (isSpace(m1) || startsWith(m1, "@")) None() else Some(m1);
					});
					if (^is_host && contains(modifiers, "public") && ^depth == 1) {
						refArrayPush(natives, trim2(xs[1], " \t\n\r"));
					}
					IllegalStruct();
				}),
			])
		)),
		IllegalStruct()
	);
	if (ret.third == "") {
		^natives;
	} else {
		fcPrintln("Failed to parse file '" + file + "'", cfg.threadId);
		[]
	}
}
*/