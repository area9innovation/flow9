import math/hash;
import tools/flowc/backends/common;
import tools/flowc/backends/java/fi2java_defines;

export {
	indexJavaModules(program : FiProgram) -> Pair<Tree<string, JavaModule>, [JavaModule]>;
	indexJavaStructs(program : FiProgram, modules : Tree<string, JavaModule>) -> Pair<Tree<string, JavaStruct>, bool>;
	indexJavaGlobals(gctx : JavaGlobalContext) -> void;
	generateJavaModules(gctx : JavaGlobalContext, output_dir : string) -> void;
	generateJavaStructDefs(gctx : JavaGlobalContext, output_dir : string) -> void;
	type2javaObjType(gctx : JavaGlobalContext, t : FiType, field : bool, no_args : bool, in_native : bool) -> string;
}

indexJavaModules(program : FiProgram) -> Pair<Tree<string, JavaModule>, [JavaModule]> {
	init = Triple(makeTree(), makeTree(), []);

	res = fold(program.traversal, init, \acc ,name -> {
		module = lookupTreeDef(program.modules, name, dummyFiModule);
		id = chooseJavaModuleId(module.fileinfo.flowfile, acc.second);
		ndecls : Tree<string, FiDeclaration> = fold(
			module.globalVars, makeTree(),
			\acc2, d : FiGlobalVar -> setTree(acc2, d.name, d)
		);
		all_decls : [FiDeclaration] = if (true) {
			// variables sorted by init order
			odecls : [FiDeclaration] = mapConcat(
				module.initOrder,
				\n -> {
					def = lookupTree(ndecls, n);
					switch (def) {
						Some(dec): [dec];
						None(): [];
					}
				}
			);
			concat(module.natives, concat(odecls, module.functions));
		} else {
			// alphabetical order for comparing files
			ndecls2 : Tree<string, FiDeclaration> = fold(
				module.functions, ndecls,
				\acc2, d : FiFunctionDec -> setTree(acc2, d.name, d)
			);
			ndecls3 : Tree<string, FiDeclaration> = fold(
				module.natives, ndecls2,
				\acc2, d : FiNativeDec -> setTree(acc2, d.name, d)
			);
			foldTree(ndecls3, [], \k,v,acc2 -> arrayPush(acc2,v))
		}
		// result
		csm = JavaModule(name, module, id, ref makeList(), all_decls);
		Triple(
			setTree(acc.first, name, csm),
			setTree(acc.second, id, true),
			arrayPush(acc.third, csm)
		);
	});

	Pair(res.first, res.third);
}

chooseJavaModuleId(name : string, known : Tree<string,bool>) -> string {
	lastSlash = strLastIndexOf(name, "/");
	nametk = if (lastSlash >= 0) strRight(name, lastSlash + 1) else name;
	nametk2 = escapeJavaReservedName(toLowerCase(strReplace(nametk, ".", "_")));
	chooseJavaIdIndex(nametk2, 1, known);
}

chooseJavaStructName(structName : string, known : Set<string>) -> Pair<string, Set<string>> {
	lcName = toLowerCase(structName);
	if (containsSet(known, lcName)) {
		idx = i2s(getIndexForName(lcName, 1, known));
		Pair(structName + "_" + idx, insertSet(known, lcName + "_" + idx));
	} else {
		Pair(structName, insertSet(known, lcName));
	}
}

getIndexForName(name : string, idx : int, known : Set<string>) -> int {
	if (containsSet(known, name + "_" + i2s(idx))) {
		getIndexForName(name, idx + 1, known);
	} else {
		idx;
	}
}

chooseJavaIdIndex(stem : string, idx : int, known : Tree<string,bool>) -> string {
	name = stem + (if (idx != 1) toString(idx) else "");
	if (lookupTreeDef(known, name, false)) {
		chooseJavaIdIndex(stem, idx + 1, known);
	} else {
		name;
	}
}

indexJavaStructs(program : FiProgram, modules : Tree<string, JavaModule>) -> Pair<Tree<string, JavaStruct>, bool> {
	// Order all structs by name
	struct_list = foldTree(modules, Pair(makeTree(), makeSet()), \name, javaModule, acc -> {
		fold(javaModule.module.structs, acc, \acc2, struct -> {
			javaStructNameAndKnownStructures = chooseJavaStructName(struct.name, acc2.second);
			Pair(
				setTree(acc2.first, struct.name, Triple(javaModule, javaStructNameAndKnownStructures.first, struct)),
				javaStructNameAndKnownStructures.second
			);
		});
	}).first;
	hashed = foldTree(
		struct_list,
		makeTree(),
		\name, __, acc -> {
			hash = fastHashString(name);
			switch (lookupTree(acc, hash)) {
				Some(structs): setTree(acc, hash, insertSet(structs, name));
				None(): setTree(acc, hash, makeSet1(name));
			}
		}
	);
	emptyArray : [Set<string>] = [];
	hashCollisions = foldTree(hashed,
		emptyArray,
		\hash, names, acc -> if (sizeSet(names) > 1) concat(acc, [names]) else acc
	);
	if (length(hashCollisions) > 0 || !isConfigParameterTrue(program.config.config, "java-incremental")) {
		if (length(hashCollisions) > 0) {
			fcPrintln("Struct names hashes have collisions:", program.config.threadId);
			iter(hashCollisions, \collision -> fcPrintln("\t" + strGlue(set2array(collision), ","), program.config.threadId));
		}
		// Assign id values
		init = Pair(0, makeTree());
		res = foldTree(struct_list, init, \name, triple, acc -> {
			id = acc.first;
			javaModule = triple.first;
			javaStructName = triple.second;
			struct = triple.third;
			fields = map(struct.args, \arg -> JavaStructField(arg.name, arg.type, arg.ismutable));
			data = JavaStruct(id, name, javaStructName, javaModule, fields);
			Pair(id + 1, setTree(acc.second, name, data));
		});
		Pair(res.second, true);
	} else {
		Pair(
			foldTree(struct_list, makeTree(), \name, triple, acc -> {
				javaModule = triple.first;
				javaStructName = triple.second;
				struct = triple.third;
				fields = map(struct.args, \arg -> JavaStructField(arg.name, arg.type, arg.ismutable));
				setTree(acc, name, JavaStruct(fastHashString(name), name, javaStructName, javaModule, fields));
			}),
			false
		);
	}
}

indexJavaGlobals(gctx : JavaGlobalContext) -> void {
	pushistr = \s -> rlistPush(gctx.init_code, s);
	iter(gctx.csm_list, \csm -> {
		iter(csm.decl_order, \decl -> {
			switch (decl : FiDeclaration) {
				FiFunctionDec(name, lambda, type, __, __): {
					switch (find(csm.module.natives, \n -> n.name == name)) {
						Some(nat): {
							// May be a native function. Check if it is the case.
							parts = strSplit(nat.nativeName, ".");
							native_host = parts[0];
							native_name = parts[1];
							if (!checkJavaNativeExists(gctx, native_host, native_name)) {
								// This is a fallback for a native, which dosn't exist - use it
								ginfo = JavaGlobalInfo("Module_" + csm.id, "f_" + name, csm, type, "");
								gctx.globalFuncs ::= setTree(gctx.globalFuncs, name, ginfo);
							}
						}
						None(): {
							// Not a fallback - use directly
							ginfo = JavaGlobalInfo("Module_" + csm.id, "f_" + name, csm, type, "");
							gctx.globalFuncs ::= setTree(gctx.globalFuncs, name, ginfo);
						}
					}
				}
				FiGlobalVar(name, expr, type,__,__): {
					tstr = type2javaObjType(gctx, type, true, false, false);
					rlistPush(csm.vars, "\tpublic static " + tstr + " g_" + name + ";\n");

					ginfo = JavaGlobalInfo("Module_" + csm.id, "g_" + name, csm, type, "");
					gctx.globals ::= setTree(gctx.globals, name, ginfo);
				}
				FiNativeDec(name, io, type, nname, fallback, __, s): {
					switch (type) {
						FiTypeFunction(__, __): {
							parts = strSplit(nname, ".");
							if (length(parts) != 2) {
								fail("Invalid native identifier: " + nname);
							}
							cast = switch (type) {
								FiTypeFunction(ats, rt): {
									switch (rt) {
										FiTypeName(nm,__): {
											switch(lookupTree(gctx.cstructs, nm)) {
												Some(cstruct):
													if (length(cstruct.fields) > 0) "(Struct_" + cstruct.javaName + ")"
													else "";
												None(): "";
											}
										}
										default: "";
									}
								}
								default: "";
							}
							native_host = parts[0];
							native_name = parts[1];
							gctx.uses_host ::= insertSet(gctx.uses_host, native_host);
							if (checkJavaNativeExists(gctx, native_host, native_name)) {
								// Use a native name as a real native from appropriate host.
								ginfo = JavaGlobalInfo(native_host, native_name, csm, type, cast);
								gctx.globalFuncs ::= setTree(gctx.globalFuncs, name, ginfo);
							} else {
								switch (fallback) {
									FiLambda(__,__,__,__): {
										// ok, using a fallback
									}
									default: {
										// no fallback neither native.
										gctx.missing_natives ::= insertSet(gctx.missing_natives, name);
									}
								}
							}
						}
						default: {
							fail("this should never happen: indexJavaGlobals");
						}
					}
				}
			}
		});
	});
}

generateJavaModules(gctx : JavaGlobalContext, output_dir : string) -> void {
	pushistr = \s -> rlistPush(gctx.init_code, s);

	// Statistics of method sizes.
	max_code_lines = ref 0;
	max_code_lines_size = ref 0;
	max_code_lines_fun = ref "";
	max_code_size = ref 0;
	max_code_size_lines = ref 0;
	max_code_size_fun = ref "";
	config = gctx.program.config;

	csm_list = filter(gctx.csm_list, \csm -> csm.decl_order != []);

	iter(csm_list, \csm -> {
		module_path = pathCombine(output_dir, "Module_" + csm.id + ".java");
		if (usePreviouslyGeneratedModules(gctx, csm.module, module_path)) {
			if (gctx.program.config.verbose > 1) {
				fcPrintln("Java module '" + module_path + "' is already generated - keeping it", gctx.program.config.threadId);
			}
			class_path = pathCombine(output_dir, "Module_" + csm.id + ".class");
			if (!fileExists(class_path)) {
				rlistPush(gctx.to_compile, module_path + "\n");
			}
			iter(csm.decl_order, \decl ->
				switch (decl : FiDeclaration) {
					FiFunctionDec(__, lambda, __, __, __):
						addJavaExpressionWrappers(gctx, lambda);
					FiGlobalVar(name, value, __, __, __): {
						addJavaExpressionWrappers(gctx, value);
						pushistr("\t\tModule_" + csm.id + ".init_" + name + "();\n");
					}
					FiNativeDec(__,__,__, nname, fallback,__,__): { }
				}
			);
		} else {
			if (gctx.program.config.verbose > 0) {
				fcPrintln("Generating java module '" + module_path + "'", gctx.program.config.threadId);
			}
			module_text = gctx.header_generator(csm.module.fileinfo.trampstamp);
			pushstr = \s -> rlistPush(module_text, s);

			pushstr("@SuppressWarnings(\"unchecked\")\n");
			pushstr("final public class Module_" + csm.id + " {\n");
			pushstr(javaList2String(csm.vars, ""));

			if (length(csm.module.globalVars) > 0) {
				pushstr(generateJavaModuleInit(gctx, csm));
				pushistr("\t\tModule_" + csm.id + ".init();\n");
			}

			iter(csm.decl_order, \decl -> {
				switch (decl : FiDeclaration) {
					FiFunctionDec(name, lambda, type, __, __): {
						code = emitJavaFunction(gctx, csm, name, "f_" + name, lambda, None(), "\t", type);
						lines = strCountOf(code, "\n");
						size = strlen(code);
						if (lines > ^max_code_lines) {
							max_code_lines := lines;
							max_code_lines_size := size;
							max_code_lines_fun := name;
						}
						if (size > ^max_code_size) {
							max_code_size := size;
							max_code_size_lines := lines;
							max_code_size_fun := name;
						}
						if (size >= 65536 && isConfigParameterTrue(config.config, "java-method-size-stats")) {
							fcPrintln("Function: " + name + " size: " + i2s(size) + " >= 65536", config.threadId);
						}
						pushstr(code);
					}
					FiGlobalVar(name, expr, type, __, __): { }
					FiNativeDec(name, io, type, nname, fallback,__,__): { }
				}
			});
			writeJavaSource(gctx, module_path, javaList2String(module_text, "}\n"));
		}
	});
	if (isConfigParameterTrue(config.config, "java-method-size-stats")) {
		fcPrintln("Max code lines: " + i2s(^max_code_lines) + " at function " + ^max_code_lines_fun + ", size: " + i2s(^max_code_lines_size), config.threadId);
		fcPrintln("Max code size: " + i2s(^max_code_size) + " at function " + ^max_code_size_fun + " , lines: " + i2s(^max_code_size_lines), config.threadId);
	}
}

generateJavaModuleInit(gctx : JavaGlobalContext, csm : JavaModule) -> string {
	local_counter = ref 0;
	globals_init = map(csm.module.globalVars, \var -> {
		fctx = JavaFunctionContext(
			gctx, csm, None(), ref makeList(), local_counter,
			javaStatementPullContext(local_counter),
			"", false, []
		);
		ctx = JavaScopeContext(fctx, "\t\t", makeTree());
		tstr = type2javaObjType(gctx, var.type, true, false, false);
		emitJavaStatement(ctx, var.value, JavaReturnLocal("g_" + var.name, tstr));
		Pair(var.name, javaList2String(fctx.text, ""));
	});
	// Initialize large global variables separately in order to limit java code size per function.
	is_large_global = \p -> strlen(p.second) > 1024;
	large_globals = concatStrings(filtermap(globals_init, \p ->
		if (!is_large_global(p)) None() else {
			Some("\tpublic static void init_" + p.first + "() {\n" + p.second + "\t}\n");
		}
	));
	all_globals = "\tpublic static void init() {\n" +
			concatStrings(map(globals_init, \p ->
				if (is_large_global(p)) {
					"\t\tinit_" + p.first + "();\n";
				} else {
					p.second;
				}
			)) +
	"\t}\n";
	large_globals + all_globals;
}

generateJavaStructDefs(gctx : JavaGlobalContext, output_dir : string) -> void {
	traverseInOrder(gctx.cstructs, \sname, sdata : JavaStruct -> {
		if (length(sdata.fields) > 0) {
			fname = pathCombine(output_dir, "Struct_" + sdata.javaName + ".java");
			mod_name = pathCombine(output_dir, "Module_" + sdata.csmodule.id + ".java");
			if (fileExists(fname) && usePreviouslyGeneratedModules(gctx, sdata.csmodule.module, mod_name)) {
				if (gctx.program.config.verbose > 1) {
					fcPrintln("Java struct module '" + fname + "' is already generated - keeping it", gctx.program.config.threadId);
				}
				class_path = pathCombine(output_dir, "Struct_" + sdata.javaName + ".class");
				if (!fileExists(class_path)) {
					rlistPush(gctx.to_compile, fname + "\n");
				}
			} else {
				if (gctx.program.config.verbose > 0) {
					fcPrintln("Generating java struct module '" + fname + "'", gctx.program.config.threadId);
				}
				str_data = gctx.header_generator(timestamp());
				pushstr = \s -> str_data := Cons(s, ^str_data);

				fnametypes = zipWith(map(sdata.fields, \f -> f.name), sdata.fields, \n, f ->
					Quadruple(
						n, type2javaObjType(gctx, f.type, true, false, false),
						f.type, type2javaObjType(gctx, f.type, false, false, false)
					)
				);
				accessor_flds = filter(fnametypes, \f -> lookupTreeDef(gctx.has_field_accessor, f.first, false));

				fieldstr = strGlue(map(accessor_flds, \f -> "Field_" + f.first + "<" + f.fourth + ">"), ", ");

				pushstr(
					"public class Struct_" + sdata.javaName + " extends Struct" +
					(if (fieldstr != "") " implements " + fieldstr else "") +
					" {\n"
				);

				// fields
				iter(fnametypes, \f ->
					pushstr("\tpublic " + f.second + " f_" + f.first + ";\n")
				);

				// constructor
				pushstr("\n\tpublic Struct_" + sdata.javaName + "() {}\n");
				if (length(sdata.fields) < java_max_number_of_args) {
					pushstr(
						"\tpublic Struct_" + sdata.javaName + "(" +
						strGlue(map(fnametypes, \f -> f.second + " a_" + f.first), ", ") +
						") {\n"
					);
					iter(fnametypes, \f ->
						pushstr("\t\tf_" + f.first + " = a_" + f.first + ";\n")
					);
					pushstr("\t}\n");
				} else {
					// If a struct has mre then 255 fields java forbids passing them in a normal constructor - use array of args
					pushstr("\t@SuppressWarnings(\"unchecked\")\n");
					pushstr("\tpublic Struct_" + sdata.javaName + "(Object as[]) {\n");
					iteri(fnametypes, \i, f ->
						pushstr("\t\tf_" + f.first + " = (" + fnametypes[i].second + ")as[" + i2s(i) + "];\n")
					);
					pushstr("\t}\n");
				}

				// accessors
				iter(accessor_flds, \f -> {
					name = f.first;
					pushstr("\tpublic " + f.fourth + " get_" + name + "() { return f_" + name + "; }\n");
					pushstr("\tpublic void set_" + name + "(" + f.fourth + " value) { f_" + name + " = value; }\n");
				});

				// metadata
				pushstr("\n\tpublic int getTypeId() { return " + i2s(sdata.id) + "; }\n");
				pushstr("\tpublic String getTypeName() { return \"" + sname + "\"; }\n");

				pushstr("\n\tprivate static final String[] field_names = new String[] {\n\t\t");
				pushstr(strGlue(map(fnametypes,\f -> "\"" + f.first + "\""), ", "));

				pushstr("\n\t};\n\tprivate static final RuntimeType[] field_types = new RuntimeType[] {\n\t\t");
				pushstr(strGlue(map(sdata.fields,\f -> type2javaRuntimeType(f.type)), ", "));

				pushstr("\n\t};\n\tpublic String[] getFieldNames() { return field_names; }\n");
				pushstr("\tpublic RuntimeType[] getFieldTypes() { return field_types; }\n");

				// generic field access
				pushstr("\n\tpublic Object[] getFields() {\n\t\treturn new Object[] {\n\t\t\t");
				pushstr(strGlue(map(fnametypes,\f -> "f_" + f.first), ", "));
				pushstr("\n\t\t};\n\t}\n");

				pushstr("\t@SuppressWarnings(\"unchecked\")\n");
				pushstr("\tpublic void setFields(Object[] values) {\n");
				pushstr("\t\tif (values.length != "+i2s(length(fnametypes))+")\n");
				pushstr("\t\t\tthrow new IndexOutOfBoundsException(\"Invalid field count in " + sname + "\");\n");
				iteri(fnametypes, \i, f ->
					pushstr("\t\tf_" + f.first + " = (" + f.fourth + ")values[" + i2s(i) + "];\n")
				);
				pushstr("\t}\n\n");

				// comparison
				pushstr("\tpublic int compareTo(Struct other_gen) {\n");
				pushstr("\t\tif (other_gen == this) return 0;\n");
				pushstr("\t\tint tmp = other_gen.getTypeId();\n");
				pushstr("\t\tif (tmp != " + i2s(sdata.id) + ") return " + i2s(sdata.id) + "-tmp;\n");
				pushstr("\t\tStruct_" + sdata.javaName + " other = (Struct_" + sdata.javaName + ")other_gen;\n");

				tmp = fold(fnametypes, false, \tmp, f -> {
					if (tmp) {
						pushstr("\t\tif (tmp != 0) return tmp;\n");
					}
					emitJavaComparison(pushstr, f.first, f.third);
				});
				if (tmp)
					pushstr("\t\treturn tmp;\n\t}\n")
				else
					pushstr("\t\treturn 0;\n\t}\n");
				writeJavaSource(gctx, fname, javaList2String(str_data, "}\n"));
			}
		}
	});
}

emitJavaFunction(gctx : JavaGlobalContext, csm : JavaModule, global : string, name : string, tree : FiLambda, parent : Maybe<JavaScopeContext>, indent0 : string, type : FiTypeFunction) -> string {
	is_closure = (parent != None());
	atypes = map(tree.args, \arg -> arg.type);
	rtype = type.returnType;

	local_counter = ref switch (parent) {
		None(): 0;
		Some(p): ^(p.func.next_local_id);
	}

	arg_locals = mapi(tree.args, \i, arg -> {
		aname2 = "a" + (if (arg.name == "__") javaNewLocalName(local_counter, i2s(i)) else arg.name);
		atypestr = type2javaObjType(gctx, atypes[i], !is_closure, false, false);
		JavaLocalInfo(arg.name, aname2, atypestr, is_closure, is_closure);
	});

	fctx = JavaFunctionContext(
		gctx, csm,
		switch (parent) {
			Some(p): Some(ref p);
			None(): None();
		},
		ref makeList(), local_counter,
		javaStatementPullContext(local_counter),

		// tail call
		if (is_closure) "" else global,
		false,

		arg_locals
	);

	indent = if (is_closure) indent0 else indent0 + "\t";

	ctx = JavaScopeContext(
		fctx, indent + "\t",
		fold(arg_locals, makeTree(), \t, l -> setTree(t, l.name, l))
	);

	rtypestr = type2javaObjType(gctx, rtype, !is_closure, false, false);
	emitJavaStatement(ctx, tree.body, JavaReturnStmt(rtypestr));

	prefix = if (is_closure)
		indent0 + "public final " + rtypestr + " invoke"
	else
		indent0 + "public static final " + rtypestr + " " + name;

	arg_text = map(arg_locals, \loc -> {
		(if (is_closure) "final " else "") + loc.type + " " + loc.id
	});

	body = javaList2String(fctx.text, "");

	reslist = ref makeList();

	if (is_closure) {
		func_type = "Func" + i2s(length(arg_locals)) + "<" + rtypestr + concatStrings(map(arg_locals, \loc -> ", " + loc.type)) + ">";
		rlistPush(reslist, "(" + func_type + ")(" + superglue(arg_locals, \loc -> loc.type + " " + loc.id, ", ") + ") -> {\n");
		//rlistPush(reslist, "(" + superglue(arg_locals, \loc -> loc.type + " " + loc.id, ", ") + ") -> {\n");
	} else {
		rlistPush(reslist, prefix + "(" + strGlue(arg_text, ", ") + ") {\n");
	}

	if (fctx.has_tail_call) {
		rlistPush(reslist, indent + "TAIL_CALL: for(;;) {\n");
		rlistPush(reslist, body);
		rlistPush(reslist, indent + "}\n");
	} else {
		rlistPush(reslist, body);
	}

	if (is_closure) {
		rlistPush(reslist, indent0 + "}");
	} else {
		rlistPush(reslist, indent + "}\n");
	}

	list2string(^reslist);
}

emitJavaStatement(ctx0 : JavaScopeContext, code0 : FiExp, retloc : JavaReturnLocation) {
	unw_code = unfoldJavaStatements(ctx0, code0, true);
	code : FiExp = unw_code.first;
	ctx = unw_code.second;

	switch (code) {
		FiIf(cond, then, elseExp, __, __): {
			cond_code = unfoldJavaStatements(ctx, cond, false);
			condstr = emitJavaExpression(cond_code.second, cond_code.first, "boolean");
			jctxPushStr(ctx, ctx.indent + "if (" + condstr + ") {\n");
			subctx = jctxPushIndent(ctx, "\t");
			emitJavaStatement(subctx, then, retloc);
			jctxPushStr(ctx, ctx.indent + "} else {\n");
			emitJavaStatement(subctx, elseExp, retloc);
			jctxPushStr(ctx, ctx.indent + "}\n");
		}
		FiSwitch(x, __, cases,__,__): {
			arg_code = unfoldJavaStatements(ctx, x, false);
			argstr = emitJavaExpression(arg_code.second, arg_code.first, "Struct");
			tmpvar = javaNewLocalName(ctx.func.next_local_id, "_tmp");
			jctxPushStr(ctx, ctx.indent + "Struct " + tmpvar + " = " +  argstr + ";\n");
			jctxPushStr(ctx, ctx.indent + "switch (" + tmpvar + ".getTypeId()) {\n");
			subctx = jctxPushIndent(ctx, "\t");
			tmpvar2 = javaNewLocalName(ctx.func.next_local_id, "_tmp");
			inputvar = x.name;
			has_default = fold(cases, false, \hasdef, case -> {
				case_ctx_v = if (case.struct == "default") {
					jctxPushStr(ctx, ctx.indent + "default: {\n");
					Pair(subctx, true);
				} else {
					switch (lookupTree(ctx.func.gctx.cstructs, case.struct)) {
						Some(cstruct): {
							jctxPushStr(ctx, ctx.indent + "case " + i2s(cstruct.id) + "/*" + cstruct.name + "*/: {\n");

							has_args = exists(case.argNames, \a -> a != "__");

							castctx = if (has_args || (length(cstruct.fields) > 0 && inputvar != "")) {
								stype = "Struct_" + cstruct.javaName;
								jctxPushStr(ctx, subctx.indent + "final " + stype + " " + tmpvar2 +
									" = (" + stype + ")" + tmpvar + ";\n");

								if (inputvar != "")
									jctxPushLocal(subctx, JavaLocalInfo(inputvar, tmpvar2, stype, true, false))
								else
									subctx;
							}
							else
								subctx;

							ectx = if (!has_args)
								castctx
							else {
								foldi(case.argNames, castctx, \i, sctx, arg -> {
									if (arg == "__")
										sctx
									else {
										aname = javaNewLocalName(ctx.func.next_local_id, arg);
										ty = type2javaObjType(ctx.func.gctx, cstruct.fields[i].type, true, false, false);
										jctxPushStr(ctx, subctx.indent + "final " + ty + " " + aname +
											" = " + tmpvar2 + ".f_" + cstruct.fields[i].name + ";\n");

										jctxPushLocal(sctx, JavaLocalInfo(arg,aname,ty,true,false));
									}
								});
							}

							Pair(ectx, hasdef);
						}
						None():
							fail0("invalid struct in case: " + case.struct);
					}
				}

				emitJavaStatement(case_ctx_v.first, case.body, retloc);

				if (!isJavaReturnStmt(retloc))
					jctxPushStr(ctx, subctx.indent + "break;\n");
				jctxPushStr(ctx, ctx.indent + "}\n");

				case_ctx_v.second;
			});

			if (!has_default) {
				jctxPushStr(ctx, ctx.indent + "default:\n");
				jctxPushStr(ctx, subctx.indent +
					"throw new RuntimeException(\"Unexpected struct in switch: \"+" +
					tmpvar + ".getTypeName());\n");
			}

			jctxPushStr(ctx, ctx.indent + "}\n");
		}

		FiCallPrim(op, es, type, __): {
			switch (op) {
				FcArrayPrim():
					if (length(es) == 0)
						javaReturnValue(ctx, retloc, "SingletonStructs.arr_empty")
					else {
						emitJavaDefaultStmt(ctx, code, retloc);
					}
				FcAssignPrim(): {
					vtype = ctxtype2javaObjType(ctx, fiExpType(es[1]), false, false);

					ref_code = unfoldJavaStatements(ctx, es[0], false);
					refstr = emitJavaExpression(ref_code.second, ref_code.first, "Reference<"+vtype+">");
					val_code = unfoldJavaStatements(ctx, es[1], false);
					valstr = emitJavaExpression(val_code.second, val_code.first, vtype);

					jctxPushStr(ctx, ctx.indent + refstr + ".value = " + valstr + ";\n");
					javaReturnNull(ctx, retloc);
				}
				FcSetMutablePrim(field): {
					sinfo = type2javaStruct(ctx.func.gctx, type);
					type1s = ctxtype2javaObjType(ctx, type, true, false);

					vtype = switch (sinfo) {
						Some(cstruct): {
							argid = elemIndex(map(cstruct.fields, \f -> f.name), field, -1);
							if (argid < 0)
								fail0("Struct " + cstruct.name + " has no field " + field);
							type2javaObjType(ctx.func.gctx, cstruct.fields[argid].type, true, false, false);
						}
						None():
							ctxtype2javaObjType(ctx, fiExpType(es[1]), true, false);
					}

					ref_code = unfoldJavaStatements(ctx, es[0], false);
					refstr = emitJavaExpression(ref_code.second, ref_code.first, type1s);
					val_code = unfoldJavaStatements(ctx, es[1], false);
					valstr = emitJavaExpression(val_code.second, val_code.first, vtype);

					switch (sinfo) {
						Some(cstruct): {
							jctxPushStr(ctx, ctx.indent + refstr + ".f_" + field + "=" + valstr + ";\n");
						}
						None(): {
							javaRequireAccessor(ctx.func.gctx, field);
							jctxPushStr(ctx, ctx.indent + "((Field_" + field + ")" + refstr +
								").set_" + field + "(" + valstr + ");\n");
						}
					}
					javaReturnNull(ctx, retloc);
				}
				default:
					emitJavaDefaultStmt(ctx, code, retloc);
			}
		}
		default:
			emitJavaDefaultStmt(ctx, code, retloc);
	}
}

emitJavaDefaultStmt(ctx : JavaScopeContext, code : FiExp, retloc : JavaReturnLocation) -> void {
	switch (retloc) {
		JavaReturnIgnore():
			switch (code) {
				FiVoid(__): {}
				default:
					if (isSafeJavaStatement(ctx.func.gctx, code))
						emitJavaExprStmt(ctx, code, "", "Object")
					else {
						tmpvar = javaNewLocalName(ctx.func.next_local_id, "_unused");
						emitJavaExprStmt(ctx, code, "Object " + tmpvar + "=", "Object");
					}
			}
		JavaReturnLocal(name,type):
			emitJavaExprStmt(ctx, code, name + "=", type);
		JavaReturnStmt(type):
			switch (code) {
				FiCall(fn, es, __, __): {
					can_tail = switch (fn) {
						FiVar(x, __, __): x == ctx.func.can_tail_call;
						default: false;
					};
					if (can_tail)
						emitJavaTailCall(ctx, code, type)
					else
						emitJavaExprStmt(ctx, code, "return ", type);
				}
				default:
					emitJavaExprStmt(ctx, code, "return ", type);
			}
	}
}

emitJavaExprStmt(ctx : JavaScopeContext, code : FiExp, eexpr : string, etype : string) -> void {
	switch (code) {
		FiLambda(__,__,__,__):
			emitJavaClosure(ctx, code, eexpr, etype);
		default:
			jctxPushStr(ctx, ctx.indent + eexpr + emitJavaExpression(ctx, code, etype) + ";\n");
	}
}

emitJavaTailCall(ctx : JavaScopeContext, code : FiCall, rtype : string) -> void {
	subindent = ctx.indent + "\t";
	(ctx.func).has_tail_call ::= true;

	jctxPushStr(ctx, ctx.indent + "{\n");

	args = code.args;

	var_assigns = mapi(ctx.func.arg_locals, \i, arg -> {
		is_same = switch (args[i]) {
			FiVar(x, __, __):
				x == arg.name &&
				eitherMap(lookupTree(ctx.locals, x), \l -> l==arg, false);
			default:
				false;
		};

		if (is_same)
			""
		else {
			arg_code = unfoldJavaStatements(ctx, args[i], false);
			tmpvar = javaNewLocalName(ctx.func.next_local_id, "__tmp");
			argstr = emitJavaExpression(arg_code.second, arg_code.first, arg.type);

			jctxPushStr(ctx, subindent + "final " + arg.type + " " + tmpvar + " = " + argstr + ";\n");

			subindent + arg.id + " = " + tmpvar + ";\n";
		}
	});

	iter(var_assigns, \s -> if (s != "") jctxPushStr(ctx, s));

	jctxPushStr(ctx, subindent + "continue TAIL_CALL;\n" + ctx.indent + "}\n");
}

emitJavaClosure(ctx : JavaScopeContext, code : FiLambda, rloc : string, rtype : string) {
	fctx = ctx.func;
	bodycode = emitJavaFunction(fctx.gctx, fctx.csm, "", "", code, Some(ctx), ctx.indent, code.type);

	type1 = type2javaObjType(fctx.gctx, fiExpType(code), true, false, false);
	type2 = rtype;

	jctxPushStr(ctx, ctx.indent + rloc);
	jctxPushStr(ctx, wrapJavaCast(bodycode, type1, type2));
	jctxPushStr(ctx, ";\n");
}

emitJavaExpression(ctx : JavaScopeContext, expcode : FiExp, rtype : string) -> string {
	result = \str, type -> {
		wrapJavaCast(str, type, rtype);
	};
	switch (expcode) {
		FiVoid(__): "null";
		FiBool(v, __): result(if (v) "true" else "false", "boolean");
		FiInt(v, __):  result(if (v < 0) "(" + i2s(v) + ")" else i2s(v), "int");
		FiDouble(d, i): {
			//TODO: infinity
			vs = if (isNanOrInf(d)) {
				"Math.NaN"
			} else {
				s = d2s(d);
				s1 = if (strIndexOf(s, ".") < 0 && strIndexOf(s, "e") < 0) s + ".0" else s;
				if (getCharAt(s, 0) == "-") "(" + s1 + ")" else s1;
			};
			result(vs, "double");
		}
		FiString(s, __): {
			vs = stringFold(s, "\"", \acc,code ->
				acc + if (code < 0x20) {
					if (code == 0x09) "\\t"
					else if (code == 0x0a) "\\n"
					else if (code == 0x0d) "\\r"
					else "\\u"+lpad(formatHex(code), "0", 4);
				} else if (code >= 0x80) {
					"\\u" + lpad(formatHex(code), "0", 4)
				} else {
					if (code == 0x22) "\\\""
					else if (code == 0x5c) "\\\\"
					else fromCharCode(code);
				}
			) + "\"";
			result(vs, "String");
		}
		FiSeq(es, type, __): {
			if (length(es) == 0) {
				"null"
			} else {
				if (length(es) != 1) fail0("unexpected sequence in expression");
				emitJavaExpression(ctx, es[0], rtype);
			}
		}
		FiVar(name, type, __):
			switch (resolveJavaLocal(ctx, name)) {
				Some(linfo):
					wrapJavaCast(linfo.id, linfo.type, rtype);
				None(): {
					gctx = ctx.func.gctx;
					switch (lookupTree(gctx.globals, name)) {
						Some(ginfo): {
							tstr = type2javaObjType(gctx, ginfo.type, true, false, startsWith(name, "h_"));
							wrapJavaCast(ginfo.class + "." + ginfo.name, tstr, rtype);
						}
						None():
							switch (lookupTree(gctx.globalFuncs, name)) {
								Some(finfo): {
									ftype = cast(finfo.type : FiType -> FiTypeFunction);
									id = "w_" + name;
									wrapper_type = type2javaObjType(gctx, ftype, false, false, false);
									rlistPush(gctx.wrapper_code, JavaWrapperCode(id, wrapper_type, finfo.class + "::" + finfo.name));
									fglobal = JavaGlobalInfo("Wrappers", id, finfo.csmodule, finfo.type, "");
									gctx.globals ::= setTree(gctx.globals, name, fglobal);
									wrapJavaCast("Wrappers." + id, wrapper_type, rtype);
								}
								None(): {
									if (containsSet(gctx.missing_natives, name)) {
										fail0("native: '" + name + "' is not implemented and has no fallback");
									} else {
										fail0("unknown var: '" + name + "'");
									}
								}
							}
					}
				}
			}
		FiCall(f, es, type, __): {
			gctx = ctx.func.gctx;
			global = switch (f) {
				FiVar(fname, __, __): {
					switch (resolveJavaLocal(ctx, fname)) {
						Some(__): None();
						None(): {
							switch (lookupTree(gctx.globals, fname)) {
								Some(glob): None();
								None(): lookupTree(gctx.globalFuncs, fname);
							}
						}
					}
				}
				default: None();
			};
			switch (global) {
				Some(finfo): {
					is_native = startsWith(finfo.name, "h_");
					ftype = cast(finfo.type : FiType -> FiTypeFunction);
					rname = finfo.cast + finfo.class + "." + finfo.name;
					aexprs = mapi(es, \j, expr ->
						emitJavaExpression(ctx, expr, type2javaObjType(gctx, ftype.args[j].type, true, false, is_native))
					);
					result(rname + "(" + strGlue(aexprs, ", ") + ")", type2javaObjType(gctx, ftype.returnType, true, false, is_native));
				}
				None(): {
					arrow = javaVerifyFiTypeFunction(fiExpType(f));
					typeinfo = switch (arrow) {
						Some(funcType):
							Triple(
								ctxtype2javaObjType(ctx, funcType, false, false),
								map(funcType.args, \arg -> ctxtype2javaObjType(ctx, arg.type, false, false)),
 								ctxtype2javaObjType(ctx, funcType.returnType, false, false)
							);
						None():
							Triple(
								javaRequireFunction(gctx, length(es)),
								map(es, \__ -> "Object"),
								"Object"
							);
					}
					fnexpr = emitJavaExpression(ctx, f, typeinfo.first);
					aexprs = zipWith(es, typeinfo.second,
						\expr, t -> emitJavaExpression(ctx, expr, t));
					result(fnexpr + ".invoke(" + strGlue(aexprs, ", ") + ")", typeinfo.third);
				}
			}
		}
		FiIf(cond, ethen, eelse, type, __): {
			etype = ctxtype2javaObjType(ctx, type, true, false);
			result(
				"(" + emitJavaExpression(ctx, cond, "boolean") + "?" +
					emitJavaExpression(ctx, ethen, etype) + ":" +
					emitJavaExpression(ctx, eelse, etype) + ")",
				etype
			);
		}
		FiCast(e0, tFrom, tTo, type, __): {
			csm = ctx.func.csm;
			sfrom = ctxtype2javaObjType(ctx, tFrom, true, false);
			sto = ctxtype2javaObjType(ctx, tTo, true, false);
			arg = emitJavaExpression(ctx, e0, sfrom);
			result(
				switch (tFrom) {
					FiTypeInt():
						switch (tTo) {
							FiTypeInt():    arg;
							FiTypeDouble(): "((double)" + arg + ")";
							FiTypeString(): "Integer.toString((int)(" + arg + "))";
							default:        "((" + sto + ")" + arg + ")";
						}
					FiTypeDouble():
						switch (tTo) {
							FiTypeInt():    "((int)" + arg + ")";
							FiTypeDouble(): arg;
							FiTypeString(): "FlowRuntime.doubleToString(" + arg + ")";
							default:        "((" + sto + ")" + arg + ")";
						}
					default: "((" + sto + ")" + arg + ")";
				},
				sto
			);
		}
		FiCallPrim(op, es, type, __):
			switch (op) {
				FcRefPrim(): {
					result(
						"(new Reference(" + emitJavaExpression(ctx, es[0], "Object") + "))",
						"Reference"
					);
				}
				FcDerefPrim(): {
					rettype = ctxtype2javaObjType(ctx, type, false, false);
					reftype = if (rettype == "Object") "Reference" else "Reference<" + rettype + ">";
					result(
						emitJavaExpression(ctx, es[0], reftype) + ".value",
						rettype
					);
				}
				FcArrayPrim():
					result(
						if (length(es) == 0)
							"SingletonStructs.arr_empty"
						else
							"(new Object[] { " + strGlue(map(es, \e -> {
								val_code = unfoldJavaStatements(ctx, e, false);
								emitJavaExpression(val_code.second, val_code.first, "Object");
							}), ", ") + " })",
						"Object[]"
					);
				FcIndexPrim(): {
					rtypestr = if (rtype == "Object") ctxtype2javaObjType(ctx, type, false, false) else rtype;
					"((" + rtypestr + ")(" + emitJavaExpression(ctx, es[0], "Object[]") + "[" + emitJavaExpression(ctx, es[1], "int") + "]))";
				}
				FcStructPrim(sname):
					switch (lookupTree(ctx.func.gctx.cstructs, sname)) {
						None(): fail0("unknown struct " + sname);
						Some(sinfo): {
							nfields = length(sinfo.fields);
							if (nfields != length(es))
								fail0("Invalid number of arguments constructing " + sname + ": " + i2s(length(es)) + " instead of " + i2s(nfields));
							if (nfields == 0)
								result("SingletonStructs.str_" + sname, "SingletonStruct")
							else {
								stype = "Struct_" + sinfo.javaName;
								sargs = strGlue(mapi(es, \j, e ->
									emitJavaExpression(ctx, e,
										type2javaObjType(ctx.func.gctx, sinfo.fields[j].type, true, false, false))),
									", "
								);
								sargs1 = if (nfields < java_max_number_of_args) sargs else "new Object[]{" + sargs + "}";
								result("(new " + stype + "(" + sargs1 + "))", stype);
							}
						}
					}
				FcFieldPrim(field): {
					gctx = ctx.func.gctx;
					type1 = fiExpType(es[0]);
					sinfo = type2javaStruct(gctx, type1);
					refstr = emitJavaExpression(ctx, es[0], ctxtype2javaObjType(ctx, type1, true, false));

					if (field == "structname")
						result("((Struct)" + refstr + ").getTypeName()", "String")
					else
						switch (sinfo) {
							Some(cstruct): {
								argid = elemIndex(map(cstruct.fields, \f -> f.name), field, -1);
								if (argid < 0)
									fail0("Struct " + cstruct.name+" has no field " + field);
								vtype = type2javaObjType(gctx, cstruct.fields[argid].type, true, false, false);
								result("(" + refstr + ").f_" + field, vtype);
							}
							None(): {
								javaRequireAccessor(gctx, field);
								result("((Field_" + field + ")" + refstr + ").get_" + field + "()", "Object");
							}
						}
				}
				FcAndPrim():
					result(
						"(" + emitJavaExpression(ctx, es[0], "boolean") + "&&" + emitJavaExpression(ctx, es[1], "boolean") + ")",
						"boolean"
					);
				FcOrPrim():
					result(
						"(" + emitJavaExpression(ctx, es[0], "boolean") + "||" + emitJavaExpression(ctx, es[1], "boolean") + ")",
						"boolean"
					);
				FcNotPrim():
					result("!" + emitJavaExpression(ctx, es[0], "boolean"), "boolean");
				FcNegPrim():
					switch (type) {
						FiTypeInt():    result("(-" + emitJavaExpression(ctx, es[0], "int") + ")", "int");
						FiTypeDouble(): result("(-" + emitJavaExpression(ctx, es[0], "double") + ")", "double");
						default:        result("FlowRuntime.negate(" + emitJavaExpression(ctx, es[0], "Object") + ")", "Object");
					}
				FcPlusPrim():  emitJavaArith(ctx, "+", "FlowRuntime.add", es[0], es[1], type, rtype);
				FcMinusPrim(): emitJavaArith(ctx, "-", "FlowRuntime.sub", es[0], es[1], type, rtype);
				FcMulPrim():   emitJavaArith(ctx, "*", "FlowRuntime.mul", es[0], es[1], type, rtype);
				FcDivPrim():   emitJavaArith(ctx, "/", "FlowRuntime.div", es[0], es[1], type, rtype);
				FcModPrim():   emitJavaArith(ctx, "%", "FlowRuntime.mod", es[0], es[1], type, rtype);
				FcEqPrim():    emitJavaCompare(ctx, "==", es[0], es[1], rtype);
				FcNePrim():    emitJavaCompare(ctx, "!=", es[0], es[1], rtype);
				FcLtPrim():    emitJavaCompare(ctx, "<",  es[0], es[1], rtype);
				FcLePrim():    emitJavaCompare(ctx, "<=", es[0], es[1], rtype);
				FcGtPrim():    emitJavaCompare(ctx, ">",  es[0], es[1], rtype);
				FcGePrim():    emitJavaCompare(ctx, ">=", es[0], es[1], rtype);
				default: "/*TODO*/";
			}
		default:
			"/*TODO*/"
	}
}

emitJavaCompare(ctx : JavaScopeContext, op : string, e1 : FiExp, e2 : FiExp, rtype : string) -> string {
	singletonNo = \e -> {
		switch(e) {
			FiCallPrim(cop, __, __, __): {
				switch(cop) {
					FcStructPrim(sname): {
						switch (lookupTree(ctx.func.gctx.cstructs, sname)) {
							Some(sinfo): {
								if (sinfo.fields == []) sinfo.id else -1;
							}
							None(): -1;
						}
					}
					default: -1;
				}
			}
			default: -1;
		}
	}
	opwrap = \ts -> {
		"(" + emitJavaExpression(ctx, e1, ts) + op + emitJavaExpression(ctx, e2, ts) + ")";
	}
	fnwrap = \fn,ts -> {
		re1 = emitJavaExpression(ctx, e1, ts);
		re2 = emitJavaExpression(ctx, e2, ts);

		wrap = \ -> {
			if (op == "==") {
				"FlowRuntime.compareEqual(" + re1 + "," + re2 + ")";
			} else if (op == "!=") {
				"(!FlowRuntime.compareEqual(" + re1 + "," + re2 + "))";
			} else {
				"(" + fn + "(" + re1 + "," + re2 + ")" + op + "0)";
			}
		}

		aempty = "SingletonStructs.arr_empty";
		rs1 = singletonNo(e1);
		rs2 = singletonNo(e2);
		if ((re1 == aempty || re2 == aempty) && (op == "==" || op == "!=")) {
			if (re1 == aempty) {
				"((Object[])" + re2 + ").length " + op + " 0";
			} else if (re2 == aempty) {
				"((Object[])" + re1 + ").length " + op + " 0";
			} else {
				wrap();
			}
		} else if ((rs1 > 0 || rs2 > 0) && (op == "==" || op == "!=")) {
			if (rs1 > 0) {
				"((Struct)" + re2 + ").getTypeId() " + op + " " + i2s(rs1);
			} else if (rs2 > 0) {
				"((Struct)" + re1 + ").getTypeId() " + op + " " + i2s(rs2);
			} else {
				wrap();
			}
		} else {
			wrap();
		}
	}
	strwrap = \ -> {
		s1 = emitJavaExpression(ctx, e1, "String");
		s2 = emitJavaExpression(ctx, e2, "String");
		if (op == "==")
			"(" + s1 + ").equals(" + s2 + ")"
		else if (op == "!=")
			"(!(" + s1 + ").equals(" + s2 + "))"
		else
			"((" + s1 + ").compareTo(" + s2 + ")" + op + "0)";
	}
	switch (fiExpType(e1)) {
		FiTypeInt():    opwrap("int");
		FiTypeDouble(): opwrap("double");
		FiTypeBool():
			if (op == "==" || op == "!=") {
				opwrap("boolean");
			} else {
				"((" + emitJavaExpression(ctx, e1, "boolean") + "? 1 : 0)" + op +
				"(" + emitJavaExpression(ctx, e2, "boolean") + "? 1 : 0))";
			}
		FiTypeString(): strwrap();
		default:        fnwrap("FlowRuntime.compareByValue","Object");
	}
}

emitJavaArith(ctx : JavaScopeContext, op : string, fn : string, e1 : FiExp, e2 : FiExp, type : FiType, rtype : string) -> string {
	opwrap = \ts -> {
		wrapJavaCast("(" + emitJavaExpression(ctx, e1, ts) + op + emitJavaExpression(ctx, e2, ts) + ")", ts, rtype);
	}
	defwrap = \-> {
		wrapJavaCast(fn+ "(" + emitJavaExpression(ctx, e1, "Object") + "," + emitJavaExpression(ctx, e2, "Object") + ")", "Object", rtype)
	}
	switch (type) {
		FiTypeInt():    opwrap("int");
		FiTypeDouble(): opwrap("double");
		FiTypeString(): opwrap("String");
		default:        defwrap();
	}
}

emitJavaComparison(pushstr : (string) -> void, name : string, t : FiType) -> bool {
	defcase = \ -> {
		pushstr("\t\ttmp = FlowRuntime.compareByValue(f_" + name + ", other.f_" + name + ");\n");
		true;
	};
	cmpcase = \ -> {
		pushstr("\t\ttmp = f_" + name + ".compareTo(other.f_" + name + ");\n");
		true;
	};
	numcase = \ -> {
		pushstr("\t\tif (f_" + name + " != other.f_" + name + ")\n");
		pushstr("\t\t\treturn (f_" + name + " > other.f_" + name + ") ? 1 : -1;\n");
		false;
	};
	boolcase = \ -> {
		pushstr("\t\tif (f_" + name + " != other.f_" + name + ")\n");
		pushstr("\t\t\treturn f_" + name + " ? 1 : -1;\n");
		false;
	};
	strcase = \ -> {
		pushstr("\t\ttmp = f_" + name+".compareTo(other.f_" + name + ");\n");
		true;
	};
	switch (t) {
		FiTypeArray(__):        defcase();
		FiTypeFunction(__, __): defcase();
		FiTypeRef(__):          cmpcase();
		FiTypeParameter(__):    defcase(); // TODO:?
		FiTypeBool():           boolcase();
		FiTypeInt():            numcase();
		FiTypeDouble():         numcase();
		FiTypeString():         strcase();
		FiTypeFlow():           defcase();
		FiTypeVoid():           defcase();
		FiTypeNative():         defcase();
		FiTypeName(__, __):     cmpcase();
	}
}

unfoldJavaStatements(ctx : JavaScopeContext, code : FiExp, allow_stmt : bool) -> Pair<FiExp,JavaScopeContext> {
	switch (code) {
		FiSeq(es, __, __): {
			if (length(es) == 0) {
				Pair(code, ctx)
			} else {
				lasti = length(es) - 1;
				head = subrange(es, 0, lasti);
				iter(head, \item ->
					emitJavaStatement(ctx, item, JavaReturnIgnore())
				);
				unfoldJavaStatements(ctx, es[lasti], allow_stmt);
			}
		}
		FiLet(x, type, e1, e2, type2, __): {
			value_body = unfoldJavaStatements(ctx, e1, true);
			body = value_body.first;
			ln = javaNewLocalName(ctx.func.next_local_id, x);
			stype = ctxtype2javaObjType(ctx, type, true, false);
			is_final = switch (body) {
				FiLambda(__, __, __, __): {
					rexpr = "final " + stype + " " + ln + " = ";
					emitJavaClosure(value_body.second, body, rexpr, stype);
					true;
				}
				default: {
					head = stype + " " + ln;
					if (isJavaStatement(body, true)) {
						jctxPushStr(ctx, ctx.indent + head + ";\n");
						emitJavaStatement(value_body.second, body, JavaReturnLocal(ln, stype));
						false;
					} else {
						expr = emitJavaExpression(value_body.second, body, stype);
						jctxPushStr(ctx, ctx.indent + "final " + head + " = " + expr + ";\n");
						true;
					}
				}
			}
			subscope = jctxPushLocal(ctx, JavaLocalInfo(x, ln, stype, is_final, false));
			unfoldJavaStatements(subscope, e2, allow_stmt);
		}
		default: {
			if (!allow_stmt || !isJavaStatement(code, true)) {
				eitherMap(
					pullFiStatements(ctx.func.pullctx, code),
					\code2 -> unfoldJavaStatements(ctx, code2, false),
					Pair(code, ctx)
				);
			} else {
				Pair(code, ctx)
			}
		}
	}
}

type2javaObjType(gctx : JavaGlobalContext, t : FiType, field : bool, no_args : bool, in_native : bool) -> string {
	switch (t) {
		FiTypeArray(arr):              "Object[]";
		FiTypeFunction(args, retType): {
			arity = length(args);
			javaRequireFunction(gctx, arity);
			ft = "Func" + i2s(arity);
			if (no_args)
				ft
			else {
				astr = strGlue(map(args, \t3 -> type2javaObjType(gctx, t3.type, false, no_args, in_native)), ", ");

				(ft + "<" + type2javaObjType(gctx, retType, false, no_args, in_native))+
					(if (arity == 0) "" else "," + astr) + ">";
			}
		};
		FiTypeRef(tp):                 if (no_args) "Reference" else "Reference<" + type2javaObjType(gctx, tp, false, no_args, in_native) + ">";
		FiTypeParameter(nm):           "Object"; // TODO: is it right ?
		FiTypeBool():                  if (field) "boolean" else "Boolean";
		FiTypeInt():                   if (field) "int" else "Integer";
		FiTypeDouble():                if (field) "double" else "Double";
		FiTypeString():                "String";
		FiTypeFlow():                  "Object";
		FiTypeVoid():                  "Object";
		FiTypeNative():                "Object";
		FiTypeName(nm, __):
			if (in_native) "Struct" else {
				switch(lookupTree(gctx.cstructs, nm)) {
					Some(cstruct):
						if (length(cstruct.fields) > 0) "Struct_" + cstruct.javaName
						else "SingletonStruct";
					None(): "Struct";
				}
			}
	}
}

javaRequireFunction(gctx : JavaGlobalContext, arity : int) -> string {
	ftypestr = "Func" + i2s(arity);

	if (!lookupTreeDef(gctx.has_func_def, arity, false)) {
		gctx.has_func_def ::= setTree(gctx.has_func_def, arity, true);
	}
	ftypestr;
}

javaRequireAccessor(gctx : JavaGlobalContext, name : string) {
	if (!lookupTreeDef(gctx.has_field_accessor, name, false)) {
		gctx.has_field_accessor ::= setTree(gctx.has_field_accessor, name, true);
	}
}

javaVerifyFiTypeFunction(t : FiType) -> Maybe<FiTypeFunction> {
	switch (t) {
		FiTypeFunction(__, __): Some(t);
		default: None();
	}
}

type2javaRuntimeType(t : FiType) -> string {
	switch (t) {
		FiTypeArray(__):        "RuntimeType.ARRAY";
		FiTypeFunction(__, __): "RuntimeType.UNKNOWN";
		FiTypeRef(__):          "RuntimeType.REF";
		FiTypeParameter(__):    "RuntimeType.UNKNOWN";
		FiTypeBool():           "RuntimeType.BOOL";
		FiTypeInt():            "RuntimeType.INT";
		FiTypeDouble():         "RuntimeType.DOUBLE";
		FiTypeString():         "RuntimeType.STRING";
		FiTypeFlow():           "RuntimeType.UNKNOWN";
		FiTypeVoid():           "RuntimeType.UNKNOWN";
		FiTypeNative():         "RuntimeType.UNKNOWN";
		FiTypeName(__, __):     "RuntimeType.STRUCT"
	}
}

type2javaStruct(gctx : JavaGlobalContext, t : FiType) -> Maybe<JavaStruct> {
	switch (t) {
		FiTypeName(name, __):
			switch(lookupTree(gctx.cstructs, name)) {
				Some(cstruct):
					if (length(cstruct.fields) > 0)
						Some(cstruct)
					else
						None();
				None(): None();
			}
		default: None();
	}
}

ctxtype2javaObjType(ctx : JavaScopeContext, type : FiType, field : bool, no_args : bool) {
	fctx = ctx.func;
	type2javaObjType(fctx.gctx, type, field, no_args, false);
}

jctxPushStr(ctx : JavaScopeContext, str : string) {
	rlistPush(ctx.func.text, str);
}

jctxPushLocal(ctx : JavaScopeContext, info : JavaLocalInfo) {
	JavaScopeContext(ctx.func, ctx.indent, setTree(ctx.locals, info.name, info))
}

jctxPushIndent(ctx : JavaScopeContext, delta : string) {
	JavaScopeContext(ctx.func, ctx.indent + delta, ctx.locals)
}

wrapJavaCast(expr : string, srct : string, dstt : string) {
	if (srct == dstt || dstt == "Object" || (dstt == "Struct" && startsWith(srct,"Struct_"))) {
		expr
	} else {
		igen = strIndexOf(dstt, "<");
		if (igen > 0 && strlen(srct) > igen && startsWith(srct, substring(dstt, 0, igen))) {
			"((" + dstt + ")(" + substring(dstt, 0, igen) + ")" + expr + ")"
		} else {
			"((" + dstt + ")" + expr + ")";
		}
	}
}

resolveJavaLocal(ctx : JavaScopeContext, name : string) -> Maybe<JavaLocalInfo> {
	lt = lookupTree(ctx.locals, name);
	switch (lt) {
		Some(info): lt;
		None():
			switch (ctx.func.parent) {
				Some(rp): {
					pctx = ^rp;
					lt2 = resolveJavaLocal(pctx, name);
					switch (lt2) {
						Some(info):
							if (info.is_final)
								lt2
							else {
								lname = javaNewLocalName(pctx.func.next_local_id, name);
								info3 = JavaLocalInfo(name, lname, info.type, true, false);

								jctxPushStr(pctx, pctx.indent + "final " + info.type + " " + lname + " = " + info.id + ";\n");

								rp := jctxPushLocal(^rp, info3);
								Some(info3);
							}
						None(): None();
					}
				}
				None(): None();
			}
	}
}

isJavaStatement(code : FiExp, if_is_statement : bool) {
	switch (code) {
		FiSeq(es, __, __):             length(es) != 1;
		FiLet(__, __, __, __, __, __): true;
		FiLambda(__, __, __, __):      true;
		FiSwitch(__, __, __, __, __):  true;
		FiIf(__, __, __, __, __):      if_is_statement;
		FiCallPrim(op, es, __, __):
			switch (op) {
				FcAssignPrim():        true;
				FcSetMutablePrim(__):  true;
				FcArrayPrim():         length(es) > 10;
				default:               false;
			}
		default: false;
	}
}

isSafeJavaStatement(gctx : JavaGlobalContext, code : FiExp) {
	switch (code) {
		FiCall(f, es, __, __):
			switch (f) {
				FiVar(x, __, __):
					lookupTree(gctx.cstructs, x) == None();
				default:
					true;
			}
		default:
			false;
	}
}

isJavaReturnStmt(retloc : JavaReturnLocation) {
	switch (retloc) {
		JavaReturnStmt(t): true;
		default: false;
	}
}

javaReturnValue(ctx : JavaScopeContext, retloc : JavaReturnLocation, valstr : string) -> void {
	switch (retloc) {
		JavaReturnIgnore(): {}
		JavaReturnLocal(name,type):
			jctxPushStr(ctx, ctx.indent + name + "=" + valstr + ";\n");
		JavaReturnStmt(type):
			jctxPushStr(ctx, ctx.indent + "return " + valstr + ";\n");
	}
}

javaReturnNull(ctx : JavaScopeContext, retloc : JavaReturnLocation) -> void {
	javaReturnValue(ctx, retloc, "null");
}

javaStatementPullContext(local_counter : ref int) {
	FiStatementPullContext(
		\s -> isJavaStatement(s, false),
		\ -> {
			id = ^local_counter;
			local_counter := id + 1;
			"$" + i2s(id);
		}
	)
}

checkJavaNativeExists(gctx : JavaGlobalContext, native_host : string, native_name : string) -> bool {
	host_natives = lookupTreeDef(gctx.runtime.natives, native_host, makeSet());
	containsSet(host_natives, native_name);
}

javaNewLocalName(counter : ref int, name : string) {
	id = ^counter;
	counter := id + 1;
	"l" + i2s(id) + "_" + name;
}

addJavaExpressionWrappers(gctx : JavaGlobalContext, expcode : FiExp) -> void {
	switch (expcode) {
		FiConst(__): { }
		FiSeq(es, __, __):
			iter(es, \e -> addJavaExpressionWrappers(gctx, e));
		FiVar(name, __, __): { }
		FiCall(f, es, __, __): {
			global = switch (f) {
				FiVar(fname, tp, __): {
					switch (lookupTree(gctx.globals, fname)) {
						Some(__): None();
						None(): lookupTree(gctx.globalFuncs, fname);
					}
				}
				default: None();
			};
			iter(es, \expr -> addJavaExpressionWrappers(gctx, expr));
			switch (global) {
				Some(__): { }
				None(): addJavaExpressionWrappers(gctx, f);
			}
		}
		FiIf(cond, ethen, eelse, __, __): {
			addJavaExpressionWrappers(gctx, cond);
			addJavaExpressionWrappers(gctx, ethen);
			addJavaExpressionWrappers(gctx, eelse);
		}
		FiCast(e, __,__,__,__):
			addJavaExpressionWrappers(gctx, e);
		FiCallPrim(op, es, type, __): {
			iter(es, \e -> addJavaExpressionWrappers(gctx, e));
			switch (op) {
				FcFieldPrim(field): {
					if (field != "structname") {
						switch (type2javaStruct(gctx, fiExpType(es[0]))) {
							Some(__): { }
							None(): javaRequireAccessor(gctx, field);
						}
					}
				}
				FcSetMutablePrim(field): {
					switch (type2javaStruct(gctx, type)) {
						Some(__): { }
						None(): javaRequireAccessor(gctx, field);
					}
				}
				default: { }
			}
        }
		FiLet(__, __, e1, e2, __, __): {
			addJavaExpressionWrappers(gctx, e1);
			addJavaExpressionWrappers(gctx, e2);
		}
		FiSwitch(x, __, cases, __,__): {
			addJavaExpressionWrappers(gctx, x);
			iter(cases, \c -> addJavaExpressionWrappers(gctx, c.body));
		}
		FiRequire(__, e, __,__):
			addJavaExpressionWrappers(gctx, e);
		FiUnsafe(__, fallback, __,__):
			addJavaExpressionWrappers(gctx, fallback);
		FiLambda(__, body, __,__):
			addJavaExpressionWrappers(gctx, body);
	}
}

usePreviouslyGeneratedModules(gctx : JavaGlobalContext, module : FiModule, path : string) -> bool {
	if (!gctx.hash_collisions && module.incremental && fileExists(path)) {
		collision_and_time = getCollisionAndTimestampOfFile(path);
		!collision_and_time.first && collision_and_time.second == d2s(module.fileinfo.trampstamp);
	} else {
		false
	}
}
