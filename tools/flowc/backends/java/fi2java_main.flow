import math/hash;
import tools/flowc/backends/common;
import tools/flowc/backends/java/fi2java_defines;

export {
	generateJavaMainCode(gctx : JavaGlobalContext) -> void;
}

generateJavaMainCode(gctx : JavaGlobalContext) -> void {
	pushstr = \s -> rlistPush(gctx.main_file_text, s);
	config = gctx.program.config;
	
	pushstr("\n\t// Singleton structs\n");
	pushstr("\tstatic final Object[] arr_empty = new Object[0];\n");
	singleton_struct_list = foldTree(gctx.cstructs, [], \sname, sdata : JavaStruct,acc -> {
		if (length(sdata.fields) == 0) {
			pushstr("\tstatic final SingletonStruct str_" + sname + " = SingletonStruct.make(" + i2s(sdata.id) + ",\"" + sname + "\");\n");
			arrayPush(acc, "\t\t\tstr_" + sname);
		} else {
			arrayPush(acc, "\t\t\tnew Struct_" + sname + "()");
		}
	});

	// Module initializers
	pushstr("\n\t// Modules\n");
	iter(gctx.csm_list, \csm ->
		pushstr("\tfinal Module_" + csm.id + " m_" + csm.id + " = new Module_" + csm.id + "(this);\n")
	);
	if (isConfigParameterTrue(config.config, "java-main-size-stats")) {
		fcPrintln("Main singleton structs: " + i2s(length(singleton_struct_list)), config.threadId);
		fcPrintln("Main modules: " + i2s(length(gctx.csm_list)), config.threadId);
	}

	pushstr("\n\t// Singleton structs array\n");
	if (length(singleton_struct_list) < 128) {
		// All structs array
		pushstr("\tstatic final private Struct[] struct_list = {\n");
		pushstr(strGlue(singleton_struct_list, ",\n") + "\n");
		pushstr("\t};\n");

		// Constructor
		pushstr("\tpublic Main(String[] args) {\n");
		pushstr("\t\tsuper(struct_list, args);\n");
		pushstr("\t}\n");
	} else {
		singleton_struct_list_chunks = splitByNumber(singleton_struct_list, 128);
		// All structs array
		iteri(singleton_struct_list_chunks, \i, chunk -> {
			pushstr("\tstatic final private Struct[] struct_list_" + i2s(i) + " = {\n");
			pushstr(strGlue(chunk, ",\n") + "\n");
			pushstr("\t};\n");
		});
		pushstr("\tstatic private final Struct[] struct_list() {\n");
		pushstr("\t\tStruct[] structs = new Struct[" + i2s(length(singleton_struct_list)) + "];\n");
		pushstr("\t\tint k = 0;\n");
		iteri(singleton_struct_list_chunks, \i, __ ->
			pushstr("\t\tfor (Struct s : struct_list_" + i2s(i) + ") structs[k++] = s;\n")
		);
		pushstr("\t\treturn structs;\n");
		pushstr("\t}\n");
		// Constructor
		pushstr("\tpublic Main(String[] args) {\n");
		pushstr("\t\tsuper(struct_list(), args);\n");
		pushstr("\t}\n");
	}

	wrappers = list2array(^(gctx.wrapper_code));
	if (isConfigParameterTrue(config.config, "java-main-size-stats")) {
		fcPrintln("Main wrappers: " + i2s(length(wrappers)), config.threadId);
	}
	pushstr("\n\t// Wrappers\n");
	pushstr(concatStrings(wrappers));

	native_wrappers = list2array(^(gctx.native_wrapper_code));
	if (isConfigParameterTrue(config.config, "java-main-size-stats")) {
		fcPrintln("Main native wrappers: " + i2s(length(native_wrappers)), config.threadId);
	}
	pushstr("\n\t// Native Wrappers\n");
	pushstr(concatStrings(native_wrappers));

	// init function
	pushstr("\n\t// Init function\n");
	host_inits = list2array(foldTree(gctx.uses_host, makeList(), \host, v, acc -> {
		pushstr("\t" + host + " h_" + host + ";\n");
		Cons("\t\th_" + host + " = super.getNativeHost(" + host + ".class);\n", acc);
	}));

	pushstr("\n\t// Init hosts\n");
	if (length(host_inits) < 32) {
		pushstr("\tfinal private void init_hosts() {\n");
		pushstr(concatStrings(host_inits));
		pushstr("\t}\n");
	} else {
		host_init_chuncks = splitByNumber(host_inits, 32);
		iteri(host_init_chuncks, \i, chunk -> {
			pushstr("\tfinal private void init_hosts_" + i2s(i) + "() {\n");
			pushstr(concatStrings(chunk));
			pushstr("\t}\n");
		});
		pushstr("\tfinal private void init_hosts() {\n");
		iteri(host_init_chuncks, \i, __ ->
			pushstr("\t\tinit_hosts_" + i2s(i) + "();\n")
		);
		pushstr("\t}\n");
	}

	pushstr("\n\t// Init code\n");
	init_code = list2array(^(gctx.init_code));
	if (length(init_code) < 32) {
		pushstr("\tfinal private void init_code() {\n");
		pushstr(concatStrings(init_code));
		pushstr("\t}\n");
	} else {
		init_code_chuncks = splitByNumber(init_code, 32);
		iteri(init_code_chuncks, \i, chunk -> {
			pushstr("\tfinal private void init_code_" + i2s(i) + "() {\n");
			pushstr(concatStrings(chunk));
			pushstr("\t}\n");
		});
		pushstr("\tfinal private void init_code() {\n");
		iteri(init_code_chuncks, \i, __ ->
			pushstr("\t\tinit_code_" + i2s(i) + "();\n")
		);
		pushstr("\t}\n");
		if (isConfigParameterTrue(config.config, "java-main-size-stats")) {
			fcPrintln("Main init_code chunks: " + i2s(length(init_code_chuncks)), config.threadId);
		}
	}

	pushstr("\tfinal private void init() {\n");
	pushstr("\t\tinit_hosts();\n");
	pushstr("\t\tinit_code();\n");
	pushstr("\t}\n");

	// main function
	pushstr("\tprotected void main() {\n");
	pushstr("\t\tinit();\n");

	switch (lookupTree(gctx.globalFuncs, "main")) {
		Some(finfo):
			pushstr("\t\tm_" + finfo.csmodule.id + "." + finfo.name + "();\n");
		None():
			fail0("No main function");
	}
	pushstr("\t}\n");
	
	pushstr("\tpublic static void main(String[] args) {\n");
	pushstr("\t\tMain runner = new Main(args);\n");
	pushstr("\t\trunner.start(null);\n");
	pushstr("\t}\n");
}
