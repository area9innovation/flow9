import tools/flowc/backends/cpp2/fi2cpp2_defines;
import tools/flowc/incremental/fiprettyprint;

export {

clearMeta(meta : Cpp2PlaceMetadata) -> Cpp2PlaceMetadata;
copyMeta(meta : Cpp2PlaceMetadata) -> Cpp2PlaceMetadata;
cpp2TagTostring(tag : Cpp2TagType) -> string;
cpp2GetStructAType(t : FiType) -> Cpp2TagType;
cpp2IsStructFieldTag(type : Cpp2TagType) -> bool;
cpp2StructFieldCode(type : Cpp2TagType) -> string;
cpp2IsNonGCFieldType(type : Cpp2TagType) -> bool;

cpp2PlaceInfo(env: Maybe<Cpp2Environment>, place: Cpp2PlaceType, slot: int, name : string) -> Cpp2PlaceInfo;
cpp2PlaceInfoIsSame(info1 : Cpp2PlaceInfo, info2 : Cpp2PlaceInfo) -> bool;
cpp2PlaceInfoIsStub(info : Cpp2PlaceInfo) -> bool;
// Temporarily overwrite the actual location, retaining the uid and
// meta identity. Returns a callback to restore the original state.
cpp2PlaceInfoSubstituteLocation(info1 : Cpp2PlaceInfo, info2 : Cpp2PlaceInfo) -> () -> void;
cpp2PlaceInfoIsStub(info : Cpp2PlaceInfo) -> bool;
cpp2PlaceInfoGetLValue(info : Cpp2PlaceInfo) -> string;
cpp2PlaceInfoIsClosureRef(info : Cpp2PlaceInfo) -> bool;
cpp2PlaceInfoGetRawField(info : Cpp2PlaceInfo, ctx : Cpp2Context, type : Cpp2TagType) -> string;
cpp2PlaceInfoGetStructAddr(info : Cpp2PlaceInfo, ctx : Cpp2Context) -> string;



cpp2CodeLines(parent : Maybe<Cpp2CodeLines>) -> Cpp2CodeLines;
cpp2CodeLinesToCode(code : Cpp2CodeLines) -> string;





cpp2ContextEnsureStructPtr(ctx : Cpp2Context, sref : Cpp2PlaceInfo, structname : string, init : bool) -> string {
	""
}
cpp2ContextGetStructField(ctx : Cpp2Context, sref : Cpp2PlaceInfo, structname : string, fname : string, ftype : Cpp2TagType) -> string {
	""
}
cpp2ContextGetStructPtr(ctx : Cpp2Context, sref : Cpp2PlaceInfo, structname : string, init : bool) -> string {
	""
}
cpp2Context(env : Cpp2Environment, indent : string) -> Cpp2Context;

}

clearMeta(meta : Cpp2PlaceMetadata) -> Cpp2PlaceMetadata {
	Cpp2PlaceMetadata(
		meta.context,
		meta.dirty,
		None(), None(), None(), None(),
		None(), None(), None(), None(),
	)
}

copyMeta(meta : Cpp2PlaceMetadata) -> Cpp2PlaceMetadata {
	/*var rv = Reflect.copy(meta);
	if (rv.known_fields != null)
		rv.known_fields = rv.known_fields.list();
	if (rv.known_compares != null)
		rv.known_compares = rv.known_compares.list();
	if (rv.struct_ptr_types != null)
		rv.struct_ptr_types = rv.struct_ptr_types.list();
	return rv;*/
	meta
}

/*
cpp2_meta_merge_fn : [flow] = [
		\a : flow, b : flow -> if (a == b) a else None(),
		\a : flow, b : flow -> if (a == b) a else None(),
		\a : Maybe<int>, b : Maybe<int> ->
			eitherMap(b, \bi -> eitherMap(a, \ai -> ai > bi, None()) ,None()),
		\a : Maybe<int>, b : Maybe<int> -> if (a == b) a else None(),
		function(a : List<string>, b : Maybe<List<string>>) {
			return if (b == null) null
			else a.filter(function(v) { return b.has(v); });
		},
		function(a : List<CppPlaceInfo>,b : Maybe<List<CppPlaceInfo>>) {
			return if (b == null) null
			else a.filter(function(v) { return b.has(v); });
		},
		function(a:Maybe<int>,b:Maybe<int>) { return if (b == null) null else if (a > b) b else a; },
		function(a : List<string>, b : Maybe<List<string>>) {
			return if (b == null) null
			else a.filter(function(v) { return b.has(v); });
		},
	];
*/

cpp2TagTostring(tag : Cpp2TagType) -> string {
	switch (tag) {
		Cpp2TVoid():           "TVoid";
		Cpp2TBool():           "TBool";
		Cpp2TInt():            "TInt";
		Cpp2TDouble():         "TDouble";
		Cpp2TString():         "TString";
		Cpp2TArray():          "TArray";
		Cpp2TStruct():         "TStruct";
		Cpp2TCodePointer():    "TCodePointer";
		Cpp2TNativeFn():       "TNativeFn";
		Cpp2TRefTo():          "TRefTo";
		Cpp2TNative():         "TNative";
		Cpp2TClosurePointer(): "TClosurePointer";
		Cpp2TNull(): {
			cpp2_error("Cpp2TNull() value must not be printed");
			"null";
		}
	}
}

cpp2GetStructAType(t : FiType) -> Cpp2TagType {
	switch(t) {
		FiTypeVoid():      Cpp2TNull();
		FiTypeBool():      Cpp2TBool();
		FiTypeInt():       Cpp2TInt();
		FiTypeDouble():    Cpp2TDouble();
		FiTypeString():    Cpp2TString();
		FiTypeArray(__):   Cpp2TArray();
		FiTypeName(__,__): Cpp2TStruct();
		FiTypeRef(__):     Cpp2TRefTo();
		default:           Cpp2TNull();
	}
}

cpp2IsStructFieldTag(type : Cpp2TagType) -> bool {
	switch (type) {
		Cpp2TBool():   true;
		Cpp2TInt():    true;
		Cpp2TDouble(): true;
		Cpp2TString(): true;
		Cpp2TArray():  true;
		Cpp2TRefTo():  true;
		Cpp2TStruct(): true;
		default:       false;
	}
}

cpp2StructFieldCode(type : Cpp2TagType) -> string {
	switch (type) {
		Cpp2TBool():   "bool";
		Cpp2TInt():    "int";
		Cpp2TDouble(): "double";
		Cpp2TString(): "string";
		Cpp2TArray():  "array";
		Cpp2TRefTo():  "ref";
		Cpp2TStruct(): "struct";
		Cpp2TNull():   "slot";
		default: {
			cpp2_error("impossible type in cpp2StructFieldCode");
			"impossible";
		}
	}
}

cpp2IsNonGCFieldType(type : Cpp2TagType) -> bool {
	switch (type) {
		Cpp2TBool():   true;
		Cpp2TInt():    true;
		Cpp2TDouble(): true;
		default:       false;
	}
}


// Cpp2PlaceInfo methods
cpp2PlaceInfo(env: Maybe<Cpp2Environment>, place: Cpp2PlaceType, slot: int, name : string) -> Cpp2PlaceInfo {
	cpp2PlaceInfoMeta(
		env, place, slot, name, 
		Cpp2PlaceMetadata(
			eitherMap(env, \e -> 
				switch (e.cur_ctx) {
					Some(ctx): ctx.id;
					None(): -1;
				}, 
				-1
			),
			false,
			None(), None(), None(), None(),
			None(), None(), None(), None(),
		)
	)
}

cpp2PlaceInfoMeta(env: Maybe<Cpp2Environment>, place: Cpp2PlaceType, slot: int, name : string, meta : Cpp2PlaceMetadata) -> Cpp2PlaceInfo {
	Cpp2PlaceInfo(
		env, place, slot, name, meta,
		eitherMap(env,
			\e -> {
				ret = e.next_uid;
				e.next_uid ::= ret + 1;
				ret
			},
			{ 
				ret = ^cpp2_next_guid;
				cpp2_next_guid := ret + 1;
				ret
			}
		),
		"", ""
	)
}

cpp2PlaceInfoIsSame(info1 : Cpp2PlaceInfo, info2 : Cpp2PlaceInfo) -> bool {
	info1.slot == info2.slot && info1.place == info2.place
}

// Temporarily overwrite the actual location, retaining the uid and
// meta identity. Returns a callback to restore the original state.
cpp2PlaceInfoSubstituteLocation(info1 : Cpp2PlaceInfo, info2 : Cpp2PlaceInfo) -> () -> void {
	cur_place = info1.place;
	cur_slot = info1.slot;
	info1.place ::= info2.place;
	info1.slot ::= info2.slot;
	info1.rvalue ::= "";
	info1.lvalue ::= "";
	\ -> {
		info1.place ::= cur_place;
		info1.slot ::= cur_slot;
		info1.rvalue ::= "";
		info1.lvalue ::= "";
	};
}

cpp2PlaceInfoIsStub(info : Cpp2PlaceInfo) -> bool {
	info.slot < 0
}

cpp2PlaceInfoGetLValue(info : Cpp2PlaceInfo) -> string {
	if (info.lvalue != "") info.lvalue else {
		lval = switch (info.place) {
			Cpp2GlobalVar():
				cpp2_GLOBALS + i2s(info.slot) + cpp2_CMSTART + info.name + cpp2_CMENDBR;
			Cpp2Local():
				cpp2_LOCALS + i2s(info.slot) + cpp2_CMSTART + info.name +  cpp2_CMENDBR;
			Cpp2Argument(): {
				switch (info.env) {
					Some(e): e.args_used ::= true;
					None(): { }
				}
				if (info.slot < 0) "RUNNER_CLOSURE"
				else {
					cpp2_RUNNER_ARG + i2s(info.slot) + cpp2_CMSTART + info.name + cpp2_CMENDPR;
				}
			}
			Cpp2Temporary():
				cpp2_TEMPS + i2s(info.slot) + cpp2_RBRACE;
			Cpp2Struct(info1): {
				cpp2_error("no lvalue for struct " + info1.structname);
				""
			}
			Cpp2SlotAlias(where, idx): {
				cpp2_error("no lvalue for field alias");
				""
			}
			Cpp2FieldAlias(where,sinfo): {
				cpp2_error("no lvalue for field alias");
				"";
			}
			Cpp2GlobalFunction(__,__): {
				cpp2_error("no lvalue for global function");
				""
			}
			Cpp2NoPlace(code, err): {
				cpp2_error(prettyFiExp(dummyPretty, code) + ": " + err);
				""
			}
		};
		info.lvalue ::= lval;
		lval
	}
}

cpp2PlaceInfoIsClosureRef(info : Cpp2PlaceInfo) -> bool {
	switch (info.place) {
		Cpp2Argument(): info.slot < 0;
		default: false;
	}
}

cpp2PlaceInfoIsLValue(info : Cpp2PlaceInfo) -> bool {
	switch (info.place) {
		Cpp2GlobalVar(): true;
		Cpp2Local():     true;
		Cpp2Argument():  true;
		Cpp2Temporary(): true;
		default:         false;
	}
}

cpp2PlaceInfoGetRValue(info : Cpp2PlaceInfo, ctx : Cpp2Context) -> string {
	if (info.rvalue != "") {
			switch (info.place) {
				Cpp2SlotAlias(where, idxvar):
					cpp2ContextEnsureStructPtr(ctx, where, "", true);
				Cpp2FieldAlias(where, sinfo):
					cpp2ContextEnsureStructPtr(ctx, where, sinfo.structname, true);
				default:  "";
			}
			info.rvalue
	} else {
		rval = switch (info.place) {
			Cpp2GlobalFunction(__,__): {
				if (info.slot < 0) {
					cpp2_error("no assigned function slot"); ""
				} else {
					cpp2_FUNCTIONS + i2s(info.slot) + cpp2_CMSTART + info.name + cpp2_CMENDBR;
				}
			}
			Cpp2SlotAlias(where, idxvar): {
				cpp2ContextGetStructPtr(ctx, where, "", true) +
				cpp2_LBRACE + (if (idxvar == "") i2s(info.slot) else idxvar);
				cpp2_CMSTART + info.name + cpp2_CMENDBR;
			}
			Cpp2FieldAlias(where, sinfo): {
				fname = sinfo.args[info.slot].name;
				s = cpp2ContextGetStructField(ctx, where, sinfo.structname, fname, sinfo.atypes[info.slot]);
				if (info.name != "" && info.name != fname) {
					s + cpp2_CMSTART + info.name + cpp2_CMEND;
				} else {
					s
				}
			}
			Cpp2Struct(info1): {
				if (length(info1.args) != 0) {
					cpp2_error("no rvalue for struct with parameters: " + info1.structname);
				}
				switch (info1.empty_addr) {
					Some(empty_addr): "StackSlot::MakeStruct(MakeFlowPtr(" + i2s(empty_addr) + ")," + i2s(info.slot) + ")";
					None(): {
						cpp2_error("no empty_addr in Cpp2Struct"); "";
					}
				}
			}
			default:
				cpp2PlaceInfoGetLValue(info);
		}
		info.rvalue ::= rval;
		rval
	}
}

cpp2PlaceInfoGetRawField(info : Cpp2PlaceInfo, ctx : Cpp2Context, type : Cpp2TagType) -> string {
	switch (info.place) {
		Cpp2FieldAlias(where, sinfo): {
			if (sinfo.atypes[info.slot] == type) {
				cpp2ContextGetStructPtr(ctx, where, sinfo.structname, true) + "->fl_" + sinfo.args[info.slot].name;
			} else {
				""
			}
		}
		default: "";
	}
}

cpp2PlaceInfoGetStructAddr(info : Cpp2PlaceInfo, ctx : Cpp2Context) -> string {
	defval = \ -> cpp2PlaceInfoGetRValue(info, ctx) + ".GetRawStructPtr()";
	switch (info.place) {
		Cpp2FieldAlias(where, sinfo): {
			if (sinfo.atypes[info.slot] == Cpp2TStruct()) {
				cpp2ContextGetStructPtr(ctx, where, sinfo.structname, true) + "->fl_" + sinfo.args[info.slot].name;
			} else {
				defval();
			}
		}
		default: defval();
	}
}


	

	
	
	
	
	
	
	
	
	
	
	
	
	
// Cpp2CodeLines methods

cpp2CodeLines(parent : Maybe<Cpp2CodeLines>) -> Cpp2CodeLines {
	Cpp2CodeLines(ref [], parent)
}

cpp2CodeLinesToCode(code : Cpp2CodeLines) -> string {
	cpp2CodeLinesPullCommonDecls(code);
	cpp2CodeLinesToString(code, "")
}

cpp2CodeLinesToString(code : Cpp2CodeLines, acc : string) -> string {
	fold(^(code.lines), acc, 
		\ac, line -> {
			switch (line) {
				Cpp2Decl(type, name, indent, origin):
					ac + indent + type + " " + name + ";\n";
				Cpp2Any(line1):
					ac + line1;
				Cpp2Block(code1):
					cpp2CodeLinesToString(code1, ac);
			}
		}
	)
}

cpp2CodeLinesPullCommonDecls(code : Cpp2CodeLines) -> void {
	decl2line = filterTree(
		cpp2CodeLinesDecl2Line(code, makeTree()),
		\__, lines -> length(lines) > 1
	);
	traverseInOrder(decl2line,
		\name, decl_lines -> {
			switch (cpp2CodeLinesLeastCommonAncestor(decl_lines)) {
				Some(common): {
					iter(decl_lines, \decl : Cpp2Decl ->
						decl.origin.lines := removeFirst(^(decl.origin.lines), decl)
					);
					common.lines := concat([cast(decl_lines[0] : Cpp2Decl -> Cpp2Line)], ^(common.lines));
				}
				None(): {
					cpp2_error("no common ancestor is found");
				}
			}
		
		}
	)
}

cpp2CodeLinesLeastCommonAncestor(lines : [Cpp2Decl]) -> Maybe<Cpp2CodeLines> {
	paths = fold(lines, [],
		\acc, decl -> {
			path = cpp2CodeLinesGetPath(Some(decl.origin), []);
			concat(acc, [path]);
		}
	);
	cpp2CodeLinesFindCommon(0, None(), paths)
}
	
cpp2CodeLinesFindCommon(i : int, val : Maybe<Cpp2CodeLines>, paths : [[Cpp2CodeLines]]) -> Maybe<Cpp2CodeLines> {
	if (
		forall(paths, \path -> i < length(path)) &&
		forall(map(paths, \path -> path[i]), \c -> c == paths[0][i])
	) {
		cpp2CodeLinesFindCommon(i + 1, Some(paths[0][i]), paths)
	} else {
		val
	}
}

cpp2CodeLinesGetPath(mcode : Maybe<Cpp2CodeLines>, acc : [Cpp2CodeLines]) -> [Cpp2CodeLines] {
	switch (mcode) {
		Some(code): cpp2CodeLinesGetPath(code.parent, concat([code], acc));
		None(): acc;
	}
}
	
cpp2CodeLinesDecl2Line(code : Cpp2CodeLines, acc : Tree<string, [Cpp2Decl]>) -> Tree<string, [Cpp2Decl]> {
	fold(^(code.lines), acc, 
		\ac, line -> {
			switch (line) {
				Cpp2Decl(type, name, indent, origin): {
					switch (lookupTree(ac, name)) {
						Some(lines): setTree(ac, name, concat(lines, [line]));
						None(): setTree(ac, name, [line]);
					}
				}
				Cpp2Block(code1): {
					cpp2CodeLinesDecl2Line(code1, ac);
				}
				default: acc;
			}
		}
	)
}
	
	
	
	
	
	
	
	
	
	
// Cppe2Environment methods:

cpp2Environment(parent : Maybe<Cpp2Environment>, mname : string, vname : string) -> Cpp2Environment {
	depth = switch (parent) {
		Some(p): p.depth + 1;
		None(): 1;
	};
	env = Cpp2Environment(
		parent,
		mname,
		vname,
		depth,
		1000000 * depth, // next_uid
		0, // next_ctx
		0, // nlocals
		0, // ntemps
		0, // nargs
		[], // local_reuse
		false, // args_used
		None(), // closure
		[], // upvalues
		false, // tail_call
		0, // lines
		None(), // cur_ctx = new CppContext(this, '    ');
		makeTree(), // locals
		makeTree(), // meta_globals
		cpp2CodeLines(None()) // code_lines
	);
	env.cur_ctx ::= Some(cpp2Context(env, "    "));
	env
}

cpp2EnvironmentPushCppBlock(env : Cpp2Environment) -> void {
	env.code_lines ::= cpp2CodeLines(Some(env.code_lines));
}

cpp2EnvironmentPopCppBlock(env : Cpp2Environment) -> void {
	switch (env.code_lines.parent) {
		Some(p): refArrayPush(p.lines, Cpp2Block(env.code_lines));
		None(): { }
	}
	env.code_lines ::= env.code_lines.parent;
}

cpp2EnvironmentAddCppLine(env : Cpp2Environment, line : Cpp2Line) ->void {
	refArrayPush(env.code_lines.lines, line);
}

cpp2EnvironmentMktemp(env : Cpp2Environment, id : int) -> Cpp2PlaceInfo {
	if (id >= env.ntemps) {
		env.ntemps ::= id + 1;
	}
	cpp2PlaceInfo(Some(env), Cpp2Temporary(), id, "")
}

cpp2EnvironmentTempvar(env : Cpp2Environment, base : string) -> string {
	uid = env.next_uid;
	env.next_uid ::= env.next_uid + 1;
	base + i2s(uid);
}

cpp2EnvironmentMkupvalue(env : Cpp2Environment, name : string, free : Cpp2PlaceInfo) -> Cpp2PlaceInfo {
	id = length(env.upvalues);
	env.upvalues ::= arrayPush(env.upvalues, name);
	type = switch (free.meta.type) {
		None(): {
			(free.meta).type ::= Some(FiTypeFlow());
			FiTypeFlow()
		}
		Some(tp): tp;
	}
	ttag = cpp2GetStructAType(type);
	vtag = ref free.meta.tag;
	if (!cpp2IsStructFieldTag(^vtag)) {
		vtag := Cpp2TNull();
	}
	if (ttag != Cpp2TNull()) {
		vtag := if (^vtag == Cpp2TNull() || ^vtag == ttag) ttag else Cpp2TNull();
	}
	tdecl = Cpp2TypeDeclaration(
		"up_" + i2s(id), // name
		type,
		false // is_mutable
	);
	meta = Cpp2PlaceMetadata(
		0, // context
		false, // dirty
		Some(^vtag), // tag 
		Some(type), // type 
		None(), // struct_size
		None(), // struct_id
		None(), // known_fields
		None(), // known_compares
		None(), // struct_ptr_gcid
		None(), // struct_ptr_types
	);
	info = switch (env.closure) {
		None(): {
			new_closure = Cpp2Closure(
				cpp2PlaceInfo(Some(env), Cpp2Argument(), -1, ""),
				Cpp2StructInfo(
					None(),    // id
					env.mname, // structname
					[tdecl],   // args
					[^vtag],    // atypes
					None()     // empty_addr
				)
			);
			(new_closure.place.meta).context ::= 0;
			env.closure ::= Some(new_closure);
			cpp2PlaceInfoMeta(Some(env), Cpp2FieldAlias(new_closure.place, new_closure.type), id, name, meta);
		}
		Some(closure): {
			(closure.type).args ::= arrayPush(closure.type.args, tdecl);
			(closure.type).atypes ::= arrayPush(closure.type.atypes, ^vtag);
			cpp2PlaceInfoMeta(Some(env), Cpp2FieldAlias(closure.place, closure.type), id, name, meta);
		}
	}
	env.locals ::= setTree(env.locals, name, info);
	info
}


cpp2EnvironmentMklocal(env : Cpp2Environment, name : string) -> Cpp2PlaceInfo {
	id = if (length(env.local_reuse) > 0) {
		i = env.local_reuse[length(env.local_reuse) - 1];
		env.local_reuse ::= take(env.local_reuse, length(env.local_reuse) - 1);
		i
	} else {
		i = env.nlocals;
		env.nlocals ::= env.nlocals + 1;
		i
	};
	cpp2PlaceInfo(Some(env), Cpp2Local(), id, name);
}

cpp2EnvironmentPoplocal(env : Cpp2Environment, name : string, olddef : Cpp2PlaceInfo) -> void {
	switch (lookupTree(env.locals, name)) {
		Some(curdef): {
			env.locals ::= setTree(env.locals, name, olddef);
			if (curdef.place == Cpp2Local()) {
				env.local_reuse ::= arrayPush(env.local_reuse, curdef.slot);
			}
		}
		None(): {
			cpp2_error("no name " + name + " in env locals");
		}
	}
}

cpp2EnvironmentStashGlobalMeta(env : Cpp2Environment) -> void {
	traverseInOrder(env.meta_globals, 
		\__, info -> {
			info.my ::= info.def.meta;
			(info.def).meta ::= info.old;
		}
	)
}

cpp2EnvironmentRestoreGlobalMeta(env : Cpp2Environment) -> void {
	traverseInOrder(env.meta_globals,
		\__, info -> (info.def).meta ::= info.my
	)
}




	
	
	
	
	
	
	
	
	

// Cpp2Context methods

cpp2Context(env : Cpp2Environment, indent : string) -> Cpp2Context {
	id = env.next_ctx;
	env.next_ctx ::= env.next_ctx + 1;
	gc_index = switch (env.cur_ctx) {
		Some(ctx): ctx.gc_index;
		None(): 0;
	};
	Cpp2Context(
		env,
		env.cur_ctx, // prev
		id,
		gc_index,
		indent,
		[], // local_names
		[], // local_binds
		makeTree(), // idxvars
		makeTree(), // meta
	)
}


/*
public function new(env : CppEnvironment, indent : string) {
	this.env = env;
	this.prev = env.cur_ctx;
	this.indent = indent;
	this.id = env.next_ctx++;

	gc_index = (prev != null) ? prev.gc_index : 0;

	local_names = [];
	local_binds = [];
	meta = new Map();
	idxvars = new OrderedHash();
	env.pushCppBlock();
}


public function exit() {
	env.popCppBlock();
	popdefs();

	for (mid in meta.iterator()) {
		mid.def.meta = mid.old;

		// Forget globals if restored
		if (mid.def.env == null && mid.old.context < 0)
			env.meta_globals.remove(mid.def.uid);
	}

	env.cur_ctx = prev;
}

	public function wrbegin() : stringBuf {
	env.lines++;
	var line_str = new stringBuf();
	line_str.add(indent);
	return line_str;
}

public function wr(s : string) {
	var line_str = wrbegin();
	line_str.add(s);
	line_str.add(NEWLINE);
	env.addCppLine(CppAny(line_str.tostring()));
}

public function wrsemi(str : string) {
	var line_str = wrbegin();
	line_str.add(str);
	line_str.add(SEMI_NL);
	env.addCppLine(CppAny(line_str.tostring()));
}

public function wrsemi2(str1 : string, str2 : string) {
	var line_str = wrbegin();
	line_str.add(str1);
	line_str.add(str2);
	line_str.add(SEMI_NL);
	env.addCppLine(CppAny(line_str.tostring()));
}

public function wrsemi3(str1 : string, str2 : string, str3 : string) {
	var line_str = wrbegin();
	line_str.add(str1);
	line_str.add(str2);
	line_str.add(str3);
	line_str.add(SEMI_NL);
	env.addCppLine(CppAny(line_str.tostring()));
}

public function wrsemi4(str1 : string, str2 : string, str3 : string, str4 : string) {
	var line_str = wrbegin();
	line_str.add(str1);
	line_str.add(str2);
	line_str.add(str3);
	line_str.add(str4);
	line_str.add(SEMI_NL);
	env.addCppLine(CppAny(line_str.tostring()));
}

public function enter(idelta : string) {
	return env.cur_ctx = new CppContext(env, indent + idelta);
}

public function localMeta(def : CppPlaceInfo) {
	var curmeta = def.meta;

	var meta = if (curmeta.context >= id) {
		curmeta;
	} else {
		var newmeta = CppPlaceInfo.copyMeta(curmeta);
		newmeta.context = id;
		meta.set(def.uid, { def: def, old: curmeta, my: newmeta });

		// Remember that a global was changed
		if (def.env == null && curmeta.context < 0)
			env.meta_globals.set(def.uid, { def: def, old: curmeta, my: newmeta });

		def.meta = newmeta;
	};

	meta.dirty = true;
	return meta;
}

public function join_one(child : CppContext) {
	if (child.gc_index > gc_index)
		gc_index = child.gc_index;
}

public function join(children : Array<CppContext>) {
	if (children.length == 0) return;

	for (child in children)
		join_one(child);

	var flist = CppPlaceInfo.meta_fields;

	for (mid in children[0].meta.iterator()) {
		var defid = mid.def.uid;

		var best = [];
		for (fn in flist)
			best.push(Reflect.field(mid.my, fn));
		var ok = true;

		for (i in 1...children.length) {
			var cur = children[i].meta.get(defid);
			if (cur == null) {
				ok = false;
				break;
			}
			for (fi in 0...flist.length) {
				if (best[fi] == null)
					continue;
				best[fi] = CppPlaceInfo.meta_merge_fn[fi](
					best[fi], Reflect.field(cur.my, flist[fi])
				);
			}
		}

		if (!ok)
			continue;

		ok = false;
		var cur = mid.def.meta;
		for (fi in 0...flist.length) {
			if (best[fi] == Reflect.field(cur, flist[fi]))
				continue;
			ok = true;
			break;
		}

		if (!ok)
			continue;

		var upd = localMeta(mid.def);
		var dirty = false;
		for (fi in 0...flist.length) {
			if (best[fi] != null) dirty = true;
			Reflect.setField(upd, flist[fi], best[fi]);
		}
		upd.dirty = dirty;
	}
}

public function pushdef(def : CppPlaceInfo) {
	local_names.push(def.name);
	local_binds.push(env.locals.get(def.name));
	env.locals.set(def.name, def);
}

public function defpos() { return local_names.length; }

public function popdefs(?pos : int = 0) {
	for (i in 0...(local_names.length - pos))
		env.poplocal(local_names.pop(), local_binds.pop());
}

public function ensureStructPtr(sref : CppPlaceInfo, structname : string, init : bool = true, sb : stringBuf = null)
{
	var bad_gcid = sref.meta.struct_ptr_gcid == null || sref.meta.struct_ptr_gcid < gc_index;
	var stale = (bad_gcid ||
					sref.meta.struct_ptr_types == null ||
					!sref.meta.struct_ptr_types.has(structname));

	if (stale && sb == null)
		sb = new stringBuf();

	if (sb != null) {
		sb.add(SPTR_);
		sb.add(sref.uid);
		if (structname.length > 0)
		{
			sb.add(UNDERSCORE);
			sb.add(structname);
		}
	}

	if (stale)
	{
		var vname = sb.tostring();

		if (structname == '') {
			registerIdxVar(vname, 'const StackSlot*');

			if (init) {
				var size = sref.meta.struct_size == null ? 1 : sref.meta.struct_size;
				var sb2 = wrbegin();
				sb2.add(vname); sb2.add(GET_ASPTR); sb2.add(sref.getRValue(this));
				sb2.add(COMMA); sb2.add(size<1?1:size); sb2.add(PAREN_SEMI_NL);
				env.addCppLine(CppAny(sb2.tostring()));
			}
		} else {
			var vtype = 'FS_'+structname;
			registerIdxVar(vname, vtype+'*');

			if (init) {
				var sb2 = wrbegin();
				sb2.add(vname); sb2.add(EQ_LPAREN); sb2.add(vtype);

				if (sref.isClosureRef()) {
					sb2.add(GET_CSPTR); sb2.add(sref.getRValue(this));
				} else {
					sb2.add(GET_SPTR); sb2.add(sref.getStructAddr(this));
				}

				sb2.add(PAREN_SEMI_NL);
				env.addCppLine(CppAny(sb2.tostring()));
			}
		}

		var lm = localMeta(sref);
		if (lm.struct_ptr_types == null || bad_gcid)
			lm.struct_ptr_types = new List();
		lm.struct_ptr_gcid = gc_index;
		lm.struct_ptr_types.push(structname);
	}
}

public function getStructPtr(sref : CppPlaceInfo, structname : string = '', init : bool = true) : string
{
	var sb = new stringBuf();
	ensureStructPtr(sref, structname, init, sb);

	if (sref.name != null) {
		sb.add(CMSTART); sb.add(sref.name); sb.add(CMEND);
	}

	return sb.tostring();
}

public function getStructField(sref : CppPlaceInfo, structname : string, fname : string, ftype : CppTagType) : string
{
	var ptr = getStructPtr(sref, structname);
	var vname = ptr+'->fl_'+fname;
	if (ftype == null)
		return vname;

	return switch (ftype) {
	Tbool: 'StackSlot::Makebool('+vname+')';
	Tint: 'StackSlot::Makeint('+vname+')';
	TDouble: 'StackSlot::MakeDouble('+vname+')';
	Tstring: vname;
	TArray: vname;
	TRefTo: vname;
	TStruct:
		'StackSlot::MakeStruct('+vname+',RUNNER->GetStructPtr('+vname+')->StructId)';
	default:
		throw "impossible";
	}
}

public function tempvar(base : string, tag : CppTagType, ?init : string = null) : string {
	var name = env.tempvar(base);
	var type = switch (tag) {
	Tint: 'int';
	TDouble: 'double';
	Tbool: 'bool';
	default: throw 'bad';
	}

	wrsemi4(type,SPACE,name, init!=null ? SPC_EQ_SPC+init : EMPTYSTR);
	return name;
}

public function inc_gc() {
	gc_index++;
}

public function wrcheck(str : string, ?gc = false) {
	var line_str = wrbegin();
	line_str.add(CHECK_ERROR);
	line_str.add(str);
	line_str.add(PAREN_SEMI_NL);
	if (gc) gc_index++;
	env.addCppLine(CppAny(line_str.tostring()));
}

public function wrcheckopt(str : string, check : bool, ?gc = false) {
	if (gc)
		inc_gc();
	if (check)
		wrcheck(str);
	else
	{
		var line_str = wrbegin();
		line_str.add(str);
		line_str.add(SEMI_NL);
		env.addCppLine(CppAny(line_str.tostring()));
	}
}

private function idxVarType(name : string) {
	if (idxvars.get(name) != null) {
		return idxvars.get(name);
	}
	if (prev != null) {
		return prev.idxVarType(name);
	}
	return null;
}

public function registerIdxVar(name : string, type : string) {
	if (idxVarType(name) == null) {
		idxvars.set(name, type);
		env.addCppLine(CppDecl(type, name, indent, env.code_lines));
	}
}














// CppWriter methods

public function new(includes : Array<string>, p : Program, debug : bool, entry : string, outdir : string, extStructDefs : bool)  {
	Profiler.get().profileStart("C++ export");
	this.p = p;
	this.extStructDefs = extStructDefs;
	this.entry = entry;
	this.includes = includes;

	// Allocate a buffer for the bytecode (to store constant strings in)
	bytecode = new BytesOutput(new DebugInfo());
	bytecode.writeByte(Bytecode.CLast);
	bytecode.writeByte(Bytecode.CLast);

	output_dir = outdir;
	file_table = new Map();

	method_names = [];
	function_table = [];
	function_map = new Map();
	global_names = [];
	global_map = new Map();
	field_index_table = [];
	field_index_list = [];
	field_index_map = new Map();
	const_strings = new Map();

	initNativeTables();

	// First, number the structs
	enumerateStructs();

	// Process natives, functions and globals
	enumerateToplevel();

	// Finally, assemble the output file
	emitOutput();

	for (f in file_table.iterator())
		f.close();
}

private function getOutputFile(name : string) {
	f = file_table.get(name);
	if (f == null) {
		try {
			f = sys.io.File.write(output_dir+'/'+name, false);
		} catch (err: Dynamic) {
			trace(err);
			Sys.exit(1);
		}
		file_table.set(name, f);

		if (stringTools.endsWith(name, '.cpp'))
			f.writestring('#include "gen_common.h"\n');
	}
	return f;
}
}
*/
