import tools/flowc/backends/cpp2/fi2cpp2_defines;
import tools/flowc/incremental/fiprettyprint;

export {

cpp2wrLine(o : ref List<string>, lines : [string]) -> void;
cpp2wrArray(cnt : int, per_line : int, head : string, indent : string, tail_ : string, f : (int) -> string) -> string;
cpp2writeLines(lines : List<string>, path : string) -> void;

cpp2FnMethodName(n : string) -> string;
cpp2ClosureMethodName(n : string, idx : int) -> string;
cpp2ClearMeta(meta : Cpp2PlaceMetadata) -> Cpp2PlaceMetadata;
cpp2CopyMeta(meta : Cpp2PlaceMetadata) -> Cpp2PlaceMetadata;
cpp2TagTostring(tag : Cpp2TagType) -> string;
cpp2GetStructAType(t : FiTypeNullable) -> Cpp2TagType;
cpp2IsStructFieldTag(type : Cpp2TagType) -> bool;
cpp2StructFieldCode(type : Cpp2TagType) -> string;
cpp2IsNonGCFieldType(type : Cpp2TagType) -> bool;

cpp2PlaceInfo(env: Maybe<Cpp2Environment>, place: Cpp2PlaceType, slot: int, name : string) -> Cpp2PlaceInfo;
cpp2PlaceInfoIsSame(info1 : Cpp2PlaceInfo, info2 : Cpp2PlaceInfo) -> bool;
cpp2PlaceInfoIsStub(info : Cpp2PlaceInfo) -> bool;
// Temporarily overwrite the actual location, retaining the uid and
// meta identity. Returns a callback to restore the original state.
cpp2PlaceInfoSubstituteLocation(info1 : Cpp2PlaceInfo, info2 : Cpp2PlaceInfo) -> () -> void;
cpp2PlaceInfoIsStub(info : Cpp2PlaceInfo) -> bool;
cpp2PlaceInfoGetLValue(info : Cpp2PlaceInfo) -> string;
cpp2PlaceInfoIsClosureRef(info : Cpp2PlaceInfo) -> bool;
cpp2PlaceInfoGetRawField(info : Cpp2PlaceInfo, ctx : Cpp2Context, type : Cpp2TagType) -> string;
cpp2PlaceInfoGetStructAddr(info : Cpp2PlaceInfo, ctx : Cpp2Context) -> string;



cpp2CodeLines(parent : Maybe<Cpp2CodeLines>) -> Cpp2CodeLines;
cpp2CodeLinesToCode(code : Cpp2CodeLines) -> string;





cpp2ContextEnsureStructPtr(ctx : Cpp2Context, sref : Cpp2PlaceInfo, structname : string, init : bool) -> string;
cpp2ContextGetStructField(ctx : Cpp2Context, sref : Cpp2PlaceInfo, structname : string, fname : string, ftype : Cpp2TagType) -> string;
cpp2ContextGetStructPtr(ctx : Cpp2Context, sref : Cpp2PlaceInfo, structname : string, init : bool) -> string;
cpp2Context(env : Cpp2Environment, indent : string) -> Cpp2Context;

}

cpp2wrLine(o : ref List<string>, lines : [string]) -> void {
	iter(lines, \line -> rlistPush(o, line + "\n"));
}

cpp2wrArray(cnt : int, per_line : int, head : string, indent : string, tail_ : string, f : (int) -> string) -> string {
	if (cnt <= 0) "" else {
		head + 
		fold(enumFromTo(0, cnt), "", 
			\acc, i -> {
				f(i) +
				if (i < cnt - 1) {
					if ((i + 1) % per_line != 0) {
						", "
					} else {
						",\n" + indent
					}
				} else {
					tail_
				}
			}
		)
	}
}

cpp2FnMethodName(n : string) -> string {
	"fn_" + n
}

cpp2ClosureMethodName(n : string, idx : int) -> string {
	"cl_" + i2s(idx) + "_" + n
}

cpp2writeLines(lines : List<string>, path : string) -> void {
	if (!setFileContent(path, list2string(lines))) {
		cpp2_error("writing to file " + path + "failed");
	}
}

cpp2ClearMeta(meta : Cpp2PlaceMetadata) -> Cpp2PlaceMetadata {
	Cpp2PlaceMetadata(
		meta.context,
		meta.dirty,
		Cpp2TNull(), // tag
		FiTypeNull(),  // type
		-1, // struct_size
		-1, // struct_id
		[], // known_fields
		[], // known_compares
		-1, // struct_ptr_gcid
		[], // struct_ptr_types
	)
}

cpp2CopyMeta(meta : Cpp2PlaceMetadata) -> Cpp2PlaceMetadata {
	/*var rv = Reflect.copy(meta);
	if (rv.known_fields != null)
		rv.known_fields = rv.known_fields.list();
	if (rv.known_compares != null)
		rv.known_compares = rv.known_compares.list();
	if (rv.struct_ptr_types != null)
		rv.struct_ptr_types = rv.struct_ptr_types.list();
	return rv;*/
	Cpp2PlaceMetadata(
		meta.context,
		meta.dirty,
		meta.tag,
		meta.type,
		meta.struct_size,
		meta.struct_id,
		meta.known_fields,
		meta.known_compares,
		meta.struct_ptr_gcid,
		meta.struct_ptr_types
	)
}

/*
cpp2_meta_merge_fn : [flow] = [
		\a : flow, b : flow -> if (a == b) a else None(),
		\a : flow, b : flow -> if (a == b) a else None(),
		\a : Maybe<int>, b : Maybe<int> ->
			eitherMap(b, \bi -> eitherMap(a, \ai -> ai > bi, None()) ,None()),
		\a : Maybe<int>, b : Maybe<int> -> if (a == b) a else None(),
		function(a : List<string>, b : Maybe<List<string>>) {
			return if (b == null) null
			else a.filter(function(v) { return b.has(v); });
		},
		function(a : List<CppPlaceInfo>,b : Maybe<List<CppPlaceInfo>>) {
			return if (b == null) null
			else a.filter(function(v) { return b.has(v); });
		},
		function(a:Maybe<int>,b:Maybe<int>) { return if (b == null) null else if (a > b) b else a; },
		function(a : List<string>, b : Maybe<List<string>>) {
			return if (b == null) null
			else a.filter(function(v) { return b.has(v); });
		},
	];
*/

cpp2TagTostring(tag : Cpp2TagType) -> string {
	switch (tag) {
		Cpp2TVoid():           "TVoid";
		Cpp2TBool():           "TBool";
		Cpp2TInt():            "TInt";
		Cpp2TDouble():         "TDouble";
		Cpp2TString():         "TString";
		Cpp2TArray():          "TArray";
		Cpp2TStruct():         "TStruct";
		Cpp2TCodePointer():    "TCodePointer";
		Cpp2TNativeFn():       "TNativeFn";
		Cpp2TRefTo():          "TRefTo";
		Cpp2TNative():         "TNative";
		Cpp2TClosurePointer(): "TClosurePointer";
		Cpp2TNull(): {
			cpp2_error("Cpp2TNull() value must not be printed");
			"null";
		}
	}
}

cpp2GetStructAType(t : FiTypeNullable) -> Cpp2TagType {
	switch(t) {
		FiTypeVoid():      Cpp2TNull();
		FiTypeBool():      Cpp2TBool();
		FiTypeInt():       Cpp2TInt();
		FiTypeDouble():    Cpp2TDouble();
		FiTypeString():    Cpp2TString();
		FiTypeArray(__):   Cpp2TArray();
		FiTypeName(__,__): Cpp2TStruct();
		FiTypeRef(__):     Cpp2TRefTo();
		default:           Cpp2TNull();
	}
}

cpp2IsStructFieldTag(type : Cpp2TagType) -> bool {
	switch (type) {
		Cpp2TBool():   true;
		Cpp2TInt():    true;
		Cpp2TDouble(): true;
		Cpp2TString(): true;
		Cpp2TArray():  true;
		Cpp2TRefTo():  true;
		Cpp2TStruct(): true;
		default:       false;
	}
}

cpp2StructFieldCode(type : Cpp2TagType) -> string {
	switch (type) {
		Cpp2TBool():   "bool";
		Cpp2TInt():    "int";
		Cpp2TDouble(): "double";
		Cpp2TString(): "string";
		Cpp2TArray():  "array";
		Cpp2TRefTo():  "ref";
		Cpp2TStruct(): "struct";
		Cpp2TNull():   "slot";
		default: {
			cpp2_error("impossible type in cpp2StructFieldCode");
			"impossible";
		}
	}
}

cpp2IsNonGCFieldType(type : Cpp2TagType) -> bool {
	switch (type) {
		Cpp2TBool():   true;
		Cpp2TInt():    true;
		Cpp2TDouble(): true;
		default:       false;
	}
}


// Cpp2PlaceInfo methods
cpp2PlaceInfo(env: Maybe<Cpp2Environment>, place: Cpp2PlaceType, slot: int, name : string) -> Cpp2PlaceInfo {
	cpp2PlaceInfoMeta(
		env, place, slot, name, 
		Cpp2PlaceMetadata(
			eitherMap(env, \e -> 
				switch (e.cur_ctx) {
					Some(ctx): ctx.id;
					None(): -1;
				}, 
				-1
			), // context
			false, // dirty
			Cpp2TNull(), // tag
			FiTypeNull(),  // type
			-1, // struct_size
			-1, // struct_id
			[], // known_fields
			[], // known_compares
			-1, // struct_ptr_gcid
			[], // struct_ptr_types
		)
	)
}

cpp2PlaceInfoMeta(env: Maybe<Cpp2Environment>, place: Cpp2PlaceType, slot: int, name : string, meta : Cpp2PlaceMetadata) -> Cpp2PlaceInfo {
	Cpp2PlaceInfo(
		env, place, slot, name, meta,
		eitherMap(env,
			\e -> {
				ret = e.next_uid;
				e.next_uid ::= ret + 1;
				ret
			},
			{ 
				ret = ^cpp2_next_guid;
				cpp2_next_guid := ret + 1;
				ret
			}
		),
		"", ""
	)
}

cpp2PlaceInfoIsSame(info1 : Cpp2PlaceInfo, info2 : Cpp2PlaceInfo) -> bool {
	info1.slot == info2.slot && info1.place == info2.place
}

// Temporarily overwrite the actual location, retaining the uid and
// meta identity. Returns a callback to restore the original state.
cpp2PlaceInfoSubstituteLocation(info1 : Cpp2PlaceInfo, info2 : Cpp2PlaceInfo) -> () -> void {
	cur_place = info1.place;
	cur_slot = info1.slot;
	info1.place ::= info2.place;
	info1.slot ::= info2.slot;
	info1.rvalue ::= "";
	info1.lvalue ::= "";
	\ -> {
		info1.place ::= cur_place;
		info1.slot ::= cur_slot;
		info1.rvalue ::= "";
		info1.lvalue ::= "";
	};
}

cpp2PlaceInfoIsStub(info : Cpp2PlaceInfo) -> bool {
	info.slot < 0
}

cpp2PlaceInfoGetLValue(info : Cpp2PlaceInfo) -> string {
	if (info.lvalue != "") info.lvalue else {
		lval = switch (info.place) {
			Cpp2GlobalVar():
				cpp2_GLOBALS + i2s(info.slot) + cpp2_CMSTART + info.name + cpp2_CMENDBR;
			Cpp2Local():
				cpp2_LOCALS + i2s(info.slot) + cpp2_CMSTART + info.name +  cpp2_CMENDBR;
			Cpp2Argument(): {
				switch (info.env) {
					Some(e): e.args_used ::= true;
					None(): { }
				}
				if (info.slot < 0) "RUNNER_CLOSURE"
				else {
					cpp2_RUNNER_ARG + i2s(info.slot) + cpp2_CMSTART + info.name + cpp2_CMENDPR;
				}
			}
			Cpp2Temporary():
				cpp2_TEMPS + i2s(info.slot) + cpp2_RBRACE;
			Cpp2Struct(info1): {
				cpp2_error("no lvalue for struct " + info1.structname);
				""
			}
			Cpp2SlotAlias(where, idx): {
				cpp2_error("no lvalue for field alias");
				""
			}
			Cpp2FieldAlias(where,sinfo): {
				cpp2_error("no lvalue for field alias");
				"";
			}
			Cpp2GlobalFunction(__,__): {
				cpp2_error("no lvalue for global function");
				""
			}
			Cpp2NoPlace(code, err): {
				cpp2_error(prettyFiExp(dummyPretty, code) + ": " + err);
				""
			}
		};
		info.lvalue ::= lval;
		lval
	}
}

cpp2PlaceInfoIsClosureRef(info : Cpp2PlaceInfo) -> bool {
	switch (info.place) {
		Cpp2Argument(): info.slot < 0;
		default: false;
	}
}

cpp2PlaceInfoIsLValue(info : Cpp2PlaceInfo) -> bool {
	switch (info.place) {
		Cpp2GlobalVar(): true;
		Cpp2Local():     true;
		Cpp2Argument():  true;
		Cpp2Temporary(): true;
		default:         false;
	}
}

cpp2PlaceInfoGetRValue(info : Cpp2PlaceInfo, ctx : Cpp2Context) -> string {
	if (info.rvalue != "") {
			switch (info.place) {
				Cpp2SlotAlias(where, idxvar):
					cpp2ContextEnsureStructPtr(ctx, where, "", true);
				Cpp2FieldAlias(where, sinfo):
					cpp2ContextEnsureStructPtr(ctx, where, sinfo.structname, true);
				default:  "";
			}
			info.rvalue
	} else {
		rval = switch (info.place) {
			Cpp2GlobalFunction(__,__): {
				if (info.slot < 0) {
					cpp2_error("no assigned function slot"); ""
				} else {
					cpp2_FUNCTIONS + i2s(info.slot) + cpp2_CMSTART + info.name + cpp2_CMENDBR;
				}
			}
			Cpp2SlotAlias(where, idxvar): {
				cpp2ContextGetStructPtr(ctx, where, "", true) +
				cpp2_LBRACE + (if (idxvar == "") i2s(info.slot) else idxvar);
				cpp2_CMSTART + info.name + cpp2_CMENDBR;
			}
			Cpp2FieldAlias(where, sinfo): {
				fname = sinfo.args[info.slot].name;
				s = cpp2ContextGetStructField(ctx, where, sinfo.structname, fname, sinfo.atypes[info.slot]);
				if (info.name != "" && info.name != fname) {
					s + cpp2_CMSTART + info.name + cpp2_CMEND;
				} else {
					s
				}
			}
			Cpp2Struct(info1): {
				if (length(info1.args) != 0) {
					cpp2_error("no rvalue for struct with parameters: " + info1.structname);
				}
				if (info1.empty_addr != cpp2_int_UNDEF) {
					"StackSlot::MakeStruct(MakeFlowPtr(" + i2s(info1.empty_addr) + ")," + i2s(info.slot) + ")";
				} else {
					cpp2_error("no empty_addr in Cpp2Struct"); "";
				}
			}
			default:
				cpp2PlaceInfoGetLValue(info);
		}
		info.rvalue ::= rval;
		rval
	}
}

cpp2PlaceInfoGetRawField(info : Cpp2PlaceInfo, ctx : Cpp2Context, type : Cpp2TagType) -> string {
	switch (info.place) {
		Cpp2FieldAlias(where, sinfo): {
			if (sinfo.atypes[info.slot] == type) {
				cpp2ContextGetStructPtr(ctx, where, sinfo.structname, true) + "->fl_" + sinfo.args[info.slot].name;
			} else {
				""
			}
		}
		default: "";
	}
}

cpp2PlaceInfoGetStructAddr(info : Cpp2PlaceInfo, ctx : Cpp2Context) -> string {
	defval = \ -> cpp2PlaceInfoGetRValue(info, ctx) + ".GetRawStructPtr()";
	switch (info.place) {
		Cpp2FieldAlias(where, sinfo): {
			if (sinfo.atypes[info.slot] == Cpp2TStruct()) {
				cpp2ContextGetStructPtr(ctx, where, sinfo.structname, true) + "->fl_" + sinfo.args[info.slot].name;
			} else {
				defval();
			}
		}
		default: defval();
	}
}


	

	
	
	
	
	
	
	
	
	
	
	
	
	
// Cpp2CodeLines methods

cpp2CodeLines(parent : Maybe<Cpp2CodeLines>) -> Cpp2CodeLines {
	Cpp2CodeLines(ref [], parent)
}

cpp2CodeLinesToCode(code : Cpp2CodeLines) -> string {
	cpp2CodeLinesPullCommonDecls(code);
	cpp2CodeLinesToString(code, "")
}

cpp2CodeLinesToString(code : Cpp2CodeLines, acc : string) -> string {
	fold(^(code.lines), acc, 
		\ac, line -> {
			switch (line) {
				Cpp2Decl(type, name, indent, origin):
					ac + indent + type + " " + name + ";\n";
				Cpp2Any(line1):
					ac + line1;
				Cpp2Block(code1):
					cpp2CodeLinesToString(code1, ac);
			}
		}
	)
}

cpp2CodeLinesPullCommonDecls(code : Cpp2CodeLines) -> void {
	decl2line = filterTree(
		cpp2CodeLinesDecl2Line(code, makeTree()),
		\__, lines -> length(lines) > 1
	);
	traverseInOrder(decl2line,
		\name, decl_lines -> {
			switch (cpp2CodeLinesLeastCommonAncestor(decl_lines)) {
				Some(common): {
					iter(decl_lines, \decl : Cpp2Decl ->
						decl.origin.lines := removeFirst(^(decl.origin.lines), decl)
					);
					common.lines := concat([cast(decl_lines[0] : Cpp2Decl -> Cpp2Line)], ^(common.lines));
				}
				None(): {
					cpp2_error("no common ancestor is found");
				}
			}
		
		}
	)
}

cpp2CodeLinesLeastCommonAncestor(lines : [Cpp2Decl]) -> Maybe<Cpp2CodeLines> {
	paths = fold(lines, [],
		\acc, decl -> {
			path = cpp2CodeLinesGetPath(Some(decl.origin), []);
			concat(acc, [path]);
		}
	);
	cpp2CodeLinesFindCommon(0, None(), paths)
}
	
cpp2CodeLinesFindCommon(i : int, val : Maybe<Cpp2CodeLines>, paths : [[Cpp2CodeLines]]) -> Maybe<Cpp2CodeLines> {
	if (
		forall(paths, \path -> i < length(path)) &&
		forall(map(paths, \path -> path[i]), \c -> c == paths[0][i])
	) {
		cpp2CodeLinesFindCommon(i + 1, Some(paths[0][i]), paths)
	} else {
		val
	}
}

cpp2CodeLinesGetPath(mcode : Maybe<Cpp2CodeLines>, acc : [Cpp2CodeLines]) -> [Cpp2CodeLines] {
	switch (mcode) {
		Some(code): cpp2CodeLinesGetPath(code.parent, concat([code], acc));
		None(): acc;
	}
}
	
cpp2CodeLinesDecl2Line(code : Cpp2CodeLines, acc : Tree<string, [Cpp2Decl]>) -> Tree<string, [Cpp2Decl]> {
	fold(^(code.lines), acc, 
		\ac, line -> {
			switch (line) {
				Cpp2Decl(type, name, indent, origin): {
					switch (lookupTree(ac, name)) {
						Some(lines): setTree(ac, name, concat(lines, [line]));
						None(): setTree(ac, name, [line]);
					}
				}
				Cpp2Block(code1): {
					cpp2CodeLinesDecl2Line(code1, ac);
				}
				default: acc;
			}
		}
	)
}
	
	
	
	
	
	
	
	
	
	
// Cppe2Environment methods:

cpp2Environment(parent : Maybe<Cpp2Environment>, mname : string, vname : string) -> Cpp2Environment {
	depth = switch (parent) {
		Some(p): p.depth + 1;
		None(): 1;
	};
	env = Cpp2Environment(
		parent,
		mname,
		vname,
		depth,
		1000000 * depth, // next_uid
		0, // next_ctx
		0, // nlocals
		0, // ntemps
		0, // nargs
		[], // local_reuse
		false, // args_used
		None(), // closure
		[], // upvalues
		false, // tail_call
		None(), // cur_ctx = new CppContext(this, '    ');
		makeTree(), // locals
		makeTree(), // meta_globals
		cpp2CodeLines(None()) // code_lines
	);
	env.cur_ctx ::= Some(cpp2Context(env, "    "));
	env
}

cpp2EnvironmentPushCppBlock(env : Cpp2Environment) -> void {
	env.code_lines ::= cpp2CodeLines(Some(env.code_lines));
}

cpp2EnvironmentPopCppBlock(env : Cpp2Environment) -> void {
	switch (env.code_lines.parent) {
		Some(p): refArrayPush(p.lines, Cpp2Block(env.code_lines));
		None(): { }
	}
	env.code_lines ::= env.code_lines.parent;
}

cpp2EnvironmentAddCppLine(env : Cpp2Environment, line : Cpp2Line) ->void {
	refArrayPush(env.code_lines.lines, line);
}

cpp2EnvironmentMktemp(env : Cpp2Environment, id : int) -> Cpp2PlaceInfo {
	if (id >= env.ntemps) {
		env.ntemps ::= id + 1;
	}
	cpp2PlaceInfo(Some(env), Cpp2Temporary(), id, "")
}

cpp2EnvironmentTempvar(env : Cpp2Environment, base : string) -> string {
	uid = env.next_uid;
	env.next_uid ::= env.next_uid + 1;
	base + i2s(uid);
}

cpp2EnvironmentMkupvalue(env : Cpp2Environment, name : string, free : Cpp2PlaceInfo) -> Cpp2PlaceInfo {
	id = length(env.upvalues);
	env.upvalues ::= arrayPush(env.upvalues, name);
	if (free.meta.type == FiTypeNull()) {
		(free.meta).type ::= FiTypeFlow();
	}
	type = free.meta.type;
	ttag = cpp2GetStructAType(type);
	vtag = ref free.meta.tag;
	if (!cpp2IsStructFieldTag(^vtag)) {
		vtag := Cpp2TNull();
	}
	if (ttag != Cpp2TNull()) {
		vtag := if (^vtag == Cpp2TNull() || ^vtag == ttag) ttag else Cpp2TNull();
	}
	tdecl = Cpp2StructArg(
		"up_" + i2s(id), // name
		type,
		false // is_mutable
	);
	meta = Cpp2PlaceMetadata(
		0, // context
		false, // dirty
		^vtag, // tag 
		type, // type 
		-1, // struct_size
		-1, // struct_id
		[], // known_fields
		[], // known_compares
		-1, // struct_ptr_gcid
		[], // struct_ptr_types
	);
	info = switch (env.closure) {
		None(): {
			new_closure = Cpp2Closure(
				cpp2PlaceInfo(Some(env), Cpp2Argument(), -1, ""),
				Cpp2StructInfo(
					cpp2_int_UNDEF, // id
					env.mname,      // structname
					[tdecl],        // args
					[^vtag],        // atypes
					cpp2_int_UNDEF  // empty_addr
				)
			);
			(new_closure.place.meta).context ::= 0;
			env.closure ::= Some(new_closure);
			cpp2PlaceInfoMeta(Some(env), Cpp2FieldAlias(new_closure.place, new_closure.type), id, name, meta);
		}
		Some(closure): {
			(closure.type).args ::= arrayPush(closure.type.args, tdecl);
			(closure.type).atypes ::= arrayPush(closure.type.atypes, ^vtag);
			cpp2PlaceInfoMeta(Some(env), Cpp2FieldAlias(closure.place, closure.type), id, name, meta);
		}
	}
	env.locals ::= setTree(env.locals, name, info);
	info
}


cpp2EnvironmentMklocal(env : Cpp2Environment, name : string) -> Cpp2PlaceInfo {
	id = if (length(env.local_reuse) > 0) {
		i = env.local_reuse[length(env.local_reuse) - 1];
		env.local_reuse ::= take(env.local_reuse, length(env.local_reuse) - 1);
		i
	} else {
		i = env.nlocals;
		env.nlocals ::= env.nlocals + 1;
		i
	};
	cpp2PlaceInfo(Some(env), Cpp2Local(), id, name);
}

cpp2EnvironmentPoplocal(env : Cpp2Environment, name : string, olddef : Cpp2PlaceInfo) -> void {
	switch (lookupTree(env.locals, name)) {
		Some(curdef): {
			env.locals ::= setTree(env.locals, name, olddef);
			if (curdef.place == Cpp2Local()) {
				env.local_reuse ::= arrayPush(env.local_reuse, curdef.slot);
			}
		}
		None(): {
			cpp2_error("no name " + name + " in env locals");
		}
	}
}

cpp2EnvironmentStashGlobalMeta(env : Cpp2Environment) -> void {
	traverseInOrder(env.meta_globals, 
		\__, info -> {
			info.my ::= info.def.meta;
			(info.def).meta ::= info.old;
		}
	)
}

cpp2EnvironmentRestoreGlobalMeta(env : Cpp2Environment) -> void {
	traverseInOrder(env.meta_globals,
		\__, info -> (info.def).meta ::= info.my
	)
}




	
	
	
	
	
	
	
	
	

// Cpp2Context methods

cpp2Context(env : Cpp2Environment, indent : string) -> Cpp2Context {
	id = env.next_ctx;
	env.next_ctx ::= env.next_ctx + 1;
	gc_index = switch (env.cur_ctx) {
		Some(ctx): ctx.gc_index;
		None(): 0;
	};
	Cpp2Context(
		env,
		env.cur_ctx, // prev
		id,
		gc_index,
		indent,
		[], // local_names
		[], // local_binds
		makeTree(), // idxvars
		makeTree(), // meta
	)
}

cpp2ContextExit(ctx : Cpp2Context) -> void {
	cpp2EnvironmentPopCppBlock(ctx.env);
	cpp2ContextPopdefs(ctx, 0);
	traverseInOrder(ctx.meta, \__, mid -> {
		(mid.def).meta ::= mid.old;
		// Forget globals if restored
		if (mid.def.env == None() && mid.old.context < 0)
			(ctx.env).meta_globals ::= removeFromTree(ctx.env.meta_globals, mid.def.uid);
	});
	(ctx.env).cur_ctx ::= ctx.prev;
}

cpp2ContextWr(ctx : Cpp2Context, s : string) -> void {
	cpp2EnvironmentAddCppLine(ctx.env, Cpp2Any(ctx.indent + s + cpp2_NEWLINE));
}

cpp2ContextWrsemi(ctx : Cpp2Context, s: string) -> void {
	cpp2EnvironmentAddCppLine(ctx.env, Cpp2Any(ctx.indent + s + cpp2_SEMI_NL));
}

cpp2ContextEnter(ctx : Cpp2Context, idelta : string) -> Cpp2Context {
	new_ctx = cpp2Context(ctx.env, ctx.indent + idelta);
	(ctx.env).cur_ctx ::= Some(new_ctx);
	new_ctx
}

cpp2ContextLocalMeta(ctx : Cpp2Context, def : Cpp2PlaceInfo) -> Cpp2PlaceMetadata {
	curmeta = def.meta;
	meta = if (curmeta.context >= ctx.id) {
		curmeta;
	} else {
		newmeta = cpp2CopyMeta(curmeta);
		newmeta.context ::= ctx.id;
		ctx.meta ::= setTree(ctx.meta, def.uid, Cpp2PlaceTriple(def, curmeta, newmeta));

		// Remember that a global was changed
		switch (def.env) {
			None(): {
				if (curmeta.context < 0) {
					(ctx.env).meta_globals ::= setTree(ctx.env.meta_globals, def.uid, Cpp2PlaceTriple(def, curmeta, newmeta));
				}
			}
			Some(__): { }
		}
		def.meta ::= newmeta;
		newmeta
	};
	meta.dirty ::= true;
	meta
}

cpp2ContextJoinOne(ctx : Cpp2Context, child : Cpp2Context) -> void {
	if (child.gc_index > ctx.gc_index) {
		ctx.gc_index ::= child.gc_index;
	}
}
/*
cpp2ContextJoin(ctx : Cpp2Context, children : [CppContext]) -> void {
	if (length(children) > 0) {
		iter(children, \child -> cpp2ContextJoinOne(ctx, child));

		//flist = Cpp2PlaceInfo.meta_fields;

		for (mid in children[0].meta.iterator()) {
			var defid = mid.def.uid;

			var best = [];
			for (fn in flist)
				best.push(Reflect.field(mid.my, fn));
			var ok = true;

			for (i in 1...children.length) {
				var cur = children[i].meta.get(defid);
				if (cur == null) {
					ok = false;
					break;
				}
				for (fi in 0...flist.length) {
					if (best[fi] == null)
						continue;
					best[fi] = CppPlaceInfo.meta_merge_fn[fi](
						best[fi], Reflect.field(cur.my, flist[fi])
					);
				}
			}

			if (!ok)
				continue;

			ok = false;
			var cur = mid.def.meta;
			for (fi in 0...flist.length) {
				if (best[fi] == Reflect.field(cur, flist[fi]))
					continue;
				ok = true;
				break;
			}

			if (!ok)
				continue;

			var upd = localMeta(mid.def);
			var dirty = false;
			for (fi in 0...flist.length) {
				if (best[fi] != null) dirty = true;
				Reflect.setField(upd, flist[fi], best[fi]);
			}
			upd.dirty = dirty;
		}
	}
}
*/

cpp2ContextPushdef(ctx : Cpp2Context, def : Cpp2PlaceInfo) -> void {
	ctx.local_names ::= arrayPush(ctx.local_names, def.name);
	switch (lookupTree(ctx.env.locals, def.name)) {
		Some(bind): {
			ctx.local_binds ::= arrayPush(ctx.local_binds, bind);
		}
		None(): {
			cpp2_error("local bind: " + def.name + " is not found");
		}
	};
	(ctx.env).locals ::= setTree(ctx.env.locals, def.name, def)
}

cpp2ContextDefpos(ctx : Cpp2Context) -> int { 
	length(ctx.local_names) 
}

cpp2ContextPopdefs(ctx : Cpp2Context, pos : int) -> void { // ?pos : int = 0
	fori(0, length(ctx.local_names) - pos, 
		\__ -> {
			loc_name = ctx.local_names[length(ctx.local_names) - 1];
			loc_bind = ctx.local_binds[length(ctx.local_binds) - 1];
			ctx.local_names ::= take(ctx.local_names, length(ctx.local_names) - 1);
			ctx.local_binds ::= take(ctx.local_binds, length(ctx.local_binds) - 1);
			cpp2EnvironmentPoplocal(ctx.env, loc_name, loc_bind);
		}
	)
	//for (i in 0...(local_names.length - pos))
	//	env.poplocal(local_names.pop(), local_binds.pop());
}

cpp2ContextEnsureStructPtr(ctx : Cpp2Context, sref : Cpp2PlaceInfo, structname : string, init : bool) -> string { // init : bool = true, sb : stringBuf = null
	bad_gcid = (sref.meta.struct_ptr_gcid == -1 || sref.meta.struct_ptr_gcid < ctx.gc_index);
	stale = (bad_gcid || !contains(sref.meta.struct_ptr_types, structname));
	vname = cpp2_SPTR_ + i2s(sref.uid) + (if (strlen(structname) > 0) cpp2_UNDERSCORE + structname else "");
	if (stale) {
		line = if (structname == "") {
			cpp2ContextRegisterIdxVar(ctx, vname, "const StackSlot*");
			if (!init) "" else {
				size = if (sref.meta.struct_size < 1) 1 else sref.meta.struct_size;
				ctx.indent + vname + cpp2_GET_ASPTR + 
				cpp2PlaceInfoGetRValue(sref, ctx) + cpp2_COMMA + 
				i2s(size) + cpp2_PAREN_SEMI_NL;
			}
		} else {
			vtype = "FS_" + structname;
			cpp2ContextRegisterIdxVar(ctx, vname, vtype + "*");
			if (!init) "" else {
				ctx.indent + vname + cpp2_EQ_LPAREN + vtype +
				(if (cpp2PlaceInfoIsClosureRef(sref))
					cpp2_GET_CSPTR + cpp2PlaceInfoGetRValue(sref, ctx)
				else
					cpp2_GET_SPTR + cpp2PlaceInfoGetStructAddr(sref, ctx)
				) 
				+ cpp2_PAREN_SEMI_NL;
			}
		}
		cpp2EnvironmentAddCppLine(ctx.env, Cpp2Any(line));
		lm = cpp2ContextLocalMeta(ctx, sref);
		lm.struct_ptr_gcid ::= ctx.gc_index;
		lm.struct_ptr_types ::= arrayPush(lm.struct_ptr_types, structname);
	}
	vname
}

cpp2ContextGetStructPtr(ctx : Cpp2Context, sref : Cpp2PlaceInfo, structname : string, init : bool) -> string { // structname : string = '', init : bool = true
	vname = cpp2ContextEnsureStructPtr(ctx, sref, structname, init);
	if (sref.name != "") {
		vname + cpp2_CMSTART + sref.name + cpp2_CMEND;
	} else {
		vname
	}
}

cpp2ContextGetStructField(ctx : Cpp2Context, sref : Cpp2PlaceInfo, structname : string, fname : string, ftype : Cpp2TagType) -> string {
	ptr = cpp2ContextGetStructPtr(ctx, sref, structname, true);
	vname = ptr + "->fl_" + fname;
	if (ftype == Cpp2TNull()) vname else {
		switch (ftype) {
			Cpp2TBool():  "StackSlot::Makebool(" + vname + ")";
			Cpp2TInt():   "StackSlot::Makeint(" + vname + ")";
			Cpp2TDouble(): "StackSlot::MakeDouble(" + vname + ")";
			Cpp2TString(): vname;
			Cpp2TArray():  vname;
			Cpp2TRefTo():  vname;
			Cpp2TStruct():
				"StackSlot::MakeStruct(" + vname + ",RUNNER->GetStructPtr(" + vname + ")->StructId)";
			default: {
				cpp2_error("impossible case in cpp2ContextGetStructField");
				""
			}
		}
	}
}

cpp2ContextTempvar(ctx : Cpp2Context, base : string, tag : Cpp2TagType, init : string) -> string { // ?init : string = null
	name = cpp2EnvironmentTempvar(ctx.env, base);
	type = switch (tag) {
		Cpp2TInt():    "int";
		Cpp2TDouble(): "double";
		Cpp2TBool():   "bool";
		default: {
			cpp2_error("impossible case in cpp2ContextTempvar");
			""
		}
	}
	cpp2ContextWrsemi(ctx, type + " " + name + (if (init != "") cpp2_SPC_EQ_SPC + init else ""));
	name
}

cpp2ContextInc_gc(ctx : Cpp2Context) -> void {
	ctx.gc_index ::= ctx.gc_index + 1
}

cpp2ContextWrcheck(ctx : Cpp2Context, str : string, gc_on : bool) { // ?gc = false
	line_str = ctx.indent + 
	cpp2_CHECK_ERROR + str + cpp2_PAREN_SEMI_NL;
	if (gc_on) {
		ctx.gc_index ::= ctx.gc_index + 1;
	}
	cpp2EnvironmentAddCppLine(ctx.env, Cpp2Any(line_str));
}

cpp2ContextWrcheckopt(ctx : Cpp2Context, str : string, check : bool, gc_on : bool) { // ?gc = false
	if (gc_on) {
		ctx.gc_index ::= ctx.gc_index + 1
	}
	if (check) {
		cpp2ContextWrcheck(ctx, str, false);
	} else {
		line_str = ctx.indent + str + cpp2_SEMI_NL;
		cpp2EnvironmentAddCppLine(ctx.env, Cpp2Any(line_str));
	}
}

cpp2ContextIdxVarType(ctx : Cpp2Context, name : string) -> string {
	switch (lookupTree(ctx.idxvars, name)) {
		Some(type): type;
		None(): {
			switch (ctx.prev) {
				Some(ctx1): cpp2ContextIdxVarType(ctx1, name);
				None(): "";
			}
		}
	}
}

cpp2ContextRegisterIdxVar(ctx : Cpp2Context, name : string, type : string) -> void {
	if (!containsKeyTree(ctx.idxvars, name)) {
		ctx.idxvars ::= setTree(ctx.idxvars, name, type);
		cpp2EnvironmentAddCppLine(ctx.env, Cpp2Decl(type, name, ctx.indent, ctx.env.code_lines));
	}
}













