import tools/flowc/incremental/fi_helpers;
import tools/flowc/backends/cpp2/fi2cpp2_util;

export {
	cpp2Writer(config : FcCpp2Config, program : FiProgram) -> Cpp2Writer;
	cpp2WriterEmitCommonAndTables(writer : Cpp2Writer) -> void;
}

// CppWriter methods

cpp2_natives = [
	Cpp2NativeDescr("mapi", 2, false, "mapi"),
	Cpp2NativeDescr("map", 2, false, "map"),
	Cpp2NativeDescr("iter", 2, false, "iter"),
	Cpp2NativeDescr("iteri", 2, false, "iteri"),
	Cpp2NativeDescr("fold", 3, false, "fold"),
	Cpp2NativeDescr("foldi", 3, false, "foldi"),
	Cpp2NativeDescr("filter", 2, false, "filter"),
	Cpp2NativeDescr("elemIndex", 3, false, "elemIndex"),
	Cpp2NativeDescr("exists", 2, false, "exists"),
	Cpp2NativeDescr("find", 2, false, "find"),
	Cpp2NativeDescr("subrange", 3, false, "subrange"),
	Cpp2NativeDescr("length", 1, true, "length"),
	Cpp2NativeDescr("strlen", 1, true, "NativeStrlen"),
	Cpp2NativeDescr("strIndexOf", 2, true, "strIndexOf"),
	Cpp2NativeDescr("substring", 3, true, "substring"),
	Cpp2NativeDescr("concat", 2, false, "mapi"),
	Cpp2NativeDescr("replace", 3, false, "replace"),
	Cpp2NativeDescr("bitXor", 2, true, "bitXor"),
	Cpp2NativeDescr("bitOr", 2, true, "bitOr"),
	Cpp2NativeDescr("bitAnd", 2, true, "bitAnd"),
	Cpp2NativeDescr("bitNot", 1, true, "bitNot"),
];

cpp2Writer(config : FcCpp2Config, program : FiProgram) -> Cpp2Writer {
	known_natives = fold(cpp2_natives, makeTree(), 
		\acc, nat -> setTree(acc, "Native." + nat.name, nat)
	);
	// We do this in alphabetical order in order to avoid random changes in the
	// code just because of hash ordering differences; however, it is combined
	// with descending order by argument count to allow size checks just by
	// looking at the id range.
	fi_structs = mergeSort(
		getTreeValues(program.names.structs),
		\s1, s2 -> {
			if (s1.name < s2.name) -1
			else if (s1.name == s2.name) 0 else 1;
		}
	);
	structs_inds = foldi(fi_structs, makeTree(),
		\i, acc, s -> setTree(acc, s.name, i)
	);
	structs_order = map(
		mergeSort(
			fi_structs,
			\s1, s2 -> {
				if (length(s1.args) < length(s2.args)) 1
				else if (length(s1.args) > length(s2.args)) -1
				else if (s1.name < s2.name) -1
				else if (s1.name == s2.name) 0 else 1;
			}
		),
		\s -> Cpp2StructOrderInfo(
			lookupTreeDef(structs_inds, s.name, -1), 
			s.name, 
			map(s.args, \a -> Cpp2StructArg(a.name, a.type, a.ismutable))
		)
	);
	struct_list_map = foldi(structs_order, Pair([], makeTree()),
		\n, acc, s -> {
			si = Cpp2StructInfo(
				n,       // id
				s.name,  // structname
				map(s.args, \a -> Cpp2StructArg(a.name, a.type, a.is_mutable)), //args
				map(s.args, \a -> cpp2GetStructAType(a.type)), // atypes
				if (length(s.args) == 0) { 
					2 + n * 4 // TODO: implement with bytecode generator 
				} else {
					cpp2_int_UNDEF
				} // empty_addr
			);
			Pair(
				concat(acc.first, [si]),
				setTree(acc.second, s.name, si)
			)
		}
	);
	struct_list = struct_list_map.first;
	structs = struct_list_map.second;
	max_size = fold(struct_list, -1, \acc, s -> 
		if (length(s.args) > acc) length(s.args) else acc
	);
	struct_counts_map = foldi(structs_order, Pair(makeTree(), max_size),
		\n, acc, s -> {
			updated = fold(enumFromTo(length(s.args), acc.second), acc.first, 
				\a, i -> setTree(a, i, n)
			);
			Pair(updated, length(s.args))
		}
	).first;
	struct_counts = map(enumFromTo(0, max_size), \i -> 
		lookupTreeDef(struct_counts_map, i, -1) 
	);
	toplevel_triple = cpp2WriterEnumerateToplevel(program);
	function_table = toplevel_triple.first;
	global_vars = toplevel_triple.second;
	global_map = toplevel_triple.third;
	writer = Cpp2Writer(
		config,
		program,
		length(struct_list),    // num_structs : int,
		0,                      // init_count : int,
		struct_counts,          // struct_counts : [int], // by size
		structs,                // structs : Tree<string, Cpp2StructInfo>,
		makeTree(),             // closure_structs : Tree<string, Cpp2StructInfo>,
		ref structs_order,          // structsOrder : [Cpp2StructOrderInfo],
		struct_list_map.first,  // struct_list : [Cpp2StructInfo],

		Cpp2StructCode(ref [], ref [], ref [], ref [], ref [], ref []),  // struct_code

		makeTree(),     // const_strings : Tree<string, Cpp2ConstString>,
		ref [],         // method_names : [string],
		ref function_table, // function_table : [Cpp2FunctionDescr],
		global_vars,    // global_vars : [string],
		global_map,     // global_map : Tree<string, Cpp2PlaceInfo>,

		//* Table for fast lookup of fields by name; maps [name][structid] -> index
		ref [], // field_index_table : [[int]],
		makeTree(), // field_index_map : Tree<string, int>,
		ref [], // field_index_list : [string],
		
		//"", // cur_global : string,
		//1, // next_closure_id : int,
		known_natives, // known_natives : Tree<string, Cpp2NativeDescr>,
	);
	iter(structs_order,
		\s -> cpp2GenerateStructCode(writer, s, lookupTreeDef(structs, s.name, dummyCpp2StructInfo))
	);
	writer
}

cpp2GenerateStructCode(writer : Cpp2Writer, s : Cpp2StructOrderInfo, info : Cpp2StructInfo) -> void {
	code = writer.struct_code;
	name = cpp2WriterRegisterConstString(writer, s.name);
	if (length(s.args) == 0) {
		refinfo = Cpp2StructInfoRef(
			cpp2_int_UNDEF,  // fld_idx
			cpp2_int_UNDEF,  // type_idx
			cpp2_int_UNDEF,  // def_idx
			cpp2_int_UNDEF,  // gcdef_idx
			0,               // gcdef_cnt 
			info.empty_addr, // empty_addr
			name.addr,       // name_addr
			name.size,       // name_sz
		);
		refArrayPush(code.info_refs, refinfo);
	} else {
		refinfo = Cpp2StructInfoRef(
			length(^(code.field_names)), // fld_idx 
			length(^(code.field_types)), // type_idx
			length(^(code.def_lines)),   // def_idx
			length(^(code.gcdef_lines)), // gcdef_idx
			0, // gcdef_cnt 
			0, // empty_addr
			name.addr, //name_addr
			name.size, // name_sz
		);

		refArrayPush(code.info_refs, refinfo);
		refArrayPush(code.hdr_lines, "struct FS_" + s.name + " {");
		refArrayPush(code.hdr_lines, "    FiExpStructHeader hdr;");

		fori(0, length(s.args) - 1, \i -> {
			arg = s.args[i];
			refArrayPush(code.field_names, s.name);
			if (arg.is_mutable) {
				refArrayPush(code.field_types, cpp2_CSetMutable);
			}
			writeFiExpTypeCode(arg.type, code, writer.config.extStructDefs);
			refArrayPush(code.field_types, -1);
			fname =  "fl_" + arg.name;
			off = "(int)offsetof(FS_" + s.name + ", " + fname + ")";
			if (i < length(info.atypes)) {
				switch (info.atypes[i]) {
					Cpp2TBool(): {
						refArrayPush(code.def_lines, "FLOW_FIELD_DEF(bool," + off + ")");
						refArrayPush(code.hdr_lines, "    char " + fname + ";");
					}
					Cpp2TInt(): {
						refArrayPush(code.def_lines, "FLOW_FIELD_DEF(int," + off + ")");
						refArrayPush(code.hdr_lines, "    int " + fname + ";");
					}
					Cpp2TDouble(): {
						refArrayPush(code.def_lines, "FLOW_FIELD_DEF(double," + off + ")");
						refArrayPush(code.hdr_lines, "    double " + fname + ";");
					}
					Cpp2TString(): {
						refArrayPush(code.def_lines, "FLOW_FIELD_DEF(string," + off + ")");
						refArrayPush(code.gcdef_lines, "FLOW_FIELD_GC_DEF(string," + off + ")");
						refArrayPush(code.hdr_lines, "    FiExpStructString " + fname + ";");
					}
					Cpp2TArray(): {
						refArrayPush(code.def_lines, "FLOW_FIELD_DEF(array," + off + ")");
						refArrayPush(code.gcdef_lines, "FLOW_FIELD_GC_DEF(array," + off + ")");
						refArrayPush(code.hdr_lines, "    FiExpStructArray " + fname + ";");
					}
					Cpp2TRefTo(): {
						refArrayPush(code.def_lines, "FLOW_FIELD_DEF(ref," + off + ")");
						refArrayPush(code.gcdef_lines, "FLOW_FIELD_GC_DEF(ref," + off + ")");
						refArrayPush(code.hdr_lines, "    FiExpStructRef " + fname + ";");
					}
					Cpp2TStruct(): {
						refArrayPush(code.def_lines, "FLOW_FIELD_DEF(struct," + off + ")");
						refArrayPush(code.gcdef_lines, "FLOW_FIELD_GC_DEF(struct," + off + ")");
						refArrayPush(code.hdr_lines, "    FiExpPtr " + fname + ";");
					}
					Cpp2TNull(): {
						refArrayPush(code.def_lines, "FLOW_FIELD_DEF(slot," + off + ")");
						refArrayPush(code.gcdef_lines, "FLOW_FIELD_GC_DEF(slot," + off + ")");
						refArrayPush(code.hdr_lines, "    StackSlot " + fname + ";");
					}
					default: {
						cpp2_error("impossible");
					}
				}
			} else {
				cpp2_error("info.atypes index " + i2s(i) + "exceeded length: " + i2s(length(info.atypes)))
			}
		});
		refArrayPush(code.hdr_lines, "};");
		refinfo.gcdef_cnt ::= length(^(code.gcdef_lines)) - refinfo.gcdef_idx;
	}
}
	
writeFiExpTypeCode(type : FiTypeNullable, code : Cpp2StructCode, extStructDefs : bool) -> void {
	switch (type) {
		FiTypeVoid():   refArrayPush(code.field_types, cpp2_CVoid);
		FiTypeBool():   refArrayPush(code.field_types, cpp2_CBool);
		FiTypeInt():    refArrayPush(code.field_types, cpp2_CInt);
		FiTypeDouble(): refArrayPush(code.field_types, cpp2_CDouble);
		FiTypeString(): refArrayPush(code.field_types, cpp2_CString);
		FiTypeArray(t): {
			if (extStructDefs) {
				refArrayPush(code.field_types, cpp2_CTypedArray); 
				writeFiExpTypeCode(t, code, extStructDefs);
			} else {
				refArrayPush(code.field_types, cpp2_CArray);
			}
		}
		/*TStruct(name, args, max): {
			refArrayPush(code.field_types, cpp2_CTypedStruct );
			refArrayPush(code.field_types, structs.get(name).id );
		}*/
		FiTypeName(name, args):
			refArrayPush(code.field_types, cpp2_CStruct);
		FiTypeRef(t): {
			if (extStructDefs) {
				refArrayPush(code.field_types, cpp2_CTypedRefTo);
				writeFiExpTypeCode(t, code, extStructDefs);
			} else {
				refArrayPush(code.field_types, cpp2_CRefTo);
			}
		}
		FiTypeNull(): cpp2_error("null type");
		default: refArrayPush(code.field_types, cpp2_CFlow); // FiExp
	}
}

// Index natives and globals
cpp2WriterEnumerateToplevel(program : FiProgram) -> Triple<[Cpp2FunctionDescr], [string], Tree<string, Cpp2PlaceInfo>> {
	triple : Triple<ref [Cpp2FunctionDescr], ref [string], Tree<string, Cpp2PlaceInfo>> = foldTree(program.names.toplevel, Triple(ref [], ref [], makeTree()),
		\name, decl : FiDeclaration, acc : Triple<ref [Cpp2FunctionDescr], ref [string], Tree<string, Cpp2PlaceInfo>> -> {
			switch (decl) {
				FiFunctionDec(n, lambda, __, __,__): {
					info = Cpp2PlaceInfo(
						None(), // env
						Cpp2GlobalFunction(length(lambda.args), ""), // place
						-1,     // slot
						name,   // name
						dummyCpp2PlaceMetadata,   // meta
						cpp2_int_UNDEF,    // uid
						"", // lvalue
						"", // rvalue
					);
					Triple(acc.first, acc.second, setTree(acc.third, name, info))
				}
				FiGlobalVar(n, value, type, __,__): {
					// assign id to global var
					info = Cpp2PlaceInfo(
						None(), // env
						Cpp2GlobalVar(), // place
						length(^(acc.second)), // slot
						name,
						dummyCpp2PlaceMetadata,   // meta
						cpp2_int_UNDEF,    // uid
						"", // lvalue
						"", // rvalue
					);
					refArrayPush(acc.second, name);
					Triple(acc.first, acc.second, setTree(acc.third, name, info))
				}
				FiNativeDec(n, io, type, n_name, fbLambda, __,__): {
					nargs = switch (type) {
						FiTypeFunction(tp_args, tp_ret): length(tp_args);
						default: {
							cpp2_error("must be a FiTypeFunction");
							-1
						}
					};
					// natives have mandatory external linkage
					info = Cpp2PlaceInfo(
						None(), // env
						Cpp2GlobalFunction(nargs, n_name), // place
						length(^(acc.first)), // slot
						name,   // name
						dummyCpp2PlaceMetadata,   // meta
						cpp2_int_UNDEF,    // uid
						"", // lvalue
						"", // rvalue
					);
					refArrayPush(acc.first, 
						Cpp2FunctionDescr(
							name, // name
							n_name, // native_name
							nargs, // nargs
							switch (fbLambda) {
								FiVoid(__): "";
								FiLambda(args, body, __,__): 
									cpp2FnMethodName(name);
								default: {
									cpp2_error("must be a FiVoid or FiLambda");
									"";
								}
							}
						)
					);
					Triple(acc.first, acc.second, setTree(acc.third, name, info))
				}
			}
		}
	);
	Triple(^(triple.first), ^(triple.second), triple.third)
}

	
cpp2WriterRegisterConstString(w : Cpp2Writer, s : string) -> Cpp2ConstString {
	switch (lookupTree(w.const_strings, s)) {
		Some(cached): cached;
		None(): {
			// TODO: implement the stub
			ret = Cpp2ConstString(0, 0, s);
			w.const_strings ::= setTree(w.const_strings, s, ret);
			ret
		}
	}/*
	cached = const_strings.get(s);
	if (cached == null) {
		addr = bytecode.getPc();
		size = bytecode.writeWideStringRaw(s);
		rslot;

		if (size > 0xffff) {
			raddr = bytecode.getPc();
			bytecode.writeInt31(size & 0xffff);
			bytecode.writeInt31(addr);
			rslot = "StackSlot::InternalMakeString(MakeFiExpPtr('+raddr+'),'+(size>>16)+",true)";
		}
		else {
			rslot = "StackSlot::InternalMakeString(MakeFiExpPtr('+addr+'),'+size+",false)";
		}

		const_strings.set(s, cached = { addr: addr, size: size, rslot: rslot });
	}
	return cached;*/
}

cpp2WriterEmitCommonAndTables(writer : Cpp2Writer) {
	bytes : [int] = []; //bytecode.extractBytes();  // TODO: use actual bytecode
	
	h = ref makeList();
	o = ref makeList();

	rlistPush(o, "#" + "include \"core/GarbageCollector.h\"\n");

	cpp2wrLine(h, 
		[
			"#" + "include \"core/NativeProgram.h\"",
			"#" + "include \"core/RunnerMacros.h\"",
			"",
			"#" +  "include <limits>",
			"",
			"#pragma GCC diagnostic ignored \"-Wunused-parameter\"",
			"",
			"#ifndef FLOW_COMPACT_STRUCTS",
			"#error Runner built without compact structs is not supported",
			"#endif",
			"",
			"namespace flowgen_" + writer.config.entry + " {",
			"    using namespace flowgen_common;",
			"",
			"    static const unsigned NUM_CODE_BYTES = " + i2s(length(bytes)) + ";",
			"    static const unsigned NUM_FUNCTIONS = " + i2s(length(^(writer.function_table))) + ";",
			"    static const unsigned NUM_STRUCTS = " + i2s(writer.num_structs) + ";",
			"    static const unsigned NUM_STRUCT_DEFS = " + i2s(length(^(writer.structs_order))) + ";",
			"    static const unsigned NUM_FIELDS = " + i2s(length(^(writer.field_index_table))) + ";",
			"    static const unsigned NUM_GLOBALS = " + i2s(length(writer.global_vars)) + ";"
		]
	);

	if (length(writer.struct_counts) >= 1) {
		rlistPush(h, "\n");
		iter(enumFromTo(0, length(writer.struct_counts) - 1), \i ->
			rlistPush(h, "    static const unsigned NUM_STRUCTS_" + i2s(i) + " = " + i2s(writer.struct_counts[i]) + ";\n")
		)
	}

	cpp2wrLine(h, 
		[
			"",
			"    class NativeProgramImpl : public NativeProgram {",
			"    public:",
			"        NativeProgramImpl() {}",
			"",
			"    protected:",
			"        virtual const char *getByteCode(int *length);",
			"        virtual void flowGCObject(GarbageCollectorFn fn);",
			"        virtual void onRunMain();",
			"",
			"    public:",
			"        StackSlot functions[NUM_FUNCTIONS];",
			"        StackSlot globals[NUM_GLOBALS];",
			"    };",
			"",
			"    extern const unsigned char bytecode_bytes[NUM_CODE_BYTES];",
			"    extern const NativeProgram::FunctionSpec function_specs[NUM_FUNCTIONS];",
			"    extern const NativeProgram::StructSpec struct_specs[NUM_STRUCT_DEFS];",
			"    extern const char field_index_table[NUM_FIELDS][NUM_STRUCTS_1];",
			"",
			"    __attribute__((always_inline)) inline NativeProgramImpl *getSelf(ByteCodeRunner *runner) {",
			"        return (NativeProgramImpl*)runner->getProgram();",
			"    }",
			"",
			"#pragma pack(push, 4)"
		]
	);

	iter(^(writer.struct_code.hdr_lines), \l -> rlistPush(h, "    " + l + "\n"));

	cpp2wrLine(h, ["#pragma pack(pop)", ""]);

	iter(^(writer.method_names), \name -> rlistPush(h, "    DECLARE_NATIVE_METHOD(" + name + ")\n"));

	rlistPush(h, "}");

	cpp2wrLine(o, 
		[
			"",
			"using namespace flowgen_" + writer.config.entry + ";",
			"",
			"NativeProgram *load_" + writer.config.entry + "() {",
			"    return new NativeProgramImpl();",
			"}",
			"",
			"const char *NativeProgramImpl::getByteCode(int *length) {",
			"    *length = NUM_CODE_BYTES;",
			"    return (const char*)bytecode_bytes;",
			"}",
			"",
			"void NativeProgramImpl::flowGCObject(GarbageCollectorFn fn) {",
			"    fn(globals, NUM_GLOBALS);",
			"}",
			"",
			"void NativeProgramImpl::onRunMain() {",
			"    RUNNER_VAR = getFiExpRunner();",
			"",
			"    if (!InitStructTable(struct_specs, NUM_STRUCT_DEFS))",
			"        return;",
			"    if (!InitFunctionTable(functions, function_specs, NUM_FUNCTIONS))",
			"        return;",
			"",
			"    memset(globals, 0, sizeof(globals));",
			"    RUNNER->FreezeNativeFunctions(true);",
			""
		]
	);

	iter(enumFromTo(0, writer.init_count - 1), \i ->
		cpp2wrLine(o, [
			"    aux_init" + i2s(i) + "(RUNNER, NULL);",
			"    if (RUNNER->IsErrorReported()) return;"
		])
	);

	cpp2wrLine(o, [
		"    fn_main(RUNNER, NULL);",
		"}",
		"",
		"const unsigned char flowgen_" + writer.config.entry + "::bytecode_bytes[] = {"
	]);

	rlistPush(o, cpp2wrArray(length(bytes), 20, "    ", "    ", "\n", \i -> i2s(bytes[i])));

	cpp2wrLine(o, 
		[
			"};",
			"",
			"const NativeProgram::FunctionSpec flowgen_" + writer.config.entry + "::function_specs[] = {"
		]
	);

	rlistPush(o, 
		cpp2wrArray(length(^(writer.function_table)), 1, "    ", "    ", "\n", 
			\i -> {
				spec = ^(writer.function_table)[i];
				"{ \"" + spec.name + "\", " +
				if (spec.native_name != "") {
					"\"" + spec.native_name + "\"";
				} else {
					"NULL"
				} +
				", " + i2s(spec.nargs) + ", ";
				if (spec.fn_name != "") {
					"&" + spec.fn_name
				} else {
					"NULL"
				}
				+ " }";
			}
		)
	);

	cpp2wrLine(o, 
		[
			"};",
			"",
			"static const char *const struct_field_names[] = {"
		]
	);

	rlistPush(o, 
		cpp2wrArray(length(^(writer.struct_code.field_names)), 10, "    ", "    ", "\n", 
			\i -> "\"" + ^(writer.struct_code.field_names)[i] + "\""
		)
	);

	cpp2wrLine(o, 
		[
			"};",
			"",
			"static const int struct_field_types[] = {"
		]
	);

	rlistPush(o, 
		cpp2wrArray(length(^(writer.struct_code.field_types)), 20, "    ", "    ", "\n", 
			\i -> i2s(^(writer.struct_code.field_types)[i])
		)
	);

	cpp2wrLine(o, 
		[
			"};",
			"",
			"static const FiExpStructFieldDef struct_field_defs[] = {"
		]
	);

	rlistPush(o, 
		cpp2wrArray(length(^(writer.struct_code.def_lines)), 1, "    ", "    ", "\n", 
			\i -> ^(writer.struct_code.def_lines)[i]
		)
	);

	cpp2wrLine(o, 
		[
			"};",
			"",
			"static const FiExpStructFieldGCDef struct_field_gcdefs[] = {"
		]
	);

	rlistPush(o, 
		cpp2wrArray(length(^(writer.struct_code.gcdef_lines)), 1, "    ", "    ", "\n", 
			\i -> ^(writer.struct_code.gcdef_lines)[i]
		)
	);

	cpp2wrLine(o, 
		[
			"};",
			"",
			"const NativeProgram::StructSpec flowgen_" + writer.config.entry + "::struct_specs[] = {"
		]
	);

	rlistPush(o, 
		cpp2wrArray(length(^(writer.structs_order)), 1, "    ", "    ", "\n", 
			\i ->{
				s = ^(writer.structs_order)[i];
				r = ^(writer.struct_code.info_refs)[i];
				"{ " + i2s(length(s.args)) + ", " + i2s(s.compare_idx) + ", " +
				i2s(r.name_sz) + ", " + i2s(r.name_addr) + ", " +
				(if (length(s.args) > 0) "sizeof(FS_" + s.name + ")" else "4") + ", " +
				i2s(r.empty_addr) + ", " + i2s(r.gcdef_cnt) + ", \"" + s.name +"\", " +
				if (r.fld_idx != cpp2_int_UNDEF) {
					"&struct_field_names["     + i2s(r.fld_idx) +
					"], &struct_field_types["  + i2s(r.type_idx) + 
					"], &struct_field_defs["   + i2s(r.def_idx) +
					"], &struct_field_gcdefs[" + i2s(r.gcdef_idx) + "]"
				} else {
					"NULL, NULL, NULL, NULL"
				}
				+ " }"
			}
		)
	);

	cpp2wrLine(o, 
		[
			"};",
			"",
			"const char flowgen_" + writer.config.entry + "::field_index_table[NUM_FIELDS][NUM_STRUCTS_1] = {"
		]
	);

	rlistPush(o, 
		cpp2wrArray(length(^(writer.field_index_table)), 1, "    ", "    ", "\n", 
			\i -> {
				ln = ^(writer.field_index_table)[i];
				"// " + ^(writer.field_index_list)[i] + ":\n    { " +
				cpp2wrArray(length(ln), 20, "", "      ", " ", 
					\j -> "(char)" + i2s(ln[j])
				) + "}"
			}
		)
	);

	rlistPush(o, "};");

	cpp2wrLine(h, 
		[
			"",
			"#define CHECK_ERROR(cmd) \\",
			"    cmd; \\",
			"    if (unlikely(RUNNER->IsErrorReported())) RETVOID;",
			"#define CHECK_TAG(tag,slot,msg) \\",
			"    if (unlikely(!slot.Is##tag())) { \\",
			"        RUNNER->ReportTagError(slot, tag, msg, NULL); \\",
			"        RETVOID; \\",
			"    }",
			"#define CHECK_STRUCT(slot,fcnt,msg) \\",
			"    if (unlikely(!slot.IsStruct()) || unlikely(unsigned(slot.GetStructId()) >= NUM_STRUCTS_##fcnt)) { \\",
			"        RUNNER->ReportTagError(slot, TStruct, msg, NULL); \\",
			"        RETVOID; \\",
			"    }",
			"#define CHECK_STRUCT_TYPE(slot,id,msg) \\",
			"    if (unlikely(!slot.IsStruct()) || unlikely(unsigned(slot.GetStructId()) != id)) { \\",
			"        RUNNER->ReportStructError(slot, id, msg, NULL); \\",
			"        RETVOID; \\",
			"    }",
			"#define FIND_STRUCT_FIELD(ivar, slot, idx, name, func) \\",
			"    i= field_index_table[idx][slot.GetStructId()]; \\",
			"    if (unlikely(i< 0)) { \\",
			"        RUNNER->ReportFieldNameError(slot, name, func); \\",
			"        RETVOID; \\",
			"    }"
		]
	);
	if (writer.config.verbose > 0) {
		fcPrintln("writing gen_common.h and gen_tables.cpp")
	}
	cpp2writeLines(^h, "gen_common.h");
	cpp2writeLines(^o, "gen_tables.cpp");
}

Cpp2GlobalFnCompilationEnv(
	cur_global : string, 
	next_closure_id : int,
);

cpp2WriterCompileGlobalFn(writer : Cpp2Writer, name : string, body : FiExp) -> void {
	//cur_global = g_name;
	//next_closure_id = 1;

	cpp2WriterCompileLambda(name, cpp2_int_UNDEF, code, None(), Cpp2GlobalFnCompilationEnv(name, 1));
}

cpp2WriterCompileLambda(writer : Cpp2Writer, name : string, idx : int, code : FiExp, upenv : Maybe<Cpp2Environment>, compile_env : Cpp2GlobalFnCompilationEnv) -> Cpp2Environment {
	switch (code) {
		FiLambda(args, body, type, pos): {
			atypes = switch (type) {
				FiTypeFunction(arg_types, ret_type): arg_types;
				default: {
					cpp2_error("cpp2Writertype must be FiTypeFunction");
					[]
				}
			};
			switch (upenv) {
				Some(env): cpp2EnvironmentStashGlobalMeta(env);
				None(): { }
			}
			// Prepare environment
			mname = if (idx == cpp2_int_UNDEF) cpp2FnMethodName(name) else cpp2ClosureMethodName(name, idx);
			vname = if (idx == cpp2_int_UNDEF) name else name + "$" + idx;
			env = cpp2Environment(upenv, mname, vname, length(args), writer.struct_list);
			//ctx = env.cur_ctx;
			//env.struct_list = struct_list;
			//env.nargs = args.length;
			
			iter(enumFromTo(0, length(args) - 1), \i -> {
					place_info = cpp2PlaceInfo(env, Cpp2Argument(), i, args[i]);
					(place.meta).contex ::= 0;
					(place.meta).dirty ::= true;
					(place.meta).type ::= atypes[i];
					env.locals ::= setTree(args[i].name, place_info)
				}
			);
			/*for (i in 0...args.length)
			{
				place = new Cpp2PlaceInfo(env, Argument, i, args[i]);
				if (atypes != null) {
					place.meta.context = 0;
					place.meta.dirty = true;
					place.meta.type = atypes[i];
				}
				env.locals.set(args[i], place);
			}*/

			// Process the body
			cpp2WriterCompileExpression(body, ctx, OutputReturn(), Cpp2StackTop(0));
			cpp2ContextExit(ctx);

			// Flush the code
			// TODO: place here a file, which contains lambda
			// Get rid of the absolute paths to our includes
			t = fold(writer.config.includes, "" /*file*/, \acc, incl ->
				strReplace(strReplace(acc, incl, ""), incl + "/", "")
			);
			t_norm = strReplace(strReplace(strReplace(t, "/", "_"), ".flow", ""), ".", "_");
			cpp2WriterEmitLambdaCode(env, "flow_" + t_norm + ".cpp");
			switch (upenv) {
				Some(e): cpp2EnvironmentRestoreGlobalMeta(e);
				None(): { }
			}
			env
		}
		default: {
			cpp2_error("cpp2Writerbody must be FiLambda");
			dummyCpp2Environment
		}
	}
}

cpp2WriterCompileExpression(writer : Cpp2Writer, code : FiExp, ctx : Cpp2Context, out : Cpp2OutputLocation, top : Cpp2StackTop) -> void {
		output = \expr, tag -> {
			cpp2WriterEmitValue(ctx, out, expr, tag);
		};
		eval_tmp = \arg -> {
			cpp2WriterEvalToTmp(writer, arg, ctx, top);
		}
		fetch_ref = \arg, lvalue -> {
			cpp2WriterFetchToRef(writer, arg, ctx, top, lvalue);
		}
		switch (code) {
			FiVoid(__):
				output("FLOWVOID", Cpp2TVoid());
			FiBool(value, __):
				output("StackSlot::MakeBool(" + b2s(value) + ")", Cpp2TBool());
			FiInt(value, __):
				output("StackSlot::MakeInt(" + cpp2WriterEmitNumericExpr(writer, code, ctx, top, Cpp2TInt()) + ")", Cpp2TInt());
			FiDouble(value, __):
				output("StackSlot::MakeDouble(" + cpp2WriterEmitNumericExpr(witer, code, ctx, top, Cpp2TDouble()) + ")", Cpp2TDouble());
			FiString(value, __):
				output(cpp2WriterRegisterConstString(writer, value).rslot, Cpp2TString());
			FiCall(fn, args, type, __):
				cpp2WriterCompileCall(code, fn, args, ctx, out, top);
			FiLambda(args, body, type, __):
				cpp2WriterCompileClosure(writer, code, ctx, out, top);
			FiVar(n, type, __):
				cpp2WriterCopyValue(ctx, out, cpp2WriterGetValueRef(code, ctx));
			FiSeq(es, type, __): {
				iteri(es, \i, e ->
					if (i == lengtn(es) -1) {
						cpp2WriterCompileExpression(e, ctx, out, top);
					} else {
						cpp2WriterCompileExpression(e, ctx, Cpp2OutputNone(), cpp2Mktop(top));
					}
				)
			}
			FiLet(name, type, e1, e2, type2, __): {
				//if (scope != null) {
					cpos = cpp2ContextDefpos(ctx);
					def = cpp2EnvironmentMklocal(ctx.env, name);
					cpp2WriterCompileExpression(e1, ctx, Cpp2Cpp2OutputVar(def), cpp2Mktop(top));
					(cpp2ContextLocalMeta(ctx, def)).type ::= type;
					cpp2ContextPushdef(ctx, def);
					cpp2WriterCompileExpression(e2, ctx, out, top);
					ctx.popdefs(cpos);
				//} else {
				//	cpp2WriterCompileExpression(value, ctx, Cpp2OutputNone(), cpp2Mktop(top));
				//	output("FLOWVOID", Cpp2TVoid());
				//}
			}
			FiIf(cond, e1, e2, type, __): {
				cond_expr = cpp2WriterEmitConditionExpr(cond, ctx, cpp2Mktop(top));
				cpp2ContextWr(ctx, "if (" + cond_expr + ") {");
					ctx_if = cpp2ContextEnter(ctx, "    ");
					cpp2WriterCompileExpression(e1, cif, out, cpp2Mktop(top));
					cpp2ContextExit(ctx_if);
				cpp2ContextWr(ctx, "} else {");
					ctx_else = cpp2ContextEnter(ctx, "    ");
					cpp2WriterCompileExpression(e2, celse, out, cpp2Mktop(top));
					cpp2ContextExit(ctx_else);
				cpp2ContextWr(ctx, "}");
				cpp2ContextJoin(ctx, [ctx_if, ctx_else]);
			}
			FiSwitch(e0, sw_type, cases, type, __): {
				mvexpr = cpp2WriterGetValueRef(e0, ctx, false);
				vexpr = switch(mvexpr) {
					Some(ve): ve;
					None(): cpp2WriterEvalToTmp(e0, ctx, top);
				}
				
				/*restore_cb = null;
				if (vexpr == null) {
					// avoid using the same temporary for out and copy
					getOutputPlace(out, top);
					vexpr = evalToTmp(e0, ctx, top);
				} else if (!vexpr.isLValue()) {
					// Copy the struct into a temporary if not lvalue, to make FieldAlias efficient.
					getOutputPlace(out, top);
					restore_cb = makeLValueCopy(ctx, vexpr, top);
				}*/
				
				restore_cb = switch (mvexpr) {
					None(): {
						// avoid using the same temporary for out and copy
						cpp2WriterGetOutputPlace(out, top);
						None()
					}
					Some(__): {
						if (!cpp2PlaceInfoIsLValue(vexpr)) {
							// Copy the struct into a temporary if not lvalue, to make FieldAlias efficient.
							cpp2WriterGetOutputPlace(out, top);
							cpp2WriterMakeLValueCopy(ctx, vexpr, top);
						} else {
							None()
						}
					}
				}
				
				cpp2WriterVerifyTag(vexpr, Cpp2TStruct(), ctx);
				cpp2ContextWr(ctx, "switch (" + cpp2PlaceInfoGetLValue(vexpr) + ".GetStructId()) {");
				branches = ref [];
				//foundDefault = false;
				//for (c in cases) {
				foundDefault = fold(cases, false, 
					\acc, c -> {
						subctx = cpp2ContextEnter(ctx, "    ");
						if (c.struct == "default") {
							cpp2ContextWr(ctx, "default: {");
						} else {
							structDef = lookupTreeDef(writer.structs, c.struct, dummyCpp2StructInfo);
							cpp2ContextWr(ctx, "case " + i2s(structDef.id) + "/*" + c.struct + "*/: {");
							loc = cpp2ContextLocalMeta(subctx, vexpr);
							loc.tag ::= Cpp2TStruct();
							loc.struct_size ::= length(structDef.args);
							loc.struct_id ::= structDef.id;
							fori(0, length(c.args) - 1, 
								\i -> {
									def = if (structDef.args[i].ismutable) {
										def1 = cpp2EnvironmentMklocal(subctx, c.argNames[i]);
										cpp2ContextWr(ctx, cpp2PlaceInfoGetLValue(def2) + " = " + cpp2PlaceInfoGetRValue(def, subctx));
										def1;
									} else {
										cpp2PlaceInfo(ctx.env, Cpp2FieldAlias(vexpr, structDef), i, c.args[i])
									};
									(def.meta).dirty ::= true;
									(def.meta).type ::= structDef.args[i].type;
									if (structDef.atypes[i] != Cpp2TNull()) {
										(def.meta).tag ::= structDef.atypes[i];
									}
									cpp2ContextPushdef(subctx, def);
								}
							)
						}
						refArrayPush(branches, subctx);
						cpp2WriterCompileExpression(c.body, subctx, out, cpp2Mktop(top));
						if (out != Cpp2OutputReturn()) {
							cpp2ContextWr(subctx, "break;");
						}
						cpp2ContextExit(subctx);
						cpp2ContextWr(ctx, "}");
						acc || c.struct == "default"
					}
				);
				foundDefault = pair.second;
				if (!foundDefault) {
					cpp2ContextWr(ctx, "default:");
					cpp2ContextWr(ctx, "    RUNNER->ReportError(UncaughtSwitch, \"Unexpected in switch in " + ctx.env.vname + "\");");
					cpp2ContextWr(ctx, "    RETVOID;");
				}
				cpp2ContextWr(ctx, "}");
				cpp2ContextJoin(ctx, ^branches);
				switch (restore_cb) {
					Some(cb): cb();
					None(): { }
				}
			}
			FiCast(value, fromtype, totype, type, __): {
				ref = fetch_ref(value, false);
				rexpr = cpp2PlaceInfoGetRValue(ref, ctx);
				switch (fromtype) {
					FiTypeInt(): {
						cpp2WriterVerifyTag(ref, Cpp2TInt(), ctx);
						switch (totype) {
							FiTypeInt():
								cpp2WriterCopyValue(ctx, out, ref);
							FiTypeDouble():
								output("StackSlot::MakeDouble(" + rexpr + ".GetInt())", Cpp2TDouble());
							FiTypeString():
								cpp2WriterEmitValue(ctx,out,"ByteCodeRunner::DoInt2String(RUNNER," + rexpr + ")", Cpp2TString(), false, true, true);
							default: 
								cpp2_error("Not implemented: " + prettyFiExp(dummyPretty, value);
						}
					}
					FiTypeDouble(): {
						switch (totype) {
							FiTypeInt(): {
								cpp2WriterVerifyTag(ref, Cpp2TDouble(), ctx);
								output("StackSlot::MakeInt(" + rexpr + ".GetDouble())", Cpp2TInt());
							}
							FiTypeDouble(): {
								cpp2WriterVerifyTag(ref, Cpp2TDouble(), ctx);
								cpp2WriterCopyValue(ctx, out, ref);
							}
							FiTypeString(): {
								cpp2WriterEmitValue(ctx,out, "ByteCodeRunner::DoDouble2String(RUNNER," + rexpr + ")", Cpp2TString(), false, true, true);
							}
							default: {
								cpp2_error("Not implemented: " + prettyFiExp(dummyPretty, value));
							}
						}
					}
					FiTypeName(n1, __): {
						switch (totype) {
							FiTypeName(n2, __): {
								cpp2WriterCopyValue(ctx, out, ref);
							}
							default: {
								cpp2_error("Not implemented: " + prettyFiExp(dummyPretty, code));
							}
						}
					}
					/*TBoundTyvar(__): {
						cpp2WriterCopyValue(ctx, out, ref);
					}*/
					FiTypeArray(fa): {
						switch (totype) {
							FiTypeArray(ta): {
								switch (fa) {
									FiTypeName(n1, __):
										switch (ta) {
											// Array of named types are OK 
											FiTypeName(n2, __): cpp2WriterCopyValue(ctx, out, ref);
											default: cpp2_error("Not implemented: " + prettyFiExp(dummyPretty, code));
									}
									default: cpp2_error("Not implemented: " + prettyFiExp(dummyPretty, code));
								}
							}
							default: cpp2_error("Not implemented: " + prettyFiExp(dummyPretty, code));
						}
					}
					FiTypeFlow(): {
						cpp2WriterCopyValue(ctx, out, ref);
					}
					default: cpp2_error("Not implemented: " + prettyFiExp(dummyPretty, code));
				}
			}
			FiCallPrim(op, es, type, __): {
				cpp2WriterCompileCallPrim(writer, code, ctx, out, top);
			}
			FiRequire(flowfile, e, type, __): {
				cpp2_error("FiRequire is not supported yet"); // TODO: implement
				output("FLOWVOID", None());
			}
			FiUnsafe(name, fallback, type, __): {
				cpp2_error("FiUnsafe is not supported yet"); // TODO: implement
				output("FLOWVOID", None());
			}
			default: {
				cpp2_error("Not implemented: " + prettyFiExp(dummyPretty, code));
				output("FLOWVOID", None());
			}
		}
	}
	
// A hack: copy a rvalue place into a temporary, and then change the
// fields of the original place to point to the new location.
cpp2WriterMakeLValueCopy(ctx : Cpp2Context, place : Cpp2PlaceInfo, top : Cpp2StackTop) -> () -> void {
	top_temp = top.temp;
	top.temp ::= top_temp + 1;
	tref = cpp2EnvironmentMktemp(ctx.env, top_temp);
	cpp2ContextWrSemi(ctx, cpp2PlaceInfoGetLValue(tref) + " = " + cpp2PlaceInfoGetRValue(place, ctx));
	cpp2PlaceInfoSubstituteLocation(place, tref);
}

	
cpp2WriterCompileCallPrim(writer : Cpp2Writer, code : FiCallPrim, ctx : Cpp2Context, out : Cpp2OutputLocation, top : Cpp2StackTop) -> void {
	output = \expr, tag -> {
		cpp2WriterEmitValue(ctx, out, expr, tag, false, false, false);
		{}
	};
	eval_tmp = \arg -> {
		cpp2WriterEvalToTmp(writer, arg, ctx, top, Cpp2OutputNull());
	}
	fetch_ref = \arg, lvalue -> {
		cpp2WriterFetchToRef(writer, arg, ctx, top, lvalue, Cpp2OutputNull());
	}
	switch (code.op) {
		FcStructPrim(name): {
			structDef = lookupTreeDef(writer.structs, name, dummyCpp2StructInfo);
			cpp2WriterCompileNewStruct(writer, structDef, code.es, ctx, out, top, "");
		}
		FcRefPrim(): {
			ref = fetch_ref(code.es[0], true);
			cpp2WriterEmitValue(ctx, out, "RUNNER->AllocateRef(" + cpp2PlaceInfoGetLValue(ref) + ")", Cpp2TRefTo(), false, true, true);
			{}
		}
		FcIndexPrim(): {
			arr = fetch_ref(code.es[0], false);
			idx = cpp2WriterEmitNumericExpr(writer, code.es[1], ctx, top, Cpp2TInt());
			cpp2WriterVerifyTag(arr, Cpp2TArray(), ctx);
			expr = "DerefArray(RUNNER," + cpp2PlaceInfoGetRValue(arr, ctx) + "," + idx + ")";
			cpp2WriterEmitValue(ctx, out, expr, Cpp2TNull(), false, true, false);
		}
		FcDerefPrim(): {
			ref = fetch_ref(code.es[0], false);
			cpp2WriterVerifyTag(ref, Cpp2TRefTo(), ctx);
			output("RUNNER->GetRefTarget(" + cpp2PlaceInfoGetRValue(ref, ctx) + ")", Cpp2TNull());
		}
		FcAssignPrim(): {
			ref = fetch_ref(code.es[0], false);
			value = fetch_ref(code.es[1], false);
			cpp2WriterVerifyTag(ref, Cpp2TRefTo(), ctx);
			//output("RUNNER->SetRefTarget(" + cpp2PlaceInfoGetRValue(ref, ctx) + "," + cpp2PlaceInfoGetRValue(value, ctx) + ");");
			cpp2ContextWrSemi(ctx, "RUNNER->SetRefTarget(" + cpp2PlaceInfoGetRValue(ref, ctx) + "," + cpp2PlaceInfoGetRValue(value, ctx) + ")");
			cpp2WriterCopyValue(ctx, out, value);
		}
		FcArrayPrim(): {
			cpp2WriterCompileConstructor(writer, code.es, ctx, out, top, Cpp2TArray(), \cnt, ptr -> {
				if (cnt == 0) {
					"StackSlot::MakeEmptyArray()";
				} else {
					"RUNNER->AllocateArray(" + i2s(cnt) + "," + ptr + ")";
				}
			}, false)
		}
		FcFieldPrim(name): {
			ref = fetch_ref(code.es[0], false);
			sref = cpp2PlaceInfoGetRValue(ref, ctx);
			if (name == "structname") {
				cpp2WriterVerifyStruct(ref, 0, ctx);
				specs = "struct_specs[" + sref + ".GetStructId()]";
				output("StackSlot::InternalMakeString(MakeFiExpPtr(" + 
					specs + ".name_addr)," + specs + ".name_size,false)", Cpp2TString());
			} else {
				v = cpp2WriterFieldSetInfo(writer, code.es[0], ref, name);
				if (v.stype != cpp2_int_UNDEF) {
					info = writer.struct_list[v.stype];
					cpp2WriterVerifyStructId(writer, ref, v.stype, ctx);
					at = info.atypes[v.index];
					switch (out) {
						Cpp2OutputScalar(sname, tag): {
							if (tag == at) {
								rf = cpp2ContextGetStructField(ctx, ref, ^(writer.structs_order)[v.stype].name, name, Cpp2TNull());
								cpp2ContextWrSemi(ctx, sname + " = " + rf);
							} else {
								output(cpp2ContextGetStructField(ctx, ref, ^(writer.structs_order)[v.stype].name, name, at), at);
							}
						}
						default: { 
							output(cpp2ContextGetStructField(ctx, ref, ^(writer.structs_order)[v.stype].name, name, at), at);
						}
					}
				} else if (v.index != cpp2_int_UNDEF && v.index >= 0) {
					cpp2WriterVerifyStruct(ref, v.minsize, ctx);
					output("RUNNER->GetStructSlot(" + sref + "," + i2s(v.index) + "/*" + name + "*/)", Cpp2TNull());
				} else {
					// Dynamic lookup
					ivar = cpp2WriterFindFieldIndex(writer, ref, name, ctx);
					output("RUNNER->GetStructSlot(" + sref + "," + ivar + ")", Cpp2TNull());
				}
			}
		}
		FcSetMutablePrim(name): {
			ref = fetch_ref(code.es[0], false);
			val = fetch_ref(code.es[1], false);
			sref = cpp2PlaceInfoGetRValue(ref, ctx);
			if (name != "structname") {
				v = cpp2WriterFieldSetInfo(writer, code.es[0], ref, name);
				if (v.stype != cpp2_int_UNDEF) {
					info = writer.struct_list[v.stype];
					cpp2WriterVerifyStructId(writer, ref, v.stype, ctx);
					at = info.atypes[v.index];
					if (at != Cpp2TNull()) {
						cpp2WriterVerifyTag(val, at, ctx); {}
					}
					ptr = cpp2ContextGetStructPtr(ctx, ref, ^(writer.structs_order)[v.stype].name, true);
					if (!cpp2IsNonGCFieldType(at)) {
						cpp2ContextWrSemi(ctx, "RUNNER->RegisterWrite(&" + ptr + "->hdr)");
					}
					if (at == Cpp2TStruct()) {
						cpp2ContextWrSemi(ctx, ptr + "->fl_" + name + " = " + cpp2PlaceInfoGetStructAddr(val, ctx));
					} else {
						cpp2ContextWrSemi(ctx, "flow_struct::set_" + cpp2StructFieldCode(at) +
							"(" + ptr + "->fl_" + name + "," + cpp2PlaceInfoGetRValue(val, ctx) + ")");
					}
				} else if (v.index != cpp2_int_UNDEF && v.index >= 0) {
					cpp2WriterVerifyStruct(ref, v.minsize, ctx);
					cpp2ContextWrCheck(ctx, "RUNNER->SetStructSlot(" + sref + "," + i2s(v.index) + "/*" + name + "*/," + cpp2PlaceInfoGetRValue(val, ctx) + ")", false);
				} else {
					// Dynamic lookup
					ivar = cpp2WriterFindFieldIndex(writer, ref, name, ctx);
					cpp2ContextWrCheck(ctx, "RUNNER->SetStructSlot(" + sref + "," + ivar + "," + cpp2PlaceInfoGetRValue(val, ctx) + ")", false);
				}
			}
			output("FLOWVOID", Cpp2TNull());
		}
		FcPlusPrim():  cpp2WriterCompileMath(code, ctx, out, top);
		FcMinusPrim(): cpp2WriterCompileMath(code, ctx, out, top);
		FcMulPrim():   cpp2WriterCompileMath(code, ctx, out, top);
		FcDivPrim():   cpp2WriterCompileMath(code, ctx, out, top);
		FcModPrim():   cpp2WriterCompileMath(code, ctx, out, top);
		FcNegPrim():   cpp2WriterCompileMath(code, ctx, out, top);

		FcAndPrim(): cpp2WriterCompileCondition(writer, code, ctx, out, top);
		FcOrPrim():  cpp2WriterCompileCondition(writer, code, ctx, out, top);
		FcNotPrim(): cpp2WriterCompileCondition(writer, code, ctx, out, top);

		FcEqPrim(): cpp2WriterCompileCondition(writer, code, ctx, out, top);
		FcNePrim(): cpp2WriterCompileCondition(writer, code, ctx, out, top);
		FcGtPrim(): cpp2WriterCompileCondition(writer, code, ctx, out, top);
		FcGePrim(): cpp2WriterCompileCondition(writer, code, ctx, out, top);
		FcLtPrim(): cpp2WriterCompileCondition(writer, code, ctx, out, top);
		FcLePrim(): cpp2WriterCompileCondition(writer, code, ctx, out, top);

		FcCreateClosurePrim(str_name, fn_name): cpp2_error("FcCreateClosurePrim is unsupported yet"); // TODO: implement
		FcQuote(): cpp2_error("FcQuote is unsupported yet"); // TODO: implement
		FcUnquote(): cpp2_error("FcUnquote() is unsupported yet"); // TODO: implement
	}
}

cpp2WriterCompileCondition(writer : Cpp2Writer, code : FiExp, ctx : Cpp2Context, out : Cpp2OutputLocation, top : Cpp2StackTop) -> void {
	cexpr = cpp2WriterEmitConditionExpr(writer, code, ctx, top);
	switch (out) {
		Cpp2OutputScalar(name,tag): {
			if (tag == Cpp2TBool()) {
				cpp2ContextWrSemi(ctx, name + " = " + cexpr);
			} else {
				cpp2WriterEmitValue(ctx, out, "StackSlot::MakeBool(" + cexpr + ")", Cpp2TBool(), false, false, false);
			}
		}
		default: { 
			cpp2WriterEmitValue(ctx, out, "StackSlot::MakeBool(" + cexpr + ")", Cpp2TBool(), false, false, false);
		}
	}
}

cpp2WriterEmitConditionExpr(writer : Cpp2Writer, code : FiCallPrim, ctx : Cpp2Context, top : Cpp2StackTop) -> string {
	switch (code.op) {
		FcEqPrim():
			cpp2WriterEmitComparisonExpr("==", code.es[0], code.es[1], code.type, ctx, top);
		FcNePrim():
			cpp2WriterEmitComparisonExpr("!=", code.es[0], code.es[1], code.type, ctx, top);
		FcLtPrim():
			cpp2WriterEmitComparisonExpr("<", code.es[0], code.es[1], code.type, ctx, top);
		FcLePrim():
			cpp2WriterEmitComparisonExpr("<=", code.es[0], code.es[1], code.type, ctx, top);
		FcGtPrim():
			cpp2WriterEmitComparisonExpr(">", code.es[0], code.es[1], code.type, ctx, top);
		FcGePrim():
			cpp2WriterEmitComparisonExpr(">=", code.es[0], code.es[1], code.type, ctx, top);
		FcNotPrim():
			"!" + cpp2WriterEmitConditionExpr(code.es[0], ctx, top);
		FcAndPrim(): {
			a1expr = cpp2WriterEmitConditionExpr(code.es[0], ctx, cpp2Mktop(top));
			tmp = cpp2ContextTempvar(ctx, "btmp", Cpp2TBool(), a1expr);
			cpp2ContextWr(ctx, "if (" + tmp + ") {");
			subctx = cpp2ContextEnter(ctx, "    ");
			a2expr = cpp2WriterEmitConditionExpr(code.es[1], subctx, cpp2Mktop(top));
			cpp2ContextWrSemi(subctx, tmp + " = " + a2expr);
			cpp2ContextExit(subctx);
			cpp2ContextWr(ctx, "}");
			cpp2ContextJoinOne(ctx, subctx);
			tmp
		}
		FcOrPrim(): {
			a1expr = cpp2WriterEmitConditionExpr(code.es[0], ctx, cpp2Mktop(top));
			tmp = cpp2ContextTempvar(ctx, "btmp", Cpp2TBool(), a1expr);
			cpp2ContextWr(ctx, "if (!" + tmp + ") {");
			subctx = cpp2ContextEnter(ctx, "    ");
			a2expr = cpp2WriterEmitConditionExpr(code.es[1], subctx, cpp2Mktop(top));
			cpp2ContextWrSemi(subctx, tmp + " = " + a2expr);
			cpp2ContextExit(subctx);
			cpp2ContextWr(ctx, "}");
			cpp2ContextJoinOne(ctx, subctx);
			tmp
		}
		default:
			cpp2WriterFetchToScalar(code, ctx, top, Cpp2TBool());
	}
}

cpp2WriterEmitComparisonExpr(op : string, expr1 : FiExp, expr2 : FiExp, tp : FiType, ctx : Cpp2Context, top : Cpp2StackTop) -> string {
	// Check for number comparisons
	type = cpp2GetPrimitiveTag(tp);
	top2 = cpp2Mktop(top);
	if (type == Cpp2TInt() || type == Cpp2TDouble()) {
		val1 = cpp2WriterEmitNumericExpr(expr1, ctx, top2, type);
		val2 = cpp2WriterEmitNumericExpr(expr2, ctx, top2, type);
		cpp2ContextTempvar(ctx, "btmp", Cpp2TBool(), val1 + op + val2);
	} else if (type == Cpp2TBool() && (op == "==" || op == "!=")) {
		val1 = cpp2WriterEmitConditionExpr(expr1, ctx, top2);
		val2 = cpp2WriterEmitConditionExpr(expr2, ctx, top2);
		cpp2ContextTempvar(ctx, "btmp", Cpp2TBool(), val1 + op + val2);
	}

	ref1_0 = cpp2WriterFetchToRef(expr1, ctx, top2, false);
	ref2_0 = cpp2WriterFetchToRef(expr2, ctx, top2, false);

	// Check if already compared in reverse order
	swap = contains(ref2_0.meta.known_compares, ref1_0);
	ref1 = if (swap) ref2_0 else ref1_0; 
	ref2 = if (swap) ref1_0 else ref2_0;

	// Call compare if needed
	cvar = "cmp_" + i2s(ref1.uid) + "_" + i2s(ref2.uid);

	if (!contains(ref1.meta.known_compares, ref2)) {
		Cpp2ContextRegisterIdxVar(ctx, cvar, "int");
		cpp2ContextWr(ctx, cvar + " = RUNNER->Compare(" + cpp2PlaceInfoGetRValue(ref1, ctx) + "," + cpp2PlaceInfoGetRValue(ref2, ctx) + ");");

		lm = cpp2ContextLocalMeta(ctx, ref1);
		lm.known_compares ::= concat(lm.known_compares, ref2);
	}
	cexpr = if (swap) "(0"+ op + cvar + ")" else "(" + cvar + op + "0)";
	cpp2ContextTempvar(ctx, "btmp", Cpp2TBool(), cexpr)
}

cpp2WriterEmitNumericExpr(writer : Cpp2Writer, expr : FiExp, ctx : Cpp2Context, top : Cpp2StackTop, tag : Cpp2TagType) -> string {
	simple_binary = \e1, e2, op -> {
		v1 = cpp2WriterEmitNumericExpr(writer, e1, ctx, top, tag);
		v2 = cpp2WriterEmitNumericExpr(writer, e2, ctx, top, tag);
		cpp2ContextTempvar(ctx, "ntmp", tag, v1 + op + v2);
	}
	switch (expr) {
		FiInt(value, __):
			//(I2i.ucompare(value, int_80000000) == 0) ? 'int(0x80000000U)' : ''+value;
			if (value == cpp2_int_80000000) "int(0x80000000U)" else i2s(value);
		FiDouble(value, __): {
			if (value <= doubleMin) {
				"(-std::numeric_limits<double>::infinity())";
			} else if (value >= doubleMax) {
				"std::numeric_limits<double>::infinity()";
			} else if (isNanOrInf(value)) {
				"std::numeric_limits<double>::quiet_NaN()";
			} else {
				sv = d2s(value);
				if (strIndexOf(sv, ".") == -1 && strIndexOf(sv, "e") == -1) sv + ".0" else sv
			}
		}
		FiCallPrim(op, es, type, __): {
			switch (op) {
				FcPlusPrim():  simple_binary(es[0], es[1], "+");
				FcMinusPrim(): simple_binary(es[0], es[1], "-");
				FcMulPrim():   simple_binary(es[0], es[1], "*");
				FcDivPrim():   simple_binary(es[0], es[1], "/");
				FcModPrim(): {
					if (tag == Cpp2TDouble()) {
						v1 = cpp2WriterEmitNumericExpr(writer, es[0], ctx, top, tag);
						v2 = cpp2WriterEmitNumericExpr(writer, es[1], ctx, top, tag);
						cpp2ContextTempvar(ctx, "ntmp", tag, "fmod(" + v1 + "," + v2 + ")");
					} else {
						 simple_binary(es[0], es[1], "%");
					}
				}
				FcNegPrim(): "(-" + cpp2WriterEmitNumericExpr(writer, es[0], ctx, top, tag) + ")"
			}
		}
		FiCast(value, fromtype, totype, type, pos): {
			switch (totype) {
				FiTypeInt(): { }
				FiTypeDouble(): { }
				default: cpp2_error("Not implemented: " + prettyFiExp(dummyPretty, expr));
			}
			switch (fromtype) {
				// TODO: is there a bug ?...
				FiTypeInt(): {
					arg = cpp2WriterEmitNumericExpr(writer, value, ctx, top, Cpp2TInt());
					if (tag == Cpp2TDouble()) "double(" + arg + ")" else arg;
				}
				FiTypeDouble(): {
					arg = cpp2WriterEmitNumericExpr(writer, value, ctx, top, Cpp2TDouble());
					if (tag == Cpp2TDouble()) "int(" + arg + ")" else arg;
				}
				default: cpp2_error("Not implemented: " + prettyFiExp(dummyPretty, expr));
			}
		}
		FiCall(fn, args, type, pos): {
			nname = cpp2WriterCallNativeName(writer, fn, ctx);
			if (nname != "") {
				if (nname == "Native.length") {
					arg = cpp2WriterFetchToRef(args[0], ctx, mktop(top), false);
					cpp2WriterVerifyTag(arg, Cpp2TArray(), ctx);
					valstr = "RUNNER->GetArraySize(" + cpp2PlaceInfoGetRValue(arg, ctx) + ")";
					cpp2ContextTempvar(ctx, "len", Cpp2TInt(), valstr);
				} else if (nname == "Native.strlen") {
					arg = cpp2WriterFetchToRef(args[0], ctx, mktop(top), false);
					cpp2WriterVerifyTag(arg, TString, ctx);
					valstr = "RUNNER->GetStringSize(" + cpp2PlaceInfoGetRValue(arg, ctx) + ")";
					cpp2ContextTempvar(ctx, "len", Cpp2TInt(), valstr);
				} else if (nname == "Native.bitXor") {
					simple_binary(args[0], args[1], "^");
				} else if (nname == "Native.bitOr") {
					simple_binary(args[0], args[1], "|");
				} else if (nname == "Native.bitAnd") {
					simple_binary(args[0], args[1], "&");
				} else if (nname == "Native.bitNot") {
					"(~" + cpp2WriterEmitNumericExpr(writer, args[0], ctx, top, Cpp2TInt()) + ")";
				} else {
					cpp2WriterFetchToScalar(expr, ctx, top, tag);
				}
			} else {
				cpp2WriterFetchToScalar(expr, ctx, top, tag);
			}
		}
		default: {
			cpp2WriterFetchToScalar(expr, ctx, top, tag);
		}
	}
}

cpp2WriterCompileNumericExpr(expr : FiExp, ctx : Cpp2Context, out : Cpp2OutputLocation, top : Cpp2StackTop, ttag : Cpp2TagType) -> void {
	cexpr = cpp2WriterEmitNumericExpr(expr, ctx, top, ttag);
	cb = \-> if (ttag == Cpp2TDouble()) {
		cpp2WriterEmitValue(ctx, out, "StackSlot::MakeDouble(" + cexpr + ")", Cpp2TDouble());
	} else {
		cpp2WriterEmitValue(ctx, out, "StackSlot::MakeInt(" + cexpr + ")", Cpp2TInt());
	};
	switch (out) {
		Cpp2OutputScalar(name, tag): {
			if (tag == ttag) {
				cpp2ContextWrSemi(ctx, name + " = " + cexpr);
			} else {
				cb();
			}
		}
		default: { 
			cb();
		}
	}
}

cpp2WriterCompileMath(expr : FiCallPrim, ctx : Cpp2Context, out : Cpp2OutputLocation, top : Cpp2StackTop) {
	ttag = cpp2GetPrimitiveTag(expr.type);
	if (ttag == Cpp2TDouble() || ttag == Cpp2TInt()) {
		compileNumericExpr(expr, ctx, out, top, ttag);
	} else {
		eval_tmp = \arg, allow_out -> { // ?allow_out = false
			cpp2WriterEvalToTmp(arg, ctx, top, if (allow_out) out else Cpp2OutputNone());
		};
		fetch_ref = \arg, lvalue, allow_out -> { // ?allow_out = false
			cpp2WriterFetchToRef(arg, ctx, top, lvalue, if (allow_out) out else Cpp2OutputNone());
		};
		simple_binary = \e1, e2, cmd -> {
			a1 = eval_tmp(e1, true);
			a2 = fetch_ref(e2, false);
			cpp2ContextWrCheck(ctx, "RUNNER->" + cmd + "(" + cpp2PlaceInfoGetLValue(a1) + ", " + cpp2PlaceInfoGetRValue(a2, ctx) + ")");
			a1
		}
		out_ref = switch (expr.op) {
			FcPlusPrim(): {
				a1 = eval_tmp(expr.es[0], true);
				a2 = fetch_ref(expr.es[1], true);
				if (ttag == Cpp2TString()) {
					cpp2WriterVerifyTag(a1, ttag, ctx);
					cpp2WriterVerifyTag(a2, ttag, ctx);
					cpp2ContextWrCheck(ctx, "RUNNER->DoPlusString(" + cpp2PlaceInfoGetLValue(a1) + ", " + cpp2PlaceInfoGetLValue(a2) + ")", true);
				} else {
					cpp2ContextWrCheck(ctx, "RUNNER->DoPlus(" + cpp2PlaceInfoGetLValue(a1) + ", " + cpp2PlaceInfoGetLValue(a2) + ")", true);
				}
				a1
			}
			FcMinusPrim(): simple_binary(expr.es[0], expr.es[1], "DoMinus");
			FcMulPrim():   simple_binary(expr.es[0], expr.es[1], "DoMultiply");
			FcDivPrim():   simple_binary(expr.es[0], expr.es[1], "DoDivide");
			FcModPrim():   simple_binary(expr.es[0], expr.es[1], "DoModulo");
			FcNegPrim(): {
				a1 = eval_tmp(e1, true);
				cpp2ContextWrCheck(ctx, "RUNNER->DoNegate(" + cpp2PlaceInfoGetLValue(a1) + ")");
				a1
			}
			default: {
				cpp2_error("impossible");
				dummyCpp2PlaceInfo
			}
		}
		cpp2WriterCopyValue(ctx, out, out_ref);
	}
}

cpp2WriterEmitPrimitiveWrap(op : FcPrim, es : [FiExp], ctx : Cpp2Context, top : Cpp2StackTop) -> string {
	numbers = \tp, pos -> {
		tp_tag = cpp2GetPrimitiveTag(tp);
		if (tp_tag != Cpp2TInt() && tp_tag != Cpp2TDouble()) "" else {
			cexpr = cpp2WriterEmitNumericExpr(expr, ctx, top, tp_tag);
			if (tp_tag == Cpp2TDouble()) {
				"StackSlot::MakeDouble(" + cexpr + ")";
			} else {
				"StackSlot::MakeInt(" + cexpr + ")";
			}
		}
	}
	boolean = \-> {
		cexpr = cpp2WriterEmitConditionExpr(expr, ctx, top);
		"StackSlot::MakeBool(" + cexpr + ")";
	}
	switch (op) {
		FcPlusPrim(e1, e2, pos): numbers(pos);
		FcMinusPrim(e1, e2, pos): numbers(pos);
		FcMulPrim(e1, e2, pos): numbers(pos);
		FcDivPrim(e1, e2, pos): numbers(pos);
		FcModPrim(e1, e2, pos): numbers(pos);
		FcNegPrim(e1, pos): numbers(pos);

		FcAndPrim(e1, e2, pos): boolean();
		FcOrPrim(e1, e2, pos): boolean();
		FcNotPrim(e1, pos): boolean();

		FcEqPrim(): boolean();
		FcNePrim(): boolean();
		FcGtPrim(): boolean();
		FcGePrim(): boolean();
		FcLtPrim(): boolean();
		FcLePrim(): boolean();

		/*Field(call, name, pos):
			var ttag = getPrimitiveTag(pos);
			if (ttag == TBool)
				boolean();
			else
				numbers(pos);*/
		default: {
			cpp2_error("not supported yet"); // TODO: implement
		}
	}
}

cpp2WriterAssignExpr(plv : string, expr : string, call : bool) -> string { // ?call : Bool = false
	if (startsWith(expr, cpp2_STACKSLOT_MAKE)) {
		i = strIndexOf(expr, "(");
		"StackSlot::Set" + 
		substring(expr, 15, i-15) +
		"(" + plv +
		(if (getCharAt(expr, i + 1) != ")") "," else "") +
		substring(expr, i + 1, strlen(expr))
	} else if (startsWith(expr, "StackSlot::internalSet")) {
		i = strIndexOf(expr, "(");
		"StackSlot::internalSet" + substring(expr, 23, i - 23) +
		"(" + plv +
		(if (getCharAt(expr, i + 1) != ")") "," else "") +
		substring(expr, i + 1, strlen(expr))
	} else if (call) {
		"CALL_WITH_RETSLOT(" + plv + "," + expr + ")"
	} else {
		plv + " = " + expr
	}
}

cpp2WriterEmitValue(ctx : Cpp2Context, out : Cpp2OutputLocation, expr : string, tag : Cpp2TagType, io : bool, check : bool, _gc : bool) -> Maybe<Cpp2PlaceInfo> { // ?io : Bool = false, ?check : Bool = false, ?gc : Bool = false
	switch (out) {
		Cpp2OutputNone(): {
			if (io) {
				cpp2ContextWrCheckopt(ctx, expr, check, _gc);
			}
			None();
		}
		Cpp2OutputNull(): {
			cpp2_error("Cpp2OutputNull()");
			None();
		}
		Cpp2OutputReturn(): {
			cpp2ContextWrSemi(ctx, "return " + expr);
			None();
		}
		Cpp2OutputVar(place): {
			expr1 = cpp2WriterAssignExpr(cpp2PlaceInfoGetLValue(place), expr, io || check || _gc);
			if (tag != Cpp2TNull()) {
				(cpp2ContextLocalMeta(ctx, place)).tag ::= tag;
			}
			cpp2ContextWrCheckopt(ctx, expr1, check, _gc);
			Some(place)
		}
		Cpp2OutputExpr(cb): {
			expr1 = cb(ctx, expr);
			cpp2ContextWrCheckopt(ctx, expr1, check, _gc);
			None()
		}
		Cpp2OutputScalar(name, tag2): {
			if (tag != tag2) {
				cpp2ContextRegisterIdxVar(ctx, "unbox_tmp", "StackSlot");
				cpp2ContextWrCheckopt(ctx, cpp2WriterAssignExpr("unbox_tmp", expr, io || check || _gc), check, _gc);
				cpp2ContextWr(ctx, "CHECK_TAG(" + cpp2TagToString(tag2) + ",unbox_tmp,\"" + ctx.env.vname + "\");");
				cpp2ContextWrCheckopt(ctx, "unbox_tmp", false, false);
			}
			expr1 = name + " = " + "unbox_tmp" +
				switch (tag2) {
					Cpp2TBool():   ".GetBool()";
					Cpp2TInt():    ".GetInt()";
					Cpp2TDouble(): ".GetDouble()";
					default: {
						cpp2_error("impossible");
						""
					}
				};
			cpp2ContextWrCheckopt(ctx, expr1, false, false);
			None();
		}
	}
}

cpp2WriterCopyValue(ctx : Cpp2Context, out : Cpp2OutputLocation, inv: Cpp2PlaceInfo) -> Maybe<Cpp2PlaceInfo> {
	switch (out) {
		Cpp2OutputNone(): None();
		Cpp2OutputNull(): {
			cpp2_error("Cpp2OutputNull()");
			None();
		}
		Cpp2OutputReturn(): {
			cpp2ContextWrSemi(ctx, "return " + cpp2PlaceInfoGetRValue(inv, ctx));
			None();
		}
		Cpp2OutputVar(place): {
			if (!cpp2PlaceInfoIsSame(place, inv)) {
				cpp2ContextWrSemi(ctx, 
					cpp2WriterAssignExpr(cpp2PlaceInfoGetLValue(place), cpp2PlaceInfoGetRValue(inv, ctx), false)
				);
				if (inv.meta.dirty || place.meta.dirty) {
					tm = cpp2ClearMeta(cpp2ContextLocalMeta(ctx, place));
					tm.tag ::= inv.meta.tag;
					tm.struct_size ::= inv.meta.struct_size;
					tm.struct_id ::= inv.meta.struct_id;
				}
			}
			Some(place)
		}
		Cpp2OutputExpr(cb): {
			cpp2ContextWrSemi(ctx, cb(ctx, cpp2PlaceInfoGetRValue(inv, ctx)));
			None();
		}
		Cpp2OutputScalar(name, tag2): {
			cpp2WriterVerifyTag(inv, tag2, ctx);
			expr = cpp2PlaceInfoGetRawField(inv, ctx, tag2);
			if (expr == "") {
				expr1 = cpp2PlaceInfoGetRValue(inv, ctx) + 
					switch (tag2) {
						Cpp2TBool():   ".GetBool()";
						Cpp2TInt():    ".GetInt()";
						Cpp2TDouble(): ".GetDouble()";
						default: {
							cpp2_error("impossible");
							""
						}
					};
				cpp2ContextWrSemi(ctx, name + " = " + expr1);
			} else {
				cpp2ContextWrSemi(ctx, name + " = " + expr);
			}
			None();
		}
	}
}

cpp2WriterGetValueRef(writer : Cpp2Writer, code : FiExp, ctx : Cpp2Context, lvalue : bool) -> Maybe<Cpp2PlaceInfo> { //?lvalue : Bool = false
	switch (code) {
		FiVar(n, type, __): {
			ref = cpp2WriterResolveName(writer, ctx, n);
			if (lvalue && !cpp2PlaceInfoIsLValue(ref)) {
				None()
			} else {
				if (cpp2PlaceInfoIsStub(ref)) {
					cpp2WriterReifyStub(writer, ref, code);
				}
				Some(ref);
			}
		}
		default: None();
	}
}

cpp2WriterVerifyTag(ref : Cpp2PlaceInfo, tag : Cpp2TagType, ctx : Cpp2Context) -> bool {
	if (ref.meta.tag == tag) true  else {
		tstr = cpp2TagToString(tag);
		if (ref.meta.tag != Cpp2TNull()) {
			cpp2_error("Cannot verify tag " + tstr + " - already " + cpp2TagToString(ref.meta.tag));
		}
		cpp2ContextWr(ctx, 
			"CHECK_TAG(" + tstr + 
			"," + cpp2PlaceInfoGetRValue(ref, ctx) + ",\"" + ctx.env.vname + "\");"
		);
		lm = cpp2ContextLocalMeta(ctx, ref);
		lm.tag ::= tag;
		false
	}
}

cpp2WriterVerifyStruct(ref : Cpp2PlaceInfo, size : int, ctx : Cpp2Context) -> bool {
	if (ref.meta.tag == Cpp2TStruct() && ref.meta.struct_size >= size) true else {
		if (ref.meta.tag != Cpp2TNull() && ref.meta.tag != Cpp2TStruct()) {
			cpp2_error("Cannot verify struct - already " + cpp2TagToString(ref.meta.tag));
		} else {
			cpp2ContextWr(ctx, 
				"CHECK_STRUCT(" + cpp2PlaceInfoGetRValue(ref, ctx) + 
				"," + i2s(size) + ",\"" + ctx.env.vname + "\");"
			);
			lm = cpp2ContextLocalMeta(ctx, ref);
			lm.tag ::= Cpp2TStruct();
			lm.struct_size ::= size;
		}
		false
	}
}

cpp2WriterVerifyStructId(writer : Cpp2Writer, ref : Cpp2PlaceInfo, id : int, ctx : Cpp2Context) -> bool {
	if (ref.meta.tag == Cpp2TStruct() && ref.meta.struct_id == id) true else {
		if (ref.meta.tag != Cpp2TNull() && ref.meta.tag != Cpp2TStruct()) {
			cpp2_error("Cannot verify struct - already " + cpp2TagToString(ref.meta.tag));
		} else {
			cpp2ContextWr(ctx, 
				"CHECK_STRUCT_TYPE(" + cpp2PlaceInfoGetRValue(ref, ctx) 
				+ "," + i2s(id) + ",\"" + ctx.env.vname + "\");"
			);
			lm = cpp2ContextLocalMeta(ctx, ref);
			lm.tag ::= Cpp2TStruct();
			lm.struct_size ::= length(writer.struct_list[id].args);
			lm.struct_id ::= id;
		}
		false
	}
}

cpp2WriterFindFieldIndex(writer : Cpp2Writer, ref : Cpp2PlaceInfo, name : string, ctx : Cpp2Context) -> string {
	cpp2WriterVerifyStruct(ref, 1, ctx);
	ivar = "fidx_" + i2s(ref.uid) + "_" + name;
	if (!contains(ref.meta.known_fields, name)) {
		cpp2ContextRegisterIdxVar(ctx, ivar, "int");

		fidx = cpp2WriterGetFieldLookupId(writer, name);
		cpp2ContextWr(ctx, 
			"FIND_STRUCT_FIELD(" + ivar+ "," + cpp2PlaceInfoGetRValue(ref, ctx) + "," + i2s(fidx) + 
			",\"" + name + "\",\"" + ctx.env.vname + "\");");

		lm = cpp2ContextLocalMeta(ctx, ref);
		lm.known_fields ::= concat(lm.known_fields, [name]);
	}
	ivar
}

cpp2WriterGetAddrPair(ref : Cpp2PlaceInfo, tag : Cpp2TagType, ctx : Cpp2Context) -> string {
	cpp2WriterVerifyTag(ref, tag, ctx);
	lv = cpp2PlaceInfoGetRawField(ref, ctx, tag);
	if (lv != "") {
		lv + ".addr," + lv + ".size";
	} else {
		lrv = cpp2PlaceInfoGetRValue(ref, ctx);
		lrv + ".PtrValue," + lrv + ".IntValue2";
	}
}

cpp2WriterEmitLambdaCode(writer : Cpp2Writer, env : Cpp2Environment, file : string) {
	refArrayPush(writer.method_names, env.mname);
	out_lines = ref makeList();
	switch (env.closure) {
		Some(closure): {
			mask = fold(closure.type.atypes, "", \acc, t -> 
				acc + cpp2StructFieldCode(t) + ";"
			);
			switch (lookupTree(writer.closure_structs, mask)) {
				Some(cs): {
					rlistPush(out_lines, "\ntypedef flowgen_native_program::FS_" + cs.structname + " FS_" + closure.type.structname + ";");
					closure.type ::= cs;
				}
				None(): {
					writer.closure_structs ::= setTree(writer.closure_structs, mask, env.closure.type);
					cs = closure.type;
					cs.id ::= length(^(writer.structs_order));
					oinfo = Cpp2StructOrderInfo(
						cs.id, // compare_idx
						cs.structname, // name
						cs.args // args
					);
					refArrayPush(writer.structs_order, oinfo);
					cpp2GenerateStructCode(writer, oinfo, cs);
				}
			}
		}
		None(): { }
	}
	rlistPush(out_lines, "\nStackSlot flowgen_" + writer.config.entry + "::" + env.mname + "(RUNNER_ARGS) {");
	if (env.nlocals > 0 || env.ntemps > 0) {
		rlistPush(out_lines, "    RUNNER_DefSlotArray(locals, " + i2s(env.nlocals) + "+" + i2s(env.ntemps) + ");");
		if (env.ntemps > 0) {
			rlistPush(out_lines, "    StackSlot *const temps = locals + " + i2s(env.nlocals) + ";");
		}
	}
	if (env.tail_call) {
		rlistPush(out_lines, "tail_call:");
	}
	rlistPush(out_lines, cpp2CodeLinesToCode(env.code_lines));
	rlistPush(out_lines, "}");
	cpp2writeLines(^out_lines, file);
}


cpp2WriterResolveLocalName(env : Cpp2Environment, name : string) -> Maybe<Cpp2PlaceInfo> {
	switch (lookupTree(env.locals, name)) {
		Some(binding): Some(binding);
		None(): {
			switch (env.parent) {
				Some(parent): {
					switch (cpp2WriterResolveLocalName(parent, name)) {
						Some(free): Some(cpp2EnvironmentMkupvalue(env, name, free));
						None(): None();
					}
				}
				None(): None();
			}
		}
	}
}

cpp2WriterResolveName(writer : Cpp2Writer, ctx : Cpp2Context, name : string) -> Cpp2PlaceInfo {
	switch (cpp2WriterResolveLocalName(ctx.env, name)) {
		Some(local): local;
		None(): {
			switch (lookupTree(writer.global_map, name)) {
				Some(global): global;
				None(): {
					cpp2_error("Unknown variable: "+name);
					dummyCpp2PlaceInfo;
				}
			}
		}
	}
}

cpp2WriterReifyStub(writer : Cpp2Writer, ref : Cpp2PlaceInfo, code : FiExp) -> void {
	switch (ref.place) {
		Cpp2GlobalFunction(nargs, native): {
			ref.slot ::= length(^(writer.function_table));
			refArrayPush(writer.function_table,
				Cpp2FunctionDescr(ref.name, "", nargs, cpp2FnMethodName(ref.name))
			);
		}
		Cpp2Struct(info): {
			cpp2_error("Cannot use struct here: " + prettyFiExp(dummyPretty, code));
		}
		default: {
			cpp2_error("Cannot reify stub: " + prettyFiExp(dummyPretty, code));
		}
	}
}

cpp2WriterWriteFlowTypeCode(writer : Cpp2Writer, t : FiTypeNullable) -> void {
	switch (t) {
		FiTypeVoid():   refArrayPush(writer.struct_code.field_types, cpp2_CVoid);
		FiTypeBool():   refArrayPush(writer.struct_code.field_types, cpp2_CBool);
		FiTypeInt():    refArrayPush(writer.struct_code.field_types, cpp2_CInt);
		FiTypeDouble(): refArrayPush(writer.struct_code.field_types, cpp2_CDouble);
		FiTypeString(): refArrayPush(writer.struct_code.field_types, cpp2_CString);
		FiTypeArray(type): {
			if (writer.config.extStructDefs) {
					refArrayPush(writer.struct_code.field_types, cpp2_CTypedArray); 
					cpp2WriterWriteFlowTypeCode(writer, type);
			} else {
				refArrayPush(writer.struct_code.field_types, cpp2_CArray);
			}
		}
		/*TStruct(name, args, max): {
			struct_field_types.push( Bytecode.CTypedStruct );
			struct_field_types.push( structs.get(name).id );
		}*/
		FiTypeName(name, args): {
			refArrayPush(writer.struct_code.field_types, cpp2_CStruct);
		}
		FiTypeRef(type): {
			if (writer.config.extStructDefs) {
				refArrayPush(writer.struct_code.field_types, cpp2_CTypedRefTo);
				cpp2WriterWriteFlowTypeCode(writer, type);
			} else {
				refArrayPush(writer.struct_code.field_types, cpp2_CRefTo);
			}
		}
		FiTypeNull(): {
			cpp2_error("type must not be null");
		}
		default: {
			refArrayPush(writer.struct_code.field_types, cpp2_CFlow); // Flow
		}
	}
}

cpp2WriterGetFieldLookupId(writer : Cpp2Writer, n : string) -> int {
	switch (lookupTree(writer.field_index_map, n)) {
		Some(fidx): fidx;
		None(): {
			if (length(writer.struct_counts) <= 1) {
				cpp2_error("Cannot access field " + n + " - no structs have fields!")
			}
			table = ref [];
			fori(0, writer.struct_counts[1] - 1, 
				\i -> {
					args = ^(writer.structs_order)[i].args;
					found = foldi(args, -1, \j, ac, arg -> 
						if (ac != -1 && arg.name == n) j else ac
					);
					refArrayPush(table, found)
				}
			);
			fidx = length(^(writer.field_index_table));
			refArrayPush(writer.field_index_table, ^table);
			refArrayPush(writer.field_index_list, n);
			writer.field_index_map ::= setTree(writer.field_index_map, n, fidx);
			fidx
		}
	}
}

cpp2WriterFieldIndex(writer : Cpp2Writer, type : FiTypeNullable, field_name : string) -> int {
	err = \-> {
		cpp2_error("Can not find the field " + field_name + " in type " + prettyFiTypeNullable(type));
		0
	};
	switch (type) {
		FiTypeName(type_name, __): {
			switch (lookupTree(writer.program.names.structs, type_name)) {
				Some(struct): {
					switch (findi(struct.args, \arg -> arg.name == field_name)) {
						Some(ind): ind;
						None(): err();
					}
				}
				None(): err();
			}
		}
		default: err();
	}
}

cpp2WriterStructTypeId(writer : Cpp2Writer, type : FiTypeNullable) -> int {
	err = \-> {
		cpp2_error("Not a struct: " + prettyFiTypeNullable(type));
		0
	};
	switch (type) {
		FiTypeName(name, __): {
			switch (lookupTree(writer.structs, name)) {
				Some(s): s.id;
				None(): err();
			}
		}
		default: err();
	}
}

cpp2WriterStructTypeSize(writer : Cpp2Writer, type : FiTypeNullable) -> int {
	err = \-> {
		cpp2_error("Not a struct: " + prettyFiTypeNullable(type));
		0
	};
	switch (type) {
		FiTypeName(type_name, __): {
			switch (lookupTree(writer.program.names.structs, type_name)) {
				Some(struct): length(struct.args);
				None(): err();
			}
		}
		default: err();
	}
}

cpp2WriterMktop(top : Cpp2StackTop) -> Cpp2StackTop {
	Cpp2StackTop(top.temp)
}

cpp2WriterGetOutputPlace(out : Cpp2OutputLocation, top : Cpp2StackTop) -> Maybe<Cpp2PlaceInfo> { // ?top : Cpp2StackTop = null
	/*if (out == null)
		return null;

	return switch (out) {
		Cpp2OutputVar(place):
			if (top != null && place.place == Temporary && place.slot >= top.temp)
				top.temp = place.slot+1;
			place;
		default:
			null;
	}*/

	switch (out) {
		Cpp2OutputVar(place): {
			if (place.place == Cpp2Temporary() && place.slot >= top.temp) {
				top.temp ::= place.slot + 1;
			}
			Some(place)
		}
		default: None();
	}
}

cpp2WriterGetOutputOrTemp(ctx : Cpp2Context, out : Cpp2OutputLocation, top : Cpp2StackTop) -> Cpp2PlaceInfo {
	/*var tmp = getOutputPlace(out, top);
	if (tmp == null) {
		tmp = ctx.env.mktemp(top.temp++);
	}
	return tmp;*/
	switch (cpp2WriterGetOutputPlace(out, top)) {
		Some(tmp): tmp;
		None(): {
			tmp = cpp2EnvironmentMktemp(ctx.env, top.temp);
			top.temp ::= top.temp + 1;
			tmp
		}
	}
}

cpp2WriterEvalToTmp(writer : Cpp2Writer, arg : FiExp, ctx : Cpp2Context, top : Cpp2StackTop, out : Cpp2OutputLocation) -> Cpp2PlaceInfo { // out : Null<Cpp2OutputLocation> = null
	atmp = cpp2WriterMktop(top);
	tmp = cpp2WriterGetOutputOrTemp(ctx, out, top);
	cpp2WriterCompileExpression(writer, arg, ctx, Cpp2OutputVar(tmp), atmp);
	tmp
}

cpp2WriterFetchToRef(writer : Cpp2Writer, arg : FiExp, ctx : Cpp2Context, top : Cpp2StackTop, lvalue : bool, out : Cpp2OutputLocation) -> Cpp2PlaceInfo { // ?out : Null<CppOutputLocation> = null	
	switch (cpp2WriterGetValueRef(arg, ctx, lvalue)) {
		Some(ref): ref;
		None(): cpp2WriterEvalToTmp(writer, arg, ctx, top, out);
	}
}

cpp2WriterFetchToScalar(arg : FiExp, ctx : Cpp2Context, top : Cpp2StackTop, tag : Cpp2TagType) -> string {
	tmp = cpp2ContextTempvar(ctx, "xtmp", tag, "");
	cpp2WriterCompileExpression(arg, ctx, Cpp2OutputScalar(tmp, tag), cpp2Mktop(top));
	tmp
}

Cpp2FieldInfo(
	index : int, 
	minsize : int, 
	stype : int
);

cpp2WriterFieldSetInfo(writer : Cpp2Writer, call : FiExp, ref : Cpp2PlaceInfo, name : string) -> Cpp2FieldInfo {
	if (ref.meta.struct_id != cpp2_int_UNDEF) {
		info = ^(writer.structs_order)[ref.meta.struct_id];
		index = switch (findi(info.args, \arg -> arg.name == name)) {
			Some(i): i; 
			None(): {
				cpp2_error("No field " + name + " in struct " + info.name);
				cpp2_int_UNDEF
			}
		}
		Cpp2FieldInfo(index, length(info.args), ref.meta.struct_id)
	} else {
		field_type = fiExpType(call);
		switch (field_type ) {
			FiTypeName(type_name, __): {
				switch (lookupTree(writer.program.names.structs, type_name)) {
					Some(struct): {
						minsize = length(struct.args);
						index = cpp2WriterFieldIndex(writer, field_type , name);
						stype = lookupTreeDef(writer.structs, struct.name, dummyCpp2StructInfo).id;
						Cpp2FieldInfo(index, minsize, stype)
					}
					None(): {
						switch (lookupTree(writer.program.names.unions, type_name)) {
							Some(uinon): {
								fold(uinon.typenames, Cpp2FieldInfo(cpp2_int_UNDEF, cpp2_int_UNDEF, cpp2_int_UNDEF),
									\acc, tn -> {
										new_index = cpp2WriterFieldIndex(writer, tn, name); 
										if (acc.index != cpp2_int_UNDEF && new_index != acc.index) {
											cpp2_error("field has different indexes in union");
										}
										new_minsize = cpp2WriterStructTypeSize(writer, tn);
										new_stype = if (acc.stype == cpp2_int_UNDEF) cpp2WriterStructTypeId(writer, tn) else acc.stype;
										Cpp2FieldInfo(
											new_index, 
											if (acc.minsize < new_minsize) new_minsize else acc.minsize, 
											new_stype
										)
									}
								)
							}
							None(): {
								cpp2_error("must be a struct or union");
								Cpp2FieldInfo(cpp2_int_UNDEF, cpp2_int_UNDEF, cpp2_int_UNDEF)
							}
						}
					}
				}
				/*TStruct(structname, cargs, max): {
					minsize = cargs.length;
					index = cpp2WriterFieldIndex(writer, fields, name);
					stype = structs.get(structname).id;
				}
				TUnion(min, max):
				if (max != null) {
					// If all in the union have the same int index, we are fine
					// even if it is polymorphic
					var first = true;
					for (m in max) {
						stype = first ? structTypeId(m) : null;
						var sz = structTypeSize(m);
						if (minsize == null || minsize > sz)
							minsize = sz;
						var i2 = fieldIndex(m, name);
						if (index == null || i2 == index) {
							index = i2;
						} else {
							index = minsize = stype = null;
							break;
						}
						first = false;
					}
				}*/
			}
			default: {
				cpp2_error("must be a struct or union");
				Cpp2FieldInfo(cpp2_int_UNDEF, cpp2_int_UNDEF, cpp2_int_UNDEF)
			}
		}
	}
}

cpp2WriterCompileConstructor(writer : Cpp2Writer, args : [FiExp], ctx : Cpp2Context, out : Cpp2OutputLocation, top : Cpp2StackTop, tag : Cpp2TagType, expr_cb : (int, string) -> string, zero_allocs : bool) -> Cpp2PlaceInfo { // ?zero_allocs : Bool = false
	csize = length(args);
	if (csize == 0) {
		cpp2WriterEmitValue(ctx, out, expr_cb(0, "NULL"), tag, false, zero_allocs, zero_allocs);
	} else {
		refs = ^fold(args, ref [], \acc, arg -> 
			refArrayPush(acc, cpp2WriterGetValueRef(writer, arg, ctx, false))
		);
		fast = foldi(refs, true, \i, acc, mref -> {
				if (!acc) acc else {
					switch (mref) {
						Some(ref): {
							if (cpp2PlaceInfoIsLValue(ref)) {
								if (i == 0) true else {
									switch (refs[i - 1]) {
										Some(ref1): {
											ref.place == ref1.place && ref.slot == ref.slot + 1
										}
										None(): false;
									}
								}
							} else {
								false
							}
						}
						None(): false;
					}
				}
			}
		);
		place = if (fast) {
			cpp2PlaceInfoGetLValue(refs[0])
		} else if (csize <= 20) {
			start = top.temp;
			fori(0, csize - 1,
				\i -> {
					atop = cpp2Mktop(top);
					top_temp = top.temp;
					top.temp ::= top_temp + 1;
					tmp = cpp2EnvironmentMktemp(ctx.env, top_temp);
					cpp2WriterCompileExpression(writer, args[i], ctx, Cpp2OutputVar(tmp), atop);
				}
			);
			"temps[" + start + "]";
		} else {
			// If a constructor is too long, instead of declaring lots of
			// temporaries, allocate an empty array and fill it destructively.
			top_temp = top.temp;
			top.temp ::= top_temp + 1;
			tmp = cpp2EnvironmentMktemp(ctx.env, top_temp);
			tstr = cpp2PlaceInfoGetLValue(tmp);
			cpp2ContextWrCheck(ctx, tstr + " = " + expr_cb(csize, "NULL"), true);
			(tmp.meta).tag ::= tag;
			fori(0, csize - 1, 
				\i -> {
					cpp2WriterCompileExpression(
						writer,
						args[i], ctx, 
						Cpp2OutputExpr(\ictx, aexpr ->
							"RUNNER->SetArraySlot(" + tstr + "," + i + "," + aexpr + ")"
						), 
						cpp2Mktop(top)
					);
				}
			);
			cpp2WriterCopyValue(ctx, out, tmp);
		};
		cpp2WriterEmitValue(ctx, out, expr_cb(csize, "&" + place), tag, false, true, true)
	}
}

cpp2WriterCompileNewStruct(writer : Cpp2Writer, info : Cpp2StructInfo, args : [FiExp], ctx : Cpp2Context, out : Cpp2OutputLocation, top : Cpp2StackTop, closure : string) { // closure : string = null
	if (length(info.args) != length(args)) {
		cpp2_error("Invalid struct field count");
	} else {
		if (length(args) == 0) {
			space_info = lookupTreeDef(writer.global_map, info.structname, dummyCpp2PlaceInfo);
			cpp2WriterCopyValue(ctx, out, space_info);
		} else {
			otmp = cpp2WriterGetOutputOrTemp(ctx, out, top);
			sout = cpp2PlaceInfoGetLValue(otmp);

			refs = ref [];
			vals = ref [];
			fori(0, length(args.length) - 1, 
				\i -> {
					tt = info.atypes[i];
					if (tt == Cpp2TDouble() || tt == Cpp2TInt()) {
						refArrayPush(refs, None());
						refArrayPush(vals, Some(emitNumericExpr(args[i], ctx, top, tt)));
					} else if (tt == TBool) {
						refArrayPush(refs, None());
						refArrayPush(vals, Some(emitConditionExpr(args[i], ctx, top)));
					} else {
						ref = cpp2WriterFetchToRef(writer, args[i], ctx, top, false);
						refArrayPush(refs, Some(ref));
						refArrayPush(vals, None());
						if (info.atypes[i] != Cpp2TNull()) {
							cppWriterVerifyTag(ref, info.atypes[i], ctx);
						}
					}
				}
			)
			ptr = cpp2ContextGetStructPtr(ctx, otmp, info.structname, false);

			if (closure != "") {
				cpp2ContextWrCheck(ctx, ptr + " = RUNNER->AllocateRawClosure<FS_" + info.structname + ">(&" + sout + "," + info.id + "," + closure + ".slot_private.IntValue)", true);
				lm = cpp2ContextLocalMeta(ctx, otmp);
				lm.tag ::= Cpp2TNativeFn();
			} else {
				cpp2ContextWrCheck(ctx, ptr + " = RUNNER->AllocateRawStruct<FS_" + info.structname + ">(&" + sout + "," + info.id + ")", true);

				lm = cpp2ContextLocalMeta(ctx, otmp);
				lm.tag ::= Cpp2TStruct();
				lm.struct_id ::= info.id;
				lm.struct_size ::= length(args);
			}

			fori(0, length(args.length) - 1, 
				\i -> {
					fname = ptr + "->fl_" + info.args[i].name;
					switch (vals[i]) {
						Some(val): 
							cpp2ContextWrSemi(fname, " = ", val);
						None(): {
							if (info.atypes[i] == Cpp2TStruct()) {
								cpp2ContextWrSemi(fname, " = ", cpp2PlaceInfoGetStructAddr(refs[i], ctx));
							} else {
								switch (refs[i].place) {
									Cpp2FieldAlias(where, sinfo): {
										if (sinfo.atypes[refs[i].slot] == info.atypes[i]) {
											cpp2ContextWrSemi(ctx, fname + " = " + cpp2ContextGetStructPtr(ctx, where, sinfo.structname) + "->fl_" + sinfo.args[refs[i].slot].name);
										} else {
											cpp2ContextWrSemi(ctx, "flow_struct::set_" + cpp2StructFieldCode(info.atypes[i]) + "(" + fname + "," + cpp2PlaceInfoGetRValue(refs[i], ctx) + ")");
										}
									}
									default: { 
										cpp2ContextWrSemi(ctx, "flow_struct::set_" + cpp2StructFieldCode(info.atypes[i]) + "(" + fname + "," + cpp2PlaceInfoGetRValue(refs[i], ctx) + ")");
									}
								}
							}
						}
					}
				}
			);
			cpp2WriterCopyValue(ctx, out, otmp);
		}
	}
}

cpp2WriterCallNativeName(writer : Cpp2Writer, fn : FiExp, ctx : Cpp2Context) -> string {
	switch (fn) {
		FiVar(n, type, pos): {
			ref = cpp2WriterResolveName(writer, ctx, n);
			switch (ref.place) {
				Cpp2GlobalFunction(nargs, native): native;
				default: "";
			}
		}
		default: "";
	}
}
