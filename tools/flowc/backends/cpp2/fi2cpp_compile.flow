import text/utf8;
import tools/flowc/incremental/fi_helpers;
import tools/flowc/backends/cpp2/fi2cpp2_util;
import tools/flowc/flowc_field_type;

export {
	cpp2Writer(config : FcCpp2Config, program : FiProgram, amain : FiFunctionDec) -> Cpp2Writer;
	cpp2WriterEmitCommonAndTables(writer : Cpp2Writer) -> void;
	cpp2WriterTranslateGlobalFunctions(writer : Cpp2Writer) -> void;
	cpp2WriterTranslateGlobalVariables(writer : Cpp2Writer) -> void;
}

// CppWriter methods

cpp2Writer(config : FcCpp2Config, program : FiProgram, amain : FiFunctionDec) -> Cpp2Writer {
	known_natives = fold(cpp2_natives, makeTree(), 
		\acc, nat -> setTree(acc, "Native." + nat.name, nat)
	);
	dependencies = getAllDependencies(
		program.names.toplevel, 
		amain.lambda, 
		emptyCpp2Dependencies
	);
	// We do this in alphabetical order in order to avoid random changes in the
	// code just because of hash ordering differences; however, it is combined
	// with descending order by argument count to allow size checks just by
	// looking at the id range.
	fi_structs = mergeSort(
		getTreeValues(program.names.structs),
		\s1, s2 -> {
			if (s1.name < s2.name) -1
			else if (s1.name == s2.name) 0 else 1;
		}
	);
	structs_inds = foldi(fi_structs, makeTree(),
		\i, acc, s -> setTree(acc, s.name, i)
	);
	structs_order = map(
		mergeSort(
			fi_structs,
			\s1, s2 -> {
				if (length(s1.args) < length(s2.args)) 1
				else if (length(s1.args) > length(s2.args)) -1
				else if (s1.name < s2.name) -1
				else if (s1.name == s2.name) 0 else 1;
			}
		),
		\s -> Cpp2StructOrderInfo(
			lookupTreeDef(structs_inds, s.name, -1), 
			s.name, 
			map(s.args, \a -> Cpp2StructArg(a.name, a.type, a.ismutable))
		)
	);
	int2bc = \i -> {
		fromCharCode(bitAnd(i, 0xFF))+
		fromCharCode(bitAnd(bitUshr(i, 8), 0xFF))+
		fromCharCode(bitAnd(bitUshr(i, 16), 0xFF))+
		fromCharCode(bitAnd(bitUshr(i, 24), 0xFF));
	}
	bytecode = ref "\x39\x39"; // CLast CLast
	struct_list_map = foldi(structs_order, Triple([], makeTree(), makeTree()),
		\n, acc, s -> {
			si = Cpp2StructInfo(
				n,       // id
				s.name,  // struct_name
				map(s.args, \a -> Cpp2StructArg(a.name, a.type, a.is_mutable)), //args
				map(s.args, \a -> cpp2GetStructAType(a.type)), // atypes
				if (length(s.args) == 0) {
					eaddr = strlen(^bytecode);
					bytecode := ^bytecode + int2bc(n);
					eaddr
				} else {
					cpp2_int_UNDEF
				} // empty_addr
			);
			pi = cpp2PlaceInfo(None(), Cpp2Struct(si), n, s.name);
			if (length(s.args) == 0) {
				(pi.meta).dirty ::= true;
				(pi.meta).tag ::= Cpp2TStruct();
				(pi.meta).struct_id ::= n;
			}
			Triple(
				concat(acc.first, [si]),
				setTree(acc.second, s.name, si),
				setTree(acc.third, s.name, pi)
			)
		}
	);
	struct_list = struct_list_map.first;
	structs = struct_list_map.second;
	max_size = fold(struct_list, -1, \acc, s -> 
		if (length(s.args) > acc) length(s.args) else acc
	);
	struct_counts_map = foldi(structs_order, Pair(makeTree(), max_size),
		\n, acc, s -> {
			updated = fold(enumFromTo(length(s.args), acc.second), acc.first, 
				\a, i -> setTree(a, i, n)
			);
			Pair(setTree(updated, length(s.args), n + 1), length(s.args))
		}
	).first;
	struct_counts = map(enumFromTo(0, max_size), \i -> 
		lookupTreeDef(struct_counts_map, i, -1) 
	);
	toplevel_triple = cpp2WriterEnumerateToplevel(program, dependencies);
	function_table = toplevel_triple.first;
	global_vars = toplevel_triple.second;
	global_map = mergeTree(struct_list_map.third, toplevel_triple.third);
	writer = Cpp2Writer(
		config,
		program,
		amain,
		
		length(struct_list),    // num_structs : int,
		0,                      // init_count : int,
		struct_counts,          // struct_counts : [int], // by size
		structs,                // structs : Tree<string, Cpp2StructInfo>,
		makeTree(),             // closure_structs : Tree<string, Cpp2StructInfo>,
		ref structs_order,          // structsOrder : [Cpp2StructOrderInfo],
		struct_list_map.first,  // struct_list : [Cpp2StructInfo],
		Cpp2StructCode(ref [], ref [], ref [], ref [], ref [], ref []),  // struct_code
		^bytecode,
		makeTree(),     // const_strings : Tree<string, Cpp2ConstString>,
		ref [],         // method_names : [string],
		ref function_table, // function_table : [Cpp2FunctionDescr],
		global_vars,    // global_vars : [string],
		global_map,     // global_map : Tree<string, Cpp2PlaceInfo>,

		//* Table for fast lookup of fields by name; maps [name][structid] -> index
		ref [], // field_index_table : [[int]],
		makeTree(), // field_index_map : Tree<string, int>,
		ref [], // field_index_list : [string],
		
		"", // cur_global : string,
		1, // next_closure_id : int,
		known_natives, // known_natives : Tree<string, Cpp2NativeDescr>,
		makeTree(),
		foldSet(dependencies.all_decls, makeSet1("main"), \acc, d -> insertSet(acc, d.name))
	);
	iter(structs_order,
		\s -> cpp2GenerateStructCode(writer, s, lookupTreeDef(structs, s.name, dummyCpp2StructInfo))
	);
	writer
}

cpp2WriterTranslateGlobalFunctions(writer : Cpp2Writer) -> void {
	prog = writer.program;
	iter(prog.traversal, 
		\mod_name -> {
			module = lookupTreeDef(prog.modules, mod_name, dummyFiModule);
			if (writer.config.verbose > 0) {
				fcPrintln("translating module: " + module.fileinfo.flowfile, writer.config.threadId);
			}
			iter(module.initOrder, 
				\glob_name -> {
					if (containsSet(writer.dependencies, glob_name)) {
						switch (lookupTree(prog.names.toplevel, glob_name)) {
							Some(decl): {
								switch (decl) {
									FiFunctionDec(name, lambda, type, __,__): {
										cpp2WriterCompileGlobalFn(writer, name, lambda);
									}
									FiNativeDec(name, io, type, nat_name, fallback, __,__): {
										switch (fallback) {
											FiVoid(__): { } // No fallback
											FiLambda(__,__,__,__): cpp2WriterCompileGlobalFn(writer, name, fallback);
											default: cpp2_error("impossible");
										}
									}
									FiGlobalVar(name, value, type, __,__): {
										// do nothing
									}
								}
							}
							None(): cpp2_error("impossible");
						}
					}
				}
			)
		}
	)
}

cpp2WriterTranslateGlobalVariables(writer : Cpp2Writer) -> void {
	endInitFunction = \global_env : Cpp2Environment -> {
		switch (global_env.cur_ctx) {
			Some(ctx): {
				cpp2ContextWrSemi(ctx, "RETVOID");
				cpp2ContextExit(ctx);
			}
			None(): cpp2_error("context must not be None");
		}
		cpp2WriterEmitLambdaCode(writer, global_env, cpp2MakePath("gen_init.cpp", writer.config));
	}
	prog = writer.program;
	last = fold(prog.traversal, cpp2Environment(writer, None(), "aux_init0", "$init", 0, writer.struct_list),
		\acc, mod_name -> {
			module = lookupTreeDef(prog.modules, mod_name, dummyFiModule);
			fold(module.initOrder, acc,
				\ac, glob_name -> {
					if (!containsSet(writer.dependencies, glob_name)) ac else {
						switch (lookupTree(prog.names.toplevel, glob_name)) {
							Some(decl): {
								switch (decl) {
									FiGlobalVar(name, value, type, __,__): {
										new_ac = if (writer.init_count == 0 || length(^(ac.code_lines.lines)) >=1024) {
											if (writer.init_count > 0) {
												endInitFunction(ac);
											}
											new_env = cpp2Environment(writer, None(), "aux_init" + i2s(writer.init_count), "$init", 0, writer.struct_list);
											writer.init_count ::= writer.init_count + 1;
											new_env
										} else {
											ac
										}
										place = lookupTreeDef(writer.global_map, name, dummyCpp2PlaceInfo);
										new_ac.vname ::= name + "$init";
										writer.cur_global ::= name;
										switch (new_ac.cur_ctx) {
											Some(ctx): cpp2WriterCompileExpression(writer, value, ctx, Cpp2OutputVar(place), Cpp2StackTop(0));
											None(): cpp2_error("context must not be None");
										}
										new_ac
									}
									default: ac; // do nothing
								}
							}
							None(): {
								cpp2_error("impossible"); 
								ac;
							}
						}
					}
				}
			)
		}
	);
	endInitFunction(last)
}

cpp2GenerateStructCode(writer : Cpp2Writer, s : Cpp2StructOrderInfo, info : Cpp2StructInfo) -> void {
	code = writer.struct_code;
	name = cpp2WriterRegisterConstString(writer, s.name);
	if (length(s.args) == 0) {
		refinfo = Cpp2StructInfoRef(
			cpp2_int_UNDEF,  // fld_idx
			cpp2_int_UNDEF,  // type_idx
			cpp2_int_UNDEF,  // def_idx
			cpp2_int_UNDEF,  // gcdef_idx
			0,               // gcdef_cnt 
			info.empty_addr, // empty_addr
			name.addr,       // name_addr
			name.size,       // name_sz
		);
		refArrayPush(code.info_refs, refinfo);
	} else {
		refinfo = Cpp2StructInfoRef(
			length(^(code.field_names)), // fld_idx 
			length(^(code.field_types)), // type_idx
			length(^(code.def_lines)),   // def_idx
			length(^(code.gcdef_lines)), // gcdef_idx
			0, // gcdef_cnt 
			0, // empty_addr
			name.addr, //name_addr
			name.size, // name_sz
		);

		refArrayPush(code.info_refs, refinfo);
		refArrayPush(code.hdr_lines, "struct FS_" + s.name + " {");
		refArrayPush(code.hdr_lines, "    FlowStructHeader hdr;");

		fori(0, length(s.args) - 1, \i -> {
			arg = s.args[i];
			refArrayPush(code.field_names, arg.name);
			if (arg.is_mutable) {
				refArrayPush(code.field_types, cpp2_CSetMutable);
			}
			writeFiExpTypeCode(arg.type, code, writer.config.extStructDefs);
			refArrayPush(code.field_types, -1);
			fname =  "fl_" + arg.name;
			off = "(int)offsetof(FS_" + s.name + "," + fname + ")";
			if (i < length(info.atypes)) {
				switch (info.atypes[i]) {
					Cpp2TBool(): {
						refArrayPush(code.def_lines, "FLOW_FIELD_DEF(bool," + off + ")");
						refArrayPush(code.hdr_lines, "    char " + fname + ";");
					}
					Cpp2TInt(): {
						refArrayPush(code.def_lines, "FLOW_FIELD_DEF(int," + off + ")");
						refArrayPush(code.hdr_lines, "    int " + fname + ";");
					}
					Cpp2TDouble(): {
						refArrayPush(code.def_lines, "FLOW_FIELD_DEF(double," + off + ")");
						refArrayPush(code.hdr_lines, "    double " + fname + ";");
					}
					Cpp2TString(): {
						refArrayPush(code.def_lines, "FLOW_FIELD_DEF(string," + off + ")");
						refArrayPush(code.gcdef_lines, "FLOW_FIELD_GC_DEF(string," + off + ")");
						refArrayPush(code.hdr_lines, "    FlowStructString " + fname + ";");
					}
					Cpp2TArray(): {
						refArrayPush(code.def_lines, "FLOW_FIELD_DEF(array," + off + ")");
						refArrayPush(code.gcdef_lines, "FLOW_FIELD_GC_DEF(array," + off + ")");
						refArrayPush(code.hdr_lines, "    FlowStructArray " + fname + ";");
					}
					Cpp2TRefTo(): {
						refArrayPush(code.def_lines, "FLOW_FIELD_DEF(ref," + off + ")");
						refArrayPush(code.gcdef_lines, "FLOW_FIELD_GC_DEF(ref," + off + ")");
						refArrayPush(code.hdr_lines, "    FlowStructRef " + fname + ";");
					}
					Cpp2TStruct(): {
						refArrayPush(code.def_lines, "FLOW_FIELD_DEF(struct," + off + ")");
						refArrayPush(code.gcdef_lines, "FLOW_FIELD_GC_DEF(struct," + off + ")");
						refArrayPush(code.hdr_lines, "    FlowPtr " + fname + ";");
					}
					Cpp2TNull(): {
						refArrayPush(code.def_lines, "FLOW_FIELD_DEF(slot," + off + ")");
						refArrayPush(code.gcdef_lines, "FLOW_FIELD_GC_DEF(slot," + off + ")");
						refArrayPush(code.hdr_lines, "    StackSlot " + fname + ";");
					}
					default: {
						cpp2_error("impossible");
					}
				}
			} else {
				cpp2_error("info.atypes index " + i2s(i) + "exceeded length: " + i2s(length(info.atypes)))
			}
		});
		refArrayPush(code.hdr_lines, "};");
		refinfo.gcdef_cnt ::= length(^(code.gcdef_lines)) - refinfo.gcdef_idx;
	}
}
	
writeFiExpTypeCode(type : FiTypeNullable, code : Cpp2StructCode, extStructDefs : bool) -> void {
	switch (type) {
		FiTypeVoid():   refArrayPush(code.field_types, cpp2_CVoid);
		FiTypeBool():   refArrayPush(code.field_types, cpp2_CBool);
		FiTypeInt():    refArrayPush(code.field_types, cpp2_CInt);
		FiTypeDouble(): refArrayPush(code.field_types, cpp2_CDouble);
		FiTypeString(): refArrayPush(code.field_types, cpp2_CString);
		FiTypeArray(t): {
			if (extStructDefs) {
				refArrayPush(code.field_types, cpp2_CTypedArray); 
				writeFiExpTypeCode(t, code, extStructDefs);
			} else {
				refArrayPush(code.field_types, cpp2_CArray);
			}
		}
		FiTypeName(name, args):
			refArrayPush(code.field_types, cpp2_CStruct);
		FiTypeRef(t): {
			if (extStructDefs) {
				refArrayPush(code.field_types, cpp2_CTypedRefTo);
				writeFiExpTypeCode(t, code, extStructDefs);
			} else {
				refArrayPush(code.field_types, cpp2_CRefTo);
			}
		}
		FiTypeNull(): cpp2_error("null type");
		default: refArrayPush(code.field_types, cpp2_CFlow); // FiExp
	}
}

// Gather all decls from module.initOrder
cpp2gatherInitOrder(prog : FiProgram) -> [FiDeclaration] {
	decls = ref [];
	iter(prog.traversal,
		\mod_name -> {
			module = lookupTreeDef(prog.modules, mod_name, dummyFiModule);
			iter(module.initOrder,
				\name -> {
					switch (lookupTree(prog.names.toplevel, name)) {
						Some(decl): refArrayPush(decls, decl);
						None(): { }
					}
				}
			)
		}
	);
	^decls
}

// Index natives and globals
cpp2WriterEnumerateToplevel(program : FiProgram, deps : Cpp2Dependencies) -> Triple<[Cpp2FunctionDescr], [string], Tree<string, Cpp2PlaceInfo>> {
	all_decls = set2array(deps.all_decls);
	triple : Triple<ref [Cpp2FunctionDescr], ref [string], Tree<string, Cpp2PlaceInfo>> = 
	fold(all_decls, Triple(ref [], ref [], makeTree()),
		\acc : Triple<ref [Cpp2FunctionDescr], ref [string], Tree<string, Cpp2PlaceInfo>>, decl : FiDeclaration -> {
			switch (decl) {
				FiFunctionDec(name, lambda, __, __,__): {
					info = cpp2PlaceInfo(None(), Cpp2GlobalFunction(length(lambda.args), ""), -1, name);
					Triple(acc.first, acc.second, setTree(acc.third, name, info))
				}
				FiGlobalVar(name, value, type, __,__): {
					// assign id to global var
					info = cpp2PlaceInfo(None(), Cpp2GlobalVar(), length(^(acc.second)), name);
					refArrayPush(acc.second, name);
					Triple(acc.first, acc.second, setTree(acc.third, name, info))
				}
				FiNativeDec(name, io, type, n_name, fbLambda, __,__): {
					nargs = switch (type) {
						FiTypeFunction(tp_args, tp_ret): length(tp_args);
						default: {
							cpp2_error("must be a FiTypeFunction");
							-1
						}
					};
					// natives have mandatory external linkage
					info = cpp2PlaceInfo(None(), Cpp2GlobalFunction(nargs, n_name), length(^(acc.first)), name);
					refArrayPush(acc.first, 
						Cpp2FunctionDescr(
							name, // name
							n_name, // native_name
							nargs, // nargs
							switch (fbLambda) {
								FiVoid(__): "";
								FiLambda(args, body, __,__): 
									cpp2FnMethodName(name);
								default: {
									cpp2_error("must be a FiVoid or FiLambda");
									"";
								}
							}
						)
					);
					Triple(acc.first, acc.second, setTree(acc.third, name, info))
				}
			}
		}
	);
	Triple(^(triple.first), ^(triple.second), triple.third)
}

getAllDependencies(toplevel : Tree<string, FiDeclaration>, expr : FiExp, acc : Cpp2Dependencies) -> Cpp2Dependencies {
	switch (expr) {
		FiConst(): acc;
		FiSeq(es, __, __): 
			fold(es, acc, \a, e -> getAllDependencies(toplevel, e, a));
		FiCast(e, __, __, __, __):
			getAllDependencies(toplevel, e, acc);
		FiCall(f, args, __, __):
			fold(args, getAllDependencies(toplevel, f, acc), \a, arg -> getAllDependencies(toplevel, arg, a));
		FiSwitch(x, __, cases, __, __):
			fold(cases, getAllDependencies(toplevel, x, acc), \a, c -> getAllDependencies(toplevel, c.body, a));
		FiLambda(__, body, __, __):
			getAllDependencies(toplevel, body, acc);
		FiLet(__, __, e1, e2, __, __):
			getAllDependencies(toplevel, e1, getAllDependencies(toplevel, e2, acc));
		FiIf(e1, e2, e3, __, __):
			getAllDependencies(toplevel, e1, getAllDependencies(toplevel, e2, getAllDependencies(toplevel, e3, acc)));
		FiCallPrim(__, es, __, __): 
			fold(es, acc, \a, e -> getAllDependencies(toplevel, e, a));
		FiVar(name, __, __): {
			switch (lookupTree(toplevel, name)) {
				Some(decl): {
					if (containsSet(acc.all_decls, decl)) acc else
					switch (decl) {
						FiFunctionDec(__, lambda, __,__,__):
							getAllDependencies(toplevel, lambda, Cpp2Dependencies(acc with funcs = insertSet(acc.funcs, decl), all_decls = insertSet(acc.all_decls, decl)));
						FiNativeDec(__,__,__,__, fallback, __,__):
							getAllDependencies(toplevel, fallback, Cpp2Dependencies(acc with natives = insertSet(acc.natives, decl), all_decls = insertSet(acc.all_decls, decl)));
						FiGlobalVar(__, value,__,__,__):
							getAllDependencies(toplevel, value, Cpp2Dependencies(acc with vars = insertSet(acc.vars, decl), all_decls = insertSet(acc.all_decls, decl)));
					}
				}
				None(): acc
			}
		}
		FiRequire(__, ex, __, __): 
			getAllDependencies(toplevel, ex, acc);
		FiUnsafe(__, fallback, __, __): 
			getAllDependencies(toplevel, fallback, acc);
	}
}

cpp2WriterRegisterConstString(w : Cpp2Writer, s : string) -> Cpp2ConstString {
	switch (lookupTree(w.const_strings, s)) {
		Some(cached): cached;
		None(): {
			/*addr = cpp2BytesOutputGetPc(w.bytecode);
			size = cpp2BytesOutputWriteWideStringRaw(w.bytecode, s);
			rslot = if (size > 0xFFFF) {
				raddr = cpp2BytesOutputGetPc(w.bytecode);
				cpp2BytesOutputWriteInt31(w.bytecode, bitAnd(size, 0xFFFF));
				cpp2BytesOutputWriteInt31(w.bytecode, addr);
				"StackSlot::InternalMakeString(MakeFlowPtr(" + i2s(raddr) + ")," + i2s(bitUshr(size, 16)) + ",true)";
			} else {
				"StackSlot::InternalMakeString(MakeFlowPtr(" + i2s(addr) + ")," + i2s(size) + ",false)";
			}
			ret = Cpp2ConstString(addr, size, rslot);
			w.const_strings ::= setTree(w.const_strings, s, ret);
			ret*/
			
			addr = strlen(w.bytecode);
			str_raw = \str -> stringFold(str, "", \acc, x -> acc + fromCharCode(bitAnd(x, 0xFF)) + fromCharCode(bitAnd(x / 256, 0xFF)));
			w.bytecode ::= w.bytecode + str_raw(s);
			size = (strlen(w.bytecode) - addr) / 2;
			ret = Cpp2ConstString(addr, size, "StackSlot::InternalMakeString(MakeFlowPtr(" + i2s(addr) + ")," + i2s(size) + ",false)");
			w.const_strings ::= setTree(w.const_strings, s, ret);
			ret
		}
	}
}

cpp2WriterEmitCommonAndTables(writer : Cpp2Writer) {
	bytes = s2a(writer.bytecode);
	h = ref makeList();
	o = ref makeList();

	rlistPush(o, "#" + "include \"core/GarbageCollector.h\"");
	cpp2wrLines(h, [
		"#" + "include \"core/NativeProgram.h\"",
		"#" + "include \"core/RunnerMacros.h\"",
		"",
		"#" +  "include <limits>",
		"",
		"#pragma GCC diagnostic ignored \"-Wunused-parameter\"",
		"",
		"#ifndef FLOW_COMPACT_STRUCTS",
		"#error Runner built without compact structs is not supported",
		"#endif",
		"",
		"namespace flowgen_" + writer.config.entry + " {",
		"    using namespace flowgen_common;",
		"",
		"    static const unsigned NUM_CODE_BYTES = " + i2s(length(bytes)) + ";",
		"    static const unsigned NUM_FUNCTIONS = " + i2s(length(^(writer.function_table))) + ";",
		"    static const unsigned NUM_STRUCTS = " + i2s(writer.num_structs) + ";",
		"    static const unsigned NUM_STRUCT_DEFS = " + i2s(length(^(writer.structs_order))) + ";",
		"    static const unsigned NUM_FIELDS = " + i2s(length(^(writer.field_index_table))) + ";",
		"    static const unsigned NUM_GLOBALS = " + i2s(length(writer.global_vars)) + ";"
	]);
	if (length(writer.struct_counts) >= 1) {
		rlistPush(h, "");
		iter(enumFromTo(0, length(writer.struct_counts) - 1), \i ->
			rlistPush(h, "    static const unsigned NUM_STRUCTS_" + i2s(i) + " = " + i2s(writer.struct_counts[i]) + ";")
		);
	}
	cpp2wrLines(h, [
		"",
		"    class NativeProgramImpl : public NativeProgram {",
		"    public:",
		"        NativeProgramImpl() {}",
		"",
		"    protected:",
		"        virtual const char *getByteCode(int *length);",
		"        virtual void flowGCObject(GarbageCollectorFn fn);",
		"        virtual void onRunMain();",
		"",
		"    public:",
		"        StackSlot functions[NUM_FUNCTIONS];",
		"        StackSlot globals[NUM_GLOBALS];",
		"    };",
		"",
		"    extern const unsigned char bytecode_bytes[NUM_CODE_BYTES];",
		"    extern const NativeProgram::FunctionSpec function_specs[NUM_FUNCTIONS];",
		"    extern const NativeProgram::StructSpec struct_specs[NUM_STRUCT_DEFS];",
		"    extern const char field_index_table[NUM_FIELDS][NUM_STRUCTS_1];",
		"",
		"    __attribute__((always_inline)) inline NativeProgramImpl *getSelf(ByteCodeRunner *runner) {",
		"        return (NativeProgramImpl*)runner->getProgram();",
		"    }",
		"",
		"#pragma pack(push, 4)"
	]);
	iter(^(writer.struct_code.hdr_lines), \l -> rlistPush(h, "    " + l));
	cpp2wrLines(h, ["#pragma pack(pop)", ""]);
	iter(^(writer.method_names), \name -> rlistPush(h, "    DECLARE_NATIVE_METHOD(" + name + ")"));
	rlistPush(h, "}");
	cpp2wrLines(o, [
		"",
		"using namespace flowgen_" + writer.config.entry + ";",
		"",
		"NativeProgram *load_" + writer.config.entry + "() {",
		"    return new NativeProgramImpl();",
		"}",
		"",
		"const char *NativeProgramImpl::getByteCode(int *length) {",
		"    *length = NUM_CODE_BYTES;",
		"    return (const char*)bytecode_bytes;",
		"}",
		"",
		"void NativeProgramImpl::flowGCObject(GarbageCollectorFn fn) {",
		"    fn(globals, NUM_GLOBALS);",
		"}",
		"",
		"void NativeProgramImpl::onRunMain() {",
		"    RUNNER_VAR = getFlowRunner();",
		"",
		"    if (!InitStructTable(struct_specs, NUM_STRUCT_DEFS))",
		"        return;",
		"    if (!InitFunctionTable(functions, function_specs, NUM_FUNCTIONS))",
		"        return;",
		"",
		"    memset(globals, 0, sizeof(globals));",
		"    RUNNER->FreezeNativeFunctions(true);",
		""
	]);
	iter(enumFromTo(0, writer.init_count - 1), \i ->
		cpp2wrLines(o, [
			"    aux_init" + i2s(i) + "(RUNNER, NULL);",
			"    if (RUNNER->IsErrorReported()) return;"
		])
	);
	cpp2wrLines(o, [
		"    fn_main(RUNNER, NULL);",
		"}",
		"",
		"const unsigned char flowgen_" + writer.config.entry + "::bytecode_bytes[] = {"
	]);
	cpp2wrArray(o, length(bytes), 20, \i -> i2s(bytes[i]));
	cpp2wrLines(o, [
		"};",
		"",
		"const NativeProgram::FunctionSpec flowgen_" + writer.config.entry + "::function_specs[] = {"
	]);
	cpp2wrArray(o, length(^(writer.function_table)), 1,
		\i -> {
			spec = ^(writer.function_table)[i];
			"{ \"" + spec.name + "\", " +
			(if (spec.native_name != "") {
				"\"" + spec.native_name + "\"";
			} else {
				"NULL"
			}) +
			", " + i2s(spec.nargs) + ", " +
			(if (spec.fn_name != "") {
				"&" + spec.fn_name
			} else {
				"NULL"
			})
			+ " }";
		}
	);
	cpp2wrLines(o, [
		"};",
		"",
		"static const char *const struct_field_names[] = {"
	]);
	cpp2wrArray(o, length(^(writer.struct_code.field_names)), 10,
		\i -> "\"" + ^(writer.struct_code.field_names)[i] + "\""
	);
	cpp2wrLines(o, [
		"};",
		"",
		"static const int struct_field_types[] = {"
	]);
	cpp2wrArray(o, length(^(writer.struct_code.field_types)), 20,
		\i -> i2s(^(writer.struct_code.field_types)[i])
	);
	cpp2wrLines(o, [
		"};",
		"",
		"static const FlowStructFieldDef struct_field_defs[] = {"
	]);
	cpp2wrArray(o, length(^(writer.struct_code.def_lines)), 1,
			\i -> ^(writer.struct_code.def_lines)[i]
	);
	cpp2wrLines(o, [
		"};",
		"",
		"static const FlowStructFieldGCDef struct_field_gcdefs[] = {"
	]);
	cpp2wrArray(o, length(^(writer.struct_code.gcdef_lines)), 1, 
		\i -> ^(writer.struct_code.gcdef_lines)[i]
	);
	cpp2wrLines(o, [
		"};",
		"",
		"const NativeProgram::StructSpec flowgen_" + writer.config.entry + "::struct_specs[] = {"
	]);
	cpp2wrArray(o, length(^(writer.structs_order)), 1,
		\i ->{
			s = ^(writer.structs_order)[i];
			r = ^(writer.struct_code.info_refs)[i];
			"{ " + i2s(length(s.args)) + ", " + i2s(s.compare_idx) + ", " +
			i2s(r.name_sz) + ", " + i2s(r.name_addr) + ", " +
			(if (length(s.args) > 0) "sizeof(FS_" + s.name + ")" else "4") + ", " +
			i2s(r.empty_addr) + ", " + i2s(r.gcdef_cnt) + ", \"" + s.name +"\", " +
			(if (r.fld_idx != cpp2_int_UNDEF) {
				"&struct_field_names["     + i2s(r.fld_idx) +
				"], &struct_field_types["  + i2s(r.type_idx) + 
				"], &struct_field_defs["   + i2s(r.def_idx) +
				"], &struct_field_gcdefs[" + i2s(r.gcdef_idx) + "]"
			} else {
				"NULL, NULL, NULL, NULL"
			})
			+ " }"
		}
	);
	cpp2wrLines(o, [
		"};",
		"",
		"const char flowgen_" + writer.config.entry + "::field_index_table[NUM_FIELDS][NUM_STRUCTS_1] = {"
	]);
	iteri(^(writer.field_index_table), \i, ln -> {
			cpp2wrLines(o, [
				"    // " + ^(writer.field_index_list)[i] + ":", 
				"    { "
			]);
			cpp2wrArray(o, length(ln), 20, \j -> "(char)" + i2s(ln[j])); 
			cpp2wrLines(o, ["    }" + (if (i + 1 == length(^(writer.field_index_table))) "" else ",")]);
		}
	);

	rlistPush(o, "};");
	cpp2wrLines(h, [
			"",
			"#define CHECK_ERROR(cmd) \\",
			"    cmd; \\",
			"    if (unlikely(RUNNER->IsErrorReported())) RETVOID;",
			"#define CHECK_TAG(tag,slot,msg) \\",
			"    if (unlikely(!slot.Is##tag())) { \\",
			"        RUNNER->ReportTagError(slot, tag, msg, NULL); \\",
			"        RETVOID; \\",
			"    }",
			"#define CHECK_STRUCT(slot,fcnt,msg) \\",
			"    if (unlikely(!slot.IsStruct()) || unlikely(unsigned(slot.GetStructId()) >= NUM_STRUCTS_##fcnt)) { \\",
			"        RUNNER->ReportTagError(slot, TStruct, msg, NULL); \\",
			"        RETVOID; \\",
			"    }",
			"#define CHECK_STRUCT_TYPE(slot,id,msg) \\",
			"    if (unlikely(!slot.IsStruct()) || unlikely(unsigned(slot.GetStructId()) != id)) { \\",
			"        RUNNER->ReportStructError(slot, id, msg, NULL); \\",
			"        RETVOID; \\",
			"    }",
			"#define FIND_STRUCT_FIELD(ivar, slot, idx, name, func) \\",
			"    ivar = field_index_table[idx][slot.GetStructId()]; \\",
			"    if (unlikely(ivar < 0)) { \\",
			"        RUNNER->ReportFieldNameError(slot, name, func); \\",
			"        RETVOID; \\",
			"    }"
	]);
	if (writer.config.verbose > 0) {
		fcPrintln("writing gen_common.h and gen_tables.cpp", writer.config.threadId)
	}
	cpp2AddLines(writer, list2array(^h), cpp2MakePath("gen_common.h", writer.config));
	cpp2AddLines(writer, list2array(^o), cpp2MakePath("gen_tables.cpp", writer.config));
}

cpp2WriterCompileGlobalFn(writer : Cpp2Writer, name : string, body : FiLambda) -> void {
	writer.cur_global ::= name;
	writer.next_closure_id ::= 1;
	cpp2WriterCompileLambda(writer, name, cpp2_int_UNDEF, body, None());
	{}
}

cpp2WriterCompileLambda(writer : Cpp2Writer, name : string, idx : int, lambda : FiLambda, upenv : Maybe<Cpp2Environment>) -> Cpp2Environment {
	atypes = switch (lambda.type) {
		FiTypeFunction(arg_types, ret_type): arg_types;
		default: {
			cpp2_error("cpp2Writertype must be FiTypeFunction");
			[]
		}
	};
	switch (upenv) {
		Some(env): cpp2EnvironmentStashGlobalMeta(env);
		None(): { }
	}
	// Prepare environment
	mname = if (idx == cpp2_int_UNDEF) cpp2FnMethodName(name) else cpp2ClosureMethodName(name, idx);
	vname = if (idx == cpp2_int_UNDEF) name else name + "$" + i2s(idx);
	env = cpp2Environment(writer, upenv, mname, vname, length(lambda.args), writer.struct_list);
	iter(enumFromTo(0, length(lambda.args) - 1), \i -> {
			place = cpp2PlaceInfo(Some(env), Cpp2Argument(), i, lambda.args[i].name);
			(place.meta).context ::= 0;
			(place.meta).dirty ::= true;
			(place.meta).type ::= atypes[i].type;
			env.locals ::= setTree(env.locals, lambda.args[i].name, place)
		}
	);
	// Process the body
	maybeApply(env.cur_ctx, 
		\ctx -> {
			cpp2WriterCompileExpression(writer, lambda.body, ctx, Cpp2OutputReturn(), Cpp2StackTop(0));
			cpp2ContextExit(ctx);
		}
	);
	// Flush the code
	mod_name = moduleWhereNameIsDefined(writer.program.names, writer.cur_global);
	file_mod = lookupTreeDef(writer.program.modules, mod_name, dummyFiModule);
	// Get rid of the absolute paths to our includes
	t = fold(writer.config.includes, file_mod.fileinfo.flowfile, \acc, incl ->
		strReplace(strReplace(acc, incl, ""), incl + "/", "")
	);
	t_norm = strReplace(strReplace(strReplace(t, "/", "_"), ".flow", ""), ".", "_");
	cpp2WriterEmitLambdaCode(writer, env, cpp2MakePath("flow_" + t_norm + ".cpp", writer.config));
	switch (upenv) {
		Some(e): cpp2EnvironmentRestoreGlobalMeta(e);
		None(): { }
	}
	env
}

cpp2WriterCompileExpression(writer : Cpp2Writer, code : FiExp, ctx : Cpp2Context, out : Cpp2OutputLocation, top : Cpp2StackTop) -> void {
	output = \expr, tag -> {
		cpp2WriterEmitValue(ctx, out, expr, tag, false, false, false); {}
	}
	eval_tmp = \arg -> {
		cpp2WriterEvalToTmp(writer, arg, ctx, top, Cpp2OutputNull());
	}
	fetch_ref = \arg, lvalue -> {
		cpp2WriterFetchToRef(writer, arg, ctx, top, lvalue, Cpp2OutputNull());
	}
	switch (code) {
		FiVoid(__):
			output("FLOWVOID", Cpp2TVoid());
		FiBool(value, __):
			output("StackSlot::MakeBool(" + b2s(value) + ")", Cpp2TBool());
		FiInt(value, __):
			output("StackSlot::MakeInt(" + cpp2WriterEmitNumericExpr(writer, code, ctx, top, Cpp2TInt()) + ")", Cpp2TInt());
		FiDouble(value, __):
			output("StackSlot::MakeDouble(" + cpp2WriterEmitNumericExpr(writer, code, ctx, top, Cpp2TDouble()) + ")", Cpp2TDouble());
		FiString(value, __):
			output(cpp2WriterRegisterConstString(writer, value).rslot, Cpp2TString());
		FiCall(fn, args, type, __): {
			cpp2WriterCompileCall(writer, code, ctx, out, top);
			{}
		}
		FiLambda(args, body, type, __): {
			cpp2WriterCompileClosure(writer, code, ctx, out, top);
			{}
		}
		FiVar(n, type, __): {
			switch (cpp2WriterGetValueRef(writer, code, ctx, false)) {
				Some(val_ref): {
					cpp2WriterCopyValue(ctx, out, val_ref);
					{}
				}
				None(): cpp2_error("error at FiVar case");
			}
		}
		FiSeq(es, type, __): {
			iteri(es, \i, e ->
				if (i == length(es) -1) {
					cpp2WriterCompileExpression(writer, e, ctx, out, top);
				} else {
					cpp2WriterCompileExpression(writer, e, ctx, Cpp2OutputNone(), cpp2Mktop(top));
				}
			)
		}
		FiLet(name, type, e1, e2, type2, __): {
			//if (scope != null) {
				cpos = cpp2ContextDefpos(ctx);
				def = cpp2EnvironmentMklocal(ctx.env, name);
				cpp2WriterCompileExpression(writer, e1, ctx, Cpp2OutputVar(def), cpp2Mktop(top));
				(cpp2ContextLocalMeta(ctx, def)).type ::= type;
				cpp2ContextPushdef(ctx, def);
				cpp2WriterCompileExpression(writer, e2, ctx, out, top);
				cpp2ContextPopdefs(ctx, cpos);
			//} else {
			//	cpp2WriterCompileExpression(value, ctx, Cpp2OutputNone(), cpp2Mktop(top));
			//	output("FLOWVOID", Cpp2TVoid());
			//}
		}
		FiIf(cond, e1, e2, type, __): {
			cond_expr = cpp2WriterEmitConditionExpr(writer, cond, ctx, cpp2Mktop(top));
			cpp2ContextWr(ctx, "if (" + cond_expr + ") {");
				ctx_if = cpp2ContextEnter(ctx, "    ");
				cpp2WriterCompileExpression(writer, e1, ctx_if, out, cpp2Mktop(top));
				cpp2ContextExit(ctx_if);
			cpp2ContextWr(ctx, "} else {");
				ctx_else = cpp2ContextEnter(ctx, "    ");
				cpp2WriterCompileExpression(writer, e2, ctx_else, out, cpp2Mktop(top));
				cpp2ContextExit(ctx_else);
			cpp2ContextWr(ctx, "}");
			cpp2ContextJoin(ctx, [ctx_if, ctx_else]);
		}
		FiSwitch(e0, sw_type, cases, type, __): {
			mvexpr = cpp2WriterGetValueRef(writer, e0, ctx, false);
			vexpr = switch(mvexpr) {
				Some(ve): ve;
				None(): cpp2WriterEvalToTmp(writer, e0, ctx, top, Cpp2OutputNull());
			}
			restore_cb = switch (mvexpr) {
				None(): {
					// avoid using the same temporary for out and copy
					cpp2WriterGetOutputPlace(out, top);
					None()
				}
				Some(__): {
					if (!cpp2PlaceInfoIsLValue(vexpr)) {
						// Copy the struct into a temporary if not lvalue, to make FieldAlias efficient.
						cpp2WriterGetOutputPlace(out, top);
						Some(cpp2WriterMakeLValueCopy(ctx, vexpr, top));
					} else {
						None()
					}
				}
			}
			
			cpp2WriterVerifyTag(vexpr, Cpp2TStruct(), ctx);
			cpp2ContextWr(ctx, "switch (" + cpp2PlaceInfoGetLValue(vexpr) + ".GetStructId()) {");
			branches = ref [];
			foundDefault = fold(cases, false, 
				\acc, c -> {
					subctx = cpp2ContextEnter(ctx, "    ");
					if (c.struct == "default") {
						cpp2ContextWr(ctx, "default: {");
					} else {
						structDef = lookupTreeDef(writer.structs, c.struct, dummyCpp2StructInfo);
						cpp2ContextWr(ctx, "case " + i2s(structDef.id) + "/*" + c.struct + "*/: {");
						loc = cpp2ContextLocalMeta(subctx, vexpr);
						loc.tag ::= Cpp2TStruct();
						loc.struct_size ::= length(structDef.args);
						loc.struct_id ::= structDef.id;
						fori(0, length(c.argNames) - 1, 
							\i -> {
								def0 = cpp2PlaceInfo(Some(ctx.env), Cpp2FieldAlias(vexpr, structDef), i, c.argNames[i]);
								def = if (structDef.args[i].is_mutable) {
									def1 = cpp2EnvironmentMklocal(subctx.env, c.argNames[i]);
									cpp2ContextWrSemi(ctx, cpp2PlaceInfoGetLValue(def1) + " = " + cpp2PlaceInfoGetRValue(def0, subctx));
									def1;
								} else {
									def0;
								};
								(def.meta).dirty ::= true;
								(def.meta).type ::= structDef.args[i].type;
								if (structDef.atypes[i] != Cpp2TNull()) {
									(def.meta).tag ::= structDef.atypes[i];
								}
								cpp2ContextPushdef(subctx, def);
							}
						)
					}
					refArrayPush(branches, subctx);
					cpp2WriterCompileExpression(writer, c.body, subctx, out, cpp2Mktop(top));
					if (out != Cpp2OutputReturn()) {
						cpp2ContextWr(subctx, "break;");
					}
					cpp2ContextExit(subctx);
					cpp2ContextWr(ctx, "}");
					acc || c.struct == "default"
				}
			);
			if (!foundDefault) {
				cpp2ContextWr(ctx, "default:");
				cpp2ContextWr(ctx, "    RUNNER->ReportError(UncaughtSwitch, \"Unexpected in switch in " + ctx.env.vname + "\");");
				cpp2ContextWr(ctx, "    RETVOID;");
			}
			cpp2ContextWr(ctx, "}");
			cpp2ContextJoin(ctx, ^branches);
			switch (restore_cb) {
				Some(cb): cb();
				None(): { }
			}
		}
		FiCast(value, fromtype, totype, type, __): {
			aref = fetch_ref(value, false);
			rexpr = cpp2PlaceInfoGetRValue(aref, ctx);
			switch (fromtype) {
				FiTypeInt(): {
					cpp2WriterVerifyTag(aref, Cpp2TInt(), ctx);
					switch (totype) {
						FiTypeInt(): {
							cpp2WriterCopyValue(ctx, out, aref);
							{}
						}
						FiTypeDouble(): {
							output("StackSlot::MakeDouble(" + rexpr + ".GetInt())", Cpp2TDouble());
						}
						FiTypeString(): {
							cpp2WriterEmitValue(ctx, out, "ByteCodeRunner::DoInt2String(RUNNER," + rexpr + ")", Cpp2TString(), false, true, true);
							{}
						}
						default: {
							cpp2_error("Not implemented 1: " + prettyFiExp(dummyPretty, value));
						}
					}
				}
				FiTypeDouble(): {
					switch (totype) {
						FiTypeInt(): {
							cpp2WriterVerifyTag(aref, Cpp2TDouble(), ctx);
							output("StackSlot::MakeInt(" + rexpr + ".GetDouble())", Cpp2TInt());
						}
						FiTypeDouble(): {
							cpp2WriterVerifyTag(aref, Cpp2TDouble(), ctx);
							cpp2WriterCopyValue(ctx, out, aref);
							{}
						}
						FiTypeString(): {
							cpp2WriterEmitValue(ctx,out, "ByteCodeRunner::DoDouble2String(RUNNER," + rexpr + ")", Cpp2TString(), false, true, true);
							{}
						}
						default: {
							cpp2_error("Not implemented 2: " + prettyFiExp(dummyPretty, value));
						}
					}
				}
				FiTypeName(n1, __): {
					switch (totype) {
						FiTypeName(n2, __): {
							cpp2WriterCopyValue(ctx, out, aref);
							{}
						}
						default: {
							cpp2_error("Not implemented 3: " + prettyFiExp(dummyPretty, code));
						}
					}
				}
				FiTypeArray(fa): {
					switch (totype) {
						FiTypeArray(ta): {
							switch (fa) {
								FiTypeName(n1, __):
									switch (ta) {
										// Array of named types are OK 
										FiTypeName(n2, __): {
											cpp2WriterCopyValue(ctx, out, aref);
											{}
										}
										default: {
											cpp2_error("Not implemented 4: " + prettyFiExp(dummyPretty, code));
										}
								}
								default: {
									cpp2_error("Not implemented 5: " + prettyFiExp(dummyPretty, code));
								}
							}
						}
						default: {
							cpp2_error("Not implemented 6: " + prettyFiExp(dummyPretty, code));
						}
					}
				}
				FiTypeFlow(): {
					cpp2WriterCopyValue(ctx, out, aref);
					{}
				}
				FiTypeParameter(__): {
					cpp2WriterCopyValue(ctx, out, aref);
					{}
				}
				default: {
					cpp2_error("Not implemented 7: " + prettyFiExp(dummyPretty, code));
				}
			}
		}
		FiCallPrim(op, es, type, __): {
			cpp2WriterCompileCallPrim(writer, code, ctx, out, top);
			{}
		}
		FiRequire(flowfile, e, type, __): {
			cpp2_error("FiRequire is not supported yet"); // TODO: implement
			output("FLOWVOID", Cpp2TNull());
		}
		FiUnsafe(name, fallback, type, __): {
			cpp2_error("FiUnsafe is not supported yet"); // TODO: implement
			output("FLOWVOID", Cpp2TNull());
		}
	}
}

// A hack: copy a rvalue place into a temporary, and then change the
// fields of the original place to point to the new location.
cpp2WriterMakeLValueCopy(ctx : Cpp2Context, place : Cpp2PlaceInfo, top : Cpp2StackTop) -> () -> void {
	top_temp = top.temp;
	top.temp ::= top_temp + 1;
	tref = cpp2EnvironmentMktemp(ctx.env, top_temp);
	cpp2ContextWrSemi(ctx, cpp2PlaceInfoGetLValue(tref) + " = " + cpp2PlaceInfoGetRValue(place, ctx));
	cpp2PlaceInfoSubstituteLocation(place, tref);
}

	
cpp2WriterCompileCallPrim(writer : Cpp2Writer, code : FiCallPrim, ctx : Cpp2Context, out : Cpp2OutputLocation, top : Cpp2StackTop) -> void {
	output = \expr, tag -> {
		cpp2WriterEmitValue(ctx, out, expr, tag, false, false, false);
		{}
	};
	eval_tmp = \arg -> {
		cpp2WriterEvalToTmp(writer, arg, ctx, top, Cpp2OutputNull());
	}
	fetch_ref = \arg, lvalue -> {
		cpp2WriterFetchToRef(writer, arg, ctx, top, lvalue, Cpp2OutputNull());
	}
	switch (code.op) {
		FcStructPrim(name): {
			structDef = lookupTreeDef(writer.structs, name, dummyCpp2StructInfo);
			cpp2WriterCompileNewStruct(writer, structDef, code.es, ctx, out, top, "");
			{}
		}
		FcRefPrim(): {
			aref = fetch_ref(code.es[0], true);
			cpp2WriterEmitValue(ctx, out, "RUNNER->AllocateRef(" + cpp2PlaceInfoGetLValue(aref) + ")", Cpp2TRefTo(), false, true, true);
			{}
		}
		FcIndexPrim(): {
			arr = fetch_ref(code.es[0], false);
			idx = cpp2WriterEmitNumericExpr(writer, code.es[1], ctx, top, Cpp2TInt());
			cpp2WriterVerifyTag(arr, Cpp2TArray(), ctx);
			expr = "DerefArray(RUNNER," + cpp2PlaceInfoGetRValue(arr, ctx) + "," + idx + ")";
			cpp2WriterEmitValue(ctx, out, expr, Cpp2TNull(), false, true, false);
			{}
		}
		FcDerefPrim(): {
			aref = fetch_ref(code.es[0], false);
			cpp2WriterVerifyTag(aref, Cpp2TRefTo(), ctx);
			output("RUNNER->GetRefTarget(" + cpp2PlaceInfoGetRValue(aref, ctx) + ")", Cpp2TNull());
			{}
		}
		FcAssignPrim(): {
			aref = fetch_ref(code.es[0], false);
			value = fetch_ref(code.es[1], false);
			cpp2WriterVerifyTag(aref, Cpp2TRefTo(), ctx);
			cpp2ContextWrSemi(ctx, "RUNNER->SetRefTarget(" + cpp2PlaceInfoGetRValue(aref, ctx) + "," + cpp2PlaceInfoGetRValue(value, ctx) + ")");
			cpp2WriterCopyValue(ctx, out, value);
			{}
		}
		FcArrayPrim(): {
			cpp2WriterCompileConstructor(writer, code.es, ctx, out, top, Cpp2TArray(), \cnt, ptr -> {
				if (cnt == 0) {
					"StackSlot::MakeEmptyArray()";
				} else {
					"RUNNER->AllocateArray(" + i2s(cnt) + "," + ptr + ")";
				}
			}, false);
			{}
		}
		FcFieldPrim(name): {
			aref = fetch_ref(code.es[0], false);
			sref = cpp2PlaceInfoGetRValue(aref, ctx);
			if (name == "structname") {
				cpp2WriterVerifyStruct(aref, 0, ctx);
				specs = "struct_specs[" + sref + ".GetStructId()]";
				output("StackSlot::InternalMakeString(MakeFlowPtr(" + 
					specs + ".name_addr)," + specs + ".name_size,false)", Cpp2TString());
			} else {
				v = cpp2WriterFieldSetInfo(writer, code.es[0], aref, name);
				if (v.stype != cpp2_int_UNDEF) {
					info = writer.struct_list[v.stype];
					cpp2WriterVerifyStructId(writer, aref, v.stype, ctx);
					at = info.atypes[v.index];
					switch (out) {
						Cpp2OutputScalar(sname, tag): {
							if (tag == at) {
								rf = cpp2ContextGetStructField(ctx, aref, ^(writer.structs_order)[v.stype].name, name, Cpp2TNull());
								cpp2ContextWrSemi(ctx, sname + " = " + rf);
							} else {
								output(cpp2ContextGetStructField(ctx, aref, ^(writer.structs_order)[v.stype].name, name, at), at);
							}
						}
						default: { 
							output(cpp2ContextGetStructField(ctx, aref, ^(writer.structs_order)[v.stype].name, name, at), at);
						}
					}
				} else if (v.index != cpp2_int_UNDEF && v.index >= 0) {
					cpp2WriterVerifyStruct(aref, v.minsize, ctx);
					output("RUNNER->GetStructSlot(" + sref + "," + i2s(v.index) + "/*" + name + "*/)", Cpp2TNull());
				} else {
					// Dynamic lookup
					i= cpp2WriterFindFieldIndex(writer, aref, name, ctx);
					output("RUNNER->GetStructSlot(" + sref + "," + i+ ")", Cpp2TNull());
				}
			}
			{}
		}
		FcSetMutablePrim(name): {
			aref = fetch_ref(code.es[0], false);
			val = fetch_ref(code.es[1], false);
			sref = cpp2PlaceInfoGetRValue(aref, ctx);
			if (name != "structname") {
				v = cpp2WriterFieldSetInfo(writer, code.es[0], aref, name);
				if (v.stype != cpp2_int_UNDEF) {
					info = writer.struct_list[v.stype];
					cpp2WriterVerifyStructId(writer, aref, v.stype, ctx);
					at = info.atypes[v.index];
					if (at != Cpp2TNull()) {
						cpp2WriterVerifyTag(val, at, ctx); {}
					}
					ptr = cpp2ContextGetStructPtr(ctx, aref, ^(writer.structs_order)[v.stype].name, true);
					if (!cpp2IsNonGCFieldType(at)) {
						cpp2ContextWrSemi(ctx, "RUNNER->RegisterWrite(&" + ptr + "->hdr)");
					}
					if (at == Cpp2TStruct()) {
						cpp2ContextWrSemi(ctx, ptr + "->fl_" + name + " = " + cpp2PlaceInfoGetStructAddr(val, ctx));
					} else {
						cpp2ContextWrSemi(ctx, "flow_struct::set_" + cpp2StructFieldCode(at) +
							"(" + ptr + "->fl_" + name + "," + cpp2PlaceInfoGetRValue(val, ctx) + ")");
					}
				} else if (v.index != cpp2_int_UNDEF && v.index >= 0) {
					cpp2WriterVerifyStruct(aref, v.minsize, ctx);
					cpp2ContextWrCheck(ctx, "RUNNER->SetStructSlot(" + sref + "," + i2s(v.index) + "/*" + name + "*/," + cpp2PlaceInfoGetRValue(val, ctx) + ")", false);
				} else {
					// Dynamic lookup
					i= cpp2WriterFindFieldIndex(writer, aref, name, ctx);
					cpp2ContextWrCheck(ctx, "RUNNER->SetStructSlot(" + sref + "," + i+ "," + cpp2PlaceInfoGetRValue(val, ctx) + ")", false);
				}
			}
			output("FLOWVOID", Cpp2TNull());
			{}
		}
		FcPlusPrim():  cpp2WriterCompileMath(writer, code, ctx, out, top);
		FcMinusPrim(): cpp2WriterCompileMath(writer, code, ctx, out, top);
		FcMulPrim():   cpp2WriterCompileMath(writer, code, ctx, out, top);
		FcDivPrim():   cpp2WriterCompileMath(writer, code, ctx, out, top);
		FcModPrim():   cpp2WriterCompileMath(writer, code, ctx, out, top);
		FcNegPrim():   cpp2WriterCompileMath(writer, code, ctx, out, top);

		FcAndPrim(): cpp2WriterCompileCondition(writer, code, ctx, out, top);
		FcOrPrim():  cpp2WriterCompileCondition(writer, code, ctx, out, top);
		FcNotPrim(): cpp2WriterCompileCondition(writer, code, ctx, out, top);

		FcEqPrim(): cpp2WriterCompileCondition(writer, code, ctx, out, top);
		FcNePrim(): cpp2WriterCompileCondition(writer, code, ctx, out, top);
		FcGtPrim(): cpp2WriterCompileCondition(writer, code, ctx, out, top);
		FcGePrim(): cpp2WriterCompileCondition(writer, code, ctx, out, top);
		FcLtPrim(): cpp2WriterCompileCondition(writer, code, ctx, out, top);
		FcLePrim(): cpp2WriterCompileCondition(writer, code, ctx, out, top);

		FcCreateClosurePrim(str_name, fn_name): cpp2_error("FcCreateClosurePrim is unsupported yet"); // TODO: implement
		FcQuote(): cpp2_error("FcQuote is unsupported yet"); // TODO: implement
		FcUnquote(): cpp2_error("FcUnquote() is unsupported yet"); // TODO: implement
	}
}

cpp2WriterCompileCondition(writer : Cpp2Writer, code : FiExp, ctx : Cpp2Context, out : Cpp2OutputLocation, top : Cpp2StackTop) -> void {
	cexpr = cpp2WriterEmitConditionExpr(writer, code, ctx, top);
	switch (out) {
		Cpp2OutputScalar(name,tag): {
			if (tag == Cpp2TBool()) {
				cpp2ContextWrSemi(ctx, name + " = " + cexpr);
			} else {
				cpp2WriterEmitValue(ctx, out, "StackSlot::MakeBool(" + cexpr + ")", Cpp2TBool(), false, false, false);
				{}
			}
		}
		default: { 
			cpp2WriterEmitValue(ctx, out, "StackSlot::MakeBool(" + cexpr + ")", Cpp2TBool(), false, false, false);
			{}
		}
	}
}

cpp2WriterEmitConditionExpr(writer : Cpp2Writer, code : FiExp, ctx : Cpp2Context, top : Cpp2StackTop) -> string {
	switch (code) {
		FiBool(value, __): b2s(value);
		FiCallPrim(op, es, type, __): {
			switch (op) {
				FcEqPrim():
					cpp2WriterEmitComparisonExpr(writer, "==", es[0], es[1], fiExpType(es[0]), ctx, top);
				FcNePrim():
					cpp2WriterEmitComparisonExpr(writer, "!=", es[0], es[1], fiExpType(es[0]), ctx, top);
				FcLtPrim():
					cpp2WriterEmitComparisonExpr(writer, "<", es[0], es[1], fiExpType(es[0]), ctx, top);
				FcLePrim():
					cpp2WriterEmitComparisonExpr(writer, "<=", es[0], es[1], fiExpType(es[0]), ctx, top);
				FcGtPrim():
					cpp2WriterEmitComparisonExpr(writer, ">", es[0], es[1], fiExpType(es[0]), ctx, top);
				FcGePrim():
					cpp2WriterEmitComparisonExpr(writer, ">=", es[0], es[1], fiExpType(es[0]), ctx, top);
				FcNotPrim():
					"!" + cpp2WriterEmitConditionExpr(writer, es[0], ctx, top);
				FcAndPrim(): {
					a1expr = cpp2WriterEmitConditionExpr(writer, es[0], ctx, cpp2Mktop(top));
					tmp = cpp2ContextTempvar(ctx, "btmp", Cpp2TBool(), a1expr);
					cpp2ContextWr(ctx, "if (" + tmp + ") {");
					subctx = cpp2ContextEnter(ctx, "    ");
					a2expr = cpp2WriterEmitConditionExpr(writer, es[1], subctx, cpp2Mktop(top));
					cpp2ContextWrSemi(subctx, tmp + " = " + a2expr);
					cpp2ContextExit(subctx);
					cpp2ContextWr(ctx, "}");
					cpp2ContextJoinOne(ctx, subctx);
					tmp
				}
				FcOrPrim(): {
					a1expr = cpp2WriterEmitConditionExpr(writer, es[0], ctx, cpp2Mktop(top));
					tmp = cpp2ContextTempvar(ctx, "btmp", Cpp2TBool(), a1expr);
					cpp2ContextWr(ctx, "if (!" + tmp + ") {");
					subctx = cpp2ContextEnter(ctx, "    ");
					a2expr = cpp2WriterEmitConditionExpr(writer, code.es[1], subctx, cpp2Mktop(top));
					cpp2ContextWrSemi(subctx, tmp + " = " + a2expr);
					cpp2ContextExit(subctx);
					cpp2ContextWr(ctx, "}");
					cpp2ContextJoinOne(ctx, subctx);
					tmp
				}
				default: {
					cpp2WriterFetchToScalar(writer, code, ctx, top, Cpp2TBool());
				}
			}
		}
		default: {
			cpp2WriterFetchToScalar(writer, code, ctx, top, Cpp2TBool());
		}
	}
}

cpp2WriterEmitComparisonExpr(writer : Cpp2Writer, op : string, expr1 : FiExp, expr2 : FiExp, tp : FiType, ctx : Cpp2Context, top : Cpp2StackTop) -> string {
	// Check for number comparisons
	type = cpp2GetPrimitiveTag(tp);
	top2 = cpp2Mktop(top);
	if (type == Cpp2TInt() || type == Cpp2TDouble()) {
		val1 = cpp2WriterEmitNumericExpr(writer, expr1, ctx, top2, type);
		val2 = cpp2WriterEmitNumericExpr(writer, expr2, ctx, top2, type);
		cpp2ContextTempvar(ctx, "btmp", Cpp2TBool(), val1 + op + val2);
	} else if (type == Cpp2TBool() && (op == "==" || op == "!=")) {
		val1 = cpp2WriterEmitConditionExpr(writer, expr1, ctx, top2);
		val2 = cpp2WriterEmitConditionExpr(writer, expr2, ctx, top2);
		cpp2ContextTempvar(ctx, "btmp", Cpp2TBool(), val1 + op + val2);
	} else {
		ref1_0 = cpp2WriterFetchToRef(writer, expr1, ctx, top2, false, Cpp2OutputNull());
		ref2_0 = cpp2WriterFetchToRef(writer, expr2, ctx, top2, false, Cpp2OutputNull());

		// Check if already compared in reverse order
		swap = contains(ref2_0.meta.known_compares, ref1_0);
		ref1 = if (swap) ref2_0 else ref1_0; 
		ref2 = if (swap) ref1_0 else ref2_0;

		// Call compare if needed
		cvar = "cmp_" + i2s(ref1.uid) + "_" + i2s(ref2.uid);

		if (!contains(ref1.meta.known_compares, ref2)) {
			cpp2ContextRegisterIdxVar(ctx, cvar, "int");
			cpp2ContextWr(ctx, cvar + " = RUNNER->Compare(" + cpp2PlaceInfoGetRValue(ref1, ctx) + "," + cpp2PlaceInfoGetRValue(ref2, ctx) + ");");

			lm = cpp2ContextLocalMeta(ctx, ref1);
			lm.known_compares ::= concat(lm.known_compares, [ref2]);
		}
		cexpr = if (swap) "(0"+ op + cvar + ")" else "(" + cvar + op + "0)";
		cpp2ContextTempvar(ctx, "btmp", Cpp2TBool(), cexpr)
	}
}

cpp2WriterEmitNumericExpr(writer : Cpp2Writer, expr : FiExp, ctx : Cpp2Context, top : Cpp2StackTop, tag : Cpp2TagType) -> string {
	simple_binary = \e1, e2, op -> {
		v1 = cpp2WriterEmitNumericExpr(writer, e1, ctx, top, tag);
		v2 = cpp2WriterEmitNumericExpr(writer, e2, ctx, top, tag);
		cpp2ContextTempvar(ctx, "ntmp", tag, v1 + op + v2);
	}
	switch (expr) {
		FiInt(value, __):
			//(I2i.ucompare(value, int_80000000) == 0) ? 'int(0x80000000U)' : ''+value;
			if (value == cpp2_int_80000000) "int(0x80000000U)" else i2s(value);
		FiDouble(value, __): {
			if (value <= doubleMin) {
				"(-std::numeric_limits<double>::infinity())";
			} else if (value >= doubleMax) {
				"std::numeric_limits<double>::infinity()";
			} else if (isNanOrInf(value)) {
				"std::numeric_limits<double>::quiet_NaN()";
			} else {
				sv = d2s(value);
				if (strIndexOf(sv, ".") == -1 && strIndexOf(sv, "e") == -1) sv + ".0" else sv
			}
		}
		FiCallPrim(op, es, type, __): {
			switch (op) {
				FcPlusPrim():  simple_binary(es[0], es[1], "+");
				FcMinusPrim(): simple_binary(es[0], es[1], "-");
				FcMulPrim():   simple_binary(es[0], es[1], "*");
				FcDivPrim():   simple_binary(es[0], es[1], "/");
				FcModPrim(): {
					if (tag == Cpp2TDouble()) {
						v1 = cpp2WriterEmitNumericExpr(writer, es[0], ctx, top, tag);
						v2 = cpp2WriterEmitNumericExpr(writer, es[1], ctx, top, tag);
						cpp2ContextTempvar(ctx, "ntmp", tag, "fmod(" + v1 + "," + v2 + ")");
					} else {
						 simple_binary(es[0], es[1], "%");
					}
				}
				FcNegPrim(): "(-" + cpp2WriterEmitNumericExpr(writer, es[0], ctx, top, tag) + ")";
				default: {
					cpp2WriterFetchToScalar(writer, expr, ctx, top, tag);
				}
			}
		}
		FiCast(value, fromtype, totype, type, pos): {
			switch (totype) {
				FiTypeInt(): { }
				FiTypeDouble(): { }
				default: cpp2_error("Not implemented -1: " + prettyFiExp(dummyPretty, expr));
			}
			switch (fromtype) {
				// TODO: is there a bug ?...
				FiTypeInt(): {
					arg = cpp2WriterEmitNumericExpr(writer, value, ctx, top, Cpp2TInt());
					if (tag == Cpp2TDouble()) "double(" + arg + ")" else arg;
				}
				FiTypeDouble(): {
					arg = cpp2WriterEmitNumericExpr(writer, value, ctx, top, Cpp2TDouble());
					if (tag == Cpp2TDouble()) "int(" + arg + ")" else arg;
				}
				default: {
					cpp2_error("Not implemented -2: " + prettyFiExp(dummyPretty, expr));
					""
				}
			}
		}
		FiCall(fn, args, type, pos): {
			nname = cpp2WriterCallNativeName(writer, fn, ctx);
			if (nname != "") {
				if (nname == "Native.length") {
					arg = cpp2WriterFetchToRef(writer, args[0], ctx, cpp2Mktop(top), false, Cpp2OutputNull());
					cpp2WriterVerifyTag(arg, Cpp2TArray(), ctx);
					valstr = "RUNNER->GetArraySize(" + cpp2PlaceInfoGetRValue(arg, ctx) + ")";
					cpp2ContextTempvar(ctx, "len", Cpp2TInt(), valstr);
				} else if (nname == "Native.strlen") {
					arg = cpp2WriterFetchToRef(writer, args[0], ctx, cpp2Mktop(top), false, Cpp2OutputNull());
					cpp2WriterVerifyTag(arg, Cpp2TString(), ctx);
					valstr = "RUNNER->GetStringSize(" + cpp2PlaceInfoGetRValue(arg, ctx) + ")";
					cpp2ContextTempvar(ctx, "len", Cpp2TInt(), valstr);
				} else if (nname == "Native.bitXor") {
					simple_binary(args[0], args[1], "^");
				} else if (nname == "Native.bitOr") {
					simple_binary(args[0], args[1], "|");
				} else if (nname == "Native.bitAnd") {
					simple_binary(args[0], args[1], "&");
				} else if (nname == "Native.bitNot") {
					"(~" + cpp2WriterEmitNumericExpr(writer, args[0], ctx, top, Cpp2TInt()) + ")";
				} else {
					cpp2WriterFetchToScalar(writer, expr, ctx, top, tag);
				}
			} else {
				cpp2WriterFetchToScalar(writer, expr, ctx, top, tag);
			}
		}
		default: {
			cpp2WriterFetchToScalar(writer, expr, ctx, top, tag);
		}
	}
}

cpp2WriterCompileNumericExpr(writer : Cpp2Writer, expr : FiExp, ctx : Cpp2Context, out : Cpp2OutputLocation, top : Cpp2StackTop, ttag : Cpp2TagType) -> void {
	cexpr = cpp2WriterEmitNumericExpr(writer, expr, ctx, top, ttag);
	cb = \-> {
		if (ttag == Cpp2TDouble()) {
			cpp2WriterEmitValue(ctx, out, "StackSlot::MakeDouble(" + cexpr + ")", Cpp2TDouble(), false, false, false);
		} else {
			cpp2WriterEmitValue(ctx, out, "StackSlot::MakeInt(" + cexpr + ")", Cpp2TInt(), false, false, false);
		};
		{}
	}
	switch (out) {
		Cpp2OutputScalar(name, tag): {
			if (tag == ttag) {
				cpp2ContextWrSemi(ctx, name + " = " + cexpr);
			} else {
				cb();
			}
		}
		default: { 
			cb();
		}
	}
}

cpp2WriterCompileMath(writer : Cpp2Writer, expr : FiCallPrim, ctx : Cpp2Context, out : Cpp2OutputLocation, top : Cpp2StackTop) -> void {
	ttag = cpp2GetPrimitiveTag(expr.type);
	if (ttag == Cpp2TDouble() || ttag == Cpp2TInt()) {
		cpp2WriterCompileNumericExpr(writer, expr, ctx, out, top, ttag);
	} else {
		eval_tmp = \arg, allow_out -> {
			cpp2WriterEvalToTmp(writer, arg, ctx, top, if (allow_out) out else Cpp2OutputNone());
		};
		fetch_ref = \arg, lvalue, allow_out -> {
			cpp2WriterFetchToRef(writer, arg, ctx, top, lvalue, if (allow_out) out else Cpp2OutputNone());
		};
		simple_binary = \e1, e2, cmd -> {
			a1 = eval_tmp(e1, true);
			a2 = fetch_ref(e2, false, false);
			cpp2ContextWrCheck(ctx, "RUNNER->" + cmd + "(" + cpp2PlaceInfoGetLValue(a1) + ", " + cpp2PlaceInfoGetRValue(a2, ctx) + ")", false);
			a1
		}
		out_ref = switch (expr.op) {
			FcPlusPrim(): {
				a1 = eval_tmp(expr.es[0], true);
				a2 = fetch_ref(expr.es[1], true, false);
				if (ttag == Cpp2TString()) {
					cpp2WriterVerifyTag(a1, ttag, ctx);
					cpp2WriterVerifyTag(a2, ttag, ctx);
					cpp2ContextWrCheck(ctx, "RUNNER->DoPlusString(" + cpp2PlaceInfoGetLValue(a1) + ", " + cpp2PlaceInfoGetLValue(a2) + ")", true);
				} else {
					cpp2ContextWrCheck(ctx, "RUNNER->DoPlus(" + cpp2PlaceInfoGetLValue(a1) + ", " + cpp2PlaceInfoGetLValue(a2) + ")", true);
				}
				a1
			}
			FcMinusPrim(): simple_binary(expr.es[0], expr.es[1], "DoMinus");
			FcMulPrim():   simple_binary(expr.es[0], expr.es[1], "DoMultiply");
			FcDivPrim():   simple_binary(expr.es[0], expr.es[1], "DoDivide");
			FcModPrim():   simple_binary(expr.es[0], expr.es[1], "DoModulo");
			FcNegPrim(): {
				a1 = eval_tmp(expr.es[0], true);
				cpp2ContextWrCheck(ctx, "RUNNER->DoNegate(" + cpp2PlaceInfoGetLValue(a1) + ")", false);
				a1
			}
			default: {
				cpp2_error("impossible");
				dummyCpp2PlaceInfo
			}
		}
		cpp2WriterCopyValue(ctx, out, out_ref);
		{}
	}
}

cpp2WriterEmitPrimitiveWrap(writer : Cpp2Writer, expr : FiExp, ctx : Cpp2Context, top : Cpp2StackTop) -> string {
	numbers = \tp : FiType -> {
		tp_tag = cpp2GetPrimitiveTag(tp);
		if (tp_tag != Cpp2TInt() && tp_tag != Cpp2TDouble()) "" else {
			cexpr = cpp2WriterEmitNumericExpr(writer, expr, ctx, top, tp_tag);
			if (tp_tag == Cpp2TDouble()) {
				"StackSlot::MakeDouble(" + cexpr + ")";
			} else {
				"StackSlot::MakeInt(" + cexpr + ")";
			}
		}
	}
	boolean = \-> {
		cexpr = cpp2WriterEmitConditionExpr(writer, expr, ctx, top);
		"StackSlot::MakeBool(" + cexpr + ")";
	}
	switch (expr) {
		FiCallPrim(op, es, type, __): {
			switch (op) {
				FcPlusPrim():  numbers(type);
				FcMinusPrim(): numbers(type);
				FcMulPrim():   numbers(type);
				FcDivPrim():   numbers(type);
				FcModPrim():   numbers(type);
				FcNegPrim():   numbers(type);

				FcAndPrim(): boolean();
				FcOrPrim():  boolean();
				FcNotPrim(): boolean();

				FcEqPrim(): boolean();
				FcNePrim(): boolean();
				FcGtPrim(): boolean();
				FcGePrim(): boolean();
				FcLtPrim(): boolean();
				FcLePrim(): boolean();
				
				FcFieldPrim(name): {
					ttag = cpp2GetPrimitiveTag(type);
					if (ttag == Cpp2TBool()) {
						boolean();
					} else {
						numbers(type);
					}
				}
				default: "";
			}
		}
		default: "";
	}
}

cpp2WriterAssignExpr(plv : string, expr : string, call : bool) -> string {
	if (startsWith(expr, "StackSlot::Make")) {
		i = strIndexOf(expr, "(");
		"StackSlot::Set" + 
		substring(expr, 15, i-15) +
		"(" + plv +
		(if (getCharAt(expr, i + 1) != ")") "," else "") +
		substring(expr, i + 1, strlen(expr))
	} else if (startsWith(expr, "StackSlot::InternalMake")) {
		i = strIndexOf(expr, "(");
		"StackSlot::InternalSet" + substring(expr, 23, i - 23) +
		"(" + plv +
		(if (getCharAt(expr, i + 1) != ")") "," else "") +
		substring(expr, i + 1, strlen(expr))
	} else if (call) {
		if (plv == "") {
			cpp2_error("empty plv in cpp2WriterAssignExpr");
		}
		"CALL_WITH_RETSLOT(" + plv + "," + expr + ")"
	} else {
		plv + " = " + expr
	}
}

cpp2WriterEmitValue(ctx : Cpp2Context, out : Cpp2OutputLocation, expr : string, tag : Cpp2TagType, io : bool, check : bool, _gc : bool) -> Maybe<Cpp2PlaceInfo> {
	switch (out) {
		Cpp2OutputNone(): {
			if (io) {
				cpp2ContextWrCheckopt(ctx, expr, check, _gc);
			}
			None();
		}
		Cpp2OutputNull(): {
			cpp2_error("Cpp2OutputNull()");
			None();
		}
		Cpp2OutputReturn(): {
			cpp2ContextWrSemi(ctx, "return " + expr);
			None();
		}
		Cpp2OutputVar(place): {
			expr1 = cpp2WriterAssignExpr(cpp2PlaceInfoGetLValue(place), expr, io || check || _gc);
			if (tag != Cpp2TNull()) {
				(cpp2ContextLocalMeta(ctx, place)).tag ::= tag;
			}
			cpp2ContextWrCheckopt(ctx, expr1, check, _gc);
			Some(place)
		}
		Cpp2OutputExpr(cb): {
			expr1 = cb(ctx, expr);
			cpp2ContextWrCheckopt(ctx, expr1, check, _gc);
			None()
		}
		Cpp2OutputScalar(name, tag2): {
			if (tag != tag2) {
				cpp2ContextRegisterIdxVar(ctx, "unbox_tmp", "StackSlot");
				cpp2ContextWrCheckopt(ctx, cpp2WriterAssignExpr("unbox_tmp", expr, io || check || _gc), check, _gc);
				cpp2ContextWr(ctx, "CHECK_TAG(" + cpp2TagToString(tag2) + ",unbox_tmp,\"" + ctx.env.vname + "\");");
				expr1 = name + " = " + "unbox_tmp" +
				switch (tag2) {
					Cpp2TBool():   ".GetBool()";
					Cpp2TInt():    ".GetInt()";
					Cpp2TDouble(): ".GetDouble()";
					default: {
						cpp2_error("impossible");
						""
					}
				};
				cpp2ContextWrCheckopt(ctx, expr1, false, false);
			} else {
				expr1 = name + " = " + expr +
				switch (tag2) {
					Cpp2TBool():   ".GetBool()";
					Cpp2TInt():    ".GetInt()";
					Cpp2TDouble(): ".GetDouble()";
					default: {
						cpp2_error("impossible");
						""
					}
				};
				cpp2ContextWrCheckopt(ctx, expr1, check, _gc);
			}
			None();
		}
	}
}

cpp2WriterCopyValue(ctx : Cpp2Context, out : Cpp2OutputLocation, inv: Cpp2PlaceInfo) -> Maybe<Cpp2PlaceInfo> {
	switch (out) {
		Cpp2OutputNone(): None();
		Cpp2OutputNull(): {
			cpp2_error("Cpp2OutputNull()");
			None();
		}
		Cpp2OutputReturn(): {
			cpp2ContextWrSemi(ctx, "return " + cpp2PlaceInfoGetRValue(inv, ctx));
			None();
		}
		Cpp2OutputVar(place): {
			if (!cpp2PlaceInfoIsSame(place, inv)) {
				cpp2ContextWrSemi(ctx, 
					cpp2WriterAssignExpr(cpp2PlaceInfoGetLValue(place), cpp2PlaceInfoGetRValue(inv, ctx), false)
				);
				if (inv.meta.dirty || place.meta.dirty) {
					tm = cpp2ClearMeta(cpp2ContextLocalMeta(ctx, place));
					tm.tag ::= inv.meta.tag;
					tm.struct_size ::= inv.meta.struct_size;
					tm.struct_id ::= inv.meta.struct_id;
				}
			}
			Some(place)
		}
		Cpp2OutputExpr(cb): {
			cpp2ContextWrSemi(ctx, cb(ctx, cpp2PlaceInfoGetRValue(inv, ctx)));
			None();
		}
		Cpp2OutputScalar(name, tag2): {
			cpp2WriterVerifyTag(inv, tag2, ctx);
			expr = cpp2PlaceInfoGetRawField(inv, ctx, tag2);
			if (expr == "") {
				expr1 = cpp2PlaceInfoGetRValue(inv, ctx) + 
					switch (tag2) {
						Cpp2TBool():   ".GetBool()";
						Cpp2TInt():    ".GetInt()";
						Cpp2TDouble(): ".GetDouble()";
						default: {
							cpp2_error("impossible");
							""
						}
					};
				cpp2ContextWrSemi(ctx, name + " = " + expr1);
			} else {
				cpp2ContextWrSemi(ctx, name + " = " + expr);
			}
			None();
		}
	}
}

cpp2WriterGetValueRef(writer : Cpp2Writer, code : FiExp, ctx : Cpp2Context, lvalue : bool) -> Maybe<Cpp2PlaceInfo> {
	switch (code) {
		FiVar(n, type, __): {
			aref = cpp2WriterResolveName(writer, ctx, n);
			if (lvalue && !cpp2PlaceInfoIsLValue(aref)) {
				None()
			} else {
				if (cpp2PlaceInfoIsStub(aref)) {
					cpp2WriterReifyStub(writer, aref, code);
				}
				Some(aref);
			}
		}
		default: None();
	}
}

cpp2WriterVerifyTag(aref : Cpp2PlaceInfo, tag : Cpp2TagType, ctx : Cpp2Context) -> bool {
	if (aref.meta.tag == tag) true else {
		tstr = cpp2TagToString(tag);
		if (aref.meta.tag != Cpp2TNull()) {
			cpp2_error("Cannot verify tag " + tstr + " - already " + cpp2TagToString(aref.meta.tag));
		}
		cpp2ContextWr(ctx, 
			"CHECK_TAG(" + tstr + 
			"," + cpp2PlaceInfoGetRValue(aref, ctx) + ",\"" + ctx.env.vname + "\");"
		);
		lm = cpp2ContextLocalMeta(ctx, aref);
		lm.tag ::= tag;
		false
	}
}

cpp2WriterVerifyStruct(aref : Cpp2PlaceInfo, size : int, ctx : Cpp2Context) -> bool {
	if (aref.meta.tag == Cpp2TStruct() && aref.meta.struct_size >= size) true else {
		if (aref.meta.tag != Cpp2TNull() && aref.meta.tag != Cpp2TStruct()) {
			cpp2_error("Cannot verify struct - already " + cpp2TagToString(aref.meta.tag));
		} else {
			cpp2ContextWr(ctx, 
				"CHECK_STRUCT(" + cpp2PlaceInfoGetRValue(aref, ctx) + 
				"," + i2s(size) + ",\"" + ctx.env.vname + "\");"
			);
			lm = cpp2ContextLocalMeta(ctx, aref);
			lm.tag ::= Cpp2TStruct();
			lm.struct_size ::= size;
		}
		false
	}
}

cpp2WriterVerifyStructId(writer : Cpp2Writer, aref : Cpp2PlaceInfo, id : int, ctx : Cpp2Context) -> bool {
	if (aref.meta.tag == Cpp2TStruct() && aref.meta.struct_id == id) true else {
		if (aref.meta.tag != Cpp2TNull() && aref.meta.tag != Cpp2TStruct()) {
			cpp2_error("Cannot verify struct - already " + cpp2TagToString(aref.meta.tag));
		} else {
			cpp2ContextWr(ctx, 
				"CHECK_STRUCT_TYPE(" + cpp2PlaceInfoGetRValue(aref, ctx) 
				+ "," + i2s(id) + ",\"" + ctx.env.vname + "\");"
			);
			lm = cpp2ContextLocalMeta(ctx, aref);
			lm.tag ::= Cpp2TStruct();
			lm.struct_size ::= length(writer.struct_list[id].args);
			lm.struct_id ::= id;
		}
		false
	}
}

cpp2WriterFindFieldIndex(writer : Cpp2Writer, aref : Cpp2PlaceInfo, name : string, ctx : Cpp2Context) -> string {
	cpp2WriterVerifyStruct(aref, 1, ctx);
	ivar = "fidx_" + i2s(aref.uid) + "_" + name;
	if (!contains(aref.meta.known_fields, name)) {
		cpp2ContextRegisterIdxVar(ctx, ivar, "int");

		fidx = cpp2WriterGetFieldLookupId(writer, name);
		cpp2ContextWr(ctx, 
			"FIND_STRUCT_FIELD(" + ivar+ "," + cpp2PlaceInfoGetRValue(aref, ctx) + "," + i2s(fidx) + 
			",\"" + name + "\",\"" + ctx.env.vname + "\");");

		lm = cpp2ContextLocalMeta(ctx, aref);
		lm.known_fields ::= concat(lm.known_fields, [name]);
	}
	ivar
}

cpp2WriterGetAddrPair(aref : Cpp2PlaceInfo, tag : Cpp2TagType, ctx : Cpp2Context) -> string {
	cpp2WriterVerifyTag(aref, tag, ctx);
	lv = cpp2PlaceInfoGetRawField(aref, ctx, tag);
	if (lv != "") {
		lv + ".addr," + lv + ".size";
	} else {
		lrv = cpp2PlaceInfoGetRValue(aref, ctx);
		lrv + ".PtrValue," + lrv + ".IntValue2";
	}
}

cpp2WriterEmitLambdaCode(writer : Cpp2Writer, env : Cpp2Environment, file : string) -> void {
	refArrayPush(writer.method_names, env.mname);
	out_lines = ref makeList();
	switch (env.closure) {
		Some(closure): {
			mask = fold(closure.type.atypes, "", \acc, t -> 
				acc + cpp2StructFieldCode(t) + ";"
			);
			switch (lookupTree(writer.closure_structs, mask)) {
				Some(cs): {
					rlistPush(out_lines, "\ntypedef flowgen_native_program::FS_" + cs.struct_name + " FS_" + closure.type.struct_name + ";");
					closure.type ::= cs;
				}
				None(): {
					writer.closure_structs ::= setTree(writer.closure_structs, mask, closure.type);
					cs = closure.type;
					cs.id ::= length(^(writer.structs_order));
					oinfo = Cpp2StructOrderInfo(
						cs.id, // compare_idx
						cs.struct_name, // name
						cs.args // args
					);
					refArrayPush(writer.structs_order, oinfo);
					cpp2GenerateStructCode(writer, oinfo, cs);
				}
			}
		}
		None(): { }
	}
	rlistPush(out_lines, "\nStackSlot flowgen_" + writer.config.entry + "::" + env.mname + "(RUNNER_ARGS) {");
	if (env.nlocals > 0 || env.ntemps > 0) {
		rlistPush(out_lines, "    RUNNER_DefSlotArray(locals, " + i2s(env.nlocals) + "+" + i2s(env.ntemps) + ");");
		if (env.ntemps > 0) {
			rlistPush(out_lines, "    StackSlot *const temps = locals+" + i2s(env.nlocals) + ";");
		}
	}
	if (env.tail_call) {
		rlistPush(out_lines, "tail_call:");
	}
	rlistPush(out_lines, rtrim2(cpp2CodeLinesToCode(env.code_lines), "\n"));
	rlistPush(out_lines, "}");
	cpp2AddLines(writer, list2array(^out_lines), file);
}


cpp2WriterResolveLocalName(env : Cpp2Environment, name : string) -> Maybe<Cpp2PlaceInfo> {
	switch (lookupTree(env.locals, name)) {
		Some(binding): Some(binding);
		None(): {
			switch (env.parent) {
				Some(parent): {
					switch (cpp2WriterResolveLocalName(parent, name)) {
						Some(free): Some(cpp2EnvironmentMkupvalue(env, name, free));
						None(): None();
					}
				}
				None(): None();
			}
		}
	}
}

cpp2WriterResolveName(writer : Cpp2Writer, ctx : Cpp2Context, name : string) -> Cpp2PlaceInfo {
	switch (cpp2WriterResolveLocalName(ctx.env, name)) {
		Some(local): local;
		None(): {
			switch (lookupTree(writer.global_map, name)) {
				Some(global): global;
				None(): {
					cpp2_error("Unknown variable: " + name);
					dummyCpp2PlaceInfo;
				}
			}
		}
	}
}

cpp2WriterReifyStub(writer : Cpp2Writer, aref : Cpp2PlaceInfo, code : FiExp) -> void {
	switch (aref.place) {
		Cpp2GlobalFunction(nargs, native): {
			aref.slot ::= length(^(writer.function_table));
			refArrayPush(writer.function_table,
				Cpp2FunctionDescr(aref.name, "", nargs, cpp2FnMethodName(aref.name))
			);
		}
		Cpp2Struct(info): {
			cpp2_error("Cannot use struct here: " + prettyFiExp(dummyPretty, code));
		}
		default: {
			cpp2_error("Cannot reify stub: " + prettyFiExp(dummyPretty, code));
		}
	}
}

cpp2WriterWriteFlowTypeCode(writer : Cpp2Writer, t : FiTypeNullable) -> void {
	switch (t) {
		FiTypeVoid():   refArrayPush(writer.struct_code.field_types, cpp2_CVoid);
		FiTypeBool():   refArrayPush(writer.struct_code.field_types, cpp2_CBool);
		FiTypeInt():    refArrayPush(writer.struct_code.field_types, cpp2_CInt);
		FiTypeDouble(): refArrayPush(writer.struct_code.field_types, cpp2_CDouble);
		FiTypeString(): refArrayPush(writer.struct_code.field_types, cpp2_CString);
		FiTypeArray(type): {
			if (writer.config.extStructDefs) {
					refArrayPush(writer.struct_code.field_types, cpp2_CTypedArray); 
					cpp2WriterWriteFlowTypeCode(writer, type);
			} else {
				refArrayPush(writer.struct_code.field_types, cpp2_CArray);
			}
		}
		FiTypeName(name, args): {
			refArrayPush(writer.struct_code.field_types, cpp2_CStruct);
		}
		FiTypeRef(type): {
			if (writer.config.extStructDefs) {
				refArrayPush(writer.struct_code.field_types, cpp2_CTypedRefTo);
				cpp2WriterWriteFlowTypeCode(writer, type);
			} else {
				refArrayPush(writer.struct_code.field_types, cpp2_CRefTo);
			}
		}
		FiTypeNull(): {
			cpp2_error("type must not be null");
		}
		default: {
			refArrayPush(writer.struct_code.field_types, cpp2_CFlow); // Flow
		}
	}
}

cpp2WriterGetFieldLookupId(writer : Cpp2Writer, n : string) -> int {
	switch (lookupTree(writer.field_index_map, n)) {
		Some(fidx): fidx;
		None(): {
			if (length(writer.struct_counts) <= 1) {
				cpp2_error("Cannot access field " + n + " - no structs have fields!")
			}
			table = ref [];
			fori(0, writer.struct_counts[1] - 1, 
				\i -> {
					args = ^(writer.structs_order)[i].args;
					found = foldi(args, -1, \j, ac, arg -> 
						if (ac != -1 || arg.name != n) ac else j
					);
					refArrayPush(table, found)
				}
			);
			fidx = length(^(writer.field_index_table));
			refArrayPush(writer.field_index_table, ^table);
			refArrayPush(writer.field_index_list, n);
			writer.field_index_map ::= setTree(writer.field_index_map, n, fidx);
			fidx
		}
	}
}

cpp2WriterFieldIndex(writer : Cpp2Writer, type : FiTypeNullable, field_name : string) -> int {
	err = \-> {
		cpp2_error("Can not find the field " + field_name + " in type " + prettyFiTypeNullable(type));
		0
	};
	switch (type) {
		FiTypeName(type_name, __): {
			switch (lookupTree(writer.program.names.structs, type_name)) {
				Some(struct): {
					switch (findi(struct.args, \arg -> arg.name == field_name)) {
						Some(ind): ind;
						None(): err();
					}
				}
				None(): err();
			}
		}
		default: err();
	}
}

cpp2WriterStructTypeId(writer : Cpp2Writer, type : FiTypeNullable) -> int {
	err = \-> {
		cpp2_error("Not a struct: " + prettyFiTypeNullable(type));
		0
	};
	switch (type) {
		FiTypeName(name, __): {
			switch (lookupTree(writer.structs, name)) {
				Some(s): s.id;
				None(): err();
			}
		}
		default: err();
	}
}

cpp2WriterStructTypeSize(writer : Cpp2Writer, type : FiTypeNullable) -> int {
	err = \-> {
		cpp2_error("Not a struct: " + prettyFiTypeNullable(type));
		0
	};
	switch (type) {
		FiTypeName(type_name, __): {
			switch (lookupTree(writer.program.names.structs, type_name)) {
				Some(struct): length(struct.args);
				None(): err();
			}
		}
		default: err();
	}
}

cpp2WriterGetOutputPlace(out : Cpp2OutputLocation, top : Cpp2StackTop) -> Maybe<Cpp2PlaceInfo> { // ?top : 
	switch (out) {
		Cpp2OutputVar(place): {
			if (place.place == Cpp2Temporary() && place.slot >= top.temp) {
				top.temp ::= place.slot + 1;
			}
			Some(place)
		}
		default: None();
	}
}

cpp2WriterGetOutputOrTemp(ctx : Cpp2Context, out : Cpp2OutputLocation, top : Cpp2StackTop) -> Cpp2PlaceInfo {
	switch (cpp2WriterGetOutputPlace(out, top)) {
		Some(tmp): tmp;
		None(): {
			tmp = cpp2EnvironmentMktemp(ctx.env, top.temp);
			top.temp ::= top.temp + 1;
			tmp
		}
	}
}

cpp2WriterEvalToTmp(writer : Cpp2Writer, arg : FiExp, ctx : Cpp2Context, top : Cpp2StackTop, out : Cpp2OutputLocation) -> Cpp2PlaceInfo { // out : Null<Cpp2OutputLocation> = null
	atmp = cpp2Mktop(top);
	tmp = cpp2WriterGetOutputOrTemp(ctx, out, top);
	cpp2WriterCompileExpression(writer, arg, ctx, Cpp2OutputVar(tmp), atmp);
	tmp
}

cpp2WriterFetchToRef(writer : Cpp2Writer, arg : FiExp, ctx : Cpp2Context, top : Cpp2StackTop, lvalue : bool, out : Cpp2OutputLocation) -> Cpp2PlaceInfo {
	switch (cpp2WriterGetValueRef(writer, arg, ctx, lvalue)) {
		Some(aref): aref;
		None(): cpp2WriterEvalToTmp(writer, arg, ctx, top, out);
	}
}

cpp2WriterFetchToScalar(writer : Cpp2Writer, arg : FiExp, ctx : Cpp2Context, top : Cpp2StackTop, tag : Cpp2TagType) -> string {
	tmp = cpp2ContextTempvar(ctx, "xtmp", tag, "");
	cpp2WriterCompileExpression(writer, arg, ctx, Cpp2OutputScalar(tmp, tag), cpp2Mktop(top));
	tmp
}

Cpp2FieldInfo(
	index : int, 
	minsize : int, 
	stype : int
);

cpp2WriterFieldSetInfo(writer : Cpp2Writer, call : FiExp, aref : Cpp2PlaceInfo, name : string) -> Cpp2FieldInfo {
	if (aref.meta.struct_id != cpp2_int_UNDEF && aref.meta.struct_id != -1) {
		info = ^(writer.structs_order)[aref.meta.struct_id];
		index = switch (findi(info.args, \arg -> arg.name == name)) {
			Some(i): i; 
			None(): {
				cpp2_error("No field " + name + " in struct " + info.name);
				cpp2_int_UNDEF
			}
		}
		Cpp2FieldInfo(index, length(info.args), aref.meta.struct_id)
	} else {
		field_type = fiExpType(call);
		switch (field_type ) {
			FiTypeName(type_name, __): {
				switch (lookupTree(writer.program.names.structs, type_name)) {
					Some(struct): {
						minsize = length(struct.args);
						index = cpp2WriterFieldIndex(writer, field_type , name);
						stype = lookupTreeDef(writer.structs, struct.name, dummyCpp2StructInfo).id;
						Cpp2FieldInfo(index, minsize, stype)
					}
					None(): {
						if (containsKeyTree(writer.program.names.unions, type_name)) {
							structs = fiUnion2typenames(writer.program, type_name);
							foldi(structs, Pair(Cpp2FieldInfo(cpp2_int_UNDEF, 0, cpp2_int_UNDEF), true),
								\i, acc, tn -> {
									if (!acc.second) acc else {
										new_minsize = cpp2WriterStructTypeSize(writer, tn);
										new_stype = if (acc.first.stype == cpp2_int_UNDEF) cpp2WriterStructTypeId(writer, tn) else acc.first.stype;
										new_index = cpp2WriterFieldIndex(writer, tn, name); 
										ok = (acc.first.index == cpp2_int_UNDEF || new_index == acc.first.index);
										Pair(
											if (!ok) Cpp2FieldInfo(cpp2_int_UNDEF, cpp2_int_UNDEF, cpp2_int_UNDEF) else 
												Cpp2FieldInfo(
													new_index, 
													if (i == 0 || new_minsize < acc.first.minsize) new_minsize else acc.first.minsize, 
													if (i == 0) new_stype else cpp2_int_UNDEF
												)
											, ok
										);
									}
								}
							).first
						} else {
							cpp2_error(type_name + " must be a struct or union");
							Cpp2FieldInfo(cpp2_int_UNDEF, cpp2_int_UNDEF, cpp2_int_UNDEF)
						}
					}
				}
			}
			FiTypeFlow(): Cpp2FieldInfo(cpp2_int_UNDEF, cpp2_int_UNDEF, cpp2_int_UNDEF);
			default: {
				cpp2_error(prettyFiType(dummyPretty, field_type, makeSet()) + " must be a struct or union");
				Cpp2FieldInfo(cpp2_int_UNDEF, cpp2_int_UNDEF, cpp2_int_UNDEF)
			}
		}
	}
}

cpp2WriterCompileConstructor(writer : Cpp2Writer, args : [FiExp], ctx : Cpp2Context, out : Cpp2OutputLocation, top : Cpp2StackTop, tag : Cpp2TagType, expr_cb : (int, string) -> string, zero_allocs : bool) -> Maybe<Cpp2PlaceInfo> {
	csize = length(args);
	if (csize == 0) {
		cpp2WriterEmitValue(ctx, out, expr_cb(0, "NULL"), tag, false, zero_allocs, zero_allocs);
	} else {
		refs : [Maybe<Cpp2PlaceInfo>] = ^(fold(args, ref [], \acc, arg -> {
				refArrayPush(acc, cpp2WriterGetValueRef(writer, arg, ctx, false)); acc
			}
		));
		fast = foldi(refs, true, \i, acc, mref -> {
				if (!acc) acc else {
					switch (mref) {
						Some(aref): {
							if (cpp2PlaceInfoIsLValue(aref)) {
								if (i == 0) true else {
									switch (refs[i - 1]) {
										Some(ref1): {
											aref.place == ref1.place && aref.slot == aref.slot + 1
										}
										None(): false;
									}
								}
							} else {
								false
							}
						}
						None(): false;
					}
				}
			}
		);
		if (fast) {
			switch (refs[0]) {
				Some(aref): {
					place = cpp2PlaceInfoGetLValue(aref);
					cpp2WriterEmitValue(ctx, out, expr_cb(csize, "&" + place), tag, false, true, true)
				}
				None(): {
					cpp2_error("must not happen");
					None()
				}
			}
		} else if (csize <= 20) {
			start = top.temp;
			fori(0, csize - 1,
				\i -> {
					atop = cpp2Mktop(top);
					top_temp = top.temp;
					top.temp ::= top_temp + 1;
					tmp = cpp2EnvironmentMktemp(ctx.env, top_temp);
					cpp2WriterCompileExpression(writer, args[i], ctx, Cpp2OutputVar(tmp), atop);
				}
			);
			place = "temps[" + i2s(start) + "]";
			cpp2WriterEmitValue(ctx, out, expr_cb(csize, "&" + place), tag, false, true, true)
		} else {
			// If a constructor is too long, instead of declaring lots of
			// temporaries, allocate an empty array and fill it destructively.
			top_temp = top.temp;
			top.temp ::= top_temp + 1;
			tmp = cpp2EnvironmentMktemp(ctx.env, top_temp);
			tstr = cpp2PlaceInfoGetLValue(tmp);
			cpp2ContextWrCheck(ctx, tstr + " = " + expr_cb(csize, "NULL"), true);
			(tmp.meta).tag ::= tag;
			fori(0, csize - 1, 
				\i -> {
					cpp2WriterCompileExpression(
						writer,
						args[i], ctx, 
						Cpp2OutputExpr(\ictx, aexpr ->
							"RUNNER->SetArraySlot(" + tstr + "," + i2s(i) + "," + aexpr + ")"
						), 
						cpp2Mktop(top)
					);
				}
			);
			cpp2WriterCopyValue(ctx, out, tmp);
		};
	}
}

cpp2WriterCompileNewStruct(writer : Cpp2Writer, info : Cpp2StructInfo, args : [FiExp], ctx : Cpp2Context, out : Cpp2OutputLocation, top : Cpp2StackTop, closure : string) -> Maybe<Cpp2PlaceInfo> {
	if (length(info.args) != length(args)) {
		cpp2_error("Invalid struct field count");
		None(); //dummyCpp2PlaceInfo
	} else {
		if (length(args) == 0) {
			space_info = lookupTreeDef(writer.global_map, info.struct_name, dummyCpp2PlaceInfo);
			if (space_info == dummyCpp2PlaceInfo) {
				cpp2_error("space info not found for struct: " + info.struct_name)
			}
			cpp2WriterCopyValue(ctx, out, space_info);
		} else {
			otmp = cpp2WriterGetOutputOrTemp(ctx, out, top);
			sout = cpp2PlaceInfoGetLValue(otmp);

			rrefs = ref [];
			rvals = ref [];
			fori(0, length(args) - 1, 
				\i -> {
					tt = info.atypes[i];
					if (tt == Cpp2TDouble() || tt == Cpp2TInt()) {
						refArrayPush(rrefs, None());
						refArrayPush(rvals, Some(cpp2WriterEmitNumericExpr(writer, args[i], ctx, top, tt)));
					} else if (tt == Cpp2TBool()) {
						refArrayPush(rrefs, None());
						refArrayPush(rvals, Some(cpp2WriterEmitConditionExpr(writer, args[i], ctx, top)));
					} else {
						aref = cpp2WriterFetchToRef(writer, args[i], ctx, top, false, Cpp2OutputNull());
						refArrayPush(rrefs, Some(aref));
						refArrayPush(rvals, None());
						if (info.atypes[i] != Cpp2TNull()) {
							cpp2WriterVerifyTag(aref, info.atypes[i], ctx);
							{}
						}
					}
				}
			);
			refs : [Maybe<Cpp2PlaceInfo>] = ^rrefs;
			vals : [Maybe<string>] = ^rvals;
			ptr = cpp2ContextGetStructPtr(ctx, otmp, info.struct_name, false);

			if (closure != "") {
				cpp2ContextWrCheck(ctx, ptr + " = RUNNER->AllocateRawClosure<FS_" + info.struct_name + ">(&" + sout + "," + i2s(info.id) + "," + closure + ".slot_private.IntValue)", true);
				lm = cpp2ContextLocalMeta(ctx, otmp);
				lm.tag ::= Cpp2TNativeFn();
			} else {
				cpp2ContextWrCheck(ctx, ptr + " = RUNNER->AllocateRawStruct<FS_" + info.struct_name + ">(&" + sout + "," + i2s(info.id) + ")", true);

				lm = cpp2ContextLocalMeta(ctx, otmp);
				lm.tag ::= Cpp2TStruct();
				lm.struct_id ::= info.id;
				lm.struct_size ::= length(args);
			}

			fori(0, length(args) - 1, 
				\i -> {
					fname = ptr + "->fl_" + info.args[i].name;
					switch (vals[i]) {
						Some(val): 
							cpp2ContextWrSemi(ctx, fname + " = " + val);
						None(): {
							switch (refs[i]) {
								Some(aref): {
									if (info.atypes[i] == Cpp2TStruct()) {
										cpp2ContextWrSemi(ctx, fname + " = " + cpp2PlaceInfoGetStructAddr(aref, ctx));
									} else {
										switch (aref.place) {
											Cpp2FieldAlias(where, sinfo): {
												if (sinfo.atypes[aref.slot] == info.atypes[i]) {
													cpp2ContextWrSemi(ctx, fname + " = " + cpp2ContextGetStructPtr(ctx, where, sinfo.struct_name, true) + "->fl_" + sinfo.args[aref.slot].name);
												} else {
													cpp2ContextWrSemi(ctx, "flow_struct::set_" + cpp2StructFieldCode(info.atypes[i]) + "(" + fname + "," + cpp2PlaceInfoGetRValue(aref, ctx) + ")");
												}
											}
											default: { 
												cpp2ContextWrSemi(ctx, "flow_struct::set_" + cpp2StructFieldCode(info.atypes[i]) + "(" + fname + "," + cpp2PlaceInfoGetRValue(aref, ctx) + ")");
											}
										}
									}
								}
								None(): {
									cpp2_error("must not happen");
								}
							}
						}
					}
				}
			);
			cpp2WriterCopyValue(ctx, out, otmp);
		}
	}
}

cpp2WriterCallNativeName(writer : Cpp2Writer, fn : FiExp, ctx : Cpp2Context) -> string {
	switch (fn) {
		FiVar(n, type, pos): {
			aref = cpp2WriterResolveName(writer, ctx, n);
			switch (aref.place) {
				Cpp2GlobalFunction(nargs, native): native;
				default: "";
			}
		}
		default: "";
	}
}

cpp2WriterCompileCall(writer : Cpp2Writer, code : FiCall, ctx : Cpp2Context, out : Cpp2OutputLocation, top : Cpp2StackTop) -> Maybe<Cpp2PlaceInfo> {
	direct_call = ref "";
	allocs = ref true;

	proceed = \ -> {
		// Allocate an output lvalue if necessary
		out_ref = if (out == Cpp2OutputReturn() || out == Cpp2OutputNone()) {
			None();
		} else {
			Some(cpp2WriterGetOutputOrTemp(ctx, out, top));
		}

		// Compute index of the start of arguments. Allow the
		// function reference intersect with the output slot,
		// but not the actual arguments.
		aidx = if (^direct_call == "") {
			switch (out_ref) {
				Some(or): {
					if (or.place == Cpp2Temporary() && or.slot == top.temp - 1) {
						or.slot
					} else {
						ret = top.temp;
						top.temp ::= ret + 1;
						ret
					}
				}
				None(): {
					ret = top.temp;
					top.temp ::= ret + 1;
					ret
				}
			}
		} else {
			top.temp
		}

		iter(code.args, 
			\arg -> {
				ctop = cpp2Mktop(top);
				tmp = cpp2EnvironmentMktemp(ctx.env, top.temp);
				top.temp ::= top.temp + 1;
				cpp2WriterCompileExpression(writer, arg, ctx, Cpp2OutputVar(tmp), ctop);
			}
		);

		expr = if (^direct_call == "") {
			ftmp = cpp2EnvironmentMktemp(ctx.env, aidx);
			cpp2WriterCompileExpression(writer, code.f, ctx, Cpp2OutputVar(ftmp), cpp2Mktop(top));
			"RUNNER->FastEvalFunction(&temps[" + i2s(aidx) + "], " + i2s(length(code.args)) + ")";
		} else {
			if (length(code.args) > 0) {
				^direct_call + "(RUNNER, &temps[" + i2s(aidx) + "])";
			} else {
				^direct_call + "(RUNNER, NULL)";
			}
		}

		switch (out_ref) {
			Some(or): {
				cpp2ContextWrCheck(ctx, "CALL_WITH_RETSLOT(" + cpp2PlaceInfoGetLValue(or) + "," + expr + ")", ^allocs);
				cpp2WriterCopyValue(ctx, out, or);
			}
			None(): cpp2WriterEmitValue(ctx, out, expr, Cpp2TNull(), true, true, ^allocs);
		}
	}

	switch (code.f) {
		FiVar(n, type, pos): {
			switch (cpp2WriterResolveName(writer, ctx, n).place) {
				Cpp2GlobalFunction(nargs, native): {
					if (length(code.args) != nargs) {
						cpp2_error("Argument count mismatch in call to " + n);
					}
					if (n == writer.cur_global) {
						if (ctx.env.parent == None() && out == Cpp2OutputReturn()) {
							(ctx.env).tail_call ::= true;
							// first compute new arguments
							arefs = ref [];
							avals = ref [];
							iteri(code.args, 
								\i, arg -> {
									try_sval = \ -> {
										sval = cpp2WriterEmitPrimitiveWrap(writer, arg, ctx, top);
										if (sval == "") {
											Pair(Some(cpp2WriterEvalToTmp(writer, arg, ctx, top, out)), None());
										} else {
											Pair(None(), Some(sval)); 
										}
									}
									pair = switch (cpp2WriterGetValueRef(writer, arg, ctx, false)) {
										Some(r): {
											if (r.place == Cpp2Argument() && r.slot < i) {
												try_sval();
											} else {
												Pair(Some(r), None());
											}
										}
										None(): try_sval();
									}
									refArrayPush(arefs, pair.first);
									refArrayPush(avals, pair.second);
								}
							);
							// now compute strings, so that struct pointers get computed
							astrings = ref [];
							fori(0, length(code.args) - 1, \i -> {
									switch ((^avals)[i]) {
										Some(aval): refArrayPush(astrings, aval);
										None(): 
											switch ((^arefs)[i]) {
												Some(aref): refArrayPush(astrings, cpp2PlaceInfoGetRValue(aref, ctx));
												None(): cpp2_error("must not happen");
											}
									}
								}
							);
							// finally assign
							fori(0, length(code.args) - 1, 
								\i -> {
									switch ((^arefs)[i]) {
										Some(aref): {
											if (aref.place != Cpp2Argument() || aref.slot != i) {
												cpp2ContextWrSemi(ctx, cpp2WriterAssignExpr("RUNNER_ARG(" + i2s(i) + ")", (^astrings)[i], false));
											}
										}
										None():
											cpp2ContextWrSemi(ctx, cpp2WriterAssignExpr("RUNNER_ARG(" + i2s(i) + ")", (^astrings)[i], false));
									}
								}
							);
							// and jump
							cpp2ContextWrSemi(ctx, "goto tail_call");
							None();
						} else {
							// allow even if optional native
							direct_call := cpp2FnMethodName(n);
							proceed();
						}
					} else if (native == "") {
						direct_call := cpp2FnMethodName(n);
						proceed();
					} else {
						rnative = lookupTreeDef(writer.known_natives, native, dummyCpp2NativeDescr);
						if (rnative.name != "" && rnative.nargs == nargs) {
							if (cpp2WriterInlineNative(writer, code, native, ctx, out, top)) {
								None();
							} else {
								direct_call := "ByteCodeRunner::" + rnative.cname;
								if (rnative.noalloc) {
									allocs := false;
								}
								proceed();
							}
						} else {
							proceed();
						}
					}
				}
				Cpp2Struct(info): {
					if (length(info.args) != length(code.args)) {
						cpp2_error("Wrong argument count for struct " + info.struct_name);
					}
					cpp2WriterCompileNewStruct(writer, info, code.args, ctx, out, top, "");
					None();
				}
				default: proceed();
			}
		}
		default: proceed();
	}
}

numeric_natives = ["Native.length", "Native.strlen", "Native.bitXor", "Native.bitOr", "Native.bitAnd", "Native.bitNot"];

cpp2WriterInlineNative(writer : Cpp2Writer, code : FiCall, fn : string, ctx : Cpp2Context, out : Cpp2OutputLocation, top : Cpp2StackTop) -> bool {
	eval_tmp = \arg, allow_out -> {
		cpp2WriterEvalToTmp(writer, arg, ctx, top, if (allow_out) out else Cpp2OutputNull());
	}
	fetch_ref = \arg, lvalue, allow_out -> {
		cpp2WriterFetchToRef(writer, arg, ctx, top, lvalue, if (allow_out) out else Cpp2OutputNull());
	}
	if (contains(numeric_natives, fn)) {
		cpp2WriterCompileNumericExpr(writer, code, ctx, out, top, Cpp2TInt());
		true
	} else if (fn == "Native.substring") {
		str = eval_tmp(code.args[0], true);
		cpp2WriterVerifyTag(str, Cpp2TString(), ctx);
		idx = cpp2WriterEmitNumericExpr(writer, code.args[1], ctx, top, Cpp2TInt());
		len = cpp2WriterEmitNumericExpr(writer, code.args[2], ctx, top, Cpp2TInt());
		cpp2ContextWrSemi(ctx, "if (unlikely(!RUNNER->DoSubstring(&" + cpp2PlaceInfoGetLValue(str) + "," + idx + "," + len + "))) RETVOID");
		cpp2WriterCopyValue(ctx, out, str);
		true
	} else if (fn == "Native.map") {
		switch (code.args[1]) {
			FiLambda(args, body, type, __):
				if (length(args) != 1) {
					false 
				} else {
					cpp2WriterInlineMapNative(writer, code.args[0], None(), "", "", args[0].name, body, ctx, out, top, false);
					true;
				}
			default: false;
		}
	} else if (fn == "Native.mapi") {
		switch (code.args[1]) {
			FiLambda(args, body, type, __):
				if (length(args) != 2) {
					false;
				} else {
					cpp2WriterInlineMapNative(writer, code.args[0], None(), args[0].name, "", args[1].name, body, ctx, out, top, false);
					true;
				}
			default: false;
		}
	} else if (fn == "Native.iter") {
		switch (code.args[1]) {
			FiLambda(args, body, type, __):
				if (length(args) != 1) {
					false;
				} else {
					cpp2WriterInlineMapNative(writer, code.args[0], None(), "", "", args[0].name, body, ctx, out, top, true);
					true;
				}
			default: false;
		}
	} else if (fn == "Native.iteri") {
		switch (code.args[1]) {
			FiLambda(args, body, type, __):
				if (length(args) != 2) {
					false;
				} else {
					cpp2WriterInlineMapNative(writer, code.args[0], None(), args[0].name, "", args[1].name, body, ctx, out, top, true);
					true;
				}
			default: false;
		}
	} else if (fn == "Native.fold") {
		switch (code.args[2]) {
			FiLambda(args, body, type, __):
				if (length(args) != 2) {
					false;
				} else {
					cpp2WriterInlineMapNative(writer, code.args[0], Some(code.args[1]), "", args[0].name, args[1].name, body, ctx, out, top, false);
					true;
				}
			default: false;
		}
	} else if (fn == "Native.foldi") {
		switch (code.args[2]) {
			FiLambda(args, body, type, __):
				if (length(args) != 3) {
					false;
				} else {
					cpp2WriterInlineMapNative(writer, code.args[0], Some(code.args[1]), args[0].name, args[1].name, args[2].name, body, ctx, out, top, false);
					true;
				}
			default: false;
		}
	} else {
		false;
	}
}

cpp2WriterInlineMapNative(writer : Cpp2Writer, arr : FiExp, minit : Maybe<FiExp>, iarg : string, farg : string, varg : string, body : FiExp, ctx : Cpp2Context, out : Cpp2OutputLocation, top : Cpp2StackTop, iter0 : bool) -> Maybe<Cpp2PlaceInfo> {
	iter1 = if (out == Cpp2OutputNone()) true else iter0;
	rvpair0 = if (!iter1 && farg == "") {
		rv = cpp2WriterGetOutputOrTemp(ctx, out, top);
		rvs = cpp2PlaceInfoGetLValue(rv);
		Pair(rv, rvs);
	} else {
		Pair(dummyCpp2PlaceInfo, "");
	}
	iv = cpp2WriterFetchToRef(writer, arr, ctx, top, true, Cpp2OutputNull());
	ivs = cpp2PlaceInfoGetLValue(iv);
	cpp2WriterVerifyTag(iv, Cpp2TArray(), ctx);

	arrsize = cpp2ContextTempvar(ctx, "isz", Cpp2TInt(), "RUNNER->GetArraySize(" + ivs + ")");

	rvpair = switch (minit) {
		Some(init): {
			// fold init value
			rv = cpp2WriterEvalToTmp(writer, init, ctx, top, Cpp2OutputNull());
			rvs = cpp2PlaceInfoGetLValue(rv);

			rv.name ::= farg;
			// Invalidate cached type info
			cpp2ClearMeta(cpp2ContextLocalMeta(ctx, rv));
			Pair(Some(rv), rvs)
		}
		None(): {
			if (!iter1) {
				rv = rvpair0.first;
				rvs = rvpair0.second;
				cpp2ContextWrCheck(ctx, cpp2WriterAssignExpr(rvs, "RUNNER->AllocateArray(" + arrsize + ")", true), true);
				(cpp2ContextLocalMeta(ctx, rv)).tag ::= Cpp2TArray();
				Pair(Some(rv), rvs)
			} else {
				Pair(None(), "");
			}
		}
	}
	rv = rvpair.first;
	rvs = rvpair.second;
	subtop = cpp2Mktop(top);

	// Index var as slot if used in closure
	idxpair = if (iarg != "") {
		subtop_temp = subtop.temp;
		subtop.temp ::= subtop_temp + 1;
		idx = cpp2EnvironmentMktemp(ctx.env, subtop_temp);
		cpp2ContextWrSemi(ctx, "StackSlot::SetInt(" + cpp2PlaceInfoGetLValue(idx) + ",0)");
		idx.name ::= iarg;
		(cpp2ContextLocalMeta(ctx, idx)).tag ::= Cpp2TInt();
		Pair(Some(idx), cpp2PlaceInfoGetLValue(idx) + ".slot_private.IntValue")
	} else {
		Pair(None(), cpp2ContextTempvar(ctx, "i", Cpp2TInt(), "0"))
	}
	idx = idxpair.first;
	idxvar = idxpair.second;

	// Invalidate all pointer caches
	cpp2ContextIncGc(ctx);
	cpp2ContextWr(ctx, "for (; " + idxvar + " < " + arrsize + "; " + idxvar + "++) {");
	subctx = cpp2ContextEnter(ctx, "    ");
	if (iarg != "") {
		switch (idx) {
			Some(id): cpp2ContextPushdef(subctx, id);
			None(): cpp2_error("impossible");
		}
	}
	if (farg != "") {
		switch (rv) {
			Some(r): cpp2ContextPushdef(subctx, r);
			None(): cpp2_error("impossible");
		}
	}
	cpp2ContextPushdef(subctx, cpp2PlaceInfo(Some(ctx.env), Cpp2SlotAlias(iv, idxvar), 0, varg));

	// Emit body
	if (farg != "") {
		cpp2WriterCompileExpression(writer, body, subctx, 
			Cpp2OutputExpr(\__, val -> if (val == rvs) "/*NOP*/" else cpp2WriterAssignExpr(rvs, val, false)), 
			subtop
		);
	} else if (iter1) {
		cpp2WriterCompileExpression(writer, body, subctx, Cpp2OutputNone(), subtop);
	} else {
		cpp2WriterCompileExpression(writer, body, subctx, 
			Cpp2OutputExpr(\__, val -> "RUNNER->SetArraySlot(" + rvs + "," + idxvar + "," + val + ")"), 
			subtop
		);
	}

	cpp2ContextExit(subctx);
	cpp2ContextWr(ctx, "}");
	cpp2ContextJoinOne(ctx, subctx);

	if (iter1) {
		cpp2WriterEmitValue(ctx, out, "FLOWVOID", Cpp2TNull(), false, false, false);
	} else {
		switch (rv) {
			Some(r): cpp2WriterCopyValue(ctx, out, r);
			None(): {
				cpp2_error("impossible");
				None();
			}
		}
	}
}

cpp2WriterCompileClosure(writer : Cpp2Writer, code : FiLambda, ctx : Cpp2Context, out : Cpp2OutputLocation, top : Cpp2StackTop) -> Maybe<Cpp2PlaceInfo> {
	id = writer.next_closure_id;
	writer.next_closure_id ::= id + 1;
	cenv = cpp2WriterCompileLambda(writer, writer.cur_global, id, code, Some(ctx.env));
	fidx = length(^(writer.function_table));

	refArrayPush(writer.function_table, Cpp2FunctionDescr(cenv.vname, "", cenv.nargs, cenv.mname));

	fslot = "getSelf(RUNNER)->functions[" + i2s(fidx) + "/*" + cenv.vname + "*/]";
	csize = length(cenv.upvalues);

	if (csize == 0) {
		cpp2WriterEmitValue(ctx, out, fslot, Cpp2TNativeFn(), false, false, false);
	} else {
		args = map(cenv.upvalues, \n -> FiVar(n, FiTypeVoid(), -1)); // TODO: change FiTypeVoid to a proper type
		switch (cenv.closure) {
			Some(closure): cpp2WriterCompileNewStruct(writer, closure.type, args, ctx, out, top, fslot);
			None(): {
				cpp2_error("closure.type must be defined");
				None()
			}
		}
	}
}

