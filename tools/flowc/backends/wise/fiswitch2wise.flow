import tools/flowc/backends/wise/fituple2wise;
import tools/flowc/incremental/fiexp;

export {
	fiSwitch2fiExp(e : FiSwitch, env : WiseAstStructs, tmpIndex : int) -> FiExp;
}

fiSwitch2fiExp(e : FiSwitch, env : WiseAstStructs, tmpIndex : int) -> FiExp {
	structIds = switch (e.switchType : FiType) {
		FiTypeName(name, __) : lookupTreeDef(env.unions, name, []);
		default : [];
	}

	if (structIds == [] || e.cases == []) {
		println("ERROR : union structs are not found. [ " + toString(e) + " ]");
		FiVoid(0);
	} else {
		tmpVar = "_tmp" + i2s(tmpIndex);
		FiSeq([FiInt(0, 0), FiLet(
			tmpVar,
			FiTypeInt(),
			FiCall(
				FiVar("getStructId", FiTypeFunction([FiFunArg("adr", FiTypeInt())], FiTypeInt()), 0),
				[e.x],
				FiTypeInt(),
				0
			),
			fiCases2fiIfs(e.cases, FiVar(tmpVar, FiTypeInt(), 0), e.type, env.unions, env.table),
			e.type,
			0
		)], e.type, 0);
	}
}

// we don't check the correctness of switch. but we could be
// for some reasons, union is already flat (cases don't contain unions)
fiCases2fiIfs(cases: [FiCase], e : FiVar, type : FiType, unions : Tree<string, [int]>, structs : Tree<string, int>) -> FiExp {
	scases = unzip(cases, \c -> c.struct == "default");
	defCases = scases.first;
	defCase = if (defCases == []) fiType2defVal(type) else defCases[0].body;
	cmprExpWithStructIds = \ids : [int] -> if (ids == []) {
		FiBool(false, 0);
	} else if (length(ids) == 1) {
		makeCmpIdFn(e, ids[0]);
	} else {
		makeCmpIdsFn(e, ids, FiBool(false, 0));
	}
	structCases = fold(scases.second, makeTree(), \acc, c -> {
		ids = eitherFn(lookupTree(unions, c.struct), idfn, \-> eitherFn(lookupTree(structs, c.struct), v2a, \-> []));
		setTree(
			acc,
			c.body,
			Pair(
				eitherMap(lookupTree(acc, c.body), \caseInf -> concat(ids, caseInf.first), ids),
				c.argNames
			)
		)
	});
	foldTree(structCases, Pair(defCase, 0), \caseBody, caseInf, acc -> unpair(acc, \caseExps, i -> {
		body = filterUnusedArgs(caseBody, caseInf.second);
		newExp = if (i == 0 && defCases == []) {
			FiSeq([body], type, 0)
		} else {
			FiIf(cmprExpWithStructIds(caseInf.first), body, caseExps, type, 0);
		}
		Pair(newExp, i + 1);
	})).first;
}

filterUnusedArgs(e : FiExp, args : [string]) -> FiExp {
	usedIds = getUsedVars([e], makeSet());
	unusedIds = filter(args, \a -> !containsSet(usedIds, a));
	if (unusedIds == []) e else removeUnusedVars(e, buildSet(unusedIds));
}

getUsedVars(exps : [FiExp], ids : Set<string>) -> Set<string> {
	if (exps == []) {
		ids;
	} else{
		newExps = tail(exps);
		values = switch (exps[0] : FiExp) {
			FiLambda(__, body, __, __): Pair(arrayPush(newExps, body), ids);
			FiCall(f, args, __, __): Pair(concat(arrayPush(newExps, f), args), ids);
			FiVar(name, __, __): Pair(newExps, insertSet(ids, name));
			FiLet(__, __, e1, e2, __, __): Pair(arrayPush(arrayPush(newExps, e1), e2), ids);
			FiIf(e1, e2, e3, __, __): Pair(arrayPush(arrayPush(arrayPush(newExps, e1), e2), e3), ids);
			FiSwitch(x, __, cases, __, __): Pair(concat(arrayPush(newExps, x), map(cases, \c -> c.body)), ids);
			FiCast(e, __, __, __, __): Pair(arrayPush(newExps, e), ids);
			FiSeq(es, __, __): Pair(concat(newExps, es), ids);
			FiCallPrim(__, es, __, __): Pair(concat(newExps, es), ids);
			FiVoid(__): Pair(newExps, ids);
			FiDouble(__, __): Pair(newExps, ids);
			FiInt(__, __): Pair(newExps, ids);
			FiString(__, __): Pair(newExps, ids);
			FiBool(__, __): Pair(newExps, ids);
			FiRequire(__, e, __, __): Pair(arrayPush(newExps, e), ids);
			FiUnsafe(__, e, __, __): Pair(arrayPush(newExps, e), ids);
		}
		getUsedVars(values.first, values.second);
	}
}

removeUnusedVars(expr : FiExp, ids : Set<string>) -> FiExp {
	switch (expr : FiExp) {
		FiLet(name, __, e1, body, __, __): {
			newBody = removeUnusedVars(body, ids);
			if (containsSet(ids, name)) newBody else FiLet(expr with e1 = removeUnusedVars(e1, ids), e2 = newBody);
		}
		FiLambda(__, body, __, __): FiLambda(expr with body = removeUnusedVars(body, ids));
		FiCall(f, args, __, __): FiCall(expr with 
			f = removeUnusedVars(f, ids),
			args = map(args, \e -> removeUnusedVars(e, ids))
		);
		FiVar(__, __, __): expr;
		FiIf(e1, e2, e3, __, __): FiIf(expr with 
			e1 = removeUnusedVars(e1, ids),
			e2 = removeUnusedVars(e2, ids),
			e3 = removeUnusedVars(e3, ids)
		);
		FiSwitch(x, __, cases, __, __): FiSwitch(expr with 
			cases = map(cases, \c -> FiCase(c with body = removeUnusedVars(c.body, ids)))
		);
		FiCast(e, __, __, __, __): FiCast(expr with e = removeUnusedVars(e, ids));
		FiSeq(es, __, __): FiSeq(expr with es = map(es, \e -> removeUnusedVars(e, ids)));
		FiCallPrim(__, es, __, __): FiCallPrim(expr with es = map(es, \e -> removeUnusedVars(e, ids)));
		FiVoid(__): expr;
		FiDouble(__, __): expr;
		FiInt(__, __): expr;
		FiString(__, __): expr;
		FiBool(__, __): expr;
		FiRequire(__, e, __, __): FiRequire(expr with e = removeUnusedVars(e, ids));
		FiUnsafe(__, e, __, __): FiUnsafe(expr with fallback = removeUnusedVars(e, ids));
	}
}

makeCmpIdsFn(e : FiVar, ids : [int], acc : FiExp) -> FiExp {
	if (ids == []) {
		acc;
	} else {
		makeCmpIdsFn(
			e,
			tail(ids),
			FiCallPrim(FcOrPrim(), [acc, makeCmpIdFn(e, ids[0])], FiTypeBool(), 0)
		);
	}
}

makeCmpIdFn(e : FiVar, id : int) -> FiExp {
	FiCallPrim(FcEqPrim(), [e, FiInt(id, 0)], FiTypeBool(), 0);
}

fiType2defVal(type : FiType) -> FiConst {
	switch (type : FiType) {
		FiTypeArray(__) : FiInt(0, 0);
		FiTypeFunction(__, __) : FiInt(0, 0);
		FiTypeRef(__) :FiInt(0, 0);
		FiTypeParameter(__) : FiInt(0, 0);
		FiTypeFlow() : FiVoid(0);
		FiTypeVoid() :  FiVoid(0);
		FiTypeNative() : FiVoid(0);
		FiTypeName(__, __) : FiInt(0, 0);
		FiTypeBool() : FiBool(false, 0);
		FiTypeInt() : FiInt(0, 0);
		FiTypeDouble() : FiDouble(0.0, 0);
		FiTypeString() : FiString("", 0);
	}
}