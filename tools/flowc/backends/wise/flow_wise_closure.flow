import tools/flowc/manipulation/lambda_lifting;
import tools/flowc/backends/wise/fi2wise_utils;
import tools/flowc/backends/wise/fituple2wise;

export {
	// todo: add structures inside the module
	liftWiseClosures(program : FiProgram, fnNames : Set<string>, structs : ref WiseAstStructs, tmpVarCounter : ref int) -> [FiModule];
}

FiWiseClosure(
	structs : Tree<string, Pair<FiTypeStruct, FiTypeStruct>>, // <closureNames.struct - <CapturedVars, CallStruct> >
	fns : [FiFunctionDec],
	names : Tree<string, FcCreateClosurePrim>, // lambdaVarName - closureNames(struct,fn)
);

liftWiseClosures(program : FiProgram, fnNames : Set<string>, structs : ref WiseAstStructs, tmpVarCounter : ref int) -> [FiModule] {
	newProgram = lift_lambdas(program);
	origStructFns = mapTree(program.modules, \m : FiModule -> Pair(
		fold(m.structs, makeSet(), \acc, s -> insertSet(acc, s.name)),
		fold(m.functions, makeSet(), \acc, s -> insertSet(acc, s.name))
	));
	addedClosures = mapTree2(newProgram.modules, \k, m : FiModule -> {
		eitherFn(
			lookupTree(origStructFns, k),
			unpairC(\structNames, __ -> {
				lambdaFns = fold(m.functions, makeTree(), \acc, s -> 
					if (!containsSet(fnNames, s.name)) setTree(acc, closureFnName2closureStructureName(s.name), s) else acc
				);
				serviceField = makeLambdaIndexFieldName();
				sfx = makeLambdaStructCallSfx();
				Pair(
					fold(m.structs, makeTree(), \acc, s -> if (!containsSet(structNames, s.name)) {
						capturedVars = FiTypeStruct(s with args = filter(s.args, \a -> a.name != serviceField));
						setTree(
							acc,
							s.name,
							Pair(
								capturedVars,
								FiTypeStruct(
									capturedVars.name + sfx,
									[],
									[
										FiStructArg("fn", eitherMap(lookupTree(lambdaFns, s.name), \f -> f.type, FiTypeInt()), false),
										FiStructArg("env", FiTypeInt(), false)
									],
									0
								)
							)
						)
					} else {
						acc
					}),
					getTreeValues(lambdaFns)
				)
			}),
			\-> Pair(makeTree(), [])
		);
	});
	foldTree(newProgram.modules, [], \name, module, acc -> {
		closures = eitherFn(
			lookupTree(addedClosures, name),
			unpairC(\s, fns -> FiWiseClosure(s, fns, makeTree())),
			makeFiWiseClosure
		);
		newModule = FiModule(module with 
			structs = mapConcat(
				module.structs,
				\s -> eitherFn(
					lookupTree(closures.structs, s.name),
					unpairC(\callStructure, closureStructure -> [callStructure, closureStructure]),
					\-> [s]
				)
			),
			functions = addClosureToFnTypes(closures, module.functions, fnNames, structs, tmpVarCounter)
		);
		arrayPush(acc, newModule);
	});
}


makeFiWiseClosure() -> FiWiseClosure {
	FiWiseClosure(makeTree(), [], makeTree());
}

makeClosureVarName() -> string {
	"__closure__"
}

makeLambdaIndexFieldName() -> string {
	"__lambda_index__"
}

makeLambdaStructCallSfx() -> string {
	"__call"
}

closureFnName2closureStructureName(name : string) -> string {
	name + makeClosureVarName();
}

extractFcCreateClosurePrim(e : FiExp) -> Maybe<FcCreateClosurePrim> {
	switch (e : FiExp) {
		FiCallPrim(op, __, __, __) : switch (op : FcPrim) {
			FcCreateClosurePrim(__, __) : Some(op);
			default : None();
		}
		default : None();
	}
}

getLambdaParams(closures : FiWiseClosure, name : string, callArgs : [FiExp]) -> Maybe<[FiExp]> {
	getLambdaCallArgs = \capturedVar : FiTypeStruct -> {
		lambdaId = 1; // TODO ?
		// freeVars = filtermapi(lambdaFn.type.args, \i, ta -> if (getFiTypeNameType(ta.type).name == capturedVar.name) None() else Some(i));
		arrayPush(
			callArgs,
			makeFiWiseClosureStruct(capturedVar.name, lambdaId, capturedVar)
		);
	}

	maybeBind(
		lookupTree(closures.names, name),
		\lambda -> maybeMap(
			findFiWiseClosureParams(closures, lambda.structName, lambda.functionName),
			untripleC(\capturedVars : FiTypeStruct, __, __ -> getLambdaCallArgs(capturedVars))
		)
	);
}

findFiWiseClosureParams(closures : FiWiseClosure, structName : string, functionName : string) -> Maybe<Triple<FiTypeStruct, FiTypeStruct, FiFunctionDec>> {
	maybeBind(
		lookupTree(closures.structs, structName),
		unpairC(\capturedVars : FiTypeStruct, callStruct -> maybeMap(
			find(closures.fns, \v -> v.name == functionName),
			\fn : FiFunctionDec -> Triple(capturedVars, callStruct, fn)
		))
	);
}

makeLambdaFnCallExp(closures : FiWiseClosure, structName : string, functionName : string) -> Maybe<FiExp> {
	maybeMap(
		findFiWiseClosureParams(closures, structName, functionName),
		untripleC(\closureStruct : FiTypeStruct, callStruct : FiTypeStruct, fn : FiFunctionDec -> 
			FiCallPrim(
				FcStructPrim(callStruct.name),
				[
					FiVar(fn.name, fn.type, 0),
					FiCallPrim(
						FcStructPrim(closureStruct.name),
						map(closureStruct.args, \a -> FiVar(a.name, a.type, 0)),
						FiTypeName(closureStruct.name, closureStruct.typars), // TODO ?
						0
					)
				],
				FiTypeName(callStruct.name, callStruct.typars), // TODO typars ?
				0
			)
		)
	);
}

// structure with captured vars
makeFiWiseClosureStruct(name : string, lambdaId : int, closure : FiTypeStruct) -> FiCallPrim {
	FiCallPrim(
		FcStructPrim(name),
		mapi(closure.args, \i, field -> if (i == 0) FiInt(lambdaId, 0) else FiVar(field.name, field.type, 0)),
		FiTypeName(name, closure.typars), // ? structTypes == typars ?
		0
	)
}

isLambdaBodyFn(closures : FiWiseClosure, name : string) -> bool {
	exists(closures.fns, \f -> f.name == name)
}

// Declaration :: replace fn with a pointer, add env(=pointer). Don't change Main and created LambdaBodyFns
// before :  myFn(val : i32, myFn2 : (i32) -> i32)
// after :  myFn(val : i32, myFn2 : i32, __closure__ : i32)
addClosureToFnTypes(
	closures : FiWiseClosure,
	functions: [FiFunctionDec],
	fnNames : Set<string>,
	structs : ref WiseAstStructs,
	tmpVarCounter : ref int
) -> [FiFunctionDec] {
	map(functions, \func -> {
		fixedFn = isMainFn2(func.name) || isLambdaBodyFn(closures, func.name);
		fnArgs = if (fixedFn) makeTree() else fold(func.lambda.args, makeTree(), \acc, arg -> switch (arg.type : FiType) {
			FiTypeFunction(args, retType): {
				structTypes = [addClosureToFiTypeFunction(FiTypeFunction(args, retType)), FiTypeInt()];
				newStruct = makeNewFiStruct(^structs, structTypes);
				structs := newStruct.first;
				setTree(acc, arg.name, FiTypeName(newStruct.second, [])); // typars ?
			}
			default: acc;
		});

		FiFunctionDec(
			func.name,
			FiLambda(
				if (fixedFn) func.lambda.args else addClosureToFiFunArgs(func.lambda.args),
				addClosureToFnTypesInFiExp(func.name, closures, func.lambda.body, fnNames, structs, tmpVarCounter, fnArgs),
				if (fixedFn) func.lambda.type else addClosureToFiTypeFunction(func.lambda.type),
				func.lambda.start
			),
			if (fixedFn) func.type else addClosureToFiTypeFunction(func.type),
			func.declStart,
			func.defiStart
		);
	});
}

addClosureToFiTypeFunction(type : FiTypeFunction) -> FiTypeFunction {
	FiTypeFunction(
		addClosureToFiFunArgs(type.args),
		setClosureFnArgType(type.returnType)
	);
}

addClosureToFiFunArgs(args : [FiFunArg]) -> [FiFunArg] {
	arrayPush(
		map(args, \arg -> FiFunArg(arg.name, setClosureFnArgType(arg.type))),
		FiFunArg(makeClosureVarName(), FiTypeInt())
	);
}

addClosureToFnTypesInFiExp(
	funName : string,
	closures : FiWiseClosure,
	e : FiExp,
	fnNames : Set<string>,
	structs : ref WiseAstStructs,
	tmpVarCounter : ref int,
	localVars : Tree<string, FiType>, // new variable types (fn->structure)
) -> FiExp {
	fixType = \type -> switch (type : FiType) {
		FiTypeFunction(__, __): addClosureToFiTypeFunction(type);
		default: type;
	}

	createFnStruct = \fnType, fnExp, fnName -> {
		structTypes = [fnType, FiTypeInt()];
		newStruct = makeNewFiStruct(^structs, structTypes);
		tmpStructName = newStruct.second;
		structs := newStruct.first;
		closureEnv = maybeBind(extractFcCreateClosurePrim(fnExp), \v -> maybeMap(lookupTree(closures.structs, v.structName), \p -> Pair(p.first, v.functionName)));
		makeDefCallArgs = \-> [fnExp, FiInt(0, 0)];
		closureData = eitherFn(
			closureEnv,
			unpairC(\capturedVars : FiTypeStruct, functionName : string -> {
				scopeEnv = if (capturedVars.args == []) {
					FiInt(0, 0);
				} else {
					capturedVarTypes = map(capturedVars.args, \a -> a.type);
					newStruct2 = makeNewFiStruct(^structs, capturedVarTypes);
					tmpStructName2 = newStruct2.second;
					structs := newStruct2.first;
					FiCallPrim(
						FcStructPrim(tmpStructName2),
						map(capturedVars.args, \a -> FiVar(a.name, a.type, 0)),
						FiTypeName(tmpStructName2, capturedVarTypes), // ? structTypes == typars ?
						0
					);
				}
				[FiVar(functionName, fnType, 0), scopeEnv]
			}),
			makeDefCallArgs
		)
		FiCallPrim(
			FcStructPrim(tmpStructName),
			closureData,
			FiTypeName(tmpStructName, structTypes), // ? structTypes == typars ?
			0
		);
	}

	rec = \e2 -> addClosureToFnTypesInFiExp(funName, closures, e2, fnNames, structs, tmpVarCounter, localVars);
	recArg = \e2 -> {
		newExp = eitherFn(
			maybeBind(
				tryExtractStruct([extractFiTypeFromFiExp(e2)], FiTypeFunction([], FiTypeVoid())),
				\fnType : FiTypeFunction -> {
					// TODO : fix extractFiVarNameFromFiExp (if, switch)
					fnName = extractFiVarNameFromFiExp(e2);
					isRealFnExpResult = containsSet(fnNames, fnName);
					// we have to replace fn with a structure with closure
					if (isRealFnExpResult) Some(createFnStruct(addClosureToFiTypeFunction(fnType), e2, fnName)) else None();
				}
			),
			idfn,
			\-> switch (e2 : FiExp) {
				FiCallPrim(op, __, __, __) : switch (op : FcPrim) {
					// it is lambda inside the fn call
					FcCreateClosurePrim(structName, functionName) : either(makeLambdaFnCallExp(closures, structName, functionName), e2);
					default : e2;
				}
				default : e2;
			}
		);
		rec(newExp);
	}
	replaceFnInLet = \type, value -> {
		switch (type : FiType) {
			FiTypeFunction(__, __): {
				// TODO : fix extractFiVarNameFromFiExp (if, switch)
				fnName = extractFiVarNameFromFiExp(value);
				isRealFnExpResult = \ -> containsSet(fnNames, fnName);
				Pair(
					FiTypeInt(),
					if (fnName == "" || isRealFnExpResult()) createFnStruct(addClosureToFiTypeFunction(type), value, fnName) else value
				);
			}
			default : Pair(type, value);
		}
	}
	switch (e : FiExp) {
		FiLambda(args, body, type, start): FiLambda(map(args, \a -> FiFunArg(a.name, fixType(a.type))), rec(body), addClosureToFiTypeFunction(type), start);
		FiCall(f, args, type, start): {
			newArgs = switch (f : FiExp) {
				FiVar(id, __, __) : {
					eitherFn(
						getLambdaParams(closures, id, args),
						idfn,
						// we can create an empty structure by makeFiWiseClosureStruct("", 0, []), but let's not complicate (use 0)
						\-> if (containsSet(fnNames, id)) {
							arrayPush(args, if (isMainFn2(funName)) FiInt(0, 0) else FiVar(makeClosureVarName(), FiTypeInt(), 0))
						} else {
							// we already added args
							args
						}
					);
				}
				default : args;
			}
			fnName = extractFiVarNameFromFiExp(f) ;
			newCall = FiCall(rec(f), map(newArgs, recArg), fixType(type), start);
			if (isLambdaBodyFn(closures, fnName) || isFixedLambdaCall(e)) {
				newCall;
			} else {
				if (containsSet(fnNames, fnName)) {
					// this is a user function
					newCall;
				} else {
					unpair(
						makeCallFiTypeFunctionFnArg(^structs, newCall, tmpVarCounter, localVars),
						\newExp : FiExp, newStructs : WiseAstStructs -> {
							structs := newStructs;
							newExp
						}
					);
				}
			}
		}
		FiVar(name, type, start): FiVar(name, fixType(type), start);
		FiLet(name, type, e1, e2, type2, start): unpair(
			replaceFnInLet(type, rec(e1)),
			\letType, letValue -> {
				recBody = \-> addClosureToFnTypesInFiExp(funName, closures, e2, fnNames, structs, tmpVarCounter, setTree(localVars, name, extractFiTypeFromFiExp(letValue)));
				FiLet(name, letType, letValue, recBody(), fixType(type2), start)
			}
		);
		FiIf(e1, e2, e3, type, start): FiIf(rec(e1), rec(e2), rec(e3), fixType(type), start);
		FiSwitch(x, switchType, cases, type, start): FiSwitch(
			FiVar(x.name, fixType(x.type), x.start),
			fixType(switchType),
			map(cases, \c -> FiCase(c.struct, c.argNames, rec(c.body), c.start)),
			fixType(type),
			start
		);
		FiCast(e1, tFrom, tTo, type, start): FiCast(rec(e1), fixType(tFrom), fixType(tTo), fixType(type), start);
		FiSeq(es, type, start): FiSeq(map(es, rec), fixType(type), start);
		FiCallPrim(op, es, type, start): FiCallPrim(op, map(es, rec), fixType(type), start);
		FiVoid(start): e;
		FiDouble(d, start): e;
		FiInt(i, start): e;
		FiString(s, start): e;
		FiBool(b, start): e;
		FiRequire(flowfile, e1, type, start): FiRequire(flowfile, rec(e1), fixType(type), start);
		FiUnsafe(name, fallback, type, start): FiUnsafe(name, rec(fallback), fixType(type), start);
	}
}

setClosureFnArgType(type : FiType) -> FiType {
	switch (type : FiType) {
		FiTypeArray(__): type;
		FiTypeFunction(__, __): FiTypeInt(); // pointer. structure
		FiTypeRef(__): type;
		FiTypeParameter(__): type;
		FiTypeBool(): type;
		FiTypeInt(): type;
		FiTypeDouble(): type;
		FiTypeString(): type;
		FiTypeFlow(): type;
		FiTypeVoid(): type;
		FiTypeNative(): type;
		FiTypeName(__, __): type;
	}
}

// TODO
extractFiVarNameFromFiExp(exp : FiExp) -> string {
	switch (exp : FiExp) {
		FiBool(__, __) : "";
		FiInt(__, __) : "";
		FiDouble(__, __) : "";
		FiString(__, __) : "";
		FiVoid(__) : "";
		FiVar(id, __, __) : id;
		FiCallPrim(__, __, __, __): "";
		FiIf(__, __, __, __, __) : ""; // TODO ?
		FiLambda(__, __, __, __) : "";
		FiCall(__, __, __, __) : "";
		FiLet(__, __, __, body, __, __) : extractFiVarNameFromFiExp(body);
		FiSwitch(__, __, __, __, __) : ""; // TODO ?
		FiCast(e, __, __, __, __) : extractFiVarNameFromFiExp(e);
		FiSeq(es, __, __) : if (es == []) "" else extractFiVarNameFromFiExp(es[length(es) - 1]);
		FiRequire(__, e, __, __) : extractFiVarNameFromFiExp(e);
		FiUnsafe(__, e, __, __) : extractFiVarNameFromFiExp(e);
	}
}

isMainFn2(name : string) -> bool {
	name == "main";
}

pushNewStructToState(structs : WiseAstStructs, name : string, id : int, args : StructTupleArgs) -> WiseAstStructs {
	WiseAstStructs(
		StructTuple(setTree(
			structs.data.link,
			name,
			args
		)),
		setTree(structs.table, name, id),
		structs.unions,
		structs.templStructs, // TODO?
		structs.nextId,
	);
}

makeTmpStructName(i : int) -> string {
	"_TMPSTRUCT_" + i2s(i);
}

makeNewFiStruct(structs : WiseAstStructs, structTypes : [FiType]) -> Pair<WiseAstStructs, string> {
	tmpStructId = ^(structs.nextId);
	structs.nextId := tmpStructId + 1;
	tmpStructName = makeTmpStructName(tmpStructId);
	makeFieldName = \i -> "field" + i2s(i);
	newStructs = pushNewStructToState(
		structs,
		tmpStructName,
		tmpStructId,
		StructTupleArgs(
			[], // typeParameters : [FiType] TODO
			foldi(structTypes, makeTree(), \i, acc, t -> setTree(acc, makeFieldName(i), StructTupleArg(i, t)))
		)
	);
	Pair(newStructs, tmpStructName);
}

// TODO: replace 2 getStructs with 1
makeCallFiTypeFunctionFnArg(structs : WiseAstStructs, e : FiCall, tmpVarCounter : ref int, localVars : Tree<string, FiType>,) -> Pair<FiExp, WiseAstStructs> {
	tmpStructTypes = [extractFiTypeFromFiExp(e.f), FiTypeInt()];
	newStruct = makeNewFiStruct(structs, tmpStructTypes);
	makeFieldName = \i -> "field" + i2s(i);
	structType = FiTypeName(newStruct.second, tmpStructTypes); // typars ?

	makeTupledot = \i, varExp -> FiCallPrim(
		FcFieldPrim(makeFieldName(i)),
		[varExp],
		structType,
		0
	);

	makeCallExp = \varExp -> FiCall(
		makeTupledot(0, varExp), // fn
		arrayPush(e.args, makeTupledot(1, varExp)), // env
		e.type,
		0
	);

	newExp = switch (e.f : FiExp) {
		FiVar(name, __, start): makeCallExp(eitherMap(lookupTree(localVars, name), \type -> FiVar(name, type, start), e.f));
		default : {
			ind = ^tmpVarCounter;
			tmpVarCounter := ind + 1;
			tmpVarName = "tmp" + i2s(ind);
			FiLet(
				tmpVarName,
				structType,
				e.f,
				makeCallExp(FiVar(tmpVarName, structType, 0)),
				e.type,
				0
			);
		}
	}

	Pair(newExp, newStruct.first);
}

// is Exp created from makeCallFiTypeFunctionFnArg ?
isFixedLambdaCall(e : FiExp) -> bool {
	switch (e : FiExp) {
		FiCall(__, args, __, __): args != [] && 
			switch (args[length(args) - 1] : FiExp) {
				FiCallPrim(__, es, __, __): es != [] && 
					switch (es[0] : FiExp) {
						FiVar(__, type, __): {
							defName = takeBeforeLast(makeTmpStructName(0), "_", "");
							startsWith(getFiTypeName(type), defName)
						}
						default : false;
					}
				default : false;
			}
		default : false;
	}
}