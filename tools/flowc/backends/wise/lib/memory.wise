
// first free cell
MEMORY_HEAP_POINTER : i32 = 4096;

// TODO: find the first free cell
// Heap address is hidden
// size  - size in bytes
// result - address of the block
allocateMemory(size : i32) -> i32 {
	freeCell : i32 = load<>(MEMORY_HEAP_POINTER);
	store<>(MEMORY_HEAP_POINTER, freeCell + size); // move the ptr to the next free cell
	freeCell;
}

// size  - size in bytes
freeMemory(address : i32, size : i32) -> () {
	// mark the memory region as free
	// free cells ?
}



initMemory() -> () {
	store<>(MEMORY_HEAP_POINTER, MEMORY_HEAP_POINTER + memoryOffset);
}

// TODO
// T âˆˆ (Structure, Reference, Array);
// counter_adr = 0 cell;
// ~ dup[T](adr : i32) -> () {
//	cntr : i32 = load<>(adr);
//	if (cntr > 0) {
//		newCntr : i32 = cntr + 1;
//		store<>(adr, newCntr);
//	} else {
		// deleted object. we can't dup it
//	}
// }
// ~ drop[T](adr : i32) -> () {
//	cntr : i32 = load<>(adr);
//	if (cntr > 0) {
//		newCntr : i32 = cntr - 1;
//		store<>(adr, newCntr);
//		freeMemory(adr, ??);
//	} else {
		// deleted object. we can't drop it
//	}
// }

// magic ?
memoryOffset : i32 = 8;