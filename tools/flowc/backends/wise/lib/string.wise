// include lib/wise/array;
// import fd_write : (i32, i32, i32, i32) -> i32 = wasi_snapshot_preview1.fd_write;

// TODO: encoding. it doesnt work yet // println

// string is an array of bytes (symbol is an unicode value)
// 1 symbol = 2 bytes (UTF-16)

//-----------------------------------------------------
// PUPLIC
//-----------------------------------------------------
// FIX IT!!!!!
// it prints ascii , but we have unicode
printlnStr(s : i32) -> () {
	len : i32 = getLengthArray(s);
	// save the str adr
	store<>(0, s);
	// How many bytes to write
	store<>(4, len * charSize);
	fd_write(1, 0, 1, len * charSize * 8);
	// drop(s);
	printByte(10);
	();
}

strlen(s : i32) -> i32 {
	len : i32 = getLengthArray(s);
	// drop(s);
	len;
}

substring(s : i32, start : i32, length : i32) -> i32 {
	newStr : i32 = subrangeArrayE(s, start, length, charSize);
	// drop(s);
	newStr;
}

createString(length : i32) -> i32 {
	initArray(length, charSize);
}

i2s(v : i32) -> i32 {
	len : i32 = getIntCharLen(v);
	arr : i32 = createString(len);
	var i = len - 1;
	var value = if (v < 0) (-1 * v) else v;
	while (i > 0) {
		charCode : i32 = rem_u<>(value, 10) + 48;
		setCharString(arr, i, charCode);
		i := i - 1;
		vv = value;
		value := div_u<>(vv, 10);
	};
	// sign or the last code
	setCharString(arr, 0, if (v < 0) 45 else value + 48);
	arr;
}

// ~PROTECTED
setCharString(s : i32, index : i32, value : i32) -> () {
	store16<>(s + charSize * index, value);
}

//-----------------------------------------------------
// PRIVATE
//-----------------------------------------------------
charSize : i32 = 2; // utf-16

getCharString(s : i32, index : i32) -> i32 {
	load16_u<>(s + charSize * index);
}

getIntCharLen(v : i32) -> i32 {
	var value = if (v < 0) (-1 * v) else v;
	var len = if (v < 0) 2 else 1;
	while (value > 9) {
		len := len + 1;
		vv = value;
		value := div_u<>(vv, 10);
	};
	len;
}