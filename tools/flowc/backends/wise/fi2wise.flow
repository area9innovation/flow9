import tools/flowc/backends/common;
import tools/flowc/incremental/fiprogram;

import text/blueprint;
import tools/flowc/backends/wise/flow_wise_natives;
import tools/flowc/backends/wise/fiarray2wise;
import tools/flowc/backends/wise/fituple2wise;

// run test from 'tests' folder
// \flow9\tools\flowc\backends\wise> .\cmpl variable
// PS C:\a9\wase> flowcpp -I .. --batch ../wise/wise.flow -- I=..,../flow9/ tests\flow\array2.wise

export {
	fi2wise(program : FiProgram, cfg : FiWiseConfig, callback : (int) -> void) -> void;
}

fi2wise(program : FiProgram, cfg : FiWiseConfig, callback : (int) -> void) -> void {
	state = makeFiWiseState();
	traverseInOrder(program.modules, \name, module -> {
		writeWise2file(state, program, cfg.outputfolder, module);
	});
	callback(0);
}

FiWiseState(
	flowWiNatives : ref Tree<string, string>,
	tmpVarCounter : ref int,
	polyFns : ref Tree<string, Pair<FiTypeFunction, Tree<string, string>>>, // <fnName, <typeParam, templatePlaceholder-templateAlias>>
	compareFnTypes : ref Set<FlowWiType>,
	structs : ref WiseAstStructs,
	getStructFields : (string) -> Maybe<[FiType]>,
);

makeFiWiseState() -> FiWiseState {
	FiWiseState(
		ref makeTree(),
		ref 0,
		ref makeTree(),
		ref makeSet(),
		ref makeWiseAstStructs(),
		\__ -> None(),
	);
}

incTmpVarCounter(state : FiWiseState) -> int {
	tmpVarIndex = ^(state.tmpVarCounter);
	state.tmpVarCounter := tmpVarIndex + 1;
	tmpVarIndex;
}

// TODO
initWiNatives(state : FiWiseState, natives : [FiNativeDec]) -> void {
	state.flowWiNatives := fold(natives, makeTree(), \acc, decl ->
		eitherMap(findNativeName(decl.name), \n -> setTree(acc, decl.name, n), acc)
	);
}

writeWise2file(state : FiWiseState, program : FiProgram, path : string, module : FiModule) -> void {
	println("----------------------\nflow->wise "+ module.fileinfo.flowfile + ".flow");
	filepath : string = pathCombine(path, takeAfter(module.fileinfo.flowfile, path, module.fileinfo.flowfile))  + ".wise";
	wiseProgram = fiModule2FlowWiseAst(state, module);
	file = wiseAst2string(wiseProgram, ^(state.structs));

	ensureDirectoryExists(dirName(filepath));
	if (!setFileContent(filepath, file)) {
		println("Could not write " + filepath);
	}
}

fiModule2FlowWiseAst(state : FiWiseState, module : FiModule) -> FlowWiseAst {
	exportNames = buildSet(module.exports);
	functions = values2tree(module.functions, \f -> f.name);
	state.structs := fiStructs2wiTuples(module.structs);
	initWiNatives(state, module.natives);

	// save templates
	iter(module.initOrder, \fnName -> maybeApply(
		lookupTree(functions, fnName),
		\fn -> {
			templates = fiTypeFunction2templates(fn.type);
			if (!isEmptyTree(templates)) {
				state.polyFns := setTree(^(state.polyFns), fn.name, Pair(fn.type, templates));
			}
		}
	));

	newState = FiWiseState(state with 
		getStructFields = \name : string -> getStructArgs(name, ^(state.structs).data)
	);

	newBody = foldr(module.initOrder, FlowWiWaseEmpty(), \acc, fnName -> eitherMap(
		lookupTree(functions, fnName),
		\fn -> fiFunctionDec2FlowWiFunction(newState, fn, containsSet(exportNames, fnName), acc),
		acc
	));

	extendedBody = foldSet(^(newState.compareFnTypes), newBody, \acc, type -> {
		newDecl = makeFlowWiComparatorFn(type, newState.tmpVarCounter);
		FlowWiFunction(newDecl with decl = acc);
	});

	// TODO: imports if necessary
	systemImports = [
		"tools/flowc/backends/wise/lib/string",
		"tools/flowc/backends/wise/lib/array",
		"tools/flowc/backends/wise/lib/tuple",
		"lib/wise/runtime",
	];
	userImports = map(module.imports, \imp -> "lib/wise/" + imp.flowfile);
	imports = fold(uniq(concat(systemImports, userImports)), extendedBody, \acc, v -> FlowWiFlowWiseInclude(v, acc));

	imports;
}

fiFunctionDec2FlowWiFunction(state : FiWiseState, func : FiFunctionDec, exported : bool, body : FlowWiDecl) -> FlowWiFunction {
	templates = eitherFn(lookupTree(^(state.polyFns), func.name), secondOfPair, makeTree);
	FlowWiFunction(
		func.name,
		b2s(exported),
		getTreeValues(templates),
		map(func.lambda.args, \arg -> FlowWiIdtype(arg.name, fiType2FlowWiType(setTemplateInFiType(arg.type, templates), state.getStructFields))),
		fiType2FlowWiType(setTemplateInFiType(func.type.returnType, templates), state.getStructFields),
		fiExp2FlowWiExp(state, func.lambda.body, templates),
		body
	);
}

// format : (A-Z)*
fiTypeFunction2templates(type : FiTypeFunction) -> Tree<string, string> {
	lastTemplate = ref [64];
	fiTypeParameter2template = \v : string -> {
		code = ^lastTemplate;
		lastChar = lastElement(code, 64);
		lastTemplate := if (lastChar > 90) arrayPush(code, 64) else replace(code, length(code) - 1, lastChar + 1);
		superglue(^lastTemplate, fromCharCode, "");
	}
	mapTree2(
		extractFiTypeParameters(arrayPush(map(type.args, \a -> a.type), type.returnType), makeSet()).tree,
		\k, __ -> fiTypeParameter2template(k)
	);
}

setTemplateInFiType(type : FiType, templates : Tree<string, string>) -> FiType {
	rec = \t -> setTemplateInFiType(t, templates);
	switch (type : FiType) {
		FiTypeArray(tt) : type;
		FiTypeFunction(args, returnType) : FiTypeFunction(map(args, \a -> FiFunArg(a with type = rec(a.type))), rec(returnType));
		FiTypeRef(t) : FiTypeRef(rec(t));
		FiTypeParameter(n) : FiTypeParameter(lookupTreeDef(templates, n, ""));
		FiTypeBool() : type;
		FiTypeInt() : type;
		FiTypeDouble() : type;
		FiTypeString() : type;
		FiTypeFlow() : type;
		FiTypeVoid() :  type;
		FiTypeNative() : type;
		FiTypeName(n, typeparameters) : FiTypeName(n, map(typeparameters, rec));
	}
}

extractFiTypeParameters(types : [FiType], acc : Set<string>) -> Set<string> {
	if (types == []) {
		acc;
	} else {
		accTypes = tail(types);
		switch (types[0] : FiType) {
			FiTypeArray(tt) : extractFiTypeParameters(arrayPush(accTypes, tt), acc);
			FiTypeFunction(args, returnType) : extractFiTypeParameters(concat(accTypes, arrayPush(map(args, \arg -> arg.type), returnType)), acc);
			FiTypeRef(tt) : extractFiTypeParameters(arrayPush(accTypes, tt), acc);
			FiTypeParameter(n) : extractFiTypeParameters(accTypes, insertSet(acc, n));
			FiTypeBool() : extractFiTypeParameters(accTypes, acc);
			FiTypeInt() : extractFiTypeParameters(accTypes, acc);
			FiTypeDouble() : extractFiTypeParameters(accTypes, acc);
			FiTypeString() : extractFiTypeParameters(accTypes, acc);
			FiTypeFlow() : extractFiTypeParameters(accTypes, acc);
			FiTypeVoid() :  extractFiTypeParameters(accTypes, acc);
			FiTypeNative() : extractFiTypeParameters(accTypes, acc);
			FiTypeName(__, typeparameters) : extractFiTypeParameters(concat(accTypes, typeparameters), acc);
		}
	}
}

fiExp2FlowWiExp(state : FiWiseState, exp : FiExp, scopeTemplates : Tree<string, string>) -> FlowWiExp {
	makeDefExp = \-> {
		println("TODO FlowWiExp: " + toString(exp));
		FlowWiBrace([]);
	}
	getTemplateRealTypes = \fnName, fnArgTypes, fnRetType -> {
		maybeMap(
			lookupTree(^(state.polyFns), fnName),
			unpairC(\fnTypes, templates -> {
				declRealTypes = matchFnTypes(fnTypes, fnArgTypes, fnRetType);
				map(getTreeKeys(templates), \t -> {
					fiType2FlowWiType(lookupTreeDef(declRealTypes, t, FiTypeFlow()), state.getStructFields)
				});
			})
		);
	}
	resloveVar = \name, type -> {
		// TODO: islocal ? (shadowing)
		id = lookupTreeDef(^(state.flowWiNatives), name, name);
		newVar = FlowWiVar(id);
		switch (type : FiType) {
			FiTypeFunction(args, returnType) : eitherMap(
				getTemplateRealTypes(id, map(args, \a -> a.type), returnType),
				\realTypes -> FlowWiPolyCall(newVar, realTypes),
				newVar
			);
			default : newVar;
		}
	}
	e2e = \e -> fiExp2FlowWiExp(state, e, scopeTemplates);
	switch (exp : FiExp) {
		FiLambda(args, body, type, start) : makeDefExp();
		FiCall(f, args, type, start) : {
			unpair(resolveWiFnName(e2e(f), args, state.getStructFields), \newFn, newArgs -> FlowWiCall(newFn, map(newArgs, e2e)));
		}
		FiVar(name, type, start) : resloveVar(name, type);
		FiLet(name, type, e1, e2, type2, start) : {
			FlowWiLet(name, 0, fiType2FlowWiType(type, state.getStructFields), e2e(e1), FlowWiBrace([e2e(e2)]));
		}
		FiIf(e, e2, e3, type, start) : {
			if (isSameStructType(e3, FiVoid(0))) {
				FlowWiIf(e2e(e), e2e(e2));
			} else {
				FlowWiIfelse(e2e(e), e2e(e2), e2e(e3));
			}
		}
		FiSwitch(x, sWitchType, cases, type, start) : makeDefExp();
			// struct is "default" for default case
			// FiCase(struct: string, argNames : [string], body: FiExp, start : int);
		FiCast(e, tFrom, tTo, type, start) : makeDefExp();
		FiSeq(es, type, start) : FlowWiBrace(map(es, e2e));
		FiCallPrim(op, es, type, start) : eitherFn(fiCallPrim2wiExp(state, exp, scopeTemplates), idfn, makeDefExp);
		FiRequire(flowfile, e, type, start) : makeDefExp();
		FiUnsafe(name, fallback, type, start) : makeDefExp();
		FiConst() : fiConst2FlowWiExp(state, exp);
	}
}

matchFnTypes(declaredTypes : FiTypeFunction, argTypes : [FiType], returnType : FiType) -> Tree<string, FiType> {
	if (length(declaredTypes.args) != length(argTypes)) {
		println("can't match fn types");
		makeTree();
	} else {
		matchFnType(
			declaredTypes.returnType,
			returnType,
			foldi(declaredTypes.args, makeTree(), \i, acc, arg -> matchFnType(arg.type, argTypes[i], acc))
		);
	}
}

matchFnType(declaredType : FiType, realType : FiType, acc : Tree<string, FiType>) -> Tree<string, FiType> {
	onError = \ -> {
		println("wrong types : declared '" + toString(declaredType) + "', used '" + toString(realType) + "'");
		acc;
	}
	switch (declaredType : FiType) {
		FiTypeArray(t1) : switch (realType : FiType) {
			FiTypeArray(t2): matchFnType(t1, t2, acc);
			default : onError();
		}
		FiTypeFunction(args1, rt1) : switch (realType : FiType) {
			FiTypeFunction(args2, rt2): if (length(args1) == length(args2)) {
				foldi(args1, matchFnType(rt1, rt2, acc), \i, acc2, a1 -> matchFnType(a1.type, args2[i].type, acc2));
			} else {
				onError();
			}
			default : onError();
		}
		FiTypeRef(t1) : switch (realType : FiType) {
			FiTypeRef(t2): matchFnType(t1, t2, acc);
			default : onError();
		}
		FiTypeParameter(n) : {
			switch (realType : FiType) {
				FiTypeParameter(n2): acc; // empty array or error -> 'auto'
				default : setTree(acc, n, realType);
			}
		}
		FiTypeBool() : acc;
		FiTypeInt() : acc;
		FiTypeDouble() : acc;
		FiTypeString() : acc;
		FiTypeFlow() : acc;
		FiTypeVoid() :  acc;
		FiTypeNative() : acc;
		FiTypeName(__, at1) : switch (realType : FiType) {
			FiTypeName(__, at2): if (length(at1) == length(at2)) {
				foldi(at1, acc, \i, acc2, t1 -> matchFnType(t1, at2[i], acc2));
			} else {
				onError();
			}
			default : onError();
		}
	}
}

fiCallPrim2wiExp(state : FiWiseState, exp : FiCallPrim, scopeTemplates : Tree<string, string>) -> Maybe<FlowWiExp> {
	e2e = \e -> fiExp2FlowWiExp(state, e, scopeTemplates);
	structM = fiStructFn2wiExp(state, exp, scopeTemplates);

	if (isSome(structM)) {
		structM;
	} else if (exp.op == FcArrayPrim()) {
		makeWiArrayConstruction(map(exp.es, e2e), incTmpVarCounter(state), fiType2FlowWiType(exp.type, state.getStructFields));
	} else if (exp.es == []) {
		None();
	} else if (length(exp.es) == 1) {
		fcPrim2flowWiExp(exp.op, e2e(exp.es[0]), exp.type);
	} else {
		firstArgType = extractFiTypeFromFiExp(exp.es[0]);
		secondArgType = extractFiTypeFromFiExp(exp.es[1]);
		firstExpM = fcPrims2flowWiExp(state, exp.op, e2e(exp.es[0]), e2e(exp.es[1]), firstArgType, secondArgType, scopeTemplates);
		tail = subrange(exp.es, 2, length(exp.es) - 1);
		secondExpM = fiCallPrim2wiExp(state, FiCallPrim(exp.op, tail, exp.type, exp.start), scopeTemplates);
		eitherMap(
			firstExpM,
			\firstExp -> {
				eitherMap(
					secondExpM,
					\secondExp -> fcPrims2flowWiExp(state, exp.op, firstExp, secondExp, firstArgType, secondArgType, scopeTemplates),
					firstExpM
				);
			},
			secondExpM
		);
	}
}

fiStructFn2wiExp(state : FiWiseState, exp : FiCallPrim, templates : Tree<string, string>) -> Maybe<FlowWiExp> {
	makeError = \desc -> {
		println("Wrong field : " + desc + toString(exp));
		None();
	}
	makeWarning = \desc -> {
		devtrace("fiStructConstr2wiExp:: " + desc);
		None();
	}
	getFieldIndex = \fieldName, type-> {
		maybeMap(
			maybeBind(
				lookupTree(^(state.structs).data.link, fiType2structName(type)),
				\args -> lookupTree(args.args, fieldName)
			),
			\arg -> arg.index + 2
		);
	}
	e2e = \e -> fiExp2FlowWiExp(state, e, templates);
	makeTupleDot = \fieldName, type, e -> {
		eitherFn(
			getFieldIndex(fieldName, type),
			\index -> Some(FlowWiTupledot(
				decostructStructInExp(e, fiType2FlowWiType(type, state.getStructFields)).first,
				index
			)),
			\ -> makeError("structure or field not found ")
		)
	}

	switch (exp.op: FcPrim) {
		FcStructPrim(structName) : eitherFn(
			lookupTree(^(state.structs).data.link, structName),
			\__ -> Some(FlowWiTuple(structName, map(exp.es, \e -> fiExp2FlowWiExp(state, e, templates)))),
			\-> makeWarning("structure not found ")
		);
		FcFieldPrim(fieldName) : if (length(exp.es) == 1) {
			switch (exp.es[0] : FiExp) {
				FiVar(varName, type, __) : makeTupleDot(fieldName, type, FlowWiVar(varName));
				FiCallPrim(__, __, type, __) : {
					eitherFn(
						fiStructFn2wiExp(state, exp.es[0], templates),
						\e -> makeTupleDot(fieldName, type, e),
						\-> makeError("wrong expression ")
					);
				}
				FiCall(f, args, type, __): makeTupleDot(fieldName, type, FlowWiCall(e2e(f), map(args, e2e)));
				default : makeError("");
			}
		} else {
			makeError("");
		}
		default : makeWarning("wrong type ");
	}
}

fiType2structName(type : FiType) -> string {
	switch (type : FiType) {
		FiTypeName(name, __) : name;
		default : {
			println("wrong struct name : " + toString(type));
			"";
		}
	};
}

fcPrim2flowWiExp(type : FcPrim, e : FlowWiExp, resultType : FiType) -> Maybe<FlowWiExp> {
	makeError = \-> {
		println("Wrong operation : " + toString(type) + " (" + toString(e) + ")");
		None();
	}
	makeDef = \-> {
		println("TODO : transform expression " + toString(type));
		None();
	}
	isBool = \-> isSameStructType(resultType, FiTypeBool());
	isNumber = \-> isSameStructType(resultType, FiTypeInt()) || isSameStructType(resultType, FiTypeDouble());
	switch (type : FcPrim) {
		FcOrPrim() : if (isBool()) Some(e) else makeError();
		FcAndPrim() : makeError();
		FcNotPrim() : if (isBool()) Some(FlowWiBoolNot(e)) else makeError();
		FcEqPrim() : makeError();
		FcNePrim() : makeError();
		FcLePrim() : makeError();
		FcGePrim() : makeError();
		FcLtPrim() : makeError();
		FcGtPrim() : makeError();
		FcPlusPrim() : makeError();
		FcMinusPrim() : makeError();
		FcMulPrim() : makeError();
		FcDivPrim() : makeError();
		FcModPrim() : makeError();
		FcNegPrim() : if (isNumber()) Some(FlowWiNegate(e)) else makeError();
		FcArrayPrim() : makeDef();
		FcIndexPrim() : makeDef();
		FcDerefPrim() : makeDef();
		FcAssignPrim() : makeDef();
		FcRefPrim() : makeDef();
		FcStructPrim(structName) : makeDef();
		FcFieldPrim(name) : makeDef();
		FcSetMutablePrim(name) : makeDef();
		FcCreateClosurePrim(structName, functionName) : makeDef();
		FcQuote() : makeDef();
		FcUnquote() : makeDef();
	}
}


fcPrims2flowWiExp(
	state : FiWiseState,
	type : FcPrim,
	e1 : FlowWiExp,
	e2 : FlowWiExp,
	arg1Type : FiType,
	arg2Type : FiType,
	scopeTemplates : Tree<string, string>,
) -> Maybe<FlowWiExp> {
	constr1 = ref None();
	constr2 = ref None();
	isArrConstr = \e, v -> onlyOnce(v, \ -> isWiArrayConstruction(e));
	makeDefCmpr = \ -> fcPrimBools2flowWiExp(type, e1, e2);
	if (isSameStructType(arg1Type, FiTypeArray(FiTypeVoid())) || isArrConstr(e1, constr1) || isArrConstr(e2, constr2)) {
		arrType = if (isArrConstr(e1, constr1) && isArrConstr(e2, constr2)) FiTypeInt()
				else if (isArrConstr(e1, constr1)) extractArrayFiType(arg2Type)
				else extractArrayFiType(arg1Type);
		fcPrimArrays2flowWiExp(type, e1, e2, setTemplateInFiType(arrType, scopeTemplates), state);
	} else {
		newType = setTemplateInFiType(arg1Type, scopeTemplates);
		switch (newType : FiType) {
			FiTypeName(name, __) : {
				if (containsKeyTree(^(state.structs).table, name)) {
					fcPrimStructs2flowWiExp(type, e1, e2, fiType2FlowWiType(newType, state.getStructFields), state);
				} else {
					makeDefCmpr()
				}
			}
			FiTypeArray(__) : makeDefCmpr();
			FiTypeFunction(__, __) : makeDefCmpr();
			FiTypeRef(__) : makeDefCmpr();
			FiTypeParameter(__) : makeDefCmpr();
			FiTypeBool() : makeDefCmpr();
			FiTypeInt() : makeDefCmpr();
			FiTypeDouble() : makeDefCmpr();
			FiTypeString() : makeDefCmpr();
			FiTypeFlow() : makeDefCmpr();
			FiTypeVoid() : makeDefCmpr();
			FiTypeNative() : makeDefCmpr();
		}
	}
}

fcPrimBools2flowWiExp(type : FcPrim, e1 : FlowWiExp, e2 : FlowWiExp) -> Maybe<FlowWiExp> {
	makeDef = \-> {
		println("TODO : join expression " + toString(type));
		None();
	}
	makeError = \-> {
		println("Wrong operation : " + toString(type) + " (" + toString(e1) + ", " + toString(e2) + ")");
		None();
	}
	makeExp = \e -> Some(FlowWiBrace([e]));
	switch (type : FcPrim) {
		FcOrPrim() : makeExp(FlowWiBoolOr(e1, e2));
		FcAndPrim() : makeExp(FlowWiBoolAnd(e1, e2));
		FcNotPrim() : makeError();
		FcEqPrim() : makeExp(FlowWiEqual(e1, e2));
		FcNePrim() : makeExp(FlowWiNotEqual(e1, e2));
		FcLePrim() : makeExp(FlowWiLessEqual(e1, e2));
		FcGePrim() : makeExp(FlowWiGreaterEqual(e1, e2));
		FcLtPrim() : makeExp(FlowWiLess(e1, e2));
		FcGtPrim() : makeExp(FlowWiGreater(e1, e2));
		FcPlusPrim() : makeExp(FlowWiAdd(e1, e2));
		FcMinusPrim() : makeExp(FlowWiSub(e1, e2));
		FcMulPrim() : makeExp(FlowWiMul(e1, e2));
		FcDivPrim() : makeExp(FlowWiDiv(e1, e2));
		FcModPrim() : makeExp(FlowWiMod(e1, e2));
		FcNegPrim() : makeError();
		FcArrayPrim() : makeDef();
		FcIndexPrim() :  makeDef();
		FcDerefPrim() : makeDef();
		FcAssignPrim() : makeDef();
		FcRefPrim() : makeDef();
		FcStructPrim(__) : makeDef();
		FcFieldPrim(__) : makeDef();
		FcSetMutablePrim(__) : makeDef();
		FcCreateClosurePrim(__, __) : makeDef();
		FcQuote() : makeDef();
		FcUnquote() : makeDef();
	}
}

// TODO: array type (compare by value, and not by pointer)
fcPrimArrays2flowWiExp(type : FcPrim, e1 : FlowWiExp, e2 : FlowWiExp, valueType : FiType, state : FiWiseState) -> Maybe<FlowWiExp> {
	makeError = \-> {
		println("Wrong operation : " + toString(type) + " (" + toString(e1) + ", " + toString(e2) + ")");
		None();
	}

	makeCmprArray = \-> {
		itemType = fiType2FlowWiType(valueType, state.getStructFields);
		state.compareFnTypes := insertSet(^(state.compareFnTypes), itemType);
		makeWiArrayCompareCall(e1, e2, itemType);
	}
	makeExp = \e -> Some(FlowWiBrace([e]));

	switch (type : FcPrim) {
		FcOrPrim() : makeError();
		FcAndPrim() : makeError();
		FcNotPrim() : makeError();
		FcEqPrim() : makeExp(FlowWiEqual(makeCmprArray(), FlowWiInt(0)));
		FcNePrim() : makeExp(FlowWiNotEqual(makeCmprArray(), FlowWiInt(0)));
		FcLePrim() : makeExp(FlowWiLessEqual(makeCmprArray(), FlowWiInt(0)));
		FcGePrim() : makeExp(FlowWiGreaterEqual(makeCmprArray(), FlowWiInt(0)));
		FcLtPrim() : makeExp(FlowWiEqual(makeCmprArray(), FlowWiInt(-1)));
		FcGtPrim() : makeExp(FlowWiEqual(makeCmprArray(), FlowWiInt(1)));
		FcPlusPrim() : makeError();
		FcMinusPrim() : makeError();
		FcMulPrim() : makeError();
		FcDivPrim() : makeError();
		FcModPrim() : makeError();
		FcNegPrim() : makeError();
		FcArrayPrim() : makeError();
		FcIndexPrim() : Some(makeWiArrayIndex(e1, e2, fiType2FlowWiType(valueType, state.getStructFields)));
		FcDerefPrim() : makeError();
		FcAssignPrim() : makeError();
		FcRefPrim() : makeError();
		FcStructPrim(__) : makeError();
		FcFieldPrim(__) : makeError();
		FcSetMutablePrim(__) : makeError();
		FcCreateClosurePrim(__, __) : makeError();
		FcQuote() : makeError();
		FcUnquote() : makeError();
	}
}

fcPrimStructs2flowWiExp(type : FcPrim, e1 : FlowWiExp, e2 : FlowWiExp, eType : FlowWiType, state : FiWiseState) -> Maybe<FlowWiExp> {
	makeCmprTuple = \-> switch(eType : FlowWiType) {
		FlowWiBasictype(__) : None();
		FlowWiFntype(__, __) : None();
		FlowWiTupletype(__, __) : Some(makeComparisonWiTuples(e1, e2, eType, state.tmpVarCounter));
		FlowWiArrayType(__) : None();
	}
	makeError = \-> {
		println("Wrong operation : " + toString(type) + " (" + toString(e1) + ", " + toString(e2) + ")");
		None();
	}
	makeExp = \cmpr -> eitherFn(
		makeCmprTuple(),
		\e -> {
			tmpVarName = "_tmp_" + i2s(^(state.tmpVarCounter));
			state.tmpVarCounter := ^(state.tmpVarCounter) + 1;
			Some(FlowWiLet(
				tmpVarName,
				0,
				fiType2FlowWiType(FiTypeInt(), state.getStructFields), // result is -1/0/1
				e,
				FlowWiBrace([cmpr(FlowWiVar(tmpVarName))])
			));
		},
		makeError
	);

	switch (type : FcPrim) {
		FcOrPrim() : makeError();
		FcAndPrim() : makeError();
		FcNotPrim() : makeError();
		FcEqPrim() : makeExp(\e -> FlowWiEqual(e, FlowWiInt(0)));
		FcNePrim() : makeExp(\e -> FlowWiNotEqual(e, FlowWiInt(0)));
		FcLePrim() : makeExp(\e -> FlowWiLessEqual(e, FlowWiInt(0)));
		FcGePrim() : makeExp(\e -> FlowWiGreaterEqual(e, FlowWiInt(0)));
		FcLtPrim() : makeExp(\e -> FlowWiEqual(e, FlowWiInt(-1)));
		FcGtPrim() : makeExp(\e -> FlowWiEqual(e, FlowWiInt(1)));
		FcPlusPrim() : makeError();
		FcMinusPrim() : makeError();
		FcMulPrim() : makeError();
		FcDivPrim() : makeError();
		FcModPrim() : makeError();
		FcNegPrim() : makeError();
		FcArrayPrim() : makeError();
		FcIndexPrim() : makeError();
		FcDerefPrim() : makeError();
		FcAssignPrim() : makeError();
		FcRefPrim() : makeError();
		FcStructPrim(__) : makeError();
		FcFieldPrim(__) : makeError();
		FcSetMutablePrim(__) : makeError();
		FcCreateClosurePrim(__, __) : makeError();
		FcQuote() : makeError();
		FcUnquote() : makeError();
	}
}

// TODO: fix this ugly function
resolveWiFnName(exp : FlowWiExp, args : [FiExp], getStructFields : (string) -> Maybe<[FiType]>) -> Pair<FlowWiExp, [FiExp]> {
	fiName2wiseFnInf = \fnName : string -> {
		if (fnName == "concat") Pair("concatArrays", true)
		else if (fnName == "arrayPush") Pair("arrayPush", true)
		else if (fnName == "length") Pair("getLengthArray", false)
		else if (fnName == "subrange") Pair("subrangeArray", true)
		else if (fnName == "replace") Pair("replaceArray", true)
		else Pair("", false);
	}
	makeArrayFnForFiType = \type, fnName -> {
		fnInf = switch (type : FiType) {
			FiTypeInt() : fiName2wiseFnInf(fnName);
			FiTypeDouble() : fiName2wiseFnInf(fnName);
			FiTypeBool() : fiName2wiseFnInf(fnName);
			FiTypeString() : fiName2wiseFnInf(fnName);
			FiTypeArray(__) : fiName2wiseFnInf(fnName);
			default : Pair("", false);
		}
		unpair(fnInf, \name : string, tmplFn : bool -> {
			if (name == "") {
				println(fnName + " for '" + toString(type) + "' isn't implemented");
				Pair(exp, args);
			} else {
				fnExp = if (tmplFn) {
					FlowWiPolyCall(FlowWiVar(name), [fiType2FlowWiType(type, getStructFields)])
				} else {
					FlowWiVar(name);
				}
				Pair(fnExp, args);
			}
		});
	}

	// TODO: fix FiTypeParameter
	resolveArrType = \arrType, defType -> {
		if (isSameStructType(arrType, FiTypeParameter(""))) defType else arrType;
	}

	switch (exp : FlowWiExp) {
		FlowWiVar(id) : if (id == "println" && args != []) {
			Pair(makeFlowWiPrint(args[0]), args);
		} else if ((id == "length" || id == "subrange") && args != []) {
			makeArrayFnForFiType(resolveArrType(extractArrayFiTypeFromExp(args[0]), FiTypeInt()), id);
		} else if (id == "concat" && length(args) == 2) {
			arrType = resolveArrType(extractArrayFiTypeFromExp(args[0]), extractArrayFiTypeFromExp(args[1]));
			makeArrayFnForFiType(resolveArrType(arrType, FiTypeInt()), id)
		} else if (id == "arrayPush" && length(args) == 2) {
			makeArrayFnForFiType(extractArrayFiTypeFromExp(args[1]), id)
			} else if (id == "replace" && length(args) == 3) {
			makeArrayFnForFiType(extractArrayFiTypeFromExp(args[2]), id)
		} else {
			Pair(exp, args);
		}
		default : Pair(exp, args);
	}
}

makeFlowWiPrint(exp : FiExp) -> FlowWiExp {
	makeNativePrintln = \fnName -> FlowWiVar(fnName);
	makeDefPrintln = \desc -> {
		println("println for '" + desc + "' isn't implemented");
		makeNativePrintln("println");
	}
	makePrintForFiType = \type -> switch (type : FiType) {
		FiTypeBool() : makeNativePrintln("printlnb");
		FiTypeInt() : makeNativePrintln("printlni32");
		FiTypeDouble() : makeNativePrintln("printlnf64");
		FiTypeVoid() : makeNativePrintln("printv128");
		FiTypeString() : makeNativePrintln("printlnStr");
		default : makeDefPrintln(toString(type));
	}
	switch (exp : FiExp) {
		FiBool(__, __) : makePrintForFiType(FiTypeBool());
		FiInt(__, __) : makePrintForFiType(FiTypeInt());
		FiDouble(v, __) : makePrintForFiType(FiTypeDouble());
		FiString(v, __) : makePrintForFiType(FiTypeString());
		FiVoid(__) : makePrintForFiType(FiTypeVoid());
		FiVar(__, type, __) : makePrintForFiType(type);
		FiCallPrim(__, __, type, __): makePrintForFiType(type);
		FiIf(__, __, __, type, __) : makePrintForFiType(type);
		FiLambda(__, __, type, start) : makePrintForFiType(type);
		FiCall(__, __, type, __) : makePrintForFiType(type);
		FiLet(__, type, __, __, type2, __) : makePrintForFiType(type);
		FiSwitch(__, switchType, __, type, __) : makePrintForFiType(type);
		FiCast(__, tFrom, tTo, type, __) : makePrintForFiType(tTo);
		FiSeq(__, type, __) : makePrintForFiType(type);
		FiRequire(__, __, type, __) : makePrintForFiType(type);
		FiUnsafe(__, __, type, __) : makePrintForFiType(type);
	}
}

extractArrayFiTypeFromExp(exp : FiExp) -> FiType {
	extractArrayFiType(extractFiTypeFromFiExp(exp));
}

extractArrayFiType(type : FiType) -> FiType {
	switch (type : FiType) {
		FiTypeArray(t) : t;
		default : type;
	}
}

extractFiTypeFromFiExp(exp : FiExp) -> FiType {
	switch (exp : FiExp) {
		FiBool(__, __) : FiTypeBool();
		FiInt(__, __) : FiTypeInt();
		FiDouble(__, __) : FiTypeDouble();
		FiString(__, __) : FiTypeString();
		FiVoid(__) : FiTypeVoid();
		FiVar(__, type, __) : type;
		FiCallPrim(__, __, type, __): type;
		FiIf(__, __, __, type, __) : type;
		FiLambda(__, __, type, __) : type;
		FiCall(__, __, type, __) : type;
		FiLet(__, type, __, __, type2, __) : type;
		FiSwitch(__, switchType, __, type, __) : type;
		FiCast(__, tFrom, tTo, type, __) : tTo;
		FiSeq(__, type, __) : type;
		FiRequire(__, __, type, __) : type;
		FiUnsafe(__, __, type, __) : type;
	}
}

extractFiVarNameFromFiExp(exp : FiExp) -> string {
	switch (exp : FiExp) {
		FiBool(__, __) : "";
		FiInt(__, __) : "";
		FiDouble(__, __) : "";
		FiString(__, __) : "";
		FiVoid(__) : "";
		FiVar(id, __, __) : id;
		FiCallPrim(__, __, __, __): "";
		FiIf(__, __, __, __, __) : "";
		FiLambda(__, __, __, __) : "";
		FiCall(__, __, __, __) : "";
		FiLet(__, __, __, __, __, __) : "";
		FiSwitch(__, __, __, __, __) : "";
		FiCast(__, __, __, __, __) : "";
		FiSeq(__, __, __) : "";
		FiRequire(__, __, __, __) : "";
		FiUnsafe(__, __, __, __) : "";
	}
}

fiConst2FlowWiExp(state : FiWiseState, exp : FiConst) -> FlowWiExp {
	switch (exp : FiConst) {
		FiVoid(__) : FlowWiTuple("", []);
		FiDouble(d, __) : FlowWiDouble(d);
		FiInt(i, __) : FlowWiInt(i);
		FiString(s, __) : {
			eitherFn(
				makeWiArrayConstruction(map(s2a(s), \v -> FlowWiInt(v)), incTmpVarCounter(state), makeStringType()),
				idfn,
				\-> {
					println("TODO: string(" + s + ")");
					FlowWiTuple("", []);
				}
			);
		}
		FiBool(b, __) : FlowWiBool(b);
	}
}

wiseAst2string(code : FlowWiseAst, structs : WiseAstStructs) -> string {
	switch (code : FlowWiseAst) {
		FlowWiseAstList(value) : foldList(value, "\n", \acc, v -> acc + wiseAst2string(v, structs));
		FlowWiseAstBool(value) : b2s(value);
		FlowWiseAstInt(value) : i2s(value);
		FlowWiseAstDouble(value) : d2s(value);
		FlowWiseAstString(value) : value;
		FlowWiType(): wiType2string(code);
		FlowWiIdtype(id, type) : id + " : " + wiType2stringForFn(type);
		FlowWiDecl() : wiDecl2string(code, structs);
		FlowWiExp() : wiExp2string(code, None(), structs);
	}
}

wiDecl2string(decl : FlowWiDecl, structs : WiseAstStructs) -> string {
	switch (decl : FlowWiDecl) {
		FlowWiFunction(id, optexport, templates, lambdaargs, type, e, decl2) : {
			parentExp = None();
			"\n" + (if (s2b(optexport)) "export " else " ")
			+ wiVar2string(id, parentExp)
			+ (if (templates == []) "" else "[" + strGlue(templates, ",")+ "]")
			+ "(" + strGlue(map(lambdaargs, \a -> wiseAst2string(a, structs)), ", ") + ")"
			+ " -> " + wiType2stringForFn(type)
			+ " {\n"
			+ "\t" + initMemory(id, structs) + "\n"
			+ "\t" + wiExp2string(e, parentExp, structs)
			+ "\n}\n"
			+ wiDecl2string(decl2, structs);
		}
		FlowWiGlobal(id, optexport, type, optmutable, expression, decl2) : "TODO Decl[" + toString(decl)+"]";
		FlowWiImport(id1, type, optmutable, id2, id3, decl2) : "TODO Decl[" + toString(decl)+"]";
		FlowWiWaseEmpty() : "";
		FlowWiFlowWiseInclude(s, decl2) : {
			"include " + s + ";\n"
			+ wiseAst2string(decl2, structs);
		}
	}
}

wiExp2string(exp : FlowWiExp, parent : Maybe<FlowWiExp>, structs : WiseAstStructs) -> string {
	joinExp = \sign : string, exp1 : FlowWiExp, exp2 : FlowWiExp -> {
		"(" + wiseAst2string(exp1, structs) + " " + sign + " " + wiseAst2string(exp2, structs) + ")";
	}
	eol = "\n\t";
	wiExpDef2string = \e -> wiExp2string(e, None(), structs);
	switch (exp : FlowWiExp) {
		FlowWiAdd(exp1, exp2) : joinExp("+", exp1, exp2);
		FlowWiSub(exp1, exp2) : joinExp("-", exp1, exp2);
		FlowWiAnd(exp1, exp2) : joinExp("&", exp1, exp2);
		FlowWiBoolAnd(exp1, exp2) : joinExp("&&", exp1, exp2);
		FlowWiBoolNot(e) : "!" + wiseAst2string(e, structs); // TODO ?
		FlowWiBoolOr(exp1, exp2) : joinExp("||", exp1, exp2);
		FlowWiXor(exp1, exp2) : joinExp("^", exp1, exp2);
		FlowWiBrace(exps) : {
			expressions = map(extractExpsFromFlowWiBrace(exp, []), \e -> wiExp2string(e, Some(exp), structs));
			if (expressions == []) {
				""
			} else if (length(expressions) == 1) {
				expressions[0];
			} else {
				"{" + eol + strGlue(expressions, ";" + eol) + ";" + eol + "}";

			}
		}
		FlowWiCall(e, exps) : wiExp2string(e, Some(exp), structs) + "(" + strGlue(map(exps, wiExpDef2string), ", ") + ")";
		FlowWiPolyCall(e, types) : {
			type2str = if (isGetStructValueExp(e)) flowWiTupletype2string else wiType2string;
			wiExp2string(e, Some(exp), structs)  + "[" + superglue(types, type2str, ", ") + "]";
		}
		FlowWiDiv(exp1, exp2) : joinExp("/", exp1, exp2);
		FlowWiEqual(exp1, exp2) : joinExp("==", exp1, exp2);
		FlowWiGreater(exp1, exp2) : joinExp(">", exp1, exp2);
		FlowWiGreaterEqual(exp1, exp2) : joinExp(">=", exp1, exp2);
		// FlowWiGreaterEqualu(exp1 : FlowWiExp, exp2 : FlowWiExp);
		// FlowWiGreateru(exp1 : FlowWiExp, exp2 : FlowWiExp);
		FlowWiLess(exp1, exp2) : joinExp("<", exp1, exp2);
		FlowWiLessEqual(exp1, exp2) : joinExp("<=", exp1, exp2);
		// FlowWiLessEqualu(exp1, exp2) : joinExp("<=", exp1, exp2); // TODO: ?
		// FlowWiLessu(exp1, exp2) : joinExp("<", exp1, exp2); // TODO: ?
		// FlowWiIsNull(e : FlowWiExp);
		FlowWiTupledot(e, index) : wiExp2string(e, None(), structs) + "." + i2s(index);
		FlowWiTypeannotation(e, type) : ""; // ignore declaration
		FlowWiLet(id, i, opttype, e, brace) : {
			body = wiExpDef2string(brace);
			varType = switch (opttype : FlowWiOpttype) {
				FlowWiBasictype(__) : wiType2string(opttype);
				FlowWiFntype(__, __) : wiType2string(opttype);
				// TODO: always pointers ?
				FlowWiTupletype(__, __) : if (isStructDecomposition(e)) {
					flowWiTupletype2string(opttype)
				} else {
					wiType2string(FlowWiBasictype("i32")); // pointer
				}
				FlowWiArrayType(__) : wiType2string(opttype);
			}
			newBody = if (length(brace.expsemi) > 1) rtrim2(ltrim2(body, "{"), "}") else body;
			id + " : " + varType + " = " + wiExpDef2string(e) + ";"
			+ eol + newBody;
		}
		// FlowWiWasmOp(s : string, wargs : [FlowWiWarg], exps : [FlowWiExp]);
		FlowWiMod(exp1, exp2) : joinExp("%", exp1, exp2);
		FlowWiMul(exp1, exp2) : joinExp("*", exp1, exp2);
		FlowWiNegate(e) : "-" + wiExpDef2string(e);
		FlowWiNotEqual(exp1, exp2) : joinExp("!=", exp1, exp2);
		FlowWiOr(exp1, exp2) : joinExp("|", exp1, exp2);
		FlowWiAtom(): wiAtom2string(exp, parent, structs);
		default : "TODO[" + toString(exp)+"]";
	}
}

extractExpsFromFlowWiBrace(e : FlowWiBrace, acc : [FlowWiExp]) -> [FlowWiExp] {
	concat(
		acc,
		mapConcat(e.expsemi, \s -> {
			switch (s) {
				FlowWiBrace(__): extractExpsFromFlowWiBrace(s, []);
				default: [s];
			}
		})
	)
}

wiAtom2string(exp : FlowWiAtom, parent : Maybe<FlowWiExp>, structs : WiseAstStructs) -> string {
	eol = "\n\t";
	switch (exp : FlowWiAtom) {
		FlowWiBool(b) : if (b) "true" else "false";
		FlowWiInt(int_0) : i2s(int_0);
		FlowWiDouble(double_0) : {
			// TODO: find the reason ?
			// ds(0.0) == 0 == i32
			isInt = isDigits(d2s(if (double_0 >= 0.) double_0 else double_0 * (-1.)));
			d2s(double_0) + (if (isInt) ".0" else "");
		}
		FlowWiTuple(id, exps) : flowWiTuple2string(exp, structs, \e -> wiExp2string(e, None(), structs));
		FlowWiVar(id) : wiVar2string(id, parent);
		FlowWiSet(id, e) : id + " := " + wiseAst2string(e, structs) + ";";
		FlowWiIf(exp1, exp2) : {
			"if (" + wiExp2string(exp1, None(), structs) + ") {"
			+ eol + wiExp2string(exp2, None(), structs) + eol
			+ "}";
		}
		FlowWiIfelse(exp1, exp2, exp3) : {
			"if (" + wiExp2string(exp1, None(), structs) + ") {"
			+ eol + wiExp2string(exp2, None(), structs) + "\n"
			+ "} else {"
			+ eol + wiExp2string(exp3, None(), structs) + "\n"
			+ "}";
		}
		// FlowWiBreak();
		// FlowWiContinue();
		// FlowWiReturn(exps : [FlowWiExp]);
		// FlowWiWhile(exp1 : FlowWiExp, exp2 : FlowWiExp);

		// FlowWiHex32(s : string);
		// FlowWiHex64(s : string);
		// FlowWiHexf32(s : string);
		// FlowWiHexf64(s : string);
		// FlowWiI64(s : string);
		default : "TODO_Atom[" + toString(exp)+"]";
	}
}

// temporary function
wiVar2string(name : string, parent : Maybe<FlowWiExp>) -> string {
	if (isMainFn(name)) {
		"export _start"
	} else if (name == "println") {
		""
	} else {
		name;
	}
}

isMainFn(name : string) -> bool {
	name == "main";
}

initMemory(fnName : string, structs : WiseAstStructs) -> string {
	if (isMainFn(fnName)) {
		wiExp2string(FlowWiCall(FlowWiVar("initMemory"), []), None(), structs) + ";";
	} else {
		""
	}
}
