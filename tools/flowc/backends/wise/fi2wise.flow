import tools/flowc/backends/common;
import tools/flowc/incremental/fiprogram;

import text/blueprint;
import tools/flowc/backends/wise/flow_wise_types;
import tools/flowc/backends/wise/flow_wise_natives;
import tools/flowc/backends/wise/fiarray2wise;

// run test from 'tests' folder
// \flow9\tools\flowc\backends\wise> .\cmpl variable

export {
	fi2wise(program : FiProgram, cfg : FiWiseConfig, callback : (int) -> void) -> void;
}

fi2wise(program : FiProgram, cfg : FiWiseConfig, callback : (int) -> void) -> void {
	state = makeFiWiseState();
	traverseInOrder(program.modules, \name, module -> {
		writeWise2file(state, program, cfg.outputfolder, module);
	});
	callback(0);
}

FiWiseState(
	flowWiNatives : ref Tree<string, string>,
	tmpVarCounter : ref int,
	polyFns : ref Tree<string, Pair<FiTypeFunction, Tree<string, string>>>, // <fnName, <typeParam, templateName>>
);

makeFiWiseState() -> FiWiseState {
	FiWiseState(
		ref makeTree(),
		ref 0,
		ref makeTree(),
	);
}

incTmpVarCounter(state : FiWiseState) -> int {
	tmpVarIndex = ^(state.tmpVarCounter);
	state.tmpVarCounter := tmpVarIndex + 1;
	tmpVarIndex;
}

// TODO
initWiNatives(state : FiWiseState, natives : [FiNativeDec]) -> void {
	state.flowWiNatives := fold(natives, makeTree(), \acc, decl -> 
		eitherMap(findNativeName(decl.name), \n -> setTree(acc, decl.name, n), acc)
	);
}

writeWise2file(state : FiWiseState, program : FiProgram, path : string, module : FiModule) -> void {
	println("----------------------\nflow->wise "+ module.fileinfo.flowfile + ".flow");
	filepath : string = pathCombine(path, takeAfter(module.fileinfo.flowfile, path, module.fileinfo.flowfile))  + ".wise";
	wiseProgram = fiModule2FlowWiseAst(state, module);
	file = wiseAst2string(wiseProgram);

	ensureDirectoryExists(dirName(filepath));
	if (!setFileContent(filepath, file)) {
		println("Could not write " + filepath);
	}
}

fiModule2FlowWiseAst(state : FiWiseState, module : FiModule) -> FlowWiseAst {
	exportNames = buildSet(module.exports);
	functions = values2tree(module.functions, \f -> f.name);
	structs = fiStructs2wiTuples(module.structs);
	initWiNatives(state, module.natives);

	// save templates
	iter(module.initOrder, \fnName -> maybeApply(
		lookupTree(functions, fnName),
		\fn -> {
			templates = fiTypeFunction2templates(fn.type);
			state.polyFns := setTree(^(state.polyFns), fn.name, Pair(fn.type, templates));
		}
	));

	newBody = foldr(module.initOrder, FlowWiWaseEmpty(), \acc, fnName -> eitherMap(
		lookupTree(functions, fnName),
		\fn -> fiFunctionDec2FlowWiFunction(state, fn, containsSet(exportNames, fnName), structs.second, acc),
		acc
	));
	
	// TODO: imports if necessary 
	systemImports = [
		"tools/flowc/backends/wise/lib/array",
		"tools/flowc/backends/wise/lib/string",
	];
	userImports = map(module.imports, \imp -> "lib/wise/" + imp.flowfile);
	imports = fold(concat(userImports, systemImports), newBody, \acc, v -> FlowWiFlowWiseInclude(v, acc));

	FlowWiseAstList(Cons(imports, structs.first));
}

StructTuple(
	link : Tree</*struct_name*/string, StructTupleArgs>
);
StructTupleArgs(
	args : Tree<string/*arg_name*/, StructTupleArg>
);
StructTupleArg(
	index : int,
	type : FiType,
);

fiStructs2wiTuples(structs : [FiTypeStruct]) -> Pair<List<FlowWiExp>, StructTuple> {
	foldr(structs, Pair(makeList(), StructTuple(makeTree())), \acc, struct -> unpair(acc, \ast, dict ->
		Pair(
			Cons(fiStruct2wiTupleAnnotation(struct, dict), ast),
			// TODO: remove type?
			StructTuple(setTree(
				dict.link, 
				struct.name,
				StructTupleArgs(foldi(struct.args, makeTree(), \i, acc2, arg -> 
					setTree(acc2, arg.name, StructTupleArg(i, arg.type))
				))
			))
		)
	));
}

fiStruct2wiTupleAnnotation(struct : FiTypeStruct, structs : StructTuple) -> FlowWiExp {
	FlowWiTypeannotation(
		FlowWiVar(struct.name),
		FlowWiTupletype(map(struct.args, \arg -> fiType2FlowWiType(arg.type, structs)))
	);
}

fiFunctionDec2FlowWiFunction(state : FiWiseState, func : FiFunctionDec, exported : bool, structs : StructTuple, body : FlowWiDecl) -> FlowWiFunction {
	templates = eitherFn(lookupTree(^(state.polyFns), func.name), secondOfPair, makeTree);
	FlowWiFunction(
		func.name,
		b2s(exported),
		getTreeValues(templates),
		map(func.lambda.args, \arg -> FlowWiIdtype(arg.name, fiType2FlowWiType(setTemplateInFiType(arg.type, templates), structs))),
		fiType2FlowWiType(setTemplateInFiType(func.type.returnType, templates), structs),
		fiExp2FlowWiExp(state, func.lambda.body, structs),
		body
	);
}

// format : (A-Z)*
fiTypeFunction2templates(type : FiTypeFunction) -> Tree<string, string> {
	lastTemplate = ref [64];
	fiTypeParameter2template = \v : string -> {
		code = ^lastTemplate;
		lastChar = lastElement(code, 64);
		lastTemplate := if (lastChar > 90) arrayPush(code, 64) else replace(code, length(code) - 1, lastChar + 1);
		superglue(^lastTemplate, fromCharCode, "");
	}
	mapTree2(
		extractFiTypeParameters(arrayPush(map(type.args, \a -> a.type), type.returnType), makeSet()).tree,
		\k, __ -> fiTypeParameter2template(k)
	);
}

setTemplateInFiType(type : FiType, templates : Tree<string, string>) -> FiType {
	rec = \t -> setTemplateInFiType(t, templates);
	switch (type : FiType) {
		FiTypeArray(tt) : type;
		FiTypeFunction(args, returnType) : FiTypeFunction(map(args, \a -> FiFunArg(a with type = rec(a.type))), rec(returnType));
		FiTypeRef(t) : FiTypeRef(rec(t));
		FiTypeParameter(n) : FiTypeParameter(lookupTreeDef(templates, n, ""));
		FiTypeBool() : type;
		FiTypeInt() : type;
		FiTypeDouble() : type;
		FiTypeString() : type;
		FiTypeFlow() : type;
		FiTypeVoid() :  type;
		FiTypeNative() : type;
		FiTypeName(n, typeparameters) : FiTypeName(n, map(typeparameters, rec));
	}
}

extractFiTypeParameters(types : [FiType], acc : Set<string>) -> Set<string> {
	if (types == []) {
		acc;
	} else {
		accTypes = tail(types);
		switch (types[0] : FiType) {
			FiTypeArray(tt) : extractFiTypeParameters(arrayPush(accTypes, tt), acc);
			FiTypeFunction(args, returnType) : extractFiTypeParameters(concat(accTypes, arrayPush(map(args, \arg -> arg.type), returnType)), acc);
			FiTypeRef(tt) : extractFiTypeParameters(arrayPush(accTypes, tt), acc);
			FiTypeParameter(n) : extractFiTypeParameters(accTypes, insertSet(acc, n));
			FiTypeBool() : extractFiTypeParameters(accTypes, acc);
			FiTypeInt() : extractFiTypeParameters(accTypes, acc);
			FiTypeDouble() : extractFiTypeParameters(accTypes, acc);
			FiTypeString() : extractFiTypeParameters(accTypes, acc);
			FiTypeFlow() : extractFiTypeParameters(accTypes, acc);
			FiTypeVoid() :  extractFiTypeParameters(accTypes, acc);
			FiTypeNative() : extractFiTypeParameters(accTypes, acc);
			FiTypeName(__, typeparameters) : extractFiTypeParameters(concat(accTypes, typeparameters), acc);
		}
	}
}

fiExp2FlowWiExp(state : FiWiseState, exp : FiExp, structs : StructTuple) -> FlowWiExp {
	makeDefExp = \-> {
		println("TODO FlowWiExp: " + toString(exp));
		FlowWiBrace([]);
	}
	getTemplateRealTypes = \fnName, fnArgTypes, fnRetType -> {
		maybeMap(
			lookupTree(^(state.polyFns), fnName),
			unpairC(\fnTypes, templates -> {
				declRealTypes = matchFnTypes(fnTypes, fnArgTypes, fnRetType);
				map(getTreeKeys(templates), \t -> fiType2FlowWiType(lookupTreeDef(declRealTypes, t, FiTypeFlow()), structs));
			})
		);
	}
	resloveVar = \name, type -> {
		// TODO: islocal ? (shadowing)
		id = lookupTreeDef(^(state.flowWiNatives), name, name);
		newVar = FlowWiVar(id);
		switch (type : FiType) {
			FiTypeFunction(args, returnType) : eitherMap(
				getTemplateRealTypes(id, map(args, \a -> a.type), returnType),
				\realTypes -> FlowWiPolyCall(newVar, realTypes),
				newVar
			);
			default : newVar;
		}
	}
	e2e = \e -> fiExp2FlowWiExp(state, e, structs);
	switch (exp : FiExp) {
		FiLambda(args, body, type, start) : makeDefExp();
		FiCall(f, args, type, start) : {
			unpair(resolveWiFnName(e2e(f), args, structs), \newFn, newArgs -> FlowWiCall(newFn, map(newArgs, e2e)));
		}
		FiVar(name, type, start) : resloveVar(name, type);
		FiLet(name, type, e1, e2, type2, start) : {
			FlowWiLet(name, 0, fiType2FlowWiType(type, structs), e2e(e1), FlowWiBrace([e2e(e2)]));
		}
		FiIf(e, e2, e3, type, start) : {
			if (isSameStructType(e3, FiVoid(0))) {
				FlowWiIf(e2e(e), e2e(e2));
			} else {
				FlowWiIfelse(e2e(e), e2e(e2), e2e(e3));
			}
		}
		FiSwitch(x, sWitchType, cases, type, start) : makeDefExp();
			// struct is "default" for default case
			// FiCase(struct: string, argNames : [string], body: FiExp, start : int);
		FiCast(e, tFrom, tTo, type, start) : makeDefExp();
		FiSeq(es, type, start) : FlowWiBrace(map(es, e2e));
		FiCallPrim(op, es, type, start) : eitherFn(fiCallPrim2wiExp(state, exp, structs), idfn, makeDefExp);
		FiRequire(flowfile, e, type, start) : makeDefExp();
		FiUnsafe(name, fallback, type, start) : makeDefExp();
		FiConst() : fiConst2FlowWiExp(state, exp);
	}
}

matchFnTypes(declaredTypes : FiTypeFunction, argTypes : [FiType], returnType : FiType) -> Tree<string, FiType> {
	if (length(declaredTypes.args) != length(argTypes)) {
		println("can't match fn types");
		makeTree();
	} else {
		matchFnType(
			declaredTypes.returnType,
			returnType,
			foldi(declaredTypes.args, makeTree(), \i, acc, arg -> matchFnType(arg.type, argTypes[i], acc))
		);
	}
}

matchFnType(declaredType : FiType, realType : FiType, acc : Tree<string, FiType>) -> Tree<string, FiType> {
	onError = \ -> {
		println("wrong types : declared '" + toString(declaredType) + "', used '" + toString(realType) + "'");
		acc;
	}
	switch (declaredType : FiType) {
		FiTypeArray(t1) : switch (realType : FiType) {
			FiTypeArray(t2): matchFnType(t1, t2, acc);
			default : onError();
		}
		FiTypeFunction(args1, rt1) : switch (realType : FiType) {
			FiTypeFunction(args2, rt2): if (length(args1) == length(args2)) {
				foldi(args1, matchFnType(rt1, rt2, acc), \i, acc2, a1 -> matchFnType(a1.type, args2[i].type, acc2));
			} else {
				onError();
			}
			default : onError();
		}
		FiTypeRef(t1) : switch (realType : FiType) {
			FiTypeRef(t2): matchFnType(t1, t2, acc);
			default : onError();
		}
		FiTypeParameter(n) : setTree(acc, n, realType);
		FiTypeBool() : acc;
		FiTypeInt() : acc;
		FiTypeDouble() : acc;
		FiTypeString() : acc;
		FiTypeFlow() : acc;
		FiTypeVoid() :  acc;
		FiTypeNative() : acc;
		FiTypeName(__, at1) : switch (realType : FiType) {
			FiTypeName(__, at2): if (length(at1) == length(at2)) {
				foldi(at1, acc, \i, acc2, t1 -> matchFnType(t1, at2[i], acc2));
			} else {
				onError();
			}
			default : onError();
		}
	}
}

fiCallPrim2wiExp(state : FiWiseState, exp : FiCallPrim, structs : StructTuple) -> Maybe<FlowWiExp> {
	e2e = \e -> fiExp2FlowWiExp(state, e, structs);
	structM = fiStructFn2wiExp(state, exp, structs);
	
	if (isSome(structM)) {
		structM;
	} else if (exp.op == FcArrayPrim()) {
		makeWiArrayConstruction(map(exp.es, e2e), incTmpVarCounter(state), fiType2FlowWiType(exp.type, structs));
	} else if (exp.es == []) {
		None();
	} else if (length(exp.es) == 1) {
		fcPrim2flowWiExp(exp.op, e2e(exp.es[0]), exp.type);
	} else {
		firstArgType = extractFiTypeFromFiExp(exp.es[0]);
		firstExpM = fcPrims2flowWiExp(state, exp.op, e2e(exp.es[0]), e2e(exp.es[1]), firstArgType, structs);
		tail = subrange(exp.es, 2, length(exp.es) - 1);
		secondExpM = fiCallPrim2wiExp(state, FiCallPrim(exp.op, tail, exp.type, exp.start), structs);
		eitherMap(
			firstExpM,
			\firstExp -> {
				eitherMap(
					secondExpM,
					\secondExp -> fcPrims2flowWiExp(state, exp.op, firstExp, secondExp, firstArgType, structs),
					firstExpM
				);
			},
			secondExpM
		);
	}
}

fiStructFn2wiExp(state : FiWiseState, exp : FiCallPrim, structs : StructTuple) -> Maybe<FlowWiExp> {
	makeError = \desc -> {
		println("Wrong field : " + desc + toString(exp));
		None();
	}
	makeWarning = \desc -> {
		devtrace("fiStructConstr2wiExp:: " + desc);
		None();
	}
	getFieldIndex = \fieldName, type-> {
		maybeMap(
			maybeBind(
				lookupTree(structs.link, fiType2structName(type)),
				\args -> lookupTree(args.args, fieldName)
			),
			\arg -> arg.index
		);
	}
	e2e = \e -> fiExp2FlowWiExp(state, e, structs);
	makeTupleDot = \fieldName, type, e -> {
		eitherFn(
			getFieldIndex(fieldName, type),
			\index -> Some(FlowWiTupledot(e, index)),
			\ -> makeError("structure or field not found ")
		)
	}

	switch (exp.op: FcPrim) {
		FcStructPrim(structName) : eitherFn(
			lookupTree(structs.link, structName),
			\__ -> Some(FlowWiTuple(map(exp.es, \e -> fiExp2FlowWiExp(state, e, structs)))),
			\-> makeWarning("structure not found ")
		);
		FcFieldPrim(fieldName) : if (length(exp.es) == 1) {
			switch (exp.es[0] : FiExp) {
				FiVar(varName, type, __) : makeTupleDot(fieldName, type, FlowWiVar(varName));
				FiCallPrim(__, __, type, __) : {
					eitherFn(
						fiStructFn2wiExp(state, exp.es[0], structs),
						\e -> makeTupleDot(fieldName, type, e),
						\-> makeError("wrong expression ")
					);
				}
				FiCall(f, args, type, __): makeTupleDot(fieldName, type, FlowWiCall(e2e(f), map(args, e2e)));
				default : makeError("");
			}
		} else {
			makeError("");
		}
		default : makeWarning("wrong type ");
	}
}

fiType2structName(type : FiType) -> string {
	switch (type : FiType) {
		FiTypeName(name, __) : name;
		default : {
			println("wrong struct name : " + toString(type));
			"";
		}
	};
}

fcPrim2flowWiExp(type : FcPrim, e : FlowWiExp, resultType : FiType) -> Maybe<FlowWiExp> {
	makeError = \-> {
		println("Wrong operation : " + toString(type) + " (" + toString(e) + ")");
		None();
	}
	makeDef = \-> {
		println("TODO : transform expression " + toString(type));
		None();
	}
	isBool = \-> isSameStructType(resultType, FiTypeBool());
	isNumber = \-> isSameStructType(resultType, FiTypeInt()) || isSameStructType(resultType, FiTypeDouble());
	switch (type : FcPrim) {
		FcOrPrim() : if (isBool()) Some(e) else makeError();
		FcAndPrim() : makeError();
		FcNotPrim() : if (isBool()) Some(FlowWiBoolNot(e)) else makeError();
		FcEqPrim() : makeError();
		FcNePrim() : makeError();
		FcLePrim() : makeError();
		FcGePrim() : makeError();
		FcLtPrim() : makeError();
		FcGtPrim() : makeError();
		FcPlusPrim() : makeError();
		FcMinusPrim() : makeError();
		FcMulPrim() : makeError();
		FcDivPrim() : makeError();
		FcModPrim() : makeError();
		FcNegPrim() : if (isNumber()) Some(FlowWiNegate(e)) else makeError();
		FcArrayPrim() : makeDef();
		FcIndexPrim() : makeDef();
		FcDerefPrim() : makeDef();
		FcAssignPrim() : makeDef();
		FcRefPrim() : makeDef();
		FcStructPrim(structName) : makeDef();
		FcFieldPrim(name) : makeDef();
		FcSetMutablePrim(name) : makeDef();
		FcCreateClosurePrim(structName, functionName) : makeDef();
		FcQuote() : makeDef();
		FcUnquote() : makeDef();
	}
}


fcPrims2flowWiExp(state : FiWiseState, type : FcPrim, e1 : FlowWiExp, e2 : FlowWiExp, firstArgType : FiType, structs : StructTuple) -> Maybe<FlowWiExp> {
	if (isSameStructType(firstArgType, FiTypeArray(FiTypeVoid())) || isWiArrayConstruction(e1) || isWiArrayConstruction(e2)) {
		fcPrimArrays2flowWiExp(type, e1, e2, extractArrayFiType(firstArgType), state, structs);
	} else {
		fcPrimBools2flowWiExp(type, e1, e2);
	}
}

fcPrimBools2flowWiExp(type : FcPrim, e1 : FlowWiExp, e2 : FlowWiExp) -> Maybe<FlowWiExp> {
	makeDef = \-> {
		println("TODO : join expression " + toString(type));
		None();
	}
	makeError = \-> {
		println("Wrong operation : " + toString(type) + " (" + toString(e1) + ", " + toString(e2) + ")");
		None();
	}
	makeExp = \e -> Some(FlowWiBrace([e]));
	switch (type : FcPrim) {
		FcOrPrim() : makeExp(FlowWiBoolOr(e1, e2));
		FcAndPrim() : makeExp(FlowWiBoolAnd(e1, e2));
		FcNotPrim() : makeError();
		FcEqPrim() : makeExp(FlowWiEqual(e1, e2));
		FcNePrim() : makeExp(FlowWiNotEqual(e1, e2));
		FcLePrim() : makeExp(FlowWiLessEqual(e1, e2));
		FcGePrim() : makeExp(FlowWiGreaterEqual(e1, e2));
		FcLtPrim() : makeExp(FlowWiLess(e1, e2));
		FcGtPrim() : makeExp(FlowWiGreater(e1, e2));
		FcPlusPrim() : makeExp(FlowWiAdd(e1, e2));
		FcMinusPrim() : makeExp(FlowWiSub(e1, e2));
		FcMulPrim() : makeExp(FlowWiMul(e1, e2));
		FcDivPrim() : makeExp(FlowWiDiv(e1, e2));
		FcModPrim() : makeExp(FlowWiMod(e1, e2));
		FcNegPrim() : makeError();
		FcArrayPrim() : makeDef();
		FcIndexPrim() :  makeDef();
		FcDerefPrim() : makeDef();
		FcAssignPrim() : makeDef();
		FcRefPrim() : makeDef(); 
		FcStructPrim(structName) : makeDef();
		FcFieldPrim(name) : makeDef(); 
		FcSetMutablePrim(name) : makeDef();
		FcCreateClosurePrim(structName, functionName) : makeDef();
		FcQuote() : makeDef();
		FcUnquote() : makeDef();
	}
}

// TODO: array type (compare by value, and not by pointer)
fcPrimArrays2flowWiExp(type : FcPrim, e1 : FlowWiExp, e2 : FlowWiExp, valueType : FiType, state : FiWiseState, structs : StructTuple) -> Maybe<FlowWiExp> {
	makeError = \-> {
		println("Wrong operation : " + toString(type) + " (" + toString(e1) + ", " + toString(e2) + ")");
		None();
	}

	makeCompareFn = \-> FlowWiCall(
		FlowWiPolyCall(FlowWiVar("compareArrays"), [fiType2FlowWiType(valueType, structs)]),
		[e1, e2/* , fiExp2FlowWiExp(state, fiType2defVal(valueType), structs) */]
	);

	makeExp = \e -> Some(FlowWiBrace([e]));

	switch (type : FcPrim) {
		FcOrPrim() : makeError();
		FcAndPrim() : makeError();
		FcNotPrim() : makeError();
		FcEqPrim() : makeExp(FlowWiEqual(makeCompareFn(), FlowWiInt(0)));
		FcNePrim() : makeExp(FlowWiNotEqual(makeCompareFn(), FlowWiInt(0)));
		FcLePrim() : makeExp(FlowWiLessEqual(makeCompareFn(), FlowWiInt(0)));
		FcGePrim() : makeExp(FlowWiGreaterEqual(makeCompareFn(), FlowWiInt(0)));
		FcLtPrim() : makeExp(FlowWiEqual(makeCompareFn(), FlowWiInt(-1)));
		FcGtPrim() : makeExp(FlowWiEqual(makeCompareFn(), FlowWiInt(1)));
		FcPlusPrim() : makeError();
		FcMinusPrim() : makeError();
		FcMulPrim() : makeError();
		FcDivPrim() : makeError();
		FcModPrim() : makeError();
		FcNegPrim() : makeError();
		FcArrayPrim() : makeError();
		FcIndexPrim() : Some(makeWiArrayIndex(e1, e2, fiType2FlowWiType(valueType, structs)));
		FcDerefPrim() : makeError();
		FcAssignPrim() : makeError();
		FcRefPrim() : makeError(); 
		FcStructPrim(__) : makeError();
		FcFieldPrim(__) : makeError(); 
		FcSetMutablePrim(__) : makeError();
		FcCreateClosurePrim(__, __) : makeError();
		FcQuote() : makeError();
		FcUnquote() : makeError();
	}
}

// TODO: fix this ugly function
resolveWiFnName(exp : FlowWiExp, args : [FiExp], structs : StructTuple) -> Pair<FlowWiExp, [FiExp]> {
	fiName2wiseFnInf = \fnName : string -> {
		if (fnName == "concat") Pair("concatArrays", true)
		else if (fnName == "arrayPush") Pair("arrayPush", true)
		else if (fnName == "length") Pair("getLengthArray", false)
		else if (fnName == "subrange") Pair("subrangeArray", true)
		else if (fnName == "replace") Pair("replaceArray", true)
		else Pair("", false);
	}
	makeArrayFnForFiType = \type, fnName -> {
		fnInf = switch (type : FiType) {
			FiTypeInt() : fiName2wiseFnInf(fnName);
			FiTypeDouble() : fiName2wiseFnInf(fnName);
			FiTypeBool() : fiName2wiseFnInf(fnName);
			FiTypeString() : fiName2wiseFnInf(fnName);
			FiTypeArray(__) : fiName2wiseFnInf(fnName);
			default : Pair("", false);
		}
		unpair(fnInf, \name : string, tmplFn : bool -> {
			if (name == "") {
				println(fnName + " for '" + toString(type) + "' isn't implemented");
				Pair(exp, args);
			} else {
				fnExp = if (tmplFn) {
					FlowWiPolyCall(FlowWiVar(name), [fiType2FlowWiType(type, structs)])
				} else {
					FlowWiVar(name);
				}
				Pair(fnExp, args);
			}
		});
	}

	// TODO: fix FiTypeParameter
	resolveArrType = \arrType, defType -> {
		if (isSameStructType(arrType, FiTypeParameter(""))) defType else arrType;
	}

	switch (exp : FlowWiExp) {
		FlowWiVar(id) : if (id == "println" && args != []) {
			Pair(makeFlowWiPrint(args[0]), args);
		} else if ((id == "length" || id == "subrange") && args != []) {
			makeArrayFnForFiType(resolveArrType(extractArrayFiTypeFromExp(args[0]), FiTypeInt()), id);
		} else if (id == "concat" && length(args) == 2) {
			arrType = resolveArrType(extractArrayFiTypeFromExp(args[0]), extractArrayFiTypeFromExp(args[1]));
			makeArrayFnForFiType(resolveArrType(arrType, FiTypeInt()), id)
		} else if (id == "arrayPush" && length(args) == 2) {
			makeArrayFnForFiType(extractArrayFiTypeFromExp(args[1]), id)
			} else if (id == "replace" && length(args) == 3) {
			makeArrayFnForFiType(extractArrayFiTypeFromExp(args[2]), id)
		} else {
			Pair(exp, args);
		}
		default : Pair(exp, args);
	}
}

makeFlowWiPrint(exp : FiExp) -> FlowWiExp {
	makeNativePrintln = \fnName -> FlowWiVar(fnName);
	makeDefPrintln = \desc -> {
		println("println for '" + desc + "' isn't implemented");
		makeNativePrintln("println");
	}
	makePrintForFiType = \type -> switch (type : FiType) {
		FiTypeBool() : makeNativePrintln("printlnb");
		FiTypeInt() : makeNativePrintln("printlni32");
		FiTypeDouble() : makeNativePrintln("printlnf64");
		FiTypeVoid() : makeNativePrintln("printv128");
		FiTypeString() : makeNativePrintln("printlnStr");
		default : makeDefPrintln(toString(type));
	}
	switch (exp : FiExp) {
		FiBool(__, __) : makePrintForFiType(FiTypeBool());
		FiInt(__, __) : makePrintForFiType(FiTypeInt());
		FiDouble(v, __) : makePrintForFiType(FiTypeDouble());
		FiString(v, __) : makePrintForFiType(FiTypeString());
		FiVoid(__) : makePrintForFiType(FiTypeVoid());
		FiVar(__, type, __) : makePrintForFiType(type);
		FiCallPrim(__, __, type, __): makePrintForFiType(type);
		FiIf(__, __, __, type, __) : makePrintForFiType(type);
		FiLambda(__, __, type, start) : makePrintForFiType(type);
		FiCall(__, __, type, __) : makePrintForFiType(type);
		FiLet(__, type, __, __, type2, __) : makePrintForFiType(type);
		FiSwitch(__, switchType, __, type, __) : makePrintForFiType(type);
		FiCast(__, tFrom, tTo, type, __) : makePrintForFiType(tTo);
		FiSeq(__, type, __) : makePrintForFiType(type);
		FiRequire(__, __, type, __) : makePrintForFiType(type);
		FiUnsafe(__, __, type, __) : makePrintForFiType(type);
	}
}

extractArrayFiTypeFromExp(exp : FiExp) -> FiType {
	extractArrayFiType(extractFiTypeFromFiExp(exp));
}

extractArrayFiType(type : FiType) -> FiType {
	switch (type : FiType) {
		FiTypeArray(t) : t;
		default : type;
	}
}

extractFiTypeFromFiExp(exp : FiExp) -> FiType {
	switch (exp : FiExp) {
		FiBool(__, __) : FiTypeBool();
		FiInt(__, __) : FiTypeInt();
		FiDouble(__, __) : FiTypeDouble();
		FiString(__, __) : FiTypeString();
		FiVoid(__) : FiTypeVoid();
		FiVar(__, type, __) : type;
		FiCallPrim(__, __, type, __): type;
		FiIf(__, __, __, type, __) : type;
		FiLambda(__, __, type, __) : type;
		FiCall(__, __, type, __) : type;
		FiLet(__, type, __, __, type2, __) : type;
		FiSwitch(__, switchType, __, type, __) : type;
		FiCast(__, tFrom, tTo, type, __) : tTo;
		FiSeq(__, type, __) : type;
		FiRequire(__, __, type, __) : type;
		FiUnsafe(__, __, type, __) : type;
	}
}

extractFiVarNameFromFiExp(exp : FiExp) -> string {
	switch (exp : FiExp) {
		FiBool(__, __) : "";
		FiInt(__, __) : "";
		FiDouble(__, __) : "";
		FiString(__, __) : "";
		FiVoid(__) : "";
		FiVar(id, __, __) : id;
		FiCallPrim(__, __, __, __): "";
		FiIf(__, __, __, __, __) : "";
		FiLambda(__, __, __, __) : "";
		FiCall(__, __, __, __) : "";
		FiLet(__, __, __, __, __, __) : "";
		FiSwitch(__, __, __, __, __) : "";
		FiCast(__, __, __, __, __) : "";
		FiSeq(__, __, __) : "";
		FiRequire(__, __, __, __) : "";
		FiUnsafe(__, __, __, __) : "";
	}
}

fiConst2FlowWiExp(state : FiWiseState, exp : FiConst) -> FlowWiExp {
	switch (exp : FiConst) {
		FiVoid(__) : FlowWiTuple([]);
		FiDouble(d, __) : FlowWiDouble(d);
		FiInt(i, __) : FlowWiInt(i);
		FiString(s, __) : {
			eitherFn(
				makeWiArrayConstruction(map(s2a(s), \v -> FlowWiInt(v)), incTmpVarCounter(state), makeStringType()),
				idfn,
				\-> {
					println("TODO: string(" + s + ")");
					FlowWiTuple([]);
				}
			);
		}
		FiBool(b, __) : FlowWiBool(b);
	}
}

fiType2FlowWiType(type : FiType, structs : StructTuple) -> FlowWiType {
	makeDefType = \-> {
		println("TODO Type: " + toString(type));
		FlowWiBasictype("auto");
	}
	switch (type : FiType) {
		FiTypeArray(t) : FlowWiArrayType(fiType2FlowWiType(t, structs));
		FiTypeFunction(args, returnType) : FlowWiFntype(
			map(args, \arg -> fiType2FlowWiType(arg.type, structs)),
			fiType2FlowWiType(returnType, structs)
		);
		FiTypeRef(t) : makeDefType();
		FiTypeParameter(n) : FlowWiBasictype(n);
		FiTypeBool() : FlowWiBasictype("auto");
		FiTypeInt() : FlowWiBasictype("i32");
		FiTypeDouble() : FlowWiBasictype("f64");
		FiTypeString() : FlowWiArrayType(makeStringType());
		FiTypeFlow() : makeDefType();
		FiTypeVoid() :  FlowWiBasictype("auto");
		FiTypeNative() : makeDefType();
		FiTypeName(name, typeparameters) : FlowWiTupletype(eitherFn(
			lookupTree(structs.link, name),
			\args -> map(
				sortCustom(getTreeValues(args.args), \arg -> arg.index, true),
				\arg -> fiType2FlowWiType(arg.type, structs)
			),
			\-> map(typeparameters, \t -> fiType2FlowWiType(t, structs))
		));
	}
}

wiseAst2string(code : FlowWiseAst) -> string {
	switch (code : FlowWiseAst) {
		FlowWiseAstList(value) : foldList(value, "\n", \acc, v -> acc + wiseAst2string(v));
		FlowWiseAstBool(value) : b2s(value);
		FlowWiseAstInt(value) : i2s(value);
		FlowWiseAstDouble(value) : d2s(value);
		FlowWiseAstString(value) : value;
		FlowWiType(): wiType2string(code);
		FlowWiIdtype(id, type) : id + " : " + wiType2string(type);
		FlowWiDecl() : wiDecl2string(code);
		FlowWiExp() : wiExp2string(code, None());
	}
}

wiDecl2string(decl : FlowWiDecl) -> string {
	switch (decl : FlowWiDecl) {
		FlowWiFunction(id, optexport, templates, lambdaargs, type, e, decl2) : {
			parentExp = None();
			"\n" + (if (s2b(optexport)) "export " else " ")
			+ wiVar2string(id, parentExp)
			+ (if (templates == []) "" else "[" + strGlue(templates, ",")+ "]")
			+ "(" + strGlue(map(lambdaargs, wiseAst2string), ", ") + ")"
			+ " -> " + wiType2string(type)
			+ " {\n"
			+ "\t" + initMemory(id) + "\n"
			+ "\t" + wiExp2string(e, parentExp)
			+ "\n}\n"
			+ wiDecl2string(decl2);
		}
		FlowWiGlobal(id, optexport, type, optmutable, expression, decl2) : "TODO Decl[" + toString(decl)+"]";
		FlowWiImport(id1, type, optmutable, id2, id3, decl2) : "TODO Decl[" + toString(decl)+"]";
		FlowWiWaseEmpty() : "";
		FlowWiFlowWiseInclude(s, decl2) : {
			"include " + s + ";\n"
			+ wiseAst2string(decl2);
		}
	}
}

wiType2string(type : FlowWiType) -> string {
	switch (type : FlowWiType) {
		FlowWiBasictype(s) : s; // TODO ?
		FlowWiFntype(types, returnType) : "(" + strGlue(map(types, wiType2string), ", ") + ") -> " + wiType2string(returnType);
		FlowWiTupletype(types) : "(" + strGlue(map(types, wiType2string), ", ") + ")";
		FlowWiArrayType(t) : "i32"; // pointer
	}
	
}

wiExp2string(exp : FlowWiExp, parent : Maybe<FlowWiExp>) -> string {
	joinExp = \sign : string, exp1 : FlowWiExp, exp2 : FlowWiExp -> {
		"(" + wiseAst2string(exp1) + " " + sign + " " + wiseAst2string(exp2) + ")";
	}
	eol = "\n\t";
	wiExpDef2string = \e -> wiExp2string(e, None());
	switch (exp : FlowWiExp) {
		FlowWiAdd(exp1, exp2) : joinExp("+", exp1, exp2);
		FlowWiSub(exp1, exp2) : joinExp("-", exp1, exp2);
		FlowWiAnd(exp1, exp2) : joinExp("&", exp1, exp2);
		FlowWiBoolAnd(exp1, exp2) : joinExp("&&", exp1, exp2);
		FlowWiBoolNot(e) : "!" + wiseAst2string(e); // TODO ?
		FlowWiBoolOr(exp1, exp2) : joinExp("||", exp1, exp2);
		FlowWiXor(exp1, exp2) : joinExp("^", exp1, exp2);
		FlowWiBrace(exps) : {
			expressions = map(extractExpsFromFlowWiBrace(exp, []), \e -> wiExp2string(e, Some(exp)));
			if (expressions == []) {
				""
			} else if (length(expressions) == 1) {
				expressions[0];
			} else {
				"{" + eol + strGlue(expressions, ";" + eol) + ";" + eol + "}";
				
			}
		}
		FlowWiCall(e, exps) : wiExp2string(e, Some(exp)) + "(" + strGlue(map(exps, wiExpDef2string), ", ") + ")";
		FlowWiPolyCall(e, types) : wiExp2string(e, Some(exp))  + "[" + superglue(types, wiType2string, ", ") + "]";
		FlowWiDiv(exp1, exp2) : joinExp("/", exp1, exp2);
		FlowWiEqual(exp1, exp2) : joinExp("==", exp1, exp2);
		FlowWiGreater(exp1, exp2) : joinExp(">", exp1, exp2);
		FlowWiGreaterEqual(exp1, exp2) : joinExp(">=", exp1, exp2);
		// FlowWiGreaterEqualu(exp1 : FlowWiExp, exp2 : FlowWiExp);
		// FlowWiGreateru(exp1 : FlowWiExp, exp2 : FlowWiExp);
		FlowWiLess(exp1, exp2) : joinExp("<", exp1, exp2);
		FlowWiLessEqual(exp1, exp2) : joinExp("<=", exp1, exp2);
		// FlowWiLessEqualu(exp1, exp2) : joinExp("<=", exp1, exp2); // TODO: ?
		// FlowWiLessu(exp1, exp2) : joinExp("<", exp1, exp2); // TODO: ?
		// FlowWiIsNull(e : FlowWiExp);
		FlowWiTupledot(e, index) : wiExp2string(e, None()) + "." + i2s(index);
		FlowWiTypeannotation(e, type) : ""; // ignore declaration
		FlowWiLet(id, i, opttype, e, brace) : {
			body = wiExpDef2string(brace);
			id + " : " + wiType2string(opttype) + " = " + wiExpDef2string(e) + ";"
			+ eol + rtrim2(ltrim2(body, "{"), "}");
		}
		// FlowWiWasmOp(s : string, wargs : [FlowWiWarg], exps : [FlowWiExp]);
		FlowWiMod(exp1, exp2) : joinExp("%", exp1, exp2);
		FlowWiMul(exp1, exp2) : joinExp("*", exp1, exp2);
		FlowWiNegate(e) : "-" + wiExpDef2string(e);
		FlowWiNotEqual(exp1, exp2) : joinExp("!=", exp1, exp2);
		FlowWiOr(exp1, exp2) : joinExp("|", exp1, exp2);
		FlowWiAtom(): wiAtom2string(exp, parent);
		default : "TODO[" + toString(exp)+"]";
	}
}

extractExpsFromFlowWiBrace(e : FlowWiBrace, acc : [FlowWiExp]) -> [FlowWiExp] {
	concat(
		acc,
		mapConcat(e.expsemi, \s -> 
			if (isSameStructType(s, FlowWiBrace([]))) extractExpsFromFlowWiBrace(s, []) else [s]
		)
	)
}

wiAtom2string(exp : FlowWiAtom, parent : Maybe<FlowWiExp>) -> string {
	eol = "\n\t";
	switch (exp : FlowWiAtom) {
		FlowWiBool(b) : if (b) "true" else "false";
		FlowWiInt(int_0) : i2s(int_0);
		FlowWiDouble(double_0) : {
			// TODO: find the reason ? 
			// ds(0.0) == 0 == i32
			isInt = isDigits(d2s(if (double_0 >= 0.) double_0 else double_0 * (-1.)));
			d2s(double_0) + (if (isInt) ".0" else "");
		}
		FlowWiTuple(exps) : "(" + strGlue(map(exps, \e -> wiExp2string(e, None())), ", ") + ")";
		FlowWiVar(id) : wiVar2string(id, parent);
		FlowWiSet(id, e) : id + " := " + wiseAst2string(e) + ";";
		FlowWiIf(exp1, exp2) : {
			"if (" + wiExp2string(exp1, None()) + ") {"
			+ eol + wiExp2string(exp2, None()) + eol
			+ "}";
		}
		FlowWiIfelse(exp1, exp2, exp3) : {
			"if (" + wiExp2string(exp1, None()) + ") {"
			+ eol + wiExp2string(exp2, None()) + "\n"
			+ "} else {"
			+ eol + wiExp2string(exp3, None()) + "\n"
			+ "}";
		}
		// FlowWiBreak();
		// FlowWiContinue();
		// FlowWiReturn(exps : [FlowWiExp]);
		// FlowWiWhile(exp1 : FlowWiExp, exp2 : FlowWiExp);

		// FlowWiHex32(s : string);
		// FlowWiHex64(s : string);
		// FlowWiHexf32(s : string);
		// FlowWiHexf64(s : string);
		// FlowWiI64(s : string);
		default : "TODO_Atom[" + toString(exp)+"]";
	}
}

// temporary function
wiVar2string(name : string, parent : Maybe<FlowWiExp>) -> string {
	if (isMainFn(name)) {
		"export _start"
	} else if (name == "println") {
		""
	} else {
		name;
	}
}

isMainFn(name : string) -> bool {
	name == "main";
}

initMemory(fnName : string) -> string {
	if (isMainFn(fnName)) {
		wiExp2string(FlowWiCall(FlowWiVar("initMemory"), []), None()) + ";";
	} else {
		""
	}
}