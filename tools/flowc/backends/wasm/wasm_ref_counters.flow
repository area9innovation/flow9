import tools/flowc/incremental/fitype;
import tools/flowc/manipulation/split_expressions;
import tools/flowc/backends/common;
import tools/flowc/backends/wasm/wasm_types;
import tools/flowc/backends/wasm/f2wasm_utils;
import tools/flowc/backends/wasm/wasm_exp;
import tools/flowc/backends/wasm/wasm_exp_convert;
import ds/array;
import string;

export {
    fiWasmInjectTempVariables(ex : FiExp) -> FiExp;
    wasmAddRefcounting(e : WasmExp, args : [WasmFunArg]) -> WasmExp;
}

// checks if the statement is last in control flow sense - there is no nesting
// i.e. consts or vars are last, while if, switch, or sequence are not
wasmIsLastStemenet(ex : WasmExp) {
    ex0 : WasmExp = ex;
    switch (ex0 : WasmExp) {
		WasmLambda(__, __, __, __): true;
		WasmCall(__, __, __, __, __): true;
		WasmVar(__, __, __): true;
		WasmLet(__, __, __, e2, __, __): 
			switch (e2) {
				WasmVoid(__): true;
				default: false;
			} 
		WasmIf(e1, e2, e3, __, __): false;
		WasmSwitch(__, __, cases, __, __): false;
		WasmCast(__, __, __, __, __): true;
		WasmSeq(es, __, iid): false;
		WasmCallPrim(__, __, __, __): true;
		WasmVoid(__): true;
		WasmDouble(__, __): true;
		WasmInt(__, __): true;
		WasmString(__, __): true;
		WasmBool(__, __): true;
		WasmRequire(__, __, __, __): true; 
		WasmUnsafe(__, fallback, __, __): false;
        WasmIncRefcnt(__, __, __): true;
        WasmDecRefcnt(__, __, __): true;
	}
}

fiTypeUsesWasmHeap(t : FiType) {
	switch (t) {
		FiTypeVoid(): false;
		FiTypeDouble(): false;
		FiTypeInt(): false;
		FiTypeBool(): false;
		default: true;
	}
}

fiWasmInjectTempVariables(ex : FiExp) {
	splitExpressions(ex, fiTypeUsesWasmHeap);
}

wasmAddRefcounting(ex : WasmExp, args : [WasmFunArg]) {
    scopeVars = map(filter(args, \a -> wasmTypeUsesWasmHeap(a.type)), \a -> {
        if (a.name == "") println("Internal error: empty var name passed as scope parameter");
        WasmScopeVar(a.name, a.type, false);
    });
    fiWasmInjectIncrements(ex, scopeVars, false);
}

// not last means never consider this statement last - i.e. it can be part of a sequence
fiWasmInjectIncrements(ex : WasmExp, scopeVars : [WasmScopeVar], notLast : bool) {
    rec = \e -> fiWasmInjectIncrements(e, scopeVars, notLast);
    recNotLast = \e -> fiWasmInjectIncrements(e, scopeVars, true);
    destructedVars = if (!notLast && wasmIsLastStemenet(ex)) scopeVars else [];

    switch (ex : WasmExp) {
		WasmLambda(args, b, type, __): WasmLambda(ex with destructedVars=destructedVars);
		WasmCall(f, args, type, callType, __): 
            WasmCall(f, 
                map(args, recNotLast), type, callType, destructedVars);
		WasmVar(name, type, __): 
            if (wasmTypeUsesWasmHeap(type))
                WasmIncRefcnt(ex, type, destructedVars)
            else
                WasmVar(ex with destructedVars=destructedVars);
		WasmLet(name, type, e1, e2, type2, __): {
            newScopeVars = if (wasmTypeUsesWasmHeap(type)) 
                arrayPush(scopeVars, WasmScopeVar(name, type, true))
            else
                scopeVars;
            isE2Empty = switch (e2) {
                WasmVoid(__) : true;
                default : false;
            }
			WasmLet(name, type, fiWasmInjectIncrements(e1, scopeVars, notLast || !isE2Empty), 
                fiWasmInjectIncrements(e2, newScopeVars, notLast), type2, destructedVars); 
        }
		WasmIf(e1, e2, e3, type, __): 
			WasmIf(recNotLast(e1), rec(e2), rec(e3), type, destructedVars);
		WasmSwitch(x, switchType, cases, type, __): 
			WasmSwitch(x, switchType, // TODO : this is implicit scope
                map(cases, \c -> WasmCase(c.struct, c.argNames, rec(c.body))),
                type, destructedVars);
		WasmCast(e, tFrom, tTo, type, __): 
            WasmCast(recNotLast(e), tFrom, tTo, type, destructedVars);
		WasmSeq(es, type, __): 
            WasmSeq(mapi(es, 
                \i, e -> fiWasmInjectIncrements(e, scopeVars, notLast || i != length(es) - 1)
                ), type, destructedVars);
		WasmCallPrim(op, es, type, __): WasmCallPrim(op, map(es, recNotLast), type, destructedVars);
		WasmVoid(__): WasmVoid(destructedVars);
		WasmDouble(__, __): WasmDouble(ex with destructedVars=destructedVars);
		WasmInt(__, __): WasmInt(ex with destructedVars=destructedVars);
		WasmString(__, __): WasmIncRefcnt(ex, WasmTypeString(), destructedVars);
		WasmBool(__, __): WasmBool(ex with destructedVars=destructedVars);
		WasmRequire(flowfile, e, type, id): WasmRequire(flowfile, rec(e), type, destructedVars); 
		WasmUnsafe(name, fallback, type, id): WasmUnsafe(name, rec(fallback), type, destructedVars);
        WasmIncRefcnt(__, __, __): ex; // should not happen
        WasmDecRefcnt(__, __, __): ex; // should not happen
	}
}
