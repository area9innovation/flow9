import tools/flowc/incremental/fitype;
import tools/flowc/manipulation/split_expressions;
import tools/flowc/backends/common;
import tools/flowc/backends/wasm/wasm_types;
import tools/flowc/backends/wasm/f2wasm_utils;
import tools/flowc/backends/wasm/wasm_exp;
import tools/flowc/backends/wasm/wasm_exp_convert;
import ds/array;
import string;

export {
    fiWasmFindLastStatements(ex : WasmExp) -> Set<WasmExp>;
    fiWasmGenerateDestructors(vars : [Pair<string, WasmTypeDescriptor>]) -> string;
	fiWasmGenerateConstructor(type : WasmTypeDescriptor) -> Wasm2Cmd;
    fiWasmInjectTempVariables(ex : FiExp) -> FiExp;
    fiWasmInjectIncrements(e : WasmExp) -> WasmExp;
}

fiWasmFindLastStatements(ex : WasmExp) {
    ex0 : WasmExp = ex;
    switch (ex0 : WasmExp) {
		WasmLambda(args, b, type, __): makeSet1(ex);
		WasmCall(f, args, type, __, __): makeSet1(ex);
		WasmVar(name, type, __): makeSet1(ex);
		WasmLet(name, type, e1, e2, type2, __): 
			switch (e2) {
				WasmVoid(__): makeSet1(ex);
				default: fiWasmFindLastStatements(e2);
			} 
		WasmIf(e1, e2, e3, type, __): // consider both if and else branches
			mergeSets(fiWasmFindLastStatements(e2), fiWasmFindLastStatements(e3));
		WasmSwitch(x, switchType, cases, type, __): 
			mergeSetsA(map(cases, \c -> fiWasmFindLastStatements(c.body)));
		WasmCast(e, tFrom, tTo, type, __): makeSet1(ex);
		WasmSeq(es, type, iid): // only consider last element of a sequence
			fiWasmFindLastStatements(lastElement(es, WasmVoid(iid)));
		// if there are calls inside es, CallPrim would be performed after it - 
		//   therefore, those calls aren't tail
		WasmCallPrim(op, es, type, __): makeSet1(ex); 
		WasmVoid(__): makeSet1(ex);
		WasmDouble(d, __): makeSet1(ex);
		WasmInt(i, __): makeSet1(ex);
		WasmString(s, __): makeSet1(ex);
		WasmBool(b, __): makeSet1(ex);
		WasmRequire(flowfile, e, type, __): makeSet1(ex); 
		WasmUnsafe(name, fallback, type, __): fiWasmFindLastStatements(fallback);
        WasmIncRefcnt(e, __, __): makeSet1(ex);
	}
}

fiWasmGenerateDestructors(vars : [Pair<string, WasmTypeDescriptor>]) {
    filtered = filter(vars, \v -> wasmTypeUsesWasmHeap(v.second));
    fold(filtered, "", \acc, v -> acc + " get_local $" + v.first + " call $wasm_dec_refcnt ;; auto-destruct \n");
}

fiWasmGenerateConstructor(type : WasmTypeDescriptor) {
	if (wasmTypeUsesWasmHeap(type)) Wasm2Call("$wasm_inc_refcnt_passthru")
	else Wasm2Void()
}

fiWasmTypeUsesHeap(t : FiType) {
	switch (t) {
		FiTypeVoid(): false;
		FiTypeDouble(): false;
		FiTypeInt(): false;
		FiTypeBool(): false;
		FiTypeNative(): false;
		default: true;
	}
}

fiWasmInjectTempVariables(ex : FiExp) {
	splitExpressions(ex, fiWasmTypeUsesHeap);
}

wrapAsIncRefcount(e: WasmExp) -> WasmExp {
    switch (e) {
        WasmVar(__, type, __): {
            if (wasmTypeUsesWasmHeap(type))
                WasmIncRefcnt(e, type, getNextWasmExpId())
            else
                e;
        }
        default: e;
    }
}

fiWasmInjectIncrements(ex : WasmExp) {
    switch (ex : WasmExp) {
		WasmLambda(args, b, type, __): ex;
		WasmCall(f, args, type, callType, id): 
            WasmCall(f, 
                map(args, fiWasmInjectIncrements), type, callType, id);
		WasmVar(name, type, __): 
            if (wasmTypeUsesWasmHeap(type))
                WasmIncRefcnt(ex, type, getNextWasmExpId())
            else
                ex;
		WasmLet(name, type, e1, e2, type2, id): 
			WasmLet(name, type, 
                fiWasmInjectIncrements(e1), 
                fiWasmInjectIncrements(e2), type2, id); 
		WasmIf(e1, e2, e3, type, id): 
			WasmIf(fiWasmInjectIncrements(e1), fiWasmInjectIncrements(e2), fiWasmInjectIncrements(e3), type, id);
		WasmSwitch(x, switchType, cases, type, id): 
			WasmSwitch(x, switchType, 
                map(cases, \c -> WasmCase(c.struct, c.argNames, fiWasmInjectIncrements(c.body), c.id)),
                type, id);
		WasmCast(e, tFrom, tTo, type, id): 
            WasmCast(fiWasmInjectIncrements(e), tFrom, tTo, type, id);
		WasmSeq(es, type, iid): /*{
            total = length(es);
            mapped = mapi(es, \i, e -> {
                injected = fiWasmInjectIncrements(e);
                if (i == total - 1) wrapAsIncRefcount(injected) else injected;
            });
            WasmSeq(mapped, type, iid);
        }*/ WasmSeq(map(es, fiWasmInjectIncrements), type, iid);
			
		WasmCallPrim(op, es, type, id): WasmCallPrim(op, map(es, fiWasmInjectIncrements), type, id);
		WasmVoid(__): ex;
		WasmDouble(d, __): ex;
		WasmInt(i, __): ex;
		WasmString(s, __): WasmIncRefcnt(ex, WasmTypeString(), getNextWasmExpId());
		WasmBool(b, __): ex;
		WasmRequire(flowfile, e, type, id): WasmRequire(flowfile, fiWasmInjectIncrements(e), type, id); 
		WasmUnsafe(name, fallback, type, id): WasmUnsafe(name, fiWasmInjectIncrements(fallback), type, id);
        WasmIncRefcnt(e, __, __): ex; // should not happen
	}
}
