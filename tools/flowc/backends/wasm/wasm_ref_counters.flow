import tools/flowc/incremental/fitype;
import tools/flowc/manipulation/split_expressions;
import tools/flowc/backends/common;
import tools/flowc/backends/wasm/wasm_types;
import tools/flowc/backends/wasm/f2wasm_utils;
import tools/flowc/backends/wasm/wasm_exp;
import tools/flowc/backends/wasm/wasm_exp_convert;
import ds/array;
import string;

export {
    fiWasmInjectTempVariables(ex : FiExp) -> FiExp;
    wasmAddRefcounting(e : WasmExp, args : [WasmFunArg]) -> WasmExp;
}

// checks if the statement is last in control flow sense - there is no nesting
// i.e. consts or vars are last, while if, switch, or sequence are not
wasmIsLastStemenet(ex : WasmExp) {
    ex0 : WasmExp = ex;
    switch (ex0 : WasmExp) {
		WasmLambda(__, __, __, __): true;
		WasmCall(__, __, __, __, __): true;
		WasmVar(__, __, __): true;
		WasmLet(__, __, __, e2, __, __): 
			switch (e2) {
				WasmVoid(__): true;
				default: false;
			} 
		WasmIf(e1, e2, e3, __, __): false;
		WasmSwitch(__, __, cases, __, __): false;
		WasmCast(__, __, __, __, __): true;
		WasmSeq(es, __, iid): false;
		WasmCallPrim(__, __, __, __): true;
		WasmVoid(__): true;
		WasmDouble(__, __): true;
		WasmInt(__, __): true;
		WasmString(__, __): true;
		WasmBool(__, __): true;
		WasmRequire(__, __, __, __): true; 
		WasmUnsafe(__, fallback, __, __): false;
        WasmIncRefcnt(__, __, __): true;
        WasmDecRefcnt(__, __, __): true;
	}
}

fiTypeUsesWasmHeap(t : FiType) {
	switch (t) {
		FiTypeVoid(): false;
		FiTypeDouble(): false;
		FiTypeInt(): false;
		FiTypeBool(): false;
		default: true;
	}
}

fiWasmInjectTempVariables(ex : FiExp) {
	splitExpressions(ex, fiTypeUsesWasmHeap);
}

ScopeVar(
    name : string,
    type : WasmTypeDescriptor,
    isLocal : bool // local vs parameter - important to generate tail calls correctly - parameters shall not be refcnt-decreased
);

wasmAddRefcounting(ex : WasmExp, args : [WasmFunArg]) {
    scopeVars = map(filter(args, \a -> wasmTypeUsesWasmHeap(a.type)), \a -> {
        if (a.name == "") println("Internal error: empty var name passed as scope parameter");
        ScopeVar(a.name, a.type, false);
    });
    fiWasmInjectIncrements(ex, scopeVars, false);
}

// not last means never consider this statement last - i.e. it can be part of a sequence
fiWasmInjectIncrements(ex : WasmExp, scopeVars : [ScopeVar], notLast : bool) {
    rec = \e -> fiWasmInjectIncrements(e, scopeVars, notLast);
    recNotLast = \e -> fiWasmInjectIncrements(e, scopeVars, true);

    result = switch (ex : WasmExp) {
		WasmLambda(args, b, type, __): ex;
		WasmCall(f, args, type, callType, id): 
            WasmCall(f, 
                map(args, recNotLast), type, callType, id);
		WasmVar(name, type, __): 
            if (wasmTypeUsesWasmHeap(type))
                WasmIncRefcnt(ex, type, getNextWasmExpId())
            else
                ex;
		WasmLet(name, type, e1, e2, type2, id): {
            newScopeVars = if (wasmTypeUsesWasmHeap(type)) 
                arrayPush(scopeVars, ScopeVar(name, type, true))
            else
                scopeVars;
            isE2Empty = switch (e2) {
                WasmVoid(__) : true;
                default : false;
            }
			WasmLet(name, type, fiWasmInjectIncrements(e1, scopeVars, notLast || !isE2Empty), 
                fiWasmInjectIncrements(e2, newScopeVars, notLast), type2, id); 
        }
		WasmIf(e1, e2, e3, type, id): 
			WasmIf(recNotLast(e1), rec(e2), rec(e3), type, id);
		WasmSwitch(x, switchType, cases, type, id): 
			WasmSwitch(x, switchType, // TODO : this is implicit scope
                map(cases, \c -> WasmCase(c.struct, c.argNames, rec(c.body), c.id)),
                type, id);
		WasmCast(e, tFrom, tTo, type, id): 
            WasmCast(recNotLast(e), tFrom, tTo, type, id);
		WasmSeq(es, type, iid): 
            WasmSeq(mapi(es, 
                \i, e -> fiWasmInjectIncrements(e, scopeVars, notLast || i != length(es) - 1)
                ), type, iid);
		WasmCallPrim(op, es, type, id): WasmCallPrim(op, map(es, recNotLast), type, id);
		WasmVoid(__): ex;
		WasmDouble(__, __): ex;
		WasmInt(__, __): ex;
		WasmString(__, __): WasmIncRefcnt(ex, WasmTypeString(), getNextWasmExpId());
		WasmBool(__, __): ex;
		WasmRequire(flowfile, e, type, id): WasmRequire(flowfile, rec(e), type, id); 
		WasmUnsafe(name, fallback, type, id): WasmUnsafe(name, rec(fallback), type, id);
        WasmIncRefcnt(__, __, __): ex; // should not happen
        WasmDecRefcnt(__, __, __): ex; // should not happen
	}

    if (!notLast && wasmIsLastStemenet(ex) && length(scopeVars) > 0) {
        destructors = map(scopeVars, \v -> WasmDecRefcnt(v.name, v.type, getNextWasmExpId()));
        WasmSeq(concat([result], destructors), wasmExpType(result), getNextWasmExpId());
    } else result;
}
