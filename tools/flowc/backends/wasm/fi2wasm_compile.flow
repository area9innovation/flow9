import tools/flowc/backends/common;
import tools/flowc/incremental/fiprogram;
import tools/flowc/incremental/fi_helpers;
import tools/flowc/manipulation/explicit_casts;
import tools/flowc/backends/wasm/wasm_types;
import tools/flowc/backends/wasm/wasm_exp;
import tools/flowc/backends/wasm/wasm_exp_convert;
import tools/flowc/backends/wasm/f2wasm_utils;
import tools/flowc/backends/wasm/wasm_string_constants;
import tools/flowc/backends/wasm/wasm_type_descriptor;
import tools/flowc/backends/wasm/wasm_function_table;
import tools/flowc/backends/wasm/wasm_ref_counters;
import text/blueprint;

import tools/flowc/backends/wasm/wasm_print;

export {
	fiWasmCompileToplevel(
		cfg : FiWasmConfig,
		program : FiProgram,
		context : WasmContext,
		decl : FiDeclaration
	) -> string;

	// Produce export statements for exported functions
	fiWasmCompileModuleExports(
		module: FiModule, 
		acc: List<string>
	) -> List<string>;

	fiWasmCompileFunctionDecl(
		cfg : FiWasmConfig,
		decl : FiFunctionDec, 
		acc : WasmAcc, 
		context : WasmContext
	) -> string;
}

fiWasmCompileToplevel(
	cfg : FiWasmConfig,
	program : FiProgram,
	context : WasmContext,
	decl : FiDeclaration,
	) -> string {

	nm = decl.name;

	fcVerbose(cfg, 1, "Generating Wasm code for " + nm + "...");

	acc = WasmAcc(ref 0);
	res = switch (decl) {
		FiFunctionDec(name, lambda, type, declStart, defiStart): {
			fiWasmCompileFunctionDecl(cfg, decl, acc, context);
		}
		FiGlobalVar(name, value, type, declStart, defiStart): {
			fiWasmCompileGlobalVar(cfg, decl, acc, context);
		}
		FiNativeDec(name, io, type, nativeName, fallbackLambda, declStart, defiStart): {
			"";
		}
	}

	if (^(acc.errors) == 0) {
		// fcPrintln("Compiled " + decl.name);
		res
	}
	else {
		// fcPrintln("Could not compile " + decl.name);
		"";
	}
}

fiWasmCompileGlobalVar(cfg : FiWasmConfig, decl : FiGlobalVar, acc : WasmAcc, context : WasmContext) {
    // we can only inline initializer for simple types and constants
    // for other initializers, we need to generate an initializer function
    wasmTyp = fitype2wasmtype(context.globalNames, decl.type);
    wasmType = compileWasmType(wasmTyp, false);
    useInitFunction = wasmTypeUsesWasmHeap(wasmTyp) || !fiExpIsConstant(decl.value); 
	if (useInitFunction) {
		initFunction = FiFunctionDec("wasm__init__global__var__" + decl.name, 
			FiLambda([], decl.value, FiTypeFunction([], decl.type), decl.declStart),
			FiTypeFunction([], decl.type),
			decl.declStart, decl.defiStart);
		wasmInitFunction = fiWasmCompileFunctionDecl(cfg, initFunction, acc, context);
		wasmExpr = "\t call $" + initFunction.name + " set_global $" + decl.name + "\n";
		context.globalVarsInitializers := Cons(Pair(decl.name, wasmExpr), ^(context.globalVarsInitializers));
		"\n" + wasmInitFunction + 
		"\n(global $" + decl.name + " (mut " + wasmType + ") " + wasmType + ".const 0)"
	} else {
		// support for mutable global variables - they start with wasm_ and end with _mut
		mut = startsWith(decl.name, "wasm_") && endsWith(decl.name, "_mut");
		mutPref = if (mut) "(mut " else "";
		mutSuff = if (mut) ")" else "";
		expandedDecl = cast(expandFlowCasts(decl) : FiDeclaration -> FiGlobalVar);
		wasmValue = fiexp2wasmexp(context, context.globalNames, fiWasmInjectTempVariables(expandedDecl.value));
		"(global $" + decl.name + " " + mutPref + wasmType + mutSuff + " " + 
			compileWasmExp(acc, wasmValue, context) + ")";
	}
}

fiWasmCompileFunctionDecl(cfg : FiWasmConfig, decl : FiFunctionDec, acc : WasmAcc, context : WasmContext) {
	expandedDecl = cast(expandFlowCasts(decl) : FiDeclaration -> FiFunctionDec);
	fiBody = fiWasmInjectTempVariables(expandedDecl.lambda.body);
	wasmBody = fiexp2wasmexp(context, context.globalNames, fiBody);
	wasmType = cast(fitype2wasmtype(context.globalNames, decl.type) : WasmTypeDescriptor -> WasmTypeFunction);
    wasmBodyConverted = wasmAddRefcounting(wasmBody, wasmType.args);

	doWasmCompileFunctionDecl(acc, context, decl.name, wasmBodyConverted, wasmType);
}

// compiles a function or lambda declaration
doWasmCompileFunctionDecl(acc : WasmAcc, context : WasmContext, 
	name : string, lambdaBody : WasmExp, type : WasmTypeFunction) {

	locals = getWasmLocals(acc, lambdaBody, makeTree());
	params = values2treeEx(type.args, \a -> a.name, \b -> b.type);
	paramPairs = concat(map(type.args, \a -> Pair(a.name, a.type)),
		// passing closure as implicit parameter to be destroyed if we need
		// struct name is dummy - it does not matter which name it is
		// we only need to do that for lambdas - global functions always get closures == 0
		if (fiWasmFunctionNeedsClosureParam(name) && strContains(name, "__lambda__")) [Pair("__closure__", WasmTypeStruct("", []))]
			else []);
	tailCalls = fiWasmCollectTailCalls(name, lambdaBody, []);
	resultClause = (if (type.returnType != WasmTypeVoid()) // to be used when generating tail call block
		" (result " + compileWasmType(type.returnType, false) + ")" else "");

	//	we'll not inject module start section for main() but instead forcibly add 'main' into export and call it after WASM module instantiated
	fiWasmBuildFunctionDecl(name, type, false, false) + "\n"
	//   (local $x i32)
	+ strGlue(convertTreeToArray(locals, \n, t -> "(local $" + n + " " + compileWasmType(t, false) + ") "), "\n")
	+ (if (length(tailCalls) > 0) // tail call requires wrapping in a loop
		"(block $exit " + resultClause + "\n(loop $cont " + resultClause + "\n" else "")
	+ (if (isSameStructType(lambdaBody, FiVoid(0))) "" else 
		compileWasmExp(acc, lambdaBody, 
			WasmContext(context with 
				tailCalls = tailCalls, 
				localNames = mergeTree(locals, pairs2tree(paramPairs)))
	  ))
	+ (if (length(tailCalls) > 0) "br $exit))" else "") // finalizing tail call wrapper
	+ "\n)"
}

fiWasmCompileModuleExports(module: FiModule, acc: List<string>) -> List<string> {
	// forcibly add 'main' as exported
	ac0 = Cons("(export \"main\" (func " + fiWasmBuildFunctionName("main") + "))\n", acc);
	ac1 = Cons("(export \"wasm_alloc\" (func " + fiWasmBuildFunctionName("wasm_alloc") + "))\n", ac0); 
	ac2 = Cons("(export \"wasm_free\" (func " + fiWasmBuildFunctionName("wasm_free") + "))\n", ac1); 
	ac3 = Cons("(export \"wasm_descriptor_from_type\" (func " + fiWasmBuildFunctionName("wasm_descriptor_from_type") + "))\n", ac2); 
	ac = Cons("(export \"wasm_init_runtime\" (func $wasm_init_runtime))\n", ac3);

	if (length(module.exports) == 0) {
		ac;
	} else {
		fold(module.exports, ac, \accc, s -> {
			Cons("(export \"" + s + "\" (func " + fiWasmBuildFunctionName(s) + "))\n", accc);
		});
	}
}

fiWasmBuildIndirectCall(acc : WasmAcc, callExp1 : Wasm2Cmd, type : WasmTypeDescriptor, 
    context : WasmContext, destructors : [Wasm2Cmd]) -> Wasm2Cmd {
	// assuming calling a closure - indirect call
	// we do not need the exact struct type - but we know first field is function index
	Wasm2Seq([
		callExp1, // put closure pointer as a last extra implicit argument
		Wasm2Call("$wasm_inc_refcnt_passthru"), // increase refcount for it
		// We have callExp on stack already. Should we use DUP here?
		callExp1, // loading pointer to the closure again - we need it to get function address
		Wasm2I32Const(8), Wasm2Code("i32.add"), // add 8 to what we have provided (0 = refcount, 4 = struct ID)
		Wasm2Code("i32.load"), // now we have function index loaded 
		// and closure remains the implicit first argument on stack
		Wasm2Seq(destructors), // inject destructors right before the call with all data on stack already
		// the syntax is "(call_indirect <inline_type_declaration>)"
		Wasm2Code("(call_indirect " 
			+ fiWasmBuildFunctionDecl("", type, true, false) + " )")
	])
}

fiWasmBuildNativeFunctionCall(acc : WasmAcc, func: string, args: [WasmExp], type : WasmTypeFunction, nativeDec: FiWasmNativeDec, context : WasmContext) -> string {
	nativeName = nativeDec.decl.nativeName;

	if (startsWith(nativeName, "wasm."))
		strReplace(strRight(nativeName, 5), "__", "/")
	// in fact this should be wrapped and should not happen here
	// else if (startsWith(nativeName, "Native."))
	// 	"call $" + strRight(nativeName, 7)
	else if (fiWasmIsHostNative(nativeName))
		"call $" + func // call to host function is done using its flow name, native linkage done in imports
	else if (nativeName == "wasm_compiler.heap_start") 
		// gets the size of the data segment effectively
		"i32.const " + i2s(context.typeTable.nextOffset)
	else if (nativeName == "wasm_compiler.typetable_start")
		// gets the offset of the typetable in memory - it is located immediately after strings
		"i32.const " + i2s((context.stringAcc).offset)
	else if (nativeName == "wasm_compiler.address_of") {
		// gets the address of its argument - which means nothing has to be emitted, just argument
		// pushed to stack
		argType = type.args[0].type;
		if (!wasmTypeUsesWasmHeap(argType)) 
			wasmError(acc, "Attempt to take an address of a non-heap value")
		else 
			""; 
	} else if (nativeName == "wasm_compiler.stack_size_of") {
		// gets the size of its argument - drops argument and replaces with const
		argType = type.args[0].type;
		"drop i32.const " + i2s(fiWasmTypeStackSize(argType) * 4);
	} else if (nativeName == "wasm_compiler.uses_heap") {
		// puts 0 or 1 depending on whether argument type uses heap - drops the argument first
		// TODO: optimize
		argType = type.args[0].type;
		"drop i32.const " + if (wasmTypeUsesWasmHeap(argType)) "1 " else "0 ";
	} else if (nativeName == "wasm_compiler.type_of") {
		argType = type.args[0].type;
		typeIndex = switch (lookupTree(context.typeTable.typesMap, argType)) {
			None(): { 
				wasmError(acc, "Attempt to take type not in type table");
				0;
			}
			Some(index): index;
		}
		"drop i32.const " + i2s(typeIndex);
	} else if (nativeName == "wasm_compiler.get_string_by_addr") {
		";; wasm_compiler.get_string_by_addr\n"
	} else if (nativeName == "wasm_compiler.call_indirect") {
		args1 = strGlue(mapi(type.args, \i, a -> {
					if (i + 1 < length(type.args)) 
						"(param " + compileWasmType(a.type, false) + ")"
					else ""
				}), " ");
		rt = if (type.returnType == WasmTypeVoid()) "" 
				else " (result " + compileWasmType(type.returnType, false) + ")";
		"(call_indirect " + args1 + rt + ")"
	} else {
		name = if (nativeDec.wrap.name != "") {
			nativeDec.wrap.name;
		} else {
			nativeDec.decl.name;
		}

		"call $" + name;
	}
}

fiWasmBuildHostFunctionCall(acc : WasmAcc, func: string, args: [WasmExp], type : WasmTypeJSCallback, context : WasmContext) -> string {
	"i32.const 0\n" + // hack to cover __closure__ param
	"call $" + fiInvokeName(type, context.typeTable);
}

fiWasmBuildFunctionCall(acc : WasmAcc, func: string, type : WasmTypeFunction, context : WasmContext,
    destructors : [Wasm2Cmd]) -> Wasm2Cmd {
	if (containsKeyTree(context.functions.functionIndices, func)) {
		callCmd = Wasm2Call("$" + func);
		Wasm2Seq(concat(destructors,
			if (startsWith(func, "wasm_"))
				// call function in runtime library directly, no dummy closure
				[callCmd] 
			else 
				// call global function and pass dummy closure argument as last one
				[Wasm2I32Const(0), callCmd]
		))
	} else {
		cmd = if (fiWasmIsGlobalVar(context, func)) Wasm2GetGlobal(func) else Wasm2GetLocal(func);
		fiWasmBuildIndirectCall(acc, cmd, type, context, destructors)
	}
}

fiWasmIsGlobalVar(context : WasmContext, name : string) {
	eitherMap(lookupTree(context.globalNames.toplevel, name), \decl : FiDeclaration -> {
		switch (decl) {
			FiGlobalVar(__, __, __, __, __): true;
			default: false;
		}
	}, false)
}

wasm2string(e : Wasm2Cmd) -> string {
	rec = \ee -> wasm2string(ee);
	s = switch (e) {
		Wasm2Code(code): code;
		Wasm2Seq(commands): strGlue(map(commands, rec), "");
		Wasm2If(cond, isVoid, f64, thenBranch, elseBranch):
			" (if" + (if (isVoid) "" else " (result " + (if (f64) "f64" else "i32") + ")") + "\n"
			+ " (block (result i32)\n" 
			+ "    " + rec(cond)
			+ " )\n"
			+ " (then\n"
			+ "    " + rec(thenBranch)
			+ " )\n"
			+ (if (elseBranch != Wasm2Void())
			  " (else\n" 
			+ rec(elseBranch)
			+ " )\n" else "")
			+ ")";
		Wasm2I32Const(i): "i32.const " + i2s(i);
		Wasm2F64Const(d): "f64.const " + d2s(d);
		Wasm2Drop(): "drop";
		Wasm2Void(): ";; void";
		Wasm2SetLocal(name): "set_local $" + name;
		Wasm2GetLocal(name): "get_local $" + name;
		Wasm2SetGlobal(name): "set_global $" + name;
		Wasm2GetGlobal(name): "get_global $" + name;
		Wasm2Call(name): "call " + name;
	}
	if (endsWith(s, "\n")) s else s + "\n"
}

// TODO
compileWasmExp(acc : WasmAcc, ex : WasmExp, context : WasmContext) {
	wasm2string(compileWasmExp2(acc, ex, context))
}

compileDestructors(destructedVars : [WasmScopeVar], localsOnly : bool) -> [Wasm2Cmd] {
    // only filter locals if asked for
    vars = if (localsOnly) filter(destructedVars, \v -> v.local) else destructedVars;
    concatA(map(vars, \v -> [
                Wasm2GetLocal(v.name),
                Wasm2Call("$wasm_dec_refcnt")
            ]));
}

compileWasmExp2(acc : WasmAcc, ex : WasmExp, context : WasmContext) -> Wasm2Cmd {
	conv = \s -> Wasm2Code(s);
	rec2 = \e, context2 -> compileWasmExp2(acc, e, context2);
	rec = \e -> rec2(e, context);
	error = \reason -> wasmError(acc, reason) |> conv;
    destructors = compileDestructors(ex.destructedVars, false);
	
    switch (ex) {
		WasmLambda(args, body, type, __): Wasm2Seq(destructors);	// does not happen after lifted lambdas
		WasmCall(f, args, type, calltype, __): {
			superglue(args, \e -> {
                expType = wasmExpType(e);
                isDeref = switch (e) { // see below
                    WasmCallPrim(op, __, __, __): switch (op) {
                        FcDerefPrim(): true;
                        default: false;
                    }
                    default: false;
                }
                // as void is i32, if we need to pass a parameter of type void, we use 0 as a placeholder
                // this actually should never happen - but happens when specializing
                // a special case is dereferencing void ref - it returns i32 already
                voidFiller = if (expType == WasmTypeVoid() && !isDeref) " i32.const 0 " else "";
				// TODO
                wasm2string(compileWasmExp2(acc, e, context)) + voidFiller
            }, " ") + 
			switch (calltype) {
				WasmCallSimple(): {					
					switch (f) {
						WasmVar(fname, ftype, __): {
							if (contains(context.tailCalls, ex)) {
								// emitting tail call: insert set_local's to save to parameters 
                                // in reverse order (as values are on stack already)
                                // it is important we do all set_local's later when parameters are computed
                                // otherwise we can overwrite parameters used in computed other parameters
                                // destructors go between the args pushed on stack and the actual call
                                // recompiling them to only destruct locals, not params
                                wasm2string(Wasm2Seq(compileDestructors(ex.destructedVars, true))) +
								supergluei(args, \i,e -> "set_local " + i2s(length(args) - i - 1), "\n") + 
								"\nbr $cont" // jump to outer loop - effectively function start
							} else {
								functionType = cast(ftype : WasmTypeDescriptor -> WasmTypeFunction);
							 	wasm2string(fiWasmBuildFunctionCall(acc, fname, functionType, context, destructors));
							}
						}
						default: {
							compileWasmExp(acc, f, context) + " " + 
							// storing temp value globally - only to be used in the next 2 instructions
							// essentially, a substitute for temp variable or stack dup instruction
							"set_global $wasm_global_temp_holder_mut \n" + wasm2string(
							fiWasmBuildIndirectCall(acc, Wasm2GetGlobal("wasm_global_temp_holder_mut"), wasmExpType(f), context, destructors))
						}
					} + "\n"
				}
				WasmCallNative(): {					
					var = cast(f : WasmExp -> WasmVar);
					nativeDec = lookupTree(context.natives, var.name);
					switch (nativeDec) {
						Some(v): {					
							functionType = cast(var.type : WasmTypeDescriptor -> WasmTypeFunction);
							fiWasmBuildNativeFunctionCall(acc, var.name, args, functionType, v, context);
						}
						None(): {
							fcPrintln("Error occurred in WasmCallNative: " + var.name);
							"";
						}
					}
					+ "\n"
				}
				WasmCallHost(): {					
					var = cast(f : WasmExp -> WasmVar);
					functionType = cast(var.type : WasmTypeDescriptor -> WasmTypeJSCallback);
					fiWasmBuildHostFunctionCall(acc, var.name, args, functionType, context)
					+ "\n"
				}
			} |> conv;
		}
		WasmVar(name, type, __): {
			isFunc = switch (type) {
				WasmTypeFunction(__, __): true;
				default: false;
			}
			name2 = getWasmLocalVarName(name, type);
			funIndex = if (isFunc) {
				fname = if (containsKeyTree(context.natives, name)) name + "__wrapped__"
						else name;
				lookupTreeDef(context.functions.functionIndices, fname, -1)
			} else -1;
			
            result = if (containsKeyTree(context.localNames, name2))
				Wasm2GetLocal(name2)
			else if (containsKeyTree(context.localNames, name))
				Wasm2GetLocal(name)
			else if (funIndex >= 0) {
				switch (lookupTree(context.typeTable.structTypes, "WasmGlobalClosureWrapper")) {
					None(): error("Global closure wrapper not defined");
					Some(s): makeWasmConstructor(acc, context, s, [WasmInt(funIndex, [])]);
				}
			} else if (containsKeyTree(context.globalNames.toplevel, name))
				Wasm2GetGlobal(name)
			else
				error("Cannot resolve variable in WasmVar: " + name);

            Wasm2Seq(arrayPush(destructors, result));
		}
		WasmLet(name, type, e1, e2, type2, __): {
			name2 = getWasmLocalVarName(name, type);

			Wasm2Seq(concat(destructors, [
				rec(e1),
				//if (!startsWith(name, "__temp__")) fiWasmGenerateConstructor(type) else Wasm2Void(),
				Wasm2SetLocal(name2),
				rec2(e2, context)
			]))
		}
		WasmIf(e1, e2, e3, type, __): {
            Wasm2Seq(arrayPush(destructors, 
			    Wasm2If(rec(e1), type == WasmTypeVoid(), type == WasmTypeDouble(), rec(e2), rec(e3))
            ));
		}
		WasmSwitch(x, switchType, cases, type, __): {
			wasm2string(Wasm2Seq(destructors)) + 
            makeWasmSwitch(acc, context, compileWasmExp(acc, x, context), 
				map(cases, \case -> {
					WasmCaseHolder(0, case.struct, compileWasmExp(acc, case.body, context))
				}),
				type
			) |> conv;
		}
		WasmCast(e, tFrom, tTo, type, __): {
			castError = \ -> {
				sF = toString(tFrom);
				sT = toString(tTo);
				error("cast (" + sF + ") -> (" + sT + ")")
			};
			value : Wasm2Cmd = compileWasmExp2(acc, e, context);
			switch (tFrom) {
				WasmTypeInt(): {
					// to string, and to double
					switch (tTo) {
						WasmTypeString():	Wasm2Call("$wasm_int_to_string");
						WasmTypeDouble(): 	Wasm2Code("f64.convert_s/i32");
						WasmTypeFlow(): 	makeWasmFlowValue(context, tFrom);
						default: 			castError();
					}
				}
				WasmTypeDouble(): {
					// to string, and to int
					switch (tTo) {
						WasmTypeString():	Wasm2Call("$wasm_double_to_string");
						WasmTypeInt():  	Wasm2Code("i32.trunc_s/f64");
						WasmTypeFlow():		makeWasmFlowValue(context, tFrom);
						default: 			castError();
					}
				}
				WasmTypeBool(): {
					switch(tTo) {
						WasmTypeString():	Wasm2Call("$wasm_bool_to_string");
						WasmTypeFlow():		makeWasmFlowValue(context, tFrom);
						default:			castError();
					}
				}
				WasmTypeFlow(): {
					switch(tTo) {
						WasmTypeFlow(): Wasm2Void(); // value;
						default: 		makeWasmUnboxFlowValue(context, tTo);
					}
				}
				WasmTypeUnion(u_name, u_structs): {
					switch(tTo) {
						WasmTypeStruct(s_name, s_fields): Wasm2Void();
						WasmTypeFlow(): makeWasmFlowValue(context, tFrom);
						default: castError();
					}
				}
				default: {
					switch (tTo) {
						WasmTypeFlow(): makeWasmFlowValue(context, tFrom);
						default: castError();
					}
				}
			} |> \cmd -> Wasm2Seq(concat([value, cmd], destructors));
		}
		WasmSeq(es, type, __): 
			Wasm2Seq(concat(destructors, map(es, rec))); // this code assumes no mid-sequence statements return value
            // see split_expressions for the logic that eliminates those
		WasmCallPrim(op, es, type, __): {
			args1 = map(es, \e -> compileWasmExp2(acc, e, context));
			argsAppend1 = \cmd -> Wasm2Seq(concat3(args1, destructors, [cmd]));
			argsAppend = \s -> argsAppend1(Wasm2Code(s));
			type0 = if (length(es) > 0) wasmExpType(es[0]) else WasmTypeVoid();
			buildCmp = \cmp0 : string, isEq : bool -> {
				cmpSigned	= if (isEq) cmp0 else cmp0 + "_s";
				cmpUnsigned	= if (isEq) cmp0 else cmp0 + "_u";
				cmp = "i32." + cmpUnsigned;
				cmp2 = " " + (
					if (cmp0 == "eq") "i32.eqz" else 
					if (cmp0 == "ne") "i32.eqz i32.eqz" else
					"i32.const 0 i32." + cmpSigned
				);
				switch (type0) {
					WasmTypeVoid():		cmp;
					WasmTypeBool():		cmp;
					WasmTypeInt():		"i32." + cmpSigned;
					WasmTypeDouble():	"f64." + cmp0;
					WasmTypeNative():	" call $wasm_compare_native" + cmp2;
					WasmTypeRef(__):	cmp;
					WasmTypeString():				" call $wasm_compare_strings" + cmp2;
					WasmTypeArray(at):				makeWasmArrayComparison(context, at) + cmp2;
					WasmTypeStruct(__, __):			makeWasmTypeNameComparison(context, type0) + cmp2; // TODO
					WasmTypeUnion(__, __):			makeWasmTypeNameComparison(context, type0) + cmp2; // TODO
					WasmTypeFunction(__, __):		" call $wasm_compare_typenames" + cmp2;
					WasmTypeJSCallback(__, __):		" call $wasm_compare_typenames" + cmp2;
					WasmTypeFlow():					" call $wasm_compare_flow" + cmp2;
				} |> argsAppend
			}
			
			
			switch (op) {
				FcOrPrim(): argsAppend(compileWasmType(type, false) + ".or");
				FcAndPrim(): argsAppend(compileWasmType(type, false) + ".and");
				FcNotPrim(): {
					if (type0 == WasmTypeBool()) argsAppend("i32.eqz")
					else error("not")
				}
				FcEqPrim(): buildCmp("eq", true);
				FcNePrim(): buildCmp("ne", true);
				FcLePrim(): buildCmp("le", false);
				FcGePrim(): buildCmp("ge", false);
				FcLtPrim(): buildCmp("lt", false);
				FcGtPrim(): buildCmp("gt", false);
				FcPlusPrim(): {
					switch (type0) {
						WasmTypeInt(): Wasm2Code("i32.add");
						WasmTypeDouble(): Wasm2Code("f64.add");
						WasmTypeString(): Wasm2Call("$wasm_concat_strings");
						default: error("add");
					} |> argsAppend1
				}
				FcMinusPrim(): argsAppend(compileWasmType(type, false) + ".sub");
				FcMulPrim(): {
					argsAppend(switch (type0) {
						WasmTypeInt(): "i32.mul";
						WasmTypeDouble(): "f64.mul";
						default: {
							wasmError(acc, "mul");
						}
					})
				}
				FcDivPrim(): {
					argsAppend1(switch (type0) {
						WasmTypeInt(): Wasm2Code("i32.div_s");
						WasmTypeDouble(): Wasm2Code("f64.div");
						default: error("div");
					})		
				}
				FcModPrim(): {
					argsAppend1(switch (type0) {
						WasmTypeInt(): Wasm2Code("i32.rem_s");
						WasmTypeDouble(): Wasm2Call("$wasm_dmod");
						default: error("mod");
					})		
				}
				FcNegPrim(): {
					switch (type0) {
						WasmTypeInt(): Wasm2Seq(concat3([Wasm2I32Const(0)], concat(args1, destructors), 
                            [Wasm2Code("i32.sub")]));
						WasmTypeDouble(): argsAppend("f64.neg");
						default: error("neg");
					}
				}
				FcArrayPrim(): {
					// How big is each element?
					elemType = switch (type) {
						WasmTypeArray(et): et;
						default: {
							wasmError(acc, "not array type");
							type;
						}
					}
					elemSize = 4 * fiWasmTypeStackSize(elemType);
					requiredSize = 8 + elemSize * length(es);

					// OK, we have to allocate memory for the array
					alloc = [
						Wasm2I32Const(length(es)),
						Wasm2I32Const(requiredSize),
						Wasm2Call("$wasm_alloc_array")
					];

					Wasm2Seq(concat3(alloc, concatA(mapi(es, \i, e -> {
						// We have the address on the stack
						// we do NOT do refcnt increase - wasm_set_array_XX is special - 
						//   it does NOT decrease refcnt for array passed
						[
							Wasm2I32Const(8 + i * elemSize),
							compileWasmExp2(acc, e, context),
							Wasm2Call("$wasm_set_array_" + compileWasmType(elemType, true))
						]
					})), destructors))
				}
				FcIndexPrim(): {
					argsAppend1(Wasm2Call("$wasm_get_array_" + compileWasmType(type, true) + " "))
				}
				FcDerefPrim(): {
					t = cast(type0 : WasmTypeDescriptor -> WasmTypeRef);
					cmd = if (t.type == WasmTypeDouble()) "$wasm_deref_f64"
						  else "$wasm_deref_" + compileWasmType(t.type, true);
					argsAppend1(Wasm2Call(cmd))
				}
				FcAssignPrim(): {
					t = cast(type0 : WasmTypeDescriptor -> WasmTypeRef);
					cmd = if (t.type == WasmTypeDouble()) "$wasm_set_ref_f64"
						  else "$wasm_set_ref_" + compileWasmType(t.type, true);
					argsAppend1(Wasm2Call(cmd));
				}
				FcRefPrim(): {
					argsAppend1(Wasm2Call("$wasm_make_ref_" + compileWasmType(type0, true)));
				}
				FcStructPrim(struct_name): {
					cons = switch (lookupTree(context.typeTable.structTypes, struct_name)) {
						Some(st): makeWasmConstructor(acc, context, st, es);
						None(): error("struct");
					}
                    Wasm2Seq(concat([cons], destructors));
				}
				FcFieldPrim(name): {
					cmd = switch (type0) {
						WasmTypeStruct(sname, fields): {
							makeWasmStructField(fields, name, Wasm2Seq(args1), type);
						}
						WasmTypeUnion(sname, structs): {
							makeWasmUnionField(context.typeTable, Wasm2Seq(args1), type, name);
						}
						default: error("FcFieldPrim wrong type");
					}
					Wasm2Seq(concat([cmd], destructors))
				}
				FcSetMutablePrim(name): {
					cmd = switch (type0) {
						WasmTypeStruct(sname, fields): {
							makeWasmSetMutableField(fields, name, args1, type);
						}
						default: error("mutable wrong type");
					}
					Wasm2Seq(concat([cmd], destructors))
				}
				FcCreateClosurePrim(struct_name, function_name): {
					eitherFn(lookupTree(context.typeTable.structTypes, struct_name), \st : WasmTypeStruct -> {
						funIndex = lookupTreeDef(context.functions.functionIndices, function_name, -1);
						if (funIndex < 0) error("closure - missing lifted function")
						else Wasm2Seq(concat(
                            [makeWasmConstructor(acc, context, st, concat([WasmInt(funIndex, [])], es))],
                            destructors));
					}, \ -> error("closure - missing struct"))
				}
			}
		}
		WasmVoid(__): Wasm2Seq(destructors);
		WasmDouble(d, __): Wasm2Seq(arrayPush(destructors, Wasm2F64Const(d)));
		WasmInt(i, __): Wasm2Seq(arrayPush(destructors, Wasm2I32Const(i)));
		WasmString(s, __): {
			maddress = lookupTree(context.stringAcc.address, s);
			switch (maddress) {
				None(): error("string not found");
				Some(address): {
					// OK, we produce the address
					Wasm2Seq(arrayPush(destructors, Wasm2I32Const(address)))
				}
			}
		}
		WasmBool(b, __): Wasm2Seq(arrayPush(destructors, Wasm2I32Const(b2i(b))));
		WasmRequire(flowfile, e, type, __): {
			error("require"); Wasm2Seq(destructors);
		}
		WasmUnsafe(name, fallback, type, __): {
			error("unsafe"); Wasm2Seq(destructors);
		}
        WasmIncRefcnt(e, type, __): // correct type of e is assumed
            Wasm2Seq(concat([
                compileWasmExp2(acc, e, context), 
                Wasm2Call("$wasm_inc_refcnt_passthru")
            ], destructors));
        WasmDecRefcnt(name, type, __): // correct type of variable 'name' is assumed
            Wasm2Void();
	}
}

makeWasmArrayComparison(context : WasmContext, at : WasmTypeDescriptor) -> string {
	atype = compileWasmType(at, true);
	(if (strContains(atype, "_ref")) {
		typeDescriptor = fiWasmGetTypeDescriptor(context, at);
		// Make sure to include the offset to the type descriptor table
		" i32.const " + i2s(typeDescriptor)
	} else {
		"";
	}) + " call $wasm_compare_arrays_" + atype;
}

makeWasmTypeNameComparison(context : WasmContext, typename : WasmTypeDescriptor) -> string {
	" call $wasm_compare_typenames";
}

makeWasmConstructor(acc : WasmAcc, context : WasmContext, structType : WasmTypeStruct, 
	args : [WasmExp]) -> Wasm2Cmd {
	// struct - i32. Heap pointer to ref. count, 32-bit struct id, then args in stack value format
	argSizes = map(args, \arg -> 4 * fiWasmTypeStackSize(wasmExpType(arg)));
	requiredSize = fold(argSizes, 8, \acc1, size -> acc1 + size);

	typeDescriptor = lookupTreeDef(context.typeTable.typesMap, structType, 0);

	// OK, we have to allocate memory for the struct
	alloc = Wasm2Seq([
		Wasm2I32Const(typeDescriptor),
		Wasm2I32Const(requiredSize),
		Wasm2Call("$wasm_alloc_struct")
	]);

	// Initialize fields
	foldi(args, Pair(8, Cons(alloc, EmptyList())), \i, acc1 : Pair<int, List<Wasm2Cmd>>, e -> {
		offset = acc1.first;
		// do NOT increase refcnt for the address - wasm_set_array_xxx will NOT decrease it
		nacc = Cons(Wasm2Seq([
			Wasm2I32Const(offset),
			compileWasmExp2(acc, e, context),
			Wasm2Call("$wasm_set_array_" + compileWasmType(wasmExpType(args[i]), true))
		]), acc1.second);
		Pair(offset + argSizes[i], nacc);
	}).second |> \l -> Wasm2Seq(list2array(l));
}

makeWasmStructField(args : [WasmStructField], field : string, structCmd : Wasm2Cmd, type : WasmTypeDescriptor) -> Wasm2Cmd {
	argSizes = map(args, \arg -> 4 * fiWasmTypeStackSize(arg.type));
	offset = -foldi(args, 8, \i, acc, arg -> {
		if (acc < 0) acc
		else if (arg.name == field) -acc
		else acc + argSizes[i]
	});

	Wasm2Seq([
		structCmd,
		Wasm2I32Const(offset),
		Wasm2Call("$wasm_get_field_" + compileWasmType(type, true))
	])
}

makeWasmUnionField(typeTable : FiWasmTypeTable, unionCmd : Wasm2Cmd, type : WasmTypeDescriptor, fieldName : string) -> Wasm2Cmd {
	fieldNo = lookupTree(typeTable.fieldIds, fieldName);
	switch (fieldNo) {
		None(): {
			fcPrintln("unknown field " + fieldName);
			Wasm2Void()
		}
		Some(fno): 
			Wasm2Seq([
				unionCmd,
				Wasm2I32Const(fno),
				Wasm2Call("$wasm_get_fieldno_" + compileWasmType(type, true))
			])
	}
}

makeWasmSetMutableField(sargs : [WasmStructField], field : string, args : [Wasm2Cmd], type : WasmTypeDescriptor) -> Wasm2Cmd {
	argSizes = map(sargs, \arg -> 4 * fiWasmTypeStackSize(arg.type));
	offset = -foldi(sargs, 8, \i, acc, arg -> {
		if (acc < 0) acc
		else if (arg.name == field) -acc
		else acc + argSizes[i]
	});
	Wasm2Seq(concat(args, [
		Wasm2I32Const(offset),
		Wasm2Call("$wasm_set_mutable_field_" + compileWasmType(type, true))
	]))
}

WasmCaseHolder(typeDescriptor : int, struct : string, body : string);

makeWasmSwitch(acc : WasmAcc, context : WasmContext, x : string, cases : [WasmCaseHolder], type : WasmTypeDescriptor) -> string {
	typeDescriptors : [WasmCaseHolder] = map(cases, \case : WasmCaseHolder -> {
		WasmCaseHolder(
			if (case.struct == "default") -1
			else {
				structType = lookupTree(context.typeTable.structTypes, case.struct);
				switch (structType) {
					None(): -1;
					Some(st): lookupTreeDef(context.typeTable.typesMap, st, -1);
				}
			}, 
			case.struct,
			case.body,
		)
	});

	sorted = sort(typeDescriptors);

	resultType = if (type == WasmTypeVoid()) ""
		else "(result " + compileWasmType(type, false) + ")";

	makeWasmSwitchCases(acc, context, x, resultType, sorted);
}

makeWasmSwitchCases(acc : WasmAcc, context : WasmContext, x : string, resultType : string, cases : [WasmCaseHolder]) -> string {
	n = length(cases);
	if (n == 0) ""
	else if (n == 1) {
        ";; " + cases[0].struct + "\n" +
		cases[0].body;
	} else if (n == 2) {
		if (cases[0].typeDescriptor == -1) {
			// The default case, we swap them
			makeWasmSwitchCases(acc, context, x, resultType, [cases[1], cases[0]]);
		} else {
			// if x.typescriptor == case[0].typescriptor case1.body else case2.body
			// (if (block (result i32) x <cast0.typescriptor> $call wasm_is_struct_type i32.eqz)
			//    (then <case0.body>)
			//    (else <case1.body>)
			// )
			"(if "  + resultType + " (block (result i32) " + x + " i32.const " + i2s(cases[0].typeDescriptor) + " call $wasm_compare_struct_type i32.eqz)\n"
			+ "\t(then ;; " + cases[0].struct + "\n" + cases[0].body + ")\n"
			+ "\t(else ;; " + cases[1].struct + "\n" + cases[1].body + ")\n"
			+ ")";
		}
	} else {
		half = (n + 1) / 2;
		cut = cases[half].typeDescriptor;
		// if x.typedescriptor < cut  
		//  	makeWasmSwitchCases(first_half)
		// else makeWasmSwitchCases(second_half)

		firstHalf = subrange(cases, 0, half);
		secondHalf0 = subrange(cases, half, length(cases) - half);

		hasDefault = cases[0].typeDescriptor == -1;

		// If there is a default, we have to copy it to both branches
		secondHalf = if (hasDefault) {
			// It is important that the default is the first one
			concat([cases[0]], secondHalf0)
		} else secondHalf0;
		firstHalfCode = makeWasmSwitchCases(acc, context, x, resultType, firstHalf);
		secondHalfCode = makeWasmSwitchCases(acc, context, x, resultType, secondHalf);

		"(if "  + resultType + " (block (result i32) " + x + " i32.const " + i2s(cut) + " call $wasm_compare_struct_type i32.const 0 i32.lt_s)\n"
		+ "\t(then " + firstHalfCode + ")\n"
		+ "\t(else " + secondHalfCode + ")\n"
		+ ")";
	}
}

makeWasmFlowValue(context : WasmContext, type : WasmTypeDescriptor) -> Wasm2Cmd {
	bytes = 4 + 4 + 4 * fiWasmTypeStackSize(type);
	// OK, we have to allocate memory for the value
	Wasm2Seq([
		Wasm2I32Const(bytes),
		Wasm2I32Const(fiWasmGetTypeDescriptor(context, type)),
		Wasm2Call("$wasm_alloc_flow_" + compileWasmType(type, true))
	])
}

makeWasmUnboxFlowValue(context : WasmContext, type : WasmTypeDescriptor) -> Wasm2Cmd {
	Wasm2Seq([
		Wasm2I32Const(fiWasmGetTypeDescriptor(context, type)),
		Wasm2Call("$wasm_unbox_flow_" + compileWasmType(type, true))
	])
}

wasmError(acc : WasmAcc, reason : string) -> string {
	fcPrintln("Wasm does not support " + reason + " yet");
	acc.errors := ^(acc.errors) + 1;
	reason;
}
