import tools/flowc/backends/common;
import tools/flowc/incremental/fiprogram;
import tools/flowc/incremental/fi_helpers;
import tools/flowc/backends/inca/promote_types;
import tools/flowc/backends/inca/lift_types;
import tools/flowc/backends/inca/lift_functions;
import tools/flowc/backends/inca/lift_globals;
import tools/flowc/backends/inca/fi2incaflow;
import tools/flowc/manipulation/lambda_lifting;

export {
	fi2inca(program : FiProgram, cfg : FcIncaConfig, callback : () -> void) -> void;
}

fi2inca(program : FiProgram, cfg : FcIncaConfig, callback : () -> void) -> void {
	timePhases = isUrlParameterTrue("timephases");
	repTime = \phase, t0 -> {
		now = timestamp();
		if (timePhases) println(phase + " " + d2s((now - t0) / 1000.0) + "s");
		now
	}
	time0 = timestamp();
	incaEnv0 = buildIncaEnv(program);
	incaEnv = promoteIncaTypes(incaEnv0);

	time1 = repTime("Build inca env", time0);

	if (false) {
		// OK, new code path for the stack-based flow
		// TODO: We should not use the normal lambda lifting, but our own
		// so any local variables of function type are also optimized out.
		p0 = lift_lambdas(program);
		i1 = buildIncaEnv(p0);
		i2 = promoteIncaTypes(i1);
		incaFlow = fi2incaflow(i2);
	}

	if (true) {
		details = isUrlParameterTrue("details");
		graph = buildIncaConversionGraph(incaEnv, details);
		dot = simpleGraph2dot(graph, "", [], \n -> {
			concat(
				[DotLabel(n)],
				if (containsKeyTree(incaEnv.unions, n)) {
					[DotFillColor("#ff0000"), DotShape("rectangle")]
				} else {
					[]
				}

			)
		}, \e -> [DotLabel(e)]);
		setFileContent("incagraph.dot", dot);
		{}
	}
	time2 = repTime("Build dot", time1);


	fcPrintln("Saving " + cfg.outputdir + "/types.flow");
	types = liftIncaTypes(incaEnv);
	saveFileContent(cfg.outputdir + "/types.flow", types);

	time3 = repTime("Lift types", time2);

	fcPrintln("Saving " + cfg.outputdir + "/functions.flow");
	functions = liftIncaFunctions(incaEnv, cfg.outputdir);
	saveFileContent(cfg.outputdir + "/functions.flow", functions);

	time4 = repTime("Lift functions", time3);

	fcPrintln("Saving " + cfg.outputdir + "/globals.flow");
	globals = liftIncaGlobals(incaEnv);
	saveFileContent(cfg.outputdir + "/globals.flow", globals);

	time5 = repTime("Lift globals", time4);

	callback();
}


buildIncaEnv(program : FiProgram) -> IncaEnv {
	// What files should we lift from?
	parsed0 = getTreeKeys(program.modules);
	// All those ending with _i.flow
	parsed = filter(parsed0, \p -> endsWith(p, "_i"));

	env0 = IncaEnv(
		program.config,
		parsed,
		makeTree(),
		makeTree(),
		makeTree(),
		makeTree(),
		makeTree(),
		[],
		makeSet()
	);
	fold(parsed, env0, \acc, m -> addModuleToIncaEnv(program, acc, m));
}


addModuleToIncaEnv(program : FiProgram, acc : IncaEnv, module : string) -> IncaEnv {
	m = lookupTree(program.modules, module);
	switch (m) {
		None(): acc;
		Some(mo): {	
			if (validIncaModule(mo)) {
				IncaEnv(
					acc with
					structs = fold(mo.structs, acc.structs, \acc0, s -> setTree(acc0, s.name, s)),
					unions = fold(mo.unions, acc.unions, \acc0, u -> setTree(acc0, u.name, u)),
					functions = fold(mo.functions, acc.functions, \acc0, f -> {
						if (endsWith(f.name, "_lifted")) acc0
						else setTree(acc0, f.name, f)
					}),
					globals = fold(mo.globalVars, acc.globals, \acc0, g -> setTree(acc0, g.name, g)),
					globalsOrder = fold(mo.initOrder, acc.globalsOrder, \acc0, o -> if (exists(mo.globalVars, \g -> g.name == o)) arrayPush(acc0, o) else acc0),
					alreadyLifted = fold(mo.functions, acc.alreadyLifted, \acc0, f -> {
						if (endsWith(f.name, "_lifted")) insertSet(acc0, strsubsmart(f.name, 0, -7))
						else acc0
					})
				)
			} else {
				println("Error in " + mo.fileinfo.flowfile);
				acc
			}
		}
	}
}


/*
Todo:
- Better error reporting in checks

- Implement linear typing, or automatic insert of copy.

- Implement lambda lifting, and check for closures

- Implement overloading of unions

- Implement duplication of structs in overloaded unions

- Implement "exploding" switches into top-level functions
*/

validIncaModule(m : FiModule) -> bool {
	// A bunch of rules apply to Inca files:
	// No natives functions

	check = \b, e -> {
		if (!b) println(e);
		b;
	}

	check(m.forbids == [], "no forbids")
	&& check(m.natives == [], "no natives")

	// Check that the structs and unions do not contain refs, mutable,
	// nested arrays, natives, functions nor polymorphism
	&& fold(m.structs, true, \acc, t -> acc && {
		forall(t.args, \a -> {
			check(validIncaType(a.type), "wrong struct type for " + t.name)
		})
	})
	&& fold(m.unions, true, \acc, t -> acc && {
		forall(t.typenames, \a -> {
			check(validIncaType(a), "wrong union type for " + t.name)
		})
	})

	&& fold(m.functions, true, \acc, f -> acc &&
		validIncaExp(f.lambda)
	)
}

validIncaType(type : FiType) -> bool {
	switch (type) {
		FiTypeBool(): true;
		FiTypeInt(): true;
		FiTypeDouble(): true;
		FiTypeString(): true;

		FiTypeFlow(): false;
		FiTypeVoid(): false;

		FiTypeNative(): false;

		FiTypeArray(t): validIncaType(t);
		FiTypeFunction(args, returnType): false;
		FiTypeRef(t): false;
		FiTypeParameter(n): true;
		FiTypeName(name, typeparameters): true;
	}
}

validIncaExp(in : FiExp) -> bool {
	switch (in) {
		FiLambda(args, body, type, start): true; // For now. TODO: Check no closures
		FiSwitch(x, switchType, cases, type, start): true; // For now. TODO

		FiCall(f, args, type, start): validIncaExp(f) && validIncaType(type);
		FiVar(name, type, start): validIncaType(type);
		FiLet(name, type, e1, e2, type2, start): validIncaExp(e1) && validIncaExp(e2) && validIncaType(type) && validIncaType(type2);

		FiIf(e1, e2, e3, type, start): validIncaExp(e1) && validIncaExp(e2) && validIncaExp(e3) && validIncaType(type);
		FiSeq(es, type, start): forall(es, validIncaExp);
		FiCallPrim(op, es, type, start): switch (op) {
			FcOrPrim(): true;
			FcAndPrim(): true;
			FcNotPrim(): true;
			FcEqPrim(): true;
			FcNePrim(): true;
			FcLePrim(): true;
			FcGePrim(): true;
			FcLtPrim(): true;
			FcGtPrim(): true;
			FcPlusPrim(): true;
			FcMinusPrim(): true;
			FcMulPrim(): true;
			FcDivPrim(): true;
			FcModPrim(): true;
			FcNegPrim(): true;
			FcArrayPrim(): true;
			FcIndexPrim(): true;
			FcDerefPrim(): false;
			FcAssignPrim(): false;
			FcRefPrim(): false;
			FcStructPrim(struct_name): true;
			FcFieldPrim(name): true;
			FcSetMutablePrim(name): false;
			FcCreateClosurePrim(structName, functionName): false;
			FcQuote(): false;
			FcUnquote(): false;
		 } && validIncaType(type) && forall(es, validIncaExp);

		FiVoid(start): true;
		FiDouble(d, start): true;
		FiInt(i, start): true;
		FiString(s, start): true;
		FiBool(b, start): true;

		FiCast(e, tFrom, tTo, type, start): false;

		FiRequire(flowfile, e, type, start): false;
		FiUnsafe(name, fallback, type, start): false;
	}
}
