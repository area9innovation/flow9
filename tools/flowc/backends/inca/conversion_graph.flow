import tools/flowc/backends/inca/env;
import ds/simplegraph;
import tools/flowc/incremental/fi_helpers;

export {
	buildIncaConversionGraph(env : IncaEnv, details : bool) -> SimpleGraph<string, string>;
}

buildIncaConversionGraph(env : IncaEnv, details : bool) -> SimpleGraph<string, string> {
	// Whether we should include details in the graph or not
	graph0 = if (details) foldTree(env.unions, makeSimpleGraph(), \name, union, acc -> {
		fold(union.typenames, acc, \acc2, tn -> {
			addSimpleEdge(acc2, name, getFiTypeName(tn), "", 0);
		})
	}) else makeSimpleGraph();

	graph = foldTree(env.functions, graph0, \name, dec, acc -> {
		addIncaFunctionToGraph(env, acc, details, dec)
	});

	graph;
}

addIncaFunctionToGraph(env : IncaEnv, acc : SimpleGraph<string, string>, details : bool, dec : FiFunctionDec) -> SimpleGraph<string, string> {
	// Extract the named function arguments
	argTypes = filtermap(dec.type.args, \a -> {
		argName = getFiTypeName(a.type);
		if (argName == "") None() else Some(argName);
	});
	retType = getIncaTypeNameOrVoid(dec.type.returnType);

	if (length(argTypes) == 1 && retType != "") {
		argType = argTypes[0];

		println("\n" + argType + " -> " + retType);

		acc2 = if (details) addIncaCasesToGraph(env, acc, dec.name, dec.lambda) else acc;
		addSimpleEdge(acc2, argType, retType, dec.name, 2);
	} else acc;
}

addIncaCasesToGraph(env : IncaEnv, acc : SimpleGraph<string, string>, fn : string, ex : FiExp) -> SimpleGraph<string, string> {
	todo = \ -> {
		println("TODO: Add cases to graph for " + ex.structname);
		acc;
	}
	switch (ex) {
		FiLambda(args, body, type, start): addIncaCasesToGraph(env, acc, fn, body);

		FiCall(f, args, type, start): {
			fold(args, acc, \acc2, e -> {
				addIncaCasesToGraph(env, acc2, fn, e);
			});
		}
		FiLet(name, type, e1, e2, type2, start): {
			acc1 = addIncaCasesToGraph(env, acc, fn, e1);
			addIncaCasesToGraph(env, acc1, fn, e2);
		}
		FiIf(e1, e2, e3, type, start): todo();
		FiSwitch(x, switchType, cases, type, start): {
			fold(cases, acc, \acc2, case : FiCase -> {
				addIncaCaseToGraph(env, acc2, fn, case)
			});
		}
		FiCast(e, tFrom, tTo, type, start): todo();
		FiSeq(es, type, start): {
			fold(es, acc, \acc2, e -> {
				addIncaCasesToGraph(env, acc2, fn, e);
			});
		}
		FiCallPrim(op, es, type, start): {
			fold(es, acc, \acc2, e -> {
				addIncaCasesToGraph(env, acc2, fn, e);
			});
		}

		FiVar(name, type, start): acc;
		FiVoid(start): acc;
		FiDouble(d, start): acc;
		FiInt(i, start): acc;
		FiString(s, start): acc;
		FiBool(b, start): acc;
		FiRequire(flowfile, e, type, start): todo();
		FiUnsafe(name, fallback, type, start): todo();
	}
}

addIncaCaseToGraph(env : IncaEnv, acc : SimpleGraph<string, string>, fn : string, case : FiCase) -> SimpleGraph<string, string> {
	switch (case.body) {
		FiVar(__, __, __): acc;
		default: {
			type = getIncaTypeNameOrVoid(fiExpType(case.body));

			addSimpleEdge(acc, case.struct, type, fn, 1);
		}
	}
}

getIncaTypeNameOrVoid(t : FiType) -> string {
	if (t == FiTypeVoid()) "void" else getFiTypeName(t);
}
