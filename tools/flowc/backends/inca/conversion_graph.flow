import tools/flowc/backends/inca/env;
import ds/simplegraph;
import tools/flowc/incremental/fi_helpers;

export {
	// If details is true, we only include structs in the graph. 
	// Otherwise, we present whatever the functions take and give.
	buildIncaConversionGraph(env : IncaEnv, details : bool) -> SimpleGraph<string, string>;
	incaFiName2structs(env : IncaEnv, tname : string) -> Set<string>;
}

buildIncaConversionGraph(env : IncaEnv, details : bool) -> SimpleGraph<string, string> {
	// Whether we should include details in the graph or not
	graph0 = if (details) {
		foldTree(env.unions, makeSimpleGraph(), \name, union, acc -> {
			fold(union.typenames, acc, \acc2, tn -> {
				addSimpleEdge(acc2, name, getFiTypeName(tn), "", 0);
			})
		}) 
	} else makeSimpleGraph();

	graph = foldTree(env.functions, graph0, \name, dec, acc -> {
		addIncaFunctionToGraph(env, acc, details, dec)
	});

	graph;
}

addIncaFunctionToGraph(env : IncaEnv, acc : SimpleGraph<string, string>, details : bool, dec : FiFunctionDec) -> SimpleGraph<string, string> {
	// Extract the named function arguments
	argTypes = filtermap(dec.type.args, \a -> {
		argName = getFiTypeName(a.type);
		if (argName == "") None() else Some(argName);
	});
	retType = getIncaTypeNameOrVoid(dec.type.returnType);

	if (length(argTypes) == 1 && retType != "") {
		argType = argTypes[0];

		// println("\n" + argType + " -> " + retType);

		acc2 = if (details) addIncaCasesToGraph(env, acc, dec.name, dec.lambda) else acc;
		addSimpleEdge(acc2, argType, retType, dec.name, 2);
	} else acc;
}

addIncaCasesToGraph(env : IncaEnv, acc : SimpleGraph<string, string>, fn : string, ex : FiExp) -> SimpleGraph<string, string> {
	todo = \ -> {
		println("TODO: Add cases to graph for " + ex.structname);
		acc;
	}
	switch (ex) {
		FiLambda(args, body, type, start): addIncaCasesToGraph(env, acc, fn, body);

		FiCall(f, args, type, start): {
			fold(args, acc, \acc2, e -> {
				addIncaCasesToGraph(env, acc2, fn, e);
			});
		}
		FiLet(name, type, e1, e2, type2, start): {
			acc1 = addIncaCasesToGraph(env, acc, fn, e1);
			addIncaCasesToGraph(env, acc1, fn, e2);
		}
		FiIf(e1, e2, e3, type, start): todo();
		FiSwitch(x, switchType, cases, type, start): {
			fold(cases, acc, \acc2, case : FiCase -> {
				addIncaCaseToGraph(env, acc2, fn, case)
			});
		}
		FiCast(e, tFrom, tTo, type, start): todo();
		FiSeq(es, type, start): {
			fold(es, acc, \acc2, e -> {
				addIncaCasesToGraph(env, acc2, fn, e);
			});
		}
		FiCallPrim(op, es, type, start): {
			fold(es, acc, \acc2, e -> {
				addIncaCasesToGraph(env, acc2, fn, e);
			});
		}

		FiVar(name, type, start): acc;
		FiVoid(start): acc;
		FiDouble(d, start): acc;
		FiInt(i, start): acc;
		FiString(s, start): acc;
		FiBool(b, start): acc;
		FiRequire(flowfile, e, type, start): todo();
		FiUnsafe(name, fallback, type, start): todo();
	}
}

addIncaCaseToGraph(env : IncaEnv, acc : SimpleGraph<string, string>, fn : string, case : FiCase) -> SimpleGraph<string, string> {
	switch (case.body) {
		FiVar(__, __, __): acc;
		default: {
			type = getIncaTypeNameOrVoid(fiExpType(case.body));

			addIncaEdge(env, acc, case.struct, type, fn, 1);
		}
	}
}

getIncaTypeNameOrVoid(t : FiType) -> string {
	if (t == FiTypeVoid()) "void" else getFiTypeName(t);
}


addIncaEdge(env : IncaEnv, g : SimpleGraph<string, string>, from : string, to : string, fn : string, cost : int) -> SimpleGraph<string, string> {
	fromExpanded = incaFiName2structs(env, from);
	toExpanded = incaFiName2structs(env, to);
	println("to: " + to + " is " + toString(set2array(toExpanded)));
	acc0 = addSimpleEdge(g, from, to, fn, cost);
	foldSet(fromExpanded, acc0, \acc1, fr -> {
		foldSet(toExpanded, acc1, \acc2, t -> {
			addSimpleEdge(acc2, fr, t, fn, cost)
		})
	})
}

incaFiName2structs(env : IncaEnv, tname : string) -> Set<string> {
	mudef = lookupTree(env.unions, tname);
	switch (mudef) {
		None(): makeSet1(tname);
		Some(udef): {
			fold(udef.typenames, makeSet(), \acc, tn -> {
				mergeSets(acc, incaFiName2structs(env, tn.name))
			})
		}
	}
}
