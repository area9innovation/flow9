import tools/flowc/backends/nim/fi2nim_defines;
import tools/flowc/manipulation/common;
import tools/flowc/backends/nim/fi2nim_mangle;

export {
	fi2nimIsImportLine(line: string) -> bool;

	fi2nimStrIndent(s: string) -> string;
	fi2nimMaybeIndent(s: string) -> string;
	fi2nimSureIndent(s: string) -> string;
	fiNimRenameKeyword(kwd: string) -> string;

	fiNimCompileFuncType(env: FiNimEnv, type: FiTypeFunction) -> string;
	fiNimCompileType(env: FiNimEnv, type: FiType) -> string;
	fiNimDerefType(t: FiType) -> FiType;

	fiNimTypeParamsList(env: FiNimEnv, type: FiType) -> string;
	fiNimParamsForInstantiate(env: FiNimEnv, params: [FiType]) -> string;

	// Get all casts from expression
	fiAllCasts(e: FiExp, acc :Tree<FiType, Set<FiType>>) -> Tree<FiType, Set<FiType>>;

	// Remove all FiTypeRef and replace union type names onto 'Struct' type name (represents a general union)
	fiType2NimType(names: FiGlobalNames, type: FiType) -> FiType;

	fi2nimTypeId(env : FiNimEnv, type: FiType) -> string;
	fi2nimStructId(env : FiNimEnv, struct: FiTypeStruct) -> string;

	// All (proper) subterms of a type as a term. 'proper' means the term 't' itself is excluded from the set
	fiTypeSubterms(t: FiType, proper: bool) -> Set<FiType>;
}

fi2nimIsImportLine(line: string) -> bool {
	startsWith(line, "import") || startsWith(line, "from");
}

fi2nimStrIndent(s : string) -> string {
	strGlue(map(
		filter(strSplit(s, "\n"), \line -> exists(s2a(line), \code -> code > 32)), 
		\line -> fiNimIndent + line
	), "\n");
}

fi2nimMaybeIndent(s : string) -> string {
	if (!strContains(s, "\n")) " " + s + " " else "\n" + fi2nimStrIndent(s) + "\n";
}

fi2nimSureIndent(s : string) -> string {
	"\n" + fi2nimStrIndent(s) + "\n";
}

fiNimRenameKeyword(kwd : string) -> string {
	k = (if (containsSet(nimKeywordSet, kwd)) "fl0w" else "") + kwd;
	strReplace(k, "_", "u")
}

fiNimTypeParamsList(env : FiNimEnv, type : FiType) -> string {
	tps = fiCollectTypars(type, makeSet());
	tp = fold(sort(set2array(tps)), [], \acc1, e -> concat(acc1, ["T" + i2s(strlen(e))]));
	if (tp == []) "" else { "[" + strGlue(tp, ", ") + "]" }
}

fiNimParamsForInstantiate(env : FiNimEnv, params : [FiType]) -> string {
	if (params == []) "" else {
		"[" + strGlue(map(params, \tp -> fiNimCompileType(env, tp)), ", ") + "]"
	}
}

fiNimCompileFuncType(env : FiNimEnv, type : FiTypeFunction) -> string {
	rt_code = switch (type.returnType) {
		FiTypeFunction(__,__): "(" + fiNimCompileType(env, type.returnType) + ")";
		default: fiNimCompileType(env, type.returnType);
	}
	"(" + 
		supergluei(type.args, \i, arg -> 
			fiNimRenameKeyword(if (arg.name == "" || arg.name == "__") "a" + i2s(i) else arg.name) + ": " +
			fiNimCompileType(env, arg.type), 
			", "
		) + 
	"): " + rt_code;
}

fiNimCompileType(env : FiNimEnv, type : FiType) -> string {
	switch (type) {
		FiTypeArray(t) :           {
			"seq[" + fiNimCompileType(env, t) + "]";
		}
		FiTypeFunction(args, rt) : {
			"proc" + fiNimCompileFuncType(env, type);
		}
		FiTypeRef(t) :             fiNimCompileType(env, t);
		FiTypeParameter(n) :       "T" + i2s(strlen(n));
		FiTypeBool() :             "bool";
		FiTypeInt() :              "int32";
		FiTypeDouble() :           "float";
		FiTypeString() :           "string";
		FiTypeFlow() :             "Flow";
		FiTypeVoid() :             "void";
		FiTypeNative() :           "Native";
		FiTypeName(name, params) : {
			if (containsKeyTree(env.prog.names.structs, name)) {
				name + fiNimParamsForInstantiate(env, params);
			} else {
				// Unions are just unspecified structs
				"Struct";
			}
		}
	}
}

fiNimDerefType(t: FiType) -> FiType {
	switch (t) {
		FiTypeRef(r): fiNimDerefType(r);
		default: t;
	}
}

fiAllCasts(e: FiExp, acc : Tree<FiType, Set<FiType>>) -> Tree<FiType, Set<FiType>> {
	fiFoldExp(e, acc, \x, env, ac -> {
			switch (x) {
				FiCast(__,from, to,__,__): {
					pure_from = fiPurifyType(from);
					setTree(ac, pure_from, 
						insertSet(lookupTreeDef(ac, pure_from, makeSet()), fiPurifyType(to))
					)
				}
				default: ac;
			}
		}, 
		AstTraverseOrder(true, true)
	);
}

fiType2NimType(names : FiGlobalNames, type : FiType) -> FiType {
	switch (type) {
		FiTypeArray(t) :           {
			FiTypeArray(fiType2NimType(names, t));
		}
		FiTypeFunction(args, rt) : {
			FiTypeFunction(
				map(args, \arg -> FiFunArg(arg with type = fiType2NimType(names, arg.type))),
				fiType2NimType(names, rt)
			);
		}
		FiTypeRef(t): {
			// Just skip references
			fiType2NimType(names, t);
		}
		FiTypeName(name, params) : {
			if (containsKeyTree(names.structs, name)) {
				FiTypeName(name, map(params, \p -> fiType2NimType(names, p)));
			} else {
				// Unions are just unspecified structs
				FiTypeName("Struct", []);
			}
		}
		default: type;
	}
}

fi2nimTypeId(env : FiNimEnv, type: FiType) -> string {
	"tp_" + fi2nimMangleType(type);
}

fi2nimStructId(env : FiNimEnv, struct: FiTypeStruct) -> string {
	"st_" + struct.name;
}

fiTypeProperSubterms(t: FiType) -> Set<FiType> {
	fiFoldType(t, makeSet(), \ac, x ->
		if (fiEqualTypes(x, t)) ac else insertSet(ac, fiPurifyType(x))
	);
}

fiTypeSubterms(t: FiType, proper: bool) -> Set<FiType> {
	fiFoldType(t, makeSet(), \ac, x ->
		if (proper && fiEqualTypes(x, t)) ac else insertSet(ac, fiPurifyType(x))
	);
}
