import tools/flowc/manipulation/common;
import tools/flowc/incremental/fi_helpers2;
import tools/flowc/backends/nim/fi2nim_defines;
import tools/flowc/backends/nim/fi2nim_mangle;

export {
	fi2nimIsImportLine(line: string) -> bool;
	fiNimRenameKeyword(kwd: string) -> string;

	fi2nimTypeId(env : FiNimEnv, type: FiType) -> string;
	fi2nimStructId(env : FiNimEnv, struct: string) -> string;

	fiNimCompileReturnType(env : FiNimEnv, type : FiType) -> string;
	fiNimCompileFuncType(env: FiNimEnv, type: FiTypeFunction) -> string;
	fiNimCompileType(env: FiNimEnv, type: FiType) -> string;

	fiNimTypeParamsList(env: FiNimEnv, type: FiType) -> string;
	fiNimParamsForInstantiate(env: FiNimEnv, params: [FiType]) -> string;

	// Get all casts from expression
	fiAllCasts(e: FiExp, acc :Tree<FiType, Set<FiType>>) -> Tree<FiType, Set<FiType>>;

	// All (proper) subterms of a type as a term. 'proper' means the term 't' itself is excluded from the set
	fiTypeSubterms(t: FiType, proper: bool) -> Set<FiType>;

	// Odrer types by dependency relation
	fi2nimToposortTypes(env: FiNimEnv, types: [FiStructOrUnion], acc: [FiStructOrUnion]) -> [FiStructOrUnion];
}

fi2nimIsImportLine(line: string) -> bool {
	startsWith(line, "import") || startsWith(line, "from");
}

fiNimRenameKeyword(kwd : string) -> string {
	k = (if (containsSet(nimKeywordSet, kwd)) "fl0w" else "") + kwd;
	strReplace(k, "_", "u")
}

fi2nimTypeId(env : FiNimEnv, type: FiType) -> string {
	"tp_" + fi2nimMangleType(type);
}

fi2nimStructId(env : FiNimEnv, struct: string) -> string {
	"st_" + struct;
}

fiNimTypeParamsList(env : FiNimEnv, type : FiType) -> string {
	typars = switch (type) {
		FiTypeName(__, typars): typars;
		default: {
			map(sort(set2array(fiCollectTypars(type, makeSet()))), \n -> FiTypeParameter(n));	
		}
	}
	fiNimParamsForInstantiate(env, typars);
}

fiNimParamsForInstantiate(env : FiNimEnv, params : [FiType]) -> string {
	if (params == []) "" else {
		"[" + strGlue(map(params, \tp -> fiNimCompileType(env, tp)), ", ") + "]"
	}
}

fiNimCompileReturnType(env : FiNimEnv, type : FiType) -> string {
	switch (type) {
		FiTypeFunction(__,__): "(" + fiNimCompileType(env, type) + ")";
		default: fiNimCompileType(env, type);
	}
}

fiNimCompileFuncType(env : FiNimEnv, type : FiTypeFunction) -> string {
	"(" + 
		supergluei(type.args, \i, arg -> 
			fiNimRenameKeyword(if (arg.name == "" || arg.name == "__") "a" + i2s(i) else arg.name) + ": " +
			fiNimCompileType(env, arg.type), 
			", "
		) + 
	"): " + fiNimCompileReturnType(env, type.returnType);
}

fiNimCompileType(env : FiNimEnv, type : FiType) -> string {
	switch (type) {
		FiTypeArray(t) :           {
			"seq[" + fiNimCompileType(env, t) + "]";
		}
		FiTypeFunction(args, rt) : {
			"proc" + fiNimCompileFuncType(env, type);
		}
		FiTypeRef(t) :             "Ref[" + fiNimCompileType(env, t) + "]";
		FiTypeParameter(n) :       "T" + i2s(strlen(n));
		FiTypeBool() :             "bool";
		FiTypeInt() :              "int32";
		FiTypeDouble() :           "float";
		FiTypeString() :           "string";
		FiTypeFlow() :             "Flow";
		FiTypeVoid() :             "void";
		FiTypeNative() :           "Native";
		FiTypeName(name, params) : {
			name + fiNimParamsForInstantiate(env, params);
		}
	}
}

fiAllCasts(e: FiExp, acc : Tree<FiType, Set<FiType>>) -> Tree<FiType, Set<FiType>> {
	fiFoldExp(e, acc, \x, env, ac -> {
			switch (x) {
				FiCast(__,from, to,__,__): {
					pure_from = fiPurifyType(from);
					setTree(ac, pure_from, 
						insertSet(lookupTreeDef(ac, pure_from, makeSet()), fiPurifyType(to))
					)
				}
				default: ac;
			}
		}, 
		AstTraverseOrder(true, true)
	);
}

fiTypeProperSubterms(t: FiType) -> Set<FiType> {
	fiFoldType(t, makeSet(), \ac, x ->
		if (fiEqualTypes(x, t)) ac else insertSet(ac, fiPurifyType(x))
	);
}

fiTypeSubterms(t: FiType, proper: bool) -> Set<FiType> {
	fiFoldType(t, makeSet(), \ac, x ->
		if (proper && fiEqualTypes(x, t)) ac else insertSet(ac, fiPurifyType(x))
	);
}

fi2nimToposortTypes(env: FiNimEnv, types: [FiStructOrUnion], acc: [FiStructOrUnion]) -> [FiStructOrUnion] {
	if (length(types) == 0) acc else {
		ready = filter(types, \tp ->
			eitherMap(
				lookupTree(env.super_types, tp.name), 
				\super -> forall(types, \t -> t.name != super.name), 
				true
			)
		);
		if (length(ready) == 0) {
			fail0("cyclic dependency among typenames:\n" + 
				superglue(types, \tp -> "\t" + pretFiStructOrUnion(tp), "\n")
			);
		} else {
			new_types = filter(types, \tp -> !exists(ready, \t -> t.name == tp.name));
			fi2nimToposortTypes(env, new_types, concat(acc, ready));
		}
	}
}
