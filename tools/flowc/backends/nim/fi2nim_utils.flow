import tools/flowc/backends/common;
import tools/flowc/backends/nim/fi2nim_defines;
import tools/flowc/incremental/fi_helpers;
import tools/flowc/manipulation/common;

export {
	fi2nimStrIndent(s : string) -> string;
	fiType2NimType(env : FiNimEnv, type : FiType) -> string;
	fiType2NimTypeName(env : FiNimEnv, type : FiType) -> string;
	fiDiscardExpr(exprStr : string, expr : FiExp) -> string;
	fiDoDiscard(exprStr : string, discard : bool) -> string;
	fiNimTypeParamsList(env : FiNimEnv, fn : FiFunctionDec) -> string;
	fiNimTypeParamsListStruct(env : FiNimEnv, arg_types: [FiType]) -> string;
	fiNimRenameKeyword(kwd : string) -> string;
	fiNimParamsForInstantiate(env : FiNimEnv, params: [FiType]) -> string;

	// Get all casts from expression
	fiAllCasts(e: FiExp, acc : Tree<FiType, Set<FiType>>) -> Tree<FiType, Set<FiType>>;
}

fiProcCounter : ref int = ref 0;

fi2nimStrIndent(s : string) -> string {
	strGlue(map(strSplit(s, "\n"), \line -> fiNimIndent + line), "\n");
}

fiNimRenameKeyword(kwd : string) -> string {
	k = (if (containsSet(nimKeywordSet, kwd)) "fl0w" else "") + kwd;
	strReplace(k, "_", "u")
}

fiNimTypeParamsList(env : FiNimEnv, fn : FiFunctionDec) -> string {
	tps = foldi(fn.lambda.args, makeSet(), \idx, accT, arg ->
		fiCollectTypars(arg.type, accT)
	);
	rt = fiCollectTypars(fn.type.returnType, tps);
	tp = fold(sort(set2array(rt)), [], \acc1, e -> concat(acc1, ["T" + i2s(strlen(e))]));
	if (tp == []) "" else { "[" + strGlue(tp, ", ") + "]" }
}

fiNimTypeParamsListStruct(env : FiNimEnv, arg_types : [FiType]) -> string {
	tps = fold(arg_types, makeSet(), \a, t ->
		fiCollectTypars(t, a)
	);
	tp = fold(sort(set2array(tps)), [], \acc1, e ->
		concat(acc1, ["T" + i2s(strlen(e))])
	);
	if (tp == []) "" else { "[" + strGlue(tp, ", ") + "]" }
}

fiNimParamsForInstantiate(env : FiNimEnv, params : [FiType]) -> string {
	if (params == []) "" else {
		"[" + strGlue(map(params, \tp -> fiType2NimType(env, tp)), ", ") + "]"
	}
}

fiType2NimType(env : FiNimEnv, type : FiType) -> string {
	switch (type) {
		FiTypeArray(t) :           {
			"seq[" + fiType2NimType(env, t) + "]";
		}
		FiTypeFunction(args, rt) : {
			tp = fiNimTypeParamsListStruct(env, map(args, \arg -> arg.type));
			r = "proc(" + strGlue(mapi(args, \ix, e -> {
				(if (e.name == "" || e.name == "__") "t" + i2s(ix) else fiNimRenameKeyword(e.name)) + ": " + fiType2NimType(env, e.type);
				//fiProcCounter := ^fiProcCounter + 1;
			}), ", ") +"): " + fiType2NimType(env, rt);
			r;
		}
		FiTypeRef(t) :             fiType2NimType(env, t);
		FiTypeParameter(n) :       "T" + i2s(strlen(n));
		FiTypeBool() :             "bool";
		FiTypeInt() :              "int";
		FiTypeDouble() :           "float";
		FiTypeString() :           "string";
		FiTypeFlow() :             "Flow";
		FiTypeVoid() :             "void";
		FiTypeNative() :           "Native";
		FiTypeName(name, params) : {
			if (containsKeyTree(env.prog.names.structs, name)) {
				name + fiNimParamsForInstantiate(env, params);
			} else {
				// Unions are just unspecified structs
				"Struct";
			}
		}
	}
}

fiType2NimTypeName(env : FiNimEnv, type : FiType) -> string {
	switch (type) {
		FiTypeArray(t) :           fiType2NimTypeName(env, t);
		FiTypeFunction(args, rt) : fiType2NimTypeName(env, rt);
		FiTypeRef(t) :             fiType2NimType(env, t);
		FiTypeParameter(n) :       "T" + i2s(strlen(n));
		FiTypeBool() :             "bool";
		FiTypeInt() :              "int";
		FiTypeDouble() :           "float";
		FiTypeString() :           "string";
		FiTypeFlow() :             "Flow";
		FiTypeVoid() :             "void";
		FiTypeNative() :           "Native";
		FiTypeName(name, params) :  {
			if (containsKeyTree(env.prog.names.structs, name)) {
				name; // Name of union or struct
			} else {
				// Unions are just unspecified structs
				"Struct";
			}
		}
	}
}

fiDiscardExpr(exprStr : string, expr : FiExp) -> string {
	switch (expr) {
		FiCallPrim(__, __, __, __): "discard " + exprStr;
		default : exprStr;
	}
}

fiDoDiscard(exprStr : string, discard : bool) -> string {
	(if (discard) "discard " else "") + exprStr;
}

fiAllCasts(e: FiExp, acc : Tree<FiType, Set<FiType>>) -> Tree<FiType, Set<FiType>> {
	fiFoldExp(e, acc, \x, env, ac -> {
			switch (x) {
				FiCast(__,from, to,__,__): {
					pure_from = fiPurifyType(from);
					setTree(ac, pure_from, 
						insertSet(lookupTreeDef(ac, pure_from, makeSet()), fiPurifyType(to))
					)
				}
				default: ac;
			}
		}, 
		AstTraverseOrder(true, true)
	);
}
