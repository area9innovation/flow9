import tools/flowc/backends/common;
import tools/flowc/backends/nim/fi2nim_defines;
import tools/flowc/incremental/fi_helpers;
import tools/flowc/manipulation/common;

export {
	fi2nimStrIndent(s : string) -> string;
	fi2nimMaybeIndent(s : string) -> string;
	fi2nimSureIndent(s : string) -> string;
	fiNimRenameKeyword(kwd : string) -> string;

	fiFuncType2NimType(env : FiNimEnv, type : FiTypeFunction) -> string;
	fiType2NimType(env : FiNimEnv, type : FiType) -> string;
	fiNimDerefType(t: FiType) -> FiType;

	fiNimTypeParamsList(env : FiNimEnv, fn : FiFunctionDec) -> string;
	fiNimParamsForInstantiate(env : FiNimEnv, params: [FiType]) -> string;

	// Get all casts from expression
	fiAllCasts(e: FiExp, acc : Tree<FiType, Set<FiType>>) -> Tree<FiType, Set<FiType>>;
}

fiProcCounter : ref int = ref 0;

fi2nimStrIndent(s : string) -> string {
	strGlue(map(
		filter(strSplit(s, "\n"), \line -> exists(s2a(line), \code -> code > 32)), 
		\line -> fiNimIndent + line
	), "\n");
}

fi2nimMaybeIndent(s : string) -> string {
	if (!strContains(s, "\n")) " " + s + " " else "\n" + fi2nimStrIndent(s) + "\n";
}

fi2nimSureIndent(s : string) -> string {
	"\n" + fi2nimStrIndent(s) + "\n";
}

fiNimRenameKeyword(kwd : string) -> string {
	k = (if (containsSet(nimKeywordSet, kwd)) "fl0w" else "") + kwd;
	strReplace(k, "_", "u")
}

fiNimTypeParamsList(env : FiNimEnv, fn : FiFunctionDec) -> string {
	tps = foldi(fn.lambda.args, makeSet(), \idx, accT, arg ->
		fiCollectTypars(arg.type, accT)
	);
	rt = fiCollectTypars(fn.type.returnType, tps);
	tp = fold(sort(set2array(rt)), [], \acc1, e -> concat(acc1, ["T" + i2s(strlen(e))]));
	if (tp == []) "" else { "[" + strGlue(tp, ", ") + "]" }
}

fiNimParamsForInstantiate(env : FiNimEnv, params : [FiType]) -> string {
	if (params == []) "" else {
		"[" + strGlue(map(params, \tp -> fiType2NimType(env, tp)), ", ") + "]"
	}
}

fiFuncType2NimType(env : FiNimEnv, type : FiTypeFunction) -> string {
	rt_code = switch (type.returnType) {
		FiTypeFunction(__,__): "(" + fiType2NimType(env, type.returnType) + ")";
		default: fiType2NimType(env, type.returnType);
	}
	"(" + 
		supergluei(type.args, \i, arg -> 
			fiNimRenameKeyword(if (arg.name == "" || arg.name == "__") "a" + i2s(i) else arg.name) + ": " +
			fiType2NimType(env, arg.type), 
			", "
		) + 
	"): " + rt_code;
}

fiType2NimType(env : FiNimEnv, type : FiType) -> string {
	switch (type) {
		FiTypeArray(t) :           {
			"seq[" + fiType2NimType(env, t) + "]";
		}
		FiTypeFunction(args, rt) : {
			"proc" + fiFuncType2NimType(env, type);
		}
		FiTypeRef(t) :             fiType2NimType(env, t);
		FiTypeParameter(n) :       "T" + i2s(strlen(n));
		FiTypeBool() :             "bool";
		FiTypeInt() :              "int";
		FiTypeDouble() :           "float";
		FiTypeString() :           "string";
		FiTypeFlow() :             "Flow";
		FiTypeVoid() :             "void";
		FiTypeNative() :           "Native";
		FiTypeName(name, params) : {
			if (containsKeyTree(env.prog.names.structs, name)) {
				name + fiNimParamsForInstantiate(env, params);
			} else {
				// Unions are just unspecified structs
				"Struct";
			}
		}
	}
}

fiNimDerefType(t: FiType) -> FiType {
	switch (t) {
		FiTypeRef(r): fiNimDerefType(r);
		default: t;
	}
}

fiAllCasts(e: FiExp, acc : Tree<FiType, Set<FiType>>) -> Tree<FiType, Set<FiType>> {
	fiFoldExp(e, acc, \x, env, ac -> {
			switch (x) {
				FiCast(__,from, to,__,__): {
					pure_from = fiPurifyType(from);
					setTree(ac, pure_from, 
						insertSet(lookupTreeDef(ac, pure_from, makeSet()), fiPurifyType(to))
					)
				}
				default: ac;
			}
		}, 
		AstTraverseOrder(true, true)
	);
}
