import tools/flowc/backends/nim/fi2nim_utils;
import tools/flowc/incremental/fi_helpers2;
import string_utils;

export {
	fi2nimTypeEnums(env : FiNimEnv) -> string;
	fi2nimStructDecl(env : FiNimEnv, struct : FiTypeStruct) -> string;
	fi2nimStructRegister(env : FiNimEnv, struct : FiTypeStruct) -> string;
	fi2nimUnionDecl(env : FiNimEnv, union : FiTypeUnion) -> string;

	fi2nimTypeDecl(env : FiNimEnv, type : FiStructOrUnion) -> string;
	fi2nimStructToFlow(env : FiNimEnv) -> NimCompiled;
	fi2nimStructToString(env : FiNimEnv) -> NimCompiled;

	//fi2nimTypeToTypeId(env : FiNimEnv, t: FiType) -> Maybe<NimCompiled>;
	fi2nimTypeToFlow(env : FiNimEnv, t: FiType) -> Maybe<NimCompiled>;
	fi2nimTypeFromFlow(env : FiNimEnv, t: FiType) -> Maybe<NimCompiled>;
	fi2nimTypeToString(env : FiNimEnv, t: FiType) -> Maybe<NimCompiled>;

	fi2nimTypeToTypeId(env : FiNimEnv, tn: FiType) -> Maybe<NimCompiled>;

	fi2nimInitTypeIndexes(env : FiNimEnv, debug_nim_type_ids: bool) -> FiNimEnv;
	fi2nimRegisterTypes(env : FiNimEnv) -> string;
}

fi2nimTypeEnums(env : FiNimEnv) -> string {
	structs_enum = if (length(env.structs) == 0) "" else {
		fiNimIndent + "# All structs, used in program \n" +
		fiNimIndent + "StructType = enum\n" +
		supergluei(env.structs, \i, s ->
			fiNimIndent2 + fi2nimStructId(env, s) + (if (i + 1 == length(env.structs)) "" else "," ) + " # " + i2s(i), "\n"
		) + "\n\n";
	}
	types_enum = if (length(env.ordered_types) == 0) "" else {
		fiNimIndent + "# All types, used in program\n" +
		fiNimIndent + "ProgType = enum\n" +
		supergluei(env.ordered_types, \i, tp ->
			fiNimIndent2 + fi2nimTypeId(env, tp) + (if (i + 1 == length(env.ordered_types)) "" else "," ) + " # " + i2s(i)  + " = " + pretFiType(tp), "\n"
		) + "\n\n";
	}
	structs_enum + types_enum;
}

fi2nimTypeDecl(env : FiNimEnv, type : FiStructOrUnion) -> string {
	switch (type) {
		FiTypeStruct(name, typars, args,__): {
			fields = if (length(args) == 0) "" else
			"\n" + superglue(args, \arg -> fiNimIndent2 + fiNimRenameKeyword(arg.name) + ": " + fiNimCompileType(env, arg.type), "\n");
			struct_type = name + fiNimParamsForInstantiate(env, typars);
			super_type = eitherMap(lookupTree(env.super_types, name), \u -> fiNimCompileType(env, u), "Struct");
			fiNimIndent + struct_type + " = ref object of " + super_type + fields + "\n\n";
		}
		FiTypeUnion(name, typars, typenames,__): {
			super_type = eitherMap(lookupTree(env.super_types, name), \u -> fiNimCompileType(env, u), "Struct");
			fiNimIndent + name + fiNimParamsForInstantiate(env, typars) + " = ref object of " + super_type + "\n\n";
		}
	}
}

fi2nimStructDecl(env : FiNimEnv, struct : FiTypeStruct) -> string {
	typars = fiNimParamsForInstantiate(env, struct.typars);
	fields = if (length(struct.args) == 0) "" else
	"\n" + superglue(struct.args, \arg -> fiNimIndent2 + fiNimRenameKeyword(arg.name) + ": " + fiNimCompileType(env, arg.type), "\n");
	struct_type = struct.name + typars;
	super_type = eitherMap(lookupTree(env.super_types, struct.name), \u -> fiNimCompileType(env, u), "Struct");
	fiNimIndent + struct_type + " = ref object of " + super_type + fields + "\n\n";
}

fi2nimUnionDecl(env : FiNimEnv, union : FiTypeUnion) -> string {
	super_type = eitherMap(lookupTree(env.super_types, union.name), \u -> fiNimCompileType(env, u), "Struct");
	fiNimIndent + union.name + fiNimParamsForInstantiate(env, union.typeparameters) + " = ref object of " + super_type + "\n\n";
}

fi2nimStructRegister(env : FiNimEnv, struct : FiTypeStruct) -> string {
	"rt_register_struct(\"" + struct.name  + "\", @[" + superglue(struct.args, \arg -> "\"" + arg.name + "\"", ", ") + "])\n"
}

/*
fi2nimTypeToTypeId(env : FiNimEnv, t: FiType) -> Maybe<NimCompiled> {
	decl = "proc rt_type_id(x: " + fiNimCompileType(env, t) + "): int32";
	switch (lookupTree(env.type_index, t)) {
		Some(id): {
			Some(NimCompiled(decl + " = " + i2s(id), ""));
		}
		None(): {
			fail("type is not present in type index: " + pretFiType(t));
			None();
		}
	}
}
*/

fi2nimTypeToFlow(env : FiNimEnv, t: FiType) -> Maybe<NimCompiled> {
	decl = "proc rt_to_flow(x: " + fiNimCompileType(env, t) + "): Flow";
	switch (t) {
		FiTypeRef(__): {
			Some(NimCompiled(decl,
				decl + " = Flow(" + "tp: rtRef, " + "ref_v: rt_to_flow(x.val))\n"
			));
		}
		FiTypeArray(__): {
			Some(NimCompiled(decl,
				decl + " = Flow(" + "tp: rtArray, " + "array_v: map(x, rt_to_flow))\n"
			));
		}
		FiTypeFunction(args,__): {
			Some(NimCompiled(decl,
				decl + " =\n" +
				fiNimIndent + "Flow(" +
					"tp: rtFunc, " +
					"func_v: proc(y: seq[Flow]): Flow = rt_to_flow(x(" +
					supergluei(args, \i, arg -> "rt_to_" + fi2nimMangleComplexType(arg.type) + "(y[" + i2s(i) + "])#[" + pretFiType(arg.type) + "]#", ", ") +
				")))\n\n"
			));
		}
		FiTypeName(nm, tps): {
			fiMapTypeName(t, env.prog.names, 
				\struct -> Some(NimCompiled(decl,
					"# to flow from: struct " + pretFiType(t) + "\n" +
					decl + " =\n" +
					fiNimIndent + "Flow(" +
						"tp: rtStruct, " +
						"str_id: x.id, " + 
						"str_name: \"" + struct.name + "\", " + 
						"str_args: @[" + superglue(struct.args, \arg -> "rt_to_flow(x." + fiNimRenameKeyword(arg.name) + ")", ", ") + "]" +
					")\n\n"
				)),
				\union -> {
					case = \spec ->
						fiNimIndent + "of int32(" + fi2nimTypeId(env, spec) + "): return rt_to_flow(" + fiNimCompileType(env, spec)  + "(x))";
					cases = concat(
						/*mapConcat(union.typenames, \tn ->
							map(set2array(lookupTreeDef(env.specializations, tn.name, makeSet1(tn))), \spec ->
								fiNimIndent + "of int32(" + fi2nimTypeId(env, spec) + "): return rt_to_flow(" + fiNimCompileType(env, spec) + "(x))"
							)
						),*/
						map(union.typenames, case),
						[fiNimIndent + "else: assert(false, \"struct id \" & intToStr(x.id) & \" is not covered by union\" & \"" + union.name + "\")"]
					);
					Some(NimCompiled(decl,
						"# to flow from: union " + pretFiType(t) + "\n" +
						decl + " =\n" + 
						fiNimIndent + "case x.id:\n" +
						strGlue(cases, "\n") +
						"\n\n"
					));
				},
				\__ -> fail0("unknown struct or union: " + nm)
			);
		}
		FiTypeParameter(__): fail0("FiTypeParameter must not occur in complete specialization in nim: " + pretFiType(t));
		default: None();
	}
}

fi2nimStructToFlow(env : FiNimEnv) -> NimCompiled {
	decl = "proc rt_to_flow(x: Struct): Flow";
	structs = filtermap(env.ordered_types, \tp -> switch (tp) {
		FiTypeName(__,__): Some(tp);
		default: None();
	});
	cases = map(structs, \s -> 
		fiNimIndent + "of int32(" + fi2nimTypeId(env, s) + "): " + 
			"return rt_to_flow(" + fiNimCompileType(env, s) + "(x))\n"
	);
	else_case = fiNimIndent + "else: assert(false,\"not a struct id: \" & intToStr(x.id))\n";
	NimCompiled(decl, 
		decl + " =\n" +
		fiNimIndent + "case x.id:\n" +
		concatStrings(concat(cases, [else_case])) + "\n"
	);
}

fi2nimStructToString(env : FiNimEnv) -> NimCompiled {
	decl = "proc rt_to_string(x: Struct): Flow";
	structs = filtermap(env.ordered_types, \tp -> switch (tp) {
		FiTypeName(__,__): Some(tp);
		default: None();
	});
	cases = map(structs, \s -> 
		fiNimIndent + "of int32(" + fi2nimTypeId(env, s) + "): " + 
			"return rt_to_string(" + fiNimCompileType(env, s) + "(x))\n"
	);
	else_case = fiNimIndent + "else: assert(false,\"not a struct id: \" & intToStr(x.id))\n";
	NimCompiled(decl, 
		decl + " =\n" +
		fiNimIndent + "case x.id:\n" +
		concatStrings(concat(cases, [else_case])) + "\n"
	);
}

fi2nimTypeFromFlow(env : FiNimEnv, t: FiType) -> Maybe<NimCompiled> {
	decl = "proc rt_to_" + fi2nimMangleType(t) + "(x: Flow): " + fiNimCompileReturnType(env, t);
	switch (t) {
		FiTypeRef(rt): {
			Some(NimCompiled(decl,
				decl + " = Ref[" + fiNimCompileType(env, rt) + "](val: rt_to_" + fi2nimMangleComplexType(rt) + "(x.ref_v))\n"
			));
		}
		FiTypeArray(at): {
			Some(NimCompiled(decl,
				decl + " = map(x.array_v, " + "rt_to_" + fi2nimMangleComplexType(at) + ")\n"
			));
		}
		FiTypeFunction(args, returnType): {
			Some(NimCompiled(decl,
				decl + " =\n" +
				fiNimIndent + "return proc(" + 
					supergluei(args, \i, arg -> "a_" + i2s(i) + ": " + fiNimCompileType(env, arg.type), ", ") + 
				"): " + fiNimCompileType(env, returnType) + " =\n" +
					fiNimIndent2 + "rt_to_" + fi2nimMangleComplexType(returnType) + "(x.func_v(@[" +
						supergluei(args, \i,__ -> "rt_to_flow(a_" + i2s(i) + ")", ", ") +
					"]))\n\n"
			));
		}
		FiTypeName(nm, tps): {
			fiMapTypeName(t, env.prog.names, 
				\struct -> {
					Some(NimCompiled(decl,
						"# from flow to: struct " + pretFiType(t) + "\n" +
						decl + " =\n" +
						fiNimIndent + "return " + fiNimCompileType(env, t) + "(id: int32(" + fi2nimTypeId(env, t) + ")" +
							concatStrings(mapi(struct.args, \i, arg -> ", " + fiNimRenameKeyword(arg.name) + ": rt_to_" + fi2nimMangleComplexType(arg.type) + "(x.str_args[" + i2s(i) + "])")) + 
						")\n\n"
					));
				},
				\union -> {
					case = \spec -> {
						struct = fiSpecializeStruct(spec, lookupTreeDef(env.prog.names.structs, spec.name, FiTypeStruct("", [], [], 0)));
						fiNimIndent + "of int32(" + fi2nimTypeId(env, spec) + "): " +
						"return " + fiNimCompileType(env, spec) + "(" +
							"id: x.str_id" +  
							concatStrings(mapi(struct.args, \i, val -> 
								", " + fiNimRenameKeyword(struct.args[i].name) + ": rt_to_" + 
								fi2nimMangleComplexType(struct.args[i].type) + "(x.str_args[" + i2s(i) + "])"
							)) + 
						") #" + pretFiType(spec)
					}
					cases = concat(
						map(union.typenames, case
							//map(set2array(lookupTreeDef(env.specializations, tn.name, makeSet1(tn))), )
						),
						[fiNimIndent + "else: assert(false, \"struct id \" & intToStr(x.str_id) & \" is not covered by union\" & \"" + union.name + "\")"]
					);
					Some(NimCompiled(decl,
						"# from flow to: union " + pretFiType(t) + "\n" +
						decl + " =\n" + 
						fiNimIndent + "case x.str_id:\n" +
						strGlue(cases, "\n") +
						"\n\n"
					));
				},
				\__ -> fail0("unknown struct or union: " + nm)
			);
		}
		FiTypeParameter(__): fail0("FiTypeParameter must not occur in complete specialization in nim: " + pretFiType(t));
		default: None();
	}
}

fi2nimTypeToString(env : FiNimEnv, t: FiType) -> Maybe<NimCompiled> {
	decl = "proc rt_to_string(x: " + fiNimCompileType(env, t) + "): string";
	switch (t) {
		FiTypeRef(rt): {
			Some(NimCompiled(decl,
				decl + " = \"ref \" & rt_to_string(x.val)\n"
			));
		}
		FiTypeArray(at): {
			Some(NimCompiled(decl,
				decl + " = \"[\" & map(x, rt_to_string).join(\", \") & \"]\" \n"
			));
		}
		FiTypeFunction(args, returnType): {
			Some(NimCompiled(decl,
				 decl + " = \"<function>\"\n"
			));
		}
		FiTypeName(nm, tps): {
			fiMapTypeName(t, env.prog.names, 
				\struct -> {
					Some(NimCompiled(decl,
						"# to string from: struct " + pretFiType(t) + "\n" +
						decl + " =\n" +
						fiNimIndent + "\"" + struct.name + "(\"" + 
							concatStrings(map(struct.args, \arg -> " & rt_to_string(x." + fiNimRenameKeyword(arg.name) + ")")) + " & \")\"" + 
						"\n\n"
					));
				},
				\union -> {
					case = \spec ->
						fiNimIndent + "of int32(" + fi2nimTypeId(env, spec) + "): return rt_to_string(" + fiNimCompileType(env, spec) + "(x))";
					cases = concat(
						/*mapConcat(union.typenames, \tn ->
							map(set2array(lookupTreeDef(env.specializations, tn.name, makeSet1(tn))), \spec ->
								"of int32(" + fi2nimTypeId(env, spec) + "): return rt_to_string(" + fiNimCompileType(env, spec) + "(x))"
							)
						),*/
						map(union.typenames, case),
						[fiNimIndent + "else: assert(false, \"struct id \" & intToStr(x.id) & \" is not covered by union\" & \"" + union.name + "\")"]
					);
					Some(NimCompiled(decl,
						"# to string from: union " + pretFiType(t) + "\n" +
						decl + " =\n" + 
						fiNimIndent + "case x.id:\n" +
						strGlue(cases, "\n") +
						"\n\n"
					));
				},
				\__ -> fail0("unknown struct or union: " + nm)
			);
		}
		FiTypeParameter(__): fail0("FiTypeParameter must not occur in complete specialization in nim: " + pretFiType(t));
		default: None();
	}
}

fi2nimTypeToTypeId(env : FiNimEnv, t: FiType) -> Maybe<NimCompiled> {
	switch (t) {
		FiTypeName(name, typars): {
			fiMapTypeName(t, env.prog.names, 
				\struct -> {
					decl = "func rt_type_id_" + name + fiNimParamsForInstantiate(env, typars) + "(): int32";
					compiled = if (length(typars) == 0) {
						NimCompiled(
							"# type id of: struct " + pretFiType(t) + "\n" +
							decl + " = int32(" + fi2nimTypeId(env, t) + ")\n\n", ""
						);
					} else {
						if (exists(typars, \tp -> switch (tp) {
							FiTypeParameter(__): false;
							default: true; 
						})) {
							println("AAAA: " + pretFiType(t));
						}
						cases = concat(
							mapi(set2array(lookupTreeDef(env.specializations, name, makeSet())), \i, spec -> {
								spec_typars = cast(spec: FiType -> FiTypeName).typeparameters;
								fiNimIndent + (if (i == 0) "when" else "elif") + " (" +  
									supergluei(typars, \j, tp -> fiNimCompileType(env, tp) + " is " + fiNimCompileType(env, spec_typars[j]), " and ") +
								"): return int32(" + fi2nimTypeId(env, spec) + ")";
								//"of int32(" + fi2nimTypeId(env, spec) + "): return int32(" + 
								//	fiNimCompileType(env, spec) + "(x))"
							}),
							[fiNimIndent + "else: assert(false, \"struct typars are not known\" & \"" + name + "\")"]
						);
						NimCompiled(decl,
							"# type id of: struct " + pretFiType(t) + "\n" +
							decl + " =\n" + 
							strGlue(cases, "\n") + "\n\n"
						);
					}
					Some(compiled);
				},
				\union -> None(),
				\__ -> fail0("unknown struct or union: " + t.name)
			);
		}
		default: None();
	}
}

fi2nim_basic_types = [
	FiTypeVoid(), 
	FiTypeBool(), 
	FiTypeInt(), 
	FiTypeDouble(), 
	FiTypeString(), 
	FiTypeNative(), 
	FiTypeFlow()
];

fi2nimType2RtType(env : FiNimEnv, tp: FiType, type_index: Tree<FiType, int>, struct_index: Tree<string, int>) -> string {
	type_ind = \t0 -> {
		t = fiPurifyType(t0);
		err = \msg -> fail0(msg + " subtype " + pretFiType(t) + " of " + pretFiType(tp) + " is not found in index");
		switch (lookupTree(type_index, t)) {
			Some(ind): i2s(ind) + "i32";
			None(): {
				switch (t) {
					FiTypeName(nm,__): {
						fiMapTypeName(t, env.prog.names, 
							\struct -> {
								err("(struct?): " + pretFiStructOrUnion(struct));
							},
							\union -> {
								switch (lookupTree(type_index, FiTypeName("Struct", []))) {
									Some(ind): i2s(ind) + "i32";
									None(): {
										err("(union?): " + pretFiStructOrUnion(union));
									}
								}
							},
							\tn -> {
								err("(typename?): " + pretFiType(t));
							}
						);
					}
					default: err("(unknown?): " + pretFiType(t));
				}
			}
		}
	}
	struct_ind = \nm -> {
		switch (lookupTree(struct_index, nm)) {
			Some(ind): i2s(ind) + "i32";
			None(): fail0("struct " + nm + " is not found in index");
		}
	}
	p = switch (tp) {
		FiTypeVoid():    Triple("ctVoid", [], "void");
		FiTypeBool():    Triple("ctBool", [], "bool");
		FiTypeInt():     Triple("ctInt", [], "int");
		FiTypeDouble():  Triple("ctDouble", [], "double");
		FiTypeString():  Triple("ctString", [], "string");
		FiTypeNative():  Triple("ctNative", [], "native");
		FiTypeFlow():    Triple("ctFlow", [], "flow");
		FiTypeRef(rt):   Triple("ctRef", [type_ind(rt)], "");
		FiTypeArray(at): Triple("ctArray", [type_ind(at)], "");
		FiTypeFunction(as, rt): {
			Triple("ctFunc", concat([type_ind(rt)], map(as, \arg -> type_ind(arg.type))),"");
		}
		FiTypeName(nm, tps): {
			fiMapTypeName(tp, env.prog.names, 
				\struct -> Triple("ctStruct", concat([struct_ind(nm)], map(struct.args, \arg -> type_ind(arg.type))), nm),
				\union -> Triple("ctUnion", map(union.typenames, type_ind), nm),
				\__ -> fail0("unknown struct or union: " + nm)
				//Triple("ctStruct", [], "Struct"),
			);
		}
		FiTypeParameter(__): fail0("FiTypeParameter must not occur in complete specialization in nim: " + pretFiType(tp));
	}
	"(" + p.first + ", @[" + strGlue(p.second, ", ") + "], \"" + p.third + "\")";
}

fi2nimOrderTypes(types0: [FiType]) -> [FiType] {
	types = filter(types0, \tp -> !exists(fi2nim_basic_types, \x -> fiEqualTypes(x, tp)));
	fi2nimDoOrderTypes(types, fi2nim_basic_types);
}

fi2nimDoOrderTypes(types: [FiType], acc: [FiType]) -> [FiType] {
	if (length(types) == 0) acc else {
		p = unzip(types, \tp -> {
			subterms = set2array(fiTypeSubterms(tp, true));
			forall(subterms, \st -> exists(acc, \x -> fiEqualTypes(x, st)));
		});
		if (length(p.first) == 0) {
			println("types:\n" +
				strIndent(concatStrings(map(types, \t -> "\t" + prettyFiType(dummyPretty, t, makeSet()) + "\n"))) + "\n"
				"acc:\n" + 
				strIndent(concatStrings(map(acc, \t -> "\t" + prettyFiType(dummyPretty, t, makeSet()) + "\n"))) + "\n" 
			);
			fail("cyclic dependency in a set of types - is impossible");
		}
		fi2nimDoOrderTypes(p.second, concat(acc, p.first));
	}
}

fi2nimAddTypenameSubterms(type: FiType, acc: Set<FiType>, names: FiGlobalNames) -> Set<FiType> {
	if (containsSet(acc, type)) acc else {
		acc1 = insertSet(acc, type);
		switch (type) {
			FiTypeName(name, typars): {
				if (name == "Struct") {
					// Special case: universal struct, which represents all structs (thus universal union)
					acc1;
				} else {
					fiMapTypeName(type, names,
						\struct -> fold(struct.args, acc1, \ac, arg -> {
							arg_type = fiPurifyType(arg.type);
							foldSet(fiTypeSubterms(arg_type, false), ac, \a, st ->
								fi2nimAddTypenameSubterms(st, a, names)
							)
						}), 
						\union -> {
							//println("observing union: " + pretFiStructOrUnion(union) + ", type: " + pretFiType(type));
							//println("acc before:\n" + strIndent(superglue(set2array(acc), pretFiType, "\n")));
							ret = fold(union.typenames, acc1, \ac, tn ->
								fi2nimAddTypenameSubterms(tn, ac, names)
							);
							//println("acc after:\n" + strIndent(superglue(set2array(ret), pretFiType, "\n")));
							ret;
						},
						\tn -> fail0("typename " + tn.name + " is not found")
					);
				}
			}
			default: acc1;
		}
	}
}

fi2nimInitTypeIndexes(env : FiNimEnv, debug_nim_type_ids: bool) -> FiNimEnv {
	spec_structs = map(env.specializedStructs, \s -> FiTypeName(s.name, s.typars));
	all_subterms = set2array(fold(spec_structs, makeSet(), \acc, s -> mergeSets(acc, fiTypeSubterms(s, false))));
	if (debug_nim_type_ids) {
		println("all_subterms:\n" +
			concatStrings(map(all_subterms, \t -> "\t" + pretFiType(t) + "\n"))
		);
	}
	//all_types = concat([FiTypeName("Struct", [])], all_subterms);
	all_types = all_subterms;
	if (debug_nim_type_ids) {
		println("all_types:\n" +
			concatStrings(map(all_types, \t -> "\t" + pretFiType(t) + "\n"))
		);
	}
	complete_types = fold(all_types, makeSet(), \acc, tp ->
		fi2nimAddTypenameSubterms(tp, acc, env.prog.names)
	);
	if (debug_nim_type_ids) {
		println("complete_types:\n" +
			concatStrings(map(set2array(complete_types), \t -> "\t" + pretFiType(t) + "\n"))
		);
	}
	ordered_types = fi2nimOrderTypes(set2array(complete_types));
	if (debug_nim_type_ids) {
		println("ordered_types:\n" +
			concatStrings(mapi(ordered_types, \i, t -> "\t" + i2s(i) + ": " + pretFiType(t) + "\n"))
		);
	}
	type_index = foldi(ordered_types, makeTree(), \i, acc, tp -> setTree(acc, tp, i));
	struct_index = foldi(env.structs, makeTree(), \i, acc, s -> setTree(acc, s.name, i));
	FiNimEnv(env with
		ordered_types = ordered_types,
		type_index = type_index,
		struct_index = struct_index
	);
}

fi2nimRegisterTypes(env : FiNimEnv) -> string {
	supergluei(env.ordered_types, 
		\i, tp -> "rt_register_type(" + fi2nimType2RtType(env, tp, env.type_index, env.struct_index) + ") # " + i2s(i) + ": " + pretFiType(tp), 
		"\n"
	) + "\n\n";
}
