import tools/flowc/backends/common;
import tools/flowc/backends/nim/fi2nim_assemble;
import tools/flowc/backends/nim/fi2nim_defines;
import tools/flowc/backends/nim/fi2nim_utils;
import tools/flowc/backends/nim/fi2nim_compile;
import tools/flowc/manipulation/flatten_unions;
import tools/flowc/manipulation/specialization;

export {
	fi2nim(program : FiProgram, cfg : FiNimConfig, callback : (int) -> void) -> void;
}

fi2nim(program0 : FiProgram, cfg : FiNimConfig, callback : (int) -> void) -> void {
	fcVerbose(cfg, 0, "Making NIM '" + cfg.outputfile + "'...");

	// Unions shouldn't contain other unions - only structs
	// fiCompleteStructTypars
	// fiRemoveImplicitStructTypars
	// specializeProgram(cfg: FcCommonConfig, program : FiProgram, onlyBasicSpecializations : bool, jsmangling : bool) -> FiProgram;\

	program = program0 |> fiCompleteStructTypars |> fiFlattenUnions;
	//program = program0 |> fiFlattenUnions |> \p -> specializeProgram(cfg, p, false, true);

	// collect_polymorphic_entities(program : FiProgram, onlyBasicSpecializations : bool) -> Tree<string, FiType>;
	polymorphics = collect_polymorphic_entities(program, false);
	println("polymorphics:\n" + strIndent(
		superglue(tree2pairs(polymorphics), \p -> p.first + " => " + prettyFiType(dummyPretty, p.second, makeSet()), "\n")
	));
	// find_specializations(program : FiProgram, polymorphics : Tree<string, FiType>, seed : Tree<string, Set<FiType>>, jsmangling : bool) -> Tree<string, Set<FiType>>;
	specializations = find_specializations(program, polymorphics, makeTree(), false);
	println("specializations:\n" + strIndent(
		superglue(
			tree2pairs(specializations), 
			\p -> p.first + " =>\n" + strIndent(superglue(set2array(p.second), \t -> prettyFiType(dummyPretty, t, makeSet()), "\n")), 
			"\n"
		))
	);
	structs0 = fold(program.traversal, [], \acc, mname ->
		eitherFn(lookupTree(program.modules, mname), \module -> concat(acc, module.structs), \ -> acc)
	);
	structs = list2array(fold(structs0, makeList(), \acc, struct ->
		switch (lookupTree(specializations, struct.name)) {
			Some(specs): foldSet(specs, acc, \ac, spec -> 
				switch (spec) {
					FiTypeName(nm, typars): Cons(FiTypeStruct(struct with typars = typars), ac);
					default: fail0("must be a typename");
				}
			);
			None(): {
				if (length(struct.typars) == 0) {
					Cons(struct, acc);
				} else {
					// Must occur in specialization, otherwise is not used
					acc;
				}
			}
		}
	));
	println("struct_ids:\n" +
		strIndent(superglue(structs, \s -> prettyFiStructOrUnion(dummyPretty, s, makeSet()), "\n"))
	);

	casts_from_to = fiFoldProgramToplevel(program, makeTree(), \decl,__,__,acc ->
		switch (decl) {
			FiFunctionDec(__,lambda,__,__,__): fiAllCasts(lambda, acc);
			FiGlobalVar(__,value,__,__,__):    fiAllCasts(value, acc);
			FiNativeDec(__,__,__,__,fb,__,__): fiAllCasts(fb, acc);
			default: acc;
		}
	);
	casts_to_from = foldTree(casts_from_to, makeTree(), \from, to_set, acc ->
		foldSet(to_set, acc, \ac, to ->
			setTree(ac, to, insertSet(lookupTreeDef(ac, to, makeSet()), from))
		)
	);
	types_map_to_s = \tree -> {
		concatStrings(map(tree2pairs(tree), \p -> 
			"\t" + prettyFiType(dummyPretty, p.first, makeSet()) + " => [" + 
				superglue(set2array(p.second), \t -> prettyFiType(dummyPretty, t, makeSet()), ", ")
			+ "]\n"
		))
	}

	/*println("casts_from_to:\n" +
		types_map_to_s(casts_from_to) + "\n" +
		"casts_to_from:\n" +
		types_map_to_s(casts_to_from) + "\n"
	);*/

	fcVerbose(cfg, 1, "Collecting code for all imported files...");

	// Store all declarations of a program into one large array.
	// Declarations stored in init order (order of their appearance in files).
	decls : [Pair<string, [FiDeclaration]>] = fiCollectDeclarationsCommon(program);

	env = FiNimEnv(cfg, program, 
		fiStruct2unions(program),
		structs0,
		casts_to_from,
		set2array(lookupTreeDef(casts_to_from, FiTypeFlow(), makeSet())),
		set2array(lookupTreeDef(casts_to_from, FiTypeString(), makeSet())),
		collectFiEffects(program), "", []
	);
	moduleCount = i2s(length(decls));

	fcVerbose(cfg, 0, "Generating Nim code for declarations...");
	modulesCode = foldi(decls, Cons("", makeList()), \i, acc, p: Pair<string, [FiDeclaration]> -> {

		fcVerbose(cfg, 1, "[" + i2s(i+1) + "/" + moduleCount + "] Generating Nim code for module " + p.first);

		mdl = lookupTree(program.modules, p.first);
		switch (mdl) {
			None(): {
				fail("Could not retrieve module " + p.first);
				Cons("", makeList());
			}
			Some(module): {
				r = fold(p.second, acc, \l, v -> {
					cfg.fileinfo ::= module.fileinfo;
					tl = fiNimCompileToplevel(env, v, fiNimIndent);
					Cons(if (tl == "") "" else "\n", Cons(tl, l));
				});
				Cons("\n", r);
			}
		}
	});

	types = "type\n" + concatStrings([
		fiNimIndent+ "# Struct Ids\n", 
		fi2nimStructIds(env) + "\n",
		fiNimIndent + "# Struct definitions\n",
		concatStrings(map(env.structs, \s -> fi2nimStructDef(env, s))) + "\n",
	]);

	fi2nimAssemble(cfg, [
		fi2nimRuntime(cfg),
		"\n# Types\n", 
		types,
		"# Struct functions\n",
		concatStrings(map(env.structs, \s -> fi2nimStructFuncs(env, s))),
		//"# Union functions\n",
		//fi2nimUnionFuncs(env) + "\n",
		fi2nimNatives(cfg), 
		list2string(^nimProcDefinition), 
		"\n", 
		list2string(modulesCode), 
		"main()\n"
	]);

	callback(0);
}
