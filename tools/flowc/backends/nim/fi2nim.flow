import tools/flowc/backends/nim/fi2nim_assemble;
import tools/flowc/backends/nim/fi2nim_types;
import tools/flowc/backends/nim/fi2nim_compile;
import tools/flowc/manipulation/flatten_unions;
import tools/flowc/manipulation/specialization;
import sys/process;

export {
	fi2nim(program : FiProgram, cfg : FiNimConfig, callback : (int) -> void) -> void;
}

fi2nim(program0 : FiProgram, cfg0 : FiNimConfig, callback : (int) -> void) -> void {
	cfg = if (cfg0.outputfile != "1") cfg0 else {
		FiNimConfig(cfg0 with outputfile = changeFileExt(cfg0.flowfile, ".nim"));
	}
	fcVerbose(cfg, 0, "Making NIM '" + cfg.outputfile + "'...");
	env = fi2nimInitEnv(program0, cfg);
	runtime = fi2nimRuntime(cfg);
	fi2nimAssemble(cfg, [
		"#[ COMMON RUNTIME ]#\n",
		runtime,
		"\n#[ TYPES ]#\n",
		fi2nimCompileTypes(env),
		"\n#[ SOURCE CODE ]#\n",
		fi2nimCompileSourceCode(env, runtime),
		"main()\n"
	]);
	fi2nimBuild(env.prog, cfg, callback);
}

fi2nimCompileTypes(env: FiNimEnv) -> string {
	structs_enum = fi2nimTypeEnums(env);

	type_decls = concatStrings(map(env.prog.traversal, \mod_name -> {
		module = lookupTreeDef(env.prog.modules, mod_name, dummyFiModule);
		concatStrings(concat(
			map(module.structs, \s -> fi2nimStructDecl(env, s)),
			map(module.unions, \u -> fi2nimUnionDecl(env, u))
		));
	}));
	type_defs = "type\n" + concatStrings([
		if (structs_enum == "") "" else fiNimIndent+ "# Struct Ids\n" + structs_enum + "\n",
		if (type_decls == "") "" else fiNimIndent + "# Type definitions\n" + type_decls + "\n"
	]);
	type_register = fi2nimRegisterTypes(env);

	register_structs = concatStrings(map(env.structs, \s -> fi2nimStructRegister(env, s)));

	/*compiled_funcs = concat3(
		mapConcat(env.structs, \s -> fi2nimStructFuncs(env, s)),
		mapConcat(env.unions, \u -> fi2nimUnionFuncs(env, u)),
		mapConcat(env.funcTypes, \f -> fi2nimFuncTypeFuncs(env, f)),
	);*/

	compiled_funcs = concatA([
		filtermap(env.ordered_types, \t -> fi2nimTypeToTypeId(env, t)),
		filtermap(env.ordered_types, \t -> fi2nimTypeToFlow(env, t)),
		filtermap(env.ordered_types, \t -> fi2nimTypeFromFlow(env, t)),
		filtermap(env.ordered_types, \t -> fi2nimTypeToString(env, t)),
		//map(env.structs, \s -> fi2nimStructMake(env, s))
	]);

	type_defs + "\n\n" + type_register + "\n\n" + register_structs + "\n\n" +
	concatStrings(map(compiled_funcs, \fn -> fn.decl + "\n")) + "\n\n" +
	concatStrings(map(compiled_funcs, \fn -> fn.def));
}

fi2nimCompileSourceCode(env: FiNimEnv, runtime: string) -> string {
	fcVerbose(env.cfg, 1, "Collecting code for all imported files...");
	// Store all declarations of a program into one large array.
	// Declarations stored in init order (order of their appearance in files).
	decls : [Pair<string, [FiDeclaration]>] = fiCollectDeclarationsCommon(env.prog);
	moduleCount = i2s(length(decls));

	fcVerbose(env.cfg, 0, "Generating Nim code for declarations...");
	modulesCode : List<NimCompiled> = foldi(decls, EmptyList(), \i, acc, p: Pair<string, [FiDeclaration]> -> {
		fcVerbose(env.cfg, 1, "[" + i2s(i + 1) + "/" + moduleCount + "] Generating Nim code for module " + p.first);
		module = lookupTreeDef(env.prog.modules, p.first, dummyFiModule);
		fold(p.second, acc, \ac, decl -> {
			compiled = fiNimCompileToplevel(env, decl);
			if (compiled.decl == "" && compiled.def == "") ac else Cons(compiled, ac);
		});
	});
	native_imports = fi2nimNativeImports(env, runtime);
	concatStrings([
		if (length(native_imports) == 0) "" else "# Native function imports\n" + strGlue(native_imports, "\n") + "\n\n",
		"# Forward declarations\n",
		list2string(mapList(modulesCode, \c -> fi2nimAssureNewLineAtEnd(c.decl))),
		"\n",
		"# Source code of functions / global variables\n",
		list2string(mapList(modulesCode, \c -> fi2nimAssureEmptyLineAtEnd(c.def))),
	]);
}

fi2nimInitEnv(program0 : FiProgram, cfg : FiNimConfig) -> FiNimEnv {
	// Unions shouldn't contain other unions - only structs
	program = program0 |> fiRemoveImplicitStructTypars |> fiFlattenUnions;

	is_explicit_polymorphic = \nm -> switch (lookupTree(program.names.structs, nm)) {
		Some(struct): length(struct.typars) > 0;
		None(): switch (lookupTree(program.names.unions, nm)) {
			Some(union): length(union.typeparameters) > 0;
			None(): true;
		}
	}

	polymorphics = filterTree(collect_polymorphic_entities(program, false), \nm, __ -> 
		// leave only true (=explicit) polymorhpic structs/unions and remove implicitly polymorphic
		is_explicit_polymorphic(nm)
	);

	debug_polymorphics = getUrlParameter("nim-debug") == "1";
	if (debug_polymorphics) {
		println("polymorphics:\n" + strIndent(
			superglue(tree2pairs(polymorphics), \p -> p.first + " => " + prettyFiType(dummyPretty, p.second, makeSet()), "\n")
		));
	}
	specializations = filterTree(
		mapTree(
			find_specializations(program, polymorphics, makeTree(), false), 
			\specs -> mapSet(specs, \spec -> fiPurifyType(spec))
		),
		// leave only true (=explicit) polymorhpic structs/unions and remove implicitly polymorphic
		\nm,__ -> is_explicit_polymorphic(nm)
	);
	if (debug_polymorphics) {
		println("specializations:\n" + strIndent(
			superglue(
				tree2pairs(specializations),
				\p -> p.first + " =>\n" + strIndent(superglue(set2array(p.second), \t -> prettyFiType(dummyPretty, t, makeSet()), "\n")),
				"\n"
			))
		);
	}
	structs = fold(program.traversal, [], \acc, mname ->
		eitherFn(lookupTree(program.modules, mname), \module -> concat(acc, module.structs), \ -> acc)
	);
	unions = fold(program.traversal, [], \acc, mname ->
		eitherFn(lookupTree(program.modules, mname), \module -> concat(acc, module.unions), \ -> acc)
	);
	specialized_structs = list2array(fold(structs, makeList(), \acc, struct ->
		switch (lookupTree(specializations, struct.name)) {
			Some(specs): foldSet(specs, acc, \ac, spec -> 
				switch (spec) {
					FiTypeName(nm, typars): Cons(fiSpecializeStruct(spec, struct), ac);
					default: fail0("must be a typename");
				}
			);
			None(): {
				if (length(struct.typars) == 0) {
					Cons(struct, acc);
				} else {
					println("Struct " + struct.name + " must occur in specialization, otherwise is not used");
					acc;
				}
			}
		}
	));
	specialized_unions = list2array(fold(unions, makeList(), \acc, union ->
		switch (lookupTree(specializations, union.name)) {
			Some(specs): foldSet(specs, acc, \ac, spec ->
				switch (spec) {
					FiTypeName(nm, typars): Cons(fiSpecializeUnion(spec, union), ac);
					default: fail0("must be a typename");
				}
			);
			None(): {
				if (length(union.typeparameters) == 0) {
					Cons(union, acc);
				} else {
					println("Union " + union.name + " must occur in specialization, otherwise is not used");
					acc;
				}
			}
		}
	));
	if (debug_polymorphics) {
		println("structs:\n" +
			strIndent(superglue(structs, \s -> pretFiStructOrUnion(s), "\n"))
		);
		println("unions:\n" +
			strIndent(superglue(unions, \u -> pretFiStructOrUnion(u), "\n"))
		);
		println("specialized_structs:\n" +
			strIndent(superglue(specialized_structs, \s -> pretFiStructOrUnion(s), "\n"))
		);
		println("specialized_unions:\n" +
			strIndent(superglue(specialized_unions, \u -> pretFiStructOrUnion(u), "\n"))
		);
	}

	casts_from_to = fiFoldProgramToplevel(program, makeTree(), \decl,__,__,acc ->
		switch (decl) {
			FiFunctionDec(__,lambda,__,__,__): fiAllCasts(lambda, acc);
			FiGlobalVar(__,value,__,__,__):    fiAllCasts(value, acc);
			FiNativeDec(__,__,__,__,fb,__,__): fiAllCasts(fb, acc);
			default: acc;
		}
	);
	casts_to_from = foldTree(casts_from_to, makeTree(), \from, to_set, acc ->
		foldSet(to_set, acc, \ac, to ->
			setTree(ac, to, insertSet(lookupTreeDef(ac, to, makeSet()), from))
		)
	);
	types_map_to_s = \tree -> {
		concatStrings(map(tree2pairs(tree), \p -> 
			"\t" + prettyFiType(dummyPretty, p.first, makeSet()) + " => [" + 
				superglue(set2array(p.second), \t -> prettyFiType(dummyPretty, t, makeSet()), ", ")
			+ "]\n"
		))
	}

	/*println("casts_from_to:\n" +
		types_map_to_s(casts_from_to) + "\n" +
		"casts_to_from:\n" +
		types_map_to_s(casts_to_from) + "\n"
	);*/

	funcTypes = set2array(fold(structs, makeSet(), \acc, struct ->
		fold(struct.args, acc, \ac, arg -> 
			switch (arg.type) {
				FiTypeFunction(__,__): insertSet(ac, cast(fiPurifyType(arg.type): FiType -> FiTypeFunction));
				default: ac;
			}
		)
	));

	env0 = FiNimEnv(cfg, program, "", ref makeSet(),
		structs,
		unions,
		funcTypes,
		specialized_structs,
		specialized_unions,
		specializations,
		casts_to_from,
		set2array(lookupTreeDef(casts_to_from, FiTypeFlow(), makeSet())),
		set2array(lookupTreeDef(casts_to_from, FiTypeString(), makeSet())),
		collectFiEffects(program), "", [],
		fi2nimNatives(cfg),
		[], makeTree(), makeTree()
	);
	fi2nimInitTypeIndexes(env0, getUrlParameter("nim-debug") == "1");
}

fi2nimNativeImports(env: FiNimEnv, runtime: string) -> [string] {
	trim_std = \imp -> if (startsWith(imp, "std/")) strRight(imp, 4) else imp;
	runtime_imports = filter(strSplit(runtime, "\n"), fi2nimIsImportLine);
	runtime_import_modules = filtermap(runtime_imports, \str -> 
		if (!startsWith(str, "import")) None() else {
			components = filter(strSplit(str, " "), isNotSpace);
			Some(trim_std(components[1]));
		}
	)
	runtime_imports_set = buildSet(runtime_imports);
	runtime_import_modules_set = buildSet(runtime_import_modules);
	filter(set2array(^(env.native_imports)), \str ->
		if (containsSet(runtime_imports_set, str)) false else {
			if (startsWith(str, "from")) {
				components = filter(strSplit(str, " "), isNotSpace);
				// Check if a module/component is already imported
				!containsSet(runtime_import_modules_set, trim_std(components[1]));
			} else {
				// Leave an import of unrecognized kind
				true;
			}
		}
	);
}

fi2nimBuild(program : FiProgram, cfg: FiNimConfig, callback : (int) -> void) -> void {
	if (isConfigParameterFalse(program.config.config, "exe")) {
		// No need to build binary
		callback(0);
	} else {
		if (cfg.verbose > 1) {
			fcPrintln("Going to build nim target: '" + cfg.outputfile + "'", cfg.threadId);
		}
		out = execSystemProcessOutput("nim", ["--overflowChecks:off", "--threads:on", "c", cfg.outputfile], ".");
		if (out.exitCode != 0) {
			fcPrintln("Building of " + cfg.outputfile + " failed:\n" + out.stdall, cfg.threadId);
			callback(5);
		} else {
			if (cfg.verbose > 0) {
				fcPrintln("Building of '" + cfg.outputfile + "' finished.", cfg.threadId);
				if (cfg.verbose > 1) {
					fcPrintln("Nim compiler output:", cfg.threadId);
					fcPrintln(out.stdall, cfg.threadId);
				}
			}
			fcPrintln("Executable '" + changeFileExt(cfg.outputfile, "") + "' is generated.", cfg.threadId);
			callback(0);
		}
	}
}
