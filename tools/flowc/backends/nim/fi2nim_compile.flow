import string_utils;
import tools/flowc/backends/common;
import tools/flowc/backends/nim/fi2nim_defines;
import tools/flowc/backends/nim/fi2nim_utils;

export {
	fiNimCompileToplevel(
		cfg : FiNimConfig,
		// ctx : FiNimToplevelContext,
		env : FiNimEnv,
		decl: FiDeclaration,
		indent : string) -> string;

	fiNimCompileToExpr(
		cfg  : FiNimConfig,
		// ctx  : FiNimToplevelContext,
		env : FiNimEnv,
		expr : FiNimExp,
		indent : string) -> string;

	fiNimCompileToReturn(
		cfg  : FiNimConfig,
		// ctx  : FiNimToplevelContext,
		env : FiNimEnv,
		expr : FiNimExp,
		indent : string) -> string;

	fiNimCompilePlus(
		cfg  : FiNimConfig,
		env : FiNimEnv,
		arg1 : Pair<string, FiType>,
		op   : string,
		arg2 : Pair<string, FiType>) -> string;

	fiNimCompileDiv(
		cfg  : FiNimConfig,
		env : FiNimEnv,
		arg1 : Pair<string, FiType>,
		op   : string,
		arg2 : Pair<string, FiType>) -> string;
}

// Temporary, will be removed.
doTN : ref bool = ref false;

fiNimCompileToplevel(cfg : FiNimConfig, env : FiNimEnv, decl : FiDeclaration, indent : string) {
	switch (decl : FiDeclaration) {
		FiNativeDec(name, io, type, nativeName, flowfallback, __, __) : {
			switch (flowfallback) {
				FiLambda(__, __, fn_type, __): {
					if (containsSet(nimNativeFunctions, name)) {
						// native is implemented in runtime
						""
					} else {
						// use a fallback
						fiNimCompileFunction(cfg, env, name, fn_type, flowfallback);
					}
				}
				FiVoid(__): {
					if (!containsSet(nimNativeFunctions, name)) {
						fcPrintln("Error: " + name + " native is not implemented in nim backend", cfg.threadId);
					}
					"# native: " + nativeName + " " + name + "\n";
				}
				default: {
					fcPrintln("fallbackLambda in FiNativeDec must be FiLambda or FiVoid, but is: " + prettyFiExp(dummyPretty, flowfallback), cfg.threadId);
					"# native: " + nativeName + " " + name + "\n"
				}
			}
		}
		FiFunctionDec(name, lambda, type, __, __): {
			if (containsSet(nimNativeFunctions, name)) {
				//is implemented as native in runtime
				""
			} else {
				fiNimCompileFunction(cfg, env, name, type, lambda);
			}
		}
		FiGlobalVar(name, value, type, __, __): {
			fiNimCompileGlobalVar(cfg, env, name, type, value, indent);
		}
	};
}

fiNimCompileFunction(cfg : FiNimConfig, env : FiNimEnv, nm: string, type: FiTypeFunction, lambda: FiLambda) -> string {
	if (containsSet(nimForbiddenFunctions, nm)) {
		nimProcDefinition := Cons("# " + nm + " forbidden with nimForbiddenFunctions\n", ^nimProcDefinition);
		""
	} else {
		nim_type = \t -> fiType2NimType(cfg, env, t);
		ret_type = switch(type.returnType) {
			FiTypeFunction(__, __): "(" + nim_type(type.returnType) + ")";
			default: nim_type(type.returnType);
		}

		stype = if (ret_type == "") "" else ": " + ret_type;

		fparams = strGlue(mapi(lambda.args, \idx, arg -> {
			tmp = {
				varPrefix = switch(arg.type) {
					FiTypeRef(__) : "var ";
					default : ""
				};
				if (^doTN) fcPrintln("HIA: at = " + toString(arg.type), cfg.threadId);
				varPrefix + fiType2NimType(cfg, env, arg.type);
			}
			fiNimRenameKeyword(cfg, arg.name) + ": " + tmp
		}
		), ", ");

		tp = fiNimTypeParamsList(env, FiFunctionDec(nm, lambda, type, -1, -1));

		hd = "proc " + fiNimRenameKeyword(cfg, nm) + tp + "(" + fparams + ")" + stype;

		if (nm != "main") {
			nimProcDefinition := Cons(hd + "\n", ^nimProcDefinition);
		}

		meq = (if (nm == "main") " {.discardable.}" else "") + " = \n";
		header = hd + meq;

		lambdaBody : FiExp = lambda.body;
		bodyOrSeq = switch (lambdaBody) {
			FiSeq(__, __, __) : lambda.body;
			default : FiSeq([lambda.body], FiTypeVoid(), -1);
		}
		// if (name == "extractStruct") doTN := true;
		if (^doTN) {
			// fcPrintln("HIA: decl = " + toString(decl));
		}
		bodyTxt = fiNimCompileToReturn(cfg, env, bodyOrSeq, fiNimIndent);
		doTN := false;
		header + bodyTxt + "\n"
	}
}

fiNimCompileGlobalVar(cfg : FiNimConfig, env : FiNimEnv, nm: string, type: FiType, value: FiExp, indent : string) {
	// TODO Dead code elimination broke this!
	// Made stub, but require to fixup it correctly!
	if (nm != "") {
			// fcPrintln("HIA: " + name + " typ = " + toString(typ));
			varType = switch(type) {
				FiTypeFunction(__, __): "";
				FiTypeRef(tr): switch(tr) {
					FiTypeFunction(__,__): "";
					default: fiType2NimType(cfg, env, type);
				}
				default: fiType2NimType(cfg, env, type);
			}
			"var " + nm +
			(if (varType != "") ": " + varType else "") +
			//(if (nm == "securityModes") "seq[OWASP]" else varType) else "") +
			" = " + fiNimCompileToExpr(cfg, env, value, indent)
	}
	else {
		fcPrintln("Error: name of a global variable is empty", cfg.threadId);
		"# FiGlobalVar = " + toString(value);
	}
}

fiNimCompileToExpr(
	cfg  : FiNimConfig,
	env : FiNimEnv,
	expr : FiNimExp,
	indent : string) -> string {
	subindent = indent + fiNimIndent;
	switch (expr : FiNimExp) {
		FiDiscard(e) : {
			switch(e) {
				None() : "discard";
				Some(ex) : "discard\n" + subindent + fiNimCompileToExpr(cfg, env, ex, subindent);
			}
		}
		FiVoid(__): "discard";
		FiBool(b, __): if (b) "true" else "false";

		FiInt(v, __): {
			i2s(v)

			// Simple heuristic:
			// Hex numbers 0..9 is the same as decimal
			/*if (v >= 0 && v <= 9) {
				i2s(v)
			} else {
				// For larger numbers detect hex numbers first

				// Check file content availability
				fcCheckAvailableContent(cfg.fileinfo);
				intval = substring(cfg.fileinfo.content, i.start, i.end-i.start);
				// Check if value is hexadecimal
				if (startsWith(intval, "0x")) {
					if (intval == "0x80000000")
						"cast[int](0x80000000)"
					else
						intval
				} else
					i2s(v);
				// In Flow negative numbers are not part of a grammar,
				// this check is not required at all.
				// if (v < 0) "("+i2s(v)+")" else i2s(v);
			}*/
		}


		FiDouble(d, __): {
			s = d2s(d);
			if (strIndexOf(s, ".") < 0 && strIndexOf(s, "e") < 0) s+".0" else s;
		}

		FiString(s, __): "\"" + unescapeStr(s) + "\"";
		FiVar(x, __, __): {
			fiNimRenameKeyword(cfg, x);
		}

		FiLet(x, tp, e1, e2, __, __): {
			"var " + fiNimRenameKeyword(cfg, x) + ": " + fiType2NimType(cfg, env, tp) + " =\n" +
			subindent + fiNimCompileToExpr(cfg, env, e1, subindent) + "\n" +
			indent + fiNimCompileToExpr(cfg, env, e2, indent);
		}

		FiLambda(xs, e0, type, __): {
			// fcPrintln("HIA: ltm = " + toString(ltm));
			lt = switch (type) {
				FiTypeFunction(__, retType): fiType2NimType(cfg, env, retType);
				default: "";
			}
			ltype = if (lt != "") ": " + lt else "";

//			ltype = "";
			"proc(" + strGlue(map(xs, \a -> {
				ats = fiType2NimType(cfg, env, a.type);
				atr = switch (a.type) {
					FiTypeFunction(__, __) : "(" + ats + ")";
					default : ats;
				}
				fiNimRenameKeyword(cfg, a.name) + ": " + atr
			}), ", ") + ")" + ltype + " =\n" +
			subindent + fiNimCompileToReturn(cfg, env, e0, subindent);
		}

		FiCall(call, es, __, __): {
			maybe_sinfo = switch (call) {
				FiVar(x, __, __): {
					switch (lookupTree(env.prog.names.structs, x) : Maybe<FiTypeStruct>) {
						Some(sinfo): Some(sinfo);
						None(): None()
					}
				}
				default: None();
			}
			switch (maybe_sinfo) {
				Some(sinfo): {
					"# FiCall:\n" + indent + "struct ()";
				}
				None(): {
					name = switch (call) {
						FiVar(x, __, __) : fiNimRenameKeyword(cfg, x);
						default : {
							if (^doTN) {
								// fcPrintln("HIA: call = " + toString(call));
							}
							fiNimCompileToExpr(cfg, env, call, indent);
							// "#[no name]#"
						}
					}
					args = strGlue(map(es, \e -> {fiNimCompileToExpr(cfg, env, e, subindent)}), ", ");
					name + "(" + args + ")";
				}
			}
		}

		FiSeq(es, __, __): {
			l = length(es);
			// "#[s]#"+
			if (^doTN) {
				// fcPrintln("HIA: expr = " + toString(expr) + "\n");
			}
			if (l >= 0)
				list2string(foldi(es, makeList(), \idx, acc, e -> {
					ndd = switch(e) {
						FiLet(__, __, __, __, __, __) : false;
						FiCallPrim(op, __, __, __) : {
							switch (op) {
								FcAssignPrim() : false;
								FcSetMutablePrim(__) : false;
								default: true;
							}
						}
						FiCall(__, __, tp, __): {
							switch (tp) {
								FiTypeVoid() : false;
								default : true;
							}
						}
						default : true;
					}
					needDiscard = (idx < l-1) && ndd;
					nrr = switch (e) {
						FiLambda(__, __, __, __): true;
						default: false;
					}
					needReturn = (idx == l-1) && nrr;

					ex = if (needDiscard) FiDiscard(Some(e)) else e;
					exprCode = (if (idx == 0) "" else "\n" + indent) + (if (needReturn) "return " else "") + fiNimCompileToExpr(cfg, env, ex, indent);
					Cons(exprCode, acc);
				}))
			else
				"discard";
		}

		FiIf(e1, e2, e3, __, __): {
			"if "+fiNimCompileToExpr(cfg, env, e1, "") +":\n"+
			subindent + fiNimCompileToExpr(cfg, env, e2, subindent) + "\n" +
			indent + "else:\n" +
			subindent + fiNimCompileToExpr(cfg, env, e3, subindent);
		}

		FiSwitch(e0, e0type, cs, __, __): {
			"# FiSwitch: \n";
			"case name(" + fiNimCompileToExpr(cfg, env, e0, subindent) + ".type)" + "\n" +
			fold(cs, "", \acc, c : FiCase -> {
				// fcPrintln("HIA: c = " + toString(c));
				acc + indent + "of \"" + c.struct + "\":\n" +
				subindent + fiNimCompileToExpr(cfg, env, c.body, subindent) + "\n"
			});
			/* 
			isIf = length(cs) == 2;
			aVar = "("+fiJsCompileToExpr(cfg, ctx, e0, indent, false)+")." + (if (rdbl) "_name" else "_id");

			fnbraces = if (es6) "()=>" else "function()";
			header = "(" + fnbraces + "{var $$ss; switch(" + aVar + "){\n"+indent;
			subindent = indent+ctx.indent2;
			ifText = if (isIf) {
				// This variable intended for corner cases, when default branch of switch
				// goes first. We can't get item id for default, because we have no struct
				// data for default case. We invert meaning of condition and use second
				// branch as condition source.
				isFirstBranchDefault = cs[0].struct == "default";
				ifSelector = fiGetItemId(ctx, cs[if (isFirstBranchDefault) 1 else 0], rdbl);
				trueBody = "$$ss=" + fiJsCompileToExpr(cfg, ctx, cs[0].body, indent+ctx.indent4, false);
				falseBody = "$$ss=" + fiJsCompileToExpr(cfg, ctx, cs[1].body, indent+ctx.indent4, false);
				"(" + fnbraces + "{var $$ss; if(" + aVar + (if (isFirstBranchDefault) "!=" else "==") + ifSelector + "){" + trueBody + "}else{" + falseBody;
			} else "";
			innerIf = Cons(ifText, EmptyList());
			inner = if (isIf)
					innerIf
				else
					fold(cs, Cons(header, EmptyList()), \acc, item -> {
						choice = if (item.struct == "default") {
								"default"
							} else {
								if (rdbl) "case '" + item.struct + "'"  else "case "+i2s(fiGetStructId(ctx, item));
							};
						body = fiJsCompileToExpr(cfg, ctx, item.body, indent+ctx.indent4, false);
						// TODO: If the body ends in a "return", we do not need this "break;" here
						Cons(";break;}\n"+indent, Cons(body, Cons(choice+":{$$ss=", acc)));
					});

			list2string(Cons("}return $$ss;}" + (if (es6) ")()" else "())"), inner));
			*/
		}
		FiCallPrim(op, es, tp, __): {
			/*
			subindent = switch (op : FiPrim) {
				FiArrayPrim(): indent + ctx.indent1;
				default: indent;
			};
			*/
			args = map(es, \arg : FiExp -> Pair(fiNimCompileToExpr(cfg, env, arg, indent), fiExpType(arg)));
			opt = switch (op : FcPrim) {
				FcOrPrim():    args[0].first + " or " + args[1].first;
				FcAndPrim():   args[0].first + " and " + args[1].first;
				FcNotPrim():   "not " + args[0].first;
				FcEqPrim():    args[0].first + " == " + args[1].first;
				FcNePrim():    args[0].first + " != " + args[1].first;
				FcLePrim():    args[0].first + " <= " + args[1].first;
				FcGePrim():    args[0].first + " >= " + args[1].first;
				FcLtPrim():    args[0].first + " < "  + args[1].first;
				FcGtPrim():    args[0].first + " > "  + args[1].first;
				FcPlusPrim():  fiNimCompilePlus(cfg, env, args[0], " + ", args[1]);
				FcMinusPrim(): args[0].first + " - "  + args[1].first;
				FcMulPrim():   args[0].first + " * "  + args[1].first;
				FcDivPrim():   fiNimCompileDiv(cfg, env, args[0], " / ", args[1]);
				FcModPrim():   fiNimCompileDiv(cfg, env, args[0], " % ", args[1]);
				FcNegPrim():  "-" + args[0].first;
				FcArrayPrim(): "@[" + strGlue(map(args, \e->e.first), ", ") + "]";
				FcIndexPrim(): args[0].first + "[" + args[1].first + "]";
				FcDerefPrim(): args[0].first;
				FcAssignPrim():	args[0].first + " = " + args[1].first;
				FcRefPrim(): args[0].first;
				// After typechecking we definitely know structure exists, so skip sanity checks.
				FcStructPrim(struct_name): {
					/*struct = {
						type = fiType2NimType(cfg, env, tp);
						argNames = switch (resolveFiTypeName(env.prog.names, tp, cfg.threadId)) {
							//FiTypeStruct(__ ,__, sargs, __): map(sargs, \e -> e.name);
							FiTypeStruct(name, tyPars, as, __): map(as, \a -> a.name);
							default: [];
						}
						Pair(type, argNames);
					}
					if (struct.second == [])
						struct.first
					else
						struct.first + "(" + strGlue(mapi(es, \ix, e -> struct.second[ix] + ": " +  args[ix].first), ", ") + ")";*/

					struct = lookupTreeDef(env.prog.names.structs, struct_name, dummyFiTypeStruct);
					type = cast(tp: FiType -> FiTypeName);
					//typars = type.typeparameters;
					//fiNimParamsForInstantiate(cfg : FiNimConfig, nimEnv : FiNimEnv, params: [FiType]) -> string;
					//structname + fiNimParamsForInstantiate(cfg, env, typars) + 
					tuple = "(" + 
						supergluei(args, \i, p ->  struct.args[i].name + ": " + p.first, ", ") + 
					")";
					switch (lookupTree(env.prog.names.unions, type.name)) {
						Some(union): {
							typars = fiNimParamsForInstantiate(cfg, env, type.typeparameters);
							union.name + "(st" + struct_name + ", " + tuple + ")";
						}
						None(): tuple;
					}
				};
				FcFieldPrim(name): {
					// fcPrintln("HIA: expr = " + toString(expr));
					a : FiExp =es[0];
					vr = switch (a) {
						FiVar(n, __, __) : n;
						default : fiNimCompileToExpr(cfg, env, a, indent);
					}
					// (cast[Some](m)).value
					tpm = fiType2NimTypeName(cfg, env, fiExpType(a));
					"(cast[" + tpm + "](" + vr + "))" +  "." + fiNimRenameKeyword(cfg, name);
				}
				/*
				if (name == "structname") {
					if (cfg.readable)
						args[0].first + "._name"
					else
						"(HaxeRuntime._structnames_.get(" + args[0].first + "._id))";
				} else {
					"(" + args[0].first
					+
					"." + lookupTreeDef(ctx.ovl.fieldRenamings, name, name) +
					")";
				}
				*/
				FcSetMutablePrim(name):
				"#FiSetMutablePrim";
				// "(" + args[0].first + ("."+lookupTreeDef(ctx.ovl.fieldRenamings, name, name) + "=") + args[1].first + ")";
				FcCreateClosurePrim(__, __): ""; // should not happen - Nim does not use lambda lifting
                FcQuote(): "TODO";
                FcUnquote(): "TODO";
			};
			opt;
		}
		FiCast(e, tFrom, tTo, __, __): {
			ex = fiNimCompileToExpr(cfg, env, e, indent);
			tf = fiType2NimType(cfg, env, tFrom);
			tt = fiType2NimType(cfg, env, tTo);
			"cast[" + tt + "](" + ex + ")";
		}
		default: "#!other!\n" + toString(expr);
	}
}

fiNimCompileToReturn(cfg, env, expr, indent) {
	subindent = indent+fiNimIndent;
	switch (expr : FiNimExp) {
		FiCallPrim(op, es, __, __) : fiNimCompileToExpr(cfg, env, expr, indent);
		FiCall(f, es, type, __): {
			if (^doTN) {
				// fcPrintln("HIA: rt = " + toString(rtt));
			}
			switch (type) {
				FiTypeVoid() : fiNimCompileToExpr(cfg, env, expr, indent);
				default: "return " + fiNimCompileToExpr(cfg, env, expr, indent);
			}
		}

		FiLet(x, tp, e1, e2, t, __): {
			dec = "var ";
			dec + fiNimRenameKeyword(cfg, x) + ": " + fiType2NimType(cfg, env, tp) + " = " +
			fiNimCompileToExpr(cfg, env, e1, subindent) + "\n"+
			fiNimCompileToReturn(cfg, env, e2, indent);
		}

		FiSeq(es, __, __): {
			l = length(es);
			//"#R FiSeq:\n" +
			if (l >= 0)
				list2string(foldi(es, makeList(), \idx, acc, e -> {
					ndd = switch(e) {
						FiLet(__, __, __, __, __, __) : false;
						FiCallPrim(op, __, __, __) : {
							switch(op) {
								FcAssignPrim() : false;
								FcSetMutablePrim(__) : false;
								default: true;
							}
						}
						FiCall(__, __, tp, __): {
							switch(tp) {
								FiTypeVoid() : false;
								default : true;
							}
						}
						default : true;
					}
					needDiscard = (idx < l-1) && ndd;
					nrr = switch(e) {
						FiLambda(__,__,__, __): true;
						default: false;
					}
					needReturn = (idx == l-1) && nrr;
					if (^doTN) {
						// fcPrintln("HIA: expr = " + toString(e));
						// fcPrintln("HIA: needReturn = " + toString(needReturn) + "\n");
					}
					ex = if (needDiscard) FiDiscard(Some(e)) else e;
					exprCode = indent + (if (needReturn) "return " else "") + fiNimCompileToExpr(cfg, env, ex, indent) + (if (idx == l-1) "" else "\n");
					Cons(exprCode, acc);
				}))
			else
				"discard";
		}

		FiIf(e1, e2, e3, __, __): {
			"if "+fiNimCompileToExpr(cfg, env, e1, "") +":\n"+
			subindent + fiNimCompileToExpr(cfg, env, e2, subindent) + "\n" +
			indent + "else:\n" +
			subindent + fiNimCompileToExpr(cfg, env, e3, subindent);
			/*
			"if "+fiNimCompileToExpr(cfg, ctx, e1, subindent, false)+": "+
			fiNimCompileToReturn(cfg, ctx, e2, subindent) + "else" +
			fiNimCompileToReturn(cfg, ctx, e3, subindent) + "}";
			*/
		}

		FiSwitch(e0, e0type, cs, __, __): {
			/*
			isIf = length(cs) == 2;

			rdbl = cfg.readable;
			aVar = "(" + fiJsCompileToExpr(cfg, ctx, e0, indent, false) + ")." + (if (rdbl) "_name" else "_id");

			header = "switch(" + aVar + "){\n" + indent;
			ifText = if (isIf) {
					// See comment above in jsCompileToExpr.
					isFirstBranchDefault = cs[0].struct == "default";
					ifSelector  = fiGetItemId(ctx, cs[if (isFirstBranchDefault) 1 else 0], rdbl);
					// TODO: TS processing
					// paramsTrue  = getNextParams(cs[0]);
					trueBody    = fiJsCompileToReturn(cfg, ctx, cs[0].body, indent+ctx.indent4);
					// TODO: TS processing
					// paramsFalse = getNextParams(cs[1]);
					falseBody   = fiJsCompileToReturn(cfg, ctx, cs[1].body, indent+ctx.indent4);
					"if(" + aVar + (if (isFirstBranchDefault) "!=" else "==") + ifSelector + "){" + trueBody + "}else{" + falseBody;
			} else "";

			subindent = indent+ctx.indent2;
			innerIf = Cons(ifText, EmptyList());
			inner = if (isIf)
					innerIf
				else
					fold(cs, Cons(header, EmptyList()), \acc, item -> {
						choice = if (item.struct == "default") {
								"default"
							} else {
								if (rdbl) "case '" + item.struct + "'" else "case "+i2s(fiGetStructId(ctx, item));
							};
						body = fiJsCompileToReturn(cfg, ctx, item.body, subindent);
						Cons("}\n"+subindent+"break;\n"+indent, Cons(body, Cons(choice+":{", acc)));
					});
			list2string(Cons("}", inner));
			*/
			"#R FiSwitch:\n"
		}
		default: fiNimCompileToExpr(cfg, env, expr, subindent) + "";
	}
}

fiNimCompilePlus(cfg : FiNimConfig, env : FiNimEnv, arg1 : Pair<string, FiType>, op : string, arg2 : Pair<string, FiType>) {
	a1 = arg1.first;
	a2 = arg2.first;
	// Type checker ensures math types are equal, so we only need one type.
	isString = switch (arg1.second) {
		FiTypeString() : true;
		default : false;
	};
	if (isString && (op == "+")) a1 + "&" + a2 else a1 + op + a2;
}

fiNimCompileDiv(cfg : FiNimConfig, env : FiNimEnv, arg1 : Pair<string, FiType>, op : string, arg2 : Pair<string, FiType>) {
	a1 = arg1.first;
	a2 = arg2.first;
	// Type checker ensures math types are equal, so we only need one type.
	isInt = switch (arg1.second) {
		FiTypeInt() : true;
		default : false;
	};
	if (isInt && (op == "/")) {
		a1 + " div " + a2
	} else	if (isInt && (op == "%")) {
		a1 + " mod " + a2
	} else {
		a1 + op + a2
	}
}
