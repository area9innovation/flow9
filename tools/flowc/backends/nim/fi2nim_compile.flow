import string_utils;
import tools/flowc/backends/common;
import tools/flowc/backends/nim/fi2nim_defines;
import tools/flowc/backends/nim/fi2nim_utils;
import tools/flowc/manipulation/transform_exps;

export {
	fiNimCompileToplevel(env : FiNimEnv, decl: FiDeclaration, indent : string) -> string;
	fi2nimStructIds(env : FiNimEnv) -> string;
	fi2nimStructDef(env : FiNimEnv, struct : FiTypeStruct) -> string;
	fi2nimUnionDef(env : FiNimEnv, union : FiTypeUnion) -> string;
	fi2nimStructFuncs(env : FiNimEnv, struct : FiTypeStruct) -> string;
}

fiNimCompileToplevel(env : FiNimEnv, decl : FiDeclaration, indent : string) {
	switch (decl) {
		FiNativeDec(name, io, type, nativeName, fallback, __, __) : {
			switch (fallback) {
				FiLambda(__, __, fn_type, __): {
					if (containsSet(nimNativeFunctions, name)) {
						// native is implemented in runtime
						""
					} else {
						// use a fallback
						fiNimCompileFunction(env, FiFunctionDec(name, fallback, fn_type, 0, 0));
					}
				}
				FiVoid(__): {
					if (!containsSet(nimNativeFunctions, name)) {
						fcPrintln("Error: " + name + " native is not implemented in nim backend", env.cfg.threadId);
					}
					"# native: " + nativeName + " " + name + "\n";
				}
				default: {
					fcPrintln("fallbackLambda in FiNativeDec must be FiLambda or FiVoid, but is: " + prettyFiExp(dummyPretty, fallback), env.cfg.threadId);
					"# native: " + nativeName + " " + name + "\n"
				}
			}
		}
		FiFunctionDec(name, lambda,__,__, __): {
			if (containsSet(nimNativeFunctions, name)) {
				//is implemented as native in runtime
				""
			} else {
				fiNimCompileFunction(env, decl);
			}
		}
		FiGlobalVar(name, __,__,__,__): {
			fiNimCompileGlobalVar(env, decl);
		}
	};
}

nim_debug_lambda0 : ref FiExp = ref FiVoid(0);
nim_debug_lambda : ref FiExp = ref FiVoid(0);

fiNimFail(msg: string, expr: FiExp) -> void {
	fail("fail: " + msg + "\n" +
		"expr: " + prettyFiExp(dummyPretty, expr) + "\n" +
		"lambda0: " + prettyFiExp(dummyPretty, ^nim_debug_lambda0) + "\n" +
		"lambda: " + prettyFiExp(dummyPretty, ^nim_debug_lambda0) + "\n" +
		"\n" +
		"RAW expr: " + toStringFormatted(expr) + "\n" +
		"RAW lambda0: " + toStringFormatted(^nim_debug_lambda0) + "\n" +
		"RAW lambda: " + toStringFormatted(^nim_debug_lambda0) + "\n"
	);
}

fiNimShow(msg: string, expr: FiExp) -> void {
	println("show: " + msg + "\n" +
		"expr: " + prettyFiExp(dummyPretty, expr) + "\n" +
		"lambda0: " + prettyFiExp(dummyPretty, ^nim_debug_lambda0) + "\n" +
		"lambda: " + prettyFiExp(dummyPretty, ^nim_debug_lambda) + "\n" +
		"\n" +
		"RAW expr: " + toStringFormatted(expr) + "\n" +
		"RAW lambda0: " + toStringFormatted(^nim_debug_lambda0) + "\n" +
		"RAW lambda: " + toStringFormatted(^nim_debug_lambda) + "\n"
	);
}

fiNimPrepareExp(env: FiNimEnv, e: FiExp, type: FiType) -> FiExp {
	e 
	|> fiFixVarInSameStructType1 
	|> \x -> fiExpMakeCastsExplicit(x, type, env.prog.names)
	|> \y -> fiExplicitCastInSwitch1(y, env.prog.names)
	|> \z -> fiRemoveUnusedVars(z, env.effects)
	|> fiExpNormalizeSeqences
	|> fiPullStatementsUp
}

fiNimCompileFunction(env : FiNimEnv, func: FiFunctionDec) -> string {
	if (containsSet(nimForbiddenFunctions, func.name)) {
		nimProcDefinition := Cons("# " + func.name + " forbidden with nimForbiddenFunctions\n", ^nimProcDefinition);
		""
	} else {
		type = FiTypeFunction(func.type with args = func.lambda.args);
		nim_debug_lambda0 := func.lambda;
		lambda = cast(fiNimPrepareExp(env, func.lambda, type): FiExp -> FiLambda);
		nim_debug_lambda := lambda;

		/*if (func.name == "euler2") {
			fiNimShow(func.name, FiVoid(0));
			//println(toStringFormatted(fiExpMakeCastsExplicit(lambda0, type, env.prog.names)))
		}*/

		fn_typars = fiNimTypeParamsList(env, func);

		decl = "proc " + fiNimRenameKeyword(func.name) + fn_typars + fiFuncType2NimType(env, type);

		if (func.name != "main") {
			nimProcDefinition := Cons(decl + "\n", ^nimProcDefinition);
		}
		has_tail_call = fiNimHasTailCall(lambda.body, func.name);
		fn_code = if (!has_tail_call) {
			fiNimCompile(env, lambda.body, true);
		} else {
			tailcall_args = map(lambda.args, \arg -> 
				FiFunArg(arg with name = fiNimRenameKeyword("tailcall_" + arg.name))
			);
			body_type = fiExpType(lambda.body);
			body = foldri(lambda.args, lambda.body, \i, acc, arg -> 
				fiRenameVar(acc, arg.name, tailcall_args[i].name)
			);
			env1 = FiNimEnv(env with 
				tailcall_fn = func.name,
				tailcall_args = tailcall_args
			);
			body_code = fiNimCompile(env1, body, true);
			strGlue(concat(
				mapi(lambda.args, \i, arg -> 
					"var " + fiNimRenameKeyword(tailcall_args[i].name) + ": " + 
						fiType2NimType(env, arg.type) + " = " + 
						fiNimRenameKeyword(arg.name)
				),
				["while true:\n" + fi2nimSureIndent(body_code)]
			), "\n"
			);
		}
		decl + (if (func.name == "main") " {.discardable.}" else "") + " =" + 
			fi2nimMaybeIndent(fn_code) + "\n";
	}
}

fiNimCompileGlobalVar(env : FiNimEnv, var: FiGlobalVar) {
	value = fiNimPrepareExp(env, var.value, var.type);
	value1 = if (fiNimIsExp(value)) value else {
		FiCall(FiLambda([], value, FiTypeFunction([], var.type), 0), [], var.type, 0);
	} 
	"var " + fiNimRenameKeyword(var.name) + ": " + fiType2NimType(env, var.type) + " =" +
		fi2nimMaybeIndent(fiNimCompile(env, value1, false));
}

fiNimIsExp(e: FiExp) -> bool {
	switch (e) {
		FiConst(): true;
		FiVar(__,__,__): true;
		FiLet(__,__,__,__,__,__): false;
		FiLambda(args, body, type, __): true;
		FiCall(fn, es, __, __): fiNimIsExp(fn) && forall(es, fiNimIsExp);
		FiSeq(es, __, __): {
			if (length(es) == 0) true else
			if (length(es) == 1) fiNimIsExp(es[0]) else false;
		}
		FiIf(e1, e2, e3, __, __):
			fiNimIsExp(e1) && fiNimIsExp(e2) && fiNimIsExp(e3);
		FiSwitch(x, __, cs, __, __): {
			false;
		}
		FiCallPrim(op, es, tp, __): {
			forall(es, fiNimIsExp) && 
			switch (op : FcPrim) {
				FcAssignPrim():	false;
				FcSetMutablePrim(name): false;
				default: true;
			};
		}
		FiCast(ex,__,__,__,__): fiNimIsExp(ex);
		default: false;
	}
}

fiNimHasTailCall(expr: FiExp, fn_name: string) -> bool {
	switch (expr) {
		FiLet(__,__,__, e2,__,__): {
			fiNimHasTailCall(e2, fn_name);
		}
		FiCall(fn,__, __, __): {
			switch (fn) {
				FiVar(x, __, __): x == fn_name;
				default: false;
			}
		}
		FiSeq(es, __, __): {
			if (length(es) == 0) false else fiNimHasTailCall(es[length(es) - 1], fn_name);
		}
		FiIf(__, e2, e3, __, __): {
			fiNimHasTailCall(e2, fn_name) || fiNimHasTailCall(e3, fn_name);
		}
		FiSwitch(__, __, cs, __, __): {
			exists(cs, \c -> fiNimHasTailCall(c.body, fn_name));
		}
		default: false;
	}
}

fiNimCompile(env : FiNimEnv, expr : FiExp, returns: bool) -> string {
	wrap_ret = \s -> if (returns && fiExpType(expr) != FiTypeVoid()) "return " + s else s;
	add_newlines = \ls -> mapi(ls, \i, line -> if (endsWith(line, "\n") || i + 1 == length(ls)) line else line + "\n");
	switch (expr) {
		FiVoid(__):  if (returns) "return" else "discard";
		FiBool(b, __): wrap_ret(if (b) "true" else "false");
		FiInt(v, __):  wrap_ret(i2s(v));
		FiDouble(d, __): {
			s = d2s(d);
			wrap_ret(if (strIndexOf(s, ".") < 0 && strIndexOf(s, "e") < 0) s + ".0" else s);
		}
		FiString(s,__): wrap_ret("\"" + escapeStr(s) + "\"");
		FiVar(x,__,__): {
			wrap_ret(fiNimRenameKeyword(x));
		}
		FiLet(x, tp, e1, e2, __, __): {
			"var " + fiNimRenameKeyword(x) + ": " + fiType2NimType(env, tp) + " =" + 
			fi2nimMaybeIndent(fiNimCompile(env, e1, false)) + "\n" +
			fiNimCompile(env, e2, returns);
		}
		FiLambda(args, body, type, __): {
			wrap_ret(fiType2NimType(env, FiTypeFunction(type with args = args)) + " =" + 
				fi2nimSureIndent(fiNimCompile(env, body, true)));
		}
		FiCall(fn, es, __, __): {
			args_code = map(es, \e -> fiNimCompile(env, e, false));
			args = "(" + strGlue(args_code, ", ") + ")";
			switch (fn) {
				FiVar(x, __, __): {
					if (!(returns && x == env.tailcall_fn)) {
						n: Maybe<FiDeclaration> = lookupTree(env.prog.names.toplevel, x);
						typars = switch (n) {
							Some(decl): {
								fiMatchTyparsOrdered(decl.type, fiExpType(fn));
							}
							None(): [];
						}
						typars_str = if (length(typars) == 0) "" else {
							"[" + superglue(typars, \tp -> fiType2NimType(env, tp), ", ") + "]";
						}
						wrap_ret(fiNimRenameKeyword(x) + typars_str + args);
					} else {
						// Tail call detected
						arg_is_not_changed = \y, i -> {
							switch (y) {
								FiVar(v,__,__): v == env.tailcall_args[i].name;
								default: false;
							}
						}
						tmp_arg = \i -> fiNimRenameKeyword("tmp__" + env.tailcall_args[i].name);
						strGlue(concat3(
							filtermapi(args_code, \i, arg_code -> 
								if (arg_is_not_changed(es[i], i)) None() else {
									Some("let " + tmp_arg(i) + ": " + fiType2NimType(env, env.tailcall_args[i].type) + " =" +
										fi2nimMaybeIndent(args_code[i])
									);
								}
							),
							filtermapi(args_code, \i, arg_code -> 
								if (arg_is_not_changed(es[i], i)) None() else {
									Some(fiNimRenameKeyword(env.tailcall_args[i].name) + " = " + tmp_arg(i));
								}
							),
							["continue"]
						), "\n");
					}
				}
				default: {
					wrap_ret("(" + fiNimCompile(env, fn, false) + ")" + args);
				}
			}
		}
		FiSeq(es, __, __): {
			if (length(es) == 0) if (returns) "return" else "discard" else
			if (length(es) == 1) fiNimCompile(env, es[0], returns) else {
				concatStrings(add_newlines(mapi(es, \i, x -> {
					needs_discard = switch(x) {
						FiLet(__, __, __, __, __, __) : false;
						FiCallPrim(op, __, __, __) : {
							switch (op) {
								FcAssignPrim() : false;
								FcSetMutablePrim(__) : false;
								default: true;
							}
						}
						FiCall(__, __, tp, __): {
							switch (tp) {
								FiTypeVoid() : false;
								default : true;
							}
						}
						default: fiExpType(x) != FiTypeVoid();
					}
					last_returns = returns && i + 1 == length(es);
					x_code = fiNimCompile(env, x, last_returns);
					if (needs_discard) {
						if (last_returns) {
							x_code;
						} else {
							"discard" + fi2nimMaybeIndent(x_code);
						}
					} else {
						x_code;
					}
				})));
			}
		}
		FiIf(e1, e2, e3, __, __): {
			"if " + fiNimCompile(env, e1, false) + ":" + 
				fi2nimSureIndent(fiNimCompile(env, e2, returns)) + 
			"else:" + 
				fi2nimSureIndent(fiNimCompile(env, e3, returns));
		}
		FiSwitch(x, __, cs, __, __): {
			non_defcases = filter(cs, \c -> c.struct != "default");
			def_case = switch (find(cs, \c -> c.struct == "default")) {
				Some(dc): fi2nimMaybeIndent(fiNimCompile(env, dc.body, returns));
				None(): "assert(false,\"illegal struct id in switch\")";
			}
			"case cast[StructType](" + fiNimCompile(env, x, false) + ".id)" + "\n" +
			concatStrings(add_newlines(concat(
				map(non_defcases, \c -> "of st" + c.struct + ":" + fi2nimSureIndent(fiNimCompile(env, c.body, returns))),
				["else:" + fi2nimSureIndent(def_case)]
			)));
		}
		FiCallPrim(op, es, tp, __): {
			args = map(es, \arg : FiExp -> Pair(fiNimCompile(env, arg, false), fiExpType(arg)));
			opt = switch (op : FcPrim) {
				FcOrPrim():    "(" + args[0].first + " or " + args[1].first + ")";
				FcAndPrim():   "(" + args[0].first + " and " + args[1].first + ")";
				FcNotPrim():   "not " + args[0].first;
				FcEqPrim():    "(" + args[0].first + " == " + args[1].first + ")";
				FcNePrim():    "(" + args[0].first + " != " + args[1].first + ")";
				FcLePrim():    "(" + args[0].first + " <= " + args[1].first + ")";
				FcGePrim():    "(" + args[0].first + " >= " + args[1].first + ")";
				FcLtPrim():    "(" + args[0].first + " < "  + args[1].first + ")";
				FcGtPrim():    "(" + args[0].first + " > "  + args[1].first + ")";
				FcPlusPrim():  fiNimCompilePlus(env, args[0], " + ", args[1]);
				FcMinusPrim(): "(" + args[0].first + " - "  + args[1].first + ")";
				FcMulPrim():   "(" + args[0].first + " * "  + args[1].first + ")";
				FcDivPrim():   fiNimCompileDiv(env, args[0], " / ", args[1]);
				FcModPrim():   fiNimCompileDiv(env, args[0], " %% ", args[1]);
				FcNegPrim():  "-" + args[0].first;
				FcArrayPrim(): "@[" + strGlue(map(args, \e->e.first), ", ") + "]";
				FcIndexPrim(): args[0].first + "[" + args[1].first + "]";
				FcDerefPrim(): args[0].first;
				FcAssignPrim():	"(" + args[0].first + " = " + args[1].first + ")";
				FcRefPrim(): args[0].first;
				FcStructPrim(struct_name): {
					typars = fiNimParamsForInstantiate(env, cast(tp: FiType -> FiTypeName).typeparameters);
					"make_" + struct_name + typars + "(" + superglue(args, \p ->  p.first, ", ") + ")";
				};
				FcFieldPrim(name): {
					args[0].first +  "." + fiNimRenameKeyword(name)
				}
				FcSetMutablePrim(name): {
					"(" + args[0].first + "." + fiNimRenameKeyword(name) + "=" + args[1].first + ")";
				}
				FcCreateClosurePrim(__, __): fail0("TODO"); // should not happen - Nim does not use lambda lifting
                FcQuote(): fail0("TODO");
                FcUnquote(): fail0("TODO");
			};
			wrap_ret(opt);
		}
		FiCast(e, from, to, __, __): {
			wrap_ret(fiNimCompileCast(env, 
				fiNimDerefType(from), 
				fiNimDerefType(to), 
				fiNimCompile(env, e, false)
			));
		}
		default: "#!other!\n" + toString(expr);
	}
}

fiNimCompileCast(env: FiNimEnv, from: FiType, to: FiType, ex: string) -> string {
	def_cast = \-> "cast[" + fiType2NimType(env, to) + "](" + ex + ")";
	structs = env.prog.names.structs;
	unions = env.prog.names.unions;
	switch (to) {
		FiTypeName(to_name, to_typars): {
			switch (from) {
				FiTypeName(from_name, from_typars): {
					switch (lookupTree(structs, from_name)) {
						Some(from_struct): {
							switch (lookupTree(structs, to_name)) {
								Some(to_struct): {
									def_cast();
								}
								None(): {
									switch (lookupTree(unions, to_name)) {
										Some(to_union): {
											"Struct(" +  ex + ")";
										}
										None(): {
											fail0(to_name + " type is not found");
										}
									}
								}
							}
						}
						None(): {
							switch (lookupTree(unions, from_name)) {
								Some(from_union): {
									switch (lookupTree(structs, to_name)) {
										Some(to_struct): {
											fiType2NimType(env, to) + "(" + ex + ")";
										}
										None(): {
											ex;
										}
									}
								}
								None(): {
									fail0(to_name + " type is not found");
								}
							}
						}
					}
				}
				default: def_cast();
			}
		}
		FiTypeFlow(): {
			"rt_to_flow(" + ex + ")";
		}
		FiTypeString(): {
			"rt_to_string(" + ex + ")";
		}
		FiTypeDouble(): {
			"rt_to_double(" + ex + ")";
		}
		FiTypeBool(): {
			"rt_to_bool(" + ex + ")";
		}
		FiTypeInt(): {
			"rt_to_int(" + ex + ")";
		}
		default: def_cast();
	}
}

fiNimCompilePlus(env : FiNimEnv, arg1 : Pair<string, FiType>, op : string, arg2 : Pair<string, FiType>) {
	a1 = arg1.first;
	a2 = arg2.first;
	// Type checker ensures math types are equal, so we only need one type.
	arg_type = fiNimDerefType(arg1.second);
	"(" + (if (arg_type == FiTypeString() && (op == " + ")) a1 + " & " + a2 else a1 + op + a2) + ")";
}

fiNimCompileDiv(env : FiNimEnv, arg1 : Pair<string, FiType>, op : string, arg2 : Pair<string, FiType>) {
	a1 = arg1.first;
	a2 = arg2.first;
	// Type checker ensures math types are equal, so we only need one type.
	arg_type = fiNimDerefType(arg1.second);
	"(" + (if (arg_type == FiTypeInt() && (op == " / ")) {
		a1 + " div " + a2
	} else if (arg_type == FiTypeInt() && (op == " %% ")) {
		a1 + " mod " + a2
	} else if (arg_type == FiTypeDouble() && (op == " %% ")) {
		a1 + " mod " + a2
	} else {
		a1 + op + a2
	}) + ")";
}

fi2nimStructIds(env : FiNimEnv) -> string {
	fiNimIndent + "StructType = enum\n" +
	strGlue(map(env.structs, \s -> fiNimIndent2 + "st" + s.name), ",\n") + "\n\n" 
}

fi2nimStructDef(env : FiNimEnv, struct : FiTypeStruct) -> string {
	typars = fiNimParamsForInstantiate(env, struct.typars);
	fields = if (length(struct.args) == 0) "" else
	"\n" + superglue(struct.args, \arg -> fiNimIndent2 + fiNimRenameKeyword(arg.name) + ": " + fiType2NimType(env, arg.type), "\n");
	struct_type = struct.name + typars;
	fiNimIndent + struct_type + " = ref object of Struct" + fields + "\n\n";
}

fi2nimUnionDef(env : FiNimEnv, union : FiTypeUnion) -> string {
	typars = fiNimParamsForInstantiate(env, union.typeparameters);
	fiNimIndent + union.name + typars + " = ref object of Struct\n\n";
}

fi2nimStructFuncs(env : FiNimEnv, struct : FiTypeStruct) -> string {
	typars = fiNimParamsForInstantiate(env, struct.typars);
	struct_type = struct.name + typars;
	check_struct_in = \tp_arr -> exists(tp_arr, \tp -> switch (fiNimDerefType(tp)) {
		FiTypeName(nm,__): nm == struct.name;
		default: false;
	});

	// to_flow
	to_flow = if (!check_struct_in(env.casts_to_flow_from)) "" else {
		"proc rt_to_flow" + typars + "(x: " + struct_type  + "): Flow =\n" +
		fiNimIndent + "Flow(tp: rtStruct, " + 
		"idStruct: cast[int](" + "st" + struct.name + "), " +
		"nameStruct: \"" + struct.name + "\", " +
		"valFields: @[" + superglue(struct.args, \arg -> "rt_to_flow(x." + arg.name + ")", ", ") + 
		"])\n\n";
	}

	// to_string
	to_string_args = \ -> if (length(struct.args) == 0) "()" else {
		"(\" & " + superglue(struct.args, \arg -> "rt_to_string(x." + arg.name + ")", " & \", \" & ") + " & \")";
	} 
	to_string = if (!check_struct_in(env.casts_to_string_from)) "" else {
		"proc rt_to_string" + typars + "(x: " + struct_type  + "): string =\n" +
		fiNimIndent + "\"" + struct.name + to_string_args() + "\"\n\n";
	}

	// make_struct
	make_args = concat(["id: cast[int](st" + struct.name + ")"], mapi(struct.args, \i, arg -> arg.name + ": a_" + i2s(i)));
	make_struct = "proc make_" + struct_type + "(" + supergluei(struct.args, \i, arg -> "a_" + i2s(i) + ": " + fiType2NimType(env, arg.type), ", ")  + "): " + struct_type + " =\n" +
	fiNimIndent + struct_type + "(" + strGlue(make_args, ", ") + ")\n\n";

	concatStrings([to_flow, to_string, make_struct]);
}
