import string_utils;
import tools/flowc/backends/common;
import tools/flowc/backends/nim/fi2nim_defines;
import tools/flowc/backends/nim/fi2nim_utils;
import tools/flowc/manipulation/transform_exps;

export {
	fiNimCompileToplevel(env : FiNimEnv, decl: FiDeclaration, indent : string) -> string;
	fiNimCompileToExpr(env : FiNimEnv, expr : FiNimExp, indent : string) -> string;
	fiNimCompileToReturn(env : FiNimEnv, expr : FiNimExp, indent : string) -> string;
	fiNimCompilePlus(env : FiNimEnv, arg1 : Pair<string, FiType>, op   : string, arg2 : Pair<string, FiType>) -> string;
	fiNimCompileDiv(env : FiNimEnv, arg1 : Pair<string, FiType>, op   : string, arg2 : Pair<string, FiType>) -> string;

	fi2nimStructIds(env : FiNimEnv) -> string;
	fi2nimStructDef(env : FiNimEnv, struct : FiTypeStruct) -> string;
	fi2nimUnionDef(env : FiNimEnv, union : FiTypeUnion) -> string;
	fi2nimStructFuncs(env : FiNimEnv, struct : FiTypeStruct) -> string;
}

// Temporary, will be removed.
doTN : ref bool = ref false;

fiNimCompileToplevel(env : FiNimEnv, decl : FiDeclaration, indent : string) {
	switch (decl : FiDeclaration) {
		FiNativeDec(name, io, type, nativeName, flowfallback, __, __) : {
			switch (flowfallback) {
				FiLambda(__, __, fn_type, __): {
					if (containsSet(nimNativeFunctions, name)) {
						// native is implemented in runtime
						""
					} else {
						// use a fallback
						fiNimCompileFunction(env, name, fn_type, flowfallback);
					}
				}
				FiVoid(__): {
					if (!containsSet(nimNativeFunctions, name)) {
						fcPrintln("Error: " + name + " native is not implemented in nim backend", env.cfg.threadId);
					}
					"# native: " + nativeName + " " + name + "\n";
				}
				default: {
					fcPrintln("fallbackLambda in FiNativeDec must be FiLambda or FiVoid, but is: " + prettyFiExp(dummyPretty, flowfallback), env.cfg.threadId);
					"# native: " + nativeName + " " + name + "\n"
				}
			}
		}
		FiFunctionDec(name, lambda, type, __, __): {
			if (containsSet(nimNativeFunctions, name)) {
				//is implemented as native in runtime
				""
			} else {
				fiNimCompileFunction(env, name, type, lambda);
			}
		}
		FiGlobalVar(name, value, type, __, __): {
			fiNimCompileGlobalVar(env, name, type, value, indent);
		}
	};
}

fiNimCompileFunction(env : FiNimEnv, nm: string, type: FiTypeFunction, lambda0: FiLambda) -> string {
	if (containsSet(nimForbiddenFunctions, nm)) {
		nimProcDefinition := Cons("# " + nm + " forbidden with nimForbiddenFunctions\n", ^nimProcDefinition);
		""
	} else {
		nim_type = \t -> fiType2NimType(env, t);
		ret_type = switch(type.returnType) {
			FiTypeFunction(__, __): "(" + nim_type(type.returnType) + ")";
			default: nim_type(type.returnType);
		}
		//lambda = cast(fiExpMakeCastsExplicit(lambda0, type, env.prog.names): FiExp -> FiLambda);
		lambda = cast(
			(lambda0 
				|> fiFixVarInSameStructType1 
				|> \ x -> fiExpMakeCastsExplicit(x, type, env.prog.names)
				|> fiPullStatementsUp
			)
			: FiExp -> FiLambda);
		body = lambda.body;

		//doStrSplit
		if (nm == "setBitSet") {
			println(
				nm + ":\n" + 
				"lambda0: " + prettyFiExp(dummyPretty, lambda0) + "\n" + 
				toStringFormatted(lambda0) + "\n"
				//"lambda: " + prettyFiExp(dummyPretty, lambda) + "\n" + 
				//toStringFormatted(lambda) + "\n" +
				//"ret type: " + prettyFiType(dummyPretty, type.returnType, makeSet())
			);
		}

		stype = if (ret_type == "") "" else ": " + ret_type;

		fparams = strGlue(mapi(lambda.args, \idx, arg -> {
			tmp = {
				varPrefix = switch(arg.type) {
					FiTypeRef(__) : "var ";
					default : ""
				};
				if (^doTN) fcPrintln("HIA: at = " + toString(arg.type), env.cfg.threadId);
				varPrefix + fiType2NimType(env, arg.type);
			}
			fiNimRenameKeyword(arg.name) + ": " + tmp
		}
		), ", ");

		tp = fiNimTypeParamsList(env, FiFunctionDec(nm, lambda, type, -1, -1));

		hd = "proc " + fiNimRenameKeyword(nm) + tp + "(" + fparams + ")" + stype;

		if (nm != "main") {
			nimProcDefinition := Cons(hd + "\n", ^nimProcDefinition);
		}

		meq = (if (nm == "main") " {.discardable.}" else "") + " = \n";
		header = hd + meq;

		lambdaBody : FiExp = body;
		bodyOrSeq = switch (lambdaBody) {
			FiSeq(__, __, __) : body;
			default : FiSeq([body], FiTypeVoid(), -1);
		}
		// if (name == "extractStruct") doTN := true;
		if (^doTN) {
			// fcPrintln("HIA: decl = " + toString(decl));
		}
		bodyTxt = fiNimCompileToReturn(env, bodyOrSeq, fiNimIndent);
		doTN := false;
		header + bodyTxt + "\n"
	}
}

fiNimCompileGlobalVar(env : FiNimEnv, nm: string, type: FiType, value: FiExp, indent : string) {
	// TODO Dead code elimination broke this!
	// Made stub, but require to fixup it correctly!
	if (nm != "") {
			// fcPrintln("HIA: " + name + " typ = " + toString(typ));
			varType = switch(type) {
				FiTypeFunction(__, __): "";
				FiTypeRef(tr): switch(tr) {
					FiTypeFunction(__,__): "";
					default: fiType2NimType(env, type);
				}
				default: fiType2NimType(env, type);
			}
			"var " + nm +
			(if (varType != "") ": " + varType else "") +
			" = " + fiNimCompileToExpr(env, value, indent)
	}
	else {
		fcPrintln("Error: name of a global variable is empty", env.cfg.threadId);
		"# FiGlobalVar = " + toString(value);
	}
}

fiNimCompileToExpr(env : FiNimEnv, expr : FiNimExp, indent : string) -> string {
	subindent = indent + fiNimIndent;
	switch (expr : FiNimExp) {
		FiDiscard(e) : {
			//fail("no explicit discard");
			switch(e) {
				None() : "discard";
				Some(ex) : "discard\n" + subindent + fiNimCompileToExpr(env, ex, subindent);
			}
		}
		FiVoid(__): "discard";
		FiBool(b, __): if (b) "true" else "false";
		FiInt(v, __): i2s(v);
		FiDouble(d, __): {
			s = d2s(d);
			if (strIndexOf(s, ".") < 0 && strIndexOf(s, "e") < 0) s+".0" else s;
		}
		FiString(s, __): "\"" + escapeStr(s) + "\"";
		FiVar(x, __, __): {
			fiNimRenameKeyword(x);
		}
		FiLet(x, tp, e1, e2, __, __): {
			"var " + fiNimRenameKeyword(x) + ": " + fiType2NimType(env, tp) + " =\n" +
			subindent + fiNimCompileToExpr(env, e1, subindent) + "\n" +
			indent + fiNimCompileToExpr(env, e2, indent);
		}

		FiLambda(xs, e0, type, __): {
			lt = switch (type) {
				FiTypeFunction(__, retType): fiType2NimType(env, retType);
				default: "";
			}
			ltype = if (lt != "") ": " + lt else "";
			"proc(" + strGlue(map(xs, \a -> {
				ats = fiType2NimType(env, a.type);
				atr = switch (a.type) {
					FiTypeFunction(__, __) : "(" + ats + ")";
					default : ats;
				}
				fiNimRenameKeyword(a.name) + ": " + atr
			}), ", ") + ")" + ltype + " =\n" +
			subindent + fiNimCompileToReturn(env, e0, subindent);
		}

		FiCall(fn, es, __, __): {
			args = "(" + superglue(es, \e -> fiNimCompileToExpr(env, e, subindent), ", ") + ")";
			switch (fn) {
				FiVar(x, __, __): {
					n: Maybe<FiDeclaration> = lookupTree(env.prog.names.toplevel, x);
					typars = switch (n) {
						Some(decl): {
							fiMatchTyparsOrdered(decl.type, fiExpType(fn));
						}
						None(): [];
					}
					typars_str = if (length(typars) == 0) "" else {
						"[" + superglue(typars, \tp -> fiType2NimType(env, tp), ", ") + "]";
					}
					fiNimRenameKeyword(x) + typars_str + args;
				}
				default: {
					fiNimCompileToExpr(env, fn, indent) + args;
				}
			}
		}
		FiSeq(es, __, __): {
			l = length(es);
			// "#[s]#"+
			if (l >= 0)
				list2string(foldi(es, makeList(), \idx, acc, e -> {
					ndd = switch(e) {
						FiLet(__, __, __, __, __, __) : false;
						FiCallPrim(op, __, __, __) : {
							switch (op) {
								FcAssignPrim() : false;
								FcSetMutablePrim(__) : false;
								default: true;
							}
						}
						FiCall(__, __, tp, __): {
							switch (tp) {
								FiTypeVoid() : false;
								default : true;
							}
						}
						default : true;
					}
					needDiscard = (idx < l-1) && ndd;
					nrr = switch (e) {
						FiLambda(__, __, __, __): true;
						default: false;
					}
					needReturn = (idx == l-1) && nrr;

					ex = if (needDiscard) FiDiscard(Some(e)) else e;
					exprCode = (if (idx == 0) "" else "\n" + indent) + (if (needReturn) "return " else "") + fiNimCompileToExpr(env, ex, indent);
					Cons(exprCode, acc);
				}))
			else
				"discard";

			/*if (length(es) == 0) "discard" else {
				supergluei(es, \i, x -> {
					x_compiled = fiNimCompileToExpr(env, x, indent);
					tp = fiExpType(es[i]);
					if (i + 1 < length(es)) {
						switch (tp) {
							FiTypeVoid(): x_compiled;
							default: "discard(" + x_compiled + ")";
						}
					} else {
						switch (tp) {
							FiTypeVoid(): x_compiled;
							default: "return " + x_compiled;
						}
					}
				}, "\n");
			}*/
		}

		FiIf(e1, e2, e3, __, __): {
			//fail("if must not occur in exp");
			"if "+fiNimCompileToExpr(env, e1, "") +":\n"+
			subindent + fiNimCompileToExpr(env, e2, subindent) + "\n" +
			indent + "else:\n" +
			subindent + fiNimCompileToExpr(env, e3, subindent);
		}

		FiSwitch(e0, e0type, cs, __, __): {
			//fail("switch must not occur in exp");
			"# FiSwitch: \n";
			"case cast[StructType](" + fiNimCompileToExpr(env, e0, subindent) + ".id)" + "\n" +
			fold(cs, "", \acc, c : FiCase ->
				acc + indent + "of st" + c.struct + ":\n" + 
					subindent + fiNimCompileToExpr(env, c.body, subindent) + "\n"
			);
		}
		FiCallPrim(op, es, tp, __): {
			args = map(es, \arg : FiExp -> Pair(fiNimCompileToExpr(env, arg, indent), fiExpType(arg)));
			opt = switch (op : FcPrim) {
				FcOrPrim():    "(" + args[0].first + " or " + args[1].first + ")";
				FcAndPrim():   "(" + args[0].first + " and " + args[1].first + ")";
				FcNotPrim():   "not " + args[0].first;
				FcEqPrim():    "(" + args[0].first + " == " + args[1].first + ")";
				FcNePrim():    "(" + args[0].first + " != " + args[1].first + ")";
				FcLePrim():    "(" + args[0].first + " <= " + args[1].first + ")";
				FcGePrim():    "(" + args[0].first + " >= " + args[1].first + ")";
				FcLtPrim():    "(" + args[0].first + " < "  + args[1].first + ")";
				FcGtPrim():    "(" + args[0].first + " > "  + args[1].first + ")";
				FcPlusPrim():  fiNimCompilePlus(env, args[0], " + ", args[1]);
				FcMinusPrim(): "(" + args[0].first + " - "  + args[1].first + ")";
				FcMulPrim():   "(" + args[0].first + " * "  + args[1].first + ")";
				FcDivPrim():   fiNimCompileDiv(env, args[0], " / ", args[1]);
				FcModPrim():   fiNimCompileDiv(env, args[0], " %% ", args[1]);
				FcNegPrim():  "-" + args[0].first;
				FcArrayPrim(): "@[" + strGlue(map(args, \e->e.first), ", ") + "]";
				FcIndexPrim(): args[0].first + "[" + args[1].first + "]";
				FcDerefPrim(): args[0].first;
				FcAssignPrim():	args[0].first + " = " + args[1].first;
				FcRefPrim(): args[0].first;
				// After typechecking we definitely know structure exists, so skip sanity checks.
				FcStructPrim(struct_name): {
					/*struct = {
						type = fiType2NimType(env, tp);
						argNames = switch (resolveFiTypeName(env.prog.names, tp, env.cfg.threadId)) {
							//FiTypeStruct(__ ,__, sargs, __): map(sargs, \e -> e.name);
							FiTypeStruct(name, tyPars, as, __): map(as, \a -> a.name);
							default: [];
						}
						Pair(type, argNames);
					}
					if (struct.second == [])
						struct.first
					else
						struct.first + "(" + strGlue(mapi(es, \ix, e -> struct.second[ix] + ": " +  args[ix].first), ", ") + ")";*/

					struct = lookupTreeDef(env.prog.names.structs, struct_name, dummyFiTypeStruct);
					type = cast(tp: FiType -> FiTypeName);
					//typars = type.typeparameters;
					//fiNimParamsForInstantiate(env : FiNimEnv, params: [FiType]) -> string;
					//structname + fiNimParamsForInstantiate(env, typars) + 
					tuple = "(" + 
						supergluei(args, \i, p ->  struct.args[i].name + ": " + p.first, ", ") + 
					")";
					/*switch (lookupTree(env.prog.names.unions, type.name)) {
						Some(union): {
							typars = fiNimParamsForInstantiate(env, type.typeparameters);
							union.name + typars + "(st" + struct_name + ", " + tuple + ")";
						}
						None(): tuple;
					}*/
					"make_" + struct_name + fiNimParamsForInstantiate(env, type.typeparameters) + "(" + 
						superglue(args, \p ->  p.first, ", ") + 
					")";
				};
				FcFieldPrim(name): {
					fiNimCompileToExpr(env, es[0], indent) +  "." + fiNimRenameKeyword(name)
				}
				FcSetMutablePrim(name):
				"#FiSetMutablePrim";
				// "(" + args[0].first + ("."+lookupTreeDef(ctx.ovl.fieldRenamings, name, name) + "=") + args[1].first + ")";
				FcCreateClosurePrim(__, __): ""; // should not happen - Nim does not use lambda lifting
                FcQuote(): "TODO";
                FcUnquote(): "TODO";
			};
			opt;
		}
		FiCast(e, tFrom, tTo, __, __): {
			fiNimCompileCast(env, fiNimCompileToExpr(env, e, indent), tFrom, tTo, indent);
		}
		default: "#!other!\n" + toString(expr);
	}
}

fiNimCompileCast(env : FiNimEnv, ex: string, from: FiType, to: FiType, indent: string) -> string {
	def_cast = \-> {
		tf = fiType2NimType(env, from);
		tt = fiType2NimType(env, to);
		"cast[" + tt + "](" + ex + ")";
	}
	structs = env.prog.names.structs;
	unions = env.prog.names.unions;
	switch (from) {
		FiTypeName(from_name, from_typars): {
			switch (to) {
				FiTypeName(to_name, to_typars): {
					switch (lookupTree(structs, from_name)) {
						Some(from_struct): {
							switch (lookupTree(structs, to_name)) {
								Some(to_struct): {
									// Structs must be the same
									ex;
								}
								None(): {
									switch (lookupTree(unions, to_name)) {
										Some(to_union): {
											"Struct(" +  ex + ")";
										}
										None(): {
											fail0(to_name + " type is not found");
										}
									}
								}
							}
						}
						None(): {
							switch (lookupTree(unions, from_name)) {
								Some(from_union): {
									switch (lookupTree(structs, to_name)) {
										Some(to_struct): {
											fiType2NimType(env, to) + "(" + ex + ")";
										}
										None(): {
											ex;
										}
									}
								}
								None(): {
									fail0(to_name + " type is not found");
								}
							}
						}
					}
				}
				default: def_cast();
			}
		}
		default: def_cast();
	}
}

fiNimCompileToReturn(env: FiNimEnv, expr: FiNimExp, indent: string) -> string {
	subindent = indent + fiNimIndent;
	switch (expr : FiNimExp) {
		FiCallPrim(op, es, __, __) : fiNimCompileToExpr(env, expr, indent);
		FiCall(f, es, type, __): {
			switch (type) {
				FiTypeVoid() : fiNimCompileToExpr(env, expr, indent);
				default: "return " + fiNimCompileToExpr(env, expr, indent);
			}
		}

		FiLet(x, tp, e1, e2, t, __): {
			dec = "var ";
			dec + fiNimRenameKeyword(x) + ": " + fiType2NimType(env, tp) + " = " +
			fiNimCompileToExpr(env, e1, subindent) + "\n"+
			fiNimCompileToReturn(env, e2, indent);
		}

		FiSeq(es, __, __): {
			l = length(es);
			//"#R FiSeq:\n" +
			if (l >= 0)
				list2string(foldi(es, makeList(), \idx, acc, e -> {
					ndd = switch(e) {
						FiLet(__, __, __, __, __, __) : false;
						FiCallPrim(op, __, __, __) : {
							switch(op) {
								FcAssignPrim() : false;
								FcSetMutablePrim(__) : false;
								default: true;
							}
						}
						FiCall(__, __, tp, __): {
							switch(tp) {
								FiTypeVoid() : false;
								default : true;
							}
						}
						default : true;
					}
					needDiscard = (idx < l-1) && ndd;
					nrr = switch(e) {
						FiLambda(__,__,__, __): true;
						default: false;
					}
					needReturn = (idx == l-1) && nrr;
					ex = if (needDiscard) FiDiscard(Some(e)) else e;
					exprCode = indent + (if (needReturn) "return " else "") + fiNimCompileToExpr(env, ex, indent) + (if (idx == l-1) "" else "\n");
					Cons(exprCode, acc);
				}))
			else
				"discard";

			/*if (length(es) == 0) "discard" else {
				supergluei(es, \i, x -> {
					x_compiled = fiNimCompileToExpr(env, x, indent);
					tp = fiExpType(es[i]);
					if (i + 1 < length(es)) {
						switch (tp) {
							FiTypeVoid(): x_compiled;
							default: "discard(" + x_compiled + ")";
						}
					} else {
						switch (tp) {
							FiTypeVoid(): x_compiled;
							default: "return " + x_compiled;
						}
					}
				}, "\n");
			}*/
		}

		FiIf(e1, e2, e3, __, __): {
			"if "+fiNimCompileToExpr(env, e1, "") +":\n"+
			subindent + fiNimCompileToExpr(env, e2, subindent) + "\n" +
			indent + "else:\n" +
			subindent + fiNimCompileToExpr(env, e3, subindent);
		}

		FiSwitch(e0, e0type, cs, __, __): {
			"#R FiSwitch:\n"
		}
		default: fiNimCompileToExpr(env, expr, subindent) + "";
	}
}

fiNimCompilePlus(env : FiNimEnv, arg1 : Pair<string, FiType>, op : string, arg2 : Pair<string, FiType>) {
	a1 = arg1.first;
	a2 = arg2.first;
	// Type checker ensures math types are equal, so we only need one type.
	isString = switch (arg1.second) {
		FiTypeString() : true;
		default : false;
	};
	"(" + (if (isString && (op == "+")) a1 + "&" + a2 else a1 + op + a2) + ")";
}

fiNimCompileDiv(env : FiNimEnv, arg1 : Pair<string, FiType>, op : string, arg2 : Pair<string, FiType>) {
	a1 = arg1.first;
	a2 = arg2.first;
	// Type checker ensures math types are equal, so we only need one type.
	isInt = switch (arg1.second) {
		FiTypeInt() : true;
		default : false;
	};
	"(" + (if (isInt && (op == " / ")) {
		a1 + " div " + a2
	} else if (isInt && (op == " %% ")) {
		a1 + " mod " + a2
	} else {
		a1 + op + a2
	}) + ")";
}

fi2nimStructIds(env : FiNimEnv) -> string {
	fiNimIndent + "StructType = enum\n" +
	strGlue(map(env.structs, \s -> fiNimIndent2 + "st" + s.name), ",\n") + "\n\n" 
}

fi2nimStructDef(env : FiNimEnv, struct : FiTypeStruct) -> string {
	typars = fiNimParamsForInstantiate(env, struct.typars);
	fields = if (length(struct.args) == 0) "" else
	"\n" + superglue(struct.args, \arg -> fiNimIndent2 + fiNimRenameKeyword(arg.name) + ": " + fiType2NimType(env, arg.type), "\n");
	struct_type = struct.name + typars;
	fiNimIndent + struct_type + " = ref object of Struct" + fields + "\n\n";
}

fi2nimUnionDef(env : FiNimEnv, union : FiTypeUnion) -> string {
	typars = fiNimParamsForInstantiate(env, union.typeparameters);
	fiNimIndent + union.name + typars + " = ref object of Struct\n\n";
}

fi2nimStructFuncs(env : FiNimEnv, struct : FiTypeStruct) -> string {
	typars = fiNimParamsForInstantiate(env, struct.typars);
	struct_type = struct.name + typars;
	check_struct_in = \tp_arr -> exists(tp_arr, \tp -> switch (tp) {
		FiTypeName(nm,__): nm == struct.name;
		default: false;
	});

	// to_flow
	to_flow = if (!check_struct_in(env.casts_to_flow_from)) "" else {
		"proc to_flow" + typars + "(x: " + struct_type  + "): Flow =\n" +
		fiNimIndent + "Flow(tp: rtStruct, " + 
		"idStruct: cast[int](" + "st" + struct.name + "), " +
		"nameStruct: \"" + struct.name + "\", " +
		"valFields: @[" + superglue(struct.args, \arg -> "to_flow(x." + arg.name + ")", ", ") + 
		"])\n\n";
	}

	// to_string
	to_string = if (!check_struct_in(env.casts_to_string_from)) "" else {
		to_string_args = if (length(struct.args) == 0) "()" else {
			"(\" & " + superglue(struct.args, \arg -> "toString(x." + arg.name + ")", " & \", \" & ") + " & \")";
		} 
		"proc to_string" + typars + "(x: " + struct_type  + "): string =\n" +
		fiNimIndent + "\"" + struct.name + to_string_args + "\"\n\n";
	}

	// make_struct
	make_args = concat(["id: cast[int](st" + struct.name + ")"], mapi(struct.args, \i, arg -> arg.name + ": a_" + i2s(i)));
	make_struct = "proc make_" + struct_type + "(" + supergluei(struct.args, \i, arg -> "a_" + i2s(i) + ": " + fiType2NimType(env, arg.type), ", ")  + "): " + struct_type + " =\n" +
	fiNimIndent + struct_type + "(" + strGlue(make_args, ", ") + ")\n\n";

	concatStrings([to_flow, to_string, make_struct]);
}
