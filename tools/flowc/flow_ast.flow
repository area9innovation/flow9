import lingo/compiler/syntaxtree_types;
import tools/flowc/flow_ast_mnemonics;

export {
	get_flow_importExport_s(st : SyntaxTree) -> [SyntaxTree];
	get_flow_import(st : SyntaxTree) -> SyntaxTree;
	get_flow_dynamicImport(st : SyntaxTree) -> SyntaxTree;
	get_flow_export(st : SyntaxTree) -> SyntaxTree;
	get_flow_forbid(st : SyntaxTree) -> SyntaxTree;
	get_flow_toplevelDeclaration_s(st : SyntaxTree) -> [SyntaxTree];
	get_flow_native(st : SyntaxTree) -> SyntaxTree;
	get_flow_native_io_s(st : SyntaxTree) -> [SyntaxTree];
	get_flow_name(st : SyntaxTree) -> SyntaxTree;
	get_flow_dot_name_s(st : SyntaxTree) -> [SyntaxTree];
	get_flow_assign(st : SyntaxTree) -> SyntaxTree;
	get_flow_union(st : SyntaxTree) -> SyntaxTree;
	get_flow_function(st : SyntaxTree) -> SyntaxTree;
	get_flow_function_args(st : SyntaxTree) -> SyntaxTree;
	get_flow_function_2(st : SyntaxTree) -> SyntaxTree;
	get_flow_typedecl(st : SyntaxTree) -> SyntaxTree;
	get_flow_vardecl(st : SyntaxTree) -> SyntaxTree;
	get_flow_assignExp_s(st : SyntaxTree) -> [SyntaxTree];
	get_flow_functiondecl(st : SyntaxTree) -> SyntaxTree;
	get_flow_structdecl(st : SyntaxTree) -> SyntaxTree;
	get_flow_returnType(st : SyntaxTree) -> SyntaxTree;
	get_flow_returnType_s(st : SyntaxTree) -> [SyntaxTree];
	get_flow_brace_or_semi(st : SyntaxTree) -> SyntaxTree;
	get_flow_funargs2_s(st : SyntaxTree) -> [SyntaxTree];
	get_flow_funargs2_more_s(st : SyntaxTree) -> [SyntaxTree];
	get_flow_funarg2(st : SyntaxTree) -> SyntaxTree;
	get_flow_funarg2_arg(st : SyntaxTree) -> SyntaxTree;
	get_flow_funargs_s(st : SyntaxTree) -> [SyntaxTree];
	get_flow_funargs_more_s(st : SyntaxTree) -> [SyntaxTree];
	get_flow_funarg(st : SyntaxTree) -> SyntaxTree;
	get_flow_funarg_mutable_s(st : SyntaxTree) -> [SyntaxTree];
	get_flow_colontype(st : SyntaxTree) -> SyntaxTree;
	get_flow_colontype_s(st : SyntaxTree) -> [SyntaxTree];
	get_flow_typenames(st : SyntaxTree) -> SyntaxTree;
	get_flow_typenames2_s(st : SyntaxTree) -> [SyntaxTree];
	get_flow_typename(st : SyntaxTree) -> SyntaxTree;
	get_flow_typelist_s(st : SyntaxTree) -> [SyntaxTree];
	get_flow_types(st : SyntaxTree) -> SyntaxTree;
	get_flow_types2_s(st : SyntaxTree) -> [SyntaxTree];
	get_flow_type(st : SyntaxTree) -> SyntaxTree;
	get_flow_type_fn_par(st : SyntaxTree) -> SyntaxTree;
	get_flow_type_rettype(st : SyntaxTree) -> SyntaxTree;
	get_flow_argtypes_s(st : SyntaxTree) -> [SyntaxTree];
	get_flow_argtypes2_s(st : SyntaxTree) -> [SyntaxTree];
	get_flow_argtype(st : SyntaxTree) -> SyntaxTree;
	get_flow_exp(st : SyntaxTree) -> SyntaxTree;
	get_flow_exp0(st : SyntaxTree) -> SyntaxTree;
	get_flow_condexp(st : SyntaxTree) -> SyntaxTree;
	get_flow_exp1(st : SyntaxTree) -> SyntaxTree;
	get_flow_exp1_assign_s(st : SyntaxTree) -> [SyntaxTree];
	get_flow_elseExp_s(st : SyntaxTree) -> [SyntaxTree];
	get_flow_exp2(st : SyntaxTree) -> SyntaxTree;
	get_flow_pipeExp_s(st : SyntaxTree) -> [SyntaxTree];
	get_flow_exp3(st : SyntaxTree) -> SyntaxTree;
	get_flow_orExp_s(st : SyntaxTree) -> [SyntaxTree];
	get_flow_exp4(st : SyntaxTree) -> SyntaxTree;
	get_flow_andExp_s(st : SyntaxTree) -> [SyntaxTree];
	get_flow_exp5(st : SyntaxTree) -> SyntaxTree;
	get_flow_exp5_compare_s(st : SyntaxTree) -> [SyntaxTree];
	get_flow_comparisonOp(st : SyntaxTree) -> SyntaxTree;
	get_flow_exp6(st : SyntaxTree) -> SyntaxTree;
	get_flow_additiveExp_s(st : SyntaxTree) -> [SyntaxTree];
	get_flow_plusMinus(st : SyntaxTree) -> SyntaxTree;
	get_flow_term(st : SyntaxTree) -> SyntaxTree;
	get_flow_multiExp_s(st : SyntaxTree) -> [SyntaxTree];
	get_flow_multiOp(st : SyntaxTree) -> SyntaxTree;
	get_flow_maybeExp(st : SyntaxTree) -> SyntaxTree;
	get_flow_maybeOp_s(st : SyntaxTree) -> [SyntaxTree];
	get_flow_nonefactor(st : SyntaxTree) -> SyntaxTree;
	get_flow_factor(st : SyntaxTree) -> SyntaxTree;
	get_flow_argNames_s(st : SyntaxTree) -> [SyntaxTree];
	get_flow_argNames2_s(st : SyntaxTree) -> [SyntaxTree];
	get_flow_argName(st : SyntaxTree) -> SyntaxTree;
	get_flow_call(st : SyntaxTree) -> SyntaxTree;
	get_flow_postfix_s(st : SyntaxTree) -> [SyntaxTree];
	get_flow_args(st : SyntaxTree) -> SyntaxTree;
	get_flow_arglist_s(st : SyntaxTree) -> [SyntaxTree];
	get_flow_fields(st : SyntaxTree) -> SyntaxTree;
	get_flow_fields_tail_s(st : SyntaxTree) -> [SyntaxTree];
	get_flow_one_more_exp_s(st : SyntaxTree) -> [SyntaxTree];
	get_flow_trailingComma(st : SyntaxTree) -> SyntaxTree;
	get_flow_trailingComma_s(st : SyntaxTree) -> [SyntaxTree];
	get_flow_atom(st : SyntaxTree) -> SyntaxTree;
	get_flow_brace(st : SyntaxTree) -> SyntaxTree;
	get_flow_brace_exps_s(st : SyntaxTree) -> [SyntaxTree];
	get_flow_brace_exps_more_s(st : SyntaxTree) -> [SyntaxTree];
	get_flow_brace_semi_s(st : SyntaxTree) -> [SyntaxTree];
	get_flow_exps_s(st : SyntaxTree) -> [SyntaxTree];
	get_flow_exps2_s(st : SyntaxTree) -> [SyntaxTree];
	get_flow_keywords(st : SyntaxTree) -> SyntaxTree;
	get_flow_totype(st : SyntaxTree) -> SyntaxTree;
	get_flow_switch(st : SyntaxTree) -> SyntaxTree;
	get_flow_switchType_s(st : SyntaxTree) -> [SyntaxTree];
	get_flow_defaultOrNamedCase_s(st : SyntaxTree) -> [SyntaxTree];
	get_flow_names_s(st : SyntaxTree) -> [SyntaxTree];
	get_flow_names_more_s(st : SyntaxTree) -> [SyntaxTree];
	get_flow_number(st : SyntaxTree) -> SyntaxTree;
	get_flow_number_float1(st : SyntaxTree) -> SyntaxTree;
	get_flow_number_float2(st : SyntaxTree) -> SyntaxTree;
	get_flow_int(st : SyntaxTree) -> SyntaxTree;
	get_flow_int_s(st : SyntaxTree) -> [SyntaxTree];
	get_flow_id(st : SyntaxTree) -> SyntaxTree;
	get_flow_letterOrDigit__s(st : SyntaxTree) -> [SyntaxTree];
	get_flow_letter_(st : SyntaxTree) -> SyntaxTree;
	get_flow_digit_(st : SyntaxTree) -> SyntaxTree;
	get_flow_digit__s(st : SyntaxTree) -> [SyntaxTree];
	get_flow_hexdigit_(st : SyntaxTree) -> SyntaxTree;
	get_flow_hexdigit__s(st : SyntaxTree) -> [SyntaxTree];
	get_flow_onechar__s(st : SyntaxTree) -> [SyntaxTree];
	get_flow_escapedchar_(st : SyntaxTree) -> SyntaxTree;
	get_flow_char_(st : SyntaxTree) -> SyntaxTree;
	get_flow_string(st : SyntaxTree) -> SyntaxTree;
	get_flow_stringinclude(st : SyntaxTree) -> SyntaxTree;
	get_flow_frenchstring(st : SyntaxTree) -> SyntaxTree;
	get_flow_path(st : SyntaxTree) -> SyntaxTree;
	get_flow_path_more_s(st : SyntaxTree) -> [SyntaxTree];
	get_flow_singlestring_s(st : SyntaxTree) -> [SyntaxTree];
	get_flow_ws(st : SyntaxTree) -> SyntaxTree;
	get_flow_s(st : SyntaxTree) -> SyntaxTree;
	get_flow_nonspace__s(st : SyntaxTree) -> [SyntaxTree];
	get_flow_whitespace__s(st : SyntaxTree) -> [SyntaxTree];
	get_flow_comment(st : SyntaxTree) -> SyntaxTree;
	get_flow_restOfComment(st : SyntaxTree) -> SyntaxTree;
	get_flow_restOfComment2_s(st : SyntaxTree) -> [SyntaxTree];
	get_flow_restOfComment1_s(st : SyntaxTree) -> [SyntaxTree];
	get_flow_nonstarchar__s(st : SyntaxTree) -> [SyntaxTree];
	get_flow_nonlinebreakchar__s(st : SyntaxTree) -> [SyntaxTree];
	get_flow_lastLineComment_s(st : SyntaxTree) -> [SyntaxTree];
	get_flow_fields__auto123(st : SyntaxTree) -> SyntaxTree;
	get_flow_fields__auto123_s(st : SyntaxTree) -> [SyntaxTree];
	get_flow_frenchstring__auto124(st : SyntaxTree) -> SyntaxTree;
	get_flow_frenchstring__auto124_s(st : SyntaxTree) -> [SyntaxTree];

}

get_flow_import(st : SyntaxTree) -> SyntaxTree {
	if (st.choice == 0 && st.rule == st_importExport) {
		st.children[0][0];
	} else failSyntaxTree
}
get_flow_dynamicImport(st : SyntaxTree) -> SyntaxTree {
	if (st.choice == 1 && st.rule == st_importExport) {
		st.children[0][0];
	} else failSyntaxTree
}
get_flow_export(st : SyntaxTree) -> SyntaxTree {
	if (st.choice == 2 && st.rule == st_importExport) {
		st.children[0][0];
	} else failSyntaxTree
}
get_flow_forbid(st : SyntaxTree) -> SyntaxTree {
	if (st.choice == 3 && st.rule == st_importExport) {
		st.children[0][0];
	} else failSyntaxTree
}
get_flow_native(st : SyntaxTree) -> SyntaxTree {
	if (st.choice == 0 && st.rule == st_toplevelDeclaration) {
		st.children[0][0];
	} else failSyntaxTree
}
get_flow_name(st : SyntaxTree) -> SyntaxTree {
	if (st.choice == 0 && st.rule == st_native) {
		st.children[7][0];
	} else failSyntaxTree
}
get_flow_assign(st : SyntaxTree) -> SyntaxTree {
	if (st.choice == 1 && st.rule == st_toplevelDeclaration) {
		st.children[0][0];
	} else if (st.choice == 0 && st.rule == st_fields) {
		st.children[0][0];
	} else if (st.choice == 0 && st.rule == st_fields_tail) {
		st.children[1][0];
	} else failSyntaxTree
}
get_flow_union(st : SyntaxTree) -> SyntaxTree {
	if (st.choice == 2 && st.rule == st_toplevelDeclaration) {
		st.children[0][0];
	} else failSyntaxTree
}
get_flow_function(st : SyntaxTree) -> SyntaxTree {
	if (st.choice == 3 && st.rule == st_toplevelDeclaration) {
		st.children[0][0];
	} else failSyntaxTree
}
get_flow_function_args(st : SyntaxTree) -> SyntaxTree {
	if (st.choice == 0 && st.rule == st_function) {
		st.children[3][0];
	} else failSyntaxTree
}
get_flow_function_2(st : SyntaxTree) -> SyntaxTree {
	if (st.choice == 1 && st.rule == st_function_args) {
		st.children[2][0];
	} else failSyntaxTree
}
get_flow_typedecl(st : SyntaxTree) -> SyntaxTree {
	if (st.choice == 4 && st.rule == st_toplevelDeclaration) {
		st.children[0][0];
	} else failSyntaxTree
}
get_flow_vardecl(st : SyntaxTree) -> SyntaxTree {
	if (st.choice == 2 && st.rule == st_typedecl) {
		st.children[0][0];
	} else failSyntaxTree
}
get_flow_functiondecl(st : SyntaxTree) -> SyntaxTree {
	if (st.choice == 0 && st.rule == st_typedecl) {
		st.children[0][0];
	} else failSyntaxTree
}
get_flow_structdecl(st : SyntaxTree) -> SyntaxTree {
	if (st.choice == 1 && st.rule == st_typedecl) {
		st.children[0][0];
	} else failSyntaxTree
}
get_flow_returnType(st : SyntaxTree) -> SyntaxTree {
	if (st.choice == 0 && st.rule == st_function_2) {
		st.children[0][0];
	} else if (st.choice == 0 && st.rule == st_functiondecl) {
		st.children[6][0];
	} else failSyntaxTree
}
get_flow_brace_or_semi(st : SyntaxTree) -> SyntaxTree {
	if (st.choice == 0 && st.rule == st_function_2) {
		st.children[1][0];
	} else failSyntaxTree
}
get_flow_funarg2(st : SyntaxTree) -> SyntaxTree {
	if (st.choice == 0 && st.rule == st_funargs2) {
		st.children[0][0];
	} else if (st.choice == 0 && st.rule == st_funargs2_more) {
		st.children[1][0];
	} else failSyntaxTree
}
get_flow_funarg2_arg(st : SyntaxTree) -> SyntaxTree {
	if (st.choice == 0 && st.rule == st_funarg2) {
		st.children[1][0];
	} else failSyntaxTree
}
get_flow_funarg(st : SyntaxTree) -> SyntaxTree {
	if (st.choice == 0 && st.rule == st_funargs) {
		st.children[0][0];
	} else if (st.choice == 0 && st.rule == st_funargs_more) {
		st.children[1][0];
	} else failSyntaxTree
}
get_flow_colontype(st : SyntaxTree) -> SyntaxTree {
	if (st.choice == 0 && st.rule == st_argtype) {
		st.children[2][0];
	} else failSyntaxTree
}
get_flow_typenames(st : SyntaxTree) -> SyntaxTree {
	if (st.choice == 0 && st.rule == st_union) {
		st.children[5][0];
	} else failSyntaxTree
}
get_flow_typename(st : SyntaxTree) -> SyntaxTree {
	if (st.choice == 0 && st.rule == st_typenames) {
		st.children[0][0];
	} else if (st.choice == 0 && st.rule == st_typenames2) {
		st.children[1][0];
	} else if (st.choice == 12 && st.rule == st_type) {
		st.children[0][0];
	} else failSyntaxTree
}
get_flow_types(st : SyntaxTree) -> SyntaxTree {
	if (st.choice == 0 && st.rule == st_typelist) {
		st.children[1][0];
	} else failSyntaxTree
}
get_flow_type(st : SyntaxTree) -> SyntaxTree {
	if (st.choice == 0 && st.rule == st_native) {
		st.children[5][0];
	} else if (st.choice == 0 && st.rule == st_vardecl) {
		st.children[3][0];
	} else if (st.choice == 0 && st.rule == st_returnType) {
		st.children[1][0];
	} else if (st.choice == 1 && st.rule == st_funarg2_arg) {
		st.children[0][0];
	} else if (st.choice == 0 && st.rule == st_colontype) {
		st.children[1][0];
	} else if (st.choice == 0 && st.rule == st_types) {
		st.children[0][0];
	} else if (st.choice == 0 && st.rule == st_types2) {
		st.children[1][0];
	} else if (st.choice == 0 && st.rule == st_type) {
		st.children[1][0];
	} else if (st.choice == 2 && st.rule == st_type) {
		st.children[1][0];
	} else if (st.choice == 11 && st.rule == st_type) {
		st.children[1][0];
	} else if (st.choice == 1 && st.rule == st_type_fn_par) {
		st.children[0][0];
	} else if (st.choice == 0 && st.rule == st_type_rettype) {
		st.children[1][0];
	} else if (st.choice == 1 && st.rule == st_argtype) {
		st.children[0][0];
	} else if (st.choice == 5 && st.rule == st_keywords) {
		st.children[4][0];
	} else if (st.choice == 0 && st.rule == st_totype) {
		st.children[0][0];
	} else if (st.choice == 0 && st.rule == st_switchType) {
		st.children[1][0];
	} else failSyntaxTree
}
get_flow_type_fn_par(st : SyntaxTree) -> SyntaxTree {
	if (st.choice == 1 && st.rule == st_type) {
		st.children[1][0];
	} else failSyntaxTree
}
get_flow_type_rettype(st : SyntaxTree) -> SyntaxTree {
	if (st.choice == 0 && st.rule == st_type_fn_par) {
		st.children[3][0];
	} else failSyntaxTree
}
get_flow_argtype(st : SyntaxTree) -> SyntaxTree {
	if (st.choice == 0 && st.rule == st_argtypes) {
		st.children[0][0];
	} else if (st.choice == 0 && st.rule == st_argtypes2) {
		st.children[1][0];
	} else failSyntaxTree
}
get_flow_exp(st : SyntaxTree) -> SyntaxTree {
	if (st.choice == 0 && st.rule == st_assign) {
		st.children[3][0];
	} else if (st.choice == 1 && st.rule == st_function_2) {
		st.children[0][0];
	} else if (st.choice == 0 && st.rule == st_assignExp) {
		st.children[1][0];
	} else if (st.choice == 0 && st.rule == st_exp0) {
		st.children[4][0];
	} else if (st.choice == 1 && st.rule == st_exp0) {
		st.children[4][0];
	} else if (st.choice == 2 && st.rule == st_exp0) {
		st.children[5][0];
	} else if (st.choice == 0 && st.rule == st_condexp) {
		st.children[0][0];
	} else if (st.choice == 0 && st.rule == st_exp1_assign) {
		st.children[1][0];
	} else if (st.choice == 0 && st.rule == st_elseExp) {
		st.children[1][0];
	} else if (st.choice == 2 && st.rule == st_factor) {
		st.children[5][0];
	} else if (st.choice == 2 && st.rule == st_postfix) {
		st.children[1][0];
	} else if (st.choice == 0 && st.rule == st_arglist) {
		st.children[0][0];
	} else if (st.choice == 0 && st.rule == st_one_more_exp) {
		st.children[1][0];
	} else if (st.choice == 4 && st.rule == st_atom) {
		st.children[1][0];
	} else if (st.choice == 0 && st.rule == st_brace_exps) {
		st.children[0][0];
	} else if (st.choice == 0 && st.rule == st_brace_exps_more) {
		st.children[1][0];
	} else if (st.choice == 0 && st.rule == st_exps) {
		st.children[0][0];
	} else if (st.choice == 0 && st.rule == st_exps2) {
		st.children[1][0];
	} else if (st.choice == 2 && st.rule == st_keywords) {
		st.children[4][0];
	} else if (st.choice == 3 && st.rule == st_keywords) {
		st.children[1][0];
	} else if (st.choice == 6 && st.rule == st_keywords) {
		st.children[5][0];
	} else if (st.choice == 7 && st.rule == st_keywords) {
		st.children[5][0];
	} else if (st.choice == 0 && st.rule == st_defaultOrNamedCase) {
		st.children[2][0];
	} else if (st.choice == 1 && st.rule == st_defaultOrNamedCase) {
		st.children[6][0];
	} else failSyntaxTree
}
get_flow_exp0(st : SyntaxTree) -> SyntaxTree {
	if (st.choice == 0 && st.rule == st_exp) {
		st.children[1][0];
	} else if (st.choice == 1 && st.rule == st_exp) {
		st.children[0][0];
	} else failSyntaxTree
}
get_flow_condexp(st : SyntaxTree) -> SyntaxTree {
	if (st.choice == 1 && st.rule == st_exp0) {
		st.children[2][0];
	} else if (st.choice == 2 && st.rule == st_keywords) {
		st.children[2][0];
	} else failSyntaxTree
}
get_flow_exp1(st : SyntaxTree) -> SyntaxTree {
	if (st.choice == 3 && st.rule == st_exp0) {
		st.children[0][0];
	} else failSyntaxTree
}
get_flow_exp2(st : SyntaxTree) -> SyntaxTree {
	if (st.choice == 0 && st.rule == st_exp1) {
		st.children[0][0];
	} else if (st.choice == 5 && st.rule == st_keywords) {
		st.children[2][0];
	} else if (st.choice == 0 && st.rule == st_switch) {
		st.children[2][0];
	} else failSyntaxTree
}
get_flow_exp3(st : SyntaxTree) -> SyntaxTree {
	if (st.choice == 0 && st.rule == st_exp2) {
		st.children[0][0];
	} else if (st.choice == 0 && st.rule == st_pipeExp) {
		st.children[1][0];
	} else failSyntaxTree
}
get_flow_exp4(st : SyntaxTree) -> SyntaxTree {
	if (st.choice == 0 && st.rule == st_exp3) {
		st.children[0][0];
	} else if (st.choice == 0 && st.rule == st_orExp) {
		st.children[1][0];
	} else failSyntaxTree
}
get_flow_exp5(st : SyntaxTree) -> SyntaxTree {
	if (st.choice == 0 && st.rule == st_exp4) {
		st.children[0][0];
	} else if (st.choice == 0 && st.rule == st_andExp) {
		st.children[1][0];
	} else failSyntaxTree
}
get_flow_comparisonOp(st : SyntaxTree) -> SyntaxTree {
	if (st.choice == 0 && st.rule == st_exp5_compare) {
		st.children[0][0];
	} else failSyntaxTree
}
get_flow_exp6(st : SyntaxTree) -> SyntaxTree {
	if (st.choice == 0 && st.rule == st_exp5) {
		st.children[0][0];
	} else if (st.choice == 0 && st.rule == st_exp5_compare) {
		st.children[2][0];
	} else failSyntaxTree
}
get_flow_plusMinus(st : SyntaxTree) -> SyntaxTree {
	if (st.choice == 0 && st.rule == st_additiveExp) {
		st.children[0][0];
	} else failSyntaxTree
}
get_flow_term(st : SyntaxTree) -> SyntaxTree {
	if (st.choice == 0 && st.rule == st_exp6) {
		st.children[0][0];
	} else if (st.choice == 0 && st.rule == st_additiveExp) {
		st.children[2][0];
	} else failSyntaxTree
}
get_flow_multiOp(st : SyntaxTree) -> SyntaxTree {
	if (st.choice == 0 && st.rule == st_multiExp) {
		st.children[0][0];
	} else failSyntaxTree
}
get_flow_maybeExp(st : SyntaxTree) -> SyntaxTree {
	if (st.choice == 0 && st.rule == st_term) {
		st.children[0][0];
	} else if (st.choice == 0 && st.rule == st_multiExp) {
		st.children[2][0];
	} else failSyntaxTree
}
get_flow_nonefactor(st : SyntaxTree) -> SyntaxTree {
	if (st.choice == 0 && st.rule == st_maybeOp) {
		st.children[3][0];
	} else failSyntaxTree
}
get_flow_factor(st : SyntaxTree) -> SyntaxTree {
	if (st.choice == 0 && st.rule == st_maybeExp) {
		st.children[0][0];
	} else if (st.choice == 0 && st.rule == st_maybeOp) {
		st.children[1][0];
	} else if (st.choice == 0 && st.rule == st_nonefactor) {
		st.children[0][0];
	} else if (st.choice == 0 && st.rule == st_factor) {
		st.children[1][0];
	} else if (st.choice == 1 && st.rule == st_factor) {
		st.children[1][0];
	} else failSyntaxTree
}
get_flow_argName(st : SyntaxTree) -> SyntaxTree {
	if (st.choice == 0 && st.rule == st_argNames) {
		st.children[0][0];
	} else if (st.choice == 0 && st.rule == st_argNames2) {
		st.children[1][0];
	} else failSyntaxTree
}
get_flow_call(st : SyntaxTree) -> SyntaxTree {
	if (st.choice == 3 && st.rule == st_factor) {
		st.children[0][0];
	} else if (st.choice == 3 && st.rule == st_postfix) {
		st.children[1][0];
	} else failSyntaxTree
}
get_flow_args(st : SyntaxTree) -> SyntaxTree {
	if (st.choice == 0 && st.rule == st_postfix) {
		st.children[0][0];
	} else failSyntaxTree
}
get_flow_fields(st : SyntaxTree) -> SyntaxTree {
	if (st.choice == 3 && st.rule == st_postfix) {
		st.children[3][0];
	} else failSyntaxTree
}
get_flow_trailingComma(st : SyntaxTree) -> SyntaxTree {
	if (get_flow_fields__auto123(st).choice == 0) {
		get_flow_fields__auto123(st).children[0][0];
	} else failSyntaxTree
}
get_flow_atom(st : SyntaxTree) -> SyntaxTree {
	if (st.choice == 2 && st.rule == st_exp0) {
		st.children[0][0];
	} else if (st.choice == 0 && st.rule == st_call) {
		st.children[0][0];
	} else if (st.choice == 8 && st.rule == st_atom) {
		st.children[1][0];
	} else if (st.choice == 9 && st.rule == st_atom) {
		st.children[1][0];
	} else failSyntaxTree
}
get_flow_brace(st : SyntaxTree) -> SyntaxTree {
	if (st.choice == 0 && st.rule == st_brace_or_semi) {
		st.children[0][0];
	} else if (st.choice == 6 && st.rule == st_atom) {
		st.children[0][0];
	} else failSyntaxTree
}
get_flow_keywords(st : SyntaxTree) -> SyntaxTree {
	if (st.choice == 0 && st.rule == st_atom) {
		st.children[0][0];
	} else failSyntaxTree
}
get_flow_totype(st : SyntaxTree) -> SyntaxTree {
	if (st.choice == 5 && st.rule == st_keywords) {
		st.children[6][0];
	} else failSyntaxTree
}
get_flow_switch(st : SyntaxTree) -> SyntaxTree {
	if (st.choice == 4 && st.rule == st_keywords) {
		st.children[0][0];
	} else failSyntaxTree
}
get_flow_number(st : SyntaxTree) -> SyntaxTree {
	if (st.choice == 2 && st.rule == st_atom) {
		st.children[0][0];
	} else failSyntaxTree
}
get_flow_number_float1(st : SyntaxTree) -> SyntaxTree {
	if (st.choice == 1 && st.rule == st_number) {
		st.children[0][0];
	} else failSyntaxTree
}
get_flow_number_float2(st : SyntaxTree) -> SyntaxTree {
	if (st.choice == 2 && st.rule == st_number) {
		st.children[0][0];
	} else failSyntaxTree
}
get_flow_int(st : SyntaxTree) -> SyntaxTree {
	if (st.choice == 3 && st.rule == st_number) {
		st.children[0][0];
	} else if (st.choice == 0 && st.rule == st_number_float1) {
		st.children[0][0];
	} else if (st.choice == 0 && st.rule == st_number_float2) {
		st.children[0][0];
	} else failSyntaxTree
}
get_flow_id(st : SyntaxTree) -> SyntaxTree {
	if (st.choice == 0 && st.rule == st_native) {
		st.children[1][0];
	} else if (st.choice == 0 && st.rule == st_name) {
		st.children[0][0];
	} else if (st.choice == 0 && st.rule == st_dot_name) {
		st.children[0][0];
	} else if (st.choice == 0 && st.rule == st_assign) {
		st.children[0][0];
	} else if (st.choice == 0 && st.rule == st_union) {
		st.children[0][0];
	} else if (st.choice == 0 && st.rule == st_function) {
		st.children[0][0];
	} else if (st.choice == 0 && st.rule == st_vardecl) {
		st.children[0][0];
	} else if (st.choice == 0 && st.rule == st_functiondecl) {
		st.children[0][0];
	} else if (st.choice == 0 && st.rule == st_structdecl) {
		st.children[0][0];
	} else if (st.choice == 0 && st.rule == st_funarg2_arg) {
		st.children[0][0];
	} else if (st.choice == 0 && st.rule == st_funarg) {
		st.children[1][0];
	} else if (st.choice == 0 && st.rule == st_typename) {
		st.children[0][0];
	} else if (st.choice == 0 && st.rule == st_argtype) {
		st.children[0][0];
	} else if (st.choice == 0 && st.rule == st_exp0) {
		st.children[0][0];
	} else if (st.choice == 2 && st.rule == st_exp0) {
		st.children[2][0];
	} else if (st.choice == 0 && st.rule == st_argName) {
		st.children[0][0];
	} else if (st.choice == 1 && st.rule == st_postfix) {
		st.children[0][0];
	} else if (st.choice == 1 && st.rule == st_atom) {
		st.children[0][0];
	} else if (st.choice == 7 && st.rule == st_keywords) {
		st.children[2][0];
	} else if (st.choice == 1 && st.rule == st_defaultOrNamedCase) {
		st.children[0][0];
	} else if (st.choice == 0 && st.rule == st_names) {
		st.children[0][0];
	} else if (st.choice == 0 && st.rule == st_names_more) {
		st.children[1][0];
	} else if (st.choice == 0 && st.rule == st_path) {
		st.children[0][0];
	} else if (st.choice == 0 && st.rule == st_path_more) {
		st.children[0][0];
	} else failSyntaxTree
}
get_flow_letter_(st : SyntaxTree) -> SyntaxTree {
	if (st.choice == 0 && st.rule == st_id) {
		st.children[0][0];
	} else failSyntaxTree
}
get_flow_digit_(st : SyntaxTree) -> SyntaxTree {
	if (st.choice == 0 && st.rule == st_hexdigit_) {
		st.children[0][0];
	} else failSyntaxTree
}
get_flow_hexdigit_(st : SyntaxTree) -> SyntaxTree {
	if (st.choice == 0 && st.rule == st_onechar_) {
		st.children[0][0];
	} else if (st.choice == 0 && st.rule == st_onechar_) {
		st.children[1][0];
	} else if (st.choice == 0 && st.rule == st_onechar_) {
		st.children[2][0];
	} else if (st.choice == 0 && st.rule == st_onechar_) {
		st.children[3][0];
	} else if (st.choice == 1 && st.rule == st_onechar_) {
		st.children[0][0];
	} else if (st.choice == 1 && st.rule == st_onechar_) {
		st.children[1][0];
	} else if (st.choice == 1 && st.rule == st_onechar_) {
		st.children[2][0];
	} else if (st.choice == 1 && st.rule == st_onechar_) {
		st.children[3][0];
	} else if (st.choice == 2 && st.rule == st_onechar_) {
		st.children[0][0];
	} else if (st.choice == 2 && st.rule == st_onechar_) {
		st.children[1][0];
	} else failSyntaxTree
}
get_flow_escapedchar_(st : SyntaxTree) -> SyntaxTree {
	if (st.choice == 3 && st.rule == st_onechar_) {
		st.children[0][0];
	} else failSyntaxTree
}
get_flow_char_(st : SyntaxTree) -> SyntaxTree {
	if (st.choice == 4 && st.rule == st_onechar_) {
		st.children[0][0];
	} else if (st.choice == 0 && st.rule == st_nonspace_) {
		st.children[0][0];
	} else if (st.choice == 0 && st.rule == st_nonstarchar_) {
		st.children[0][0];
	} else if (st.choice == 0 && st.rule == st_nonlinebreakchar_) {
		st.children[0][0];
	} else if (get_flow_frenchstring__auto124(st).choice == 0) {
		get_flow_frenchstring__auto124(st).children[0][0];
	} else failSyntaxTree
}
get_flow_string(st : SyntaxTree) -> SyntaxTree {
	if (st.choice == 3 && st.rule == st_atom) {
		st.children[0][0];
	} else failSyntaxTree
}
get_flow_stringinclude(st : SyntaxTree) -> SyntaxTree {
	if (st.choice == 0 && st.rule == st_string) {
		st.children[1][0];
	} else failSyntaxTree
}
get_flow_frenchstring(st : SyntaxTree) -> SyntaxTree {
	if (st.choice == 2 && st.rule == st_string) {
		st.children[0][0];
	} else failSyntaxTree
}
get_flow_path(st : SyntaxTree) -> SyntaxTree {
	if (st.choice == 0 && st.rule == st_import) {
		st.children[1][0];
	} else if (st.choice == 0 && st.rule == st_dynamicImport) {
		st.children[1][0];
	} else if (st.choice == 0 && st.rule == st_forbid) {
		st.children[1][0];
	} else if (st.choice == 6 && st.rule == st_keywords) {
		st.children[2][0];
	} else failSyntaxTree
}
get_flow_ws(st : SyntaxTree) -> SyntaxTree {
	if (st.choice == 0 && st.rule == st_flow) {
		st.children[0][0];
	} else if (st.choice == 0 && st.rule == st_import) {
		st.children[2][0];
	} else if (st.choice == 0 && st.rule == st_import) {
		st.children[3][0];
	} else if (st.choice == 0 && st.rule == st_dynamicImport) {
		st.children[2][0];
	} else if (st.choice == 0 && st.rule == st_dynamicImport) {
		st.children[3][0];
	} else if (st.choice == 0 && st.rule == st_export) {
		st.children[0][0];
	} else if (st.choice == 0 && st.rule == st_export) {
		st.children[1][0];
	} else if (st.choice == 0 && st.rule == st_export) {
		st.children[3][0];
	} else if (st.choice == 0 && st.rule == st_forbid) {
		st.children[2][0];
	} else if (st.choice == 0 && st.rule == st_forbid) {
		st.children[3][0];
	} else if (st.choice == 0 && st.rule == st_native) {
		st.children[2][0];
	} else if (st.choice == 0 && st.rule == st_native) {
		st.children[3][0];
	} else if (st.choice == 0 && st.rule == st_native) {
		st.children[6][0];
	} else if (st.choice == 0 && st.rule == st_native) {
		st.children[8][0];
	} else if (st.choice == 0 && st.rule == st_native) {
		st.children[9][0];
	} else if (st.choice == 0 && st.rule == st_native_io) {
		st.children[0][0];
	} else if (st.choice == 0 && st.rule == st_assign) {
		st.children[1][0];
	} else if (st.choice == 0 && st.rule == st_assign) {
		st.children[2][0];
	} else if (st.choice == 0 && st.rule == st_assign) {
		st.children[4][0];
	} else if (st.choice == 0 && st.rule == st_union) {
		st.children[1][0];
	} else if (st.choice == 0 && st.rule == st_union) {
		st.children[3][0];
	} else if (st.choice == 0 && st.rule == st_union) {
		st.children[4][0];
	} else if (st.choice == 0 && st.rule == st_union) {
		st.children[6][0];
	} else if (st.choice == 0 && st.rule == st_function) {
		st.children[1][0];
	} else if (st.choice == 0 && st.rule == st_function) {
		st.children[2][0];
	} else if (st.choice == 0 && st.rule == st_function_args) {
		st.children[1][0];
	} else if (st.choice == 0 && st.rule == st_function_args) {
		st.children[3][0];
	} else if (st.choice == 1 && st.rule == st_function_args) {
		st.children[1][0];
	} else if (st.choice == 1 && st.rule == st_function_2) {
		st.children[1][0];
	} else if (st.choice == 0 && st.rule == st_vardecl) {
		st.children[1][0];
	} else if (st.choice == 0 && st.rule == st_vardecl) {
		st.children[2][0];
	} else if (st.choice == 0 && st.rule == st_vardecl) {
		st.children[5][0];
	} else if (st.choice == 0 && st.rule == st_assignExp) {
		st.children[0][0];
	} else if (st.choice == 0 && st.rule == st_functiondecl) {
		st.children[1][0];
	} else if (st.choice == 0 && st.rule == st_functiondecl) {
		st.children[2][0];
	} else if (st.choice == 0 && st.rule == st_functiondecl) {
		st.children[3][0];
	} else if (st.choice == 0 && st.rule == st_functiondecl) {
		st.children[5][0];
	} else if (st.choice == 0 && st.rule == st_functiondecl) {
		st.children[7][0];
	} else if (st.choice == 0 && st.rule == st_structdecl) {
		st.children[1][0];
	} else if (st.choice == 0 && st.rule == st_structdecl) {
		st.children[2][0];
	} else if (st.choice == 0 && st.rule == st_structdecl) {
		st.children[3][0];
	} else if (st.choice == 0 && st.rule == st_structdecl) {
		st.children[5][0];
	} else if (st.choice == 0 && st.rule == st_structdecl) {
		st.children[6][0];
	} else if (st.choice == 0 && st.rule == st_returnType) {
		st.children[0][0];
	} else if (st.choice == 0 && st.rule == st_brace_or_semi) {
		st.children[1][0];
	} else if (st.choice == 0 && st.rule == st_funargs2_more) {
		st.children[0][0];
	} else if (st.choice == 0 && st.rule == st_funarg2_arg) {
		st.children[1][0];
	} else if (st.choice == 0 && st.rule == st_funargs_more) {
		st.children[0][0];
	} else if (st.choice == 0 && st.rule == st_funarg) {
		st.children[2][0];
	} else if (st.choice == 0 && st.rule == st_colontype) {
		st.children[0][0];
	} else if (st.choice == 0 && st.rule == st_typenames2) {
		st.children[0][0];
	} else if (st.choice == 0 && st.rule == st_typename) {
		st.children[1][0];
	} else if (st.choice == 0 && st.rule == st_typelist) {
		st.children[0][0];
	} else if (st.choice == 0 && st.rule == st_typelist) {
		st.children[2][0];
	} else if (st.choice == 0 && st.rule == st_types2) {
		st.children[0][0];
	} else if (st.choice == 0 && st.rule == st_type) {
		st.children[0][0];
	} else if (st.choice == 0 && st.rule == st_type) {
		st.children[2][0];
	} else if (st.choice == 0 && st.rule == st_type) {
		st.children[3][0];
	} else if (st.choice == 1 && st.rule == st_type) {
		st.children[0][0];
	} else if (st.choice == 2 && st.rule == st_type) {
		st.children[0][0];
	} else if (st.choice == 3 && st.rule == st_type) {
		st.children[0][0];
	} else if (st.choice == 4 && st.rule == st_type) {
		st.children[0][0];
	} else if (st.choice == 5 && st.rule == st_type) {
		st.children[0][0];
	} else if (st.choice == 6 && st.rule == st_type) {
		st.children[0][0];
	} else if (st.choice == 7 && st.rule == st_type) {
		st.children[0][0];
	} else if (st.choice == 8 && st.rule == st_type) {
		st.children[0][0];
	} else if (st.choice == 9 && st.rule == st_type) {
		st.children[0][0];
	} else if (st.choice == 10 && st.rule == st_type) {
		st.children[0][0];
	} else if (st.choice == 11 && st.rule == st_type) {
		st.children[0][0];
	} else if (st.choice == 12 && st.rule == st_type) {
		st.children[1][0];
	} else if (st.choice == 0 && st.rule == st_type_fn_par) {
		st.children[2][0];
	} else if (st.choice == 1 && st.rule == st_type_fn_par) {
		st.children[1][0];
	} else if (st.choice == 0 && st.rule == st_type_rettype) {
		st.children[0][0];
	} else if (st.choice == 0 && st.rule == st_argtypes2) {
		st.children[0][0];
	} else if (st.choice == 0 && st.rule == st_argtype) {
		st.children[1][0];
	} else if (st.choice == 0 && st.rule == st_exp) {
		st.children[0][0];
	} else if (st.choice == 0 && st.rule == st_exp0) {
		st.children[1][0];
	} else if (st.choice == 0 && st.rule == st_exp0) {
		st.children[3][0];
	} else if (st.choice == 1 && st.rule == st_exp0) {
		st.children[0][0];
	} else if (st.choice == 1 && st.rule == st_exp0) {
		st.children[1][0];
	} else if (st.choice == 1 && st.rule == st_exp0) {
		st.children[3][0];
	} else if (st.choice == 2 && st.rule == st_exp0) {
		st.children[1][0];
	} else if (st.choice == 2 && st.rule == st_exp0) {
		st.children[3][0];
	} else if (st.choice == 2 && st.rule == st_exp0) {
		st.children[4][0];
	} else if (st.choice == 0 && st.rule == st_exp1_assign) {
		st.children[0][0];
	} else if (st.choice == 0 && st.rule == st_elseExp) {
		st.children[0][0];
	} else if (st.choice == 0 && st.rule == st_pipeExp) {
		st.children[0][0];
	} else if (st.choice == 0 && st.rule == st_orExp) {
		st.children[0][0];
	} else if (st.choice == 0 && st.rule == st_andExp) {
		st.children[0][0];
	} else if (st.choice == 0 && st.rule == st_exp5_compare) {
		st.children[1][0];
	} else if (st.choice == 0 && st.rule == st_additiveExp) {
		st.children[1][0];
	} else if (st.choice == 0 && st.rule == st_multiExp) {
		st.children[1][0];
	} else if (st.choice == 0 && st.rule == st_maybeOp) {
		st.children[0][0];
	} else if (st.choice == 0 && st.rule == st_maybeOp) {
		st.children[2][0];
	} else if (st.choice == 0 && st.rule == st_factor) {
		st.children[0][0];
	} else if (st.choice == 1 && st.rule == st_factor) {
		st.children[0][0];
	} else if (st.choice == 2 && st.rule == st_factor) {
		st.children[0][0];
	} else if (st.choice == 2 && st.rule == st_factor) {
		st.children[3][0];
	} else if (st.choice == 2 && st.rule == st_factor) {
		st.children[4][0];
	} else if (st.choice == 0 && st.rule == st_argNames2) {
		st.children[0][0];
	} else if (st.choice == 0 && st.rule == st_argName) {
		st.children[1][0];
	} else if (st.choice == 1 && st.rule == st_postfix) {
		st.children[1][0];
	} else if (st.choice == 2 && st.rule == st_postfix) {
		st.children[0][0];
	} else if (st.choice == 2 && st.rule == st_postfix) {
		st.children[2][0];
	} else if (st.choice == 3 && st.rule == st_postfix) {
		st.children[0][0];
	} else if (st.choice == 3 && st.rule == st_postfix) {
		st.children[4][0];
	} else if (st.choice == 0 && st.rule == st_args) {
		st.children[0][0];
	} else if (st.choice == 0 && st.rule == st_args) {
		st.children[2][0];
	} else if (st.choice == 0 && st.rule == st_args) {
		st.children[3][0];
	} else if (st.choice == 0 && st.rule == st_fields_tail) {
		st.children[0][0];
	} else if (st.choice == 0 && st.rule == st_one_more_exp) {
		st.children[0][0];
	} else if (st.choice == 0 && st.rule == st_trailingComma) {
		st.children[0][0];
	} else if (st.choice == 1 && st.rule == st_atom) {
		st.children[1][0];
	} else if (st.choice == 2 && st.rule == st_atom) {
		st.children[1][0];
	} else if (st.choice == 4 && st.rule == st_atom) {
		st.children[0][0];
	} else if (st.choice == 4 && st.rule == st_atom) {
		st.children[2][0];
	} else if (st.choice == 5 && st.rule == st_atom) {
		st.children[0][0];
	} else if (st.choice == 6 && st.rule == st_atom) {
		st.children[1][0];
	} else if (st.choice == 7 && st.rule == st_atom) {
		st.children[0][0];
	} else if (st.choice == 7 && st.rule == st_atom) {
		st.children[3][0];
	} else if (st.choice == 8 && st.rule == st_atom) {
		st.children[0][0];
	} else if (st.choice == 9 && st.rule == st_atom) {
		st.children[0][0];
	} else if (st.choice == 0 && st.rule == st_brace) {
		st.children[0][0];
	} else if (st.choice == 0 && st.rule == st_brace_semi) {
		st.children[0][0];
	} else if (st.choice == 0 && st.rule == st_exps2) {
		st.children[0][0];
	} else if (st.choice == 0 && st.rule == st_keywords) {
		st.children[0][0];
	} else if (st.choice == 1 && st.rule == st_keywords) {
		st.children[0][0];
	} else if (st.choice == 2 && st.rule == st_keywords) {
		st.children[0][0];
	} else if (st.choice == 2 && st.rule == st_keywords) {
		st.children[1][0];
	} else if (st.choice == 2 && st.rule == st_keywords) {
		st.children[3][0];
	} else if (st.choice == 3 && st.rule == st_keywords) {
		st.children[0][0];
	} else if (st.choice == 5 && st.rule == st_keywords) {
		st.children[0][0];
	} else if (st.choice == 5 && st.rule == st_keywords) {
		st.children[1][0];
	} else if (st.choice == 5 && st.rule == st_keywords) {
		st.children[3][0];
	} else if (st.choice == 5 && st.rule == st_keywords) {
		st.children[5][0];
	} else if (st.choice == 5 && st.rule == st_keywords) {
		st.children[7][0];
	} else if (st.choice == 6 && st.rule == st_keywords) {
		st.children[0][0];
	} else if (st.choice == 6 && st.rule == st_keywords) {
		st.children[1][0];
	} else if (st.choice == 6 && st.rule == st_keywords) {
		st.children[3][0];
	} else if (st.choice == 6 && st.rule == st_keywords) {
		st.children[4][0];
	} else if (st.choice == 6 && st.rule == st_keywords) {
		st.children[6][0];
	} else if (st.choice == 7 && st.rule == st_keywords) {
		st.children[0][0];
	} else if (st.choice == 7 && st.rule == st_keywords) {
		st.children[1][0];
	} else if (st.choice == 7 && st.rule == st_keywords) {
		st.children[3][0];
	} else if (st.choice == 7 && st.rule == st_keywords) {
		st.children[4][0];
	} else if (st.choice == 7 && st.rule == st_keywords) {
		st.children[6][0];
	} else if (st.choice == 0 && st.rule == st_switch) {
		st.children[0][0];
	} else if (st.choice == 0 && st.rule == st_switch) {
		st.children[1][0];
	} else if (st.choice == 0 && st.rule == st_switch) {
		st.children[4][0];
	} else if (st.choice == 0 && st.rule == st_switch) {
		st.children[5][0];
	} else if (st.choice == 0 && st.rule == st_switch) {
		st.children[7][0];
	} else if (st.choice == 0 && st.rule == st_switchType) {
		st.children[0][0];
	} else if (st.choice == 0 && st.rule == st_defaultOrNamedCase) {
		st.children[0][0];
	} else if (st.choice == 0 && st.rule == st_defaultOrNamedCase) {
		st.children[1][0];
	} else if (st.choice == 0 && st.rule == st_defaultOrNamedCase) {
		st.children[3][0];
	} else if (st.choice == 1 && st.rule == st_defaultOrNamedCase) {
		st.children[1][0];
	} else if (st.choice == 1 && st.rule == st_defaultOrNamedCase) {
		st.children[2][0];
	} else if (st.choice == 1 && st.rule == st_defaultOrNamedCase) {
		st.children[4][0];
	} else if (st.choice == 1 && st.rule == st_defaultOrNamedCase) {
		st.children[5][0];
	} else if (st.choice == 1 && st.rule == st_defaultOrNamedCase) {
		st.children[7][0];
	} else if (st.choice == 0 && st.rule == st_names) {
		st.children[1][0];
	} else if (st.choice == 0 && st.rule == st_names_more) {
		st.children[0][0];
	} else if (st.choice == 0 && st.rule == st_names_more) {
		st.children[2][0];
	} else if (st.choice == 0 && st.rule == st_string) {
		st.children[2][0];
	} else if (st.choice == 2 && st.rule == st_string) {
		st.children[1][0];
	} else if (st.choice == 0 && st.rule == st_singlestring) {
		st.children[1][0];
	} else if (get_flow_fields__auto123(st).choice == 0) {
		get_flow_fields__auto123(st).children[1][0];
	} else failSyntaxTree
}
get_flow_s(st : SyntaxTree) -> SyntaxTree {
	if (st.choice == 0 && st.rule == st_import) {
		st.children[0][0];
	} else if (st.choice == 0 && st.rule == st_dynamicImport) {
		st.children[0][0];
	} else if (st.choice == 0 && st.rule == st_forbid) {
		st.children[0][0];
	} else if (st.choice == 0 && st.rule == st_native) {
		st.children[0][0];
	} else if (st.choice == 0 && st.rule == st_funarg_mutable) {
		st.children[0][0];
	} else if (st.choice == 3 && st.rule == st_postfix) {
		st.children[2][0];
	} else if (st.choice == 0 && st.rule == st_string) {
		st.children[0][0];
	} else failSyntaxTree
}
get_flow_comment(st : SyntaxTree) -> SyntaxTree {
	if (st.choice == 3 && st.rule == st_whitespace_) {
		st.children[0][0];
	} else failSyntaxTree
}
get_flow_restOfComment(st : SyntaxTree) -> SyntaxTree {
	if (st.choice == 0 && st.rule == st_comment) {
		st.children[0][0];
	} else failSyntaxTree
}
get_flow_fields__auto123(st : SyntaxTree) -> SyntaxTree {
	failSyntaxTree
}
get_flow_frenchstring__auto124(st : SyntaxTree) -> SyntaxTree {
	failSyntaxTree
}

get_flow_importExport_s(st : SyntaxTree) -> [SyntaxTree] {
	if (st.choice == 0 && st.rule == st_flow) {
		st.children[1];
	} else []
}
get_flow_toplevelDeclaration_s(st : SyntaxTree) -> [SyntaxTree] {
	if (st.choice == 0 && st.rule == st_flow) {
		st.children[2];
	} else if (st.choice == 0 && st.rule == st_export) {
		st.children[2];
	} else []
}
get_flow_native_io_s(st : SyntaxTree) -> [SyntaxTree] {
	if (st.choice == 0 && st.rule == st_native) {
		st.children[4];
	} else []
}
get_flow_dot_name_s(st : SyntaxTree) -> [SyntaxTree] {
	if (st.choice == 0 && st.rule == st_name) {
		st.children[1];
	} else []
}
get_flow_assignExp_s(st : SyntaxTree) -> [SyntaxTree] {
	if (st.choice == 0 && st.rule == st_vardecl) {
		st.children[4];
	} else []
}
get_flow_returnType_s(st : SyntaxTree) -> [SyntaxTree] {
	if (st.choice == 0 && st.rule == st_function_args) {
		st.children[2];
	} else if (st.choice == 0 && st.rule == st_function_2) {
		st.children[0];
	} else if (st.choice == 0 && st.rule == st_functiondecl) {
		st.children[6];
	} else []
}
get_flow_funargs2_s(st : SyntaxTree) -> [SyntaxTree] {
	if (st.choice == 0 && st.rule == st_function_args) {
		st.children[0];
	} else []
}
get_flow_funargs2_more_s(st : SyntaxTree) -> [SyntaxTree] {
	if (st.choice == 0 && st.rule == st_funargs2) {
		st.children[1];
	} else []
}
get_flow_funargs_s(st : SyntaxTree) -> [SyntaxTree] {
	if (st.choice == 1 && st.rule == st_function_args) {
		st.children[0];
	} else if (st.choice == 0 && st.rule == st_structdecl) {
		st.children[4];
	} else []
}
get_flow_funargs_more_s(st : SyntaxTree) -> [SyntaxTree] {
	if (st.choice == 0 && st.rule == st_funargs) {
		st.children[1];
	} else []
}
get_flow_funarg_mutable_s(st : SyntaxTree) -> [SyntaxTree] {
	if (st.choice == 0 && st.rule == st_funarg2) {
		st.children[0];
	} else if (st.choice == 0 && st.rule == st_funarg) {
		st.children[0];
	} else []
}
get_flow_colontype_s(st : SyntaxTree) -> [SyntaxTree] {
	if (st.choice == 0 && st.rule == st_funarg2_arg) {
		st.children[2];
	} else if (st.choice == 0 && st.rule == st_funarg) {
		st.children[3];
	} else if (st.choice == 0 && st.rule == st_argtype) {
		st.children[2];
	} else if (st.choice == 0 && st.rule == st_exp0) {
		st.children[2];
	} else if (st.choice == 0 && st.rule == st_argName) {
		st.children[2];
	} else []
}
get_flow_typenames2_s(st : SyntaxTree) -> [SyntaxTree] {
	if (st.choice == 0 && st.rule == st_typenames) {
		st.children[1];
	} else []
}
get_flow_typelist_s(st : SyntaxTree) -> [SyntaxTree] {
	if (st.choice == 0 && st.rule == st_union) {
		st.children[2];
	} else if (st.choice == 0 && st.rule == st_typename) {
		st.children[2];
	} else []
}
get_flow_types2_s(st : SyntaxTree) -> [SyntaxTree] {
	if (st.choice == 0 && st.rule == st_types) {
		st.children[1];
	} else []
}
get_flow_argtypes_s(st : SyntaxTree) -> [SyntaxTree] {
	if (st.choice == 0 && st.rule == st_functiondecl) {
		st.children[4];
	} else if (st.choice == 0 && st.rule == st_type_fn_par) {
		st.children[0];
	} else []
}
get_flow_argtypes2_s(st : SyntaxTree) -> [SyntaxTree] {
	if (st.choice == 0 && st.rule == st_argtypes) {
		st.children[1];
	} else []
}
get_flow_exp1_assign_s(st : SyntaxTree) -> [SyntaxTree] {
	if (st.choice == 0 && st.rule == st_exp1) {
		st.children[1];
	} else []
}
get_flow_elseExp_s(st : SyntaxTree) -> [SyntaxTree] {
	if (st.choice == 1 && st.rule == st_exp0) {
		st.children[5];
	} else if (st.choice == 2 && st.rule == st_keywords) {
		st.children[5];
	} else []
}
get_flow_pipeExp_s(st : SyntaxTree) -> [SyntaxTree] {
	if (st.choice == 0 && st.rule == st_exp2) {
		st.children[1];
	} else []
}
get_flow_orExp_s(st : SyntaxTree) -> [SyntaxTree] {
	if (st.choice == 0 && st.rule == st_exp3) {
		st.children[1];
	} else []
}
get_flow_andExp_s(st : SyntaxTree) -> [SyntaxTree] {
	if (st.choice == 0 && st.rule == st_exp4) {
		st.children[1];
	} else []
}
get_flow_exp5_compare_s(st : SyntaxTree) -> [SyntaxTree] {
	if (st.choice == 0 && st.rule == st_exp5) {
		st.children[1];
	} else []
}
get_flow_additiveExp_s(st : SyntaxTree) -> [SyntaxTree] {
	if (st.choice == 0 && st.rule == st_exp6) {
		st.children[1];
	} else []
}
get_flow_multiExp_s(st : SyntaxTree) -> [SyntaxTree] {
	if (st.choice == 0 && st.rule == st_term) {
		st.children[1];
	} else []
}
get_flow_maybeOp_s(st : SyntaxTree) -> [SyntaxTree] {
	if (st.choice == 0 && st.rule == st_maybeExp) {
		st.children[1];
	} else []
}
get_flow_argNames_s(st : SyntaxTree) -> [SyntaxTree] {
	if (st.choice == 2 && st.rule == st_factor) {
		st.children[1];
	} else []
}
get_flow_argNames2_s(st : SyntaxTree) -> [SyntaxTree] {
	if (st.choice == 0 && st.rule == st_argNames) {
		st.children[1];
	} else []
}
get_flow_postfix_s(st : SyntaxTree) -> [SyntaxTree] {
	if (st.choice == 0 && st.rule == st_call) {
		st.children[1];
	} else []
}
get_flow_arglist_s(st : SyntaxTree) -> [SyntaxTree] {
	if (st.choice == 0 && st.rule == st_args) {
		st.children[1];
	} else []
}
get_flow_fields_tail_s(st : SyntaxTree) -> [SyntaxTree] {
	if (st.choice == 0 && st.rule == st_fields) {
		st.children[1];
	} else []
}
get_flow_one_more_exp_s(st : SyntaxTree) -> [SyntaxTree] {
	if (st.choice == 0 && st.rule == st_arglist) {
		st.children[1];
	} else []
}
get_flow_trailingComma_s(st : SyntaxTree) -> [SyntaxTree] {
	if (st.choice == 0 && st.rule == st_funargs2) {
		st.children[2];
	} else if (st.choice == 0 && st.rule == st_funargs) {
		st.children[2];
	} else if (st.choice == 0 && st.rule == st_type_fn_par) {
		st.children[1];
	} else if (st.choice == 2 && st.rule == st_factor) {
		st.children[2];
	} else if (st.choice == 0 && st.rule == st_arglist) {
		st.children[2];
	} else if (st.choice == 7 && st.rule == st_atom) {
		st.children[2];
	} else if (get_flow_fields__auto123(st).choice == 0) {
		get_flow_fields__auto123(st).children[0];
	} else []
}
get_flow_brace_exps_s(st : SyntaxTree) -> [SyntaxTree] {
	if (st.choice == 0 && st.rule == st_brace) {
		st.children[1];
	} else []
}
get_flow_brace_exps_more_s(st : SyntaxTree) -> [SyntaxTree] {
	if (st.choice == 0 && st.rule == st_brace_exps) {
		st.children[1];
	} else []
}
get_flow_brace_semi_s(st : SyntaxTree) -> [SyntaxTree] {
	if (st.choice == 0 && st.rule == st_brace_exps) {
		st.children[2];
	} else if (st.choice == 0 && st.rule == st_brace_exps_more) {
		st.children[0];
	} else []
}
get_flow_exps_s(st : SyntaxTree) -> [SyntaxTree] {
	if (st.choice == 7 && st.rule == st_atom) {
		st.children[1];
	} else []
}
get_flow_exps2_s(st : SyntaxTree) -> [SyntaxTree] {
	if (st.choice == 0 && st.rule == st_exps) {
		st.children[1];
	} else []
}
get_flow_switchType_s(st : SyntaxTree) -> [SyntaxTree] {
	if (st.choice == 0 && st.rule == st_switch) {
		st.children[3];
	} else []
}
get_flow_defaultOrNamedCase_s(st : SyntaxTree) -> [SyntaxTree] {
	if (st.choice == 0 && st.rule == st_switch) {
		st.children[6];
	} else []
}
get_flow_names_s(st : SyntaxTree) -> [SyntaxTree] {
	if (st.choice == 1 && st.rule == st_defaultOrNamedCase) {
		st.children[3];
	} else []
}
get_flow_names_more_s(st : SyntaxTree) -> [SyntaxTree] {
	if (st.choice == 0 && st.rule == st_names) {
		st.children[2];
	} else []
}
get_flow_int_s(st : SyntaxTree) -> [SyntaxTree] {
	if (st.choice == 3 && st.rule == st_number) {
		st.children[0];
	} else if (st.choice == 0 && st.rule == st_number_float1) {
		st.children[0];
	} else if (st.choice == 0 && st.rule == st_number_float2) {
		st.children[0];
	} else if (st.choice == 0 && st.rule == st_number_float2) {
		st.children[1];
	} else []
}
get_flow_letterOrDigit__s(st : SyntaxTree) -> [SyntaxTree] {
	if (st.choice == 0 && st.rule == st_id) {
		st.children[1];
	} else []
}
get_flow_digit__s(st : SyntaxTree) -> [SyntaxTree] {
	if (st.choice == 0 && st.rule == st_int) {
		st.children[0];
	} else if (st.choice == 0 && st.rule == st_hexdigit_) {
		st.children[0];
	} else []
}
get_flow_hexdigit__s(st : SyntaxTree) -> [SyntaxTree] {
	if (st.choice == 0 && st.rule == st_number) {
		st.children[0];
	} else if (st.choice == 0 && st.rule == st_onechar_) {
		st.children[0];
	} else if (st.choice == 0 && st.rule == st_onechar_) {
		st.children[1];
	} else if (st.choice == 0 && st.rule == st_onechar_) {
		st.children[2];
	} else if (st.choice == 0 && st.rule == st_onechar_) {
		st.children[3];
	} else if (st.choice == 1 && st.rule == st_onechar_) {
		st.children[0];
	} else if (st.choice == 1 && st.rule == st_onechar_) {
		st.children[1];
	} else if (st.choice == 1 && st.rule == st_onechar_) {
		st.children[2];
	} else if (st.choice == 1 && st.rule == st_onechar_) {
		st.children[3];
	} else if (st.choice == 2 && st.rule == st_onechar_) {
		st.children[0];
	} else if (st.choice == 2 && st.rule == st_onechar_) {
		st.children[1];
	} else []
}
get_flow_onechar__s(st : SyntaxTree) -> [SyntaxTree] {
	if (st.choice == 0 && st.rule == st_singlestring) {
		st.children[0];
	} else []
}
get_flow_path_more_s(st : SyntaxTree) -> [SyntaxTree] {
	if (st.choice == 0 && st.rule == st_path) {
		st.children[1];
	} else []
}
get_flow_singlestring_s(st : SyntaxTree) -> [SyntaxTree] {
	if (st.choice == 1 && st.rule == st_string) {
		st.children[0];
	} else []
}
get_flow_nonspace__s(st : SyntaxTree) -> [SyntaxTree] {
	if (st.choice == 0 && st.rule == st_stringinclude) {
		st.children[0];
	} else []
}
get_flow_whitespace__s(st : SyntaxTree) -> [SyntaxTree] {
	if (st.choice == 0 && st.rule == st_ws) {
		st.children[0];
	} else if (st.choice == 0 && st.rule == st_s) {
		st.children[0];
	} else []
}
get_flow_restOfComment2_s(st : SyntaxTree) -> [SyntaxTree] {
	if (st.choice == 0 && st.rule == st_restOfComment) {
		st.children[1];
	} else if (st.choice == 1 && st.rule == st_restOfComment) {
		st.children[0];
	} else []
}
get_flow_restOfComment1_s(st : SyntaxTree) -> [SyntaxTree] {
	if (st.choice == 0 && st.rule == st_restOfComment2) {
		st.children[0];
	} else []
}
get_flow_nonstarchar__s(st : SyntaxTree) -> [SyntaxTree] {
	if (st.choice == 0 && st.rule == st_restOfComment) {
		st.children[0];
	} else []
}
get_flow_nonlinebreakchar__s(st : SyntaxTree) -> [SyntaxTree] {
	if (st.choice == 2 && st.rule == st_restOfComment) {
		st.children[0];
	} else if (st.choice == 0 && st.rule == st_lastLineComment) {
		st.children[0];
	} else []
}
get_flow_lastLineComment_s(st : SyntaxTree) -> [SyntaxTree] {
	if (st.choice == 0 && st.rule == st_flow) {
		st.children[3];
	} else []
}
get_flow_fields__auto123_s(st : SyntaxTree) -> [SyntaxTree] {
	if (st.choice == 0 && st.rule == st_fields) {
		st.children[2];
	} else []
}
get_flow_frenchstring__auto124_s(st : SyntaxTree) -> [SyntaxTree] {
	if (st.choice == 0 && st.rule == st_frenchstring) {
		st.children[0];
	} else []
}

