import ds/tree;
import tools/flowc/fctypeenv;
import tools/flowc/incremental/fimodule;
import tools/flowc/incremental/fi_helpers;
import tools/flowc/incremental/fiprettyprint;
import tools/flowc/incremental/fisubtype;
import tools/flowc/incremental/fi_verify_struct_type;
import tools/flowc/flowc_helpers;
import tools/flowc/flowc_module;
import tools/flowc/incremental/fc2fi;
import tools/flowc/flowc_field_type;

export {
	// Check that all types in a module are consistent with FcTypeEnvGlobal
	typeverifyFiModule(env : FcTypeEnvProgram, module : FiModule, onError : (FcError) -> void) -> bool;
}

TypeVerifyEnv(
	module : TypeVerifyModuleEnv,
	varNames : Set<string>
);

TypeVerifyModuleEnv(
	name : string, 
	global : FcTypeEnvProgram,
	moduleStructsUnions : Tree<string, FiStructOrUnion>,
	moduleNames : Set<string>,
	exprError : ref bool,
	typeError : ref bool,
	imports : Set<string>
);

typeverifyFiModule(env : FcTypeEnvProgram, module : FiModule, onError : (FcError) -> void) -> bool {
	t = timestamp();
	moduleNames = fold(module.structs,
		fold(module.unions,
			fold(module.functions, 
				fold(module.globalVars, 
					fold(module.natives, 
						makeSet(),
						\all1, nat -> insertSet(all1, nat.name)
					),
					\all2, gvar -> insertSet(all2, gvar.name)
				),
				\all3, func -> insertSet(all3, func.name)
			),
			\all4, union -> insertSet(all4, union.name)
		),
		\all5, struct -> insertSet(all5, struct.name)
	);
	flowfile = module.fileinfo.flowfile;
	moduleEnv = TypeVerifyModuleEnv(
		flowfile,
		env,
		fold(module.structs, 
			fold(module.unions, 
				makeTree(), 
				\acc : Tree<string, FiStructOrUnion>, union -> setTree(acc, union.name, union)
			), 
			\acc, struct -> setTree(acc, struct.name, struct)
		),
		moduleNames,
		ref false,
		ref false,
		fold(module.imports, makeSet(), \acc, imp ->
			mergeSets(
				mergeSets(acc, makeSet1(imp.flowfile)),
				lookupTreeDef(env.acc.names.moduleImports, imp.flowfile, makeSet())
			)
		)
	);
	ret = fold(module.structs,    true, \ok, struct -> ok && typeverifyFiTypeStruct(moduleEnv, struct, onError)) &&
	fold(module.unions,     true, \ok, union -> ok && typeverifyFiTypeUnion(moduleEnv, union, onError)) &&
	fold(module.functions,  true, \ok, func -> ok && typeverifyFiFunctionDec(moduleEnv, func, onError)) &&
	fold(module.globalVars, true, \ok, var -> ok && typeverifyFiGlobalVar(moduleEnv, var, onError)) &&
	fold(module.natives,    true, \ok, nat -> ok && typeverifyFiNativeDec(moduleEnv, nat, onError));
	incrementTimePhase(fcTimePhases.typeverify, t);
	ret
}

typeverifyFiTypeStruct(moduleEnv : TypeVerifyModuleEnv, struct : FiTypeStruct, onError : (FcError) -> void) -> bool {
	tenv = TypeVerifyEnv(moduleEnv, makeSet());
	ret = 
		verifyNameUnused(moduleEnv, struct.name, onError, struct.start) &&
		fold(struct.typars, true, \ok, type -> ok && typeverifyFiType(tenv, type, onError, struct.start)) &&
		fold(struct.args,   true, \ok, arg -> ok && typeverifyFiType(tenv, arg.type, onError, struct.start));
	if (!ret) {
		onError(FcError("in struct '" + struct.name + "'", [FcPosition(moduleEnv.name, struct.start, struct.start)]));
	}
	ret
}

typeverifyFiTypeUnion(moduleEnv : TypeVerifyModuleEnv, union : FiTypeUnion, onError : (FcError) -> void) -> bool {
	tenv = TypeVerifyEnv(moduleEnv, makeSet());
	ret = 
		verifyNameUnused(moduleEnv, union.name, onError, union.start) &&
		fold(union.typeparameters, true, \ok, type -> ok && typeverifyFiType(tenv, type, onError, union.start));
	if (!ret) {
		onError(FcError("in union '" + union.name + "'", [FcPosition(moduleEnv.name, union.start, union.start)]));
	}
	ret
}

verifyNameUnused(env : TypeVerifyModuleEnv, name : string, onError : (FcError) -> void, start : int) -> bool {
	names = env.global.acc.names;
	ret = 
		!containsKeyTree(names.structs, name) &&
		!containsKeyTree(names.unions, name) &&
		!containsKeyTree(names.toplevel, name);
	if (!ret) {
		position : FcPosition = switch (lookupTree(names.structs, name)) {
			Some(struct): {
				module = lookupTreeDef(names.struct2module, name, "");
				FcPosition(module, struct.info.start, struct.info.end);
			}
			None(): {
				switch (lookupTree(names.unions, name)) {
					Some(union): {
						module = lookupTreeDef(names.union2module, name, "");
						FcPosition(module, union.info.start, union.info.end);
					}
					None(): {
						switch (lookupTree(names.toplevel, name)) {
							Some(decl): {
								switch (decl) {
									FcFunctionDec(__,__,__,declInfo, defiInfo): {
										module = lookupTreeDef(names.function2module, name, "");
										FcPosition(module, declInfo.start, declInfo.end);
									}
									FcGlobalVar(__,__,declInfo, bodyInfo): {
										module = lookupTreeDef(names.globalVar2module, name, "");
										FcPosition(module, declInfo.start, declInfo.end);
									}
									FcNativeDec(__,__,__,__,__, info): {
										module = lookupTreeDef(names.native2module, name, "");
										FcPosition(module, info.start, info.end);
									}
								}
							}
							None(): {
								onError(FcError("this branch is impossible", []));
								FcPosition("", -1, -1);
							}
						}
					}
				}
			}
		}
		if (position.file == env.name) {
			// in this case 'name' is defined in this module, so there's no collision
			true
		} else {
			onError(FcError(
				"name '" + name + "' is already used", 
				[position, FcPosition(env.name, start, start)]
			));
			false
		}
	} else {
		ret
	}
}

typeverifyFiFunctionDec(moduleEnv : TypeVerifyModuleEnv, func : FiFunctionDec, onError : (FcError) -> void) -> bool {
	tenv = TypeVerifyEnv(moduleEnv, makeSet());
	ret = 
		verifyNameUnused(moduleEnv, func.name, onError, func.declStart) &&
		typeverifyFiExp(tenv, func.lambda, onError) &&
		isFiSubType(tenv.module.global.acc.names, fiExpType(func.lambda), func.type, true, true) &&
		typeverifyFiType(tenv, func.type, onError, func.declStart);
	if (!ret) {
		onError(FcError("in function '" + func.name + "'", [FcPosition(moduleEnv.name, func.declStart, func.declStart)]));
	}
	ret
}

typeverifyFiGlobalVar(moduleEnv : TypeVerifyModuleEnv, var : FiGlobalVar, onError : (FcError) -> void) -> bool {
	tenv = TypeVerifyEnv(moduleEnv, makeSet());
	ret = 
		verifyNameUnused(moduleEnv, var.name, onError, var.declStart) &&
		typeverifyFiExp(tenv, var.value, onError) &&
		isFiSubType(tenv.module.global.acc.names, fiExpType(var.value), var.type, true, true) &&
		typeverifyFiType(tenv, var.type, onError, var.declStart);
	if (!ret) {
		onError(FcError("in global variable '" + var.name + "'", [FcPosition(moduleEnv.name, var.declStart, var.declStart)]));
	}
	ret
}

typeverifyFiNativeDec(moduleEnv : TypeVerifyModuleEnv, nat : FiNativeDec, onError : (FcError) -> void) -> bool {
	tenv = TypeVerifyEnv(moduleEnv, makeSet());
	ret = 
		verifyNameUnused(moduleEnv, nat.name, onError, nat.declStart) &&
		typeverifyFiExp(tenv, nat.fallbackLambda, onError) &&
		(
			switch (nat.fallbackLambda) {
				FiVoid(__): true;
				default: isFiSubType(tenv.module.global.acc.names, fiExpType(nat.fallbackLambda), nat.type, true, true);
			}
		) &&
		typeverifyFiType(tenv, nat.type, onError, nat.declStart);
	if (!ret) {
		onError(FcError("in native '" + nat.name + "'", [FcPosition(moduleEnv.name, nat.declStart, nat.declStart)]));
	}
	ret
}

typeverifyFiExp(env : TypeVerifyEnv, expr : FiExp, onError : (FcError) -> void) -> bool {
	ret = switch (expr) {
		FiLambda(args, body, type, __): {
			newEnv = TypeVerifyEnv(
				env.module,
				fold(args, env.varNames, \acc, arg -> insertSet(acc, arg.name))
			);
			typeverifyFiType(newEnv, type, onError, expr.start) && 
			typeverifyFiExp(newEnv, body, onError) && 
			forall(args, \arg -> typeverifyFiType(newEnv, arg.type, onError, expr.start));
		}
		FiCall(f, args, type, __): {
			fnType = fiExpType(f);
			callType = FiTypeFunction(map(args, \a -> FiFunArg("", fiExpType(a))), type);
			//println("Check call super\n\t" + prettyFiType(dummyPretty, fnType, makeSet()) + ", sub\n\t"  + prettyFiType(dummyPretty, callType, makeSet()));
			callTypeIsOk = isFiSubType(env.module.global.acc.names, fnType, callType, true, true);
			if (!callTypeIsOk) {
				onError(
					FcError(
						"Wrong type in call to '"
						+ cutoffString(prettyFiExp(dummyPretty, f), 32) + "'"
						+  ". Expected\n\t" + prettyFiType(dummyPretty, fnType, makeSet()) + ",\ngot\n\t"  + prettyFiType(dummyPretty, callType, makeSet()),
						[FcPosition(env.module.name, expr.start, expr.start)]
					)
				);
			}
			callTypeIsOk &&
			typeverifyFiType(env, type, onError, expr.start) && 
			typeverifyFiExp(env, f, onError) && 
			forall(args, \arg -> typeverifyFiExp(env, arg, onError));
		}
		FiVar(name, type, s):
			typeverifyFiVar(env, expr, onError);
		FiLet(x, tp, e1, e2, type, __): {
			subType = fiExpType(e1);
			//println("Check let super\n\t" + prettyFiType(dummyPretty, tp, makeSet()) + ",\nsub\n\t"  + prettyFiType(dummyPretty, subType, makeSet()));
			check_subtype = isFiSubType(env.module.global.acc.names, subType, tp, true, true);
			if (!check_subtype) {
				onError(
					FcError(
						"Wrong type in let statement '"
						+ cutoffString(prettyFiExp(dummyPretty, expr), 32) + "'"
						+  ". Expected\n\t" + prettyFiType(dummyPretty, tp, makeSet()) + ",\ngot\n\t"  + prettyFiType(dummyPretty, subType, makeSet()),
						[FcPosition(env.module.name, expr.start, expr.start)]
					)
				)
			}
			if (subType == FiTypeVoid()) {
				onError(
					FcError(
						"Let expression has a void type",
						[FcPosition(env.module.name, expr.start, expr.start)]
					)
				)
			}
			newEnv = TypeVerifyEnv(env.module, insertSet(env.varNames, x));
			check_subtype && subType != FiTypeVoid() &&
			typeverifyFiType(newEnv, type, onError, expr.start) && 
			typeverifyFiType(newEnv, tp, onError, expr.start) && 
			typeverifyFiExp(newEnv, e1, onError) && 
			typeverifyFiExp(newEnv, e2, onError)
		}
		FiIf(e1, e2, e3, type, __): {
			e1t = fiExpType(e1);
			e2t = fiExpType(e2);
			e3t = fiExpType(e3);
			e1t_is_bool = (e1t == FiTypeBool() || e1t == FiTypeFlow());
			if (!e1t_is_bool) {
				onError(
					FcError(
						"If condition must have a bool or flow type, but is " +
						prettyFiType(dummyPretty, e1t, makeSet()),
						[FcPosition(env.module.name, expr.start, expr.start)]
					)
				);
			}
			e1_type_is_subtype = isFiSubType(env.module.global.acc.names, e2t, type, true, true);
			if (!e1_type_is_subtype) {
				onError(
					FcError(
						"Then branch type is not a subtype of return type\n" +
						"\tthen branch type: " + prettyFiType(dummyPretty, e2t, makeSet()) + "\nand\n"
						"\treturn type:      " + prettyFiType(dummyPretty, type, makeSet()),
						[FcPosition(env.module.name, expr.start, expr.start)]
					)
				);
			}
			e3_type_is_subtype = isFiSubType(env.module.global.acc.names, e3t, type, true, true);
			if (!e3_type_is_subtype) {
				onError(
					FcError(
						"Else branch type is not a subtype of return type\n" +
						"\telse branch type: " + prettyFiType(dummyPretty, e3t, makeSet()) + "\n"
						"\treturn type:      " + prettyFiType(dummyPretty, type, makeSet()),
						[FcPosition(env.module.name, expr.start, expr.start)]
					)
				);
			};
			e1t_is_bool && e1_type_is_subtype && e3_type_is_subtype &&
			typeverifyFiType(env, type, onError, expr.start) && 
			typeverifyFiExp(env, e1, onError) && 
			typeverifyFiExp(env, e2, onError) && 
			typeverifyFiExp(env, e3, onError);
		}
		FiSwitch(e, typ, cs, type, __):
			typeverifyFiSwitch(env, expr, onError);
		FiCast(e, from, to, type, __): {
			et = fiExpType(e);
			expr_type_is_ok = (et == from || et == FiTypeFlow());
			if (!expr_type_is_ok) {
				onError(
					FcError(
						"Cast expression type doesn't match the cast declared from type\n" +
						"\texpression type: " + prettyFiType(dummyPretty, et, makeSet()) + "\n"
						"\tfrom type:       " + prettyFiType(dummyPretty, from, makeSet()),
						[FcPosition(env.module.name, expr.start, expr.start)]
					)
				);
			}
			isconvertible = \t ->
				switch (t : FiType) {
					FiTypeInt():    true;
					FiTypeDouble(): true;
					FiTypeString(): true;
					default:        false;
				};

			cast_is_correct = \ -> {
				ret = if (isConfigParameterTrue(env.module.global.acc.config.config, "strict")) {
					// Check that we only up-cast
					isFiSubType(env.module.global.acc.names, from, to, true, true)
				} else {
					// Check that some common supertype exists
					fiSuperTypeExists(env.module.global.acc.names, from, to, true)
				}
				if (!ret) {
					onError(FcError(
						"Wrong cast typing, from and to cast types don't have a common supertype\n" +
						"\tfrom type: " + prettyFiType(dummyPretty, from, makeSet()) + "\n"
						"\tto type:   " + prettyFiType(dummyPretty, to, makeSet()),
						[FcPosition(env.module.name, expr.start, expr.start)]
					))
				}
				ret
			};
			expr_type_is_ok && 
			(
				fiTypeIsFlow(from) || fiTypeIsFlow(to) || // Cast to/from flow is always allowed
				(isconvertible(from) && isconvertible(to)) || // i2s or one of the built-in conversions are excepted and fine
				cast_is_correct() // general case
			) &&
			typeverifyFiType(env, type, onError, expr.start) && 
			typeverifyFiType(env, from, onError, expr.start) && 
			typeverifyFiType(env, to, onError, expr.start) && 
			typeverifyFiExp(env, e, onError);
		}
		FiSeq(es, type, __):
			typeverifyFiType(env, type, onError, expr.start) && 
			forall(es, \e -> typeverifyFiExp(env, e, onError));
		FiCallPrim(__, es, type, s): {
			typeverifyFiCallPrim(env, expr, onError) && 
			typeverifyFiType(env, type, onError, expr.start) && 
			forall(es, \e -> typeverifyFiExp(env, e, onError));
		}
		FiString(__, __):               true;
		FiBool(__, __):                 true;
		FiDouble(__, __):               true;
		FiVoid(__):                     true;
		FiInt(__, __):                  true;
		FiRequire(__, e, type, __):     typeverifyFiType(env, type, onError, expr.start) && typeverifyFiExp(env, e, onError);
		FiUnsafe(__, fb, type, __):     typeverifyFiType(env, type, onError, expr.start) && typeverifyFiExp(env, fb, onError);
	}
	if (!ret && !^(env.module.exprError)) {
		env.module.exprError := true;
		onError(FcError(
			"in expression '" + cutoffString(prettyFiExp(dummyPretty, expr), 32) + "'", 
			[FcPosition(env.module.name, expr.start, expr.start)])
		);
	}
	ret
}

typeverifyFiCallPrim(env : TypeVerifyEnv, call : FiCallPrim, onError : (FcError) -> void) -> bool {
	joinable = \ -> {
		t1 = fiExpType(call.es[0]);
		t2 = fiExpType(call.es[1]);
		supremum_type_exists = fiSuperTypeExists(env.module.global.acc.names, t1, t2, true);
		if (!supremum_type_exists) {
			onError(
				FcError(
					prettyFiType(dummyPretty, t1, makeSet()) + " not compatible with " + prettyFiType(dummyPretty, t2, makeSet()),
					[FcPosition(env.module.name, call.start, call.start)]
				)
			);
		}
		is_func_type = \t -> {
			if (!isConfigParameterTrue(env.module.global.acc.config.config, "no-fn-comparison")) false else {
				if (!fiTypeIsFunction(t)) false else {
					onError(
						FcError(
							"Function types are not allowed in operation",
							[FcPosition(env.module.name, call.start, call.start)]
						)
					);
					true
				}
			}
		}
		supremum_type_exists && !is_func_type(t1) && !is_func_type(t2)
	}
	binis = \types -> {
		t1 = fiExpType(call.es[0]);
		t2 = fiExpType(call.es[1]);
		allowed_type = contains(types, t1);
		if (!allowed_type) {
			onError(
				FcError(
					"Type " + prettyFiType(dummyPretty, t1, makeSet()) + " is not allowed.\n" +
					"List of allowed types: " + strGlue(map(types, \t -> prettyFiType(dummyPretty, t, makeSet())), ", "),
					[FcPosition(env.module.name, call.start, call.start)]
				)
			);
		}
		equal_operands = (t2 == t1 || t1 == FiTypeFlow() || t2 == FiTypeFlow());
		if (!equal_operands) {
			onError(
				FcError(
					"Types of operands " + prettyFiType(dummyPretty, t1, makeSet()) + " and " + prettyFiType(dummyPretty, t2, makeSet()) + " must be equal",
					[FcPosition(env.module.name, call.start, call.start)]
				)
			);
		}
		allowed_type && equal_operands
	}
	is = \given, demanded -> {
		if (given == FiTypeFlow() || given == demanded) true else {
			onError(
				FcError(
					"Type " + prettyFiType(dummyPretty, given, makeSet()) + " is not allowed.\n" +
					"List of allowed types: " + prettyFiType(dummyPretty, demanded, makeSet()),
					[FcPosition(env.module.name, call.start, call.start)]
				)
			);
			false
		}
	}
	switch (call.op) {
		FcStructPrim(struct_name): {
			if (true || isUrlParameterTrue("verify-structs")) {
				// OK, the type of the struct can be reconstructed from the args
				mstr = lookupTree(env.module.global.acc.names.structs, struct_name);
				verify = \fitype : FiTypeStruct -> {
					verifyFiStructInstantiation(env.module.global.acc.names, fitype, map(call.es, \e -> fiExpType(e)), call.type, \err -> {
						onError(
							FcError(
								prettyFiType(dummyPretty, call.type, makeSet()) + " " + err,
								[FcPosition(env.module.name, call.start, call.start)]
							)
						);
					});
				}
				switch (mstr) {
					None(): {
						switch (lookupTree(env.module.moduleStructsUnions, struct_name)) {
							None(): {
								onError(
									FcError(
										"Could not find struct " + struct_name,
										[FcPosition(env.module.name, call.start, call.start)]
									)
								);
							}
							Some(lfi): {
								switch (lfi) {
									FiTypeStruct(__, __, __, __): verify(lfi);
									FiTypeUnion(__, __, __, __): println("Can not make union");
								}
							}
						}
					}
					Some(str): {
						// OK, now convert the struct def to fitype
						st = fctypestruct2fi(initFcTypeEnvLocal(), \e, __ -> println(e), str);
						verify(st);
					}
				}
			}
			typeverifyFcStructPrim(env, struct_name, call.es, onError, call.start);
		}
		FcFieldPrim(field_name): {
			// Check, that the given field name exists
			type = fiExpType(call.es[0]);
			switch (type) {
				FiTypeName(type_name, __): {
					sf_env = GetStructFieldEnv(
							env.module.global.acc.names,
							env.module.moduleStructsUnions,
							field_name, type_name, onError,
							env.module.name, call.start
					);
					if (getStructField(sf_env) != None()) true else {
						onError(FcError(
							"There's no field " + field_name + " in struct or union " + type_name,  
							[FcPosition(env.module.name, call.start, call.start)])
						);
						false
					}
				}
				FiTypeFlow():
					true;  // We can't do better, if type is flow
				default: {
					onError(FcError(
						"Trying to access field " + field_name + " form a non-struct: " + 
							prettyFiType(dummyPretty, type, makeSet()), 
						[FcPosition(env.module.name, call.start, call.start)])
					);
					false;
				}
			}
		}
		FcArrayPrim(): {
			at = switch (call.type) {
				FiTypeArray(tt): tt;
				default: call.type; // Will never happen
			};
			argno = ref 0;
			forall(call.es, \e -> {
				argno := ^argno + 1;
				if (isFiSubType(env.module.global.acc.names, fiExpType(e), at, true, true)) true else {
					onError(FcError(
						"Wrong type in array element #" + i2s(^argno) 
						+ ". Expected\n\t" + prettyFiType(dummyPretty, at, makeSet()) + ", got\n\t"  + prettyFiType(dummyPretty, fiExpType(e), makeSet())
						,  
						[FcPosition(env.module.name, e.start, e.start)])
					);
					false
				}
			});
		}
		FcSetMutablePrim(field_name): {
			// Check, that the given field name exists and has a proper type for assignment
			switch (fiExpType(call.es[0])) {
				FiTypeName(type_name, __): {
					sf_env = GetStructFieldEnv(
						env.module.global.acc.names,
						env.module.moduleStructsUnions,
						field_name, type_name, onError,
						env.module.name, call.start
					);
					switch (getStructField(sf_env)) {
						Some(struct_field): {
							// Check that assigned type is less general
							assign_type = fiExpType(call.es[1]);
							field_subtyping = isFiSubType(env.module.global.acc.names, assign_type, struct_field.type, true, true);
							if (!field_subtyping) {
								onError(FcError(
									"In assignment of field " + field_name + " in struct or union " + type_name + ":\n" + 
									"type of field: " + prettyFiType(dummyPretty, call.type, makeSet()) + " "
									"is not a supertype of assigned value: " + prettyFiType(dummyPretty, assign_type, makeSet()),  
									[FcPosition(env.module.name, call.start, call.start)])
								)
							}
							if (!struct_field.ismutable) {
								onError(FcError(
									"Field " + field_name + " of struct or union " + type_name + " must be mutable to be assignable",
									[FcPosition(env.module.name, call.start, call.start)])
								)
							}
							field_subtyping && struct_field.ismutable
						}
						None(): {
							onError(FcError(
								"There's no field " + field_name + " in struct or union " + type_name,  
								[FcPosition(env.module.name, call.start, call.start)])
							);
							false; // field doesn't exist
						}
					}
				}
				FiTypeFlow(): true;
				default: false; // This branch must never occur
			}
		}
		FcPlusPrim():  binis([FiTypeInt(), FiTypeDouble(), FiTypeString(), FiTypeFlow()]);
		FcMinusPrim(): binis([FiTypeInt(), FiTypeDouble(), FiTypeFlow()]);
		FcMulPrim():   binis([FiTypeInt(), FiTypeDouble(), FiTypeFlow()]);
		FcDivPrim():   binis([FiTypeInt(), FiTypeDouble(), FiTypeFlow()]);
		FcModPrim():   binis([FiTypeInt(), FiTypeDouble(), FiTypeFlow()]);
		FcNegPrim(): {
			t1 = fiExpType(call.es[0]);
			if (t1 == FiTypeInt() || t1 == FiTypeDouble() || t1 == FiTypeFlow()) true else {
				onError(
					FcError(
						"Type " + prettyFiType(dummyPretty, t1, makeSet()) + " is not allowed.\n" +
						"List of allowed types: int, double",
						[FcPosition(env.module.name, call.start, call.start)]
					)
				);
				false
			}
		}
		FcNePrim():  joinable();
		FcEqPrim():  joinable();
		FcLePrim():  joinable();
		FcGePrim():  joinable();
		FcLtPrim():  joinable();
		FcGtPrim():  joinable();
		FcAndPrim(): is(fiExpType(call.es[0]), FiTypeBool()) && is(fiExpType(call.es[1]), FiTypeBool());
		FcOrPrim():  is(fiExpType(call.es[0]), FiTypeBool()) && is(fiExpType(call.es[1]), FiTypeBool());
		FcNotPrim(): is(fiExpType(call.es[0]), FiTypeBool());
		FcIndexPrim(): {
			at = fiExpType(call.es[0]);
			at_is_ok = fiTypeIsArray(at) || fiTypeIsFlow(at);
			if (!at_is_ok) {
				onError(
					FcError(
						"Type " + prettyFiType(dummyPretty, at, makeSet()) + " must be array or flow",
						[FcPosition(env.module.name, call.start, call.start)]
					)
				)
			}
			it = fiExpType(call.es[1]);
			it_is_int = (it == FiTypeInt());
			if (!it_is_int) {
				onError(
					FcError(
						"Array indext type must be int, not " + prettyFiType(dummyPretty, at, makeSet()),
						[FcPosition(env.module.name, call.start, call.start)]
					)
				);
			}
			at_is_ok && it_is_int
		}
		FcDerefPrim(): {
			rt = fiExpType(call.es[0]);
			if (isFiSubType(env.module.global.acc.names, rt, FiTypeRef(call.type), true, true)) true else {
				onError(
					FcError(
						"Reference type doesn't fit\n" +
						"got:      " + prettyFiType(dummyPretty, rt, makeSet()) + "\n"
						"expected: " + prettyFiType(dummyPretty, FiTypeRef(call.type), makeSet()),
						[FcPosition(env.module.name, call.start, call.start)]
					)
				);
				false
			}
		}
		FcRefPrim(): {
			t = fiExpType(call.es[0]);
			if (isFiSubType(env.module.global.acc.names, FiTypeRef(t), call.type, true, true)) true else {
				onError(
					FcError(
						"Reference type doesn't fit, type:\n" + 
						prettyFiType(dummyPretty, FiTypeRef(t), makeSet()) +
						"\nmust be a subtype of:\n" + 
						prettyFiType(dummyPretty, call.type, makeSet()),
						[FcPosition(env.module.name, call.start, call.start)]
					)
				);
				false
			}
		}
		FcAssignPrim(): {
			tvar = fiExpType(call.es[0]);
			tval = fiExpType(call.es[1]);
			deref = \t ->
				switch (t) {
					FiTypeRef(r): r;
					default: t;
				};
			if (isFiSubType(env.module.global.acc.names, tval, deref(tvar), true, true)) true else {
				onError(
					FcError(
						"Assignment type doesn't fit, type:\n\t" + 
						prettyFiType(dummyPretty, tval, makeSet()) +
						"\nmust be a subtype of:\n\t" + 
						prettyFiType(dummyPretty, deref(tvar), makeSet()),
						[FcPosition(env.module.name, call.start, call.start)]
					)
				);
				false
			}
		}
		FcCreateClosurePrim(structName, functionName): true; // TODO:
		FcQuote(): true; // TODO:
		FcUnquote(): true; // TODO:
	}
}

typeverifyFcStructPrim(env : TypeVerifyEnv, name : string, es : [FiExp], onError : (FcError) -> void, start : int) -> bool {
	// Check the number and types of arguments
	switch (lookupTree(env.module.global.acc.names.structs, name)) {
		Some(struct): {
			// Case of FcTypeStruct - origin from the outer module
			if (length(struct.args) != length(es)) {
				struct_start = startOfStructOrUnion(typeverifyName2StructOrUnion(env, name));
				onError(FcError(
					"number of struct args: " + i2s(length(struct.args)) + " mismatch with number of arguments: " + i2s(length(es)),
					[
						FcPosition(env.module.name, start, start),
						FcPosition(moduleWhereNameIsDefined(env.module.global.acc.names, name), struct_start, struct_start)
					]
				));
			}
			typarInst = ref makeTree();
			length(struct.args) == length(es) &&
			forall(
				zipWith(struct.args, es, \a, e -> Pair(a, e)),
				\p -> {
                    consistentInstantiation(
                        TypeVerifyEnv(env.module, makeSet()),
                        TypeInst(
							fctypeTofi(p.first.type),
							\t1, t2 -> resolveOrMatchTypeParameter(env.module.global.acc.names, typarInst, t1, t2)
						),
                        TypeInst(
							fiExpType(p.second),
							\t1, __ -> Some(t1)
						),
                        onError, start
                    )
                }
			);
		}
		None(): {
			struct_start = startOfStructOrUnion(typeverifyName2StructOrUnion(env, name));
			switch (lookupTree(env.module.moduleStructsUnions, name)) {
				Some(su): {
					// Case of FiTypeStruct - origin from the current module
					switch (su) {
						FiTypeStruct(n, __, args, __): {
							if (length(args) != length(es)) {
								onError(FcError("Number of struct args: " + i2s(length(args)) + " mismatch with number of arguments: " + i2s(length(es)), 
									[
										FcPosition(env.module.name, start, start),
										FcPosition(moduleWhereNameIsDefined(env.module.global.acc.names, name), struct_start, struct_start)
									]
								));
							}
							length(args) == length(es) &&
							forall(
								zipWith(args, es, \a, e -> Pair(a, e)),
								\p -> {
									argType = p.first.type;
									expType = fiExpType(p.second);
									argType == expType || isFiSubType(env.module.global.acc.names, argType, expType, false, true)
								}
							)
						}
						FiTypeUnion(__,__,__,__): {
							onError(FcError("Union " + name + " is used as struct", 
								[
									FcPosition(env.module.name, start, start),
									FcPosition(moduleWhereNameIsDefined(env.module.global.acc.names, name), struct_start, struct_start)
								]
							));
							false;
						}
					}
				}
				None(): {
					onError(FcError("Struct: " + name + " is not found", 
						[
							FcPosition(env.module.name, start, start),
							FcPosition(moduleWhereNameIsDefined(env.module.global.acc.names, name), struct_start, struct_start)
						]
					));
					false;
				}
			}
		}
	}
}

typeverifyFiVar(env : TypeVerifyEnv, var : FiVar, onError : (FcError) -> void) -> bool {
	typarInst = ref makeTree();
	typeverifyFiType(env, var.type, onError, var.start) &&
	switch (lookupTree(env.module.global.types, var.name)) {
		Some(tp): {
			consistentInstantiation(
				TypeVerifyEnv(env.module, makeSet()), 
				TypeInst(var.type, \t1, __ -> Some(t1)),
				TypeInst(fctypeTofi(tp), \t1, t2 -> resolveOrMatchTypeParameter(env.module.global.acc.names, typarInst, t1, t2)), 
				onError, var.start
			)
		}
		None(): true;
	}
}

typeverifyFiSwitch(env : TypeVerifyEnv, sw : FiSwitch, onError : (FcError) -> void) -> bool {
	switchVarTypeIsOk = isFiSubType(env.module.global.acc.names, sw.x.type, sw.switchType, true, true);
	if (!switchVarTypeIsOk) {
		onError(
			FcError(
				"Var type in switch '" + prettyFiType(dummyPretty, sw.x.type, makeSet()) + "' " +
				"is not a subtype of a switch type " + prettyFiType(dummyPretty, sw.switchType, makeSet()),
				[FcPosition(env.module.name, sw.start, sw.start)]
			)
		);
	}
	switchCaseTypes = fold(sw.cases, makeSet(), \caseTypes, c -> insertSet(caseTypes, c.struct));
	switchTypeName = switch (sw.switchType) {
		FiTypeFlow(): "";
		FiTypeName(name, __): name;
		default: {
			onError(FcError(
				"Did not expect a switch on type '" + prettyFiType(dummyPretty, sw.switchType, makeSet()) + "'", 
				[FcPosition(env.module.name, sw.start, sw.start)]
			));
			"";
		}
	};

	// Look in the global environment
	subtypes = buildSet(getTreeKeys(typeVerifyName2structs(env, switchTypeName, makeTree())));
	caseTypesCoincide = (
		switchTypeName == "" ||
		(containsSet(switchCaseTypes, "default") &&
			foldSet(switchCaseTypes, true,
				\ok, caseType -> caseType == "default" || containsSet(subtypes, caseType)
			)
		) ||
		equalSet(switchCaseTypes, subtypes)
	);
	if (!caseTypesCoincide) {
		diff_set = \s1, s2 -> foldSet(s1, makeSet(), \acc, x -> if (containsSet(s2, x)) acc else insertSet(acc, x));
		diff_1 = diff_set(subtypes, switchCaseTypes);
		if (sizeSet(diff_1) > 0) {
			onError(FcError(
				"Switch cases do not cover type variants: " + strGlueSetWithCutoff(diff_1, 16),
				[FcPosition(env.module.name, sw.start, sw.start)]
			));
		}
		diff_2 = diff_set(switchCaseTypes, subtypes);
		if (sizeSet(diff_2) > 0) {
			onError(FcError(
				"Switch cases which have no corresponding structs: " + strGlueSetWithCutoff(diff_2, 16),
				[FcPosition(env.module.name, sw.start, sw.start)]
			));
		}
	}
	caseTypesCoincide && switchVarTypeIsOk &&
	typeverifyFiType(env, sw.type, onError, sw.start) && 
	typeverifyFiType(env, sw.switchType, onError, sw.start) && 
	forall(sw.cases,
		\c -> {
			newEnv = TypeVerifyEnv(
				env.module,
				fold(c.argNames, env.varNames, \acc, argname -> insertSet(acc, argname))
			);
			argsNumIsOk = (
				c.struct == "default" ||
				isSome(typeverifyName2Union(env, c.struct)) || // This exception is added because unions in switch cases always produce structs with no args
				typeverifyNumberOfStructArgs(env, c.struct) == length(c.argNames)
			);
			if (!argsNumIsOk) {
				struct_start = startOfStructOrUnion(typeverifyName2StructOrUnion(env, c.struct));
				onError(
					FcError(
						"Struct '" + c.struct + "' has wrong number of args: " + i2s(length(c.argNames)),
						[
							FcPosition(env.module.name, c.start, c.start),
							FcPosition(moduleWhereNameIsDefined(env.module.global.acc.names, c.struct), struct_start, struct_start)
						]
					)
				);
			}
			caseTypeIsOk = isFiSubType(env.module.global.acc.names, fiExpType(c.body), sw.type, true, true);
			if (!caseTypeIsOk) {
				struct_start = startOfStructOrUnion(typeverifyName2StructOrUnion(env, c.struct));
				onError(
					FcError(
						"Case '" + c.struct + "' type " + prettyFiType(dummyPretty, fiExpType(c.body), makeSet()) + 
						" is not a subtype of a switch type " + prettyFiType(dummyPretty, sw.type, makeSet()),
						[
							FcPosition(env.module.name, c.start, c.start),
							FcPosition(moduleWhereNameIsDefined(env.module.global.acc.names, c.struct), struct_start, struct_start)
						]
					)
				);
			}
			argsNumIsOk && caseTypeIsOk &&
			typeverifyFiExp(newEnv, c.body, onError)
		}
	)
}


typeVerifyName2structs(env : TypeVerifyEnv, name : string, acc : Tree<string, int>) -> Tree<string, int> {
	// Look in the global environment
	subtypes0 = switch (lookupTree(env.module.global.acc.names.unions, name)) {
		Some(switchTypeUnion): fold(switchTypeUnion.typenames, acc, \acc2, subtype -> typeVerifyName2structs(env, subtype.name, acc2));
		None(): {
			switch (lookupTree(env.module.global.acc.names.structs, name)) {
				Some(st): setTree(acc, name, st.info.start);
				None(): acc;
			}
		}
	}
	// Look for this in the local environment as well
	switch (lookupTree(env.module.moduleStructsUnions, name)) {
		None(): subtypes0;
		Some(su): {
			switch (su) {
				FiTypeStruct(__, __, __, s): setTree(subtypes0, name, s);
				FiTypeUnion(__, __, tns, __): {
					fold(tns, subtypes0, \acc2, tn -> typeVerifyName2structs(env, tn.name, acc2));
				}
			}
		}
	};
}

typeverifyFiType(env : TypeVerifyEnv, type : FiType, onError : (FcError) -> void, start : int) -> bool {
	ret = switch (type) {
		FiTypeArray(at):
			typeverifyFiType(env, at, onError, start);
		FiTypeFunction(ats, rt):
			typeverifyFiType(env, rt, onError, start) && 
			fold(ats, true, \ok, at : FiFunArg -> ok && typeverifyFiType(env, at.type, onError, start));
		FiTypeRef(rt):
			typeverifyFiType(env, rt, onError, start);
		FiTypeParameter(s1): true; // TODO: any checks?...
		FiTypeBool():   true;
		FiTypeInt():    true;
		FiTypeDouble(): true;
		FiTypeString(): true;
		FiTypeFlow():   true;
		FiTypeVoid():   true;
		FiTypeNative(): true;
		FiTypeName(name,__):
			typeverifyFiTypeName(env, type, onError, start);
	}
	if (!ret && !^(env.module.typeError)) {
		env.module.typeError := true;
		onError(FcError(
			"in type '" + cutoffString(prettyFiType(dummyPretty, type, makeSet()), 32) + "'", 
			[FcPosition(env.module.name, start, start)]
		));
	}
	ret
}

typeverifyFiTypeName(env : TypeVerifyEnv, type : FiTypeName, onError : (FcError) -> void, start : int) -> bool {
	fold(type.typeparameters, true, \ok, tp -> ok && typeverifyFiType(env, tp, onError, start)) &&
	typeverifyIsStructOrUnionName(env, type.name, onError, start)
}

typeverifyIsStructOrUnionName(env : TypeVerifyEnv, name : string, onError : (FcError) -> void, start : int) -> bool {
	switch (typeverifyName2StructOrUnion(env, name)) {
		Some(su): true;
		None(): {
			onError(FcError(
				"name '" + name + "' is not a name of struct or union", 
				[FcPosition(env.module.name, start, start)]
			));
			false;
		}
	}
}

FcStructOrUnion ::= FcTypeStruct, FcTypeUnion;
FcFiStructOrUnion ::= FcStructOrUnion, FiStructOrUnion;

typeverifyName2StructOrUnion(env : TypeVerifyEnv, name : string) -> Maybe<FcFiStructOrUnion> {
	struct : Maybe<FcFiStructOrUnion> = lookupTree(env.module.global.acc.names.structs, name);
	switch (struct) {
		Some (s): Some(s);
		None(): {
			union : Maybe<FcFiStructOrUnion> = lookupTree(env.module.global.acc.names.unions, name);
			switch (union) {
				Some(u): Some(u);
				None(): {
					switch (lookupTree(env.module.moduleStructsUnions, name)) {
						Some(su): Some(su);
						None(): None();
					}
				}
			}
		}
	}
}

typeverifyName2Union(env : TypeVerifyEnv, name : string) -> Maybe<FcFiStructOrUnion> {
	struct : Maybe<FcFiStructOrUnion> = lookupTree(env.module.global.acc.names.structs, name);
	switch (struct) {
		Some(s): None();
		None(): {
			union : Maybe<FcFiStructOrUnion> = lookupTree(env.module.global.acc.names.unions, name);
			switch (union) {
				Some(u): Some(u);
				None(): {
					switch (lookupTree(env.module.moduleStructsUnions, name)) {
						Some(su): {
							switch (su) {
								FiTypeStruct(__,__, args,__): None();
								FiTypeUnion(__,__,__,__): Some(su);
							}
						}
						None(): None();
					}
				}
			}
		}
	}
}

typeverifyNumberOfStructArgs(env : TypeVerifyEnv, typename : string) -> int {
	switch (lookupTree(env.module.global.acc.names.structs, typename)) {
		Some(st): length(st.args);
		None(): {
			switch (lookupTree(env.module.moduleStructsUnions, typename)) {
				Some(su): {
					switch (su) {
						FiTypeStruct(__,__, args,__): length(args);
						FiTypeUnion(__,__,__,__): -1;
					}
				}
				None(): -1;
			}
		}
	}
}

// Type with typars instantiation function
TypeInst(
	type : FiType,
	inst: (TypeInst, TypeInst) -> Maybe<TypeInst>, // matches and instantiates type parameters (maybe)
);

fctypeTofi(t : FcType) -> FiType {
	fctype2fi(initFcTypeEnvLocal(), \__,__ -> {}, t)
}

consistentInstantiation(env : TypeVerifyEnv, t1 : TypeInst, t2 : TypeInst, onError : (FcError) -> void, start : int) -> bool {
	switch (t1.inst(t1, t2)) {
		Some(t1_inst):
			switch (t2.inst(t2, t1_inst)) {
				Some(t2_inst):
					consistentInstantiationResolved(
						env, 
						t1_inst, 
						t2_inst, 
						onError, start
					);
				None(): false;
			}
		None(): false;
	}
}

// If t1 is a type parameter, then there are two possiboilities:
// a) either it is already resolved, then return the resolved value
// b) or it is not yet resolved. Then match it with the second type.
resolveOrMatchTypeParameter(names : FcGlobalNames, inst : ref Tree<string, TypeInst>, t1 : TypeInst, t2 : TypeInst) -> Maybe<TypeInst> {
	switch (t1.type) {
		FiTypeParameter(n1): {
			switch (lookupTree(^inst, n1)) {
				Some(t1_inst): {
					if (isFiSubType(names, t2.type, t1_inst.type, true, true)) {
						Some(t1_inst);
					} else if (isFiSubType(names, t1_inst.type, t2.type, true, true)) {
						inst := setTree(^inst, n1, t2); 
						Some(t2);
					} else {
						None();
					}
				}
				None(): {
					inst := setTree(^inst, n1, t2); 
					Some(t2);
				}
			}
		}
		default: Some(t1);
	}
}

// t2 is a subtype of t1, so s1 var may be substituted with t2 value
consistentInstantiationResolved(env : TypeVerifyEnv, t1 : TypeInst, t2 : TypeInst, onError : (FcError) -> void, start : int) -> bool {
	ret = switch (t2.type) {
		FiTypeParameter(n2):
			switch (t1.type) {
				FiTypeFlow(): true;
				FiTypeParameter(n1): n2 == n1;
				default: false;
			}
		FiTypeArray(t2_arr):
			switch (t1.type) {
				FiTypeFlow(): true;
				FiTypeArray(t1_arr):
					consistentInstantiation(env,
						TypeInst(t1_arr, t1.inst),
						TypeInst(t2_arr, t2.inst),
						onError, start
					);
				default: false;
			}
		FiTypeRef(t2_ref):
			switch (t1.type) {
				FiTypeFlow(): true;
				FiTypeRef(t1_ref): 
					consistentInstantiation(env,
						TypeInst(t1_ref, t1.inst),
						TypeInst(t2_ref, t2.inst),
						onError, start
					);
				default: false;
			}
		FiTypeFunction(t2_at, t2_rt):
			switch (t1.type) {
				FiTypeFlow(): true;
				FiTypeFunction(t1_at, t1_rt):
					consistentInstantiation(env, 
						TypeInst(t1_rt, t1.inst),
						TypeInst(t2_rt, t2.inst),
						onError, start
					) &&
					length(t1_at) == length(t2_at) &&
					foldi(t1_at, true, 
						\i, ok, a -> ok && 
							consistentInstantiation(env,
								TypeInst(t2_at[i].type, t2.inst),
								TypeInst(a.type, t1.inst),
								onError, start
							)
					);
				default: false;
			}
		FiTypeBool():        switch (t1.type) { FiTypeFlow(): true; FiTypeBool(): true;   default: false; }
		FiTypeInt():         switch (t1.type) { FiTypeFlow(): true; FiTypeInt():  true;   default: false; }
		FiTypeDouble():      switch (t1.type) { FiTypeFlow(): true; FiTypeDouble(): true; default: false; }
		FiTypeString():      switch (t1.type) { FiTypeFlow(): true; FiTypeString(): true; default: false; }
		FiTypeFlow():        true;
		FiTypeVoid():        switch (t1.type) { FiTypeFlow(): true; FiTypeVoid():   true; default: false; }
		FiTypeNative():      switch (t1.type) { FiTypeFlow(): true; FiTypeNative(): true; default: false; }
		FiTypeName(n2, typars2):
			switch (t1.type) {
				FiTypeFlow(): true; 
				FiTypeName(n1, typars1): {
					(n1 == n2 || isFiSubType(env.module.global.acc.names, t2.type, t1.type, true, true)) && // !!! isFiSubType !!!
					length(typars1) == length(typars2) &&
					foldi(typars1, true, 
						\i, ok, tp1 -> 
							ok && consistentInstantiation(env, 
								TypeInst(tp1, t1.inst), 
								TypeInst(typars2[i], t2.inst), 
								onError, start
							)
					);
				}
				default: false;
			}
	}
	if (!ret) {
		onError(FcError(
			"type '" + prettyFiType(dummyPretty, t2.type, makeSet()) + "' cannot be substituted with '" + prettyFiType(dummyPretty, t1.type, makeSet()) + "'", 
			[FcPosition(env.module.name, start, start)]
		));
	}
	ret
}

startOfStructOrUnion(msu : Maybe<FcFiStructOrUnion>) -> int {
	eitherMap(msu, \su -> 
		switch(su) {
			FiTypeStruct(__,__,__, s): s;
			FiTypeUnion(__,__,__, s):  s;
			FcTypeStruct(__,__,__, i): i.start;
			FcTypeUnion(__,__,__, i):  i.start;
		},
		-1
	)
}
