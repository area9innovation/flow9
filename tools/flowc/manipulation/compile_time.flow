import tools/flowc/incremental/fiprettyprint;
import tools/flowc/manipulation/common;
import tools/flowc/flowc_helpers;
import tools/flowc/const_eval;
import tools/flowc/incremental/fi_helpers2;

export {
	// Try to find a named constant from config and pass it to AST.
	// The definition of constants in options is done with `env` option and looks like:
	//    env=bar=1,js=true,bit_width=32,pi=3.14,app_id=A9_APP
	//
	// If `env` option is defined in flow.config file, more sparse format is available:
	//    env += bar = 1
	//    env += js=true, bit_width = 32
	//    env += pi = 3.14, app_id=A9_APP
	//
	// Following types of compile-time constants are supported:
	//    boolean, integer, double and string
	//
	// LIMITATIONS:
	//  - spaces, tabs, etc. are not allowed in string values
	//  - commas are not allowed in string values
	//  - booleans are of the form: 1, 0, true, false, TRUE, FALSE
	//
	substituteCompileTimeValues(program: FiProgram, on_err: (FcError) -> void) -> FiProgram;

	// Try to eval expressions in `compileTime` and `compileTimeDef` functions.
	evalProgramCompileTimeExprs(prog : FiProgram, on_err: (FcError) -> void) -> FiProgram;
}

substituteCompileTimeValues(program: FiProgram, on_err: (FcError) -> void) -> FiProgram {
	env_opt = getConfigParameter(program.config.config, "env");
	if (env_opt == "") program else {
		cp_vars = configString2tree(env_opt);
		if (program.config.verbose > 0) {
			fcPrintln("Substituting compile-time constants from config:\n" +
				strGlue(map(tree2pairs(cp_vars), \p -> "\t" + p.first + " = " + p.second), "\n"),
				program.config.threadId
			);
		}
		fiMapProgramExp(program, \e, decl, module,__ -> {
			module_err = \msg, pos -> on_err(FcError(msg, [FcPosition(module.fileinfo.flowfile, pos, pos)]));
			mapFiExp(e,
				\x -> switch (x) {
					FiVar(name, type, start): {
						switch (lookupTree(cp_vars, name)) {
							Some(val):
								switch (compileTimeValue(val, type, start, module_err)) {
									Some(c): c;
									None(): x;
								}
							None(): x;
						}
					}
					default: x;
				}
			);
		}, fcParallelOn(program.config));
	}
}

compileTimeValue(val: string, type: FiType, start: int, on_err: (string, int) -> void) -> Maybe<FiExp> {
	switch (type) {
		FiTypeBool():   Some(FiBool(s2b(val), start));
		FiTypeInt():    Some(FiInt(s2i(val), start));
		FiTypeDouble(): Some(FiDouble(s2d(val), start));
		FiTypeString(): Some(FiString(val, start));
		default: {
			on_err("Compile-time constant cannot be of type: " + pretFiType(type) + ", must be one of: bool, int, double or string", start);
			None();
		}
	}
}

collectGlobalDependencies(e: FiExp, trav_env: FiExpTraverseEnv, acc: Set<string>) -> Set<string> {
	free = fifreevars(e);
	globals = filterSet(free, \v -> !containsKeyTree(trav_env.locals, v));
	foldSet(
		differenceSets(free, acc),
		mergeSets(globals, acc), 
		\ac, v -> switch (lookupTree(trav_env.lets, v)) {
			Some(x): collectGlobalDependencies(x.e1, trav_env, ac);
			None(): ac;
		}
	);
}

evalExpValue(e: FiExp, trav_env: FiExpTraverseEnv, eval_env: FcEvalEnv, locals : HashMap<string, FcEvalLocal>) -> Maybe<flow> {
	free_vars = filterSet(fifreevars(e), \x -> containsKeyTree(trav_env.locals, x));
	ok = ref true;
	iterSet(free_vars, \x -> if (!containsKeyHashMap(locals, x)) {
		switch (lookupTree(trav_env.lets, x)) {
			Some(let): {
				switch (evalExpValue(let.e1, trav_env, eval_env, locals)) {
					Some(v): setHashMap(locals, let.name, FcEvalLocal(v));
					None(): ok := false;
				}
			}
			None(): ok := false;
		}
	});
	if (!^ok) None() else {
		err_no = length(^(eval_env.errors));
		val = fcReplEval(e, eval_env, locals);
		if (length(^(eval_env.errors)) == err_no) Some(val) else None();
	}
}

evalProgramCompileTimeExprs(prog : FiProgram, on_err: (FcError) -> void) -> FiProgram {
	detect_compile_time = \x -> switch (x) {
		FiCall(f, args,__,__): switch (f) {
			FiVar(f_name,__,__): {
				if (f_name == "compileTime") {
					Some(args[0]);
				} else if (f_name == "compileTimeDef") {
					Some(args[0]);
				} else {
					None();
				}
			}
			default: None();
		}
		default: None();
	}
	used_globals = foldTree(prog.names.toplevel, makeSet(), \__, decl, acc -> {
		e = switch (decl) {
			FiFunctionDec(__,lambda,__,__,__): lambda;
			FiGlobalVar(__,value,__,__,__): value;
			FiNativeDec(__,__,__,__,fallback,__,__): fallback;
		}
		fiFoldExp(e, acc,
			\x, trav_env, ac -> eitherMap(detect_compile_time(x),
				\y -> collectGlobalDependencies(y, trav_env, ac), ac
			),
			AstTraverseOrder(true, true
		));
	});
	eval_env = fcInitEvalEnv(fcOptimizeTailCalls(prog), None(), Some(used_globals), on_err);
	verb = s2i(getConfigParameterDef(prog.config.config, "compile-time-verbose", "0"));

	fiMapProgramModule(prog,
		\m, p -> fiMapModuleExp(p, m, \e0, decl,__,__ ->
			fiMapExp(e0, \x, trav_env -> switch (x) {
				FiCall(f, args, type,__): switch (f) {
					FiVar(f_name,__,__): {
						if (f_name == "compileTime") {
							ex = args[0];
							ex_c = eitherMap(
								evalExpValue(ex, trav_env, eval_env, makeHashMap(fastHashString)),
								\v -> switch(fiflow2Constant(v, Some(type), eval_env)) {
									Some(ex_c): ex_c;
									None(): {
										on_err(FcError(
											"Failed to type a constant.\n" +
											"Type: " + pretFiType(type) + "\n" +
											"Constant:\n" + toStringFormatted(v),
											[]
										));
										ex;
									}
								},
								ex
							);
							if (verb > 0) {
								fcPrintln(
									"Evaled during compile-time:\n" +
										strIndent(pretFiExp(ex)) + "\n" +
									"value is:\n" +
										strIndent(if (fiEqualExps(ex, ex_c)) "the same" else pretFiExp(ex_c)),
									prog.config.threadId
								);
							}
							ex_c;
						} else if (f_name == "compileTimeDef") {
							ex = args[0];
							def = args[1];
							ex_c = eitherMap(
								evalExpValue(ex, trav_env,
									FcEvalEnv(eval_env with onError = nop3),
									makeHashMap(fastHashString)
								),
								\v -> either(fiflow2Constant(v, Some(type), eval_env), def),
								def
							);
							if (verb > 0 && !fiEqualExps(ex, ex_c)) {
								fcPrintln(
									"Evaled during compile-time:\n" +
										strIndent(pretFiExp(ex)) + "\n" +
									"value is:\n" +
										strIndent(if (fiEqualExps(ex, ex_c)) "the same" else pretFiExp(ex_c)),
									prog.config.threadId
								);
							}
							ex_c;
						} else {
							x;
						}
					}
					default: x;
				}
				default: x;
			}, true)
		),
		fcParallelOn(prog.config)
	);
}
