import tools/flowc/incremental/fiprettyprint;
import tools/flowc/manipulation/common;
import tools/flowc/flowc_helpers;
import tools/flowc/const_eval;
import tools/flowc/incremental/fi_helpers2;

export {
	// Try to find a named constant from config and pass it to AST.
	// The definition of constants in options is done with `env` option and looks like:
	//    env=bar=1,js=true,bit_width=32,pi=3.14,app_id=A9_APP
	//
	// If `env` option is defined in flow.config file, more sparse format is available:
	//    env += bar = 1
	//    env += js=true, bit_width = 32
	//    env += pi = 3.14, app_id=A9_APP
	//
	// Following types of compile-time constants are supported:
	//    boolean, integer, double and string
	//
	// LIMITATIONS:
	//  - spaces, tabs, etc. are not allowed in string values
	//  - commas are not allowed in string values
	//  - booleans are of the form: 1, 0, true, false, TRUE, FALSE
	//
	substituteCompileTimeValues(program: FiProgram, on_err: (FcError) -> void) -> FiProgram;

	// Try to eval argument of `compileTime` function.
	evalProgramCompileTimeExprs(prog : FiProgram, on_err: (FcError) -> void) -> FiProgram;
}

substituteCompileTimeValues(program: FiProgram, on_err: (FcError) -> void) -> FiProgram {
	env_opt = getConfigParameter(program.config.config, "env");
	if (env_opt == "") program else {
		cp_vars = configString2tree(env_opt);
		if (program.config.verbose > 0) {
			fcPrintln("Substituting compile-time constants from config:\n" +
				strGlue(map(tree2pairs(cp_vars), \p -> "\t" + p.first + " = " + p.second), "\n"),
				program.config.threadId
			);
		}
		fiMapProgramExp(program, \e, decl, module,__ -> {
			module_err = \msg, pos -> on_err(FcError(msg, [FcPosition(module.fileinfo.flowfile, pos, pos)]));
			mapFiExp(e,
				\x -> switch (x) {
					FiVar(name, type, start): {
						switch (lookupTree(cp_vars, name)) {
							Some(val):
								switch (compileTimeValue(val, type, start, module_err)) {
									Some(c): c;
									None(): x;
								}
							None(): x;
						}
					}
					default: x;
				}
			);
		}, fcParallelOn(program.config));
	}
}

compileTimeValue(val: string, type: FiType, start: int, on_err: (string, int) -> void) -> Maybe<FiExp> {
	switch (type) {
		FiTypeBool():   Some(FiBool(s2b(val), start));
		FiTypeInt():    Some(FiInt(s2i(val), start));
		FiTypeDouble(): Some(FiDouble(s2d(val), start));
		FiTypeString(): Some(FiString(val, start));
		default: {
			on_err("Compile-time constant cannot be of type: " + pretFiType(type) + ", must be one of: bool, int, double or string", start);
			None();
		}
	}
}

collectGlobalDependencies(e: FiExp, trav_env: FiExpTraverseEnv, names: FiGlobalNames, acc: Set<string>) -> Set<string> {
	free = fifreevars(e);
	globals = filterSet(free, \v -> !containsKeyTree(trav_env.locals, v));
	foldSet(
		differenceSets(free, acc),
		mergeSets(globals, acc), 
		\ac, v -> switch (lookupTree(trav_env.lets, v)) {
			Some(x): collectGlobalDependencies(x.e1, trav_env, names, ac);
			None(): eitherMap(lookupTree(names.toplevel, v),
				\decl -> collectGlobalDependencies(
					fiDeclExp(decl),
					FiExpTraverseEnv(trav_env with
						lets = makeTree(),
						locals = switch (fiDeclExp(decl)) {
							FiLambda(args,__,__,__): {
								pairs2tree(map(args, \arg -> Pair(arg.name, FiVar(arg.name, arg.type, -1))));
							}
							default: makeTree();
						}
					),
					names, ac
				), ac
			);
		}
	);
}

evalExpValue(e: FiExp, trav_env: FiExpTraverseEnv, eval_env: FcEvalEnv, locals : HashMap<string, FcEvalLocal>) -> Maybe<flow> {
	free_vars = filterSet(fifreevars(e), \x -> containsKeyTree(trav_env.locals, x));
	ok = ref true;
	iterSet(free_vars, \x -> if (!containsKeyHashMap(locals, x)) {
		switch (lookupTree(trav_env.lets, x)) {
			Some(let): {
				switch (evalExpValue(let.e1, trav_env, eval_env, locals)) {
					Some(v): setHashMap(locals, let.name, FcEvalLocal(v));
					None(): ok := false;
				}
			}
			None(): ok := false;
		}
	});
	if (!^ok) None() else {
		err_no = length(^(eval_env.errors));
		val = fcReplEval(e, eval_env, locals);
		if (length(^(eval_env.errors)) == err_no) Some(val) else None();
	}
}

evalProgramCompileTimeExprs(prog : FiProgram, on_err: (FcError) -> void) -> FiProgram {
	has_compile_time = ref false;
	detect_compile_time = \x -> switch (x) {
		FiCall(f, args,__,__): switch (f) {
			FiVar(f_name,__,__): {
				if (f_name == "compileTime") {
					has_compile_time := true;
					Some(x);
				} else {
					None();
				}
			}
			default: None();
		}
		default: None();
	}
	used_globals = foldTree(prog.names.toplevel, makeSet(), \__, decl, acc ->
		fiFoldExp(fiDeclExp(decl), acc,
			\x, trav_env, ac -> eitherMap(detect_compile_time(x),
				\call -> collectGlobalDependencies(call.args[0], trav_env, prog.names, ac), ac
			),
			AstTraverseOrder(true, true)
		)
	);
	if (!^has_compile_time) prog else {
		eval_env = fcInitEvalEnv(fcOptimizeTailCalls(prog), None(), Some(used_globals), nop1);
		fiMapProgramModule(prog,
			\m, pr -> fiMapModuleExp(pr, m, \e0, decl,__,__ ->
				fiMapExp(e0, \x, trav_env ->
					eitherMap(
						detect_compile_time(x),
						\call -> {
							ex = call.args[0];
							switch (evalExpValue(ex, trav_env, eval_env, makeHashMap(fastHashString))) {
								Some(v): {
									switch(fiflow2Constant(v, Some(call.type), eval_env)) {
										Some(const): const;
										None(): {
											on_err(FcError(
												"Failed to assign the type " + pretFiType(call.type) + " to a constant:\n" +
												strIndent(toStringFormatted(v)), []
											));
											ex;
										}
									}
								}
								None(): {
									on_err(FcError(
										"Failed to eval a compile-time constant from the expression:\n" +
										strIndent(pretFiExp(ex)), []
									));
									ex;
								}
							}
						},
						x
					), true
				)
			),
			fcParallelOn(prog.config)
		)
	}
}
