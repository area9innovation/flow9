import tools/flowc/incremental/fiprogram;

export {
	checkAntipattern(program : FiProgram) -> void;
}

// Currently this functions checks only antipattern fold + arrayPush/ifArrayPush/concat
checkAntipattern(program : FiProgram) -> void {
	traversePreOrder(program.modules, \modname : string, mo : FiModule -> {
		println("module = " + modname);
		iter(mo.functions, \fun -> checkAntipatternRec(fun.lambda, false));
	});
}

checkAntipatternRec(expr : FiExp, insideFold : bool) -> void {
	multipleCheck = \args : [FiExp] -> iter(args, \arg -> checkAntipatternRec(arg, insideFold));
	switch (expr) {
		FiLambda(__, body, __, __): checkAntipatternRec(body, insideFold);
		FiCall(f, args, type, __): {
			switch(f) {
				FiVar(x, __, start) : {
					if (x == "fold") {
						checkAntipatternRec(args[2], true)
					} else if (insideFold && contains(["arrayPush", "concat", "ifArrayPush"], x)) {
						println("call " + x + " inside fold at " )
					} else {
						multipleCheck(args)
					}
				}
				default : multipleCheck(args);
			}
		}
		FiVar(__, __, __): 				{};
		FiLet(__, __, e1, e2, __, __): 	multipleCheck([e1, e2]);
		FiIf(e1, e2, e3, __, __): 		multipleCheck([e1, e2, e3]);
		FiSwitch(x, __, cases, __, __): multipleCheck(concat([x], map(cases, \case -> case.body)));
		FiCast(e, __, __, __, __):      checkAntipatternRec(e, insideFold);
		FiSeq(es, __, __):              multipleCheck(es);
		FiCallPrim(__, es, __, __):     multipleCheck(es);
		FiString(s, __):                {};
		FiBool(__, __):                 {};
		FiDouble(__, __):               {};
		FiVoid(__):                     {};
		FiInt(__, __):                  {};
		FiRequire(__, e, __, __):       checkAntipatternRec(e, insideFold);
		FiUnsafe(__, fallback, __, __): checkAntipatternRec(fallback, insideFold);
	}
}
