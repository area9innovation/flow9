import tools/flowc/incremental/fi_helpers;
import math/stringmath;
import string_utils;

export {
	// Expand all occurences of unions inside other unions to pure structs so that
	// unions contain only struct names.
	fiFlattenUnions(program : FiProgram) -> FiProgram;

	// Add implicit typars to structs, which come from embracing unions.
	// Example: None() struct from Maybe<?> union implicitly inherits the ? type parameter
	fiCompleteStructTypars(program : FiProgram) -> FiProgram;

	// Remove implicit typars to structs, which come from embracing unions.
	// Example: None() struct from Maybe<?> union implicitly inherits the ? type parameter
	fiRemoveImplicitStructTypars(program : FiProgram) -> FiProgram;

	// Set the implicit typars to some particular type (FiTypeVoid or FiTypeFlow or whatever).
	fiSetImplicitStructTypars(program : FiProgram, implicit: FiType) -> FiProgram;

	// If a native is implemented - remove a fallback, otherwise remove a native.
	// In case a native is not implemented and 
	fiResolveNatives(program : FiProgram, native_is_implemented: (string) -> bool) -> FiProgram;
}

fiFlattenUnions(program : FiProgram) -> FiProgram {
	unions2structs = fiUnions2Structs(program.names);
	flatten_unions = mapTree(program.names.unions, \un ->
		FiTypeUnion(un with 
			typenames = switch (lookupTree(unions2structs, un.name)) {
				Some(structs): map(structs, \struct -> FiTypeName(struct.name, struct.typars));
				None(): un.typenames;
			}
		)
	);
	FiProgram(program with
		names = FiGlobalNames(program.names with unions = flatten_unions),
		modules = mapTree(program.modules, \module ->
			FiModule(module with
				unions = map(module.unions, \un -> lookupTreeDef(flatten_unions, un.name, un))
			)
		)
	);
}

fiUnions2Structs(names : FiGlobalNames) -> Tree<string, [FiTypeStruct]> {
	fold(getTreeValues(names.unions), makeTree(), \acc, union ->
		fiUnion2Structs(union, acc, names)
	);
}

fiUnion2Structs(union : FiTypeUnion, acc: Tree<string, [FiTypeStruct]>, names : FiGlobalNames) -> Tree<string, [FiTypeStruct]> {
	if (containsKeyTree(acc, union.name)) acc else {
		p = fold(union.typenames, Pair([], acc), \ac, type -> 
			switch (lookupTree(names.structs, type.name)) {
				Some(struct): Pair(concat(ac.first, [struct]), ac.second);
				None(): {
					switch (lookupTree(names.unions, type.name)) {
						Some(union1): {
							ac1 = fiUnion2Structs(union1, ac.second, names);
							Pair(concat(ac.first, lookupTreeDef(ac1, union1.name, [])), ac1);
						}
						None(): {
							fail("must not happen, type: " + type.name + " is not found");
							ac;
						}
					}
				}
			}
		);
		setTree(p.second, union.name, uniq(p.first));
	}
}

fiCompleteStructTypars(program : FiProgram) -> FiProgram {
	unions2structs = fiUnions2Structs(program.names);
	structs2unions = fiStucts2Unions(program.names, unions2structs);
	completed_structs = mapTree(program.names.structs, \struct ->
		FiTypeStruct(struct with 
			typars = fiStrcutFullTypars(struct, structs2unions)
		)
	);
	FiProgram(program with
		names = FiGlobalNames(program.names with structs = completed_structs),
		modules = mapTree(program.modules, \module ->
			FiModule(module with
				structs = map(module.structs, \s -> lookupTreeDef(completed_structs, s.name, s))
			)
		)
	);
}

fiStucts2Unions(names : FiGlobalNames, unions2structs: Tree<string, [FiTypeStruct]>) -> Tree<string, [FiTypeUnion]> {
	no_union = FiTypeUnion("", [], [], 0);
	foldTree(unions2structs, makeTree(), \union, structs, acc -> 
		fold(structs, acc, \ac, struct ->
			setTree(ac, struct.name, 
				concat(
					lookupTreeDef(ac, struct.name, []), 
					[lookupTreeDef(names.unions, union, no_union)]
				)
			)
		)
	);
}

fiStrcutFullTypars(struct : FiTypeStruct, struct2union: Tree<string, [FiTypeUnion]>) -> [FiTypeParameter] {
	filter_typars = \types -> filtermap(types, \type -> 
		switch (type) {
			FiTypeParameter(__): Some(type);
			default: None();
		}
	);
	supertypes = lookupTreeDef(struct2union, struct.name, []);
	sort(uniq(fold(supertypes, filter_typars(struct.typars), \acc, union ->
		concat(acc, filter_typars(union.typeparameters))
	)));
}

fiRemoveImplicitStructTypars(program : FiProgram) -> FiProgram {
	fiTransformImplicitStructTypars(program, \__ -> None());
}

fiSetImplicitStructTypars(program : FiProgram, implicit: FiType) -> FiProgram {
	fiTransformImplicitStructTypars(program, \__ -> Some(implicit));
}

fiTransformImplicitStructTypars(program : FiProgram, fn: (FiTypeParameter) -> Maybe<FiType>) -> FiProgram {
	on_err = \msg -> {
		fcPrintln(msg, program.config.threadId);
	}
	names = program.names;
	remove_func = \func: FiFunctionDec -> {
		typars = fiCollectTypars(func.type, makeSet());
		lambda_removed = fiTransformImplicitStructTyparsFromFiExp(func.lambda, typars, on_err, fn, names, func.name);
		FiFunctionDec(func with
			lambda = cast(lambda_removed: FiExp -> FiLambda)
		);
	}
	remove_var = \var: FiGlobalVar -> {
		typars = fiCollectTypars(var.type, makeSet());
		FiGlobalVar(var with
			value = fiTransformImplicitStructTyparsFromFiExp(var.value, typars, on_err, fn, names, var.name)
		);
	}
	remove_nat = \nat: FiNativeDec -> {
		typars = fiCollectTypars(nat.type, makeSet());
		FiNativeDec(nat with
			fallbackLambda = fiTransformImplicitStructTyparsFromFiExp(nat.fallbackLambda, typars, on_err, fn, names, nat.name)
		);
	}
	toplevel_removed = mapTree(program.names.toplevel, \decl ->
		switch (decl) {
			FiFunctionDec(__,__,__, __, __): remove_func(decl);
			FiGlobalVar(__,__,__,__,__): remove_var(decl);
			FiNativeDec(__,__,__,__,__,__,__): remove_nat(decl);
		}
	);
	FiProgram(program with
		modules = mapTree(program.modules, \module ->
			FiModule(module with
				functions = map(module.functions, remove_func),
				globalVars = map(module.globalVars, remove_var),
				natives = map(module.natives, remove_nat)
			)
		),
		names = FiGlobalNames(program.names with
			toplevel = toplevel_removed
		)
	);
}

fiTransformImplicitStructTyparsFromFiExp(e : FiExp, typars: Set<string>, on_err: (string) -> void, fn: (FiTypeParameter) -> Maybe<FiType>, names: FiGlobalNames, toplevel_name: string) -> FiExp {
	re = \x -> fiTransformImplicitStructTyparsFromFiExp(x, typars, on_err, fn, names, toplevel_name);
	rt = \x -> switch (fiTransformImplicitStructTyparsFromFiType(x, typars, fn, names)) {
		Some(tp): tp;
		None(): {
			on_err(
				"type dissapeared: " + prettyFiType(dummyPretty, x, makeSet()) + 
				", typars: [" + strGlue(set2array(typars), ", ") + "]\n" + 
				"expression: " + prettyFiExp(dummyPretty, e) + "\n" +
				"in declaration: " + toplevel_name
			);
			x;
		}
	}
	switch(e) {
		FiLambda(args, body, type, start): {
			body_typars = fold(args, typars, \acc, arg -> fiCollectTypars(arg.type, acc));
			FiLambda(args,
				fiTransformImplicitStructTyparsFromFiExp(body, body_typars, on_err, fn, names, toplevel_name),
				cast(rt(type): FiType -> FiTypeFunction), start
			);
		}
		FiCall(f, args, type, start): {
			FiCall(re(f), map(args, re), rt(type), start);
		}
		FiLet(name, vtype, e1, e2, type, start): {
			FiLet(name, rt(vtype), re(e1), re(e2), rt(type), start);
		}
		FiIf(e1, e2, e3, type, start): {
			FiIf(re(e1), re(e2), re(e3), rt(type), start);
		}
		FiSwitch(v, vtype, cases, type, start): {
			FiSwitch(
				FiVar(v.name, rt(v.type), v.start), rt(vtype), 
				map(cases, \c -> FiCase(c with body = re(c.body))), 
				rt(type), start
			);
		}
		FiCast(ex, from, to, type, start): {
			FiCast(re(ex), rt(from), rt(to), rt(type), start);
		}
		FiSeq(es, type, start): {
			FiSeq(map(es, re), rt(type), start);			
		}
		FiCallPrim(op, es, type, start): {
			FiCallPrim(op, map(es, re), rt(type), start);
		}
		FiRequire(flowfile, ex, type, start): {
			FiRequire(flowfile, re(ex), rt(type), start);
		}
		FiUnsafe(name, ex, type, start): {
			FiUnsafe(name, re(ex), rt(type), start);
		}
		default: e;
	}
}

fiTransformImplicitStructTyparsFromFiType(t : FiType, typars: Set<string>, fn: (FiTypeParameter) -> Maybe<FiType>, names: FiGlobalNames) -> Maybe<FiType> {
	doit = \x -> fiTransformImplicitStructTyparsFromFiType(x, typars, fn, names);
	typename_typars = \nm -> switch (lookupTree(names.structs, nm)) {
		Some(struct): struct.typars;
		None(): switch (lookupTree(names.unions, nm)) {
			Some(union): union.typeparameters;
			None(): [];
		}
	}
	switch (t) {
		FiTypeParameter(n): {
			if (containsSet(typars, n)) Some(t) else fn(t);
		}
		FiTypeRef(rt): {
			maybeMap(doit(rt), \r -> FiTypeRef(r));
		}
		FiTypeArray(at): {
			maybeMap(doit(at), \a -> FiTypeArray(a));
		}
		FiTypeName(id, tps): {
			type_tps = typename_typars(id);
			filtered = filtermap(tps, doit);
			if (length(type_tps) == 0) {
				Some(FiTypeName(id, []));
			} else {
				if (length(type_tps) != length(filtered)) {
					println("length(type_tps) != length(filtered)\n" +
						"type:\n" + toStringFormatted(t) + "\n" +
						"type_tps:\n" + toStringFormatted(type_tps) + "\n" +
						"filtered:\n" + toStringFormatted(filtered) + "\n"
					);
				}
				Some(FiTypeName(id, filtered));
			}
		}
		FiTypeFunction(args, rt): {
			maybeBind(doit(rt),
				\r -> {
					as = filtermap(args, \arg -> doit(arg.type));
					if (length(as) == length(args)) {
						Some(FiTypeFunction(mapi(as, \i, tp -> FiFunArg(args[i].name, tp)), r));
					} else {
						None();
					}
				}
			);
		}
		default: Some(t);
	}
}

fiResolveNatives(program : FiProgram, native_is_implemented: (string) -> bool) -> FiProgram {
	// for each function name decide: if it is a true native or should use a fallback
	native_resolver = foldTree(program.modules, makeTree(), \__, module, acc ->
		fold(module.natives,
			fold(module.functions, acc, 
				\ac, func -> if (native_is_implemented(func.name)) ac else setTree(ac, func.name, func)
			),
			\ac, nat -> if (native_is_implemented(nat.name)) setTree(ac, nat.name, nat) else ac
		)
	);
	FiProgram(program with
		modules = mapTree(program.modules, \module ->
			FiModule(module with
				// Filter out fallbacks for non-true natives
				functions = filter(module.functions, \func -> !native_is_implemented(func.name)),
				// Filter out true natives
				natives = filter(module.natives, \nat -> native_is_implemented(nat.name)),
			)
		),
		names = FiGlobalNames(program.names with
			// update toplevel declarations with proper ones
			toplevel = mapTree2(program.names.toplevel, \name, decl -> lookupTreeDef(native_resolver, name, decl))
		)
	);
}
