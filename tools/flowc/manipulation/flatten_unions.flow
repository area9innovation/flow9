import tools/flowc/incremental/fi_helpers2;
import tools/flowc/manipulation/common;
import math/stringmath;
import string_utils;

export {
	// Expand all occurences of unions inside other unions to pure structs so that
	// unions contain only struct names.
	fiFlattenUnions(program : FiProgram) -> FiProgram;

	// Add implicit typars to structs, which come from embracing unions.
	// Example: None() struct from Maybe<?> union implicitly inherits the ? type parameter
	fiCompleteStructTypars(program : FiProgram) -> FiProgram;

	// Remove implicit typars to structs, which come from embracing unions.
	// Example: None() struct from Maybe<?> union implicitly inherits the ? type parameter
	fiRemoveImplicitStructTypars(program : FiProgram) -> FiProgram;

	// Set the implicit typars to some particular type (FiTypeVoid or FiTypeFlow or whatever).
	fiSetImplicitStructTypars(program : FiProgram, implicit: FiType) -> FiProgram;

	// If a native is implemented - remove a fallback, otherwise remove a native.
	// In case a native is not implemented and 
	fiResolveNatives(program : FiProgram, native_is_implemented: (string) -> bool) -> FiProgram;

	// For any struct, which is contained in several unions, add a super union, which
	// is a set-theoretical union of all these unions, i.e. is a single supertype for all.
	fiAddSuperUnions(program : FiProgram) -> FiProgram;

	// Check if all type parameters lists size match the corresponding struct/union type parameters list
	fiCheckPolymorphism(p : FiProgram, types: [FiType]) -> [string];

	// Collects all types, used in a program.
	fiProgramTypes(p : FiProgram) -> [FiType];

	// Extract all casts in a program. Returns a tree: key - 'from' type, value - set of 'to' types
	fiProgramCasts(prog: FiProgram) -> Tree<FiType, Set<FiType>>;

	// Adds functions for struct casts in situations like: cast(x: Tree<int, A> -> Tree<int, B>)
	fiProgramAddPolymorphicStructsCasts(program: FiProgram) -> FiProgram;
}

fiFlattenUnions(program : FiProgram) -> FiProgram {
	unions2structs = fiUnions2Structs(program.names);
	flatten_unions = mapTree(program.names.unions, \un ->
		FiTypeUnion(un with 
			typenames = switch (lookupTree(unions2structs, un.name)) {
				Some(structs): map(structs, \struct -> FiTypeName(struct.name, struct.typars));
				None(): un.typenames;
			}
		)
	);
	FiProgram(program with
		names = FiGlobalNames(program.names with unions = flatten_unions),
		modules = mapTree(program.modules, \module ->
			FiModule(module with
				unions = map(module.unions, \un -> lookupTreeDef(flatten_unions, un.name, un))
			)
		)
	);
}

fiUnions2Structs(names : FiGlobalNames) -> Tree<string, [FiTypeStruct]> {
	fold(getTreeValues(names.unions), makeTree(), \acc, union ->
		fiUnion2Structs(union, acc, names)
	);
}

fiUnion2Structs(union : FiTypeUnion, acc: Tree<string, [FiTypeStruct]>, names : FiGlobalNames) -> Tree<string, [FiTypeStruct]> {
	if (containsKeyTree(acc, union.name)) acc else {
		p = fold(union.typenames, Pair([], acc), \ac, type -> 
			switch (lookupTree(names.structs, type.name)) {
				Some(struct): Pair(concat(ac.first, [struct]), ac.second);
				None(): {
					switch (lookupTree(names.unions, type.name)) {
						Some(union1): {
							ac1 = fiUnion2Structs(union1, ac.second, names);
							Pair(concat(ac.first, lookupTreeDef(ac1, union1.name, [])), ac1);
						}
						None(): {
							fail("must not happen, type: " + type.name + " is not found");
							ac;
						}
					}
				}
			}
		);
		setTree(p.second, union.name, uniq(p.first));
	}
}

fiCompleteStructTypars(program : FiProgram) -> FiProgram {
	unions2structs = fiUnions2Structs(program.names);
	structs2unions = fiStucts2Unions(program.names, unions2structs);
	completed_structs = mapTree(program.names.structs, \struct ->
		FiTypeStruct(struct with 
			typars = fiStrcutFullTypars(struct, structs2unions)
		)
	);
	FiProgram(program with
		names = FiGlobalNames(program.names with structs = completed_structs),
		modules = mapTree(program.modules, \module ->
			FiModule(module with
				structs = map(module.structs, \s -> lookupTreeDef(completed_structs, s.name, s))
			)
		)
	);
}

fiStucts2Unions(names : FiGlobalNames, unions2structs: Tree<string, [FiTypeStruct]>) -> Tree<string, [FiTypeUnion]> {
	no_union = FiTypeUnion("", [], [], 0);
	foldTree(unions2structs, makeTree(), \union, structs, acc -> 
		fold(structs, acc, \ac, struct ->
			setTree(ac, struct.name, 
				concat(
					lookupTreeDef(ac, struct.name, []), 
					[lookupTreeDef(names.unions, union, no_union)]
				)
			)
		)
	);
}

fiStrcutFullTypars(struct : FiTypeStruct, struct2union: Tree<string, [FiTypeUnion]>) -> [FiTypeParameter] {
	filter_typars = \types -> filtermap(types, \type -> 
		switch (type) {
			FiTypeParameter(__): Some(type);
			default: None();
		}
	);
	supertypes = lookupTreeDef(struct2union, struct.name, []);
	sort(uniq(fold(supertypes, filter_typars(struct.typars), \acc, union ->
		concat(acc, filter_typars(union.typeparameters))
	)));
}

fiRemoveImplicitStructTypars(program : FiProgram) -> FiProgram {
	fiTransformImplicitStructTypars(program, \__ -> None());
}

fiSetImplicitStructTypars(program : FiProgram, implicit: FiType) -> FiProgram {
	fiTransformImplicitStructTypars(program, \__ -> Some(implicit));
}

fiTransformImplicitStructTypars(program : FiProgram, fn: (FiTypeParameter) -> Maybe<FiType>) -> FiProgram {
	on_err = \msg -> {
		fcPrintln(msg, program.config.threadId);
	}
	names = program.names;
	unions2structs = fiUnions2Structs(program.names);
	structs2unions = fiStucts2Unions(program.names, unions2structs);
	do_type = \typars, x -> switch (fiTransformImplicitStructTyparsFromFiType(x, typars, fn, names, structs2unions)) {
		Some(tp): tp;
		None(): {
			on_err(
				"type dissapeared: " + prettyFiType(dummyPretty, x, makeSet()) + ", " +
				"typars: [" + strGlue(set2array(typars), ", ") + "]"
			);
			x;
		}
	}
	do_exp = \e, typars, name -> {
		fiTransformImplicitStructTyparsFromFiExp(fiCorrectVarTypes(e), typars, on_err, fn, names, structs2unions, name);
	}
	remove_struct = \s: FiTypeStruct -> {
		typars = buildSet(filtermap(s.typars, \x -> switch (x) {
			FiTypeParameter(p): Some(p);
			default: None();
		}));
		FiTypeStruct(s with
			args = map(s.args, \arg -> FiStructArg(arg with type = do_type(typars, arg.type)))
		)
	}
	remove_union = \u: FiTypeUnion -> {
		typars = buildSet(filtermap(u.typeparameters, \x -> switch (x) {
			FiTypeParameter(p): Some(p);
			default: None();
		}));
		FiTypeUnion(u with
			typenames = map(u.typenames, \tn -> cast(do_type(typars, tn): FiType -> FiTypeName))
		)
	}
	remove_func = \func: FiFunctionDec -> {
		typars = fiCollectTypars(func.type, makeSet());
		lambda_removed = do_exp(func.lambda, typars, func.name);
		FiFunctionDec(func with
			lambda = cast(lambda_removed: FiExp -> FiLambda),
			type = cast(do_type(typars, func.type): FiType -> FiTypeFunction)
		);
	}
	remove_var = \var: FiGlobalVar -> {
		typars = fiCollectTypars(var.type, makeSet());
		FiGlobalVar(var with
			value = do_exp(var.value, typars, var.name),
			type = do_type(typars, var.type)
		);
	}
	remove_nat = \nat: FiNativeDec -> {
		typars = fiCollectTypars(nat.type, makeSet());
		FiNativeDec(nat with
			fallbackLambda = do_exp(nat.fallbackLambda, typars, nat.name),
			type = do_type(typars, nat.type)
		);
	}
	FiProgram(program with
		modules = mapTree(program.modules, \module ->
			FiModule(module with
				structs = map(module.structs, remove_struct),
				unions = map(module.unions, remove_union),
				functions = map(module.functions, remove_func),
				globalVars = map(module.globalVars, remove_var),
				natives = map(module.natives, remove_nat)
			)
		),
		names = FiGlobalNames(names with
			toplevel = mapTree(names.toplevel, \decl ->
				switch (decl) {
					FiFunctionDec(__,__,__, __, __): remove_func(decl);
					FiGlobalVar(__,__,__,__,__): remove_var(decl);
					FiNativeDec(__,__,__,__,__,__,__): remove_nat(decl);
				}
			),
			structs = mapTree(names.structs, remove_struct),
			unions = mapTree(names.unions, remove_union),
		)
	);
}

/*
Example of what is corrected:

FiSwitch(
		FiVar(
			"gsymswitch26",
			FiTypeName(
				"Triple", // TYPE PARAMETERS EXIST
				[
					FiTypeArray(FiTypeName("Maybe", [FiTypeName("TmpVar", [])])),
					FiTypeArray(FiTypeName("FiExp", [])),
					FiTypeName("OptEnvExp", [])
				]
			),
			25916
		),
		FiTypeName(
			"Triple",
			[
				FiTypeArray(FiTypeName("Maybe", [FiTypeName("TmpVar", [])])),
				FiTypeArray(FiTypeName("FiExp", [])),
				FiTypeName("OptEnvExp", [])
			]
		),
		[
			FiCase(
				"Triple",
				["tmp_decls", "call_args", "effectedEnv"],
				FiLet(
					"tmp_decls",
					FiTypeArray(FiTypeName("Maybe", [FiTypeName("TmpVar", [])])),
					FiCallPrim(
						FcFieldPrim("first"),
						[FiVar("gsymswitch26", FiTypeName("Triple", []), -25972)],      // NO TYPE PARAMETERS
						FiTypeArray(FiTypeName("Maybe", [FiTypeName("TmpVar", [])])),
						-25972
					),
					FiLet(
*/

fiCorrectVarTypes(e: FiExp) -> FiExp {
	fiMapExp(e, \x, env -> switch (x) {
		FiVar(name, type1,__): {
			eitherMap(lookupTree(env.locals, name), \v ->
				if (fiEqualTypes(type1, v.type)) x else {
					FiVar(x with type = v.type);
				}, x
			);
		}
		default: x;
	}, true);
}

fiTransformImplicitStructTyparsFromFiExp(
	e : FiExp, typars: Set<string>, 
	on_err: (string) -> void, 
	fn: (FiTypeParameter) -> Maybe<FiType>, names: FiGlobalNames, 
	structs2unions: Tree<string, [FiTypeUnion]>,
	toplevel_name: string
) -> FiExp {
	re = \x -> fiTransformImplicitStructTyparsFromFiExp(x, typars, on_err, fn, names, structs2unions, toplevel_name);
	rt = \x -> switch (fiTransformImplicitStructTyparsFromFiType(x, typars, fn, names, structs2unions)) {
		Some(tp): tp;
		None(): {
			on_err(
				"type dissapeared: " + prettyFiType(dummyPretty, x, makeSet()) + 
				", typars: [" + strGlue(set2array(typars), ", ") + "]\n" + 
				"expression: " + prettyFiExp(dummyPretty, e) + "\n" +
				"in declaration: " + toplevel_name
			);
			x;
		}
	}
	switch(e) {
		FiLambda(args, body, type, start): {
			body_typars = fold(args, typars, \acc, arg -> fiCollectTypars(arg.type, acc));
			FiLambda(
				map(args, \arg -> FiFunArg(arg.name, rt(arg.type))),
				fiTransformImplicitStructTyparsFromFiExp(body, body_typars, on_err, fn, names, structs2unions, toplevel_name),
				cast(rt(type): FiType -> FiTypeFunction), start
			);
		}
		FiCall(f, args, type, start): {
			FiCall(re(f), map(args, re), rt(type), start);
		}
		FiLet(name, vtype, e1, e2, type, start): {
			FiLet(name, rt(vtype), re(e1), re(e2), rt(type), start);
		}
		FiIf(e1, e2, e3, type, start): {
			FiIf(re(e1), re(e2), re(e3), rt(type), start);
		}
		FiSwitch(v, vtype, cases, type, start): {
			FiSwitch(
				FiVar(v.name, rt(v.type), v.start), rt(vtype), 
				map(cases, \c -> FiCase(c with body = re(c.body))), 
				rt(type), start
			);
		}
		FiCast(ex, from, to, type, start): {
			FiCast(re(ex), rt(from), rt(to), rt(type), start);
		}
		FiSeq(es, type, start): {
			FiSeq(map(es, re), rt(type), start);			
		}
		FiCallPrim(op, es, type, start): {
			FiCallPrim(op, map(es, re), rt(type), start);
		}
		FiRequire(flowfile, ex, type, start): {
			FiRequire(flowfile, re(ex), rt(type), start);
		}
		FiUnsafe(name, ex, type, start): {
			FiUnsafe(name, re(ex), rt(type), start);
		}
		FiVar(name, type, start): {
			FiVar(name, rt(type), start);
		}
		FiConst(): e;
	}
}

fiResoveStructTypars(s: FiTypeStruct, typars: [FiType], struct2unions: Tree<string, [FiTypeUnion]>) -> [FiType] {
	num_typars = length(typars);
	if (num_typars == length(s.typars)) {
		typars;
	} else {
		unions = lookupTreeDef(struct2unions, s.name, []);
		switch (find(unions, \union -> length(union.typeparameters) == num_typars)) {
			Some(union): {
				mapping = pairs2tree(mapi(union.typeparameters, \i, tp -> switch (tp) {
					FiTypeParameter(nm): Pair(nm, typars[i]);
					default: fail0("union " + union.name + " type parameter must be of FiTypeParameter type, got: " + pretFiType(tp));
				}));
				switch (find(union.typenames, \tn -> tn.name == s.name)) {
					Some(tn): {
						map(tn.typeparameters, \tp -> switch (tp) {
							FiTypeParameter(nm): {
								switch (lookupTree(mapping, nm)) {
									Some(t): t;
									None(): {
										fail0("type parameter " + nm + " of a struct " + s.name + " is not found among type parameters of enclosing union " + union.name + " type parameters");
									}
								}
							}
							default: {
								fail0("struct " + s.name + " among union typename " + union.name + " type parameter must be of FiTypeParameter type, got: " + pretFiType(tp));
							}
						});
					}
					None(): {
						fail0("struct " + s.name + " is not found among union " + union.name + " typenames");
					}
				}
			}
			None(): {
				fail0("can't resolve typars: [" + superglue(typars, pretFiType, ", ") + "] of a struct " + s.name);
			}
		}
	}
}

fiTransformImplicitStructTyparsFromFiType(
	t : FiType, typars: Set<string>, 
	fn: (FiTypeParameter) -> Maybe<FiType>, 
	names: FiGlobalNames,
	structs2unions: Tree<string, [FiTypeUnion]>
) -> Maybe<FiType> {
	doit = \x -> fiTransformImplicitStructTyparsFromFiType(x, typars, fn, names, structs2unions);
	typename_typars = \nm -> switch (lookupTree(names.structs, nm)) {
		Some(struct): struct.typars;
		None(): switch (lookupTree(names.unions, nm)) {
			Some(union): union.typeparameters;
			None(): [];
		}
	}
	switch (t) {
		FiTypeParameter(n): {
			if (containsSet(typars, n)) Some(t) else fn(t);
		}
		FiTypeRef(rt): {
			maybeMap(doit(rt), \r -> FiTypeRef(r));
		}
		FiTypeArray(at): {
			maybeMap(doit(at), \a -> FiTypeArray(a));
		}
		FiTypeName(name, tps): {
			tps1 = filtermap(tps, doit);
			Some(FiTypeName(t with 
				typeparameters = switch (lookupTree(names.structs, name)) {
					Some(struct): {
						fiResoveStructTypars(struct, tps1, structs2unions);
					}
					None(): tps1;
				}
			));
		}
		FiTypeFunction(args, rt): {
			maybeBind(doit(rt),
				\r -> {
					as = filtermap(args, \arg -> doit(arg.type));
					if (length(as) == length(args)) {
						Some(FiTypeFunction(mapi(as, \i, tp -> FiFunArg(args[i].name, tp)), r));
					} else {
						None();
					}
				}
			);
		}
		FiTypeBool(): Some(t);
		FiTypeInt(): Some(t);
		FiTypeDouble(): Some(t);
		FiTypeString(): Some(t);
		FiTypeFlow(): Some(t);
		FiTypeVoid(): Some(t);
		FiTypeNative(): Some(t);
	}
}

fiResolveNatives(program : FiProgram, native_is_implemented: (string) -> bool) -> FiProgram {
	// for each function name decide: if it is a true native or should use a fallback
	native_resolver = foldTree(program.modules, makeTree(), \__, module, acc: Tree<string, FiDeclaration> ->
		fold(module.natives,
			fold(module.functions, acc, 
				\ac, func -> if (native_is_implemented(func.name)) ac else setTree(ac, func.name, func)
			),
			\ac, nat: FiNativeDec -> if (!native_is_implemented(nat.name)) ac else {
				setTree(ac, nat.name, FiNativeDec(nat with fallbackLambda = FiVoid(0)))
			}
		)
	);
	FiProgram(program with
		modules = mapTree(program.modules, \module ->
			FiModule(module with
				// Filter out fallbacks for non-true natives
				functions = filter(module.functions, \func -> !native_is_implemented(func.name)),
				// Filter out true natives
				natives = filtermap(module.natives, \nat -> if (!native_is_implemented(nat.name)) None() else
					Some(FiNativeDec(nat with fallbackLambda = FiVoid(0)))
				),
			)
		),
		names = FiGlobalNames(program.names with
			// update toplevel declarations with proper ones
			toplevel = mapTree2(program.names.toplevel, \name, decl -> lookupTreeDef(native_resolver, name, decl))
		)
	);
}

fiAddSuperUnions(program : FiProgram) -> FiProgram {
	names = program.names;
	all_unions = getTreeValues(names.unions);

	gather_super_unions = \acc0, supers -> foldTree(supers, acc0, \str, unions, acc ->
		if (length(unions) <= 1) {
			// A struct is cointained in a single / none union - it is its super union.
			acc;
		} else {
			// A set of all types in a super union for a struct 'str'
			super_names = set2array(fold(unions, makeSet(), \ac, un ->
				fold(un.typenames, ac, \a, tn -> insertSet(a, tn))
			));
			// try to find an existing superunion among a program unions
			switch (find(all_unions, \un -> forall(super_names, \tn -> contains(un.typenames, tn)))) {
				Some(super_union): {
					// no need to create a new super union
					acc;
				}
				None(): {
					// try to find an existing superunion among a constructed new super unions
					switch (findList(acc, \p -> forall(super_names, \tn -> contains(p.first.typenames, tn)))) {
						Some(p): {
							// no need to create a new super union
							acc;
						}
						None(): {
							// A super union for a current struct doesn't exist - let's create it and add it
							super_union = FiTypeUnion(
								"super_" + superglue(super_names, \tn -> tn.name, "_"),
								set2array(fold(super_names, makeSet(), \ac, tn ->
									fold(tn.typeparameters, ac, \a, tp -> insertSet(ac, tp))
								)),
								super_names,
								-1
							);
							Cons(Pair(super_union, str), acc);
						}
					}
				}
			}
		}
	);

	// Gather all unions, where a struct belongs to
	struct2unions = fold(all_unions, makeTree(), \acc, union ->
		fold(union.typenames, acc, \ac, tn ->
			setTree(ac, tn.name, insertSet(lookupTreeDef(ac, tn.name, makeSet()), union))
		)
	);
	// List of pairs: a super union and a corresponding struct name
	struct_super_unions = gather_super_unions(makeList(), mapTree(struct2unions, set2array));

	// Gather all unions, which form a superset of typenames of a given union
	union2super_unions = fold(all_unions, makeTree(), \acc, union -> {
			super_unions = filter(all_unions, \u ->
				u.name != union.name && forall(union.typenames, \tn -> contains(u.typenames, tn))
			);
			if (length(super_unions) == 0) acc else setTree(acc, union.name, super_unions);
		});

	// Add missing amalgamating superunions for unions
	super_unions = gather_super_unions(struct_super_unions, union2super_unions);

	FiProgram(program with
		// Add newly created super unions to a modules for a corresponding structs
		modules = foldList(super_unions, program.modules, \acc, p -> {
			mod_name = lookupTreeDef(names.struct2module, p.second, "");
			module = lookupTreeDef(acc, mod_name, dummyFiModule);
			setTree(acc, mod_name, FiModule(module with unions = concat(module.unions, [p.first])))
		}),
		// Update names with newly created super unions
		names = FiGlobalNames(names with
			unions = foldList(super_unions, names.unions, \acc, p ->
				setTree(acc, p.first.name, p.first)
			),
			union2module = foldList(super_unions, names.union2module, \acc, p ->
				setTree(acc, p.first.name, lookupTreeDef(names.struct2module, p.second, ""))
			)
		)
	);
}

fiCheckPolymorphism(p : FiProgram, types: [FiType]) -> [string] {
	names = p.names;
	type_arity = foldTree(names.unions, 
		foldTree(names.structs, makeTree(), \name, s, acc -> setTree(acc, name, length(s.typars))),
		\name, u, acc -> setTree(acc, name, length(u.typeparameters))
	);
	filtermap(types, \t -> switch (t) {
		FiTypeName(nm, typars): {
			arity = lookupTreeDef(type_arity, nm, -1);
			if (arity == -1) {
				fail("no arity for type: " + nm);
			}
			if (arity == length(typars)) None() else {
				Some("Struct type parameters number mismatch the used type parameters number:\n" +
					"type: " + nm + ", used type: " + pretFiType(t) + ", arity: " + i2s(arity));
			}
		}
		default: None();
	});
}

fiProgramTypes(p : FiProgram) -> [FiType] {
	names = p.names;
	types = ref makeSet();
	add_type = \t -> {
		t1 = fiPurifyType(t);
		if (!containsSet(^types, t1)) {
			types := insertSet(^types, t1);
		}
	}
	observe_exp = \e -> {
		ignore(mapFiExp(e, \x-> { add_type(fiExpType(x)); x; }));
	}
	observe_struct = \s -> {
		iter(s.typars, \tp -> add_type(tp));
		iter(s.args, \arg -> add_type(arg.type));
	}
	observe_union = \u -> {
		iter(u.typeparameters, \tp -> add_type(tp));
		iter(u.typenames, \tn -> add_type(tn));
	}
	observe_func = \fn -> {
		observe_exp(fn.lambda);
		add_type(fn.type);
	}
	observe_var = \var -> {
		observe_exp(var.value);
		add_type(var.type);
	}
	observe_nat = \nat -> {
		observe_exp(nat.fallbackLambda);
		add_type(nat.type);
	}
	iter(getTreeValues(names.toplevel), \decl -> 
		switch (decl) {
			FiFunctionDec(__,__,__,__,__): observe_func(decl);
			FiGlobalVar(__,__,__,__,__): observe_var(decl);
			FiNativeDec(__,__,__,__,__,__,__): observe_nat(decl);
		}
	);
	traverseInOrder(names.structs, \__,s -> observe_struct(s));
	traverseInOrder(names.unions, \__, u -> observe_union(u));
	traverseInOrder(p.modules, \__,m -> { 
		iter(m.structs, observe_struct);
		iter(m.unions, observe_union);
		iter(m.functions, observe_func);
		iter(m.globalVars, observe_var);
		iter(m.natives, observe_nat);
	});
	set2array(^types);
}

fiProgramCasts(prog: FiProgram) -> Tree<FiType, Set<FiType>> {
	proc_exp = \x, acc, nm -> fiFoldExp(x, acc, \e,__, ac -> switch (e) {
		FiCast(__,from, to,__,__): {
			from1 = fiPurifyType(from);
			to1 = fiPurifyType(to);
			if (fiEqualTypes(from1, to1)) {
				ac;
			} else {
				setTree(ac, from1, 
					insertSet(lookupTreeDef(ac, from1, makeSet()), to1)
				);
			}
		}
		default: ac;
	}, AstTraverseOrder(true, true));
	fiFoldProgramToplevel(prog, makeTree(), \toplevel,__,__, acc ->
		switch (toplevel) {
			FiFunctionDec(nm, lambda,__,__,__): proc_exp(lambda, acc, nm);
			FiGlobalVar(nm, value,__,__,__): proc_exp(value, acc, nm);
			FiNativeDec(nm,__,__,__,fallback,__,__): proc_exp(fallback, acc, nm);
			default: acc;
		}
	);
}


fiProgramAddPolymorphicStructsCasts(program: FiProgram) -> FiProgram {
	names = program.names;
	polymorphic_structs = filter(getTreeValues(names.structs), \s -> length(s.typars) > 0);
	struct_casts = map(polymorphic_structs, \s -> fiStructCastWrapperFunction(s, names));
	casts_module = FiModule(
		FiFileInfo("virtual_module_structs_casts", 0.0, "", "", 0.0, 0.0),
		[], // imports
		[], // forbids
		map(struct_casts, \c -> c.name), // exports
		[], // structs
		[], // unions
		struct_casts, // functions
		[], // global vars
		[], // natives
		map(struct_casts, \c -> c.name), // initOrder
		[], // stringIncludes
		0, // start
		0, // end
		makeSet(), // allImports
		false // incremental
	);
	FiProgram(program with 
		modules = setTree(program.modules, casts_module.fileinfo.flowfile, casts_module),
		names = FiGlobalNames(names with 
			toplevel = fold(struct_casts, names.toplevel, \acc, fn -> setTree(acc, fn.name, fn))
		)
	);
}

fiStructCastWrapperFunction(s: FiTypeStruct, names: FiGlobalNames) -> FiFunctionDec {
	max_typar = fold(fiTypes2typars(s.typars), 0, \acc, tp -> max(acc, strlen(tp.n)));
	from = FiTypeName(s.name, s.typars);
	make_typar = \n -> strRepeat("?", n);
	sub = pairs2tree(generate(1, max_typar + 1, \n ->
		Pair(make_typar(n), FiTypeParameter(make_typar(n + max_typar)))
	));
	to = fiApplyTypeSubstitution(sub, from);
	fn_args = [FiFunArg("x", from)];
	fn_type = FiTypeFunction(fn_args, to);
	FiFunctionDec("__wrap_cast_of_" + s.name,
		FiLambda(fn_args,
			FiCallPrim(
				FcStructPrim(s.name),
				map(s.args, \arg -> {
					field_val = FiCallPrim(FcFieldPrim(arg.name), [FiVar("x", from, 0)], arg.type, 0);
					arg_typars = fiCollectTypars(arg.type, makeSet());
					if (isEmptySet(arg_typars)) field_val else {
						field_to = fiApplyTypeSubstitution(sub, arg.type);
						FiCast(field_val, arg.type, field_to, field_to, 0);
					}
				}), to, 0
			), fn_type, 0
		),
		fn_type, 0, 0
	);
}
