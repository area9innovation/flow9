import tools/flowc/manipulation/transform_exps;
import tools/flowc/const_eval;

export {
	// Try to compute the values of constant expressions - those, which may be computed.
	evalProgramConstExprs(prog : FiProgram, auto: bool, on_err: (FcError) -> void, on_msg: (string) -> void) -> FiProgram;
}

evalProgramConstExprs(prog : FiProgram, auto: bool, on_err: (FcError) -> void, on_msg: (string) -> void) -> FiProgram {
	env = fcInitConstEvalEnv(prog, on_err, on_msg);
	optimzie_debug = getConfigParameter(prog.config.config, "const-eval-debug");
	verb = s2i(getConfigParameterDef(prog.config.config, "const-eval-verbose", "0"));
	threshold = s2i(getConfigParameterDef(prog.config.config, "const-eval-threshold", "0"));
	check_compile_time = \e: FiExp -> isSome(fiFindInExpr(e, \x -> switch (x) {
		FiCall(f,__,__,__): switch (f) {
			FiVar(f_name,__,__): if (f_name == "compileTime" || f_name == "compileTimeDef") Some(x) else None();
			default: None();
		}
		default: None();
	}));
	fiMapProgramModule(prog,
		\m, p -> {
			start = timestamp();
			m_opt = fiMapModuleExp(p, m, \e0, decl,__,__ -> {
				if (!(auto || check_compile_time(e0))) e0 else {
					e1 = fiExpMakeStartUnique(e0);
					e2 = evalExpConstExprs(e1, auto,
						FcConstEvalEnv(env with cache = makeHashMap(idfn)), 
						makeSet(), threshold, decl.name == optimzie_debug
					);
					if (decl.name == optimzie_debug || verb > 0) {
						if (fiEqualExps(e1, e2)) {
							if (verb > 1) {
								fcPrintln("No compile-time consts in " + decl.name, prog.config.threadId);
							}
							if (decl.name == optimzie_debug) {
								fcPrintln(
									strIndent("Nothing changed: Compile-time consts of " + decl.name + ":" +
										"\n" + strIndent(pretFiExp(e1)) + "\n" +
										"ended up with:\n" + strIndent(pretFiExp(e2))
									),
									prog.config.threadId
								);
							}
						} else {
							fcPrintln(
								strIndent(
									"Something changed: Compile-time consts of " + decl.name + ":" +
									"\n" + strIndent(pretFiExp(e1)) + "\n" +
									"ended up with:\n" + strIndent(pretFiExp(e2)) + "\n" +
									"raw\n" + strIndent(toStringFormatted(e2)) + "\n"
								),
								prog.config.threadId
							);
						}
					}
					e2;
				}
			});
			time_elapsed = timestamp() - start;
			if (verb > 0 && (verb > 1 || time_elapsed > 500.0)) {
				fcPrintln("compile-time constants are evaluated in " + m.fileinfo.flowfile + " in " + d2st(time_elapsed / 1000.0, 3) + " s.", prog.config.threadId);
			}
			m_opt;
		},
		fcParallelOn(prog.config)
	);
}

decideToUseConst(x: FiExp, c: FiExp, threshold: int, debug: bool) -> bool {
	switch (x) {
		FiVar(__,__,__): false;
		default: {
			fiCountAstNodes(x) - fiCountAstNodes(c) > threshold;
		}
 	}
}

fiStructMatchesSwitchCase(struct: string, case: string, unions: HashMap<string, FiTypeUnion>) -> bool {
	(struct == case) || switch (lookupHashMap(unions, case)) {
		Some(union): {
			exists(union.typenames, \tn -> fiStructMatchesSwitchCase(struct, tn.name, unions));
		}
		None(): false;
	}
}

evalExpConstExprs(x : FiExp, auto: bool, env: FcConstEvalEnv, locals: Set<string>, threshold: int, debug: bool) -> FiExp {
	rec = \e -> evalExpConstExprs(e, auto, env, locals, threshold, debug);
	rec_locals = \e, new_locals -> evalExpConstExprs(e, auto, env, new_locals, threshold, debug);
	const_eval = \e -> {
		if (auto) {
			maybeBind(fcConstEval(e, env, locals, debug), \c ->
				if (!c.plain && !fiEqualExps(e, c.exp) && decideToUseConst(e, c.exp, threshold, debug)) {
					Some(c);
				} else {
					None()
				}
			);
		} else {
			switch (e) {
				FiCall(f, args,__,__): {
					switch (f) {
						FiVar(f_name,__,__): {
							if (f_name == "compileTime") {
								fcConstEval(e, env, locals, debug)
							} else if (f_name == "compileTimeDef") {
								fcConstEval(e, env, locals, debug)
							} else {
								None();
							}
						}
						default: None();
					}
				}
				default: None();
			}
		}
	};
	switch (const_eval(x)) {
		Some(c): {
			c_exp = c.exp;
			switch (c_exp) {
				FiLambda(__,body,__,__): {
					FiLambda(c_exp with body = rec(body));
				}
				default: c_exp;
			}
		}
		None(): {
			switch (x) {
				FiVar(v,__,__): x;
				FiLet(v,__, e1, e2,__,__): {
					new_locals = insertSet(locals, v);
					switch (e1) {
						FiVar(w,__,__): {
							// Do not change this let statement.
							FiLet(x with
								e2 = evalExpConstExprs(e2, auto,
									FcConstEvalEnv(env with
										consts = eitherMap(
											lookupTree(env.consts, w),
											\c -> setTree(env.consts, w, c),
											env.consts
										)
									),
									new_locals, threshold, debug
								)
							);
						}
						default: {
							let_env = eitherMap(fcConstEval(e1, env, locals, debug),
								\ce1 -> FcConstEvalEnv(env with
									consts = setTree(env.consts, v, ce1)
								), env
							);
							switch (const_eval(e1)) {
								Some(c): {
									FiLet(x with
										type = fiExpType(c.exp),
										e1 = c.exp,
										e2 = evalExpConstExprs(e2, auto, let_env, new_locals, threshold, debug)
									);
								}
								None(): {
									FiLet(x with
										e1 = rec(e1),
										e2 = evalExpConstExprs(e2, auto, let_env, new_locals, threshold, debug)
									);
								}
							}
						}
					}
				}
				FiCall(f, args,__,__): {
					FiCall(x with f = rec(f), args = map(args, rec));
				}
				FiLambda(args, body,__,__): {
					FiLambda(x with
						body = rec_locals(body, fold(args, locals, \acc, arg -> insertSet(acc, arg.name)))
					);
				}
				FiIf(e1, e2, e3,__,__): {
					e1c = rec(e1);
					switch (e1c) {
						FiBool(b,__): if (b) rec(e2) else rec(e3);
						default: FiIf(x with e1 = rec(e1), e2 = rec(e2), e3 = rec(e3));
					}
				}
				FiSwitch(v,__, cs,__,__): {
					do_case_body = \c -> rec_locals(c.body, fold(c.argNames, locals, \acc, arg -> insertSet(acc, arg)));
					switch (lookupTree(env.consts, v.name)) {
						Some(vc): {
							switch (vc.exp) {
								FiCallPrim(op, as,__,__): {
									switch (op) {
										FcStructPrim(name): {
											switch (find(cs, \c -> fiStructMatchesSwitchCase(c.struct, name, env.unions))) {
												Some(c): {
													do_case_body(c);
												}
												None(): {
													switch (find(cs, \c -> c.struct == "default")) {
														Some(c): rec(c.body);
														None(): fail0("switch var constant struct " + name + " doesn't fit any switch variant");
													}
												}
											}
										}
										default: fail0("switch var constant must be a struct");
									}
								}
								default: {
									FiSwitch(x with cases = map(cs, \c -> FiCase(c with body = do_case_body(c))));
								}
							}
						}
						None(): {
							FiSwitch(x with cases = map(cs, \c -> FiCase(c with body = do_case_body(c))));
						}
					}
				}
				FiCast(e,__,__,__,__): {
					FiCast(x with e = rec(e));
				}
				FiSeq(es,__,__): {
					if (length(es) == 0) x else 
					if (length(es) == 1) rec(es[0]) else {
						esc = map(es, rec);
						FiSeq(x with es = filtermapi(esc, \i, y ->
							if (i + 1 == length(es)) Some(y) else
							switch (const_eval(y)) {
								Some(__): None();
								None(): Some(y);
							}
						));
					}
				}
				FiCallPrim(__, es,__,__):{
					FiCallPrim(x with es = map(es, rec));
				}
				FiRequire(__, e,__,__): {
					FiRequire(x with e = rec(e));
				}
				FiUnsafe(__, fb,__,__): {
					FiUnsafe(x with fallback = rec(fb));
				}
				FiConst(): x;
			}
		}
	}
}
