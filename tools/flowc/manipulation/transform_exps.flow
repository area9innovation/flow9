import tools/flowc/incremental/fi_helpers2;
import tools/flowc/manipulation/common;
import tools/flowc/incremental/fi_type_unify;
import tools/flowc/manipulation/effects;
import tools/flowc/manipulation/transform_programs;
import string_utils;
import tools/flowc/backends/cpp3/fi2cpp3_util;

export {

// Expand calls of common field of a struct in some unions to switch with individual 
// structs.
fiTransEliminateUnionFields(expr : FiExp, names: FiGlobalNames) -> FiExp;

/*
Example:
	U :: S1, S2;
		S1(a: int, b: string);
		S2(x: double, a: int);

function
	makeU() -> U { 
		...
	}

	someFn() -> void {
		...
		makeU().a
		...
	}

will expand to
	someFn() -> void {
		...
		__union_3 = makeU();
		switch(__union_3) {
			S1(__field_3,__): __field_3;
			S2(__,__field_3): __field_3;
		}
		...
	}

*/

fiRemoveUnusedVars(e : FiExp, effects : FiEffects) -> FiExp;

// Make explicit cast of a switch variable to all particular cases.
fiExplicitCastInSwitch(e : FiExp, names: FiGlobalNames) -> FiExp;

// Rename enclosed same var name in recurring FiLet.
/* Example: here rettype is recurring, i.e. needs renaming in the inner scope
rettype = {
		switch (type) {
			FiTypeFunction(__, rettype): fiCppLambdaRetType(cfg, program, rettype);
			default: "TODO";
		}
}
*/
fiExpRenameRecurringVars1(e: FiExp, names: FiGlobalNames) -> FiExp;

/* Undo type coercing inside: 
	`if (isSameStructType(a, b)) { 
		e
	}`
transform it to:
	`if (isSameStructType(a, b)) { 
		__prime_a = cast(e: a.type -> b.type);
		e_prime
	}`
where `e_prime` - is e with `a` replaced by `__prime_a`
 */
fiFixVarInSameStructType1(e : FiExp) -> FiExp;

/*
In compound expressions, which contain subexpressions with non-scalar types, extract these
subexpressions via let-statements, which bind them with temporary variables, i.e.

func(Struct("A", 3, 4), 15, "...")

will be transformed into:

v1 = "A";
v2 = Struct(v1, 3, 4);
v3 = "...";
func(v2, 15, v3)

*/
//fiExpExtractNonScalarToLet(e: FiExp) -> FiExp;

// Repace sequences of length 1 by its content
fiExpNormalizeSeqences(e: FiExp) -> FiExp;

// Replace chains of casts into single transitive cast
fiNormalizeCasts(e: FiExp) -> FiExp;

// The same as FiSSA
fiExpMakeVarsUnique(e: FiExp) -> FiExp;
fiExpMakeVarsUniqueCompletely(e: FiExp, names: FiGlobalNames) -> FiExp;

fiExpMakeCastsExplicit(x: FiExp, t: FiType, names: FiGlobalNames) -> FiExp;

fiExpInterpolateTypars(e: FiExp, names: FiGlobalNames) -> FiExp;

fiExpReturnVars(e: FiExp) -> FiExp;

fiExtractCallNonScalarExp(e: FiExp, names: FiGlobalNames) -> FiExp;

fiExtractParticularCalls(e: FiExp, to_extract: Set<string>, names: FiGlobalNames) -> FiExp;

// Remove casts from non-scalar types to flow - these casts are implicit
fiRemoveImplicitCasts(e: FiExp) -> FiExp;

fiRemoveTrivialCasts(e: FiExp) -> FiExp;

fiPushExpsDown(e: FiExp) -> FiExp;

fiIsStat(e: FiExp) -> bool;

// In case a switch has only one variant - remove it
fiExpShortcutTrivialSwitch(e: FiExp, names: FiGlobalNames) -> FiExp;

fiExpChangeAndOr2If(x: FiExp) -> FiExp;

fiExpShortcutIf(x: FiExp) -> FiExp;

fiExpReduceChainLets(x: FiExp) -> FiExp;

fiMakeCallerVar(x: FiExp) -> FiExp;

fiWrapFunctionCasts(x: FiExp) -> FiExp;

fiExpUnfoldCasts(x: FiExp, names: FiGlobalNames, toplevel_name: string, unfold_unions: bool) -> FiExp;

fiWrapGlobalFuncInLambdas(ex : FiExp, names : FiGlobalNames) -> FiExp;

fiInlineHostCalls(e: FiExp, names: FiGlobalNames) -> FiExp;

fiTypeEmptyArrays(e: FiExp) -> FiExp;

fiLabelAnonymLambdaArgs(e: FiExp) -> FiExp;

fiCorrectCastCaseVarType(e: FiExp, sw: Tree<string, Pair<string, FiType>>) -> FiExp;

fiCorrectStructFieldTypes(e: FiExp, names: FiGlobalNames) -> FiExp;

fiRemoveRedundantVoids(e: FiExp) -> FiExp;

fiPurifyTypesInExp(e: FiExp) -> FiExp;

fiComparisonWithConst(e: FiExp, const_cmp_max_size: int) -> FiExp;

}

fiTransEliminateUnionFields(expr : FiExp, names: FiGlobalNames) -> FiExp {
	fiFoldMapExp(expr, 0, 
		\x, env, local -> {
			switch (x) {
				FiCallPrim(op, es, rtype, start): {
					make_switch = \union, switch_var -> {
						FiSwitch(switch_var, switch_var.type, 
							map(union.typenames, \tn -> {
								struct = fiSpecializeStruct(tn, lookupTreeDef(names.structs, tn.name, FiTypeStruct("", [], [], 0)));
								case_var = FiVar(switch_var with 
									type = FiTypeName(struct.name, struct.typars)
								);
								FiCase(
									tn.name,
									map(struct.args, \__ -> "__"),
									FiCallPrim(x with es = replace(es, 0, case_var)),
									start
								)
							}),
							rtype, start
						);
					}
					do_work = \field -> {
						arg = es[0];
						arg_type = fiExpType(arg);
						switch (arg_type) {
							FiTypeName(__,typars): {
								switch (lookupTree(names.unions, arg_type.name)) {
									Some(union): {
										switch (arg) {
											FiVar(var, vtype,__): {
												Pair(make_switch(union, arg), local);
											}
											default: {
												union_var = "__union_" + i2s(local);
												Pair(FiLet(
													union_var, arg_type,
													arg,
													make_switch(union, FiVar(union_var, arg_type, start)),
													rtype, start
												), local + 1);
											}
										}
									}
									None(): Pair(x, local);
								}
							}
							default: Pair(x, local);
						}
					}
					switch (op) {
						FcFieldPrim(field): {
							if (field == "structname") Pair(x, local) else do_work(field);
						}
						FcSetMutablePrim(field): {
							do_work(field);
						}
						default: Pair(x, local);
					}
				}
				default: Pair(x, local);
			}
		},
		AstTraverseOrder(false, true)
	).first;
}

fiRemoveUnusedVars(e : FiExp, effects : FiEffects) -> FiExp {
	mapFiExp(e, \x -> 
		switch (x) {
			FiLet(var, vtype, e1, e2, type, start): {
				switch (fiFindInExpr(e2, \y ->
					switch (y) {
						FiVar(n,__,__): if (n == var) Some(y) else None();
						default: None();
					} 
				)) {
					Some(__): x;
					None(): {
						switch (e1) {
							FiLambda(__,__,__,__): {
								// We can safely skip unused lambda
								e2;
							}
							default: {
								// var is not used
								if (hasFiSideEffects(effects, e1)) {
									switch (e2) {
										FiSeq(es,__,s): {
											if (length(es) == 0) {
												// In this case we can't just concat es with e1,
												// since the type of the expression in that case would change
												FiSeq(e2 with es = [e1, FiVoid(s)]);
											} else {
												FiSeq(e2 with es = concat([e1], es));
											}
										}
										default: FiSeq([e1, e2], type, e1.start);
									}
								} else {
									e2;
								}
							}
						}
					}
				}
			}
			FiSeq(es, __,__): {
				es1 = filtermapi(es, \i, y ->
					// Remove non-last elements with no effects
					if (i + 1 == length(es) || hasFiSideEffects(effects, y)) Some(y) else None()
				);
				if (length(es1) == 1) es1[0] else FiSeq(x with es = es1);
			}
			default: x;
		}
	);
}

fiExplicitCastInSwitch(e : FiExp, names: FiGlobalNames) -> FiExp {
	mapFiExp(e, \x -> 
		switch (x) {
			FiSwitch(var, vtype, cases, type, start): {
				do_switch = \struct_resolver -> {
					FiSwitch(x with
						cases = map(cases, \c -> {
							if (c.struct == "default") c else {
								is_var = \y, nm -> switch (y) {
									FiVar(z,__,__): if (z == nm) Some(y) else None();
									default: None();
								}
								spec_var = var.name + "__spec";
								if (isNone(fiFindInExpr(c.body, \y -> is_var(y, var.name)))) {
									// No variable in the body at all
									c;
								} else if (isSome(fiFindInExpr(c.body, \y -> is_var(y, spec_var)))) {
									// Cast is already done
									c;
								} else {
									case_type = struct_resolver(c.struct);
									FiCase(c with body = 
										FiLet(spec_var, case_type, 
											FiCast(var, vtype, case_type, case_type, start),
											fiReplaceVar(c.body, var.name, FiVar(spec_var, case_type, 0)),
											fiExpType(c.body), c.body.start
										)
									);
								}
							}
						})
					);
				}
				switch (vtype) {
					FiTypeName(typename, typars): {
						if (containsKeyTree(names.unions, typename)) {
							union = lookupTreeDef(names.unions, typename, FiTypeUnion("", [], [], 0));
							if (length(union.typeparameters) != length(typars)) {
								fail("Union " + typename + " type parameters number mismatch: must be " + i2s(length(union.typeparameters)) + 
									" while actual is: " + i2s(length(union.typeparameters))
								);
							}
							/*
								Un<?, ??, ???> ::= ... Str<??, string> ...
								Str(a: ?, b: ??);

								switch (Un<??, int, ?>) {
									Str():
								}

								union  typars:[FiTypeParameter("??"), FiTypeInt(), FiTypeParameter("?")]
								sub:
									? => ??
									?? => int
									??? =? ?
								struct typars:[FiTypeParameter("??"), FiTypeString()]
								sub(struct typars): struct[FiTypeInt(), FiTypeString()]

									RESULT: struct[FiTypeInt(), FiTypeString()]
							*/
							union_types = values2tree(union.typenames, \tn -> tn.name);
							sub = foldi(union.typeparameters, makeTree(), \i, acc, tp -> switch (tp) {
								FiTypeParameter(n): setTree(acc, n, typars[i]);
								default: acc;
							});
							do_switch(\struct_name -> {
								struct = lookupTreeDef(union_types, struct_name, FiTypeName("", []));
								fiSubstituteTypars(struct, sub);
							});
						} else {
							switch (find(cases, \c -> c.struct == typename)) {
								Some(c): {
									c.body;
								}
								None(): {
									fail0("unmatched struct type '" + typename + "' in switch:\n" + prettyFiExp(dummyPretty, e));
								}
							}
						}
					}
					default: {
						do_switch(\struct_name -> eitherMap(
							lookupTree(names.structs, struct_name),
							\struct -> {
								typars_instances = fiMatchTyparsOrdered(FiTypeName(struct.name, struct.typars), vtype);
								FiTypeName(struct_name, typars_instances);
							},
							FiTypeName("", [])
						));
					}
				}
			}
			default: x;
		}
	);
}

fiExpRenameRecurringVars1(e: FiExp, names: FiGlobalNames) -> FiExp {
	fiMapExp(e, \x, env ->
		switch (x) {
			FiLet(v, type, e1, e2,__, start): {
				if (v == "__" || !containsKeyTree(env.locals, v)) x else {
					w = fiMakeNewVar("", v, env.locals, names);
					FiLet(x with
						name = w,
						e2 = fiRenameVar(e2, v, w)
					);
				}
			}
			default: x;
		}, false
	);
}

fiFixVarInSameStructType1(e : FiExp) -> FiExp {
	fiDetectIfIsSameStructType = \x -> switch (x.e1) {
		FiCall(f, args, __,__): {
			switch (f) {
			FiVar(name,__,__): {
				if (name == "isSameStructType") {
					filtermap(args, \arg -> 
						switch (arg) {
							FiVar(__,__,__): Some(arg);
							default: None();
						}
					);
				} else {
					[];
				}
			}
			default: [];
			}
		}
		default: [];
	}
	fiVarTypeInExpr = \y , var -> maybeMap(
		fiFindInExpr(y, \x ->
			switch (x) {
				FiVar(name,__,__): if (name == var) Some(x) else None();
				default: None();
			}
		), \x -> cast(x: FiExp -> FiVar)
	);
	mapFiExp(e, \x ->
		switch (x) {
			FiIf(e1, e2, e3, type, start): {
				vars = fiDetectIfIsSameStructType(x);
				if (length(vars) != 2) x else {
					v0 = vars[0];
					v1 = vars[1];
					fix_vars = \old: FiVar, new: FiVar -> {
						prim_name = "__prim_" + old.name;
						/* Example: 
							if (isSameStructType(acc, el)) {
								t : ?? = cast(flow(el) : flow -> ??);
								...
							} ...
						*/
						e2_prim = FiLet(prim_name, new.type, 
							FiCast(old, old.type, new.type, new.type, start),
							fiRenameVar(e2, old.name, prim_name), type, start
						);
						/*
							if (isSameStructType(acc, el)) {
								__prim_el : ?? = cast(el : ? -> ??);
								t : ?? = cast(flow(__prim_el) : flow -> ??);
								...
							} ...
						*/
						e2_prim_prim = mapFiExp(e2_prim, \y ->
							switch (y) {
								FiCast(y_e, y_from, y_to, y_type, __): {
									if (!fiEqualTypes(new.type, y_type)) y else {
										switch (y_e) {
											FiCall(fn, args, __,__): {
												switch (fn) {
													FiVar(fn_name,__,__): {
														if (fn_name != "flow") y else {
															switch (args[0]) {
																FiVar(arg_name,__,__): {
																	if (arg_name != prim_name) y else {
																		/*
																			if (isSameStructType(acc, el)) {
																				__prim_el : ?? = cast(el : ? -> ??);
																				t : ?? = __prim_el;
																				...
																			} ...
																		*/
																		args[0];
																	}
																}
																default: y;
															}
														}
													}
													default: y;
												}
											}
											default: y;
										}
									}
								}
								default: y;
							}
						);
						FiIf(x with e2 = e2_prim_prim);
					}
					switch (fiVarTypeInExpr(e2, v0.name)) {
						Some(v0_prim): {
							fix_vars(v0, v0_prim);
						}
						None(): {
							switch (fiVarTypeInExpr(e2, v1.name)) {
								Some(v1_prim): fix_vars(v1, v1_prim);
								None(): x;
							}
						}
					} 
				}
			}
			default: x;
		}
	);
}

fiExpNormalizeSeqences(e: FiExp) -> FiExp {
	mapFiExp(e,
		\x, -> switch (x) {
			FiSeq(es,__,__): {
				if (length(es) == 1) es[0] else {
					FiSeq(x with es = mapConcat(es, \y ->
						switch (y) {
							FiSeq(es1,__,__): es1;
							default: [y];
						}
					));
				}
			}
			default: x;
		}
	);
}

fiExpMakeVarsUniqueCompletely(e: FiExp, names: FiGlobalNames) -> FiExp {
	vars_map = ref makeTree();
	fiMapExp(e, \x, env ->
		switch (x) {
			FiLet(v, type, e1, e2,__, start): {
				if (v == "__") x else {
					switch (lookupTree(^vars_map, v)) {
						Some(i): {
							w = fiMakeNewVari("", v, env.locals, names, i);
							vars_map := setTree(^vars_map, v, i + 1);
							FiLet(x with
								name = w,
								e2 = fiRenameVar(e2, v, w)
							);
						}
						None(): {
							vars_map := setTree(^vars_map, v, 0);
							x;
						}
					}
				}
			}
			FiLambda(args, body,__,__): {
				p = fold(args, Pair([], body), \acc, arg ->
					switch (lookupTree(^vars_map, arg.name)) {
						Some(i): {
							w = fiMakeNewVari("", arg.name, env.locals, names, i);
							vars_map := setTree(^vars_map, arg.name, i + 1);
							Pair(arrayPush(acc.first, FiFunArg(w, arg.type)), fiRenameVar(acc.second, arg.name, w));
						}
						None(): {
							vars_map := setTree(^vars_map, arg.name, 0);
							Pair(arrayPush(acc.first, arg), acc.second);
						}
					}
				);
				FiLambda(x with args = p.first, body = p.second);
			}
			default: x;
		}, false
	);
}

fiExpMakeVarsUnique(e: FiExp) -> FiExp {
	fiDoExpMakeVarsUnique(e, makeTree(), makeTree());
}

fiDoExpMakeVarsUnique(e: FiExp, counter: Tree<string, int>, rename: Tree<string, string>) -> FiExp {
	do = \x -> fiDoExpMakeVarsUnique(x, counter, rename);
	switch (e) {
		FiLet(name,__,e1, e2,__,__): {
			if (name == "__") {
				FiLet(e with e1 = do(e1), e2 = do(e2));
			} else {
				counter1 = setTree(counter, name, lookupTreeDef(counter, name, -1) + 1);
				rename1 = if (!containsKeyTree(counter, name)) rename else {
					setTree(rename, name, name + "__ssa_" + i2s(lookupTreeDef(counter1, name, 0) - 1))
				}
				FiLet(e with
					name = lookupTreeDef(rename1, name, name),
					e1 = fiDoExpMakeVarsUnique(e1, counter1, rename1), 
					e2 = fiDoExpMakeVarsUnique(e2, counter, rename1),
				);
			}
		}
		FiVar(name,__,__): {
			if (!containsKeyTree(rename, name)) e else {
				FiVar(e with name = lookupTreeDef(rename, name, name));
			}
		}
		FiLambda(args, body,__,__): {
			FiLambda(e with body = do(body));
		}
		FiSwitch(v, vtype, cases,__,__): {
			FiSwitch(e with 
				x = FiVar(v with name = lookupTreeDef(rename, v.name, v.name)),
				cases = map(cases, \c -> FiCase(c with body = do(c.body)))
			);
		}
		FiIf(e1, e2, e3, __,__): { 
			FiIf(e with e1 = do(e1), e2 = do(e2), e3 = do(e3));
		}
		FiSeq(es,__,__): {
			FiSeq(e with es = map(es, do));
		}
		FiCast(x, from, to,__,__): { 
			FiCast(e with e = do(x));
		}
		FiCall(f, args,__,__): { 
			FiCall(e with f = do(f), args = map(args, do));
		}
		FiCallPrim(op, args,__,__): { 
			FiCallPrim(e with es = map(args, do));
		}
		FiRequire(file, x,__,__): { 
			FiRequire(e with e = do(x));
		}
		FiUnsafe(name, x,__,__): { 
			FiUnsafe(e with fallback = do(x));
		}
		FiConst(): e;
	}
}

fiExpMakeCastsExplicit(x: FiExp, t: FiType, names: FiGlobalNames) -> FiExp {
	switch (x) {
		FiLambda(args, body, type, start): {
			body1 = switch (type) {
				FiTypeFunction(__,returnType): fiExpMakeCastsExplicit(body, returnType, names);
				default: fiExpMakeCastsExplicit(body, fiExpType(body), names);
			}
			switch (t) {
				FiTypeFunction(t_args, t_ret): {
					if (length(args) != length(t_args)) {
						fail("function args length mismatch with function arguments length:\n" +
							"args: [" + superglue(args, \y -> pretFiType(y.type), ", ") + "]\n" + 
							"t_args: [" + superglue(t_args, \y -> pretFiType(y.type), ", ") + "]\n"
						);
					}
					p = foldi(args, Pair([], body1), \i, acc, arg -> 
						if (fiEqualTypes(arg.type, t_args[i].type)) {
							Pair(concat(acc.first, [arg]), acc.second);
						} else {
							new_arg = FiFunArg(arg.name, t_args[i].type);
							new_body = fiReplaceVar(acc.second, arg.name, 
								fiMakeCast(FiVar(arg.name, t_args[i].type, start), t_args[i].type, arg.type)
							);
							Pair(concat(acc.first, [new_arg]), new_body);
						}
					);
					body2 = p.second;
					body2_type = fiExpType(body2);
					t1 = FiTypeFunction(t with 
						args = mapi(t_args, \i, t_arg -> FiFunArg(args[i].name, t_arg.type))
					);
					if (fiEqualTypes(body2_type, t_ret)) {
						FiLambda(x with args = p.first, body = body2, type = t1);
					} else {
						FiLambda(x with args = p.first, body = fiMakeCast(body2, body2_type, t_ret), type = t1);
					}
				}
				FiTypeFlow(): {
					FiCast(FiLambda(x with body = body1), type, t, t, start);
				}
				default: {
					fail("lambda must have a functional type");
					x;
				}
			}
		}
		FiLet(v, v_type, e1, e2, type,__): {
			FiLet(x with 
				e1 = fiExpMakeCastsExplicit(e1, v_type, names),
				e2 = fiExpMakeCastsExplicit(e2, t, names),
				type2 = t
			);
		}
		FiIf(e1, e2, e3, type,__): {
			FiIf(x with
				e1 = fiExpMakeCastsExplicit(e1, FiTypeBool(), names),
				e2 = fiExpMakeCastsExplicit(e2, t, names),
				e3 = fiExpMakeCastsExplicit(e3, t, names),
				type = t
			);
		}
		FiSwitch(v, v_type, cases, type,__): {
			x1 = FiSwitch(x with
				cases = map(cases, \c -> FiCase(c with body = fiExpMakeCastsExplicit(c.body, t, names))),
				type = t
			);
			fiMakeCast(x1, fiExpType(x1), t);
		}
		FiSeq(es, type,__): {
			FiSeq(x with 
				es = mapi(es, \i, e ->
					if (i + 1 == length(es)) fiExpMakeCastsExplicit(e, t, names)
					else fiExpMakeCastsExplicit(e, fiExpType(e), names)
				),
				type = t
			);
		}
		FiCall(fn, args, type,__): {
			fn_type = cast(fiExpType(fn): FiType -> FiTypeFunction);
			if (length(args) != length(fn_type.args)) {
				fail("function call args length mismatch with function arguments length:\n" +
					"args: [" + superglue(args, \y -> pretFiType(fiExpType(y)), ", ") + "]\n" + 
					"fn_type.args: [" + superglue(fn_type.args, \y -> pretFiType(y.type), ", ") + "]\n"
				);
			}
			x1 = FiCall(x with
				f = fiExpMakeCastsExplicit(fn, fn_type, names),
				args = mapi(args, \i, arg ->
					fiExpMakeCastsExplicit(arg, fn_type.args[i].type, names)
				)
			);
			fiMakeCast(x1, type, t);
		}
		FiCallPrim(op, es, type, s): {
			def_case = \ -> fiMakeCast(
				FiCallPrim(x with es = map(es, \y -> fiExpMakeCastsExplicit(y, fiExpType(y), names))), 
				type, t
			);
			switch (t) {
				FiTypeFlow(): def_case();
				default: {
					typed_case = \tp -> FiCallPrim(x with 
						es = map(es, \y -> fiExpMakeCastsExplicit(y, tp, names)),
						type = t
					);
					mtyped_case = \mtp, defval -> switch (mtp) {
						Some(tp): typed_case(tp);
						None(): defval();
					}
					switch (op) {
						FcOrPrim():  def_case();
						FcAndPrim(): def_case();
						FcNotPrim(): def_case();

						FcEqPrim():  mtyped_case(fiTypeUpperBoundary(fiExpType(es[0]), fiExpType(es[1]), names), \-> FiBool(false, s));
						FcNePrim():  mtyped_case(fiTypeUpperBoundary(fiExpType(es[0]), fiExpType(es[1]), names), \-> FiBool(true, s));
						FcLePrim():  mtyped_case(fiTypeUpperBoundary(fiExpType(es[0]), fiExpType(es[1]), names), \-> FiBool(false, s));
						FcGePrim():  mtyped_case(fiTypeUpperBoundary(fiExpType(es[0]), fiExpType(es[1]), names), \-> FiBool(false, s));
						FcLtPrim():  mtyped_case(fiTypeUpperBoundary(fiExpType(es[0]), fiExpType(es[1]), names), \-> FiBool(false, s));
						FcGtPrim():  mtyped_case(fiTypeUpperBoundary(fiExpType(es[0]), fiExpType(es[1]), names), \-> FiBool(false, s));

						FcPlusPrim():  mtyped_case(fiTypeLowerBoundary(fiExpType(es[0]), fiExpType(es[1]), names), \-> fail0("+ operatos must have same type"));
						FcMinusPrim(): def_case();
						FcMulPrim():   def_case();
						FcDivPrim():   def_case();
						FcModPrim():   def_case();
						FcNegPrim():   def_case();
						FcArrayPrim(): switch(t) {
							FiTypeArray(at): typed_case(at);
							default: def_case();
						}
						FcIndexPrim(): {
							switch (fiExpType(es[0])) {
								FiTypeString(): {
									// special case: index of char in a string.
									FiCallPrim(x with
										es = [
											fiExpMakeCastsExplicit(es[0], FiTypeString(), names),
											fiExpMakeCastsExplicit(es[1], FiTypeInt(), names)
										],
										type = t
									);
								}
								default: {
									FiCallPrim(x with
										es = [
											fiExpMakeCastsExplicit(es[0], FiTypeArray(t), names),
											fiExpMakeCastsExplicit(es[1], FiTypeInt(), names)
										],
										type = t
									);
								}
							}
						}
						FcDerefPrim(): typed_case(FiTypeRef(t));
						FcRefPrim(): switch (t) {
							FiTypeRef(rt): typed_case(rt);
							default: def_case();
						}
						FcStructPrim(name): {
							struct = lookupTreeDef(names.structs, name, FiTypeStruct("", [], [], 0));
							switch (type) {
								FiTypeName(__,typars): {
									if (length(struct.typars) != length(typars)) {
										fail("struct " + name + " typars length mismatch with typename typars length:\n" +
											"struct typars: [" + superglue(struct.typars, pretFiType, ", ") + "]\n" + 
											"typename typars: [" + superglue(typars, pretFiType, ", ") + "]\n"
										);
									}
									typar_subst = foldi(struct.typars, makeTree(), \i, acc, tp ->
										switch (tp) {
											FiTypeParameter(nm): setTree(acc, nm, typars[i]);
											default: acc;
										}
									);
									if (length(struct.args) != length(es)) {
										fail("struct " + name + " arguments length mismatch with call arguments length:\n" +
											"struct args: [" + superglue(struct.args, \y -> pretFiType(y.type), ", ") + "]\n" + 
											"call args: [" + superglue(es, \y -> pretFiType(fiExpType(y)), ", ") + "]\n"
										);
									}
									x1 = FiCallPrim(x with es = mapi(es, \i, y ->
										fiExpMakeCastsExplicit(y, fiApplyTypeSubstitution(typar_subst, struct.args[i].type), names)
									));
									fiMakeCast(x1, type, t);
								}
								default: {
									fail("struct type must be FiTypeName, got: " + toString(type));
									def_case();
								}
							}
						}
						FcFieldPrim(name): {
							if (name == "structname") def_case() else {
								switch (fiExpType(es[0])) {
									FiTypeName(struct_name, typars): {
										switch (lookupTree(names.structs, struct_name)) {
											Some(struct): {
												switch (find(struct.args, \arg -> arg.name == name)) {
													Some(arg): {
														fiMakeCast(def_case(), arg.type, type);
													}
													None(): {
														fail("field '" + name + "' of struct '" + struct_name + "' is not found in expression: " + pretFiExp(x)
															+ "\n" + strIndent(toStringFormatted(x))
														);
														def_case();
													}
												}
											}
											None(): def_case();
										}
									}
									default: def_case();
								}
							}
						}
						FcAssignPrim(): {
							to = es[0];
							what = es[1];
							tp = fiExpType(to);
							switch (tp) {
								FiTypeRef(rt): {
									switch (fiExpType(what)) {
										FiTypeRef(__): {
											FiCallPrim(x with es = [
												fiExpMakeCastsExplicit(to, tp, names), 
												fiExpMakeCastsExplicit(what, tp, names)
											]);
										}
										default: {
											FiCallPrim(x with es = [
												fiExpMakeCastsExplicit(to, tp, names), 
												fiExpMakeCastsExplicit(what, rt, names)
											]);
										}
									}
								}
								default: {
									FiCallPrim(x with es = [
										fiExpMakeCastsExplicit(to, tp, names), 
										fiExpMakeCastsExplicit(what, tp, names)
									]);
								}
							}
						}
						FcSetMutablePrim(name): {
							struct_type = fiExpType(es[0]);
							switch (struct_type) {
								FiTypeName(struct_name, typars): {
									switch (lookupTree(names.structs, struct_name)) {
										Some(struct): {
											spec = fiSpecializeStruct(struct_type, struct);
											switch (find(spec.args, \arg -> arg.name == name)) {
												Some(arg): {
													if (length(es) != 2) {
														fail("FcSetMutablePrim must have exactly 2 arguments, but is:\n" + 
															//pretFiExp(x) + "\n" + 
															"raw format:\n" + toStringFormatted(x)
														);
													}
													FiCallPrim(x with es = [
														fiExpMakeCastsExplicit(es[0], struct_type, names), 
														fiExpMakeCastsExplicit(es[1], arg.type, names)
													]);
												}
												None(): {
													fail("field '" + name + "' of struct '" + struct_name + "' is not found in expression: " + pretFiExp(x)
														+ "\n" + strIndent(toStringFormatted(x))
													);
													def_case();
												}
											}
										}
										None(): def_case();
									}
								}
								default: def_case();
							}
						}
						FcCreateClosurePrim(structName, functionName): def_case();
						FcQuote(): def_case();
						FcUnquote(): def_case();
					}
				}
			}
		}
		FiCast(e, from, to, type,__): {
			x1 = FiCast(x with e = fiExpMakeCastsExplicit(e, from, names));
			fiNormalizeCasts(fiMakeCast(x1, type, t));
		}
		FiUnsafe(name, fallback, type,__): {
			x1 = FiUnsafe(x with fallback = fiExpMakeCastsExplicit(fallback, fiExpType(fallback), names));
			fiMakeCast(x1, type, t);
		}
		FiRequire(file, e, type,__): {
			x1 = FiRequire(x with e = fiExpMakeCastsExplicit(e, fiExpType(e), names));
			fiMakeCast(x1, type, t);
		}
		FiVar(name, type, __): {
			fiMakeCast(x, type, t);
		}
		FiVoid(__):      fiMakeCast(x, FiTypeVoid(), t);
		FiBool(__,__):   fiMakeCast(x, FiTypeBool(), t);
		FiInt(__,__):    fiMakeCast(x, FiTypeInt(), t);
		FiDouble(__,__): fiMakeCast(x, FiTypeDouble(), t);
		FiString(__,__): fiMakeCast(x, FiTypeString(), t);
	}
}

fiNormalizeCasts(e: FiExp) -> FiExp {
	mapFiExp(e, \x -> switch (x) {
		FiCast(y, x_from, x_to, x_type, start): {
			if (fiEqualTypes(x_from, x_to)) y else {
				switch (y) {
					FiCast(z, y_from, y_to, y_type, __): {
						if (!fiEqualTypes(y_to, x_from)) {
							fail("inconsistent cast sequence callee type " + prettyFiType(dummyPretty, y_to, makeSet()) + " differs from the caller type " + prettyFiType(dummyPretty, x_from, makeSet()));
						}
						if (fiEqualTypes(y_from, x_to)) z else
						FiCast(z, y_from, x_to, x_type, start);
					}
					default: x;
				}
			}
		}
		default: x;
	});
}

fiExpInterpolateTypars(e: FiExp, names: FiGlobalNames) -> FiExp {
	mapFiExp(e, \x -> switch (x) {
		FiCall(fn, args, ret_type,__): {
			switch (fiExpType(fn)) {
				FiTypeFunction(fn_args, returnType): {
					// Match arguments 
					args_unified = mapi(args, \i, arg -> fiUnifyTypes(fiExpType(arg), fn_args[i].type));
					ret_unified = fiUnifyTypes(returnType, ret_type);
					FiCall(x with 
						f = fiSetExpType(fn, FiTypeFunction(
							mapi(fn_args, \i, arg -> FiFunArg(arg.name, args_unified[i].second)),
							ret_unified.second
						)), 
						args = mapi(args, \i, arg -> fiSetExpType(arg, args_unified[i].first)),
						type = ret_unified.first
					);
				}
				default: {
					FiCall(x with f = fn, args = args);
				}
			}
		}
		FiCallPrim(op, es, type,__): {
			switch (op) {
				FcStructPrim(name): {
					struct = lookupTreeDef(names.structs, name, FiTypeStruct("", [], [], 0));
					switch (type) {
						FiTypeName(__,typars): {
							typar_subst = foldi(struct.typars, makeTree(), \i, acc, tp ->
								switch (tp) {
									FiTypeParameter(nm): setTree(acc, nm, typars[i]);
									default: acc;
								}
							);
							subst = foldi(struct.args, makeTree(), \i, sub, struct_arg -> 
								fiMatchTypars(fiExpType(es[i]), fiApplyTypeSubstitution(typar_subst, struct_arg.type), sub)
							);
							FiCallPrim(x with es = mapi(es, \i, y ->
								fiSetExpType(y, fiApplyTypeSubstitution(subst, fiExpType(y)))
							));
						}
						default: {
							fail("struct type must be FiTypeName, got: " + toString(type));
							x;
						}
					}
				}
				default: x;
			}
		}
		default: x;
	});
}

fiExpReturnVars(e: FiExp) -> FiExp {
	fiDoExpReturnVars(e, true);
}

fiDoExpReturnVars(e: FiExp, returns: bool) -> FiExp {
	wrap_with_var = \x : FiExp -> {
		if (!returns) x else {
			switch (x) {
				FiVar(__,__,__): x;
				default: {
					tp = fiExpType(x);
					switch (tp) {
						FiTypeVoid(): {
							switch (x) {
								FiVoid(__): x;
								default: FiSeq([x, FiVoid(x.start)], tp, x.start);
							}
						}
						default: {
							ret = "__ret_var__";
							FiLet(ret, tp, x, FiVar(ret, tp, x.start), tp, x.start);
						}
					}
				}
			}
		}
	}
	switch (e) {
		FiLambda(__, body,__, __): {
			FiLambda(e with body = fiDoExpReturnVars(body, true));
		}
		FiCall(fn, args,__,__): {
			wrap_with_var(FiCall(e with
				f = fiDoExpReturnVars(fn, false),
				args = map(args, \x -> fiDoExpReturnVars(x, false))
			));
		}
		FiLet(__, __,e1, e2,__, __): {
			FiLet(e with
				e1 = fiDoExpReturnVars(e1, false),
				e2 = fiDoExpReturnVars(e2, returns)
			);
		}
		FiIf(e1, e2, e3,__, __): {
			FiIf(e with
				e1 = fiDoExpReturnVars(e1, false),
				e2 = fiDoExpReturnVars(e2, returns),
				e3 = fiDoExpReturnVars(e3, returns)
			);
		}
		FiSwitch(v, __,cases,__, __): {
			FiSwitch(e with 
				cases = map(cases, \c -> FiCase(c with body = fiDoExpReturnVars(c.body, returns)))
			);
		}
		FiCast(ex, __, __, __, __): {
			wrap_with_var(FiCast(e with e = fiDoExpReturnVars(ex, false)));
		}
		FiSeq(es,__,__): {
			FiSeq(e with es = mapi(es, \i, x -> fiDoExpReturnVars(x, returns && i + 1 == length(es))));
		}
		FiCallPrim(__, es,__,__): {
			wrap_with_var(FiCallPrim(e with es = map(es, \x -> fiDoExpReturnVars(x, false))));
		}
		FiRequire(__, ex,__,__): {
			wrap_with_var(FiRequire(e with e = fiDoExpReturnVars(ex, false)));
		}
		FiUnsafe(__, ex,__,__): {
			wrap_with_var(FiUnsafe(e with fallback = fiDoExpReturnVars(ex, false)));
		}
		FiVar(name,__, __): e;
		FiVoid(__):       e;
		FiDouble(__,__):  e;
		FiInt(__,__):     e;
		FiString(__,__):  e;
		FiBool(__,__):    e;
	}
}

fiExtractCallNonScalarExp(e: FiExp, names: FiGlobalNames) -> FiExp {
	tmp_var_counter = ref 0;
	new_num = \-> {
		num = i2s(^tmp_var_counter);
		tmp_var_counter := ^tmp_var_counter + 1;
		num;
	}
	fiMapExp(e,
		\x, env -> switch (env.parents) {
			EmptyList(): x;
			Cons(parent,__): {
				try_call = \force_extract -> switch (x) {
					FiVar(__,__,__): x;
					FiInt(__,__): x;
					FiBool(__,__): x;
					FiDouble(__,__): x;
					FiVoid(__): x;
					FiLet(__,__,__,__,__,__): x;
					default: {
						type = fiExpType(x);
						if (fiTypeIsScalar(type) && !force_extract) x else {
							fn_var = fiMakeNewVar("w", new_num(), env.locals, names);
							FiLet(fn_var, type, x, FiVar(fn_var, type, 0), type, 0);
						}
					}
				}
				switch (parent.first) {
					FiLet(v, v_type, e1, e2,__,__): x;
					FiSeq(__,__,__): x;
					FiSwitch(__,__,__,__,__): x;
					FiIf(__,__,__,__,__): x;
					FiLambda(__,__,__,__): x;
					FiCallPrim(op,__,__,__): {
						switch (op) {
							FcStructPrim(__): try_call(true);
							default: try_call(false);
						}
					}
					default: try_call(false);
				}
			}
		},
		false
	);
}

fiExtractParticularCalls(e: FiExp, to_extract: Set<string>, names: FiGlobalNames) -> FiExp {
	tmp_var_counter = ref 0;
	new_num = \-> {
		num = i2s(^tmp_var_counter);
		tmp_var_counter := ^tmp_var_counter + 1;
		num;
	}
	fiMapExp(e,
		\x, env -> switch (x) {
			FiCall(fn,__,__,__): {
				switch (fn) {
					FiVar(fn_name,__,__): {
						if (!containsSet(to_extract, fn_name)) x else {
							type = fiExpType(x);
							if (type == FiTypeVoid()) x else {
								fn_var = fiMakeNewVar("wx", new_num(), env.locals, names);
								FiLet(fn_var, type, x, FiVar(fn_var, type, 0), type, 0);
							}
						}
					}
					default: x;
				}
			}
			default: x;
		},
		true
	);
}

fiRemoveImplicitCasts(e: FiExp) -> FiExp {
	mapFiExp(e, \x -> switch (x) {
		FiCast(y, from, to, type, start): {
			switch (to) {
				FiTypeFlow(): {
					if (fiTypeIsScalar(from)) x else y;
				}
				default: x;
			}
		}
		default: x;
	});
}

fiRemoveTrivialCasts(e: FiExp) -> FiExp {
	mapFiExp(e, \x -> switch (x) {
		FiCast(y, from, to, type, start): {
			if (fiEqualTypes(from, to)) y else x;
		}
		default: x;
	});
}

fiLastVarUses(e: FiExp) -> [List<int>] {
	make_index_path = \pairs -> mapList(pairs, \p -> p.second);
	fiFoldExp(e, Pair([], makeSet()), \x, env, acc -> 
		switch (x) {
			FiVar(name, __,__): {
				if (containsSet(acc.second, name)) acc else {
					Pair(
						concat(acc.first, [make_index_path(env.parents)]),
						insertSet(acc.second, name)
					);
				}
			}
			default: acc;
		},
		AstTraverseOrder(true, false)
	).first;
}

fiIsStat(e: FiExp) -> bool {
	switch (e) {
		FiSeq(__,__,__): true;
		FiLet(__,__,__,__,__,__): true;
		FiSwitch(__,__,__,__,__): true;
		FiIf(__,__,__,__,__): true;
		FiCallPrim(op,__,__,__): {
			switch (op) {
				FcAssignPrim(): true;
				FcSetMutablePrim(__): true;
				default: false;
			}
		}
		default: false;
	}
}

fiStatsArePulled(e: FiExp) -> bool {
	isNone(fiFindInExpr(e, \x -> 
		switch (x) {
			FiLet(__,__, e1,__,__,__): {
				if (fiIsStat(e1)) Some(x) else None();
			}
			FiIf(e1,__,__,__,__): {
				if (fiIsStat(e1)) Some(x) else None();
			}
			FiCall(f, args,__,__): {
				if (exists(concat([f], args), fiIsStat)) Some(x) else None();
			}
			FiCast(e1,__,__,__,__): {
				if (fiIsStat(e1)) Some(x) else None();
			}
			FiCallPrim(__,es,__,__): {
				if (exists(es, fiIsStat)) Some(x) else None();
			}
			default: None();
		}
	));
}

fiDoPushExpsDown(i: int, xs: [FiExp], as: [FiExp], fn: ([FiExp]) -> FiExp, type: FiType) -> FiExp {
	if (i == length(xs)) fn(as) else {
		x = xs[i];
		switch (x) {
			FiIf(e1, e2, e3,__,__): {
				FiIf(x with
					type = type,
					e2 = fiDoPushExpsDown(i + 1, xs, concat(as, [e2]), fn, type),
					e3 = fiDoPushExpsDown(i + 1, xs, concat(as, [e3]), fn, type)
				);
			}
			FiSeq(es,__,__): {
				FiSeq(x with
					type = type,
					es = replace(es, length(es) - 1,
						fiDoPushExpsDown(i + 1, xs, concat(as, [es[length(es) - 1]]), fn, type)
					)
				);
			}
			FiLet(__,__,e1,e2,__,__): {
				FiLet(x with
					type2 = type,
					e2 = fiDoPushExpsDown(i + 1, xs, concat(as, [e2]), fn, type)
				);
			}
			FiSwitch(__,__,cs,__,__): {
				FiSwitch(x with
					type = type,
					cases = map(cs, \c -> 
						FiCase(c with body = fiDoPushExpsDown(i + 1, xs, concat(as, [c.body]), fn, type))
					)
				);
			}
			default: {
				fiDoPushExpsDown(i + 1, xs, concat(as, [x]), fn, type)
			}
		}
	}
}

fiPushExpDown(x: FiExp) -> FiExp {
	if (fiStatsArePulled(x)) x else {
		switch (x) {
			FiLet(v, vtype, e1, e2, type, start): {
				if (!fiIsStat(e1)) x else {
					switch (e1) {
						FiSeq(es1, type1, start1): {
							if (length(es1) == 1) FiLet(v, vtype, es1[0], e2, type, start) else {
								FiSeq(
									concat(
										take(es1, length(es1) - 1),
										[fiPushExpDown(FiLet(v, vtype, es1[length(es1) - 1], e2, type, start))]
									), type, start1
								);
							}
						}
						FiLet(v1, vtype1, e1_1, e1_2, type1, start1): {
							FiLet(v1, vtype1, e1_1,
								fiPushExpDown(FiLet(v, vtype, e1_2, e2, type, start)),
								type, start1
							);
						}
						FiSwitch(x1, swtype1, cs1, type1, start1): {
							FiSwitch(x1, swtype1, map(cs1, \c1 ->
									FiCase(c1 with body = fiPushExpDown(FiLet(v, vtype, c1.body, e2, type, start)))
								), 
								type, start1
							);
						}
						FiIf(e1_1, e1_2, e1_3, type1, start_1): {
							FiIf(e1_1, 
								fiPushExpDown(FiLet(v, vtype, e1_2, e2, type, start)),
								fiPushExpDown(FiLet(v, vtype, e1_3, e2, type, start)),
								type, start_1
							);
						}
						default: x; // TODO: FsAssign
					}
				}
			}
			FiIf(e1, e2, e3, type, start): {
				if (!fiIsStat(e1)) x else {
					switch (e1) {
						FiSeq(es1, type1, start1): {
							if (length(es1) == 1) FiIf(es1[0], e2, e3, type, start) else {
								FiSeq(
									concat(
										take(es1, length(es1) - 1),
										[fiPushExpDown(FiIf(es1[length(es1) - 1], e2, e3, type, start))]
									), type, start1
								);
							}
						}
						FiLet(v1, vtype1, e1_1, e1_2, type1, start1): {
							FiLet(v1, vtype1, e1_1,
								fiPushExpDown(FiIf(e1_2, e2, e3, type, start)),
								type, start1
							);
						}
						FiSwitch(x1, swtype1, cs1, type1, start1): {
							FiSwitch(x1, swtype1, map(cs1, \c1 ->
									FiCase(c1 with body = fiPushExpDown(FiIf(c1.body, e2, e3, type, start)))
								), 
								type, start1
							);
						}
						FiIf(e1_1, e1_2, e1_3, type1, start_1): {
							FiIf(e1_1, 
								fiPushExpDown(FiIf(e1_2, e2, e3, type, start)),
								fiPushExpDown(FiIf(e1_3, e2, e3, type, start)),
								type, start_1
							);
						}
						default: x; // TODO: FsAssign
					}
				}
			}
			FiCall(f, args, type, start): {
				if (!exists(concat([f], args), fiIsStat)) x else {
					fiDoPushExpsDown(0, concat([f], args), [], \as ->
						fiPushExpDown(FiCall(as[0], tail(as), type, start)), 
						type
					);
				}
			}
			FiCast(e, from, to, type, start): {
				if (!fiIsStat(e)) x else {
					fiDoPushExpsDown(0, [e], [], \as ->
						fiPushExpDown(FiCast(as[0], from, to, type, start)),
						type
					);
				}
			}
			FiLambda(__,body,__,__): {
				x;
			}
			FiCallPrim(op, es, type, start): {
				if (!exists(es, fiIsStat)) x else {
					fiDoPushExpsDown(0, es, [], \as ->
						fiPushExpDown(FiCallPrim(op, as, type, start)),
						type
					);
				}
			}
			default: x;
		}
	}
}

fiPushExpsDown(e: FiExp) -> FiExp {
	fiExpShortcutIf(mapFiExp(e, fiPushExpDown));
}

// In case a switch has only one variant - remove it
fiExpShortcutTrivialSwitch(x: FiExp, names: FiGlobalNames) -> FiExp {
	mapFiExp(x, \e -> switch (e) {
		FiSwitch(v, vtype, cs, type, start): {
			switch (vtype) {
				FiTypeName(typename,__): {
					if (containsKeyTree(names.unions, typename)) {
						e;
					} else {
						switch (find(cs, \c -> c.struct == typename)) {
							Some(c): c.body;
							None(): {
								fail0("unmatched struct type '" + typename + "' in switch:\n" + prettyFiExp(dummyPretty, e));
							}
						}
					}
				}
				FiTypeFlow(): {
					e;
				}
				default: {
					fail0("non-struct|union|flow type " + prettyFiType(dummyPretty, v.type, makeSet()) + " in switch:\n" + prettyFiExp(dummyPretty, e));
				}
			}
		}
		default: e;
	});
}

fiIsSimpleForIfExp(x: FiExp) -> bool {
	switch (x) {
		FiBool(__,__): true;
		FiInt(__,__): true;
		FiDouble(__,__): true;
		FiString(__,__): true;
		FiCallPrim(op, es,__,__): {
			switch (op) {
				FcAndPrim(): true;
				FcOrPrim(): true;
				FcNotPrim(): true;

				FcPlusPrim(): true;
				FcMinusPrim(): true;
				FcMulPrim(): true;
				FcDivPrim(): true;
				FcModPrim(): true;
				FcNegPrim(): true;

				FcEqPrim(): true;
				FcNePrim(): true;
				FcGtPrim(): true;
				FcLtPrim(): true;
				FcGePrim(): true;
				FcLePrim(): true;

				FcFieldPrim(__): true;
				FcIndexPrim(): true;

				default: false;
			} && forall(es, fiIsSimpleForIfExp);
		}
		FiVar(__,__,__): true;
		FiCall(f, as,__,__): {
			switch(f) {
				FiVar(fn,__,__): (fn == "strlen" || fn == "length") && forall(as, fiIsSimpleForIfExp);
				default: false;
			}
		}
		default: false;
	}
}

fiExpChangeAndOr2If(x: FiExp) -> FiExp {
	mapFiExp(x, \e -> switch (e) {
		FiCallPrim(op, es, type, start): {
			switch (op) {
				FcAndPrim(): {
					if (fiIsSimpleForIfExp(es[0]) && fiIsSimpleForIfExp(es[1])) e else
					FiIf(es[0], es[1], FiBool(false, start), type, start);
				}
				FcOrPrim(): {
					if (fiIsSimpleForIfExp(es[0]) && fiIsSimpleForIfExp(es[1])) e else
					FiIf(es[0], FiBool(true, start), es[1], type, start);
				}
				default: {
					e;
				}
			}
		}
		default: e;
	});
}


fiExpShortcutIf(x: FiExp) -> FiExp {
	mapFiExp(x, \e -> switch (e) {
		FiIf(c, e1, e2,__,__): {
			switch (c) {
				FiBool(v,__): {
					if (v) e1 else e2;
				}
				default: e;
			}
		}
		default: e;
	});
}

fiExpReduceChainLets(x: FiExp) -> FiExp {
	mapFiExp(x, \e -> switch (e) {
		FiLet(v, t1, e1, e2,__,__): {
			switch (e1) {
				FiVar(w,__,__): {
					fiRenameVar(e2, v, w);
				}
				default: e;
			}
		}
		default: e;
	});
}

fiMakeCallerVar(x: FiExp) -> FiExp {
	id = ref 0;
	new_id = \-> {
		nid = "tmp_fn_var_" + i2s(^id);
		id := ^id + 1;
		nid;
	}
	mapFiExp(x, \e -> switch (e) {
		FiCall(fn, args, type, s): {
			if (fiExpIsNestedField(fn)) e else {
				n_var = FiVar(new_id(), fiExpType(fn), s);
				FiLet(n_var.name, n_var.type, fn,
					FiCall(n_var, args, type, s), type, s
				);
			}
		}
		default: e;
	});
}


fiWrapFunctionCasts(x: FiExp) -> FiExp {
	mapFiExp(x, \e -> switch (e) {
		FiCast(e1, from, to, type, s): {
			switch (from) {
				FiTypeFunction(from_args, from_ret): {
					switch (to) {
						FiTypeFunction(to_args, to_ret): {
							args = mapi(to_args, \i, arg ->
								FiFunArg("fn_cast_wrapper_arg__" + i2s(i), arg.type)
							);
							FiLambda(
								args,
								FiCast(
									FiCall(e1, 
										mapi(args, \i, arg ->
											FiCast(FiVar(arg.name, arg.type, s), arg.type, from_args[i].type, from_args[i].type, s)
										), 
										from_ret, s
									),
									from_ret, to_ret, to_ret, s
								),
								to, s
							);
						}
						default:e;
					}
				}
				default:e;
			}
		}
		default: e;
	});
}

fiExpUnfoldCasts(x: FiExp, names: FiGlobalNames, toplevel_name: string, unfold_unions: bool) -> FiExp {
	id = ref 0;
	new_id = \-> {
		nid = "tmp_cast_wrapper_arg__" + i2s(^id);
		id := ^id + 1;
		nid;
	}
	mapFiExp(x, \e -> switch (e) {
		FiCast(e1, from, to, type, s): {
			if (fiEqualTypes(from, to)) e1 else {
				fiUnfoldCasts(e1, from, to, s, names, new_id, toplevel_name, unfold_unions);
			}
		}
		default: e;
	});
}

fiUnfoldCasts(e: FiExp, from: FiType, to: FiType, s: int, names: FiGlobalNames, new_id: () -> string, toplevel_name: string, unfold_unions: bool) -> FiExp {
	if (fiEqualTypes(from, to)) e else {
		switch (from) {
			FiTypeFunction(from_args, from_ret): {
				switch (to) {
					FiTypeFunction(to_args, to_ret): {
						args = mapi(to_args, \i, arg ->
							FiFunArg(new_id(), arg.type)
						);
						call = FiCall(e, 
							mapi(args, \i, arg ->
								fiUnfoldCasts(FiVar(arg.name, arg.type, s), arg.type, from_args[i].type, s, names, new_id, toplevel_name, unfold_unions)
							), 
							from_ret, s
						);
						FiLambda(
							args,
							if (to_ret == FiTypeVoid()) call else FiCast(call, from_ret, to_ret, to_ret, s),
							to, s
						);
					}
					default: FiCast(e, from, to, to, s);
				}
			}
			FiTypeArray(from_arr): {
				switch (to) {
					FiTypeArray(to_arr): {
						arg = FiFunArg(new_id(), from_arr);
						FiCall(
							FiVar("map", 
								FiTypeFunction([
									FiFunArg("", from), 
									FiFunArg("", FiTypeFunction([FiFunArg("", from_arr)], to_arr))
								], to), 
								s
							),
							[e, FiLambda([arg],
								fiUnfoldCasts(FiVar(arg.name, arg.type, s), from_arr, to_arr, s, names, new_id, toplevel_name, unfold_unions),
								FiTypeFunction([arg], to_arr),
								s
							)],
							to, s
						);
					}
					default: FiCast(e, from, to, to, s);
				}
			}
			FiTypeRef(from_ref): {
				switch (to) {
					FiTypeRef(to_ref): {
						FiCallPrim(FcRefPrim(),
							[fiUnfoldCasts(FiCallPrim(FcDerefPrim(), [e], from_ref, s), from_ref, to_ref, s, names, new_id, toplevel_name, unfold_unions)],
							to, s
						);
					}
					default: FiCast(e, from, to, to, s);
				}
			}
			FiTypeName(from_name, from_typars): {
				fiMapTypeName(from, names, 
					\struct_from -> switch (to) {
						FiTypeName(to_name,__): {
							fiMapTypeName(to, names, 
								\struct_to -> {
									if (from_name != to_name) {
										fail(
											"illegal cast of " + pretFiType(from) + " to " + pretFiType(to) + " in " + toplevel_name + ", expression:\n" +
											strIndent(pretFiExp(e))
										);
									}
									fiMakeStructCast(e, s, struct_from, struct_to, names, new_id, toplevel_name, unfold_unions);
								},
								\union_to -> FiCast(e, from, to, to, s),
								\err -> FiCast(e, from, to, to, s)
							);
						}
						default: FiCast(e, from, to, to, s)
					},
					\union_from -> {
						if (unfold_unions) {
							switch (to) {
								FiTypeName(to_name,__): {
									fiMapTypeName(to, names, 
										\struct_to -> FiCast(e, from, to, to, s),
										\union_to -> {
											tmp = FiVar(new_id(), from, s);
											FiLet(tmp.name, tmp.type, e, 
												FiSwitch(tmp, tmp.type,
													map(union_from.typenames,
														\tn_from -> {
															struct_from = fiTypeName2Struct(tn_from, names);
															switch (find(union_to.typenames, \x -> x.name == tn_from.name)) {
																Some(tn_to): {
																	struct_to = fiTypeName2Struct(tn_to, names);
																	from_tn = FiTypeName(struct_from.name, struct_from.typars);
																	to_tn = FiTypeName(struct_to.name, struct_to.typars);
																	FiCase(tn_from.name, map(struct_from.args, \__-> "__"),
																		fiNormalizeCasts(FiCast(
																			fiMakeStructCast(
																				FiCast(e, from, from_tn, from_tn, s), s,
																				struct_from, struct_to,
																				names, new_id, toplevel_name, unfold_unions
																			),
																			to_tn, to, to, s
																		)), 
																		s
																	);
																}
																None(): {
																	// Such a cast will cause a runtime error
																	FiCase(tn_from.name, map(struct_from.args, \__-> "__"),
																		fiNormalizeCasts(FiCast(e, from, to, to, s)), 
																		s
																	);
																}
															}
														}),
													to, s
												),
												to, s
											);
										},
										\err -> fail0("error")
									);
								}
								default: {
									FiCast(e, from, to, to, s);
								}
							}
						} else {
							FiCast(e, from, to, to, s);
						}
					},
					\err -> FiCast(e, from, to, to, s)
				);
			}
			default: FiCast(e, from, to, to, s);
		}
	}
}

fiMakeStructCast(x: FiExp, s: int, struct_from: FiTypeStruct, struct_to: FiTypeStruct, names: FiGlobalNames, new_id: () -> string, toplevel_name: string, unfold_unions: bool) -> FiExp {
	name = struct_from.name;
	from_tp = FiTypeName(name, struct_from.typars);
	to_tp = FiTypeName(name, struct_to.typars);
	if (struct_from == struct_to) x else {
		wrapper_name = fiStructCastWrapperName(name);
		switch (lookupTree(names.toplevel, wrapper_name)) {
			Some(wrapper): {
				switch (wrapper) {
					FiFunctionDec(__,__,fn_type,__,__): {
						wrapper_spec_type = FiTypeFunction(fn_type with
							args = [FiFunArg(fn_type.args[0] with type = from_tp)],
							returnType = to_tp
						);
						FiCall(FiVar(wrapper_name, wrapper_spec_type, 0), [x], to_tp, 0);
					}
					default: {
						fail0("must be a function, got:\n" +
							strIndent(pretFiDeclaration(wrapper))
						);
					}
				}
			}
			None(): {
				tmp = FiVar(new_id(), from_tp, s);
				FiLet(tmp.name, tmp.type, x, 
					FiCallPrim(FcStructPrim(name),
						mapi(struct_from.args, \i, arg -> 
							fiUnfoldCasts(
								FiCallPrim(FcFieldPrim(arg.name), [tmp], arg.type, s),
								arg.type, struct_to.args[i].type, s, names, new_id, toplevel_name, unfold_unions
							)
						),
						to_tp, s
					),
					to_tp, s
				);
			}
		}
	}
}

fiWrapGlobalFuncInLambdas(ex : FiExp, names : FiGlobalNames) -> FiExp {
	fiDoWrapGlobalFuncInLambdas(names, ex, true);
}

fiDoWrapGlobalFuncInLambdas(names : FiGlobalNames, ex : FiExp, isArg : bool) -> FiExp {
	processA = \exp0 -> fiDoWrapGlobalFuncInLambdas(names, exp0, true);
	process = \exp0 -> fiDoWrapGlobalFuncInLambdas(names, exp0, false);
	switch (ex) {
		FiBool(b, start): ex;
		FiInt(i, start): ex;
		FiString(s, start): ex;
		FiDouble(d, start): ex;
		FiVoid(start): ex;
		FiVar(name, type, start): {
			if (isArg && fiTypeIsFunction(type) && containsKeyTree(names.toplevel, name)) {
				ftype = cast (type : FiType -> FiTypeFunction);
				fargs = mapi(ftype.args, \i, a -> {
					FiFunArg("__" + name + "__arg__" + i2s(i) + "__" + a.name, a.type);
				}); 
				args = map(fargs, \aaa -> {
					FiVar(aaa.name, aaa.type, 0);
				});

				FiLambda(
					fargs,
					FiCall(ex, args, ftype.returnType, start),
					FiTypeFunction(fargs, ftype.returnType),
					start
				);
			} else {
				ex;
			}
		}
		FiCall(f, args, type, start):
			FiCall(process(f), map(args, \a -> processA(a)), type, start);
		FiSwitch(__, __, __, __, __): 
			FiSwitch(ex with cases = 
				map(ex.cases, \c -> FiCase(c with body = processA(c.body))));
		FiLambda(args, body, type, start):
			FiLambda(args, processA(body), type, start); 
		FiLet(name, type, e1, e2, type2, start): 
			FiLet(ex with e1 = processA(e1), e2 = processA(e2));
		FiIf(e1, e2, e3, type, start): 
			FiIf(processA(e1), processA(e2), processA(e3), type, start);
		FiCallPrim(__, es, __, __):
			FiCallPrim(ex with es = map(es, processA));
		FiRequire(flowfile, e, type, start):
			FiRequire(flowfile, processA(e), type, start);
		FiUnsafe(name, fallback, type, start):
			FiUnsafe(name, processA(fallback), type, start);
		FiSeq(es, type, start):
			FiSeq(map(es, processA), type, start);
		FiCast(__, __, __, __, __): 
			FiCast(ex with e = processA(ex.e));
	}
}

fiInlineHostCalls(e: FiExp, names: FiGlobalNames) -> FiExp {
	fiMapExp(e, \x,__ -> switch (x) {
		FiCall(f, args, ret_type, s1): {
			switch(f) {
				FiVar(v, v_type, s2): {
					if (v != "hostCall") x else {
						switch (args[0]) {
							FiString(fn,__): {
								switch (unFiCast(args[1])) {
									FiCallPrim(op, fn_args,__,__): {
										if (op != FcArrayPrim()) x else {
											mdecl: Maybe<FiDeclaration> = lookupTree(names.toplevel, fn);
											switch (mdecl) {
												Some(decl): {
													fn_type0 = cast(decl.type: FiType -> FiTypeFunction);
													sub = foldi(fn_type0.args, makeTree(), \i, acc, decl_arg ->
														fiMatchTypars(decl_arg.type, fiExpType(fn_args[i]), acc)
													);
													fn_type = cast(fiSubstituteTypars(fn_type0, sub): FiType -> FiTypeFunction);
													out_type = FiTypeFunction(map(fn_args, \arg -> FiFunArg("", fiExpType(arg))), ret_type);
													call1 = FiCall(x with f = FiVar(fn, out_type, s2), args = fn_args);
													if (fiEqualTypes(fn_type.returnType, ret_type)) call1 else {
														switch (fn_type.returnType) {
															FiTypeVoid(): {
																FiCall(call1 with type = FiTypeVoid());
															}
															default: {
																FiCast(call1, fn_type.returnType, ret_type, ret_type, s1);
															}
														}
													}
												}
												None(): x;
											}
										}
									}
									default: x;
								}
							}
							default: x;
						}
					}
				}
				default: x;
			}
		}
		default: x;
	}, true);
}

fiTypeEmptyArrays(e: FiExp) -> FiExp {
	id = ref 0;
	new_id = \-> {
		nid = "tmp_empty_array_var_" + i2s(^id);
		id := ^id + 1;
		nid;
	}
	fiMapExp(e, \x, env -> switch (x) {
		FiCallPrim(op, args, ret_type, s1): {
			switch(op) {
				FcArrayPrim(): {
					if (length(args) > 0) x else {
						switch (env.parents) {
							Cons(p,__): {
								make_let = \ -> {
									tmp_var = new_id();
									FiLet(tmp_var, ret_type, x, FiVar(tmp_var, ret_type, s1), ret_type, s1);
								}
								switch (p.first) {
									FiLet(__,__,__,__,__,__): {
										if (p.second == 0) x else make_let();
									}
									default: make_let();
								}
							}
							EmptyList(): x;
						}
					}
				}
				default: x;
			}
		}
		default: x;
	}, true);
}

fiLabelAnonymLambdaArgs(e: FiExp) -> FiExp {
	mapFiExp(e, \x -> switch (x) {
		FiLambda(args, body, type,__): {
			if (forall(args, \arg -> arg.name != "__" && arg.name != "")) x else {
				i = ref 0;
				FiLambda(x with args = map(args, \arg ->
					if (arg.name != "__" && arg.name != "") arg else {
						ind = ^i;
						i := ^i + 1;
						FiFunArg(arg with name = "__" + i2s(ind));
					}
				));
			}
		}
		default: x;
	});
}

fiCorrectCastCaseVarType(e: FiExp, sw: Tree<string, Pair<string, FiType>>) -> FiExp {
	switch (e) {
		FiLambda(args, body, type, start): {
			FiLambda(e with body = fiCorrectCastCaseVarType(body, sw));
		}
		FiCall(f, args, __, __): {
			FiCall(e with
				f = fiCorrectCastCaseVarType(f, sw),
				args = map(args, \arg -> fiCorrectCastCaseVarType(arg, sw))
			);
		}
		FiVar(x, __, __): e;
		FiLet(x, t, e1, e2, __, __): {
			sw1 = switch (e1) {
				FiCallPrim(op, es, tp, __): {
					switch (op) {
						FcFieldPrim(field): {
							switch (es[0]) {
								FiVar(v,__,__): setTree(sw, field, Pair(v, t));
								default: sw;
							}
						}
						default: sw;
					}
				}
				default: sw;
			}
			FiLet(e with
				e1 = fiCorrectCastCaseVarType(e1, sw),
				e2 = fiCorrectCastCaseVarType(e2, sw1)
			);
		}
		FiIf(e1, e2, e3, __, __): {
			FiIf(e with
				e1 = fiCorrectCastCaseVarType(e1, sw),
				e2 = fiCorrectCastCaseVarType(e2, sw),
				e3 = fiCorrectCastCaseVarType(e3, sw)
			);
		}
		FiSwitch(x, typ, cs, __, __): {
			FiSwitch(e with 
				cases = map(cs, \c -> FiCase(c with body = fiCorrectCastCaseVarType(c.body, sw)))
			);
		}
		FiCast(e0, tFrom, tTo, __, __): {
			FiCast(e with e = fiCorrectCastCaseVarType(e0, sw));
		}
		FiSeq(es, __, __): {
			FiSeq(e with es = map(es, \x -> fiCorrectCastCaseVarType(x, sw)));
		}
		FiCallPrim(op, es, t, __): {
			switch (op) {
				FcFieldPrim(field): {
					switch (es[0]) {
						FiVar(v,__,__): {
							switch (lookupTree(sw, field)) {
								Some(p): {
									if (p.first == v) {
										// Correct type!
										FiCallPrim(e with
											es = map(es, \x -> fiCorrectCastCaseVarType(x, sw)),
											type = p.second
										);
									} else {
										FiCallPrim(e with es = map(es, \x -> fiCorrectCastCaseVarType(x, sw)));
									}
								}
								None(): {
									FiCallPrim(e with es = map(es, \x -> fiCorrectCastCaseVarType(x, sw)));
								}
							}
						}
						default: {
							FiCallPrim(e with es = map(es, \x -> fiCorrectCastCaseVarType(x, sw)));
						}
					}
				}
				default: {
					FiCallPrim(e with es = map(es, \x -> fiCorrectCastCaseVarType(x, sw)));
				}
			}
		}
		FiRequire(flowfile2, e2, __, __): {
			FiRequire(e with e = fiCorrectCastCaseVarType(e2, sw));
		}
		FiUnsafe(name, fallback, __, __): {
			FiUnsafe(e with fallback = fiCorrectCastCaseVarType(fallback, sw));
		}
		FiString(s, __): e;
		FiBool(b, __): e;
		FiDouble(d, __): e;
		FiVoid(__): e;
		FiInt(i, __): e;
	}
}

fiCorrectStructFieldTypes(e: FiExp, names: FiGlobalNames) -> FiExp {
	mapFiExp(e, \x -> switch (x) {
		FiCallPrim(op, es, type,__): {
			switch (op) {
				FcFieldPrim(field): {
					tp = fiExpType(es[0]);
					switch (tp) {
						FiTypeName(tp_name, typars): {
							switch (lookupTree(names.structs, tp_name)) {
								Some(s): {
									if (length(tp.typeparameters) != length(s.typars)) {
										fail("length of struct typeparameters mismatch with length of typename typeparameters: " + i2s(length(s.typars)) + " != " + i2s(length(tp.typeparameters)) + " (length(tn.typeparameters))\n" +
											"struct: " + pretFiStructOrUnion(s) + ", typename: " + pretFiType(tp) + "\n" +
											"expr\n" + pretFiExp(x)
 										);
									}
									spec = fiSpecializeStruct(tp, s);
									switch (find(spec.args, \arg -> arg.name == field)) {
										Some(arg): {
											if (fiEqualTypes(arg.type, type)) x else {
												FiCallPrim(x with type = arg.type);
											}
										}
										None(): fail0("unknown field: " + field + " of struct: " + tp_name);
									}
								}
								None(): x;
							}
						}
						default: x;
					}
				}
				default: x;
			}
		}
		default: x;
	});
}

fiRemoveRedundantVoids(e: FiExp) -> FiExp {
	mapFiExp(e, \x -> switch (x) {
		FiSeq(es, type, s): {
			if (length(es) <=1) x else {
				non_last = take(es, length(es) - 1);
				filtered = filter(non_last, \y -> switch (y) {
					FiVoid(__): false;
					FiSeq(es1,__,__): length(es1) > 0;
					default: true;
				});
				last = es[length(es) - 1];
				if (length(filtered) > 0) {
					FiSeq(x with es = arrayPush(filtered, last));
				} else {
					last;
				}
			}
		}
		default: x;
	});
}

fiPurifyTypesInExp(e: FiExp) -> FiExp {
	mapFiExp(e, \x -> {
		t = fiExpType(x);
		if (fiTypeIsPure(t)) x else {
			fiSetExpType(x, fiPurifyType(t));
		}
	});
}

fiComparisonWithConst(e: FiExp, const_cmp_max_size: int) -> FiExp {
	wrap_log_op = \op, as -> if (length(as) == 0) FiBool(true, -1) else
	if (length(as) == 1) as[0] else {
		ras = reverseA(as);
		fold(tail(ras), ras[0], \acc, x ->
			FiCallPrim(op, [x, acc], FiTypeBool(), -1)
		);
	}
	make_cmp_strs = \op1, op2, s_const, s_exp -> wrap_log_op(op1,
		concat(
			[FiCallPrim(op2,
				[
					FiCall(
						FiVar("strlen", FiTypeFunction([FiFunArg("", FiTypeString())], FiTypeInt()), -1),
						[s_exp], FiTypeInt(), -1
					),
					FiInt(strlen(s_const), -1)
				],
				FiTypeBool(), -1
			)],
			mapi(s2a(s_const), \i, c -> FiCallPrim(op2,
				[
					FiCallPrim(FcIndexPrim(),
						[s_exp, FiInt(i, -1)], FiTypeInt(), -1
					),
					FiInt(getCharCodeAt(s_const, i), -1)
				],
				FiTypeBool(), -1
			)),
		)
	);
	make_cmp_arrs1 = \arr_tp, op1, op2, a_const, a_exp -> wrap_log_op(op1,
		concat(
			[FiCallPrim(op2,
				[
					FiCall(
						FiVar("length", FiTypeFunction([FiFunArg("", FiTypeArray(arr_tp))], FiTypeInt()), -1),
						[a_exp], FiTypeInt(), -1
					),
					FiInt(length(a_const), -1)
				],
				FiTypeBool(), -1
			)],
			mapi(a_const, \i, x -> FiCallPrim(op2,
				[
					FiCallPrim(FcIndexPrim(),
						[a_exp, FiInt(i, -1)], arr_tp, -1
					),
					x
				],
				FiTypeBool(), -1
			)),
		)
	);
	make_cmp_arrs2 = \arr_tp, op1, op2, a1_const, a2_const -> wrap_log_op(op1,
		mapi(a1_const, \i, x -> FiCallPrim(op2, [a2_const[i], x],
			FiTypeBool(), -1
		))
	);
	fiMapExp(e, \x, __ -> switch (x) {
		FiCallPrim(op, es, tp, s): {
			switch (op) {
				FcEqPrim(): {
					switch (fiExpType(es[0])) {
						FiTypeString(): {
							switch (es[0]) {
								FiString(s0,__): {
									switch (es[1]) {
										FiString(s1,__): {
											FiBool(s0 == s1, s);
										}
										default: {
											if (strlen(s0) > const_cmp_max_size) x else {
												make_cmp_strs(FcAndPrim(), FcEqPrim(), s0, es[1]);
											}
										}
									}
								}
								default: {
									switch (es[1]) {
										FiString(s1,__): {
											if (strlen(s1) > const_cmp_max_size) x else {
												make_cmp_strs(FcAndPrim(), FcEqPrim(), s1, es[0]);
											}
										}
										default: x;
									}
								}
							}
						}
						FiTypeArray(arr_tp): {
							switch (es[0]) {
								FiCallPrim(op0, c_arr0, __,__): {
									switch (op0) {
										FcArrayPrim(): {
											switch (es[1]) {
												FiCallPrim(op1, c_arr1,__,__): {
													switch (op1) {
														FcArrayPrim(): {
															if (length(c_arr0) != length(c_arr1)) {
																FiBool(false, s);
															} else {
																make_cmp_arrs2(arr_tp, FcAndPrim(), FcEqPrim(), c_arr0, c_arr1);
															}
														}
														default: {
															if (length(c_arr0) > const_cmp_max_size) x else {
																make_cmp_arrs1(arr_tp, FcAndPrim(), FcEqPrim(), c_arr0, es[1]);
															}
														}
													}
												}
												default: {
													if (length(c_arr0) > const_cmp_max_size) x else {
														make_cmp_arrs1(arr_tp, FcAndPrim(), FcEqPrim(), c_arr0, es[1]);
													}
												}
											}
										}
										default: x;
									}
								}
								default: {
									switch (es[1]) {
										FiCallPrim(op1, c_arr1,__,__): {
											switch (op1) {
												FcArrayPrim(): {
													if (length(c_arr1) > const_cmp_max_size) x else {
														make_cmp_arrs1(arr_tp, FcAndPrim(), FcEqPrim(), c_arr1, es[0]);
													}
												}
												default: x;
											}
										}
										default: x;
									}
								}
							}
						}
						default: x;
					}
				}
				FcNePrim(): {
					switch (fiExpType(es[0])) {
						FiTypeString(): {
							switch (es[0]) {
								FiString(s0,__): {
									switch (es[1]) {
										FiString(s1,__): {
											FiBool(s0 != s1, s);
										}
										default: {
											if (strlen(s0) > const_cmp_max_size) x else {
												make_cmp_strs(FcOrPrim(), FcNePrim(), s0, es[1]);
											}
										}
									}
								}
								default: {
									switch (es[1]) {
										FiString(s1,__): {
											if (strlen(s1) > const_cmp_max_size) x else {
												make_cmp_strs(FcOrPrim(), FcNePrim(), s1, es[0]);
											}
										}
										default: x;
									}
								}
							}
						}
						FiTypeArray(arr_tp): {
							switch (es[0]) {
								FiCallPrim(op0, c_arr0, __,__): {
									switch (op0) {
										FcArrayPrim(): {
											switch (es[1]) {
												FiCallPrim(op1, c_arr1,__,__): {
													switch (op1) {
														FcArrayPrim(): {
															if (length(c_arr0) != length(c_arr1)) {
																FiBool(true, s);
															} else {
																make_cmp_arrs2(arr_tp, FcOrPrim(), FcNePrim(), c_arr0, c_arr1);
															}
														}
														default: {
															if (length(c_arr0) > const_cmp_max_size) x else {
																make_cmp_arrs1(arr_tp, FcOrPrim(), FcNePrim(), c_arr0, es[1]);
															}
														}
													}
												}
												default: {
													if (length(c_arr0) > const_cmp_max_size) x else {
														make_cmp_arrs1(arr_tp, FcOrPrim(), FcNePrim(), c_arr0, es[1]);
													}
												}
											}
										}
										default: x;
									}
								}
								default: {
									switch (es[1]) {
										FiCallPrim(op1, c_arr1,__,__): {
											switch (op1) {
												FcArrayPrim(): {
													if (length(c_arr1) > const_cmp_max_size) x else {
														make_cmp_arrs1(arr_tp, FcOrPrim(), FcNePrim(), c_arr1, es[0]);
													}
												}
												default: x;
											}
										}
										default: x;
									}
								}
							}
						}
						default: x;
					}
				}
				default: x;
			}
		}
		default: x;
	}, false);
}
