import tools/flowc/incremental/fi_helpers2;
import tools/flowc/manipulation/common;
import tools/flowc/incremental/fi_type_unify;
import tools/flowc/manipulation/effects;
import tools/flowc/manipulation/flatten_unions;
import string_utils;
import tools/flowc/backends/cpp3/fi2cpp3_util;

export {

// Expand calls of common field of a struct in some unions to switch with individual 
// structs.
fiTransEliminateUnionFields(expr : FiExp, names: FiGlobalNames) -> FiExp;

/*
Example:
	U :: S1, S2;
		S1(a: int, b: string);
		S2(x: double, a: int);

function
	makeU() -> U { 
		...
	}

	someFn() -> void {
		...
		makeU().a
		...
	}

will expand to
	someFn() -> void {
		...
		__union_3 = makeU();
		switch(__union_3) {
			S1(__field_3,__): __field_3;
			S2(__,__field_3): __field_3;
		}
		...
	}

*/

fiRemoveUnusedVars(e : FiExp, effects : FiEffects) -> FiExp;

// Make explicit cast of a switch variable to all particular cases.
fiExplicitCastInSwitch1(e : FiExp, names: FiGlobalNames) -> FiExp;

// Rename enclosed same var name in recurring FiLet.
/* Example: here rettype is recurring, i.e. needs renaming in the inner scope
rettype = {
		switch (type) {
			FiTypeFunction(__, rettype): fiCppLambdaRetType(cfg, program, rettype);
			default: "TODO";
		}
}
*/
fiExpRenameRecurringVars1(e: FiExp, names: FiGlobalNames) -> FiExp;

/* Undo type coercing inside: 
	`if (isSameStructType(a, b)) { 
		e
	}`
transform it to:
	`if (isSameStructType(a, b)) { 
		__prime_a = cast(e: a.type -> b.type);
		e_prime
	}`
where `e_prime` - is e with `a` replaced by `__prime_a`
 */
fiFixVarInSameStructType1(e : FiExp) -> FiExp;

/*
In compound expressions, which contain subexpressions with non-scalar types, extract these
subexpressions via let-statements, which bind them with temporary variables, i.e.

func(Struct("A", 3, 4), 15, "...")

will be transformed into:

v1 = "A";
v2 = Struct(v1, 3, 4);
v3 = "...";
func(v2, 15, v3)

*/
//fiExpExtractNonScalarToLet(e: FiExp) -> FiExp;

// Repace sequences of length 1 by its content
fiExpNormalizeSeqences(e: FiExp) -> FiExp;

// Replace chains of casts into single transitive cast
fiNormalizeCasts(e: FiExp) -> FiExp;

// The same as FiSSA
fiExpMakeVarsUnique(e: FiExp) -> FiExp;

fiExpMakeCastsExplicit(x: FiExp, t: FiType, names: FiGlobalNames) -> FiExp;

fiExpInterpolateTypars(e: FiExp, names: FiGlobalNames) -> FiExp;

fiExpReturnVars(e: FiExp) -> FiExp;

fiExtractCallNonScalarExp(e: FiExp, names: FiGlobalNames) -> FiExp;

// Remove casts from non-scalar types to flow - these casts are implicit
fiRemoveImplicitCasts(e: FiExp) -> FiExp;

fiRemoveTrivialCasts(e: FiExp) -> FiExp;

fiPushExpsDown(e: FiExp) -> FiExp;

fiIsStat(e: FiExp) -> bool;

// In case a switch has only one variant - remove it
fiExpShortcutTrivialSwitch(e: FiExp, names: FiGlobalNames) -> FiExp;

fiExpChangeAndOr2If(x: FiExp) -> FiExp;

fiExpShortcutIf(x: FiExp) -> FiExp;

fiExpReduceChainLets(x: FiExp) -> FiExp;

fiMakeCallerVar(x: FiExp) -> FiExp;

fiWrapFunctionCasts(x: FiExp) -> FiExp;

fiExpUnfoldCasts(x: FiExp, names: FiGlobalNames, toplevel_name: string) -> FiExp;

}

fiTransEliminateUnionFields(expr : FiExp, names: FiGlobalNames) -> FiExp {
	fiFoldMapExp(expr, 0, 
		\x, env, local -> {
			switch (x) {
				FiCallPrim(op, es, rtype, start): {
					make_switch = \union, switch_var -> {
						FiSwitch(switch_var, switch_var.type, 
							map(union.typenames, \tn -> {
								struct = fiSpecializeStruct(tn, lookupTreeDef(names.structs, tn.name, FiTypeStruct("", [], [], 0)));
								case_var = FiVar(switch_var with 
									type = FiTypeName(struct.name, struct.typars)
								);
								FiCase(
									tn.name,
									map(struct.args, \__ -> "__"),
									FiCallPrim(x with es = [case_var]),
									start
								)
							}),
							rtype, start
						);
					}
					do_work = \field -> {
						arg = es[0];
						arg_type = fiExpType(arg);
						switch (arg_type) {
							FiTypeName(__,typars): {
								switch (lookupTree(names.unions, arg_type.name)) {
									Some(union): {
										switch (arg) {
											FiVar(var, vtype,__): {
												Pair(make_switch(union, arg), local);
											}
											default: {
												union_var = "__union_" + i2s(local);
												Pair(FiLet(
													union_var, arg_type,
													arg,
													make_switch(union, FiVar(union_var, arg_type, start)),
													rtype, start
												), local + 1);
											}
										}
									}
									None(): Pair(x, local);
								}
							}
							default: Pair(x, local);
						}
					}
					switch (op) {
						FcFieldPrim(field): {
							if (field == "structname") Pair(x, local) else do_work(field);
						}
						FcSetMutablePrim(field): {
							do_work(field);
						}
						default: Pair(x, local);
					}
				}
				default: Pair(x, local);
			}
		},
		AstTraverseOrder(false, true)
	).first;
}

fiRemoveUnusedVars(e : FiExp, effects : FiEffects) -> FiExp {
	mapFiExp(e, \x -> 
		switch (x) {
			FiLet(var, vtype, e1, e2, type, start): {
				switch (fiFindInExpr(e2, \y ->
					switch (y) {
						FiVar(n,__,__): if (n == var) Some(y) else None();
						default: None();
					} 
				)) {
					Some(__): x;
					None(): {
						switch (e1) {
							FiLambda(__,__,__,__): {
								// We can safely skip unused lambda
								e2;
							}
							default: {
								// var is not used
								if (hasFiSideEffects(effects, e1)) {
									switch (e2) {
										FiSeq(es,__,s): {
											if (length(es) == 0) {
												// In this case we can't just concat es with e1,
												// since the type of the expression in that case would change
												FiSeq(e2 with es = [e1, FiVoid(s)]);
											} else {
												FiSeq(e2 with es = concat([e1], es));
											}
										}
										default: FiSeq([e1, e2], type, e1.start);
									}
								} else {
									e2;
								}
							}
						}
					}
				}
			}
			FiSeq(es, __,__): {
				es1 = filtermapi(es, \i, y ->
					// Remove non-last elements with no effects
					if (i + 1 == length(es) || hasFiSideEffects(effects, y)) Some(y) else None()
				);
				if (length(es1) == 1) es1[0] else FiSeq(x with es = es1);
			}
			default: x;
		}
	);
}

fiExplicitCastInSwitch1(e : FiExp, names: FiGlobalNames) -> FiExp {
	mapFiExp(e, \x -> 
		switch (x) {
			FiSwitch(var, vtype, cases, type, start): {
				do_switch = \ -> {
					FiSwitch(x with 
						cases = map(cases, \c -> {
							if (c.struct == "default") c else {
								switch (lookupTree(names.structs, c.struct)) {
									Some(struct): {
										is_var = \y, nm -> switch (y) {
											FiVar(z,__,__): if (z == nm) Some(y) else None();
											default: None();
										}
										spec_var = var.name + "__spec";
										if (isNone(fiFindInExpr(c.body, \y -> is_var(y, var.name)))) {
											// No variable in the body at all
											c;
										} else if (isSome(fiFindInExpr(c.body, \y -> is_var(y, spec_var)))) {
											// Cast is already done
											c;
										} else { 
											typars_instances = fiMatchTyparsOrdered(FiTypeName(struct.name, struct.typars), vtype);
											case_type = FiTypeName(struct.name, typars_instances);
											FiCase(c with body = 
												FiLet(spec_var, case_type, 
													FiCast(var, vtype, case_type, case_type, start),
													fiReplaceVar(c.body, var.name, FiVar(spec_var, case_type, 0)),
													fiExpType(c.body), c.body.start
												)
											);
										}
									}
									None(): {
										fail0("all switch cases must be structs, met: " + toStringFormatted(c));
									}
								}
							}
						})
					);
				}
				switch (vtype) {
					FiTypeName(typename, __): {
						if (containsKeyTree(names.unions, typename)) {
							do_switch();
						} else {
							switch (find(cases, \c -> c.struct == typename)) {
								Some(c): {
									c.body;
								}
								None(): {
									fail0("unmatched struct type '" + typename + "' in switch:\n" + prettyFiExp(dummyPretty, e));
								}
							}
						}
					}
					default: {
						do_switch();
					}
				}
			}
			default: x;
		}
	);
}

fiMakeNewVar(pref: string, v: string, locals: Tree<string, FiVar>, names: FiGlobalNames) -> string {
	fiDoMakeNewVar(pref, v, locals, names, 0);
}

fiDoMakeNewVar(pref: string, v: string, locals: Tree<string, FiVar>, names: FiGlobalNames, i: int) -> string {
	w = pref + v + "_" + i2s(i);
	if (!containsKeyTree(locals, w) && !containsKeyTree(names.toplevel, w)) w else fiDoMakeNewVar(pref, v, locals, names, i + 1);
}

fiExpRenameRecurringVars1(e: FiExp, names: FiGlobalNames) -> FiExp {
	fiMapExp(e, \x, env ->
		switch (x) {
			FiLet(v, type, e1, e2,__, start): {
				if (v == "__" || !containsKeyTree(env.locals, v)) x else {
					w = fiMakeNewVar("", v, env.locals, names);
					FiLet(x with
						name = w,
						e2 = fiRenameVar(e2, v, w)
					);
				}
			}
			default: x;
		}, false
	);
}

fiFixVarInSameStructType1(e : FiExp) -> FiExp {
	fiDetectIfIsSameStructType = \x -> switch (x.e1) {
		FiCall(f, args, __,__): {
			switch (f) {
			FiVar(name,__,__): {
				if (name == "isSameStructType") {
					filtermap(args, \arg -> 
						switch (arg) {
							FiVar(__,__,__): Some(arg);
							default: None();
						}
					);
				} else {
					[];
				}
			}
			default: [];
			}
		}
		default: [];
	}
	fiVarTypeInExpr = \y , var -> maybeMap(
		fiFindInExpr(y, \x ->
			switch (x) {
				FiVar(name,__,__): if (name == var) Some(x) else None();
				default: None();
			}
		), \x -> cast(x: FiExp -> FiVar)
	);
	mapFiExp(e, \x ->
		switch (x) {
			FiIf(e1, e2, e3, type, start): {
				vars = fiDetectIfIsSameStructType(x);
				if (length(vars) != 2) x else {
					v0 = vars[0];
					v1 = vars[1];
					fix_vars = \old: FiVar, new: FiVar -> {
						prim_name = "__prim_" + old.name;
						/* Example: 
							if (isSameStructType(acc, el)) {
								t : ?? = cast(flow(el) : flow -> ??);
								...
							} ...
						*/
						e2_prim = FiLet(prim_name, new.type, 
							FiCast(old, old.type, new.type, new.type, start),
							fiRenameVar(e2, old.name, prim_name), type, start
						);
						/*
							if (isSameStructType(acc, el)) {
								__prim_el : ?? = cast(el : ? -> ??);
								t : ?? = cast(flow(__prim_el) : flow -> ??);
								...
							} ...
						*/
						e2_prim_prim = mapFiExp(e2_prim, \y ->
							switch (y) {
								FiCast(y_e, y_from, y_to, y_type, __): {
									if (!fiEqualTypes(new.type, y_type)) y else {
										switch (y_e) {
											FiCall(fn, args, __,__): {
												switch (fn) {
													FiVar(fn_name,__,__): {
														if (fn_name != "flow") y else {
															switch (args[0]) {
																FiVar(arg_name,__,__): {
																	if (arg_name != prim_name) y else {
																		/*
																			if (isSameStructType(acc, el)) {
																				__prim_el : ?? = cast(el : ? -> ??);
																				t : ?? = __prim_el;
																				...
																			} ...
																		*/
																		args[0];
																	}
																}
																default: y;
															}
														}
													}
													default: y;
												}
											}
											default: y;
										}
									}
								}
								default: y;
							}
						);
						FiIf(x with e2 = e2_prim_prim);
					}
					switch (fiVarTypeInExpr(e2, v0.name)) {
						Some(v0_prim): {
							fix_vars(v0, v0_prim);
						}
						None(): {
							switch (fiVarTypeInExpr(e2, v1.name)) {
								Some(v1_prim): fix_vars(v1, v1_prim);
								None(): x;
							}
						}
					} 
				}
			}
			default: x;
		}
	);
}

fiExpNormalizeSeqences(e: FiExp) -> FiExp {
	mapFiExp(e,
		\x, -> switch (x) {
			FiSeq(es,__,__): {
				if (length(es) == 1) es[0] else {
					FiSeq(x with es = mapConcat(es, \y ->
						switch (y) {
							FiSeq(es1,__,__): es1;
							default: [y];
						}
					));
				}
			}
			default: x;
		}
	);
}

fiExpMakeVarsUnique(e: FiExp) -> FiExp {
	fiDoExpMakeVarsUnique(e, makeTree(), makeTree());
}

fiDoExpMakeVarsUnique(e: FiExp, counter: Tree<string, int>, rename: Tree<string, string>) -> FiExp {
	do = \x -> fiDoExpMakeVarsUnique(x, counter, rename);
	switch (e) {
		FiLet(name,__,e1, e2,__,__): {
			if (name == "__") {
				FiLet(e with e1 = do(e1), e2 = do(e2));
			} else {
				counter1 = setTree(counter, name, lookupTreeDef(counter, name, -1) + 1);
				rename1 = if (!containsKeyTree(counter, name)) rename else {
					setTree(rename, name, name + "__ssa_" + i2s(lookupTreeDef(counter1, name, 0) - 1))
				}
				FiLet(e with
					name = lookupTreeDef(rename1, name, name),
					e1 = fiDoExpMakeVarsUnique(e1, counter1, rename1), 
					e2 = fiDoExpMakeVarsUnique(e2, counter, rename1),
				);
			}
		}
		FiVar(name,__,__): {
			if (!containsKeyTree(rename, name)) e else {
				FiVar(e with name = lookupTreeDef(rename, name, name));
			}
		}
		FiLambda(args, body,__,__): {
			FiLambda(e with body = do(body));
		}
		FiSwitch(v, vtype, cases,__,__): {
			FiSwitch(e with 
				x = FiVar(v with name = lookupTreeDef(rename, v.name, v.name)),
				cases = map(cases, \c -> FiCase(c with body = do(c.body)))
			);
		}
		FiIf(e1, e2, e3, __,__): { 
			FiIf(e with e1 = do(e1), e2 = do(e2), e3 = do(e3));
		}
		FiSeq(es,__,__): {
			FiSeq(e with es = map(es, do));
		}
		FiCast(x, from, to,__,__): { 
			FiCast(e with e = do(x));
		}
		FiCall(f, args,__,__): { 
			FiCall(e with f = do(f), args = map(args, do));
		}
		FiCallPrim(op, args,__,__): { 
			FiCallPrim(e with es = map(args, do));
		}
		FiRequire(file, x,__,__): { 
			FiRequire(e with e = do(x));
		}
		FiUnsafe(name, x,__,__): { 
			FiUnsafe(e with fallback = do(x));
		}
		FiConst(): e;
	}
}


fiExpMakeCastsExplicit(x: FiExp, t: FiType, names: FiGlobalNames) -> FiExp {
	switch (x) {
		FiLambda(args, body, type, start): {
			body1 = switch (type) {
				FiTypeFunction(__,returnType): fiExpMakeCastsExplicit(body, returnType, names);
				default: fiExpMakeCastsExplicit(body, fiExpType(body), names);
			}
			switch (t) {
				FiTypeFunction(t_args, t_ret): {
					p = foldi(args, Pair([], body1), \i, acc, arg -> 
						if (fiEqualTypes(arg.type, t_args[i].type)) {
							Pair(concat(acc.first, [arg]), acc.second);
						} else {
							new_arg = FiFunArg(arg.name, t_args[i].type);
							new_body = fiReplaceVar(acc.second, arg.name, 
								fiMakeCast(FiVar(arg.name, t_args[i].type, start), t_args[i].type, arg.type)
							);
							Pair(concat(acc.first, [new_arg]), new_body);
						}
					);
					body2 = p.second;
					body2_type = fiExpType(body2);
					if (fiEqualTypes(body2_type, t_ret)) {
						FiLambda(x with args = p.first, body = body2, type = t);
					} else {
						FiLambda(x with args = p.first, body = fiMakeCast(body2, body2_type, t_ret), type = t);
					}
				}
				FiTypeFlow(): {
					FiCast(FiLambda(x with body = body1), type, t, t, start);
				}
				default: {
					fail("lambda must have a functional type");
					x;
				}
			}
		}
		FiLet(v, v_type, e1, e2, type,__): {
			FiLet(x with 
				e1 = fiExpMakeCastsExplicit(e1, v_type, names),
				e2 = fiExpMakeCastsExplicit(e2, t, names),
				type2 = t
			);
		}
		FiIf(e1, e2, e3, type,__): {
			FiIf(x with
				e1 = fiExpMakeCastsExplicit(e1, FiTypeBool(), names),
				e2 = fiExpMakeCastsExplicit(e2, t, names),
				e3 = fiExpMakeCastsExplicit(e3, t, names),
				type = t
			);
		}
		FiSwitch(v, v_type, cases, type,__): {
			x1 = FiSwitch(x with
				cases = map(cases, \c -> FiCase(c with body = fiExpMakeCastsExplicit(c.body, t, names))),
				type = t
			);
			fiMakeCast(x1, fiExpType(x1), t);
		}
		FiSeq(es, type,__): {
			FiSeq(x with 
				es = mapi(es, \i, e ->
					if (i + 1 == length(es)) fiExpMakeCastsExplicit(e, t, names)
					else fiExpMakeCastsExplicit(e, fiExpType(e), names)
				),
				type = t
			);
		}
		FiCall(fn, args, type,__): {
			fn_type = cast(fiExpType(fn): FiType -> FiTypeFunction);
			x1 = FiCall(x with
				f = fiExpMakeCastsExplicit(fn, fn_type, names),
				args = mapi(args, \i, arg ->
					fiExpMakeCastsExplicit(arg, fn_type.args[i].type, names)
				)
			);
			fiMakeCast(x1, type, t);
		}
		FiCallPrim(op, es, type,__): {
			def_case = \ -> {
				x1 = FiCallPrim(x with es = map(es, \y -> fiExpMakeCastsExplicit(y, fiExpType(y), names)));
				fiMakeCast(x1, type, t);
			}
			typed_case = \tp -> {
				x1 = FiCallPrim(x with es = map(es, \y -> fiExpMakeCastsExplicit(y, tp, names)));
				fiMakeCast(x1, type, t);
			}
			switch (op) {
				FcOrPrim():  def_case();
				FcAndPrim(): def_case();
				FcNotPrim(): def_case();

				FcEqPrim():  typed_case(fiTypeUpperBoundary(fiExpType(es[0]), fiExpType(es[1]), names));
				FcNePrim():  typed_case(fiTypeUpperBoundary(fiExpType(es[0]), fiExpType(es[1]), names));
				FcLePrim():  typed_case(fiTypeUpperBoundary(fiExpType(es[0]), fiExpType(es[1]), names));
				FcGePrim():  typed_case(fiTypeUpperBoundary(fiExpType(es[0]), fiExpType(es[1]), names));
				FcLtPrim():  typed_case(fiTypeUpperBoundary(fiExpType(es[0]), fiExpType(es[1]), names));
				FcGtPrim():  typed_case(fiTypeUpperBoundary(fiExpType(es[0]), fiExpType(es[1]), names));

				FcPlusPrim():  typed_case(fiTypeLowerBoundary(fiExpType(es[0]), fiExpType(es[1]), names));
				FcMinusPrim(): def_case();
				FcMulPrim():   def_case();
				FcDivPrim():   def_case();
				FcModPrim():   def_case();
				FcNegPrim():   def_case();
				FcArrayPrim(): typed_case(fiDearrayType(type));
				FcIndexPrim(): {
					x1 = FiCallPrim(x with es = [
						fiExpMakeCastsExplicit(es[0], FiTypeArray(type), names),
						fiExpMakeCastsExplicit(es[1], FiTypeInt(), names)
					]);
					fiMakeCast(x1, type, t);
				}
				FcDerefPrim(): typed_case(FiTypeRef(type));
				FcRefPrim(): typed_case(fiDerefType(type));
				FcStructPrim(name): {
					struct = lookupTreeDef(names.structs, name, FiTypeStruct("", [], [], 0));
					switch (type) {
						FiTypeName(__,typars): {
							if (length(struct.typars) != length(typars)) {
								fail("struct " + name + " typars length mismatch with typename typars length:\n" +
									"struct typars: [" + superglue(struct.typars, pretFiType, ", ") + "]\n" + 
									"typename typars: [" + superglue(typars, pretFiType, ", ") + "]\n"
								);
							}
							typar_subst = foldi(struct.typars, makeTree(), \i, acc, tp ->
								switch (tp) {
									FiTypeParameter(nm): setTree(acc, nm, typars[i]);
									default: acc;
								}
							);
							x1 = FiCallPrim(x with es = mapi(es, \i, y ->
								fiExpMakeCastsExplicit(y, fiApplyTypeSubstitution(typar_subst, struct.args[i].type), names)
							));
							fiMakeCast(x1, type, t);
						}
						default: {
							fail("struct type must be FiTypeName, got: " + toString(type));
							def_case();
						}
					}
				}
				FcFieldPrim(name): {
					if (name == "structname") def_case() else {
						switch (fiExpType(es[0])) {
							FiTypeName(struct_name, typars): {
								switch (lookupTree(names.structs, struct_name)) {
									Some(struct): {
										switch (find(struct.args, \arg -> arg.name == name)) {
											Some(arg): {
												fiMakeCast(def_case(), arg.type, type);
											}
											None(): {
												fail("field '" + name + "' of struct '" + struct_name + "' is not found in expression: " + pretFiExp(x)
													+ "\n" + strIndent(toStringFormatted(x))
												);
												def_case();
											}
										}
									}
									None(): def_case();
								}
							}
							default: def_case();
						}
					}
				}
				FcAssignPrim(): {
					to = es[0];
					what = es[1];
					tp = fiExpType(to);
					x1 = switch (tp) {
						FiTypeRef(rt): {
							switch (fiExpType(what)) {
								FiTypeRef(__): {
									FiCallPrim(x with es = [
										fiExpMakeCastsExplicit(to, tp, names), 
										fiExpMakeCastsExplicit(what, tp, names)
									]);
								}
								default: {
									FiCallPrim(x with es = [
										fiExpMakeCastsExplicit(to, tp, names), 
										fiExpMakeCastsExplicit(what, rt, names)
									]);
								}
							}
						}
						default: {
							FiCallPrim(x with es = [
								fiExpMakeCastsExplicit(to, tp, names), 
								fiExpMakeCastsExplicit(what, tp, names)
							]);
						}
					}
					fiMakeCast(x1, type, t);
				}
				FcSetMutablePrim(name): {
					struct_type = fiExpType(es[0]);
					switch (struct_type) {
						FiTypeName(struct_name, typars): {
							switch (lookupTree(names.structs, struct_name)) {
								Some(struct): {
									spec = fiSpecializeStruct(struct_type, struct);
									switch (find(spec.args, \arg -> arg.name == name)) {
										Some(arg): {
											x1 = FiCallPrim(x with es = [
												fiExpMakeCastsExplicit(es[0], struct_type, names), 
												fiExpMakeCastsExplicit(es[1], arg.type, names)
											]);
											fiMakeCast(x1, type, t);
										}
										None(): {
											fail("field '" + name + "' of struct '" + struct_name + "' is not found in expression: " + pretFiExp(x)
												+ "\n" + strIndent(toStringFormatted(x))
											);
											def_case();
										}
									}
								}
								None(): def_case();
							}
						}
						default: def_case();
					}
				}
				FcCreateClosurePrim(structName, functionName): def_case();
				FcQuote(): def_case();
				FcUnquote(): def_case();
			}
		}
		FiCast(e, from, to, type,__): {
			x1 = FiCast(x with e = fiExpMakeCastsExplicit(e, from, names));
			fiNormalizeCasts(fiMakeCast(x1, type, t));
		}
		FiUnsafe(name, fallback, type,__): {
			x1 = FiUnsafe(x with fallback = fiExpMakeCastsExplicit(fallback, fiExpType(fallback), names));
			fiMakeCast(x1, type, t);
		}
		FiRequire(file, e, type,__): {
			x1 = FiRequire(x with e = fiExpMakeCastsExplicit(e, fiExpType(e), names));
			fiMakeCast(x1, type, t);
		}
		FiVar(name, type, __): {
			fiMakeCast(x, type, t);
		}
		FiVoid(__):      fiMakeCast(x, FiTypeVoid(), t);
		FiBool(__,__):   fiMakeCast(x, FiTypeBool(), t);
		FiInt(__,__):    fiMakeCast(x, FiTypeInt(), t);
		FiDouble(__,__): fiMakeCast(x, FiTypeDouble(), t);
		FiString(__,__): fiMakeCast(x, FiTypeString(), t);
	}
}

fiNormalizeCasts(e: FiExp) -> FiExp {
	mapFiExp(e, \x -> switch (x) {
		FiCast(y, x_from, x_to, x_type, start): {
			switch (y) {
				FiCast(z, y_from, y_to, y_type, __): {
					if (!fiEqualTypes(y_to, x_from)) {
						fail("inconsistent cast sequence callee type " + prettyFiType(dummyPretty, y_to, makeSet()) + " differs from the caller type " + prettyFiType(dummyPretty, x_from, makeSet()));
					}
					if (fiEqualTypes(y_from, x_to)) z else
					FiCast(z, y_from, x_to, x_type, start);
				}
				default: x;
			}
		}
		default: x;
	});
}

fiExpInterpolateTypars(e: FiExp, names: FiGlobalNames) -> FiExp {
	mapFiExp(e, \x -> switch (x) {
		FiCall(fn, args, ret_type,__): {
			switch (fiExpType(fn)) {
				FiTypeFunction(fn_args, returnType): {
					// Match arguments 
					args_unified = mapi(args, \i, arg -> fiUnifyTypes(fiExpType(arg), fn_args[i].type));
					ret_unified = fiUnifyTypes(returnType, ret_type);
					FiCall(x with 
						f = fiSetExpType(fn, FiTypeFunction(
							mapi(fn_args, \i, arg -> FiFunArg(arg.name, args_unified[i].second)),
							ret_unified.second
						)), 
						args = mapi(args, \i, arg -> fiSetExpType(arg, args_unified[i].first)),
						type = ret_unified.first
					);
				}
				default: {
					FiCall(x with f = fn, args = args);
				}
			}
		}
		FiCallPrim(op, es, type,__): {
			switch (op) {
				FcStructPrim(name): {
					struct = lookupTreeDef(names.structs, name, FiTypeStruct("", [], [], 0));
					switch (type) {
						FiTypeName(__,typars): {
							typar_subst = foldi(struct.typars, makeTree(), \i, acc, tp ->
								switch (tp) {
									FiTypeParameter(nm): setTree(acc, nm, typars[i]);
									default: acc;
								}
							);
							subst = foldi(struct.args, makeTree(), \i, sub, struct_arg -> 
								fiMatchTypars(fiExpType(es[i]), fiApplyTypeSubstitution(typar_subst, struct_arg.type), sub)
							);
							FiCallPrim(x with es = mapi(es, \i, y ->
								fiSetExpType(y, fiApplyTypeSubstitution(subst, fiExpType(y)))
							));
						}
						default: {
							fail("struct type must be FiTypeName, got: " + toString(type));
							x;
						}
					}
				}
				default: x;
			}
		}
		default: x;
	});
}

fiExpReturnVars(e: FiExp) -> FiExp {
	fiDoExpReturnVars(e, true);
}

fiDoExpReturnVars(e: FiExp, returns: bool) -> FiExp {
	wrap_with_var = \x : FiExp -> {
		if (!returns) x else {
			switch (x) {
				FiVar(__,__,__): x;
				default: {
					tp = fiExpType(x);
					switch (tp) {
						FiTypeVoid(): {
							switch (x) {
								FiVoid(__): x;
								default: FiSeq([x, FiVoid(x.start)], tp, x.start);
							}
						}
						default: {
							ret = "__ret_var__";
							FiLet(ret, tp, x, FiVar(ret, tp, x.start), tp, x.start);
						}
					}
				}
			}
		}
	}
	switch (e) {
		FiLambda(__, body,__, __): {
			FiLambda(e with body = fiDoExpReturnVars(body, true));
		}
		FiCall(fn, args,__,__): {
			wrap_with_var(FiCall(e with
				f = fiDoExpReturnVars(fn, false),
				args = map(args, \x -> fiDoExpReturnVars(x, false))
			));
		}
		FiLet(__, __,e1, e2,__, __): {
			FiLet(e with
				e1 = fiDoExpReturnVars(e1, false),
				e2 = fiDoExpReturnVars(e2, returns)
			);
		}
		FiIf(e1, e2, e3,__, __): {
			FiIf(e with
				e1 = fiDoExpReturnVars(e1, false),
				e2 = fiDoExpReturnVars(e2, returns),
				e3 = fiDoExpReturnVars(e3, returns)
			);
		}
		FiSwitch(v, __,cases,__, __): {
			FiSwitch(e with 
				cases = map(cases, \c -> FiCase(c with body = fiDoExpReturnVars(c.body, returns)))
			);
		}
		FiCast(ex, __, __, __, __): {
			wrap_with_var(FiCast(e with e = fiDoExpReturnVars(ex, false)));
		}
		FiSeq(es,__,__): {
			FiSeq(e with es = mapi(es, \i, x -> fiDoExpReturnVars(x, returns && i + 1 == length(es))));
		}
		FiCallPrim(__, es,__,__): {
			wrap_with_var(FiCallPrim(e with es = map(es, \x -> fiDoExpReturnVars(x, false))));
		}
		FiRequire(__, ex,__,__): {
			wrap_with_var(FiRequire(e with e = fiDoExpReturnVars(ex, false)));
		}
		FiUnsafe(__, ex,__,__): {
			wrap_with_var(FiUnsafe(e with fallback = fiDoExpReturnVars(ex, false)));
		}
		FiVar(name,__, __): e;
		FiVoid(__):       e;
		FiDouble(__,__):  e;
		FiInt(__,__):     e;
		FiString(__,__):  e;
		FiBool(__,__):    e;
	}
}

fiExtractCallNonScalarExp(e: FiExp, names: FiGlobalNames) -> FiExp {
	tmp_var_counter = ref 0;
	new_num = \-> {
		num = i2s(^tmp_var_counter);
		tmp_var_counter := ^tmp_var_counter + 1;
		num;
	}
	fiMapExp(e,
		\x, env -> switch (env.parents) {
			EmptyList(): x;
			Cons(parent,__): {
				switch (parent.first) {
					FiLet(v, v_type, e1, e2,__,__): x;
					default: {
						switch (x) {
							FiVar(__,__,__): x;
							FiInt(__,__): x;
							FiBool(__,__): x;
							FiDouble(__,__): x;
							FiVoid(__): x;
							FiLet(__,__,__,__,__,__): x;
							default: {
								type = fiExpType(x);
								if (fiTypeIsScalar(type)) x else {
									fn_var = fiMakeNewVar("w", new_num(), env.locals, names);
									FiLet(fn_var, type, x, FiVar(fn_var, type, 0), type, 0);
								}
							}
						}
					}
				}
			}
		},
		false
	);
}

fiRemoveImplicitCasts(e: FiExp) -> FiExp {
	mapFiExp(e, \x -> switch (x) {
		FiCast(y, from, to, type, start): {
			switch (to) {
				FiTypeFlow(): {
					if (fiTypeIsScalar(from)) x else y;
				}
				default: x;
			}
		}
		default: x;
	});
}

fiRemoveTrivialCasts(e: FiExp) -> FiExp {
	mapFiExp(e, \x -> switch (x) {
		FiCast(y, from, to, type, start): {
			if (fiEqualTypes(from, to)) y else x;
		}
		default: x;
	});
}

fiLastVarUses(e: FiExp) -> [List<int>] {
	make_index_path = \pairs -> mapList(pairs, \p -> p.second);
	fiFoldExp(e, Pair([], makeSet()), \x, env, acc -> 
		switch (x) {
			FiVar(name, __,__): {
				if (containsSet(acc.second, name)) acc else {
					Pair(
						concat(acc.first, [make_index_path(env.parents)]),
						insertSet(acc.second, name)
					);
				}
			}
			default: acc;
		},
		AstTraverseOrder(true, false)
	).first;
}

fiIsStat(e: FiExp) -> bool {
	switch (e) {
		FiSeq(__,__,__): true;
		FiLet(__,__,__,__,__,__): true;
		FiSwitch(__,__,__,__,__): true;
		FiIf(__,__,__,__,__): true;
		FiCallPrim(op,__,__,__): {
			switch (op) {
				FcAssignPrim(): true;
				FcSetMutablePrim(__): true;
				default: false;
			}
		}
		default: false;
	}
}

fiStatsArePulled(e: FiExp) -> bool {
	isNone(fiFindInExpr(e, \x -> 
		switch (x) {
			FiLet(__,__, e1,__,__,__): {
				if (fiIsStat(e1)) Some(x) else None();
			}
			FiIf(e1,__,__,__,__): {
				if (fiIsStat(e1)) Some(x) else None();
			}
			FiCall(f, args,__,__): {
				if (exists(concat([f], args), fiIsStat)) Some(x) else None();
			}
			FiCast(e1,__,__,__,__): {
				if (fiIsStat(e1)) Some(x) else None();
			}
			FiCallPrim(__,es,__,__): {
				if (exists(es, fiIsStat)) Some(x) else None();
			}
			default: None();
		}
	));
}

fiDoPushExpsDown(i: int, xs: [FiExp], as: [FiExp], fn: ([FiExp]) -> FiExp, type: FiType) -> FiExp {
	if (i == length(xs)) fn(as) else {
		x = xs[i];
		switch (x) {
			FiIf(e1, e2, e3,__,__): {
				FiIf(x with
					type = type,
					e2 = fiDoPushExpsDown(i + 1, xs, concat(as, [e2]), fn, type),
					e3 = fiDoPushExpsDown(i + 1, xs, concat(as, [e3]), fn, type)
				);
			}
			FiSeq(es,__,__): {
				FiSeq(x with
					type = type,
					es = replace(es, length(es) - 1,
						fiDoPushExpsDown(i + 1, xs, concat(as, [es[length(es) - 1]]), fn, type)
					)
				);
			}
			FiLet(__,__,e1,e2,__,__): {
				FiLet(x with
					type2 = type,
					e2 = fiDoPushExpsDown(i + 1, xs, concat(as, [e2]), fn, type)
				);
			}
			FiSwitch(__,__,cs,__,__): {
				FiSwitch(x with
					type = type,
					cases = map(cs, \c -> 
						FiCase(c with body = fiDoPushExpsDown(i + 1, xs, concat(as, [c.body]), fn, type))
					)
				);
			}
			default: {
				fiDoPushExpsDown(i + 1, xs, concat(as, [x]), fn, type)
			}
		}
	}
}

fiPushExpDown(x: FiExp) -> FiExp {
	if (fiStatsArePulled(x)) x else {
		switch (x) {
			FiLet(v, vtype, e1, e2, type, start): {
				if (!fiIsStat(e1)) x else {
					switch (e1) {
						FiSeq(es1, type1, start1): {
							if (length(es1) == 1) FiLet(v, vtype, es1[0], e2, type, start) else {
								FiSeq(
									concat(
										take(es1, length(es1) - 1),
										[fiPushExpDown(FiLet(v, vtype, es1[length(es1) - 1], e2, type, start))]
									), type, start1
								);
							}
						}
						FiLet(v1, vtype1, e1_1, e1_2, type1, start1): {
							FiLet(v1, vtype1, e1_1,
								fiPushExpDown(FiLet(v, vtype, e1_2, e2, type, start)),
								type, start1
							);
						}
						FiSwitch(x1, swtype1, cs1, type1, start1): {
							FiSwitch(x1, swtype1, map(cs1, \c1 ->
									FiCase(c1 with body = fiPushExpDown(FiLet(v, vtype, c1.body, e2, type, start)))
								), 
								type, start1
							);
						}
						FiIf(e1_1, e1_2, e1_3, type1, start_1): {
							FiIf(e1_1, 
								fiPushExpDown(FiLet(v, vtype, e1_2, e2, type, start)),
								fiPushExpDown(FiLet(v, vtype, e1_3, e2, type, start)),
								type, start_1
							);
						}
						default: x; // TODO: FsAssign
					}
				}
			}
			FiIf(e1, e2, e3, type, start): {
				if (!fiIsStat(e1)) x else {
					switch (e1) {
						FiSeq(es1, type1, start1): {
							if (length(es1) == 1) FiIf(es1[0], e2, e3, type, start) else {
								FiSeq(
									concat(
										take(es1, length(es1) - 1),
										[fiPushExpDown(FiIf(es1[length(es1) - 1], e2, e3, type, start))]
									), type, start1
								);
							}
						}
						FiLet(v1, vtype1, e1_1, e1_2, type1, start1): {
							FiLet(v1, vtype1, e1_1,
								fiPushExpDown(FiIf(e1_2, e2, e3, type, start)),
								type, start1
							);
						}
						FiSwitch(x1, swtype1, cs1, type1, start1): {
							FiSwitch(x1, swtype1, map(cs1, \c1 ->
									FiCase(c1 with body = fiPushExpDown(FiIf(c1.body, e2, e3, type, start)))
								), 
								type, start1
							);
						}
						FiIf(e1_1, e1_2, e1_3, type1, start_1): {
							FiIf(e1_1, 
								fiPushExpDown(FiIf(e1_2, e2, e3, type, start)),
								fiPushExpDown(FiIf(e1_3, e2, e3, type, start)),
								type, start_1
							);
						}
						default: x; // TODO: FsAssign
					}
				}
			}
			FiCall(f, args, type, start): {
				if (!exists(concat([f], args), fiIsStat)) x else {
					fiDoPushExpsDown(0, concat([f], args), [], \as ->
						fiPushExpDown(FiCall(as[0], tail(as), type, start)), 
						type
					);
				}
			}
			FiCast(e, from, to, type, start): {
				if (!fiIsStat(e)) x else {
					fiDoPushExpsDown(0, [e], [], \as ->
						fiPushExpDown(FiCast(as[0], from, to, type, start)),
						type
					);
				}
			}
			FiLambda(__,body,__,__): {
				x;
			}
			FiCallPrim(op, es, type, start): {
				if (!exists(es, fiIsStat)) x else {
					fiDoPushExpsDown(0, es, [], \as ->
						fiPushExpDown(FiCallPrim(op, as, type, start)),
						type
					);
				}
			}
			default: x;
		}
	}
}

fiPushExpsDown(e: FiExp) -> FiExp {
	fiExpShortcutIf(mapFiExp(e, fiPushExpDown));
}

// In case a switch has only one variant - remove it
fiExpShortcutTrivialSwitch(x: FiExp, names: FiGlobalNames) -> FiExp {
	mapFiExp(x, \e -> switch (e) {
		FiSwitch(v, vtype, cs, type, start): {
			switch (vtype) {
				FiTypeName(typename,__): {
					if (containsKeyTree(names.unions, typename)) {
						e;
					} else {
						switch (find(cs, \c -> c.struct == typename)) {
							Some(c): c.body;
							None(): {
								fail0("unmatched struct type '" + typename + "' in switch:\n" + prettyFiExp(dummyPretty, e));
							}
						}
					}
				}
				FiTypeFlow(): {
					e;
				}
				default: {
					fail0("non-struct|union|flow type " + prettyFiType(dummyPretty, v.type, makeSet()) + " in switch:\n" + prettyFiExp(dummyPretty, e));
				}
			}
		}
		default: e;
	});
}

fiExpChangeAndOr2If(x: FiExp) -> FiExp {
	mapFiExp(x, \e -> switch (e) {
		FiCallPrim(op, es, type, start): {
			switch (op) {
				FcAndPrim(): {
					FiIf(es[0], es[1], FiBool(false, start), type, start);
				}
				FcOrPrim(): {
					FiIf(es[0], FiBool(true, start), es[1], type, start);
				}
				default: {
					e;
				}
			}
		}
		default: e;
	});
}


fiExpShortcutIf(x: FiExp) -> FiExp {
	mapFiExp(x, \e -> switch (e) {
		FiIf(c, e1, e2,__,__): {
			switch (c) {
				FiBool(v,__): {
					if (v) e1 else e2;
				}
				default: e;
			}
		}
		default: e;
	});
}

fiExpReduceChainLets(x: FiExp) -> FiExp {
	mapFiExp(x, \e -> switch (e) {
		FiLet(v, t1, e1, e2,__,__): {
			switch (e1) {
				FiVar(w,__,__): {
					fiRenameVar(e2, v, w);
				}
				default: e;
			}
		}
		default: e;
	});
}

fiMakeCallerVar(x: FiExp) -> FiExp {
	id = ref 0;
	new_id = \-> {
		nid = "tmp_fn_var_" + i2s(^id);
		id := ^id + 1;
		nid;
	}
	mapFiExp(x, \e -> switch (e) {
		FiCall(fn, args, type, s): {
			if (fiExpIsNestedField(fn)) e else {
				n_var = FiVar(new_id(), fiExpType(fn), s);
				FiLet(n_var.name, n_var.type, fn,
					FiCall(n_var, args, type, s), type, s
				);
			}
		}
		default: e;
	});
}


fiWrapFunctionCasts(x: FiExp) -> FiExp {
	mapFiExp(x, \e -> switch (e) {
		FiCast(e1, from, to, type, s): {
			switch (from) {
				FiTypeFunction(from_args, from_ret): {
					switch (to) {
						FiTypeFunction(to_args, to_ret): {
							args = mapi(to_args, \i, arg ->
								FiFunArg("fn_cast_wrapper_arg__" + i2s(i), arg.type)
							);
							FiLambda(
								args,
								FiCast(
									FiCall(e1, 
										mapi(args, \i, arg ->
											FiCast(FiVar(arg.name, arg.type, s), arg.type, from_args[i].type, from_args[i].type, s)
										), 
										from_ret, s
									),
									from_ret, to_ret, to_ret, s
								),
								to, s
							);
						}
						default:e;
					}
				}
				default:e;
			}
		}
		default: e;
	});
}

fiExpUnfoldCasts(x: FiExp, names: FiGlobalNames, toplevel_name: string) -> FiExp {
	id = ref 0;
	new_id = \-> {
		nid = "tmp_cast_wrapper_arg__" + i2s(^id);
		id := ^id + 1;
		nid;
	}
	mapFiExp(x, \e -> switch (e) {
		FiCast(e1, from, to, type, s): {
			if (fiEqualTypes(from, to)) e1 else {
				fiUnfoldCasts(e1, from, to, s, names, new_id, toplevel_name);
			}
		}
		default: e;
	});
}

fiUnfoldCasts(e: FiExp, from: FiType, to: FiType, s: int, names: FiGlobalNames, new_id: () -> string, toplevel_name: string) -> FiExp {
	if (fiEqualTypes(from, to)) e else {
		switch (from) {
			FiTypeFunction(from_args, from_ret): {
				switch (to) {
					FiTypeFunction(to_args, to_ret): {
						args = mapi(to_args, \i, arg ->
							FiFunArg(new_id(), arg.type)
						);
						call = FiCall(e, 
							mapi(args, \i, arg ->
								fiUnfoldCasts(FiVar(arg.name, arg.type, s), arg.type, from_args[i].type, s, names, new_id, toplevel_name)
							), 
							from_ret, s
						);
						FiLambda(
							args,
							if (to_ret == FiTypeVoid()) call else FiCast(call, from_ret, to_ret, to_ret, s),
							to, s
						);
					}
					default: FiCast(e, from, to, to, s);
				}
			}
			FiTypeArray(from_arr): {
				switch (to) {
					FiTypeArray(to_arr): {
						arg = FiFunArg(new_id(), from_arr);
						FiCall(
							FiVar("map", 
								FiTypeFunction([
									FiFunArg("", from), 
									FiFunArg("", FiTypeFunction([FiFunArg("", from_arr)], to_arr))
								], to), 
								s
							),
							[e, FiLambda([arg],
								fiUnfoldCasts(FiVar(arg.name, arg.type, s), from_arr, to_arr, s, names, new_id, toplevel_name),
								FiTypeFunction([arg], to_arr),
								s
							)],
							to, s
						);
					}
					default: FiCast(e, from, to, to, s);
				}
			}
			FiTypeRef(from_ref): {
				switch (to) {
					FiTypeRef(to_ref): {
						FiCallPrim(FcRefPrim(),
							[fiUnfoldCasts(FiCallPrim(FcDerefPrim(), [e], from, s), from_ref, to_ref, s, names, new_id, toplevel_name)],
							to, s
						);
					}
					default: FiCast(e, from, to, to, s);
				}
			}
			FiTypeName(from_name, from_typars): {
				cast_struct = \x, struct_from, struct_to -> {
					name = struct_from.name;
					from_tp = FiTypeName(name, struct_from.typars);
					to_tp = FiTypeName(name, struct_to.typars);
					if (struct_from == struct_to) x else {
						wrapper_name = fiStructCastWrapperName(name);
						switch (lookupTree(names.toplevel, wrapper_name)) {
							Some(wrapper): {
								switch (wrapper) {
									FiFunctionDec(__,__,fn_type,__,__): {
										wrapper_spec_type = FiTypeFunction(fn_type with
											args = [FiFunArg(fn_type.args[0] with type = from_tp)],
											returnType = to_tp
										);
										FiCall(FiVar(wrapper_name, wrapper_spec_type, 0), [x], to_tp, 0);
									}
									default: {
										fail0("must be a function, got:\n" +
											strIndent(pretFiDeclaration(wrapper))
										);
									}
								}
							}
							None(): {
								tmp = FiVar(new_id(), from_tp, s);
								FiLet(tmp.name, tmp.type, x, 
									FiCallPrim(FcStructPrim(name),
										mapi(struct_from.args, \i, arg -> 
											fiUnfoldCasts(
												FiCallPrim(FcFieldPrim(arg.name), [tmp], arg.type, s),
												arg.type, struct_to.args[i].type, s, names, new_id, toplevel_name
											)
										),
										to_tp, s
									),
									to_tp, s
								);
							}
						}
					}
				}
				fiMapTypeName(from, names, 
					\struct_from -> switch (to) {
						FiTypeName(to_name,__): {
							fiMapTypeName(to, names, 
								\struct_to -> {
									if (from_name != to_name) {
										fail(
											"illegal cast of " + pretFiType(from) + " to " + pretFiType(to) + " in " + toplevel_name + ", expression:\n" +
											strIndent(pretFiExp(e))
										);
									}
									cast_struct(e, struct_from, struct_to);
								},
								\union_to -> FiCast(e, from, to, to, s),
								\err -> FiCast(e, from, to, to, s)
							);
						}
						default: FiCast(e, from, to, to, s)
					},
					\union_from -> {
						switch (to) {
							FiTypeName(to_name,__): {
								fiMapTypeName(to, names, 
									\struct_to -> FiCast(e, from, to, to, s),
									\union_to -> {
										tmp = FiVar(new_id(), from, s);
										FiLet(tmp.name, tmp.type, e, 
											FiSwitch(tmp, tmp.type,
												map(union_from.typenames,
													\tn_from -> {
														switch (find(union_to.typenames, \x -> x.name == tn_from.name)) {
															Some(tn_to): {
																struct_from = fiTypeName2Struct(tn_from, names);
																struct_to = fiTypeName2Struct(tn_to, names);
																from_tn = FiTypeName(struct_from.name, struct_from.typars);
																to_tn = FiTypeName(struct_to.name, struct_to.typars);
																FiCase(tn_from.name, map(struct_from.args, \__-> "__"),
																	FiCast(
																		cast_struct(
																			FiCast(e, from, from_tn, from_tn, s),
																			struct_from, struct_to
																		),
																		to_tn, to, to, s
																	), 
																	s
																);
															}
															None(): {
																// Such a cast will cause a runtime error
																FiCase(tn_from.name, [],
																	FiCast(e, tn_from, to, to, s), 
																	s
																);
															}
														}
													}),
												to, s
											),
											to, s
										);
									},
									\err -> fail0("error")
								);
							}
							default: {
								FiCast(e, from, to, to, s);
							}
						}
					},
					\err -> FiCast(e, from, to, to, s)
				);
			}
			default: FiCast(e, from, to, to, s);
		}
	}
}
