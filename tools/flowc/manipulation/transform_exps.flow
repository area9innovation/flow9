import tools/flowc/incremental/fi_helpers; 
import tools/flowc/manipulation/common;
import tools/flowc/incremental/fi_type_unify;
import string_utils;

export {

// Expand calls of common field of a struct in some unions to switch with individual 
// structs.
fiTransEliminateUnionFields(expr : FiExp, names: FiGlobalNames) -> FiExp;

/*
Example: 
	U :: S1, S2;
		S1(a: int, b: string);
		S2(x: double, a: int);

function 
	makeU() -> U { 
		...
	}

	someFn() -> void {
		...
		makeU().a
		...
	}

will expand to
	someFn() -> void {
		...
		__union_3 = makeU();
		switch(__union_3) {
			S1(__field_3,__): __field_3;
			S2(__,__field_3): __field_3;
		}
		...
	}

*/

// Make explicit cast of a switch variable to all particular cases.
fiExplicitCastInSwitch1(e : FiExp, names: FiGlobalNames) -> FiExp;

// Rename enclosed same var name in recurring FiLet.
/* Example: here rettype is recurring, i.e. needs renaming in the inner scope
rettype = {
		switch (type) {
			FiTypeFunction(__, rettype): fiCppLambdaRetType(cfg, program, rettype);
			default: "TODO";
		}
}
*/
fiExpRenameRecurringVars1(e: FiExp) -> FiExp;

/* Undo type coercing inside: 
	`if (isSameStructType(a, b)) { 
		e 
	}`  
transform it to:
	`if (isSameStructType(a, b)) { 
		__prime_a = cast(e: a.type -> b.type);
		e_prime
	}`
where `e_prime` - is e with `a` replaced by `__prime_a`
 */
fiFixVarInSameStructType1(e : FiExp) -> FiExp;

/*
In compound expressions, which contain subexpressions with non-scalar types, extract these
subexpressions via let-statements, which bind them with temporary variables, i.e.

func(Struct("A", 3, 4), 15, "...")

will be transformed into:

v1 = "A";
v2 = Struct(v1, 3, 4);
v3 = "...";
func(v2, 15, v3)

*/
fiExpExtractNonScalarToLet(e: FiExp) -> FiExp;

// Repace sequences of length 1 by its content
fiExpRemoveSigletonSeqences(e: FiExp) -> FiExp;

// The same as FiSSA
fiExpMakeVarsUnique(e: FiExp) -> FiExp;

fiExpMakeCastsExplicit(x: FiExp, t: FiType, names: FiGlobalNames) -> FiExp;

fiExpInterpolateTypars(e: FiExp, names: FiGlobalNames) -> FiExp;

fiExpReturnVars(e: FiExp) -> FiExp;

}

fiTransEliminateUnionFields(expr : FiExp, names: FiGlobalNames) -> FiExp {
	fiFoldMapExp(expr, 0, 
		\x,__,local -> {
			switch (x) {
				FiCallPrim(op, es, rtype, start): {
					switch (op) {
						FcFieldPrim(field): {
							if (field == "structname") Pair(x, local) else {
								arg = es[0];
								arg_type = fiExpType(arg);
								switch (arg_type) {
									FiTypeName(__,__): {
										switch (lookupTree(names.unions, arg_type.name)) {
											Some(union): {
												make_switch = \switch_var -> {
													FiSwitch(switch_var, switch_var.type, 
														map(union.typenames, \tn -> {
															struct = lookupTreeDef(names.structs, tn.name, FiTypeStruct("", [], [], 0));
															FiCase(
																tn.name,
																map(struct.args, \__ -> "__"),
																FiCallPrim(op, [switch_var], rtype, start),
																start
															)
														}),
														rtype, start
													);
												}
												switch (arg) {
													FiVar(var, vtype,__): {
														Pair(make_switch(arg), local);
													}
													default: {
														union_var = "__union_" + i2s(local);
														Pair(FiLet(
															union_var, arg_type,
															arg,
															make_switch(FiVar(union_var, arg_type, start)),
															rtype, start
														), local + 1);
													}
												}
											}
											None(): Pair(x, local);
										}
									}
									default: Pair(x, local);
								}
							}
						}
						FcSetMutablePrim(field): {
							arg = es[0];
							arg_type = fiExpType(arg);
							switch (arg_type) {
								FiTypeName(__,__): { 
									switch (lookupTree(names.unions, arg_type.name)) {
										Some(union): {
											make_switch = \switch_var -> {
												FiSwitch(switch_var, switch_var.type, 
													map(union.typenames, \tn -> {
														struct = lookupTreeDef(names.structs, tn.name, FiTypeStruct("", [], [], 0));
														FiCase(
															tn.name,
															map(struct.args, \__ -> "__"),
															FiCallPrim(x with es = [switch_var, es[1]]),
															start
														)
													}),
													rtype, start
												);
											}
											switch (arg) {
												FiVar(var, vtype,__): {
													Pair(make_switch(arg), local);
												}
												default: {
													union_var = "__union_" + i2s(local);
													Pair(FiLet(
														union_var, arg_type,
														arg,
														make_switch(FiVar(union_var, arg_type, start)),
														rtype, start
													), local + 1);
												}
											}
										}
										None(): Pair(x, local);
									}
								}
								default: Pair(x, local);
							}
						}
						default: Pair(x, local);
					}
				}
				default: Pair(x, local);
			}
		},
		FiMapOrder(false, true)
	).first;
}

fiExplicitCastInSwitch1(e : FiExp, names: FiGlobalNames) -> FiExp {
	mapFiExp(e, \x -> 
		switch (x) {
			FiSwitch(var, vtype, cases, type, start): {
				do_switch = \ -> {
					FiSwitch(x with 
						cases = map(cases, \c -> {
							if (c.struct == "default") c else {
								switch (lookupTree(names.structs, c.struct)) {
									Some(struct): {
										typars_instances = fiMatchTyparsOrdered(FiTypeName(struct.name, struct.typars), vtype);
										case_type = FiTypeName(struct.name, typars_instances);
										FiCase(c with body = 
											fiReplaceVar(c.body, var.name, FiCast(var, vtype, case_type, case_type, start))
										);
									}
									None(): {
										fail0("all switch cases must be structs, met: " + toStringFormatted(c));
									}
								}
							}
						})
					);
				}
				switch (vtype) {
					FiTypeName(typename, __): {
						if (containsKeyTree(names.unions, typename)) {
							do_switch();
						} else {
							switch (find(cases, \c -> c.struct == typename)) {
								Some(c): {
									c.body;
								}
								None(): {
									fail0("unmatched struct type '" + typename + "' in switch:\n" + prettyFiExp(dummyPretty, e));
								}
							}
						}
					}
					default: {
						do_switch();
					}
				}
			}
			default: x;
		}
	);
}

fiMakeNewVar(v: string, locals: Tree<string, FiVar>) -> string {
	fiDoMakeNewVar(v, locals, 0);
}

fiDoMakeNewVar(v: string, locals: Tree<string, FiVar>, i: int) -> string {
	w = "__" + v + "_" + i2s(i);
	if (!containsKeyTree(locals, w)) w else fiDoMakeNewVar(v, locals, i + 1);
}

fiExpRenameRecurringVars1(e: FiExp) -> FiExp {
	fiMapExp(e, \x, env ->
		switch (x) {
			FiLet(v, type, e1, e2,__, start): {
				if (v == "__" || !containsKeyTree(env.locals, v)) x else {
					w = fiMakeNewVar(v, env.locals);
					FiLet(x with
						name = w,
						e2 = fiRenameVar(e2, v, w)
					);
				}
			}
			default: x;
		}, false
	);
}

fiFixVarInSameStructType1(e : FiExp) -> FiExp {
	fiDetectIfIsSameStructType = \x -> switch (x.e1) {
		FiCall(f, args, __,__): {
			switch (f) {
			FiVar(name,__,__): {
				if (name == "isSameStructType") {
					filtermap(args, \arg -> 
						switch (arg) {
							FiVar(__,__,__): Some(arg);
							default: None();
						}
					);
				} else {
					[];
				}
			}
			default: [];
			}
		}
		default: [];
	}
	fiVarTypeInExpr = \y , var -> maybeMap(
		fiFindInExpr(y, \x ->
			switch (x) {
				FiVar(name,__,__): if (name == var) Some(e) else None();
				default: None();
			}
		), \x -> cast(x: FiExp -> FiVar)
	);
	mapFiExp(e, \x ->
		switch (x) {
			FiIf(e1, e2, e3, type, start): {
				vars = fiDetectIfIsSameStructType(x);
				if (length(vars) != 2) x else {
					v0 = vars[0];
					v1 = vars[1];
					fix_vars = \old: FiVar, new: FiVar -> {
						prim_name = "__prim_" + old.name;
						e2_prim = FiLet(prim_name, new.type, 
							FiCast(old, old.type, new.type, new.type, start),
							fiRenameVar(e2, old.name, prim_name), type, start
						);
						FiIf(x with e2 = e2_prim);
					}
					switch (fiVarTypeInExpr(e2, v0.name)) {
						Some(v0_prim): {
							switch (fiVarTypeInExpr(e2, v1.name)) {
								Some(v1_prim): {
									fail("both variables change types in 'if' with 'isSameStructType' condition");
									x;
								}
								None(): fix_vars(v0, v0_prim);
							}
						}
						None(): {
							switch (fiVarTypeInExpr(e2, v1.name)) {
								Some(v1_prim): fix_vars(v1, v1_prim);
								None(): x;
							}
						}
					} 
				}
			}
			default: x;
		}
	);
}

fiExpExtractNonScalarToLet(e: FiExp) -> FiExp {
	tmp_var_counter = ref 0;
	new_var = \-> {
		name = "__tv_" + i2s(^tmp_var_counter);
		tmp_var_counter := ^tmp_var_counter + 1;
		name;
	}
	fiMapExp(e,
		\x, env -> switch (env.parents) {
			EmptyList(): x;
			Cons(parent,__): {
				switch (parent) {
					FiLet(__,__,__,__,__,__): x;
					default: {
						switch (x) {
							FiVar(__,__,__): x;
							FiInt(__,__): x;
							FiBool(__,__): x;
							FiDouble(__,__): x;
							FiVoid(__): x;
							default: {
								type = fiExpType(x);
								if (fiTypeIsScalar(type)) x else {
									fn_var = new_var();
									FiLet(fn_var, type, x, FiVar(fn_var, type, 0), type, 0);
								}
							}
						}
					}
				}
			}
		},
		false
	);
}

fiExpRemoveSigletonSeqences(e: FiExp) -> FiExp {
	fiMapExp(e,
		\x,__ -> switch (x) {
			FiSeq(es,__,__): {
				if (length(es) == 1) es[0] else x;
			}
			default: x;
		},
		true
	);
}

fiExpMakeVarsUnique(e: FiExp) -> FiExp {
	new_var = \vars, v -> if (v == "__") vars else setTree(vars, v, lookupTreeDef(vars, v, 0) + 1);
	rename_var = \vars, v -> {
		if (v == "__") v else {
			i = lookupTreeDef(vars, v, 0);
			if (i == 0) fail("fsSSAvar: i == 0, v=" + v);
			v + if (i == 1) "" else "__ssa_" + i2s(i - 1);
		}
	}
	fiFoldMapExp(e, makeTree(),
		\x, env, vars -> {
			switch (x) {
				FiLambda(args, __,__,__): {
					new_vars = fold(args, vars, \acc, arg -> new_var(acc, arg.name));
					Pair(
						FiLambda(x with 
							args = map(args, \arg -> FiFunArg(arg with name = rename_var(new_vars, arg.name)))
						), 
						new_vars
					);
				}
				FiLet(name,__,__,__,__,__): {
					if (name == "__") Pair(x, vars) else {
						new_vars = new_var(vars, name);
						Pair(FiLet(x with name = rename_var(new_vars, name)), new_vars);
					}
				}
				FiSwitch(v, __,__,__,__): {
					new_vars = new_var(vars, v.name);
					Pair(
						FiSwitch(x with
							x = FiVar(v with name = rename_var(new_vars, v.name))
						),
						new_vars
					);
				}
				FiVar(name,__,__): {
					if (containsKeyTree(env.locals, name)) {
						Pair(FiVar(x with name = rename_var(vars, name)), vars);
					} else {
						Pair(x, vars);
					}
				}
				default(): Pair(x, vars);
			}
		},
		FiMapOrder(false, true)
	).first;
}

fiExpMakeCastsExplicit(x: FiExp, t: FiType, names: FiGlobalNames) -> FiExp {
	x1 = switch (x) {
		FiLambda(args, body, type,__): {
			switch (type) {
				FiTypeFunction(__,returnType): {
					FiLambda(x with body = fiExpMakeCastsExplicit(body, returnType, names));
				}
				default: {
					FiLambda(x with body = fiExpMakeCastsExplicit(body, fiExpType(body), names));
				}
			}
		}
		FiLet(v, v_type, e1, e2, __,__): {
			FiLet(x with 
				e1 = fiExpMakeCastsExplicit(e1, v_type, names),
				e2 = fiExpMakeCastsExplicit(e2, t, names)
			);
		}
		FiIf(e1, e2, e3, __,__): {
			FiIf(x with
				e1 = fiExpMakeCastsExplicit(e1, FiTypeBool(), names),
				e2 = fiExpMakeCastsExplicit(e2, t, names),
				e3 = fiExpMakeCastsExplicit(e2, t, names),
			);
		}
		FiSwitch(v, v_type, cases, __,__): {
			FiSwitch(x with
				cases = map(cases, \c -> FiCase(c with body = fiExpMakeCastsExplicit(c.body, t, names)))
			);
		}
		FiSeq(es, __,__): {
			FiSeq(x with es = mapi(es, \i, e -> 
				if (i + 1 == length(es)) fiExpMakeCastsExplicit(e, t, names)
				else fiExpMakeCastsExplicit(e, fiExpType(e), names)
			));
		}
		FiCall(fn, args,__,__): {
			fn_type = cast(fiExpType(fn): FiType -> FiTypeFunction);
			FiCall(x with
				f = fiExpMakeCastsExplicit(fn, fn_type, names),
				args = mapi(args, \i, arg ->
					fiExpMakeCastsExplicit(arg, fn_type.args[i].type, names)
				)
			);
		}
		FiCallPrim(op, es, type,__): {
			def_case = \ -> FiCallPrim(x with es = map(es, \y -> fiExpMakeCastsExplicit(y, fiExpType(y), names)));
			typed_case = \tp -> FiCallPrim(x with es = map(es, \y -> fiExpMakeCastsExplicit(y, tp, names)));
			switch (op) {
				FcOrPrim():  def_case();
				FcAndPrim(): def_case();
				FcNotPrim(): def_case();

				FcEqPrim():  typed_case(fiTypeUpperBoundary(fiExpType(es[0]), fiExpType(es[1]), names));
				FcNePrim():  typed_case(fiTypeUpperBoundary(fiExpType(es[0]), fiExpType(es[1]), names));
				FcLePrim():  typed_case(fiTypeUpperBoundary(fiExpType(es[0]), fiExpType(es[1]), names));
				FcGePrim():  typed_case(fiTypeUpperBoundary(fiExpType(es[0]), fiExpType(es[1]), names));
				FcLtPrim():  typed_case(fiTypeUpperBoundary(fiExpType(es[0]), fiExpType(es[1]), names));
				FcGtPrim():  typed_case(fiTypeUpperBoundary(fiExpType(es[0]), fiExpType(es[1]), names));

				FcPlusPrim():  def_case();
				FcMinusPrim(): def_case();
				FcMulPrim():   def_case();
				FcDivPrim():   def_case();
				FcModPrim():   def_case();
				FcNegPrim():   def_case();
				FcArrayPrim(): typed_case(fiDearrayType(type));
				FcIndexPrim(): FiCallPrim(x with es = [
					fiExpMakeCastsExplicit(es[0], FiTypeArray(type), names),
					fiExpMakeCastsExplicit(es[1], FiTypeInt(), names)
				]);
				FcDerefPrim(): typed_case(FiTypeRef(type));
				FcRefPrim(): typed_case(fiDerefType(type));
				FcStructPrim(name): {
					struct = lookupTreeDef(names.structs, name, FiTypeStruct("", [], [], 0));
					switch (type) {
						FiTypeName(__,typars): {
							typar_subst = foldi(struct.typars, makeTree(), \i, acc, tp ->
								switch (tp) {
									FiTypeParameter(nm): setTree(acc, nm, typars[i]);
									default: acc;
								}
							);
							FiCallPrim(x with es = mapi(es, \i, y ->
								fiExpMakeCastsExplicit(y, fiApplyTypeSubstitution(typar_subst, struct.args[i].type), names)
							));
						}
						default: {
							fail("struct type must be FiTypeName, got: " + toString(type));
							def_case();
						}
					}
				}
				FcFieldPrim(name): {
					if (name == "structname") def_case() else {
						switch (fiExpType(es[0])) {
							FiTypeName(struct_name, typars): {
								switch (lookupTree(names.structs, struct_name)) {
									Some(struct): {
										switch (find(struct.args, \arg -> arg.name == name)) {
											Some(arg): {
												fiMakeCast(def_case(), arg.type, type);
											}
											None(): {
												fail("field " + name + " of struct " + struct_name + " is not found");
												def_case();
											}
										}
									}
									None(): def_case();
								}
							}
							default: def_case();
						}
					}
				}
				FcAssignPrim(): {
					to = es[0];
					what = es[1];
					tp = fiExpType(to);
					switch (tp) {
						FiTypeRef(rt): {
							switch (fiExpType(what)) {
								FiTypeRef(__): FiCallPrim(x with es = [
									fiExpMakeCastsExplicit(to, tp, names), 
									fiExpMakeCastsExplicit(what, tp, names)
								]);
								default: FiCallPrim(x with es = [
									fiExpMakeCastsExplicit(to, tp, names), 
									fiExpMakeCastsExplicit(what, rt, names)
								]);
							}
						}
						default: {
							FiCallPrim(x with es = [
								fiExpMakeCastsExplicit(to, tp, names), 
								fiExpMakeCastsExplicit(what, tp, names)
							]);
						}
					}
				}
				FcSetMutablePrim(name): {
					switch (fiExpType(es[0])) {
						FiTypeName(struct_name, typars): {
							switch (lookupTree(names.structs, struct_name)) {
								Some(struct): {
									switch (find(struct.args, \arg -> arg.name == name)) {
										Some(arg): {
											FiCallPrim(x with es = [
												fiExpMakeCastsExplicit(es[0], arg.type, names), 
												fiExpMakeCastsExplicit(es[1], arg.type, names)
											]);
										}
										None(): {
											fail("field " + name + " of struct " + struct_name + " is not found");
											def_case();
										}
									}
								}
								None(): def_case();
							}
						}
						default: def_case();
					}
				}
				FcCreateClosurePrim(structName, functionName): def_case();
				FcQuote(): def_case();
				FcUnquote(): def_case();
			}
		}
		default: x;
	}
	fiMakeCast(x1, fiExpType(x1), t);
}

fiExpInterpolateTypars(e: FiExp, names: FiGlobalNames) -> FiExp {
	mapFiExp(e, \x -> switch (x) {
		FiCall(fn, args, ret_type,__): {
			switch (fiExpType(fn)) {
				FiTypeFunction(fn_args, returnType): {
					// Match arguments 
					args_unified = mapi(args, \i, arg -> fiUnifyTypes(fiExpType(arg), fn_args[i].type));
					ret_unified = fiUnifyTypes(returnType, ret_type);
					FiCall(x with 
						f = fiSetExpType(fn, FiTypeFunction(
							mapi(fn_args, \i, arg -> FiFunArg(arg.name, args_unified[i].second)),
							ret_unified.second
						)), 
						args = mapi(args, \i, arg -> fiSetExpType(arg, args_unified[i].first)),
						type = ret_unified.first
					);
				}
				default: {
					FiCall(x with f = fn, args = args);
				}
			}
		}
		FiCallPrim(op, es, type,__): {
			switch (op) {
				FcStructPrim(name): {
					struct = lookupTreeDef(names.structs, name, FiTypeStruct("", [], [], 0));
					switch (type) {
						FiTypeName(__,typars): {
							typar_subst = foldi(struct.typars, makeTree(), \i, acc, tp ->
								switch (tp) {
									FiTypeParameter(nm): setTree(acc, nm, typars[i]);
									default: acc;
								}
							);
							subst = foldi(struct.args, makeTree(), \i, sub, struct_arg -> 
								fiMatchTypars(fiExpType(es[i]), fiApplyTypeSubstitution(typar_subst, struct_arg.type), sub)
							);
							FiCallPrim(x with es = mapi(es, \i, y ->
								fiSetExpType(y, fiApplyTypeSubstitution(subst, fiExpType(x)))
							));
						}
						default: {
							fail("struct type must be FiTypeName, got: " + toString(type));
							x;
						}
					}
				}
				default: x;
			}
		}
		default: x;
	});
}

fiExpReturnVars(e: FiExp) -> FiExp {
	fiDoExpReturnVars(e, true);
}

fiDoExpReturnVars(e: FiExp, returns: bool) -> FiExp {
	e1 = switch (e) {
		FiLambda(__, body,__, __): {
			FiLambda(e with body = fiDoExpReturnVars(body, true));
		}
		FiCall(fn, args,__,__): {
			FiCall(e with
				f = fiDoExpReturnVars(fn, false),
				args = map(args, \x -> fiDoExpReturnVars(x, false))
			);
		}
		FiLet(__, __,e1, e2,__, __): {
			FiLet(e with
				e1 = fiDoExpReturnVars(e1, false),
				e2 = fiDoExpReturnVars(e2, returns)
			);
		}
		FiIf(e1, e2, e3,__, __): {
			FiIf(e with
				e1 = fiDoExpReturnVars(e1, false),
				e2 = fiDoExpReturnVars(e2, returns),
				e3 = fiDoExpReturnVars(e3, returns)
			);
		}
		FiSwitch(v, __,cases,__, __): {
			FiSwitch(e with 
				cases = map(cases, \c -> FiCase(c with body = fiDoExpReturnVars(c.body, returns)))
			);
		}
		FiCast(ex, __, __, __, __): {
			FiCast(e with e = fiDoExpReturnVars(ex, false));
		}
		FiSeq(es,__,__): {
			FiSeq(e with es = mapi(es, \i, x -> fiDoExpReturnVars(x, returns && i + 1 == length(es))));
		}
		FiCallPrim(__, es,__,__): {
			FiCallPrim(e with es = map(es, \x -> fiDoExpReturnVars(x, false)));
		}
		FiRequire(__, ex,__,__): {
			FiRequire(e with e = fiDoExpReturnVars(ex, false));
		}
		FiUnsafe(__, ex,__,__): {
			FiUnsafe(e with fallback = fiDoExpReturnVars(ex, false));
		}
		FiVar(name,__, __): e;
		FiVoid(__):       e;
		FiDouble(__,__):  e;
		FiInt(__,__):     e;
		FiString(__,__):  e;
		FiBool(__,__):    e;
	}
	if (!returns) e1 else {
		switch (e1) {
			FiVar(__,__,__): e1;
			default: {
				tp = fiExpType(e1);
				switch (tp) {
					FiTypeVoid(): e1;
					default: {
						ret = "__ret_var__";
						FiLet(ret, tp, e1, FiVar(ret, tp, e1.start), tp, e1.start);
					}
				}
			}
		}
	}
}
