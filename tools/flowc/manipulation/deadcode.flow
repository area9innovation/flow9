import tools/flowc/incremental/fiprogram;
import tools/flowc/manipulation/effects;
import tools/flowc/manipulation/freevars;

export {
	deadFiCode(prog : FiProgram, effects : FiEffects, preserveNames : HashSet<string>, eliminateNames : HashSet<string>, removeMain : bool, removeGlobals : bool, verbose : int) -> FiProgram;
}

deadFiCode(prog : FiProgram, effects : FiEffects, preserveNames : HashSet<string>, eliminateNames : HashSet<string>, removeMain : bool, removeGlobals : bool, verbose : int) -> FiProgram {
	used = deadFiCodeAlive(prog, effects, preserveNames, eliminateNames, removeMain, removeGlobals);
	dead = ref makeList();
	reportdead = \n -> dead := Cons(n, ^dead);
	modules = foldTree(
		prog.modules, 
		makeTree(), 
		\modname : string, mo : FiModule, acc -> {
			nfns = fold(mo.functions, [], \a, fn -> if (containsHashSet(used, fn.name)) concat(a, [fn]) else { reportdead(fn.name); a });
			nglobals = fold(mo.globalVars, [], \a, gv -> if (containsHashSet(used, gv.name)) concat(a, [gv]) else { reportdead(gv.name); a });
			nnatives = fold(mo.natives, [], \a, nat -> if (containsHashSet(used, nat.name)) concat(a, [nat]) else { reportdead(nat.name); a });
			ninitorder = filter(mo.initOrder, \n : string -> containsHashSet(used, n));
			nexports = hashSet2array(intersectHashSets(buildHashSet(mo.exports, fastHashString), used));
			nmo = FiModule(
				mo.fileinfo, 
				mo.imports, mo.forbids,
				nexports,
				mo.structs, mo.unions, 
				nfns, nglobals, nnatives,
				ninitorder,
				mo.stringIncludes,
				mo.start,
				mo.end,
				mo.allImports,
				mo.incremental,
			);
			setTree(acc, modname, nmo)
		}
	);
	// Show list of dead items only on verbose=2
	if (verbose > 1) {
		fcPrintln("Dead: " + strGlue(list2array(^dead), ", "), prog.config.threadId);
	}
	FiProgram(
		prog.config,
		modules,
		prog.traversal,
		prog.names,	// TODO: We should probably filter this dude as well
	);
}

DeadCodeAcc(effects : FiEffects, modules : Tree<string, FiModule>, queue : HashSet<string>, used : HashSet<string>);

deadFiCodeAlive(prog : FiProgram, effects : FiEffects, preserveNames : HashSet<string>, eliminateNames : HashSet<string>, removeMain : bool, removeGlobals : bool) -> HashSet<string> {
	queue = foldTree(
		prog.modules,
		differenceHashSets(
			mergeHashSets(if (removeMain) makeHashSet(fastHashString) else insertHashSet(makeHashSet(fastHashString), "main"), preserveNames),
			eliminateNames
		),
		\modname, mo, acc -> {
			fold(
				mo.globalVars, 
				acc, 
				\a, gv -> if (!removeGlobals && hasFiSideEffects(effects, gv.value)) insertHashSet(a, gv.name) else a
			)
		}
	);
	visitDead(DeadCodeAcc(effects, prog.modules, queue, makeHashSet(fastHashString)), eliminateNames).used
}

visitDead(acc : DeadCodeAcc, eliminateNames : HashSet<string>) -> DeadCodeAcc {
	switch (popHashSet(acc.queue)) {
		None(): acc;
		Some(name): {
			visitDead(
				deadFiName(DeadCodeAcc(acc.effects, acc.modules, acc.queue, acc.used),name, eliminateNames),
				eliminateNames
			)
		}
	}
}

deadFiName(acc : DeadCodeAcc, name : string, eliminateNames : HashSet<string>) -> DeadCodeAcc {
	mdec = lookupTree(acc.effects.names.toplevel, name);
	switch (mdec) {
		None(): {
			if (name != "main") {
				fcPrintln("WARNING: Something is wrong with DCE: Could not find '" + name + "'", acc.effects.config.threadId);
			}
			acc
		}
		Some(dec): {
			nused = insertHashSet(acc.used, name);
			referenced = switch (dec : FiDeclaration) {
				FiFunctionDec(f, lambda, __, __, __):          fifreevars(lambda);
				FiGlobalVar(x, value, __, __, __): fifreevars(value);
				FiNativeDec(n, isio, type, nativeName, flowfallback, __, __):
					switch (flowfallback) {
						FiLambda(__, __, __, __): fifreevars(flowfallback);
						default: makeHashSet(fastHashString);
					}
			}
			newnames = differenceHashSets(differenceHashSets(referenced, nused), eliminateNames);
			nqueue = mergeHashSets(acc.queue, newnames);
			nused2 = mergeHashSets(nused, newnames);
			DeadCodeAcc(acc.effects, acc.modules, nqueue, nused2)
		}
	}
}
