import ds/union_find_map;
import tools/flowe/dexp/dexp;
import tools/flowe/tracing;
import tools/flowe/types/reason;

export {
	TMap(
		// The union/find map of tnodes for each equivalence class
		tmap : UnionFindMap<TNode, ErrorReason>,
		// To help find a type name in the union find map
		typenameEClasses : ref Tree<string, [int]>,
		// The helpers we need to do the unification
		resolveUnionName : ref (string) -> Maybe<DUnion>,
		resolveSupertypes : ref (string) -> [string],
		resolveSubtypes : ref (string) -> [string],
		// For error reporting
		onError : (ErrorReason) -> void,
		// The next eclass
		nextEClass : ref int,
		// Make a unique id for supertypes
		mkUnique : () -> int,
		// A list of pending unifications that we could not do
		pending : ref List<Triple<TNode, TNode, ErrorReason>>,
		// A list of pending subtypings we could not do
		pendingSubtypes : ref List<Triple<int, int, ErrorReason>>,
		// For debugging
		tracing : Tracing,
		// What id are we type checking at the moment?
		topid : ref string,
	);

	// Our nodes in the type graph
	TNode ::= TNodeName, TNodeOverload, TNodeSupertype;
		// If the name is empty, it is a function. If name is empty, and typars empty, null
		// For functions, the last typar is the return type
		TNodeName(name : string, typars : [int], pos : [int]);
		TNodeOverload(
			unique : Set<int>, 
			// When we do not know what overload to pick, we keep candidates here
			overloads : [TNodeName], 
			pos : [int]
		);
		TNodeSupertype(
			// These are just unique ids to keep these separate
			uniques : Set<int>, 
			// When we know what the name is of a subtype, it goes here
			subtypes : [TNodeName],
			// When we do not know what the subtype is called, it goes here
			unknownSubtypes : Set<int>,
			// Is this set of subtypes the maximum it can be?
			maxed : bool,
			// Source code placements
			pos : [int]
		);
}
