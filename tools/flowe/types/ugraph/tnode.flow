import tools/flowe/types/ugraph/tmap;
import tools/flowe/types/ugraph/find;
import tools/flowe/types/ugraph/incompatible;
import tools/flowe/types/pretty;

/*
TODO:
- For random supertypes, we should find the "closest" supertype and pick that.

- Try to reset eclasses for each chunk: To do this, we need a "copy into new tmap"
  operation to run after each chunk, where we pick up "live" eclasses from the global
  names.
*/

export {
	// Set up the type unification map
	makeTMap(
		onError : (int, string) -> void, 
		nextEClass : ref int,
		mkUnique : () -> int, 
		tracing : Tracing
	) -> TMap;

	// Define the resolvers we need
	setTMapResolvers(t : TMap, 
		resolveUnionName : (string) -> Maybe<DUnion>,
		resolveSupertypes : (string) -> [string], 
		resolveSubtypes : (string) -> [string], 
	) -> TMap;

	// Given this eclass, what is the root equivalence class?
	rootTTypeEClass(tg : TMap, eclass : int) -> int;
	
	// Make a new type class
	makeTNodeClass(tmap : TMap) -> int;

	// When we know the type is unique - supertypes come to mind
	makeTNodeClassForType(tmap : TMap, type : TType, reason : ErrorReason) -> int;

	dtype2eclass(tmap : TMap, typars : Tree<string, int>, d : DType) -> int;
	findOrMakeTNodeClass(tmap : TMap, type : TType, reason : ErrorReason) -> int;
	joinTNodes(tmap : TMap, left : int, right : int, reason : ErrorReason) -> int;

	unifyTNodes(tmap : TMap, left : TType, right : TType, reason : ErrorReason) -> void;

	simplifyTNode(tmap : TMap, node : TNode, reason : ErrorReason) -> TNode;
	instantiateTNodeName(tmap : TMap, name : string, nodes : [TNodeName], pos : [int]) -> TNodeName;
	unifyTNodeNameWithSuper(tmap : TMap, node : TNodeName, super : TNodeSupertype, reason : ErrorReason) -> TNode;
	mergeTNodes(tmap : TMap, left : TNode, right : TNode, reason : ErrorReason) -> TNode;
	subtypeTNodes(tmap : TMap, sub : int, super : int, reason : ErrorReason) -> void;
}

makeTMap(onError : (int, string) -> void, nextEClass : ref int,
			mkUnique : () -> int, tracing : Tracing
		) -> TMap {
	self = ref None();
	tmap = TMap(
		makeUnionFindMap(defaultTNode(), \l, r, cookie : ErrorReason -> {
			switch (^self) {
				None(): {
					println("NOT SUPPOSED TO HAPPEN");
					l;
				}
				Some(s): mergeTNodes(s, l, r, cookie);
			}
		}),
		ref makeTree(),
		ref \__ -> {
			println("TODO: The resolvers are not set");
			None();
		},
		ref \__ -> {
			println("TODO: The resolvers are not set");
			[];
		},
		ref \__ -> {
			println("TODO: The resolvers are not set");
			[];
		},
		\er -> {
			reportErrors(er, onError)
		},
		nextEClass,
		mkUnique,
		ref makeList(),
		ref makeList(),
		ref false,
		tracing,
		ref "",
	);
	self := Some(tmap);
	tmap;
}

setTMapResolvers(t : TMap, 
	resolveUnionName : (string) -> Maybe<DUnion>,
	resolveSupertypes : (string) -> [string], 
	resolveSubtypes : (string) -> [string], 
) -> TMap {
	t.resolveUnionName := resolveUnionName;
	t.resolveSupertypes := resolveSupertypes;
	t.resolveSubtypes := resolveSubtypes;
	t;
}

rootTTypeEClass(tg : TMap, eclass : int) -> int {
	findUnionMapRoot(tg.tmap, eclass)
}

defaultTNode() -> TNode {
	TNodeName("", [], []);
}

uindent : ref string = ref "";

// These two types are unified
unifyTNodes(tmap : TMap, left : TType, right : TType, reason : ErrorReason) -> void {
	ind = ^uindent;
	verbose = isTracingId(tmap.tracing, StageTypeInference(), 2, ^(tmap.topid));
	if (verbose) {
		debugErrorReason(reason, "\n" + ind + "Unify " + rpad(prettyTTypeNode(tmap, left) + " and " + prettyTTypeNode(tmap, right), " ", 60) + " | ");
	}
	lclass = findOrMakeTNodeClass(tmap, left, reason);
	rclass = findOrMakeTNodeClass(tmap, right, reason);
	verbose2 = verbose 
		|| isDebuggingEClass(tmap, lclass, makeSet())
		|| isDebuggingEClass(tmap, rclass, makeSet());
	if (verbose2) {
		uindent := ind + "  ";
		debugErrorReason(reason, ind + "Unify 2 " + rpad(prettyTTypeNode(tmap, left) + " and " + prettyTTypeNode(tmap, right), " ", 60) + " e" + i2s(lclass) + " vs e" + i2s(rclass) + " | " + ^(tmap.topid) + ": ");
		// println("  " + debugTNode(tmap, lclass));
		// println("  " + debugTNode(tmap, rclass));
	}
	if (lclass != -1 && rclass != -1) {
		// println("  Union e" + i2s(lclass) + " and e" + i2s(rclass));
		root = unionUnionMap(tmap.tmap, lclass, rclass, reason);
		
		// println("  to e" + i2s(root) + " =  " + debugTNode(tmap, root));
		if (verbose) {
			debugErrorReason(reason, "\n" + ind + "After unify " + rpad(prettyTTypeNode(tmap, left) + " and " + prettyTTypeNode(tmap, right), " ", 60) + " | ");
			dumpTNodes(tmap);
		}
		{}
	} else {
		println("Not supposed to happen: " + prettyTType(left) + " and " + prettyTType(right));
	}
	uindent := ind;
}

findOrMakeTNodeClass(tmap : TMap, type : TType, reason : ErrorReason) -> int {
	eclass = findTNode(tmap, type);
	if (eclass != -1) {
		eclass
	} else {
		makeTNodeClassForType(tmap, type, reason);
	}
}

findOrMakeTNode(tmap : TMap, node : TNode, reason : ErrorReason) -> int {
	// And see if we can find that node!

	// println("\nLooking for " + prettyTNode(tmap, node));
	// dumpTNodes(tmap);

	sclass = switch (node) {
		TNodeOverload(unique, overloads, pos): {
			println("Not supposed to happen");
			-1;
		}
		TNodeSupertype(uniques, subtypes, unknownSubtypes, pos): {
			println("Not supposed to happen");
			-1;
		}
		TNodeName(name, typars, pos): {
			eclasses = getTreeArrayValue(^(tmap.typenameEClasses), name);
			mclass = find(eclasses, \ec -> {
				valnode = getUnionMapValue(tmap.tmap, ec);
				isSameTNode(tmap, node, valnode);
			});
			mclass ?? mclass : -1;
		}
	};

	if (sclass == -1) {
		makeEClassForTNode(tmap, node, reason);
	} else {
 		// println(^uindent + "Found it as an existing node " + i2s(sclass) + "\n");
		sclass;
	}
}

findTNodeClass(tmap : TMap, node : TNode) -> int {
	switch (node) {
		TNodeOverload(unique, overloads, pos): {
			findUnionMap(tmap.tmap, \eclass, nn -> {
				isSameTNode(tmap, node, nn)
			}, -1);
		}
		TNodeSupertype(uniques, subtypes, unknownSubtypes, pos): {
			findUnionMap(tmap.tmap, \eclass, nn -> {
				isSameTNode(tmap, node, nn)
			}, -1);
		}
		TNodeName(name, typars, pos): {
			eclasses = getTreeArrayValue(^(tmap.typenameEClasses), name);
			mclass = find(eclasses, \ec -> {
				valnode = getUnionMapValue(tmap.tmap, ec);
				isSameTNode(tmap, node, valnode);
			});
			mclass ?? mclass : -1;
		}
	};
}

makeTNodeClassForType(tmap : TMap, type : TType, reason : ErrorReason) -> int {
	node = makeTNode(tmap, type, reason);
	// println(^uindent + "Making a type for "+ prettyTTypeNode(tmap, type) + " from " + prettyTNode(tmap, node));
	makeEClassForTNode(tmap, node, reason);
}

makeEClassForTNode(tmap : TMap, node : TNode, reason : ErrorReason) -> int {
	// OK, could not find it. We need a new class
	nclass = makeTNodeClass(tmap);
	if (isDebuggingTopid(tmap)) {
		debugErrorReason(reason, ^uindent + "  Made e" + i2s(nclass) + " as " + prettyTNode(tmap, node) + ": ");
	}
	switch (node) {
		TNodeName(name, __, __): {
			tmap.typenameEClasses := treePushToArrayValue(^(tmap.typenameEClasses), name, nclass);
		}
		default: {}
	}
	setUnionMapValue(tmap.tmap, nclass, node);
	nclass;
}

setTNodeClass(tmap : TMap, eclass : int, node : TNode) -> void {
	setUnionMapValue(tmap.tmap, eclass, node);
}

makeTNodeClass(tmap : TMap) -> int {
	nclass = ^(tmap.nextEClass);
	tmap.nextEClass := nclass + 1;
	nclass;
}

dtype2eclass(tmap : TMap, typars : Tree<string, int>, d : DType) -> int {
	switch (d) {
		DTypePar(id, pos): {
			meclass = lookupTree(typars, id);
			switch (meclass) {
				None(): {
					node = TNodeName(id, [], [pos]);
					findOrMakeTNode(tmap, node, makeErrorReason([pos], "dtype2eclass"));
				}
				Some(eclass): eclass;
			}
		}
		DTypeName(id, ttypars, pos): {
			if (id == "auto") {
				makeTNodeClass(tmap)
			} else {
				node = TNodeName(id, map(ttypars, \tp -> dtype2eclass(tmap, typars, tp)), [pos]);
				findOrMakeTNode(tmap, node, makeErrorReason([pos], "dtype2eclass"));
			}
		}
		DTypeFunction(args, returnType, pos): {
			node = TNodeName("", 
				arrayPush(
					map(args, \arg -> dtype2eclass(tmap, typars, arg)),
					dtype2eclass(tmap, typars, returnType)
				),
				[pos]
			);
			findOrMakeTNode(tmap, node, makeErrorReason([pos], "dtype2eclass"));
		}
	}
}

isSameTNode(tmap : TMap, left : TNode, right : TNode) -> bool {
	// println(^uindent + "  Check " + prettyTNode(tmap, left) + " vs " + prettyTNode(tmap, right));
	left == right
	|| switch (left) {
		TNodeName(lname, ltypars, __): {
			switch (right) {
				TNodeName(rname, rtypars, __): {
					lname == rname 
					&& length(ltypars) == length(rtypars)
					&& forall(mapi(ltypars, \i, tp -> {
						findUnionMapRoot(tmap.tmap, tp)
						== findUnionMapRoot(tmap.tmap, rtypars[i])
					}), idfn)
				}
				default: false;
			}
		}
		TNodeOverload(uniques, overloads, __): {
			switch (right) {
				TNodeOverload(runiques, __, __): !isEmptySet(intersectSets(uniques, runiques));
				default: false;
			}
		}
		TNodeSupertype(uniques, __, __, __): {
			switch (right) {
				TNodeSupertype(runiques, __, __, __): !isEmptySet(intersectSets(uniques, runiques));
				default: false;
			}
		}
	}
}

makeTNode(tmap : TMap, t : TType, reason : ErrorReason) -> TNode {
	error = \ -> {
		println("ERROR: Could not make TNode for " + prettyTType(t));
		TNodeName("", [], []);
	}
	switch (t) {
		TTypeName(id, typars): makeTNodeName(tmap, t, reason);
		TTypeEClass(eclass): {
			getUnionMapValue(tmap.tmap, eclass);
		}
		TTypeFunction(args, returnType): makeTNodeName(tmap, t, reason);
		TTypeOverload(unique, overloads): {
			uid = findTNode(tmap, unique);
			uniques = if (uid == -1) {
				error();
				makeSet();
			} else makeSet1(uid);
			simplifyTNode(tmap, TNodeOverload(
				uniques,
				map(overloads, \st -> makeTNodeName(tmap, st, 
					elaborateReason(reason, "overload")
				)),
				getTreeKeys(reason.reasons)
			), reason)
		}
		TTypeSupertype(unique, subtypes, maxed): {
			emptySuper = TNodeSupertype(makeSet1(unique), [], makeSet(), getTreeKeys(reason.reasons));
			super = fold(subtypes, emptySuper, \acc, st -> extractSupers(tmap, acc, st));
			simplifyTNode(tmap, super, reason);
		}
	}
}

// Add t to this supertype as a subtype. If t is a supertype, add all members of that
extractSupers(tmap : TMap, acc : TNodeSupertype, t : TType) -> TNodeSupertype {
	addName = \n : TNodeName -> {
		//if (hasSupertype(tmap, n)) {
			// println("TODO: Wrap the children in supertype if not resolved! " + prettyTNode(tmap, n));
		// }
		TNodeSupertype(acc with subtypes = arrayPush(acc.subtypes, n));
	}
	addEClass = \e : int -> {
		TNodeSupertype(acc with unknownSubtypes = insertSet(acc.unknownSubtypes, e));
	}
	switch (t) {
		TTypeSupertype(__, sub, __): {
			fold(sub, acc, \acc2, st -> extractSupers(tmap, acc2, st));
		}
		TTypeEClass(eclass): {
			node = getUnionMapValue(tmap.tmap, eclass);
			switch (node) {
				TNodeName(name, typars, __): {
					if (isEmptyTNode(node)) {
						addEClass(eclass);
					} else {
						addName(node);
					}
				}
				TNodeOverload(unique, overloads, pos): {
					if (exists(overloads, isFlowNode)) {
						println("REVIEW: Somehow, we extract flow here");
						TNodeSupertype(acc with subtypes = arrayPush(acc.subtypes, TNodeName("flow", [], pos)));
					} else {
						println("TODO: Figure out how to represent this overload as a named type: " + prettyTType(t));
						acc;
					}
				}
				TNodeSupertype(uniques, subtypes, usub, pos): {
					TNodeSupertype(acc with
						subtypes = concat(acc.subtypes, subtypes),
						unknownSubtypes = mergeSets(acc.unknownSubtypes, usub),
					);
				}
			}
		}
		TTypeName(__, __): {
			addName(makeTNodeName(tmap, t, makeErrorReason(acc.pos, "extractsupers")));
		}
		TTypeFunction(args, returnType): {
			addName(makeTNodeName(tmap, t, makeErrorReason(acc.pos, "extractsupers")));
		}
		TTypeOverload(unique, overloads): {
			println("TODO: Figure out how to represent this overload as a named node: " + prettyTType(t));
			acc;
		}
	}
}

// Ensure that we get a named type out of this type. Used for the args of overloads and supertypes
makeTNodeName(tmap : TMap, t : TType, reason : ErrorReason) -> TNodeName {
	error = \ -> {
		println("ERROR: Could not make TNodeName for " + prettyTType(t));
		TNodeName("", [], getTreeKeys(reason.reasons));
	};
	switch (t) {
		TTypeName(id, typars): {
			TNodeName(id, mapi(typars, \i, tp -> findOrMakeTNodeClass(tmap, tp, 
				elaborateReason(reason, id + " typar #" + i2s(i + 1))
			)), getTreeKeys(reason.reasons));
		}
		TTypeFunction(args, returnType): {
			TNodeName("", 
				arrayPush(
					mapi(args, \i, a -> 
						findOrMakeTNodeClass(tmap, a, 
							elaborateReason(reason, "arg #" + i2s(i + 1))
						)
					),
					findOrMakeTNodeClass(tmap, returnType, 
						elaborateReason(reason, "return type")
					)
				), getTreeKeys(reason.reasons)
			)
		}
		TTypeEClass(eclass): {
			node = getUnionMapValue(tmap.tmap, eclass);
			switch (node) {
				TNodeName(__, __, __): node;
				default: {
					println("TODO: Lift this up to super or overload: " + prettyTNode(tmap, node));
					error();
				}
			}
		}
		TTypeOverload(unique, overloads): error();
		TTypeSupertype(unique, subtypes, maxed): error();
	}
}

// Given a node, simplify overload and supertypes as much as possible.
// - If overloads are unique, pick the one it is
// - If a supertype has unknown subtypes, see if any are known
// - If a supertype has all subtypes known, find the potential supers

simplifyTNode(tmap : TMap, node : TNode, reason : ErrorReason) -> TNode {
	switch (node) {
		TNodeName(name, typars, pos): {
			// The typars are eclasses, to they will be simplified elsewhere
			node;
		}
		TNodeOverload(unique, overloads, __): {
			// The overloads are assumed to be simplified already
			if (length(overloads) == 1) {
				overloads[0];
			} else {
				node;
			}
		}
		TNodeSupertype(uniques, subtypes, unknownSubtypes, pos): {
			simplifyTNodeSupertype(tmap, node, reason);
		}
	}
}

simplifyTNodeSupertype(tmap : TMap, node : TNodeSupertype, reason : ErrorReason) -> TNode {
	uniques = node.uniques;
	subtypes : [TNodeName] = node.subtypes;
	unknownSubtypes = node.unknownSubtypes;
	pos = node.pos;
	if (!isEmptySet(unknownSubtypes)) {
		// We have some typevars in here. See if any of those are
		// resolved
		resolved : Pair<[TNodeName], Set<int>> = foldSet(unknownSubtypes, Pair([], makeSet()), 
				\acc : Pair<[TNodeName], Set<int>>, st : int -> {
			root = rootTTypeEClass(tmap, st);
			unode = getUnionMapValue(tmap.tmap, root);
			unknown = \ -> {
				Pair(acc.first, insertSet(acc.second, root));
			}
			switch (unode) {
				TNodeName(name, typars, __): {
					if (isEmptyTNode(unode)) {
						unknown();
					} else {
						Pair(arrayPush(acc.first, unode), acc.second)
					}
				}
				TNodeSupertype(nuniques, nsubtypes, nunknownSubtypes, npos): {
					if (nsubtypes != []) {
						Pair(concat(acc.first, nsubtypes), acc.second);
					} else unknown();
				}
				TNodeOverload(unique, overloads, __): unknown();
			}
		});
		if (resolved.first != []) {
			cleaned = TNodeSupertype(uniques, concat(subtypes, resolved.first), resolved.second, pos);
			// println("Cleaned unknown " + prettyTNode(tmap, cleaned));
			simplifyTNode(tmap, cleaned, reason);
		} else {
			// Simplify the supertypes
			TNodeSupertype(uniques, subtypes, resolved.second, pos);
		}
	} else {
		// OK, we can calculate potential super types here
		// and reduce them to an overload or a given type
		named = getPossibleTSupers(tmap, node);
		nnamed = sizeSet(named);

		// Here we have the names that are possible
		if (nnamed == 1) {
			fnode = instantiateTNodeName(tmap, set2array(named)[0], subtypes, pos);
			unifyTNodeNameWithSuper(tmap, fnode, node, 
				joinReasons(reason,
					makeErrorReason(pos, "simplify supertype")
				)
			);
		} else {
			// Unify the typars of identical typenames
			nameGroups : Tree<string, [TNodeName]> = fold(subtypes, makeTree(), \acc, st : TNodeName -> {
				treePushToArrayUnique(acc, st.name, st)
			});
			unis : Pair<[TNodeName], [TNode]> = foldTree(nameGroups, Pair([], []), \name, group, acc : Pair<[TNodeName], [TNode]> -> {
				if (length(group) > 1) {
					merged = foldi(tail(group), group[0], \i, nn, acc2 : TNode -> {
						mergeTNodes(tmap, acc2, nn, 
							joinReasons(reason,
								makeErrorReason(pos, "resolved supertype")
							)
						);
					});
					switch (merged) {
						TNodeName(__, __, __): Pair(arrayPush(acc.first, merged), acc.second);
						default: {
							Pair(acc.first, arrayPush(acc.second, merged));
						}
					}
				} else Pair(concat(acc.first, group), acc.second);
			});
			if (unis.second == []) {
				TNodeSupertype(uniques, unis.first, unknownSubtypes, pos);
			} else {
				println("TODO: We found a non-named thing in a supertype");
				println(unis.second);
				TNodeSupertype(uniques, unis.first, unknownSubtypes, pos);
			}
		}
	}

}

// Are there any direct supertypes of this node?
hasSupertype(tmap : TMap, node : TNodeName) -> bool {
	id = node.name;
	supers0 = ^(tmap.resolveSupertypes)(id);
	supers0 != [];
}

// Could there be some supertype placement in this one?
isEClassResolved(tmap : TMap, eclass : int) -> bool {
	node = getUnionMapValue(tmap.tmap, eclass);
	switch (node) {
		TNodeName(name, typars, pos): {
			!isEmptyTNode(node) && forall(typars, \tp -> isEClassResolved(tmap, tp))
		}
		TNodeOverload(unique, overloads, pos): false;
		TNodeSupertype(uniques, subtypes, unknownSubtypes, pos): false;
	}
}

// Could there be a different subtype that this one?
hasSubtype(tmap : TMap, node : TNodeName) -> bool {
	subtypes = ^(tmap.resolveSubtypes)(node.name);
	length(subtypes) > 1;
}

// We know we want a given name, and we have a set of candidates to pick from which
// help figure out the required number of type-parameters.
// It constructs type classes for each typar
instantiateTNodeName(tmap : TMap, name : string, nodes : [TNodeName], pos : [int]) -> TNodeName {
	node = filter(nodes, \n -> n.name == name);	
	if (length(node) > 0) {
		TNodeName(
			name, map(node[0].typars, \tp -> {
				 makeTNodeClass(tmap)
			}), pos
		)
	} else {
		munion = ^(tmap.resolveUnionName)(name);
		switch (munion) {
			None(): {
				typars = if (name == "array" || name == "ref") 1 else 0;
				TNodeName(name, generate(0, typars, \__ -> makeTNodeClass(tmap)), pos);
			}
			Some(union): {
				typars = map(union.typars, \tp -> makeTNodeClass(tmap));
				TNodeName(name, typars, pos);
			}
		}
	}
}

//
// The pure unification
//

mergeTNodes(tmap : TMap, left : TNode, right : TNode, reason : ErrorReason) -> TNode {
	if (isDebuggingTopid(tmap)) {
		lclass = findTNodeClass(tmap, left);
		rclass = findTNodeClass(tmap, right);
		if (isDebuggingEClass(tmap, lclass, makeSet()) || isDebuggingEClass(tmap, rclass, makeSet())) {
			println(^uindent + "Merge nodes " + prettyTNode(tmap, left) + " and " + prettyTNode(tmap, right));
		}
	}
	// println(^uindent + "Merge nodes " + prettyTNode(tmap, left) + " and " + prettyTNode(tmap, right));
	todo = \ -> {
		println("TODO: Merge nodes " + prettyTNode(tmap, left) + " and " + prettyTNode(tmap, right));
		left;
	}
	error = \pos1 : [int], pos2 : [int] -> {
		lclass = findUnionMap(tmap.tmap, \i, val : TNode -> {
				isSameTNode(tmap, left, val)
			}, -1);

		rclass = findUnionMap(tmap.tmap, \i, val : TNode -> {
				isSameTNode(tmap, right, val)
			}, -1);
		tmap.onError(
				joinReasons(reason,
					makeErrorReason(concat(pos1, pos2), 
						prettyTNode(tmap, left) + " != " + prettyTNode(tmap, right) + " (e" + i2s(lclass) + " and e" + i2s(rclass) + ")"
					)
				)
		);
		// dumpTNodes(tmap);
		left;
	}
	if (isEmptyTNode(left)) simplifyTNode(tmap, right, reason)
	else if (isEmptyTNode(right)) simplifyTNode(tmap, left, reason)
	else if (isSameTNode(tmap, left, right)) left
	else switch (left) {
		TNodeName(lname, ltypars, pos): {
			switch (right) {
				TNodeName(rname, rtypars, rpos): {
					if (lname != rname) {
						if (lname == "flow" || rname == "flow") {
							// OK, we model it as an overload.
							TNodeOverload(makeSet1(tmap.mkUnique()), [left, right], concat(pos, rpos));
						} else if (isSingleUnionName(tmap, lname, rname)) {
							// As a special case, if one of these
							// is a singleton union with the other element,
							// it is ok
							left;
						} else {
							if (trim2(lname, "?") == "" && trim2(rname, "?") == "") {
								// ? vs ?? is not a problem
								left;
							} else {
								error(pos, rpos);
							}
						}
					} else if (length(ltypars) != length(rtypars)) {
						error(pos, rpos);
					} else {
						// Same name and # typars
						simplifyTNode(tmap, TNodeName(lname, mapi(ltypars, \i, lt -> {
							joinTNodes(tmap, lt, rtypars[i], elaborateReason(reason, 
								(if (lname == "") {
									if (i + 1 == length(ltypars)) {
										"return type"
									} else "arg #" + i2s(i + 1) 
								} else "typar #" + i2s(i + 1))
							));
						}), concat(pos, rpos)), reason)
					}
				}
				TNodeOverload(unique, overloads, __): {
					mergeTNodes(tmap, right, left, reason);
				}
				TNodeSupertype(unique, subtypes, __, __): {
					unifyTNodeNameWithSuper(tmap, left, right, reason);
				}
			}
		}
		TNodeOverload(lunique, loverloads, lpos): {
			switch (right) {
				TNodeName(name, typars, pos): {
					// OK: Find which of the overloads potentially match this one
					overloads = filter(loverloads, \lo : TNodeName -> {
						c = incompatibleTNodeNames(tmap, right, lo);
						if (c) {
							// println("Ignoring incompatible overload " + prettyTNode(tmap, lo) + " for " + prettyTNode(tmap, right));
							false;
						} else {
							true;
						}
					});
					if (overloads == []) {
						error(lpos, pos);
					} else if (length(overloads) == 1) {
						// println("Resolved overload " + prettyTNode(tmap, overloads[0]) + " for " + prettyTNode(tmap, left));
						mergeTNodes(tmap, overloads[0], right, 
							joinReasons(reason,
								makeErrorReason(concat(lpos, pos), "overload resolved")
							)
						);
					} else {
						// If we have identical information already, we do not
						// need to pend it
						if (!exists(overloads, \o -> {
							isSameTNode(tmap, o, right)
						})) {
							// OK, we can not clarify it, so push it to pending
							noverload = TNodeOverload(lunique, overloads, concat(lpos, pos));
							tmap.pending := Cons(Triple(noverload, right, reason), ^(tmap.pending));
							// println("Push pending again " + prettyTNode(tmap, right) + " to " + prettyTNode(tmap, noverload));
						}
						right;
					}
				}
				TNodeOverload(unique, overloads, pos): {
					flows = filter(concat(loverloads, overloads), isFlowNode);
					if (flows != []) {
						// OK, we have a flow type, so just pick that
						println("REVIEW: Why do we just pick the flow here?");
						flows[0];
					} else {
						println("TODO: Find the intersection between " + prettyTNode(tmap, left) + " and " + prettyTNode(tmap, right));
						left;
					}
				}
				TNodeSupertype(uniques, subtypes, usub, pos): {
					// We handle it in the opposite case
					mergeTNodes(tmap, right, left, reason);
				}
			}
		}
		TNodeSupertype(lunique, lsubtypes, lusub, lpos): {
			switch (right) {
				TNodeName(name, typars, pos): {
					unifyTNodeNameWithSuper(tmap, right, left, reason);
				}
				TNodeOverload(runique, roverloads, pos): {
					flows = filter(roverloads, isFlowNode);
					if (flows != []) {
						println("REVIEW: Why do we pick the flow in this supertype?");
						// OK, we resolve to the flow type
						flows[0];
					} else {
						todo();
					}
				}
				TNodeSupertype(runique, rsubtypes, rusub, pos): {
					simplifyTNode(tmap, TNodeSupertype(
						mergeSets(lunique, runique), 
						concat(lsubtypes, rsubtypes),
						mergeSets(lusub, rusub),
						concat(pos, lpos)
					), reason);
				}
			}
		}
	}
}

// OK, we have a named type against a super.
// There are a range of cases:
// The name can be a supertype of the right hand side.
// The name can be the same as the supertype
unifyTNodeNameWithSuper(tmap : TMap, node : TNodeName, super : TNodeSupertype, reason : ErrorReason) -> TNode {
	// println(^uindent + "Unifying " + prettyTNode(tmap, node) + " vs " + prettyTNode(tmap, super));
	found = ref false;
	iter(super.subtypes, \st -> {
		found := unifyTNodeNameWithSubtype(tmap, node, st, 
			joinReasons(reason,
				makeErrorReason(concat(node.pos, st.pos), "Unifying sub " + prettyTNode(tmap, node) + " vs super " + prettyTNode(tmap, super))
			)
		) || ^found;
	});

	if (!isEmptySet(super.unknownSubtypes)) {
		eclass = findOrMakeTNode(tmap, node, joinReasons(reason, makeErrorReason(concat(node.pos, super.pos), "unifynodevssuper")));
		iterSet(super.unknownSubtypes, \st -> {
			// println(^uindent + "Joining e" + i2s(eclass) + " and e" + i2s(st));
			subtypeTNodes(tmap, st, eclass, 
				joinReasons(reason,
					makeErrorReason(concat(node.pos, super.pos), node.name + " vs e" + i2s(st))
				)
			);
			found := true;
		});
	}

	if (!^found) {
		tmap.onError(makeErrorReason(concat(node.pos, super.pos), "TODO: Join " + prettyTNode(tmap, node) + " not complete against " + prettyTNode(tmap, super)));
	}

	node;
}

// Try to unify this super type against a subtype. Return true if successful
unifyTNodeNameWithSubtype(tmap : TMap, node : TNodeName, subtype : TNodeName, reason : ErrorReason) -> bool {
	if (subtype.name == node.name) {
		if (isDebuggingTopid(tmap)) {
			println(^uindent + "Sub with node " + prettyTNode(tmap, subtype) + " vs " + prettyTNode(tmap, node));
		}
		// OK, the same name, just go and subtype the typars
		if (length(subtype.typars) == length(node.typars)) {
			iteri(subtype.typars, \i, tp -> {
				subtypeTNodes(tmap, tp, node.typars[i], 
					joinReasons(
						reason,
						makeErrorReason(
							concat(node.pos, subtype.pos),
							"Sub with node " + prettyTNode(tmap, subtype) + " vs " + prettyTNode(tmap, node)
						)
					)
				);
				{}
			});
			true;
		} else {
			tmap.onError(
				joinReasons(reason,
					makeErrorReason(node.pos, "ERROR: Mismatch typars of " + prettyTNode(tmap, node) + " against " + prettyTNode(tmap, subtype))
				)
			);
			false;
		}
	} else if (node.name == "flow" || subtype.name == "flow") {
		true;
	} else {
		// OK, we know that the node has to be a supertype of st
		munion = ^(tmap.resolveUnionName)(node.name);
		switch (munion) {
			None(): {
				// OK, it is not a union, so they have to be the same
				tmap.onError(
					joinReasons(reason,
						makeErrorReason(node.pos, "Expected union " + prettyTNode(tmap, node) + " against " + prettyTNode(tmap, subtype))
					)
				);
				false;
			}
			Some(union): {
				stype : Maybe<DTypeName> = find(union.types, \tn -> tn.id == subtype.name);
				stype ?? {
					// OK, we have the relation from the union to the struct in this union
					unifyTNodeNameAgainstSubtype(tmap, node, subtype, union, stype);
					true;
				} : {
					msubunion : Maybe<DTypeName> = find(union.types, \tn -> {
						subs = collectSubtypes(tmap, makeSet(), tn.id);
						containsSet(subs, subtype.name)
					});
					switch (msubunion) {
						None(): {
							tmap.onError(
								joinReasons(reason,
									makeErrorReason(node.pos, "ERROR: Unknown subtype " + prettyTNode(tmap, node) + " from " + prettyTNode(tmap, subtype))
								)
							);
							false;
						}
						Some(subunion): {
							// OK, this is a stepping stone: We know this subunion contains our subtype
							misub = instantiateTNodeNameAgainstSubtype(tmap, node, subtype, 
								union, subunion);
							switch (misub) {
								None(): {
									tmap.onError(
										joinReasons(reason,
											makeErrorReason(node.pos, "ERROR: Unknown subtype " + prettyTNode(tmap, node) + " from " + prettyTNode(tmap, subtype))
										)
									);
									false;
								}
								Some(isub): {
									// OK, inch closer
									unifyTNodeNameWithSubtype(tmap, isub, subtype, reason)
								}
							}
						}
					}
				}
			}
		}
	}
}

// We have PExp and the expansion [PValue, PCall];
// We need to find PBool.
collectSubtypes(tmap : TMap, acc : Set<string>, typename : string) -> Set<string> {
	nacc = insertSet(acc, typename);
	munion = ^(tmap.resolveUnionName)(typename);
	switch (munion) {
		None(): nacc;
		Some(un): {
			fold(un.types, nacc, \acc2, tn -> {
				if (containsSet(acc2, tn.id)) acc2
				else collectSubtypes(tmap, acc2, tn.id)
			})
		}
	}
}

// OK, we have a union on the left hand side, and a subtype on the right hand side
// We have to figure out how those typars relate to each other.
// Thus, we have unionDef and the corresponding typename instantiation
unifyTNodeNameAgainstSubtype(tmap : TMap, unionNode : TNodeName, subNode : TNodeName, 
		unionDef : DUnion, subDef : DTypeName) -> void {
	msubInstantiated : Maybe<TNodeName>= instantiateTNodeNameAgainstSubtype(tmap, unionNode, subNode, 
		unionDef, subDef);
	msubInstantiated ?? {
		subtypes = msubInstantiated.typars;
		if (length(subtypes) == length(subNode.typars)) {
			// println("    " + prettyTNode(tmap, msubInstantiated) + " vs " + prettyTNode(tmap, subNode));
			iteri(subtypes, \i, tp -> {
				if (tp != -1) {
					joinTNodes(tmap, tp, subNode.typars[i], 
						makeErrorReason(concat(unionNode.pos, subNode.pos), 
						"TODO: Typar #" + i2s(i + 1) + " from " + prettyTNode(tmap, subNode) + " vs " + prettyTNode(tmap, unionNode) + " from " + prettyTNode(tmap, msubInstantiated))
					);
					{}
				} else {
					tmap.onError(makeErrorReason(unionNode.pos, "ERROR: Could not match typars " + prettyTNode(tmap, subNode) + " vs " + prettyTNode(tmap, unionNode)));
				}
			{}
			});
		} else {
			tmap.onError(makeErrorReason(unionNode.pos, "ERROR: Expected typars for " + prettyTNode(tmap, subNode) + " vs " + prettyTNode(tmap, unionNode)));
		}
	} : {
		tmap.onError(makeErrorReason(unionNode.pos, "ERROR: Expected typars for " + prettyTNode(tmap, subNode) + " vs " + prettyTNode(tmap, unionNode)));
	}
}

// Instantiates a typename that we know is in the union
instantiateTNodeNameAgainstSubtype(tmap : TMap, unionNode : TNodeName, subNode : TNodeName, 
		unionDef : DUnion, subDef : DTypeName) -> Maybe<TNodeName> {
	// println("  Node " + prettyTNode(tmap, unionNode) + " vs " + prettyTNode(tmap, subNode));
	if (length(unionNode.typars) == length(unionDef.typars)) {
		// OK, map from the typar to the eclass it is bound to
		typars : Tree<string, int> = foldi(unionDef.typars, makeTree(), \i, acc, tp : DTypePar -> {
			setTree(acc, tp.id, unionNode.typars[i]);
		});

		// Consider
		// Maybe<?> ::= None, Some<?>
		// If we are in the None, case, notice we have one too little typars
		sdtype : DTypeName = if (length(subDef.typars) == 0) {
			// So we implicitly extend it when there are none
			DTypeName(subDef with typars = unionDef.typars)
		} else subDef;
		subtypes = map(sdtype.typars, \tp -> {
			dtype2eclass(tmap, typars, tp)
		});
		// OK, instantiate the struct from the union typars
		subInstantiated = TNodeName(subNode.name, subtypes, subNode.pos);
		Some(subInstantiated)
	} else {
		None();
	}	
}

joinTNodes(tmap : TMap, left : int, right : int, reason : ErrorReason) -> int {
	root = unionUnionMap(tmap.tmap, left, right, reason);
	
	if (false) {
		lnode = getUnionMapValue(tmap.tmap, left);
		rnode = getUnionMapValue(tmap.tmap, right);
		
		println("  Joining e" + i2s(left) + " and e" + i2s(right) + " to e" + i2s(root) + ": " + debugTNode(tmap, root)
			+ " from " + prettyTNode(tmap, lnode) + " and " + prettyTNode(tmap, rnode));
	}
	root;
}

// We know that the eclass "sub" is a subclass of "super".
subtypeTNodes(tmap : TMap, sub : int, super : int, reason : ErrorReason) -> void {
	postpone = \ -> {
		tmap.pendingSubtypes := Cons(Triple(sub, super, reason), ^(tmap.pendingSubtypes));
	}
	supernode = getUnionMapValue(tmap.tmap, super);
	subnode = getUnionMapValue(tmap.tmap, sub);
	// println(^uindent + "Subtyping " + prettyTNode(tmap, subnode) + " vs " + prettyTNode(tmap, supernode) + "  // e" + i2s(sub) + " vs e" + i2s(super));
	switch (subnode) {
		TNodeSupertype(__, __, __, spos): {
			if (isEmptyTNode(supernode)) {
				postpone();
			} else {
				// This is optimistic, but we just take the chance
				joinTNodes(tmap, sub, super, 
					joinReasons(reason, makeErrorReason(concat(supernode.pos, spos), "optimistic sub vs super"))
				);
				{}
			}
		}
		TNodeName(name, typars, npos): {
			if (hasSupertype(tmap, subnode)) {
				// We have a direct supertype
				switch (supernode) {
					TNodeName(__, __, __): {
						if (isEmptyTNode(supernode)) {
							supertype = TNodeSupertype(makeSet(), [subnode], makeSet(), []);
							supers = getPossibleTSupers(tmap, supertype);
							nsupers = sizeSet(supers);
							if (nsupers == 1) {
								println("TODO: We could infer that sub is " + toString(set2array(supers)));
							}
							postpone();
						} else {
							// println("Unifying subtype for e" + i2s(sub) + ": " + prettyTNode(tmap, subnode) + " vs " + prettyTNode(tmap, supernode));
							unifyTNodeNameWithSubtype(tmap, supernode, subnode, reason);
							{}
						}
					}
					TNodeSupertype(suniques, stypes, seclass, spos): {
						mega = TNodeSupertype(suniques, arrayPush(stypes, subnode), seclass, spos);
						mergeTNodes(tmap, supernode, mega, joinReasons(reason, makeErrorReason(concat(npos, spos), "subtype")));
						{}
					}
					TNodeOverload(unique, overloads, __): postpone();
				}
			} else {
				def = \ -> {
					if (!isEClassResolved(tmap, sub) && !isEClassResolved(tmap, super)) {
						// println(^(tmap.topid) + ": Postpone. TODO: We could maybe stub the type up " + prettyTNode(tmap, subnode) + " vs " + prettyTNode(tmap, supernode));
						postpone();
					} else {
						joinTNodes(tmap, sub, super, 
							joinReasons(
								reason,
								makeErrorReason(
									concat(subnode.pos, supernode.pos),
									prettyTNode(tmap, subnode) + " vs " + prettyTNode(tmap, supernode)
								)
							)
						);
						{}
					}
				}
				switch (supernode) {
					TNodeName(supername, stypars, spos): {
						if (name == supername && length(typars) == length(stypars)) {
							// OK, we subtype the typars
							// println("Subtyping the typars");
							if (name == "") {
								// Function
								def();
							} else {
								iteri(typars, \i, tp -> {
									if (i < length(stypars)) {
										subtypeTNodes(tmap, tp, stypars[i], 
											joinReasons(reason,
												makeErrorReason(concat(npos, spos), "Subtyping typars for " + name)
											)
										)
									}
								});
							}
						} else {
							if (isEmptyTNode(subnode) && !isEmptyTNode(supernode) && !hasSubtype(tmap, supernode)) {
								subtype = TNodeName(supername, mapi(stypars, \i, lt -> {
									makeTNodeClass(tmap)
								}), supernode.pos);
								setTNodeClass(tmap, sub, subtype);
								// println(^(tmap.topid) + ": We stub the subtype up " + prettyTNode(tmap, subtype) + " vs " + prettyTNode(tmap, supernode));
								iteri(subtype.typars, \i, tp -> {
									subtypeTNodes(tmap, tp, stypars[i], 
										joinReasons(
											reason,
											makeErrorReason(concat(npos, spos), "stub subtype up " + prettyTNode(tmap, subtype) + " vs " + prettyTNode(tmap, supernode))
										)
									)
								});
							} else if (!isEmptyTNode(subnode) && isEmptyTNode(supernode)) {
								suptype = TNodeName(name, mapi(typars, \i, lt -> {
									makeTNodeClass(tmap)
								}), subnode.pos);
								setTNodeClass(tmap, super, suptype);
								// println(^(tmap.topid) + ": We stub the supertype up " + prettyTNode(tmap, subnode) + " vs " + prettyTNode(tmap, supernode));
								iteri(suptype.typars, \i, tp -> {
									subtypeTNodes(tmap, typars[i], tp, 
										joinReasons(reason, 
											makeErrorReason(concat(npos, spos), "stub the supertype up " + prettyTNode(tmap, subnode) + " vs " + prettyTNode(tmap, supernode))
										)
									)
								});
							} else {
								def();
							}
						}
					}
					default: def();
				}
			}
		}
		TNodeOverload(__, __, __): postpone();
	}
}

