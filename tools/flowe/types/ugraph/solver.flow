import tools/flowe/types/ugraph/tnode;
import tools/flowe/types/ugraph/debug;

export {
	solveTNodes(tmap : TMap, visited : ref Set<int>, eclass : int) -> void;
}

solveTNodes(tmap : TMap, visited : ref Set<int>, eclass : int) -> void {
	if (eclass < ^(tmap.nextEClass)
		&& solveEClass(tmap, visited, eclass)) {
		solveTNodes(tmap, visited, eclass + 1);
	} else {}
}

solveEClass(tmap : TMap, visited : ref Set<int>, eclass : int) -> bool {
	if (!containsSet(^visited, eclass)) {
		root = rootTTypeEClass(tmap, eclass);
		if (root == eclass) {
			visited := insertSet(^visited, root);
			// OK, this is a root node. Let us try this one
			tnode = getUnionMapValue(tmap.tmap, root);
			snode = simplifyTNode(tmap, tnode, makeErrorReason([0], "Solving"));
			// OK, here try to resolve this node
			if (solveTNode(tmap, visited, eclass, snode)) {
				// TODO: This should be unify
				mergeTNodes(tmap, tnode, snode, makeErrorReason([0], "Simplified"));
				true;
			} else {
				false;
			}
		} else true;
	} else true;
}

solveTNode(tmap : TMap, visited : ref Set<int>, eclass : int, tnode : TNode) -> bool {
	if (isEmptyTNode(tnode)) true
	else {
		switch (tnode) {
			TNodeName(name, typars, pos): true;
			TNodeOverload(unique, overloads, pos): {
				nonflows = filter(overloads, \n -> !isFlowNode(n));
				if (length(nonflows) == 1) {
					// TODO: This should be unify
					merged = mergeTNodes(tmap, tnode, nonflows[0], makeErrorReason([0], "Simplified away from flow"));
					println("TODO: Lost resolution of "  + prettyEClass(tmap, eclass) + " to " + prettyTNode(tmap, nonflows[0]));
					true;
				} else {
					println("TODO: Try to solve each of these " + prettyEClass(tmap, eclass));
					false;
				}
			}
			TNodeSupertype(uniques, subtypes, unknownSubtypes, maxed, pos): {
				def = \ -> {
					supers = getPossibleTSupers(tmap, tnode);
					if (isEmptySet(supers)) {
						// OK, it is polymorphic or decided elsewhere
						true;
					} else {
						println("TODO: Try these " + strGlue(set2array(supers), ",") + " for " + prettyEClass(tmap, eclass));
						false;
					}
				}
				if (isEmptySet(unknownSubtypes)) {
					def();
				} else {
					us = foldSet(unknownSubtypes, true, \acc, st -> {
						acc && solveEClass(tmap, visited, st)
					});
					if (us) {
						// OK, we resolved these somehow
						snode = simplifyTNode(tmap, tnode, makeErrorReason([0], "Solving after unknnown"));
						if (snode != tnode) {
							// OK, this never happens.
							// TODO: This should be unify
							merged = mergeTNodes(tmap, tnode, snode, makeErrorReason([0], "Simplified"));
							if (merged != tnode) {
								println("TODO: We loose that tnode " + prettyTNode(tmap, tnode) + " simplifies to " + prettyTNode(tmap, snode));
							}
						}
						switch (snode) {
							TNodeName(__, __, __): {
								true;
							}
							TNodeOverload(__, __, __): {
								solveTNode(tmap, visited, eclass, snode);
							}
							TNodeSupertype(__, __, unknownSubtypes2, __, __): {
								if (isEmptySet(unknownSubtypes2)) {
									def();
								} else {
									iterSet(unknownSubtypes2, \st -> {
										println("Could not resolve unknown " + prettyEClass(tmap, st));
									});
									false;
								}
							}
						}
					} else {
						us;
					}
				};
			}
		}
	}
}
