import tools/flowe/types/ugraph/tnode;
import tools/flowe/types/ugraph/debug;

export {
	solveTNodes(tmap : TMap, visited : ref Set<int>, eclass : int) -> void;
}

solveTNodes(tmap : TMap, visited : ref Set<int>, eclass : int) -> void {
	if (eclass < ^(tmap.nextEClass)
		&& doSolveTNodes(tmap, visited, eclass)) {
		solveTNodes(tmap, visited, eclass + 1);
	} else {}
}

doSolveTNodes(tmap : TMap, visited : ref Set<int>, eclass : int) -> bool {
	if (!containsSet(^visited, eclass)) {
		root = rootTTypeEClass(tmap, eclass);
		if (root == eclass) {
			visited := insertSet(^visited, root);
			// OK, this is a root node. Let us try this one
			tnode = getUnionMapValue(tmap.tmap, root);
			snode = simplifyTNode(tmap, tnode, makeErrorReason([0], "Solving"));
			// OK, here try to resolve this node
			if (solveTNode(tmap, eclass, snode)) {
				mergeTNodes(tmap, tnode, snode, makeErrorReason([0], "Simplified"));
				true;
			} else {
				false;
			}
		} else true;
	} else true;
}

solveTNode(tmap : TMap, eclass : int, tnode : TNode) -> bool {
	if (isEmptyTNode(tnode)) true
	else {
		todo = \ -> {
			println("TODO: Try to solve each of these " + prettyEClass(tmap, eclass));
			false;
		}
		switch (tnode) {
			TNodeName(name, typars, pos): true;
			TNodeOverload(unique, overloads, pos): {
				todo();
			}
			TNodeSupertype(uniques, subtypes, unknownSubtypes, pos): {
				// TODO: We should arguably visit all the unknownSubtypes first
				iterSet(unknownSubtypes, \st -> {
					unode = getUnionMapValue(tmap.tmap, st);
					if (!isEmptyTNode(unode)) {
						println("TODO: Unknown subtype is not empty: " + prettyEClass(tmap, st));
					}
				});
				supers = getPossibleTSupers(tmap, tnode);
				if (isEmptySet(supers)) {
					// OK, it is polymorphic or decided elsewhere
					true;
				} else {
					println("TODO: Try these " + strGlue(set2array(supers), ",") + " for " + prettyEClass(tmap, eclass));
					false;
				}
			}
		}
	}
}
