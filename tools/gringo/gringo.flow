import gringo/gringo_grammar;
import gringo/gringo_parse;
import gringo/exponential;
import gringo/compiler/gcode;
import gringo/gringo_prepare;
import gringo/gringo_ast_actions;
import gringo/json_actions;
import gringo/gringo_to_fast;
import net/url_parameter;
import fs/filesystem;

main() {
	file0 = getUrlParameter("file");

	if (file0 != "") {
		grammar = gringoGrammar();
		file = changeFileExt(file0, ".gringo");
		if (!fileExists(file)) {
			println(file + " not found");
		}
		text = getFileContent(file);

		// Construct a Gringo AST from the parse
		env = doGringoParse(grammar, gringoAstAction, GringoAstAcc(makeList()), text, false, false);

		if (!env.fail && strlen(text) == env.i) {
			println("Parsed " + file + " (" + i2s(env.i) + " chars) successfully.");

			// OK, we have the result of the parse
			resGrammar = optimizeGTerm(getAstResult(env.output));

			grammar_term = prepareGringoGrammar(resGrammar);
			checkRules(file, grammar_term);

			// Produce flow output with the grammar AST
			out = getUrlParameter("out");
			if (out != "") {
				outfile = if (out == "1") changeFileExt(file, "") + "_grammar.flow" else out;
				println("Saving " + outfile);
				setFileContent(
					outfile,
					blueprint("
						// Generated by 
						// gringo file=%file% out=%out%
						import text/gringo/gringo_ast;

						export {
							%name%() -> GTerm;
						}

						%name%() -> GTerm {
							%grammar%
						}
					", [
						"file", file,
						"out", out,
						"name", changeFileExt(fileNameOnly(file), "") + "Grammar",
						"grammar", toString(grammar_term),
					])
				);
				{}
			};

			// Produce fast parser code with the grammar AST
			fast = getUrlParameter("fast");
			if (fast != "") {
				name = strReplaces(changeFileExt(file, ""), ["/", "_", "\\", "_"]);
				outfile = if (fast == "1") changeFileExt(file, "") + "_grammar.fast" else fast;
				println("Saving " + outfile);
				conf = Gringo2FastConf(
					getUrlParameter("accType"),
					getUrlParameter("verb"),
					getUrlParameter("matched")
				);
				setFileContent(
					outfile,
					blueprint("
						// Generated by 
						// gringo file=%file% fast=%fast% accTYpe=%accType% verb=%verb% matched=%matched%
						import parsec;

						%funcs%
					", [
						"file", file,
						"fast", fast,
						"funcs", generateFastParserFromGringo(name, grammar_term, conf),
						"accType", getUrlParameter("accType"),
						"verb", getUrlParameter("verb"),
						"matched", getUrlParameter("matched"),
					])
				);
				{}
			};

			// Compile to flow code
			compile = getUrlParameter("compile");
			if (compile != "") {
				name = strReplaces(changeFileExt(file, ""), ["/", "_", "\\", "_"]);
				outfile = if (compile == "1") changeFileExt(file, "") + "_parser.flow" else compile;
				println("Saving " + outfile);
				setFileContent(outfile, makeGTermParser(grammar_term, file));
				{}
			}

			// Test parse
			test = getUrlParameterDef("test", "");
			testfile = getUrlParameter("testfile");
			testtext = if (test != "") test else if (testfile != "") getFileContent(testfile) else "";
			if (testtext != "") {
				tenv = doGringoParse(resGrammar, jsonAction, makeList(), testtext, isUrlParameterTrue("trace"), isUrlParameterTrue("grammar"));
				if (!tenv.fail && strlen(testtext) == tenv.i) {
					println("Parsed test: " + i2s(tenv.i) + " chars successfully.");
				};
				if (true) {
					println("Stack");
					iterList(tenv.output, \j -> {
						println(json2stringFormatted(j));
					});
				};
				json : Json = getJsonGringo(tenv.output);
				result = getUrlParameter("result");
				if (result == "1") {
					println(json2stringFormatted(json));
				} else if (result != "") {
					setFileContent(result, json2stringFormatted(json));
					println("Saved output to " + result);
				}
			} else if (isUrlParameterTrue("grammar")) {
				ogrammar = prepareGringoGrammar(resGrammar);
				println("Fully optimized:");
				println(gterm2string(ogrammar));
			};

			quit(0);
		} else {
			quit(1);
		}
	} else {
		println("
Usage:

gringo file=path/grammar.gringo <options>

    file=<file> gives the path to the Gringo file to work with.

    out=1 or <file> compiles the grammar to AST and saves it as a flow file.

    compile=1 or <file> compiles the grammar to efficient flow code.
    fast=1 or <file> compiles the grammar to fast code.

    grammar=1 prints the optimized grammar for inspection.
	prefix=1 dumps the prefix terminals per processed rule.

	profile=<rule> will count the number of times rules with the <rule> prefix are called

    test=<string> immediately tests the grammar on that string.
	testfile=<filename> tests the grammar on the contents of that file.
    result=1 prints the output of the test parse.
    result=<file> saves the output of the test parse.
	trace=1 will print debugging while parsing the test
");

		quit(0);
	}
}

doGringoParse(grammar : GTerm, actions : GringoAction<?>, output : ?, text : string, verbose : bool, debugGrammar : bool) -> GringoEnv<?> {
	if (false) {
		println("Original:");
		println(gterm2string(grammar));
	};
	ogrammar = prepareGringoGrammar(grammar);
	if (debugGrammar) {
		println("Fully optimized:");
		println(gterm2string(ogrammar));
	};

	env = GringoEnv(text, makeTree(), actions, output, makeTree(), 0, false, 0);
	genv = gringoParse(env, ogrammar);

	if (genv.fail) {
		println("Parsing failed");
	};
	linefn = \s -> if (strlen(s) > 80) strLeft(s, 80) + "..." else s;
	traverseInOrder(genv.errors, \pos, error -> {
		remaining = linefn(strRight(env.input, pos));
		println("Error: " + remaining);
	});
	if (genv.i < strlen(env.input) || genv.fail) {
		remaining = linefn(strRight(env.input, genv.maxi));
		println("Did not parse: " + remaining);
	};
	genv;
}
