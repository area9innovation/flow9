import gringo/gringo_ast;
import gringo/gringo_pretty;
import gringo/utils;
import gringo/compiler/dcode;
import text/blueprint;

export {
	makeGTermParser(g : GTerm, file : string) -> string;
}

/*
TODO:
The flow-parser takes a SyntaxParseAcc and returns the result.

Changes required:

- Our output is polymorphic, so we have to figure out how to represent 
  the failure node

- Caching

- Change i to be mutable
  - Choice reverts the i when match fails

- A sequence of multiple things is "outlined"

- There is a range of low-level optimizations for Opt(string) and such.
  - Consider to have an intermediate representation
  - SyntaxStar is a function that takes a matching function
  - SyntaxPlus is a function that takes a matching function

- There is a special case for when we are NOT inside a choice

- Two chars is still code with getCharCodeAt
*/

makeGTermParser(g : GTerm, file : string) -> string {
	if (true) {
		makeDExpParser(g, file);
	} else {
		main = mainRule(g);
		blueprint("
			// Produced by  flowcpp gringo/gringo.flow -- file=%file%.gringo compile=1
			import text/gringo/gcode_env;
			import string;
			
			export {
				parse_%main%(GCodeEnv) -> GCodeEnv;
			}

			%term%"
			, [
				"file", file,
				"term", compileGTerm(g, ref 0, "env"),
				"main", main
			]
		);
	}
}

compileGTerm(g : GTerm, var : ref int, envname : string) -> string {
	newid = \ -> {
		var := ^var + 1;
		"var" + i2s(^var)
	}
	switch (g) {
		GRule(id, term, body): {
			blueprint("
				parse_%id%(env : GCodeEnv) -> GCodeEnv {
					%term%
				}

				%body%", ["id", id,
					"term", compileGTerm(term, var, "env"),
					"body", {
						switch (body) {
							GVar(__): ""
							default: compileGTerm(body, var, "")
						}
					}
				]
			)
		}
		GPrecedence(left, right): "ERROR";
		GChoice(left, right): {
			blueprint("
				{
					// Choice
					%var% = %left%;
					if (%var%.fail) {
						%right%
					} else %var%
				}
				", [
					"var", newid(),
					"left", compileGTerm(left, var, envname),
					"right", compileGTerm(right, var, envname)
				]
			)
		}
		GSeq(left, right): {
			lvar = newid();
			blueprint("
				{
				// seq
				%var% = %left%;
				if (%var%.fail) {%var%} else {
				%right%
				}}", [
					"var", lvar,
					"env", envname,
					"left", compileGTerm(left, var, envname),
					"right", compileGTerm(right, var, lvar)
				]
			);
		}
		GStar(term): {
			blueprint("
				{
					// *
					%var% = ref \\acc -> acc;
					%var% := \\acc -> {
						senv = %term%;
						if (senv.fail) {
							acc
						} else {
							(^%var%)(senv)
						}
					};
					(^%var%)(%env%);
				}", [
					"env", envname,
					"var", newid(),
					"term", compileGTerm(term, var, "acc"),
				]
			);
		}
		GPlus(term): {
			compileGTerm(
				GSeq(term, GStar(term)), var, envname
			);
		}
		GOpt(term): {
			blueprint("
				{
					// Opt
					%var% = %term%;
					if (%var%.fail) {
						%env%
					} else {
						%var%
					}
				}", [
					"env", envname,
					"var", newid(),
					"term", compileGTerm(term, var, envname),
				]
			);
		}
		GNegate(term): {
			blueprint("
				{
					// Negate
					%var% = %term%;
					if (%var%.fail) {
						%env%
					} else {
						GCodeEnv(%env% with fail = true);
					}
				}", [
					"env", envname,
					"var", newid(),
					"term", compileGTerm(term, var, envname),
				]
			);
		}
		GError(term): {
			switch (term) {
				GNegate(nterm): {
					blueprint("
						{
							// Negative error
							%var% = %nterm%;
							if (%var%.fail) {
								GCodeEnv(%var% with fail = false);
							} else {
								GCodeEnv(
									%var% with errors = setTree(%env%.errors, %env%.i, %error%)
								);
							}
						}", [
							"env", envname,
							"var", newid(),
							"nterm", compileGTerm(nterm, var, envname),
							"error", toString("Superfluous " + makeGExplanation(nterm))
						]
					);
				}
				default: {
					blueprint("
						{
							// Error handling
							%var% = %term%;
							if (%var%.fail) {
								GCodeEnv(
									%var% with fail = false, 
									errors = setTree(%env%.errors, %env%.i, %error%)
								);
							} else {
								%var%
							}
						}", [
							"env", envname,
							"var", newid(),
							"term", compileGTerm(term, var, envname),
							"error", toString("Expected " + makeGExplanation(term))
						]
					);
				}
			}
		}
		GLower(term): compileGTerm(term, var, envname);
		GUnquote(term): {
			def = \ -> {
				blueprint("
					{
						// Unquote matched
						%var% = %term%;
						if (%var%.fail) {
							%var%;
						} else {
							starti = %env%.i;
							matched = substring(%env%.input, starti, %var%.i - starti);
							GCodeEnv(%var% with output = %env%.action.addMatched(%var%.output, matched))
						}
					}", [
						"env", envname,
						"var", newid(),
						"term", compileGTerm(term, var, envname),
					]
				);
			};
			switch (term) {
				GString(text): {
					blueprint("GCodeEnv(%env% with output = %env%.action.addVerbatim(%env%.output, %text%))", [
							"env", envname,
							"text", toString(text)
						]
					);
				}
				GUnquote(nt): {
					switch (nt) {
						GString(text): {
							blueprint("GCodeEnv(%env% with output = %env%.action.addMatched(%env%.output, %text%))", [
									"env", envname,
									"text", toString(text)
								]
							);
						}
						GVar(id): {
							if (id == "pos") {
								blueprint("GCodeEnv(%env% with output = %env%.action.addVerbatim(%env%.output, i2s(%env%.i))", [
										"env", envname,
									]
								);
							} else def();
						}
						default: {
							def();
						}
					}
				}
				default: def();
			}
		}
		GString(text): {
			if (strlen(text) == 1) {
				blueprint("
					// Char
					if (getCharCodeAt(%env%.input, %env%.i) == %textcode%) {
						ni = %env%.i + 1;
						GCodeEnv(
							%env% with i = ni,
							maxi = max(%env%.maxi, ni)
						)
					} else {
						GCodeEnv(%env% with fail = true)
					}", [
						"env", envname,
						"textcode", i2s(getCharCodeAt(text, 0)),
					]
				);
			} else {
				blueprint("
					if (strContainsAt(%env%.input, %env%.i, %text%)) {
						ni = %env%.i + %length%;
						GCodeEnv(
							%env% with i = ni,
							maxi = max(%env%.maxi, ni)
						)
					} else {
						GCodeEnv(%env% with fail = true)
					}", [
						"env", envname,
						"text", toString(text),
						"length", i2s(strlen(text)),
					]
				);

			}
		}
		GRange(lower, upper): {
			blueprint("
				// Range
				if ({%code% = getCharCodeAt(%env%.input, %env%.i);%lower% <= %code% && %code% <= %upper%}) {
					ni = %env%.i + 1;
					GCodeEnv(
						%env% with i = ni,
						maxi = max(%env%.maxi, ni)
					)
				} else {
					GCodeEnv(%env% with fail = true)
				}", [
					"env", envname,
					"code", newid(),
					"lower", i2s(lower),
					"upper", i2s(upper)
				]
			);
		}
		GVar(id): {
			"parse_" + id + "(" + envname + ")";
		}
		GEpsilon():	envname;
	}
}
