import tools/gringo/type/type_eval;
import tools/gringo/type/types;
import tools/gringo/type/type_converter;
import ds/arrayutils;
import net/url_parameter;
import fs/filesystem;

export {
	// Save a file with the types required for the given grammar
	produceGringoTypes(file : string, grammar : GTerm) -> void;
}

produceGringoTypes(file : string, grammar : GTerm) -> void {
	typeenv = gringoType(grammar);
	// OK, map of what GTypes each rule produces
	types1 : Tree<string, [GType]> = typeenv.env;

	// OK, some of these types are simple, so we can instantiate them where they occur
	types = simplifyGRuleTypes(types1);

	if (false) {
		println("Result of grammar: " + superglue(typeenv.stack, prettyGType, "  \n"));
		traverseInOrder(types, \rule, rtype -> {
			println(capitalize(rule) + " = " + prettyGType(rtype));
		});
	}

	// OK, extract the unions and structs, and the type of each rule
	typeacc = foldTree(types, GTypeAcc(makeTree(), makeTree(), makeTree(), 
		getUrlParameter("type-prefix"), GfTypeName("error", "ERROR")), \rule, rtype, acc -> {
		acc2 = processRuleGType(acc, rule, rtype);
		ruletype = acc2.type;
		GTypeAcc(acc2 with named = setTree(acc2.named, rule, ruletype));
	});

	// At this point, we have a translation of each rule to what type it results in

	if (false) {
		println("\nConverted to flow types:");
		// And report on the result
		traverseInOrder(typeacc.named, \name, undef -> {
			println(name + " : " + toString(undef));
		});

		traverseInOrder(typeacc.unions, \un, undef -> {
			println(toString(undef));
		});

		traverseInOrder(typeacc.structs, \un, undef -> {
			println(toString(undef));
		});
	}

	// Simplify the unions
	typeacc2 = foldTree(typeacc.unions, typeacc, \un, undef, acc -> {
		stypes = sortUnique(map(undef.subtypes, \st -> {
			simplifyGfType(acc, st);
		}));
		if (stypes != sortUnique(undef.subtypes)) {
			GTypeAcc(acc with
				unions = setTree(acc.unions, un, GfTypeUnion(un, stypes))
			);
		} else acc;
	});

	// Simplify the structs
	typeacc3 = foldTree(typeacc2.structs, typeacc2, \st, stdef, acc -> {
		stargs = map(stdef.args, \sa -> {
			Pair(sa.first, simplifyGfType(acc, sa.second));
		});
		GTypeAcc(acc with
			structs = setTree(acc.structs, st, GfTypeStruct(st, stargs))
		);
	});

	// Should we construct an Ã¼ber union to use for parsing?
	masterType = getUrlParameter("master-type");
	monster = if (masterType != "") {
		// Produce the type converter file
		typepath = changeFileExt(strReplace(file, "\\", "/"), "");
		makeGfTypeConverter(typepath, masterType, typeacc3.prefix, typeacc3.unions, typeacc3.structs);

		prefix = getUrlParameter("prefix");
		mainRule = mainRule(grammar);
		main = prefix + "parse_" + mainRule;

		mainType = gfType2Flow(typeacc3, lookupTreeDef(typeacc3.named, mainRule, GfTypeName(mainRule, mainRule)));

		// Produce the typed parser
		typedParser = blueprint("
			// Generated by Gringo
			import %typepath%2dsl;
			import %parserpath%;
			import text/gringo/gringo_typed_action;
			import tools/dsl/dsl_parse;

			export {
				parse%t%(code : string, onError : (string) -> void) -> %t%;
			}

			parse%t%(code : string, onError : (string) -> void) -> %t% {
				ast = gringoTypedParse(code, dslAction, %main%, DslList(makeList()), onError);
				dslAst2%t%(ast);
			}
		", [
			"typepath", typepath,
			"parserpath", strReplace(typepath, "_types", "_parser"),
			"t", mainType,
			"main", main
		]);
		setFileContent(strReplace(typepath, "_types", "_parse_typed.flow"), typedParser);

		names = concat(getTreeKeys(typeacc3.unions), getTreeKeys(typeacc3.structs));
		"\t// This is a monster type used when parsing\n"
		"\t" + masterType + " ::= " 
			// We need a special list for parsing as well as basic types
			+ masterType + "List, " + masterType + "Bool, " + masterType + "Int, " + masterType + "Double, " + masterType + "String, " 
			+ strGlue(names, ", ") + ";\n"
			+ "\n\t" + masterType + "List(value : List<"+ masterType +">);\n"
			+ "\t" + masterType + "Bool(value : bool);\n"
			+ "\t" + masterType + "Int(value : int);\n"
			+ "\t" + masterType + "Double(value : double);\n"
			+ "\t" + masterType + "String(value : string);\n"
			+ "\n"
	} else "";

	if (endsWith(file, ".flow")) {
		// OK, generate the code for these guys
		start = "// Automatically generated from Gringo grammar\n"
			+ (if (masterType != "") "import ds/list;\n" else "") 
			+  "\nexport {\n" + monster;

		unions = foldTree(typeacc3.unions, start, \un, undef, acc -> {
			acc + "\t" + gfUnion2Flow(typeacc3, undef)
		});
		result = foldTree(typeacc3.structs, unions, \st, stdef, acc -> {
			acc + "\t" + gfStruct2Flow(typeacc3, false, stdef)
		}) + "}\n";

		// println(result);
		setFileContent(file, result);
		{}
	} else {
		produceMelonTypes(file, typeacc3, typeacc3.unions, typeacc3.structs);
		{}
	}
}

simplifyGRuleTypes(rules : Tree<string, [GType]>) -> Tree<string, GType> {
	simpleRules = foldTree(rules, makeTree(), \rule, vals, acc -> {
		if (length(vals) == 1) {
			val = vals[0];
			switch (val) {
				GTypeResult(__): acc;
				GTypeNil(): acc;
				GTypeBool(): setTree(acc, rule, val);
				GTypeInt(): setTree(acc, rule, val);
				GTypeDouble(): setTree(acc, rule, val);
				GTypeString(): setTree(acc, rule, val);
				GTypeAction(name, args): acc;
				GTypeStar(type): acc;
				GTypeUnion(types): acc;
			}
		} else acc;
	});

	foldTree(rules, makeTree(), \rule, vals, acc -> {
		if (length(vals) != 1) acc
		else {
			stype = instantiateSimpleGRules(simpleRules, vals[0]);
			if (isSameStructType(vals[0], stype)) setTree(acc, rule, vals[0])
			else setTree(acc, rule, stype)
		}
	})
}

instantiateSimpleGRules(simple : Tree<string, GType>, type : GType) -> GType {
	switch (type) {
		GTypeResult(rule): lookupTreeDef(simple, rule, type);
		GTypeNil(): type;
		GTypeBool(): type;
		GTypeInt(): type;
		GTypeDouble(): type;
		GTypeString(): type;
		GTypeAction(name, args): {
			GTypeAction(name, map(args, \a -> instantiateSimpleGRules(simple, a)));
		}
		GTypeStar(typ): GTypeStar(instantiateSimpleGRules(simple, typ));
		GTypeUnion(types): {
			stypes = sortUnique(map(types, \a -> instantiateSimpleGRules(simple, a)));
			if (length(stypes) == 1) {
				stypes[0];
			} else {
				GTypeUnion(stypes);
			}
		}
	}
}

GTypeAcc(
	unions : Tree<string, GfTypeUnion>,
	structs : Tree<string, GfTypeStruct>,
	named : Tree<string, GfType>,
	prefix : string,
	type : GfType
);

makeGfTypeName(acc : GTypeAcc, name : string) -> GfTypeName {
	typename = if (toLowerCase(name) == name) {
		humpCase(name, true)
	} else name;
	GfTypeName(name, acc.prefix + typename);
}	

simplifyGfType(acc : GTypeAcc, type : GfType) -> GfType {
	switch (type) {
		GfTypeName(fieldName, typename): {
			if (containsKeyTree(acc.unions, typename)) {
				type;
			} else if (containsKeyTree(acc.structs, typename)) {
				type;
			} else {
				mresolve = lookupTree(acc.named, fieldName);
				mresolve ?? {
					if (mresolve != type) {
						simplifyGfType(acc, mresolve);
					} else mresolve;
				} : {
					println("TODO: Figure out what to do with this unknown type: " + fieldName);
					type;
				}
			}
		}
		GfTypeArray(t): {
			GfTypeArray(simplifyGfType(acc, t));
		}
		default: type;
	}
}

// Find and extract all structs and unions, and otherwise return the corresponding type
processRuleGType(acc : GTypeAcc, rule : string, t : GType) -> GTypeAcc {
	mktypename = \r -> makeGfTypeName(acc, r);
	switch (t) {
		GTypeResult(r): GTypeAcc(acc with type = mktypename(r));
		GTypeNil(): {
			println(rule + ": Did not expect bare nil result");
			acc;
		}
		GTypeBool(): GTypeAcc(acc with type = t);
		GTypeInt(): GTypeAcc(acc with type = t);
		GTypeDouble(): GTypeAcc(acc with type = t);
		GTypeString(): GTypeAcc(acc with type = t);
		GTypeAction(name, args): {
			// OK, we have a struct
			tname = mktypename(name);
			sname = tname.typename;

			// Process the arguments
			arged = fold2(args, acc, [], \acc2, argacc, arg -> {
				tt = processRuleGType(acc2, rule, arg);
				sarg = Pair(gftype2fieldname(tt.type), tt.type);
				Pair(tt, arrayPush(argacc, sarg));
			});
			nacc = arged.first;
			sargs = if (isUrlParameterTrue("eclasses")) {
				arrayPush(arged.second, Pair("eclass", GTypeInt()))
			} else arged.second;
			struct = GfTypeStruct(sname, sargs);
			GTypeAcc(
				nacc with structs = setTree(nacc.structs, sname, struct),
					type = tname
			);
		}
		GTypeStar(type): {
			tt = processRuleGType(acc, rule, type);
			GTypeAcc(tt with type = GfTypeArray(tt.type));
		}
		GTypeUnion(types): {
			tname = mktypename(rule);
			sname = tname.typename;
			stypes = fold2(types, acc, [], \acc2, atypes, tt -> {
				// allow optional parameters (GTypeNil)
				acc3 = if (tt == GTypeNil()) GTypeAcc(acc with type = mktypename(rule)) else processRuleGType(acc2, rule, tt);
				ut : GfType = acc3.type;
				if (ut == tname) Pair(acc3, atypes)
				else {
					Pair(acc3, arrayPush(atypes, ut));
				}
			});
			subtypes = uniq(stypes.second);
			if (length(subtypes) == 1) {
				// An alias is not required to be named
				GTypeAcc(acc with type = subtypes[0]);
			} else {
				union = GfTypeUnion(sname, subtypes);
				GTypeAcc(
					stypes.first
					with unions = setTree(stypes.first.unions, sname, union),
					type = tname
				);
			}
		}
	}
}

gftype2fieldname(g : GfType) -> string {
	switch (g) {
		GTypeBool(): "b";
		GTypeInt(): "i";
		GTypeDouble(): "d";
		GTypeString(): "s";
		GfTypeArray(t): gftype2fieldname(t) + "s";
		GfTypeName(f, name): f;
	}
}

gfUnion2Flow(acc : GTypeAcc, f : GfTypeUnion) -> string {
	typenames = filtermap(f.subtypes, \type : GfType -> {
		typename = gfType2Flow(acc, type);
		prefix = strLeft(typename, strlen(acc.prefix));
		if (prefix != acc.prefix) {
			println("Union " + f.name + " requires named type, not " + toString(type));
		}
		if (typename == f.name) None() else Some(typename)
	});

	f.name + " ::= " + strGlue(uniq(typenames), ", ") + ";\n";
}

gfStruct2Flow(acc : GTypeAcc, colon : bool, s : GfTypeStruct) -> string {
	nameCounts = fold(s.args, makeTree(), \acc2, arg -> {
		incTreeValue(acc2, arg.first);
	});

	// Find out what the fields should be baned
	rename = fold2(s.args, [], makeTree(), \acc2, counts, arg -> {
		count = lookupTreeDef(counts, arg.first, 0);
		ncount = setTree(counts, arg.first, count + 1);
		name = if (count == 0 && lookupTreeDef(nameCounts, arg.first, 0) == 1) {
			arg.first
		} else {
			arg.first + i2s(count + 1);
		};
		rname = if (name == "bool") "b"
			else if (name == "int") "i"
			else if (name == "double") "d"
			else if (name == "string") "s"
			else name;
		cname = if (isUpperLetter(getCharAt(rname, 0))) toLowerCase(rname) else rname;
		Pair(arrayPush(acc2, cname), ncount)
	}).first;

	s.name + (if (colon) " : " else "") + "(" + supergluei(s.args, \i, arg -> {
		rename[i] + " : " + gfType2Flow(acc, arg.second)
	}, ", ") + ");\n";
}

gfType2Flow(acc : GTypeAcc, t : GfType) -> string {
	switch (t) {
		GTypeBool(): "bool";
		GTypeInt(): "int"
		GTypeDouble(): "double";
		GTypeString(): "string";
		GfTypeArray(tt): "[" + gfType2Flow(acc, tt) + "]";
		GfTypeName(f, name): {
			if (containsKeyTree(acc.unions, name)) name
			else if (containsKeyTree(acc.structs, name)) name
			else {
				// OK, we simplify this
				named = lookupTree(acc.named, f);
				switch (named) {
					None(): {
						println("Unknown result: " + name);
						name;
					}
					Some(tt): {
						gfType2Flow(acc, tt);
					}
				}
			}
		}
	}
}

produceMelonTypes(file : string, tacc : GTypeAcc, unions : Tree<string, GfTypeUnion>, structs : Tree<string, GfTypeStruct>) -> void {
	res = foldTree(unions, "", \un, tu, acc -> {
		acc + un + " ::=\n\t" + superglue(tu.subtypes, \st -> {
			switch (st) {
				GfTypeName(f, struct): {
					mstdef = lookupTree(structs, struct);
					mstdef ?? {
						ft = gfStruct2Flow(tacc, false, mstdef);
						strsubsmart(ft, 0, -2);
					} : {
						// A union
						struct + "()";
					}
				}
				default: toString(st);
			}
		}, ",\n\t") + ";\n\n";
	});

	usedStructs = foldTree(unions, makeSet(), \un, ud, acc -> {
		fold(ud.subtypes, acc, \acc2, tu -> {
			switch (tu) {
				GfTypeName(f, struct): insertSet(acc2, struct);
				default: acc2;
			}
		})
	});

	res2 = foldTree(structs, res, \st, std, acc -> {
		if (containsSet(usedStructs, st)) acc
		else {
			ft = gfStruct2Flow(tacc, true, std);
			acc + ft;
		}
	});

	// println(res);

	setFileContent(file, res2);
	{}
}
