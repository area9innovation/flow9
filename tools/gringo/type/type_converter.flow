import tools/gringo/type/types;
import ds/tree;
import text/blueprint;
import string_utils;
import net/url_parameter;

export {
	// Will construct a flow file with conversion from and to DslAst
	makeGfTypeConverter(
		typePath : string,
		masterType : string,
		prefix : string,
		unions : Tree<string, GfTypeUnion>,
		structs : Tree<string, GfTypeStruct>,
	) -> void;
}

makeGfTypeConverter(
	typePath : string,
	masterType : string,
	prefix : string,
	unions : Tree<string, GfTypeUnion>,
	structs : Tree<string, GfTypeStruct>,
) -> void {
	filename = typePath + "2dsl.flow";

	named = concat(getTreeKeys(unions), getTreeKeys(structs));
	if (contains(named, masterType)) {
		println("WARNING: Master type name: " + masterType + " is already used in AST type names");
	}

	result = blueprint(<<
		// Generated by Gringo
		import %typepath%;
		import runtime;
		import tools/dsl/dsl_util;

		export {
			%lt%2DslAst(w : %t%) -> DslAst;
			dslAst2%t%(d : DslAst) -> %t%;
			%typed%
		}

		%lt%2DslAst(wal : %t%) -> DslAst {
			switch (wal) {
				%t%Bool(value): DslBool(value);
				%t%Int(value): DslInt(value);
				%t%Double(value): DslDouble(value);
				%t%String(value): DslString(value);
				%t%List(value): DslList(mapList(value, %lt%2DslAst));
				%from%
			}
		}

		dslAst2%t%(d : DslAst) -> %t% {
			switch (d) {
				DslBool(value): %t%Bool(value);
				DslInt(value): %t%Int(value);
				DslDouble(value): %t%Double(value);
				DslString(value): %t%String(value);
				DslList(value): %t%List(mapList(value, dslAst2%t%));
				DslNode(name, args, pos): {
					%to%
				}
			}
		}

		%dsl2s%
	>>, [
		"typepath", typePath,
		"t", masterType,
		"lt", decapitalize(masterType),
		"from", makeGfFromConverter(masterType, prefix, decapitalize(masterType) + "2DslAst", structs),
		"typed", superglue(named, \name -> "dslAst2" + name + "(d : DslAst) -> " + name + ";", "\n"),
		"to", makeGfStructs2Dsl(masterType, prefix, masterType + "Bool(false)", structs),
		"dsl2s", makeGf2Converters(masterType, prefix, unions, structs),
	]);
	setFileContent(filename, result);
	{}
}


// Make a converter from the mastertype to the DSL
makeGfFromConverter(masterType : string, prefix : string, converter : string, structs : Tree<string, GfTypeStruct>) -> string {
	foldTree(structs, "", \st, stdef1, acc -> {
		// Skip the eclass when going back to DSL
		sargs = if (isUrlParameterTrue("eclasses")) subrange(stdef1.args, 0, length(stdef1.args) - 1) else stdef1.args;
		acc + st + "(" + supergluei(stdef1.args, \i, arg -> "a" + i2s(i), ", ") + "): "
		+ "DslNode("
		+ toString(snakeCase(decapitalize(strRight(st, strlen(prefix))))) + ", "
		+ "[" + supergluei(sargs, \i, arg -> {
			argType = arg.second;
			argName = "a" + i2s(i);
			makeGfFromGTypeConverter(converter, argName, argType)
		}, ", ") + "], 0);\n"
	});
}

makeGfFromGTypeConverter(converter : string, argName : string, type : GfType) -> string {
	switch (type) {
		GTypeBool(): "DslBool(" + argName + ")";
		GTypeInt(): "DslInt(" + argName + ")";
		GTypeDouble(): "DslDouble(" + argName + ")";
		GTypeString(): "DslString(" + argName + ")";
		GfTypeArray(t): {
			"DslList(fold(" + argName + ", makeList(), \\acc, e -> Cons(" + makeGfFromGTypeConverter(converter, "e", t) + ", acc)))";
		}
		GfTypeName(fieldName, typename): converter + "(" + argName + ")";
	}
}

// Constructs a converter from DSL to masterType with the given structs inside
makeGfStructs2Dsl(masterType : string, prefix : string, def : string, structs : Tree<string, GfTypeStruct>) -> string {
	foldTree(structs, "", \st, stdef, acc -> {
		sargs = if (isUrlParameterTrue("eclasses")) subrange(stdef.args, 0, length(stdef.args) - 1) else stdef.args;
		args = supergluei(sargs, \i, sa -> {
			makeGfType2Dsl(sa.second) + "(args[" + i2s(i) + "])";
		}, ", ")
			+ (if (isUrlParameterTrue("eclasses")) {if (sargs == []) "0" else ", 0"} else "")
		;
		acc + blueprint(<< 
			if (name == %nodename%) {
				%typename%(%args%)
			} else >>, [
			"t", masterType,
			"typename", st,
			"nodename", toString(snakeCase(decapitalize(strRight(st, strlen(prefix))))),
			"args", args,
		])
	}) + "{ println(\"ERROR: Could not convert \" + name + \" in " + masterType + "\"); " + def + " }\n";
}

makeGfType2Dsl(t : GfType) -> string {
	switch (t) {
		GTypeBool(): "getDslBool";
		GTypeInt(): "getDslInt";
		GTypeDouble(): "getDslDouble";
		GTypeString(): "getDslString";
		GfTypeArray(tt): "(\\t -> map(list2array(getDslList(t)), " + makeGfType2Dsl(tt) + "))";
		GfTypeName(fieldName, typename): "dslAst2" + typename;
	}
}

makeGf2Converters(masterType : string, prefix : string, unions : Tree<string, GfTypeUnion>, structs : Tree<string, GfTypeStruct>) {
	foldTree(unions, "", \un, def : GfTypeUnion, acc -> {
		acc + makeGfUnion2Converters(masterType, prefix, unions, structs, def)
	})
	+ foldTree(structs, "", \st, def : GfTypeStruct, acc -> {
		acc + makeGfTypeName2Converters(masterType, prefix, unions, structs, GfTypeName(st, st))
	});
}

makeGfUnion2Converters(masterType : string, prefix : string, unions : Tree<string, GfTypeUnion>, structs : Tree<string, GfTypeStruct>, union : GfTypeUnion) -> string {
	un = union.name;
	ustructs : [GfTypeStruct] = concatA(map(union.subtypes, \st -> {
		expandGfType2Structs(unions, structs, st)
	}));
	to = makeGfStructs2Dsl(un, prefix, 
		makeDefaultGfTypeNameValue(unions, structs, GfTypeName(un, un)),
		fold(ustructs, makeTree(), \acc2, s -> setTree(acc2, s.name, s))
	);
		
	blueprint(<<
		dslAst2%t%(d : DslAst) -> %t% {
			node = getDslNode(d);
			name = node.name;
			args = node.args;
			%to%
		}
	>>, [
		"t", un,
		"to", to
	])
}

expandGfType2Structs(unions : Tree<string, GfTypeUnion>, structs : Tree<string, GfTypeStruct>, st : GfType) -> [GfTypeStruct] {
	switch (st) {
		GfTypeName(fieldName, name): {
			mstruct = lookupTree(structs, name);
			mstruct ?? {
				[mstruct]
			} : {
				// OK, maybe it is a union
				munion = lookupTree(unions, name);
				switch (munion) {
					None(): {
						println("Unknown type name " + name);
						[];
					}
					Some(undef): {
						concatA(map(undef.subtypes, \s -> {
							expandGfType2Structs(unions, structs, s)
						}))
					}
				}
			}
		}
		default: [];
	}
}

makeGfType2Converters(masterType : string, prefix : string, unions : Tree<string, GfTypeUnion>, structs : Tree<string, GfTypeStruct>, type : GfType) -> string {
	switch (type) {
		GfTypeName(__, __): makeGfTypeName2Converters(masterType, prefix, unions, structs, type);
		default: {
			"// TODO " + toString(type) + "\n";
		}
	}
}

makeGfTypeName2Converters(masterType : string, prefix : string, unions : Tree<string, GfTypeUnion>, structs : Tree<string, GfTypeStruct>, typename : GfTypeName) -> string {
	mstruct = lookupTree(structs, typename.typename);
	mstruct ?? {
		if (mstruct.args == []) {
			blueprint(<<
				dslAst2%t%(d : DslAst) -> %t% {
					%t%()
				}
			>>, [
				"t", typename.typename,
			])
		} else {
			sargs = if (isUrlParameterTrue("eclasses")) subrange(mstruct.args, 0, length(mstruct.args) - 1) else mstruct.args;
			args = supergluei(sargs, \i, sa -> {
				makeGfType2Dsl(sa.second) + "(args[" + i2s(i) + "])";
			}, ", ") + (if (isUrlParameterTrue("eclasses")) {if (sargs == []) "0" else ", 0"} else "");

			blueprint(<<
				dslAst2%t%(d : DslAst) -> %t% {
					node = getDslNode(d);
					args = node.args;
					%t%(%args%)
				}
			>>, [
				"t", typename.typename,
				"args", args,
			])

		}

	} : {
		munion = lookupTree(unions, typename.typename);
		"// TODO " + toString(typename) + "\n";
	}
}

makeDefaultGfTypeValue(
	unions : Tree<string, GfTypeUnion>,
	structs : Tree<string, GfTypeStruct>, t : GfType) -> string {
	switch (t) {
		GTypeBool(): "false";
		GTypeInt(): "0";
		GTypeDouble(): "0.0";
		GTypeString(): "\"\"";
		GfTypeArray(tt): "[]";
		GfTypeName(fieldName, typename): {
			mstruct = lookupTree(structs, typename);
			mstruct ?? {
				mstruct.name + "(" + superglue(mstruct.args, \p -> {
					rec = \ -> makeDefaultGfTypeValue(unions, structs, p.second);
					switch (p.second) {
						GfTypeName(n, tn): {
							if (tn != typename) rec() else {
								println("cyclic struct: " + typename + "(" + superglue(mstruct.args, toString, ", ") + ")");
								"cyclic struct: " + typename;
							}
						}
						default: rec();
					}
				}, ", ") + ")"
			} : {
				munion = lookupTree(unions, typename);
				switch (munion) {
					None(): "UNKNOWN " + typename;
					Some(u): {
						cheapest = findGfTypeNameComplexity(ref makeSet(), unions, structs, t).second;
						if (cheapest == t) {
							println("endless recursion:\ncheapest == t:\n" + toString(cheapest) + "\n == \n" + toString(t));
							"cyclic union default value: " + typename;
						} else {
							makeDefaultGfTypeValue(unions, structs, cheapest)
						}
					}
				}
			}
		}
	}
}

makeDefaultGfTypeStructValue(
	unions : Tree<string, GfTypeUnion>,
	structs : Tree<string, GfTypeStruct>, struct : GfTypeStruct) -> string {
	struct.name + "(" + superglue(struct.args, \p -> {
		makeDefaultGfTypeValue(unions, structs, p.second)
	}, ", ") + ")"
}

makeDefaultGfTypeNameValue(
	unions : Tree<string, GfTypeUnion>,
	structs : Tree<string, GfTypeStruct>, tn : GfTypeName) -> string {
	cheapest = findGfTypeNameComplexity(ref makeSet(), unions, structs, tn);
	makeDefaultGfTypeValue(unions, structs, cheapest.second)
}

findGfTypeNameComplexity(seen : ref Set<GfType>, unions : Tree<string, GfTypeUnion>, structs : Tree<string, GfTypeStruct>, type : GfTypeName) -> Pair<int, GfTypeName> {
	if (containsSet(^seen, type)) {
		Pair(100000, type)
	} else {
		seen := insertSet(^seen, type);
		mstruct = lookupTree(structs, type.typename);
		mstruct ?? {
			Pair(
				fold(mstruct.args, 0, \acc, arg -> {
					c = findGfTypeComplexity(seen, unions, structs, arg.second);
					acc + c.first;
				}),
				type
			);
		} : {
			munion = lookupTree(unions, type.typename);
			switch (munion) {
				None(): Pair(100, type);
				Some(undef): {
					fold(undef.subtypes, Pair(1000000, type), \acc, st : GfType -> {
						switch (st) {
							GfTypeName(__, __): {
								c = findGfTypeNameComplexity(seen, unions, structs, st);
								if (c.first < acc.first) c else acc
							}
							default: acc;
						}
					})
				}
			}
		}
	}
}

findGfTypeComplexity(seen : ref Set<GfType>, unions : Tree<string, GfTypeUnion>, structs : Tree<string, GfTypeStruct>, type : GfType) -> Pair<int, GfType> {
	switch (type) {
		GTypeBool(): Pair(0, type);
		GTypeInt(): Pair(0, type);
		GTypeDouble(): Pair(0, type);
		GTypeString(): Pair(1, type);
		GfTypeArray(t): Pair(0, type);
		GfTypeName(fieldName, typename): {
			findGfTypeNameComplexity(seen, unions, structs, type);
		}
	}
}
