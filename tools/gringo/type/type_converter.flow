import tools/gringo/type/types;
import ds/tree;
import text/blueprint;
import string_utils;

export {
	// Will construct a flow file with conversion from and to DslAst
	makeGfTypeConverter(
		typePath : string,
		masterType : string,
		prefix : string,
		unions : Tree<string, GfTypeUnion>,
		structs : Tree<string, GfTypeStruct>,
	) -> void;
}

makeGfTypeConverter(
	typePath : string,
	masterType : string,
	prefix : string,
	unions : Tree<string, GfTypeUnion>,
	structs : Tree<string, GfTypeStruct>,
) -> void {
	filename = typePath + "2dsl.flow";
	result = blueprint(<<
		import %typepath%;
		import runtime;
		import tools/dsl/dsl_util;

		export {
			// %lt%2DslAst(w : %t%) -> DslAst;
			dslAst2%t%(d : DslAst) -> %t%;
		}

		/* %lt%2DslAst(w : %t%) -> DslAst {
			DslBool(false);
		}
		*/

		dslAst2%t%(d : DslAst) -> %t% {
			switch (d) {
				DslBool(value): %t%Bool(value);
				DslInt(value): %t%Int(value);
				DslDouble(value): %t%Double(value);
				DslString(value): %t%String(value);
				DslList(value): %t%List(mapList(value, dslAst2%t%));
				DslNode(name, args, pos): {
					%to%
				}
			}
		}

		%dsl2s%
	>>, [
		"typepath", typePath,
		"t", masterType,
		"lt", decapitalize(masterType),
		"to", makeGfStructs2Dsl(masterType, prefix, masterType + "Bool(false)", structs),
		"dsl2s", makeGf2Converters(masterType, prefix, unions, structs),
	]);
	setFileContent(filename, result);
	{}
}

// Constructs a converter from DSL to masterType with the given structs inside
makeGfStructs2Dsl(masterType : string, prefix : string, def : string, structs : Tree<string, GfTypeStruct>) -> string {
	foldTree(structs, "", \st, stdef, acc -> {
		args = supergluei(stdef.args, \i, sa -> {
			makeGfType2Dsl(sa.second) + "(args[" + i2s(i) + "])";
		}, ", ");
		acc + blueprint(<< 
			if (name == %nodename%) {
				%typename%(%args%)
			} else >>, [
			"t", masterType,
			"typename", st,
			"nodename", toString(snakeCase(decapitalize(strRight(st, strlen(prefix))))),
			"args", args,
		])
	}) + "{ println(\"ERROR: Could not convert \" + name + \" in " + masterType + "\"); " + def + " }\n";
}

makeGfType2Dsl(t : GfType) -> string {
	switch (t) {
		GTypeBool(): "getDslBool";
		GTypeInt(): "getDslInt";
		GTypeDouble(): "getDslDouble";
		GTypeString(): "getDslString";
		GfTypeArray(tt): "(\\t -> map(list2array(getDslList(t)), " + makeGfType2Dsl(tt) + "))";
		GfTypeName(fieldName, typename): "dslAst2" + typename;
	}
}

makeGf2Converters(masterType : string, prefix : string, unions : Tree<string, GfTypeUnion>, structs : Tree<string, GfTypeStruct>) {
	foldTree(unions, "", \un, def : GfTypeUnion, acc -> {
		acc + makeGfUnion2Converters(masterType, prefix, unions, structs, def)
	})
	+ foldTree(structs, "", \st, def : GfTypeStruct, acc -> {
		acc + makeGfTypeName2Converters(masterType, prefix, unions, structs, GfTypeName(st, st))
	});
}

makeGfUnion2Converters(masterType : string, prefix : string, unions : Tree<string, GfTypeUnion>, structs : Tree<string, GfTypeStruct>, union : GfTypeUnion) -> string {
	un = union.name;
	ustructs : [GfTypeStruct] = concatA(map(union.subtypes, \st -> {
		expandGfType2Structs(unions, structs, st)
	}));
	to = makeGfStructs2Dsl(un, prefix, 
		makeDefaultGfTypeNameValue(unions, structs, GfTypeName(un, un)),
		fold(ustructs, makeTree(), \acc2, s -> setTree(acc2, s.name, s))
	);
		
	blueprint(<<
		dslAst2%t%(d : DslAst) -> %t% {
			node = getDslNode(d);
			name = node.name;
			args = node.args;
			%to%
		}
	>>, [
		"t", un,
		"to", to
	])
}

expandGfType2Structs(unions : Tree<string, GfTypeUnion>, structs : Tree<string, GfTypeStruct>, st : GfType) -> [GfTypeStruct] {
	switch (st) {
		GfTypeName(fieldName, name): {
			mstruct = lookupTree(structs, name);
			mstruct ?? {
				[mstruct]
			} : {
				// OK, maybe it is a union
				munion = lookupTree(unions, name);
				switch (munion) {
					None(): {
						println("Unknown type name " + name);
						[];
					}
					Some(undef): {
						concatA(map(undef.subtypes, \s -> {
							expandGfType2Structs(unions, structs, s)
						}))
					}
				}
			}
		}
		default: [];
	}
}

makeGfType2Converters(masterType : string, prefix : string, unions : Tree<string, GfTypeUnion>, structs : Tree<string, GfTypeStruct>, type : GfType) -> string {
	switch (type) {
		GfTypeName(__, __): makeGfTypeName2Converters(masterType, prefix, unions, structs, type);
		default: {
			"// TODO " + toString(type) + "\n";
		}
	}
}

makeGfTypeName2Converters(masterType : string, prefix : string, unions : Tree<string, GfTypeUnion>, structs : Tree<string, GfTypeStruct>, typename : GfTypeName) -> string {
	mstruct = lookupTree(structs, typename.typename);
	mstruct ?? {
		if (mstruct.args == []) {
			blueprint(<<
				dslAst2%t%(d : DslAst) -> %t% {
					%t%()
				}
			>>, [
				"t", typename.typename,
			])
		} else {
			args = supergluei(mstruct.args, \i, sa -> {
				makeGfType2Dsl(sa.second) + "(args[" + i2s(i) + "])";
			}, ", ");

			blueprint(<<
				dslAst2%t%(d : DslAst) -> %t% {
					node = getDslNode(d);
					args = node.args;
					%t%(%args%)
				}
			>>, [
				"t", typename.typename,
				"args", args,
			])

		}

	} : {
		munion = lookupTree(unions, typename.typename);
		"// TODO " + toString(typename) + "\n";
	}
}

makeDefaultGfTypeValue(
	unions : Tree<string, GfTypeUnion>,
	structs : Tree<string, GfTypeStruct>, t : GfType) -> string {
	switch (t) {
		GTypeBool(): "false";
		GTypeInt(): "0";
		GTypeDouble(): "0.0";
		GTypeString(): "\"\"";
		GfTypeArray(tt): "[]";
		GfTypeName(fieldName, typename): {
			mstruct = lookupTree(structs, typename);
			mstruct ?? {
				mstruct.name + "(" + superglue(mstruct.args, \p -> {
					makeDefaultGfTypeValue(unions, structs, p.second)
				}, ", ") + ")"
			} : {
				munion = lookupTree(unions, typename);
				switch (munion) {
					None(): "UNKNOWN " + typename;
					Some(u): makeDefaultGfTypeNameValue(unions, structs, t);
				}
			}
		}
	}
}

makeDefaultGfTypeStructValue(
	unions : Tree<string, GfTypeUnion>,
	structs : Tree<string, GfTypeStruct>, struct : GfTypeStruct) -> string {
	struct.name + "(" + superglue(struct.args, \p -> {
		makeDefaultGfTypeValue(unions, structs, p.second)
	}, ", ") + ")"
}

makeDefaultGfTypeNameValue(
	unions : Tree<string, GfTypeUnion>,
	structs : Tree<string, GfTypeStruct>, tn : GfTypeName) -> string {
	cheapest = findGfTypeNameComplexity(ref makeSet(), unions, structs, tn);
	makeDefaultGfTypeValue(unions, structs, cheapest.second)
}

findGfTypeNameComplexity(seen : ref Set<GfType>, unions : Tree<string, GfTypeUnion>, structs : Tree<string, GfTypeStruct>, type : GfTypeName) -> Pair<int, GfTypeName> {
	if (containsSet(^seen, type)) {
		Pair(100000, type)
	} else {
		seen := insertSet(^seen, type);
		mstruct = lookupTree(structs, type.typename);
		mstruct ?? {
			Pair(
				fold(mstruct.args, 0, \acc, arg -> {
					c = findGfTypeComplexity(seen, unions, structs, arg.second);
					acc + c.first;
				}),
				type
			);
		} : {
			munion = lookupTree(unions, type.typename);
			switch (munion) {
				None(): Pair(100, type);
				Some(undef): {
					fold(undef.subtypes, Pair(1000000, type), \acc, st : GfType -> {
						switch (st) {
							GfTypeName(__, __): {
								c = findGfTypeNameComplexity(seen, unions, structs, st);
								if (c.first < acc.first) c else acc
							}
							default: acc;
						}
					})
				}
			}
		}
	}
}

findGfTypeComplexity(seen : ref Set<GfType>, unions : Tree<string, GfTypeUnion>, structs : Tree<string, GfTypeStruct>, type : GfType) -> Pair<int, GfType> {
	switch (type) {
		GTypeBool(): Pair(0, type);
		GTypeInt(): Pair(0, type);
		GTypeDouble(): Pair(0, type);
		GTypeString(): Pair(1, type);
		GfTypeArray(t): Pair(0, type);
		GfTypeName(fieldName, typename): {
			findGfTypeNameComplexity(seen, unions, structs, type);
		}
	}
}
