import gringo/gringo_action;
import gringo/gringo_ast;
import ds/list;
import math/math;

export {
	gringoAstAction = GringoAction(
		\acc : GringoAstAcc, v -> {
			if (v == "GRule") {
				// GRule(id : string, term : GTerm, body : GTerm);
				pbody = popAstStack(acc);
				pterm = popAstStack(pbody.second);
				pid = popAstStack(pterm.second);
				rule = GRule(gtermAsString(pid.first), pterm.first, pbody.first);
				pushAstStack(pid.second, rule);
			} else if (v == "GSeq") {
				// GSeq(left : GTerm, right : GTerm);
				pright = popAstStack(acc);
				pleft = popAstStack(pright.second);
				seq = GSeq(pleft.first, pright.first);
				pushAstStack(pleft.second, seq);
			} else if (v == "GPrecedence") {
				// GPrecedence(left : GTerm, right : GTerm);
				pright = popAstStack(acc);
				pleft = popAstStack(pright.second);
				choice = GPrecedence(pleft.first, pright.first);
				pushAstStack(pleft.second, choice);
			} else if (v == "GChoice") {
				// GChoice(left : GTerm, right : GTerm);
				pright = popAstStack(acc);
				pleft = popAstStack(pright.second);
				choice = GChoice(pleft.first, pright.first);
				pushAstStack(pleft.second, choice);
			} else if (v == "GUnquote") {
				// GUnquote(term : GTerm);
				pterm = popAstStack(acc);
				unquote = GUnquote(pterm.first);
				pushAstStack(pterm.second, unquote);
			} else if (v == "GStar") {
				// GStar(term : GTerm);
				pterm = popAstStack(acc);
				unquote = GStar(pterm.first);
				pushAstStack(pterm.second, unquote);
			} else if (v == "GPlus") {
				// GPlus(term : GTerm);
				pterm = popAstStack(acc);
				unquote = GPlus(pterm.first);
				pushAstStack(pterm.second, unquote);
			} else if (v == "GNegate") {
				// GNegate(term : GTerm);
				pterm = popAstStack(acc);
				unquote = GNegate(pterm.first);
				pushAstStack(pterm.second, unquote);
			} else if (v == "GError") {
				// GError(term : GTerm);
				pterm = popAstStack(acc);
				unquote = GError(pterm.first);
				pushAstStack(pterm.second, unquote);
			} else if (v == "GLower") {
				// GLower(term : GTerm);
				pterm = popAstStack(acc);
				unquote = GLower(pterm.first);
				pushAstStack(pterm.second, unquote);
			} else if (v == "GOpt") {
				// GOpt(term : GTerm);
				pterm = popAstStack(acc);
				unquote = GOpt(pterm.first);
				pushAstStack(pterm.second, unquote);
			} else if (v == "GVar") {
				// GVar(id : string);
				pid = popAstStack(acc);
				var = GVar(gtermAsString(pid.first));
				pushAstStack(pid.second, var);
			} else if (v == "GString") {
				// GString(text : string);
				pstring = popAstStack(acc);
				str = GString(gtermAsString(pstring.first));
				pushAstStack(pstring.second, str);
			} else if (v == "GRange") {
				// GRange(lower : int, upper : int);
				pupper = popAstStack(acc);
				plower = popAstStack(pupper.second);
				chfn = \s -> if (startsWith(s, "0x")) parseHex(s) else getCharCodeAt(s, 0);
				str = GRange(
					chfn(gtermAsString(plower.first)), 
					chfn(gtermAsString(pupper.first))
				);
				pushAstStack(plower.second, str);
			} else {
				println("TODO: Handle "+ v);
				acc;
			}
		},
		\acc : GringoAstAcc, m -> {
			pushAstStack(acc, GString(m));
		}
	);

	getAstResult(s : GringoAstAcc) -> GTerm;

	GringoAstAcc(
		stack : List<GTerm>,
	);

	pushAstStack(a : GringoAstAcc, e : GTerm) -> GringoAstAcc;
	popAstStack(a : GringoAstAcc) -> Pair<GTerm, GringoAstAcc>;
}

pushAstStack(a : GringoAstAcc, e : GTerm) -> GringoAstAcc {
	GringoAstAcc(
		a with stack = Cons(e, a.stack),
	);
}

popAstStack(a : GringoAstAcc) -> Pair<GTerm, GringoAstAcc> {
	switch (a.stack) {
		EmptyList(): {
			println("Stack underflow");
			Pair(GEpsilon(), a);
		}
		Cons(head, tailL): {
			Pair(head, GringoAstAcc(a with stack = tailL))
		}
	}
}

getAstResult(s : GringoAstAcc) -> GTerm {
	switch (s.stack) {
		EmptyList(): {
			println("Stack underflow");
			GEpsilon()
		}
		Cons(head, tailL): {
			head;
		}
	}
}

gtermAsString(g : GTerm) -> string {
	switch (g) {
		GString(s): s;
		default: {
			println("Expected string");
			"";
		}
	}
}
