# Experiment to bootstrap Gringo with Gringo

This is a test bed for how to get Gringo bootstrapped using
Gringo and the DSL infrastructure in the best possible way.

TODO:
- Finish interpreter

# Interpreter

To get to robust parsing with an interpreter, we need these this:

- Expand precedence

   	   e = e tail e |> rest;

   is converted to

		e = e1 tail e1 | e1;
		e1 = rest;

  and after this, there are no more precedence clauses

  We also replace recursion with the expanded names according to somewhat
  tricky rules. left and right recursion is special in this regard.

- Reduce common (optimization)
  -  Builds a dependency graph of the rules, and replaces common subexpressions
     in a loop-free version of the graph starting from the leaves
  -  Does dead-code elimination from the dependency graph as well, including 
     identity rules

- Common prefix. Rewrites

	e = pr tail1 | pr tail2 | rest
		=>
	e = pr (tail1 | tail2) | rest
 
- Right associate gterms

	// Turns ((a | b) | c)  into (a | (b | c))
  
- Rewrite left recursion. Rewrites

	e1 = e1 tail | rest
	== GRule(e1, GChoice(GSeq(GVar(rule), tail), rest))

	-> 

	e1 = rest tail*;
	== GRule(e1, GSeq(rest, GStar(tail)))

- Reduce common (optimization)

- Optimize (optimization)
  - <epsilon> | right   => right?
  - left | <epsilon>    => left?
  - term | term  		=> term
  - <epsilon> term   => term
  - term <epsilon>   => term
  - "st" "ring"  	 => "string"
  - term*?           => term*
  - term??           => term?
  - l-l   => "l"

TODO:
Add a choice reordering phase.
If the prefixes between two choices do not overlap,
then we can reorder them. Use this to optimize the
grammar and get more common prefixes exposed.

## Summary Interpretation

The tricky part is reducing the precedence.
Next tricky bit is CSE, respecting dependencies, as
well as DCE.
The rest is term rewriting.
Evaluation is relatively simple.

# Compilation

Converts terms to opcodes:
	Lambda like:

	function(name : string, code : DOpCode, body : DOpCode);
		fun name() {
			code; 
		} 
		body

	true, false
	string
	if(cond, then, else)
	sequence(opcodes)
	call(id)
	and(left, right)
	or(left, right)

	Push checkpoint
	Discard checkpoint
	Restore Checkpoint

	DParseStar(term)
	DAddError(error : string)
	CaptureI() - capture the current position
	Matched() - The string from current position to the captured
	Position() - push the current position as a string 

	MatchString(string)
	matchrange(low, up)

# AST representations

Strongly typed, specific generated by Gringo
  Cons: Not as reusable
DslAST, generic runtime-type for DSL system
  Cons: Does not scale to big complexity

Egraph:
  Cons: Does not exist

Rewrite DSLs

TODO:
- Egraph in memory database. Write in imperative language
    - Term rewriting
	- Rel algebra
	- List comprehensions
	- Wise
	- Flow
	- Datalog

Exp =
	Add(left : Exp, right : Exp)
	Int(value : int)

1 + 2 + 3 
= Add(Add(Int(1), Int(2)), Int(3))
= DslNode(....)

Programmet = 5

Add-table
4, 1, 2
5, 4, 3 
7, 2, 1

Int-table
1, int 1
2, int 2
3, int 3
6, int 6

E-classes
4, 3
5, 6
4, 7

Types
10 int
11 double
12 [int]

Filename

Position
1 int, ref to filename

C-syntax
<n>, "1+2"

select from add where left is int and right is int, insert sum as int and equivalence class

1 + ......... -1

Add a + b -> Add b + a
Add (Add a b), c  -> Add (a, Add(b, c))


Term rewriting AST syntax:
	Add(a, b) -> Add(b, a)

relalg
	[ 2 * x | x in 1..10 ]
	[ Add(e.b, e.a) | e in Add ]

datalog

flow/wise

# Convert type to database

