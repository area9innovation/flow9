import tools/gringo/pflow/parse;
import tools/gringo/pflow/interpreter;
import tools/gringo/pflow/typechecker;
import tools/gringo/pflow/prettyprint;

main() {
	code = "#include tools/gringo/pflow/tests/fact.flow";

	e : PExp = parsePFlow(code);

	tenv = makeTypeEnv();
	t0 : TExp = convertPExp2TExp(tenv, e);
	t1 : TType = typecheckTExp(tenv, t0);

	if (false) {
		println("Equivalence class");
		generate(0, ^(tenv.unique), \tv -> {
			root = findUnionMapRoot(tenv.unionFindMap, tv);
			println("Root of " + i2s(tv) + " is " + i2s(root) + " with " + prettyTType(tenv, TTypeVar(tv)));
		});
		{}
	}

	rt : TExp = resolveTExp(tenv, t0);
	println(prettyTExp(tenv, rt));
/*
	value = interpretPExp(makeTree(), e);

	println(value);*/
	quit(0);
}
