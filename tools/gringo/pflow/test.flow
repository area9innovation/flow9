import text/gringo/gringo_interpreter;
import tools/gringo/pflow/pexp;
import tools/gringo/pflow/values;
import text/deserialize_string;

main() {
	grammar = prepareGringoParser("#include tools/gringo/pflow/pexp.gringo", println);
	// println(gterm2string(grammar));
	
	code = "#include tools/gringo/pflow/fact.flow";

	actions : GringoAction<List<PExp>> = gringoTypedAction(
		\s -> PString(s),
		\e -> switch (e) {
			PString(s): s;
			default: "";
		},
		\b -> PBool(b),
		\i : string -> PInt(s2i(i)),
		\d : string -> PString(d),
		\ -> PArray([]),
		\e : PExp, l -> {
			switch (l) {
				PArray(es): PArray(arrayPush(es, e));
				default: e;
			}
		},
		expOps(),
	);

	e : PExp = gringoParseWithActionCheck(code, 
		expOps(),
		actions,
		grammar,
		PBool(false),
		println
	);

	println(e);
	quit(0);
}


expOps() -> GringoTypedOperators {
	un = \op -> {
		Pair(op, \a : PExp -> PCall(PVar(op), [a]))
	};
	bin = \op -> {
		Pair(op, \a : PExp, b : PExp -> PCall(PVar(op), [a, b]))
	};
	GringoTypedOperators(
		makeTree(),
		// Unary
		pairs2tree([
			Pair("unescape", \s : PExp -> {
				PString(deserializeString(getPString(s)).first)
			}),
			Pair("var", \id -> PVar(getPString(id))),
			un("negate"),
			un("not"),
			Pair("sequence", \ss -> {
				PSequence(getPArray(ss))
			})
		]),
		// Binary
		pairs2tree([
			Pair("call", \fn, args -> {
				PCall(fn, getPArray(args))
			}),
			Pair("lambda", \args, body -> {
				PLambda(map(getPArray(args), getPString), body)
			}),
			bin("||"), bin("&&"),
			bin("=="), bin("!="), bin("<="), bin("<"), bin(">="), bin(">"),
			bin("+"), bin("-"), bin("*"), bin("/"), bin("%"),
		]),
		// Ternary
		pairs2tree([
			Pair("let", \id, val, body -> {
				PLet(getPString(id), val, body)
			}),
			Pair("if", \c, t, e -> {
				PIf(c, t, e)
			}),
		]),
		makeTree(),
		// Stack ops
		makeTree(),
	);
}
