import tools/flow9/backends/bprogram;
import tools/flow9/bexp/type;
import tools/flow9/backends/cpp/cpp_backend;
import sys/concurrent;

// Known issues:
//
// 1) IF
// if the branch doesn't contain a terminal variable, we'll drop it, but it would be ideal if we could predict the branch and drop the variable early.
// Example :
//  1: fn(c : bool, b : int) -> int {
//  2:   var = b * 10;
//  3:   d = if (c) var + 1 else b;
//  4:   return d;
//  5: }
// we'll free _var_ on line 3. but if c is false, it would be greate to free _var_ on line 2;
//
// 2) Dangling variables
// Example :
//  1: fn(b : int) -> int {
//  2:   var = b * 10;
//  3:   d = b;
//  4:   var; // dangling variable
//  5:   return d;
//  6: }
// we'll free _var_ on line 4. but it would be greate to free _var_ on line 2;
//
// 3) Dangling arguments
// Example :
//  1: c = "long_string";
//  2: a = 2;
//  3: b = a + 1;
//  4: fn(c, 10);
//  01: fn(c : string, b : int) -> int {
//  02:   println("fn");
//  03:   return b;
//  04: }
// we'll free _c_ on line 4 (02). but it would be greate to free _c_ on line 1;


// TODO:
// 1) condition
// Example : 
//   1: if (fn1() > 1 || fn2(1)) {
//   2: 	println("yes")
//   3: } else {
//   4: 	println("no")
//   5: }
// we'll free the memory for the result of fn1() on line 2 or 4. but we have to free on line 1 after || .
// take lazy comparison into account (&&, ||). example : c = Struct(-1); if (c.i > 0 && c.i < 10) ...
//
// 2) unused result of functions
// Example :
// 01: SomeStruct makeStruct();
// ...
// 1: a = 1;
// 2: makeStruct();
// 3: b = 2;
// 4: c = makeStruct();
// 4 - OK; 2 - Error
// We free the memory of the result on line 2.
// The correct solution is to pass 'unused : bool' to the function.

// Think about:
// 1) BTailCall
// BTailCall = loop . should we move the creation of local variables out of the loop?

export {
	addRefCounting(prog : BExpProgram) -> BExpProgram;

	addRefCounting2BProgram(prog : BProgram) -> BProgram;

	isComparisonFn(fn : BExp) -> bool;

	isNativeFnWithoutDrop(exp : BExp) -> bool;
	isBLet(exp : BExp) -> bool;
}

optimization = true;

addRefCounting(prog : BExpProgram) -> BExpProgram {
	fnIds = extractExpFnIds(prog);
	BExpProgram(prog with declarations = map(prog.declarations, \d -> refCountingBExpDeclaration(d, fnIds)));
}

extractExpFnIds(prog : BExpProgram) -> Set<string> {
	fold(prog.declarations, makeSet(), \acc, decl -> switch (decl) {
		BGlobalVar(id, body, type): acc;
		BExpFunction(id, typars, args, body, type): insertSet(acc, id);
		BExpNative(id, isio, type, nativeName): insertSet(acc, id);
	});
}

refCountingBExpDeclaration(decl : BExpDeclaration, fnIds : Set<string>) -> BExpDeclaration {
	switch (decl) {
		BGlobalVar(id, body, type): BGlobalVar(id, addBCounterToBExp(body, [], type, fnIds), type);
		BExpFunction(id, typars, args, body, type): BExpFunction(id, typars, args, addBCounterToBExp(body, args, type, fnIds), type);
		BExpNative(id, isio, type, nativeName): decl;
	}
}

addBCounterToBExp(exp : BExp, capturedVarIds : [string], type : BType, userFnIds : Set<string>) -> BExp {
	generators = fold(cppGenerators(), makeSet(), \acc, g -> insertSet(acc, g.name));
	newBody = refCountingBExp(BExpUsedVars(exp, makeTree(), makeSet(), []), generators, isReturnBType(type), false, userFnIds);
	usedVars = map(capturedVarIds, \id -> containsKeyTree(newBody.usedVars, id));
	if (forall(usedVars, idfn)) {
		newBody.exp;
	} else {
		capturedVarTypes : [BType] = switch (type : BType) {
			BTypePar(__) : [];
			BTypeName(__, __) : [];
			BTypeFunction(args, __) : args;
		}
		unusedVars = filtermapi(usedVars, \i, isUsed -> {
			if (isUsed) {
				None()
			} else {
				maybeBind(
					elementAtM(capturedVarTypes, i),
					\varType -> maybeMap(
						elementAtM(capturedVarIds, i),
						\id -> BDropValue(BVar(id, varType))
					)
				);
			}
		});
		if (unusedVars == []) {
			newBody.exp;
		} else {
			BSequence(arrayPush(unusedVars, newBody.exp), getBType(newBody.exp));
		}
	}
}

BExpUsedVars(
	exp : BExp,
	usedVars : Tree<string, BExpUsedVar>, // key is _id_
	createdVars : Set<string>, // local variables
	downDrops : [BCounter], // variables we want to delete later (in the parent expression)
);

BExpUsedVar(
	type : BType,
	externalDrop : bool, // used in a function
);

foldri(cs : [?], acc : ??, fn : (int, ??, ?) -> ??) -> ?? {
	doFoldri(cs, length(cs) - 1, acc, fn);
}

doFoldri(cs : [?], i : int, acc : ??, fn : (int, ??, ?) -> ??) -> ?? {
	if (i >= 0) {
		doFoldri(cs, i - 1, fn(i, acc, cs[i]), fn);
	} else {
		acc;
	}
}

existsi(a : [?], fn : (int, ?) -> bool) -> bool {
	foundIndex = iteriUntil(a, \i, e -> fn(i, e));
	foundIndex != length(a);
}

refCountingBExp(exp : BExpUsedVars, generators : Set<string>, withReturn : bool, isDownDrop : bool, fnIds : Set<string>) -> BExpUsedVars {
	dupDrop = \e, reuse -> dropBExpUsedVars(dupBExpUsedVars(e, false), reuse);
	recInc = \e, tails, createdVars, drops, recWithReturn, recIsDownDrop -> refCountingBExp(BExpUsedVars(e, tails, createdVars, drops), generators, recWithReturn, recIsDownDrop, fnIds);
	rec = \e, recWithReturn, recIsDownDrop -> recInc(e, exp.usedVars, exp.createdVars, exp.downDrops, recWithReturn, recIsDownDrop);
	mapExpA = \args, lastWithReturn : bool, allWithReturn : bool, recIsDownDrop : bool, dupItem : bool -> {
		lastIndex = length(args) - 1;
		foldri(args, Quadruple([], exp.usedVars, exp.createdVars, exp.downDrops), \i, acc, arg -> unquadruple(acc, \newArgs, newTails, newCreatedVars, newDrops -> {
			newExp = recInc(arg, newTails, exp.createdVars, newDrops, allWithReturn || lastWithReturn && (i == lastIndex), recIsDownDrop);
			newArg = if (dupItem) dupBExpUsedVars(newExp, false) else newExp;
			reducedExp = reduceBCounter(newArg.exp, recIsDownDrop);
			Quadruple(
				concat([reducedExp.first], newArgs),
				newArg.usedVars,
				mergeSets(newCreatedVars, newArg.createdVars),
				arrayPushMaybe(newArg.downDrops, reducedExp.second)
			);
		}));
	}

	// TODO: result of the function?
	dupAlias = \val : BExp -> {
		varId = extractBVarId(val);
		isAlias = varId != "";
		// TODO: we don't know the type of Cast
		// should be:
		// if downCast, then dup the result (e.g. result of cast())
		// if upCast, dup the init value
		if (!isBCounter(val) && isAlias) BDupValue(val)/*(addBCounterToExp(val, \e -> BDupValue(e)))*/ else val;
	}

	switch (exp.exp) {
		BVoid() : exp;
		BBool(v) : exp;
		BInt(v) : exp;
		BDouble(v) : exp;
		BString(v): if (withReturn) exp else BExpUsedVars(exp with exp = BDropValue(exp.exp));
		BVar(id, type): if (isBTypeFunction(type) || containsSet(fnIds, id)) exp else dupDrop(exp, withReturn);
		BArray(args, type): unquadruple(
			mapExpA(args, false, true, isDownDrop, true),
			\newValues, newUsedVars, newCreatedVars, newDrops -> {
				newArray = BArray(newValues, type);
				BExpUsedVars(if (withReturn) newArray else BDropValue(newArray), newUsedVars, newCreatedVars, newDrops)
			}
		);
		BLet(id, val, body, type): {
			newBody = rec(body, true, isDownDrop);
			newValue = recInc(val, newBody.usedVars, newBody.createdVars, newBody.downDrops, true, isDownDrop);
			dupExp = dupDrop(BExpUsedVars(BVar(id, getBType(val)), newValue.usedVars, insertSet(newValue.createdVars, id), newValue.downDrops), false);
			reducedBCounter = reduceBCounter(dupExp.exp, isDownDrop);
			bodyWithDup = if (isBCounter(reducedBCounter.first)) {
				BSequence([reducedBCounter.first, newBody.exp], type);
			} else {
				newBody.exp;
			}
			reducedValue = reduceBCounter(newValue.exp, isDownDrop);
			BExpUsedVars(
				BLet(id, dupAlias(reducedValue.first), bodyWithDup, type),
				dupExp.usedVars,
				dupExp.createdVars,
				arrayPushMaybe(arrayPushMaybe(dupExp.downDrops, reducedBCounter.second), reducedValue.second)
			);
		}
		BLambda(args, body, type): {
			newBody = rec(body, withReturn || isReturnBType(type), isDownDrop);
			BExpUsedVars(BLambda(args, newBody.exp, type), newBody.usedVars, newBody.createdVars, newBody.downDrops);
		}
		BCall(fn, args, type): {
			lambdaFn = getLambdaId(fn, fnIds);
			isNativeOperation = isNativeWithoutDropFn(fn, generators); // +, -, *, etc.
			isComparison = isComparisonFn(fn);
			isLambda = lambdaFn.first != "" && !isNativeOperation;
			hasResult = type != bvoidType;
			newFn = rec(fn, withReturn || hasResult, isDownDrop);
			newFnExp = reduceBCounter(newFn.exp, isDownDrop || isComparison);
			newArgs = foldr(args, Quadruple([], newFn.usedVars, newFn.createdVars, maybeArrayPush(newFn.downDrops, newFnExp.second)), \acc, arg -> unquadruple(acc, \newArgs, newTails, createdVars, newDrops -> {
				newArg = recInc(arg, newTails, exp.createdVars, newDrops, true, isDownDrop || isComparison);
				// if (!isComparison) drop is inside the FN
				dupedArg = if (isComparison) newArg else dupBExpUsedVars(newArg, true);
				reducedValue = reduceBCounter(dupedArg.exp, isDownDrop || isComparison);
				Quadruple(concat([reducedValue.first], newArgs), dupedArg.usedVars, mergeSets(createdVars, newArg.createdVars), arrayPushMaybe(dupedArg.downDrops, reducedValue.second));
			}));

			newBCall = if (isNativeOperation) {
				BCall(newFnExp.first, newArgs.first, type);
			} else {
				addTmpVars(newArgs.first, \tmpVars : [BExp] -> BCall(newFnExp.first, tmpVars, type));
			}
			newUsedVars = if (isLambda) unpair(lambdaFn, \id, lambdaType -> setTree(newArgs.second, id, BExpUsedVar(lambdaType, false))) else newArgs.second;
			// TODO: reuse only the result from which we use the part (field). otherwise you don't need to add BReuse.
			dropedBCall = if (!hasResult) newBCall else if (withReturn) BReuseValue(newBCall) else BDropValue(newBCall);
			newDownDrops = newArgs.fourth;
			expWithDownDrop = if (newDownDrops == []) {
				dropedBCall;
			} else {
				addTempVar(dropedBCall, newDownDrops, type, withReturn);
			}
			newExp = BExpUsedVars(expWithDownDrop, newUsedVars, newArgs.third, []);

			if (isLambda) {
				//newExp = makeBConstructWithDrops(newConstruct, newDrops, withReturn || isDownDrop);
				newExp; //dupDrop(newExp, withReturn)
			} else {
				newExp;
			}
		}
		BIf(cond, then, else_, type): {
			calculatedCases = [rec(then, withReturn, isDownDrop), rec(else_, withReturn, isDownDrop)];
			calculatedCasesUsedVars = fold(calculatedCases, exp.usedVars, \acc, c -> mergeTree(acc, c.usedVars));
			origCond = rec(cond, withReturn, isDownDrop);
			addDupDropToCmpr(
				BExpUsedVars(cond, origCond.usedVars, origCond.createdVars, origCond.downDrops),
				calculatedCases,
				type,
				exp.usedVars,
				generators,
				isDownDrop,
				\newCond : BExp, condUsedVars : Tree<string, BExpUsedVar>, createdVars -> recInc(newCond, condUsedVars, mergeSets(exp.createdVars, createdVars), exp.downDrops, withReturn, isDownDrop),
				\newCond : BExp, cases : [BExp] -> if (length(cases) == 2) BIf(newCond, cases[0], cases[1], type) else exp.exp,
				\condBody : BExp, condUsedVars : Tree<string, BExpUsedVar> -> {
					// withReturn = true because we create a tmp var for condBody
					recInc(condBody, mergeTree(calculatedCasesUsedVars, condUsedVars), exp.createdVars, exp.downDrops, true, isDownDrop).exp;
				},
			);
		}
		BSequence(exps, type): unquadruple(
			mapExpA(exps, withReturn, false, isDownDrop, false),
			\newValues, newUsedVars, newCreatedVars, newDrops -> BExpUsedVars(BSequence(newValues, type), newUsedVars, newCreatedVars, newDrops)
		);
		BSwitch(value, switchType, cases, defaultCase, type): {
			newValue = rec(value, withReturn, isDownDrop);
			calculatedCases = arrayPushMaybe(map(cases, \c -> rec(c.body, withReturn, isDownDrop)), maybeMap(defaultCase, \c -> rec(c, withReturn, isDownDrop)));
			calculatedCasesUsedVars = fold(calculatedCases, exp.usedVars, \acc, c -> mergeTree(acc, c.usedVars));
			addDupDropToCmpr(
				BExpUsedVars(value, newValue.usedVars, newValue.createdVars, newValue.downDrops),
				calculatedCases,
				type,
				exp.usedVars,
				generators,
				isDownDrop,
				\newCond : BExp, condUsedVars : Tree<string, BExpUsedVar>, createdVars -> recInc(newCond, condUsedVars, mergeSets(exp.createdVars, createdVars), exp.downDrops, withReturn, isDownDrop),
				\newCond : BExp, newCases : [BExp] -> if (length(newCases) == (length(cases) + eitherMap(defaultCase, \__ -> 1, 0))) {
					BSwitch(
						extractSwitchVar(newCond, type),
						switchType,
						mapi(cases, \i, c -> BCase(c.id, newCases[i])),
						maybeMap(defaultCase, \c -> lastElement(newCases, c)),
						type
					)
				} else {
					exp.exp
				},
				\condBody : BExp, condUsedVars : Tree<string, BExpUsedVar> -> recInc(condBody, mergeTree(calculatedCasesUsedVars, condUsedVars), exp.createdVars, exp.downDrops, withReturn, isDownDrop).exp, 
			);
		}
		BConstruct(struct, args, type): unquadruple(
			// allWithReturn = true
			// isDownDrop = true for args (we will remove the values after the whole structure has been constructed.)
			mapExpA(map(args, dupAlias), false, true, true, false),
			\newValues, newUsedVars, newCreatedVars, newDrops -> {
				newConstruct = BConstruct(struct, newValues, type);
				newExp = makeBConstructWithDrops(newConstruct, newDrops, withReturn || isDownDrop);
				BExpUsedVars(if (withReturn) newExp else BDropValue(newExp), newUsedVars, newCreatedVars, []);
			}
		);
		BField(value, field, type): {
			newValue = rec(value, withReturn, isDownDrop);
			reducedValue = reduceBCounter(newValue.exp, isDownDrop);
			reusedVal = getReusedValue(reducedValue.first);
			newExp = if (reusedVal != reducedValue.first) {
				reuseBField(BField(reusedVal, field, type));
			} else {
				BDupValue(BField(reducedValue.first, field, type));
			}
			BExpUsedVars(newExp, newValue.usedVars, newValue.createdVars, arrayPushMaybe(newValue.downDrops, reducedValue.second));
		}
		BSetMutable(left, field, value, type): {
			newLeft = rec(left, withReturn, isDownDrop);
			newValue = recInc(value, newLeft.usedVars, newLeft.createdVars, newLeft.downDrops, true, isDownDrop);
			BExpUsedVars(
				BSetMutable(newLeft.exp, field, newValue.exp, type),
				newValue.usedVars,
				newValue.createdVars,
				newValue.downDrops,
			)
		}
		BCast(value, from, to): {
			newValue = rec(value, withReturn, isDownDrop);
			reducedValue = reduceBCounter(newValue.exp, isDownDrop);
			reusedVal = getReusedValue(reducedValue.first);
			newExp = if (reusedVal != reducedValue.first) {
				reuseBCast(BCast(reusedVal, from, to));
			} else {
				BCast(reducedValue.first, from, to);
			}
			BExpUsedVars(newExp, newValue.usedVars, newValue.createdVars, arrayPushMaybe(newValue.downDrops, reducedValue.second));
		}
		BDupValue(value) : {
			newValue = rec(value, withReturn, isDownDrop);
			reducedValue = reduceBCounter(BDupValue(newValue.exp), isDownDrop);
			BExpUsedVars(reducedValue.first, newValue.usedVars, newValue.createdVars, arrayPushMaybe(newValue.downDrops, reducedValue.second));
		}
		BDropValue(value) : {
			newValue = rec(value, withReturn, isDownDrop);
			reducedValue = reduceBCounter(BDropValue(newValue.exp), isDownDrop);
			BExpUsedVars(reducedValue.first, newValue.usedVars, newValue.createdVars, arrayPushMaybe(newValue.downDrops, reducedValue.second));
		}
		BReuseValue(value) : {
			newValue = rec(value, withReturn, isDownDrop);
			reducedValue = reduceBCounter(BReuseValue(newValue.exp), isDownDrop);
			BExpUsedVars(reducedValue.first, newValue.usedVars, newValue.createdVars, arrayPushMaybe(newValue.downDrops, reducedValue.second));
		}
	}
}

// TODO: alias ?
getLambdaId(fn : BExp, functionIds : Set<string>) -> Pair<string, BType> {
	switch (fn) {
		BVar(id, type) : if (!containsSet(functionIds, id)) Pair(id, type) else Pair("", bvoidType);
		BDupValue(value) : getLambdaId(value, functionIds);
		BDropValue(value) : getLambdaId(value, functionIds);
		BReuseValue(value) : getLambdaId(value, functionIds);
		BCast(value, __, __) : getLambdaId(value, functionIds);
		default : Pair("", bvoidType);
	}
}

dropBExpUsedVars(exp : BExpUsedVars, reuse : bool) -> BExpUsedVars {
	BExpUsedVars(
		addBCounterToExp(exp.exp, \e -> if (reuse) BReuseValue(e) else BDropValue(e)),
		exp.usedVars,
		exp.createdVars,
		exp.downDrops
	);
}

dupBExpUsedVars(exp : BExpUsedVars, isExternalDrop : bool) -> BExpUsedVars {
	id = extractBVarId(exp.exp);
	if (id == "") {
		exp;
	} else {
		eitherFn(
			lookupTree(exp.usedVars, id),
			\v -> BExpUsedVars(addBCounterToExp(exp.exp, \e -> BDupValue(e)), setTree(exp.usedVars, id, BExpUsedVar(v with externalDrop = isExternalDrop)), exp.createdVars, exp.downDrops),
			\-> BExpUsedVars(exp.exp, setTree(exp.usedVars, id, BExpUsedVar(getBType(exp.exp), isExternalDrop)), exp.createdVars, exp.downDrops)
		);
	}
}

addBCounterToExp(exp : BExp, addCounter : (BExp) -> BCounter) -> BExp {
	switch (exp) {
		BCast(value, from, to) : BCast(addBCounterToExp(value, addCounter), from, to);
		default : addCounter(exp);
	}
}

extractBVarId(exp : BExp) -> string {
	switch (exp) {
		BVar(id, __) : id;
		BDupValue(value) : extractBVarId(value);
		BDropValue(value) : extractBVarId(value);
		BReuseValue(value) : extractBVarId(value);
		BCast(value, __, __) : extractBVarId(value);
		default : "";
	}
}

isBCounter(exp : BExp) -> bool {
	switch (exp : BExp) {
		BCounter(): true;
		default: false;
	}
}

getReusedValue(exp : BExp) -> BExp {
	switch (exp : BExp) {
		BReuseValue(value): value;
		default: exp;
	}
}

isBTypeFunction(type : BType) -> bool {
	switch (type) {
		BTypePar(__) : false;
		BTypeName(__, __) : false;
		BTypeFunction(__, __) : true;
	}
}

isReturnBType(type : BType) -> bool {
	switch (type) {
		BTypePar(__) : false;
		BTypeName(__, __) : false;
		BTypeFunction(__, returnType) : returnType != bvoidType;
	}
}

// TODO
isNativeWithoutDropFn(exp : BExp, generators : Set<string>) -> bool {
	containsSet(generators, extractBVarId(exp));
}

isNativeFnWithoutDrop(exp : BExp) -> bool {
	generators = fold(cppGenerators(), makeSet(), \acc, g -> insertSet(acc, g.name));
	isNativeWithoutDropFn(exp, generators);
}

reduceBCounter(counter : BExp, isDownDrop : bool) -> Pair<BExp, Maybe<BCounter>> {
	if (optimization) {
	unquadruple(extractBExpFromBCounter(counter, 0, 0, false), \exp, dupCnt, dropCnt, reuse -> {
		cnt = min(dupCnt, dropCnt);
		reducedDupCnt = dupCnt - cnt;
		reducedDropCnt = dropCnt - cnt;

		newValue = fold(enumFromTo(1, reducedDupCnt), exp, \newExp, __ -> addBCounterToExp(newExp, \e -> BDupValue(e)));
		addReuseDrop = \newExp -> addBCounterToExp(newExp, \e -> if (reuse) BReuseValue(e) else BDropValue(e));
		// we can only move drop() for variables
		if (isDownDrop && extractBVarId(exp) != "") {
			Pair(newValue, if (reducedDropCnt > 0) Some(fold(enumFromTo(1, reducedDropCnt - 1), BDropValue(newValue), \newExp, __ -> addReuseDrop(newExp))) else None())
		} else {
			Pair(fold(enumFromTo(1, reducedDropCnt), newValue, \newExp, __ -> addReuseDrop(newExp)), None());
		}
	});
	} else Pair(counter, None());
}

extractBExpFromBCounter(exp : BExp, dupCnt : int, dropCnt : int, reuse : bool) -> Quadruple<BExp, int, int, bool> {
	switch (exp : BExp) {
		BDupValue(value) : extractBExpFromBCounter(value, dupCnt + 1, dropCnt, reuse);
		BDropValue(value) : extractBExpFromBCounter(value, dupCnt, dropCnt + 1, reuse);
		BReuseValue(value) : extractBExpFromBCounter(value, dupCnt, dropCnt + 1, true);
		BCast(value, from, to) : unquadruple(
			extractBExpFromBCounter(value, dupCnt, dropCnt, reuse),
			\newExp, newDupCnt, newDropCnt, newReuse -> Quadruple(BCast(newExp, from, to), newDupCnt, newDropCnt, newReuse)
		);
		default : Quadruple(exp, dupCnt, dropCnt, reuse);
	}
}

extractLastUsedVars(exp : BExpUsedVars, usedVars : Tree<string, BExpUsedVar>) -> Tree</*id*/string, Pair<BVar, bool>> {
	foldTree(exp.usedVars, makeTree(), \id : string, uv : BExpUsedVar, acc -> {
		if (containsKeyTree(usedVars, id)) acc else setTree(acc, id, Pair(BVar(id, uv.type), uv.externalDrop))
	});
}

addBDropVars(exp : BExpUsedVars, vars : [BVar]) -> BExpUsedVars {
	if (vars == []) {
		exp;
	} else {
		BExpUsedVars(
			BSequence(
				arrayPush(map(vars, \v -> BDropValue(v)), exp.exp),
				getBType(exp.exp)
			),
			exp.usedVars,
			exp.createdVars,
			exp.downDrops,
		);
	}
}

extractSwitchVar(exp : BExp, defType : BType) -> BVar {
	switch (exp) {
		BVar(id, t) : exp;
		BReuseValue(value) : extractSwitchVar(value, defType);
		default: BVar("", defType);
	}
}

// bind a variable to each data creation.
// this way we'll free memory immediately after checking the condition, and not at the end of the if/switch block.
extractConstructedVars(exp : BExp, resultType : BType, generators : Set<string>) -> Triple<[Pair<BVar, bool>], (BExp, (BExp) -> BExp) -> BExp, BExp> {
	// false ? fn(if (fn())) ?
	untriple(makeConstructedVars(exp, [], [], generators, false), \vars, lets, newExp -> {
		Triple(
			vars,
			\tail, updateCondBody -> foldr(lets, tail, \acc, v -> BLet(v with value = updateCondBody(v.value), body = acc, type = getBType(acc))),
			either(newExp, exp)
		)
	})
}

tmpConstructedVarCounter = ref 1;
// create tmp vars for expressions
makeConstructedVars(exp : BExp, vars : [Pair<BVar, bool>], exps : [BLet], generators : Set<string>, externalDrop : bool) -> Triple<[Pair<BVar, bool>], [BLet], Maybe<BExp>> {
	makeTmpVar = \varType, expType -> {
		varName = makeTmpVariableName();
		Triple([Pair(BVar(varName, varType), externalDrop)], [BLet(varName, exp, BVoid(), varType)], Some(BVar(varName, expType)));
	}
	switch (exp) {
		BConstruct(struct, args, type) : makeTmpVar(type, type);
		BCall(fn, args, type) : {
			newArgs = fold(args, Triple(vars, exps, []), \acc, a -> {
				v = makeConstructedVars(a, [], [], generators, !isNativeWithoutDropFn(fn, generators));
				Triple(concat(acc.first, v.first), concat(acc.second, v.second), arrayPush(acc.third, v.third));
			});
			newFn = makeConstructedVars(fn, [], [], generators, false);
			Triple(
				concat(newFn.first, newArgs.first),
				concat(
					newArgs.second,
					eitherMap(
						newFn.third,
						\__ -> if (newFn.second == []) {
							[]
						} else {
							newValue = BCall(newFn.second[0].value, mapi(args, \i, arg -> either(newArgs.third[i], arg)), type);
							replace(newFn.second, 0, BLet(newFn.second[0] with value = newValue))
						},
						newFn.second
					)
				),
				eitherFn(
					newFn.third,
					\varFn -> Some(varFn),
					\-> Some(BCall(fn, mapi(args, \i, arg -> either(newArgs.third[i], arg)), type))
				)
			);
		}
		BField(value, fieldName, type) : {
			untriple(makeConstructedVars(value, vars, exps, generators, externalDrop), \newVars, lets, newExp -> {
				Triple(newVars, lets, Some(BField(either(newExp, value), fieldName, type)))
			});
		}
		BVar(id, type) : switch (type : BType) {
			BTypePar(__) : Triple([], [], None());
			BTypeName(__, __) : Triple([], [], None());
			BTypeFunction(__, returnType) : if (isNativeWithoutDropFn(exp, generators)) {
				Triple([], [], None())
			} else {
				makeTmpVar(returnType, type);
			}
		}
		default: Triple([], [], None());
	}
}

addDupDropToCmpr(
	cond : BExpUsedVars,
	cases : [BExpUsedVars],
	type : BType,
	usedVars : Tree<string, BExpUsedVar>,
	generators : Set<string>,
	isDownDrop : bool,
	updateCond : (BExp, Tree<string, BExpUsedVar>, Set<string>) -> BExpUsedVars,
	updateCases : (cond : BExp, cases : [BExp]) -> BExp,
	updateCondBody : (BExp, Tree<string, BExpUsedVar>) -> BExp,
) -> BExpUsedVars {
	// TODO: think about : 
	// Which is cheaper: create a variable and free the memory earlier, or not bind the variable and let c++ do it itself?
	condTmpVars : Triple<[Pair<BVar, bool>], (BExp, (BExp) -> BExp) -> BExp, BExp> = extractConstructedVars(cond.exp, type, generators);
	condTmpCreatedVars = condTmpVars.first;

	condUsedVars = extractLastUsedVars(cond, usedVars);
	caseUsedVars = map(cases, \c -> extractLastUsedVars(c, usedVars));
	isVarUsedInOtherCases = \id : string, ind : int -> existsi(caseUsedVars, \j, case -> ind != j && containsKeyTree(case, id));
	caseUniqueUsedVars = mapi(caseUsedVars, \i, c -> foldTree(c, [], \id, v, acc -> unpair(v, \var, isExternalDrop -> {
		isLocal = \-> containsSet(cases[i].createdVars, id);
		if (isExternalDrop || isLocal() || isVarUsedInOtherCases(id, i)) acc else arrayPush(acc, var)
	})));
	condUniqueUsedVars = foldTree(condUsedVars, [], \id, v, acc -> unpair(v, \var, isExternalDrop -> {
		isLocal = \-> containsSet(cond.createdVars, id);
		if (isExternalDrop || isLocal() || isVarUsedInOtherCases(id, -1)) acc else arrayPush(acc, var)
	}));

	// drop vars, that are last used in this If/Switch
	tmpCondVars = filtermap(condTmpCreatedVars, unpairC(\cvar, externalDrop -> if (externalDrop) None() else Some(cvar)));
	casesWithDrop = mapi(cases, \i, c -> {
		addBDropVars(c, concat(condUniqueUsedVars, foldi(caseUniqueUsedVars, tmpCondVars, \j, acc, a -> if (i == j) acc else concat(acc, a))))
	});
	newCondTmpUsedVars = values2treeEx(condTmpCreatedVars, \cvar -> cvar.first.id, \cvar -> BExpUsedVar(cvar.first.type, false));
	newCondUsedVars = mergeTree(newCondTmpUsedVars, cond.usedVars);
	fixedCond = updateCond(condTmpVars.third, newCondUsedVars, fold(condTmpCreatedVars, makeSet(), \acc, v -> insertSet(acc, v.first.id)));
	reducedCond = reduceBCounter(fixedCond.exp, isDownDrop);
	newExpr = updateCases(reducedCond.first, map(casesWithDrop, \c -> c.exp));
	BExpUsedVars(
		if (condTmpCreatedVars == []) {
			newExpr
		} else {
	// TODO: don't create a lambda
			condTmpVars.second(newExpr, \e -> updateCondBody(e, newCondTmpUsedVars)) // this is BLet -> lambda if var=if(...)
		},
		fold(cases, fixedCond.usedVars, \acc, c -> mergeTree(acc, c.usedVars)),
		fold(cases, fixedCond.createdVars, \acc, c -> mergeSets(acc, c.createdVars)),
		arrayPushMaybe(concat(fixedCond.downDrops, mapConcat(cases, \c -> c.downDrops)), reducedCond.second)
	);
}

// TODO: remove lambda (tmpVar + BLet), down dropExps
// c++ doesn't guarantee the order of initialization of the structure fields (?)
// we add drop to the last arg, but should after construction
// example : Struct3(Struct(a.v + a.v), Struct(a.v * a.v));
// -> Struct3(Struct(a.v + a.v), { Struct(a.v * a.v), drop(a)});
// => Struct3(...), drop(a)
makeBConstructWithDrops(constr : BConstruct, dropExps : [BCounter], withReturn : bool) -> BExp {
	if (dropExps == []) {
		constr;
	} else {
		addTempVar(constr, dropExps, constr.type, withReturn);
	}
}

//
// Before: auto flow_a = (*reuse(flow_makeStruct())).flow_val;
// After : auto _tmp_con = flow_makeStruct(); auto _tmp_con2 = dup((*_tmp_con).flow_val); drop(_tmp_con); _tmp_con2;
reuseBField(field : BField) -> BExp {
	replaceReuseWithDrop(field.value, field.type, \val -> BField(val, field.field, field.type));
}

replaceReuseWithDrop(value : BExp, type : BType, makeExp : (BExp) -> BExp) -> BExp {
	addFieldTmpVar = \val -> {
		tmpVarField = BVar(makeTmpVariableName(), type);
		BLet(
			tmpVarField.id,
			BDupValue(makeExp(val)),
			BSequence(
				[
					BDropValue(val),
					tmpVarField
				],
				tmpVarField.type
			),
			type
		);
	}
	varId = extractBVarId(value);
	if (varId != "") {
		addFieldTmpVar(value);
	} else if (isBLet(value)) {
		value;
	} else {
		tmpVarStruct = BVar(makeTmpVariableName(), getBType(value));
		BLet(
			tmpVarStruct.id,
			value,
			addFieldTmpVar(tmpVarStruct),
			type
		);
	}
}

// TODO: we don't know the type of Cast
// should be:
// if downCast, then dup the result (e.g. result of cast())
// if upCast, dup the init value
reuseBCast(exp : BCast) -> BExp {
	replaceReuseWithDrop(exp.value, exp.to, \val -> BCast(val, exp.from, exp.to));
}

addTempVar(exp : BExp, body : [BExp], type : BType, withReturn : bool) -> BLet {
	tmpVar = BVar(makeTmpVariableName(), type);
	BLet(
		tmpVar.id,
		exp,
		BSequence(arrayPush(body, if (withReturn) tmpVar else BDropValue(tmpVar)), tmpVar.type),
		type
	);
}

// first exp = top exp
addTmpVars(exps : [BExp], makeBody : ([BExp]) -> BExp) -> BExp {
	if (length(exps) < 2) {
		makeBody(exps);
	} else {
		// TODO: optimization. this is only needed if the variable uses multiple times and needs to be removed.
		isExpForTmpVar = \exp -> {
			switch (exp : BExp) {
				BVoid(): false;
				BBool(__): false;
				BInt(__): false;
				BDouble(__): false;
				BString(__): false;
				BLet(id, __, __, __): !startsWith(id, "_tmp_con");
				default : true;
				}
		}
		tmpVars = map(exps, \exp -> {
			if (isExpForTmpVar(exp)) {
				tmpVar = BVar(makeTmpVariableName(), getBType(exp));
				Pair(Some(tmpVar), tmpVar);
			} else {
				Pair(None(), exp);
			}
		});

		newBody = makeBody(map(tmpVars, secondOfPair));
		bodyType = getBType(newBody);

		foldri(exps, newBody, \i, acc, exp -> {
			eitherMap(
				tmpVars[i].first, 
				\tmpVar -> BLet(tmpVar.id, exp, acc, getBType(acc)),
				acc
			)
		});

	}
}

makeTmpVariableName() -> string {
	"_tmp_con" + i2s(atomicRefIntAddition(tmpConstructedVarCounter, 1));
}

addRefCounting2BProgram(prog : BProgram) -> BProgram {
	BProgram(
		prog.structs,
		prog.unions,
		map(prog.declarations, addRefCounting2BDeclaration)
	)
}

addRefCounting2BDeclaration(decl : BDeclaration) -> BDeclaration {
	switch (decl : BDeclaration) {
		BGlobalVar(__, __, __) : decl;
		BExpNative(__, __, __, __) : decl;
		BStatFunction(id, typars, args, body, tailCall, type) : addRefCounting2BStatFunction(decl);
	}
}

addRefCounting2BStatFunction(fn : BStatFunction) -> BStatFunction {
	if (fn.tailCall) {
		BStatFunction(fn.id, fn.typars, fn.args, addRefCounting2BStatement(fn.body), fn.tailCall, fn.type)
	} else {
		fn
	}
}

addRefCounting2BStatement(s : BStatement) -> BStatement {
	switch (s : BStatement) {
		BIfStatement(cond, then, else_): BIfStatement(cond, addRefCounting2BStatement(then), addRefCounting2BStatement(else_));
		BLetStatement(name, value, body): BLetStatement(name, value, addRefCounting2BStatement(body));
		BReturnVoid(): s;
		BReturn(val): s;
		BTailCall(fn, args, values, type): {
			fnArgs = buildSet(args);
			BTailCall(fn, args, map(values, \v -> removeBDropValueForVariables(v, fnArgs).first), type);
		}
		BSequenceStatement(statements): BSequenceStatement(map(statements, addRefCounting2BStatement));
		BSwitchStatement(expr, cases, type): BSwitchStatement(expr, map(cases, \c -> BCaseStatement(c.id, addRefCounting2BStatement(c.body))), type);
		BSetMutableStatement(left, field, value): s;
	}
}

// we should not drop(argument) in a loop
removeBDropValueForVariables(exp : BExp, vars : Set<string>) -> Pair<BExp, bool> {
	switch (exp) {
		BValue(): Pair(exp, false);
		BVar(name, type): Pair(exp, containsSet(vars, name));
		BLet(name, value, body, type): Pair(BLet(
			name,
			removeBDropValueForVariables(value, vars).first,
			removeBDropValueForVariables(body, vars).first,
			type
		), false);
		BLambda(args, body, type): Pair(BLambda(args, removeBDropValueForVariables(body, vars).first, type), false);
		BCall(fn, args, type): Pair(BCall(
			removeBDropValueForVariables(fn, vars).first,
			map(args, \a -> removeBDropValueForVariables(a, vars).first),
			type
		), false);
		BIf(cond, then, else_, type): Pair(BIf(
			removeBDropValueForVariables(cond, vars).first,
			removeBDropValueForVariables(then, vars).first,
			removeBDropValueForVariables(else_, vars).first,
			type
		), false);
		BSequence(exps, type): Pair(BSequence(map(exps, \a -> removeBDropValueForVariables(a, vars).first), type), false);
		BSwitch(val, switchType, cases, defaultCase, type): Pair(BSwitch(
			val,
			switchType,
			map(cases, \case -> BCase(case.id, removeBDropValueForVariables(case.body, vars).first)),
			maybeMap(defaultCase, \c -> removeBDropValueForVariables(c, vars).first),
			type
		), false);
		BConstruct(struct, args, type): Pair(BConstruct(struct, map(args, \a -> removeBDropValueForVariables(a, vars).first), type), false);
		BField(value, field, type): Pair(BField(removeBDropValueForVariables(value, vars).first, field, type), false);
		BSetMutable(left, field, value, type): Pair(BSetMutable(
			removeBDropValueForVariables(left, vars).first,
			field,
			removeBDropValueForVariables(value, vars).first,
			type
		), false);
		BArray(args, type): Pair(BArray(map(args, \a -> removeBDropValueForVariables(a, vars).first), type), false);
		BCast(value, from, to): Pair(BCast(removeBDropValueForVariables(value, vars).first, from, to), false);
		BDupValue(value) : Pair(BDupValue(removeBDropValueForVariables(value, vars).first), false);
		BDropValue(value) : unpair(
			removeBDropValueForVariables(value, vars),
			\newValue, removeDrop -> Pair(if (removeDrop) newValue else BDropValue(newValue), false)
		);
		BReuseValue(value) : Pair(BReuseValue(removeBDropValueForVariables(value, vars).first), false);
	}
}

isComparisonFn(fn : BExp) -> bool {
	fnName = switch (fn : BExp) {
		BVar(id, __) : id;
		default : "";
	}
	fnName == "==" || fnName == "!=" || fnName == ">" || fnName == ">=" || fnName == "<" || fnName == "<=";
}

isBLet(exp : BExp) -> bool {
	switch (exp : BExp) {
		BLet(__, __, __, __) : true;
		BCast(value, __, __) : isBLet(value);
		default : false;
	}
}