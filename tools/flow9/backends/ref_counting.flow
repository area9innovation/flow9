import tools/flow9/backends/bprogram;
import tools/flow9/bexp/type;

export {
	addRefCounting(prog : BExpProgram) -> BExpProgram;
}

addRefCounting(prog : BExpProgram) -> BExpProgram {
//ntv = BExpNative("", false, BTypePar(""), "");println(toString(filter(prog.declarations, \d -> isSameStructType(d, ntv))));
	BExpProgram(prog with declarations = map(prog.declarations, refCountingBExpDeclaration));
}

refCountingBExpDeclaration(decl : BExpDeclaration) -> BExpDeclaration {
	switch (decl) {
		BGlobalVar(id, body, type): BGlobalVar(id, refCountingBExp(BExpUsedVars(body, makeSet())).exp, type);
		BExpFunction(id, typars, args, body, type): {
			BExpFunction(id, typars, args, refCountingBExp(BExpUsedVars(body, makeSet())).exp, type);
		}
		BExpNative(id, isio, type, nativeName): decl;
	}
}

BExpUsedVars(
	exp : BExp,
	usedVars : Set<string>,
);

refCountingBExp(exp : BExpUsedVars) -> BExpUsedVars {
	dupEx = \e, newTails -> {
		id = extractBVarId(e);
		//if (id != "") Pair(BDupValue(e), insertSet(newTails, id)) else Pair(e, newTails);
		// TODO:
		if (id != "" && !containsSet(newTails, id)) BExpUsedVars(e, insertSet(newTails, id)) else BExpUsedVars(BDupValue(e), newTails);
	}
	dup = \e -> dupEx(e.exp, e.usedVars);
	drop = \e -> BExpUsedVars(BDropValue(e.exp), e.usedVars);
	recInc = \e, tails -> refCountingBExp(BExpUsedVars(e, tails));
	rec = \e -> recInc(e, exp.usedVars);
	fnType = BTypeFunction([], BTypePar(""));
	isFn = \type -> isSameStructType(type, fnType);
	mapExpA = \args -> {
		unpair(
			foldr(args, Pair([], exp.usedVars), \acc, arg -> unpair(acc, \newArgs, newTails -> {
				newExp = recInc(arg, newTails);
				Pair(arrayPush(newArgs, newExp.exp), newExp.usedVars);
			})),
			\exps, newTails -> Pair(reverseA(exps), newTails)
		);
	}

	switch (exp.exp) {
		BVoid() : exp;
		BBool(v) : exp;
		BInt(v) : exp;
		BDouble(v) : exp;
		BString(v): exp; // TODO: ?? dup(exp);
		BVar(id, type): if (isFn(type)) exp else drop(dup(exp));
		BArray(args, type): {
			values = mapExpA(args);
			BExpUsedVars(BArray(values.first, type), values.second);
			// TODO: dup(BArray(map(args, rec), type));
		}
		BLet(id, val, body, type): {
			newBody = rec(body);
			newValue = recInc(val, newBody.usedVars);
			dupExp = drop(dupEx(BVar(id, getBType(val)), newValue.usedVars));
			bodyWithDup = BSequence([reduceBCounter(dupExp.exp), newBody.exp], type);
			BExpUsedVars(
				BLet(id, newValue.exp, bodyWithDup, type),
				dupExp.usedVars
			);
		}
		BLambda(args, body, type): {
			newBody = rec(body);
			BExpUsedVars(BLambda(args, newBody.exp, type), newBody.usedVars);
		}
		BCall(fn, args, type): {
			newFn = rec(fn);
			newArgs = foldr(args, Pair([], newFn.usedVars), \acc, arg -> unpair(acc, \newArgs, newTails -> {
				newArg = recInc(arg, newTails);
				if (isNativeWithoutDropFn(fn)) {
					Pair(arrayPush(newArgs, newArg.exp), newArg.usedVars);
				} else {
					// drop is inside the FN
					dupedArg = dupEx(newArg.exp, newArg.usedVars);
					Pair(arrayPush(newArgs, reduceBCounter(dupedArg.exp)), dupedArg.usedVars);
				}
			}));
			BExpUsedVars(BCall(newFn.exp, reverseA(newArgs.first), type), newArgs.second)
		}
		BIf(cond, then, else_, type): {
			newCond = rec(cond);
			newThen = recInc(then, newCond.usedVars);
			newElse = recInc(else_, newThen.usedVars);
			BExpUsedVars(
				BIf(newCond.exp, newThen.exp, newElse.exp, type),
				newElse.usedVars
			);
		}
		BSequence(exps, type): {
			values = mapExpA(exps);
			BExpUsedVars(BSequence(values.first, type), values.second);
		}
		BSwitch(value, switchType, cases, defaultCase, type): {
			newValueExp = rec(value);
			newValue : BVar = switch (newValueExp.exp) {
				BVar(id, t) : BVar(id, t);
				default: BVar("", type);
			}
			newCases = foldr(cases, Pair([], newValueExp.usedVars), \acc, case -> unpair(acc, \newArgs, newTails -> {
				newBody = recInc(case.body, newTails);
				Pair(arrayPush(newArgs, BCase(case.id, newBody.exp)), newBody.usedVars);
			}));
			newDefCase = maybeMap(defaultCase, \c -> recInc(c, newCases.second));
			BExpUsedVars(
				BSwitch(newValue, switchType, reverseA(newCases.first), maybeMap(newDefCase, \c -> c.exp), type),
				eitherMap(newDefCase, \c -> c.usedVars, newCases.second)
			);
		}
		BConstruct(struct, args, type): {
			values = mapExpA(args);
			BExpUsedVars(BConstruct(struct, values.first, type), values.second);
		}
		BField(value, field, type): {
			newValue = rec(value);
			BExpUsedVars(BField(newValue.exp, field, type), newValue.usedVars);
		}
		BSetMutable(left, field, value, type): {
			newLeft = rec(left);
			newValue = recInc(value, newLeft.usedVars);
			BExpUsedVars(
				BSetMutable(newLeft.exp, field, newValue.exp, type),
				newValue.usedVars
			)
		}
		BCast(value, from, to): {
			newValue = rec(value);
			BExpUsedVars(BCast(newValue.exp, from, to), newValue.usedVars);
		}
		BCounter(): exp; // shouldn't happen
	}
}

extractBVarId(exp : BExp) -> string {
	switch (exp) {
		BVar(id, __) : id;
		BDupValue(value) : extractBVarId(value);
		BDropValue(value) : extractBVarId(value);
		default : "";
	}
}

// TODO
isNativeWithoutDropFn(exp : BExp) -> bool {
	switch (exp) {
		BVar(id, __) : id == "+" || id == "-" || id == "*" || id == "/";
		default : false;
	}
}

reduceBCounter(counter : BCounter) -> BExp {
	untriple(extractBExpFromBCounter(counter, 0, 0), \exp, dupCnt, dropCnt -> {
		cnt = min(dupCnt, dropCnt);
		reducedDupCnt = dupCnt - cnt;
		reducedDropCnt = dropCnt - cnt;
		newValue = fold(enumFromTo(1, dupCnt), exp, \newExp, __ -> BDupValue(newExp));
		fold(enumFromTo(1, dropCnt), newValue, \newExp, __ -> BDropValue(newExp));
	});
}

extractBExpFromBCounter(exp : BExp, dupCnt : int, dropCnt : int) -> Triple<BExp, int, int> {
	switch (exp : BExp) {
		BDupValue(value) : extractBExpFromBCounter(value, dupCnt + 1, dropCnt);
		BDropValue(value) : extractBExpFromBCounter(value, dupCnt, dropCnt + 1);
		default : Triple(exp, dupCnt, dropCnt);
	}
}