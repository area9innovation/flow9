import tools/flow9/backends/bprogram;
import tools/flow9/bexp/type;
import tools/flow9/backends/cpp/cpp_backend;
import sys/concurrent;

// Known issues:
//
// 1) IF
// if the branch doesn't contain a terminal variable, we'll drop it, but it would be ideal if we could predict the branch and drop the variable early.
// Example :
//  1: fn(c : bool, b : int) -> int {
//  2:   var = b * 10;
//  3:   d = if (c) var + 1 else b;
//  4:   return d;
//  5: }
// we'll free _var_ on line 3. but if c is false, it would be greate to free _var_ on line 2;
//
// 2) Dangling variables
// Example :
//  1: fn(b : int) -> int {
//  2:   var = b * 10;
//  3:   d = b;
//  4:   var; // dangling variable
//  5:   return d;
//  6: }
// we'll free _var_ on line 4. but it would be greate to free _var_ on line 2;
//
// 3) Dangling arguments
// Example :
//  1: c = "long_string";
//  2: a = 2;
//  3: b = a + 1;
//  4: fn(c, 10);
//  01: fn(c : string, b : int) -> int {
//  02:   println("fn");
//  03:   return b;
//  04: }
// we'll free _c_ on line 4 (02). but it would be greate to free _c_ on line 1;

export {
	addRefCounting(prog : BExpProgram) -> BExpProgram;
}

optimization = true;

addRefCounting(prog : BExpProgram) -> BExpProgram {
	BExpProgram(prog with declarations = map(prog.declarations, refCountingBExpDeclaration));
}

refCountingBExpDeclaration(decl : BExpDeclaration) -> BExpDeclaration {
	switch (decl) {
		BGlobalVar(id, body, type): BGlobalVar(id, addBCounterToBExp(body, [], type), type);
		BExpFunction(id, typars, args, body, type): BExpFunction(id, typars, args, addBCounterToBExp(body, args, type), type);
		BExpNative(id, isio, type, nativeName): decl;
	}
}

addBCounterToBExp(exp : BExp, capturedVarIds : [string], type : BType) -> BExp {
	generators = fold(cppGenerators(), makeSet(), \acc, g -> insertSet(acc, g.name));
	newBody = refCountingBExp(BExpUsedVars(exp, makeTree()), generators, isReturnBType(type));
	usedVars = map(capturedVarIds, \id -> containsKeyTree(newBody.usedVars, id));
	if (forall(usedVars, idfn)) {
		newBody.exp;
	} else {
		capturedVarTypes : [BType] = switch (type : BType) {
			BTypePar(__) : [];
			BTypeName(__, __) : [];
			BTypeFunction(args, __) : args;
		}
		unusedVars = filtermapi(usedVars, \i, isUsed -> {
			if (isUsed) {
				None()
			} else {
				maybeBind(
					elementAtM(capturedVarTypes, i),
					\varType -> maybeMap(
						elementAtM(capturedVarIds, i),
						\id -> BDropValue(BVar(id, varType))
					)
				);
			}
		});
		if (unusedVars == []) {
			newBody.exp;
		} else {
			BSequence(arrayPush(unusedVars, newBody.exp), getBType(newBody.exp));
		}
	}
}

BExpUsedVars(
	exp : BExp,
	usedVars : Tree<string, BType>, // id - type
);

foldri(cs : [?], acc : ??, fn : (int, ??, ?) -> ??) -> ?? {
	doFoldri(cs, length(cs) - 1, acc, fn);
}

doFoldri(cs : [?], i : int, acc : ??, fn : (int, ??, ?) -> ??) -> ?? {
	if (i >= 0) {
		doFoldri(cs, i - 1, fn(i, acc, cs[i]), fn);
	} else {
		acc;
	}
}

refCountingBExp(exp : BExpUsedVars, generators : Set<string>, withReturn : bool) -> BExpUsedVars {
	dupDrop = \e, reuse -> dropBExpUsedVars(dupBExpUsedVars(e), reuse);
	recInc = \e, tails, recWithReturn -> refCountingBExp(BExpUsedVars(e, tails), generators, recWithReturn);
	rec = \e, recWithReturn -> recInc(e, exp.usedVars, recWithReturn);
	mapExpA = \args, lastWithReturn -> {
		lastIndex = length(args) - 1;
		foldri(args, Pair([], exp.usedVars), \i, acc, arg -> unpair(acc, \newArgs, newTails -> {
			newExp = recInc(arg, newTails, lastWithReturn && i == lastIndex);
			Pair(concat([reduceBCounter(newExp.exp)], newArgs), newExp.usedVars);
		}));
	}

	switch (exp.exp) {
		BVoid() : exp;
		BBool(v) : exp;
		BInt(v) : exp;
		BDouble(v) : exp;
		BString(v): exp; // TODO: ?? dupBExpUsedVars(exp);
		BVar(id, type): if (isBTypeFunction(type)) exp else dupDrop(exp, withReturn);
		BArray(args, type): {
			values = mapExpA(args, false);
			BExpUsedVars(BArray(values.first, type), values.second);
			// TODO: dupBExpUsedVars(BArray(map(args, rec), type));
		}
		BLet(id, val, body, type): {
			newBody = rec(body, true);
			newValue = recInc(val, newBody.usedVars, true);
			dupExp = dupDrop(BExpUsedVars(BVar(id, getBType(val)), newValue.usedVars), false);
			reducedBCounter = reduceBCounter(dupExp.exp);
			bodyWithDup = switch (reducedBCounter : BExp) {
				BCounter(): BSequence([reducedBCounter, newBody.exp], type);
				default: newBody.exp;
			}
			BExpUsedVars(
				BLet(id, reduceBCounter(newValue.exp), bodyWithDup, type),
				dupExp.usedVars
			);
		}
		BLambda(args, body, type): {
			newBody = rec(body, withReturn || isReturnBType(type));
			BExpUsedVars(BLambda(args, newBody.exp, type), newBody.usedVars);
		}
		BCall(fn, args, type): {
			newFn = rec(fn, withReturn || isReturnBType(type));
			newArgs = foldr(args, Pair([], newFn.usedVars), \acc, arg -> unpair(acc, \newArgs, newTails -> {
				newArg = recInc(arg, newTails, false);
				if (isNativeWithoutDropFn(fn, generators)) {
					Pair(concat([reduceBCounter(newArg.exp)], newArgs), newArg.usedVars);
				} else {
					// drop is inside the FN
					dupedArg = dupBExpUsedVars(newArg);
					Pair(concat([reduceBCounter(dupedArg.exp)], newArgs), dupedArg.usedVars);
				}
			}));
			BExpUsedVars(BCall(newFn.exp, newArgs.first, type), newArgs.second)
		}
		BIf(cond, then, else_, type): {
			addDupDropToCmpr(
				BExpUsedVars(cond, rec(cond, withReturn).usedVars),
				[rec(then, withReturn), rec(else_, withReturn)],
				type,
				exp.usedVars,
				generators,
				\newCond : BExp, condUsedVars : Tree<string, BType> -> recInc(newCond, condUsedVars, withReturn),
				\newCond : BExp, cases : [BExp] -> if (length(cases) == 2) BIf(newCond, cases[0], cases[1], type) else exp.exp,
			);
		}
		BSequence(exps, type): {
			values = mapExpA(exps, true);
			BExpUsedVars(BSequence(values.first, type), values.second);
		}
		BSwitch(value, switchType, cases, defaultCase, type): {
			addDupDropToCmpr(
				BExpUsedVars(value, rec(value, withReturn).usedVars),
				arrayPushMaybe(map(cases, \c -> rec(c.body, withReturn)), maybeMap(defaultCase, \c -> rec(c, withReturn))),
				type,
				exp.usedVars,
				generators,
				\newCond : BExp, condUsedVars : Tree<string, BType> -> recInc(newCond, condUsedVars, withReturn),
				\newCond : BExp, newCases : [BExp] -> if (length(newCases) == (length(cases) + eitherMap(defaultCase, \__ -> 1, 0))) {
					BSwitch(
						extractSwitchVar(newCond, type),
						switchType,
						mapi(cases, \i, c -> BCase(c.id, newCases[i])),
						maybeMap(defaultCase, \c -> lastElement(newCases, c)),
						type
					)
				} else {
					exp.exp
				}
			);
		}
		BConstruct(struct, args, type): {
			values = mapExpA(args, false);
			BExpUsedVars(BConstruct(struct, values.first, type), values.second);
		}
		BField(value, field, type): {
			// TODO: reuse only field
			newValue = rec(value, true);
			BExpUsedVars(BField(reduceBCounter(newValue.exp), field, type), newValue.usedVars);
		}
		BSetMutable(left, field, value, type): {
			newLeft = rec(left, withReturn);
			newValue = recInc(value, newLeft.usedVars, true);
			BExpUsedVars(
				BSetMutable(newLeft.exp, field, newValue.exp, type),
				newValue.usedVars
			)
		}
		BCast(value, from, to): {
			newValue = rec(value, withReturn);
			BExpUsedVars(BCast(reduceBCounter(newValue.exp), from, to), newValue.usedVars);
		}
		BCounter(): exp; // shouldn't happen
	}
}

dropBExpUsedVars(exp : BExpUsedVars, reuse : bool) -> BExpUsedVars {
	BExpUsedVars(if (reuse) BReuseValue(exp.exp) else BDropValue(exp.exp), exp.usedVars);
}

dupBExpUsedVars(exp : BExpUsedVars) -> BExpUsedVars {
	id = extractBVarId(exp.exp);
	if (id == "") {
		exp;
	} else if (!containsKeyTree(exp.usedVars, id)){
		BExpUsedVars(exp.exp, setTree(exp.usedVars, id, getBType(exp.exp)));
	} else {
		BExpUsedVars(BDupValue(exp.exp), exp.usedVars);
	}
}

extractBVarId(exp : BExp) -> string {
	switch (exp) {
		BVar(id, __) : id;
		BDupValue(value) : extractBVarId(value);
		BDropValue(value) : extractBVarId(value);
		BReuseValue(value) : extractBVarId(value);
		default : "";
	}
}

isBTypeFunction(type : BType) -> bool {
	switch (type) {
		BTypePar(__) : false;
		BTypeName(__, __) : false;
		BTypeFunction(__, __) : true;
	}
}

isReturnBType(type : BType) -> bool {
	switch (type) {
		BTypePar(__) : false;
		BTypeName(__, __) : false;
		BTypeFunction(__, returnType) : returnType != bvoidType;
	}
}

// TODO
isNativeWithoutDropFn(exp : BExp, generators : Set<string>) -> bool {
	switch (exp) {
		BVar(id, __) : containsSet(generators, id);
		default : false;
	}
}

reduceBCounter(counter : BCounter) -> BExp {
	if (optimization) {
	unquadruple(extractBExpFromBCounter(counter, 0, 0, false), \exp, dupCnt, dropCnt, reuse -> {
		cnt = min(dupCnt, dropCnt);
		reducedDupCnt = dupCnt - cnt;
		reducedDropCnt = dropCnt - cnt;
		newValue = fold(enumFromTo(1, reducedDupCnt), exp, \newExp, __ -> BDupValue(newExp));
		fold(enumFromTo(1, reducedDropCnt), newValue, \newExp, __ -> if (reuse) BReuseValue(newExp) else BDropValue(newExp));
	});
	} else counter;
}

extractBExpFromBCounter(exp : BExp, dupCnt : int, dropCnt : int, reuse : bool) -> Quadruple<BExp, int, int, bool> {
	switch (exp : BExp) {
		BDupValue(value) : extractBExpFromBCounter(value, dupCnt + 1, dropCnt, reuse);
		BDropValue(value) : extractBExpFromBCounter(value, dupCnt, dropCnt + 1, reuse);
		BReuseValue(value) : extractBExpFromBCounter(value, dupCnt, dropCnt + 1, true);
		default : Quadruple(exp, dupCnt, dropCnt, reuse);
	}
}

extractLastUsedVars(exp : BExpUsedVars, usedVars : Tree<string, BType>) -> Tree<string, BVar> {
	foldTree(exp.usedVars, makeTree(), \id : string, type : BType, acc -> 
		if (containsKeyTree(usedVars, id)) acc else setTree(acc, id, BVar(id, type))
	);
}

addBDropVars(exp : BExpUsedVars, vars : [BVar]) -> BExpUsedVars {
	if (vars == []) {
		exp;
	} else {
		BExpUsedVars(
			BSequence(
				arrayPush(map(vars, \v -> BDropValue(v)), exp.exp),
				getBType(exp.exp)
			),
			exp.usedVars
		);
	}
}

extractSwitchVar(exp : BExp, defType : BType) -> BVar {
	switch (exp) {
		BVar(id, t) : exp;
		BReuseValue(value) : extractSwitchVar(value, defType);
		default: BVar("", defType);
	}
}

// bind a variable to each data creation.
// this way we'll free memory immediately after checking the condition, and not at the end of the if/switch block.
extractConstructedVars(exp : BExp, resultType : BType, generators : Set<string>) -> Triple<[BVar], (BExp) -> BExp, BExp> {
	untriple(makeConstructedVars(exp, [], [], generators), \vars, lets, newExp -> {
		Triple(
			vars,
			\tail -> foldr(lets, tail, \acc, v -> BLet(v with body = acc)),
			either(newExp, exp)
		)
	})
}

tmpConstructedVarCounter = ref 1;
makeConstructedVars(exp : BExp, vars : [BVar], exps : [BLet], generators : Set<string>) -> Triple<[BVar], [BLet], Maybe<BExp>> {
	makeTmpVar = \varType, expType -> {
		varName = "_tmp_con" + i2s(atomicRefIntAddition(tmpConstructedVarCounter, 1));
		Triple([BVar(varName, varType)], [BLet(varName, exp, BVoid(), varType)], Some(BVar(varName, expType)));
	}
	switch (exp) {
		BConstruct(struct, args, type) : makeTmpVar(type, type);
		BCall(fn, args, type) : {
			newArgs = fold(args, Triple(vars, exps, []), \acc, a -> {
				v = makeConstructedVars(a, [], [], generators);
				Triple(concat(acc.first, v.first), concat(acc.second, v.second), arrayPush(acc.third, v.third));
			});
			newFn = makeConstructedVars(fn, [], [], generators);
			Triple(
				concat(newFn.first, newArgs.first),
				concat(
					eitherMap(
						newFn.third,
						\__ -> if (newFn.second == []) {
							[]
						} else {
							newValue = BCall(newFn.second[0].value, mapi(args, \i, arg -> either(newArgs.third[i], arg)), type);
							replace(newFn.second, 0, BLet(newFn.second[0] with value = newValue))
						},
						newFn.second
					),
					newArgs.second
				),
				eitherFn(
					newFn.third,
					\varFn -> Some(varFn),
					\-> Some(BCall(fn, mapi(args, \i, arg -> either(newArgs.third[i], arg)), type))
				)
			);
		}
		BField(value, fieldName, type) : {
			untriple(makeConstructedVars(value, vars, exps, generators), \newVars, lets, newExp -> {
				Triple(newVars, lets, Some(BField(either(newExp, value), fieldName, type)))
			});
		}
		BVar(id, type) : switch (type : BType) {
			BTypePar(__) : Triple([], [], None());
			BTypeName(__, __) : Triple([], [], None());
			BTypeFunction(__, returnType) : if (isNativeWithoutDropFn(exp, generators)) {
				Triple([], [], None())
			} else {
				makeTmpVar(returnType, type);
			}
		}
		default: Triple([], [], None());
	}
}

existsi(a : [?], fn : (int, ?) -> bool) -> bool {
	foundIndex = iteriUntil(a, \i, e -> fn(i, e));
	foundIndex != length(a);
}

addDupDropToCmpr(
	cond : BExpUsedVars,
	cases : [BExpUsedVars],
	type : BType,
	usedVars : Tree<string, BType>,
	generators : Set<string>,
	updateCond : (BExp, Tree<string, BType>) -> BExpUsedVars,
	updateExpr : (cond : BExp, cases : [BExp]) -> BExp,
) -> BExpUsedVars {

	// TODO: think about : 
	// Which is cheaper: create a variable and free the memory earlier, or not bind the variable and let c++ do it itself?
	condTmpVars : Triple<[BVar], (BExp) -> BExp, BExp> = extractConstructedVars(cond.exp, type, generators);

	condUsedVars = extractLastUsedVars(cond, usedVars);
	caseUsedVars = map(cases, \c -> extractLastUsedVars(c, usedVars));
	caseUniqueUsedVars = mapi(caseUsedVars, \i, c -> foldTree(c, [], \id, var, acc -> 
		if (existsi(caseUsedVars, \j, c2 -> i != j && containsKeyTree(c2, id))) acc else arrayPush(acc, var)
	));
	condUniqueUsedVars = foldTree(condUsedVars, [], \id, var, acc -> 
		if (exists(caseUsedVars, \c -> containsKeyTree(c, id))) acc else arrayPush(acc, var)
	);

	// drop vars, that are last used in this If/Switch
	casesWithDrop = mapi(cases, \i, c -> 
		addBDropVars(c, concat(condUniqueUsedVars, foldi(caseUniqueUsedVars, condTmpVars.first, \j, acc, a -> if (i == j) acc else concat(acc, a))))
	);
	newCondUsedVars = fold(condTmpVars.first, cond.usedVars, \acc, cvar -> setTree(acc, cvar.id, cvar.type));
	fixedCond = updateCond(condTmpVars.third, newCondUsedVars);

	newExpr = updateExpr(reduceBCounter(fixedCond.exp), map(casesWithDrop, \c -> c.exp));
	BExpUsedVars(
		if (condTmpVars.first == []) {
			newExpr
		} else {
	// TODO: don't create a lambda
			condTmpVars.second(newExpr) // this is BLet -> lambda if var=if(...)
		},
		fold(cases, fixedCond.usedVars, \acc, c -> mergeTree(acc, c.usedVars))
	);
}