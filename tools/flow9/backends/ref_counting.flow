import tools/flow9/backends/bprogram;

export {
	addRefCounting(prog : BExpProgram) -> BExpProgram;
}

addRefCounting(prog : BExpProgram) -> BExpProgram {
	BExpProgram(prog with declarations = map(prog.declarations, refCountingBExpDeclaration));
}

refCountingBExpDeclaration(decl : BExpDeclaration) -> BExpDeclaration {
	switch (decl) {
		BGlobalVar(id, body, type): BGlobalVar(id, refCountingBExp(body), type);
		BExpFunction(id, args, body, type): BExpFunction(id, args, refCountingBExp(body), type);
		BExpNative(id, isio, type, nativeName): decl;
	}
}

refCountingBExp(exp : BExp) -> BExp {
	switch (exp) {
		BVoid() : exp;
		BBool(v) : exp;
		BInt(v) : exp;
		BDouble(v) : exp;
		BString(v): BDupValue(exp);
		BVar(id, type): BDupValue(exp);
		BArray(args, type): {
			BDupValue(BArray(map(args, refCountingBExp), type));
		}
		BLet(id, val, body, type): {
			BLet(id, refCountingBExp(val), refCountingBExp(body), type);
		}
		BLambda(args, body, type): {
			BLambda(args, refCountingBExp(body), type)
		}
		BCall(fn, args, type): {
			BCall(refCountingBExp(fn), map(args, refCountingBExp), type)
		}
		BIf(cond, then, else_, type): {
			BIf(refCountingBExp(cond), refCountingBExp(then), refCountingBExp(else_), type)
		}
		BSequence(exps, type): {
			BSequence(map(exps, refCountingBExp), type);
		}
		BSwitch(value, switchType, cases, defaultCase, type): {
			BSwitch(value, switchType, map(cases, \c -> BCase(c.id, refCountingBExp(c.body))), maybeMap(defaultCase, refCountingBExp), type)
		}
		BConstruct(struct, args, type): {
			BConstruct(struct, map(args, refCountingBExp), type);
		}
		BField(value, field, type): {
			BField(refCountingBExp(value), field, type);
		}
		BSetMutable(left, field, value, type): {
			BSetMutable(refCountingBExp(left), field, refCountingBExp(value), type)
		}
		BCast(value, from, to): {
			BCast(refCountingBExp(value), from, to)
		}
		BCounter(): exp; // shouldn't happen
	}
}