import tools/flow9/backends/bprogram;
import tools/flow9/bexp/type;

export {
	addRefCounting(prog : BExpProgram) -> BExpProgram;
}

addRefCounting(prog : BExpProgram) -> BExpProgram {
	BExpProgram(prog with declarations = map(prog.declarations, refCountingBExpDeclaration));
}

refCountingBExpDeclaration(decl : BExpDeclaration) -> BExpDeclaration {
	switch (decl) {
		BGlobalVar(id, body, type): BGlobalVar(id, refCountingBExp(body, makeSet()).first, type);
		BExpFunction(id, typars, args, body, type): {
			BExpFunction(id, typars, args, refCountingBExp(body, makeSet()).first, type);
		}
		BExpNative(id, isio, type, nativeName): decl;
	}
}

// TODO: optimization : dup(drop(dup(var))) -> dup(var)
refCountingBExp(exp : BExp, tails : Set<string>) -> Pair<BExp, Set<string>> {
	dup = \e -> {
		id = switch (e) {
			BVar(id, type) : id;
			default : "";
		}
		// TODO:
		Pair(BDupValue(e), tails);
		//if (id != "" && !containsSet(tails, id)) Pair(e, insertSet(tails, id)) else Pair(BDupValue(e), tails);
	}
	drop = unpairC(\e, newTails -> Pair(BDropValue(e), newTails));
	rec = \e -> refCountingBExp(e, tails);
	fnType = BTypeFunction([], BTypePar(""));
	isFn = \type -> isSameStructType(type, fnType);
	mapExpA = \args -> fold(args, Pair([], makeSet()), \acc, arg -> unpair(acc, \newArgs, newTails -> 
		unpair(rec(arg), \newArg, newTail -> Pair(arrayPush(newArgs, newArg), mergeSets(newTails, newTail)))
	));
	switch (exp) {
		BVoid() : Pair(exp, tails);
		BBool(v) : Pair(exp, tails);
		BInt(v) : Pair(exp, tails);
		BDouble(v) : Pair(exp, tails);
		BString(v): Pair(exp, tails); // TODO: ?? dup(exp);
		BVar(id, type): if (isFn(type)) Pair(exp, tails) else drop(dup(exp));
		BArray(args, type): {
			values = mapExpA(args);
			Pair(BArray(values.first, type), values.second);
			// TODO: dup(BArray(map(args, rec), type));
		}
		BLet(id, val, body, type): {
			newBody = rec(body);
			newValue = rec(val);
			dupExp = dup(BVar(id, getBType(val)));
			bodyWithDup = BSequence([dupExp.first, newBody.first], type);
			Pair(
				BLet(id, newValue.first, bodyWithDup, type),
				mergeSets(mergeSets(newBody.second, newValue.second), dupExp.second)
			);
		}
		BLambda(args, body, type): {
			unpair(rec(body), \newBody, newTails -> Pair(BLambda(args, newBody, type), newTails))
		}
		// BCall(fn : BExp, args : [BExp], type : BType);
		BCall(fn, args, type): {
			newFn = rec(fn);
			newArgs = fold(args, Pair([], makeSet()), \acc, arg -> unpair(acc, \newArgs, newTails -> 
				unpair(rec(arg), \newArg, newTail -> {
					// todo: pass newTail
					unpair(dup(newArg), \dupedArg, newTail2 ->
						Pair(arrayPush(newArgs, dupedArg), mergeSets(mergeSets(newTails, newTail), newTail))
					)
				})
			));
			Pair(BCall(newFn.first, newArgs.first, type), mergeSets(newFn.second, newArgs.second))
		}
		BIf(cond, then, else_, type): {
			newCond = rec(cond);
			newThen = rec(then);
			newElse = rec(else_);
			Pair(
				BIf(newCond.first, newThen.first, newElse.first, type),
				mergeSets(mergeSets(newCond.second, newThen.second), newElse.second)
			);
		}
		BSequence(exps, type): {
			// order? reverse
			values = mapExpA(exps);
			Pair(BSequence(values.first, type), values.second);
		}
		BSwitch(value, switchType, cases, defaultCase, type): {
			newCases = fold(cases, Pair([], makeSet()), \acc, case -> unpair(acc, \newArgs, newTails -> 
				unpair(rec(case.body), \newArg, newTail -> Pair(arrayPush(newArgs, BCase(case.id, newArg)), mergeSets(newTails, newTail)))
			));
			newDefCase = maybeMap(defaultCase, rec);
			Pair(
				BSwitch(value, switchType, newCases.first, maybeMap(newDefCase, firstOfPair), type),
				eitherMap(newDefCase, \c -> mergeSets(newCases.second, c.second), newCases.second)
			);
		}
		BConstruct(struct, args, type): {
			values = mapExpA(args);
			Pair(BConstruct(struct, values.first, type), values.second);
		}
		BField(value, field, type): {
			unpair(rec(value), \newValue, newTails -> Pair(BField(newValue, field, type), newTails))
		}
		BSetMutable(left, field, value, type): {
			newLeft = rec(left);
			newValue = rec(value);
			Pair(
				BSetMutable(newLeft.first, field, newValue.first, type),
				mergeSets(newLeft.second, newValue.second)
			)
		}
		BCast(value, from, to): {
			unpair(rec(value), \newValue, newTails -> Pair(BCast(newValue, from, to), newTails));
		}
		BCounter(): Pair(exp, tails); // shouldn't happen
	}
}