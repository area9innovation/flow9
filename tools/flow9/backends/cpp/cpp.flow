import tools/flow9/backends/link;
import tools/flow9/backends/back_eval;
import tools/flow9/backends/pretty;
import tools/flow9/backends/cpp/cpp_backend;
import tools/flow9/backends/type_hierarchy;
import tools/flow9/backends/utils;
import tools/flow9/backends/struct_ids;

/*

flowcpp flow9\flow9.flow -- file=demos/euler/euler1.flow cpp=euler1.cpp
g++ -std=c++2a euler1.cpp 2>out.flow
-I for path to flow9
g++ -std=c++2a /mnt/d/a9/flow9/demos/euler/euler8.cpp -o euler8 -I/mnt/d/a9/flow9/
*/

export {
	// Compiles the given flow path to C++ as a single string
	bmodule2cpp(cache : FlowCache, flowpath : string, shortenIds : bool) -> string;
}

bmodule2cpp(cache : FlowCache, flowpath : string, shortenIds : bool) -> string {
	bprogram2cpp(linkBProgram(cache, flowpath, shortenIds, cppBackendSpec()), flowpath);
}

bprogram2cpp(b : BProgram, flowpath : string) -> string {
	typeHierarchy = resolveBTypeHierarchy(b.structs, b.unions);

	unionTypes = flatUnionTypes(typeHierarchy.unionTypes);
	unionedStructs = splitUnionedStructs(unionTypes, typeHierarchy.unionedStructs, b.structs, b.unions);

	info = CppInfo(
		fold(b.declarations, makeSet(), \acc, d -> {
			insertSet(acc, d.id)
		}),
		makeStructIds(b.structs, b.unions),
		unionTypes,
		getStatFunctionTypes(b.declarations),
		values2treeEx(unionedStructs.second, \struct -> struct.struct.id, recursiveDStruct2recursiveStruct)
	);

	backend = cppBackend(info);
	// Structs in unions
	simpleUnionStructs = fold(unionedStructs.first, "", \acc, struct -> {
		acc + dstruct2cpp(backend, struct) + "\n"
	});
	unionStructs = fold(unionedStructs.second, simpleUnionStructs, \acc, struct -> {
		acc + recursiveDstruct2cpp(backend, struct, false) + "\n"
	});
	recursiveStructs = fold(unionedStructs.second, "", \acc, struct -> {
		acc + recursiveDstruct2cpp(backend, struct, true) + "\n"
	});
	unions = superglue(typeHierarchy.unions, \u : DUnion -> dunion2cpp(backend, u, info.unionTypes), "\n");
	structs = superglue(typeHierarchy.structs, \s : DStruct -> dstruct2cpp(backend, s), "\n");
	functions = map(b.declarations, \d : BDeclaration -> bdeclaration2cpp(backend, d));
	body = superglue(functions, firstOfPair, "\n");
	declarations = superglue(filter(functions, \p -> p.second != ""), secondOfPair, ";\n");

	// The backend keeps track of what requirements are used by the various
	// constructs used
	strReplace(
		"#include <cstdint>\n#include <variant>\n#include <functional>\n#include <any>\n#include <iostream>\n#include <memory>\n"
		// TODO: fix in the future path to flow9
		"#include \"" + "tools/flow9/backends/cpp/flow_natives.hpp\" \n"
		+ getBackendRequirements(backend) + "\n"
	//	+ "// RUNTIME\n"
	//	+ runtime + "\n"
		+ "// Structs for unions\n"
		+ unionStructs
		+ "// UNIONS\n"
		+ unions + "\n"
		+ "// RECURSIVE STRUCTURES\n"
		+ recursiveStructs + "\n"
		+ "// STRUCTS\n"
		+ structs + "\n"
		+ "// DECLARATIONS\n"
		+ declarations + ";\n"
		+ "// BODY\n"
		+ body
		// TODO: If flow_main returns int, do something else
		+ "int main() { flow_main(); return 0; }",
		"\t",
		"  "
	)
}

// TODO: filter fns in the correct order ?
// result : body, declaration
bdeclaration2cpp(backend : Backend<CppInfo>, d : BDeclaration) -> Pair<string, string> {
	// TODO: calculate form 'flow_natives.hpp' or cppBackendSpec()
	implementedNatives = buildSet([
		"flow_println",
		"flow_println2",
		"flow_quit",
		"flow_substring",
		"flow_isSameStructType",
		"flow_strlen",
		"flow_fold",
		"flow_log",
		"flow_exp",
		"flow_enumFromTo",
		"flow_map",
		"flow_filter",
		"flow_concat",
		"flow_getCharCodeAt",
		"flow_extractStruct",
		"flow_bitNot",
		"flow_bitAnd",
		"flow_bitOr",
		"flow_bitXor",
		"flow_bitShl",
		"flow_bitUshr",
		"flow_length",
		"flow_replace",
	]);
	makeTailCallBody = \body : BStatement, type -> {
		defaultReturn = if (type == bvoidType.id) {
			"";
		} else {
			blueprint(
				"%type% _defReturn;
return _defReturn;",
				["type", type,]
			);
		}
		blueprint(
			"bool _end;
do {
	_end = true;
	%body%
} while (!_end);
%return%",
			[
				"body", bstatement2cpp(backend, body, true),
				"return", defaultReturn,
			]
		)
	}
	switch (d) {
		BGlobalVar(id, body, type): {
			Pair(btype2cpp(backend, type) + " " + id + " = " + bexp2cpp(backend, body, true) + ";", "");
		}
		BStatFunction(id, args, body, tailCall, type): {
			if (id == "flow_i2s") {
				declaration = "std::u16string flow_i2s(int32_t flow_i)";
				Pair(
					blueprint(
						"
					%declaration% {
					  std::wstring_convert<std::codecvt_utf8_utf16<char16_t>,char16_t> convert;
					  return convert.from_bytes(std::to_string(flow_i));
					}
				",
						[ "declaration", declaration,]
					),
					declaration
				)
			} else if (id == "flow_i2d") {
				declaration = "double flow_i2d(int32_t flow_i)";
				Pair(
					blueprint(
						"
					%declaration% {
						return double(flow_i);
					}
				",
						[ "declaration", declaration,]
					),
					declaration
				)
			} else {
				polyvars = uniq(map(set2array(extractPolymorphism(makeSet(), type)),  \pv -> btype2cpp(backend, pv)));
				argtypes = getBArgTypes(type);
				returnType = btype2cpp(backend, getBReturnType(type));

				declaration = blueprint(
					"%polyvars%%returnType% %id%(%args%)",
					[
						"polyvars", {
							if (polyvars == []) ""
							else "template <" + superglue(polyvars, \pv -> "typename " + pv, ", ") + "> "
						},
						"id", id,
						// TODO: if (tailCall) byValue (as it is now) else byRef (add &)
						"args", supergluei(args, \i, arg -> {
							btype2cpp(backend, argtypes[i]) + " " + arg
						}, ", "),
						"returnType", returnType,
					]
				);

				Pair(
					blueprint(
						"
					%declaration% {
						%body%
					}
				",
						[
							"declaration", declaration,
							"body", if (tailCall) makeTailCallBody(body, returnType) else bstatement2cpp(backend, body, true)
						]
					),
					declaration
				)
			}
		}
		BExpNative(id, isio, type, nativeName): {
			if (containsSet(implementedNatives, id)) {
				Pair("", "")
			} else {
				Pair("// TODO: Native " + id, "");
			}
		}
	}
}

bstatement2cpp(backend : Backend<CppInfo>, s : BStatement, withReturn : bool) -> string {
	todo = \ -> {
		println("TODO C++ statement: " + toString(s));
		toString(s)
	}
	rec = \ss -> bstatement2cpp(backend, ss, withReturn);
	rece = \ee -> bexp2cpp(backend, ee, false);
	switch (s) {
		BIfStatement(cond, then, else_): {
			blueprint("
					if (%c%) {
						%then%
					} else {
						%else%
					}",
				[
					"c", rece(cond),
					"then", rec(then),
					"else", rec(else_),
			]);

		}
		BLetStatement(id, value, body): {
			"auto " + id + " = " + bexp2cpp(backend, value, false) + ";\n"
			+ bstatement2cpp(backend, body, withReturn);
		}
		BSetMutableStatement(left, field, value): todo();
		BReturnVoid(): "return;";
		BReturn(val): {
			type = getBType(val);
			(if (type == bvoidType || !withReturn) {
				""
			} else {
				"return ";
			}) + bexp2cpp(backend, val, false) + ";"
		}
		BTailCall(fn, args, values, type): {
			"_end = false;\n"
			+ supergluei(args, \i, arg -> {
				"auto __" + arg + " = " + rece(values[i])
			}, ";\n") + ";\n"
			+ supergluei(args, \i, arg -> {
				arg + " = " + "__" + arg
			}, ";\n") + ";"
		}
		BSequenceStatement(statements): {
			blueprint("
					{
						%exps%
					}",
				[
					"exps", supergluei(statements, \i, v -> bstatement2cpp(backend, v, i == length(statements) - 1), "\n"),
				]
			);

		}
		BSwitchStatement(expr, cases, type): {
			switchType = getBType(expr);
			caseIndexes = switchType2caseIndexes(switchType, backend);
			// cases should not be empty. otherwise let there be a crash.
			// cpp needs a default case in the 'return' case
			defaultCase = cases[0].body;
			blueprint("
					switch (%value%.index()) {
						%cases%
						%default%
					}",
				[
					"value", rece(expr),
					"cases", superglue(cases, \case : BCaseStatement -> {
						blueprint("
							case %id%: {
								%body%
								break;
							}",
							[
								"id", eitherMap(lookupTree(caseIndexes, case.id), i2s, ""),
								"body", rec(case.body),
							]);
					}, ";\n"),
					"default", "default: " + rec(defaultCase) + ";",
			]);
		}
	}
}


bexp2cpp(backend : Backend<CppInfo>, bexp : BExp, isGlobalExp : bool) -> string {
	rec = \ee -> bexp2cpp(backend, ee, false);
	switch (bexp) {
		BVoid(): "({})";
		BBool(v): if (v) "true" else "false";
		BInt(v): "int32_t(" + i2s(v) + ")";
		BDouble(v): double2string(v);
		BString(v): "std::u16string(u" + toString(v) + ")";
		BVar(id, type): {
			// add function argument types to help the —Å++ compiler with polymorphism
			// before : type12type2
			// after : type12type2<Type1,Type2>
			id + bVar2realFuncTypes(bexp, backend);
		}
		BLet(id, value, body, type): {
			blueprint("
				[%capture%]() {
					auto %id% = %value%;
					return %body%;
				}()", [
				"capture", if (isGlobalExp) "" else "&",
				"id", id,
				"value", rec(value),
				"body", rec(body),
			])
		}
		BIf(cond, then, else_, type): {
			blueprint("
					(%c%) ? (
						%then%
					) : (
						%else%
					)",
				[
					"c", rec(cond),
					"then", rec(then),
					"else", rec(else_),
			]);
		}
		BCall(fn, args, type): {
			produceBackendCall(backend, bexp, \a1, a2 -> bexp2cpp(a1, a2, isGlobalExp));
		}
		BLambda(args, body, type): {
			argtypes = getBArgTypes(type);
			returnType = btype2cpp(backend, getBReturnType(type));
			blueprint("
					%type%([%capture%](%args%) {
						%return% %body%;
					})",
				[
					"capture", if (isGlobalExp) "" else "&",
					"args", supergluei(args, \i, arg -> {
							btype2cpp(backend, argtypes[i]) + " " + arg
						}, ", "),
					"body", rec(body),
					"type", btype2cpp(backend, type),
					"return", if (returnType == bvoidType.id) "" else "return",
			]);
		}
		BSequence(exps, type): {
			blueprint("
					(%exps%)",
				[
					"exps", superglue(exps, rec, ", "),
			]);
		}
		BConstruct(struct, args, type): {
			blueprint(
				"(struct %struct%){%args%}",
				[
					"struct", if (args == []) struct else addTyparsToStruct(backend, type, struct),
					"args", superglue(args, rec, ", "),
				]
			);
		}
		BField(value, field, type): {
			blueprint("
					%value%.%field%",
				[
					"value", rec(value),
					"field", field,
			]);
		}
		BSetMutable(left, field, value, type): "TODO-set-mutable(" + rec(left) + "." + field + ", " + rec(value);
		BSwitch(value, switchType, allCases, defaultCaseM, type): makeBSwitchType(bexp, backend);
		BArray(args, type): {
			blueprint("%type%({ %args% })",
				[
					"type", btype2cpp(backend, type),
					"args", superglue(args, rec, ", "),
			]);
		}
		BCast(value, from, to): castBexp2cpp(backend, bexp);
	}
}

dunion2cpp(backend : Backend<CppInfo>, u : DUnion, unionTypes : Tree<string, [BType]>,) -> string {
	addTemplatesToStruct(
		mapConcat(u.types, \t -> t.typars),
		blueprint("
			using %name% = std::variant<%members%>;", [
				"name", u.id,
				"members", superglue(lookupTreeDef(unionTypes, u.id, []), \t : BType -> {
					btype2cpp(backend, t);
				}, ", ")
			]
		)
	);
}

dstruct2cpp(backend : Backend<CppInfo>, s : DStruct) -> string {
	dstruct2cppEx(backend, s, \__, type -> dtype2cpp(backend, type), "");
}

dstruct2cppEx(backend : Backend<CppInfo>, s : DStruct, argType2cpp : (int, DType) -> string, dstructFns : string) -> string {
	addTemplatesToStruct(
		map(s.structArgs, \arg -> arg.type),
		"struct " + s.id + "{"
		+ supergluei(s.structArgs, \i, sa -> {
			argType2cpp(i, sa.type) + " " + sa.id + ";"
		}, "; ")
		+ dstruct2id(backend, s) + ";" 
		+ dstructFns
		+ "};"
	);
}

recursiveDstruct2cpp(backend : Backend<CppInfo>, s : RecursiveDStruct, withBody : bool) -> string {
	if (withBody) {
		dstruct2cppEx(
			backend,
			s.struct,
			\ind, type -> {
				isRecursiveField = elementAt(s.recursiveArgs, ind, false);
				cppType = dtype2cpp(backend, type);
				if (isRecursiveField) "std::unique_ptr<" + cppType + ">" else cppType;
			},
			makeStructConstructors(backend, s)
		);
	} else {
		"struct " + s.struct.id + ";";
	}
}

addTemplatesToStruct(types : [DType], body : string) -> string {
	templates = makeStructTemplates(extractDTypes(types, []));
	if (templates == "") body else templates + "\n" + body;
}

makeStructTemplates(types : [DType]) -> string {
	parameters = uniq(filtermap(types, \type -> {
		parametr = bTypePar2cpp(dtype2btype(type));
		if (parametr == "") None() else Some(parametr) 
	}));
	if (parameters == []) {
		""
	} else {
		blueprint(
			"template <typename %types%>",
			["types", strGlue(parameters, ", typename ")]
		);
	}
}

extractDTypes(types : [DType], acc : [DType]) -> [DType] {
	if (types == []) {
		acc
	} else {
		children = mapConcat(types, \type -> 
			switch (type : DType) {
				DTypeName(__, typars, __): typars;
				DTypePar(__, __) : [];
				DTypeFunction(args, returnType, __): arrayPush(args, returnType);
			}
		);
		extractDTypes(children, concat(acc, types));
	}
}
addTyparsToStruct(backend : Backend<CppInfo>, type : BType, body : string) -> string {
	switch (type : BType) {
		BTypePar(id) : body;
		BTypeName(id, typars) : {
			if (typars == []) {
				body
			} else {
				blueprint(
					"%struct%<%types%>",
					[
						"struct", body,
						"types", superglue(typars, \tp -> btype2cpp(backend, tp), ", ")
					]
				);
			}
		}
		BTypeFunction(args, returnType) : body;
	}
}

dtype2cpp(backend : Backend<CppInfo>, type : DType) -> string {
	btype2cpp(backend, dtype2btype(type));
}

btype2cpp(backend : Backend<CppInfo>, btype : BType) -> string {
	switch (btype) {
		BTypePar(id): bTypeParId2cpp(id);
		BTypeName(id, typars): {
			if (id == "void") "void"
			else if (id == "bool" || id == "double") id
			else if (id == "int") { "int32_t" }
			else if (id == "string") { "std::u16string" }
			else if (id == "flow") "std::any"
			else if (id == "array") {
				"std::vector<" + btype2cpp(backend, typars[0]) + ">"
			} else if (id == "ref") {
				blueprint(
					"std::shared_ptr<%valueType%>",
					["valueType", btype2cpp(backend, typars[0]),]
				);
			} else if (trim2(id, "?") == "") {
				btype2cpp(backend, BTypePar(id));
			} else {
				id
				+ (if (typars != []) {
					"<" + superglue(typars, \tp -> btype2cpp(backend, tp), ", ") + ">"
				} else "")
			}
		}
		BTypeFunction(args, returnType): {
			"std::function<" + btype2cpp(backend, returnType)
			+ "(" + superglue(args, \tp -> btype2cpp(backend, tp), ", ") + ")>"
		}
	}
}

dstruct2id(backend : Backend<CppInfo>, s : DStruct) -> string {
	eitherMap(
		lookupTree(backend.info.structIds, s.id),
		\id -> getStructIdMember() + " = " + i2s(id),
		""
	);
}

getStructIdMember() -> string {
	" unsigned int _id";
}

makeBSwitchType(bexp : BSwitch, backend : Backend<CppInfo>) -> string {
	rec = \ee -> bexp2cpp(backend, ee, false);
	len = length(bexp.cases);
	expDefaultCase = bexp.defaultCase;

	if (len < 1) { // error
		""
	} else if (len < 6) { // if
		caseIndexes = switchType2caseIndexes(bexp.switchType, backend);
		// cases should not be empty. otherwise let there be a crash.
		defaultCase = expDefaultCase ?? expDefaultCase : bexp.cases[0].body;
		cases = expDefaultCase ?? bexp.cases : tail(bexp.cases);
		blueprint("
				%cases%(
					%default%
				)",
			[
				"cases", superglue(cases, \case -> {
					blueprint("
						(%value%.index() == %id%) ? (
							%body%
						) : ",
						[
							"value", rec(bexp.value),
							"id", eitherMap(lookupTree(caseIndexes, case.id), i2s, ""),
							"body", rec(case.body)
						]
					);
				}, ""),
				"default", " " + rec(defaultCase),
		]);
	} else { // switch + lambda
		caseIndexes = switchType2caseIndexes(bexp.switchType, backend);
		// cases should not be empty. otherwise let there be a crash.
		// cpp needs a default case in the 'return' case
		defaultCase = expDefaultCase ?? expDefaultCase : bexp.cases[0].body;
		blueprint("
				[&](int32_t ind){switch (ind) {
					%cases%
					%default%
				}}(%value%.index())",
			[
				"value", rec(bexp.value),
				"cases", superglue(bexp.cases, \case -> {
					blueprint("
						case %id%: {
							return %body%;
						}",
						[
							"id", eitherMap(lookupTree(caseIndexes, case.id), i2s, ""),
							"body", rec(case.body)
						]);
				}, ";\n"),
				"default", "default: return " + rec(defaultCase) + ";",
		]);
	}
}

switchType2caseIndexes(switchType : BType, backend : Backend<CppInfo>) -> Tree<string, int> {
	switch (switchType : BType) {
		BTypePar(__) : makeTree(); // error
		BTypeName(id, __) : {
			foldi(
				lookupTreeDef(backend.info.unionTypes, id, []),
				makeTree(),
				\i, acc, item : BType -> setTree(acc, bType2id(item), i)
			);
		}
		BTypeFunction(__, __) : makeTree(); // error
	}
}

isBExpStringValue(e : BExp) -> bool {
	switch (e : BExp) {
		BString(__) : true;
		default : false;
	}
}

// only for structs
castBexp2cpp(backend : Backend<CppInfo>, bcast : BCast) -> string {
	getStructTypeId = \type : BType -> 
		switch (type : BType) {
			BTypePar(__) : "";
			BTypeName(typeId, __) : if (containsKeyTree(backend.info.structIds, typeId)) typeId else "";
			BTypeFunction(__, __) : "";
		}

	isSubStruct = \unionId : string, subStructId : string -> {
		exists(lookupTreeDef(backend.info.unionTypes, unionId, []), \t : BType -> bType2id(t) == subStructId);
	}

	liftType = \value -> {
		blueprint(
			"(%type%)%value%",
			[
				"type", btype2cpp(backend, bcast.to),
				"value", value,
			]
		);
	}

	downType = \value -> {
		blueprint(
			"std::get<%type%>(%id%)",
			[
				"type", btype2cpp(backend, bcast.to),
				"id", value,
			]
		);
	}

	fromId = getStructTypeId(bcast.from);
	toId =  getStructTypeId(bcast.to);
	value = bexp2cpp(backend, bcast.value, false);

	if (fromId == "" || toId == "") {
		value;
	} else if (isSubStruct(fromId, toId)) {
		downType(value)
	} else if (isSubStruct(toId, fromId)) {
		liftType(value)
	} else {
		value;
	}
}

bTypePar2cpp(btype : BType) -> string {
	switch (btype) {
		BTypePar(id): bTypeParId2cpp(id);
		default: "";
	}
}

bTypeParId2cpp(id : string) -> string {
	// In C++, we use a, b, c, ...
	len = strlen(id) - 1;
	fromCharCode(getCharCodeAt("A", 0) + len);
}

flatUnionTypes(unionTypes : Tree<string, [DTypeName]>) -> Tree<string, [BType]> {
	mapTree(unionTypes, \subTypes -> flatUnions(subTypes, unionTypes, []));
}

flatUnions(types : [DTypeName], unionTypes : Tree<string, [DTypeName]>, acc : [BType]) -> [BType] {
	if (types == []) {
		acc
	} else {
		splittedTypes = fold2(types, acc, [], \structTypes, unionSubTypes, type -> {
			eitherFn(
				lookupTree(unionTypes, dType2id(type)),
				\subTypes -> Pair(structTypes, concat(unionSubTypes, subTypes)),
				\-> Pair(arrayPush(structTypes, dtype2btype(type)), unionSubTypes)
			)
		});
		flatUnions(splittedTypes.second, unionTypes, splittedTypes.first);
	}
}

bType2id(type : BType) -> string {
	switch (type : BType) {
		BTypePar(id) : id;
		BTypeName(id, __) : id;
		BTypeFunction(__, __) : "";
	}
}

dType2id(type : DType) -> string {
	switch (type : DType) {
		DTypeName(id, __, __) : id;
		DTypePar(id, __) : id;
		DTypeFunction(__, __, __) : "";
	}
}

getStatFunctionTypes(declarations : [BDeclaration]) -> Tree<string, BType> {
	// TODO: find a better way
	// native functions can have multiple implementations (polimorphic)
	// add fn to this array if it has only 1 implementation with template + std::function
	nativesWhiteList = buildSet([
		"flow_fold",
		"flow_map",
		"flow_filter",
		"flow_isSameStructType",
		"flow_extractStruct",
		"flow_replace",
	]);
	fold(declarations, makeTree(), \acc, decl -> {
		switch (decl) {
			BGlobalVar(id, body, type): acc;
			BStatFunction(id, args, body, tailCall, type): setTree(acc, id, type);
			BExpNative(id, isio, type, nativeName): if (containsSet(nativesWhiteList, id)) setTree(acc, id, type) else acc;
		}
	});
}

// find the type of function arguments
bVar2realFuncTypes(var : BVar, backend : Backend<CppInfo>) -> string {
	switch (var.type : BType) {
		BTypePar(__) : "";
		BTypeName(__, __) : "";
		BTypeFunction(args, returnType) : {
			eitherMap(
				lookupTree(backend.info.statFunctions, var.id),
				\statFuncType -> {
					switch (statFuncType : BType) {
						BTypePar(__) : "";
						BTypeName(__, __) : "";
						BTypeFunction(sfArgs, afReturnType) : {
							polyvars = extractPolyTypes(makeTree(), BTypeFunction(args, returnType), statFuncType);
							if (isEmptyTree(polyvars)) {
								""
							} else {
								"<" + strGlue(uniq(map(getTreeValues(polyvars), \pv -> btype2cpp(backend, pv))), ", ") + "> "
							}
						}
					}
				},
				""
			)
		}
	}
}

RecursiveDStruct(
	struct : DStruct,
	recursiveArgs : [bool], // len(recursiveArgs) = len(structArgs)
);

recursiveDStruct2recursiveStruct(struct : RecursiveDStruct) -> RecursiveStruct {
	RecursiveStruct(
		filtermapi(struct.struct.structArgs, \i, arg -> {
			isRecursiveField = elementAt(struct.recursiveArgs, i, false);
			if (isRecursiveField) Some(arg.id) else None()
			
		})
	)
}

splitUnionedStructs(unionTypes : Tree<string, [BType]>, unionedStructs : Tree<string, DStruct>, structs : Tree<string, DStruct>, unions : Tree<string, DUnion>,) -> Pair<[DStruct], [RecursiveDStruct]> {
	foldTree(unionedStructs, Pair([], []), \id, struct, acc -> {
		recFields = getRecursiveDStructureArgs(struct, structs, unions);
		if (exists(recFields, idfn)) {
			Pair(acc.first, arrayPush(acc.second, RecursiveDStruct(struct, recFields)))
		} else {
			Pair(arrayPush(acc.first, struct), acc.second)
		}
	});
}

getRecursiveDStructureArgs(
	struct : DStruct,
	allStructs : Tree<string, DStruct>,
	allUnions : Tree<string, DUnion>,
) -> [bool] {
	map(struct.structArgs, \arg -> 
		switch (arg.type : DType) {
			DTypeName(id, __, __) : {
				eitherFn(
					lookupTree(allStructs, id),
					\st -> isRecursiveDStructure(st.id, [st], [], allStructs, allUnions),
					\-> eitherMap(
						lookupTree(allUnions, id),
						\un -> isRecursiveDStructure(un.id, [], [un], allStructs, allUnions),
						false
					)
				)
			}
			DTypePar(id, __) : false;
			DTypeFunction(__, __, __) : false;
		}
	);
}

isRecursiveDStructure(
	structId : string,
	structs : [DStruct],
	unions : [DUnion],
	allStructs : Tree<string, DStruct>,
	allUnions : Tree<string, DUnion>,
) -> bool {
	structIds : [string] = mapConcat(structs, \struct -> filtermap(struct.structArgs, \arg -> 
		switch (arg.type : DType) {
			DTypeName(id, __, __) : Some(id);
			DTypePar(id, __) : None();
			DTypeFunction(__, __, __) : None();
		}
	));
	unionIds : [string] = mapConcat(unions, \union -> map(union.types, \arg -> arg.id));
	argIds = concat(structIds, unionIds);

	if (argIds == []) {
		false
	} else if (exists(argIds, \id -> id == structId)) {
		true
	} else {
		argStructs = filtermap(argIds, \id -> lookupTree(allStructs, id));
		argUnions = filtermap(argIds, \id -> lookupTree(allUnions, id));
		isRecursiveDStructure(structId, argStructs, argUnions, allStructs, allUnions)
	}
}

// TODO
makeStructConstructors(backend : Backend<CppInfo>, struct : RecursiveDStruct) -> string {	
	args = unzipi(struct.struct.structArgs, \i, arg -> elementAt(struct.recursiveArgs, i, false));
	simpleArgs = args.second;
	recArgs = args.first;
	copyConstructor = blueprint(
		"%type%(const %type%& a) {
		%simpleTypes%
		%recTypes%
	}",
		[
			"type", struct.struct.id,
			"simpleTypes", concatStrings(map(simpleArgs, \arg -> 
				blueprint(
					"%field% = a.%field%;\n",
					["field", arg.id]
				)
			)),
			"recTypes", concatStrings(map(recArgs, \arg -> 
				blueprint(
					"%field% = std::make_unique<%ptype%>(*a.%field%);\n",
					[
						"field", arg.id,
						"ptype", dtype2cpp(backend, arg.type)
					]
				)
			))
		]
	);
	initConstructor = blueprint(
		"%type%(%fields%) {
		%simpleTypes%
		%recTypes%
	}",
		[
			"type", struct.struct.id,
			"fields", superglue(
				struct.struct.structArgs,
				\arg -> blueprint(
					"%type% _%field%",
					[
						"field", arg.id,
						"type", dtype2cpp(backend, arg.type),
					]
				),
				", "
			),
			"simpleTypes", concatStrings(map(simpleArgs, \arg -> 
				blueprint(
					"%field% = _%field%;\n",
					["field", arg.id]
				)
			)),
			"recTypes", concatStrings(map(recArgs, \arg -> 
				blueprint(
					"%field% = std::make_unique<%ptype%>(_%field%);\n",
					[
						"field", arg.id,
						"ptype", dtype2cpp(backend, arg.type)
					]
				)
			))
		]
	);

	"\n" + initConstructor + "\n" + copyConstructor + "\n";
}