import tools/flow9/backends/link;
import tools/flow9/backends/back_eval;
import tools/flow9/backends/pretty;
import tools/flow9/backends/cpp/cpp_backend;
import tools/flow9/backends/type_hierarchy;
import tools/flow9/backends/utils;
import tools/flow9/backends/struct_ids;

/*

flowcpp flow9\flow9.flow -- file=demos/euler/euler1.flow cpp=euler1.cpp
g++ -std=c++2a euler1.cpp 2>out.flow
-I for path to flow9
g++ -std=c++2a /mnt/d/a9/flow9/demos/euler/euler8.cpp -o euler8 -I/mnt/d/a9/flow9/
*/

// Known issues:
//
// 1) Aliases
// Example :
// 1: Struct* a = new Struct();
// 2: Struct* b = a;
// -> drop(a); drop(b); If we miss the additional dup(a), there will be an attempt to double free the memory.
//
// 2) Struct inside Struct
// Example :
// 1: Struct* a = new Struct();
// 2: Struct2* b = new Struct2(a);
// -> drop(a); drop(b); If we miss the additional dup(a), there will be 1)wrong data in b; 2) an attempt to double free the memory.

export {
	// Compiles the given flow path to C++ as a single string
	bmodule2cpp(cache : FlowCache, flowpath : string, shortenIds : bool) -> string;
}

bmodule2cpp(cache : FlowCache, flowpath : string, shortenIds : bool) -> string {
	bprogram2cpp(linkBProgram(cache, flowpath, shortenIds, cppBackendSpec()), flowpath);
}

debugFlowMode = false;

bprogram2cpp(b : BProgram, flowpath : string) -> string {
	typeHierarchy = resolveBTypeHierarchy(b.structs, b.unions);
	unionTypes = flatUnionTypes(typeHierarchy.unionTypes);
	unionedStructs = splitUnionedStructs(unionTypes, typeHierarchy.unionedStructs, b.structs, b.unions);
	if (debugFlowMode) println(toString(b) + "\n");

	info = CppInfo(
		fold(b.declarations, makeSet(), \acc, d -> {
			insertSet(acc, d.id)
		}),
		makeStructIds(b.structs, b.unions),
		unionTypes,
		getStatFunctionTypes(b.declarations),
		values2treeEx(unionedStructs.second, \struct -> struct.struct.id, recursiveDStruct2recursiveStruct),
		makeUsedStructTypars(b.structs)
	);

	backend = cppBackend(info);
	// Structs in unions
	simpleUnionStructs = fold(unionedStructs.first, "", \acc, struct -> {
		acc + dstruct2cpp(backend, struct) + "\n"
	});
	unionStructs = fold(unionedStructs.second, simpleUnionStructs, \acc, struct -> {
		acc + recursiveDstruct2cpp(backend, struct, false) + "\n"
	});
	recursiveStructs = fold(unionedStructs.second, "", \acc, struct -> {
		acc + recursiveDstruct2cpp(backend, struct, true) + "\n"
	});
	methodRecursiveStructs = fold(unionedStructs.second, "", \acc, struct -> {
		acc 
		+ makeStructConstructors(backend, struct, true) + "\n" 
		+ makeStructDestructor(backend, struct, true) + "\n"
		+ makeStructOperators(backend, struct) + "\n"
	});
	unions = superglue(typeHierarchy.unions, \u : DUnion -> dunion2cpp(backend, u, info.unionTypes), "\n");
	structs = superglue(typeHierarchy.structs, \s : DStruct -> dstruct2cpp(backend, s), "\n");
	functions = map(b.declarations, \d : BDeclaration -> bdeclaration2cpp(backend, d));
	body = superglue(functions, firstOfPair, "\n");
	declarations = superglue(filter(functions, \p -> p.second != ""), secondOfPair, ";\n");

	// The backend keeps track of what requirements are used by the various
	// constructs used
	strReplace(
		"#inc" + "lude <cstdint>\n#include <functional>\n#include <iostream>\n#include <memory>\n#include <type_traits>\n"
		// TODO: fix in the future path to flow9
		+ "#inc" + "lude \"" + "tools/flow9/backends/cpp/flow_type.hpp\" \n"
		+ getBackendRequirements(backend) + "\n"
	//	+ "// RUNTIME\n"
	//	+ runtime + "\n"
		+ "// Structs for unions\n"
		+ unionStructs
		+ "// UNIONS\n"
		+ unions + "\n"
		+ "// RECURSIVE STRUCTURES\n"
		+ recursiveStructs + "\n"
		+ "// METHODS OF RECURSIVE STRUCTURES\n"
		+ methodRecursiveStructs + "\n"
		+ "// STRUCTS\n"
		+ structs + "\n"
		+ "// DECLARATIONS\n"
		+ declarations + ";\n"
		+ "// BODY\n"
		+ body
		// TODO: If flow_main returns int, do something else
		+ "int main() { flow_main(); return 0; }",
		"\t",
		"  "
	)
}

// TODO: filter fns in the correct order ?
// result : body, declaration
bdeclaration2cpp(backend : Backend<CppInfo>, d : BDeclaration) -> Pair<string, string> {
	// TODO: calculate form 'flow_natives.hpp' or cppBackendSpec()
	implementedNatives = getImplementedNatives();
	switch (d) {
		BGlobalVar(id, body, type): {
			Pair(btype2cpp(backend, type) + " " + id + " = " + bexp2cpp(backend, body, true, false, false, makeSet(), implementedNatives).first + ";", "");
		}
		BStatFunction(id, typars, args, body, tailCall, type): {
			if (id == "flow_i2s") {
				Pair("", "")
			} else if (id == "flow_i2d") {
				declaration = "double flow_i2d(int32_t flow_i)";
				Pair(
					blueprint(
						"
					%declaration% {
						return double(flow_i);
					}
				",
						[ "declaration", declaration,]
					),
					declaration
				)
			} else {
				polyvars = uniq(map(typars, \pv -> btype2cpp(backend, BTypePar(pv))));
				argtypes = getBArgTypes(type);
				breturnType = getBReturnType(type);
				isSimpleReturnType = isSimpleBType(breturnType);
				polyvarIds = fold(typars, buildSet(polyvars), insertSet);
				btypeFn2cpp = \btype -> btype2cppEx(backend, btype, \atype -> typars2cpp(atype.typars, \tp -> btype2cpp(backend, tp)), polyvarIds);
				returnType = btypeFn2cpp(breturnType);

				declaration = blueprint(
					"%polyvars%%returnType% %id%(%args%)",
					[
						"polyvars", {
							if (polyvars == []) ""
							else "template <" + superglue(polyvars, \pv -> "typename " + pv, ", ") + "> \n"
						},
						"id", id,
						"args", supergluei(args, \i, arg -> btypeFn2cpp(argtypes[i]) + " " + arg, ", "),
						"returnType", returnType,
					]
				);

				argIds = buildSet(args);
				fnBody = if (tailCall) {
					tailCallBody2cpp(backend, body, returnType, isSimpleReturnType, argIds, implementedNatives);
				} else {
					bstatement2cpp(backend, body, argIds, true, makeSet(), implementedNatives).first;
				}

				Pair(
					blueprint(
						"
					%declaration% {
						%body%
					}
				",
						[
							"declaration", declaration,
							"body", fnBody,
						]
					),
					declaration
				)
			}
		}
		BExpNative(id, isio, type, nativeName): {
			if (containsSet(implementedNatives, id)) {
				Pair("", "")
			} else {
				Pair("// TODO: Native " + id, "");
			}
		}
	}
}

tailCallBody2cpp(backend : Backend<CppInfo>, body : BStatement, type : string, simpleType : bool, fnArgs : Set<string>, nativeIds : Set<string>) -> string {
	defaultReturn = if (type == bvoidType.id) {
		"";
	} else if (simpleType) {
		blueprint(
			"%type% _defReturn;
return _defReturn;",
			["type", type,]
		);
	} else {
		blueprint(
			"%type%* _defReturn;
return *_defReturn;",
			["type", type,]
		);
	}

	recursiveBody = bstatement2cpp(backend, body, fnArgs, true, makeSet(), nativeIds).first;
	if (recursiveBody == "") {
		defaultReturn
	} else {
		blueprint(
			"bool _end;
do {
	_end = true;
	%body%
} while (!_end);
%return%",
			[
				"body", recursiveBody,
				"return", defaultReturn,
			]
		)
	}
}

bstatement2cpp(backend : Backend<CppInfo>, s : BStatement, fnArgs : Set<string>, withReturn : bool, lambdaIds : Set<string>, nativeIds : Set<string>) -> Pair<string, Set<string>> {
	todo = \ -> {
		println("TODO C++ statement: " + toString(s));
		Pair(toString(s), lambdaIds);
	}
	rec = \ss -> bstatement2cpp(backend, ss, fnArgs, withReturn, lambdaIds, nativeIds);
	rece = \ee -> bexp2cpp(backend, ee, false, false, false, lambdaIds, nativeIds);
	receLambda = \ee, newLambdaIds -> bexp2cpp(backend, ee, false, false, false, newLambdaIds, nativeIds);
	switch (s : BStatement) {
		BIfStatement(cond, then, else_): {
			Pair(
				blueprint("
						if (%c%) {
							%then%
						} else {
							%else%
						}",
					[
						"c", rece(cond).first,
						"then", rec(then).first,
						"else", rec(else_).first,
				]),
				lambdaIds
			);
		}
		BLetStatement(id, value, body): {
			valueType = getBType(value);
			valueVarId = getBVarId(value); // to check for aliases
			newLambdaIds = if (isBTypeFunction(valueType) && !containsKeyTree(backend.info.statFunctions, valueVarId) || containsSet(lambdaIds, valueVarId)) insertSet(lambdaIds, id) else lambdaIds;
			varType = if (!isSimpleBType(valueType)) btype2cpp(backend, valueType) else "auto";
			letCpp = varType + " " + id + " = " + bexp2cpp(backend, value, false, false, false, lambdaIds, nativeIds).first + ";\n"
					+ (if (debugFlowMode) "std::cout<<\"FN : &" + id + " = \"<< &" + id + " << \" : value=\" << " + id + " <<std::endl;\n" else "")
					+ bstatement2cpp(backend, body, fnArgs, withReturn, newLambdaIds, nativeIds).first;
			Pair(letCpp, newLambdaIds)
		}
		BSetMutableStatement(left, field, value): todo();
		BReturnVoid(): Pair("return;", lambdaIds);
		BReturn(val): {
			// TODO: replace reuse with drop , extract real value (isBConstruct)
			value = bexp2cpp(backend, val, false, false, false, lambdaIds, nativeIds).first + ";";
			returnCpp = if (!withReturn || getBType(val) == bvoidType || isSameStructType(val, BDropValue(BVoid()))) {
				value
			} else {
				"return " + value;
			}
			Pair(returnCpp, lambdaIds);
		}
		BTailCall(fn, args, values, type): {
			Pair(
				"_end = false;\n"
				+ foldi(args, Pair("", lambdaIds), \i, acc, arg -> {
					unpair(receLambda(values[i], acc.second), \valueCpp, newLambdaIds ->
						Pair(acc.first + "auto __" + arg + " = " + valueCpp + ";\n", newLambdaIds)
					)
				}).first
				+ supergluei(args, \i, arg -> arg + " = reuse(" + "__" + arg + ")", ";\n") + ";",
				lambdaIds
			)
		}
		BSequenceStatement(statements): {
			unpair(
				foldi(statements, Pair("", lambdaIds), \i, acc, v -> {
					unpair(
						bstatement2cpp(backend, v, fnArgs, i == length(statements) - 1, acc.second, nativeIds),
						\scpp, newLambdaIds -> Pair(acc.first + scpp + "\n", newLambdaIds)
					)
				}),
				\cppExp, newLambdaIds -> Pair(
					blueprint("
							{
								%exps%
							}",
						["exps", cppExp]
					),
					newLambdaIds
				)
			);
		}
		BSwitchStatement(expr, cases, type): {
			switchType = getBType(expr);
			caseIndexes = switchType2caseIndexes(switchType, backend);
			// cases should not be empty. otherwise let there be a crash.
			// cpp needs a default case in the 'return' case
			defaultCase = cases[0].body;
			Pair(blueprint("
					switch (%value%.index()) {
						%cases%
						%default%
					}",
				[
					"value", ("(*" + rece(expr).first + ")"),
					"cases", superglue(cases, \case : BCaseStatement -> {
						blueprint("
							case %id%: {
								%body%
								break;
							}",
							[
								"id", eitherMap(lookupTree(caseIndexes, case.id), i2s, ""),
								"body", rec(case.body).first,
							]);
					}, ";\n"),
					"default", "default: {" + (if (type == bvoidType) "" else rec(defaultCase).first) + ";break;}",
			]), lambdaIds);
		}
	}
}

// isCallFn  -> getValue(fn_ptr)()
// isArg -> create object for fn
bexp2cpp(backend : Backend<CppInfo>, bexp : BExp, isGlobalExp : bool, isCallFn : bool, isArg : bool, lambdaIds : Set<string>, nativeIds : Set<string>) -> Pair<string, Set<string>> {
	rec = \ee -> bexp2cpp(backend, ee, false, isCallFn, isArg, lambdaIds, nativeIds);
	rece = \ee, newLambdaIds -> bexp2cpp(backend, ee, false, isCallFn, isArg, newLambdaIds, nativeIds);
	switch (bexp) {
		BVoid(): Pair("", lambdaIds);
		BBool(v): Pair(if (v) "true" else "false", lambdaIds);
		BInt(v): Pair("int32_t(" + i2s(v) + ")", lambdaIds);
		BDouble(v): Pair(double2string(v), lambdaIds);
		BString(v): Pair("new _FlowString(u" + toString(v) + ")", lambdaIds);
		BVar(id, type): Pair(bvar2cpp(bexp, backend, isCallFn, isArg, containsSet(lambdaIds, id)), lambdaIds);
		BLet(id, value, body, type): {
			newLambdaIds = switch (value) {
				BLambda(__, __, __, __) : insertSet(lambdaIds, id);
				default : lambdaIds;
			}
			// TODO: don't create a lambda if BLet(BLet( ... BLet(BIf))) // ref_counting.flow
			Pair(blueprint("
				[%capture%]() {
					auto %id% = %value%;
					%debug%
					return %body%;
				}()", [
				"capture", if (isGlobalExp) "" else "&",
				"id", id,
				"value", rec(value).first,
				"body", bexp2cpp(backend, body, false, isCallFn, isArg, newLambdaIds, nativeIds).first,
				"debug", if (debugFlowMode) ("std::cout<<\"FN : &" + id + " = \"<< &" + id + " <<std::endl;") else "",
			]), newLambdaIds)
		}
		BIf(cond, then, else_, type): {
			Pair(blueprint("
					(%c%) ? (
						%then%
					) : (
						%else%
					)",
				[
					"c", rec(cond).first,
					"then", rec(then).first,
					"else", rec(else_).first,
			]), lambdaIds);
		}
		BCall(fn, args, type): {
			Pair(untriple(createTmpVars(backend, args, isGlobalExp, lambdaIds, nativeIds), \newStatements, newArgs, drops -> {
				createdTmpVars = newStatements != [];
				isComparison = isComparisonFn(fn);
				newBCall = BCall(fn, newArgs, type);
				isStructArg = \e -> exists(args, \a -> a == e) && !isSimpleBType(getBType(e));
				bcallExp2cpp = \newBackend, newExp -> {
					structArg = isStructArg(newExp);
					cppExp = bexp2cpp(newBackend, newExp, isGlobalExp, isCallFn || (fn == newExp), structArg, lambdaIds, nativeIds).first;
					// we have to compare values, not pointers
					if (isComparison && structArg) ("(*(" + cppExp + "))") else cppExp;
				}
				// TODO: find a better solution!!
				// and we only need lambda for BLetStatement
				if (createdTmpVars) {
					returnVarName = "_tmp" + i2s(atomicRefIntAddition(tmpVarCounter, 1));
					blueprint(
						if (type == bvoidType) "{\n%tmpVars% %body%;\n%drops%\n}"
						else " ([%capture%]() {\n	%tmpVars%auto %returnVarName% = %body%;\n	%drops%\n	return %returnVarName%;\n})()",
						[
							"capture", if (isGlobalExp) "" else "&",
							"tmpVars", concatStrings(newStatements),
							"body", produceBackendCall(backend, newBCall, bcallExp2cpp),
							"drops", if (isNativeFnWithoutDrop(fn)) concatStrings(map(drops, \v -> bexp2cpp(backend, v, isGlobalExp, false, false, lambdaIds, nativeIds).first+";")) else "",
							"returnVarName", returnVarName,
					]);
				} else {
					produceBackendCall(backend, newBCall, bcallExp2cpp)
				}
				// it works with linux, but not with VS
				/*(if (createdTmpVars) "({\n" else "")
				+ concatStrings(newStatements)
				+ produceBackendCall(backend, BCall(fn, newArgs, type), \newBackend, newExp -> bexp2cpp(newBackend, newExp, isGlobalExp))
				+ (if (createdTmpVars) ";\n})" else "")*/
			}), lambdaIds);
		}
		BLambda(args, body, type, capturedVars): {
			argtypes = getBArgTypes(type);
			returnBType = getBReturnType(type);
			returnType = btype2cpp(backend, returnBType);
			Pair(blueprint("
					new %type%(
						([%capture%](%args%)%returnType% {
							%return% %body%;
						})
						%capturedVars%
					)",
				[
					"capture", if (isGlobalExp) "" else "&",
					"args", supergluei(args, \i, arg -> {
						eitherMap(
							elementAtM(argtypes, i),
							\atype -> btype2cpp(backend, atype) + " ",
							"auto "
						) + arg
					}, ", "),
					"body", rec(body).first,
					"return", if (returnType == bvoidType.id) "" else "return",
					"returnType", if (returnType == bvoidType.id) "" else (" -> " + returnType),
					"type", rtrim2(btype2cppConstruct(backend, type), "*"), // TODO: fix btype2cppConstruct
					"capturedVars", if (capturedVars == []) {
										""
									} else {
										",[&]() {" + superglue(capturedVars, \v -> "dup("+ v + ");", " ") + "}, "
										+ "[&]() {" + superglue(capturedVars, \v -> "drop("+ v + ");", " ") + "}"
									}
			]), lambdaIds);
		}
		BSequence(exps, type): {
			lastInd = length(exps) - 1;
			unpair(
				foldi(exps, Pair("", lambdaIds), \i, acc, e -> {
					unpair(rece(e, acc.second), \cppExp, newLambdaIds -> {
						Pair(acc.first + cppExp + (if (i == lastInd || cppExp == "") "" else ", "), newLambdaIds)
					})
				}),
				\cppExp, newLambdaIds -> Pair(
					blueprint("
						(%exps%)",
						["exps", rtrim2(cppExp, ", ")]
					),
					newLambdaIds
				)
			);
		}
		BConstruct(struct, args, type): {
			Pair(blueprint(
				"new %struct%{%args%}",
				[
					"struct", addTyparsToStruct(backend, type, struct),
// TODO: don't dup userFn
					"args", superglue(args, \arg -> bexp2cpp(backend, arg, false, isCallFn, true, lambdaIds, nativeIds).first, ", "),
				]
			), lambdaIds);
		}
		BField(value, field, type): {
			structType = getBType(value);
			isSimpleStructType = !isSimpleBType(structType);
			isRecursiveField = eitherMap(
				lookupTree(backend.info.recursiveStructs, bType2id(structType)),
				\s -> containsSet(s.recursiveFields, field),
				false
			);
			Pair(blueprint("
				%ptr%%value%.%field%",
				[
					"value", rec(value).first + (if (isSimpleStructType) ")" else ""),
					"field", field,
					"ptr",  (if (isSimpleStructType) "(*" else "")
			]), lambdaIds);
		}
		BSetMutable(left, field, value, type): Pair("TODO-set-mutable(" + rec(left).first + "." + field + ", " + rec(value).first, lambdaIds);
		BSwitch(value, switchType, allCases, defaultCaseM, type): Pair(makeBSwitchType(bexp, backend, isCallFn, isArg, lambdaIds, nativeIds), lambdaIds);
		BArray(args, type): {
			Pair(blueprint("new %type%({ %args% })",
				[
					"type", btype2cppConstruct(backend, type),
					"args", superglue(args, \arg -> bexp2cpp(backend, arg, false, isCallFn, true, lambdaIds, nativeIds).first, ", "),
			]), lambdaIds);
		}
		BCast(value, from, to): castBexp2cpp(backend, bexp, isCallFn, isArg, lambdaIds, nativeIds);
		BDupValue(value) : bCounter2cpp(backend, bexp, isCallFn, isArg, lambdaIds, nativeIds);
		BDropValue(value) : bCounter2cpp(backend, bexp, isCallFn, isArg, lambdaIds, nativeIds);
		BReuseValue(value) : bCounter2cpp(backend, bexp, isCallFn, isArg, lambdaIds, nativeIds);
	}
}

dunion2cpp(backend : Backend<CppInfo>, u : DUnion, unionTypes : Tree<string, [BType]>,) -> string {
	argTypes = dtypes2parameters(mapConcat(u.types, \t -> t.typars)).first;
	structType2cpp = \type -> btype2cppEx(backend, type, \t -> typars2cpp(t.typars, \tp -> btype2cpp(backend, tp)), makeSet());
	addTemplatesToStruct(
		argTypes,
		blueprint(
			"using %name% = _FlowUnion<%members%>;\n",
			[
				"name", u.id,
				"members", superglue(lookupTreeDef(unionTypes, u.id, []), structType2cpp, ", "),
			]
		)
	)
	+ addTemplatesToStruct(
		argTypes,
		blueprint(
			"std::ostream& operator<<(std::ostream& os, const %name%%typar%& a){
				\tos << \"%name% [union type]\";
				\treturn os;
			}",
			[
				"name", u.id,
				"typar", makeTyparsForConstructorHeader(argTypes),
			]
		)
	);
}

dstruct2cpp(backend : Backend<CppInfo>, s : DStruct) -> string {
	argTypes = lookupTreeDef(backend.info.usedTypars, s.id, Pair([], [])).first;
	lastInd = length(s.structArgs) - 1;
	operatorPrint = addTemplatesToStruct(
		argTypes,
		blueprint(
			"std::ostream& operator<<(std::ostream& os, const %type%%typar%& a){
	os << \"%type%{\"; %fields% os <<\"}\";
	return os;
}\n",
			[
				"type", s.id,
				"typar", makeTyparsForConstructorHeader(argTypes),
				"fields", supergluei(
					s.structArgs,
					\i, a ->  "flow_print2(a." + a.id + "); " + (if (i == lastInd) "" else "os<<\", \";"),
					""
				)
			]
		)
	);

	recStruct = RecursiveDStruct(s, map(s.structArgs, \__ ->false));

	dstruct2cppEx(
		backend,
		s,
		\__, type -> dtype2cpp(backend, type),
		blueprint(
			"
			bool operator==(const %type%& a) const {return %equalFields%;}
			bool operator!=(const %type%& a) const {return %nequalFields%;}
			bool operator>(const %type%& a) const {return %gFields%;}
			bool operator<(const %type%& a) const {return %lFields%;}
			bool operator>=(const %type%& a) const {return %geFields%;}
			bool operator<=(const %type%& a) const {return %leFields%;}
			%destructor%
			%constructors%\n",
			[
				"type", s.id,
				"equalFields", makeEqualStructArgsBody(backend, s.structArgs, []),
				"nequalFields", makeNotEqualStructArgsBody(backend, s.structArgs, []),
				"gFields", makeGreaterStructArgsBody(backend, s.structArgs, []),
				"lFields", makeLessStructArgsBody(backend, s.structArgs, []),
				"leFields", makeLessEqStructArgsBody(backend, s.structArgs, []),
				"geFields", makeGreaterEqStructArgsBody(backend, s.structArgs, []),
				"constructors", makeStructConstructors(backend, recStruct, false),
				"destructor", makeStructDestructor(backend, recStruct, false),
			]
		)
	) + "\n"
	+ operatorPrint
	+ makeStructConstructors(backend, recStruct, true)
	+ makeStructDestructor(backend, recStruct, true)
	+ "\n";
}

dstruct2cppEx(backend : Backend<CppInfo>, s : DStruct, argType2cpp : (int, DType) -> string, dstructFns : string) -> string {
	addTemplatesToStruct(
		lookupTreeDef(backend.info.usedTypars, s.id, Pair([], [])).first,
		"struct " + s.id + "{"
		+ supergluei(s.structArgs, \i, sa -> {
			argType2cpp(i, sa.type) + " " + sa.id + ";"
		}, "; ")
		+ dstruct2id(backend, s)
		+ dstruct2counter(backend, s) + "\n"
		+ dstructFns
		+ dstruct2DupDropFields(s)
		+ "};\n"
	);
}

recursiveDstruct2cpp(backend : Backend<CppInfo>, s : RecursiveDStruct, withBody : bool) -> string {
	if (withBody) {
		overloadedOperators = blueprint(
			"%type%& operator=(const %type%& a);
	bool operator==(const %type%& a) const;
	bool operator!=(const %type%& a) const;
	bool operator>(const %type%& a) const;
	bool operator<(const %type%& a) const;
	bool operator>=(const %type%& a) const;
	bool operator<=(const %type%& a) const;
	",
			["type", s.struct.id,]
		);
		dstruct2cppEx(
			backend,
			s.struct,
			\ind, type -> dtype2cpp(backend, type),
			makeStructConstructors(backend, s, false) + "\n	"
			+ makeStructDestructor(backend, s, false) + "\n"
			+ overloadedOperators + "\n"
		);
	} else {
		addTemplatesToStruct(
			lookupTreeDef(backend.info.usedTypars, s.struct.id, Pair([], [])).first,
			"struct " + s.struct.id + ";"
		);
	}
}

addTemplatesToStruct(types : [string], body : string) -> string {
	templates = makeStructTemplates(types);
	if (templates == "") body else templates + "\n" + body;
}

dtypes2parameters(types : [DType]) -> Pair<[string], [bool]> {
	usedParams = map(types, \type -> {
		filtermap(extractDTypes([type], []), \dtype -> {
			parametr = bTypePar2cpp(dtype2btype(dtype));
			if (parametr == "") None() else Some(parametr) 
		})
	});

	Pair(uniq(concatA(usedParams)), map(usedParams, \a -> a != []));
}

makeStructTemplates(parameters : [string]) -> string {
	if (parameters == []) {
		""
	} else {
		blueprint(
			"template <typename %types%>",
			["types", strGlue(parameters, ", typename ")]
		);
	}
}

extractDTypes(types : [DType], acc : [DType]) -> [DType] {
	if (types == []) {
		acc
	} else {
		children = mapConcat(types, \type -> 
			switch (type : DType) {
				DTypeName(__, typars, __): typars;
				DTypePar(__, __) : [];
				DTypeFunction(args, returnType, __): arrayPush(args, returnType);
			}
		);
		extractDTypes(children, concat(acc, types));
	}
}

addTyparsToStruct(backend : Backend<CppInfo>, type : BType, structId : string) -> string {
	switch (type : BType) {
		BTypePar(id) : structId;
		BTypeName(id, typars) : {
			argTypes = lookupTreeDef(backend.info.usedTypars, structId, Pair([], [])); // TODO
			realTypars = filtermapi(argTypes.second, \i, isUsed -> if (isUsed) elementAtM(typars, i) else None());
			if (realTypars == []) {
				structId
			} else {
				blueprint(
					"%struct%<%types%>",
					[
						"struct", structId,
						"types", superglue(realTypars, \tp -> btype2cpp(backend, tp), ", "),
					]
				);
			}
		}
		BTypeFunction(args, returnType) : structId;
	}
}

dtype2cpp(backend : Backend<CppInfo>, type : DType) -> string {
	btype2cpp(backend, dtype2btype(type));
}

btype2cpp(backend : Backend<CppInfo>, btype : BType) -> string {
	btype2cppEx(
		backend,
		btype,
		\type -> {
			if (containsKeyTree(backend.info.unionTypes, type.id)) {
				typars2cpp(type.typars, \tp -> btype2cpp(backend, tp))
			} else {
				structWithParams = addTyparsToStruct(backend, type, type.id);
				takeAfter(structWithParams, type.id, structWithParams);
			}
		},
		makeSet()
	);
}

typars2cpp(typars : [BType], typar2cpp : (BType) -> string) -> string {
	if (typars != []) {
		"<" + superglue(typars, typar2cpp, ", ") + ">"
	} else {
		""
	}
}

btype2cppConstruct(backend : Backend<CppInfo>, btype : BType) -> string {
	rtrim2(
		btype2cppEx(
			backend,
			btype,
			\type -> typars2cpp(type.typars, \tp -> btype2cppConstruct(backend, tp)),
			makeSet()
		),
		"*"
	)
}

btype2cppEx(backend : Backend<CppInfo>, btype : BType, structTypars2cpp : (BTypeName) -> string, polyvars : Set<string>) -> string {
	isPolymorphicType = \type : BType -> containsSet(polyvars, bType2id(type));
	getPtr = \type -> if (!isSimpleBType(type) && !isPolymorphicType(type)) "*" else "";
	switch (btype) {
		BTypePar(id): bTypeParId2cpp(id);
		BTypeName(id, typars): {
			if (id == "void") "void"
			else if (id == "bool" || id == "double") id
			else if (id == "int") { "int32_t" }
			else if (id == "string") { "_FlowString" + getPtr(btype) }
			else if (id == "flow") { "_FlowType" + getPtr(btype) }
			else if (isArrayTypeId(id)) {
				"_FlowArray<" + btype2cppEx(backend, typars[0], structTypars2cpp, polyvars) + ">" + getPtr(btype)
			} else if (id == "ref") {
				blueprint(
					"std::shared_ptr<%valueType%>",
					["valueType", btype2cppEx(backend, typars[0], structTypars2cpp, polyvars),]
				);
			} else if (trim2(id, "?") == "") {
				btype2cppEx(backend, BTypePar(id), structTypars2cpp, polyvars);
			} else {
				id + structTypars2cpp(btype) + getPtr(btype)
			}
		}
		BTypeFunction(args, returnType): {
			fnType2cpptype(backend, btype, getPtr(btype) != "");
		}
	}
}

// TODO: polyvars ?
fnType2cpptype(backend : Backend<CppInfo>, type : BTypeFunction, withPtr : bool) -> string {
	// fnType2cpp = \type -> btype2cppEx(backend, type, structTypars2cpp, polyvars);
	fnType2cpp = \btype -> btype2cpp(backend, btype);
	"_FlowFunction<" + superglue(concat([type.returnType], type.args), fnType2cpp, ", ") + ">" 
	//  + getPtr(btype)
	+ (if (withPtr) "*" else "")
}

dstruct2id(backend : Backend<CppInfo>, s : DStruct) -> string {
	eitherMap(
		lookupTree(backend.info.structIds, s.id),
		\id -> " static const unsigned int _id = " + i2s(id) + ";",
		""
	);
}

dstruct2counter(backend : Backend<CppInfo>, s : DStruct) -> string {
	" int _counter = 1;"
}

dstruct2DupDropFields(s : DStruct) -> string {
	makeFn = \name, sa -> if (isSimpleBType(dtype2btype(sa.type))) "" else ("::" + name + "(" + sa.id + ");");
	blueprint(
		"void dupFields() {%dupFields%}
		void dropFields() {%dropFields%}
",
		[
			"type", s.id,
			"dupFields", superglue(s.structArgs, \sa -> makeFn("dup", sa), " "),
			"dropFields", superglue(s.structArgs, \sa -> makeFn("drop", sa), " "),
		]
	)
}

makeBSwitchType(bexp : BSwitch, backend : Backend<CppInfo>, isCallFn : bool, isArg : bool, lambdaIds : Set<string>, nativeIds : Set<string>) -> string {
	rec = \ee -> bexp2cpp(backend, ee, false, isCallFn, isArg, lambdaIds, nativeIds).first;
	len = length(bexp.cases);
	expDefaultCase = bexp.defaultCase;

	if (len < 1) { // error
		""
	} else if (len < 6) { // if
		caseIndexes = switchType2caseIndexes(bexp.switchType, backend);
		// cases should not be empty. otherwise let there be a crash.
		defaultCase = expDefaultCase ?? expDefaultCase : bexp.cases[0].body;
		cases = expDefaultCase ?? bexp.cases : tail(bexp.cases);
		blueprint("
				%cases%(
					%default%
				)",
			[
				"cases", superglue(cases, \case -> {
					blueprint("
						(%value%.index() == %id%) ? (
							%body%
						) : ",
						[
							"value", ("(*" + rec(bexp.value) + ")"),
							"id", eitherMap(lookupTree(caseIndexes, case.id), i2s, ""),
							"body", rec(case.body)
						]
					);
				}, ""),
				"default", " " + rec(defaultCase),
		]);
	} else { // switch + lambda
		caseIndexes = switchType2caseIndexes(bexp.switchType, backend);
		// cases should not be empty. otherwise let there be a crash.
		// cpp needs a default case in the 'return' case
		defaultCase = expDefaultCase ?? expDefaultCase : bexp.cases[0].body;
		blueprint("
				[&](int32_t ind){switch (ind) {
					%cases%
					%default%
				}}(%value%.index())",
			[
				"value", ("(*" + rec(bexp.value) + ")"),
				"cases", superglue(bexp.cases, \case -> {
					blueprint("
						case %id%: {
							return %body%;
						}",
						[
							"id", eitherMap(lookupTree(caseIndexes, case.id), i2s, ""),
							"body", rec(case.body)
						]);
				}, ";\n"),
				"default", "default: return " + rec(defaultCase) + ";",
		]);
	}
}

switchType2caseIndexes(switchType : BType, backend : Backend<CppInfo>) -> Tree<string, int> {
	switch (switchType : BType) {
		BTypePar(__) : makeTree(); // error
		BTypeName(id, __) : {
			foldi(
				lookupTreeDef(backend.info.unionTypes, id, []),
				makeTree(),
				\i, acc, item : BType -> setTree(acc, bType2id(item), i)
			);
		}
		BTypeFunction(__, __) : makeTree(); // error
	}
}

// only for structs
castBexp2cpp(backend : Backend<CppInfo>, bcast : BCast, isCallFn : bool, isArg : bool, lambdaIds : Set<string>, nativeIds : Set<string>) -> Pair<string, Set<string>> {
	value2cpp = \value -> bexp2cpp(backend, value, false, isCallFn, isArg, lambdaIds, nativeIds);

	liftType = \value  : BExp -> {
		newVal = replaceArrayType(value, bcast.to);
		unpair(value2cpp(newVal), \cppVal, newLambdaIds -> Pair(
			blueprint(
				if (newVal != value) "%value%" else "new %type%{%value%}",
				[
					"type", btype2cppConstruct(backend, bcast.to),
					"value", cppVal,
				]
			),
			newLambdaIds
		));
	}

	downType = \value : string -> {
		structId = getStructTypeId(bcast.to, backend.info.structIds);
		type = addTyparsToStruct(backend, bcast.to, structId);
		blueprint(
			"std::get<%type%>(%id%)",
			[
				"type", type + "*",
				"id", "*" + value,
			]
		);
	}

	switch (getBCastType(backend, bcast) : BCastType) {
		BCastUp() : liftType(bcast.value);
		BCastDown() : unpair(value2cpp(bcast.value), \v, newLambdaIds -> Pair(downType(v), newLambdaIds));
		BCastNone() : value2cpp(bcast.value);

	}
}

// only for structs
BCastType ::= BCastUp, BCastDown, BCastNone;
	BCastUp();
	BCastDown();
	BCastNone();

getBCastType(backend : Backend<CppInfo>, bcast : BCast) -> BCastType {
	isSubStruct = \unionId : string, subStructId : string -> {
		exists(lookupTreeDef(backend.info.unionTypes, unionId, []), \t : BType -> bType2id(t) == subStructId);
	}

	fromId = getStructTypeId(bcast.from, backend.info.structIds);
	toId =  getStructTypeId(bcast.to, backend.info.structIds);

	if (fromId == "" || toId == "") {
		BCastNone();
	} else if (isSubStruct(fromId, toId)) {
		BCastDown();
	} else if (isSubStruct(toId, fromId)) {
		BCastUp();
	} else {
		BCastNone();
	}
}

isArrayTypeId(id : string) -> bool {
	id == "array"
}

replaceArrayType(exp : BExp, type : BType) -> BExp {
	switch (exp : BExp) {
		BArray(args, oldType) : BArray(args, type);
		default : exp;
	}
}

getStructTypeId(type : BType, structIds : Tree<string, int>,) -> string {
	switch (type : BType) {
		BTypePar(__) : "";
		BTypeName(typeId, typars) : {
			if (isArrayTypeId(typeId) && typars != []) {
				getStructTypeId(typars[0], structIds)
			} else {
				if (containsKeyTree(structIds, typeId)) typeId else "";
			}
		}
		BTypeFunction(__, returnType) : "";
	}
}


bTypePar2cpp(btype : BType) -> string {
	switch (btype) {
		BTypePar(id): bTypeParId2cpp(id);
		default: "";
	}
}

bTypeParId2cpp(id : string) -> string {
	// In C++, we use a, b, c, ...
	len = strlen(id) - 1;
	fromCharCode(getCharCodeAt("A", 0) + len);
}

flatUnionTypes(unionTypes : Tree<string, [DTypeName]>) -> Tree<string, [BType]> {
	mapTree(unionTypes, \subTypes -> flatUnions(subTypes, unionTypes, []));
}

flatUnions(types : [DTypeName], unionTypes : Tree<string, [DTypeName]>, acc : [BType]) -> [BType] {
	if (types == []) {
		acc
	} else {
		splittedTypes = fold2(types, acc, [], \structTypes, unionSubTypes, type -> {
			eitherFn(
				lookupTree(unionTypes, dType2id(type)),
				\subTypes -> Pair(structTypes, concat(unionSubTypes, subTypes)),
				\-> Pair(arrayPush(structTypes, dtype2btype(type)), unionSubTypes)
			)
		});
		flatUnions(splittedTypes.second, unionTypes, splittedTypes.first);
	}
}

bType2id(type : BType) -> string {
	switch (type : BType) {
		BTypePar(id) : id;
		BTypeName(id, __) : id;
		BTypeFunction(__, __) : "";
	}
}

dType2id(type : DType) -> string {
	switch (type : DType) {
		DTypeName(id, __, __) : id;
		DTypePar(id, __) : id;
		DTypeFunction(__, __, __) : "";
	}
}

getStatFunctionTypes(declarations : [BDeclaration]) -> Tree<string, Pair<Maybe<[string]>, BType>> {
	nativesWhiteList = getPolymorphicNatives();
	fold(declarations, makeTree(), \acc, decl -> {
		switch (decl) {
			BGlobalVar(id, body, type): acc;
			BStatFunction(id, typars, args, body, tailCall, type): setTree(acc, id, Pair(Some(typars), type));
			BExpNative(id, isio, type, nativeName): if (containsSet(nativesWhiteList, id)) setTree(acc, id, Pair(None(), type)) else acc;
		}
	});
}

bvar2cpp(bexp : BVar, backend : Backend<CppInfo>, isCallFn : bool, isArg : bool, isLambda : bool) -> string {
	if (bexp.id == "__cast") {
		// From : __cast(flow_var)
		// To : flow_cast<TypeName>(flow_var)
		fromToType = switch (bexp.type : BType) {
			BTypePar(__) : Triple("", false, false);
			BTypeName(__, __) : Triple("", false, false);
			BTypeFunction(args, returnType) : Triple(
				btype2cpp(backend, returnType),
				containsKeyTree(backend.info.unionTypes, bType2id(returnType)),
				args != [] && containsKeyTree(backend.info.unionTypes, bType2id(args[0]))
			)
		}
		if (fromToType.first == "") {
			// something is wrong
			bexp.id
		} else {
			untriple(fromToType, \toType, isToUnion, isFromUnion -> blueprint(
				"%castFn%<%type%>",
				[
					"type", toType,
					"castFn", if (!isToUnion && isFromUnion) "flow_cast_variant" else "flow_cast",
				]
			))
		}
	} else {
		// add function argument types to help the с++ compiler with polymorphism
		// before : typeA2typeB
		// after : typeA2typeB<TypeA,TypeB>
		varId = bexp.id + bVar2realFuncTypes(bexp, backend);
		// TODO: optimization. polymorphism ?
		isNativeFn = \id -> containsSet(getImplementedNatives(), id);
		fnType = switch (bexp.type) {
			BTypePar(__) : None();
			BTypeName(__, __) : None();
			BTypeFunction(args, retType) : Some(BTypeFunction(args, retType));
		}

		if (isCallFn && isSome(fnType) && !isNativeFn(bexp.id)) {
			if (!isLambda && containsKeyTree(backend.info.statFunctions, bexp.id)) varId else ("(*" + varId + ")");
		} else if ((isArg || !isCallFn) && !isLambda && isSome(fnType) && (isNativeFn(bexp.id) || containsKeyTree(backend.info.statFunctions, bexp.id) )) {
			eitherMap(
				fnType,
				\t -> "new " + fnType2cpptype(backend, t, false) + "{" + varId + "}",
				varId
			)
		} else {
			varId;
		}
	}
}

// TODO: we somehow have to distinguish a lambda from a stat fn of the same name. lambda has no polyvars.
// (rename BVar = lambda ?)
// find the type of function arguments
bVar2realFuncTypes(var : BVar, backend : Backend<CppInfo>) -> string {
	polyvarType2cpp = if (containsSet(getPolymorphicNatives(), var.id)) {\type -> btype2cppConstruct(backend, type);} else {\type -> btype2cpp(backend, type);}
	switch (var.type : BType) {
		BTypePar(__) : "";
		BTypeName(__, __) : "";
		BTypeFunction(args, returnType) : {
			eitherMap(
				lookupTree(backend.info.statFunctions, var.id),
				unpairC(\polyvarsM, statFuncType -> {
					switch (statFuncType : BType) {
						BTypePar(__) : "";
						BTypeName(__, __) : "";
						BTypeFunction(sfArgs, sfReturnType) : {
							if (length(args) != length(sfArgs)) {
								""
							} else {
								polyvars = getTreeValues(extractPolyTypes(makeTree(), BTypeFunction(args, returnType), statFuncType));
								if (polyvars == []) {
									""
								} else {
									"<" + strGlue(map(polyvars, polyvarType2cpp), ", ") + "> "
								}
							}
						}
					}
				}),
				""
			)
		}
	}
}

RecursiveDStruct(
	struct : DStruct,
	recursiveArgs : [bool], // len(recursiveArgs) = len(structArgs)
);

recursiveDStruct2recursiveStruct(struct : RecursiveDStruct) -> RecursiveStruct {
	RecursiveStruct(
		foldi(struct.struct.structArgs, makeSet(), \i, acc, arg -> {
			isRecursiveField = elementAt(struct.recursiveArgs, i, false);
			if (isRecursiveField) insertSet(acc, arg.id) else acc
			
		})
	)
}

splitUnionedStructs(unionTypes : Tree<string, [BType]>, unionedStructs : Tree<string, DStruct>, structs : Tree<string, DStruct>, unions : Tree<string, DUnion>,) -> Pair<[DStruct], [RecursiveDStruct]> {
	foldTree(unionedStructs, Pair([], []), \id, struct, acc -> {
		recFields = getRecursiveDStructureArgs(struct, structs, unions);
		if (exists(recFields, idfn)) {
			Pair(acc.first, arrayPush(acc.second, RecursiveDStruct(struct, recFields)))
		} else {
			Pair(arrayPush(acc.first, struct), acc.second)
		}
	});
}

getRecursiveDStructureArgs(
	struct : DStruct,
	allStructs : Tree<string, DStruct>,
	allUnions : Tree<string, DUnion>,
) -> [bool] {
	map(struct.structArgs, \arg -> 
		switch (arg.type : DType) {
			DTypeName(id, __, __) : {
				eitherFn(
					lookupTree(allStructs, id),
					\st -> isRecursiveDStructure(st.id, [st], [], allStructs, allUnions),
					\-> eitherMap(
						lookupTree(allUnions, id),
						\un -> isRecursiveDStructure(un.id, [], [un], allStructs, allUnions),
						false
					)
				)
			}
			DTypePar(id, __) : false;
			DTypeFunction(__, __, __) : false;
		}
	);
}

isRecursiveDStructure(
	structId : string,
	structs : [DStruct],
	unions : [DUnion],
	allStructs : Tree<string, DStruct>,
	allUnions : Tree<string, DUnion>,
) -> bool {
	structIds : [string] = mapConcat(structs, \struct -> filtermap(struct.structArgs, \arg -> 
		switch (arg.type : DType) {
			DTypeName(id, __, __) : Some(id);
			DTypePar(id, __) : None();
			DTypeFunction(__, __, __) : None();
		}
	));
	unionIds : [string] = mapConcat(unions, \union -> map(union.types, \arg -> arg.id));
	argIds = concat(structIds, unionIds);

	if (argIds == []) {
		false
	} else if (exists(argIds, \id -> id == structId)) {
		true
	} else {
		argStructs = filtermap(argIds, \id -> lookupTree(allStructs, id));
		argUnions = filtermap(argIds, \id -> lookupTree(allUnions, id));
		isRecursiveDStructure(structId, argStructs, argUnions, allStructs, allUnions)
	}
}

makeStructCopyConstructorBody(backend : Backend<CppInfo>, simpleArgs : [DStructArg], recArgs : [DStructArg]) -> string {
	blueprint(
		"%simpleTypes%",
		[
			"simpleTypes", strGlue(map(concat(simpleArgs, recArgs), \arg -> 
				blueprint(
					"%field% = a.%field%;",
					["field", arg.id]
				)
			), "\n")
		]
	);
}

makeOperatorStructArgsBody(
	backend : Backend<CppInfo>,
	simpleArgs : [DStructArg],
	recArgs : [DStructArg],
	operator : string,
	function : string,
	anyField : bool, // true = OR, false = AND
) -> string {
	if (recArgs == [] && simpleArgs == []) {
		"true"
	} else {
		makeCompareValue = \id : string, type : DType, withPrefix : bool -> {
			simpleType = isSimpleBType(dtype2btype(type));
			if (function == "" || simpleType) {
				blueprint(
					"%prefix%%id% %operator% %prefix%a.%id%",
					[
						"id", id,
						"operator", operator,
						"prefix", if (withPrefix || !simpleType) "*" else "",
					]
				)
			} else {
				blueprint(
					"%fn%(%prefix%%id%, %prefix%a.%id%)",
					[
						"id", id,
						"fn", function,
						"prefix", if (withPrefix || !simpleType) "*" else "",
					]
				)
			}
		} 
		join = if (anyField) " || " else " && ";
		recursiveArgs = superglue(recArgs, \arg -> makeCompareValue(arg.id, arg.type, true), join);
		superglue(simpleArgs, \arg -> makeCompareValue(arg.id, arg.type, false), join)
		+ (if (recursiveArgs == "" || simpleArgs == []) "" else join)
		+ recursiveArgs;
	}
}

makeEqualStructArgsBody(backend : Backend<CppInfo>, simpleArgs : [DStructArg], recArgs : [DStructArg]) -> string {
	makeOperatorStructArgsBody(backend, simpleArgs, recArgs, "==", "areValuesEqual", false);
}

makeNotEqualStructArgsBody(backend : Backend<CppInfo>, simpleArgs : [DStructArg], recArgs : [DStructArg]) -> string {
	makeOperatorStructArgsBody(backend, simpleArgs, recArgs, "!=", "!areValuesEqual", true);
}

makeGreaterStructArgsBody(backend : Backend<CppInfo>, simpleArgs : [DStructArg], recArgs : [DStructArg]) -> string {
	makeOperatorStructArgsBody(backend, simpleArgs, recArgs, ">", "", true);
}
makeLessStructArgsBody(backend : Backend<CppInfo>, simpleArgs : [DStructArg], recArgs : [DStructArg]) -> string {
	makeOperatorStructArgsBody(backend, simpleArgs, recArgs, "<", "", true);
}
makeLessEqStructArgsBody(backend : Backend<CppInfo>, simpleArgs : [DStructArg], recArgs : [DStructArg]) -> string {
	"(" + makeEqualStructArgsBody(backend, simpleArgs, recArgs)
	+ ") || (" + makeLessStructArgsBody(backend, simpleArgs, recArgs) + ")"
}
makeGreaterEqStructArgsBody(backend : Backend<CppInfo>, simpleArgs : [DStructArg], recArgs : [DStructArg]) -> string {
	"(" + makeEqualStructArgsBody(backend, simpleArgs, recArgs)
	+ ") || (" + makeGreaterStructArgsBody(backend, simpleArgs, recArgs) + ")"
}

makeTyparsForConstructorHeader(argTypes : [string]) -> string {
	typeParams = strGlue(argTypes, ", ");
	if (typeParams == "") "" else "<" + typeParams + ">";
}

makeStructDestructor(backend : Backend<CppInfo>, struct : RecursiveDStruct, withBody : bool) -> string {
	if (withBody) {
		makeDropField = \field : DStructArg, simple : bool -> "::drop(" + field.id + ");";

		printField = \id -> "flow_print2(" + id + ")";
		isRecursiveField = \i -> elementAt(struct.recursiveArgs, i, false);
		structArgs = unzipi(struct.struct.structArgs, \i, arg -> isRecursiveField(i));
		isNotSimpleArgType = \arg -> !isSimpleBType(dtype2btype(arg.type));
		simpleArgs = filter(structArgs.second, isNotSimpleArgType);
		recArgs = filter(structArgs.first, isNotSimpleArgType);
		argTypes = lookupTreeDef(backend.info.usedTypars, struct.struct.id, Pair([], [])).first;

		destructor = blueprint(
			"%type%%typars%::~%type%(){\n"
			+ (if (debugFlowMode) "  std::cout << (_counter == 0 ? \"\" : \" !!ERROR!! \") << \" ~ destroy %type%(\"; %printFields%; std::cout<<\") counter=\"<<_counter<<\" &=\" << this <<\" ~ \"<<std::endl;\n" else "")
			+"%fields%
}",
			[
				"type", struct.struct.id,
				"typars", makeTyparsForConstructorHeader(argTypes),
				"printFields", supergluei(struct.struct.structArgs, \i, a -> printField(a.id), "; "),
				"fields", superglue(simpleArgs, \f -> makeDropField(f, true), "\n")
						+ (if (simpleArgs == []) "" else "\n")
						+ superglue(recArgs, \f -> makeDropField(f, false) + "\n", "\n")
						+ (if (recArgs == []) "" else "\n")
			]
		);
		addTemplatesToStruct(argTypes, destructor);
	} else {
		blueprint(
			"~%type%();",
			[
				"type", struct.struct.id,
			]
		)
	};
}

makeStructConstructors(backend : Backend<CppInfo>, struct : RecursiveDStruct, withBody : bool) -> string {
	if (withBody) {
		args = unzipi(struct.struct.structArgs, \i, arg -> elementAt(struct.recursiveArgs, i, false));
		simpleArgs = args.second;
		recArgs = args.first;
		initDeclaration = makeStructInitCtorDeclaration(backend, struct);
		copyDeclaration = makeStructCopyCtorDeclaration(struct);
		argTypes = lookupTreeDef(backend.info.usedTypars, struct.struct.id, Pair([], [])).first;
		typars = makeTyparsForConstructorHeader(argTypes);
		
		copyConstructor = blueprint(
			"%type%%typars%::%declaration% {
	%body%
}",
			[
				"type", struct.struct.id,
				"typars", typars,
				"declaration", copyDeclaration,
				"body", makeStructCopyConstructorBody(backend, simpleArgs, recArgs)
			]
		);
		initConstructor = if (initDeclaration == "") {
			""
		} else {
			blueprint(
				"%type%%typars%::%declaration% {
	%simpleTypes%
}",
				[
					"type", struct.struct.id,
					"typars", typars,
					"declaration", initDeclaration,
					"simpleTypes", strGlue(map(struct.struct.structArgs, \arg -> 
						blueprint(
							"%field% = _%field%;",
							["field", arg.id]
						)
					), "\n")
				]
			);
		}

		addTemplatesToStruct(argTypes, initConstructor) + "\n" + addTemplatesToStruct(argTypes, copyConstructor) + "\n";
	} else {
		"\n	" + makeStructInitCtorDeclaration(backend, struct)
		+ ";\n	" + makeStructCopyCtorDeclaration(struct)
		+ ";\n	" + makeStructDefConstructor(struct)
		+ ";\n" ;
	}
}

makeStructOperators(backend : Backend<CppInfo>, s : RecursiveDStruct) -> string {
	argTypes = lookupTreeDef(backend.info.usedTypars, s.struct.id, Pair([], [])).first;
	splittedArgs = unzipi(s.struct.structArgs, \i, arg -> elementAt(s.recursiveArgs, i, false));
	typars = makeTyparsForConstructorHeader(argTypes);

	copyOp = blueprint(
			"%type%%typar%& %type%%typar%::operator=(const %type%& a) {
	if (this != &a) {
		%copyFields%
	}
	return *this;
}",
		[
			"type", s.struct.id,
			"typar", typars,
			"copyFields", unpair(splittedArgs, \recArgs, simpleArgs -> makeStructCopyConstructorBody(backend, simpleArgs, recArgs)),
		]
	);
	// TODO: order
	printOperator = blueprint(
		"std::ostream& operator<<(std::ostream& os, const %type%%typar%& a){
    os << \"%type%{\"; %fields% os <<\"}\";
    return os;
}",
		[
			"type", s.struct.id,
			"typar", typars,
			"fields", unpair(splittedArgs, \recArgs, simpleArgs -> 
				superglue(simpleArgs, \a -> "flow_print2(a." + a.id + ");", "")
				+ superglue(recArgs, \a -> "flow_print2(*a." + a.id + ");", "")
			)
		]
	);

	makeOperator = \op : string, fn -> blueprint(
			"bool %type%%typar%::operator%op%(const %type%& a) const {
  return %cmpFields%;
}",
		[
			"op", op,
			"type", s.struct.id,
			"typar", typars,
			"cmpFields", unpair(splittedArgs, \recArgs, simpleArgs -> fn(backend, simpleArgs, recArgs)),
		]
	);

    addTemplatesToStruct(argTypes, copyOp) + "\n"
    + addTemplatesToStruct(argTypes, makeOperator("==", makeEqualStructArgsBody)) + "\n"
    + addTemplatesToStruct(argTypes, makeOperator("!=", makeNotEqualStructArgsBody)) + "\n"
    + addTemplatesToStruct(argTypes, makeOperator(">", makeGreaterStructArgsBody)) + "\n"
    + addTemplatesToStruct(argTypes, makeOperator("<", makeLessStructArgsBody)) + "\n"
    + addTemplatesToStruct(argTypes, makeOperator("<=", makeLessEqStructArgsBody)) + "\n"
    + addTemplatesToStruct(argTypes, makeOperator(">=", makeGreaterEqStructArgsBody)) + "\n"
    + addTemplatesToStruct(argTypes, printOperator) + "\n";
}

makeStructInitCtorDeclaration(backend : Backend<CppInfo>, struct : RecursiveDStruct) -> string {
	if (struct.struct.structArgs == []) {
		// we have the default constructor
		""
	} else {
		blueprint(
			"%type%(%fields%)",
			[
				"type", struct.struct.id,
				"fields", superglue(
					struct.struct.structArgs,
					\arg -> blueprint(
						"%type% _%field%",
						[
							"field", arg.id,
							"type", dtype2cpp(backend, arg.type),
						]
					),
					", "
				),
			]
		);
	}
}

makeStructCopyCtorDeclaration(struct : RecursiveDStruct) -> string {
	blueprint(
		"%type%(const %type%& a)",
		[
			"type", struct.struct.id,
		]
	);
}

makeStructDefConstructor(struct : RecursiveDStruct) -> string {
	blueprint(
		"%type%() = default",
		["type", struct.struct.id,]
	);
}

// supertype (union) can have templates, but struct can't
// TreeEmpty has no types in the following example:
//     Tree<?, ??> ::= TreeNode<?, ??>, TreeEmpty;
makeUsedStructTypars(structs : Tree<string, DStruct>) -> Tree<string, Pair<[string], [bool]>> {
	mapTree(structs, \struct -> {
		dtypes2parameters(map(struct.structArgs, \arg -> arg.type))
	})
}

// TODO: 
isSimpleBType(type : BType) -> bool {
	type == bvoidType || type  == bboolType || type  == bintType || type  == bdoubleType
}

// TODO: ignore simple types (remove all dup/drop/reuse) ?
bCounter2cpp(backend : Backend<CppInfo>, exp : BCounter, isCallFn : bool, isArg : bool, lambdaIds : Set<string>, nativeIds : Set<string>) -> Pair<string, Set<string>> {
	rec = \ee -> bexp2cpp(backend, ee, false, isCallFn, isArg, lambdaIds, nativeIds);
	extractValueFromBDup = \e -> switch (e : BCounter) {
		BDupValue(value) : value;
		BDropValue(__) : exp;
		BReuseValue(__) : exp;
	}
	extractCastUpFromExp = \e -> switch (e : BExp) {
		BCast(__, __, __) : if (getBCastType(backend, e) == BCastUp()) Some(e) else None();
		default : None();
	}
	bcounter2fnName = \-> switch (exp : BCounter) {
		BDupValue(__) : "dup";
		BDropValue(__) : "drop";
		BReuseValue(__) : "";
	}
	isRealFunction = \v : BVar -> {
		containsSet(nativeIds, v.id)
		|| !containsSet(lambdaIds, v.id) && containsKeyTree(backend.info.statFunctions, v.id);
	}

	value = exp.value;
	type = if (isVariableExp(value)) getBType(value) else getBReturnType(getBType(value));

	makeDefaultCppCounter = \-> {
		unpair(rec(value), \v, newLambdaIds -> Pair(
			blueprint(
				"%fn%(%val%)",
				[
					"fn", bcounter2fnName(),
					"val", v,
				]
			),
			newLambdaIds
		));
	}
	makeCppCounter = \dupValue -> eitherFn(
		dupValue,
		\e -> {
			expVar = getBVar(e);
			if (expVar.id != "" && isBTypeFunction(expVar.type)) {
				if (isCallFn) {
					unpair(rec(e), \v, newLambdaIds -> Pair(
						blueprint(
							"(%fn%->dupFields(), %val%)",
							[
								"val", v,
								"fn", expVar.id,
							]
						),
						newLambdaIds
					));
				} else if (isRealFunction(expVar)) {
					// ignore dup for real and native functions
					rec(e)
				} else {
					makeDefaultCppCounter()
				}
			} else {
				makeDefaultCppCounter()
			}
		},
		makeDefaultCppCounter
	);

	if (isSimpleBType(type)) {
		rec(value)
	// TODO: move to ref_counting ?
	// replace dup(liftType(val)) with liftType(dup(val)) // swap BCast and BDup
	} else {
		newVal = extractValueFromBDup(exp);
		if (newVal == exp) {
			makeCppCounter(None())
		} else {
			eitherFn(
				extractCastUpFromExp(newVal),
				\bcast -> bexp2cpp(backend, BCast(BDupValue(bcast.value), bcast.from, bcast.to), false, isCallFn, isArg, lambdaIds, nativeIds),
				\-> makeCppCounter(Some(newVal))
			)
		}
	}
}

// TODO: move to addRefCounting2BProgram() ?
//
// Test case #1: refcnt12.flow : test5() 
// fn3(Struct(v), end)
// tmp_var = Struct(v)
// Test case #1: refcnt17.flow : test8() 
// useVars8 = \v, v2 -> v;
// a = useVars8(Struct(8), Struct(11));
// tmp_var_1 = Struct(8);
tmpVarCounter = ref 0;
createTmpVars(backend : Backend<CppInfo>, args : [BExp], isGlobalExp : bool, lambdaIds : Set<string>, nativeIds : Set<string>) -> Triple<[string], [BExp], [BExp]> {
	newArgs = map(args, \arg -> {
		if (isBLet(arg)) { // temp vars
			Pair(Some(Pair("", BVoid())), arg); // ~= BCall
		} else if (isBConstruct(arg)) {
			varName = "_tmp" + i2s(atomicRefIntAddition(tmpVarCounter, 1));
			tmpVar = blueprint(
				"auto %varName% = %exp%;\n"
				+ (if (debugFlowMode) "std::cout<<\"FN : &%varName% = \"<< &%varName% <<std::endl;\n" else ""),
				[
					"varName", varName,
					"exp", bexp2cpp(backend, arg, isGlobalExp, false, true, lambdaIds, nativeIds).first,
				]
			);
			type = getBType(arg);
			dropTmpVar = BDropValue(BVar(varName, type));
			Pair(Some(Pair(tmpVar, dropTmpVar)), BVar(varName, type));
		} else {
			Pair(None(), arg);
		}
	});

	Triple(
		filtermap(newArgs, unpairC(\tmpVarM, __ -> maybeMap(tmpVarM, firstOfPair))),
		map(newArgs, secondOfPair),
		filtermap(newArgs, unpairC(\tmpVarM, __ -> maybeMap(tmpVarM, secondOfPair)))
	);
}

isBConstruct(exp : BExp) -> bool {
	switch (exp : BExp) {
		BArray(__, __) : true; // ?
		BConstruct(__, __, __) : true;
		BCast(value, __, __) : isBConstruct(value);
		default : false;
	}
}

getBVarId(exp : BExp) -> string {
	getBVar(exp).id;
}

getBVar(exp : BExp) -> BVar {
	switch (exp : BExp) {
		BVar(id, __) : exp;
		BCast(value, __, __) : getBVar(value);
		BReuseValue(value) : getBVar(value);
		BDropValue(value) : getBVar(value);
		BField(value, __, __) : getBVar(value);
		default : BVar("", bvoidType);
	}
}

isBCast(exp : BExp) -> bool {
	switch (exp : BExp) {
		BCast(value, __, __) : true;
		default : false;
	}
}

isVariableExp(exp : BExp) -> bool {
	switch (exp) {
		BVar(id, __) : id != "";
		BDupValue(value) : isVariableExp(value);
		BDropValue(value) : isVariableExp(value);
		BReuseValue(value) : isVariableExp(value);
		BCast(value, __, __) : isVariableExp(value);
		BField(value, __, __) : isVariableExp(value);
		default : false;
	}
}