native println2 : io (flow) -> void = Native.println;
Struct(v : int);
// ------------------------------------------------------------------------------------------
foo1() -> void {
	a = Struct(1); // dup(a)
	println2(a); // dup(a) // in println : drop(a)
	b = Struct(a.v + 2); // no dup(a) because this is the last use // in + : drop(a) // no dup(b) because this is the last use
}
// ------------------------------------------------------------------------------------------
fn2(a : Struct) -> Struct {
	c = a; // dup(a) // drop(a) inside '=' // dup(c)
	b = a; // no dup(a) because this is the last use // drop(a) inside '=' // no dup(b) because this is the last use 
	c; // dup(return_value) // no dup(c) because this is the last use // drop(c) 
	/*
		c;
		==
		tmp = c; // drop(c) // dup(tmp)
		return tmp;
	*/
}
foo2() -> void {
	i = Struct(12); // dup(i)
	fn2(i); // no dup(i) because this is the last use
	{}
}
// ------------------------------------------------------------------------------------------
// return = create a tmp var
fn3(a : Struct, c : Struct) -> Struct {
	b = a; // dup(a) // drop(a) inside '=' // no dup(b) because this is the last use
	// a; --> tmp = a; return tmp;
	a; // dup(return_value) // no dup(a) because this is the last use // drop(a) because Dangling/Hanging var = expr 
//  a + 1; --> tmp = a + 1; return tmp;
//  a + 1; // dup(return_value) // no dup(a) because this is the last use // in + : drop(a)
}
foo3() -> void {
	i = Struct(12); // dup(i)
	// TODO: variants:
	// 1) don't add dup() + fn(Type var) (without &)
	// 2) add tmp var. auto _tmp = ...; fn(dup(_tmp));
	v = fn3(i, Struct(5)); // no dup(i) because this is the last use // dup(v) // in fn3 drop(i)
	println2(v); // no dup(v) because this is the last use // in println drop(v)
}
// ------------------------------------------------------------------------------------------
foo4() -> void {
	a = 1;
	b = a + 2 + a * 5;
}
// ------------------------------------------------------------------------------------------
main() {
	println2("------------------------");
	println2("FOO 1");
	foo1();
	println2("------------------------");
	println2("FOO 2");
	foo2();
	println2("------------------------");
	println2("FOO 3");
	foo3();
	println2("------------------------");
	println2("FOO 4");
	foo4();
}
// ------------------------------------------------------------------------------------------


// TODO: 
// 1) dup(return_value) or not dup ?
// if the result of the fn is ignored. example : fn2 in foo2
// 2) unused arguments
// when to delete/drop? example : c in fn3()


/*

main() {
	foo();
}

+(a : string, b : string) -> string {
	dup(native_+(drop(a), drop(b));
}

*/
