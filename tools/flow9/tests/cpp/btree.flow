//import ds/tree;
//native println2 : io (?) -> void = Native.println;

/*// A binary tree with keys of type ? and values of type ??
Tree<?, ??> ::= TreeNode<?, ??>, TreeEmpty;
	TreeNode : (key : ?, value : ??, left : Tree<?, ??>, right : Tree<?, ??>, depth : int);
	TreeEmpty : ();

makeTree : () -> Tree<?, ??>;

	// Make a tree of one element
	makeTree1 : (key : ?, value : ??) -> TreeNode<?, ??>;

	lookupTree : (tree : Tree<?, ??>, key : ?) -> Maybe<??>;

makeTree() {
	TreeEmpty();
}

makeTree1(key, value) {
	TreeNode(key, value, TreeEmpty(), TreeEmpty(), 1);
}

lookupTree(set : Tree<?, ??>, key : ?) {
	switch (set : Tree) {
		TreeNode(k, v, l, r, depth):
			if (key < k) {
				lookupTree(l, key);
			} else if (key == k) {
				Some(v);
			} else {
				lookupTree(r, key);
			}
		TreeEmpty():
			None();
	}
}*/

Union ::= Struct, None;
Struct(v : int, link : Union);
None();
native extractStruct : (a : [?], e : ??) -> ?? = Native.extractStruct;
native i2s : (int) -> string = Native.i2s;
native println2 : io (?) -> void = Native.println;
i2s(i) { cast(i : int -> string); }

main() {

	u1 = Struct(1, Struct(2, None()));
	s1 = extractStruct([u1], Struct(0, None()));
	u2 = s1.link;
	s2 = extractStruct([u2], Struct(-1, None()));
	println2(s2.v);

	// TODO
	/*v = makeTree1(1, "1");

	println2(lookupTreeDef(v, 1, "-"));*/
}