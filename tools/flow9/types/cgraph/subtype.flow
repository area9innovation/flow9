import tools/flow9/types/cgraph/cgraph;
import tools/flow9/types/cgraph/unionmap;
import tools/flow9/types/ugraph/class;
import tools/flow9/types/cgraph/pretty;
import tools/flow9/types/ugraph/tmap;
import tools/flow9/types/typars;

export {
	// Find all subtypes of this (super) node
	makeSubtypeOverload(tmap : TMap, node : CNode, reason : ErrorReason) -> CNode;

	// Find all supertypes of this (sub)node. Constructs new eclasses as required
	makeSupertypeOverload(tmap : TMap, node : CNode, reason : ErrorReason) -> CNode;

	// Given a subtype, construct the corresponding supertype with the right type parameters
	makeSupertypeFromSub(tmap : TMap, sub : CName, super : string) -> int;
}

makeSubtypeOverload(tmap : TMap, node : CNode, reason0 : ErrorReason) -> CNode {
	todo = \ -> {
		println("TODO: Find all sub types of " + prettyCNode(tmap.cmap, node));
		node;
	}
	switch (node) {
		CEpsilon(): todo();
		CName(name, typars, reason): {
			subs = ^(tmap.resolveSubtypes)(name);
			if (subs == []) node
			else {
				nclass = findOrMakeCNode(tmap, node);
				subtypes = map(subs, \sub -> {
					makeSubtypeFromSuper(tmap, node, sub);
				});
				all = buildSet(arrayPush(subtypes, nclass));
				COverload(
					makeSet1(tmap.mkUnique()),
					all,
					node.reason
				)
			}
		}
		CFunction(args, return, reason): {
			// We just sub the child
			retNode = getUnionMapValue(tmap.cmap.cmap, return);
			subRet = makeSubtypeOverload(tmap, retNode, reason);
			subClass = findOrMakeCNode(tmap, subRet);
			CFunction(args, subClass, reason);
		}
		COverload(unique, options, reason): {
			// OK, here, we should arguably collect the total set of subtypes
			// and check if they are the same as the overload, in which case
			// we are all good already
			todo();
		}
	}
}

makeSupertypeOverload(tmap : TMap, node : CNode, reason0 : ErrorReason) -> CNode {
	todo = \ -> {
		println("TODO: Find all super types of " + prettyCNode(tmap.cmap, node));
		node;
	}
	switch (node) {
		CEpsilon(): todo();
		CName(name, typars, reason): {
			supers = ^(tmap.resolveSupertypes)(name);
			if (supers == []) node
			else {
				supertypes = map(supers, \super -> {
					makeSupertypeFromSub(tmap, node, super);
				});
				nclass = findOrMakeCNode(tmap, node);
				all = buildSet(arrayPush(supertypes, nclass));
				COverload(
					makeSet1(tmap.mkUnique()),
					all,
					node.reason
				)
			}
		}
		CFunction(args, return, reason): {
			returnNode = getUnionMapValue(tmap.cmap.cmap, return);
			if (returnNode != CEpsilon()) {
				// OK, find the supertype of the return type
				superReturn : CNode = makeSupertypeOverload(tmap, returnNode, reason0);
				if (superReturn != returnNode) {
					// We overload on the returntype somehow
					nclass = findOrMakeCNode(tmap, superReturn);
					CFunction(args, nclass, reason);
				} else node;
			} else {
				// OK, it is an unknown return type, so we should set up a type var
				// and subtype it
				supClass = makeTNodeClass(tmap);
				// subtypeCEClass(tmap, return, supClass, false, reason);
				CFunction(args, supClass, reason)
			}
		}
		COverload(unique, options, reason): {
			supers : Set<CNode> = mapSet(options, \op -> {
				super = getUnionMapValue(tmap.cmap.cmap, op);
				makeSupertypeOverload(tmap, super, reason);
			});
			// OK, join them all up
			superClasses = foldSet(supers, makeSet(), \acc, super -> {
				switch (super) {
					CEpsilon(): acc;
					CName(__, __, __): insertSet(acc, findOrMakeCNode(tmap, super));
					CFunction(__, __, __): insertSet(acc, findOrMakeCNode(tmap, super));
					COverload(__, opts, __): mergeSets(acc, opts);
				}
			});
			COverload(makeSet1(tmap.mkUnique()), superClasses, reason);
		}
	}
}

makeSupertypeFromSub(tmap : TMap, sub : CName, super : string) -> int {
	error = \ -> {
		println("ERROR: Could not make supertype " + super + " from " + prettyCNode(tmap.cmap, sub));
		node = CName(super, [], sub.reason);
		findOrMakeCNode(tmap, node);
	}	
	msuperdef = ^(tmap.resolveUnionName)(super);
	switch (msuperdef) {
		None(): error()
		Some(superdef): {
			mtypars = extractTyparsFromSubtype2(tmap, sub, super);
			switch (mtypars) {
				None(): error();
				Some(typars): {
					// TODO: Arguably, we should do subtypes for these typars
					node = CName(super, typars, sub.reason);
					findOrMakeCNode(tmap, node);
				}
			}
		}
	}
}

makeSubtypeFromSuper(tmap : TMap, super : CName, sub : string) -> int {
	error = \ -> {
		println("ERROR: Could not make " + sub + " from " + prettyCNode(tmap.cmap, super));
		node = CName(sub, [], super.reason);
		findOrMakeCNode(tmap, node);
	}
	msuperdef = ^(tmap.resolveUnionName)(super.name);
	switch (msuperdef) {
		None(): {
			error();
		}
		Some(superdef): {
			mtypars = extractTyparsFromSuper2(tmap, super, sub);
			switch (mtypars) {
				None(): {
					error();
				}
				Some(tps): {
					// TODO: Arguably, we should do subtypes for these typars
					node = CName(sub, tps, super.reason);
					findOrMakeCNode(tmap, node);
				}
			}
		}
	}
}


// This is basically identical to extractTyparsFromSubtype
extractTyparsFromSubtype2(tmap : TMap, sub : CName, super : string) -> Maybe<[int]> {
	def = \ -> {
		munion = ^(tmap.resolveUnionName)(super);
		switch (munion) {
			None(): {
				println("Not supposed to happen: Extract typars from non-union " + super + " to " + sub.name);
				None();
			}
			Some(union): {
				if (union.typars == []) Some([])
				else {
					stype : Maybe<DTypeName> = find(union.types, \tn -> tn.id == sub.name);
					stype ?? {
						// OK, we have the relation from the union to the struct in this union
						Some(extractTyparsFromSubTypeDTypename(union, stype, sub.typars))
					} : {
						// We could not find it, go look for it in the union members
						utypars = filtermap(union.types, \t : DTypeName -> {
							usubtypars = extractTyparsFromSubTypeDTypename(union, t, sub.typars);
							usub = CName(t.id, usubtypars, sub.reason);
							extractTyparsFromSubtype2(tmap, usub, super)
						});
						println("TODO: Look through the unions to find the right struct " + super);
						println(utypars);
						Some(sub.typars);
					}
				}
			}
		}
	};
	if (super == sub.name) {
		Some(sub.typars)
	} else {
		mstruct = ^(tmap.resolveStructName)(super);
		switch (mstruct) {
			None(): def();
			Some(struct): {
				if (struct.typars == []) Some([])
				else def();
			}
		}
	}
}

// This is basically identical to extractTyparsFromSuper
extractTyparsFromSuper2(tmap : TMap, super : CName, subname : string) -> Maybe<[int]> {
	def = \ -> {
		munion = ^(tmap.resolveUnionName)(super.name);
		switch (munion) {
			None(): {
				println("Not supposed to happen: Extract typars from non-union " + super.name + " to " + subname);
				None();
			}
			Some(union): {
				stype : Maybe<DTypeName> = find(union.types, \tn -> tn.id == subname);
				stype ?? {
					// OK, we have the relation from the union to the struct in this union
					Some(extractTyparsFromSuperDTypename(union, stype, super.typars));
				} : {
					// We could not find it, go look for it in the children
					println("TODO: Look through the unions to find the right struct " + prettyCNode(tmap.cmap, super) + " vs "  + subname);
					Some(super.typars);
				}
			}
		}
	};
	if (super.name == subname) {
		Some(super.typars)
	} else {
		mstruct = ^(tmap.resolveStructName)(subname);
		switch (mstruct) {
			None(): def();
			Some(struct): {
				if (struct.typars == []) Some([])
				else def();
			}
		}
	}
}
