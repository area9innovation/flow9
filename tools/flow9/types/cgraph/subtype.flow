import tools/flow9/types/cgraph/cgraph;
import tools/flow9/types/cgraph/unionmap;
import tools/flow9/types/ugraph/class;
import tools/flow9/types/cgraph/pretty;
import tools/flow9/types/ugraph/tmap;
import tools/flow9/types/typars;

export {
	// Find all subtypes of this (super) node
	makeSubtypeOverload(tmap : TMap, node : CNode, checkOnly : bool, reason : ErrorReason) -> Maybe<CNode>;

	// Find all supertypes of this (sub)node. Constructs new eclasses as required
	makeSupertypeOverload(tmap : TMap, node : CNode, reason : ErrorReason) -> Maybe<CNode>;

	// Given a subtype, construct the corresponding supertype with the right type parameters
	makeSupertypeFromSub(tmap : TMap, sub : CName, super : string) -> int;
}

makeSubtypeOverload(tmap : TMap, node : CNode, checkOnly : bool, reason0 : ErrorReason) -> Maybe<CNode> {
	switch (node) {
		CEpsilon(): None();
		CName(name, typars, reason): {
			subs = ^(tmap.resolveSubtypes)(name);
			if (subs == []) Some(node)
			else {
				subtypes = map(subs, \sub -> {
					makeSubtypeFromSuper(tmap, node, sub);
				});
				nclass = findCNode(tmap.cmap, node);
				if (nclass == -1) {
					println("Not Supposed to Happen. Could not find eclass for " + prettyCNode(tmap.cmap, node));
				}
				all = buildSet(arrayPush(subtypes, nclass));
				Some(COverload(
					if (checkOnly) makeSet() else makeSet1(tmap.mkUnique()),
					all,
					node.reason
				))
			}
		}
		CFunction(args, return, reason): {
			// We just sub the child
			retNode = getUnionMapValue(tmap.cmap.cmap, return);
			subRet = makeSubtypeOverload(tmap, retNode, checkOnly, reason);
			subRet ?? {
				subClass = if (checkOnly) findCNode(tmap.cmap, subRet) else findOrMakeCNode(tmap, subRet);
				if (subClass != -1) {
					Some(CFunction(args, subClass, reason));
				} else {
					None();
				}
			} : None();
		}
		COverload(unique, options, reason): {
			// OK, here, we should arguably collect the total set of subtypes
			// and check if they are the same as the overload, in which case
			// we are all good already
			None();
		}
	}
}

makeSupertypeOverload(tmap : TMap, node : CNode, reason0 : ErrorReason) -> Maybe<CNode> {
	switch (node) {
		CEpsilon(): None();
		CName(name, typars, reason): {
			supers = ^(tmap.resolveSupertypes)(name);
			if (supers == []) Some(node)
			else {
				supertypes = map(supers, \super -> {
					makeSupertypeFromSub(tmap, node, super);
				});
				nclass = findCNode(tmap.cmap, node);
				if (nclass == -1) {
					println("Not Supposed to Happen in Super. Could not find eclass for " + prettyCNode(tmap.cmap, node));
					None();
				} else {
					all = buildSet(arrayPush(supertypes, nclass));
					Some(COverload(
						makeSet1(tmap.mkUnique()),
						all,
						node.reason
					))
				}
			}
		}
		CFunction(args, return, reason): {
			returnNode = getUnionMapValue(tmap.cmap.cmap, return);
			if (returnNode != CEpsilon()) {
				// OK, find the supertype of the return type
				superReturn : Maybe<CNode> = makeSupertypeOverload(tmap, returnNode, reason0);
				superReturn ?? {
					supClass = findOrMakeCNode(tmap, superReturn);
					if (supClass != -1) {
						Some(CFunction(args, supClass, reason));
					} else {
						None();
					}
				} : {
					None();
				}
			} else {
				// OK, it is an unknown return type, so we should set up a type var
				// and subtype it. Or maybe just postpone it?
				None();
			}
		}
		COverload(unique, options, reason): {
			supers : Set<int> = foldSet(options, makeSet(), \acc, opt -> {
				super = getUnionMapValue(tmap.cmap.cmap, opt);
				msup = makeSupertypeOverload(tmap, super, reason);
				msup ?? {
					eclass = findOrMakeCNode(tmap, msup);
					insertSet(acc, eclass);
				} : insertSet(acc, -1);
			});
			if (containsSet(supers, -1)) {
				None()
			} else {
				Some(COverload(makeSet1(tmap.mkUnique()), supers, reason));
			}
		}
	}
}

makeSupertypeFromSub(tmap : TMap, sub : CName, super : string) -> int {
	error = \ -> {
		println("ERROR: Could not make supertype " + super + " from " + prettyCNode(tmap.cmap, sub));
		node = CName(super, [], sub.reason);
		findOrMakeCNode(tmap, node);
	}	
	msuperdef = ^(tmap.resolveUnionName)(super);
	switch (msuperdef) {
		None(): error()
		Some(superdef): {
			mtypars = extractTyparsFromSubtype2(tmap, sub, super);
			switch (mtypars) {
				None(): error();
				Some(typars): {
					// TODO: Arguably, we should do subtypes for these typars
					node = CName(super, typars, sub.reason);
					findOrMakeCNode(tmap, node);
				}
			}
		}
	}
}

makeSubtypeFromSuper(tmap : TMap, super : CName, sub : string) -> int {
	error = \ -> {
		println("ERROR: Could not make " + sub + " from " + prettyCNode(tmap.cmap, super));
		node = CName(sub, [], super.reason);
		findOrMakeCNode(tmap, node);
	}
	msuperdef = ^(tmap.resolveUnionName)(super.name);
	switch (msuperdef) {
		None(): {
			error();
		}
		Some(superdef): {
			mtypars = extractTyparsFromSuper2(tmap, super, sub);
			switch (mtypars) {
				None(): {
					error();
				}
				Some(tps): {
					// TODO: Arguably, we should do subtypes for these typars
					node = CName(sub, tps, super.reason);
					findOrMakeCNode(tmap, node);
				}
			}
		}
	}
}


// This is basically identical to extractTyparsFromSubtype
extractTyparsFromSubtype2(tmap : TMap, sub : CName, super : string) -> Maybe<[int]> {
	def = \ -> {
		munion = ^(tmap.resolveUnionName)(super);
		switch (munion) {
			None(): {
				println("Not supposed to happen: Extract typars from non-union " + super + " to " + sub.name);
				None();
			}
			Some(union): {
				if (union.typars == []) Some([])
				else {
					stype : Maybe<DTypeName> = find(union.types, \tn -> tn.id == sub.name);
					stype ?? {
						// OK, we have the relation from the union to the struct in this union
						Some(extractTyparsFromSubTypeDTypename(union, stype, sub.typars))
					} : {
						// We could not find it, go look for it in the union members
						utypars = filtermap(union.types, \t : DTypeName -> {
							usubtypars = extractTyparsFromSubTypeDTypename(union, t, sub.typars);
							usub = CName(t.id, usubtypars, sub.reason);
							extractTyparsFromSubtype2(tmap, usub, super)
						});
						println("TODO: Look through the unions to find the right struct " + super);
						println(utypars);
						Some(sub.typars);
					}
				}
			}
		}
	};
	if (super == sub.name) {
		Some(sub.typars)
	} else {
		mstruct = ^(tmap.resolveStructName)(super);
		switch (mstruct) {
			None(): def();
			Some(struct): {
				if (struct.typars == []) Some([])
				else def();
			}
		}
	}
}

// This is basically identical to extractTyparsFromSuper
extractTyparsFromSuper2(tmap : TMap, super : CName, subname : string) -> Maybe<[int]> {
	def = \ -> {
		munion = ^(tmap.resolveUnionName)(super.name);
		switch (munion) {
			None(): {
				println("Not supposed to happen: Extract typars from non-union " + super.name + " to " + subname);
				None();
			}
			Some(union): {
				stype : Maybe<DTypeName> = find(union.types, \tn -> tn.id == subname);
				stype ?? {
					// OK, we have the relation from the union to the struct in this union
					Some(extractTyparsFromSuperDTypename(union, stype, super.typars));
				} : {
					// We could not find it, go look for it in the children
					println("TODO: Look through the unions to find the right struct " + prettyCNode(tmap.cmap, super) + " vs "  + subname);
					Some(super.typars);
				}
			}
		}
	};
	if (super.name == subname) {
		Some(super.typars)
	} else {
		mstruct = ^(tmap.resolveStructName)(subname);
		switch (mstruct) {
			None(): def();
			Some(struct): {
				if (struct.typars == []) Some([])
				else def();
			}
		}
	}
}
