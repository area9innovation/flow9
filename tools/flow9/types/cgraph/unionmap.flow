import tools/flow9/types/ugraph/tmap;
import tools/flow9/types/cgraph/cgraph;
import tools/flow9/types/pretty;

import tools/flow9/types/ugraph/class;

export {
	findOrMakeCNodeClass(tmap : TMap, type : TType, reason : ErrorReason) -> int;
}

findOrMakeCNodeClass(tmap : TMap, type : TType, reason : ErrorReason) -> int {
	eclass = findTTypeInCMap(tmap.cmap, type);
	if (eclass != -1) {
		eclass;
	} else {
		nclass = makeTNodeClass(tmap);
		node = makeCNode(tmap, type, reason);
		setUnionMapValue(tmap.cmap.cmap, nclass, node);
		nclass;
	}
}

findTTypeInCMap(cmap : CMap, type : TType) -> int {
	todo = \ -> {
		println("TODO: Look for " + prettyTType(type));
		-1;
	}
	switch (type) {
		TTypeName(id, typars): {
			findUnionMap(cmap.cmap, \class, node : CNode -> {
				switch (node) {
					CEpsilon(): 
					CName(name, typars, reason): 
					CFunction(args, return, reason): 
					COverload(unique, options, reason): 
				}
			}, -1);
		}
		TTypeEClass(eclass): {
			findUnionMapRoot(cmap.cmap, eclass)
		}
		TTypeFunction(args, returnType): todo();
		TTypeOverload(unique, overloads): todo();
		TTypeSupertype(unique, subtypes, maxed): todo();
	}
}

// We know this type does not exist in the union map
makeCNode(tmap : TMap, type : TType, reason : ErrorReason) -> CNode {
	todo = \ -> {
		println("TODO: Make cnode for " + prettyTType(type));
		CEpsilon();
	}

	switch (type) {
		TTypeName(id, typars): {
			CName(id,
				map(typars, \tp -> {
					findOrMakeCNodeClass(tmap, tp, reason)
				}),
				reason
			);
		}
		TTypeEClass(eclass): todo();
		TTypeFunction(args, returnType): {
			// A function type
			CFunction(
				map(args, \arg -> {
					findOrMakeCNodeClass(tmap, arg, reason)
				}),
				findOrMakeCNodeClass(tmap, returnType, reason),
				reason
			);
		}
		TTypeOverload(unique, overloads): {
			/*
			// An overloaded type
			COverload(
				unique : Set<int>, 
				options : Set<CName>, 
				reason : ErrorReason
			);*/

			todo();
		}
		TTypeSupertype(unique, subtypes, maxed): todo();
	}
}
