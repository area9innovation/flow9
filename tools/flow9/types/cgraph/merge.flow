import tools/flow9/types/cgraph/cgraph;
import tools/flow9/types/cgraph/pretty;

export {
	// This propagates all info between these nodes, but does not unify them at the top level
	mergeCNodes(cmap : CMap, leftClass : int, left : CNode, rightClass : int, right : CNode, reason : ErrorReason) -> CNode;

	matchesCNode(cmap : CMap, left : CNode, right : CNode) -> bool;
}

mergeCNodes(cmap : CMap, leftClass : int, left : CNode, rightClass : int, right : CNode, reason : ErrorReason) -> CNode {
	if (right == CEpsilon() || right == left) left
	else {
		error = \r2 -> {
			println(
				joinReasons(reason,
					elaborateReason(r2, 
						prettyCNode(cmap, left) + " != " + prettyCNode(cmap, right)
					)
				)
			);
			left;
		};
		todo = \ -> {
			println("TODO: Merge " + prettyCNode(cmap, left) + " and " + prettyCNode(cmap, right));
			left;
		}
		switch (left) {
			CEpsilon(): right;
			CName(name, typars, nreason): {
				switch (right) {
					CName(rname, rtypars, rnreason): {
						if (name == rname) {
							if (length(typars) == length(rtypars)) {
								CName(
									name,
									mapi(typars, \i, typar -> {
										unionUnionMap(cmap.cmap, typar, rtypars[i], reason);
									}),
									joinReasons(nreason, rnreason)
								);
							} else todo();
						} else todo();
					}
					default: todo();
				}
			}
			CFunction(largs, lreturn, lreason): {
				switch (right) {
					CFunction(rargs, rreturn, rreason): {
						if (length(largs) == length(rargs)) {
							nargs = mapi(largs, \i, larg : int -> {
								unionUnionMap(cmap.cmap, larg, rargs[i], reason);
							});
							CFunction(
								nargs,
								unionUnionMap(cmap.cmap, lreturn, rreturn, reason),
								joinReasons(lreason, rreason)
							);
						} else {
							error(joinReasons(lreason, rreason));
						}
					}
					COverload(unique, options, oreason): {
						todo();
					}
					default: error(lreason);
				}
			}
			COverload(unique, options, oreason): {
				switch (right) {
					CEpsilon(): left;
					CName(name, typars, rreason): {
						println("TODO: Should we really merge " + prettyCNode(cmap, left) + " and " + prettyCNode(cmap, right));
						printCallstack();
						if (false) {
							matches = set2array(filterSet(options, \opt -> {
								onode = getUnionMapValue(cmap.cmap, opt);
								matchesCNode(cmap, onode, right);
							}));
							if (length(matches) != 1) {
								println("TODO: Merge result " + prettyCNode(cmap, right) + " into "  + prettyCNode(cmap, left));
							} else {
								unionUnionMap(cmap.cmap, rightClass, matches[0], oreason);
								{}
							}
						}
						// OK, restrict the options to this
						right;
					}
					CFunction(args, return, rreason): {
						todo();
					}
					COverload(runique, roptions, rreason): {
						// find the intersection
						todo();
					}
				}
			}
		}
	}
}

matchesCNode(cmap : CMap, left : CNode, right : CNode) -> bool {
	left == right || right == CEpsilon()
	|| switch (left) {
		CEpsilon(): true;
		CName(name, typars, reason): {
			switch (right) {
				CName(rname, rtypars, rreason): {
					name == rname && matchesEClasses(cmap, typars, rtypars);
				}
				default: false;
			}
		}
		CFunction(args, return, reason): {
			switch (right) {
				CFunction(rargs, rreturn, rreason): {
					matchesEClasses(cmap, args, rargs)
					&& matchesEClass(cmap, return, rreturn);
				}
				default: false;
			}
		}
		COverload(unique, options, reason): {
			false;
		}
	}
}

matchesEClasses(cmap : CMap, lclasses : [int], rclasses : [int]) -> bool {
	length(lclasses) == length(rclasses)
	&& forall(mapi(lclasses, \i, lc -> matchesEClass(cmap, lc, rclasses[i])), idfn)
}

matchesEClass(cmap : CMap, lclass : int, rclass : int) -> bool {
	l = getUnionMapValue(cmap.cmap, lclass);
	r = getUnionMapValue(cmap.cmap, rclass);
	matchesCNode(cmap, l, r)
}
