import tools/flow9/types/cgraph/cgraph;
import tools/flow9/types/cgraph/dtype;
import tools/flow9/types/cgraph/unionmap;
import tools/flow9/types/ugraph/tmap;
import tools/flow9/types/cgraph/subtype;
import tools/flow9/types/cgraph/merge;
import tools/flow9/types/pretty;

export {
	// When we know the type, find or make an eclass for this type
	resultCType(tmap : TMap, t : TType, reason : ErrorReason) -> TTypeEClass;

	// We know the result is a unification of these types
	unifyCType(tmap : TMap, left : TType, right : TType, checkOnly : bool, reason : ErrorReason) -> bool;
	unifyCEClass(tmap : TMap, lclass : int, rclass : int, checkOnly : bool, reason : ErrorReason) -> bool;

	// We know we have to subtype here - TODO: Figure out what the result is?
	// checkOnly defines whether we should update our types, or just do a check.
	// Returns true if this is possible.
	subtypeCType(tmap : TMap, subtype : TType, supertype : TType, checkOnly : bool, reason : ErrorReason) -> bool;
	subtypeCEClass(tmap : TMap, subClass : int, superClass : int, checkOnly : bool, reason : ErrorReason) -> bool;

	// When we have a DType, we use this one. Instantiates polymorphism
	dtype2CType(tmap : TMap, d : DType, reason : ErrorReason) -> TTypeEClass;
}

resultCType(tmap : TMap, t : TType, reason : ErrorReason) -> TTypeEClass {
	eclass = findOrMakeCNodeClass(tmap, t, reason);
	if (isTracingId(tmap.tracing, StageTypeInference(), 2, ^(tmap.topid))) {
		println("  Set " + prettyCEClass(tmap.cmap, eclass) + " = ttype " + prettyTType(t));
	}
	
	TTypeEClass(eclass);
}

unifyCType(tmap : TMap, left : TType, right : TType, checkOnly : bool, reason : ErrorReason) -> bool {
	lclass = findOrMakeCNodeClass(tmap, left, reason);
	rclass = findOrMakeCNodeClass(tmap, right, reason);
	res = unifyCEClass(tmap, lclass, rclass, checkOnly, reason);
	if (!res) {
		debugErrorReason(reason, ^cindent + "  TODO: Postpone " + prettyCEClass(tmap.cmap, lclass) + " with " + prettyCEClass(tmap.cmap, rclass) + ". ");
	}
	res;
}

cindent = ref "";

unifyCEClass(tmap : TMap, lclass : int, rclass : int, checkOnly : bool, reason : ErrorReason) -> bool {
	indent = ^cindent;
	if (isTracingId(tmap.tracing, StageTypeInference(), 1, ^(tmap.topid))) {
		debugErrorReason(reason, indent + "  Unify " + prettyCEClass(tmap.cmap, lclass) + " with " + prettyCEClass(tmap.cmap, rclass) + ". ");
		cindent := indent + "  ";
	}

	left : CNode = getUnionMapValue(tmap.cmap.cmap, lclass);
	right : CNode = getUnionMapValue(tmap.cmap.cmap, rclass);

	todo =  \ -> {
		debugErrorReason(reason, "TODO: Figure out how to unify " + prettyCEClass(tmap.cmap, lclass) + " with " + prettyCEClass(tmap.cmap, rclass) + ". ");
		false;
	}

	error = \ -> {
		debugErrorReason(reason, "ERROR: Could not unify " + prettyCEClass(tmap.cmap, lclass) + " with " + prettyCEClass(tmap.cmap, rclass) + ". ");
		false;
	}

	def = \ -> {
		if (!checkOnly) {
			root = unionUnionMap(tmap.cmap.cmap, lclass, rclass, reason);
			if (isTracingId(tmap.tracing, StageTypeInference(), 2, ^(tmap.topid))) {
				println(indent + "   to get root " + prettyCEClass(tmap.cmap, root));
			}
		}
		true;
	}

	join = \ -> {
		if (!checkOnly) {
			setUnionMapValue(tmap.cmap.cmap, lclass, right);
		}
		def();
	}

	res = switch (left) {
		CEpsilon(): def();
		CName(name, typars, lreason): {
			switch (right) {
				CEpsilon(): def();
				CName(rname, rtypars, rreason): {
					// TODO: Check that they are compatible
					if (name == rname) {
						if (length(typars) == length(rtypars)) {
							join();
							forall(
								mapi(typars, \i, typar -> {
									unifyCEClass(tmap, typar, rtypars[i], checkOnly, elaborateReason(reason, name + " arg#" + i2s(i + 1)));
								}),
								idfn
							);
						} else todo();
					} else error();
				}
				CFunction(args, return, rreason): error();
				COverload(unique, options, rreason): {
					unifyCOverload(tmap.cmap, rclass, right, left, checkOnly);
				}
			}
		}
		CFunction(args, return, lreason): {
			switch (right) {
				CEpsilon(): def();
				CName(name, typars, rreason): error();
				CFunction(rargs, rreturn, rreason): {
					if (length(args) == length(rargs)) {
						join();
						unifyCEClass(tmap, return, rreturn, checkOnly, elaborateReason(reason, "call ret"))
						&& forall(
							mapi(args, \i, typar -> {
								unifyCEClass(tmap, typar, rargs[i], checkOnly, elaborateReason(reason, "call arg#" + i2s(i + 1)));
							}),
							idfn
						);
					} else error();
				}
				COverload(unique, options, rreason): {
					unifyCOverloadFunction(tmap, rclass, right, lclass, left, checkOnly);
				}
			}
		}
		COverload(unique, options, lreason): {
			switch (right) {
				CEpsilon(): {
					if (!checkOnly) {
						setUnionMapValue(tmap.cmap.cmap, rclass, left);
					}
					true;
				}
				CName(name, typars, freason): unifyCOverload(tmap.cmap, lclass, left, right, checkOnly);
				CFunction(args, return, rreason): unifyCOverloadFunction(tmap, lclass, left, rclass, right, checkOnly);
				COverload(runique, roptions, rreason): todo();
			}
		}
	};
	cindent := indent;
	res;
}


unifyCOverload(cmap : CMap, overloadClass : int, overload : COverload, other : CNode, checkOnly : bool) -> bool {
	moverload = resolveCOverload(cmap, overload, other);
	moverload ?? {
		if (!checkOnly) {
			// println("  Reducing overload " + prettyCEClass(cmap, overloadClass) + " to " + prettyCNode(cmap, nover));
			setUnionMapValue(cmap.cmap, overloadClass, moverload);
		}
		true;
	} : false;
}

resolveCOverload(cmap : CMap, overload : COverload, other : CNode) -> Maybe<CNode> {
	options = foldSet(overload.options, makeSet(), \acc, opt -> {
		extractCNodes(cmap, opt, acc)
	});
	matches = filterSet(options, \opt -> {
		onode = getUnionMapValue(cmap.cmap, opt);
		matchesCNode(cmap, onode, other);
	});

	if (false) {
		println("TODO: Result of " + prettyCNode(cmap, overload) + " against " + prettyCNode(cmap, other) + " is");
		iterSet(matches, \match -> {
			println("  " + prettyCEClass(cmap, match));
		});
	}

	nmatches = sizeSet(matches);
	if (nmatches == 1) {
		class = set2array(matches)[0];
		winner = getUnionMapValue(cmap.cmap, class);
		Some(winner);
	} else {
		if (nmatches != 0) {
			Some(COverload(overload with options = matches));
		} else {
			None();
		}
	}
}

extractCNodes(cmap : CMap, class : int, acc : Set<int>) -> Set<int> {
	onode = getUnionMapValue(cmap.cmap, class);
	switch (onode) {
		CEpsilon(): insertSet(acc, class);
		CName(__, __, __): insertSet(acc, class);
		CFunction(__, __, __): insertSet(acc, class);
		COverload(uniques, options, reason): foldSet(options, acc, \acc2, ee -> extractCNodes(cmap, ee, acc2));
	}
}

unifyCOverloadFunction(tmap : TMap, overloadClass : int, overload : COverload, fnClass : int, fn : CFunction, checkOnly : bool) -> bool {
	cmap = tmap.cmap;
	options : Set<int> = foldSet(overload.options, makeSet(), \acc, opt -> {
		extractCNodes(cmap, opt, acc)
	});
	nodes : Set<CNode> = mapSet(options, \opt -> {
		getUnionMapValue(cmap.cmap, opt);
	});
	errors = ref false;
	fns : [CFunction] = filtermap(set2array(nodes), \node -> {
		error = \ -> {
			errors := true;
			None();
		}
		switch (node) {
			CEpsilon(): error();
			CName(name, typars, reason): error();
			CFunction(args, return, reason): {
				if (length(args) == length(fn.args)) {
					Some(node);
				} else None();
			}
			COverload(unique, __, reason): error();
		}
	});
	if (^errors) {
		println("ERROR: Could not resolve function overload " + prettyCNode(cmap, overload) + " vs " + prettyCNode(cmap, fn));
		false;
	} else {
		// OK, we have a bunch of functions. Deconstruct the args and returns
		// println("Verify function overload " + prettyCNode(cmap, overload) + " vs " + prettyCNode(cmap, fn));
		// Unify the args
		args : [int] = filtermapi(fn.args, \i, arg : int -> {
			argOptions : [int] = map(fns, \ofn -> ofn.args[i]);
			aoverload = COverload(overload.unique, buildSet(argOptions), overload.reason);
			argNode = getUnionMapValue(cmap.cmap, arg);
			// println("Result of " + prettyCNode(cmap, aoverload) + " vs " + prettyCNode(cmap, argNode));
			moverload = resolveCOverload(cmap, aoverload, argNode);
			switch (moverload) {
				None(): None();
				Some(ov): {
					// OK, merge the args
					nodeClass = findOrMakeCNode(tmap, ov);
					if (unifyCEClass(tmap, arg, nodeClass, checkOnly, overload.reason)) {
						Some(arg);
					} else None();
				}
			}
		});
		if (length(args) == length(fn.args)) {
			ret : COverload = COverload(overload.unique, buildSet(map(fns, \ofn -> ofn.return)), overload.reason);
			retNode = getUnionMapValue(cmap.cmap, fn.return);
			uret = resolveCOverload(cmap, ret, retNode);
			uret ?? {
				// OK, we have the ret type
				retClass = findOrMakeCNode(tmap, uret);
				if (unifyCEClass(tmap, fn.return, retClass, checkOnly, overload.reason)) {
					// and resolve the overload
					setUnionMapValue(cmap.cmap, overloadClass, CEpsilon());
					unionUnionMap(cmap.cmap, overloadClass, fnClass, overload.reason);
					true;
				} else false;
			} : {
				false;
			}
		} else {
			false;
		}
	}
}
 




subtypeCType(tmap : TMap, subtype : TType, supertype : TType, checkOnly : bool, reason : ErrorReason) -> bool {
	subClass = findOrMakeCNodeClass(tmap, subtype, reason);
	superClass = findOrMakeCNodeClass(tmap, supertype, reason);
	orig = prettyCEClass(tmap.cmap, subClass) + " with super " + prettyCEClass(tmap.cmap, superClass);
	res = subtypeCEClass(tmap, subClass, superClass, checkOnly, reason);

	if (res) {
		if (isTracingId(tmap.tracing, StageTypeInference(), 1, ^(tmap.topid))) {
			// debugErrorReason(reason, "  Subtype success " + orig + ". ");
			debugErrorReason(reason, "  Subtype success " + prettyCEClass(tmap.cmap, subClass) + " with super " + prettyCEClass(tmap.cmap, superClass) + ". ");
		}
	}
	res;
}

subtypeCEClass(tmap : TMap, subClass : int, superClass : int, checkOnly : bool, reason : ErrorReason) -> bool {
	sub : CNode = getUnionMapValue(tmap.cmap.cmap, subClass);
	super : CNode = getUnionMapValue(tmap.cmap.cmap, superClass);

	indent = ^cindent;
	if (isTracingId(tmap.tracing, StageTypeInference(), 2, ^(tmap.topid)) && !checkOnly) {
		debugErrorReason(reason, indent + "  Subtype " + prettyCEClass(tmap.cmap, subClass) + "\n" + indent + "    with  " + prettyCEClass(tmap.cmap, superClass) + ". ");
		cindent := indent + "  ";
	}

	error = \ -> {
		if (!checkOnly) {
			println("TODO: Report error on subtype " + prettyCNode(tmap.cmap, sub) + " vs "  + prettyCNode(tmap.cmap, super));
		}
		false;
	}

	postpone = \ -> {
		if (!checkOnly) {
			constraint = TConstraint(subClass, superClass, reason);
			tmap.cmap.constraints := Cons(constraint, ^(tmap.cmap.constraints));
		}
		true;
	}

	// If we have a subtype against an overload. I.e. name or function against overload
	subVsOverload = \ov : COverload -> {
		potentials = filterSet(ov.options, \opt : int -> {
			subtypeCEClass(tmap, subClass, opt, true, elaborateReason(reason, " overloads"));
		});
		npot = sizeSet(potentials);
		if (npot == 0) {
			error();
		} else if (npot == 1) {
			// OK, exactly one is possible.
			if (!checkOnly) {
				// We resolve the overload
				cand : int = set2array(potentials)[0];
				setUnionMapValue(tmap.cmap.cmap, superClass, CEpsilon());
				root = unionUnionMap(tmap.cmap.cmap, superClass, cand, reason);
				subtypeCEClass(tmap, subClass, cand, checkOnly, elaborateReason(reason, "resolve overload"));
			} else true;
		} else {
			if (sizeSet(ov.options) > npot) {
				// OK, it is at least reduced
				if (!checkOnly) {
					nover = COverload(ov with options = potentials);
					setUnionMapValue(tmap.cmap.cmap, superClass, nover);
					true;
				} else true;
			} else {
				postpone();
			}
		}
	}

	// overload vs name or function
	overloadVsSuper = \ov : COverload -> {
		potentials = filterSet(ov.options, \opt : int -> {
			subtypeCEClass(tmap, opt, superClass, true, reason);
		});
		npot = sizeSet(potentials);
		if (npot == 0) {
			error();
		} else if (npot == 1) {
			// OK, exactly one is possible.
			if (!checkOnly) {
				// We resolve the overload
				cand : int = set2array(potentials)[0];
				setUnionMapValue(tmap.cmap.cmap, subClass, CEpsilon());
				root = unionUnionMap(tmap.cmap.cmap, subClass, cand, reason);
				subtypeCEClass(tmap, cand, superClass, checkOnly, reason);
			} else true;
		} else {
			if (npot < sizeSet(ov.options)) {
				if (!checkOnly) {
					nover = COverload(ov with options = potentials);
					setUnionMapValue(tmap.cmap.cmap, subClass, nover);
					true;
				} else true;
			} else {
				postpone();
			}
		}
	}

	anyVsEpsilon = \ -> {
		if (!checkOnly) {
			moverload = makeSupertypeOverload(tmap, sub, reason);
			moverload ?? {
				setUnionMapValue(tmap.cmap.cmap, superClass, moverload);
			} : {
				postpone();
				{}
			}
		}
		true;
	};

	end = if (sub == CEpsilon() && super == CEpsilon()) {
		// OK, postpone
		postpone();
	} else if (isCFlow(sub) || isCFlow(super)) {
		true;
	} else {
		switch (sub) {
			CEpsilon(): {
				// OK, we should find all subtypes of super, and make an overload for those
				moverload = makeSubtypeOverload(tmap, super, checkOnly, reason);
				moverload ?? {
					if (!checkOnly) {
						setUnionMapValue(tmap.cmap.cmap, subClass, moverload);
					}
					true;
				} : {
					postpone();
				}
			}
			CName(name, typars, subreason): {
				switch (super) {
					CEpsilon(): anyVsEpsilon();
					CName(sname, stypars, supreason): {
						if (name == sname) {
							if (length(typars) == length(stypars)) {
								foldi(typars, true, \i, ok : bool, typar -> {
									ok && subtypeCEClass(tmap, typar, stypars[i], checkOnly, elaborateReason(reason, "typar #" + i2s(i + 1)));
								});
							} else {
								error();
							}
						} else {
							supers = ^(tmap.resolveSupertypes)(name);
							if (contains(supers, sname)) {
								// OK, lift the sub to the superworld, and do it there
								sub2super = makeSupertypeFromSub(tmap, sub, sname);
								subtypeCEClass(tmap, sub2super, superClass, checkOnly, elaborateReason(reason, "sub vs super"));
							} else {
								error();
							}
						}
					}
					CFunction(sargs, return, supreason): error();
					COverload(sunique, options, supreason): subVsOverload(super);
				}
			}
			CFunction(args, return, subreason): {
				switch (super) {
					CEpsilon(): anyVsEpsilon();
					CName(sname, stypars, supreason): error();
					CFunction(sargs, sreturn, supreason): {
						if (length(args) == length(sargs)) {
							foldi(args, true, \i, ok : bool, arg -> {
								ok && subtypeCEClass(tmap, sargs[i], arg, checkOnly, elaborateReason(reason, "arg #" + i2s(i + 1)));
							}) && subtypeCEClass(tmap, return, sreturn, checkOnly, elaborateReason(reason, "fn ret"));
						} else {
							error();
						}
					}
					COverload(sunique, options, supreason): subVsOverload(super);
				}
			}
			COverload(unique, options, subreason): {
				switch (super) {
					CEpsilon(): anyVsEpsilon();
					CName(__, __, __): overloadVsSuper(sub);
					CFunction(__, __, __): overloadVsSuper(sub);
					COverload(sunique, soptions, supreason): {
						// Find the supers that work for all subsets:
						supPotentials = filterSet(soptions, \sopt -> {
							forall(set2array(mapSet(options, \opt : int -> {
								subtypeCEClass(tmap, opt, sopt, true, reason);
							})), idfn)
						});
						if (isEmptySet(supPotentials)) {
							println("TODO: No super works for all subs, but probably something works for " + prettyCNode(tmap.cmap, sub) + " sub " + prettyCNode(tmap.cmap, super));
							postpone();
						} else {
							// OK, we have the list of supers that work.
							resSuper = if (sizeSet(supPotentials) == 1) {
								cand = set2array(supPotentials)[0];
								getUnionMapValue(tmap.cmap.cmap, cand);
							} else {
								COverload(sunique, supPotentials, supreason);
							};
							// println("Result of " + prettyCNode(tmap.cmap, sub) + " sub " + prettyCNode(tmap.cmap, super) + " is " + prettyCNode(tmap.cmap, resSuper));
							if (!checkOnly) {
								setUnionMapValue(tmap.cmap.cmap, superClass, resSuper);
								subtypeCEClass(tmap, subClass, superClass, checkOnly, reason);
							} else true;
						}
					}
				}
			}
		}
	};

	cindent := indent;
	end;
}

dtype2CType(tmap : TMap, d : DType, reason : ErrorReason) -> TTypeEClass {
	tt = dtype2CType2(tmap, ref makeTree(), d);
	resultCType(tmap, tt, reason);
}

isCFlow(c : CNode) -> bool {
	switch (c) {
		CName(n, tp, __): n == "flow" && tp == [];
		default: false;
	}
}
