import tools/flow9/types/cgraph/cgraph;
import tools/flow9/types/cgraph/pretty;
import tools/flow9/types/ugraph/tmap;
import tools/flow9/types/pretty;
import tools/flow9/bexp/bexp;

export {
	// At the end, we use this to resolve the eclasses
	resolveCNodes(tmap : TMap) -> Tree<int, TType>;

	// After resolution, check if two eclasses are the same
	isSameEClassInCMap(tmap : TMap, eclass1 : int, eclass2 : int) -> bool;

	// Given the resolution map, and a given eclass, find the final type
	resolveCNode(tmap : TMap, eclasses : Tree<int, TType>, eclass : int) -> Maybe<BType>;
}

resolveCNodes(tmap : TMap) -> Tree<int, TType> {
	types = ref makeTree();
	visited : ref Set<int> = ref makeSet();
	iterUnionMap(tmap.cmap.cmap, \root, node -> {
		if (node == CEpsilon()) {

		} else {
			println("e" + i2s(root) + " = " + prettyCNode(tmap.cmap, node));
			mtype = resolveCNode(tmap, ^types, /*visited,*/ root);
			mtype ?? {
				// println(mtype);
			} : {}
		}
	});
	^types;
}

isSameEClassInCMap(tmap : TMap, eclass1 : int, eclass2 : int) -> bool {
	root1 = findUnionMapRoot(tmap.cmap.cmap, eclass1);
	root2 = findUnionMapRoot(tmap.cmap.cmap, eclass1);
	root1 == root2;
}

resolveCNode(tmap : TMap, eclasses : Tree<int, TType>, eclass : int) -> Maybe<BType> {
	root = findUnionMapRoot(tmap.cmap.cmap, eclass);
	mtype = lookupTree(eclasses, root);
	mtype ?? {
		println("TODO: Convert " + prettyTType(mtype) + " to btype");
		None();
	} : {
		val = getUnionMapValue(tmap.cmap.cmap, root);
		switch (val) {
			CEpsilon(): {
				println("TODO: Empty eclass " + i2s(eclass) + " as btype");
				None();
			}
			CName(name, typars, reason): {
				btypars = filtermap(typars, \tp -> {
					resolveCNode(tmap, eclasses, tp);
				});
				if (length(btypars) == length(typars)) {
					Some(BTypeName(name, btypars));
				} else {
					None();
				}
			}
			CFunction(args, return, reason): {
				bargs = filtermap(args, \arg -> {
					resolveCNode(tmap, eclasses, arg);
				});
				if (length(bargs) == length(args)) {
					mbret = resolveCNode(tmap, eclasses, return);
					mbret ?? {
						Some(BTypeFunction(bargs, mbret));
					} : {
						println("Unknown return");
						None();
					}
				} else {
					println("Unknown args");
					None();
				}
			}
			COverload(unique, options, reason): {
				None();
			}
		}
	}
}

