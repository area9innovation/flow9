import tools/flow9/types/ugraph/tmap;
import tools/flow9/types/ugraph/type;
import tools/flow9/types/ugraph/find;
import tools/flow9/types/ugraph/incompatible;
import tools/flow9/types/pretty;

/*
TODO:
- For random supertypes, we should find the "closest" supertype and pick that.

- Try to reset eclasses for each chunk: To do this, we need a "copy into new tmap"
  operation to run after each chunk, where we pick up "live" eclasses from the global
  names.
*/

export {
	// Set up the type unification map
	makeTMap(
		onError : (int, string) -> void, 
		nextEClass : ref int,
		mkUnique : () -> int, 
		tracing : Tracing
	) -> TMap;

	// Define the resolvers we need. Required before unification works
	setTMapResolvers(t : TMap, 
		resolveStructName : (string) -> Maybe<DStruct>,
		resolveUnionName : (string) -> Maybe<DUnion>,
		resolveSupertypes : (string) -> [string], 
		resolveSubtypes : (string) -> [string], 
	) -> TMap;

	// When we know the type is unique - supertypes come to mind
	makeTNodeClassForType(tmap : TMap, type : TType, reason : ErrorReason) -> int;

	// Construct or find an eclass for this TType
	findOrMakeTNodeClass(tmap : TMap, type : TType, reason : ErrorReason) -> int;

	// Put these two types into the same equilvance class
	unifyTTypes(tmap : TMap, left : TType, right : TType, reason : ErrorReason) -> void;

	// Try to simplify this node - does not update the TMap
	simplifyTNode(tmap : TMap, node : TNode, reason : ErrorReason) -> TNode;

	// Resolve the node against a supertype. Does NOT unify the top-level, but information about
	// the subtypes are merged.
	mergeTNodeNameWithSuper(tmap : TMap, node : TNodeName, super : TNodeSupertype, reason : ErrorReason) -> TNode;

	// Unifies these nodes
	unifyTNodes(tmap : TMap, left : TNode, right : TNode, reason : ErrorReason) -> void;

	// This propagates all info between these nodes, but does not unify them at the top level
	mergeTNodes(tmap : TMap, left : TNode, right : TNode, reason : ErrorReason) -> TNode;

	// We known that sub is a subtype of the super, so unify as much as possible for that
	subtypeTNodes(tmap : TMap, sub : int, super : int, reason : ErrorReason) -> void;
}

makeTMap(onError : (int, string) -> void, nextEClass : ref int,
			mkUnique : () -> int, tracing : Tracing
		) -> TMap {
	self = ref None();
	tmap = TMap(
		makeUnionFindMap(defaultTNode(), \l, r, cookie : ErrorReason -> {
			switch (^self) {
				None(): {
					println("NOT SUPPOSED TO HAPPEN");
					l;
				}
				Some(s): mergeTNodes(s, l, r, cookie);
			}
		}),
		ref makeTree(),
		ref \__ -> {
			println("TODO: The resolvers are not set");
			None();
		},
		ref \__ -> {
			println("TODO: The resolvers are not set");
			None();
		},
		ref \__ -> {
			println("TODO: The resolvers are not set");
			[];
		},
		ref \__ -> {
			println("TODO: The resolvers are not set");
			[];
		},
		\er -> {
			reportErrors(er, onError)
		},
		nextEClass,
		mkUnique,
		ref makeList(),
		ref makeList(),
		tracing,
		ref "",
	);
	self := Some(tmap);
	tmap;
}

setTMapResolvers(t : TMap, 
	resolveStructName : (string) -> Maybe<DStruct>,
	resolveUnionName : (string) -> Maybe<DUnion>,
	resolveSupertypes : (string) -> [string], 
	resolveSubtypes : (string) -> [string], 
) -> TMap {
	t.resolveStructName := resolveStructName;
	t.resolveUnionName := resolveUnionName;
	t.resolveSupertypes := resolveSupertypes;
	t.resolveSubtypes := resolveSubtypes;
	t;
}

defaultTNode() -> TNode {
	TNodeName("", [], []);
}

uindent : ref string = ref "";

// These two types are unified
unifyTTypes(tmap : TMap, left : TType, right : TType, reason : ErrorReason) -> void {
	ind = ^uindent;
	verbose = isTracingId(tmap.tracing, StageTypeInference(), 2, ^(tmap.topid));
	if (verbose) {
		debugErrorReason(reason, "\n" + ind + "Unify " + rpad(prettyTTypeNode(tmap, left) + " and " + prettyTTypeNode(tmap, right), " ", 60) + " | ");
	}
	lclass = findOrMakeTNodeClass(tmap, left, reason);
	rclass = findOrMakeTNodeClass(tmap, right, reason);
	verbose2 = verbose 
		|| isDebuggingEClass(tmap, lclass, makeSet())
		|| isDebuggingEClass(tmap, rclass, makeSet());
	if (verbose2) {
		uindent := ind + "  ";
		debugErrorReason(reason, ind + "Unify 2 " + rpad(prettyTTypeNode(tmap, left) + " and " + prettyTTypeNode(tmap, right), " ", 60) + " e" + i2s(lclass) + " vs e" + i2s(rclass) + " | " + ^(tmap.topid) + ": ");
		// println("  " + debugTNode(tmap, lclass));
		// println("  " + debugTNode(tmap, rclass));
	}
	if (lclass != -1 && rclass != -1) {
		// println("  Union e" + i2s(lclass) + " and e" + i2s(rclass));
		root = unionUnionMap(tmap.tmap, lclass, rclass, reason);
		
		// println("  to e" + i2s(root) + " =  " + debugTNode(tmap, root));
		if (verbose) {
			debugErrorReason(reason, "\n" + ind + "After unify " + rpad(prettyTTypeNode(tmap, left) + " and " + prettyTTypeNode(tmap, right), " ", 60) + " | ");
			dumpTNodes(tmap);
		}
		{}
	} else {
		println("Not supposed to happen: " + prettyTType(left) + " and " + prettyTType(right));
	}
	uindent := ind;
}

findOrMakeTNodeClass(tmap : TMap, type : TType, reason : ErrorReason) -> int {
	eclass = findTNode(tmap, type);
	if (eclass != -1) {
		eclass
	} else {
		makeTNodeClassForType(tmap, type, reason);
	}
}

makeTNodeClassForType(tmap : TMap, type : TType, reason : ErrorReason) -> int {
	node = makeTNode(tmap, type, reason);
	// println(^uindent + "Making a type for "+ prettyTTypeNode(tmap, type) + " from " + prettyTNode(tmap, node));
	makeEClassForTNode(tmap, node, reason);
}

makeTNode(tmap : TMap, t : TType, reason : ErrorReason) -> TNode {
	error = \ -> {
		println("ERROR: Could not make TNode for " + prettyTType(t));
		TNodeName("", [], []);
	}
	switch (t) {
		TTypeName(id, typars): makeTNodeName(tmap, t, reason);
		TTypeEClass(eclass): {
			getUnionMapValue(tmap.tmap, eclass);
		}
		TTypeFunction(args, returnType): makeTNodeName(tmap, t, reason);
		TTypeOverload(unique, overloads): {
			uid = findTNode(tmap, unique);
			uniques = if (uid == -1) {
				error();
				makeSet();
			} else makeSet1(uid);
			simplifyTNode(tmap, TNodeOverload(
				uniques,
				map(overloads, \st -> makeTNodeName(tmap, st, 
					elaborateReason(reason, "overload")
				)),
				getTreeKeys(reason.reasons)
			), reason)
		}
		TTypeSupertype(unique, subtypes, maxed): {
			emptySuper = TNodeSupertype(makeSet1(unique), [], makeSet(), maxed, getTreeKeys(reason.reasons));
			super = fold(subtypes, emptySuper, \acc, st -> extractSupers(tmap, acc, st));
			simplifyTNode(tmap, super, reason);
		}
	}
}

// Add t to this supertype as a subtype. If t is a supertype, add all members of that
extractSupers(tmap : TMap, acc : TNodeSupertype, t : TType) -> TNodeSupertype {
	addName = \n : TNodeName -> {
		//if (hasSupertype(tmap, n)) {
			// println("TODO: Wrap the children in supertype if not resolved! " + prettyTNode(tmap, n));
		// }
		TNodeSupertype(acc with subtypes = arrayPush(acc.subtypes, n));
	}
	switch (t) {
		TTypeSupertype(__, sub, __): {
			fold(sub, acc, \acc2, st -> extractSupers(tmap, acc2, st));
		}
		TTypeEClass(eclass): {
			node = getUnionMapValue(tmap.tmap, eclass);
			switch (node) {
				TNodeName(name, typars, __): {
					if (isEmptyTNode(node)) {
						// OK, add it
						// println("Adding unknown");
						TNodeSupertype(acc with unknownSubtypes = insertSet(acc.unknownSubtypes, eclass));
					} else {
						addName(node);
					}
				}
				TNodeOverload(unique, overloads, pos): {
					if (exists(overloads, isFlowNode)) {
						// OK, we are adding a flow to a supertype.
						TNodeSupertype(acc with subtypes = arrayPush(acc.subtypes, TNodeName("flow", [], pos)));
					} else {
						println("TODO: Figure out how to represent this overload as a named type: " + prettyTType(t));
						acc;
					}
				}
				TNodeSupertype(uniques, subtypes, usub, maxed, pos): {
					TNodeSupertype(acc with
						subtypes = concat(acc.subtypes, subtypes),
						unknownSubtypes = mergeSets(acc.unknownSubtypes, usub),
					);
				}
			}
		}
		TTypeName(__, __): {
			addName(makeTNodeName(tmap, t, makeErrorReason(acc.pos, "extractsupers")));
		}
		TTypeFunction(args, returnType): {
			addName(makeTNodeName(tmap, t, makeErrorReason(acc.pos, "extractsupers")));
		}
		TTypeOverload(unique, overloads): {
			println("TODO: Figure out how to represent this overload as a named node: " + prettyTType(t));
			acc;
		}
	}
}

// Ensure that we get a named type out of this type. Used for the args of overloads and supertypes
makeTNodeName(tmap : TMap, t : TType, reason : ErrorReason) -> TNodeName {
	error = \ -> {
		println("ERROR: Could not make TNodeName for " + prettyTType(t));
		TNodeName("", [], getTreeKeys(reason.reasons));
	};
	switch (t) {
		TTypeName(id, typars): {
			TNodeName(id, mapi(typars, \i, tp -> findOrMakeTNodeClass(tmap, tp, 
				elaborateReason(reason, id + " typar #" + i2s(i + 1))
			)), getTreeKeys(reason.reasons));
		}
		TTypeFunction(args, returnType): {
			TNodeName("", 
				arrayPush(
					mapi(args, \i, a -> 
						findOrMakeTNodeClass(tmap, a, 
							elaborateReason(reason, "arg #" + i2s(i + 1))
						)
					),
					findOrMakeTNodeClass(tmap, returnType, 
						elaborateReason(reason, "return type")
					)
				), getTreeKeys(reason.reasons)
			)
		}
		TTypeEClass(eclass): {
			node = getUnionMapValue(tmap.tmap, eclass);
			switch (node) {
				TNodeName(__, __, __): node;
				default: {
					println("TODO: Lift this up to super or overload: " + prettyTNode(tmap, node));
					error();
				}
			}
		}
		TTypeOverload(unique, overloads): error();
		TTypeSupertype(unique, subtypes, maxed): error();
	}
}

// Given a node, simplify overload and supertypes as much as possible.
// - If overloads are unique, pick the one it is
// - If a supertype has unknown subtypes, see if any are known
// - If a supertype has all subtypes known, find the potential supers

simplifyTNode(tmap : TMap, node : TNode, reason : ErrorReason) -> TNode {
	switch (node) {
		TNodeName(name, typars, pos): {
			// The typars are eclasses, to they will be simplified elsewhere
			node;
		}
		TNodeOverload(unique, overloads, __): {
			// The overloads are assumed to be simplified already
			if (length(overloads) == 1) {
				overloads[0];
			} else {
				node;
			}
		}
		TNodeSupertype(uniques, subtypes, unknownSubtypes, maxed, pos): {
			simplifyTNodeSupertype(tmap, node, reason);
		}
	}
}

simplifyTNodeSupertype(tmap : TMap, node : TNodeSupertype, reason : ErrorReason) -> TNode {
	uniques = node.uniques;
	subtypes : [TNodeName] = node.subtypes;
	unknownSubtypes = node.unknownSubtypes;
	pos = node.pos;
	if (!isEmptySet(unknownSubtypes)) {
		// We have some typevars in here. See if any of those are
		// resolved
		resolved : Pair<[TNodeName], Set<int>> = foldSet(unknownSubtypes, Pair([], makeSet()), 
				\acc : Pair<[TNodeName], Set<int>>, st : int -> {
			root = rootTTypeEClass(tmap, st);
			unode = getUnionMapValue(tmap.tmap, root);
			unknown = \ -> {
				Pair(acc.first, insertSet(acc.second, root));
			}
			switch (unode) {
				TNodeName(name, typars, __): {
					if (isEmptyTNode(unode)) {
						unknown();
					} else {
						Pair(arrayPush(acc.first, unode), acc.second)
					}
				}
				TNodeSupertype(nuniques, nsubtypes, nunknownSubtypes, maxed, npos): {
					if (nsubtypes != []) {
						Pair(concat(acc.first, nsubtypes), acc.second);
					} else unknown();
				}
				TNodeOverload(unique, overloads, __): unknown();
			}
		});
		if (resolved.first != []) {
			cleaned = TNodeSupertype(uniques, concat(subtypes, resolved.first), resolved.second, node.maxed, pos);
			// println("Cleaned unknown " + prettyTNode(tmap, cleaned));
			simplifyTNode(tmap, cleaned, reason);
		} else {
			// Simplify the supertypes
			TNodeSupertype(uniques, subtypes, resolved.second, node.maxed, pos);
		}
	} else {
		// OK, we can calculate potential super types here
		// and reduce them to an overload or a given type
		named = getPossibleTSupers(tmap, node);
		nnamed = sizeSet(named);

		// Here we have the names that are possible
		if (nnamed == 1) {
			fnode = instantiateTSuper(tmap, set2array(named)[0], subtypes, pos);
			mergeTNodeNameWithSuper(tmap, fnode, node, 
				joinReasons(reason,
					makeErrorReason(pos, "simplify supertype")
				)
			);
		} else {
			// Unify the typars of identical typenames
			nameGroups : Tree<string, [TNodeName]> = fold(subtypes, makeTree(), \acc, st : TNodeName -> {
				treePushToArrayUnique(acc, st.name, st)
			});
			unis : Pair<[TNodeName], [TNode]> = foldTree(nameGroups, Pair([], []), \name, group, acc : Pair<[TNodeName], [TNode]> -> {
				if (length(group) > 1) {
					merged = foldi(tail(group), group[0], \i, nn, acc2 : TNode -> {
						mergeTNodes(tmap, acc2, nn, 
							joinReasons(reason,
								makeErrorReason(pos, "resolved supertype")
							)
						);
					});
					switch (merged) {
						TNodeName(__, __, __): Pair(arrayPush(acc.first, merged), acc.second);
						default: {
							Pair(acc.first, arrayPush(acc.second, merged));
						}
					}
				} else Pair(concat(acc.first, group), acc.second);
			});
			if (unis.second == []) {
				TNodeSupertype(uniques, unis.first, unknownSubtypes, node.maxed, pos);
			} else {
				println("TODO: We found a non-named thing in a supertype");
				println(unis.second);
				TNodeSupertype(uniques, unis.first, unknownSubtypes, node.maxed, pos);
			}
		}
	}
}

unifyTNodes(tmap : TMap, left : TNode, right : TNode, reason : ErrorReason) -> void {
	if (isEmptyTNode(left) && isEmptyTNode(right)) {
	} else {
		lclass = findTNodeClass(tmap, left);
		rclass = findTNodeClass(tmap, right);
		if (lclass == -1) {
			println("could not find " + prettyTNode(tmap, left));
		} else if (rclass == -1) {
			println("could not find " + prettyTNode(tmap, right));
		} else {
			joinTNodes(tmap, lclass, rclass, reason);
			{}
		}
	}
}


//
// The pure unification - just calculates the resulting type, does not update the direct node
//

mergeTNodes(tmap : TMap, left : TNode, right : TNode, reason : ErrorReason) -> TNode {
	if (isDebuggingTopid(tmap)) {
		lclass = findTNodeClass(tmap, left);
		rclass = findTNodeClass(tmap, right);
		if (isDebuggingEClass(tmap, lclass, makeSet()) || isDebuggingEClass(tmap, rclass, makeSet())) {
			println(^uindent + "Merge nodes " + prettyTNode(tmap, left) + " and " + prettyTNode(tmap, right));
		}
	}
	// println(^uindent + "Merge nodes " + prettyTNode(tmap, left) + " and " + prettyTNode(tmap, right));
	todo = \ -> {
		println("TODO: Merge nodes " + prettyTNode(tmap, left) + " and " + prettyTNode(tmap, right));
		left;
	}
	error = \pos1 : [int], pos2 : [int] -> {
		lclass = findUnionMap(tmap.tmap, \i, val : TNode -> {
				isSameTNode(tmap, left, val)
			}, -1);

		rclass = findUnionMap(tmap.tmap, \i, val : TNode -> {
				isSameTNode(tmap, right, val)
			}, -1);
		tmap.onError(
				joinReasons(reason,
					makeErrorReason(concat(pos1, pos2), 
						prettyTNode(tmap, left) + " != " + prettyTNode(tmap, right) + " (e" + i2s(lclass) + " and e" + i2s(rclass) + ")"
					)
				)
		);
		// dumpTNodes(tmap);
		left;
	}
	if (isEmptyTNode(left)) simplifyTNode(tmap, right, reason)
	else if (isEmptyTNode(right)) simplifyTNode(tmap, left, reason)
	else if (isSameTNode(tmap, left, right)) left
	else switch (left) {
		TNodeName(lname, ltypars, pos): {
			switch (right) {
				TNodeName(rname, rtypars, rpos): {
					if (lname != rname) {
						if (lname == "flow" || rname == "flow") {
							// OK, we model it as an overload.
							TNodeOverload(makeSet1(tmap.mkUnique()), [left, right], concat(pos, rpos));
						} else if (isSingleUnionName(tmap, lname, rname)) {
							// As a special case, if one of these
							// is a singleton union with the other element,
							// it is ok
							left;
						} else {
							if (trim2(lname, "?") == "" && trim2(rname, "?") == "") {
								// ? vs ?? is not a problem
								left;
							} else {
								error(pos, rpos);
							}
						}
					} else if (length(ltypars) != length(rtypars)) {
						error(pos, rpos);
					} else {
						// Same name and # typars
						simplifyTNode(tmap, TNodeName(lname, mapi(ltypars, \i, lt -> {
							joinTNodes(tmap, lt, rtypars[i], elaborateReason(reason, 
								(if (lname == "") {
									if (i + 1 == length(ltypars)) {
										"return type"
									} else "arg #" + i2s(i + 1) 
								} else "typar #" + i2s(i + 1))
							));
						}), concat(pos, rpos)), reason)
					}
				}
				TNodeOverload(unique, overloads, __): {
					mergeTNodes(tmap, right, left, reason);
				}
				TNodeSupertype(unique, subtypes, __, __, __): {
					mergeTNodeNameWithSuper(tmap, left, right, reason);
				}
			}
		}
		TNodeOverload(lunique, loverloads, lpos): {
			switch (right) {
				TNodeName(name, typars, pos): {
					// OK: Find which of the overloads potentially match this one
					overloads = filter(loverloads, \lo : TNodeName -> {
						c = incompatibleTNodeNames(tmap, right, lo);
						if (c) {
							// println("Ignoring incompatible overload " + prettyTNode(tmap, lo) + " for " + prettyTNode(tmap, right));
							false;
						} else {
							true;
						}
					});
					if (overloads == []) {
						error(lpos, pos);
					} else if (length(overloads) == 1) {
						// println("Resolved overload " + prettyTNode(tmap, overloads[0]) + " for " + prettyTNode(tmap, left));
						mergeTNodes(tmap, overloads[0], right, 
							joinReasons(reason,
								makeErrorReason(concat(lpos, pos), "overload resolved")
							)
						);
					} else {
						// If we have identical information already, we do not
						// need to pend it
						if (!exists(overloads, \o -> {
							isSameTNode(tmap, o, right)
						})) {
							// OK, we can not clarify it, so push it to pending
							noverload = TNodeOverload(lunique, overloads, concat(lpos, pos));
							tmap.pending := Cons(Triple(noverload, right, reason), ^(tmap.pending));
							// println("Push pending again " + prettyTNode(tmap, right) + " to " + prettyTNode(tmap, noverload));
						}
						right;
					}
				}
				TNodeOverload(unique, overloads, pos): {
					if (false) {
						flows = filter(concat(loverloads, overloads), isFlowNode);
						if (flows != []) {
							// OK, we have a flow type, so just pick that
							println("REVIEW: Why do we just pick the flow here?");
							flows[0];
						} else {
							println("TODO: Find the intersection between " + prettyTNode(tmap, left) + " and " + prettyTNode(tmap, right));
							left;
						}
					} else {
						nonflows = filter(concat(loverloads, overloads), \n -> !isFlowNode(n));
						if (length(nonflows) == 1) {
							nonflows[0];
						} else {
							println("TODO: Find the intersection between " + prettyTNode(tmap, left) + " and " + prettyTNode(tmap, right));
							left;
						}
					}
				}
				TNodeSupertype(uniques, subtypes, usub, maxed, pos): {
					// We handle it in the opposite case
					mergeTNodes(tmap, right, left, reason);
				}
			}
		}
		TNodeSupertype(lunique, lsubtypes, lusub, lmaxed, lpos): {
			switch (right) {
				TNodeName(name, typars, pos): {
					mergeTNodeNameWithSuper(tmap, right, left, reason);
				}
				TNodeOverload(runique, roverloads, pos): {
					if (true) {
						nonflows = filter(roverloads, \n -> !isFlowNode(n));
						if (length(nonflows) == 1) {
							nonflows[0];
						} else {
							todo();
						}
					} else {
						flows = filter(roverloads, isFlowNode);
						if (flows != []) {
							println("REVIEW: Why do we pick the flow in this supertype?");
							// OK, we resolve to the flow type
							flows[0];
						} else {
							todo();
						}
					}
				}
				TNodeSupertype(runique, rsubtypes, rusub, rmaxed, pos): {
					simplifyTNode(tmap, TNodeSupertype(
						mergeSets(lunique, runique), 
						concat(lsubtypes, rsubtypes),
						mergeSets(lusub, rusub),
						lmaxed || rmaxed, // TODO: I guess if they disagree, there might be a problem?
						concat(pos, lpos)
					), reason);
				}
			}
		}
	}
}

// OK, we have a named type against a super.
// There are a range of cases:
// The name can be a supertype of the right hand side.
// The name can be the same as the supertype
mergeTNodeNameWithSuper(tmap : TMap, node : TNodeName, super : TNodeSupertype, reason : ErrorReason) -> TNode {
	if (isDebuggingTopid(tmap)) {
		debugErrorReason(reason, ^uindent + "Unifying " + prettyTNode(tmap, node) + " vs " + prettyTNode(tmap, super));
	}
	found = ref false;
	iter(super.subtypes, \st -> {
		found := unifyTNodeNameWithSubtype(tmap, node, st, 
			joinReasons(reason,
				makeErrorReason(concat(node.pos, st.pos), "Unifying sub " + prettyTNode(tmap, node) + " vs super " + prettyTNode(tmap, super))
			)
		) || ^found;
	});

	if (!isEmptySet(super.unknownSubtypes)) {
		eclass = findOrMakeTNode(tmap, node, joinReasons(reason, makeErrorReason(concat(node.pos, super.pos), "unifynodevssuper")));
		iterSet(super.unknownSubtypes, \st -> {
			// println(^uindent + "Joining e" + i2s(eclass) + " and e" + i2s(st));
			subtypeTNodes(tmap, st, eclass, 
				joinReasons(reason,
					makeErrorReason(concat(node.pos, super.pos), node.name + " vs e" + i2s(st))
				)
			);
			found := true;
		});
	}

	if (!^found) {
		tmap.onError(makeErrorReason(concat(node.pos, super.pos), "TODO: Join " + prettyTNode(tmap, node) + " not complete against " + prettyTNode(tmap, super)));
	}

	node;
}

// Try to unify this super type against a subtype. Return true if successful
unifyTNodeNameWithSubtype(tmap : TMap, node : TNodeName, subtype : TNodeName, reason : ErrorReason) -> bool {
	if (subtype.name == node.name) {
		if (isDebuggingTopid(tmap)) {
			debugErrorReason(reason, ^uindent + "Sub with node " + prettyTNode(tmap, subtype) + " vs " + prettyTNode(tmap, node) + ". ");
		}
		if (isEmptyTNode(node) || isEmptyTNode(subtype)) {
			println("Did not expect empty");
			false;
		} else if (node == subtype) {
			true;
		// OK, the same name, just go and subtype the typars
		} else if (length(subtype.typars) == length(node.typars)) {
			iteri(subtype.typars, \i, tp -> {
				subtypeTNodes(tmap, tp, node.typars[i], 
					joinReasons(
						reason,
						makeErrorReason(
							concat(node.pos, subtype.pos),
							"Sub with node " + prettyTNode(tmap, subtype) + " vs " + prettyTNode(tmap, node)
						)
					)
				);
				{}
			});
			true;
		} else {
			tmap.onError(
				joinReasons(reason,
					makeErrorReason(node.pos, "ERROR: Mismatch typars of " + prettyTNode(tmap, node) + " against " + prettyTNode(tmap, subtype))
				)
			);
			false;
		}
	} else if (node.name == "flow" || subtype.name == "flow") {
		true;
	} else {
		// OK, we know that the node has to be a supertype of st
		munion = ^(tmap.resolveUnionName)(node.name);
		switch (munion) {
			None(): {
				// OK, it is not a union, so they have to be the same
				tmap.onError(
					joinReasons(reason,
						makeErrorReason(node.pos, "Expected union " + prettyTNode(tmap, node) + " against " + prettyTNode(tmap, subtype))
					)
				);
				false;
			}
			Some(union): {
				stype : Maybe<DTypeName> = find(union.types, \tn -> tn.id == subtype.name);
				stype ?? {
					// OK, we have the relation from the union to the struct in this union
					unifyTNodeNameAgainstSubtype(tmap, node, subtype, union, stype);
					true;
				} : {
					msubunion : Maybe<DTypeName> = find(union.types, \tn -> {
						subs = collectSubtypes(tmap, makeSet(), tn.id);
						containsSet(subs, subtype.name)
					});
					switch (msubunion) {
						None(): {
							tmap.onError(
								joinReasons(reason,
									makeErrorReason(node.pos, "ERROR: Unknown subtype " + prettyTNode(tmap, node) + " from " + prettyTNode(tmap, subtype))
								)
							);
							false;
						}
						Some(subunion): {
							// OK, this is a stepping stone: We know this subunion contains our subtype
							misub = instantiateTNodeNameAgainstSubtype(tmap, node, subtype, 
								union, subunion);
							switch (misub) {
								None(): {
									tmap.onError(
										joinReasons(reason,
											makeErrorReason(node.pos, "ERROR: Unknown subtype " + prettyTNode(tmap, node) + " from " + prettyTNode(tmap, subtype))
										)
									);
									false;
								}
								Some(isub): {
									// OK, inch closer
									unifyTNodeNameWithSubtype(tmap, isub, subtype, reason)
								}
							}
						}
					}
				}
			}
		}
	}
}

// We have PExp and the expansion [PValue, PCall];
// We need to find PBool.
collectSubtypes(tmap : TMap, acc : Set<string>, typename : string) -> Set<string> {
	nacc = insertSet(acc, typename);
	munion = ^(tmap.resolveUnionName)(typename);
	switch (munion) {
		None(): nacc;
		Some(un): {
			fold(un.types, nacc, \acc2, tn -> {
				if (containsSet(acc2, tn.id)) acc2
				else collectSubtypes(tmap, acc2, tn.id)
			})
		}
	}
}

// OK, we have a union on the left hand side, and a subtype on the right hand side
// We have to figure out how those typars relate to each other.
// Thus, we have unionDef and the corresponding typename instantiation
unifyTNodeNameAgainstSubtype(tmap : TMap, unionNode : TNodeName, subNode : TNodeName, 
		unionDef : DUnion, subDef : DTypeName) -> void {
	msubInstantiated : Maybe<TNodeName>= instantiateTNodeNameAgainstSubtype(tmap, unionNode, subNode, 
		unionDef, subDef);
	msubInstantiated ?? {
		sub : TNodeName = msubInstantiated;
		subtypes = sub.typars;
		if (length(subtypes) == length(subNode.typars)) {
			// println("    " + prettyTNode(tmap, sub) + " vs " + prettyTNode(tmap, subNode));
			iteri(subtypes, \i, tp -> {
				if (tp != -1) {
					joinTNodes(tmap, tp, subNode.typars[i], 
						makeErrorReason(concat(unionNode.pos, subNode.pos), 
						"TODO: Typar #" + i2s(i + 1) + " from " + prettyTNode(tmap, subNode) + " vs " + prettyTNode(tmap, unionNode) + " from " + prettyTNode(tmap, sub))
					);
					{}
				} else {
					tmap.onError(makeErrorReason(unionNode.pos, "ERROR: Could not match typars " + prettyTNode(tmap, subNode) + " vs " + prettyTNode(tmap, unionNode)));
				}
			{}
			});
		} else {
			tmap.onError(makeErrorReason(unionNode.pos, "ERROR: Expected typars for " + prettyTNode(tmap, subNode) + " vs " + prettyTNode(tmap, unionNode)));
		}
	} : {
		tmap.onError(makeErrorReason(unionNode.pos, "ERROR: Expected typars for " + prettyTNode(tmap, subNode) + " vs " + prettyTNode(tmap, unionNode)));
	}
}

// Instantiates a typename that we know is in the union
instantiateTNodeNameAgainstSubtype(tmap : TMap, unionNode : TNodeName, subNode : TNodeName, 
		unionDef : DUnion, subDef : DTypeName) -> Maybe<TNodeName> {
	// println("  Node " + prettyTNode(tmap, unionNode) + " vs " + prettyTNode(tmap, subNode));
	if (length(unionNode.typars) == length(unionDef.typars)) {
		// OK, map from the typar to the eclass it is bound to
		typars : Tree<string, int> = foldi(unionDef.typars, makeTree(), \i, acc, tp : DTypePar -> {
			setTree(acc, tp.id, unionNode.typars[i]);
		});

		// Consider
		// Maybe<?> ::= None, Some<?>
		// If we are in the None, case, notice we have one too little typars
		sdtype : DTypeName = if (length(subDef.typars) == 0) {
			// So we implicitly extend it when there are none
			DTypeName(subDef with typars = unionDef.typars)
		} else subDef;
		subtypes = map(sdtype.typars, \tp -> {
			dtype2eclass(tmap, typars, tp)
		});
		// OK, instantiate the struct from the union typars
		subInstantiated = TNodeName(subNode.name, subtypes, subNode.pos);
		Some(subInstantiated)
	} else {
		None();
	}	
}

// We know that the eclass "sub" is a subclass of "super".
subtypeTNodes(tmap : TMap, sub : int, super : int, reason : ErrorReason) -> void {
	supernode = getUnionMapValue(tmap.tmap, super);
	subnode = getUnionMapValue(tmap.tmap, sub);
	postpone = \ -> {
		// println(^uindent + "Postponing subtyping " + prettyTNode(tmap, subnode) + " vs " + prettyTNode(tmap, supernode) + "  // e" + i2s(sub) + " vs e" + i2s(super));
		tmap.pendingSubtypes := Cons(Triple(sub, super, reason), ^(tmap.pendingSubtypes));
	}

	if (isEmptyTNode(supernode) && isEmptyTNode(subnode)) {
		if (false) {
			// OK, in this case, we could resolve the super to contain the subtype
			supertype = TNodeSupertype(makeSet1(tmap.mkUnique()), [], 
				makeSet1(sub), false, getPositionsFromReason(reason)
			);
			setTNodeClass(tmap, super, supertype);
		} else {
			// But it turns out to be worse
			postpone();
		}
	} else if (supernode == subnode) {
		// OK, nothing to do.
	} else {
		// println(^uindent + "Subtyping " + prettyTNode(tmap, subnode) + " vs " + prettyTNode(tmap, supernode) + "  // e" + i2s(sub) + " vs e" + i2s(super));
		switch (subnode) {
			TNodeName(name, typars, npos): {
				// TODO: There is some potential here, but it does not seem to help
				if (false && isEmptyTNode(subnode) && !isEmptyTNode(supernode)) {
					switch (supernode) {
						TNodeName(sname, stypars, pos): {
							// In cases like this:
							// - ε vs Maybe<super215{e1144}>  // e1157 vs e1160
							//   we could make an overload for the subtype: 
							// None<super215{e1144}>, Some<super215{e1144}> or Maybe<super215{e1144}>
							subnames = ^(tmap.resolveSubtypes)(sname);
							subtypes = map(subnames, \sn -> {
								instantiateTSubtype(tmap, sn, supernode, pos);
							});
							overload = TNodeOverload(makeSet1(tmap.mkUnique()), arrayPush(subtypes, supernode), pos);

							setTNodeClass(tmap, sub, overload);
							reason1 = elaborateReason(reason, "lower super to sub");
							subtypeTNodes(tmap, sub, super, reason1);
							{}
						}
						default: {}
					}
				} else if (hasSupertype(tmap, subnode)) {
					// We have a direct supertype
					switch (supernode) {
						TNodeName(__, __, __): {
							if (isEmptyTNode(supernode)) {
								supertype = TNodeSupertype(makeSet(), [subnode], makeSet(), false, getPositionsFromReason(reason));
								supers = getPossibleTSupers(tmap, supertype);
								nsupers = sizeSet(supers);
								if (nsupers == 1) {
									println("TODO: We could infer that sub is " + toString(set2array(supers)));
								}
								postpone();
							} else {
								// println("Unifying subtype for e" + i2s(sub) + ": " + prettyTNode(tmap, subnode) + " vs " + prettyTNode(tmap, supernode));
								unifyTNodeNameWithSubtype(tmap, supernode, subnode, reason);
								{}
							}
						}
						TNodeSupertype(suniques, stypes, seclass, smaxed, spos): {
							mega = TNodeSupertype(suniques, arrayPush(stypes, subnode), seclass, smaxed, spos);
							unifyTNodes(tmap, supernode, mega, joinReasons(reason, makeErrorReason(concat(npos, spos), "subtype")));
							{}
						}
						TNodeOverload(unique, overloads, __): postpone();
					}
				} else {
					def = \ -> {
						if (!isEClassResolved(tmap, sub) && !isEClassResolved(tmap, super)) {
							// println(^(tmap.topid) + ": Postpone. TODO: We could maybe stub the type up " + prettyTNode(tmap, subnode) + " vs " + prettyTNode(tmap, supernode));
							postpone();
						} else {
							joinTNodes(tmap, sub, super, 
								joinReasons(
									reason,
									makeErrorReason(
										concat(subnode.pos, supernode.pos),
										prettyTNode(tmap, subnode) + " vs " + prettyTNode(tmap, supernode)
									)
								)
							);
							{}
						}
					}
					switch (supernode) {
						TNodeName(supername, stypars, spos): {
							if (name == supername && length(typars) == length(stypars)) {
								// OK, we subtype the typars
								// println("Subtyping the typars");
								if (name == "") {
									// Function or epsilon
									def();
								} else {
									iteri(typars, \i, tp -> {
										if (i < length(stypars)) {
											subtypeTNodes(tmap, tp, stypars[i], 
												joinReasons(reason,
													makeErrorReason(concat(npos, spos), "Subtyping typars for " + name)
												)
											)
										}
									});
								}
							} else {
								if (isEmptyTNode(subnode) && !isEmptyTNode(supernode) && !hasSubtype(tmap, supernode)) {
									subtype = TNodeName(supername, mapi(stypars, \i, lt -> {
										makeTNodeClass(tmap)
									}), supernode.pos);
									setTNodeClass(tmap, sub, subtype);
									// println(^(tmap.topid) + ": We stub the subtype up " + prettyTNode(tmap, subtype) + " vs " + prettyTNode(tmap, supernode));
									iteri(subtype.typars, \i, tp -> {
										subtypeTNodes(tmap, tp, stypars[i], 
											joinReasons(
												reason,
												makeErrorReason(concat(npos, spos), "stub subtype up " + prettyTNode(tmap, subtype) + " vs " + prettyTNode(tmap, supernode))
											)
										)
									});
								} else if (!isEmptyTNode(subnode) && isEmptyTNode(supernode)) {
									suptype = TNodeName(name, mapi(typars, \i, lt -> {
										makeTNodeClass(tmap)
									}), subnode.pos);
									setTNodeClass(tmap, super, suptype);
									// println(^(tmap.topid) + ": We stub the supertype up " + prettyTNode(tmap, subnode) + " vs " + prettyTNode(tmap, supernode));
									iteri(suptype.typars, \i, tp -> {
										subtypeTNodes(tmap, typars[i], tp, 
											joinReasons(reason, 
												makeErrorReason(concat(npos, spos), "stub the supertype up " + prettyTNode(tmap, subnode) + " vs " + prettyTNode(tmap, supernode))
											)
										)
									});
								} else {
									def();
								}
							}
						}
						default: def();
					}
				}
			}
			TNodeSupertype(__, subs, unknowns, maxed, spos): {
				if (false && isEmptyTNode(supernode)) {
					// - super0{EmptyList<e32>} vs ε  // e34 vs e36
					//   This is hard, since the subtype could grow, and then our choice would be invalid
					//   Maybe we could do an overload.  EmptyList<e32>, Cons<e32>, List<e32>
					if (isEmptySet(unknowns)) {
						supers = getPossibleTSupers(tmap, subnode);
						supertypes = map(set2array(supers), \sn -> {
							// TODO: We should have another one, so we can
							// instantiate the correct type parameters
							instantiateTSubtype(tmap, sn, supernode, spos);
						});
						overload = TNodeOverload(makeSet1(tmap.mkUnique()), supertypes, spos);
						setTNodeClass(tmap, super, overload);
						reason1 = elaborateReason(reason, "lift subtype to super");
						subtypeTNodes(tmap, sub, super, reason1);
					} else {
						postpone();
					}
				} else {
					// This is optimistic, but we just take the chance
					switch (supernode) {
						TNodeName(name, typars, pos): {
							if (^(tmap.resolveSubtypes)(name) != []) {
								// println("REVIEW: Optimistic subtyping against super " + prettyTNode(tmap, subnode) + " vs " + prettyTNode(tmap, supernode));
							}
						}
						TNodeOverload(unique, overloads, pos): {}
						TNodeSupertype(uniques, subtypes, unknownSubtypes, __, pos): {}
					}
					joinTNodes(tmap, sub, super, 
						joinReasons(reason, makeErrorReason(concat(supernode.pos, spos), "optimistic sub vs super"))
					);
					{}
				}
			}
			TNodeOverload(__, __, __): {
				postpone();
			}
		}
	}
}
