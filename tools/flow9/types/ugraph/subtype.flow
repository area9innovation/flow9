import tools/flow9/types/ugraph/debug;

export {
	// Is this a union with a single struct inside? That is a special case: I.e. an alias
	isSingleUnionName(tmap : TMap, name1 : string, name2 : string) -> bool;

	// What potential typenames could resolve this super type?
	getPossibleTSupers(tmap : TMap, super : TNodeSupertype) -> Set<string>;

	// Expand this union to the raw structs
	expandTypeName2Structs(tmap : TMap, name : string) -> [string];
}

// It could be that we have a union with just one struct
isSingleUnionName(tmap : TMap, name1 : string, name2 : string) -> bool {
	// Are these names compatible
	muname1 = ^(tmap.resolveUnionName)(name1);
	switch (muname1) {
		None(): {
			muname2 = ^(tmap.resolveUnionName)(name2);
			switch (muname2) {
				None(): false;
				Some(u): {
					if (length(u.types) == 1) {
						u.types[0].id == name1
					} else false;
				}
			}
		}
		Some(u): {
			if (length(u.types) == 1) {
				u.types[0].id == name2
			} else false;
		}
	}
}

getPossibleTSupers(tmap : TMap, super : TNodeSupertype) -> Set<string> {
	supers = foldi(super.subtypes, makeSet(), \i, acc, t : TNodeName -> {
		id = t.name;
		supers0 = ^(tmap.resolveSupertypes)(id);
		supers = arrayPush(supers0, id);
		supset = buildSet(supers);
		if (i == 0) supset
		else intersectSets(supset, acc)
	});
	if (super.maxed) {
		supstructs = fold(super.subtypes, makeSet(), \acc, t : TNodeName -> {
			mergeSets(acc, buildSet(expandTypeName2Structs(tmap, t.name)));
		});

		filterSet(supers, \s -> {
			structs = expandTypeName2Structs(tmap, s);
			sizeSet(supstructs) == length(structs);
		});
	} else {
		supers
	}
}

expandTypeName2Structs(tmap : TMap, name : string) -> [string] {
		munion = ^(tmap.resolveUnionName)(name);
		switch (munion) {
			None(): [name];
			Some(union): {
				// OK, expand to the members of this union
				concatA(
					map(union.types, \tn -> {
						expandTypeName2Structs(tmap, tn.id)
					})
				)
			}
		}
}
