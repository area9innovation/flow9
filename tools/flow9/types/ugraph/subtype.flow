import tools/flow9/types/ugraph/debug;
import tools/flow9/types/ugraph/class;
import tools/flow9/types/typars;

export {
	// Is this a union with a single struct inside? That is a special case: I.e. an alias
	isSingleUnionName(tmap : TMap, name1 : string, name2 : string) -> bool;

	// What potential typenames could resolve this super type?
	getPossibleTSupers(tmap : TMap, super : TNodeSupertype) -> Set<string>;
	getPossibleSupers(tmap : TMap, subtypes : [string], maxed : bool) -> Set<string>;

	// Expand this union to the raw structs
	expandTypeName2Structs(tmap : TMap, name : string) -> [string];

	// Are there any direct supertypes of this node?
	hasSupertype(tmap : TMap, node : TNodeName) -> bool;

	// Could there be a different subtype that this one?
	hasSubtype(tmap : TMap, node : TNodeName) -> bool;

	// Instantiate a known supertype from these subtypes.
	// It constructs type classes for each typar. Caller should unify the typars in!
	instantiateFreshTSuper(tmap : TMap, name : string, subtypes : [TNodeName], pos : [int]) -> TNodeName;

	// Instantiate a possible supertype from this supertype.
	// This should carry over the typras
	instantiateTSuper(tmap : TMap, name : string, super : TNodeSupertype, pos : [int]) -> TNodeName;

	// Instantiate a subtype of a given super type. This carries over type parameters
	instantiateTSubtype(tmap : TMap, subname : string, super : TNode, pos : [int]) -> TNodeName;

	convertTSuper2Overload(tmap : TMap, super : TNodeSupertype) -> TNode;

	extractTyparsFromSubtype(tmap : TMap, sub : TNodeName, super : string) -> Maybe<[int]>;
}

// It could be that we have a union with just one struct
isSingleUnionName(tmap : TMap, name1 : string, name2 : string) -> bool {
	// Are these names compatible
	muname1 = ^(tmap.resolveUnionName)(name1);
	switch (muname1) {
		None(): {
			muname2 = ^(tmap.resolveUnionName)(name2);
			switch (muname2) {
				None(): false;
				Some(u): {
					if (length(u.types) == 1) {
						u.types[0].id == name1
					} else false;
				}
			}
		}
		Some(u): {
			if (length(u.types) == 1) {
				u.types[0].id == name2
			} else false;
		}
	}
}

getPossibleTSupers(tmap : TMap, super : TNodeSupertype) -> Set<string> {
	getPossibleSupers(tmap, map(super.subtypes, \st -> st.name), super.maxed);
}

getPossibleSupers(tmap : TMap, subtypes : [string], maxed : bool) -> Set<string> {
	supers = foldi(subtypes, makeSet(), \i, acc, id : string -> {
		supers0 = ^(tmap.resolveSupertypes)(id);
		supers = arrayPush(supers0, id);
		supset = buildSet(supers);
		if (i == 0) supset
		else intersectSets(supset, acc)
	});
	if (maxed) {
		supstructs = fold(subtypes, makeSet(), \acc, id : string -> {
			mergeSets(acc, buildSet(expandTypeName2Structs(tmap, id)));
		});
		filterSet(supers, \s -> {
			structs = expandTypeName2Structs(tmap, s);
			sizeSet(supstructs) == length(structs);
		});
	} else {
		supers
	}
}

expandTypeName2Structs(tmap : TMap, name : string) -> [string] {
	munion = ^(tmap.resolveUnionName)(name);
	switch (munion) {
		None(): [name];
		Some(union): {
			// OK, expand to the members of this union
			concatA(
				map(union.types, \tn -> {
					expandTypeName2Structs(tmap, tn.id)
				})
			)
		}
	}
}

// Are there any direct supertypes of this node?
hasSupertype(tmap : TMap, node : TNodeName) -> bool {
	id = node.name;
	supers0 = ^(tmap.resolveSupertypes)(id);
	supers0 != [];
}

// Could there be a different subtype that this one?
hasSubtype(tmap : TMap, node : TNodeName) -> bool {
	subtypes = ^(tmap.resolveSubtypes)(node.name);
	length(subtypes) > 1;
}

// Notice: Does not have to carry over type parameters
instantiateFreshTSuper(tmap : TMap, name : string, nodes : [TNodeName], pos : [int]) -> TNodeName {
	node = filter(nodes, \n -> n.name == name);	
	if (length(node) > 0) {
		// This is really just an optimization. We could just do the thing below.
		TNodeName(
			name, map(node[0].typars, \tp : int -> {
				 makeTNodeClass(tmap)
			}), pos
		)
	} else {
		// OK, it was not found, so let us construct a new one
		munion = ^(tmap.resolveUnionName)(name);
		switch (munion) {
			None(): {
				mstruct = ^(tmap.resolveStructName)(name);
				typars = switch (mstruct) {
					None(): if (name == "array" || name == "ref") 1 else 0;
					Some(st): length(st.typars);
				}
				TNodeName(name, generate(0, typars, \__ -> makeTNodeClass(tmap)), pos);
			}
			Some(union): {
				typars = map(union.typars, \__ -> makeTNodeClass(tmap));
				TNodeName(name, typars, pos);
			}
		}
	}
}

// Instantiate a possible supertype from this supertype.
// This should carry over the typars
instantiateTSuper(tmap : TMap, name : string, super : TNodeSupertype, pos : [int]) -> TNodeName {
	stypars : [[int]] = filtermap(super.subtypes, \st -> {
		extractTyparsFromSubtype(tmap, st, name)
	});
	if (stypars == []) {
		println("TODO: Not supposed to happen: " + name + " is expected to be a subtype of " + prettyTNode(tmap, super));
		instantiateFreshTSuper(tmap, name, [], pos);
	} else {
		if (length(uniq(stypars)) > 1) {
			println("TODO: We could unify typars for " + name);
			println(uniq(stypars));
		}
		TNodeName(name, stypars[0], pos);
	}
}

// Instantiate a known subtype of the given supertype.
// This one should carry over the type parameters
instantiateTSubtype(tmap : TMap, subname : string, super : TNode, pos : [int]) -> TNodeName {
	res = switch (super) {
		TNodeName(name, typars, __): {
			// We assume it is a subtype
			mtypars = extractTyparsFromSuper(tmap, super, subname);
			mtypars ?? {
				TNodeName(subname, mtypars, pos);
			} : {
				println("TODO: Not supposed to happen: " + subname + " is expected to be a subtype of " + name);
				instantiateFreshTSuper(tmap, subname, [], pos);
			}
		}
		TNodeOverload(unique, overloads, __): {
			println("Do know expect an overload to be a supertype");
			instantiateFreshTSuper(tmap, subname, [], pos);
		}
		TNodeSupertype(uniques, subtypes, unknownSubtypes, maxed, __): {
			stypars : [[int]] = filtermap(subtypes, \st -> {
				extractTyparsFromSuper(tmap, st, subname)
			});
			if (stypars == []) {
				println("TODO: Not supposed to happen: " + subname + " is expected to be a subtype of " + prettyTNode(tmap, super));
				instantiateFreshTSuper(tmap, subname, [], pos);
			} else {
				TNodeName(subname, stypars[0], pos);
			}
		}
	};
	// println("Instantiate sub " + subname + " from "  + prettyTNode(tmap, super) + " to " + prettyTNode(tmap, res));
	res
}

convertTSuper2Overload(tmap : TMap, super : TNodeSupertype) -> TNode {
	supers = getPossibleTSupers(tmap, super);
	// println("Finding supers for " + prettyTNode(tmap, super) + ": " + strGlue(set2array(supers), ", "));
	supertypes = map(set2array(supers), \sn -> {
		instantiateTSuper(tmap, sn, super, super.pos);
	});
	if (length(supertypes) == 1) {
		supertypes[0];
	} else {
		ov = TNodeOverload(makeSet1(tmap.mkUnique()), supertypes, super.pos);
		// println("Gave " + prettyTNode(tmap, ov));
		ov;
	}
}

extractTyparsFromSuper(tmap : TMap, super : TNodeName, subname : string) -> Maybe<[int]> {
	def = \ -> {
		munion = ^(tmap.resolveUnionName)(super.name);
		switch (munion) {
			None(): {
				println("Not supposed to happen: Extract typars from non-union " + super.name + " to " + subname);
				None();
			}
			Some(union): {
				stype : Maybe<DTypeName> = find(union.types, \tn -> tn.id == subname);
				stype ?? {
					// OK, we have the relation from the union to the struct in this union
					Some(extractTyparsFromSuperDTypename(union, stype, super.typars));
				} : {
					// We could not find it, go look for it in the children
					println("TODO: Look through the unions to find the right struct " + prettyTNode(tmap, super) + " vs "  + subname);
					Some(super.typars);
				}
			}
		}
	};
	if (super.name == subname) {
		Some(super.typars)
	} else {
		mstruct = ^(tmap.resolveStructName)(subname);
		switch (mstruct) {
			None(): def();
			Some(struct): {
				if (struct.typars == []) Some([])
				else def();
			}
		}
	}
}

extractTyparsFromSubtype(tmap : TMap, sub : TNodeName, super : string) -> Maybe<[int]> {
	def = \ -> {
		munion = ^(tmap.resolveUnionName)(super);
		switch (munion) {
			None(): {
				println("Not supposed to happen: Extract typars from non-union " + super + " to " + sub.name);
				None();
			}
			Some(union): {
				if (union.typars == []) Some([])
				else {
					stype : Maybe<DTypeName> = find(union.types, \tn -> tn.id == sub.name);
					stype ?? {
						// OK, we have the relation from the union to the struct in this union
						Some(extractTyparsFromSubTypeDTypename(union, stype, sub.typars))
					} : {
						// We could not find it, go look for it in the union members
						utypars = filtermap(union.types, \t : DTypeName -> {
							usubtypars = extractTyparsFromSubTypeDTypename(union, t, sub.typars);
							usub = TNodeName(t.id, usubtypars, sub.pos);
							extractTyparsFromSubtype(tmap, usub, super)
						});
						println("TODO: Look through the unions to find the right struct " + super);
						println(utypars);
						Some(sub.typars);
					}
				}
			}
		}
	};
	if (super == sub.name) {
		Some(sub.typars)
	} else {
		mstruct = ^(tmap.resolveStructName)(super);
		switch (mstruct) {
			None(): def();
			Some(struct): {
				if (struct.typars == []) Some([])
				else def();
			}
		}
	}
}


