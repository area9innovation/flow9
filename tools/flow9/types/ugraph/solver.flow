import tools/flow9/types/ugraph/tnode;
import tools/flow9/types/ugraph/debug;

export {
	solveTNodes(tmap : TMap, visited : ref Set<int>, eclass : int) -> void;
}

solveTNodes(tmap : TMap, visited : ref Set<int>, eclass : int) -> void {
	if (eclass < ^(tmap.nextEClass)
		&& solveEClass(tmap, visited, eclass)) {
		solveTNodes(tmap, visited, eclass + 1);
	} else {}
}

solveEClass(tmap : TMap, visited : ref Set<int>, eclass : int) -> bool {
	if (!containsSet(^visited, eclass)) {
		root = rootTTypeEClass(tmap, eclass);
		if (root == eclass) {
			visited := insertSet(^visited, root);
			// OK, this is a root node. Let us try this one
			tnode = getUnionMapValue(tmap.tmap, root);
			snode = simplifyTNode(tmap, tnode, makeErrorReason(if (tnode.pos == []) [0] else tnode.pos, "Solving"));

			if (true) {
				// OK, here try to resolve this node
				if (solveTNode(tmap, visited, eclass, snode)) {
					true;
				} else {
					false;
				}
			} else {
				// OK, just set the new type up
				// TODO: It turns out that we need the simplification away from flow as well.
				setTNode(tmap, eclass, snode);
				true;
			}
		} else true;
	} else true;
}

solveTNode(tmap : TMap, visited : ref Set<int>, eclass : int, tnode : TNode) -> bool {
	if (isEmptyTNode(tnode)) true
	else {
		switch (tnode) {
			TNodeName(name, typars, pos): true;
			TNodeOverload(unique, overloads, pos): {
				nonflows = filter(overloads, \n -> !isFlowNode(n));
				if (length(nonflows) == 1) {
					setTNode(tmap, eclass, nonflows[0]);
					true;
				} else {
					tryTNodes(tmap, visited, eclass, overloads);
				}
			}
			TNodeSupertype(uniques, subtypes, unknownSubtypes, maxed, pos): {
				def = \ -> {
					supers = getPossibleTSupers(tmap, tnode);
					if (isEmptySet(supers)) {
						// OK, it is polymorphic or decided elsewhere
						true;
					} else {
						supernodes = map(set2array(supers), \super -> {
							instantiateTSuper(tmap, super, tnode, pos);
						});
						tryTNodes(tmap, visited, eclass, supernodes);
					}
				}
				if (isEmptySet(unknownSubtypes)) {
					def();
				} else {
					us = foldSet(unknownSubtypes, true, \acc, st -> {
						acc && solveEClass(tmap, visited, st)
					});
					if (us) {
						// OK, we resolved these somehow
						reason = makeErrorReason([0], "Solving after unknnown");
						snode = simplifyTNode(tmap, tnode, reason);
						if (snode != tnode) {
							setTNode(tmap, eclass, snode);
							{}
						}
						switch (snode) {
							TNodeName(__, __, __): {
								true;
							}
							TNodeOverload(__, __, __): {
								println("REVIEW THIS: " + prettyTNode(tmap, snode));
								solveTNode(tmap, visited, eclass, snode);
							}
							TNodeSupertype(__, __, unknownSubtypes2, __, __): {
								if (isEmptySet(unknownSubtypes2)) {
									def();
								} else {
									if (false) {
										iterSet(unknownSubtypes2, \st -> {
											println("Could not resolve unknown " + prettyEClass(tmap, st));
										});
									}
									false;
								}
							}
						}
					} else {
						us;
					}
				};
			}
		}
	}
}

// OK, try these in turn, to find one that works
tryTNodes(tmap : TMap, visited : ref Set<int>, eclass : int, nodes : [TNode]) -> bool {
//	println("TODO: Try these " + superglue(nodes, \n -> prettyTNode(tmap, n), ",") + " for " + prettyEClass(tmap, eclass) + " (e" + i2s(eclass) + ")");
	false;
}


setTNode(tmap : TMap, eclass : int, node : TNode) -> void {
	reason = makeErrorReason(if (node.pos == []) [0] else node.pos, "Simplified");
	existingEClass = findTNodeClass(tmap, node);
	ecl = if (existingEClass == -1) {
		// println("Making a new class for " + prettyTNode(tmap, node));
		makeEClassForTNode(tmap, node, reason);
	} else existingEClass;
	joinTNodes(tmap, eclass, ecl, reason);
	{}
}
