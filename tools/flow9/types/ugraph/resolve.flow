import tools/flow9/types/ugraph/tnode;
import tools/flow9/types/ugraph/solver;

export {
	// At the end, extract the types for each type class
	resolveTNodes(tmap : TMap, iterations : int, verbose : bool) -> Tree<int, TType>;
}

//
// At the end, extract the types
//

resolveTNodes(tmap : TMap, iterations : int, verbose : bool) -> Tree<int, TType> {
	pending = ^(tmap.pending);
	tmap.pending := makeList();
	iterList(pending, \p : Triple<TNode, TNode, ErrorReason> -> {
		// println("Merge pending " + prettyTNode(tmap, p.first) + " and " + prettyTNode(tmap, p.second));
		mergeTNodes(tmap, p.first, p.second, p.third);
		{}
	});
	pendingSubtypes = ^(tmap.pendingSubtypes);
	tmap.pendingSubtypes := makeList();
	iterList(pendingSubtypes, \p : Triple<int, int, ErrorReason> -> {
		// println("Subtype " + prettyEClass(tmap, p.first) + " super " + prettyEClass(tmap, p.second));
		subtypeTNodes(tmap, p.first, p.second, p.third);
	});

	if (true) {
		// OK, now do prolog-style search to resolve any subtypes and overloads
		// and then do the pending items again
		solveTNodes(tmap, ref makeSet(), 0)
	}

	if (iterations == 0
		|| (isEmptyList(^(tmap.pending)) && isEmptyList(^(tmap.pendingSubtypes)))
	) {
		pendingSubtypes2 = ^(tmap.pendingSubtypes);
		switch (pendingSubtypes2) {
			EmptyList(): {
				if (isDebuggingTopid(tmap)) {
					iterList(^(tmap.pending), \p -> {
						println("Ignoring " + prettyTNode(tmap, p.first) + " vs " + prettyTNode(tmap, p.second));
					});
					iterList(^(tmap.pendingSubtypes), \t -> {
						println("Ignoring " + prettyEClass(tmap, t.first) + " sub " + prettyEClass(tmap, t.second));
					});
				}
				extractTNodes(tmap, verbose);
			}
			Cons(head, ltail): {
				// OK, we will just switch to join instead, and then continue
				if (isDebuggingTopid(tmap)) {
					println("REVIEW: Optimistic joining " + prettyEClass(tmap, head.first) + " sub " + prettyEClass(tmap, head.second));
				}
				if (true) {
					joinTNodes(tmap, head.first, head.second, elaborateReason(head.third, "Optimistic subtypes join"));
					tmap.pendingSubtypes := ltail;
					// TODO: This gives infinite loops in some cases
					resolveTNodes(tmap, 0, verbose);
				} else {
					// We get infinite loops from the other branch, but this one
					// gives the wrong types
					iterList(^(tmap.pendingSubtypes), \t -> {
						joinTNodes(tmap, t.first, t.second, elaborateReason(t.third, "Optimistic subtypes join"));
						{}
					});
					extractTNodes(tmap, verbose);
				}
			}
		};
	} else {
		resolveTNodes(tmap, iterations - 1, verbose);
	}
}

extractTNodes(tmap : TMap, verbose : bool) -> Tree<int, TType> {
	types = ref makeTree();
	visited = ref makeSet();

	iterUnionMap(tmap.tmap, \root, node -> {
		if (!isEmptyTNode(node)) {
			t = resolveTNodeClass(tmap, types, visited, root);
			if (verbose) {
				println("e" + i2s(root) + " = " + rpad(prettyTType(t), " ", 30) + "   from " + debugTNode(tmap, root));
			}
		}
	});

	^types
}

resolveTNodeClass(tmap : TMap, acc : ref Tree<int, TType>, visited : ref Set<int>, eclass : int) -> TType {
	mkClass = \ee -> {
		lookupTreeDef(^acc, ee, TTypeEClass(ee))
	}
	if (containsSet(^visited, eclass)) {
		mkClass(eclass)
	} else {
		visited := insertSet(^visited, eclass);
		node = getUnionMapValue(tmap.tmap, eclass);
		resolveTNode(tmap, acc, visited, eclass, node);
	}
}

resolveTNode(tmap : TMap, acc : ref Tree<int, TType>, visited : ref Set<int>, eclass : int, node : TNode) -> TType {
	mkClass = \ee -> {
		lookupTreeDef(^acc, ee, TTypeEClass(ee))
	}
	set = \tt -> {
		acc := setTree(^acc, eclass, tt);
		tt;
	}

	switch (node) {
		TNodeName(name, typars, pos): {
			if (name == "" && typars == []) {
				mkClass(eclass)
			} else if (name == "") {
				args = subrange(typars, 0, length(typars) - 1);
				rt = typars[length(typars) - 1];
				set(TTypeFunction(
					map(args, \a -> {
						resolveTNodeClass(tmap, acc, visited, a)
					}),
					resolveTNodeClass(tmap, acc, visited, rt)
				))
			} else {
				set(TTypeName(name, map(typars, \tp -> {
					resolveTNodeClass(tmap, acc, visited, tp)
				})))
			}
		}
		TNodeOverload(unique, overloads, pos): {
			simpler = simplifyTNode(tmap, node, makeErrorReason(pos, "resolving"));
			if (simpler != node) {
				resolveTNode(tmap, acc, visited, eclass, simpler);
			} else if (length(overloads) > 0) {
				nonflow = filter(overloads, \t -> {
					!isFlowNode(t)
				});
				res = if (length(nonflow) == 1) {
					nonflow[0];
				} else if (length(nonflow) != length(overloads)) {
					// There is a flow in there
					println("REVIEW: We found a flow in an overload");
					TNodeName("flow", [], pos);
				} else {
					if (length(overloads) != 1) {
						println("TODO: Picking random overload: " + prettyTNode(tmap, node));
					}
					overloads[0];
				}
				resolveTNode(tmap, acc, visited, eclass, res);
			} else {
				println("TODO: Resolve overload: " + prettyTNode(tmap, node));
				mkClass(eclass);
			}
		}
		TNodeSupertype(unique, subtypes, unsup, maxed, pos): {
			simpler = simplifyTNode(tmap, node, makeErrorReason(pos, "resolving super"));
			if (simpler != node) {
				resolveTNode(tmap, acc, visited, eclass, simpler);
			} else if (subtypes != []) {
				mflow = find(subtypes, \st : TNodeName -> st.name == "flow");
				mflow ?? {
					resolveTNode(tmap, acc, visited, eclass, mflow);
				} : {
					if (length(subtypes) == 1) {
						// A single type - we just grab it as is
						resolveTNode(tmap, acc, visited, eclass, subtypes[0]);
					} else {
						// OK, find the set of potential supertypes
						supers : [string] = set2array(getPossibleTSupers(tmap, node));
						if (length(supers) != 1) {
							// TODO: We should count the expanded length of
							// each supertypes, and pick the "smallest" one
							println("TODO: Picking random supertype from " + toString(supers) + " for: " + prettyTNode(tmap, node));
							// tmap.onError(pos, "TODO: Picking random supertype from " + toString(supers) + " for: " + prettyTNode(tmap, node));
						}
						if (supers == []) {
							tmap.onError(makeErrorReason(pos, "No supertype for " + prettyTNode(tmap, node)));
							resolveTNode(tmap, acc, visited, eclass, subtypes[0]);
						} else {
							fnode = instantiateTSuper(tmap, supers[0], subtypes, pos);
							uni = mergeTNodeNameWithSuper(tmap, fnode, node, makeErrorReason(pos, "resolving"));
							// println("REVIEW: Should we record a uni " + prettyTNode(tmap, uni) + " from " + prettyTNode(tmap, node));
							resolveTNode(tmap, acc, visited, eclass, uni);
						}
					}
				}
/*			} else if (sizeSet(unsup) == 1) {
				feclass = set2array(unsup)[0];
				TTypeEClass(feclass);*/
			} else {
				tmap.onError(makeErrorReason(pos, "Could not resolve supertype: " + prettyTNode(tmap, node)));
				mkClass(eclass);
			}
		}
	}
}
