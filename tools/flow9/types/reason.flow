import algorithms;

export {
	ErrorReason(
		// Lookup from position to reasons
		reasons : Tree<int, [string]>,
	);

	joinReasons(left : ErrorReason, right : ErrorReason) -> ErrorReason;

	makeErrorReason(pos : [int], error : string) -> ErrorReason;

	elaborateReason(e : ErrorReason, extra : string) -> ErrorReason;

	reportErrors(e : ErrorReason, onError : (int, string) -> void) -> void;

	debugErrorReason(er : ErrorReason, prefix : string) -> void;
}

makeErrorReason(pos : [int], error : string) -> ErrorReason {
	if (pos == []) {
		println("We do not have a position for this error: " + error);
		printCallstack();
	}
	ErrorReason(fold(pos, makeTree(), \acc, p -> treePushToArrayUnique(acc, p, error)));
}

joinReasons(left : ErrorReason, right : ErrorReason) -> ErrorReason {
	if (isEmptyTree(left.reasons)) {
		println("We do not have a position for the left");
		println(right.reasons);
	}
	if (isEmptyTree(right.reasons)) {
		println("We do not have a position for the right");
		println(left.reasons);
	}
	ErrorReason(
		foldTree(left.reasons, right.reasons, \p, rs : [string], acc -> {
			fold(rs, acc, \acc2, r -> {
				treePushToArrayUnique(acc2, p, r)
			})
		})
	)
}

elaborateReason(e : ErrorReason, extra : string) -> ErrorReason {
	ErrorReason(
		mapTree(e.reasons, \rs -> {
			if (contains(rs, extra)) rs
			else arrayPush(rs, extra)
		})
	)
}

reportErrors(er : ErrorReason, onError : (int, string) -> void) -> void {
	cnt = ref 0;
	traverseInOrder(er.reasons, \pos, errors -> {
		onError(pos, 
			(if (^cnt == 0) "ERROR: " else "")
			+ strGlue(errors, ", ")
		);
		cnt := ^cnt + 1;
	});
}

debugErrorReason(er : ErrorReason, prefix : string) -> void {
	if (isEmptyTree(er.reasons)) {
		println(prefix);
	} else {
		traverseInOrder(er.reasons, \pos, errors -> {
			println(prefix + strGlue(errors, ", "));
		});
	}
}
