import tools/flow9/dexp/types;

export {
	// Given a union, and a set of type parameters for this supertype,
	// find out what type parameters the stype subtype should have
	extractTyparsFromSuperDTypename(union : DUnion, stype : DTypeName, superTypars : [int]) -> [int];

	// OK, we have the relation from the union to the instance struct/typename in this union
	// so go and extract the typars from this subtype
	extractTyparsFromSubTypeDTypename(union : DUnion, stype : DTypeName, subTypars : [int]) -> [int];
}

extractTyparsFromSuperDTypename(union : DUnion, stype : DTypeName, superTypars : [int]) -> [int] {
	typars : Tree<DType, int> = foldi(union.typars, makeTree(), \i, acc, tp : DTypePar -> {
		val = superTypars[i];
		setTree(acc, cleanDType(tp), val);
	});

	// Maybe<?> ::= None, Some<?>
	// means that None should be None<?>
	subtypars = if (stype.typars == []) {
		// OK, we have a type inference deal going on here
		// union.typars is [DTypePar]
		union.typars
	} else {
		// This is [DType]
		stype.typars;
	};

	mapi(subtypars, \i, tp -> {
		ttp = lookupTree(typars, cleanDType(tp));
		switch (ttp) {
			None(): {
				// Implicit typars in the struct
				// Consider List<?> ::= EmptyList, Cons<?>;
				superTypars[i];
			}
			Some(tt): tt;
		}
	}); 
}

// OK, we have the relation from the union to the instance struct/typename in this union
// so go and extract the typars from this subtype
extractTyparsFromSubTypeDTypename(union : DUnion, stype : DTypeName, subTypars : [int]) -> [int] {
	typars : Tree<DType, int> = foldi(stype.typars, makeTree(), \i, acc, tp -> {
		val = subTypars[i];
		setTree(acc, cleanDType(tp), val);
	});
	mapi(union.typars, \i, tp -> {
		ttp = lookupTree(typars, cleanDType(tp));
		switch (ttp) {
			None(): {
				// Implicit typars in the struct
				// Consider List<?> ::= EmptyList, Cons<?>;
				subTypars[i];
			}
			Some(tt): tt;
		}
	}); 
}
