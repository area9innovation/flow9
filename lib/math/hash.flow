// Â© Copyright 2011 Area9 Technologies.
import math/bits;
import text/binary;

export {
	hashString(key : string) -> int;
	// Faster version of hash for strings, uses tail recursion
	fastHashString(key : string) -> int;
	// Even faster version of hash for strings: uses only 'cutoff' symbols from the string
	fastHashStringWithCutoff(key : string, cutoff : int) -> int;

	// Constants for FNV hash: http://en.wikipedia.org/wiki/Fowler_Noll_Vo_hash
	FNV_offset_basis = 0x811C9DC5;
	FNV_prime = 16777619;

	// Update hash with integer/double/string value
	addHashInt(hash: int, v: int) -> int;
	addHashDouble(hash: int, d: double) -> int;
	addHashString(hash: int, s: string) -> int;
}

// http://en.wikipedia.org/wiki/Fowler_Noll_Vo_hash
hashString(key) {
	hash = FNV_offset_basis;

	fold(string2utf8(key), hash, \acc, b -> {
		bitXor(acc, b) * FNV_prime;
	});
}

/*
import math/bits;

hashByte(k : int, b : int) -> int {
	bitXor(k, bitAnd(b, 0xff)) * 16777619;
}

hashInt(k : int, i : int) -> int {
	h1 = hashByte(k, i);
	h2 = hashByte(h1, bitUshr(i, 8));
	h3 = hashByte(h2, bitUshr(i, 16));
	hashByte(h3, bitUshr(i, 24));
}
*/

fastHashString(key : string) -> int {
	fastHashStringTailRecursion(key, strlen(key), strlen(key), FNV_offset_basis, 0, 0)
}

fastHashStringWithCutoff(key : string, cutoff : int) -> int {
	fastHashStringTailRecursion(key, strlen(key), cutoff, FNV_offset_basis, 0, 0)
}

fastHashStringTailRecursion(key : string, len : int, cutoff : int, acc : int, ind : int, i : int) -> int {
	if (i == cutoff || i == len) {
		acc 
	} else {
		fastHashStringTailRecursion(
			key, len, cutoff, 
			bitXor(acc, getCharCodeAt(key, ind)) * FNV_prime,
			(ind + 1021) % len,
			i + 1
		)
	}
}

addHashInt(hash: int, v: int) -> int {
	hash1 = bitXor(hash, bitAnd(v, 0xFF)) * FNV_prime;
	v1 = bitUshr(v, 8);
	hash2 = bitXor(hash1, bitAnd(v1, 0xFF)) * FNV_prime;
	v2 = bitUshr(v1, 8);
	hash3 = bitXor(hash2, bitAnd(v2, 0xFF))* FNV_prime;
	v3 = bitUshr(v2, 8);
	bitXor(hash3, bitAnd(v3, 0xFF)) * FNV_prime;
}

addHashDouble(hash: int, d: double) -> int {
	addHashBytes(hash, s2a(toBinary(flow(d))), 0);
}

addHashString(hash: int, s: string) -> int {
	addHashBytes(hash, s2a(s), 0);
}

addHashBytes(hash: int, bytes: [int], i: int) -> int {
	if (i == length(bytes)) hash else {
		addHashBytes(bitXor(hash, bytes[i]) * FNV_prime, bytes, i + 1);
	}
}
