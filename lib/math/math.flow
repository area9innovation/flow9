// Â© Copyright 2011 Area9 Technologies.

import string;

export {
	forceRange : (x : ?, xMin : ?, xMax : ?) -> ?;

	max3 : (?, ?, ?) -> ?;
	min3 : (?, ?, ?) -> ?;

	maxA : ([?]) -> Maybe<?>;
	minA : ([?]) -> Maybe<?>;

	abs : (double) -> double;
	iabs : (int) -> int;
	sign : (double) -> double;
	isign : (int) -> int;
	b2sign : (bool) -> double;

	pow : (int, int) -> int;
	dpow : (double, double) -> double;
	pow2 : (double, int) -> Maybe<double>;
	dpow2 : (double, double) -> Maybe<double>;

	//Radians
	native sin : (double) -> double = Native.sin;
	cos : (double) -> double;
	tan : (double) -> double;
	cot : (double) -> double;

	native asin : (double) -> double = Native.asin;
	native acos : (double) -> double = Native.acos;
	native atan : (double) -> double = Native.atan;
	native atan2 : (double, double) -> double = Native.atan2;
	acot : (double) -> double;

	//Degrees
	sinus : (double) -> double;
	cosinus : (double) -> double;
	tangent : (double) -> double;
	cotangent : (double) -> double;

	asinus : (double) -> double;
	acosinus : (double) -> double;
	atangent : (double) -> double;
	acotangent : (double) -> double;

	sqrt : (double) -> double;
	native exp : (double) -> double = Native.exp;
	native log : (double) -> double = Native.log;
	log10 : (double) -> double;
	// Conversion functions
	i2d : (int) -> double;
	i2b: (int) -> bool;
	b2d : (bool) -> double;
	b2i : (bool) -> int;
	s2i : (string) -> int;
	s2d : (string) -> double;
	s2dint(s : string, i : int, n : int, acc : double) -> double;

	// Rounds towards negative infinite: floor(-1.5) = -2
	floor : (double) -> int;
	// floor with equalDoubles compare with int value
	floorEq : (double) -> int;
	// Rounds towards positive infinite: ceil(-1.5) = -1
	ceil : (double) -> int;
	// Rounds towards 0.0: trunc(-1.5) = -1
	trunc : (double) -> int;
	// Rounds away from 0.0: round(-1.5) == -2
	round : (double) -> int;

	// Rounds to nearest value divided by second arg
	// previous version (used floor logic) moved to floorTo()
	roundTo : (double, double) -> double;

	// Rounds to nearest value below divided by second arg
	floorTo : (double, double) -> double;

	// floor for double, rounds towards zero: dfloor(-1.5) = -1.0
	dfloor : (double) -> double;
	// Rounds towards positive infinite: dceil(-1.5) = -1.0
	dceil : (double) -> double;

	// round double without converting to integer and back
	dround : (double) -> double;
	// convert rem to mod (mod is always non-negative)
	mod : (int, int) -> int;
	// remainder for doubles: drem(4.0,3.0) = 1.0, drem(-4.0, 3.0) = -1.0
	drem : (double, double) -> double;
	// mod for doubles: dmod(4.0,3.0) = 1.0, dmod(-4.0, 3.0) = 2.0
	dmod : (double, double) -> double;
	// returns fractional part (e.g. 12.75 -> 0.75)
	frac : (double) -> double;

	PI : double;
	E_CONST : double;
	maxAngleDegrees : double;

	intMax : int;
	intMin : int;
	// Approximately the biggest double that can be represented
	doubleMax : double;
	// Approximately the minimum double that can be represented
	doubleMin : double;

	even(x : int) -> bool;
	odd(x : int) -> bool;

	sum : ([int]) -> int;
	dsum :([double]) -> double;
	// The same as dsum but number2double is added to each element of array.
	// It helps to avoid crash when we serialize numbers in JS and deserialize them in c++
	dsumPatched : ([double]) -> double;
	average : ([double]) -> double;

	factorial : (int) -> int;
	//combinatorial number A(n,m) = n!/m!
	combA(n : int, m : int) -> int;
	//combinatorial number C(n,m) = n!/[(n-m)!m!]
	combC(n : int, m : int) -> int;

	equalRelative(a : double, b: double, maxRelativeError : double) -> bool;

	equalDoubles(a : double, b : double) -> bool;
	equalDoubles2(a : double, b : double, precision : int) -> bool; // precision - number of digits after comma in max absolute error allowed

	leqDoubles(a: double, b : double) -> bool;
	geqDoubles(a: double, b : double) -> bool;

	gcd(a : int,b : int) -> int;
	gcdA(args : [int]) -> int;

	lcm(a : int, b : int) -> int;

	isNanOrInf(d : double) -> bool;

	// normalizes number in scientific notation, i.e. makes mantissa less than 10
	normalizeScientificNumber(m : double, p : double) -> Pair<double, double>;

	// rounds number according to math rules with given precision. I.e roundWithPrecision(2.254, 2) gives 2.25, roundWithPrecision(-4.34445, 2) gives -4.35.
	roundWithPrecision(number : double, _precision : int) -> double;

	// Make a random generator with a given seed
	native randomGenerator : io (seed : int) -> () -> double = Native.randomGenerator;

	// Memory measurement units as doubles
	kilobyteUnit() -> double;
	megabyteUnit() -> double;
	gigabyteUnit() -> double;
}

max3(a,b,c) {
	if (a > b) {
		if (a > c) a else c;
	} else {
		max(b, c);
	}
}

min3(a,b,c) {
	if (a < b) {
		if (a < c) a else c;
	} else {
		min(b, c);
	}
}

maxA(a) {
	if (length(a) == 0) {
		None()
	} else {
		Some(fold(a, a[0], max))
	}
}

minA(a) {
	if (length(a) == 0) {
		None()
	} else {
		Some(fold(a, a[0], min))
	}
}

forceRange(x, xMin, xMax) {
	if (x < xMin) xMin else
	if (x > xMax) xMax else
	x
}

native i2d : (i : int) -> double = Native.i2d;

i2d(i : int) -> double { cast(i : int -> double)}

b2d(b : bool) -> double { if (b) 1.0 else 0.0; }

b2i(b : bool) -> int { if (b) 1 else 0; }

s2i(s) {floor(s2d(s));}

i2b(i: int) -> bool { i != 0 }

s2d(s) {
	n = strlen(s);
	if (n == 0) {
		0.0
	} else {
		negative = (getCharCodeAt(s, 0) == 0x2d); // -
		if (negative) {
			-s2dint(s, 1, n, 0.0);
		} else {
			s2dint(s, 0, n, 0.0);
		}
	}
}

// Handle the integer part at the start
s2dint(s : string, i : int, n : int, acc : double) -> double {
	if (i < n) {
		c = getCharCodeAt(s, i);
		d = getDigitCode(c);
		if (d != -1) {
			s2dint(s, i + 1, n, 10.0 * acc + i2d(d));
		} else {
			if (c == 0x2E) { // .
				fracres : Pair<double, double> = s2dfrac(s, i + 1, n, acc, 10.0);
				mult = 10.0 * fracres.first;
				if (isNanOrInf(mult)) fracres.first / fracres.second * 10.0
				else mult / fracres.second
			} else if (c == 0x45 || c == 0x65) { // E e
				s2dexp(s, i + 1, n, acc);
			} else {
				acc;
			}
		}
	} else acc
}

// Handle the decimal part after the dot
// returns Pair<cumulative value, cumulative divider>
// the real value is (cumulative value) / (cumulative divider)
// we postpone the dividing till the end because of precision loss on every dividing acts
s2dfrac(s : string, i : int, n : int, acc : double, fracacc : double) -> Pair<double, double> {
	if (i < n) {
		c = getCharCodeAt(s,i);
		d = getDigitCode(c);
		if (d != -1) {
			fracres = s2dfrac(s, i + 1, n, acc * 10.0 + i2d(d), fracacc * 10.0);
			Pair(fracres.first, fracres.second);
		} else {
			if (c == 0x45 || c == 0x65) { // E e
				Pair(s2dexp(s, i + 1, n, acc / fracacc), 1.0);
			} else {
				Pair(acc, fracacc);
			}
		}
	} else Pair(acc, fracacc);
}

// Handle the exponent
s2dexp(s : string, i : int, n : int, acc : double) -> double {
	if (i < n) {
		c = getCharCodeAt(s, i);
		expNeg = c == 0x2d; // -
		expPos = c == 0x2b; // +
		exponent = s2i2(s, i + b2i(expNeg || expPos), n, 0);
		shiftExponent(acc, if (expNeg) -exponent else exponent);
	} else acc
}

// Convert ascii code to number for "0"-"9"
getDigitCode(c : int) -> int {
	if (0x30 <= c && c <= 0x39) c - 0x30 // 0-9, 0
	else -1
}

// Get integer part from this position
s2i2(s : string, i : int, n : int, acc : int) -> int {
	if (i < n) {
		c = getCharCodeAt(s, i);
		d = getDigitCode(c);
		if (d != -1) {
			s2i2(s, i + 1, n, 10 * acc + d)
		} else {
			acc;
		}
	} else acc
}

shiftExponent(acc : double, exponent : int) -> double {
	// Though this code looks better, it could loose the last symbol (e.g. for 9.10000985294723e-016)
	//   if (exponent < 0) acc / dpow(10.0, exponent)
	//  else acc * dpow(10.0, exponent)
	if (exponent == 0) acc
	else if (exponent < 0) shiftExponent(acc / 10.0, exponent + 1)
	else shiftExponent(acc * 10.0, exponent - 1)
}


native trunc : (d : double) -> int = Native.trunc;
trunc(d) cast(d : double -> int);

floor(d) trunc(
	if (d >= 0.0) d 
	else if (-d - i2d(trunc(-d)) > 0.0) d-1.0
	else d
);

floorEq(d) if (equalDoubles(i2d(round(d)), d)) round(d) else floor(d);

ceil(d) -floor(-d);

round(d) floor(d + 0.5);

frac(d) abs(d % 1.0);

abs(x) { if (x < 0.0) -x else x; }

iabs(x) { if (x < 0) -x else x; }

sign(x) { if (x < 0.0) -1.0 else if (x > 0.0) 1.0 else 0.0 }

isign(x) { if (x < 0) -1 else if (x > 0) 1 else 0 }

b2sign(b) { if (b) 1.0 else -1.0 }

pow(i, n) {
	if (n > 0) {
		n2 = pow(i, n/2);
		if (n % 2 == 0) n2*n2 else n2*n2*i
	} else {
		1
	}
}

pow2(x, n) {
	if (x == 0.0) {
		if (n <= 0) None() else Some(0.0)
	} else {
		if (n == 0) {
			Some(1.0)
		} else if (n > 0) {
			x2 = pow2(x, n/2);
			if (n % 2 == 0) maybeMap(x2, \t -> t*t) else maybeMap(x2, \t -> t*t*x)
		} else {
			maybeMap(pow2(x, -n), \t -> 1.0 / t)
		}
	}
}

dpow(x, m) {
	exp(m * log(abs(x))) * if ((x < 0.0) && (floor(abs(m)) % 2 == 1)) -1.0 else 1.0;
}

dpow2(x, m) {
	mi = trunc(m);
	if (i2d(mi) == m) {
		pow2(x, mi)
	} else if (x < 0.0) {
		powerRoot = 1.0 / m;
		powerRootI = trunc(powerRoot);
		if (i2d(powerRootI) == powerRoot && iabs(powerRootI) % 2 == 1) {
			Some(exp(m * log(abs(x))) * -1.0)
		} else {
			None()
		}
	} else if (x == 0.0 && m > 0.0) {
		Some(0.0)
	} else if (x == 0.0 && m <= 0.0) {
		None()
	} else {
		Some(exp(m*log(x)))
	}
}

dfloor(d) { d - d % 1.0 }

dceil(d) {
	dfloor(d) + i2d(ceil(d % 1.0))
}

dround(x : double) -> double {
	dfloor(x + (if (x < 0.0) -0.5 else 0.5))
}

mod(x : int, y : int) -> int { if (x%y >= 0) x%y else (iabs(y) + x%y) }

drem(x,y) { x - dfloor(x/y)*y }

dmod(x,y) {
	tmp = drem(x,y);
	if (tmp >= 0.0) tmp else (tmp + y)
}

sqrt(x) { exp(log(x) * 0.5) }

PI = 3.14159265358979323846264338327950;
E_CONST = 2.718281828459045235360287471352662497757247093699959574966967;

// Degrees
maxAngleDegrees = 360.0;

cos(x : double) -> double {
	sin(PI/2.0 - x)
}

tan(x : double) -> double {
	sin(x) / cos(x)
}

cot(x : double) -> double {
	cos(x) / sin(x)
}

acot(x : double) -> double {
	atan(1.0 / x)
}

// Radians
degrees2radians = 2.0 * PI / maxAngleDegrees;

sinus(x : double) -> double {
	sin(x * degrees2radians)
}

cosinus(x : double) -> double {
	cos(x * degrees2radians)
}

tangent(x : double) -> double {
	tan(x * degrees2radians)
}

cotangent(x : double) -> double {
	cot(x * degrees2radians)
}

asinus(x : double) -> double {
	asin(x) / degrees2radians
}

acosinus(x : double) -> double {
	acos(x) / degrees2radians
}

atangent(x : double) -> double {
	atan(x) / degrees2radians
}

acotangent(x : double) -> double {
	atangent(1.0 / x)
}

intMax = 0x7fffffff;  // 2147483647
intMin = 0x80000000;
doubleMax = 17976931348623158000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000.0;
doubleMin = -doubleMax;


even(x : int) -> bool {
	x%2 == 0
}

odd(x : int) -> bool {
	!even(x);
}


sum(l) {
	fold(l, 0, \a, b -> a + b);
}

dsum(l) {
	fold(l, 0.0, \a, b -> a + b);
}

dsumPatched(l) {
	fold(l, 0.0, \a, b -> a + number2double(b));
}

average(l) {
	len = length(l);
	if (len == 0) {
		0.0;
	} else {
		dsum(l) / i2d(len);
	}
}

factorial(n) {
	if (n <= 1) {
		1;
	} else {
		n * factorial(n-1);
	}
}

combA(n, m) {
	if (n < m) {
		0
	} else if (n == m) {
		1
	} else {
		n * combA(n-1, m)
	}
}

combC(n, m) {
	if (m > n) {
		0
	} else if (m >= n / 2) {
		combA(n, m) / factorial(n - m)
	} else combC(n, n - m)
}

log10(x) {
	log(x) * 0.4342944819032518276511; // 1.0 / ln(10);
}

// see http://www.cygnus-software.com/papers/comparingfloats/comparingfloats.htm
// and http://stackoverflow.com/questions/17333/most-effective-way-for-float-and-double-comparison
equalRelativeOrAbsolute(a : double, b : double, maxRelativeError : double, maxAbsoluteError : double) -> bool {
	if (a == b || abs(a - b) < maxAbsoluteError) {
		true
	} else {
		equalRelative(a, b, maxRelativeError)
	}
}

// See http://www.cygnus-software.com/papers/comparingfloats/Comparing%20floating%20point%20numbers.htm
equalRelative(a, b, maxRelativeError) {
	x = abs(a);
	y = abs(b);
	relativeError = if (y > x)
		abs(b - a) / y
	else if (x != 0.0)
		abs(a - b) / x
	else
		y;

	relativeError <= maxRelativeError;
}

defaultMaxRelativeError = 0.0000000001;
defaultMaxAbsoluteError = 0.000000000001;

equalDoubles(a : double, b : double) -> bool {
	// The absolute difference is suspect... It means you can not really use small numbers
	equalRelativeOrAbsolute(a, b, defaultMaxRelativeError, defaultMaxAbsoluteError);
}

equalDoubles2(a : double, b : double, precision : int) -> bool {
	precisionD = i2d(pow(10, precision));

	equalRelativeOrAbsolute(a, b, defaultMaxRelativeError, 1.0 / precisionD);
}

leqDoubles(a: double, b : double) -> bool {
	(a < b) || equalDoubles(a, b)
}

geqDoubles(a: double, b : double) -> bool {
	(a > b) || equalDoubles(a, b)
}

gcd(a : int, b : int) -> int {
	if (b == 0) {
		a
	} else {
		gcd(b, a % b)
	}
}

gcdA(args : [int]) -> int {
	if (length(args) == 0) {
		0
	} else if (length(args) == 1) {
		args[0]
	} else {
		gcd(args[0], gcdA(tail(args)))
	}
}

lcm(a : int, b : int) -> int {
	// iabs(a * b) / gcd(a, b)
	iabs(a / gcd(a, b) * b)		// prevents int overflow if possible
}

revertPrecision(precision : double) {
 // roundTo(8.76, 0.0000001), returns 8.799999999999999 if we multiply result of dround / dfloor by precision
 // so we try to round reverted precesion to be close to actual reverted value if possible.
	reverted = 1.0 / precision;
	roundedAsDouble = i2d(trunc(reverted + 0.5));
	if (equalDoubles(roundedAsDouble, reverted)) {
		roundedAsDouble
	} else {
		reverted
	}
}

roundTo(p, precision) {
	if (equalDoubles(0.0, precision)) {
		p
	} else {
		reverted = revertPrecision(precision);
		dround(p * reverted) / reverted
	}
}

floorTo(p, precision) {
	if (equalDoubles(0.0, precision)) {
		p
	} else {
		reverted = revertPrecision(precision);
		dfloor(p * reverted) / reverted
	}
}

isNanOrInf(d : double) -> bool {
	(d == 2.0 * d && d != 0.0)  // works for inf and nan
	|| d != d // works for 0/0
}


normalizeScientificNumber(m : double, p : double) -> Pair<double, double> {
	if (isNanOrInf(m) || isNanOrInf(p)) {
		Pair(m, p)
	} else if (m == 0.0)
		Pair(0.0, 0.0)
	else {
		if (abs(m) >= 10.0) {
			normalizeScientificNumber(m / 10.0, p + 1.0)
		} else if (abs(m) >= 1.0) {
			Pair(m, p)
		} else {
			normalizeScientificNumber(m * 10.0, p - 1.0)
		}
	}
}

roundWithPrecision(number : double, precision : int) -> double {
	if (precision <= 0)
		number
	else {
		multiplier = i2d(pow(10, precision));
		dround(number * multiplier) / multiplier
	}
}

randomGenerator(seed : int) -> () -> double {
	\ -> random()
}

kilobyteUnit() -> double {
	1024.0;
}

megabyteUnit() -> double {
	kilobyteUnit() * 1024.0;
}

gigabyteUnit() -> double {
	megabyteUnit() * 1024.0;
}
