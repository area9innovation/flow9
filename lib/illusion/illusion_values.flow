export {
	IuValue ::= IuDouble, IuInt, IuBool, IuString, IuArrayValue, IuStructValue, IuUnionValue, IuDoubleVar, IuIntVar;
		IuDouble(d : DynamicBehaviour<double>);
		IuDoubleVar(source : DynamicBehaviour<string>, previewD : DynamicBehaviour<double>);
		IuInt(i : DynamicBehaviour<int>);
		IuIntVar(source : DynamicBehaviour<string>, previewI : DynamicBehaviour<int>);
		IuBool(b : DynamicBehaviour<bool>);
		IuString(s : DynamicBehaviour<string>);
		IuArrayValue(a : DynamicBehaviour<[IuValue]>);
		IuStructValue(id : string, args : [IuValue]);

		IuUnionValue(kind : string, value : DynamicBehaviour<IuStructValue>);

	IuEnvironment : (names : Tree<string, IuValue>);

	defaultIuEnvironment(iu : IuDialog) -> IuEnvironment;

	// Adds values for all variables that are not already defined, using the default values
	defaultIuWhereMissing(env : IuEnvironment, iu : IuDialog) -> IuEnvironment;

	lookupIu(env : IuEnvironment, name : string) -> IuValue;
	evalIuExp(env : IuEnvironment, expr : IuExp) -> IuValue;
	copyValue(v : IuValue) -> IuValue;

	makeDynamic(b : Behaviour<?>) -> DynamicBehaviour<?>;

	//Part of temporary hack. Should be removed when we implement Shape element with dynamic type.
	toVarDependentFixup : Tree<string, (flow) -> flow>;
}

import ds/tree;
import transforms;
import illusion/illusion;

defaultIuEnvironment(iu : IuDialog) -> IuEnvironment {
	IuEnvironment(defaultIuEnvironment2(iu, makeTree(), false));
}

defaultIuWhereMissing(env : IuEnvironment, iu : IuDialog) -> IuEnvironment {
	IuEnvironment(defaultIuEnvironment2(iu, env.names, true));
}

lookupIu(iu : IuEnvironment, name : string) -> IuValue {
	lookupTreeDef(iu.names, name, IuString(make("Unknown variable " + name)));
}

evalIuExp(env : IuEnvironment, expr : IuExp) -> IuValue {
	getIuExpValue(expr, env.names);
}

defaultIuEnvironment2(iu : IuDialog, env : Tree<string, IuValue>, onlyMissing : bool) -> Tree<string, IuValue> {
	e = fold(iu.elements, env, \acc, e -> defaultIuEnvironment3(e, acc, onlyMissing));
	v = getIuExpValue(iu.exp, e);
	if (!onlyMissing && !isNone(lookupTree(env, iu.title))) {
		println("Warning: " + iu.title + " seems to be duplicated!");
	}
	setIuEnv(e, iu.title, v, onlyMissing);
}

setIuEnv(env : Tree<string, IuValue>, name : string, value : IuValue, onlyMissing : bool) -> Tree<string, IuValue> {
	if (onlyMissing) {
		t = lookupTree(env, name);
		if (isNone(t)) {
			setTree(env, name, value);
		} else {
			env;
		}
	} else {
		setTree(env, name, value);
	}
}

defaultIuEnvironment3(iu : IuElement, env : Tree<string, IuValue>, onlyMissing : bool) -> Tree<string, IuValue> {
	switch (iu : IuElement) {
		IuInput(title, kind, visibility): {
			switch (kind : IuInputKind) {
			IuNumber(v, range):  setIuEnv(env, title, IuDouble(make(v)), onlyMissing);
			IuColor(v): setIuEnv(env, title, IuInt(make(v)), onlyMissing);
			IuText(v, __): setIuEnv(env, title, IuString(make(v)), onlyMissing);
			IuCombox(c): setIuEnv(env, title, IuString(make(c[0])), onlyMissing);
			}
		}
		IuCheckBox(title, checked, visibility): {
			setIuEnv(env, title, IuBool(make(checked != "")), onlyMissing);
		}
		IuList(dialog): {
			e2 = defaultIuEnvironment(dialog);
			setIuEnv(env, dialog.title, IuArrayValue(make([lookupIu(e2, dialog.title)])), onlyMissing);
		}
		IuLinebreak(): {
			env;
		}
	}
}

getIuExpValue(expr : IuExp, env : Tree<string, IuValue>) -> IuValue {
	switch (expr : IuExp) {
	IuStruct(id, args): IuStructValue(id, map(args, \a -> getIuExpValue(a, env)));
	IuIf(condition, thenExp, elseExp): {
		v = getIuExpValue(condition, env);
		switch (v : IuValue) {
			IuBool(b) : {
				tv = getIuExpValue(thenExp, env);
				ev = getIuExpValue(elseExp, env);
				getIuIfValue(b, tv, ev);
			}
			default: IuString(make("Error: Expected bool in if"));
		}
	}
	IuArray(elements): {
		IuArrayValue(make(map(elements, \e -> getIuExpValue(e, env))));
	}
	IuVar(name): {
		lookupTreeDef(env, name, IuString(make("Error: Unknown name: " + name)));
	}
	IuCons(e1, e2): {
		v1 = getIuExpValue(e1, env);
		v2 = getIuExpValue(e2, env);
		switch (v2 : IuValue) {
		IuArrayValue(ba): {
			join = makeDynamic(select(ba, \a -> concat([v1], a)));
			IuArrayValue(join);
		}
		default: {
			println("Something is wrong");
			IuArrayValue(make([]));
		}
		}
	}
	IuOr(e1, e2): {
		v1 = getIuExpValue(e1, env);
		v2 = getIuExpValue(e2, env);
		switch (v1 : IuValue) {
			IuBool(b1):
				switch (v2 : IuValue) {
					IuBool(b2):
						IuBool(makeDynamic(select2(b1, b2, \bv1, bv2 -> bv1 || bv2)));
					default: IuString(make("Error: expected bool after ||"));
				}
			default: IuString(make("Error: expected bool left of ||"));
		}
	}
}
}

makeDynamic(b : Behaviour<?>) -> DynamicBehaviour<?> {
	r = make(getValue(b));
	connectDistinct(b, r);
	r;
}

getIuIfValue(b : Behaviour<bool>, tv : IuValue, ev : IuValue) -> IuValue {
	switch (tv : IuValue) {
	IuDouble(d1): {
		switch (ev : IuValue) {
		IuDouble(d2): {
			IuDouble(makeDynamic(select3(b, d1, d2, \bv, dv1, dv2 -> if (bv) dv1 else dv2)));
		}
		default: IuString(make("Incompatible types"));
		}
	}
	IuInt(i1): {
		switch (ev : IuValue) {
		IuInt(i2): {
			IuInt(makeDynamic(select3(b, i1, i2, \bv, iv1, iv2 -> if (bv) iv1 else iv2)));
		}
		default: IuString(make("Incompatible types"));
		}
	}
	IuBool(b1): {
		switch (ev : IuValue) {
		IuBool(b2): {
			IuBool(makeDynamic(select3(b, b1, b2, \bv, bv1, bv2 -> if (bv) bv1 else bv2)));
		}
		default: IuString(make("Incompatible types"));
		}
	}
	IuString(s1): {
		switch (ev : IuValue) {
		IuString(s2): {
			IuString(makeDynamic(select3(b, s1, s2, \bv, sv1, sv2 -> if (bv) sv1 else sv2)));
		}
		default: IuString(make("Incompatible types"));
		}
	}
	IuArrayValue(a1): {
		switch (ev : IuValue) {
		IuArrayValue(a2): {
			IuArrayValue(makeDynamic(select3(b, a1, a2, \bv, av1, av2 -> if (bv) av1 else av2)));
		}
		default: IuString(make("Incompatible types"));
		}
	}
	IuStructValue(id, args): {
		IuString(make("Not supported yet"));
	}
	IuUnionValue(id, value): {
		IuString(make("Not supported yet"));
	}
	IuDoubleVar(name, d) : {
		IuString(make("Not supported yet"));
	}
	IuIntVar(name, i) : {
		IuString(make("Not supported yet"));
	}
}
}

copyValue(v : IuValue) -> IuValue {
	switch (v : IuValue) {
	IuDouble(d): IuDouble(make(getValue(d)));
	IuInt(i): IuInt(make(getValue(i)));
	IuDoubleVar(name, d): IuDoubleVar(make(getValue(name)), make(getValue(d)));
	IuIntVar(name, i): IuIntVar(make(getValue(name)), make(getValue(i)));
	IuBool(b): IuBool(make(getValue(b)));
	IuString(s): IuString(make(getValue(s)));
	IuArrayValue(a): IuArrayValue(make(map(getValue(a), copyValue)));
	IuStructValue(id, args): IuStructValue(id, map(args, copyValue));
	IuUnionValue(id, value): IuUnionValue(id, make(cast(copyValue(getValue(value)) : IuValue -> IuStructValue)));
	}
}

toVarDependentFixup = {
	setTree(
	setTree(
		makeTree(),
		"IuInt", idfn),
		"IuDouble", idfn
	)
}
