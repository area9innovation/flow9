// Â© Copyright 2011 Area9 Technologies.

import fs/filesystem;
import net/http_types;
import ds/arrayutils;

export {
	// Example simple call disregarding errors:
	// httpRequest("http://localhost:81/flow/myfile.txt", false, [], [], \c -> println(c), \e -> {}, \s -> {});

	// The response is assumed to be UTF-8 encoded, unless a UTF-16 BOM is present
	// Also, js target uses UTF-8 encoding with surrogate pairs
	//  and cpp target uses correct UTF8 encoding, but it returns only two bytes of symbol (even if the character is represented by 3 bytes) - it is a BUG.
	// But js surrogate pairs and cpp `cropped` character codes are not often. Only for specific symbols, like emoji and etc..
	//  (which has code more than 0xFFFF, an example is emoji smile with code 0x1F609 (one symbol (ðŸ˜‰) with 3 bytes code (0x1F609) and stored in UTF8 with 4 bytes (0xF09F9889)).

	// at the moment of comment POST-request parameters were encoded differently for different compiler backends:
	// in flowcpp POST-request parameters arent url-encoded, thus doesn't work with getUrlParameter
	// in js POST-request parameters are url-encoded
	httpRequest : (
		url : string,
		postMethod : bool,
		headers : [KeyValue],
		params : [KeyValue],
		onData : (string) -> void,
		onError : (string) -> void,
		onStatus : (int) -> void
	) -> void;

	// For JS the async parameter works.
	// For Java it is never asynchronous (The onResponse is called before httpCustomRequest returns)
	// For Cpp it is always asynchronous, except maybe on failures (httpCustomRequest will return before onResponse is called)
	httpCustomRequest(
		url : string,
		method : RequestMethod,
		headers : [KeyValue],
		data : RequestData,
		onResponse : (responseStatus : int, responseData : string, responseHeaders : [KeyValue]) -> void,
		async : bool
	) -> void;
	// Added `responseEncoding` parameter to return data in the requested encoding.
	// Compiler or url parameter takes precedence:
	//  - cpp flag is `use_utf8_js_style`;
	//  - js flag is `utf8_no_surrogates`.
	// If there is no such - `responseEncoding` will be used.
	//
	// RequestTimeout currently implemented only in java backend.
	httpCustomRequestStyled(
		url : string,
		method : RequestMethod,
		onResponse : (responseStatus : int, responseData : string, responseHeaders : [KeyValue]) -> void,
		style : [RequestStyle]
	) -> void;

	// Here and below. onProgress callback receives (done, total) parameters, so progress is done/total.
	// downloadFile usually does not invoke onProgress(total, total) when download is over.
	// So when some application code waits for 100% progress, it should consider onDone invokation as
	// 100% and stop waiting then.
	native downloadFile : io (
		url : string,
		onData : (string) -> void,
		onError : (string) -> void,
		onProgress : (double, double) -> void,
	) -> void = HttpSupport.downloadFile;

	// platform-specific call for system to download the file
	native systemDownloadFile : (url : string) -> void = HttpSupport.systemDownloadFile;

	// C++ only targets
	// Downloads file by http request and saves by path provided
	native downloadFileBinary : io (
		url : string,
		pathToSave : string,
		onDone : () -> void,
		onError : (string) -> void,
	) -> void = HttpSupport.downloadFileBinary;

	// A very simple wrapper that just gets a file and ignores errors and parameters
	httpRequest2(url : string, onData : (string) -> void) -> void;
	httpRequest3(url : string, onData : (string) -> void, onError : (string) -> void) -> void;

	preloadMediaUrl(url : string, onSuccess : () -> void, onError : (string) -> void) -> void;
	native removeUrlFromCache : (url : string) -> void = HttpSupport.removeUrlFromCache;
	native clearUrlCache : () -> void = HttpSupport.clearUrlCache;

	native getAvailableCacheSpaceMb : () -> int = HttpSupport.getAvailableCacheSpaceMb;

	native deleteAppCookies : () -> void = HttpSupport.deleteAppCookies;

	sendHttpRequestWithAttachments(
		url : string,
		headers : [KeyValue],
		params : [KeyValue],
		attachments : [KeyValue],	// [(name, local path of file to be uploaded)]
		onData : (string) -> void,
		onError : (string) -> void
	) -> void;

	// Sets withCredentials attribute for CORS requests (for targets where they are used - JS).
	// Setting to true (default value) requires non-wildcard domain in the server's response
	// Access-Control-Allow-Origin header.
	native enableCORSCredentials : (enabled : bool) -> void = HttpSupport.enableCORSCredentials;

	// Uploads native file(fs/filesystem.flow) to server
	uploadClientFile : (
		file : native,
		url: string,
		params: [KeyValue],
		headers: [KeyValue],
		eventListeners: [UploadOnlyEventListener]
	) -> () -> void;

	// Deprecated: use openFileDialog(fs/filesystem.flow) + uploadClientFile instead
	// Default payload file name is name of selected file.
	// To change it just add to params parameter with "uploadDataFieldName" as key and name of file as value
	uploadFile : (
		url : string,
		params : [KeyValue],
		headers : [KeyValue],
		fileTypes : [string], // array of "*.jpg" like strings
		eventListeners : [UploadEventListener]
	) -> void;

	//Returns and array without empry values of
	removeEmptyURLValues(params: [KeyValue]) -> [KeyValue];

	isErrorStatus(status : int) -> bool;

	// current running HTTP requests
	runningRealtimeHTTPrequests: ref int;

	// Priority of response encoding flags (hight to low):
	//  Request style -> Global setter -> Url parameter -> Compiler parameter
	setDefaultResponseEncoding : (encoding : ResponseEncoding) -> void;

	// Set function that updates arguments before passing them to native functions
	// If it returns None() then the request should not be processed, in this case
	// onData or onError have already been called
	setHttpRequestArgsUpdater(update : (HttpRequestArgs) -> Maybe<HttpRequestArgs>) -> void;
	HttpRequestArgs(
		url : string,
		method : RequestMethod,
		headers : [KeyValue],
		params : [KeyValue],
		onData : (int, string, [KeyValue]) -> void,
		onError : (int, string, [KeyValue]) -> void
	);
}

httpRequestArgsUpdater : ref (HttpRequestArgs) -> Maybe<HttpRequestArgs> = ref \a -> Some(a);
setHttpRequestArgsUpdater(update : (HttpRequestArgs) -> Maybe<HttpRequestArgs>) -> void {
	httpRequestArgsUpdater := update;
}

setDefaultResponseEncoding(encoding : ResponseEncoding) -> void {
	setDefaultResponseEncodingNative(responseEncoding2string(encoding));
}

native setDefaultResponseEncodingNative : (encoding : string) -> void = HttpSupport.setDefaultResponseEncoding;

// passing array of KeyValue to native wasn't working in flash on 01.04.2011
// hence this wrapper
native makeHttpRequest : io (
	url : string,
	postMethod : bool,
	headers : [[string]],
	params : [[string]],
	onData : (string) -> void,
	onError : (string) -> void,
	onStatus : (int) -> void,
) -> void = HttpSupport.httpRequest;

// responseEncoding parameter allows to set which encoding should be the response:
//  'auto' - defined by target (js - 'utf8_js', cpp - 'utf8', but cropped by two bytes (it is bug));
//  'utf8_js' -  UTF-8 encoding with surrogate pairs;
//  'utf8' - original UTF-8 encoding with 1, 2, 3 bytes length;
//  'byte' - 1 byte encoding (raw response).
native httpCustomRequestNative : io (
	url : string,
	method : string,
	headers : [[string]],
	parameters : [[string]],
	data : string,
	responseEncoding : string, // ['auto', 'utf8_js', 'utf8', 'byte']
	onResponse : (responseStatus : int, responseData : string, responseHeaders : [[string]]) -> void,
	async : bool
) -> void = HttpSupport.httpCustomRequestNative;

// This version currently implemented only in java backend
native httpCustomRequestWithTimeoutNative : io (
	url : string,
	method : string,
	headers : [[string]],
	parameters : [[string]],
	data : string,
	onResponse : (responseStatus : int, responseData : string, responseHeaders : [[string]]) -> void,
	async : bool,
	timeout : int
) -> void = HttpSupport.httpCustomRequestWithTimeoutNative;

httpCustomRequestWithTimeoutNative (
	url : string,
	method : string,
	headers : [[string]],
	parameters : [[string]],
	data : string,
	onResponse : (responseStatus : int, responseData : string, responseHeaders : [[string]]) -> void,
	async : bool,
	timeout : int
) -> void {
	httpCustomRequestNative(url, method, headers, parameters, data, responseEncoding2string(ResponseEncodingAuto()), onResponse, async);
}

native doPreloadMediaUrl : io (url : string, onSuccess : () -> void, onError : (string) -> void) -> void = HttpSupport.preloadMediaUrl;

// Always post
native makeSendHttpRequestWithAttachments : (
	url : string,
	headers : [[string]],
	params : [[string]],
	attachments : [[string]], // path to files in file system.
	onData : (string) -> void,
	onError : (string) -> void
) -> void = HttpSupport.sendHttpRequestWithAttachments;

runningRealtimeHTTPrequests = ref 0;
httpRequest(url, postMethod2, headers, params2, onData, onError, onStatus) {
	if (js || (cpp && !mobile)) {
		httpCustomRequest(
			url,
			if (postMethod2) POST() else GET(),
			headers,
			RequestParameters(params2),
			\responseStatus, responseData, responseHeaders -> {
				onStatus(responseStatus);

				if (!isErrorStatus(responseStatus)) {
					onData(responseData);
				} else {
					onError("HTTPRequest error. Status: " + i2s(responseStatus) + ";\nData: " + responseData);
				}
			},
			true
		);
	} else {
		// In OWASP mode GET request with parameters is forbidden, so we replace it with POST
		postMethod =
			if (isOWASPLevel1() && !postMethod2 && (params2 != [] || strContains(url, "?"))) {
				if (!cgi) println2(flow("GET request with parameters is forbidden by the current security settings. It is replaced by POST."));
				true;
			} else {
				postMethod2;
			}

		params = if (endsWith(url, ".php")) arrayPush(params2, KeyValue("t", d2s(timestamp()))) else params2;
		runningRealtimeHTTPrequests := ^runningRealtimeHTTPrequests + 1;
		fixedUrl =
			if (!isOWASPLevel1() && isUrlParameterTrue("disable_https_fix_protocol")) {
				url;
			} else {
				if (!nwjs && js && startsWith(url, "http://")) {
					proto = if (startsWith(loaderUrl(), "http://")) "http" else "https";
					proto + strRight(url, 4)
				} else {
					url;
				}
			}

		args = HttpRequestArgs(
			fixedUrl,
			if (postMethod) POST() else GET(),
			headers,
			params,
			\status, data, __ -> {
				runningRealtimeHTTPrequests := ^runningRealtimeHTTPrequests - 1;
				onStatus(status);
				onData(data);
			},
			\status, error, __ -> {
				runningRealtimeHTTPrequests := ^runningRealtimeHTTPrequests - 1;
				onStatus(status);
				onError(error);
			}
		);
		eitherFn(
			(^httpRequestArgsUpdater)(args),
			\argsUpdated -> {
				status = ref 0;
				makeHttpRequest(
					argsUpdated.url,
					argsUpdated.method == POST(),
					keyValues2strings(argsUpdated.headers),
					keyValues2strings(argsUpdated.params),
					\data -> argsUpdated.onData(^status, data, []),
					\error -> argsUpdated.onError(^status, error, []),
					\s -> status := s
				);
			},
			\ -> args.onError(0, "Request denied", [])
		);
	}
}

httpRequest2(url, onData) {
	httpRequest(url, false, [], [], onData, println, \i -> {});
}

httpRequest3(url, onData, onError) httpRequest(url, false, [], [], onData, onError, nop1);

httpCustomRequest(
	url : string,
	method : RequestMethod,
	headers : [KeyValue],
	data : RequestData,
	onResponse : (responseStatus : int, responseData : string, responseHeaders : [KeyValue]) -> void,
	async : bool
) -> void {
	// Timeout 0 means no real timeout - it will wait for the response infinitely.
	httpCustomRequestBase(url, method, headers, data, onResponse, async, 0, ResponseEncodingAuto());
}

httpCustomRequestStyled(
	url : string,
	method : RequestMethod,
	onResponse : (responseStatus : int, responseData : string, responseHeaders : [KeyValue]) -> void,
	style : [RequestStyle]
) -> void {
	headers = extractStruct(style, RequestHeaders([])).headers;
	data = either(tryExtractStruct(style, RequestPayload("")), extractStruct(style, RequestParameters([])));
	async = extractStruct(style, RequestAsync(true)).async;
	responseEncoding = extractStruct(style, RequestEncoding(ResponseEncodingAuto())).responseEncoding;
	timeout = extractStruct(style, RequestTimeout(0)).timeout;

	// Timeout 0 means no real timeout - it will wait for the response infinitely.
	httpCustomRequestBase(url, method, headers, data, onResponse, async, timeout, responseEncoding);
}

httpCustomRequestBase(
	url : string,
	method : RequestMethod,
	headers : [KeyValue],
	data : RequestData,
	onResponse : (responseStatus : int, responseData : string, responseHeaders : [KeyValue]) -> void,
	async : bool,
	timeout : int,
	responseEncoding : ResponseEncoding
) -> void {
	isPHPRequest = endsWith(url, ".php");
	noCacheTimestamp = KeyValue("t", d2s(timestamp()));
	params = switch(data : RequestData) {
		RequestParameters(params): ifArrayPush(params, isPHPRequest, noCacheTimestamp);
		default: [];
	}

	headers2 = ifArrayPush(headers, isPHPRequest && !isSameStructType(data, RequestParameters([])), noCacheTimestamp);

	payload = switch(data : RequestData) {
		RequestPayload(body): body;
		default: "";
	}

	methodName = method2string(method);
	// In OWASP mode GET request with parameters is forbidden, so we replace it with POST
	methodName2 =
		if (isOWASPLevel1() && methodName == "GET" && (payload != "" || params != [] || strContains(url, "?"))) {
			if (!cgi) println2(flow("GET request with parameters is forbidden by the current security settings. It is replaced by POST."));
			"POST"
		} else {
			methodName;
		}

	runningRealtimeHTTPrequests := ^runningRealtimeHTTPrequests + 1;
	fixedUrl =
		if (!isOWASPLevel1() && isUrlParameterTrue("disable_https_fix_protocol")) {
			url;
		} else {
			if (!nwjs && js && !isCapacitor() && startsWith(url, "http://")) {
				proto = if (startsWith(loaderUrl(), "http://")) "http" else "https";
				proto + strRight(url, 4);
			} else {
				url;
			}
		}

	onResponse2 = \responseStatus, responseData, responseHeaders -> {
		runningRealtimeHTTPrequests := ^runningRealtimeHTTPrequests - 1;
		onResponse(responseStatus, responseData, responseHeaders);
	}
	args = HttpRequestArgs(
		fixedUrl,
		string2method(methodName2),
		headers,
		params,
		onResponse2,
		onResponse2
	);
	eitherFn(
		(^httpRequestArgsUpdater)(args),
		\argsUpdated -> {
			onResponse3 = \responseStatus, responseData, responseHeaders -> {
				argsUpdated.onData(
					responseStatus,
					responseData,
					strings2KeyValues(responseHeaders)
				);
			}
			if (timeout == 0) {
				httpCustomRequestNative(
					argsUpdated.url,
					method2string(argsUpdated.method),
					keyValues2strings(argsUpdated.headers),
					keyValues2strings(argsUpdated.params),
					payload,
					responseEncoding2string(responseEncoding),
					onResponse3,
					async
				);
			} else {
				httpCustomRequestWithTimeoutNative(
					argsUpdated.url,
					method2string(argsUpdated.method),
					keyValues2strings(argsUpdated.headers),
					keyValues2strings(argsUpdated.params),
					payload,
					onResponse3,
					async,
					timeout
				);
			}
		},
		\ -> args.onError(0, "Request denied", [])
	);
}

doPreloadMediaUrl(url : string, onSuccess : () -> void, onError : (string) -> void) -> void {
	httpRequest(url + "#", false, [], [], \data -> onSuccess(), onError, nop1);
}
preloadMediaUrl(url : string, onSuccess : () -> void, onError : (string) -> void) -> void {
	if (cpp || csharp) {
		doPreloadMediaUrl(url, onSuccess, onError);
	} else {
		httpRequest(url + "#", false, [], [], \data -> onSuccess(), onError, nop1);
	}
}

uploadFile(url, params, headers, fileTypes, listeners) {
	onData = extractStruct(listeners, UploadData(nop1));
	onError = extractStruct(listeners, UploadError(nop1));
	onOpen = extractStruct(listeners, UploadOpen(nop));
	onProgress = extractStruct(listeners, UploadProgress(nop2));
	onSelect = extractStruct(listeners, UploadSelect(\name, size -> {true}));
	onSelectUnfit = extractStruct(listeners, UploadSelectUnfit(nop));
	onCancel = extractStruct(listeners, UploadCancel(nop));

	openFileDialog(1, fileTypes, \files -> {
		if (length(files) > 0) {
			if (onSelect.onSelect(fileNameClient(files[0]), trunc(fileSizeClient(files[0])))) {
				uploadClientFile(
					files[0],
					url,
					params,
					headers,
					[onData, onError, onOpen, onProgress]
				) |> ignore;
			} else {
				onSelectUnfit.onSelectUnfit();
			}
		} else {
			onCancel.onCancel();
		}
	});
}

native doUploadClientFile : (
	file : native,
	url: string,
	params: [[string]],
	headers: [[string]],
	onOpen: () -> void,
	onData: (string) -> void,
	onError: (string) -> void,
	onProgress: (double, double) -> void
) -> () -> void = HttpSupport.uploadNativeFile;

uploadClientFile(file, url, params, headers, listeners) {
	onOpen = extractStruct(listeners, UploadOpen(nop));
	onData = extractStruct(listeners, UploadData(nop1));
	onError = extractStruct(listeners, UploadError(nop1));
	onProgress = extractStruct(listeners, UploadProgress(nop2));

	doUploadClientFile(
		file,
		url,
		keyValues2strings(params),
		keyValues2strings(headers),
		onOpen.onOpen,
		onData.onData,
		onError.onError,
		onProgress.onProgress
	);
}


removeEmptyURLValues(params: [KeyValue]) -> [KeyValue] {
	filter(params, \p -> p.value != "")
}

sendHttpRequestWithAttachments(
	url : string,
	headers : [KeyValue],
	params : [KeyValue],
	attachments : [KeyValue],
	onData : (string) -> void,
	onError : (string) -> void
) -> void {
	makeSendHttpRequestWithAttachments(
		url,
		keyValues2strings(headers),
		keyValues2strings(params),
		keyValues2strings(attachments),
		onData,
		onError
	);
}

isErrorStatus(status : int) -> bool {
	status < 200 || status >= 400;
}

// getAvailableCacheSpaceMb is implemented only in C++ targets
getAvailableCacheSpaceMb() {
	-1
}

systemDownloadFile(url : string) {
	// NOP
	// Fallback for non-C++ targets
}

downloadFileBinary(
	url : string,
	pathToSave : string,
	onDone : () -> void,
	onError : (string) -> void,
) {
	// NOP
	// Fallback for non-C++ targets
}

deleteAppCookies() {
	// Clean all webview cookies of your mobile app
}

enableCORSCredentials(enabled : bool) {
	// NOP
	// Works in JS only
}

keyValues2strings(kvs : [KeyValue]) -> [[string]] {
	map(kvs, \kv -> [kv.key, kv.value]);
}

strings2KeyValues(strings : [[string]]) -> [KeyValue] {
	filtermap(strings, \ss -> {
		if (length(ss) >= 2) {
			Some(KeyValue(ss[0], ss[1]));
		} else {
			None();
		}
	});
}
