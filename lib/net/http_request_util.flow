import ds/tuples;
import date;
import maybe;
import material/internal/types;

export {
	HttpRequestParamPosition ::= HRPPosition, HRPPositionAny;
		HRPPosition(pos : int);
		HRPPositionAny();

	HttpRequestSelectionRule ::= HRRSURL, HRRSPost, HRRSHeader, HRRSParam;
		HRRSURL(url : string);
		HRRSPost(post : bool);
		HRRSHeader(header : KeyValue, position : HttpRequestParamPosition);
		HRRSParam(param : KeyValue, position : HttpRequestParamPosition);

	HttpRequestPrepareOptions ::= HRPOTimeFiltering, HRPOFilterParams;
		HRPOTimeFiltering();
		HRPOFilterParams(keys : [string]);

	HttpRequestsCompareRule ::= HRCRCompareAll, HRCRCompareURL, HRCRComparePost, HRCRCompareHeader, HRCRCompareHeaderValues, HRCRCompareParam, HRCRCompareParamValues;
		HRCRCompareAll();
		HRCRCompareURL();
		HRCRComparePost();
		HRCRCompareHeader();
		HRCRCompareHeaderValues(keys : [string]);
		HRCRCompareParam();
		HRCRCompareParamValues(keys : [string]);

	HttpResponseHandleRule ::= HRHResponseAcceptWithoutChecking, HRHResponseCheckType, HRHResponseCheckTypeAndStatus, HRHResponseCheckAll, HRHResponseReject;
		HRHResponseAcceptWithoutChecking();
		HRHResponseCheckType();
		HRHResponseCheckTypeAndStatus();
		HRHResponseCheckAll();
		HRHResponseReject();

	HttpRequestRecordHandleRule(
		requestSelectionRules : [HttpRequestSelectionRule],
		requestPrepareOptions : [HttpRequestPrepareOptions],
		requestsCompareRules : [HttpRequestsCompareRule],
		responseHandleRule : HttpResponseHandleRule
	);

	HttpRequestResponseCompareFns(
		requestsCompareFn : (received : IScriptRequestRecord, stored : IScriptRequestRecord) -> bool,
		responseCompareFn : (received : IScriptRequestRespose, stored : IScriptRequestRespose) -> bool
	);

	getHttpRequestResponseCompareFns(r : IScriptRequestRecord) -> HttpRequestResponseCompareFns;

	dummyHttpRequestCompareFn(received : IScriptRequestRecord, stored : IScriptRequestRecord) -> bool;

	dummyHttpResponseCompareFn(left : IScriptRequestRespose, right : IScriptRequestRespose) -> bool;

	setHttpRequestHandleRules(rules : [ HttpRequestRecordHandleRule ]) -> void;

	getHttpRequestHandleRules() -> [ HttpRequestRecordHandleRule ];

	isHttpRequestHandleRulesSet() -> bool;

	filterRequestRecordHeaders(headers : [KeyValue]) -> [KeyValue];

	filterRequestRecordParams(params : [KeyValue]) -> [KeyValue];
}

httpRequestHandleRules : ref Maybe<[ HttpRequestRecordHandleRule ]> = ref None();

filterRequestRecordHeaders(headers : [KeyValue]) -> [KeyValue] {
	filter(headers, \p -> !(p.key == "Authorization" && startsWith(p.value, "Bearer ")))
}

filterRequestRecordParams(params : [KeyValue]) -> [KeyValue] {
	filter(params, \p -> p.key != "t" && p.key != "jwt")
}

timeFilteredKeyValues(kv : [KeyValue]) -> [KeyValue] {
	filter(kv, \v -> !isSome(validateTime(v.value)))
}

paramFilteredKeyValues(kv : [KeyValue], options : HRPOFilterParams ) -> [KeyValue] {
	filter(kv, \v -> !contains(options.keys, v.key))
}

filterRequestRecord(record : IScriptRequestRecord, options : [HttpRequestPrepareOptions]) -> IScriptRequestRecord {
	IScriptRequestRecord(
		record.url,
		record.post,
		filterRequestRecordHeaders(record.headers)
		|> (\v -> if (contains(options, HRPOTimeFiltering())) timeFilteredKeyValues(v) else v),
		filterRequestRecordParams(record.params)
		|> (\v -> if (contains(options, HRPOTimeFiltering())) timeFilteredKeyValues(v) else v)
		|> (\v -> if (contains(options, HRPOFilterParams([]))) paramFilteredKeyValues(v, extractStruct(options, HRPOFilterParams([]))) else v),
		record.delay,
		record.response
	)
}

dummyHttpRequestCompareFn(received2 : IScriptRequestRecord, stored2 : IScriptRequestRecord) -> bool {
	received = filterRequestRecord(received2, []);
	stored = filterRequestRecord(stored2, []);
	(received.url == stored.url && received.post == stored.post && received.headers == stored.headers && received.params == stored.params);
}

dummyHttpResponseCompareFn(left : IScriptRequestRespose, right : IScriptRequestRespose) -> bool {
	left == right
}

getHttpRequestResponseCompareFns(requestRecord : IScriptRequestRecord) -> HttpRequestResponseCompareFns {
	if (isHttpRequestHandleRulesSet()) {
		// Handle Rules is set
		// Search through an array of rules to find the first suitable rule for 'requestRecord'.
		fold(getHttpRequestHandleRules(), None(), \acc, handleRule -> {
			// Result: acc = None() - not found, Some(rule) - found suitable rule
			if (isNone(acc)) {
				// Cycle through the atom rules in the current rule and check their compliance.
				fold(handleRule.requestSelectionRules, true, \acc2, rsr -> {
					if (acc2) {
						switch (rsr : HttpRequestSelectionRule) {
							HRRSURL(url) : if (requestRecord.url != url) false else acc2;
							HRRSPost(post) : if (requestRecord.post != post) false else acc2;
							HRRSHeader(header, position) : {
								switch (position : HttpRequestParamPosition) {
									HRPPosition(pos) : if (elementAt(requestRecord.headers, pos, KeyValue("", "")) != header) false else acc2;
									HRPPositionAny() : if (!contains(requestRecord.headers, header)) false else acc2;
								}
							};
							HRRSParam(param, position) : {
								switch (position : HttpRequestParamPosition) {
									HRPPosition(pos) : if (elementAt(requestRecord.params, pos, KeyValue("", "")) != param) false else acc2;
									HRPPositionAny() : if (!contains(requestRecord.params, param)) false else acc2;
								}
							};
						}
					} else acc2;
				})
				|> (\v -> if (v) {
						// The current rule is suitable, return it
						Some(handleRule)
					} else {
						// The current rule is not suitable, return acc
						acc
					})
			} else
				// The suitable rule is already set in acc - return acc
				acc
			}
		)
		// Check is suitable rule found.
		|> (\v0 -> eitherMap(v0,
			// if suitable rule is found, then create compare functions based on it
			\rule -> {
				// Request compare
				requestCompareFn = if (rule.requestsCompareRules != []) {
					\received2 : IScriptRequestRecord, stored2 : IScriptRequestRecord -> {
						received = filterRequestRecord(received2, rule.requestPrepareOptions);
						stored = filterRequestRecord(stored2, rule.requestPrepareOptions);
						fold(rule.requestsCompareRules, true, \acc, rcr -> {
							if (acc) {
								switch (rcr : HttpRequestsCompareRule) {
									HRCRCompareAll() : {
										received.url == stored.url && received.post == stored.post &&
											received.headers == stored.headers && received.params == stored.params
									}
									HRCRCompareURL() : received.url == stored.url;
									HRCRComparePost() : received.post == stored.post;
									HRCRCompareHeader() : received.headers == stored.headers;
									HRCRCompareHeaderValues(keys) : {
										fold(keys, true, \acc2, kcv ->
											eitherMap(
												find(received.headers, \v2 -> v2.key == kcv),
												\v3 -> eitherMap(find(stored.headers, \v2 -> v2.key == kcv), \v4 -> v3 == v4, false),
												false
											)
										)
									}
									HRCRCompareParam() : received.params == stored.params;
									HRCRCompareParamValues(keys) : {
										fold(keys, true, \acc2, kcv ->
											eitherMap(
												find(received.params, \v2 -> v2.key == kcv),
												\v3 -> eitherMap(find(stored.params, \v2 -> v2.key == kcv), \v4 -> v3 == v4, false),
												false
											)
										)
									}
								}
							} else acc
						})
					}
					} else dummyHttpRequestCompareFn;

				// Response compare
				responseCompareFn = \received : IScriptRequestRespose, stored : IScriptRequestRespose -> {
					switch (rule.responseHandleRule : HttpResponseHandleRule) {
						HRHResponseAcceptWithoutChecking() : true;
						HRHResponseCheckType() : {
							switch (received : IScriptRequestRespose) {
								IScriptRequestOk(__) : {
									switch (stored : IScriptRequestRespose) {
										IScriptRequestOk(__): true;
										default: false;
									}
								}
								IScriptRequestError(__) : {
									switch (stored : IScriptRequestRespose) {
										IScriptRequestError(__): true;
										default: false;
									}
								}
								IScriptRequestStatus(__) : {
									switch (stored : IScriptRequestRespose) {
										IScriptRequestStatus(__): true;
										default: false;
									}
								}
							}
						};
						HRHResponseCheckTypeAndStatus() : {
							switch (received : IScriptRequestRespose) {
								IScriptRequestOk(data) : {
									switch (stored : IScriptRequestRespose) {
										IScriptRequestOk(_data): strLeft(data, strIndexOf(data, "\n")) == strLeft(_data, strIndexOf(_data, "\n"));
										default: false;
									}
								}
								IScriptRequestError(error) : {
									switch (stored : IScriptRequestRespose) {
										IScriptRequestError(_error): strLeft(error, strIndexOf(error, "\n")) == strLeft(_error, strIndexOf(_error, "\n"));
										default: false;
									}
								}
								IScriptRequestStatus(status) : {
									switch (stored : IScriptRequestRespose) {
										IScriptRequestStatus(_status): status == stored.status;
										default: false;
									}
								}
							}
						};
						HRHResponseCheckAll() : received == stored;
						HRHResponseReject() : false;
					}
				}
				HttpRequestResponseCompareFns(
					requestCompareFn,
					responseCompareFn
				)
			},
			// If not found - return dummy compare functions
			HttpRequestResponseCompareFns(
				dummyHttpRequestCompareFn,
				dummyHttpResponseCompareFn
			)
		))
	} else {
		HttpRequestResponseCompareFns(
			dummyHttpRequestCompareFn,
			dummyHttpResponseCompareFn
		)
	}
}

setHttpRequestHandleRules(rules : [ HttpRequestRecordHandleRule ]) -> void {
	httpRequestHandleRules := Some(rules);
}

getHttpRequestHandleRules() -> [ HttpRequestRecordHandleRule ] {
	either(
		^httpRequestHandleRules,
		[]
	)
}

isHttpRequestHandleRulesSet() -> bool {
	isSome(^httpRequestHandleRules)
}
