import ds/tuples;
import date;
import maybe;
import material/internal/types;

export {

	HRCPosition ::= HRCPositionAny, HRCPositionConcrete;
		HRCPositionAny();
		HRCPositionConcrete(pos : int);

	HRCAtomRule ::= HRCURL, HRCPost, HRCHeader, HRCParamExists, HRCParamValuesCompare;
		HRCURL(url : string);
		HRCPost(post : bool);
		HRCHeader(header : KeyValue, position : HRCPosition);
		HRCParamExists(param : KeyValue, position : HRCPosition);
		HRCParamValuesCompare(valueKeys : [string]);

	HttpResponseCompareAction ::= HRCAResponseAcceptWithoutChecking, HRCAResponseCheckStatus, HRCAResponseCheckAll, HRCAResponseReject;
		HRCAResponseAcceptWithoutChecking();
		HRCAResponseCheckStatus();
		HRCAResponseCheckAll();
		HRCAResponseReject();

	HttpResponseCompareRule(
		filters : [HRCAtomRule],
		action : HttpResponseCompareAction
	);

	HttpRequestCompareOptions ::= HRCOTimeFiltering;
		HRCOTimeFiltering();

	HttpRequestCompareAction ::= HRCATakeEqual, HRCATakeNotEqual, HRCADrop;
		HRCATakeEqual();
		HRCATakeNotEqual();
		HRCADrop();

	HttpRequestCompareRule(
		filters : [HRCAtomRule],
		options : [HttpRequestCompareOptions],
		action : HttpRequestCompareAction,
	);

	dummyHttpRequestCompareFn(left : IScriptRequestRecord, right : IScriptRequestRecord) -> bool;

	timeFilteredHttpRequestCompareFn(left : IScriptRequestRecord, right : IScriptRequestRecord) -> bool;

	setHttpRequestCompareFn(fn : (left : IScriptRequestRecord, right : IScriptRequestRecord) -> bool) -> void;

	getHttpRequestCompareFn() -> Maybe<(left : IScriptRequestRecord, right : IScriptRequestRecord) -> bool>;

	dummyHttpResponseCompareFn(request : IScriptRequestRecord, response : IScriptRequestRespose) -> bool;

	setHttpResponseCompareFns(
		fnOk : (request : IScriptRequestRecord, response : IScriptRequestRespose) -> bool,
		fnError : (request : IScriptRequestRecord, response : IScriptRequestRespose) -> bool,
		fnStatus : (request : IScriptRequestRecord, response : IScriptRequestRespose) -> bool
	) -> void;

	getHttpResponseOkCompareFn() -> Maybe<(request : IScriptRequestRecord, response : IScriptRequestRespose) -> bool>;

	getHttpResponseErrorCompareFn() -> Maybe<(request : IScriptRequestRecord, response : IScriptRequestRespose) -> bool>;

	getHttpResponseStatusCompareFn() -> Maybe<(request : IScriptRequestRecord, response : IScriptRequestRespose) -> bool>;

	createHttpResponseCompareFn(rules : [ HttpResponseCompareRule ]) -> (request : IScriptRequestRecord, response : IScriptRequestRespose) -> bool;
}

httpRequestCompareFn : ref Maybe<(left : IScriptRequestRecord, right : IScriptRequestRecord) -> bool> = ref None();

httpResponseOkCompareFn : ref Maybe<(request : IScriptRequestRecord, right : IScriptRequestRespose) -> bool> = ref None();

httpResponseErrorCompareFn : ref Maybe<(request : IScriptRequestRecord, right : IScriptRequestRespose) -> bool> = ref None();

httpResponseStatusCompareFn : ref Maybe<(request : IScriptRequestRecord, right : IScriptRequestRespose) -> bool> = ref None();

dummyHttpRequestCompareFn(left : IScriptRequestRecord, right : IScriptRequestRecord) -> bool {
	(left.url == right.url && left.post == right.post && left.headers == left.headers && left.params == right.params)
}

timeFilteredHttpRequestCompareFn(left : IScriptRequestRecord, right : IScriptRequestRecord) -> bool {
	if (dummyHttpRequestCompareFn(left, right))
		true
	else if (left.url == right.url && left.post == right.post && left.headers == right.headers) {
		zipFold(left.params, right.params, true, \ -> false, \a, v, _v -> {
			if ((!a) || (v == _v) || isSome(validateTime(v.value)))
				a
			else
				false
		})
	} else
		false
}

setHttpRequestCompareFn(fn : (left : IScriptRequestRecord, right : IScriptRequestRecord) -> bool) -> void {
	httpRequestCompareFn := Some(fn);
}

getHttpRequestCompareFn() -> Maybe<(left : IScriptRequestRecord, right : IScriptRequestRecord) -> bool> {
	^httpRequestCompareFn
}

dummyHttpResponseCompareFn(request : IScriptRequestRecord, response : IScriptRequestRespose) -> bool {
	(request.response == response)
}

setHttpResponseCompareFns(
	fnOk : (request : IScriptRequestRecord, response : IScriptRequestRespose) -> bool,
	fnError : (request : IScriptRequestRecord, response : IScriptRequestRespose) -> bool,
	fnStatus : (request : IScriptRequestRecord, response : IScriptRequestRespose) -> bool
) -> void {
	httpResponseOkCompareFn := Some(fnOk);
	httpResponseErrorCompareFn := Some(fnError);
	httpResponseStatusCompareFn := Some(fnStatus);
}

getHttpResponseOkCompareFn() -> Maybe<(request : IScriptRequestRecord, response : IScriptRequestRespose) -> bool> {
	^httpResponseOkCompareFn
}

getHttpResponseErrorCompareFn() -> Maybe<(request : IScriptRequestRecord, right : IScriptRequestRespose) -> bool> {
	^httpResponseErrorCompareFn
}

getHttpResponseStatusCompareFn() -> Maybe<(request : IScriptRequestRecord, right : IScriptRequestRespose) -> bool> {
	^httpResponseStatusCompareFn
}

createHttpResponseCompareFn(rules : [ HttpResponseCompareRule ]) -> (request : IScriptRequestRecord, response : IScriptRequestRespose) -> bool {
	\_request : IScriptRequestRecord, _response : IScriptRequestRespose -> {
		// Search through an array of rules to find the first suitable.
		fold(rules, None(), \acc, r -> {
			// Result: acc = None() - not found, Some(false) - found and deny, Some(true) - found and allow
			if (isNone(acc)) {
				// Cycle through the atom rules in the current rule and check their compliance.
				fold(r.filters, true, \acc2, f -> {
					if (acc2) {
						switch (f : HRCAtomRule) {
							HRCURL(url) : if (_request.url != url) false else acc2;
							HRCPost(post) : if (_request.post != post) false else acc2;
							HRCHeader(header, position) : {
								switch (position : HRCPosition) {
									HRCPositionConcrete(pos) : if (elementAt(_request.headers, pos, KeyValue("", "")) != header) false else acc2;
									HRCPositionAny() : if (!contains(_request.headers, header)) false else acc2;
								}
							};
							HRCParamExists(param, position) : {
								switch (position : HRCPosition) {
									HRCPositionConcrete(pos) : if (elementAt(_request.params, pos, KeyValue("", "")) != param) false else acc2;
									HRCPositionAny() : if (!contains(_request.params, param)) false else acc2;
								}
							};
							HRCParamValuesCompare(valueKeys) : {
								acc2
							}

						}
					} else acc2;
				})
				|> (\v -> if (v) {
					// If the suitable rule is found, apply the action
						switch (r.action : HttpResponseCompareAction) {
							HRCAResponseAcceptWithoutChecking() : Some(true);
							HRCAResponseCheckStatus() : {
								switch ((_request.response) : IScriptRequestRespose) {
									IScriptRequestOk(data) : {
										switch (_response : IScriptRequestRespose) {
											IScriptRequestOk(_data): {
												Some(
													strLeft(data, strIndexOf(data, "\n")) == strLeft(_data, strIndexOf(_data, "\n"))
												);
											};
											default: Some(false);
										}
									}
									IScriptRequestError(error) : {
										switch (_response : IScriptRequestRespose) {
											IScriptRequestError(_error): {
												Some(
													strLeft(error, strIndexOf(error, "\n")) == strLeft(_error, strIndexOf(_error, "\n"))
												);
											};
											default: Some(false);
										}
									}
									IScriptRequestStatus(status) : {
										switch (_response : IScriptRequestRespose) {
											IScriptRequestStatus(_status): {
												Some(status == _response.status);
											};
											default: Some(false);
										}
									}
								}
							}
							HRCAResponseCheckAll() : Some(_request.response == _response);
							HRCAResponseReject() : Some(false);
						}
					} else acc
				)
			} else acc
		})
		|> (\v0 -> either(v0, true))
	}
}
