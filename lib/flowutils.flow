
import maybe;
import net/url_parameter; // isUrlParameterTrue
import string;
import ds/arrayutils;

export {

	/* Once here was a bunch of functions. 
	 * However almost all of them are greenland specific and were quite useless in general appliance.
	 * So most of them are moved to greenland/greenlandutils.flow
	 */


	// checks for URL parameter &test=true
	isTest() -> bool;

	// No idea where to put it otherwise. This function is used in evey datawarp-generated file.
	// Fill free to move it some better place, but don't forget to update generated imports in flowwarp.flow
	// For value == Some(v) it returns [KeyValue(key, toStringNoExtraQuotes(v))]
	// For value == None it returns []
	// For other values it returns [KeyValue(toStringNoExtraQuotes(value))]
	buildKeyValueForPhp(key : string, value : ?) -> [KeyValue];
	idsArrayToRanges(ids : [int]) -> RequestIds;
	RequestIds ::= RequestIdsArray, RequestIdsRanges;
		RequestIdsArray(ids : [int]);
		RequestIdsRanges(ranges : [[int]]);
	
	// For x == Some(v) it returns fn(v)
	// For x == None(x) it returns alternative
	// For x == RequestIdsArray(v) it returns fn(v)
	// For x == RequestIdsRanges(v) it returns fn(v)
	// For other values it returns fn(x)
	eitherMapAnyType(x : flow, fn : (?) -> ??, alternative : ??) -> ??;
}

isTestRef : ref Maybe<bool> = ref None();
isTest() -> bool {
	onlyOnce(isTestRef, \ -> {
		isUrlParameterTrue("test")
	})
}

eitherMapAnyType(x : flow, fn : (?) -> ??, alternative : ??) -> ?? {
	if (isSameStructType(x, None()) || isSameStructType(x, Some(0))) {
		eitherMap(x, fn, alternative);
	} else if (isSameStructType(x, RequestIdsArray([]))) {
		fn(x.ids);
	} else if (isSameStructType(x, RequestIdsRanges([]))) {
		fn(x.ranges);
	} else {
		fn(x)
	}
}

buildKeyValueForPhp(key : string, value : ?) -> [KeyValue] {
	eitherMapAnyType(value, \v -> [KeyValue(key, toStringNoExtraQuotes(v))], [])
}

idsArrayToRanges(ids : [int]) -> RequestIds {
	if (ids != [] && isUrlParameterTrue("load_by_range")) {
		sorted = sort(ids);
		l = length(sorted);
		ranges = mapiConcat(sorted, \i, id -> {
			if (i > 0 && i < l && id - 1 == sorted[i - 1] && id + 1 == sorted[i + 1]) {
				[]
			} else if ((i == 0 || id - 1 != sorted[i - 1]) && i < l && id + 1 != sorted[i + 1]) {
				[id, id]
			} else {
				[id]
			}
		});
		if (length(ranges) < length(ids)) {
			RequestIdsRanges(filtermapi(ranges, \i, id -> {
				if (i % 2 == 0) {
					to = elementAt(ranges, i + 1, id);
					Some(ifArrayPush([id], to != id, to));
				} else {
					None()
				}
			}));
		} else {
			RequestIdsArray(ids);
		}
	} else {
		RequestIdsArray(ids);
	}
}
