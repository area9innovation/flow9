
import maybe;
import net/url_parameter; // isUrlParameterTrue
import string;
import ds/arrayutils;

export {

	/* Once here was a bunch of functions. 
	 * However almost all of them are greenland specific and were quite useless in general appliance.
	 * So most of them are moved to greenland/greenlandutils.flow
	 */


	// checks for URL parameter &test=true
	isTest() -> bool;

	// No idea where to put it otherwise. This function is used in evey datawarp-generated file.
	// Fill free to move it some better place, but don't forget to update generated imports in flowwarp.flow
	// For value == Some(v) it returns [KeyValue(key, toStringNoExtraQuotes(v))]
	// For value == None it returns []
	// For other values it returns [KeyValue(toStringNoExtraQuotes(value))]
	buildKeyValueForPhp(key : string, value : ?) -> [KeyValue];
	idsArrayToRanges(ids : [int]) -> RequestIds;
	RequestIds ::= RequestIdsArray, RequestIdsRanges;
		RequestIdsArray(ids : [int]);
		// ranges - an array of Pairs containing the start and end of the range
		RequestIdsRanges(ranges : [Pair<int, int>]);
	requestIdsToJson(requestIds : RequestIds) -> Json;
	
	// For x == Some(v) it returns fn(v)
	// For x == None(x) it returns alternative
	// For other values it returns fn(x)
	eitherMapAnyType(x : flow, fn : (?) -> ??, alternative : ??) -> ??;
}

isTestRef : ref Maybe<bool> = ref None();
isTest() -> bool {
	onlyOnce(isTestRef, \ -> {
		isUrlParameterTrue("test")
	})
}

eitherMapAnyType(x : flow, fn : (?) -> ??, alternative : ??) -> ?? {
	if (isSameStructType(x, None()) || isSameStructType(x, Some(0))) {
		eitherMap(x, fn, alternative);
	} else {
		fn(x)
	}
}

buildKeyValueForPhp(key : string, value : ?) -> [KeyValue] {
	if (isSameStructType(value, RequestIdsArray([])) || isSameStructType(value, RequestIdsRanges([]))) {
		switch (flow(value)) {
			RequestIdsArray(ids): [KeyValue(key, toStringNoExtraQuotes(ids))];
			RequestIdsRanges(ranges): buildRangesKeyValueForPhp(key, ranges);
		}
	} else {
		eitherMapAnyType(value, \v -> [KeyValue(key, toStringNoExtraQuotes(v))], []);
	}
}

buildRangesKeyValueForPhp(key : string, ranges : [Pair<int, int>]) -> [KeyValue] {
	values = map(ranges, \range -> {
		if (range.first == range.second) flow(range.first) else flow([range.first, range.second])
	});
	[KeyValue(key, toStringNoExtraQuotes(values))];
}

idsArrayToRanges(ids : [int]) -> RequestIds {
	if (ids != [] && isUrlParameterTrue("load_by_range")) {
		sorted = sort(ids);
		if (foldi(sorted, false, \i, acc, id -> acc || i > 0 && id - 1 == sorted[i - 1])) {
			last = length(sorted) - 1;
			list = foldi(sorted, makeList(), \i : int, acc : List<Pair<int, int>>, id : int -> {
				if (i == 0 || (id - 1 != sorted[i - 1] && id != sorted[i - 1])) {
					Cons(Pair(id, id), acc);
				} else if (i < last && (id + 1 == sorted[i + 1] || id == sorted[i + 1])) {
					acc;
				} else {
					head = headList(acc, Pair(id, id));
					Cons(Pair(head.first, id), tailList(acc));
				}
			});
			RequestIdsRanges(list2array(list));
		} else {
			RequestIdsArray(ids);
		}
	} else {
		RequestIdsArray(ids);
	}
}

requestIdsToJson(requestIds : RequestIds) -> Json {
	switch (requestIds) {
		RequestIdsArray(idsArray): {
			JsonArray(map(idsArray, \id ->
				JsonDouble(i2d(id))
			));
		};
		RequestIdsRanges(requestIdsRanges): {
			JsonArray(map(requestIdsRanges, \range -> {
				fromId = range.first;
				toId = range.second;
				if (fromId == toId) {
					JsonDouble(i2d(fromId));
				} else {
					JsonArray([JsonDouble(i2d(fromId)), JsonDouble(i2d(toId))]);
				}
			}));
		};
	}
}
