
import maybe;
import net/url_parameter; // isUrlParameterTrue
import string;
import ds/arrayutils;

export {

	/* Once here was a bunch of functions. 
	 * However almost all of them are greenland specific and were quite useless in general appliance.
	 * So most of them are moved to greenland/greenlandutils.flow
	 */


	// checks for URL parameter &test=true
	isTest() -> bool;

	// No idea where to put it otherwise. This function is used in evey datawarp-generated file.
	// Fill free to move it some better place, but don't forget to update generated imports in flowwarp.flow
	// For value == Some(v) it returns [KeyValue(key, toStringNoExtraQuotes(v))]
	// For value == None it returns []
	// For other values it returns [KeyValue(toStringNoExtraQuotes(value))]
	buildKeyValueForPhp(key : string, value : ?) -> [KeyValue];
	idsArrayToRanges(ids : [int]) -> RequestIds;
	RequestIds ::= RequestIdsArray, RequestIdsRanges;
		RequestIdsArray(ids : [int]);
		// ranges - an array of arrays containing the start and end of the range
		RequestIdsRanges(ranges : [[int]]);
	
	// For x == Some(v) it returns fn(v)
	// For x == None(x) it returns alternative
	// For x == RequestIdsArray(v) it returns fn(v)
	// For x == RequestIdsRanges(v) it returns fn(v)
	// For other values it returns fn(x)
	eitherMapAnyType(x : flow, fn : (?) -> ??, alternative : ??) -> ??;
}

isTestRef : ref Maybe<bool> = ref None();
isTest() -> bool {
	onlyOnce(isTestRef, \ -> {
		isUrlParameterTrue("test")
	})
}

eitherMapAnyType(x : flow, fn : (?) -> ??, alternative : ??) -> ?? {
	if (isSameStructType(x, None()) || isSameStructType(x, Some(0))) {
		eitherMap(x, fn, alternative);
	} else if (isSameStructType(x, RequestIdsArray([]))) {
		fn(x.ids);
	} else if (isSameStructType(x, RequestIdsRanges([]))) {
		fn(x.ranges);
	} else {
		fn(x)
	}
}

buildKeyValueForPhp(key : string, value : ?) -> [KeyValue] {
	eitherMapAnyType(value, \v -> [KeyValue(key, toStringNoExtraQuotes(v))], [])
}

idsArrayToRanges(ids : [int]) -> RequestIds {
	if (ids != [] && isUrlParameterTrue("load_by_range")) {
		sorted = sort(ids);
		if (foldi(sorted, false, \i, acc, id -> acc || i > 0 && id - 1 == sorted[i - 1])) {
			last = length(sorted) - 1;
			list = foldi(sorted, makeList(), \i : int, acc : List<[int]>, id : int -> {
				if (i == 0 || (id - 1 != sorted[i - 1] && id != sorted[i - 1])) {
					concatList(makeList1([id]), acc);
				} else if (i < last && (id + 1 == sorted[i + 1] || id == sorted[i + 1])) {
					acc;
				} else {
					head = headList(acc, [id]);
					concatList(makeList1(ifArrayPush(head, head != [id], id)), tailList(acc));
				}
			});
			RequestIdsRanges(list2array(list));
		} else {
			RequestIdsArray(ids);
		}
	} else {
		RequestIdsArray(ids);
	}
}
