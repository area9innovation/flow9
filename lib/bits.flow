// Â© Copyright 2011 Area9 Innovation. All rights reserved

import runtime;
import math;

export {
	// 2^n
	pot2(n : int) -> int;

	// Shift "a" left "n" bits 
	native bitShl : (a : int, n : int) -> int = Native.bitShl;

	// Shift "a" right "n" bits, where a is considered unsigned
	native bitUshr : (a : int, n : int) -> int = Native.bitUshr;
}

pots2 = generate(0, 32, \i -> pow(2, i));

pot2(n : int) -> int {
	pots2[n];
}

// Some targets have a native...
// ...others do not, but we have a fallback here
bitShl(a, b) {
	if (b == 0) {
		a;
	} else if (b >= 32) {
		0;
	} else {
		highest = bitAnd(a, pot2(31 - b));
		mask = pot2(31 - b) - 1;
		shifted = bitAnd(a, mask) * pot2(b);
		if (highest != 0) {
			bitOr(shifted, 0x80000000);
		} else {
			shifted;
		}
	}
}

// Some targets have a native...
// ...others do not, but we have a fallback here
bitUshr(a, b) {
	if (b == 0) {
		a;
	} else {
		// Only works for 31-bit ints
		shr = \a1, b1 -> {
			a1 / pot2(b1);
		};
		if (a < 0) {
			v = bitOr(shr(bitAnd(a, 0x7fffffff), b), pot2(31 - b));
			mask = pot2(32 - b) - 1;
			bitAnd(mask, v);
		} else {
			shr(a, b);
		}
	}
}
