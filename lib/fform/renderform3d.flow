import rendersupport3d;
import fform/renderfform;
import fusion_utils;

export {
	Point3D(x : double, y : double, z : double);
	zeroPoint3D = Point3D(0.0, 0.0, 0.0);
	makePoint3D() -> DynamicBehaviour<Point3D> { make(zeroPoint3D) };

	F3DStage(wh : Transform<WidthHeight>, scene : F3DObject, camera : F3DObject, style : [F3DStageStyle]) -> FForm;
		F3DStageStyle ::= F3DIgnoreMouseEvents, F3DExportScene, F3DTransformControlsEnabled, F3DAttachTransformControls, F3DCameraDistance,
			F3DOrbitControlsParameters;

			F3DIgnoreMouseEvents();
			F3DExportScene(fn : ref Maybe<(includeCamera : bool) -> string>);
			F3DTransformControlsEnabled(enabled : Transform<bool>); // const(false) by default, doesn't affect F3DTransformControls
			F3DAttachTransformControls(fn : ref (clip : native, attach : bool) -> void);
			F3DCameraDistance(min : double, max : double); // min = 0.0, max = 1000.0 by default
			F3DOrbitControlsParameters(parameters : [KeyValue]);

	F3DObject ::= F3DScene, F3DMutable, F3DVisible, F3DAlpha, F3DPosition, F3DRotation, F3DScale, F3DLookAt, F3DOnLoad,
		F3DInspectRotation, F3DInspectPosition, F3DInspectScale, F3DInspectBoundingSphereCenter, F3DInspectBoundingSphereMin,
		F3DInspectBoundingSphereMax, F3DCamera, F3DLight, F3DMesh, F3DTransformControls, F3DLoader, F3DGLTFLoader, F3DSceneLoader,
		F3DChildren, F3DNative, F3DJsonObject, F3DObject2Json, F3DBoxHelper, F3DAxesHelper, F3DGridHelper, F3DInteractive, F3DEmpty;

		F3DScene(objects : Transform<[F3DObject]>);
		F3DGroup(objects : [F3DObject]) -> F3DScene { F3DScene(const(objects)); };
		F3DMutable(object : Transform<F3DObject>);

		F3DSelect(t : Transform<?>, fn : (?) -> F3DObject) -> F3DObject { F3DMutable(fselect(t, fn |> FLift)); };
		F3DSelect2(t1 : Transform<?>, t2 : Transform<??>, fn : (?, ??) -> F3DObject) -> F3DObject { F3DMutable(fselect2(t1, t2, fn |> FLift2)); };
		F3DSelect3(t1 : Transform<?>, t2 : Transform<??>, t3 : Transform<???>, fn : (?, ??, ???) -> F3DObject) -> F3DObject { F3DMutable(fselect3(t1, t2, t3, fn)); };

		F3DVisible(object : F3DObject, visible : Transform<bool>);
		F3DAlpha(object : F3DObject, alpha : Transform<double>);
		F3DPosition(object : F3DObject, point : Transform<Point3D>);
		F3DRotation(object : F3DObject, point : Transform<Point3D>);
		F3DScale(object : F3DObject, point : Transform<Point3D>);
		F3DLookAt(object : F3DObject, point : Transform<Point3D>, update : DynamicBehaviour<bool>);

		F3DOnLoad(object : F3DObject, onLoad : (native) -> void);

		F3DInspectRotation(object : F3DObject, point : DynamicBehaviour<Point3D>);
		F3DInspectPosition(object : F3DObject, point : DynamicBehaviour<Point3D>);
		F3DInspectScale(object : F3DObject, point : DynamicBehaviour<Point3D>);

		F3DInspectBoundingSphereCenter(object : F3DObject, point : DynamicBehaviour<Point3D>);
		F3DInspectBoundingSphereMin(object : F3DObject, point : DynamicBehaviour<Point3D>);
		F3DInspectBoundingSphereMax(object : F3DObject, point : DynamicBehaviour<Point3D>);

		F3DTransformControls(object : F3DObject, enabled : DynamicBehaviour<bool>);

		F3DLoader(objUrl : string, mtlUrl : string);
		F3DGLTFLoader(url : string, onAnimation : ([F3DAnimation]) -> void);
			F3DAnimation(start : () -> void, stop : () -> void, duration : DynamicBehaviour<double>);

		F3DSceneLoader(url : string);
		F3DChildren(object : F3DObject, fn : (F3DNative) -> F3DNative);

		F3DNative ::= F3DNativeObject, F3DNativeScene, F3DNativeMutable, F3DNativeOnLoad;
			F3DNativeObject(object : native);
			F3DNativeScene(scene : native, objects : Transform<[F3DNative]>);
			F3DNativeMutable(object : Transform<F3DNative>);
			F3DNativeOnLoad(object : F3DNative, onLoad : (native) -> void);

		F3DJsonObject(json : string);
		F3DObject2Json(object : F3DObject, jsonFn : ref Maybe<(includeCamera : bool) -> string>);

		F3DBoxHelper(object : F3DObject, enabled : DynamicBehaviour<bool>);
		F3DAxesHelper(size : double);
		F3DGridHelper(size : double, divisions : int, colorCenterLine : int, colorGrid : int);

		F3DInteractive(object : F3DObject, listeners : [F3DEventHandler]);
			F3DEventHandler ::= F3DMouseDown, F3DMouseUp;
				F3DMouseDown(fn : (handled : bool) -> bool);
				F3DMouseUp(fn : (handled : bool) -> bool);

		F3DLight ::= F3DPointLight, F3DSpotLight, F3DAmbientLight;
			F3DPointLight(color : Transform<int>, intensity : Transform<double>, distance : Transform<double>, decayAmount : Transform<double>);
			F3DSpotLight(color : Transform<int>, intensity : Transform<double>, distance : Transform<double>, angle : Transform<double>, penumbra : Transform<double>, decayAmount : Transform<double>);
			F3DAmbientLight(color : Transform<int>, intensity : Transform<double>);

		F3DCamera ::= F3DPerspectiveCamera;
			F3DPerspectiveCamera(fov : Transform<double>, aspect : Transform<double>, near : Transform<double>, far : Transform<double>);

		F3DMesh(geometry : F3DGeometry, materials : [F3DMaterial], parameters : [KeyValue]);
			F3DGeometry ::= F3DBoxGeometry, F3DSphereGeometry, F3DCircleGeometry, F3DConeGeometry, F3DCylinderGeometry, F3DNativeGeometry, F3DBufferGeometry;
				F3DBoxGeometry(width : double, height : double, depth : double, widthSegments : int, heightSegments : int, depthSegments : int);
				F3DSphereGeometry(radius : double, widthSegments : int, heightSegments : int, phiStart : double, phiLength : double, thetaStart : double, thetaLength : double);
				F3DCircleGeometry(radius : double, segments : int, thetaStart : double, thetaLength : double);
				F3DConeGeometry(radius : double, height : double, radialSegments : int, heightSegments : int, openEnded : bool, thetaStart : double, thetaLength : double);
				F3DCylinderGeometry(radiusTop : double, radiusBottom : double, height : double, radialSegments : int, heightSegments : int, openEnded : bool, thetaStart : double, thetaLength : double);
				F3DNativeGeometry(geometry : native);
			F3DBufferGeometry ::= F3DSphereBufferGeometry;
				F3DSphereBufferGeometry(radius : double, widthSegments : int, heightSegments : int, phiStart : double, phiLength : double,
					thetaStart : double, thetaLength : double, attributes : Maybe<F3DBufferGeometryAttributes>);

					F3DBufferGeometryAttributes(
						get : [string], // Attributes names to get from buffer geometry, these attributes data is passed as 'attributes' to 'add' function
						add : (attributes : Tree<string, [[double]]>) -> Tree<string, [[double]]> // Attributes to add to buffer geometry
					);

			F3DMaterial ::= F3DMeshBasicMaterial, F3DMeshStandardMaterial, F3DMeshNormalMaterial, F3DShaderMaterial, F3DNativeMaterials,
				F3DMaterialTexture, F3DMaterialAlphaTexture, F3DMaterialDisplacementTexture, F3DMaterialBumpTexture,
				F3DMaterialOpacity, F3DMaterialVisible;

				F3DMeshBasicMaterial(color : int, parameters : [KeyValue]);
				F3DMeshStandardMaterial(color : int, parameters : [KeyValue]);
				F3DMeshNormalMaterial(color : int, parameters : [KeyValue]);
				F3DShaderMaterial(uniforms : string, vertexShader : string, fragmentShader : string, parameters : [KeyValue]);
				F3DNativeMaterials(materials : native);

				F3DMaterialTexture(material : F3DMaterial, texture : F3DTexture);
				F3DMaterialAlphaTexture(material : F3DMaterial, texture : F3DTexture);
				F3DMaterialDisplacementTexture(material : F3DMaterial, texture : F3DTexture, scale : Transform<double>, bias : Transform<double>);
				F3DMaterialBumpTexture(material : F3DMaterial, texture : F3DTexture, scale : Transform<double>);

					F3DTexture ::= F3DTextureLoader, F3DDataTexture, F3DFFormTexture, F3DTextureRotation, F3DTextureOffset;

						F3DTextureLoader(url : string, onLoad : () -> void, parameters : [KeyValue]);
						F3DDataTexture(data : [int], width : int, height : int, parameters : [KeyValue]);
						F3DFFormTexture(fform : FForm, parameters : [KeyValue]);
						F3DTextureRotation(material : F3DTexture, rotation : Transform<double>);
						F3DTextureOffset(material : F3DTexture, point : Transform<Point>);


				F3DMaterialOpacity(material : F3DMaterial, opacity : Transform<double>);
				F3DMaterialVisible(material : F3DMaterial, visible : Transform<bool>);
				F3DMaterialAlpha(material : F3DMaterial, alpha : Transform<double>) -> F3DMaterialOpacity { F3DMaterialOpacity(material, alpha) };

		F3DEmpty();
}

handled3DMouseDown : ref bool = ref false;
handled3DMouseUp : ref bool = ref false;

F3DStage(wh : Transform<WidthHeight>, scene : F3DObject, camera : F3DObject, style : [F3DStageStyle]) -> FForm {
	if (js) {
		container = make(FEmpty());

		load3DLibraries(\ -> {
			metrics = make(FormMetrics(0., 0., 0., 0.));
			clip = make3DStage(fgetValue(fwidth(wh)), fgetValue(fheight(wh)));
			transformControlsEnabled = extractStruct(style, F3DTransformControlsEnabled(const(false))).enabled;
			maybeApply(
				tryExtractStruct(style, F3DAttachTransformControls(ref nop2)),
				\es -> es.fn := \c, b -> if (b) attach3DTransformControls(clip, c) else detach3DTransformControls(clip, c)
			);

			next(
				container,
				FNativeForm(
					FEmpty(),
					metrics,
					\ -> FEmpty(),
					\__, __, __ ->
						NativeRenderResult(
							[clip],
							concat3(
								[
									makeSubscribe(wh, \v -> {
										setClipWidth(clip, v.width);
										setClipHeight(clip, v.height);
										nextDistinct(metrics, FormMetrics(v.width, v.height, v.height, v.height));
									})()
								],
								render3dform(camera, clip, const(false), \c -> {
										cameraDistance = extractStruct(style, F3DCameraDistance(0.0, 1000.0));
										parameters =
											concat(
												extractStruct(style, F3DOrbitControlsParameters([])).parameters,
												[
													KeyValue("minDistance", toString(cameraDistance.min)),
													KeyValue("maxDistance", toString(cameraDistance.max))
												]
											);

										set3DCamera(clip, c, map(parameters, \v -> [v.key, v.value]));

										[];
									}
								),
								render3dform(scene, clip, transformControlsEnabled, \s -> {
									set3DScene(clip, s);

									maybeApply(tryExtractStruct(style, F3DExportScene(ref None())), \es ->
										es.fn := Some(\includeCamera -> get3DObjectJSON(s, includeCamera))
									);

									addF3DMouseListeners(clip, s, transformControlsEnabled);
								})
							)
							|> (\f -> \ -> applyall(f))
						)
				)
				|> (\f ->
					if (!contains(style, F3DIgnoreMouseEvents())) {
						mouseDown = make(false);

						FGroup2(
							FInteractive(
								[
									MouseDown(\mi -> {
										if (mi.inside()) {
											emit3DMouseEvent(
												clip,
												"mousedown",
												mi.x,
												mi.y
											);

											if (!^handled3DMouseDown) {
												clear3DTransformControls(clip);
											}
										}

										false;
									}),
									MouseUp(\mi -> {
										emit3DMouseEvent(
											clip,
											"mouseup",
											mi().x,
											mi().y
										);

										false;
									}),
									MouseMiddleDown(\mi -> {
										if (mi.inside()) {
											emit3DMouseEvent(
												clip,
												"mousemiddledown",
												mi.x,
												mi.y
											);
										}

										false;
									}),
									MouseMiddleUp(\mi -> {
										emit3DMouseEvent(
											clip,
											"mousemiddleup",
											mi().x,
											mi().y
										);

										false;
									}),
									MouseRightDown(\mi -> {
										if (mi.inside()) {
											emit3DMouseEvent(
												clip,
												"mouserightdown",
												mi.x,
												mi.y
											);
										}

										false;
									}),
									MouseRightUp(\mi -> {
										emit3DMouseEvent(
											clip,
											"mouserightup",
											mi().x,
											mi().y
										);

										false;
									}),
									MouseMove(\mi -> {
										if (mi().inside) {
											emit3DMouseEvent(
												clip,
												"mousemove",
												mi().x,
												mi().y
											);
										}

										false;
									}),
									KeyDown(\ke -> {
										emit3DKeyEvent(
											clip,
											"keydown",
											ke.utf,
											ke.ctrl,
											ke.shift,
											ke.alt,
											ke.meta,
											ke.keycode
										);
									}),
									KeyUp(\ke -> {
										emit3DKeyEvent(
											clip,
											"keyup",
											ke.utf,
											ke.ctrl,
											ke.shift,
											ke.alt,
											ke.meta,
											ke.keycode
										);
									}),
									FineGrainMouseWheel(\mi -> {
										if (mi.inside) {
											emit3DMouseEvent(
												clip,
												"wheel",
												-mi.dx,
												-mi.dy
											);
										}
									}),
									TouchStart(\mi -> {
										if (exists(mi.inside, apply0)) {
											emit3DTouchEvent(
												clip,
												"touchstart",
												map(mi.points, \p -> [p.x, p.y])
											);

											if (!^handled3DMouseDown) {
												clear3DTransformControls(clip);
											}
										}

										false;
									}),
									TouchMove(\mi -> {
										emit3DTouchEvent(
											clip,
											"touchmove",
											map(mi.points, \p -> [p.x, p.y])
										);

										false;
									}),
									TouchEnd(\mi -> {
										emit3DTouchEvent(
											clip,
											"touchend",
											map(mi.points, \p -> [p.x, p.y])
										);

										false;
									})
								],
								FGraphics(fselect(wh, FLift(\v -> [GRect(0.0, 0.0, v.width, v.height)])), const([Fill(0x000000), FillOpacity(0.0)])),
							),
							f,
							false
						);
					} else {
						f;
					}
				)
			);
		});

		FMutable(container);
	} else {
		FEmpty();
	}
}

render3dform(object : F3DObject, stage : native, transformControlsEnabled : Transform<bool>, onLoad : (native) -> [() -> void]) -> [() -> void] {
	switch (object : F3DObject) {
		F3DEmpty() : [];
		F3DScene(objects) : {
			scene = make3DScene();

			concat(
				onLoad(scene),
				[
					fiteriu(objects, \index, o -> {
						render3dform(
							o,
							stage,
							transformControlsEnabled,
							\c ->
								concat(
									addF3DMouseListeners(stage, c, transformControlsEnabled),
									[
										makeSubscribe(index, \i -> add3DChildAt(scene, c, i))(),
										\ -> remove3DChild(scene, c)
									]
								)
						)
					})
				]
			)
		}
		F3DMutable(innerObject) : {
			[
				makeSubscribeUns(innerObject, \obj ->
					render3dform(
						obj,
						stage,
						transformControlsEnabled,
						onLoad
					)
				)()
			]
		}
		F3DNativeMutable(innerObject) : {
			[
				makeSubscribeUns(innerObject, \obj ->
					render3dform(
						obj,
						stage,
						transformControlsEnabled,
						onLoad
					)
				)()
			]
		}
		F3DNativeOnLoad(innerObject, innerOnLoad) : {
			r = render3dform(
				innerObject,
				stage,
				transformControlsEnabled,
				\clip -> {
					d = onLoad(clip);
					innerOnLoad(clip);
					d;
				}
			);

			r;
		}
		F3DVisible(innerObject, visible) : {
			r = render3dform(
				innerObject,
				stage,
				transformControlsEnabled,
				\clip -> {
					concat(
						onLoad(clip),
						[
							makeSubscribe(visible, \v -> set3DObjectVisible(clip, v))(),
						]
					)
				}
			);

			r;
		}
		F3DAlpha(innerObject, alpha) : {
			r = render3dform(
				innerObject,
				stage,
				transformControlsEnabled,
				\clip -> {
					concat(
						onLoad(clip),
						[
							makeSubscribe(alpha, \v -> set3DObjectAlpha(clip, v))(),
						]
					)
				}
			);

			r;
		}
		F3DPosition(innerObject, point) : {
			r = render3dform(
				innerObject,
				stage,
				transformControlsEnabled,
				\clip -> {
					concat(
						onLoad(clip),
						[
							makeSubscribe(point, \v -> {
								set3DObjectX(clip, v.x);
								set3DObjectY(clip, v.y);
								set3DObjectZ(clip, v.z);
							})()
						]
					)
				}
			);

			r;
		}
		F3DRotation(innerObject, point) : {
			r = render3dform(
				innerObject,
				stage,
				transformControlsEnabled,
				\clip ->
					concat(
						onLoad(clip),
						[
							makeSubscribe(point, \v -> {
								set3DObjectRotationX(clip, v.x);
								set3DObjectRotationY(clip, v.y);
								set3DObjectRotationZ(clip, v.z);
							})()
						]
					)
			);

			r;
		}
		F3DScale(innerObject, point) : {
			r = render3dform(
				innerObject,
				stage,
				transformControlsEnabled,
				\clip ->
					concat(
						onLoad(clip),
						[
							makeSubscribe(point, \v -> {
								set3DObjectScaleX(clip, v.x);
								set3DObjectScaleY(clip, v.y);
								set3DObjectScaleZ(clip, v.z);
							})()
						]
					)
			);

			r;
		}
		F3DLookAt(innerObject, point, update) : {
			r = render3dform(
				innerObject,
				stage,
				transformControlsEnabled,
				\clip ->
					concat(
						onLoad(clip),
						[
							make2Subscribe(point, update, \v, __ -> set3DObjectLookAt(clip, v.x, v.y, v.z))()
						]
					)
			);

			r;
		}
		F3DOnLoad(innerObject, innerOnLoad) : {
			r = render3dform(
				innerObject,
				stage,
				transformControlsEnabled,
				\clip -> {
					d = onLoad(clip);
					innerOnLoad(clip);
					d;
				}
			);

			r;
		}
		F3DInspectRotation(innerObject, point) : {
			r = render3dform(
				innerObject,
				stage,
				transformControlsEnabled,
				\clip ->
					concat(
						onLoad(clip),
						[
							add3DObjectRotationListener(clip, \nx, ny, nz -> {
								nextDistinct(point, Point3D(nx, ny, nz));
							})
						]
					)
			);

			r;
		}
		F3DInspectPosition(innerObject, point) : {
			r = render3dform(
				innerObject,
				stage,
				transformControlsEnabled,
				\clip ->
					concat(
						onLoad(clip),
						[
							add3DObjectPositionListener(clip, \nx, ny, nz -> {
								nextDistinct(point, Point3D(nx, ny, nz));
							})
						]
					)
			);

			r;
		}
		F3DInspectScale(innerObject, point) : {
			r = render3dform(
				innerObject,
				stage,
				transformControlsEnabled,
				\clip ->
					concat(
						onLoad(clip),
						[
							add3DObjectScaleListener(clip, \nx, ny, nz -> {
								nextDistinct(point, Point3D(nx, ny, nz));
							})
						]
					)
			);

			r;
		}
		F3DInspectBoundingSphereCenter(innerObject, point) : {
			r = render3dform(
				innerObject,
				stage,
				transformControlsEnabled,
				\clip ->
					concat(
						onLoad(clip),
						[
							add3DObjectBoundingBoxListener(clip, \box -> {
								nextDistinct(point, Point3D((box[0][0] + box[1][0]) / 2.0, (box[0][1] + box[1][1]) / 2.0, (box[0][2] + box[1][2]) / 2.0));
							})
						]
					)
			);

			r;
		}
		F3DInspectBoundingSphereMin(innerObject, point) : {
			r = render3dform(
				innerObject,
				stage,
				transformControlsEnabled,
				\clip ->
					concat(
						onLoad(clip),
						[
							add3DObjectBoundingBoxListener(clip, \box -> {
								nextDistinct(point, Point3D(box[0][0], box[0][1], box[0][2]));
							})
						]
					)
			);

			r;
		}
		F3DInspectBoundingSphereMax(innerObject, point) : {
			r = render3dform(
				innerObject,
				stage,
				transformControlsEnabled,
				\clip ->
					concat(
						onLoad(clip),
						[
							add3DObjectBoundingBoxListener(clip, \box -> {
								nextDistinct(point, Point3D(box[1][0], box[1][1], box[1][2]));
							})
						]
					)
			);

			r;
		}
		F3DTransformControls(innerObject, enabled) : {
			r = render3dform(
				innerObject,
				stage,
				transformControlsEnabled,
				\clip ->
					concat(
						onLoad(clip),
						[
							add3DEventListener(clip, "detached", \ -> nextDistinct(enabled, false)),
							add3DEventListener(clip, "attached", \ -> nextDistinct(enabled, true)),
							makeSubscribe(enabled, \en ->
								if (en)
									attach3DTransformControls(stage, clip)
								else
									detach3DTransformControls(stage, clip)
							)()
						]
					)
			);

			r;
		}
		F3DLight() : {
			renderF3DLight(object, onLoad);
		}
		F3DCamera() : {
			renderF3DCamera(object, onLoad);
		}
		F3DMesh(geometry, materials, parameters) : {
			materialDisposers = map(materials, \m -> renderF3DMaterial(m, stage));

			concat(
				map(materialDisposers, \m -> m.disposers) |> concatA,
				onLoad(make3DMesh(renderF3DGeometry(geometry), map(materialDisposers, \m -> m.clip), map(parameters, \v -> [v.key, v.value])))
			);
		}
		F3DLoader(objUrl, mtlUrl) : {
			uns = ref [];

			load3DObject(objUrl, mtlUrl, \obj -> {
				uns := onLoad(obj);
			});

			[
				\ -> dispUnsA(uns)
			]
		}
		F3DGLTFLoader(url, onAnimation) : {
			uns = ref [];

			load3DGLTFObject(url, \animations, scene, scenes, cameras, assets -> {
				uns := onLoad(scene);

				if (length(animations) > 0) {
					mixer = create3DAnimationMixer(scene);

					onAnimation(
						map(animations, \a -> {
							aUns = ref None();
							duration = make(get3DAnimationDuration(a));

							uns :=
								concat(
									^uns,
									[
										\ -> dispUns2(aUns),
										makeSubscribe2(duration, \d -> set3DAnimationDuration(a, d))()
									]
								);

							F3DAnimation(
								\ -> {
									aUns := Some(start3DAnimationMixer(mixer, a));
								},
								\ -> {
									dispUns2(aUns);
								},
								duration
							)
						})
					)
				}
			});

			[
				\ -> dispUnsA(uns)
			]
		}
		F3DSceneLoader(url) : {
			uns = ref [];

			load3DScene(url, \obj -> {
				uns := onLoad(obj);
			});

			[
				\ -> dispUnsA(uns)
			]
		}
		F3DChildren(innerObject, fn) : {
			r = render3dform(
				innerObject,
				stage,
				transformControlsEnabled,
				\clip -> {
					parsedClip = parseF3DNativeObject(clip);

					concat(
						parsedClip.second,
						render3dform(
							fn(parsedClip.first),
							stage,
							transformControlsEnabled,
							onLoad
						)
					)
				}
			);

			r;
		}
		F3DNativeObject(nativeObject) : {
			onLoad(nativeObject);
		}
		F3DNativeScene(scene, objects) : {
			concat(
				onLoad(scene),
				[
					fiteriu(objects, \index, o -> {
						render3dform(
							o,
							stage,
							transformControlsEnabled,
							\c ->
								concat(
									addF3DMouseListeners(stage, c, transformControlsEnabled),
									[
										makeSubscribe(index, \i -> add3DChildAt(scene, c, i))(),
										// \ -> remove3DChild(scene, c) TODO:
									]
								)
						)
					})
				]
			)
		}
		F3DJsonObject(json) : {
			onLoad(make3DObjectFromJSON(json));
		}
		F3DObject2Json(innerObject, jsonFn) : {
			r = render3dform(
				innerObject,
				stage,
				transformControlsEnabled,
				\clip -> {
					jsonFn := Some(\includeCamera -> get3DObjectJSON(clip, includeCamera));

					onLoad(clip);
				}
			);

			r;
		}
		F3DBoxHelper(innerObject, enabled) : {
			r = render3dform(
				innerObject,
				stage,
				transformControlsEnabled,
				\clip ->
					concat(
						onLoad(clip),
						[
							makeSubscribe(enabled, \en ->
								if (en)
									attach3DBoxHelper(stage, clip)
								else
									detach3DBoxHelper(stage, clip)
							)()
						]
					)
			);

			r;
		}
		F3DAxesHelper(size) : {
			onLoad(make3DAxesHelper(size));
		}
		F3DGridHelper(size, divisions, colorCenterLine, colorGrid) : {
			onLoad(make3DGridHelper(size, divisions, colorCenterLine, colorGrid));
		}
		F3DInteractive(innerObject, listeners) : {
			r = render3dform(
				innerObject,
				stage,
				transformControlsEnabled,
				\clip ->
					concat(
						onLoad(clip),
						map(listeners, \l -> {
							switch (l : F3DEventHandler) {
								F3DMouseDown(fn): {
									add3DEventListener(clip, "mousedown", \ -> {
										handled3DMouseDown := fn(^handled3DMouseDown);

										if (^handled3DMouseDown) {
											deferred(\ -> handled3DMouseDown := false);
										}

									});
								}
								F3DMouseUp(fn): {
									add3DEventListener(clip, "mouseup", \ -> {
										handled3DMouseUp := fn(^handled3DMouseUp);

										if (^handled3DMouseUp) {
											deferred(\ -> handled3DMouseUp := false);
										}
									});
								}
							}
						})
					)
			);

			r;
		}
	}
}

renderF3DCamera(camera : F3DCamera, onLoad : (native) -> [() -> void]) -> [() -> void] {
	switch (camera : F3DCamera) {
		F3DPerspectiveCamera(fov, aspect, near, far): {
			clip = make3DPerspectiveCamera(fgetValue(fov), fgetValue(aspect), fgetValue(near), fgetValue(far));

			concat(
				onLoad(clip),
				[
					makeSubscribe2(fov, \v -> set3DCameraFov(clip, v))(),
					makeSubscribe2(aspect, \v -> set3DCameraAspect(clip, v))(),
					makeSubscribe2(near, \v -> set3DCameraNear(clip, v))(),
					makeSubscribe2(far, \v -> set3DCameraFar(clip, v))()
				]
			)
		}
	}
}

renderF3DLight(light : F3DLight, onLoad : (native) -> [() -> void]) -> [() -> void] {
	switch (light : F3DLight) {
		F3DPointLight(color, intensity, distance, decayAmount): {
			clip = make3DPointLight(fgetValue(color), fgetValue(intensity), fgetValue(distance), fgetValue(decayAmount));

			concat(
				onLoad(clip),
				[
					makeSubscribe2(color, \v -> set3DLightColor(clip, v))(),
					makeSubscribe2(intensity, \v -> set3DLightIntensity(clip, v))(),
					makeSubscribe2(distance, \v -> set3DLightDistance(clip, v))(),
					makeSubscribe2(decayAmount, \v -> set3DLightDecay(clip, v))()
				]
			)
		}
		F3DSpotLight(color, intensity, distance, angle, penumbra, decayAmount): {
			clip = make3DSpotLight(fgetValue(color), fgetValue(intensity), fgetValue(distance), fgetValue(angle), fgetValue(penumbra), fgetValue(decayAmount));

			concat(
				onLoad(clip),
				[
					makeSubscribe2(color, \v -> set3DLightColor(clip, v))(),
					makeSubscribe2(intensity, \v -> set3DLightIntensity(clip, v))(),
					makeSubscribe2(distance, \v -> set3DLightDistance(clip, v))(),
					makeSubscribe2(angle, \v -> set3DLightAngle(clip, v))(),
					makeSubscribe2(penumbra, \v -> set3DLightPenumbra(clip, v))(),
					makeSubscribe2(decayAmount, \v -> set3DLightDecay(clip, v))()
				]
			)
		}
		F3DAmbientLight(color, intensity): {
			clip = make3DAmbientLight(fgetValue(color), fgetValue(intensity));

			concat(
				onLoad(clip),
				[
					makeSubscribe2(color, \v -> set3DLightColor(clip, v))(),
					makeSubscribe2(intensity, \v -> set3DLightIntensity(clip, v))()
				]
			)
		}
	}
}

renderF3DGeometry(geometry : F3DGeometry) -> native {
	switch (geometry : F3DGeometry) {
		F3DBoxGeometry(width, height, depth, widthSegments, heightSegments, depthSegments) : {
			make3DBoxGeometry(width, height, depth, widthSegments, heightSegments, depthSegments);
		}
		F3DSphereGeometry(radius, widthSegments, heightSegments, phiStart, phiLength, thetaStart, thetaLength) : {
			make3DSphereGeometry(radius, widthSegments, heightSegments, phiStart, phiLength, thetaStart, thetaLength);
		}
		F3DSphereBufferGeometry(radius, widthSegments, heightSegments, phiStart, phiLength, thetaStart, thetaLength, attributesM) : {
			g = make3DSphereBufferGeometry(radius, widthSegments, heightSegments, phiStart, phiLength, thetaStart, thetaLength);

			maybeApply(
				attributesM,
				\attributes ->
					iter(
						tree2pairs(attributes.add(pairs2tree(map(attributes.get, \a -> Pair(a, get3DBufferGeometryAttribute(g, a)))))),
						\p -> add3DBufferGeometryAttribute(g, p.first, p.second)
					)
			);

			g;
		}
		F3DCircleGeometry(radius, segments, thetaStart, thetaLength) : {
			make3DCircleGeometry(radius, segments, thetaStart, thetaLength);
		}
		F3DConeGeometry(radius, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength) : {
			make3DConeGeometry(radius, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength);
		}
		F3DCylinderGeometry(radiusTop, radiusBottom, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength) : {
			make3DCylinderGeometry(radiusTop, radiusBottom, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength);
		}
		F3DNativeGeometry(innerGeometry) : {
			innerGeometry;
		}
	}
}

F3DRenderResult(clip : native, disposers : [() -> void]);

renderF3DMaterial(material : F3DMaterial, stage : native) -> F3DRenderResult {
	switch (material : F3DMaterial) {
		F3DMeshBasicMaterial(color, parameters) : {
			F3DRenderResult(
				make3DMeshBasicMaterial(color, map(parameters, \v -> [v.key, v.value])),
				[]
			);
		}
		F3DMeshStandardMaterial(color, parameters) : {
			F3DRenderResult(
				make3DMeshStandardMaterial(color, map(parameters, \v -> [v.key, v.value])),
				[]
			);
		}
		F3DMeshNormalMaterial(color, parameters) : {
			F3DRenderResult(
				make3DMeshNormalMaterial(color, map(parameters, \v -> [v.key, v.value])),
				[]
			);
		}
		F3DShaderMaterial(uniforms, vertexShader, fragmentShader, parameters) : {
			m = make3DShaderMaterial(stage, uniforms, vertexShader, fragmentShader, map(parameters, \v -> [v.key, v.value]));

			F3DRenderResult(
				m,
				[
					addDrawFrameEventListener(\ts -> {
						set3DShaderMaterialUniformValue(m, "iTime", d2s(ts / 1000.0));
					}),
					addEventListener(getStage(), "resize", \ -> {
						wd = getClipWidth(stage);
						hgt = getClipHeight(stage);

						set3DShaderMaterialUniformValue(m, "iResolution", "new THREE.Vector2(" + d2s(wd) + ", " + d2s(hgt) + ")");
						set3DShaderMaterialUniformValue(m, "iAspectRatio", d2s(hgt / wd));
					})
				]
			);
		}
		F3DNativeMaterials(innerMaterials) : {
			F3DRenderResult(innerMaterials, []);
		}
		F3DMaterialTexture(innerMaterial, texture) : {
			m = renderF3DMaterial(innerMaterial, stage);
			t = renderF3DTexture(texture);
			set3DMaterialMap(m.clip, t.clip);

			F3DRenderResult(m.clip, concat(m.disposers, t.disposers));
		}
		F3DMaterialAlphaTexture(innerMaterial, texture) : {
			m = renderF3DMaterial(innerMaterial, stage);
			t = renderF3DTexture(texture);
			set3DMaterialAlphaMap(m.clip, t.clip);

			F3DRenderResult(m.clip, concat(m.disposers, t.disposers));
		}
		F3DMaterialDisplacementTexture(innerMaterial, texture, scale, bias) : {
			m = renderF3DMaterial(innerMaterial, stage);
			t = renderF3DTexture(texture);
			set3DMaterialDisplacementMap(m.clip, t.clip, fgetValue(scale), fgetValue(bias));

			F3DRenderResult(m.clip, concat(m.disposers, t.disposers));
		}
		F3DMaterialBumpTexture(innerMaterial, texture, scale) : {
			m = renderF3DMaterial(innerMaterial, stage);
			t = renderF3DTexture(texture);
			set3DMaterialBumpMap(m.clip, t.clip, fgetValue(scale));

			F3DRenderResult(m.clip, concat(m.disposers, t.disposers));
		}
		F3DMaterialOpacity(innerMaterial, opacity) : {
			m = renderF3DMaterial(innerMaterial, stage);

			F3DRenderResult(
				m.clip,
				arrayPush(
					m.disposers,
					makeSubscribe(opacity, \v -> set3DMaterialOpacity(m.clip, v))()
				)
			);
		}
		F3DMaterialVisible(innerMaterial, visible) : {
			m = renderF3DMaterial(innerMaterial, stage);

			F3DRenderResult(
				m.clip,
				arrayPush(
					m.disposers,
					makeSubscribe(visible, \v -> set3DMaterialVisible(m.clip, v))()
				)
			);
		}
	}
}

renderF3DTexture(texture : F3DTexture) -> F3DRenderResult {
	switch (texture : F3DTexture) {
		F3DTextureLoader(url, onLoad, parameters) : {
			F3DRenderResult(
				load3DTexture(url, \__ -> onLoad(), map(parameters, \v -> [v.key, v.value])),
				[]
			);
		}
		F3DDataTexture(data, width, height, parameters) : {
			F3DRenderResult(
				make3DDataTexture(data, width, height, map(parameters, \v -> [v.key, v.value])),
				[]
			);
		}
		F3DFFormTexture(fform, parameters) : {
			d = renderFForm(fform, const([0]));
			t = make3DCanvasTexture(d.clips[0], map(parameters, \v -> [v.key, v.value]));
			applyall(d.disposers);
			t;

			F3DRenderResult(t, []);
		}
		F3DTextureRotation(innerTexture, rotation) : {
			t = renderF3DTexture(innerTexture);

			F3DRenderResult(
				t.clip,
				arrayPush(
					t.disposers,
					makeSubscribe(rotation, \r -> set3DTextureRotation(t.clip, r))()
				)
			)
		}
		F3DTextureOffset(innerTexture, point) : {
			t = renderF3DTexture(innerTexture);

			F3DRenderResult(
				t.clip,
				arrayPush(
					t.disposers,
					makeSubscribe(point, \p -> {
						set3DTextureOffsetX(t.clip, p.x);
						set3DTextureOffsetY(t.clip, p.y);
					})()
				)
			)
		}
	}
}

parseF3DNativeObject(object : native) -> Pair<F3DNative, [() -> void]> {
	children = make(get3DObjectChildren(object));
	uns = ref nop;

	Pair(
		F3DNativeScene(object, fmapu(children, parseF3DNativeObject)),
		[
			add3DEventListener(object, "childrenchanged", \ -> {
				^uns();
				newChildren = get3DObjectChildren(object);

				if (map(getValue(children), get3DObjectId) != map(newChildren, get3DObjectId)) {
					uns := interruptibleTimer(33, \ -> next(children, newChildren));
				}
			}),
			\ -> ^uns()
		]
	)
}

addF3DMouseListeners(stage : native, object : native, transformControlsEnabled : Transform<bool>) -> [() -> void] {
	if (transformControlsEnabled != const(false)) {
		children = get3DObjectChildren(object);

		if (length(children) > 0) {
			concatA(map(children, \c -> addF3DMouseListeners(stage, c, transformControlsEnabled)))
		} else {
			[
				makeSubscribeUns(transformControlsEnabled, \en ->
					if (en)
						[
							add3DEventListener(object, "mousedown", \ -> {
								if (!^handled3DMouseDown) {
									handled3DMouseDown := true;
									deferred(\ -> handled3DMouseDown := false);

									attach3DTransformControls(stage, object);
								}
							})
						]
					else
						[]
				)()
			]
		}
	} else {
		[]
	}
}