import rendersupport3d;
import fform/renderfform;
import fusion_utils;

export {
	Point3D(x : double, y : double, z : double);
	zeroPoint3D = Point3D(0.0, 0.0, 0.0);
	makePoint3D() -> DynamicBehaviour<Point3D> { make(zeroPoint3D) };

	F3DStage(wh : Transform<WidthHeight>, scene : F3DObject, camera : F3DObject, style : [F3DStageStyle]) -> FForm;
		F3DStageStyle ::= F3DIgnoreMouseEvents, F3DExportScene, F3DTransformControlsEnabled, F3DAttachTransformControls, F3DCameraDistance,
			F3DOrbitControlsParameters, F3DOrbitControlsEnabled, F3DLoading, F3DGetLoadingManager;

			F3DIgnoreMouseEvents();
			F3DExportScene(fn : ref Maybe<(includeCamera : bool) -> string>);
			F3DTransformControlsEnabled(enabled : Transform<bool>); // const(false) by default, doesn't affect F3DTransformControls
			F3DAttachTransformControls(fn : ref (clip : native, attach : bool) -> void);
			F3DCameraDistance(min : double, max : double); // min = 0.0, max = 1000.0 by default
			F3DOrbitControlsParameters(parameters : [KeyValue]);
			F3DOrbitControlsEnabled(enabled : Transform<bool>);
			F3DLoading(loading : DynamicBehaviour<bool>);
			F3DGetLoadingManager(fn : (loadingManager : F3DLoadingManager) -> void);

		F3DLoadingManager(
			load : (url : string, onLoad : () -> void) -> void,
			ddsSupported : () -> bool,
			pvrSupported : () -> bool
		);

		emptyF3DLoadingManager = F3DLoadingManager(\__, __ -> {}, \ -> false, \ -> false);

	F3DObject ::= F3DScene, F3DSceneDeferred, F3DMutable, F3DConstruct, F3DName, F3DVisible, F3DAlpha, F3DLocalPosition, F3DLocalRotation, F3DLocalScale, F3DLookAt, F3DLocalMatrix, F3DWorldMatrix, F3DOnLoad,
		F3DInspectLocalRotation, F3DInspectLocalPosition, F3DInspectLocalScale, F3DInspectWorldPosition, F3DInspectStagePosition,
		F3DInspectBoundingSphereCenter, F3DInspectBoundingSphereMin, F3DInspectBoundingSphereMax, F3DInspectLocalMatrix, F3DInspectWorldMatrix, F3DCamera, F3DLight,
		F3DMesh, F3DInstancedMesh, F3DLine, F3DLineSegments, F3DPoints, F3DInstancedGeometry, F3DTransformControls, F3DLoader, F3DGLTFLoader, F3DSceneLoader, F3DChildren, F3DNative, F3DJsonObject, F3DObject2Json, F3DBoxHelper, F3DAxesHelper,
		F3DGridHelper, F3DVertexNormalsHelper, F3DInteractive, F3DLOD, F3DGLTFExporter, F3DObjectParameters, F3DObjectMaterialParameters, F3DEmpty;

		F3DScene(objects : Transform<[F3DObject]>);
		F3DSceneDeferred(objects : Transform<[F3DObject]>, delay : Transform<int>, duration : Transform<int>);
		F3DGroup(objects : [F3DObject]) -> F3DScene { F3DScene(const(objects)); };
		F3DGroupDeferred(objects : [F3DObject], delay : Transform<int>, duration : Transform<int>) -> F3DSceneDeferred { F3DSceneDeferred(const(objects), delay, duration); };
		F3DMutable(object : Transform<F3DObject>);
		F3DIf(condition : Transform<bool>, then : F3DObject, elset : F3DObject) -> F3DObject { F3DMutable(fif(condition, const(then), const(elset))); }
		F3DConstruct(constructors : [() -> () -> void], object : F3DObject);

		F3DName(object : F3DObject, name : Transform<string>);

		F3DSelect(t : Transform<?>, fn : (?) -> F3DObject) -> F3DObject { F3DMutable(fselect(t, fn |> FLift)); };
		F3DSelect2(t1 : Transform<?>, t2 : Transform<??>, fn : (?, ??) -> F3DObject) -> F3DObject { F3DMutable(fselect2(t1, t2, fn |> FLift2)); };
		F3DSelect3(t1 : Transform<?>, t2 : Transform<??>, t3 : Transform<???>, fn : (?, ??, ???) -> F3DObject) -> F3DObject { F3DMutable(fselect3(t1, t2, t3, fn)); };
		F3DShow(object : F3DObject, show : Transform<bool>) -> F3DObject { F3DMutable(fif(show, const(object), const(F3DEmpty()))); }

		F3DVisible(object : F3DObject, visible : Transform<bool>);
		F3DAlpha(object : F3DObject, alpha : Transform<double>);
		F3DLocalPosition(object : F3DObject, point : Transform<Point3D>);
		F3DLocalRotation(object : F3DObject, point : Transform<Point3D>);
		F3DLocalScale(object : F3DObject, point : Transform<Point3D>);
		F3DLookAt(object : F3DObject, point : Transform<Point3D>, update : DynamicBehaviour<bool>);
		F3DLocalMatrix(object : F3DObject, matrix : Transform<[double]>);
		F3DWorldMatrix(object : F3DObject, matrix : Transform<[double]>);

		F3DOnLoad(object : F3DObject, onLoad : (native) -> void);

		F3DInspectLocalRotation(object : F3DObject, point : DynamicBehaviour<Point3D>, enabled : Transform<bool>);
		F3DInspectWorldPosition(object : F3DObject, point : DynamicBehaviour<Point3D>, enabled : Transform<bool>);
		F3DInspectStagePosition(object : F3DObject, point : DynamicBehaviour<Point>, enabled : Transform<bool>);
		F3DInspectLocalPosition(object : F3DObject, point : DynamicBehaviour<Point3D>, enabled : Transform<bool>);
		F3DInspectLocalScale(object : F3DObject, point : DynamicBehaviour<Point3D>, enabled : Transform<bool>);

		F3DInspectBoundingSphereCenter(object : F3DObject, point : DynamicBehaviour<Point3D>, enabled : Transform<bool>);
		F3DInspectBoundingSphereMin(object : F3DObject, point : DynamicBehaviour<Point3D>, enabled : Transform<bool>);
		F3DInspectBoundingSphereMax(object : F3DObject, point : DynamicBehaviour<Point3D>, enabled : Transform<bool>);
		F3DInspectLocalMatrix(object : F3DObject, matrix : DynamicBehaviour<[double]>, enabled : Transform<bool>);
		F3DInspectWorldMatrix(object : F3DObject, matrix : DynamicBehaviour<[double]>, enabled : Transform<bool>);

		F3DTransformControls(object : F3DObject, enabled : DynamicBehaviour<bool>);

		F3DLoader(objUrl : string, mtlUrl : string);
		F3DGLTFLoader(url : string, onAnimation : ([F3DAnimation]) -> void, onError : (string) -> F3DObject);
			F3DAnimation(start : () -> void, stop : () -> void, duration : DynamicBehaviour<double>);

		F3DSceneLoader(url : string);
		F3DChildren(object : F3DObject, fn : (F3DNative) -> void);

		F3DNative ::= F3DNativeObject, F3DNativeScene, F3DNativeMutable, F3DNativeOnLoad, F3DEmpty;
			F3DNativeObject(object : native);
			F3DNativeScene(scene : native, objects : Transform<[F3DNative]>);
			F3DNativeMutable(object : Transform<F3DNative>);
			F3DNativeOnLoad(object : F3DNative, onLoad : (native) -> void);

		F3DJsonObject(json : string);
		F3DObject2Json(object : F3DObject, jsonFn : ref Maybe<(includeCamera : bool) -> string>);

		F3DBoxHelper(object : F3DObject, enabled : DynamicBehaviour<bool>);
		F3DAxesHelper(size : double);
		F3DGridHelper(size : double, divisions : int, colorCenterLine : int, colorGrid : int);

		F3DVertexNormalsHelper(object : F3DObject, size : double, color : int, lineWidth : double);

		F3DInteractive(object : F3DObject, listeners : [F3DEventHandler], enabled : Transform<bool>);
			F3DEventHandler ::= F3DMouseDown, F3DMouseUp, F3DMouseMove, F3DMouseOver, F3DMouseOut;
				F3DMouseDown(fn : (handled : bool) -> bool);
				F3DMouseUp(fn : (handled : bool) -> bool);
				F3DMouseMove(fn : (handled : bool) -> bool);
				F3DMouseOver(fn : (handled : bool) -> bool);
				F3DMouseOut(fn : (handled : bool) -> bool);

		F3DLOD(levels : [Pair<double, F3DObject>]);

		F3DLight ::= F3DPointLight, F3DSpotLight, F3DAmbientLight;
			F3DPointLight(color : Transform<int>, intensity : Transform<double>, distance : Transform<double>, decayAmount : Transform<double>);
			F3DSpotLight(color : Transform<int>, intensity : Transform<double>, distance : Transform<double>, angle : Transform<double>, penumbra : Transform<double>, decayAmount : Transform<double>);
			F3DAmbientLight(color : Transform<int>, intensity : Transform<double>);

		F3DCamera ::= F3DPerspectiveCamera, F3DOrthographicCamera;
			F3DPerspectiveCamera(fov : Transform<double>, aspect : Transform<double>, near : Transform<double>, far : Transform<double>);
			F3DOrthographicCamera(width : Transform<double>, height : Transform<double>, near : Transform<double>, far : Transform<double>, zoom : Transform<double>);

		F3DMesh(geometry : F3DGeometry, materials : [F3DMaterial], parameters : [KeyValue]);
		F3DInstancedMesh(geometry : F3DGeometry, materials : [F3DMaterial], parameters : [KeyValue], count : int, fn : (id : int, object : F3DObject) -> F3DObject);
		F3DLine(geometry : F3DGeometry, materials : [F3DMaterial], parameters : [KeyValue]);
		F3DLineSegments(geometry : F3DGeometry, materials : [F3DMaterial], parameters : [KeyValue]);
		F3DPoints(geometry : F3DGeometry, materials : [F3DMaterial], parameters : [KeyValue]);

		F3DInstancedGeometry(geometry : F3DGeometry, fn : (geometry : F3DGeometry) -> F3DObject);
			F3DGeometry ::= F3DPlaneGeometry, F3DBoxGeometry, F3DSphereGeometry, F3DCircleGeometry, F3DConeGeometry, F3DCylinderGeometry, F3DShapeGeometry, F3DVertexGeometry,
				F3DShapeGeometry3D, F3DVertexGeometry3D, F3DEdgesGeometry, F3DWireframeGeometry, F3DNativeGeometry, F3DModifyGeometryVertices, F3DGeometryTesselate, F3DGeometrySimplify, F3DGeometryMatrix, F3DBufferGeometry;

				F3DPlaneGeometry(width : double, height : double, widthSegments : int, heightSegments : int);
				F3DBoxGeometry(width : double, height : double, depth : double, widthSegments : int, heightSegments : int, depthSegments : int);
				F3DSphereGeometry(radius : double, widthSegments : int, heightSegments : int, phiStart : double, phiLength : double, thetaStart : double, thetaLength : double);
				F3DCircleGeometry(radius : double, segments : int, thetaStart : double, thetaLength : double);
				F3DConeGeometry(radius : double, height : double, radialSegments : int, heightSegments : int, openEnded : bool, thetaStart : double, thetaLength : double);
				F3DCylinderGeometry(radiusTop : double, radiusBottom : double, height : double, radialSegments : int, heightSegments : int, openEnded : bool, thetaStart : double, thetaLength : double);
				F3DShapeGeometry(pathes : [[Point]]);
				F3DVertexGeometry(vertices : [Point]);
				F3DShapeGeometry3D(path : [Point3D]);
				F3DVertexGeometry3D(vertices : [Point3D]);
				F3DEdgesGeometry(geometry : F3DGeometry);
				F3DWireframeGeometry(geometry : F3DGeometry);
				F3DNativeGeometry(geometry : native);
				F3DModifyGeometryVertices(geometry : F3DGeometry, modifyFn : (Point3D) -> Point3D);
				F3DGeometryTesselate(geometry : F3DGeometry, distance : double, iterations : int);
				F3DGeometrySimplify(geometry : F3DGeometry, countFn : (initial : int) -> int);

				F3DGeometryMatrix(geometry : F3DGeometry, matrix : Transform<[double]>);

			F3DBufferGeometry ::= F3DSphereBufferGeometry, F3DCylinderBufferGeometry, F3DBoxBufferGeometry, F3DShapeBufferGeometry, F3DBufferFromGeometry;
				F3DSphereBufferGeometry(
					radius : double,
					widthSegments : int,
					heightSegments : int,
					phiStart : double,
					phiLength : double,
					thetaStart : double,
					thetaLength : double,
					addGroups : (geometryLength : int, materialsLength : int) -> [F3DBufferGeometryGroup],
					attributes : Maybe<F3DBufferGeometryAttributes>
				);
				F3DCylinderBufferGeometry(
					radiusTop : double,
					radiusBottom : double,
					height : double,
					radialSegments : int,
					heightSegments : int,
					openEnded : bool,
					thetaStart : double,
					thetaLength : double,
					addGroups : (geometryLength : int, materialsLength : int) -> [F3DBufferGeometryGroup],
					attributes : Maybe<F3DBufferGeometryAttributes>
				);
				F3DBoxBufferGeometry(
					width : double,
					height : double,
					depth : double,
					widthSegments : int,
					heightSegments : int,
					depthSegments : int,
					addGroups : (geometryLength : int, materialsLength : int) -> [F3DBufferGeometryGroup],
					attributes : Maybe<F3DBufferGeometryAttributes>
				);
				F3DShapeBufferGeometry(
					path : [[Point]],
					addGroups : (geometryLength : int, materialsLength : int) -> [F3DBufferGeometryGroup],
					attributes : Maybe<F3DBufferGeometryAttributes>
				);

					F3DBufferGeometryGroup(start : int, count : int, materialIndex : int);
					F3DBufferGeometryAttributes(
						get : [string], // Attributes names to get from buffer geometry, these attributes data is passed as 'attributes' to 'add' function
						add : (attributes : Tree<string, [[double]]>) -> Tree<string, [[double]]> // Attributes to add to buffer geometry
					);

				F3DBufferFromGeometry(geometry : F3DGeometry, parameters : [KeyValue]);

			F3DMaterial ::= F3DMeshBasicMaterial, F3DLineBasicMaterial, F3DPointsMaterial, F3DMeshStandardMaterial, F3DMeshNormalMaterial, F3DShaderMaterial, F3DNativeMaterials,
				F3DMaterialTexture, F3DMaterialAlphaTexture, F3DMaterialDisplacementTexture, F3DMaterialBumpTexture,
				F3DMaterialOpacity, F3DMaterialVisible;

				F3DMeshBasicMaterial(color : int, parameters : [KeyValue]);
				F3DLineBasicMaterial(color : int, parameters : [KeyValue]);
				F3DPointsMaterial(color : int, size : double, parameters : [KeyValue]);
				F3DMeshStandardMaterial(color : Transform<int>, parameters : [KeyValue]);
				F3DMeshNormalMaterial(color : int, parameters : [KeyValue]);
				F3DShaderMaterial(uniforms : string, vertexShader : string, fragmentShader : string, parameters : [KeyValue]);
				F3DNativeMaterials(materials : native);

				F3DMaterialTexture(material : F3DMaterial, texture : F3DTexture);
				F3DMaterialAlphaTexture(material : F3DMaterial, texture : F3DTexture);
				F3DMaterialDisplacementTexture(material : F3DMaterial, texture : F3DTexture, scale : Transform<double>, bias : Transform<double>);
				F3DMaterialBumpTexture(material : F3DMaterial, texture : F3DTexture, scale : Transform<double>);

					F3DTexture ::= F3DTextureLoader, F3DTexturesLoader, F3DCubeTextureLoader, F3DDataTexture, F3DFFormTexture, F3DTextureRotation, F3DTextureOffset, F3DTextureMutable, F3DTextureConstruct;

						F3DTextureLoader(url : string, onLoad : () -> void, enabled : Transform<bool>, parameters : [KeyValue]);
						// Picks one or other depending on supported by device format
						F3DTexturesLoader(image : string, dds : string, pvr : string, onLoad : () -> void, enabled : Transform<bool>, parameters : [KeyValue]);
						F3DCubeTextureLoader(
							px : string,
							nx : string,
							py : string,
							ny : string,
							pz : string,
							nz : string,
							onLoad : () -> void,
							parameters : [KeyValue]
						);
						F3DDataTexture(data : [int], width : int, height : int, parameters : [KeyValue]);
						F3DFFormTexture(fform : FForm, parameters : [KeyValue]);
						F3DTextureRotation(texture : F3DTexture, rotation : Transform<double>);
						F3DTextureOffset(texture : F3DTexture, point : Transform<Point>);
						F3DTextureMutable(texture : Transform<F3DTexture>);
						F3DTextureConstruct(constructors : [() -> () -> void], texture : F3DTexture);


				F3DMaterialOpacity(material : F3DMaterial, opacity : Transform<double>);
				F3DMaterialVisible(material : F3DMaterial, visible : Transform<bool>);
				F3DMaterialAlpha(material : F3DMaterial, alpha : Transform<double>) -> F3DMaterialOpacity { F3DMaterialOpacity(material, alpha) };

		F3DGLTFExporter(object : F3DObject, exportFn : (string) -> void, parameters : [KeyValue]);
		F3DObjectParameters(object : F3DObject, parameters : [KeyValue]);
		F3DObjectMaterialParameters(object : F3DObject, parameters : [KeyValue]);

		F3DEmpty();
}

handled3DMouseDown : ref bool = ref false;
handled3DMouseUp : ref bool = ref false;
handled3DMouseMove : ref bool = ref false;
handled3DMouseOver : ref bool = ref false;
handled3DMouseOut : ref bool = ref false;

F3DRenderState(
	wh : Transform<WidthHeight>,
	stage : native,
	transformControlsEnabled : Transform<bool>,
	loading : Transform<bool>,
	supportedExtensions : [string]
);

F3DStage(wh : Transform<WidthHeight>, scene : F3DObject, camera : F3DObject, style : [F3DStageStyle]) -> FForm {
	if (js) {
		FMutable(fselect(fasync(false, \cb -> load3DLibraries(\ -> cb(true))), FLift(\isReady ->
			if (isReady) {
				FCreate(\ -> {
					metrics = make(FormMetrics(0., 0., 0., 0.));

					isLoading = extractStruct(style, F3DLoading(make(true))).loading;
					nextDistinct(isLoading, true);

					clip = make3DStage(fgetValue(fwidth(wh)), fgetValue(fheight(wh)));
					supportedExtensions = get3DSupportedExtensions(clip);
					transformControlsEnabled = extractStruct(style, F3DTransformControlsEnabled(const(false))).enabled;
					maybeApply(
						tryExtractStruct(style, F3DAttachTransformControls(ref nop2)),
						\es -> es.fn := \c, b -> if (b) attach3DTransformControls(clip, c) else detach3DTransformControls(clip, c)
					);
					maybeApply(tryExtractStruct(style, F3DGetLoadingManager(nop1)), \glm ->
						glm.fn(
							F3DLoadingManager(
								\url, onLoad -> load3DTexture(make3DTextureLoader(clip, url, \__ -> onLoad(), [])) |> ignore,
								\ -> contains(supportedExtensions, "WEBGL_compressed_texture_s3tc") ||
									contains(supportedExtensions, "WEBKIT_WEBGL_compressed_texture_s3tc"),
								\ -> contains(supportedExtensions, "WEBGL_compressed_texture_pvrtc") ||
									contains(supportedExtensions, "WEBKIT_WEBGL_compressed_texture_pvrtc")
							)
						)
					);

					onDoneCounter : ref int = ref 0;
					resourcesLoading : ref bool = ref false;

					set3DStageOnStart(clip, \ -> {
						println("Three.js loading resources");
						resourcesLoading := true;
					});

					set3DStageOnError(clip, \ -> {
						println("Three.js loading error");
						nextDistinct(isLoading, false);
					});

					set3DStageOnLoad(clip, \ -> {
						println("Three.js loading finished");
						resourcesLoading := false;

						if (^onDoneCounter == 2) {
							nextDistinct(isLoading, false);
						}
					});

					set3DStageOnProgress(clip, \url, loaded, total -> {
						println("Three.js loaded " + i2s(loaded) + " of " + i2s(total));
					});

					innerOnDone = \ -> {
						onDoneCounter := ^onDoneCounter + 1;

						if (^onDoneCounter == 2 && !^resourcesLoading) {
							nextDistinct(isLoading, false);
						};

						[];
					}

					FNativeForm(
						FEmpty(),
						metrics,
						\ -> FEmpty(),
						\__, __, __ -> {
							NativeRenderResult(
								[clip],
								concat3(
									[
										makeSubscribe(wh, \v -> {
											setClipWidth(clip, v.width);
											setClipHeight(clip, v.height);
											nextDistinct(metrics, FormMetrics(v.width, v.height, v.height, v.height));
										})(),
									],
									render3dform(
										camera,
										F3DRenderState(
											wh,
											clip,
											const(false),
											isLoading,
											supportedExtensions
										),
										\c -> {
											cameraDistance = extractStruct(style, F3DCameraDistance(0.0, 1000.0));
											parameters =
												concat(
													extractStruct(style, F3DOrbitControlsParameters([])).parameters,
													[
														KeyValue("minDistance", toString(cameraDistance.min)),
														KeyValue("maxDistance", toString(cameraDistance.max))
													]
												);

											set3DCamera(clip, c, map(parameters, \v -> [v.key, v.value]));

											[
												makeSubscribe(extractStruct(style, F3DOrbitControlsEnabled(const(true))).enabled, \en ->
													set3DOrbitControlsEnabled(clip, en)
												)()
											];
										},
										innerOnDone
									),
									render3dform(
										scene,
										F3DRenderState(
											wh,
											clip,
											transformControlsEnabled,
											isLoading,
											supportedExtensions
										),
										\s -> {
											set3DScene(clip, s);

											maybeApply(tryExtractStruct(style, F3DExportScene(ref None())), \es ->
												es.fn := Some(\includeCamera -> get3DObjectJSON(s, includeCamera))
											);

											addF3DMouseListeners(clip, s, transformControlsEnabled);
										},
										innerOnDone
									)
								)
								|> (\f -> \ -> applyall(f))
							)
						}
					)
					|> (\f ->
						if (!contains(style, F3DIgnoreMouseEvents())) {
							mouseDown = make(false);

							FGroup2(
								FInteractive(
									[
										KeyDown(\ke -> {
											emit3DKeyEvent(
												clip,
												"keydown",
												ke.utf,
												ke.ctrl,
												ke.shift,
												ke.alt,
												ke.meta,
												ke.keycode
											);
										}),
										KeyUp(\ke -> {
											emit3DKeyEvent(
												clip,
												"keyup",
												ke.utf,
												ke.ctrl,
												ke.shift,
												ke.alt,
												ke.meta,
												ke.keycode
											);
										}),
										FineGrainMouseWheel(\mi -> {
											if (mi.inside) {
												emit3DMouseEvent(
													clip,
													"wheel",
													-mi.dx,
													-mi.dy
												);
											}
										}),
										TouchStart(\mi -> {
											if (exists(mi.inside, apply0)) {
												emit3DTouchEvent(
													clip,
													"touchstart",
													map(mi.points, \p -> [p.x, p.y])
												);

												if (!^handled3DMouseDown) {
													clear3DTransformControls(clip);
												}
											}

											^handled3DMouseDown;
										}),
										TouchMove(\mi -> {
											emit3DTouchEvent(
												clip,
												"touchmove",
												map(mi.points, \p -> [p.x, p.y])
											);

											^handled3DMouseMove;
										}),
										TouchEnd(\mi -> {
											emit3DTouchEvent(
												clip,
												"touchend",
												map(mi.points, \p -> [p.x, p.y])
											);

											^handled3DMouseUp;
										})
									]
									|> (\ev ->
										if (!mobile)
											concat(
												ev,
												[
													MouseDown(\mi -> {
														if (mi.inside()) {
															emit3DMouseEvent(
																clip,
																"mousedown",
																mi.x,
																mi.y
															);

															if (!^handled3DMouseDown) {
																clear3DTransformControls(clip);
															}
														}

														^handled3DMouseDown;
													}),
													MouseUp(\mi -> {
														emit3DMouseEvent(
															clip,
															"mouseup",
															mi().x,
															mi().y
														);

														^handled3DMouseUp;
													}),
													MouseMiddleDown(\mi -> {
														if (mi.inside()) {
															emit3DMouseEvent(
																clip,
																"mousemiddledown",
																mi.x,
																mi.y
															);
														}

														false;
													}),
													MouseMiddleUp(\mi -> {
														emit3DMouseEvent(
															clip,
															"mousemiddleup",
															mi().x,
															mi().y
														);

														false;
													}),
													MouseRightDown(\mi -> {
														if (mi.inside()) {
															emit3DMouseEvent(
																clip,
																"mouserightdown",
																mi.x,
																mi.y
															);
														}

														false;
													}),
													MouseRightUp(\mi -> {
														emit3DMouseEvent(
															clip,
															"mouserightup",
															mi().x,
															mi().y
														);

														false;
													}),
													MouseMove(\mi -> {
														if (mi().inside) {
															emit3DMouseEvent(
																clip,
																"mousemove",
																mi().x,
																mi().y
															);
														}

														^handled3DMouseMove;
													})
												]
											)
										else
											ev
									),
									FGraphics(fselect(wh, FLift(\v -> [GRect(0.0, 0.0, v.width, v.height)])), const([Fill(0x000000), FillOpacity(0.0)])),
								),
								f,
								false
							);
						} else {
							f;
						}
					)
					|> (\f -> FConstructor(f, \ -> \ -> dispose3DStage(clip)))
				})
			} else {
				FEmpty();
			}
		)));
	} else {
		FEmpty();
	}
}

render3dform(object : F3DObject, state : F3DRenderState, onStart : (native) -> [() -> void], onDone : () -> [() -> void]) -> [() -> void] {
	switch (object : F3DObject) {
		F3DEmpty() : onDone();
		F3DScene(objects) : {
			scene = make3DScene();
			onDoneCounter : ref int = ref 0;
			loadingFinished = ref false;
			innerOnDone = \ -> {
				onDoneCounter := ^onDoneCounter + 1;

				if (!^loadingFinished && ^onDoneCounter == length(fgetValue(objects))) {
					loadingFinished := true;
					onDone();
				} else {
					[]
				}
			}

			concat3(
				onStart(scene),
				[
					fiteriu(objects, \index, o -> {
						render3dform(
							o,
							state,
							\c ->
								concat(
									addF3DMouseListeners(state.stage, c, state.transformControlsEnabled),
									[
										makeSubscribe(index, \i -> add3DChildAt(scene, c, i))(),
										\ -> remove3DChild(scene, c)
									]
								),
							innerOnDone
						)
					})
				],
				if (!^loadingFinished && length(fgetValue(objects)) == 0) {
					loadingFinished := true;
					onDone();
				} else {
					[]
				}
			)
		}
		F3DSceneDeferred(objects, delay, duration) : {
			scene = make3DScene();
			onDoneCounter : ref int = ref 0;
			loadingFinished = ref false;
			uns = ref [];
			innerOnDone = \ -> {
				onDoneCounter := ^onDoneCounter + 1;

				if (!^loadingFinished && ^onDoneCounter == length(fgetValue(objects))) {
					loadingFinished := true;
					onDone();
				} else {
					[]
				}
			}

			uns :=
				[
					interruptibleTimer(fgetValue(delay) + fgetValue(duration), \ -> {
						if (!^loadingFinished && length(fgetValue(objects)) == 0) {
							loadingFinished := true;
							uns := onDone();
						}
					})
				];

			concat(
				onStart(scene),
				[
					fiteriu(objects, \index, o -> {
						ms = fgetValue(delay) + fgetValue(duration) * (fgetValue(index) + 1) / length(fgetValue(objects));

						if (ms == 0)
							render3dform(
								o,
								state,
								\c ->
									concat(
										addF3DMouseListeners(state.stage, c, state.transformControlsEnabled),
										[
											makeSubscribe(index, \i -> add3DChildAt(scene, c, i))(),
											\ -> remove3DChild(scene, c)
										]
									),
								innerOnDone
							)
						else
							[
								interruptibleTimerUns(ms, \ ->
									render3dform(
										o,
										state,
										\c ->
											concat(
												addF3DMouseListeners(state.stage, c, state.transformControlsEnabled),
												[
													makeSubscribe(index, \i -> add3DChildAt(scene, c, i))(),
													\ -> remove3DChild(scene, c)
												]
											),
										innerOnDone
									)
									|> (\f -> \ -> applyall(f))
								)
							]
					}),
					\ -> {
						applyall(^uns);
						uns := [];
					}
				]
			)
		}
		F3DMutable(innerObject) : {
			onDonePad = ref None();

			[
				makeSubscribeUns(innerObject, \obj ->
					render3dform(
						obj,
						state,
						onStart,
						\ -> onlyOnce(onDonePad, onDone)
					)
				)()
			]
		}
		F3DConstruct(constructors, innerObject) : {
			r = render3dform(
				innerObject,
				state,
				\clip -> {
					concat(
						onStart(clip),
						map(constructors, apply0)
					)
				},
				onDone
			);

			r;
		}
		F3DName(innerObject, name) : {
			r = render3dform(
				innerObject,
				state,
				\clip -> {
					concat(
						onStart(clip),
						[
							makeSubscribe(name, \v -> set3DObjectName(clip, v))(),
						]
					)
				},
				onDone
			);

			r;
		}
		F3DNativeMutable(innerObject) : {
			onDonePad = ref None();

			[
				makeSubscribeUns(innerObject, \obj ->
					render3dform(
						obj,
						state,
						onStart,
						\ -> onlyOnce(onDonePad, onDone)
					)
				)()
			]
		}
		F3DNativeOnLoad(innerObject, innerOnLoad) : {
			r = render3dform(
				innerObject,
				state,
				\clip -> {
					d = onStart(clip);
					innerOnLoad(clip);
					d;
				},
				onDone
			);

			r;
		}
		F3DVisible(innerObject, visible) : {
			r = render3dform(
				innerObject,
				state,
				\clip -> {
					concat(
						onStart(clip),
						[
							makeSubscribe(visible, \v -> set3DObjectVisible(clip, v))(),
						]
					)
				},
				onDone
			);

			r;
		}
		F3DAlpha(innerObject, alpha) : {
			r = render3dform(
				innerObject,
				state,
				\clip -> {
					concat(
						onStart(clip),
						[
							makeSubscribe(alpha, \v -> set3DObjectAlpha(clip, v))(),
						]
					)
				},
				onDone
			);

			r;
		}
		F3DLocalPosition(innerObject, point) : {
			r = render3dform(
				innerObject,
				state,
				\clip -> {
					concat(
						onStart(clip),
						[
							makeSubscribe(point, \v -> {
								set3DObjectLocalPositionX(clip, v.x);
								set3DObjectLocalPositionY(clip, v.y);
								set3DObjectLocalPositionZ(clip, v.z);
							})()
						]
					)
				},
				onDone
			);

			r;
		}
		F3DLocalRotation(innerObject, point) : {
			r = render3dform(
				innerObject,
				state,
				\clip ->
					concat(
						onStart(clip),
						[
							makeSubscribe(point, \v -> {
								set3DObjectLocalRotationX(clip, v.x);
								set3DObjectLocalRotationY(clip, v.y);
								set3DObjectLocalRotationZ(clip, v.z);
							})()
						]
					),
				onDone
			);

			r;
		}
		F3DLocalScale(innerObject, point) : {
			r = render3dform(
				innerObject,
				state,
				\clip ->
					concat(
						onStart(clip),
						[
							makeSubscribe(point, \v -> {
								set3DObjectLocalScaleX(clip, v.x);
								set3DObjectLocalScaleY(clip, v.y);
								set3DObjectLocalScaleZ(clip, v.z);
							})()
						]
					),
				onDone
			);

			r;
		}
		F3DLookAt(innerObject, point, update) : {
			r = render3dform(
				innerObject,
				state,
				\clip ->
					concat(
						onStart(clip),
						[
							make2Subscribe(point, update, \v, __ -> set3DObjectLookAt(clip, v.x, v.y, v.z))()
						]
					),
				onDone
			);

			r;
		}
		F3DLocalMatrix(innerObject, matrix) : {
			r = render3dform(
				innerObject,
				state,
				\clip ->
					concat(
						onStart(clip),
						[
							makeSubscribe(matrix, \m -> set3DObjectLocalMatrix(clip, m))()
						]
					),
				onDone
			);

			r;
		}
		F3DWorldMatrix(innerObject, matrix) : {
			r = render3dform(
				innerObject,
				state,
				\clip ->
					concat(
						onStart(clip),
						[
							makeSubscribe(matrix, \m -> set3DObjectWorldMatrix(clip, m))()
						]
					),
				onDone
			);

			r;
		}
		F3DOnLoad(innerObject, innerOnLoad) : {
			r = render3dform(
				innerObject,
				state,
				\clip -> {
					d = onStart(clip);
					innerOnLoad(clip);
					d;
				},
				onDone
			);

			r;
		}
		F3DInspectLocalRotation(innerObject, point, enabled) : {
			r = render3dform(
				innerObject,
				state,
				\clip ->
					concat(
						onStart(clip),
						[
							makeSubscribeUns(enabled, \en ->
								if (en)
									[
										add3DObjectLocalRotationListener(clip, \nx, ny, nz -> {
											nextDistinct(point, Point3D(nx, ny, nz));
										})
									]
								else
									[]
							)()
						]
					),
				onDone
			);

			r;
		}
		F3DInspectLocalPosition(innerObject, point, enabled) : {
			r = render3dform(
				innerObject,
				state,
				\clip ->
					concat(
						onStart(clip),
						[
							makeSubscribeUns(enabled, \en ->
								if (en)
									[
										add3DObjectLocalPositionListener(clip, \nx, ny, nz -> {
											nextDistinct(point, Point3D(nx, ny, nz));
										})
									]
								else
									[]
							)()
						]
					),
				onDone
			);

			r;
		}
		F3DInspectLocalScale(innerObject, point, enabled) : {
			r = render3dform(
				innerObject,
				state,
				\clip ->
					concat(
						onStart(clip),
						[
							makeSubscribeUns(enabled, \en ->
								if (en)
									[
										add3DObjectLocalScaleListener(clip, \nx, ny, nz -> {
											nextDistinct(point, Point3D(nx, ny, nz));
										})
									]
								else
									[]
							)()
						]
					),
				onDone
			);

			r;
		}
		F3DInspectWorldPosition(innerObject, point, enabled) : {
			r = render3dform(
				innerObject,
				state,
				\clip ->
					concat(
						onStart(clip),
						[
							makeSubscribeUns(enabled, \en ->
								if (en)
									[
										add3DObjectWorldPositionListener(clip, \nx, ny, nz -> {
											nextDistinct(point, Point3D(nx, ny, nz));
										})
									]
								else
									[]
							)()
						]
					),
				onDone
			);

			r;
		}
		F3DInspectStagePosition(innerObject, point, enabled) : {
			r = render3dform(
				innerObject,
				state,
				\clip ->
					concat(
						onStart(clip),
						[
							makeSubscribeUns(enabled, \en ->
								if (en)
									[
										add3DObjectStagePositionListener(state.stage, clip, \nx, ny -> {
											nextDistinct(point, Point(nx, ny));
										})
									]
								else
									[]
							)()
						]
					),
				onDone
			);

			r;
		}
		F3DInspectBoundingSphereCenter(innerObject, point, enabled) : {
			r = render3dform(
				innerObject,
				state,
				\clip ->
					concat(
						onStart(clip),
						[
							makeSubscribeUns(enabled, \en ->
								if (en)
									[
										add3DObjectBoundingBoxListener(clip, \box -> {
											nextDistinct(point, Point3D((box[0][0] + box[1][0]) / 2.0, (box[0][1] + box[1][1]) / 2.0, (box[0][2] + box[1][2]) / 2.0));
										})
									]
								else
									[]
							)()
						]
					),
				onDone
			);

			r;
		}
		F3DInspectBoundingSphereMin(innerObject, point, enabled) : {
			r = render3dform(
				innerObject,
				state,
				\clip ->
					concat(
						onStart(clip),
						[
							makeSubscribeUns(enabled, \en ->
								if (en)
									[
										add3DObjectBoundingBoxListener(clip, \box -> {
											nextDistinct(point, Point3D(box[0][0], box[0][1], box[0][2]));
										})
									]
								else
									[]
							)()
						]
					),
				onDone
			);

			r;
		}
		F3DInspectBoundingSphereMax(innerObject, point, enabled) : {
			r = render3dform(
				innerObject,
				state,
				\clip ->
					concat(
						onStart(clip),
						[
							makeSubscribeUns(enabled, \en ->
								if (en)
									[
										add3DObjectBoundingBoxListener(clip, \box -> {
											nextDistinct(point, Point3D(box[1][0], box[1][1], box[1][2]));
										})
									]
								else
									[]
							)()
						]
					),
				onDone
			);

			r;
		}
		F3DInspectLocalMatrix(innerObject, matrix, enabled) : {
			r = render3dform(
				innerObject,
				state,
				\clip ->
					concat(
						onStart(clip),
						[
							makeSubscribeUns(enabled, \en ->
								if (en)
									[
										add3DObjectLocalMatrixListener(clip, \m -> {
											nextDistinct(matrix, m);
										})
									]
								else
									[]
							)()
						]
					),
				onDone
			);

			r;
		}
		F3DInspectWorldMatrix(innerObject, matrix, enabled) : {
			r = render3dform(
				innerObject,
				state,
				\clip ->
					concat(
						onStart(clip),
						[
							makeSubscribeUns(enabled, \en ->
								if (en)
									[
										add3DObjectWorldMatrixListener(clip, \m -> {
											nextDistinct(matrix, m);
										})
									]
								else
									[]
							)()
						]
					),
				onDone
			);

			r;
		}
		F3DTransformControls(innerObject, enabled) : {
			r = render3dform(
				innerObject,
				state,
				\clip ->
					concat(
						onStart(clip),
						[
							add3DEventListener(clip, "detached", \ -> nextDistinct(enabled, false)),
							add3DEventListener(clip, "attached", \ -> nextDistinct(enabled, true)),
							makeSubscribe(enabled, \en ->
								if (en)
									attach3DTransformControls(state.stage, clip)
								else
									detach3DTransformControls(state.stage, clip)
							)()
						]
					),
				onDone
			);

			r;
		}
		F3DLight() : {
			renderF3DLight(object, onStart, onDone);
		}
		F3DCamera() : {
			renderF3DCamera(object, onStart, onDone);
		}
		F3DMesh(geometry, materials, parameters) : {
			renderF3DGeometry(
				geometry,
				state,
				\g -> {
					materialClips = ref makeTree();

					mapi(materials, \i, mm ->
						renderF3DMaterial(
							mm,
							state,
							\m -> {
								materialClips := setTree(^materialClips, i, m);

								if (sizeTree(^materialClips) == length(materials)) {
									concat(
										onStart(make3DMesh(g, getTreeValues(^materialClips), map(parameters, \v -> [v.key, v.value]))),
										onDone()
									)
								} else {
									[]
								}
							},
							\ -> []
						)
					)
					|> concatA
				},
				\ -> []
			)
		}
		F3DInstancedMesh(geometry, materials, parameters, count, fn) : {
			renderF3DGeometry(
				geometry,
				state,
				\g -> {
					materialClips = ref makeTree();

					mapi(materials, \i, mm ->
						renderF3DMaterial(
							mm,
							state,
							\m -> {
								materialClips := setTree(^materialClips, i, m);

								if (sizeTree(^materialClips) == length(materials)) {
									uns = ref [];

									concat3(
										onStart(
											make3DInstancedMesh(
												g,
												getTreeValues(^materialClips), map(parameters, \v -> [v.key, v.value]),
												count,
												\id, instance -> {
													r = render3dform(
														fn(id, F3DNativeObject(instance)),
														state,
														\__ -> [],
														onDone
													);

													uns := concat(^uns, r);
												}
											)
										),
										[
											\ -> applyall(^uns)
										],
										onDone()
									)
								} else {
									[]
								}
							},
							\ -> []
						)
					)
					|> concatA
				},
				\ -> []
			)
		}
		F3DLine(geometry, materials, parameters) : {
			renderF3DGeometry(
				geometry,
				state,
				\g -> {
					materialClips = ref makeTree();

					mapi(materials, \i, mm ->
						renderF3DMaterial(
							mm,
							state,
							\m -> {
								materialClips := setTree(^materialClips, i, m);

								if (sizeTree(^materialClips) == length(materials)) {
									concat(
										onStart(make3DLine(g, getTreeValues(^materialClips), map(parameters, \v -> [v.key, v.value]))),
										onDone()
									)
								} else {
									[]
								}
							},
							\ -> []
						)
					)
					|> concatA
				},
				\ -> []
			)
		}
		F3DLineSegments(geometry, materials, parameters) : {
			renderF3DGeometry(
				geometry,
				state,
				\g -> {
					materialClips = ref makeTree();

					mapi(materials, \i, mm ->
						renderF3DMaterial(
							mm,
							state,
							\m -> {
								materialClips := setTree(^materialClips, i, m);

								if (sizeTree(^materialClips) == length(materials)) {
									concat(
										onStart(make3DLineSegments(g, getTreeValues(^materialClips), map(parameters, \v -> [v.key, v.value]))),
										onDone()
									)
								} else {
									[]
								}
							},
							\ -> []
						)
					)
					|> concatA
				},
				\ -> []
			)
		}
		F3DPoints(geometry, materials, parameters) : {
			renderF3DGeometry(
				geometry,
				state,
				\g -> {
					materialClips = ref makeTree();

					mapi(materials, \i, mm ->
						renderF3DMaterial(
							mm,
							state,
							\m -> {
								materialClips := setTree(^materialClips, i, m);

								if (sizeTree(^materialClips) == length(materials)) {
									concat(
										onStart(make3DPoints(g, getTreeValues(^materialClips), map(parameters, \v -> [v.key, v.value]))),
										onDone()
									)
								} else {
									[]
								}
							},
							\ -> []
						)
					)
					|> concatA
				},
				\ -> []
			)
		}
		F3DInstancedGeometry(geometry, fn) : {
			renderF3DGeometry(
				geometry,
				state,
				\g -> {
					r = render3dform(
						fn(F3DNativeGeometry(g)),
						state,
						onStart,
						onDone
					);

					r;
				},
				\ -> []
			)
		}
		F3DLoader(objUrl, mtlUrl) : {
			uns = ref [];
			destroyed = ref false;

			load3DObject(state.stage, objUrl, mtlUrl, \obj -> {
				if (!^destroyed) {
					uns := concat(onStart(obj), onDone());
				}
			});

			[
				\ -> {
					destroyed := true;
					dispUnsA(uns);
				}
			]
		}
		F3DGLTFLoader(url, onAnimation, onError) : {
			uns = ref [];

			[
				load3DGLTFObject(
					state.stage,
					url,
					\animations, scene, scenes, cameras, assets -> {
						uns := onStart(scene);

						if (length(animations) > 0) {
							mixer = create3DAnimationMixer(scene);

							onAnimation(
								map(animations, \a -> {
									aUns = ref None();
									duration = make(get3DAnimationDuration(a));

									uns :=
										concat(
											^uns,
											[
												\ -> dispUns2(aUns),
												makeSubscribe2(duration, \d -> set3DAnimationDuration(a, d))()
											]
										);

									F3DAnimation(
										\ -> {
											aUns := Some(start3DAnimationMixer(mixer, a));
										},
										\ -> {
											dispUns2(aUns);
										},
										duration
									)
								})
							)
						}

						uns := concat(^uns, onDone());
					},
					\e -> {
						uns := render3dform(
							onError(e),
							state,
							onStart,
							onDone
						);
					}
				),
				\ -> dispUnsA(uns)
			]
		}
		F3DSceneLoader(url) : {
			uns = ref [];

			load3DScene(state.stage, url, \obj -> {
				uns := concat(onStart(obj), onDone());
			});

			[
				\ -> dispUnsA(uns)
			]
		}
		F3DChildren(innerObject, fn) : {
			onDoneCounter : ref int = ref 0;
			innerOnDone = \ -> {
				onDoneCounter := ^onDoneCounter + 1;

				if (^onDoneCounter == 1) {
					onDone();
				} else {
					[]
				}
			}

			r = render3dform(
				innerObject,
				state,
				\clip -> {
					parsedClip = parseF3DNativeObject(clip, state);
					fn(parsedClip.first);

					concat(
						onStart(clip),
						parsedClip.second
					);
				},
				onDone
			);

			r;
		}
		F3DNativeObject(nativeObject) : {
			concat(
				onStart(nativeObject),
				onDone()
			)
		}
		F3DNativeScene(scene, objects) : {
			onDoneCounter : ref int = ref 0;
			loadingFinished = ref false;
			destroyed = ref false;
			uns = ref [];
			innerOnDone = \ -> {
				onDoneCounter := ^onDoneCounter + 1;

				if (!^loadingFinished && ^onDoneCounter == length(fgetValue(objects))) {
					loadingFinished := true;
					onDone();
				} else {
					[]
				}
			}

			uns :=
				[
					interruptibleTimer(33, \ -> {
						if (!^loadingFinished && length(get3DObjectChildren(scene)) == 0) {
							loadingFinished := true;
							uns := onDone();
						}
					})
				];

			concat(
				onStart(scene),
				[
					\ -> {
						destroyed := true;
					},
					fiteriu(fthrottleUntilNextFrameRendered(objects), \index, o -> {
						render3dform(
							o,
							state,
							\c ->
								if (contains(fgetValue(objects), o))
									concat(
										addF3DMouseListeners(state.stage, c, state.transformControlsEnabled),
										[
											makeSubscribe(index, \i -> add3DChildAt(scene, c, i))(),
											\ -> {
												if (!^destroyed && !contains(fgetValue(objects), o))
													remove3DChild(scene, c)
											}
										]
									)
								else
									[],
							innerOnDone
						)
					}),
					\ -> {
						applyall(^uns);
						uns := [];
					}
				]
			)
		}
		F3DJsonObject(json) : {
			concat(
				onStart(make3DObjectFromJSON(state.stage, json)),
				onDone()
			);
		}
		F3DObject2Json(innerObject, jsonFn) : {
			r = render3dform(
				innerObject,
				state,
				\clip -> {
					jsonFn := Some(\includeCamera -> get3DObjectJSON(clip, includeCamera));

					onStart(clip);
				},
				onDone
			);

			r;
		}
		F3DBoxHelper(innerObject, enabled) : {
			r = render3dform(
				innerObject,
				state,
				\clip ->
					concat(
						onStart(clip),
						[
							makeSubscribe(enabled, \en ->
								if (en)
									attach3DBoxHelper(state.stage, clip)
								else
									detach3DBoxHelper(state.stage, clip)
							)()
						]
					),
				onDone
			);

			r;
		}
		F3DAxesHelper(size) : {
			concat(
				onStart(make3DAxesHelper(size)),
				onDone()
			);
		}
		F3DGridHelper(size, divisions, colorCenterLine, colorGrid) : {
			concat(
				onStart(make3DGridHelper(size, divisions, colorCenterLine, colorGrid)),
				onDone()
			);
		}
		F3DVertexNormalsHelper(innerObject, size, color, lineWidth) : {
			onDoneCounter : ref int = ref 0;
			innerOnDone = \ -> {
				onDoneCounter := ^onDoneCounter + 1;

				if (^onDoneCounter == 2) {
					onDone();
				} else {
					[]
				}
			}

			r = render3dform(
				innerObject,
				state,
				\clip ->
					render3dform(
						F3DGroup([F3DNativeObject(clip), F3DNativeObject(make3DVertexNormalsHelper(clip, size, color, lineWidth))]),
						state,
						onStart,
						innerOnDone
					),
				innerOnDone
			);

			r;
		}
		F3DInteractive(innerObject, listeners, enabled) : {
			r = render3dform(
				innerObject,
				state,
				\clip ->
					concat3(
						onStart(clip),
						map(listeners, \l -> {
							switch (l : F3DEventHandler) {
								F3DMouseDown(fn): {
									add3DEventListener(clip, if (mobile) "touchstart" else "mousedown", \ -> {
										handled3DMouseDown := fn(^handled3DMouseDown);

										if (^handled3DMouseDown) {
											deferred(\ -> handled3DMouseDown := false);
										}

									});
								}
								F3DMouseUp(fn): {
									add3DEventListener(clip, if (mobile) "touchend" else "mouseup", \ -> {
										handled3DMouseUp := fn(^handled3DMouseUp);

										if (^handled3DMouseUp) {
											deferred(\ -> handled3DMouseUp := false);
										}
									});
								}
								F3DMouseMove(fn): {
									add3DEventListener(clip, if (mobile) "touchmove" else "mousemove", \ -> {
										handled3DMouseMove := fn(^handled3DMouseMove);

										if (^handled3DMouseMove) {
											deferred(\ -> handled3DMouseMove := false);
										}
									});
								}
								F3DMouseOver(fn): {
									add3DEventListener(clip, "mouseover", \ -> {
										handled3DMouseOver := fn(^handled3DMouseOver);

										if (^handled3DMouseOver) {
											deferred(\ -> handled3DMouseOver := false);
										}
									});
								}
								F3DMouseOut(fn): {
									add3DEventListener(clip, "mouseout", \ -> {
										handled3DMouseOut := fn(^handled3DMouseOut);

										if (^handled3DMouseOut) {
											deferred(\ -> handled3DMouseOut := false);
										}
									});
								}
							}
						}),
						[
							makeSubscribe(enabled, \v -> set3DObjectInteractive(clip, v))()
						]
					),
				onDone
			);

			r;
		}
		F3DLOD(levels) : {
			lod = make3DLOD();

			onDoneCounter : ref int = ref 0;
			innerOnDone = \ -> {
				onDoneCounter := ^onDoneCounter + 1;

				if (^onDoneCounter == length(levels)) {
					onDone();
				} else {
					[]
				}
			}

			concat(
				onStart(lod),
				map(levels, \l ->
					render3dform(
						l.second,
						state,
						\clip -> {
							add3DLODLevel(lod, l.first, clip);
							[];
						},
						innerOnDone
					)
				)
				|> concatA
			);
		}
		F3DGLTFExporter(innerObject, exportFn, parameters): {
			r = render3dform(
				innerObject,
				state,
				\clip ->
					arrayPush(
						onStart(clip),
						interruptibleTimer(10000, \ -> export3DGLTFObject(clip, exportFn, map(parameters, \v -> [v.key, v.value])))
					),
				onDone
			);

			r;
		}
		F3DObjectParameters(innerObject, parameters): {
			r = render3dform(
				innerObject,
				state,
				\clip -> onStart(set3DObjectParameters(clip, map(parameters, \v -> [v.key, v.value]))),
				onDone
			);

			r;
		}
		F3DObjectMaterialParameters(innerObject, parameters): {
			r = render3dform(
				innerObject,
				state,
				\clip -> onStart(set3DObjectMaterialParameters(clip, map(parameters, \v -> [v.key, v.value]))),
				onDone
			);

			r;
		}
	}
}

renderF3DCamera(camera : F3DCamera, onStart : (native) -> [() -> void], onDone : () -> [() -> void]) -> [() -> void] {
	switch (camera : F3DCamera) {
		F3DPerspectiveCamera(fov, aspect, near, far): {
			clip = make3DPerspectiveCamera(fgetValue(fov), fgetValue(aspect), fgetValue(near), fgetValue(far));

			concat3(
				onStart(clip),
				[
					makeSubscribe2(fov, \v -> set3DCameraFov(clip, v))(),
					makeSubscribe2(aspect, \v -> set3DCameraAspect(clip, v))(),
					makeSubscribe2(near, \v -> set3DCameraNear(clip, v))(),
					makeSubscribe2(far, \v -> set3DCameraFar(clip, v))()
				],
				onDone()
			)
		}
		F3DOrthographicCamera(width, height, near, far, zoom): {
			clip = make3DOrthographicCamera(fgetValue(width), fgetValue(height), fgetValue(near), fgetValue(far));

			concat3(
				onStart(clip),
				[
					makeSubscribe(zoom, \v -> set3DCameraZoom(clip, v))(),
					makeSubscribe2(width, \v -> set3DCameraWidth(clip, v))(),
					makeSubscribe2(height, \v -> set3DCameraHeight(clip, v))(),
					makeSubscribe2(near, \v -> set3DCameraNear(clip, v))(),
					makeSubscribe2(far, \v -> set3DCameraFar(clip, v))()
				],
				onDone()
			)
		}
	}
}

renderF3DLight(light : F3DLight, onStart : (native) -> [() -> void], onDone : () -> [() -> void]) -> [() -> void] {
	switch (light : F3DLight) {
		F3DPointLight(color, intensity, distance, decayAmount): {
			clip = make3DPointLight(fgetValue(color), fgetValue(intensity), fgetValue(distance), fgetValue(decayAmount));

			concat3(
				onStart(clip),
				[
					makeSubscribe2(color, \v -> set3DObjectColor(clip, v))(),
					makeSubscribe2(intensity, \v -> set3DLightIntensity(clip, v))(),
					makeSubscribe2(distance, \v -> set3DLightDistance(clip, v))(),
					makeSubscribe2(decayAmount, \v -> set3DLightDecay(clip, v))()
				],
				onDone()
			)
		}
		F3DSpotLight(color, intensity, distance, angle, penumbra, decayAmount): {
			clip = make3DSpotLight(fgetValue(color), fgetValue(intensity), fgetValue(distance), fgetValue(angle), fgetValue(penumbra), fgetValue(decayAmount));

			concat3(
				onStart(clip),
				[
					makeSubscribe2(color, \v -> set3DObjectColor(clip, v))(),
					makeSubscribe2(intensity, \v -> set3DLightIntensity(clip, v))(),
					makeSubscribe2(distance, \v -> set3DLightDistance(clip, v))(),
					makeSubscribe2(angle, \v -> set3DLightAngle(clip, v))(),
					makeSubscribe2(penumbra, \v -> set3DLightPenumbra(clip, v))(),
					makeSubscribe2(decayAmount, \v -> set3DLightDecay(clip, v))()
				],
				onDone()
			)
		}
		F3DAmbientLight(color, intensity): {
			clip = make3DAmbientLight(fgetValue(color), fgetValue(intensity));

			concat3(
				onStart(clip),
				[
					makeSubscribe2(color, \v -> set3DObjectColor(clip, v))(),
					makeSubscribe2(intensity, \v -> set3DLightIntensity(clip, v))()
				],
				onDone()
			)
		}
	}
}

renderF3DGeometry(geometry : F3DGeometry, state : F3DRenderState, onStart : (native) -> [() -> void], onDone : () -> [() -> void]) -> [() -> void] {
	switch (geometry : F3DGeometry) {
		F3DPlaneGeometry(width, height, widthSegments, heightSegments) : {
			concat(
				onStart(make3DPlaneGeometry(width, height, widthSegments, heightSegments)),
				onDone()
			);
		}
		F3DBoxGeometry(width, height, depth, widthSegments, heightSegments, depthSegments) : {
			concat(
				onStart(make3DBoxGeometry(width, height, depth, widthSegments, heightSegments, depthSegments)),
				onDone()
			);
		}
		F3DSphereGeometry(radius, widthSegments, heightSegments, phiStart, phiLength, thetaStart, thetaLength) : {
			concat(
				onStart(make3DSphereGeometry(radius, widthSegments, heightSegments, phiStart, phiLength, thetaStart, thetaLength)),
				onDone()
			);
		}
		F3DSphereBufferGeometry(radius, widthSegments, heightSegments, phiStart, phiLength, thetaStart, thetaLength, addGroups, attributesM) : {
			addGroupsFn = \gl, ml -> map(addGroups(gl, ml), \g -> [g.start, g.count, g.materialIndex]);
			g = make3DSphereBufferGeometry(radius, widthSegments, heightSegments, phiStart, phiLength, thetaStart, thetaLength, addGroupsFn);

			maybeApply(
				attributesM,
				\attributes ->
					iter(
						tree2pairs(attributes.add(pairs2tree(map(attributes.get, \a -> Pair(a, get3DBufferGeometryAttribute(g, a)))))),
						\p -> add3DBufferGeometryAttribute(g, p.first, p.second)
					)
			);

			concat(
				onStart(g),
				onDone()
			);
		}
		F3DCylinderBufferGeometry(radiusTop, radiusBottom, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength, addGroups, attributesM) : {
			addGroupsFn = \gl, ml -> map(addGroups(gl, ml), \g -> [g.start, g.count, g.materialIndex]);
			g = make3DCylinderBufferGeometry(radiusTop, radiusBottom, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength, addGroupsFn);

			maybeApply(
				attributesM,
				\attributes ->
					iter(
						tree2pairs(attributes.add(pairs2tree(map(attributes.get, \a -> Pair(a, get3DBufferGeometryAttribute(g, a)))))),
						\p -> add3DBufferGeometryAttribute(g, p.first, p.second)
					)
			);

			concat(
				onStart(g),
				onDone()
			);
		}
		F3DBoxBufferGeometry(width, height, depth, widthSegments, heightSegments, depthSegments, addGroups, attributesM) : {
			addGroupsFn = \gl, ml -> map(addGroups(gl, ml), \g -> [g.start, g.count, g.materialIndex]);
			g = make3DBoxBufferGeometry(width, height, depth, widthSegments, heightSegments, depthSegments, addGroupsFn);

			maybeApply(
				attributesM,
				\attributes ->
					iter(
						tree2pairs(attributes.add(pairs2tree(map(attributes.get, \a -> Pair(a, get3DBufferGeometryAttribute(g, a)))))),
						\p -> add3DBufferGeometryAttribute(g, p.first, p.second)
					)
			);

			concat(
				onStart(g),
				onDone()
			);
		}
		F3DShapeBufferGeometry(pathes, addGroups, attributesM) : {
			addGroupsFn = \gl, ml -> map(addGroups(gl, ml), \g -> [g.start, g.count, g.materialIndex]);
			g = make3DShapeBufferGeometry(map(pathes, \path -> map(path, \p -> [p.x, p.y]) |> concatA), addGroupsFn);

			maybeApply(
				attributesM,
				\attributes ->
					iter(
						tree2pairs(attributes.add(pairs2tree(map(attributes.get, \a -> Pair(a, get3DBufferGeometryAttribute(g, a)))))),
						\p -> add3DBufferGeometryAttribute(g, p.first, p.second)
					)
			);

			concat(
				onStart(g),
				onDone()
			);
		}
		F3DBufferFromGeometry(innerGeometry, parameters) : {
			r = renderF3DGeometry(
				innerGeometry,
				state,
				\clip ->
					onStart(make3DBufferFromGeometry(clip, map(parameters, \v -> [v.key, v.value]))),
				onDone
			);

			r;
		}
		F3DCircleGeometry(radius, segments, thetaStart, thetaLength) : {
			concat(
				onStart(make3DCircleGeometry(radius, segments, thetaStart, thetaLength)),
				onDone()
			);
		}
		F3DConeGeometry(radius, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength) : {
			concat(
				onStart(make3DConeGeometry(radius, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength)),
				onDone()
			);
		}
		F3DCylinderGeometry(radiusTop, radiusBottom, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength) : {
			concat(
				onStart(make3DCylinderGeometry(radiusTop, radiusBottom, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength)),
				onDone()
			);
		}
		F3DShapeGeometry(pathes) : {
			concat(
				onStart(make3DShapeGeometry(map(pathes, \path -> map(path, \p -> [p.x, p.y]) |> concatA))),
				onDone()
			);
		}
		F3DVertexGeometry(vertices) : {
			concat(
				onStart(make3DVertexGeometry(map(vertices, \p -> [p.x, p.y]) |> concatA)),
				onDone()
			);
		}
		F3DShapeGeometry3D(path) : {
			concat(
				onStart(make3DShapeGeometry3D(map(path, \p -> [p.x, p.y, p.z]) |> concatA)),
				onDone()
			);
		}
		F3DVertexGeometry3D(vertices) : {
			concat(
				onStart(make3DVertexGeometry3D(map(vertices, \p -> [p.x, p.y, p.z]) |> concatA)),
				onDone()
			);
		}
		F3DEdgesGeometry(innerGeometry) : {
			r = renderF3DGeometry(
				innerGeometry,
				state,
				\clip ->
					onStart(make3DEdgesGeometry(clip)),
				onDone
			);

			r;
		}
		F3DWireframeGeometry(innerGeometry) : {
			r = renderF3DGeometry(
				innerGeometry,
				state,
				\clip ->
					onStart(make3DWireframeGeometry(clip)),
				onDone
			);

			r;
		}
		F3DNativeGeometry(innerGeometry) : {
			concat(
				onStart(innerGeometry),
				onDone()
			);
		}
		F3DModifyGeometryVertices(innerGeometry, modifyFn) : {
			r = renderF3DGeometry(
				innerGeometry,
				state,
				\clip ->
					onStart(modify3DGeometryVertices(
						clip,
						\p -> modifyFn(Point3D(p[0], p[1], p[2])) |> (\pp -> [pp.x, pp.y, pp.z])
					)),
				onDone
			);

			r;
		}
		F3DGeometryTesselate(innerGeometry, distance, iterations) : {
			r = renderF3DGeometry(
				innerGeometry,
				state,
				\clip ->
					onStart(tesselate3DGeometry(clip, distance, iterations)),
				onDone
			);

			r;
		}
		F3DGeometrySimplify(innerGeometry, countFn) : {
			r = renderF3DGeometry(
				innerGeometry,
				state,
				\clip ->
					onStart(simplify3DGeometry(clip, countFn)),
				onDone
			);

			r;
		}
		F3DGeometryMatrix(innerGeometry, matrix) : {
			r = renderF3DGeometry(
				innerGeometry,
				state,
				\clip ->
					concat(
						[makeSubscribe(matrix, \m -> set3DGeometryMatrix(clip, m))()],
						onStart(clip)
					),
				onDone
			);

			r;
		}
	}
}

renderF3DMaterial(material : F3DMaterial, state : F3DRenderState, onStart : (native) -> [() -> void], onDone : () -> [() -> void]) -> [() -> void] {
	switch (material : F3DMaterial) {
		F3DMeshBasicMaterial(color, parameters) : {
			concat(
				onStart(make3DMeshBasicMaterial(color, map(parameters, \v -> [v.key, v.value]))),
				onDone()
			);
		}
		F3DLineBasicMaterial(color, parameters) : {
			concat(
				onStart(make3DLineBasicMaterial(color, map(parameters, \v -> [v.key, v.value]))),
				onDone()
			);
		}
		F3DPointsMaterial(color, size, parameters) : {
			concat(
				onStart(make3DPointsMaterial(color, size, map(parameters, \v -> [v.key, v.value]))),
				onDone()
			);
		}
		F3DMeshStandardMaterial(color, parameters) : {
			m = make3DMeshStandardMaterial(fgetValue(color), map(parameters, \v -> [v.key, v.value]));

			concat3(
				onStart(m),
				[
					makeSubscribe2(color, \c -> set3DMaterialColor(m, c))()
				],
				onDone()
			);
		}
		F3DMeshNormalMaterial(color, parameters) : {
			concat(
				onStart(make3DMeshNormalMaterial(color, map(parameters, \v -> [v.key, v.value]))),
				onDone()
			);
		}
		F3DShaderMaterial(uniforms, vertexShader, fragmentShader, parameters) : {
			m = make3DShaderMaterial(state.stage, uniforms, vertexShader, fragmentShader, map(parameters, \v -> [v.key, v.value]));

			concat(
				onStart(m),
				onDone()
			);
		}
		F3DNativeMaterials(innerMaterials) : {
			concat(
				onStart(innerMaterials),
				onDone()
			);
		}
		F3DMaterialTexture(innerMaterial, texture) : {
			r = renderF3DMaterial(
				innerMaterial,
				state,
				\mclip ->
					renderF3DTexture(
						texture,
						state,
						\tclip -> {
							set3DMaterialMap(mclip, tclip);
							onStart(mclip);
						},
						\ -> []
					),
				onDone
			);

			r;
		}
		F3DMaterialAlphaTexture(innerMaterial, texture) : {
			r = renderF3DMaterial(
				innerMaterial,
				state,
				\mclip ->
					renderF3DTexture(
						texture,
						state,
						\tclip -> {
							set3DMaterialAlphaMap(mclip, tclip);
							onStart(mclip);
						},
						\ -> []
					),
				onDone
			);

			r;
		}
		F3DMaterialDisplacementTexture(innerMaterial, texture, scale, bias) : {
			r = renderF3DMaterial(
				innerMaterial,
				state,
				\mclip ->
					renderF3DTexture(
						texture,
						state,
						\tclip -> {
							set3DMaterialDisplacementMap(mclip, tclip, fgetValue(scale), fgetValue(bias));
							onStart(mclip);
						},
						\ -> []
					),
				onDone
			);

			r;
		}
		F3DMaterialBumpTexture(innerMaterial, texture, scale) : {
			r = renderF3DMaterial(
				innerMaterial,
				state,
				\mclip ->
					renderF3DTexture(
						texture,
						state,
						\tclip -> {
							set3DMaterialBumpMap(mclip, tclip, fgetValue(scale));
							onStart(mclip);
						},
						\ -> []
					),
				onDone
			);

			r;
		}
		F3DMaterialOpacity(innerMaterial, opacity) : {
			r = renderF3DMaterial(
				innerMaterial,
				state,
				\mclip ->
					arrayPush(
						onStart(mclip),
						makeSubscribe(opacity, \v -> set3DMaterialOpacity(mclip, v))()
					),
				onDone
			);

			r;
		}
		F3DMaterialVisible(innerMaterial, visible) : {
			r = renderF3DMaterial(
				innerMaterial,
				state,
				\clip ->
					arrayPush(
						onStart(clip),
						makeSubscribe(visible, \v -> set3DMaterialVisible(clip, v))()
					),
				onDone
			);

			r;
		}
	}
}

renderF3DTexture(texture : F3DTexture, state : F3DRenderState, onStart : (native) -> [() -> void], onDone : () -> [() -> void]) -> [() -> void] {
	switch (texture : F3DTexture) {
		F3DTextureLoader(url, onLoad, enabled, parameters) : {
			t = make3DTextureLoader(state.stage, url, \__ -> onLoad(), map(parameters, \v -> [v.key, v.value]));
			loading = ref false;

			concat3(
				onStart(t),
				[
					makeSubscribeUns(enabled, \en -> {
						if (!^loading && en) {
							loading := true;
							[load3DTexture(t)]
						} else {
							[]
						}
					})()
				],
				onDone()
			);
		}
		F3DTexturesLoader(image, dds, pvr, onLoad, enabled, parameters) : {
			ddsSupported = dds != "" && (contains(state.supportedExtensions, "WEBGL_compressed_texture_s3tc") ||
				contains(state.supportedExtensions, "WEBKIT_WEBGL_compressed_texture_s3tc"));
			pvrSupported = pvr != "" && (contains(state.supportedExtensions, "WEBGL_compressed_texture_pvrtc") ||
				contains(state.supportedExtensions, "WEBKIT_WEBGL_compressed_texture_pvrtc"));

			t =
				make3DTextureLoader(
					state.stage,
					if (ddsSupported) dds else if (pvrSupported) pvr else image,
					\__ -> onLoad(),
					map(
						concat(
							if (!pvrSupported && !ddsSupported)
								[
									KeyValue("wrapT", "THREE.RepeatWrapping"),
									KeyValue("repeat", "new THREE.Vector2(1, -1)")
								]
							else
								[],
							parameters
						),
						\v -> [v.key, v.value]
					)
				);
			loading = ref false;

			concat3(
				onStart(t),
				[
					makeSubscribeUns(enabled, \en -> {
						if (!^loading && en) {
							loading := true;
							[load3DTexture(t)]
						} else {
							[]
						}
					})()
				],
				onDone()
			);
		}
		F3DCubeTextureLoader(px, nx, py, ny, pz, nz, onLoad, parameters) : {
			concat(
				onStart(load3DCubeTexture(state.stage, px, nx, py, ny, pz, nz, \__ -> onLoad(), map(parameters, \v -> [v.key, v.value]))),
				onDone()
			);
		}
		F3DDataTexture(data, width, height, parameters) : {
			concat(
				onStart(make3DDataTexture(data, width, height, map(parameters, \v -> [v.key, v.value]))),
				onDone()
			);
		}
		F3DFFormTexture(fform, parameters) : {
			d = renderFForm(fform, const([0]));
			t = make3DCanvasTexture(d.clips[0], map(parameters, \v -> [v.key, v.value]));

			applyall(d.disposers);

			concat(
				onStart(t),
				onDone()
			);
		}
		F3DTextureRotation(innerTexture, rotation) : {
			r = renderF3DTexture(
				innerTexture,
				state,
				\clip ->
					arrayPush(
						onStart(clip),
						makeSubscribe(rotation, \r -> set3DTextureRotation(clip, r))()
					),
				onDone
			);

			r;
		}
		F3DTextureOffset(innerTexture, point) : {
			r = renderF3DTexture(
				innerTexture,
				state,
				\clip ->
					arrayPush(
						onStart(clip),
						makeSubscribe(point, \p -> {
							set3DTextureOffsetX(clip, p.x);
							set3DTextureOffsetY(clip, p.y);
						})()
					),
				onDone
			);

			r;
		}
		F3DTextureMutable(innerTexture) : {
			onDonePad = ref None();

			[
				makeSubscribeUns(innerTexture, \t ->
					renderF3DTexture(
						t,
						state,
						onStart,
						\ -> onlyOnce(onDonePad, onDone)
					)
				)()
			]
		}
		F3DTextureConstruct(constructors, innerTexture) : {
			r = renderF3DTexture(
				innerTexture,
				state,
				\clip ->
					concat(
						onStart(clip),
						map(constructors, apply0)
					),
				onDone
			);

			r;
		}
	}
}

parseF3DNativeObject(object : native, state : F3DRenderState) -> Pair<F3DNative, [() -> void]> {
	children = make(map(get3DObjectChildren(object), get3DObjectId));
	outputChildren = make([]);
	uns = ref nop;

	Pair(
		F3DNativeScene(object, outputChildren),
		[
			add3DEventListener(object, "childrenchanged", \ -> {
				^uns();

				if (!fgetValue(state.loading)) {
					uns := interruptibleTimer(33, \ -> nextDistinct(children, map(get3DObjectChildren(object), get3DObjectId)));
				} else {
					uns := makeSubscribe2(state.loading, \l -> if (!l) {
						^uns();
						uns := interruptibleTimer(33, \ -> nextDistinct(children, map(get3DObjectChildren(object), get3DObjectId)));
					})();
				}
			}),
			\ -> ^uns(),
			\ -> next(children, []),
			fconnect(
				fmapu(
					ffiltermap(children, \c -> get3DObjectById(state.stage, c) |> (\ch -> if (length(ch) > 0) Some(ch[0]) else None())),
					\ch -> parseF3DNativeObject(ch, state)
				),
				outputChildren
			)
		]
	)
}

addF3DMouseListeners(stage : native, object : native, transformControlsEnabled : Transform<bool>) -> [() -> void] {
	if (transformControlsEnabled != const(false)) {
		children = get3DObjectChildren(object);

		if (length(children) > 0) {
			concatA(map(children, \c -> addF3DMouseListeners(stage, c, transformControlsEnabled)))
		} else {
			[
				makeSubscribeUns(transformControlsEnabled, \en ->
					if (en)
						[
							add3DEventListener(object, "mousedown", \ -> {
								if (!^handled3DMouseDown) {
									handled3DMouseDown := true;
									deferred(\ -> handled3DMouseDown := false);

									attach3DTransformControls(stage, object);
								}
							})
						]
					else
						[]
				)()
			]
		}
	} else {
		[]
	}
}