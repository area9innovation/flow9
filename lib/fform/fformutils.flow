import fform/fform;
import render;
import fusion_utils;
import form/formmetrics;

export {
	addChildClip(parent : native, child : native, alive : ref bool) -> void;
	addChildClipAt(parent : native, child : native, id : int, alive : ref bool) -> void;
	removeChildClip(parent : native, child : native, alive : ref bool) -> void;

	isConvertableForm(form : Form) -> bool;
	fform2form(fform : FForm) -> Form;
	form2fform(form : Form) -> FForm;

	AccessProperties2FAccessProperties(prop : [AccessProperty]) -> [FAccessProperty];
	FAccessProperties2AccessProperties(prop : [FAccessProperty]) -> Pair<[AccessProperty], () -> () -> void>;

	FVideo2Video(fvideo : FVideo) -> Pair<Video, () -> () -> void>;
	Video2FVideo(video : Video) -> Pair<FVideo, () -> () -> void>;

	TextInput2FTextInput(textInput : TextInput) -> Pair<FTextInput, () -> () -> void>;
	FTextInput2TextInput(ftextInput : FTextInput) -> Pair<TextInput, () -> () -> void>;

	renderFGraphics(path : Transform<[StaticGraphicOp]>, style : Transform<[GraphicsStyle]>) -> FRenderResult;
	renderFText(text : Transform<string>, style : [FTextStyle]) -> FRenderResult;
	renderFTexts(texts : Transform<[Text]>, style : [FTextStyle]) -> FRenderResult;
	renderFParagraph(text : Transform<string>, style : [FParagraphStyle]) -> FRenderResult;
	renderFParagraphs(texts : Transform<[Text]>, style : [FParagraphStyle]) -> FRenderResult;

	renderFAnimation(clip : native, keyframes : Transform<[FAnimationKeyframe]>, style : [FAnimationStyle]) -> () -> void;

	fform2s(rform : FForm, level : int) -> string;

	FClipCapability ::= FClipMove, FClipScale, FClipRotate, FClipAlpha, FClipOrigin, FClipAnimation, FClipVisible, FClipInteractive, FClipMask, FClipFilters, FClipAccess, FClipCursor;
		FClipMove();
		FClipScale();
		FClipRotate();
		FClipAlpha();
		FClipOrigin();
		FClipAnimation();
		FClipVisible();
		FClipInteractive();
		FClipMask();
		FClipFilters();
		FClipAccess();
		FClipCursor();

	// capabilities tell if some capability is already used on this clip
	// For example FClipMove tells that setClipX has been already used on the clip
	// and you have to create new one to be able to apply setClipX on top of it
	FRenderResult(clips : [native], disposers : [() -> void], capabilities : [FClipCapability]);
	emptyFRenderResult = FRenderResult([], [], []);

	extractFAccessProperties(style : [flow]) -> [FAccessProperty];
	addFAccessProperties(properties : [FAccessProperty], zorder : Transform<[int]>) -> (native) -> () -> void;
}

addChildClip(parent : native, child : native, alive : ref bool) -> void {
	if (!^alive) {
		alive := true;
		addChild(parent, child);
	} else if (isUrlParameterTrue("dev")) {
		println("Warning: Double construct");
		printCallstack();
		println("---");
	}
}

addChildClipAt(parent : native, child : native, id : int, alive : ref bool) -> void {
	if (!^alive) {
		alive := true;
		addChildAt(parent, child, id);
	} else if (isUrlParameterTrue("dev")) {
		println("Warning: Double construct");
		printCallstack();
		println("---");
	}
}

removeChildClip(parent : native, child : native, alive : ref bool) -> void {
	if (^alive) {
		alive := false;
		removeChild(parent, child);
	} else if (isUrlParameterTrue("dev")) {
		println("Warning: Double dispose");
		printCallstack();
		println("---");
	}
}

switchTransform(tr : Transform<?>, fn : (b : Behaviour<?>) -> Form) -> Form {
	switch (tr) {
		ConstBehaviour(__) : fn(tr);
		DynamicBehaviour(__, __) : fn(tr);
		default: {
			trB = make(fgetValue(tr));

			Constructor(
				fn(trB),
				\ -> fconnect(tr, trB)
			)
		}
	}
}

switchTransform2(tr : Transform<?>, convertFn : (?) -> ??, fn : (b : Behaviour<??>) -> Form) -> Form {
	switch (tr) {
		ConstBehaviour(__) : fn(const(convertFn(fgetValue(tr))));
		default: {
			trB = make(convertFn(fgetValue(tr)));

			Constructor(
				fn(trB),
				makeSubscribe(tr, \tr0 -> nextDistinct(trB, convertFn(tr0)))
			)
		}
	}
}

isConvertableForm(form : Form) -> bool {
	switch (form : Form) {
		DynamicGroup2(__, combiner, __, __): combiner == GroupCombiner();
		Grid(__): false;
		Camera(__, __, __, __): false;
		default: true;
	}
}

fform2form(fform : FForm) -> Form {
	switch (fform) {
		FText(text, style) : {
			if (isFConst(text)) {
				Text(fgetValue(text), style2characterStyle(style));
			} else {
				form = make(Empty());

				Constructor(
					Mutable(form),
					makeSubscribe(text, \t -> next(form, Text(t, style2characterStyle(style))))
				);
			}
		}
		FParagraph(__, __) : FParagraph2Form(fform);
		FGraphics(path, style) : {
			fm = make(FormMetrics(0., 0., 0., 0.));

			NativeForm(
				fform,
				fm,
				\ -> Empty(),
				\av, zo, to -> {
					d = renderFGraphics(path, style);
					u = make2Subscribe(path, style, \p, s -> next(fm, getStaticFormSize2(Graphics(p, s), false)))();

					NativeRenderResult(
						d.clips,
						\ -> applyall(arrayPush(d.disposers, u))
					)
				}
			);
		}
		FTranslate(x, y, form) : switchTransform(x, \x0 -> switchTransform(y, \y0 -> Translate(x0, y0, fform2form(form))));
		FScale(x, y, form) : switchTransform(x, \x0 -> switchTransform(y, \y0 -> Scale(x0, y0, fform2form(form))));
		FRotate(degree, form) : switchTransform(degree, \dg -> Rotate(dg, fform2form(form)));
		FAlpha(alpha, form) : switchTransform(alpha, \al -> Alpha(al, fform2form(form)));
		FVisible(visible, form) : switchTransform2(visible, b2i, \vi -> Visible(vi, fform2form(form)));
		FRenderable(renderable, form) : switchTransform2(renderable, b2i, \r -> Visible(r, fform2form(form)));
		FGroup(layers, __) : Group(map(layers, fform2form));
		FGroup2(layer1, layer2, __) : Group([fform2form(layer1), fform2form(layer2)]);
		FEmpty() : Empty();
		FBorder(left, top, right, bottom, form) : Border(left, top, right, bottom, fform2form(form));
		FMask2(form, mask, stack) : Mask2(fform2form(form), fform2form(mask), stack);
		FInteractive(listeners, form) : Interactive(listeners, fform2form(form));
		FFilter2(filt, form, stack) : Filter2(filt, fform2form(form), stack);
		FCursor(shape, form) : Cursor(shape, fform2form(form));
		FInspect(inspectors, form) : Inspect(inspectors, fform2form(form));
		FMutable2(form, stack) : switchTransform2(form, fform2form, \fo -> Mutable2(fo, stack));
		FDecorator2(form, decorators, above, stack) : {
			f1 = fform2form(form);

			f2 = map(decorators, \d -> {
				c = make(Empty());

				Constructor(Mutable2(c, stack), makeSubscribe(d.first, \en -> next(c, if (en) fform2form(d.second()) else Empty())));
			});

			Group(if (above) concat([f1], f2) else arrayPush(f2, f1));
		}
		FCrop2(left, top, width, height, enabled, form, stack) : switchTransform(left, \l -> switchTransform(top, \t -> switchTransform(width, \w ->
			switchTransform(height, \h -> Crop2(l, t, w, h, fform2form(form), stack)))));
		FControlFocus(focus, form) : ControlFocus(focus, fform2form(form));
		FPicture(url, size, s) : Inspect([ISize(size)], Picture(url, s));
		FConstructor(form, fn) : Constructor(fform2form(form), fn);
		FCreate2(current, fn) : Create2(ref fform2form(^current), \ -> fform2form(fn()));
		FFullWindow(fullscreen, available, form) : FullWindow(fullscreen, Inspect([IAvailable(available)], fform2form(form)));
		FFullScreen2(fullscreen, available, form, __) : FullScreen(fullscreen, Inspect([IAvailable(available)], fform2form(form)));
		FBaseline(b, form) : Baseline(b, fform2form(form));
		FSize2(s, form) : Size2(s, fform2form(form));
		FAvailable2(a, form) : Available2(a, fform2form(form));
		FAccess(prop, form) : FAccessProperties2AccessProperties(prop) |> (\f -> Constructor(Access(f.first, fform2form(form)), f.second));
		FSetPending(setpending, form) : switchTransform(setpending, \sp -> SetPending(sp, fform2form(form)));
		FRealHTML(url, wh, style) : switchTransform(wh, \whB -> RealHTML2(url, whB, FRealHTMLStyle2RealHTMLStyle(style)));
		FMForm(form) : form;
		FDynamicGroup2(__, __, __) : FDynamicGroup2DynamicGroup(fform) |> (\f -> Constructor(f.first, f.second));
		FVideo(__, __, __) : FVideo2Video(fform) |> (\f -> Constructor(f.first, f.second));
		FNativeForm(init, metrics, ff, fn): NativeForm(init, metrics, \ -> fform2form(ff()), fn);
		FTextInput(__, __, __) : FTextInput2TextInput(fform) |> (\f -> Constructor(f.first, f.second));
		FCanvas(content) : fform2form(content);
		FAnimation(content, __, __) : fform2form(content); // TODO:
		FOrigin(origin, form) : fform2form(form); // TODO:
	}
}

FRealHTMLStyle2RealHTMLStyle(style : [FRealHTMLStyle]) -> [RealHTMLStyle] {
	filtermap(style, \st -> 
		switch (st) {
			RealHTMLStyle(): cast(Some(st) : Some<FRealHTMLStyle> -> Maybe<RealHTMLStyle>);
			default: None();
		}
	)
}

form2fform(_form : Form) -> FForm {
	switch (_form : Form) {
		Text(text, style) : FText(const(text), style);
		Graphics(path, style) : FGraphics(const(path), const(style));
		Translate(x, y, form) : FTranslate(x, y, form2fform(form));
		Scale(x, y, form) : FScale(x, y, form2fform(form));
		Rotate(deg, form) : FRotate(deg, form2fform(form));
		Alpha(alpha, form) : FAlpha(alpha, form2fform(form));
		Visible(visible, form) : FVisible(fselect(visible, FLift(\v -> i2b(v))), form2fform(form));
		Group(layers) : FGroup(map(layers, form2fform), true);
		Empty() : FEmpty();
		Border(left, top, right, bottom, form) : FBorder(left, top, right, bottom, form2fform(form));
		Mask2(form, mask, stack) : FMask2(form |> form2fform, mask |> form2fform, stack);
		Interactive(listeners, form) : FInteractive(listeners, form2fform(form));
		Filter2(filt, form, stack) : FFilter2(filt, form2fform(form), stack);
		Cursor(shape, form) : FCursor(shape, form2fform(form));
		Mutable2(form, stack) : FMutable2(fselect(form, FLift(\f -> form2fform(f))), stack);
		Crop2(left, top, width, height, form, stack) : FCrop2(left, top, width, height, const(true), form2fform(form), stack);
		Picture(url, s) : FPicture(url, make(zeroWH), s);
		Constructor(form, fn) : FConstructor(form2fform(form), fn);
		FullWindow(fw, form) : FFullWindow(fw, make(zeroWH), form2fform(form));
		FullScreen(fs, form) : FFullScreen(fs, make(zeroWH), form2fform(form));
		Baseline(b, form) : FBaseline(b, form2fform(form));
		Size2(s, form) : FSize2(s, form2fform(form));
		Available2(a, form) : FAvailable2(a, form2fform(form));
		Access(prop, form) : FAccess(AccessProperties2FAccessProperties(prop), form2fform(form));
		Inspect(inspectors, form) : FInspect(inspectors, form2fform(form));
		SetPending(pending, form) : FSetPending(pending, form2fform(form));
		ControlFocus(focus, form) : FControlFocus(focus, form2fform(form));
		RealHTML2(url, wh, style) : FRealHTML(url, wh, style);
		Create2(current, fn) : FCreate2(ref form2fform(^current), \ -> form2fform(fn()));
		Camera(filename, parameters, listeners, controls) : FMForm(_form); // TODO:
		Video(__, __, __, __) : Video2FVideo(_form) |> (\f -> FConstructor(f.first, f.second));
		TextInput(__, __, __) : TextInput2FTextInput(_form) |> (\f -> FConstructor(f.first, f.second));
		Switch(val, cases) : FMutable(fselect(val, FLift(\v -> form2fform(cases[v]))));
		NativeForm(init, metrics, f, fn) : FNativeForm(init, metrics, \ -> form2fform(f()), fn);
		Grid(cells) : FMForm(_form); // TODO:
		DynamicGroup2(__, __, __, __) : {
			if (isConvertableForm(_form))
				DynamicGroup2FDynamicGroup(_form) |> (\f -> FConstructor(f.first, f.second))
			else
				FMForm(_form);
		}
	}
}

AccessProperties2FAccessProperties(prop : [AccessProperty]) -> [FAccessProperty] {
	fold(prop, [], \acc, p ->
		switch (p : AccessProperty) {
			AccessChildSelected(__) : arrayPush(acc, p);
			AccessRole(__) : arrayPush(acc, p);
			AccessGroup(__) : acc;
			AccessFocused(__) : arrayPush(acc, p);
			AccessEnabled(enabled) : arrayPush(acc, FAccessEnabled(enabled));
			AccessCallback(__) : arrayPush(acc, p);
			AccessAttribute(name, value) : arrayPush(acc, FAccessAttribute(name, value));
			AccessStyle(name, value) : arrayPush(acc, FAccessStyle(name, value));
			AccessDescription(__) : arrayPush(acc, p);
			AccessKbdShortcutString(__) : arrayPush(acc, p);
			AccessTabOrder(tabOrder) : arrayPush(acc, FAccessTabOrder(tabOrder));
			AccessTabindex(ti) : arrayPush(acc, FAccessTabindex(const(ti)));
			AccessSelectable() : arrayPush(acc, p);
			AccessState(__) : arrayPush(acc, p);
			AccessZorder(zOrder) : arrayPush(acc, FAccessZorder(zOrder));
			TagName(__) : arrayPush(acc, p);
			LangAttribute(__) : arrayPush(acc, p);
			AccessForceMakeClip(__) : arrayPush(acc, p);
		}
	)
}

FAccessProperties2AccessProperties(prop : [FAccessProperty]) -> Pair<[AccessProperty], () -> () -> void> {
	fold(prop, Pair([], []), \acc : Pair<[AccessProperty], [() -> () -> void]>, p ->
		switch (p : FAccessProperty) {
			AccessChildSelected(__) :
				Pair(
					arrayPush(firstOfPair(acc), p),
					secondOfPair(acc)
				);
			AccessRole(__) :
				Pair(
					arrayPush(firstOfPair(acc), p),
					secondOfPair(acc)
				);
			AccessFocused(__) :
				Pair(
					arrayPush(firstOfPair(acc), p),
					secondOfPair(acc)
				);
			AccessCallback(__) :
				Pair(
					arrayPush(firstOfPair(acc), p),
					secondOfPair(acc)
				);
			AccessSelectable() :
				Pair(
					arrayPush(firstOfPair(acc), p),
					secondOfPair(acc)
				);
			AccessState(__) :
				Pair(
					arrayPush(firstOfPair(acc), p),
					secondOfPair(acc)
				);
			AccessDescription(__) :
				Pair(
					arrayPush(firstOfPair(acc), p),
					secondOfPair(acc)
				);
			AccessKbdShortcutString(__) :
				Pair(
					arrayPush(firstOfPair(acc), p),
					secondOfPair(acc)
				);
			FAccessTabindex(ti) : {
				Pair(
					arrayPush(firstOfPair(acc), AccessTabindex(fgetValue(ti))),
					secondOfPair(acc)
				);
			}
			FAccessEnabled(enabled) : {
				enabledB = make(fgetValue(enabled));

				Pair(
					arrayPush(firstOfPair(acc), AccessEnabled(enabledB)),
					arrayPush(secondOfPair(acc), makeSubscribe2(enabled, \en -> nextDistinct(enabledB, en)))
				);
			}
			FAccessAttribute(name, value) : {
				valueB = make(fgetValue(value));

				Pair(
					arrayPush(firstOfPair(acc), AccessAttribute(name, valueB)),
					arrayPush(secondOfPair(acc), makeSubscribe2(value, \v -> nextDistinct(valueB, v)))
				);
			}
			FAccessStyle(name, value) : {
				valueB = make(fgetValue(value));

				Pair(
					arrayPush(firstOfPair(acc), AccessStyle(name, valueB)),
					arrayPush(secondOfPair(acc), makeSubscribe2(value, \v -> nextDistinct(valueB, v)))
				);
			}
			FAccessTabOrder(tabOrder) : {
				tabOrderB = make(fgetValue(tabOrder));

				Pair(
					arrayPush(firstOfPair(acc), AccessTabOrder(tabOrderB)),
					arrayPush(secondOfPair(acc), makeSubscribe2(tabOrder, \to -> nextDistinct(tabOrderB, to)))
				);
			}
			FAccessZorder(zOrder) : {
				zOrderB = make(fgetValue(zOrder));

				Pair(
					arrayPush(firstOfPair(acc), AccessZorder(zOrderB)),
					arrayPush(secondOfPair(acc), makeSubscribe2(zOrder, \z -> nextDistinct(zOrderB, z)))
				);
			}
			FAccessVisible(__): {
				acc;
			}
			TagName(__): {
				acc;
			}
			ClassName(__): {
				acc;
			}
			LangAttribute(__): {
				acc;
			}
			FAccessProtected() : {
				acc;
			}
			FAccessHidden() : {
				Pair(
					arrayPush(firstOfPair(acc), AccessAttribute("aria-hidden", const("true"))),
					secondOfPair(acc)
				)
			}
			AccessForceMakeClip(__) : {
				Pair(
					arrayPush(firstOfPair(acc), p),
					secondOfPair(acc)
				);
			}
		}
	)
	|> (\f : Pair<[AccessProperty], [() -> () -> void]> -> Pair(f.first, \ -> {disp = map(f.second, apply0); \ -> applyall(disp);}))
}

FVideo2Video(fvideo : FVideo) -> Pair<Video, () -> () -> void> {
	playing = extractStruct(fvideo.style, FVideoPlay(make(false))).play;
	paused = make(!getValue(playing));
	position = extractStruct(fvideo.style, FVideoPosition(make(0.))).position;
	errorHandlerFn = extractStruct(fvideo.style, OnVideoLoadingError(nop));
	streamListenerFn = extractStruct(fvideo.style, StreamStatus(nop1));
	synchroCalls = extractStruct(fvideo.style, SynchroCalls(nop, nop));
	duration = extractStruct(fvideo.style, FVideoLength(make(1.))).length;

	volume = extractStruct(fvideo.style, FVideoVolume(make(1.))).volume;
	fullscreen = extractStruct(fvideo.style, FVideoFullscreen(make(false))).fullscreen;
	controls = extractStruct(fvideo.style, FVideoControls([])).controls;
	subtitles = extractStruct(fvideo.style, FVideoSubtitles(const(VideoSubtitle("", [])))).subtitles;
	looping = extractStruct(fvideo.style, FVideoLoop(const(false))).loop;
	timeRange = tryExtractStruct(fvideo.style, FVideoTimeRange(const(0.), const(0.)));

	videoSubtitles = make(fgetValue(subtitles));
	videoFullscreen = ref make(getValue(fullscreen));

	Pair(
		Video(
			fvideo.url,
			[
				VideoSize(floor(fgetValue(fvideo.wh).width),floor(fgetValue(fvideo.wh).height)),
				errorHandlerFn
			]
			|> (\videoParameters ->
				if (fgetValue(looping))
					arrayPush(videoParameters, LoopPlayback())
				else
					videoParameters
			)
			|> (\videoParameters ->
				if (!getValue(playing))
					arrayPush(videoParameters, NoAutoPlay())
				else
					videoParameters
			)
			|> (\videoParameters ->
				eitherMap(
					timeRange,
					\tr ->
						concat(
							videoParameters,
							[
								StreamStartOffset(fgetValue(tr.start)),
								StreamEndOffset(fgetValue(tr.end))
							]
						),
					videoParameters
				)
			),
			[
				streamListenerFn,
				synchroCalls,
				PlayerLength(duration),
				PlayerIsPlaying(playing),
				PlayerPosition(position, 33)
			],
			[
				PlayerVolume(volume),
				PlayerPause(paused),
				PlayerSeek(position),
				VideoFullScreen(\fs -> {
					nextDistinct(fs, getValue(^videoFullscreen));
					videoFullscreen := fs
				}),
				VideoPlayerControls(controls),
				VideoPlayerSubtitles(videoSubtitles)
			]
		),
		\ -> {
			disp =
				[
					fconnect(subtitles, videoSubtitles),
					fconnect(fnot(playing), paused),
					makeSubscribe(fullscreen, \fs -> nextDistinct(^videoFullscreen, fs))()
				];

			\ -> applyall(disp);
		}
	);
}

Video2FVideo(video : Video) -> Pair<FVideo, () -> () -> void> {
	videoFullscreen = make(false);
	videoVolume = make(1.);

	videoSize = extractStruct(video.parameters, VideoSize(-1, -1));
	loopVideo = contains(video.parameters, LoopPlayback());
	autoPlay = !contains(video.parameters, NoAutoPlay());
	onVideoLoadingError = extractStruct(video.parameters, OnVideoLoadingError(nop));
	startOffset = extractStruct(video.parameters, StreamStartOffset(0.)).offset;
	endOffset = extractStruct(video.parameters, StreamEndOffset(0.)).offset;

	streamStatus = extractStruct(video.listeners, StreamStatus(nop1));
	synchroCalls = extractStruct(video.listeners, SynchroCalls(nop, nop));
	videoDuration = extractStruct(video.listeners, PlayerLength(make(0.))).length;
	videoPlaying = extractStruct(video.listeners, PlayerIsPlaying(make(autoPlay))).isPlaying;
	videoPosition = extractStruct(video.listeners, PlayerPosition(extractStruct(video.listeners, PlayerPosition2(make(0.), make(0.))).position, 0)).position;

	playerVolume = extractStruct(video.controls, PlayerVolume(make(1.))).volume;
	playerPause = extractStruct(video.controls, PlayerPause(make(!autoPlay))).pause;
	playerSeek = extractStruct(video.controls, PlayerSeek(make(0.))).position;
	fsInit = extractStruct(video.controls, VideoFullScreen(nop1)).stateInitializer;
	playerControls = extractStruct(video.controls, VideoPlayerControls([])).controls;
	playerSubtitles = extractStruct(video.controls, VideoPlayerSubtitles(make(VideoSubtitle("", [])))).subtitle;

	nextDistinct(videoPlaying, autoPlay);
	fsInit(videoFullscreen);

	Pair(
		FVideo(
			video.filename,
			make(WidthHeight(videoSize.width |> i2d, videoSize.height |> i2d)),
			concatA([
				[
					FVideoLoop(make(loopVideo)),
					onVideoLoadingError,
					streamStatus,
					synchroCalls,
					FVideoLength(videoDuration),
					FVideoPlay(videoPlaying),
					FVideoPosition(videoPosition),
					FVideoVolume(videoVolume),
					FVideoControls(playerControls),
					FVideoSubtitles(playerSubtitles),
				],
				if (startOffset != 0. || endOffset != 0.)
					[FVideoTimeRange(const(startOffset), faddition(videoDuration, const(endOffset)))]
				else
					[]
			])
		),
		\ -> {
			disp =
				[
					fconnect(fnot(playerPause), videoPlaying),
					fconnect(playerSeek, videoPosition),
					fconnect(playerVolume, videoVolume),
				];

			\ -> applyall(disp);
		}
	)
}

TextInput2FTextInput(textInput : TextInput) -> Pair<FTextInput, () -> () -> void> {
	autoAlign = make(AutoAlignLeft());
	multiline = make(false);
	textSize = make(WidthHeight(-1., -1.));
	focused = make(false);
	wordWrap = make(false);
	numeric = make(false);
	readOnly = make(false);
	maxChars = make(-1);
	content = make("");
	charStyle = make([]);
	position = make(-1);
	selection = make(-1);
	eatKeyDownOnFocus = make(false);
	scrollInfo = make(ScrollInfo(-1, -1, -1));
	inputType = make(TextType());
	inputFilter = make(\__ -> true);
	tabIndex = make(-1);
	tabEnabled = make(false);

	stateFn = \state -> {
		nextDistinct(autoAlign, extractStruct(state, AutoAlign(getValue(autoAlign))).autoalign);
		nextDistinct(multiline, extractStruct(state, Multiline(getValue(multiline))).multiline);
		nextDistinct(textSize, extractStruct(state, getValue(textSize) |> (\ts -> TextSize(ts.width, ts.height)))
			|> (\ts -> WidthHeight(ts.width, ts.height)));
		nextDistinct(focused, extractStruct(state, Focus(getValue(focused))).focus);
		nextDistinct(wordWrap, extractStruct(state, WordWrap(getValue(wordWrap))).wordWrap);
		nextDistinct(numeric, extractStruct(state, Numeric(getValue(numeric))).numeric);
		nextDistinct(readOnly, extractStruct(state, ReadOnly(getValue(readOnly))).readOnly);
		nextDistinct(maxChars, extractStruct(state, MaxChars(getValue(maxChars))).n);
		extractStruct(state, Content(getValue(content), getValue(charStyle)))
		|> (\c -> {
			nextDistinct(content, c.content);
			nextDistinct(charStyle, c.style);
		});

		extractStruct(state, Selection(getValue(position), getValue(selection)))
		|> (\s -> {
			nextDistinct(position, s.start);
			nextDistinct(selection, s.end);
		});

		if (extractStruct(state, PasswordMode(getValue(inputType) == PasswordType())).password)
			nextDistinct(inputType, PasswordType());

		nextDistinct(eatKeyDownOnFocus, contains(state, EatKeyDownOnFocus()));
		nextDistinct(scrollInfo, extractStruct(state, getValue(scrollInfo)));
		nextDistinct(inputType, extractStruct(state, TextInputType(getValue(inputType))).inputType);
		nextDistinct(inputFilter, extractStruct(state, TextInputFilter(getValue(inputFilter))).f);
		nextDistinct(tabIndex, extractStruct(state, TabIndex(getValue(tabIndex))).index);
		nextDistinct(tabEnabled, extractStruct(state, TabEnabled(getValue(tabEnabled))).enabled);
	}

	modelFn = \ ->
		TextInputModel(
			getValue(content),
			getValue(textSize).width,
			getValue(textSize).height,
			getValue(position),
			Selection(getValue(position), getValue(selection)),
			getValue(focused),
			if (getValue(scrollInfo) != ScrollInfo(-1, -1, -1))
				Some(getValue(scrollInfo))
			else
				None()
		);

	stateFn(textInput.state);

	prevContent = ref getValue(content);

	textChange = tryExtractStruct(textInput.listeners, TextChange(nop1));
	textScroll = tryExtractStruct(textInput.listeners, TextScroll(nop1));
	focusIn = tryExtractStruct(textInput.listeners, FocusIn(nop));
	focusOut = tryExtractStruct(textInput.listeners, FocusOut(nop));

	stateChanger = tryExtractStruct(textInput.stateaccess, StateChanger(const([])));
	stateQuery = extractStruct(textInput.stateaccess, StateQuery(nop1)).reader;
	stateQuery2 = extractStruct(textInput.stateaccess, StateQuery2(ref \ -> modelFn())).reader;

	stateQuery(modelFn);
	stateQuery2 := modelFn;

	Pair(
		FTextInput(
			content,
			textSize,
			[
				FWordWrap(wordWrap),
				FMultiline(multiline),
				FInputType(inputType),
				FReadOnly(readOnly),
				FInputFilter(\s -> if (getValue(inputFilter)(s)) {prevContent := s; s} else ^prevContent),
				FMaxChars(maxChars),
				FAutoAlign(autoAlign),
				FFocus(focused),
				FPosition(position),
				FSelection(selection),
				FScrollInfo(scrollInfo),
			]
		),
		\ -> {
			disp =
				concatA([
					eitherMap(
						textChange,
						\tc -> [make4Subscribe(content, position, selection, focused, \__, __, __, __ -> tc.fn(modelFn()))()],
						[]
					),
					eitherMap(
						textScroll,
						\ts -> [makeSubscribe(scrollInfo, \__ -> ts.fn(modelFn()))()],
						[]
					),
					eitherMap(
						focusIn,
						\fi -> [makeSubscribe(focused, \f -> if (f) fi.fn())()],
						[]
					),
					eitherMap(
						focusOut,
						\fo -> [makeSubscribe(focused, \f -> if (!f) fo.fn())()],
						[]
					),
					eitherMap(
						stateChanger,
						\sc -> [subscribe(sc.state, \s -> deferred(\ -> stateFn(s)))],
						[]
					),
				]);

			\ -> applyall(disp);
		}
	)
}

FTextInput2TextInput(ftextInput : FTextInput) -> Pair<TextInput, () -> () -> void> {
	state = make([]);
	content = ftextInput.content;
	textSize = make(fgetValue(ftextInput.wh));
	charStyle = style2characterStyle(ftextInput.style);
	autoAlign = extractStruct(ftextInput.style, FAutoAlign(const(AutoAlignLeft()))).align;
	multiline = extractStruct(ftextInput.style, FMultiline(const(false))).multiline;
	focused = extractStruct(ftextInput.style, FFocus(make(false))).focus;
	wordWrap = extractStruct(ftextInput.style, FWordWrap(const(fgetValue(multiline)))).wrap;
	readOnly = extractStruct(ftextInput.style, FReadOnly(const(false))).readOnly;
	maxChars = extractStruct(ftextInput.style, FMaxChars(const(-1))).maxChars;
	position = extractStruct(ftextInput.style, FPosition(make(-1))).position;
	selection = extractStruct(ftextInput.style, FSelection(make(-1))).selection;
	scrollInfo = extractStruct(ftextInput.style, FScrollInfo(make(ScrollInfo(-1, -1, -1)))).info;
	inputType = extractStruct(ftextInput.style, FInputType(const(TextType()))).type;
	inputFilter = extractStruct(ftextInput.style, FInputFilter(idfn)).fn;

	stateFn = \ -> {
		nextDistinct(
			state,
			[
				Content(getValue(content), charStyle),
				TextSize(getValue(textSize).width, getValue(textSize).height),
				AutoAlign(fgetValue(autoAlign)),
				Multiline(fgetValue(multiline)),
				Focus(getValue(focused)),
				WordWrap(fgetValue(wordWrap)),
				ReadOnly(fgetValue(readOnly)),
				MaxChars(fgetValue(maxChars)),
				Selection(getValue(position), getValue(selection)),
				TextInputType(fgetValue(inputType)),
				TextInputFilter(\s -> inputFilter(s) == s)
			]
		)
	}

	modelFn = \model : TextInputModel -> {
		nextDistinct(content, model.content);
		nextDistinct(textSize, WidthHeight(model.width, model.height));
		nextDistinct(position, model.cursorPosition);
		nextDistinct(selection, if (model.selection.end == model.selection.start) model.cursorPosition else model.selection.end);
		nextDistinct(focused, model.focus);
		nextDistinct(scrollInfo, either(model.scrollinfo, ScrollInfo(-1, -1, -1)));
	}

	Pair(
		TextInput(
			[],
			[
				TextChange(modelFn),
				TextScroll(modelFn),
				FocusIn(\ -> nextDistinct(focused, true)),
				FocusOut(\ -> nextDistinct(focused, false)),
			],
			[
				StateChanger(state)
			]
		),
		\ -> {
			disp = [
				fconnect(ftextInput.wh, textSize),
				makeSubscribe(content, \__ -> stateFn())(),
				makeSubscribe(textSize, \__ -> stateFn())(),
				makeSubscribe(autoAlign, \__ -> stateFn())(),
				makeSubscribe(multiline, \__ -> stateFn())(),
				makeSubscribe(focused, \__ -> stateFn())(),
				makeSubscribe(wordWrap, \__ -> stateFn())(),
				makeSubscribe(readOnly, \__ -> stateFn())(),
				makeSubscribe(maxChars, \__ -> stateFn())(),
				makeSubscribe(position, \__ -> stateFn())(),
				makeSubscribe(selection, \__ -> stateFn())(),
				makeSubscribe(inputType, \__ -> stateFn())(),
			];

			\ -> applyall(disp);
		}
	)
}

FParagraphStyle2FTextStyle(style : [FParagraphStyle]) -> [FTextStyle] {
	filtermap(style, \s -> switch (s) {
		Underlined(__) : None();
		FTextStyle() : {a : Maybe<FTextStyle> = Some(s); a}
		default : None()
	})
}

FDynamicGroup2DynamicGroup(group : FDynamicGroup2) -> Pair<DynamicGroup2, () -> () -> void> {
	formChanges : DynamicBehaviour<[GroupChange]> = make([]);

	Pair(
		DynamicGroup2(formChanges, GroupCombiner(), make(map(getValue(group.currentStack), \cs -> fform2form(cs))), group.stack),
		makeSubscribe(group.stackChanges, \changes -> {
			recentChanges : [GroupChange] =
				fold(changes, [], \acc, change -> {
					switch (change : FGroupChange) {
						FGroupAdd(f, z) : arrayPush(acc, GroupAdd(fform2form(f), z));
						FGroupDelete(z) : arrayPush(acc, GroupDelete(z));
						FGroupMove(f, t) : arrayPush(acc, GroupMove(f, t));
						FGroupReplace(f, z) : concat(acc, [GroupDelete(z), GroupAdd(fform2form(f), z)]);
					}
				});

			nextDistinct(group.stackChanges, []);
			next(formChanges, recentChanges);
		})
	)
}

DynamicGroup2FDynamicGroup(group : DynamicGroup2) -> Pair<FDynamicGroup2, () -> () -> void> { // TODO:
	fformChanges : DynamicBehaviour<[FGroupChange]> = make([]);

	Pair(
		FDynamicGroup2(fformChanges, make(map(getValue(group.currentStack), \cs -> form2fform(cs))), group.stack),
		makeSubscribe(group.stackChanges, \changes -> {
			recentChanges : [FGroupChange] =
				fold(changes, [], \acc, change -> {
					switch (change : GroupChange) {
						GroupAdd(f, z) : arrayPush(acc, FGroupAdd(form2fform(f), z));
						GroupDelete(z) : arrayPush(acc, FGroupDelete(z));
						GroupMove(f, t) : arrayPush(acc, FGroupMove(f, t));
					}
				});

			nextDistinct(group.stackChanges, []);
			next(fformChanges, recentChanges);
		})
	)
}

// form2FNativeForm(form : Form) -> FNativeForm {
// 	met = make(FormMetrics(0., 0., 0., 0.));

// 	FNativeForm(
// 		form,
// 		met,
// 		\ -> form2fform(form),
// 		\a, t, z  ->
// 			renderForm(form, a, t, z)
// 			|> (\rr : RenderResult -> {
// 				disp = make2Subscribe(rr.widthHeight, rr.baseline, \wh, b ->
// 					nextDistinct(met, FormMetrics(wh.width, wh.height, b, wh.height)))();

// 				NativeRenderResult(rr.clips, \ -> applyall(arrayPush(rr.disposers, disp)))
// 			})
// 	)
// }

FParagraph2Form(fParagraph : FParagraph) -> Form {
	wh = make(zeroWH);
	met = make(FormMetrics(0., 0., 0., 0.));
	fform =
		FParagraph(
			fParagraph.text,
			eitherFn(
				tryExtractStruct(fParagraph.style, ParagraphMetrics(nop1)),
				\pm ->
					replaceStruct(fParagraph.style, ParagraphMetrics(\m -> {
						pm.fn(m);
						nextDistinct(met, FormMetrics(m.width, m.height, m.baseline, m.height));
						nextDistinct(wh, WidthHeight(m.width, m.height));
					})),
				\ ->
					replaceStruct(fParagraph.style, ParagraphMetrics(\m -> {
						nextDistinct(met, FormMetrics(m.width, m.height, m.baseline, m.height));
						nextDistinct(wh, WidthHeight(m.width, m.height));
					}))
			)
		);

	NativeForm(
		fform,
		met,
		\ -> {
			charStyle = style2characterStyle(fParagraph.style);

			if (isFConst(fParagraph.text)) {
				Text(fgetValue(fParagraph.text), charStyle);
			} else {
				form = make(Empty());

				Size2(
					wh,
					Constructor(
						Mutable(form),
						makeSubscribe(fParagraph.text, \t -> next(form, Text(t, charStyle)))
					)
				);
			}
		},
		\__, __, __ -> {
			renderFParagraph(fform.text, fform.style)
			|> (\f -> NativeRenderResult(f.clips, \ -> applyall(f.disposers)))
		}
	)
}

renderFGraphics(path0 : Transform<[StaticGraphicOp]>, style0 : Transform<[GraphicsStyle]>) -> FRenderResult {
	if (js) {
		clip = makeGraphics();
		setClipDebugInfo(clip, "form", FGraphics(path0, style0));

		u = make2Subscribe(path0, style0, \path, style -> {
			clearGraphics(clip);

			fillcolour = ref None();
			fillopacity = ref 1.0;
			gradientFill = ref None();
			gradientType = ref "linear";
			strokecolour = ref None();
			strokeopacity = ref 1.0;
			strokewidth = ref 1.0;
			strokeLineGradient = ref None();

			iter(style, \s : GraphicsStyle ->
				switch (s : GraphicsStyle) {
					Fill(col): fillcolour := Some(col);
					FillOpacity(op): fillopacity := op;
					GradientFill(c, rotation): gradientFill := Some(s);
					RadialGradient(): gradientType := "radial";
					Stroke(colour): strokecolour := Some(colour);
					StrokeOpacity(opacity): strokeopacity := opacity;
					StrokeWidth(width): strokewidth := width;
					StrokeLineGradient(c, rotation): strokeLineGradient := Some(s);
					UseSvg() : {}
				}
			);

			matrix = if (isSome(^strokeLineGradient) || isSome(^gradientFill)) {
				updateQRange = \acc : Quadruple<double, double, double, double>, x : double, y : double -> {
					Quadruple(
						min(x, acc.first),
						max(x, acc.second),
						min(y, acc.third),
						max(y, acc.fourth),
					)
				}

				m = fold(path, Quadruple(doubleMax, doubleMin, doubleMax, doubleMin), \acc : Quadruple<double, double, double, double>, op : StaticGraphicOp ->
					switch (op : StaticGraphicOp) {
						MoveTo(x, y) : updateQRange(acc, x, y);
						LineTo(x, y) : updateQRange(acc, x, y);
						CubicBezierTo(x, y, cx, cy): updateQRange(acc, x, y);
						QuadraticBezierTo(x, y, cx, cy): updateQRange(acc, x, y);
						ClosePath(): acc;
						GRect(x, y, w, h): {
							updateQRange(updateQRange(acc, x, y), x + w, y + h);
						}
						GRoundedRect(x, y, w, h, __): {
							updateQRange(updateQRange(acc, x, y), x + w, y + h);
						}
						GEllipse(x, y, w, h): {
							updateQRange(updateQRange(acc, x - w, y - h), x + w, y + h);
						}
						GCircle(x, y, r): {
							updateQRange(updateQRange(acc, x - r, y - r), x + r, y + r);
						}
					}
				);

				Some(\r -> makeMatrix(abs(m.second - m.first), abs(m.fourth - m.third), r, m.first, m.third))
			} else {
				None()
			}

			maybeApply(^fillcolour, \fc : int -> beginFill(clip, fc, ^fillopacity));
			maybeApply(^strokecolour, \sc : int -> setLineStyle(clip, ^strokewidth, sc, ^strokeopacity));
			maybeApply(^strokeLineGradient, \sg : StrokeLineGradient-> {
				colors = map(sg.points, \c -> c.color);
				alphas = map(sg.points, \c -> c.alpha);
				offsets = map(sg.points, \c -> c.offset);
				maybeApply(matrix, \m -> setLineGradientStroke(clip, colors, alphas, offsets, m(sg.rotation)));
			});
			maybeApply(^gradientFill, \gf : GradientFill -> {
				colors = map(gf.points, \c -> c.color);
				alphas = map(gf.points, \c -> c.alpha);
				offsets = map(gf.points, \c -> c.offset);
				maybeApply(matrix, \m -> beginGradientFill(clip, colors, alphas, offsets, m(gf.rotation), ^gradientType));
			});

			if (contains(style, UseSvg()) && !isUrlParameterFalse("useSvg")) {
				useSvg(clip);
			}

			// Render the path
			needClose = ref false;
			moveTo(clip, 0.0, 0.0);

			iter(if (js && length(path) == 1) path else deconstructGraphicsPath(path), \op : StaticGraphicOp ->
				switch (op : StaticGraphicOp) {
					MoveTo(x, y) : {
						moveTo(clip, x, y);
					}
					LineTo(x, y) : {
						needClose := true;
						lineTo(clip, x, y);
					}
					CubicBezierTo(x, y, cx, cy): {
						needClose := true;
						curveTo(clip, cx, cy, x, y);
					}
					QuadraticBezierTo(x, y, cx, cy): {
						needClose := true;
						curveTo(clip, cx, cy, x, y);
					}
					ClosePath(): {
						needClose := false;
						endFill(clip);
					}
					GRect(x, y, width, height): {
						needClose := false;
						drawRect(clip, x, y, width, height);
					}
					GRoundedRect(x, y, width, height, radius): {
						needClose := false;
						drawRoundedRect(clip, x, y, width, height, radius);
					}
					GEllipse(x, y, width, height): {
						needClose := false;
						drawEllipse(clip, x, y, width, height);
					}
					GCircle(x, y, radius): {
						needClose := false;
						drawCircle(clip, x, y, radius);
					}
				}
			);

			if (^needClose) {
				endFill(clip);
			}

		})();

		FRenderResult([clip], [u, \ -> deleteNative(clip)], [FClipMove(), FClipAnimation()])
	} else {
		clip = makeClip();
		setClipDebugInfo(clip, "form", FGraphics(path0, style0));
		u = make2Subscribe(path0, style0, \path, style -> {
			renderGraphics(clip, path, style) |> ignore;
		})();

		FRenderResult([clip], [u, \ -> deleteNative(clip)], [FClipMove(), FClipAnimation()])
	}
}

FTextRenderResult(
	x : Transform<double>,
	maxX : Transform<double>,
	y : Transform<double>,
	disposers : [() -> void]
);

emptyFTextRenderResult = FTextRenderResult(zero, zero, zero, []);

renderFTexts(texts : Transform<[Text]>, style : [FTextStyle]) -> FRenderResult {
	if (isFConst(texts) && length(fgetValue(texts)) < 2) {
		if (length(fgetValue(texts)) == 1) {
			renderFText(const(fgetValue(texts)[0].text), style);
		} else {
			emptyFRenderResult;
		}
	} else {
		renderFParagraphs(texts, style);
	}
}

renderFText(text : Transform<string>, style : [FTextStyle]) -> FRenderResult {
	charStyle = style2characterStyle(style);
	localizationEnabled = extractStruct(style, LocalizationEnabled(false)).enabled;
	localizedText = if (localizationEnabled) fselectLift(text, localizeNumbers) else text;
	textfield = makeStyledTextfield(fgetValue(localizedText), style);

	if (contains(style, SkipOrderCheck())) {
		setTextSkipOrderCheck(textfield, true);
	}

	uns = [
		eitherFn(
			tryExtractStruct(style, FDynamicColor(const(-1))),
			\dc -> make2Subscribe(localizedText, dc.color, \t, col -> defineTextStyle(textfield, t, replaceStruct(charStyle, Fill(col))))(),
			makeSubscribe(localizedText, \t -> defineTextStyle(textfield, t, charStyle))
		),

		eitherMap(
			tryExtractStruct(style, LangAttribute(const(""))),
			\la -> makeSubscribe(la.languageCode, \code -> setAccessAttributes(textfield, [["lang", code]]))(),
			nop
		),

		eitherMap(
			tryExtractStruct(style, TextWidthInspector(make(0.))),
			\tw -> addExtendedEventListener(textfield, "textwidthchanged", \values -> {
				wd = elementAt(values, 0, 0.);
				nextDistinct(tw.width, wd);
			}),
			nop
		),

		{
			if (contains(style, PreventTextNodeWidthCalculation())) setTextPreventCheckTextNodeWidth(textfield, true);
			nop;
		},

		eitherMap(
			tryExtractStruct(style, WordSpacing(zero)),
			\ws -> makeSubscribe(ws.spacing, \spacing -> setTextWordSpacing(textfield, spacing))(),
			nop
		)
	];

	disposer = \ -> {
		applyall(uns);

		// Flash is not very helpful: If a text has the focus, but dies, then we effectively lose focus
		if (flash && getFocus(textfield)) {
			setFocus(getStage(), true);
		}

		deleteNative(textfield);
	}

	eitherFn(
		tryExtractStruct(style, Underlined([])),
		\undr -> {
			urr = renderUnderline(textfield, undr, StartAlign(), None(), style);
			FRenderResult(arrayPush(urr.clips, textfield), arrayPush(urr.disposers, disposer), [FClipMask()])
		},
		\ ->
			FRenderResult([textfield], [disposer], [FClipMask()])
	)
}

renderFParagraphs(texts : Transform<[Text]>, style : [FParagraphStyle]) -> FRenderResult {
	if (isFConst(texts) && length(fgetValue(texts)) < 2) {
		if (length(fgetValue(texts)) == 1) {
			renderFParagraph(const(fgetValue(texts)[0].text), style);
		} else {
			emptyFRenderResult;
		}
	} else {
		clip = makeClip();

		FRenderResult(
			[clip],
			[
				makeSubscribeUns(texts, \tt -> {
					lineHeight = ref 0.0;

					d = foldi(tt, emptyFTextRenderResult, \i, acc, t -> {
						tstyle = replaceStructMany(style, t.style);

						childClip : ref native = ref clip;
						cx = make(0.0);
						cmx = make(0.0);
						cy = make(0.0);
						pm = ParagraphMetrics(\fm -> {
							deferUntilNextFrameRendered(\ -> next(cx, getTextFieldCharXPosition(^childClip, strlen(t.text))));
							next(cx, fm.width);
							next(cmx, fm.maxWidth);
							next(cy, fm.height);
						});

						alive = ref false;
						c = renderFParagraph(const(t.text), replaceStruct(tstyle, pm));
						childClip := c.clips[0];

						addChildClipAt(clip, ^childClip, i, alive);
						tm = getTextMetrics(^childClip);
						lineHeight := tm[0] + tm[1];
						accY = fmax(fsubtract(acc.y, const(^lineHeight)), zero);

						FTextRenderResult(
							faddition(acc.x, cx),
							faddition(acc.maxX, cmx),
							faddition(accY, cy),
							concat3(
								acc.disposers,
								[
									make2Subscribe(acc.x, accY, \x, y -> {
										setClipX(^childClip, x);
										setClipY(^childClip, y);
									})(),
									\ -> {
										removeChildClip(clip, ^childClip, alive);
									}
								],
								c.disposers
							)
						);
					});

					concat(
						d.disposers,
						[
							make3Subscribe(d.x, d.y, d.maxX, \x, y, mx ->
								maybeApply(tryExtractStruct(style, ParagraphMetrics(nop1)), \pm -> pm.fn(FFormMetrics(x, y, y, mx)))
							)()
						]
					)
				})()
			],
			[FClipMask()]
		);
	}
}

renderFParagraph(text : Transform<string>, style : [FParagraphStyle]) -> FRenderResult {
	charStyle = FParagraphStyle2FTextStyle(style);

	d = renderFText(text, charStyle);
	textfield = d.clips[length(d.clips) - 1];
	rtl = extractStruct(style, SetRTL(getDefaultRtl())).rtl;
	disposers = ref [];

	setEscapeHTML(textfield, extractStruct(style, EscapeHTML(false)).escape);
	setTextDirection(textfield, if (rtl) "rtl" else "ltr");
	setTextFieldCropWords(textfield, extractStruct(style, CropWords(true)).crop);

	if (js) {
		maybeApply(tryExtractStruct(style, Resolution(1.0)), \r -> setClipResolution(textfield, r.resolution));
	}

	metricsListeners = extractStructMany(style, ParagraphMetrics(nop1));

	updateMetricsFn =
		if (length(metricsListeners) == 0) nop
		else \ -> {
			metrics = FFormMetrics(
				getTextFieldWidth(textfield),
				getTextFieldHeight(textfield),
				getTextMetrics(textfield)[0],
				getTextFieldMaxWidth(textfield)
			);
			iter(metricsListeners, \listener -> listener.fn(metrics))
		}

	maybeApply(
		tryExtractStruct(style, InterlineSpacing(0.)),
		\interlineSpacing -> {
			setTextFieldInterlineSpacing(textfield, interlineSpacing.d);
			updateMetricsFn();
		}
	);

	autoAlign =
		if (contains(style, LeftAlign()))
			"AutoAlignLeft"
		else if (contains(style, RightAlign()))
			"AutoAlignRight"
		else if (contains(style, CenterAlign()))
			"AutoAlignCenter"
		else if (js && contains(style, Justify()))
			"AutoAlignJustify"
		else
			"AutoAlignNone";

	setAutoAlign(textfield, autoAlign);

	eitherFn(
		tryExtractStruct(style, ParagraphWidth(const(-1.))),
		\width -> {
			setWordWrap(textfield, true);

			maybeApply(
				tryExtractStruct(style, ParagraphEllipsis(0, nop1)),
				\el -> {
					setTextEllipsis(textfield, el.lines, el.fn);
				}
			);

			refArrayPush(
				disposers,
				makeSubscribe(width.width, \wd -> {
					setTextFieldWidth(textfield, wd);
					updateMetricsFn();
				})()
			)
		},
		updateMetricsFn
	);

	refArrayPush(disposers,
		makeSubscribe2(text, \__ -> updateMetricsFn())()
	);

	refArrayPush(disposers,
		addEventListener(textfield, "textwidthchanged", updateMetricsFn)
	);

	result = FRenderResult(d.clips, concat(d.disposers, ^disposers), d.capabilities);

	eitherMap(
		tryExtractStruct(style, Underlined([])),
		\undr -> {
			urr = renderUnderline(textfield, undr, extractCommonAlignment(style), tryExtractStruct(style, ParagraphWidth(const(-1.))), charStyle);
			FRenderResult(
				concat(result.clips, urr.clips),
				concat(result.disposers, urr.disposers),
				concat(result.capabilities, urr.capabilities)
			)
		},
		result
	)
}

renderUnderline(
	textfield : native,
	underlined : Underlined,
	align : CommonAlignment,
	paragraphWidth : Maybe<ParagraphWidth>,
	style : [FTextStyle]) -> FRenderResult {

	renderFGraphics(
		eitherFn(
			paragraphWidth,
			\parWd ->
				fselect(parWd.width, FLift(\pwd -> {
					wd = getTextFieldWidth(textfield);
					hgt = getTextFieldHeight(textfield) - 1.;

					left = max(0.,
						if (align == RightAlign()) pwd - wd
						else if (align == CenterAlign()) (pwd - wd) / 2.
						else 0.
					);

					[
						MoveTo(left, hgt),
						LineTo(left + wd, hgt),
					]
				})),
			\ -> {
				wd = getTextFieldWidth(textfield);
				hgt = getTextFieldHeight(textfield) - 1.;
				const([
					MoveTo(0., hgt),
					LineTo(wd, hgt),
				])
			}
		),
		const(
			if (underlined.style != [])
				underlined.style
			else
				[Stroke(extractStruct(style, Fill(0x000000)).color)]
		)
	);
}

renderFAnimation(clip : native, keyframes : Transform<[FAnimationKeyframe]>, style : [FAnimationStyle]) -> () -> void {
	onFinish = extractStruct(style, FAnimationOnFinish(nop)).onFinish;
	animationPercent = tryExtractStruct(style, FAnimationPercent(make(0.0)));
	direction =
		if (contains(style, FAnimationAlternateReverse()))
			FAnimationAlternateReverse()
		else if (contains(style, FAnimationAlternate()))
			FAnimationAlternate()
		else if (contains(style, FAnimationReverse()))
			FAnimationReverse()
		else
			FAnimationNormal();

	makeSubscribeUns(keyframes, \kf -> {
		if (length(kf) > 0) {
			[
				makeSubscribeUns(
					extractStruct(style, FAnimationDuration(const(1.0))).duration,
					\duration ->
						[
							makeSubscribeUns(
								extractStruct(style, FAnimationDelay(const(0.0))).delay,
								\delay ->
									[
										makeSubscribeUns(
											extractStruct(style, FAnimationEasing(const(CubicBezierEasing(0.0, 0.0, 1.0, 1.0)))).easing,
											\easing ->
												[
													makeSubscribeUns(
														extractStruct(style, FAnimationIterations(const(1))).iterations,
														\iterations ->
															[
																addFClipAnimation(
																	clip,
																	addMissingFAnimationKeyframeValues(kf),
																	duration,
																	delay,
																	easing,
																	iterations,
																	direction,
																	onFinish,
																	animationPercent
																)
															]
													)()
												]
										)()
									]
							)()
						]
				)()
			]
		} else {
			[]
		}
	})()
}

addMissingFAnimationKeyframeValues(keyframes : [FAnimationKeyframe]) -> [FAnimationKeyframe] {
	addScale = find(keyframes, \keyframe -> isSome(tryExtractStruct(keyframe.values, FScaleValue(Factor(1.0, 1.0)))));
	addAlpha = find(keyframes, \keyframe -> isSome(tryExtractStruct(keyframe.values, FAlphaValue(1.0))));
	addTranslate = find(keyframes, \keyframe -> isSome(tryExtractStruct(keyframe.values, FTranslateValue(zeroPoint))));
	addRotate = find(keyframes, \keyframe -> isSome(tryExtractStruct(keyframe.values, FRotateValue(0.0))));

	map(keyframes, \keyframe -> {
		FAnimationKeyframe(
			eitherMap(
				addScale,
				\scaleKeyframe -> {
					if (isNone(tryExtractStruct(keyframe.values, FScaleValue(Factor(1.0, 1.0)))))
						arrayPush(keyframe.values, extractStruct(scaleKeyframe.values, FScaleValue(Factor(1.0, 1.0))))
					else
						keyframe.values;
				},
				keyframe.values
			)
			|> (\values ->
				eitherMap(
					addAlpha,
					\alphaKeyframe -> {
						if (isNone(tryExtractStruct(values, FAlphaValue(1.0))))
							arrayPush(values, extractStruct(alphaKeyframe.values, FAlphaValue(1.0)))
						else
							values;
					},
					values
				)
			)
			|> (\values ->
				eitherMap(
					addTranslate,
					\translateKeyframe -> {
						if (isNone(tryExtractStruct(values, FTranslateValue(zeroPoint))))
							arrayPush(values, extractStruct(translateKeyframe.values, FTranslateValue(Point(1.0, 1.0))))
						else
							values;
					},
					values
				)
			)
			|> (\values ->
				eitherMap(
					addTranslate,
					\translateKeyframe -> {
						if (isNone(tryExtractStruct(values, FRotateValue(0.0))))
							arrayPush(values, extractStruct(translateKeyframe.values, FRotateValue(0.0)))
						else
							values;
					},
					values
				)
			)
		)
	});
}

addFClipAnimation(
	clip : native,
	keyframes : [FAnimationKeyframe],
	duration : double,
	delay : double,
	easing : CubicBezierEasing,
	iterations : int,
	direction : FAnimationDirection,
	onFinish : () -> void,
	animationPercent : Maybe<FAnimationPercent>
) -> () -> void {
	finalized = ref false;
	commitInitStylesFn = \ -> {
		if (!^finalized) {
			iter(keyframes[0].values, \v -> {
				switch (v : FAnimationValue) {
					FScaleValue(factor): {
						setClipScaleX(clip, factor.x);
						setClipScaleY(clip, factor.y);
					}
					FAlphaValue(alpha): {
						setClipAlpha(clip, alpha);
					}
					FTranslateValue(point): {
						setClipX(clip, point.x);
						setClipY(clip, point.y);
					}
					FRotateValue(degrees): {
						setClipRotation(clip, degrees);
					}
					FEasingValue(__): {}
				}
			});
		}
	}

	resetStylesFn = \ -> {
		if (exists(keyframes, \keyframe -> isSome(tryExtractStruct(keyframe.values, FScaleValue(Factor(1.0, 1.0)))))) {
			setClipScaleX(clip, 1.0);
			setClipScaleY(clip, 1.0);
		}

		if (exists(keyframes, \keyframe -> isSome(tryExtractStruct(keyframe.values, FAlphaValue(1.0))))) {
			setClipAlpha(clip, 1.0);
		}

		if (exists(keyframes, \keyframe -> isSome(tryExtractStruct(keyframe.values, FTranslateValue(zeroPoint))))) {
			setClipX(clip, 0.0);
			setClipY(clip, 0.0);
		}

		if (exists(keyframes, \keyframe -> isSome(tryExtractStruct(keyframe.values, FRotateValue(0.0))))) {
			setClipRotation(clip, 0.0);
		}
	}

	commitStylesFn = \ -> {
		if (!^finalized) {
			finalized := true;
			iter(keyframes[length(keyframes) - 1].values, \v -> {
				switch (v : FAnimationValue) {
					FScaleValue(factor): {
						setClipScaleX(clip, factor.x);
						setClipScaleY(clip, factor.y);
					}
					FAlphaValue(alpha): {
						setClipAlpha(clip, alpha);
					}
					FTranslateValue(point): {
						setClipX(clip, point.x);
						setClipY(clip, point.y);
					}
					FRotateValue(degrees): {
						setClipRotation(clip, degrees);
					}
					FEasingValue(__): {}
				}
			});
		}
	}

	if (length(keyframes) > 1) {
		animationPercentDisposer =
			eitherMap(
				animationPercent,
				\ap -> {
					started = ref None();
					disp = ref nop;

					disp :=
						addDrawFrameEventListener(\df -> {
							percent =
								eitherFn(
									^started,
									\st -> {
										max(0.0, df - st - delay * 1000.0) / 1000.0 / duration;
									},
									\ -> {
										started := Some(df);
										0.0;
									}
								);

							if (percent >= 0.0) {
								if (percent < 1.0) {
									next(ap.percent, percent);
								} else {
									next(ap.percent, 1.0);
									^disp();
									disp := nop;
								}
							}
						});

					\ -> {
						^disp();
						disp := nop;
					}
				},
				nop
			);

		addClipAnimationFn = \ ->
			addClipAnimation(
				clip,
				map(keyframes, \v -> {
					fold(v.values, [], \acc, vv -> {
						switch (vv : FAnimationValue) {
							FScaleValue(factor): {
								eitherFn(
									findi(acc, \vvv -> vvv == "transform"),
									\i -> {
										replace(acc, i + 1, acc[i + 1] + " scale(" + d2s(factor.x) + ", " + d2s(factor.y) + ")")
									},
									\ -> {
										concat(acc, ["transform", "scale(" + d2s(factor.x) + ", " + d2s(factor.y) + ")"])
									}
								)
							}
							FAlphaValue(alpha): {
								eitherFn(
									findi(acc, \vvv -> vvv == "opacity"),
									\i -> {
										replace(acc, i + 1, acc[i + 1] + " " + d2s(alpha))
									},
									\ -> {
										concat(acc, ["opacity", d2s(alpha)])
									}
								)
							}
							FTranslateValue(point): {
								eitherFn(
									findi(acc, \vvv -> vvv == "transform"),
									\i -> {
										replace(acc, i + 1, acc[i + 1] + " translate(" + d2s(point.x) + "px, " + d2s(point.y) + "px)")
									},
									\ -> {
										concat(acc, ["transform", "translate(" + d2s(point.x) + "px," + d2s(point.y) + "px)"])
									}
								)
							}
							FRotateValue(degrees): {
								eitherFn(
									findi(acc, \vvv -> vvv == "transform"),
									\i -> {
										replace(acc, i + 1, acc[i + 1] + " rotate(" + d2s(degrees) + "deg)")
									},
									\ -> {
										concat(acc, ["transform", "rotate(" + d2s(degrees) + "deg)"])
									}
								)
							}
							FEasingValue(easing2): {
								eitherFn(
									findi(acc, \vvv -> vvv == "easing"),
									\i -> {
										replace(acc, i + 1, acc[i + 1] + " cubic-bezier(" + d2s(easing2.x1) + ", " + d2s(easing2.y1) + ", " +
											d2s(easing2.x2) + ", " + d2s(easing2.y2) + ")")
									},
									\ -> {
										concat(acc, ["easing", "cubic-bezier(" + d2s(easing2.x1) + ", " + d2s(easing2.y1) + ", " +
											d2s(easing2.x2) + ", " + d2s(easing2.y2) + ")"])
									}
								)
							}
						}
					})
				}),
				[
					[
						"duration",
						i2s(floor(duration * 1000.0))
					],
					[
						"easing",
						"cubic-bezier(" + d2s(easing.x1) + ", " + d2s(easing.y1) + ", " +
							d2s(easing.x2) + ", " + d2s(easing.y2) + ")",
					],
					[
						"iterations",
						if (iterations >= intMax)
							"Infinity"
						else
							i2s(iterations)
					],
					[
						"direction",
						switch (direction : FAnimationDirection) {
							FAnimationNormal(): "normal";
							FAnimationAlternate(): "alternate";
							FAnimationReverse(): "reverse";
							FAnimationAlternateReverse(): "alternate-reverse";
						}
					]
				],
				\ -> {
					commitStylesFn();

					onFinish();
				},
				\ -> {
					animationPercentDisposer();

					started = ref None();
					iteration = ref 0;
					disp = ref nop;
					reversed = ref direction == FAnimationReverse() || direction == FAnimationAlternateReverse();

					disp :=
						addDrawFrameEventListener(\df -> {
							percent =
								eitherFn(
									^started,
									\st -> {
										max(0.0, df - st) / 1000.0 / duration;
									},
									\ -> {
										started := Some(df);
										0.0;
									}
								);

							if (percent >= 0.0) {
								if (percent < 1.0) {
									maybeApply(animationPercent, \ap -> next(ap.percent, percent));

									easedPercent = lerpCurve(0.0, 1.0, easing)(if (^reversed) 1.0 - percent else percent);

									i = floor(i2d(length(keyframes) - 1) * easedPercent);
									keyframe = keyframes[i];
									nextKeyframe = keyframes[min(i + 1, length(keyframes) - 1)];
									localPercent = (easedPercent - i2d(i) / i2d(length(keyframes) - 1)) * i2d(length(keyframes) - 1);
									localEasing = extractStruct(keyframe.values, FEasingValue(easingLinearCurve)).easing;

									iter(keyframe.values, \v -> {
										switch (v : FAnimationValue) {
											FScaleValue(factor): {
												nextFactor = extractStruct(nextKeyframe.values, v).factor;
												if (^reversed) {
													setClipScaleX(clip, lerpCurve(nextFactor.x, factor.x, localEasing)(1.0 - localPercent));
													setClipScaleY(clip, lerpCurve(nextFactor.y, factor.y, localEasing)(1.0 - localPercent));
												} else {
													setClipScaleX(clip, lerpCurve(factor.x, nextFactor.x, localEasing)(localPercent));
													setClipScaleY(clip, lerpCurve(factor.y, nextFactor.y, localEasing)(localPercent));
												}
											}
											FAlphaValue(alpha): {
												nextAlpha = extractStruct(nextKeyframe.values, v).alpha;
												if (^reversed) {
													setClipAlpha(clip, lerpCurve(nextAlpha, alpha, localEasing)(1.0 - localPercent));
												} else {
													setClipAlpha(clip, lerpCurve(alpha, nextAlpha, localEasing)(localPercent));
												}
											}
											FTranslateValue(point): {
												nextPoint = extractStruct(nextKeyframe.values, v).point;
												if (^reversed) {
													setClipX(clip, lerpCurve(nextPoint.x, point.x, localEasing)(1.0 - localPercent));
													setClipY(clip, lerpCurve(nextPoint.y, point.y, localEasing)(1.0 - localPercent));
												} else {
													setClipX(clip, lerpCurve(point.x, nextPoint.x, localEasing)(localPercent));
													setClipY(clip, lerpCurve(point.y, nextPoint.y, localEasing)(localPercent));
												}
											}
											FRotateValue(degrees): {
												nextPoint = extractStruct(nextKeyframe.values, v).degrees;
												if (^reversed) {
													setClipRotation(clip, lerpCurve(nextPoint, degrees, localEasing)(1.0 - localPercent));
												} else {
													setClipRotation(clip, lerpCurve(degrees, nextPoint, localEasing)(localPercent));
												}
											}
											FEasingValue(__): { }
										}
									});
								} else {
									maybeApply(animationPercent, \ap -> next(ap.percent, 1.));

									iteration := ^iteration + 1;

									if (^iteration >= iterations) {
										^disp();
										disp := nop;

										commitStylesFn();

										onFinish();
									} else {
										started := Some(df);

										if (direction == FAnimationAlternate() || direction == FAnimationAlternateReverse()) {
											reversed := !^reversed;
										}
									}
								}
							}
						});

					\ -> {
						^disp();
						disp := nop;
					}
				}
			);

		addClipAnimationDisposer =
			if (delay == 0.0) {
				resetStylesFn();
				addClipAnimationFn();
			} else {
				commitInitStylesFn();
				disp = ref nop;
				timerDisp = interruptibleTimer(floor(delay * 1000.0), \ -> if (!^finalized) { resetStylesFn(); disp := addClipAnimationFn(); });

				\ -> {
					timerDisp();
					^disp();
				}
			};

		\ -> {
			commitStylesFn();
			addClipAnimationDisposer();
			animationPercentDisposer();
		}
	} else {
		commitStylesFn();

		nop;
	}
}

fform2s(rform : FForm, level : int) -> string {
	generateSpaces = concatStrings(generate(0, level, \__ -> " "));
	structName = rform.structname + "(";

	switch (rform) {
		FEmpty(): {
			generateSpaces + structName + ")"
		}
		FConstructor(form, construct): {
			generateSpaces + structName + "\n" +
			fform2s(form, level + 1) + "\n" +
			generateSpaces + ")"
		}
		FCreate2(current, fn): {
			generateSpaces + structName + "\n" +
			fform2s(^current, level + 1) + "\n" +
			fform2s(fn(), level + 1) + "\n" +
			generateSpaces + ")"
		}
		FText(text, style): {
			generateSpaces + structName /*+ text*/ + ")"
		}
		FParagraph(text, style): {
			generateSpaces + structName /*+ text*/ + ")"
		}
		FPicture(url_, wh, style): {
			generateSpaces + structName + url_ + ")"
		}
		FGraphics(path, style): {
			generateSpaces + structName + toString(path) + ")"
		}
		FTranslate(x, y, form): {
			generateSpaces + structName + toString(fgetValue(x)) + ", " + toString(fgetValue(y)) + "," + "\n" +
			fform2s(form, level + 1) + "\n" +
			generateSpaces + ")"
		}
		FBorder(left, top, right, bottom, form): {
			generateSpaces + structName + toString(left) + ", " + toString(top) + ", " + toString(right) + ", " + toString(bottom) + "," + "\n" +
			fform2s(form, level + 1) + "\n" +
			generateSpaces + ")"
		}
		FScale(x, y, form): {
			generateSpaces + structName + toString(fgetValue(x)) + ", " + toString(fgetValue(y)) + "," + "\n" +
			fform2s(form, level + 1) + "\n" +
			generateSpaces + ")"
		}
		FRotate(degrees, form): {
			generateSpaces + structName + toString(fgetValue(degrees)) + "," + "\n" +
			fform2s(form, level + 1) + "\n" +
			generateSpaces + ")"
		}
		FOrigin(origin, form): {
			generateSpaces + structName + toString(fgetValue(origin)) + "," + "\n" +
			fform2s(form, level + 1) + "\n" +
			generateSpaces + ")"
		}
		FAlpha(alpha, form): {
			generateSpaces + structName + toString(fgetValue(alpha)) + "," + "\n" +
			fform2s(form, level + 1) + "\n" +
			generateSpaces + ")"
		}
		FVisible(visible, form): {
			generateSpaces + structName + toString(fgetValue(visible)) + "," + "\n" +
			fform2s(form, level + 1) + "\n" +
			generateSpaces + ")"
		}
		FRenderable(renderable, form): {
			generateSpaces + structName + toString(fgetValue(renderable)) + "," + "\n" +
			fform2s(form, level + 1) + "\n" +
			generateSpaces + ")"
		}
		FDynamicGroup2(stackChanges, currentStack, stack) : {
			generateSpaces + structName + "[" + "\n" +
			concatStrings(map(fgetValue(currentStack), \cs -> fform2s(cs, level + 1) + "," + "\n")) +
			generateSpaces + "])"
		}
		FGroup(forms, z) : {
			generateSpaces + structName + "[" + "\n" +
			concatStrings(map(forms, \cs -> fform2s(cs, level + 1) + "," + "\n")) +
			generateSpaces + "])"
		}
		FGroup2(form1, form2, z) : {
			generateSpaces + structName + "[" + "\n" +
			fform2s(form1, level + 1) + "," + "\n" +
			fform2s(form2, level + 1) + "," + "\n" +
			generateSpaces + "])"
		}
		FMutable2(behaviour, stack) : {
			generateSpaces + structName + "\n" +
			fform2s(fgetValue(behaviour), level + 1) + "\n" +
			generateSpaces + ")"
		}
		FDecorator2(form, decorators, above, stack) : {
			generateSpaces + structName + "\n" +
			fform2s(form, level + 1) + "," + "\n" +
			concatStrings(map(decorators, \d -> fform2s(d.second(), level + 1) + "," + "\n")) +
			generateSpaces + ")"
		}
		FFullWindow(fullscreen, wh, form) : {
			generateSpaces + structName + "\n" +
			fform2s(form, level + 1) + "\n" +
			generateSpaces + ")"
		}
		FFullScreen2(fullscreen, wh, form, __) : {
			generateSpaces + structName + "\n" +
			fform2s(form, level + 1) + "\n" +
			generateSpaces + ")"
		}
		FInteractive(listeners, form) : {
			generateSpaces + structName + "\n" +
			fform2s(form, level + 1) + "\n" +
			generateSpaces + ")"
		}
		FMask2(form, mask, stack): {
			generateSpaces + structName + "[" + "\n" +
			fform2s(form, level + 1) + "," + "\n" +
			fform2s(mask, level + 1) + "," + "\n" +
			generateSpaces + "])"
		}
		FFilter2(filters, form, stack) : {
			generateSpaces + structName + "\n" +
			fform2s(form, level + 1) + "\n" +
			generateSpaces + ")"
		}
		FCursor(shape, form) : {
			generateSpaces + structName + toString(shape) + "," + "\n" +
			fform2s(form, level + 1) + "\n" +
			generateSpaces + ")"
		}
		FInspect(inspectors, form): {
			generateSpaces + structName + "\n" +
			fform2s(form, level + 1) + "\n" +
			generateSpaces + ")"
		}
		FCrop2(left, top, cwidth, cheight, enabled, form, stack): {
			generateSpaces + structName + toString(fgetValue(left)) + ", " + toString(fgetValue(top)) + ", " +
				toString(fgetValue(cwidth)) + ", " + toString(fgetValue(cheight)) + "," + "\n" + toString(fgetValue(enabled)) + "," + "\n" +
			fform2s(form, level + 1) + "\n" +
			generateSpaces + ")"
		}
		FControlFocus(focus, form): {
			generateSpaces + structName + toString(fgetValue(focus)) + "," + "\n" +
			fform2s(form, level + 1) + "\n" +
			generateSpaces + ")"
		}
		FMForm(form): {
			generateSpaces + structName + ")"
		}
		FBaseline(__, form): fform2s(form, level);
		FSize2(__, form): fform2s(form, level);
		FAvailable2(__, form): fform2s(form, level);
		FAccess(properties, form): {
			generateSpaces + structName + "\n" +
			fform2s(form, level + 1) + "\n" +
			generateSpaces + ")"
		}
		FRealHTML(url, wh, style): {
			generateSpaces + structName + stringEncodeFix(url) + ")"
		}
		FVideo(filename, wh, style): {
			generateSpaces + structName + stringEncodeFix(filename) + ")"
		}
		FTextInput(content, wh, style): {
			generateSpaces + structName + stringEncodeFix(getValue(content)) + ")"
		}
		FSetPending(pen, form): fform2s(form, level);
		FNativeForm(__, __, ff, __): {
			generateSpaces + structName + "\n" +
			fform2s(ff(), level + 1) + "\n" +
			generateSpaces + ")"
		}
		FCanvas(content): {
			generateSpaces + structName + "\n" +
			fform2s(content, level + 1) + "\n" +
			generateSpaces + ")"
		}
		FAnimation(content, __, __): {
			generateSpaces + structName + "\n" +
			fform2s(content, level + 1) + "\n" +
			generateSpaces + ")"
		}
	}
}

extractFAccessProperties(style : [flow]) -> [FAccessProperty] {
	fold(style, [], \acc : [FAccessProperty], el : flow -> {
		switch (el) {
			FAccessProperty(): arrayPush(acc, el);
			default: acc;
		}
	})
}

addFAccessProperties(properties : [FAccessProperty], zorder : Transform<[int]>) -> (native) -> () -> void {
	\clip -> {
		accessVisible = extractStruct(properties, FAccessVisible(const(true))).visible;
		accessCallback = ref None();

		fold(
			properties,
			Pair(
				makeTree(),
				[]
			),
			\acc : Pair<Tree<string, () -> string>, [() -> () -> void]>, p -> {
				switch (p : FAccessProperty) {
					AccessRole(r): {
						Pair(
							setTree(acc.first, "role", \ -> r),
							acc.second
						);
					}
					AccessDescription(ds): {
						Pair(
							setTree(acc.first, "description", \ -> ds),
							acc.second
						);
					}
					FAccessTabOrder(ti): {
						uns = makeSubscribe2(ti, \i -> setAccessAttributes(clip, [["nodeindex", strGlue(map(i, i2s), " ")]]));

						Pair(
							setTree(acc.first, "nodeindex", \ -> strGlue(map(fgetValue(ti), i2s), " ")),
							arrayPush(acc.second, uns)
						)
					}
					AccessKbdShortcutString(s) : {
						uns = \ -> addKeyboardShortcut(s, extractStruct(properties, AccessDescription("")).description);

						Pair(
							acc.first,
							arrayPush(acc.second, uns)
						)
					}
					FAccessAttribute(name, val): {
						uns = makeSubscribe2(val, \v -> setAccessAttributes(clip, [[name, v]]));

						Pair(
							setTree(acc.first, name, \ -> fgetValue(val)),
							arrayPush(acc.second, uns)
						)
					}
					FAccessStyle(name, val): {
						uns = makeSubscribe(val, \v -> setClipStyle(clip, name, v));

						Pair(
							acc.first,
							arrayPush(acc.second, uns)
						)
					}
					AccessSelectable(): {
						Pair(
							setTree(acc.first, "selectable", \ -> "true"),
							acc.second
						)
					}
					AccessCallback(cb): {
						accessCallback := Some(cb);

						Pair(
							acc.first,
							arrayPush(acc.second, \ -> \ -> {
								setAccessCallback(clip, nop);
								accessCallback := None()
							})
						)
					}
					AccessChildSelected(acsFn): {
						uns = \ -> addExtendedEventListener(clip, "childfocused", \args : [flow]-> {
							a0 = flow2d(args[0]);
							a1 = flow2d(args[1]);
							a2 = flow2d(args[2]);
							a3 = flow2d(args[3]);
							acsFn(Point(a0, a1), WidthHeight(a2, a3))
						});

						Pair(
							acc.first,
							arrayPush(acc.second, uns)
						)
					}
					AccessFocused(focused) : {
						focusGate = make(true);

						switchFocus = \focus -> {
							nextDistinct(focusGate, false);
							nextDistinct(focused, focus);
							nextDistinct(focusGate, true);
						};

						uns =
							[
								\ -> addEventListener(clip, "focusin", \ -> switchFocus(true)),
								\ -> addEventListener(clip, "focusout", \ -> switchFocus(false)),
								makeSubscribe2(focused, \v -> if (getValue(focusGate)) setFocus(clip, v))
							];

						Pair(
							acc.first,
							concat(acc.second, uns)
						)
					}
					FAccessEnabled(en): {
						uns = makeSubscribe2(en, \e -> setAccessAttributes(clip, [["enabled", b2s(e)]]));

						Pair(
							setTree(acc.first, "enabled", \ -> b2s(fgetValue(en))),
							arrayPush(acc.second, uns)
						)
					}
					FAccessTabindex(ti) : {
						uns = makeSubscribe2(ti, \t -> setAccessAttributes(clip, [["tabindex", i2s(t)]]));

						Pair(
							setTree(acc.first, "tabindex", \ -> i2s(fgetValue(ti))),
							arrayPush(acc.second, uns)
						)
					}
					AccessState(state): {
						uns = makeSubscribe2(state, \v -> setAccessAttributes(clip, [["aria-checked", v]]));

						Pair(
							setTree(acc.first, "aria-checked", \ -> getValue(state)),
							arrayPush(acc.second, uns)
						)
					}
					FAccessZorder(zo): {
						uns = makeSubscribe2(zo, \z -> setAccessAttributes(clip, [["zorder", i2s(z)]]));

						Pair(
							setTree(acc.first, "zorder", \ -> i2s(fgetValue(zo))),
							arrayPush(acc.second, uns)
						)
					}
					FAccessVisible(__): {
						acc;
					}
					TagName(tagName): {
						setClipTagName(clip, tagName);

						Pair(
							setTree(acc.first, "keepableTagName", \ -> tagName),
							acc.second
						);
					}
					ClassName(className): {
						setClipClassName(clip, className);

						acc;
					}
					LangAttribute(languageCode): {
						uns = makeSubscribe2(languageCode, \code -> setAccessAttributes(clip, [["lang", code]]));

						Pair(
							setTree(acc.first, "lang", \ -> fgetValue(languageCode)),
							arrayPush(acc.second, uns)
						)
					}
					FAccessProtected() : {
						setClipProtected(clip);

						acc;
					}
					FAccessHidden(): {
						Pair(
							setTree(acc.first, "aria-hidden", \ -> "true"),
							acc.second
						)
					}
					AccessForceMakeClip(__) : {
						acc;
					}
				}
			}
		)
		|> (\attributes : Pair<Tree<string, () -> string>, [() -> () -> void]> -> {
			uns =
				makeSubscribeUns(accessVisible, \av ->
					if (!av) {
						removeAccessAttributes(clip);
						[]
					} else {
						disp = map(attributes.second, apply0);
						setAccessAttributes(clip, map(tree2pairs(attributes.first), \p : Pair<string, () -> string> -> [p.first, p.second()]));
						maybeApply(^accessCallback, \cb -> setAccessCallback(clip, cb));
						disp;
					}
				)();

			\ -> {
				uns();
				removeAccessAttributes(clip);
			}
		});
	}
}
