import fform/optimizefform;
import fform/fformutils;
import form/renderform;
import formats/svg/svg;

export {
	frender : (form : FForm, awh : DynamicBehaviour<WidthHeight>) -> () -> void;
	// In JS - looks for html element and renders form inside it
	// The same as frender for other targets
	frenderTo(form : FForm, awh : DynamicBehaviour<WidthHeight>, rootId : string) -> () -> void;
	frenderStage : (form : FForm, awh : DynamicBehaviour<WidthHeight>) -> () -> void;
	renderFForm(rform : FForm, zorder : Transform<[int]>) -> FRenderResult;
	attachFChildren(clip : native, children : [native], disposers : [() -> void], cap : [FClipCapability]) -> FRenderResult;

	// Override to set custom stage wh
	stageWidthHeight : DynamicBehaviour<Maybe<WidthHeight>> = make(None());
	fAccessibilityEnabled = ref false;
	fSvg2GraphicsEnabled = ref !js;
	isFullScreenActive = make(false);
	fullScreenNoReattachmentsModeZorder = make(-1);
}

currentFFormCount = ref 0;

frenderToClip(parent : native, form : FForm, awh : DynamicBehaviour<WidthHeight>, rootId : string) -> () -> void {
	renCt = ^globalRenderCount;
	globalRenderCount := ^globalRenderCount + 1;

	d1 = monitorFResize(awh, rootId);
	d2 = optimizeAndRenderFForm(parent, form, const([renCt]));

	\ -> {d1(); applyall(d2.disposers); if (renCt == ^globalRenderCount - 1) globalRenderCount := renCt}
}

frenderStage(form : FForm, awh : DynamicBehaviour<WidthHeight>) -> () -> void {
	if (^globalRenderCount == 0)
		println("Warning: Don't use overlay stage render as first layer render.");

	frenderToClip(currentClip(), form, awh, "");
}

frenderTo(form : FForm, awh : DynamicBehaviour<WidthHeight>, rootId : string) -> () -> void {
	if (rootId != "") {
		if (js) setRenderRoot(rootId)
		else println("Warning: no setRenderRoot implementation for this target");
	}
	frenderToClip(mainRenderClip(), form, awh, rootId);
}

frender(form : FForm, awh : DynamicBehaviour<WidthHeight>) -> () -> void {
	frenderToClip(mainRenderClip(), form, awh, "");
}

monitorFResize(awh : DynamicBehaviour<WidthHeight>, rootId : string) -> () -> void {
	enableResize();
	sendStageSize = \ -> {
		nextDistinct(awh, WidthHeight(getStageWidthOf(rootId), getStageHeightOf(rootId)));
	}

	// We have to explicitly hold on to this function to keep it alive
	r = ref Some(sendStageSize);

	disposer =
		makeSubscribeUns(stageWidthHeight, \swh : Maybe<WidthHeight> ->
			eitherFn(
				swh,
				\wh : WidthHeight -> {
					nextDistinct(awh, wh);

					[]
				},
				\ -> {
					sendStageSize();

					[addEventListener(currentClip(), "resize", sendStageSize)]
				}
			)
		)();

	\ -> { r := Some(nop); disposer(); }
}

optimizeAndRenderFForm(parent : native, form : FForm, zorder : Transform<[int]>) -> FRenderResult {
	renderFForm(optimizeFForm(form), zorder)
	|> (\r  -> attachFChildren(parent, r.clips, r.disposers, r.capabilities))
}

optimizeAndRenderFFormAt(parent : native, form : FForm, zorder : Transform<[int]>, id : int) -> FRenderResult {
	renderFForm(optimizeFForm(form), zorder)
	|> (\r  -> attachFChildrenAt(parent, r.clips, r.disposers, r.capabilities, id))
}

attachFChildren(clip : native, children : [native], disposers : [() -> void], cap : [FClipCapability]) -> FRenderResult {
	alive = generate(0, length(children), \__ -> ref false);
	iteri(children, \i, c -> addChildClip(clip, c, alive[i]));

	FRenderResult(
		[clip],
		concat([\ -> iteri(children, \i, c -> removeChildClip(clip, c, alive[i]))], disposers),
		cap
	)
}

attachFChildrenAt(clip : native, children : [native], disposers : [() -> void], cap : [FClipCapability], id : int) -> FRenderResult {
	alive = generate(0, length(children), \__ -> ref false);
	iteri(children, \i, c -> addChildClipAt(clip, c, id + i, alive[i]));

	FRenderResult(
		[clip],
		concat([\ -> iteri(children, \i, c -> removeChildClip(clip, c, alive[i]))], disposers),
		cap
	)
}

attachFChildAndCapability(form : FForm, d : FRenderResult, cap : [FClipCapability], fn : (native) -> () -> void) -> FRenderResult {
	if (length(d.clips) > 0) {
		if (length(d.clips) == 1 && !exists(d.capabilities, \c -> contains(cap, c))) {
			FRenderResult(d.clips, concat(map(d.clips, fn), d.disposers), uniq(concat(d.capabilities, cap)));
		} else {
			c = makeClip();
			setClipDebugInfo(c, "form", form);

			attachFChildren(c, d.clips, concat(d.disposers, [fn(c), \ -> deleteNative(c)]), cap)
		}
	} else {
		FRenderResult(d.clips, d.disposers, [])
	}
}

fullScreenTarget : ref Maybe<native> = ref None();

setFullScreenTargetFlow(clip : native) -> void {
	fullScreenTarget := Some(clip);
	nextDistinct(isFullScreenActive, true);
	setFullScreenTarget(clip);
}

isFullScreenTarget(clip : native) -> bool {
	eitherFn(^fullScreenTarget, \ft -> ft == clip, \ -> { setFullScreenTargetFlow(clip); true; });
};

removeFullScreenTarget(clip : native) -> void {
	if (isSome(^fullScreenTarget)) {
		if (isFullScreenTarget(clip)) {
			fullScreenTarget := None();
		}
	}
	resetFullScreenTarget();
	nextDistinct(isFullScreenActive, false);
}

renderFForm(rform : FForm, zorder : Transform<[int]>) -> FRenderResult {
	// println(rform.structname);
	// currentFFormCount := ^currentFFormCount + 1;

	switch (rform) {
		FEmpty(): {
			emptyFRenderResult
		}
		FConstructor(form, construct): {
			uns = construct();
			d = renderFForm(form, zorder);

			FRenderResult(d.clips, arrayPush(d.disposers, uns), d.capabilities)
		}
		FCreate2(current, fn): {
			current := fn();
			d = renderFForm(optimizeFForm(^current), zorder);

			FRenderResult(d.clips, d.disposers, d.capabilities)
		}
		FText(text, style): {
			if (!js && extractStruct(style, EscapeHTML(false)).escape) {
				renderFText(fselect(text, escapeHtml |> FLift), style);
			} else if (js && getRendererType() != "html" && !extractStruct(style, EscapeHTML(false)).escape) {
				charStyle = style2characterStyle(style);
				renderFText(fselect(text, FLift(\t -> fold(html2text(t, charStyle), "", \acc, tt -> acc + tt.text))), style);
			} else {
				renderFText(text, style);
			}
		}
		FParagraph(text, style): {
			if (!js && extractStruct(style, EscapeHTML(false)).escape) {
				renderFParagraph(fselect(text, escapeHtml |> FLift), style);
			} else if (js && getRendererType() != "html" && !extractStruct(style, EscapeHTML(false)).escape) {
				charStyle = style2characterStyle(style);
				renderFParagraph(fselect(text, FLift(\t -> fold(html2text(t, charStyle), "", \acc, tt -> acc + tt.text))), style);
			} else {
				renderFParagraph(text, style);
			}
		}
		FPicture(url2, wh, style2): {
			f = FPictureApplyJwtExtraction(rform);

			if (downloadPictures) {
				cache = ref true;
				onlydl = ref false;
				picErrorHandler = ref nop1;
				onWarning = ref nop1;
				onLoaded = ref nop;
				realSizeFn = ref nop1;
				picAltText = ref "";
				headers =  ref [];

				decreaseFFilesCount = increaseFFilesCount();
				// Seems, we need no this transformation there
				// url = if (contains(f.style, SharedUrl())) f.url else applyMediaPathMapping(f.url);
				clipalive = ref true;

				iter(f.style, \s ->
					switch (s : PictureStyle) {
						DontCache(): cache := false;
						OnlyDownloadToCache(): onlydl := true;
						OnLoadingError(fn): picErrorHandler := fn;
						OnWarning(fn): onWarning := fn;
						OnLoaded(fn): {
							onLoaded := {
								prevOnLoaded = ^onLoaded;
								\ -> {
									prevOnLoaded();
									fn();
								}
							}
						}
						InspectRealSize(fn): realSizeFn := fn;
						AltText(text): picAltText := text;
						UseCrossOrigin(__) : {}
						ReferrerPolicy(__) : {}
						RequestHeaders(hs) :headers := concat(^headers, hs);
						SharedUrl(): {}
					}
				);

				picture =
					if (endsWith(f.url, ".svg") && ^fSvg2GraphicsEnabled) {
						container = makeClip();

						httpRequest(
							addServerPathIfRelative(f.url),
							false,
							^headers,
							[],
							\d -> {
								if (^clipalive) {
									form = svgString2Form(d, []);
									formWH = getStaticFormSize(form) |> (\fm -> WidthHeight(fm.width, fm.height));

									iter(renderFForm(form |> form2fform |> optimizeFForm, zorder).clips, \c -> addChild(container, c));

									setCachedPictureSize(f.url, formWH);
									nextDistinct(wh, formWH);

									decreaseFFilesCount();

									^realSizeFn(formWH);
									^onLoaded();
								} else {
									decreaseFFilesCount();
								}
							},
							\er -> {
								if (^clipalive) {
									if (startsWith(er, "Warning")) {
										^onWarning(er);
									} else {
										e = "Cannot load " + f.url + " " + er;

										removeCachedPictureSize(f.url);
										nextDistinct(wh, zeroWH);

										^picErrorHandler(e);
										decreaseFFilesCount();
									}
								} else {
									removeCachedPictureSize(f.url);
									decreaseFFilesCount();
								}
							},
							\s -> {}
						);

						container;
					} else {
						makePicture(
							addServerPathIfRelative(f.url),
							^cache,
							\w, h -> {
								setCachedPictureSize(f.url, WidthHeight(w, h));
								nextDistinct(wh, WidthHeight(w, h));

								decreaseFFilesCount();

								^realSizeFn(WidthHeight(w, h));
								^onLoaded();
							},
							\e -> {
								if (startsWith(e, "Warning")) {
									^onWarning(e);
								} else {
									removeCachedPictureSize(f.url);
									nextDistinct(wh, zeroWH);

									^picErrorHandler(e);
									decreaseFFilesCount();
								}
							},
							^onlydl,
							^picAltText,
							map(^headers, \h -> [h.key, h.value])
						);
					}

				setPictureUseCrossOrigin(picture, extractStruct(f.style, UseCrossOrigin(false)).useCrossOrigin);
				setPictureReferrerPolicy(picture, extractStruct(f.style, ReferrerPolicy("")).referrerpolicy);

				FRenderResult(
					[picture],
					[
						\ -> {
							clipalive := false;
							//Decrease loading files count if Form is closed until onOK or onError has happened.
							decreaseFFilesCount();
							deleteNative(picture);
						}
					],
					[FClipMask()]
				)
			} else
				emptyFRenderResult
		}
		FGraphics(path, style): {
			renderFGraphics(path, style);
		}
		FTranslate(x, y, form): {
			attachFChildAndCapability(
				rform,
				renderFForm(form, zorder),
				[FClipMove(), FClipAnimation(), FClipInteractive()],
				\clip ->
					[
						makeSubscribe(x, \x0 -> setClipX(clip, x0))(),
						makeSubscribe(y, \y0 -> setClipY(clip, y0))()
					]
					|> (\f -> \ -> applyall(f))
			)
		}
		FBorder(left, top, right, bottom, form): {
			attachFChildAndCapability(
				rform,
				renderFForm(form, zorder),
				[FClipMove(), FClipAnimation(), FClipInteractive()],
				\clip -> {
					if (left != 0.0)
						setClipX(clip, left);

					if (top != 0.0)
						setClipY(clip, top);

					nop
				}
			)
		}
		FScale(x, y, form): {
			attachFChildAndCapability(
				rform,
				renderFForm(form, zorder),
				[FClipScale(), FClipRotate(), FClipAnimation()],
				\clip ->
					[
						makeSubscribe(x, \x0 -> setClipScaleX(clip, x0))(),
						makeSubscribe(y, \y0 -> setClipScaleY(clip, y0))()
					]
					|> (\f -> \ -> applyall(f))
			)
		}
		FRotate(degrees, form): {
			attachFChildAndCapability(
				rform,
				renderFForm(form, zorder),
				[FClipScale(), FClipMove(), FClipRotate(), FClipAnimation()],
				\clip ->
					makeSubscribe(degrees, \de -> setClipRotation(clip, de))()
			)
		}
		FOrigin(origin, form): {
			attachFChildAndCapability(
				rform,
				renderFForm(form, zorder),
				[FClipOrigin()],
				\clip ->
					makeSubscribe(origin, \orig -> setClipOrigin(clip, orig.x, orig.y))()
			)
		}
		FAlpha(alpha, form): {
			attachFChildAndCapability(
				rform,
				renderFForm(form, zorder),
				[FClipAlpha()],
				\clip ->
					makeSubscribe(alpha, \a -> setClipAlpha(clip, a))()
			)
		}
		FVisible(visible, form): {
			attachFChildAndCapability(
				rform,
				renderFForm(form, zorder),
				[FClipVisible()],
				\clip ->
					makeSubscribe(visible, \v -> setClipVisible(clip, v))()
			)
		}
		FRenderable(renderable, form): {
			attachFChildAndCapability(
				rform,
				renderFForm(form, zorder),
				[],
				\clip -> {
					nextDistinct(renderable, getClipRenderable(clip));
					addEventListener(clip, "visible", \ -> nextDistinct(renderable, getClipRenderable(clip)));
				}
			)
		}
		FDynamicGroup2(stackChanges, currentStack, stack) : {
			parentClip = makeClip();

			setClipCallstack(parentClip, stack);
			setClipDebugInfo(parentClip, "form", rform);

			childDisposers : ref [[() -> void]] = ref [[]];
			childrenClips : ref [[Pair<native, ref bool>]] = ref [[]];
			childrenCount : ref [int] = ref [];

			handleAdd = \form, z -> {
				childResult = renderFForm(form, farrayPush(zorder, const(z)));
				childClip = map(childResult.clips, \c -> Pair(c, ref false));
				clipsBefore = foldi(^childrenClips, 0, \i, acc, c -> {
					if (i < z) {
						acc + length(c)
					} else {
						acc
					}
				});
				iteri(childClip, \i, d -> addChildClipAt(parentClip, d.first, clipsBefore + i, d.second));

				childrenClips := insertArray(^childrenClips, z, childClip);
				childDisposers := insertArray(^childDisposers, z, childResult.disposers);
			};

			handleDelete = \z -> if (existsIndex(^childrenClips, z)) {
				iter(^childrenClips[z], \clip -> removeChildClip(parentClip, clip.first, clip.second));
				childrenClips := removeIndex(^childrenClips, z);

				applyall(^childDisposers[z]);
				childDisposers := removeIndex(^childDisposers, z);
			}

			handleReplace = \form, z -> {
				childrenAfter = tailFrom(^childrenClips, z);

				iter(childrenAfter, \children ->
					iter(children, \child -> removeChildClip(parentClip, child.first, child.second))
				);

				applyall(^childDisposers[z]);

				childResult = renderFForm(form, farrayPush(zorder, const(z)));
				childClip = map(childResult.clips, \c -> Pair(c, ref false));

				iter(
					replace(childrenAfter, 0, childClip),
					\childClips ->
						iter(childClips, \clip -> addChildClip(parentClip, clip.first, clip.second))
				);

				childrenClips := replace(^childrenClips, z, childClip);
				childDisposers := replace(^childDisposers, z, childResult.disposers);
			}

			handleMove = \from, to -> {
				childrenFixedOrder = moveElement(^childrenClips, from, to);
				childrenChanged = tailFrom(childrenFixedOrder, min(from, to));

				iter(childrenChanged, \children ->
					iter(children, \child -> removeChildClip(parentClip, child.first, child.second))
				);

				iter(
					childrenChanged,
					\childClips ->
						iter(childClips, \clip -> addChildClip(parentClip, clip.first, clip.second))
				);

				childrenClips := childrenFixedOrder;
				childDisposers := moveElement(^childDisposers, from, to);
			}

			iteri(getValue(currentStack), \i, f -> handleAdd(f, i));

			handleChanges = \changes -> if (length(changes) > 0) {
				next(stackChanges, []);

				iter(changes, \change -> {
					switch (change : FGroupChange) {
						FGroupAdd(form, z) : {
							next(currentStack, insertArray(getValue(currentStack), z, form));
							handleAdd(form, z);
						}
						FGroupDelete(z) : {
							next(currentStack, removeIndex(getValue(currentStack), z));
							handleDelete(z);
						}
						FGroupMove(from, to) : {
							currentStackValue = getValue(currentStack);
							toFixed = forceRange(to, 0, length(currentStackValue) - 1);

							if (existsIndex(currentStackValue, from) && from != toFixed) {
								next(
									currentStack,
									moveElement(currentStackValue, from, toFixed)
								);

								handleMove(from, toFixed);
							}
						}
						FGroupReplace(form, z) : {
							next(currentStack, replace(getValue(currentStack), z, form));
							handleReplace(form, z);
						}
					}
				});
			}

			disposeChanges = fsubscribe(stackChanges, handleChanges);

			disposeGroup =
				\ -> {
					callList(disposeChanges);

					iter(^childrenClips, \childClips -> iter(childClips, \clip -> removeChildClip(parentClip, clip.first, clip.second)));
					childrenClips := [];

					iter(^childDisposers, applyall);
					childDisposers := [];

					deleteNative(parentClip);
				};

			FRenderResult([parentClip], [disposeGroup], []);
		}
		FGroup(forms, z) : {
			results : [FRenderResult] = mapi(forms, \i, form -> renderFForm(form, if (z || ^accessibilityEnabled || ^fAccessibilityEnabled) farrayPush(zorder, const(i)) else zorder));
			clips = concatA(map(results, \r -> r.clips));
			disposers = concatA(map(results, \r -> r.disposers));
			capabilities = concatA(map(results, \r -> if (length(r.clips) > 0) [r.capabilities] else []));

			FRenderResult(clips, disposers, if (length(clips) == 1 && length(capabilities) > 0) capabilities[0] else [])
		}
		FGroup2(form1, form2, z) : {
			r1 = renderFForm(form1, if (z || ^accessibilityEnabled || ^fAccessibilityEnabled) farrayPush(zorder, const(0)) else zorder);
			r2 = renderFForm(form2, if (z || ^accessibilityEnabled || ^fAccessibilityEnabled) farrayPush(zorder, const(1)) else zorder);

			FRenderResult(
				concat(r1.clips, r2.clips),
				concat(r1.disposers, r2.disposers),
				if (length(r1.clips) == 1 && length(r2.clips) == 0)
					r1.capabilities
				else if (length(r1.clips) == 0 && length(r2.clips) == 1)
					r2.capabilities
				else
					[]
			)
		}
		FDecorator2(form, decorators, above, stack) : {
			clip = makeClip();
			setClipCallstack(clip, stack);
			setClipDebugInfo(clip, "form", rform);

			clips : ref [[Pair<native, ref bool>]] = ref generate(0, length(decorators), \__ -> []);

			d1 = renderFForm(
					optimizeFForm(form),
					if (^accessibilityEnabled || ^fAccessibilityEnabled)
						farrayPush(zorder, const(b2i(!above)))
					else
						zorder
				);

			d2 = map(d1.clips, \d -> {addChild(clip, d); \ -> removeChild(clip, d)});

			d3 = mapi(decorators, \i, d -> {
				uns = ref [];

				makeSubscribe(d.first, \en -> {
					iter(^clips[i], \c -> removeChildClip(clip, c.first, c.second));
					clips := replace(^clips, i, []);
					applyall(^uns);

					uns :=
						if (en) {
							r = renderFForm(
								optimizeFForm(d.second()),
								if (^accessibilityEnabled || ^fAccessibilityEnabled)
									farrayPush(zorder, const(b2i(above)))
								else
									zorder,
							);

							clipsBefore = length(concatA(subrange(^clips, 0, i)));
							childClip = map(r.clips, \c -> Pair(c, ref false));
							iteri(childClip, \j, c -> addChildClipAt(clip, c.first, clipsBefore + j + if (above) length(d1.clips) else 0, c.second));
							clips := replace(^clips, i, childClip);

							r.disposers
						} else {
							[]
						}
				})()
				|> (\f -> \ -> {f(); applyall(^uns);})
			});

			FRenderResult([clip], concatA([d2, d1.disposers, d3, [\ -> deleteNative(clip)]]), [])
		}
		FMutable2(behaviour, stack) : {
			old = ref [];
			nested = ref 0;

			clip = makeClip();
			setClipCallstack(clip, stack);
			setClipDebugInfo(clip, "form", rform);

			dodisplay = \form -> {
				// Block post-destroy calls
				if (^nested == 0) {
					nested := 1;
					applyall(^old);
					old := optimizeAndRenderFForm(clip, form, zorder).disposers;

					if (showRedraw) {
						gr = getGraphics(clip);
						setLineStyle(gr, 1.0, floor(random() * i2d(0xffffff)), 1.0);
						moveTo(gr, 0.0, 0.0);
						lineTo(gr, 100., 100.);
						endFill(gr);
					}

					// If re-entrant destroy pending, finish it
					if (^nested < 0) {
						applyall(^old);
						old := [];

						deleteNative(clip);
					} else {
						nested := 0;
					}
				}
			};

			updateFn = \form -> {
				// Postpone re-entrant updates if necessary
				if (^nested > 0)
					deferred(\ -> {
						impersonateCallstackItem(stack, 1);
						dodisplay(form);
					})
				else {
					impersonateCallstackItem(stack, 1);
					dodisplay(form);
				}
			}

			unsub =
				if (!isUrlParameterFalse("mutable_fix")) {
					makeSubscribeExt(behaviour, updateFn, false)();
				} else {
					makeSubscribe(behaviour, updateFn)();
				}

			FRenderResult(
				[clip],
				[
					\ -> {
						unsub();

						if (^nested == 0) {
							impersonateCallstackItem(stack, 1);
							applyall(^old);
							old := [];

							deleteNative(clip);
						}

						nested := -1;
					}
				],
				[]
			)
		}
		FFullWindow(fullwindow, wh, form) : {
			resize = ref nop;
			container = makeClip();
			rootId = getRenderRoot();
			listenerUns = initUnsM();
			innerFW = make(false);

			setResize = \fw -> {
				^resize();

				if (fw) {
					nextDistinct(wh, WidthHeight(getStageWidthOf(rootId), getStageHeightOf(rootId)));
					resize := monitorFResize(wh, rootId);
				} else {
					resize := nop;
				}
			};

			setFullWindow = \fw -> {
				setFullWindowTarget(container);
				toggleFullWindow(fw);
				if (fw) {
					setUnsM(listenerUns,
						onFullWindow(\fw2 -> nextDistinct(innerFW, fw2))
					);
				} else {
					dispUnsM(listenerUns);
					resetFullWindowTarget();
				}
			};

			connectUns = fconnect(fullwindow, innerFW);

			if (getValue(fullwindow)) {
				deferred(\ -> {
					setResize(true);
					setFullWindow(true);
				})
			};

			uns = subscribe2(innerFW, \fw -> {
				setResize(fw);
				setFullWindow(fw);
			});

			innerFWDelayed = fuse(fdelay(innerFW, 100));
			wasFWbeforePrint = make(false);
			beforePrintUns = addEventListener(getStage(), "beforeprint", \ ->
				nextDistinct(wasFWbeforePrint, fgetValue(innerFWDelayed.first))
			);
			afterPrintUns = addEventListener(getStage(), "afterprint", \ ->
				if (fgetValue(wasFWbeforePrint)) {
					deferUntilNextFrameRendered(\ -> {
						nextDistinct(innerFW, true);
						nextDistinct(wasFWbeforePrint, false);
					})
				}
			);

			d = renderFForm(form, zorder);

			attachFChildren(
				container,
				d.clips,
				arrayPush(
					d.disposers,
					\ -> {
						beforePrintUns();
						afterPrintUns();
						connectUns();
						uns();
						applyall(innerFWDelayed.second);
						^resize();
						if (getValue(fullwindow)) {
							setFullWindow(false);
						}
						deleteNative(container);
					}
				),
				d.capabilities
			);
		}
		FFullScreen2(fullscreen, wh, form, appendToMainStage): {
			resizeUns = initUnsM();
			listenerUns = initUnsM();

			attachFChildAndCapability(
				rform,
				renderFForm(if (appendToMainStage) FFullWindow(fullscreen, wh, form) else form, zorder),
				[],
				\clip -> {
					changeFullscreen = \fsc -> {
						enableFullscreen = \ -> {
							if (appendToMainStage) {
								toggleFullScreen(fsc);
							} else {
								if (fsc) {
									rootId = getRenderRoot();
									nextDistinct(wh, WidthHeight(getStageWidthOf(rootId), getStageHeightOf(rootId)));
									setUnsM(resizeUns, monitorFResize(wh, rootId));
									requestFullScreen(clip)
								}
								else {
									dispUnsM(resizeUns);
									exitFullScreen(clip);
								}
							}
						}

						if (fsc) {
							openFS = \ -> {
								setFullScreenTargetFlow(clip);
								setUnsM(listenerUns, onFullScreen(\change -> {
									if (!change || isFullScreenTarget(clip)) {
										nextDistinct(fullscreen, change);
										if (!change) dispUnsM(listenerUns);
									}
								}));
								enableFullscreen();
							}

							eitherFn(^fullScreenTarget,
								\fst -> {
									tempListenerUns = initUnsM();
									setUnsM(tempListenerUns, onFullScreen(\fs -> {
										if (!fs) {
											openFS();
											dispUnsM(tempListenerUns);
										}
									}));
									removeFullScreenTarget(fst);
								},
								openFS
							)
						} else {
							removeFullScreenTarget(clip);
							enableFullscreen();
						}
					}

					if (getValue(fullscreen)) {
						if (appendToMainStage) {
							changeFullscreen(true);
						} else {
							timer(200, \ -> changeFullscreen(true));
						}
					}

					cfsd = subscribe2(fullscreen, changeFullscreen);

					\ -> {
						if (getValue(fullscreen)) {
							toggleFullScreen(false);
						}

						dispUnsM(listenerUns);
						cfsd();
					}
				}
			);
		}
		FInteractive(listeners, form) : {
			clipalive = ref true;

			attachFChildAndCapability(
				rform,
				renderFForm(form, zorder),
				[FClipInteractive()],
				\clip -> {
					stage = getStage();
					disposers = map(listeners, \l -> makeSubscribeUns(zorder, \z -> [handleRealEvents(l, clip, clipalive, stage, z, true, false)])());

					\ -> {
						applyall(disposers);
						clipalive := false
					}
				}
			)
		}
		FMask2(form, mask, stack): {
			d1 = renderFForm(form, zorder);
			r1 = attachFChildAndCapability(
				rform,
				d1,
				[FClipMove(), FClipRotate(), FClipScale(), FClipMask()],
				\clip -> {
					setClipCallstack(clip, stack);
					nop;
				}
			);

			d2 = renderFForm(mask, zorder);
			r2 = attachFChildAndCapability(
				rform,
				d2,
				[FClipMove(), FClipRotate(), FClipScale()],
				\maskClip -> {
					if (length(r1.clips) > 0) {
						setClipMask(r1.clips[0], maskClip);
					}

					setClipCallstack(maskClip, stack);
					nop;
				}
			);

			FRenderResult(
				concat(r2.clips, r1.clips),
				concat(r1.disposers, r2.disposers),
				r1.capabilities
			);
		}
		FFilter2(filters, form, stack) : {
			d = renderFForm(form, zorder);

			if (targetNoFilters()) {
				// Not supported
				d
			} else if (getRendererType() == "html") {
				fold(filters, d, \acc, f -> {
					attachFChildAndCapability(
						rform,
						acc,
						[FClipFilters()],
						\clip -> {
							fils = switch(f : Filters) {
								Bevel(params): {
									angle = ref 45.0;
									distance = ref 3.0;
									radius = ref 3.0;
									spread = ref 1.0;
									color1 = ref 0xffffff;
									alpha1 = ref 1.0;
									color2 = ref 0x000000;
									alpha2 = ref 1.0;
									inner = ref true;
									iter(params, \p -> switch (p : BevelParameter) {
										Placement(a, ds): { angle := a; distance := ds; }
										Radius(r): radius := r;
										Spread(s): spread := s;
										Color(c, a): { color1 := c; alpha1 := a; }
										ShadowColor(c, a): { color2 := c; alpha2 := a; }
										Inner(i): inner := i;
									});
									makeBevel(^angle, ^distance, ^radius, ^spread, ^color1, ^alpha1, ^color2, ^alpha2, ^inner) |> Some;
								}
								DropShadow(params): {
									if (!ios() || isUrlParameterTrue("shadow")) {
										angle = ref 45.0;
										distance = ref 4.0;
										radius = ref 4.0;
										spread = ref 1.0;
										color = ref 0x000000;
										alpha = ref 1.0;
										inner = ref false;
										useBoxShadow = ref false;
										iter(params, \p -> switch (p : DropShadowParameter) {
											Placement(a, ds): { angle := a; distance := ds; }
											Radius(r): radius := r;
											Spread(s): spread := s;
											Color(c, a): { color := c; alpha := a; }
											Inner(i): inner := i;
											UseBoxShadow(): useBoxShadow := true;
										});
										ds = makeDropShadow(^angle, ^distance, ^radius, ^spread, ^color, ^alpha, ^inner);
										if (^useBoxShadow) setUseBoxShadow(ds);
										Some(ds);
									} else {
										None();
									}
								}
								Blur(params): {
									radius = ref 3.0;
									spread = ref 1.0;
									iter(params, \p -> switch (p : BlurParameter) {
										Radius(r): radius := r;
										Spread(s): spread := s;
									});
									makeBlur(^radius, ^spread) |> Some;
								}
								BackdropBlur(params): {
									if (js) {
										spread = extractStruct(params, Spread(1.)).radius;
										makeBackdropBlur(spread) |> Some
									} else None()
								}
								Glow(params): {
									radius = ref 4.0;
									spread = ref 1.0;
									color = ref 0x000000;
									alpha = ref 1.0;
									inner = ref false;
									iter(params, \p -> switch (p : GlowParameter) {
										Radius(r): radius := r;
										Spread(s): spread := s;
										Color(c, a): { color := c; alpha := a; }
										Inner(i): inner := i;
									});
									makeGlow(^radius, ^spread, ^color, ^alpha, ^inner) |> Some;
								}
								Shader(vertex, fragment, uniforms) : {
									makeShader(
										strSplitLeave(strReplace(vertex, "\t", ""), "\n"),
										strSplitLeave(strReplace(fragment, "\t", ""), "\n"),
										map(uniforms, \u -> [u.name, u.type, u.value])
									) |> Some;
								}
							};
							eitherMap(fils, \fls -> {
								setClipCallstack(clip, stack);
								addFilters(clip, [fls]);

								\ -> deleteNative(fls)
							}, nop)
						}
					)
				})
			} else {
				attachFChildAndCapability(
					rform,
					d,
					[FClipFilters()],
					\clip -> {
						fils = filtermap(filters, \f -> switch(f : Filters) {
							Bevel(params): {
								angle = ref 45.0;
								distance = ref 3.0;
								radius = ref 3.0;
								spread = ref 1.0;
								color1 = ref 0xffffff;
								alpha1 = ref 1.0;
								color2 = ref 0x000000;
								alpha2 = ref 1.0;
								inner = ref true;
								iter(params, \p -> switch (p : BevelParameter) {
									Placement(a, ds): { angle := a; distance := ds; }
									Radius(r): radius := r;
									Spread(s): spread := s;
									Color(c, a): { color1 := c; alpha1 := a; }
									ShadowColor(c, a): { color2 := c; alpha2 := a; }
									Inner(i): inner := i;
								});
								makeBevel(^angle, ^distance, ^radius, ^spread, ^color1, ^alpha1, ^color2, ^alpha2, ^inner) |> Some;
							}
							DropShadow(params): {
								angle = ref 45.0;
								distance = ref 4.0;
								radius = ref 4.0;
								spread = ref 1.0;
								color = ref 0x000000;
								alpha = ref 1.0;
								inner = ref false;
								useBoxShadow = ref false;
								iter(params, \p -> switch (p : DropShadowParameter) {
									Placement(a, ds): { angle := a; distance := ds; }
									Radius(r): radius := r;
									Spread(s): spread := s;
									Color(c, a): { color := c; alpha := a; }
									Inner(i): inner := i;
									UseBoxShadow(): useBoxShadow := true;
								});
								ds = makeDropShadow(^angle, ^distance, ^radius, ^spread, ^color, ^alpha, ^inner);
								if (^useBoxShadow) setUseBoxShadow(ds);
								Some(ds);
							}
							Blur(params): {
								radius = ref 3.0;
								spread = ref 1.0;
								iter(params, \p -> switch (p : BlurParameter) {
									Radius(r): radius := r;
									Spread(s): spread := s;
								});
								makeBlur(^radius, ^spread) |> Some;
							}
							BackdropBlur(params): None();
							Glow(params): {
								radius = ref 4.0;
								spread = ref 1.0;
								color = ref 0x000000;
								alpha = ref 1.0;
								inner = ref false;
								iter(params, \p -> switch (p : GlowParameter) {
									Radius(r): radius := r;
									Spread(s): spread := s;
									Color(c, a): { color := c; alpha := a; }
									Inner(i): inner := i;
								});
								makeGlow(^radius, ^spread, ^color, ^alpha, ^inner) |> Some;
							}
							Shader(vertex, fragment, uniforms) : {
								makeShader(
									strSplitLeave(strReplace(vertex, "\t", ""), "\n"),
									strSplitLeave(strReplace(fragment, "\t", ""), "\n"),
									map(uniforms, \u -> [u.name, u.type, u.value])
								) |> Some;
							}
						});
						setClipCallstack(clip, stack);
						addFilters(clip, fils);

						\ -> iter(fils, deleteNative)
					}
				)
			}
		}
		FCursor(shape, form) : {
			if (js) {
				attachFChildAndCapability(
					rform,
					renderFForm(form, zorder),
					[FClipCursor()],
					\clip -> {
						switch (shape : CursorShape2) {
							CursorShape(): {
								setClipCursor(clip, getCursorShapeName(shape));
								nop;
							}
							DynamicCursor(shape2): {
								makeSubscribe(shape2, \sh -> setClipCursor(clip, getCursorShapeName(sh)))();
							}
						}
					}
				)
			} else {
				cursorListeners = makeGlobalCursorListeners(shape, zorder);

				d = renderFForm(
					FInteractive(
						cursorListeners.first,
						form
					),
					zorder
				);

				FRenderResult(
					d.clips,
					arrayPush(d.disposers, cursorListeners.second),
					d.capabilities
				)
			}
		}
		FInspect(inspectors, form): {
			d = renderFForm(form, zorder);
			disps : ref [() -> void] = ref [];

			iter(inspectors, \i ->
				switch (i : Inspector) {
					ITransformMatrix(setfn): {
						if (length(d.clips) > 0) {
							// interruptibleDeferUntilNextFrameRendered to have form built and transforms calculated
							refArrayPush(disps, interruptibleDeferUntilNextFrameRendered(\ -> setfn(\ -> getGlobalTransform(d.clips[0]))));
							refArrayPush(disps, \ -> setfn(getDummyTransformMatrix));
						}
					}
					default: {}
				}
			);

			if (length(^disps) > 0)
				FRenderResult(
					d.clips,
					concat(d.disposers, ^disps),
					d.capabilities
				)
			else
				d
		}
		FCrop2(left, top, cwidth, cheight, enabled, form, stack): {
			attachFChildAndCapability(
				rform,
				renderFForm(form, zorder),
				[FClipMove(), FClipRotate(), FClipScale(), FClipMask()],
				\clip -> {
					setClipCallstack(clip, stack);
					uns = [
						if (cpp)
							// Workaround to disable cropping in cpp
							// TODO : implement setCropEnabled on cpp level
							makeSubscribeUns(fstall(enabled, 0), \en ->
								if (en) [
									make4Subscribe(left, top, cwidth, cheight, \l, t, w, h -> setScrollRect(clip, l, t, w, h))()
								] else [
									makeSubscribe(left, \l -> if (l != 0.) setClipX(clip, -l))(),
									makeSubscribe(top, \t -> if (t != 0.) setClipY(clip, -t))(),
									\ -> {
										setClipX(clip, 0.);
										setClipY(clip, 0.);
									}
								]
							)()
						else
							make4Subscribe(left, top, cwidth, cheight, \l, t, w, h -> setScrollRect(clip, l, t, w, h))(),					
						makeSubscribe(enabled, \en -> setCropEnabled(clip, en))()
					];
					\ -> applyall(uns)
				}
			);
		}
		FControlFocus(focus, form): {
			d = renderFForm(form, zorder);

			if (length(d.clips) > 0) {
				uns = makeSubscribe(focus, \fc -> setFocus(d.clips[0], fc))();

				FRenderResult(
					d.clips,
					arrayPush(d.disposers, uns),
					d.capabilities
				);
			} else {
				d;
			}
		}
		FMForm(form): {
			d = renderForm(form, const(zeroWH), fgetValue(zorder), fgetValue(zorder)); // TODO: sub to zorder

			FRenderResult(
				d.clips,
				d.disposers,
				[
					FClipMove(),
					FClipScale(),
					FClipRotate(),
					FClipAlpha(),
					FClipVisible(),
					FClipInteractive(),
					FClipMask(),
					FClipFilters(),
					FClipAccess(),
					FClipCursor(),
					FClipOrigin(),
					FClipAnimation()
				]
			)
		}
		FBaseline(__, form): renderFForm(form, zorder);
		FSize2(__, form): renderFForm(form, zorder);
		FAvailable2(__, form): renderFForm(form, zorder);
		FAccess(properties, form): {
			if (^accessibilityEnabled || ^fAccessibilityEnabled ||
				(js && (extractStruct(properties, ClassName("")).className != "" || extractStruct(properties, TagName("")).tagName != ""))) {
				d = renderFForm(form, zorder);

				role = extractStruct(properties, AccessRole("")).role;
				tagName = extractStruct(properties, TagName("")).tagName;

				defMakeAccessClip =
					(
						!contains(["button", "checkbox", "textbox", "video", "iframe"], role) &&
						!contains(["button", "textarea", "input", "video", "iframe", "span"], tagName) &&
						!(role == "presentation" && tagName == "p")
					)
					|| isSome(tryExtractStruct(properties, AccessChildSelected(nop2)));

				makeAccessClip = extractStruct(properties, AccessForceMakeClip(defMakeAccessClip)).makeClip;

				if (makeAccessClip) {
					attachFChildAndCapability(
						rform,
						attachFChildAndCapability(
							rform,
							d,
							[FClipAccess()],
							\__ -> nop
						),
						[FClipAccess()],
						addFAccessProperties(properties, zorder)
					);
				} else {
					attachFChildAndCapability(
						rform,
						d,
						[FClipAccess()],
						addFAccessProperties(properties, zorder)
					);
				}
			} else {
				renderFForm(form, zorder);
			}
		}
		FRealHTML(url, wh, style): {
			zoom_enabled = ref const(false);
			mouse_disabled = ref const(false);
			sandbox = ref None();

			domain = extractStruct(style, OverridePageDomain("")).domain;
			updateCachedContent = extractStruct(style, UpdateCachedContent(true)).update;
			reloadBlock = extractStruct(style, ReloadBlock(false)).show;

			flowCallback = extractStruct(style, FlowCallback(\args : [string] -> { "" })).fn;
			onPageLoaded = extractStruct(style, OnPageLoaded(nop)).fn;
			onError = extractStruct(style, OnError(nop1)).fn;
			onDone = \s -> if (s == "OK") onPageLoaded() else onError(s);
			shrink2fit = containsStruct(style, RealHtmlShrink2Fit());

			clip = makeWebClip(url, domain, updateCachedContent, reloadBlock, flowCallback, onDone, shrink2fit);

			disp =
				fold(
					style,
					arrayPush(
						[makeSubscribe(wh, \whv ->  { setClipWidth(clip, whv.width); setClipHeight(clip, whv.height); })()],
						addFAccessProperties(extractFAccessProperties(style), zorder)(clip)
					),
					\acc, st ->
						switch (st : FRealHTMLStyle) {
							PageHostcallSetter(fn): {
								fn(\name, args -> webClipHostCall(clip, name, args));
								acc;
							}
							PageEvalJS(fn): {
								fn(\code, cb -> webClipEvalJS(clip, code, cb));
								acc;
							}
							ZoomEnabled(enabled): {
								arrayPush(acc, makeSubscribe(enabled, \en -> setWebClipZoomable(clip, en))())
							}
							MouseDisabled(disabled): {
								arrayPush(acc, makeSubscribe(disabled, \dis -> setWebClipDisabled(clip, dis))())
							}
							SandBoxJS(sboxes) : {
								setWebClipSandBox(
									clip,
									strGlue(
										map(sboxes, \sb ->
											switch (sb : SandBoxJSStyle) {
												AllowSameOrigin()		: "allow-same-origin";
												AllowTopNavigation()	: "allow-top-navigation";
												AllowForms()	: "allow-forms";
												AllowScripts()	: "allow-scripts";
											}
										),
										" "
									)
								);

								acc;
							}
							WhitelistDomains(domains): {
								setWebClipDomains(clip, domains);

								acc;
							}
							ViewBounds(bounds): {
								arrayPush(acc, makeSubscribe(bounds, \b -> if (isCorrectBounds(b)) setClipViewBounds(clip, b.minX, b.minY, b.maxX, b.maxY))())
							}
							NoScroll(): {
								setWebClipNoScroll(clip);
								acc;
							}
							PassEvents(): {
								setWebClipPassEvents(clip);
								acc;
							}
							default: acc;
						}
				)
				|> (\disp -> arrayPush(disp, \ -> deleteNative(clip)))
				|> (\disp ->
					if (^accessibilityEnabled || ^fAccessibilityEnabled) {
						arrayPush(
							disp,
							makeSubscribe(felementAt(zorder, const(0), const(0)), \z -> setAccessAttributes(clip, [["zorder", toString(z)]]))()
						);
					} else {
						disp;
					}
				);

			FRenderResult(
				[clip],
				disp,
				[FClipInteractive(), FClipFilters(), FClipMask(), FClipAccess()]
			);
		}
		FVideo(url2, wh, style2): {
			//f = FVideoApplyJwtExtraction(rform);
			// Seems, we need no this transformation there
			// url = if (contains(style2, SharedUrl())) url2 else applyMediaPathMapping(f.url);
			url = url2;//f.url;
			style = style2;//f.style;
			streamListenerResponse = ref false;
			realVideoSize = extractStruct(style, FVideoRealSize(make(getValue(wh)))).size;
			inspectVideoArea = tryExtractStruct(style, FInspectVideoArea(make(FVideoAreaMetrics(zeroPoint, WidthHeight(0., 0.), Factor(0., 0.)))));

			playing = extractStruct(style, FVideoPlay(make(true))).play;
			position = extractStruct(style, FVideoPosition(make(0.))).position;
			errorHandlerFn = extractStruct(style, OnVideoLoadingError(nop)).fn;
			streamListenerFn = extractStruct(style, StreamStatus(nop1)).fn;
			synchroCalls = extractStruct(style, SynchroCalls(nop, nop));
			videoPlayStatus = extractStruct(style, FVideoPlayStatus(make(false)));
			keepAspectRation = extractStruct(style, FVideoKeepAspectRatio(const(true))).keep;
			coverBox = extractStruct(style, FVideoCoverBox(const(false), []));
			coverBoxAlign = extractStruct(coverBox.style, FAlign(const(0.5), const(0.5)));
			duration = extractStruct(style, FVideoLength(make(1.))).length;

			volume = tryExtractStruct(style, FVideoVolume(make(1.)));
			fullscreen = tryExtractStruct(style, FVideoFullscreen(make(false)));
			controls = extractStruct(style, FVideoControls([])).controls;
			subtitles = tryExtractStruct(style, FVideoSubtitles(const(VideoSubtitle("", []))));
			subtitlesAlignBottom = contains(style, FVideoSubtitlesAlignBottom());
			subtitlesBottomBorder = extractStruct(style, FVideoSubtitlesBottomBorder(-1.)).border;
			subtitlesScaleMode = tryExtractStruct(style, FVideoSubtitlesScaleMode(-1., -1.));
			externalSubtitles = tryExtractStruct(style, FVideoExternalSubtitles("", "", const(true)));
			looping = tryExtractStruct(style, FVideoLoop(const(false)));
			timeRange = tryExtractStruct(style, FVideoTimeRange(const(0.), const(0.)));
			playbackRate = tryExtractStruct(style, FVideoPlaybackRate(make(0.)));
			mediaStream = tryExtractStruct(style, MediaStream(makeClip(), nop2, nop));
			viewBounds = tryExtractStruct(style, ViewBounds(const(zeroBounds)));
			getCurrentFrame = tryExtractStruct(style, FVideoGetCurrentFrame(ref \ -> ""));
			additionalSources = extractStruct(style, FVideoAdditionalSources([])).sources;
			headers = map(extractStruct(style, RequestHeaders([])).headers, \header -> [header.key, header.value]);

			video =
				makeVideo(
					\w, h -> {
						if (w > 0. && h > 0.) {
							nextDistinct(realVideoSize, WidthHeight(w, h));
						}
						if (getValue(wh).width == 0. && getValue(wh).height == 0.) {
							nextDistinct(wh, WidthHeight(w, h));
						}
					},
					\p -> {
						streamListenerResponse := true;
						nextDistinct(playing, p);
						if (!p)
							next(videoPlayStatus.playing, p);
						streamListenerResponse := false;
					},
					\len -> {
						nextDistinct(duration, len);
					},
					\pos -> {
						streamListenerResponse := true;
						nextDistinct(position, pos);
						streamListenerResponse := false;
					}
				);
			iter(additionalSources, \s -> addVideoSource(video, s.url, s.type, headers));
			esUns = initUnsM();
			maybeApply(externalSubtitles, \es -> {
				setUnsM(esUns, makeSubscribeUns(es.enabled, \en -> if (en) [setVideoExternalSubtitle(video, es.src, es.kind)] else [])());
			});

			if (contains(style, FAudio())) setVideoIsAudio(video);

			eitherFn(mediaStream,
				\ms -> playVideoFromMediaStream(video, ms.stream, !getValue(playing)),
				\ -> playVideo(video, addServerPathIfRelative(url), !getValue(playing), headers)
			);

			if (controls != []) setVideoControls(video, controls);

			maybeApply(getCurrentFrame, \gcf -> gcf.fn := \ -> getVideoCurrentFrame(video));

			disp = concatA([
				[
					make5Subscribe(
						fpair(realVideoSize, wh), keepAspectRation, coverBox.cover, coverBoxAlign.x, coverBoxAlign.y,
						\pr, kar, cover, alX, alY -> {

						rwh = firstOfPair(pr);
						cwh = secondOfPair(pr);

						if (rwh.width > 0. && cwh.width > 0. && rwh.height > 0. && cwh.height > 0.) {
							xScale = cwh.width / rwh.width;
							yScale = cwh.height / rwh.height;

							setClipMetrics = \xSc, ySc, clX, clY -> {
								setClipScaleX(video, xSc);
								setClipScaleY(video, ySc);
								setClipX(video, clX);
								setClipY(video, clY);
								maybeApply(inspectVideoArea, \iva ->
									nextDistinct(iva.metrics, FVideoAreaMetrics(
										Point(clX, clY),
										WidthHeight(rwh.width * xSc, rwh.height * ySc),
										Factor(xSc, ySc)
									))
								)
							}

							if (cover) {
								xyScale = max(xScale, yScale);
								clipX = (cwh.width - rwh.width * xyScale) * forceRange(alX, 0., 1.);
								clipY = (cwh.height - rwh.height * xyScale) * forceRange(alY, 0., 1.);
								setClipMetrics(xyScale, xyScale, clipX, clipY)
							} else if (kar) {
								xyScale = min(xScale, yScale);
								clipX = max(cwh.width - rwh.width * xyScale, 0.) / 2.;
								clipY = max(cwh.height - rwh.height * xyScale, 0.) / 2.;
								setClipMetrics(xyScale, xyScale, clipX, clipY)
							} else {
								setClipMetrics(xScale, yScale, 0., 0.)
							}
						}
					})(),
				],
				if (targetVideoLooping())
					eitherMap(
						looping,
						\lp ->
							[
								makeSubscribe(lp.loop, \l -> setVideoLooping(video, l))()
							],
						[]
					)
				else
					[],
				eitherMap(
					volume,
					\vol ->
						[
							makeSubscribe(vol.volume, \v -> setVideoVolume(video, v))()
						],
					[]
				),
				eitherMap(
					timeRange,
					\tr ->
						[
							make2Subscribe(tr.start, tr.end, \s, e -> setVideoTimeRange(video, s, e))()
						],
					[]
				),
				if (!android())
					eitherMap(
						playbackRate,
						\pr ->
							[
								makeSubscribe(pr.rate, \rate -> setVideoPlaybackRate(video, rate))()
							],
						[]
					)
				else
					[],
				eitherMap(
					fullscreen,
					\fs -> {
						resize = ref nop;
						prevWH = ref getValue(wh);
						rootId = getRenderRoot();

						[
							onFullScreen(\v -> if (isFullScreenTarget(video) || !v) nextDistinct(fs.fullscreen, v)),
							makeSubscribe(fs.fullscreen, \v -> {
								setFullWindowTarget(video);

								^resize();

								if (v) {
									setFullScreenTargetFlow(video);
									prevWH := getValue(wh);
									nextDistinct(wh, WidthHeight(getStageWidthOf(rootId), getStageHeightOf(rootId)));
									resize := monitorFResize(wh, rootId);
								} else {
									removeFullScreenTarget(video);
									nextDistinct(wh, ^prevWH);
								}

								toggleFullScreen(v);
								toggleFullWindow(v);
							})(),
							resetFullWindowTarget,
							\ -> ^resize()
						]
					},
					[]
				),
				eitherMap(
					subtitles,
					\sbt ->
						[
							makeSubscribe(sbt.subtitles, \s -> {
								definedTextStyle = getDefinedTextStyle(s.style);
								setVideoSubtitle(
									video,
									s.text,
									definedTextStyle.face.family,
									definedTextStyle.fontSize,
									definedTextStyle.face.weight,
									definedTextStyle.face.slope,
									definedTextStyle.fillColor,
									definedTextStyle.fillOpacity,
									definedTextStyle.letterSpacing,
									definedTextStyle.backgroundColor,
									definedTextStyle.backgroundOpacity,
									subtitlesAlignBottom,
									subtitlesBottomBorder,
									isSome(subtitlesScaleMode),
									eitherMap(subtitlesScaleMode, \sc -> sc.min, -1.),
									eitherMap(subtitlesScaleMode, \sc -> sc.max, -1.),
									extractStruct(s.style, EscapeHTML(true)).escape
								);
							})()
						],
					[]
				),
				eitherMap(
					viewBounds,
					\vb ->
						[
							makeSubscribe(vb.bounds, \b -> setClipViewBounds(video, b.minX, b.minY, b.maxX, b.maxY))()
						],
					[]
				),
				[
					\ -> dispUnsM(esUns),
					\ -> closeVideo(video),
					\ -> deleteNative(video),
				]
			]);

			dispR = ref [];
			streamListener = addStreamStatusListener(video, \code -> {
				if (code == "NetStream.Play.StreamNotFound") {
					errorHandlerFn();
					synchroCalls.onStart();
					timer(1000, synchroCalls.onStop);
				} else if (code == "NetStream.Play.Start") {
					synchroCalls.onStart();
				} else if (code == "NetStream.Play.Stop") {
					synchroCalls.onStop();
				} else if (code == "FlowGL.User.Resume") {
					if (!getValue(playing)) {
						synchroCalls.onStart();
					}
				} else if (code == "FlowGL.User.Stop") {
					synchroCalls.onStop();
				} else if (code == "FlowGL.User.Playing") {
					next(videoPlayStatus.playing, true)
				} else if (code == "FlowGL.User.Waiting") {
					next(videoPlayStatus.playing, false)
				}

				if (^dispR == []) {
					dispR := [
						makeSubscribe(playing, \pl -> if (!^streamListenerResponse) {
							if (pl) {
								resumeVideo(video);
							} else {
								pauseVideo(video);

								next(videoPlayStatus.playing, false);
							}
						})(),
						makeSubscribe(position, \pos -> if (!^streamListenerResponse) seekVideo(video, pos))()
					];
				}

				streamListenerFn(code);
			});

			FRenderResult(
				[video],
				[\-> applyall(concat3(^dispR, [streamListener], disp))],
				[FClipInteractive(), FClipFilters(), FClipMask()]
			);
		}
		FTextInput(content, wh, style): {
			textInputResponse = ref false;
			constCharacterStyle = style2characterStyle(style);
			characterStyle = fconcat(extractStruct(style, FCharacterStyle(const([]))).style, const(constCharacterStyle));
			textfield = makeTextfield(getMappedFontFace(fgetValue(characterStyle)));
			rtl = extractStruct(style, SetRTL(getDefaultRtl())).rtl;
			setTextDirection(textfield, if (rtl) "rtl" else "ltr");
			setPreventContextMenu(textfield, contains(style, FPreventContextMenu()));
			setTextInput(textfield);

			focus = extractStruct(style, FFocus(make(false))).focus;
			position = extractStruct(style, FPosition(make(0))).position;
			selection = extractStruct(style, FSelection(make(-1))).selection;
			positionSelection = extractStruct(style, FPositionSelection(make(PositionSelection(0, -1)))).positionSelection;
			onSelection = tryExtractStruct(style, FInputOnSelect(nop2));
			onSelectAll = tryExtractStruct(style, FInputOnSelectAll(nop));
			scrollInfo = extractStruct(style, FScrollInfo(make(ScrollInfo(0, 0, 0)))).info;

			inputType = extractStruct(style, FInputType(const(TextType()))).type;
			autoCompleteType = tryExtractStruct(style, FAutoCompleteType(const(ACNewPassword())));
			autoAlign = extractStruct(style, FAutoAlign(const(AutoAlignNone()))).align;
			wordWrap = extractStruct(style, FWordWrap(const(true))).wrap;
			multiline = extractStruct(style, FMultiline(const(false))).multiline;
			readOnly = extractStruct(style, FReadOnly(const(false))).readOnly;
			maxChars = extractStruct(style, FMaxChars(const(-1))).maxChars;
			autofillBackgroundFill = tryExtractStruct(style, AutofillBackgroundFill(0));
			autofillBackgroundOpacity = tryExtractStruct(style, AutofillBackgroundOpacity(1.0));
			numericStep = tryExtractStruct(style, FNumericStep(const(1.)));
			filterFn = tryExtractStruct(style, FInputFilter(idfn));
			eventFilterFn = tryExtractStruct(style, dummyFInputEventFilter);
			onCopyFn = tryExtractStruct(style, FInputOnCopy(\ -> None()));
			onCompositionEndFn = tryExtractStruct(style, FInputOnCompositionEnd(nop));
			openDatePickerMB = tryExtractStruct(style, FOpenDatePicker(make(None())));
			enablePreventXSSDef = isUrlParameterTrue("new") && !isUrlParameterFalse("input_xss_protection_enabled");
			enablePreventXSS = extractStruct(style, FPreventFromXSS(enablePreventXSSDef)).enable;

			keyFilterFn = tryExtractStruct(style, FInputKeyFilter(\__, __ -> true));
			cursorColor = extractStruct(style, FCursorColor(fselect(characterStyle, FLift(\cs -> extractStruct(cs, Fill(0)).color)))).color;
			cursorOpacity = extractStruct(style, FCursorOpacity(fselect(characterStyle, FLift(\cs -> extractStruct(cs, FillOpacity(1.)).opacity)))).opacity;
			cursorWidth = tryExtractStruct(style, FCursorWidth(const(2.)));
			viewBounds = tryExtractStruct(style, ViewBounds(const(zeroBounds)));
			interlineSpacing = extractStruct(style, InterlineSpacing(0.0)).d;

			setTextFieldInterlineSpacing(textfield, interlineSpacing);
			// changing multiline leads to recreating on native element so we have to set is first
			setMultiline(textfield, fgetValue(multiline));
			defineTextStyle(textfield, getValue(content), fgetValue(characterStyle));
			maybeApply(autofillBackgroundFill, \afbf -> setAutofillBackgroundColor(textfield, afbf.color));
			maybeApply(autofillBackgroundOpacity, \afbo -> setAutofillBackgroundOpacity(textfield, afbo.opacity));
			setTextFieldPreventXSS(textfield, enablePreventXSS);

			disp =
				concatA([
					[
						makeSubscribe(content, \c ->
							if (!^textInputResponse) defineTextStyle(textfield, c, fgetValue(characterStyle))
						)(),
						makeSubscribe(characterStyle, \cs ->
							defineTextStyle(textfield, getValue(content), cs)
						)(),
						makeSubscribe(wh, \v -> /*if (!^textInputResponse)*/ {
							setTextFieldWidth(textfield, v.width);
							setTextFieldHeight(textfield, v.height);
						})(),
						if (mobile) subscribe(focus, \f ->
							if (!^textInputResponse) setFocus(textfield, f)
						) else makeSubscribe(focus, \f ->
							if (!^textInputResponse) setFocus(textfield, f)
						)(),
						make2Subscribe(position, selection, \p, s -> if (!^textInputResponse) {
							if (cpp && getValue(focus)) {
								setFocus(textfield, false);
								setSelection(textfield, p, s);
								setFocus(textfield, true);
							} else {
								setSelection(textfield, p, s);
							}
							textInputResponse := true;
							nextDistinct(positionSelection, PositionSelection(p, s));
							textInputResponse := false;
						})(),
						makeSubscribe(positionSelection, \ps -> if (!^textInputResponse) {
							setSelection(textfield, ps.position, ps.selection);
							textInputResponse := true;
							nextDistinct(position, ps.position);
							nextDistinct(selection, ps.selection);
							textInputResponse := false;
						})(),
						makeSubscribe(inputType, \t -> {
							type =
								switch (t : InputType) {
									EmailType(): "email";
									TelType(): "tel";
									UrlType(): "url";
									TextType(): "text";
									NumericType(): "number";
									SearchType(): "search";
									PasswordType(): "password";
									DateType(__, __): "date";
								};
							setTextInputType(textfield, type);
							if (type == "date") {
								switch(t : InputType) {
									DateType(minDate, maxDate): {
										maybeApply(minDate, \dt -> {
											setAccessAttributes(textfield, [["min", date2string(dt)]]);
										})
										maybeApply(maxDate, \dt -> {
											setAccessAttributes(textfield, [["max", date2string(dt)]]);
										})
										maybeApply(openDatePickerMB, \openDatePickerB ->	{
												nextDistinct(openDatePickerB.fn, Some(openDatePicker(textfield)));
											}
										)
									};
									default : {}
								}
							}
						})(),
						makeSubscribe(autoAlign, \aa -> setAutoAlign(textfield,
							switch (aa : AutoAlignType) {
								AutoAlignLeft(): "AutoAlignLeft";
								AutoAlignRight(): "AutoAlignRight";
								AutoAlignCenter(): "AutoAlignCenter";
								AutoAlignNone(): "AutoAlignNone";
							}
						))(),
						makeSubscribe(wordWrap, \ww -> {
							setTextFieldCropWords(textfield, ww && fgetValue(multiline));
							setWordWrap(textfield, ww);
						})(),
						makeSubscribe(multiline, \ml -> {
							setTextFieldCropWords(textfield, ml && fgetValue(wordWrap));
							setMultiline(textfield, ml);
						})(),
						makeSubscribe(readOnly, \ro -> setReadOnly(textfield, ro))(),
						makeSubscribe(maxChars, \mc -> setMaxChars(textfield, mc))(),
						addEventListener(textfield, "change", \ -> {
							textInputResponse := true;
							nextDistinct(content, getContent(textfield));
							pos = getCursorPosition(textfield);
							sel = getSelectionEnd(textfield);
							nextDistinct(position, pos);
							nextDistinct(selection, sel);
							nextDistinct(positionSelection, PositionSelection(pos, sel));
							nextDistinct(focus, getFocus(textfield));
							textInputResponse := false;
						}),
						addEventListener(textfield, "scroll", \ ->
							nextDistinct(scrollInfo, ScrollInfo(
								getScrollV(textfield),
								getBottomScrollV(textfield),
								getNumLines(textfield)
							))
						),
						addEventListener(textfield, "focusin", \ -> {
							textInputResponse := true;
							nextDistinct(focus, true);
							textInputResponse := false;
						}),
						addEventListener(textfield, "focusout", \ -> {
							textInputResponse := true;
							nextDistinct(focus, false);
							textInputResponse := false;
						}),
						make2Subscribe(cursorColor, cursorOpacity, \c, o -> setTextFieldCursorColor(textfield, c, o))(),
						addFAccessProperties(style |> extractFAccessProperties, zorder)(textfield)
					],
					eitherMap(
						autoCompleteType,
						\ac ->
							[
								makeSubscribe(ac.type, \c ->
									setTextInputAutoCompleteType(
										textfield,
										switch (c : ACType) {
											ACUserName(): "username";
											ACNewPassword(): "new-password";
											ACCurrentPassword(): "current-password";
											ACOneTimeCode(): "one-time-code";
										}
									)
								)()
							],
						[]
					),
					eitherMap(
						numericStep,
						\step ->
							[makeSubscribe(step.step, \st -> setTextInputStep(textfield, st))()],
						[]
					),
					eitherMap(
						filterFn,
						\fn ->
							[addTextInputFilter(textfield, fn.fn)],
						[]
					),
					eitherMap(
						eventFilterFn,
						\fn ->
							[addTextInputEventFilter(textfield, fn.fn)],
						[]
					),
					eitherMap(
						keyFilterFn,
						\fn ->
							[
								addTextInputKeyEventFilter(textfield, "keydown", \utf, ctrl, shift, alt, meta, keycode ->
									fn.fn("keydown", KeyEvent(utf, ctrl, shift, alt, meta, keycode, nop))),
								addTextInputKeyEventFilter(textfield, "keyup", \utf, ctrl, shift, alt, meta, keycode ->
									fn.fn("keyup", KeyEvent(utf, ctrl, shift, alt, meta, keycode, nop)))
							],
						[]
					),
					eitherMap(
						onCopyFn,
						\fn ->
							[addTextInputOnCopyEvent(textfield, \setClipboardFn -> maybeApply(fn.fn(), setClipboardFn))],
						[]
					),
					eitherMap(
						cursorWidth,
						\cw ->
							[makeSubscribe(cw.width, \w -> setTextFieldCursorWidth(textfield, w))()],
						[]
					),
					eitherMap(
						viewBounds,
						\vb ->
							[
								makeSubscribe(vb.bounds, \b -> if (isCorrectBounds(b)) setClipViewBounds(textfield, b.minX, b.minY, b.maxX, b.maxY))()
							],
						[]
					),
					eitherMap(
						onSelection,
						\onSelect ->
							[
								addEventListener(textfield, "selectionchange", \ -> {
									onSelect.fn(getCursorPosition(textfield), getSelectionEnd(textfield))
								})
							],
						[]
					),
					eitherMap(
						onSelectAll,
						\onSelect ->
							[
								addEventListener(textfield, "selectall", \ -> {
									onSelect.fn()
								})
							],
						[]
					),
					eitherMap(
						onCompositionEndFn,
						\onCompositionEnd ->
							[
								addEventListener(textfield, "compositionend", \ -> onCompositionEnd.fn())
							],
						[]
					)
				]);

			FRenderResult(
				[textfield],
				disp,
				[FClipInteractive(), FClipFilters(), FClipMask(), FClipCursor()]
			);
		}
		FSetPending(pen, form): renderFForm(form, zorder);
		FNativeForm(__, __, __, fn): {
			d = fn(const(zeroWH), fgetValue(zorder), fgetValue(zorder)); // TODO: sub to zorder

			FRenderResult(
				d.clips,
				[d.dispose],
				[
					FClipMove(),
					FClipScale(),
					FClipRotate(),
					FClipAlpha(),
					FClipVisible(),
					FClipInteractive(),
					FClipMask(),
					FClipFilters(),
					FClipAccess(),
					FClipCursor(),
					FClipOrigin(),
					FClipAnimation()
				]
			)
		}
		FCanvas(content): {
			clip = makeCanvasClip();
			d = renderFForm(content, zorder);

			attachFChildren(
				clip,
				d.clips,
				d.disposers,
				[
					FClipMove(),
					FClipScale(),
					FClipRotate(),
					FClipAlpha(),
					FClipVisible(),
					FClipInteractive(),
					FClipMask(),
					FClipFilters(),
					FClipAccess(),
					FClipCursor(),
					FClipOrigin(),
					FClipAnimation()
				]
			)
		}
		FAnimation(form, keyframes, style): {
			attachFChildAndCapability(
				rform,
				renderFForm(form, zorder),
				[FClipAnimation()],
				\clip ->
					[
						renderFAnimation(clip, keyframes, style),
						addFAccessProperties(style |> extractFAccessProperties, zorder)(clip)
					]
					|> (\f -> \ -> applyall(f))
			)
		}
	}
}

increaseFFilesCount() -> () -> void {
	alreadyDecreased = ref false;

	next(loadingContentFilesCount, getValue(loadingContentFilesCount) + 1);
	\ -> if (!^alreadyDecreased) {
		alreadyDecreased := true;
		next(loadingContentFilesCount, getValue(loadingContentFilesCount) - 1);
	}
}
