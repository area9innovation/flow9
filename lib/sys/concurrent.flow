import ds/array;
import algorithms;

export {
	//
	// Concurrency for C++ runner natives
	//

	// Load and JIT a bytecode file
	native loadBytecode : io (file : string) -> native  = Native.loadBytecode;

	// Launch loaded bytecode in a parallel thread with the specified url and parameters.
	// The loaded code object can be reused for more runBytecode calls.
	// Specified callbacks are invoked on completion and via child's notifyParentRunner.
	native runBytecode : io (code : native, url : string, onDone : (code : int, output : string) -> void, 
			onMessage : (id : string, msg : string) -> void) -> native = Native.runBytecode;

	// Send an asynchronous message to the child thread started with runBytecode.
	// Both id and message are simply passed on to the callback.
	native notifyChildRunner : io (thread : native, id : string, message : string) -> void = Native.notifyChildRunner;

	// Send an asynchronous message to the parent thread; invokes the onMessage callback of runBytecode.
	native notifyParentRunner : io (id : string, message : string) -> void = Native.notifyParentRunner;

	// Register a callback for messages sent via parent's notifyChildRunner.
	native registerParentRunnerCallback : io (onMessage : (id : string, msg : string) -> void) -> void = Native.registerParentRunnerCallback;

	//
	// Concurrency for Java
	//

	// Runs a number of functions potentially in parallel. The fine flag
	// indicates if the functions are finegrained.
	// The result may be in a different order than tasks.
	native concurrent : (fine : bool, tasks : [() -> ?]) -> [?] = Native.concurrent;

	// Implementation with using concurrentAsyncCallback: a new task is started just as some previous has finished.
	concurrent2 : (fine : bool, tasks : [() -> ?]) -> [?];

	// Returns the value of a given ref while atomically adding to it. It is guaranteed
	// that the operation is atomic even with different concurrent tasks sharing the reference
	native atomicRefIntAddition : (v : ref int, delta : int) -> int = Native.atomicRefIntAddition;

	// Runs asynchronous task in a new thread passing it's ID as an argument as well as a callback
	// to return a result in the end. Will call onDone when task is finished and send result to the main thread.
	native concurrentAsyncCallback : (task : (threadId : string, callback : (?) -> void) -> void, onDone : (?) -> void) -> void = Native.concurrentAsyncCallback;

	native getThreadId : () -> string = Native.getThreadId;

	// Wrapper around ConcurrentHashMap - Java implementation of a thread safe map
	native initConcurrentHashMap : () -> native = Native.initConcurrentHashMap;
	native setConcurrentHashMap : (m : native, key : ?, value : ??) -> void = Native.setConcurrentHashMap;
	native getConcurrentHashMap : (m : native, key : ?, defval : ??) -> ?? = Native.getConcurrentHashMap;
	native containsConcurrentHashMap : (m : native, key : ?) -> bool = Native.containsConcurrentHashMap;
	native valuesConcurrentHashMap : (m : native) -> [??] = Native.valuesConcurrentHashMap;
	native removeConcurrentHashMap : (m : native, key : ?) -> void = Native.removeConcurrentHashMap;

	// Change number of available threads in the thead pool. Make sure to call it before thread pool is used
	native setThreadPoolSize : (threads : int) -> void = Native.setThreadPoolSize;

	// Returns number of CPUs on the machine
	native availableProcessors : () -> int = Native.availableProcessors;

	// Calls Thread.sleep(ms) in java backend
	native threadSleep : (ms : int) -> void = Native.threadSleep;

	// Also see bellow: concurrentAsyncOne

	//
	// Concurrency for JS
	//

	// Async version of concurrent. Native version returns immediately,
	// callback called after all tasks finished.
	concurrentAsync : (fine : bool, tasks : [() -> ?], callback : ([?]) -> void) -> void;
	// Also works in Java
	concurrentAsyncOne : (fine : bool, task : () -> ?, callback : (?) -> void) -> void;


	// An implementation of the concurrent interface that is guaranteed to be
	// sequential (of some ordering of tasks).
	notConcurrent : (fine : bool, tasks : [() -> ?]) -> [?];

	sequential : (fine : bool, tasks : [() -> ?]) -> [?];
}

// C++ runner native stubs

loadBytecode(file : string) -> native {
	flow([]);
}



runBytecode(code : native, url : string, onDone : (code : int, output : string) -> void, onMessage : (id : string, msg : string) -> void) -> native {
	deferred(\ -> onDone(-1, "NOT IMPLEMENTED"));
	flow([]);
}
notifyChildRunner(thread, id, message) {}
notifyParentRunner(id, message) {}
registerParentRunnerCallback(onMessage) {}

// For Haskell and Java backends
concurrent(fine : bool, tasks : [()->?])->[?] {
	sequential(fine, tasks)
}

atomicRefIntAddition(v : ref int, delta : int) -> int {
	result = ^v;
	v := result + delta;
	result
}

notConcurrent(fine, tasks)
	map(shuffleArray(tasks), \task -> task());

sequential(fine, tasks) {
	map(tasks, \task -> task());
}

native concurrentAsync : (fine : bool, tasks : [() -> ?], callback : ([?]) -> void) -> void = Native.concurrentAsync;
native concurrentAsyncOne : (fine : bool, task : () -> ?, callback : (?) -> void) -> void = Native.concurrentAsyncOne;


// Stub for async version of concurrent.
// Actually waits for all tasks to complete.
concurrentAsync(fine : bool, tasks : [() -> ?], callback : ([?]) -> void) {
	callback(notConcurrent(fine, tasks));
}

concurrentAsyncOne(fine : bool, task : () -> ?, callback : (?) -> void) {
	callback(task());
}

getThreadId() -> string {
	""
}

// CAUTION: the fallback doens't actually makes a thread sleep
threadSleep(ms : int) -> void {
}

// Fallbacks for concurrent hash map

initConcurrentHashMap() -> native {
	flow(ref makeTree())
}

setConcurrentHashMap(m : native, key : ?, value : ??) -> void {
	t = cast(flow(m) : flow -> ref Tree<?, ??>);
	t := setTree(^t, key, value);
}

getConcurrentHashMap(m : native, key : ?, defval : ??) -> ?? {
	t = cast(flow(m) : flow -> ref Tree<?, ??>);
	lookupTreeDef(^t, key, defval);
}

containsConcurrentHashMap(m : native, key : ?) -> bool {
	t = cast(flow(m) : flow -> ref Tree<?, ??>);
	containsKeyTree(^t, key);
}

valuesConcurrentHashMap(m : native) -> [??] {
	t = cast(flow(m) : flow -> ref Tree<?, ??>);
	getTreeValues(^t);
}

removeConcurrentHashMap(m : native, key : ?) -> void {
	t = cast(flow(m) : flow -> ref Tree<?, ??>);
	t := removeFromTree(^t, key);
}

concurrent2(fine : bool, tasks: [() -> ?]) -> [?] {
	if (length(tasks) == 0) [] else
	if (length(tasks) == 1) [tasks[0]()] else 
	if (length(tasks) <= availableProcessors()) concurrent(fine, tasks) else {
		status = initConcurrentHashMap();
		results = initConcurrentHashMap();
		iteri(tasks, \i, task -> setConcurrentHashMap(status, i, ConcurTaskStatus(i, task)));
		doConcurrent2(length(tasks), status, ref 0, ref 0, results);
		getTreeValues(fold(valuesConcurrentHashMap(results), makeTree(), \acc, res -> setTree(acc, res.ind, res.data)));
	}
}

ConcurTaskStatus(
	ind : int,
	task : () -> ?
);

ConcurTaskResult(
	ind : int,
	data : ?
);

doConcurrent2(ntasks : int, status : native, started : ref int, finished : ref int, results : native) -> void {
	if (^finished < ntasks) {
		free_cpus = availableProcessors() - (^started - ^finished);
		if (free_cpus > 0) {
			ready = take(valuesConcurrentHashMap(status), free_cpus);
			iter(ready, \task_status -> {
				atomicRefIntAddition(started, 1);
				removeConcurrentHashMap(status, task_status.ind);
				concurrentAsyncCallback(
					\__, cb -> cb(task_status.task()),
					\r -> {
						setConcurrentHashMap(results, task_status.ind, ConcurTaskResult(task_status.ind, r));
						atomicRefIntAddition(finished, 1);
						{}
					}
				)
			});
		}
		threadSleep(100);
		doConcurrent2(ntasks, status, started, finished, results);
	}
}
