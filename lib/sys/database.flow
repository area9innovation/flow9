// Â© Copyright 2011 Area9 Technologies.

import runtime;
import string;
import compile_time;

export {
	// Database API

	// If socket is given in Java, then we send that directly to DriverManager.getConnection.
	native connectDb : io (host : string, port : int, socket : string, user : string, password : string, database : string) -> native = Database.connectDb;
	// In case the connection fails, you can get the exception here
	native connectExceptionDb : io (database : native) -> string = Database.connectExceptionDb;

	native closeDb : io (database : native) -> void = Database.closeDb;

	// Return the given string with special characters escaped ready for use in SQL queries. Add " around yourself
	// this function does not protect from tricky sql injections, and OWASP recommends to avoid it
	// consider it deprecated and use requestDbWithQueryParams instead (if implemented)
	native escapeDb : io (database : native, s : string) -> string = Database.escapeDb;

	// prepared-statement-based request with params to safely escape strings and avoid sql injections
	// query is passed with "?" for parameters, n'th param in array is inlined for n'th question sign
	// e.g. requestDbWithQueryParams(conn, "select id from users where email = ? or name = ?", ["email@mail.org", "Oleg"]);
	native requestDbWithQueryParams : io (database : native, query : string, stringParams : [string]) -> native = Database.requestDbWithQueryParams;

	// Do a request to the db. Use requestExceptionDb to check whether the request succeeds
	native requestDb : io (database : native, query : string) -> native = Database.requestDb;
	native requestExceptionDb : io (database : native) -> string = Database.requestExceptionDb;

	// Run multiple queries at once, if database backend supports this.
	// Empty queries are not allowed, if one of queries is "", empty array returned,
	// no queries executed.
	// DML queries are executed, but at their place [] returned.
	// So, ["select * from a", "insert into b", "select * from b"] after processing will return something like
	// [[[DbIntField("fa", 1), ...], ...], [], [[DbIntField("fb", 2)...], ...]]
	//
	// Implemented only in Java backend currently
	//
	// If table is empty return single row of DbNullField (allows to collect columns names)
	//
	// NOTE: in general case there is no guarantee that it will return the same number of results as
	// number of requests we sent. For example CALL of stored procedure with multiple SELECTs inside
	native requestDbMulti : io (database : native, queries : [string]) -> [[[DbField]]] = Database.requestDbMulti;

	native lastInsertIdDb : io (database : native) -> int = Database.lastInsertIdDb;

	// Management of the result sets from queries
	native resultLengthDb : io (result : native) -> int = Database.resultLengthDb;

	// Do we have more results?
	native hasNextResultDb : io (result : native) -> bool = Database.hasNextResultDb;

	// Get all fields and values of the next result as an array
	//
	// If table is empty return single row of DbNullField (allows to collect columns names)
	native nextResultDb : io (result : native) -> [DbField] = Database.nextResultDb;

	DbField ::= DbIntField, DbDoubleField, DbStringField, DbNullField;
		DbIntField(name : string, value : int);
		DbDoubleField(name : string, value : double);
		DbStringField(name : string, value : string);
		// It turns out that the haXe database wrapper can not return null values. These fields are simply absent.
		// If you use getFieldValueDb below, it will work.
		DbNullField(name : string);

	// In the given result, get the value of the named field
	getFieldValueDb(result : [DbField], field : string) -> DbField;

	// formatDb(db, "select * where %d, %s, %f", [1, "Test '\with' escape\"", 3.9])
	formatDb(db : native, sql : string, pars : [flow]) -> string;

	// These ones below: I'm not sure we want to expose these after all

	// Transaction support
	native startTransactionDb : io (database : native) -> void = Database.startTransactionDb;
	native commitDb : io (database : native) -> void = Database.commitDb;
	native rollbackDb : io (database : native) -> void = Database.rollbackDb;
	// Get field #n as int in next result
	native getIntResultDb : io (result : native, n : int) -> int = Database.getIntResultDb;
	// Get field #n as double in next result
	native getFloatResultDb : io (result : native, n : int) -> double = Database.getFloatResultDb;
	// Get field #n as string in next result
	native getResultDb : io (result : native, n : int) -> string = Database.getResultDb;

}

getFieldValueDb(result, field) {
	r = find(result, \r -> r.name == field);
	either(r, DbNullField(field));
}


formatDb(db, sql, pars) {
	i = strIndexOf(sql, "%");
	if (i == -1) {
		sql;
	} else {
		before = strLeft(sql, i);
		format = substring(sql, i + 1, 1);
		after = substring(sql, i + 2, strlen(sql) - i - 2);
		rest = formatDb(db, after, subrange(pars, 1, length(pars) - 1));
		v = pars[0];
		t =  before	+
				if (format == "s") {
					escapeDb(db, v)
				} else if (format == "d") {
					i2s(flow(v))
				} else if (format == "f") {
					d2s(flow(v))
				} else {
					"%" + format
				};
		t + rest;
	}
}

/*
        return s.replace("\\", "\\\\")
                .replace("\b", "\\b")
                .replace("\n", "\\n")
                .replace("\r", "\\r")
                .replace("\t", "\\t")
                .replace("\\x1A", "\\Z")
                .replace("\\x00", "\\0")
                .replace("'", "\\'")
                .replace("\"", "\\\"");
*/

escapeDb(database : native, s : string) -> string {
	concatStrings(map(s2a(s), \c ->
		if (c == compileTime(getCharCodeAt("\\", 0))) {
			"\\\\"
		} else if (c == 8) { // backspace ASCII code is 8
			"\\b"
		} else if (c == compileTime(getCharCodeAt("\n", 0))) {
			"\\n"
		} else if (c == compileTime(getCharCodeAt("\r", 0))) {
			"\\r"
		} else if (c == compileTime(getCharCodeAt("\t", 0))) {
			"\\t"
		} else if (c == compileTime(getCharCodeAt("\x1A", 0))) {
			"\\Z"
		} else if (c == compileTime(getCharCodeAt("\x00", 0))) {
			"\\0"
		} else if (c == compileTime(getCharCodeAt("'", 0))) {
			"\\'"
		} else if (c == compileTime(getCharCodeAt("\"", 0))) {
			"\\\""
		} else {
			fromCharCode(c);
		} 
	));
}

requestDb(database : native, query : string) -> native {
	requestDbWithQueryParams(database, query, []);
}
