import devmode;
import net/http_types;
import formats/json/json;
import net/http;

export {
	// A service worker is a script which your browser runs in the background, separate from a web page, opening the door to features that don't need a web page or user interaction.

	// Browsers support map: http://caniuse.com/#search=service%20worker
	// EXAMPLE: flow/sandbox/serviceworker.flow
	// LIVE EXAMPLE: https://tech.area9innovation.com/sw/flowjs.html?name=test_sw

	// Functionality contained in this file is intended to manipulate implemented Service Worker for controlling FlowJS cache.
	// NOTE: Service Worker influences over all static resources with scope matching to files located lower than flowjs.html.
	// CAUTION: Service Worker keeps running behind the scene, despite of launches.
	// CAUTION: Service Worker runs only for pages served over HTTPS protocol.

	// Service Worker caches each launch request to static resources (all extensions, except .php & .serverbc).
	// Such way helps us to keep actual responses inside cache storage.
	// EXCEPTION: Only one particular php request is cached - it's the request to /php/stamp.php?file=<application>.js.
	// We do this to respond with the latest timestamp for <application>.js file in offline mode.

	// Once static resource request fails (user is offline, etc.) we respond to a client with previously cached resource.

	// Registers the Service Worker for a web page.
	// Once called the Service Worker will be run until disableServiceWorkerCaching called.
	native enableServiceWorkerCaching : io (swFileName : string, callback : (success : bool) -> void) -> void = ProgressiveWebTools.enableServiceWorkerCaching;

	// Unregisters the Service Worker from a web page.
	// Make sure to call after enableServiceWorkerCaching or checkServiceWorkerCachingEnabled callback called with true.
	// Disables Service Worker once any ongoing operation will be finished.
	native disableServiceWorkerCaching : io (callback : (success : bool) -> void) -> void = ProgressiveWebTools.disableServiceWorkerCaching;


	// Check whether we already registered a Service Worker
	native checkServiceWorkerEnabledOnly : io (callback : (enabled : bool) -> void) -> void = ProgressiveWebTools.checkServiceWorkerEnabledOnly;

	// Check whether we already registered a Service Worker and if does not - register new one
	native checkServiceWorkerCachingEnabled : io (swFileName : string, callback : (enabled : bool) -> void) -> void = ProgressiveWebTools.checkServiceWorkerCachingEnabled;

	// Fires when all progressive web app requirements are abided: https, web app manifest, service worker registered
	native addShortcutAvailableListener : io (callback : () -> void) -> (() -> void) = ProgressiveWebTools.addShortcutAvailableListener;

	// Prompts user to install shortcut
	// IMPORTANT: Call it only after shortcut available listener fired
	native installShortcut : io (callback : (bool) -> void) -> void = ProgressiveWebTools.installShortcut;

	// Clean Service Worker cache immediately
	native cleanServiceWorkerCache : io (callback : (success : bool) -> void) -> void = ProgressiveWebTools.cleanServiceWorkerCache;

	// By default cached only static resources.
	// This method allows to add filter to cache dynamic requests.
	// The request will be cached if (concatinated by AND, None() or empty array - means any value):
	// 1. if request Url will be match to the `cacheIfUrlMatchM` string (use absolute path)
	// 2. if request Method equals to `methodM`
	// 3. if request Parameters (for GET or POST method) contains given KeyValue pairs (case insensitive)
	// If you request contains any variable/temporary parameters, which should be skipped (like time stamp) - send them in `ignoreParameterKeysOnCache`
	addRequestCacheFilter(
		cacheIfUrlMatchM : Maybe<string>,
		methodM : Maybe<RequestMethodBase>,
		cacheIfParametersMatchM : [KeyValue],
		ignoreParameterKeysOnCache : [string],
		onOK : () -> void,
		onError : (string) -> void
	) -> void;

	addRequestSkipFilter(
		urlM : Maybe<string>,
		methodM : Maybe<RequestMethodBase>,
		headerMatchM : Maybe<KeyValue>,
		onOK : () -> void,
		onError : (string) -> void
	) -> void;

	// loading and caching data by given urls
	native loadAndCacheUrls : io (
		urls : [string],
		ignoreParameterKeysOnCache : [string],
		onOK : () -> void,
		onError : (string) -> void
	) -> void = ProgressiveWebTools.loadAndCacheUrls;

	// Check and return urls (from the given list) which are presented in the Service Worker cache.
	// Useful for the GET-request urls, where the request parameters are in the url string.
	native checkUrlsInServiceWorkerCache : io (
		urls : [string],
		onOK : ([string]) -> void,
		onError : (string) -> void
	) -> void = ProgressiveWebTools.checkUrlsInServiceWorkerCache;

	// Check whether we run as standalone or fullscreen PWA
	native isRunningPWA : io () -> bool = ProgressiveWebTools.isRunningPWA;

	addShortcutDialog() -> () -> void;
	// By default for ServiceWorker registration will be used `defaultServiceWorkerFilePath` sw file (see path below).
	// But in some cases (for different applications on the same origin) we can't register different sw files with the same name - 
	//  will works only one application. So, by this reason each application may now initialize ServiceWorker with own sw file.
	//  Specific SW file will be create on app genetation and you can send it name in `specificServiceWorkerFileM` parameter.
	// `onUpdateFound` callback is activated if new version of ServiceWorker was loaded and installed in the browser, 
	// but didn't activated (app reload needs). Doesn't supported on IE.
	setServiceWorkerEnabled(specificServiceWorkerFileM : Maybe<string>, enabled : bool, ondone : (success : bool) -> void, onUpdateFound : (string) -> void) -> void;

	native getServiceWorkerJsVersion : io (
		onOK : (int) -> void,
		onError : (string) -> void
	) -> void = ProgressiveWebTools.getServiceWorkerJsVersion;

	native subscribeOnServiceWorkerUpdateFound : io (
		onUpdateFound : () -> void,
		onError : (string) -> void
	) -> void = ProgressiveWebTools.subscribeOnServiceWorkerUpdateFound;

	// The endpoint could be used for transferring data between browser & PWA application
	// Simply POST data with httpRequestCustom to put any data there with RequestPayload
	// Use GET request to the endpoint to get stored data
	// PHP should force to don't use cached shared pwa data on PWA
	PWA_SHARED_DATA_ENDPOINT = "/share/pwa/data.php";

	storeSharedKeyValue(key : string, value : string) -> void;
	takeSharedKeyValue(key : string, callback : (value : string) -> void) -> void;
}

defaultServiceWorkerFilePath = "sw.min.js";
service_worker_version = 6;

enableServiceWorkerCaching(swFileName : string, callback : (bool) -> void) { callback(false) }
disableServiceWorkerCaching(callback : (bool) -> void) { callback(false) }
checkServiceWorkerEnabledOnly(callback : (bool) -> void) { callback(false) }
checkServiceWorkerCachingEnabled(swFileName : string, callback : (bool) -> void) { callback(false) }
cleanServiceWorkerCache(callback : (bool) -> void) { callback(false) }
loadAndCacheUrls(urls : [string], ignoreParameterKeysOnCache : [string], onOK : () -> void, onError : (string) -> void) -> void { onOK(); }
checkUrlsInServiceWorkerCache(urls : [string], onOK : ([string]) -> void, onError : (string) -> void) -> void { onOK([]); };
getServiceWorkerJsVersion(onOK : (int) -> void, onError : (string) -> void) -> void { onOK(0); };
subscribeOnServiceWorkerUpdateFound(onUpdateFound : () -> void, onError : (string) -> void) -> void {};
isRunningPWA() { false }

addShortcutDialog() -> () -> void {
	uns = ref None();

	dispose = \ -> {
		maybeApply(^uns, \u -> { u(); uns := None(); });
	}

	uns :=
		addShortcutAvailableListener(\ -> {
			installShortcut(\accepted -> devtrace("User " + (if (accepted) "accepted" else "dismissed") + " shortcut installation!"));
			deferred(dispose);
		})
		|> Some;

	dispose;
}

setServiceWorkerEnabled(specificServiceWorkerFileM : Maybe<string>, enable : bool, ondone : (success : bool) -> void, onUpdateFound : (string) -> void) -> void {
	doEnable = enable && !isUrlParameterFalse("sw");
	swFileName = either(specificServiceWorkerFileM, defaultServiceWorkerFilePath);
	checkServiceWorkerCachingEnabled(swFileName, \enabled -> {
		onDone2 = \success -> {
			ondone(success);
			if (enable && success) {
				subscribeOnServiceWorkerUpdateFound(
					\-> {
						msg = "A component is updated. Please reload the application to apply it.";
						println(msg);
						onUpdateFound(msg);
					},
					\err -> println(formatString("Can not load info about ServiceWorker updates: %1", [err]))
				);

				if (success) getServiceWorkerJsVersion(
					\v -> {
						if (v == service_worker_version) println(formatString("ServiceWorker version is #%1 (the last version).", [i2s(v)]))
						else println(formatString("ServiceWorker version is #%1 (an old, exists version #%2).", [i2s(v), i2s(service_worker_version)]))
					},
					\err -> println(formatString("Can not retrieve version of ServiceWorker: %1.", [err]))
				);
			}
		}

		cb = \success -> {
			onDone2(success);
			devtrace(if (success) "Success Service Worker Toggle" else "Service Worker Error");
		};

		if (!enabled && doEnable)
			enableServiceWorkerCaching(swFileName, cb)
		else if (enabled && !doEnable)
			disableServiceWorkerCaching(cb)
		else
			onDone2(true);
	});
}

native addRequestCacheFilterN : io (
	cacheIfUrlMatch : string,
	cacheIfMethodMatch : string,
	cacheIfParametersMatch : [[string]],
	ignoreParameterKeysOnCache : [string],
	onOK : () -> void,
	onError : (string) -> void
) -> void = ProgressiveWebTools.addRequestCacheFilterN;

native addRequestSkipFilterN : io (
	skipIfUrlMatch : string,
	skipIfMethodMatch : string,
	skipIfHeaderMatch : [string],
	onOK : () -> void,
	onError : (string) -> void
) -> void = ProgressiveWebTools.addRequestSkipFilterN;

addRequestCacheFilter(
	cacheIfUrlMatchM : Maybe<string>,
	cacheIfMethodMatchM : Maybe<RequestMethodBase>,
	cacheIfParametersMatch : [KeyValue],
	ignoreParameterKeysOnCache : [string],
	onOK : () -> void,
	onError : (string) -> void
) -> void {
	checkServiceWorkerEnabledOnly(
		\enabled -> if (enabled) {
			if (cacheIfUrlMatchM == Some(""))
				onError("Parameter `cacheIfUrlMatchM` can't be empty");

			cacheIfUrlMatch = either(cacheIfUrlMatchM, "");
			cacheIfMethodMatch = eitherMap(cacheIfMethodMatchM, method2string, "");
			cacheIfParametersMatchN = map(cacheIfParametersMatch, \p -> [toLowerCase(p.key), toLowerCase(p.value)]);
			ignoreParameterKeysOnCacheN = map(ignoreParameterKeysOnCache, toLowerCase);

			addRequestCacheFilterN(strReplace(cacheIfUrlMatch, "//", "/"), cacheIfMethodMatch, cacheIfParametersMatchN, ignoreParameterKeysOnCacheN, onOK, onError);
		} else {
			onOK();
		}
	);
}

addRequestSkipFilter(
	urlM : Maybe<string>,
	methodM : Maybe<RequestMethodBase>,
	headerMatchM : Maybe<KeyValue>,
	onOK : () -> void,
	onError : (string) -> void
) -> void {
	checkServiceWorkerEnabledOnly(
		\enabled -> if (enabled) {
			if (urlM == Some(""))
				onError("Parameter `urlM` can't be empty");

			skipIfUrlMatch = either(urlM, "");
			skipIfUrlMatch2 = (if (startsWith(skipIfUrlMatch, "/")) "." else "") + skipIfUrlMatch;
			skipIfMethodMatch = eitherMap(methodM, method2string, "");
			skipIfHeaderMatch = eitherMap(headerMatchM, \m -> [toLowerCase(m.key), toLowerCase(m.value)], []);

			addRequestSkipFilterN(strReplace(skipIfUrlMatch2, "//", "/"), skipIfMethodMatch, skipIfHeaderMatch, onOK, onError);
		} else {
			onOK();
		}
	);
}

storeSharedKeyValue(key : string, value : string) {
	payload = json2string(JsonObject([
		Pair("key", JsonString(key)),
		Pair("value", JsonString(value))
	]));

	httpCustomRequest(
		PWA_SHARED_DATA_ENDPOINT,
		POST(),
		[],
		RequestPayload(payload),
		nop3,
		true
	);
}

takeSharedKeyValue(key : string, callback : (value : string) -> void) {
	payload = json2string(JsonObject([
		Pair("key", JsonString(key))
	]));

	httpCustomRequest(
		PWA_SHARED_DATA_ENDPOINT,
		GET(),
		[],
		RequestParameters([KeyValue("key", key)]),
		\__, value, __ -> callback(value),
		true
	);
}
