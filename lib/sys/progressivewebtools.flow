import devmode;
import net/http_types;
import formats/json/json;
import net/http;

export {
	// A service worker is a script which your browser runs in the background, separate from a web page, opening the door to features that don't need a web page or user interaction.

	// Browsers support map: http://caniuse.com/#search=service%20worker
	// EXAMPLE: flow/sandbox/serviceworker.flow
	// LIVE EXAMPLE: https://tech.area9innovation.com/sw/flowjs.html?name=test_sw

	// Functionality contained in this file is intended to manipulate implemented Service Worker for controlling FlowJS cache.
	// NOTE: Service Worker influences over all static resources with scope matching to files located lower than flowjs.html.
	// CAUTION: Service Worker keeps running behind the scene, despite of launches.
	// CAUTION: Service Worker runs only for pages served over HTTPS protocol.

	// Service Worker caches each launch request to static resources (all extensions, except .php & .serverbc).
	// Such way helps us to keep actual responses inside cache storage.
	// EXCEPTION: Only one particular php request is cached - it's the request to /php/stamp.php?file=<application>.js.
	// We do this to respond with the latest timestamp for <application>.js file in offline mode.

	// Once static resource request fails (user is offline, etc.) we respond to a client with previously cached resource.

	// Registers the Service Worker for a web page.
	// Once called the Service Worker will be run until disableServiceWorkerCaching called.
	native enableServiceWorkerCaching : io (callback : (success : bool) -> void) -> void = ProgressiveWebTools.enableServiceWorkerCaching;

	// Unregisters the Service Worker from a web page.
	// Make sure to call after enableServiceWorkerCaching or checkServiceWorkerCachingEnabled callback called with true.
	// Disables Service Worker once any ongoing operation will be finished.
	native disableServiceWorkerCaching : io (callback : (success : bool) -> void) -> void = ProgressiveWebTools.disableServiceWorkerCaching;


	// Check whether we already registered a Service Worker
	native checkServiceWorkerCachingEnabled : io (callback : (enabled : bool) -> void) -> void = ProgressiveWebTools.checkServiceWorkerCachingEnabled;

	// Fires when all progressive web app requirements are abided: https, web app manifest, service worker registered
	native addShortcutAvailableListener : io (callback : () -> void) -> (() -> void) = ProgressiveWebTools.addShortcutAvailableListener;

	// Prompts user to install shortcut
	// IMPORTANT: Call it only after shortcut available listener fired
	native installShortcut : io (callback : (bool) -> void) -> void = ProgressiveWebTools.installShortcut;

	// Clean Service Worker cache immediately
	native cleanServiceWorkerCache : io (callback : (success : bool) -> void) -> void = ProgressiveWebTools.cleanServiceWorkerCache;

	// By default cached only static resources.
	// This method allows to add filter to cache dynamic requests.
	// The request will be cached if (concatinated by AND, None() or empty array - means any value):
	// 1. if request Url will be match to the `cacheIfUrlMatchM` string (use absolute path)
	// 2. if request Method equals to `methodM`
	// 3. if request Parameters (for GET or POST method) contains given KeyValue pairs (case insensitive)
	// If you request contains any variable/temporary parameters, which should be skipped (like time stamp) - send them in `ignoreParameterKeysOnCache`
	addRequestCacheFilter(
		cacheIfUrlMatchM : Maybe<string>,
		methodM : Maybe<RequestMethodBase>,
		cacheIfParametersMatchM : [KeyValue],
		ignoreParameterKeysOnCache : [string],
		onOK : () -> void,
		onError : (string) -> void
	) -> void;

	// loading and caching data by given urls
	native loadAndCacheUrls : io (
		urls : [string],
		ignoreParameterKeysOnCache : [string],
		onOK : () -> void,
		onError : (string) -> void
	) -> void = ProgressiveWebTools.loadAndCacheUrls;

	// Check and return urls (from the given list) which are presented in the Service Worker cache.
	// Useful for the GET-request urls, where the request parameters are in the url string.
	native checkUrlsInServiceWorkerCache : io (
		urls : [string],
		onOK : ([string]) -> void,
		onError : (string) -> void
	) -> void = ProgressiveWebTools.checkUrlsInServiceWorkerCache;

	// Check whether we run as standalone or fullscreen PWA
	native isRunningPWA : io () -> bool = ProgressiveWebTools.isRunningPWA;

	addShortcutDialog() -> () -> void;
	setServiceWorkerEnabled(enabled : bool, ondone : (success : bool) -> void) -> void;

	// The endpoint could be used for transferring data between browser & PWA application
	// Simply POST data with httpRequestCustom to put any data there with RequestPayload
	// Use GET request to the endpoint to get stored data
	PWA_SHARED_DATA_ENDPOINT = "/share/pwa/data";

	storeSharedKeyValue(key : string, value : string) -> void;
	takeSharedKeyValue(key : string, callback : (value : string) -> void) -> void;
}

enableServiceWorkerCaching(callback : (bool) -> void) { callback(false) }
disableServiceWorkerCaching(callback : (bool) -> void) { callback(false) }
checkServiceWorkerCachingEnabled(callback : (bool) -> void) { callback(false) }
cleanServiceWorkerCache(callback : (bool) -> void) { callback(false) }
loadAndCacheUrls(urls : [string], ignoreParameterKeysOnCache : [string], onOK : () -> void, onError : (string) -> void) -> void { onOK(); }
checkUrlsInServiceWorkerCache(urls : [string], onOK : ([string]) -> void, onError : (string) -> void) -> void { onOK([]); };
isRunningPWA() { false }

addShortcutDialog() -> () -> void {
	uns = ref None();

	dispose = \ -> {
		maybeApply(^uns, \u -> { u(); uns := None(); });
	}

	uns :=
		addShortcutAvailableListener(\ -> {
			installShortcut(\accepted -> devtrace("User " + (if (accepted) "accepted" else "dismissed") + " shortcut installation!"));
			deferred(dispose);
		})
		|> Some;

	dispose;
}

setServiceWorkerEnabled(enable : bool, ondone : (success : bool) -> void) -> void {
	doEnable = enable && !isUrlParameterFalse("sw");
	checkServiceWorkerCachingEnabled(\enabled -> {
		cb = \success -> {
			ondone(success);
			devtrace(if (success) "Success Service Worker Toggle" else "Service Worker Error");
		};

		if (!enabled && doEnable)
			enableServiceWorkerCaching(cb)
		else if (enabled && !doEnable)
			disableServiceWorkerCaching(cb)
		else
			ondone(true);
	});
}

native addRequestCacheFilterN : io (
	cacheIfUrlMatch : string,
	cacheIfMethodMatch : string,
	cacheIfParametersMatch : [[string]],
	ignoreParameterKeysOnCache : [string],
	onOK : () -> void,
	onError : (string) -> void
) -> void = ProgressiveWebTools.addRequestCacheFilterN;

addRequestCacheFilter(
	cacheIfUrlMatchM : Maybe<string>,
	cacheIfMethodMatchM : Maybe<RequestMethodBase>,
	cacheIfParametersMatch : [KeyValue],
	ignoreParameterKeysOnCache : [string],
	onOK : () -> void,
	onError : (string) -> void
) -> void {
	if (cacheIfUrlMatchM == Some(""))
		onError("Parameter `cacheIfUrlMatchM` can't be empty");

	cacheIfUrlMatch = either(cacheIfUrlMatchM, "");
	cacheIfMethodMatch = eitherMap(cacheIfMethodMatchM, method2string, "");
	cacheIfParametersMatchN = map(cacheIfParametersMatch, \p -> [toLowerCase(p.key), toLowerCase(p.value)]);
	ignoreParameterKeysOnCacheN = map(ignoreParameterKeysOnCache, toLowerCase);

	addRequestCacheFilterN(strReplace(cacheIfUrlMatch, "//", "/"), cacheIfMethodMatch, cacheIfParametersMatchN, ignoreParameterKeysOnCacheN, onOK, onError);
}

storeSharedKeyValue(key : string, value : string) {
	payload = json2string(JsonObject([
		Pair("key", JsonString(key)),
		Pair("value", JsonString(value))
	]));

	httpCustomRequest(
		PWA_SHARED_DATA_ENDPOINT,
		POST(),
		[],
		RequestPayload(payload),
		nop3,
		true
	);
}

takeSharedKeyValue(key : string, callback : (value : string) -> void) {
	payload = json2string(JsonObject([
		Pair("key", JsonString(key))
	]));

	httpCustomRequest(
		PWA_SHARED_DATA_ENDPOINT,
		GET(),
		[],
		RequestParameters([KeyValue("key", key)]),
		\__, value, __ -> callback(value),
		true
	);
}
