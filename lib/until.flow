import runtime;
import ds/tuples;

export {

	//the same as map but breaks when got false as .first field in result of a callback. returns previous successfull result
	mapUntil : ([?], (?) -> Pair<bool, ??>) -> [??];
	mapiUntil : ([?], (int, ?) -> Pair<bool, ??>) -> [??];

	// breaks when callback returns false in .first field and returns previous .second
	foldUntil(a : [?], init : ??, fn : (??, ?) -> Pair<bool, ??>) -> ??;
	foldiUntil(a : [?], init : ??, fn : (int, ??, ?) -> Pair<bool, ??>) -> ??;

	// breaks when callback returns true in .first field and returns it`s .second
	foldUntil2(a : [?], init : ??, fn : (??, ?) -> Pair<bool, ??>) -> ??;
	foldiUntil2(a : [?], init : ??, fn : (int, ??, ?) -> Pair<bool, ??>) -> ??;

	// repeats fn infinitily until it returns true;
	repeatUntil(fn : () -> bool) -> void;
}


_foldUntil(a : [?], ix : int, res : ??, fn : (int, ??, ?) -> Pair<bool, ??>) -> ?? {
	if (ix >= length(a)) res
	else {
		r = fn(ix, res, a[ix]);
		if (!r.first) res else _foldUntil(a, ix + 1, r.second, fn);
	}
}

foldUntil(a : [?], init : ??, fn : (??, ?) -> Pair<bool, ??>) -> ?? {
	if (length(a) == 0) init else _foldUntil(a, 0, init, \__, r : ??, v : ? -> fn(r, v));
}

foldiUntil(a : [?], init : ??, fn : (int, ??, ?) -> Pair<bool, ??>) -> ?? {
	if (length(a) == 0) init else _foldUntil(a, 0, init, fn);
}

_foldUntil2(a : [?], ix : int, res : ??, fn : (int, ??, ?) -> Pair<bool, ??>) -> ?? {
	if (ix >= length(a)) res
	else {
		r = fn(ix, res, a[ix]);
		if (r.first) r.second else _foldUntil2(a, ix + 1, res, fn);
	}
}

foldUntil2(a : [?], init : ??, fn : (??, ?) -> Pair<bool, ??>) -> ?? {
	if (length(a) == 0) init else _foldUntil2(a, 0, init, \__, r : ??, v : ? -> fn(r, v));
}

foldiUntil2(a : [?], init : ??, fn : (int, ??, ?) -> Pair<bool, ??>) -> ?? {
	if (length(a) == 0) init else _foldUntil2(a, 0, init, fn);
}


_mapUntil(a : [?], ix : int, res : [??], fn : (int, ?) -> Pair<bool, ??>) -> [??] {
	if (ix >= length(a)) res
	else {
		r = fn(ix, a[ix]);
		if (!r.first) res else _mapUntil(a, ix + 1, arrayPush(res, r.second), fn);
	}
}

mapUntil(a : [?], fn : (?) -> Pair<bool, ??>) -> [??] {
	if (length(a) == 0) [] else _mapUntil(a, 0, [], \__, v : ? -> fn(v));
}

mapiUntil(a : [?], fn : (int, ?) -> Pair<bool, ??>) -> [??] {
	if (length(a) == 0) [] else _mapUntil(a, 0, [], fn);
}

// repeats fn infinitily until it returns true;
repeatUntil(fn : () -> bool) -> void {
	if (!fn()) repeatUntil(fn);
}

