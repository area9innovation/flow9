import string;
import ds/array;
import math/math;
import algorithms;
import devmode;
import lingo/pegcode/driver;

export {
	// Create a CSV string with provided rows, using comma as separator
	makeCsv(rows : [[string]]) -> string;

	// Create a CSV string with custom separator
	makeCsvSep(rows : [[string]], sep: string) -> string;

	// Like makeCsv but adds BOM marker for Excel compatibility
	makeCsvFile(rows : [[string]]) -> string;

	// Like makeCsvSep but adds BOM marker for Excel compatibility
	makeCsvFileSep(rows : [[string]], sep: string) -> string;

	// Parses a CSV file with automatic separator detection
	// onlyRectangular: if true, returns empty array when rows have different column counts
	parseCsvFile(content : string, onlyRectangular : bool) -> [[string]];

	// Parses CSV content with known separator
	parseCsv(s : string, sep : string) -> [[string]];

	// Parses a single CSV line into array of fields
	parseCsvLine(s : string, sep : string) -> [string];

	// Like parseCsvLine but handles quoted separators correctly
	parseCsvLineWithQuotedSeparators(s: string, sep: string) -> [string];

	// Extracts next field from CSV line starting at given index
	parseCsvField(s : string, index : int, sep : string) -> Pair<string, int>;

	ParseCsvOption ::= ParseCsvSeparator, ParseCsvDetectSeparator, ParseCsvRectangle, ParseCsvSkipEmpty, ParseCsvQuotedEscapes;
		// Any character except double quotes or empty string
		ParseCsvSeparator(sep : string);
		// Try to detect if separator is either of , ; \t
		ParseCsvDetectSeparator();
		// Treat inconsistent number of columns as an error
		ParseCsvRectangle();
		// Ignore empty rows, can be used with ParseCsvRectangle
		ParseCsvSkipEmpty();
		// Whether to parse values escaped with quotes
		ParseCsvQuotedEscapes(enabled : bool);

	// Parses CSV data with configurable options
	// Returns parsed rows and any error messages
	parseCsvData(data : string, styles : [ParseCsvOption]) -> CsvParseResult;
}

// Represents the result of parsing CSV data
CsvParseResult(
	rows : [[string]],
	error : string
);

// Information about a parsed CSV row
CsvRowInfo(
	start : int,
	end : int,
	row : [string]
);

// Cache for compiled CSV grammars
compiledCsvGrammarsR : ref Tree<string, [PegOp]> = ref makeTree();

// Actions for parsing quoted strings
csvGrammarActions = SemanticActions(setTree(defaultPegActions.t, "unescapeQ", \args : [flow] -> {
	str = flow2s(args[0]);
	trimmed = substring(str, 1, strlen(str) - 2);
	strReplace(trimmed, "\"\"", "\"");
}));

// Validates if a separator is valid (not empty or containing quotes)
validateSeparator(sepStr : string) -> Maybe<string> {
	if (sepStr == "" || strContains(sepStr, "\\u0022")) None()
	else Some(sepStr);
}

// Determines the separator to use based on parsing options
getSeparator(styles : [ParseCsvOption], data : string) -> string {
	styleSepM = tryExtractStruct(styles, ParseCsvSeparator(""));
	eitherFn(styleSepM, \styleSep -> styleSep.sep, \ -> {
		if (containsStruct(styles, ParseCsvDetectSeparator())) {
			sep = detectCsvSeparator(data).second;
			devtrace("parseCsvData: detected separator is " + sep);
			sep;
		} else {
			","; // default separator
		}
	});
}

// Gets or creates a grammar for parsing CSV with given separator
getGrammar(sep : string, disableEscapes : bool) -> [PegOp] {
	grammarM = if (disableEscapes) None() else lookupTree(^compiledCsvGrammarsR, sep);
	eitherFn(grammarM, idfn, \ -> {
		escapeCh = if (disableEscapes) "\\uFFFF" else "\\u0022";
		wsCh1 = if (strContains(sep, "\\u0020")) "\\uFFFF" else "\\u0020";
		wsCh2 = if (strContains(sep, "\\u0009")) "\\uFFFF" else "\\u0009";
		newOps = compilePegGrammar(formatString("#include formats/csv/csv.lingo-template",
			[sep, escapeCh, wsCh1, wsCh2]));
		if (!disableEscapes) {
			compiledCsvGrammarsR := setTree(^compiledCsvGrammarsR, sep, newOps);
		}
		newOps;
	});
}

// Main CSV parsing function with configurable options
parseCsvData(data : string, styles : [ParseCsvOption]) -> CsvParseResult {
	disableEscapes = !extractStruct(styles, ParseCsvQuotedEscapes(true)).enabled;
	sepStr = getSeparator(styles, data);

	// Convert string to unicode escapes
	sep = concatStrings(map(s2a(sepStr), \code -> {
		hex = formatHex(code);
		substring("\\u0000", 0, 6 - strlen(hex)) + hex;
	}));

	sepM = validateSeparator(sepStr);
	switch (sepM) {
		None(): CsvParseResult([], "invalid separator");
		Some(validSep): {
			grammar = getGrammar(sep, disableEscapes);
			parseResult = parsic3(grammar, data, csvGrammarActions, []);

			if (parseResult.third != "") {
				devtrace("parseCsvData: " + parseResult.third);
				CsvParseResult([], "parsing error");
			} else {
				processParseResult(parseResult.first, styles);
			}
		}
	}
}

// Process parsed rows according to style options
processParseResult(rawRows : [CsvRowInfo], styles : [ParseCsvOption]) -> CsvParseResult {
	rows = map(rawRows, \info -> if (info.start == info.end) [] else info.row);
	filteredRows = if (containsStruct(styles, ParseCsvSkipEmpty())) {
		filter(rows, \row -> row != []);
	} else {
		// Trim empty rows at the end
		idxM = lastfindi(rows, \row -> row != []);
		eitherMap(idxM, \idx -> take(rows, idx + 1), rows);
	}

	if (containsStruct(styles, ParseCsvRectangle())) {
		columnCounts = uniq(map(filteredRows, length));
		if (length(columnCounts) > 1) {
			CsvParseResult(filteredRows, "inconsistent number of columns");
		} else {
			CsvParseResult(filteredRows, "");
		}
	} else {
		CsvParseResult(filteredRows, "");
	}
}

// Detects the most likely separator in CSV content
detectCsvSeparator(s : string) -> Pair<int, string> {
	sampleText = strLeft(s, 2000);
	separators = [",", ";", "\t"];
	counts = map(separators, \sep ->
		if (strCountOf(sampleText, sep) > 0) getBestRowCount(sampleText, sep)
		else 0
	);

	if (counts[0] == counts[1] && counts[1] == counts[2]) {
		Pair(counts[0], ",")
	} else {
		max3(
			Pair(counts[0], ","),
			Pair(counts[1], ";"),
			Pair(counts[2], "\t")
		);
	}
}

// Determines how many rows have consistent column counts for a given separator
getBestRowCount(content : string, sep : string) -> int {
	lines = strSplit2WithoutLeave(content, [fromCharCode(10), fromCharCode(13)]);
	columnCounts = filtermap(lines, \line -> {
		columnCount = length(parseCsvLineWithQuotedSeparators(line, sep));
		if (columnCount == 1) None() else Some(columnCount);
	});

	uniqueCounts = uniq(columnCounts);
	fold(map(uniqueCounts, \count ->
		countA(columnCounts, eq(count))
	), 0, max);
}

// Parses a CSV line handling quoted separators
parseCsvLineWithQuotedSeparators(s: string, sep: string) -> [string] {
	list2array(strSplitCheckQuotes(s, sep, makeList()));
}

// Splits string on separator while respecting quotes
strSplitCheckQuotes(s: string, sep: string, acc: List<string>) -> List<string> {
	strLen = strlen(s);
	lastQuoteIndex = ref -1;
	separatorIndex = strIndexOfSepOutOfQuotes(s, sep, lastQuoteIndex);

	nextSubstring = if (^lastQuoteIndex > 0) {
		substring(s, 1, if (separatorIndex < 0) (^lastQuoteIndex - 1) else (separatorIndex - 2));
	} else if (separatorIndex < 0) {
		s;
	} else {
		strLeft(s, separatorIndex);
	}

	if (separatorIndex < 0) {
		Cons(nextSubstring, acc);
	} else {
		newAcc = Cons(nextSubstring, acc);
		if (separatorIndex < strLen) {
			sepLen = strlen(sep);
			remainingStr = substring(s, separatorIndex + sepLen, strLen - separatorIndex - sepLen);
			strSplitCheckQuotes(remainingStr, sep, newAcc);
		} else {
			newAcc;
		}
	}
}

// Finds index of separator outside quoted sections
strIndexOfSepOutOfQuotes(str : string, sep : string, lastQuoteInd : ref int) -> int {
	quotePos = strIndexOf(str, "\"");
	if (quotePos < 0 || strIndexOf(str, sep) < quotePos) {
		strIndexOf(str, sep);
	} else {
		quotesPositions = multipleStrIndexOf(str, "\"");
		// Group quote positions into pairs (start, end)
		quotePairs = foldi(quotesPositions, [], \idx, acc, quoteIdx -> {
			if (even(idx)) acc
			else concat(acc, [Pair(quotesPositions[idx - 1], quotesPositions[idx])])
		});
		
		separatorPositions = multipleStrIndexOf(str, sep);
		strLength = strlen(str);
		
		isInQuotes = \pos -> fold(quotePairs, false, \acc, pair -> 
			acc || (pos > pair.first && pos < pair.second)
		);
		
		updateLastQuote = \sepIdx -> {
			quoteCount = length(quotesPositions);
			if (quoteCount > 1 && quotesPositions[0] == 0 && quotesPositions[1] == (sepIdx - 1)) {
				lastQuoteInd := sepIdx - 1;
			}
		}
		
		firstValidSep = fold(separatorPositions, strLength, \acc, sepIdx -> {
			if (acc < strLength || isInQuotes(sepIdx)) acc
			else {
				updateLastQuote(sepIdx);
				sepIdx;
			}
		});
		
		if (firstValidSep == strLength) {
			updateLastQuote(strLength);
			if ((^lastQuoteInd) < 0) updateLastQuote(strLength - 1);
			-1;
		} else {
			firstValidSep;
		}
	}
}

// Create CSV string with default comma separator
makeCsv(rows : [[string]]) -> string {
	makeCsvSep(rows, ",");
}

// Create CSV file with BOM marker
makeCsvFile(rows : [[string]]) -> string {
	fromCharCode(0xFEFF) + makeCsv(rows);
}

// Escapes a cell value if needed
escapeCell(value: string, sep: string) -> string {
	needsEscaping = isSome(strFindFirstOfStrings(value, ["\n", sep, ";", "\""]));
	if (needsEscaping) {
		formatString("\"%1\"", [strReplace(value, "\"", "\"\"")])
	} else {
		value;
	}
}

// Create CSV string with custom separator
makeCsvSep(rows : [[string]], sep: string) -> string {
	rowStrings = map(rows, \row -> strGlue(map(row, \cell -> escapeCell(cell, sep)), sep));
	strGlue(rowStrings, "\n");
}

// Create CSV file with BOM marker and custom separator
makeCsvFileSep(rows : [[string]], sep: string) -> string {
	fromCharCode(0xFEFF) + makeCsvSep(rows, sep);
}

// Parse CSV file with automatic separator detection
parseCsvFile(content : string, onlyRectangular : bool) -> [[string]] {
	detectedSeparator = detectCsvSeparator(content);

	// Handle line endings
	newline = fromCharCode(10);
	carriageReturn = fromCharCode(13);

	trimmedContent = trim2(trim2(content, newline), carriageReturn);

	parsedRows = if (strContains(trimmedContent, newline) || strContains(trimmedContent, carriageReturn)) {
		map(strSplit2WithoutLeave(trimmedContent, [newline, carriageReturn]),
			\line -> parseCsvLineWithQuotedSeparators(line, detectedSeparator.second))
	} else {
		map(parseCsvLineWithQuotedSeparators(trimmedContent, detectedSeparator.second), \v -> [v]);
	}

	// Process and clean parsed rows
	processedRows = map(
		map(parsedRows, \row ->
			if (length(row) != detectedSeparator.first)
				tryToConcatStringsWithQuotes(row)
			else row
		),
		\row -> map(row, \cell -> strReplace(trimQuotes(trim(cell)), "\"\"", "\""))
	);

	// Analyze column counts
	columnCounts = map(processedRows, length);
	uniqueColumnCounts = uniq(columnCounts);
	columnStatistics = sort(map(uniqueColumnCounts, \count ->
		Pair(countA(columnCounts, eq(count)), count)
	));

	mostCommonColumnCount = columnStatistics[length(columnStatistics)-1].second;

	devtrace("separator: " + if (detectedSeparator.second == "\t") "tab" else detectedSeparator.second);
	iter(columnStatistics, \stat -> {
		devtrace(i2s(stat.first) + " rows have " + i2s(stat.second) + " columns")
	});

	if (onlyRectangular && length(columnStatistics) > 1) [[]]
	else processedRows;
}

// Try to concatenate strings that were incorrectly split due to quotes
tryToConcatStringsWithQuotes(arr : [string]) -> [string] {
	quoteStartIndex = findi(arr, \s -> startsWith(s, "\"") && !endsWith(s, "\""));
	switch(quoteStartIndex) {
		None(): arr;
		Some(startPos): {
			remainingArr = subrange(arr, startPos, length(arr)-startPos);
			quoteEndIndex = findi(remainingArr, \s -> !startsWith(s, "\"") && endsWith(s, "\""));

			switch(quoteEndIndex) {
				None(): arr;
				Some(endPos): {
					concatenatedStr = concatStrings(subrange(arr, startPos, startPos+endPos));
					arrayLength = length(arr);
					concat3(
						subrange(arr, 0, startPos),
						[concatenatedStr],
						if (arrayLength-1 > endPos)
							tryToConcatStringsWithQuotes(subrange(arr, endPos, arrayLength-1-endPos))
						else []
					);
				}
			}
		}
	}
}

// Remove surrounding quotes from a string if present
trimQuotes(s : string) -> string {
	if (startsWith(s, "\"") && endsWith(s, "\"")) {
		substring(s, 1, strlen(s)-2);
	} else {
		s;
	}
}

// Extract substring until a delimiter is found
takeUntil(s : string, from : int, delimiter : string) -> Pair<string, int> {
	if (from == -1) {
		Pair("", -1);
	} else {
		remainder = strRight(s, from);
		delimiterIndex = strIndexOf(remainder, delimiter);
		if (delimiterIndex == -1) {
			Pair(remainder, -1);
		} else {
			Pair(substring(s, from, delimiterIndex), delimiterIndex + from + strlen(delimiter));
		}
	}
}

// Parse a single CSV line into fields
parseCsvLine(s : string, sep : string) -> [string] {
	doParseCsvLine(s, 0, [], sep);
}

// Helper function for parseCsvLine
doParseCsvLine(s : string, index : int, acc : [string], sep : string) -> [string] {
	field = parseCsvField(s, index, sep);
	updatedAcc = arrayPush(acc, rtrim2(field.first, "\u000d"));
	if (field.second == -1) updatedAcc
	else doParseCsvLine(s, field.second, updatedAcc, sep);
}

// Parse next field from CSV content
parseCsvField(s : string, index : int, sep : string) -> Pair<string, int> {
	if (index <= -1) {
		Pair("", -1);
	} else {
		if (getCharAt(s, index) == "\"") {
			stringContent = parseRestOfString(s, index + 1);
			separatorPos = takeUntil(s, stringContent.second, sep);
			Pair(stringContent.first, separatorPos.second);
		} else {
			takeUntil(s, index, sep);
		}
	}
}

// Parse quoted string content
parseRestOfString(s : string, start : int) -> Pair<string, int> {
	remainder = strRight(s, start);
	nextQuotePos = strIndexOf(remainder, "\"");
	escapedQuotePos = strIndexOf(remainder, "\"\"");

	if (escapedQuotePos != -1 && escapedQuotePos == nextQuotePos) {
		// Handle escaped quote
		restOfString = parseRestOfString(s, start + escapedQuotePos + 2);
		Pair(substring(s, start, nextQuotePos - start + 2) + restOfString.first, restOfString.second);
	} else {
		Pair(strLeft(remainder, nextQuotePos), start + nextQuotePos + 1);
	}
}

// Parse CSV with known separator
parseCsv(s : string, sep : string) -> [[string]] {
	lines = strSplit(s, "\n");
	map(lines, \line -> parseCsvLine(line, sep));
}