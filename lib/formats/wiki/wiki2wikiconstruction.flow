import formats/wiki/wikiast;
import formats/wiki/wikilexer;
import formats/writeparser;
import formats/wiki/wikiparsertags;
import formats/wiki/wikimediaextractorshelper;
import formats/wiki/wikitools2;
import formats/xml;
import formats/html/html;
import textstyles2;

export {
	wiki2wikiConstruction(text_ : string, asMathForm : bool, wikiStyle : [WikiParsingStyle],
		tableStyle : WikiTableStyle
	) -> [WikiConstruction];

	getXmlNodeAttrs(xml : string) -> [XmlAttribute];
}

wiki2wikiConstruction(text_ : string, asMathForm : bool, wikiStyle : [WikiParsingStyle],
		tableStyle : WikiTableStyle) -> [WikiConstruction] {
	// This code is accidentally used to parse Write sources.
	// Source with simple text only is exported without enclosing tags, so general Wiki rules are applied.
	text = if (contains(wikiStyle, WriteSource()) && !isWriteContent(text_)) simpleText2WriteSource(text_) else text_;
	recCall = \src -> wiki2wikiConstruction(src, asMathForm, wikiStyle, tableStyle);
	recCallAsMath = \src -> wiki2wikiConstruction(src, true, wikiStyle, tableStyle);
	l = strlen(text);
	rest = \from -> substring(text, from, l - from);


	firstOccurrence = findFirstWikiTag(text);


	// previously it had  "&& !isDigit(ch)", but with that condition it's impossible to use italic with a number (e.g. *1960*)
	// also it had comment: "Maybe: isLetter() || isPunct()"
	isMarkupLetter = \ch -> ch != " ";

	i = firstOccurrence.start;
	e = firstOccurrence.end;
	end = ref e;

	occurrenceArgs = ref [];
	argsUsed = ref 0;
	correctArgs = ref true;
	argsCount = ref 0;

	multilineBlock = contains(wikiStyle, AllowSpacesBeetweenBracketedArgs());
	// try to get list of actual arguments based on list of expected arguments.
	// updates state refs. Refs are used to support lookahead when ambiguity has taken place.
	updateArgs = \argsDescription -> {
		argsList = getArgsList(rest(e), argsDescription, multilineBlock);
		correctArgs := isSome(argsList);
		argsUsed := 0;
		occurrenceArgs := eitherMap(argsList, \al -> al.args, []);
		argsSourceLen = eitherMap(argsList, \al -> al.end, 0);
		argsCount := length(^occurrenceArgs);
		end := ^end + argsSourceLen;
	}

	maybeApply(firstOccurrence.args, updateArgs);


	getArgText = \arg : WikiArgValue -> {
		switch(arg) {
			SingleArgValue(txt) : {
				txt;
			}
			ListArgValue(__) : {
				println("Wrong type of arg is requested. A");
				""
			}
		}
	}

	getNextArg = \ -> {
		if (^argsUsed < ^argsCount) {
			arg = ^occurrenceArgs[^argsUsed];
			argsUsed := ^argsUsed + 1;
			getArgText(arg)
		} else {
			""
		}
	}
	getNextListArg = \ -> {
		if (^argsUsed < ^argsCount) {
			arg = ^occurrenceArgs[^argsUsed];
			argsUsed := ^argsUsed + 1;
			switch(arg) {
				SingleArgValue(__) : {
					println("Wrong type of arg is requested. B");
					[];
				}
				ListArgValue(texts) : texts;
			}
		} else {
			[]
		}
	}

	getElementsText = \ -> substring(text, i, ^end-i);

	sourceAsPlainText = \ -> WikiBaseTextEx(getElementsText()) |> v2a;

	useFirstTextIfNotEmpty = \s1, s2 -> if (isNotSpace(s1)) s1 else s2;

	restrictLineBreak = \nextChar -> \elements : [WikiConstruction] -> {
		if (isUrlParameterTrue("disable34834") && nextChar != "" && strIndexOf(" \t\n", nextChar) == -1 && length(elements) > 0) {
			arrayPush(elements, GlueFragments())
		} else {
			elements
		}
	};

	processDefiniteControl = \signType -> {
		ft = getNextArg();
		tt = getNextArg();
		bt = getNextArg();

		to = tt |> recCall;
		from = ft |> recCall;
		body = bt |> recCall;
		DefiniteControlEx(signType, to, from, body) |> v2a
	}

	insertSymbolByCode = \styleAddition -> {
		if (
			isHexDigit(getCharAt(text, ^end)) &&
			isHexDigit(getCharAt(text, ^end + 1)) &&
			isHexDigit(getCharAt(text, ^end + 2)) &&
			isHexDigit(getCharAt(text, ^end + 3))
		) {
			end := ^end + 4;
			WikiSimpleTextEx("&#x" + substring(text, ^end - 4, 4) + ";", styleAddition) |> v2a;
		} else {
			sourceAsPlainText()
		}
	}

	parseScript = \src -> {
		pr = parseWikiVariables(src);
		switch(pr : WV_ParseResult) {
			WV_CorrectResult(sequence, remainder) : {
				end := l - strlen(remainder.s);
				WikiSequenceEx(sequence) |> v2a
			}
			WV_RemainderOnly(remainder) : {
				sourceAsPlainText()
			}
		}
	}

	addScriptHeaderAndFooter = \s -> "{" + s + "}";
	addOptionalParameterBrackets = \s -> if (isNotSpace(s)) "[" + s + "]" else "";

	improveLeadingMinus = \t, wiki -> {
		if (startsWith(t, "-") && !startsWith(t, "--")) {
			if (!wiki) {
				"&#x2013;" + strRight(t, 1)
			} else {
				"\\endash" + strRight(t, 1)
			}
		} else {
			t
		}
	}

	improveXScriptReadability = \src -> {
		if (isBaseWikiText(src)) {
			"**" + improveLeadingMinus(src, true) + "**"
		} else {
			src
		}
	}



	processFormattingSymbol = \s, toConstruction -> {
		//assumption:
		//s is a sequence of equal letters with non-zero length
		//i.e. "_", "*", "***"
		sl = strlen(s);
		assert(sl > 0, "Wrong s is passed to processFormattingSymbol (a)");
		formattingSymbol = getCharAt(s,0);
		assert(strlen(trim2(s, formattingSymbol)) == 0, "Wrong s is passed to processFormattingSymbol");
		result : [WikiConstruction] = if (isMarkupLetter(getCharAt(text, i+sl))) {
			textLength = e-i-2*sl;
			if (textLength > 0) {
				src = substring(text, i+sl, textLength);
				tc : (string) -> WikiConstruction = toConstruction;
				src |> tc |> v2a
			} else {
				//Merge all equal symbols to one fragment to avoid considering, for example,
				//"____" (4 '_' without enclosed text) as "__" and "__"
				end := countUntil(^end, l, \cs -> getCharAt(text, cs) != formattingSymbol);
				r : [WikiConstruction] = sourceAsPlainText();
				r
			}
		} else {
			end := i + sl;
			WikiBaseTextEx(substring(text, i, sl)) |> v2a
		}
		result
	}

	parseColor : (string) -> int = \s -> {
		if (startsWith(s, "#")) {
			parseHex(substring(s, 1, strlen(s)-1));
		} else {
			s2i(s)
		}
	}

	getMediaCollector = \ -> findmap(wikiStyle, \ws -> switch(ws : WikiParsingStyle) {
			MediaCollector(media) : Some(media);
			default : None();
	});

	parseWikiBlank = \newSyntax -> {
		widthSrc = getNextArg();
		comparisonOptsSrc = getNextArg();
		if (!newSyntax) {
			getNextArg() |> ignore
		}
		decimalTolerance = getNextArg() |> \sDecTol -> if (isNotSpace(sDecTol)) s2i(sDecTol) else -1; //for specific decimal place tolerance: http://process.area9.dk/cases/default.asp?33647
		signForTolerance = getNextArg(); //for $ sign tolerance: http://process.area9.dk/cases/default.asp?33647
		varsNames = getNextArg() |> \vN -> map(strSplit(vN, ","), trim);
		answers = getNextListArg();

		width = {
			defaultWidth = 50.0;
			maxWidth = 500.0;
			minWidth = 10.0;
			widthRaw = if (isNotSpace(widthSrc)) {
				widthSrc |> addScriptHeaderAndFooter |> parseWikiVariables |> getWVSequence |> processWVSequence |> s2d
			} else {
				defaultWidth
			}
			max(minWidth, min(widthRaw, maxWidth))
		}

		matching = {
			comparisonOpts = map(strSplit2WithoutLeave(comparisonOptsSrc, ["|"]), \s -> toLowerCase(strLeft(s, 1)));
			caseSensitive = contains(comparisonOpts, "c");
			exactMatch = contains(comparisonOpts, "e");
			WikiBlankMatchingOptions(caseSensitive, exactMatch, signForTolerance, decimalTolerance)
		}

		answersArray = if (newSyntax) {
			parseAnswerType = \c -> {
				if (c == "+") {
					WikiScoringCorrect() |> Some
				} else if (c == "0") {
					WikiScoringAlmostCorrect() |> Some
				} else if (c == "-") {
					WikiScoringIncorrect() |> Some
				} else {
					None()
				}
			}
			parsedAnswers = filtermap(answers, \a -> {
				typeChar = strLeft(a, 1);
				maybeMap(parseAnswerType(typeChar), \t -> WikiBlankAnswer(strRight(a, 1), t))
			});
			if (length(parsedAnswers) == length(answers)) {
				Some(parsedAnswers)
			} else {
				None()
			}
		} else {
			map(answers, \a -> WikiBlankAnswer(a, WikiScoringCorrect())) |> Some
		}

		answersData = maybeBind(answersArray, \a -> {
			varsCount = length(varsNames);
			if (forall(varsNames, \vn -> isCorrectWVVarName(vn) || !isNotSpace(vn))) {
				makeVarDescription = \pos -> {
					if (0 <= pos && pos < varsCount && isNotSpace(varsNames[pos])) {
						Some(varsNames[pos])
					} else {
						None()
					}
				}

				if (newSyntax) {
					vGeneralCorrectnessMB = makeVarDescription(0);
					vAnswerIndexMB = makeVarDescription(1);
					vIsMisstypedMB = makeVarDescription(2);
					vAnswerTypeMB = makeVarDescription(3);
					vAnswerValueMB = makeVarDescription(4);

					WikiBlankAnswers2Data(
						WikiBlank2Scoring(vGeneralCorrectnessMB, vAnswerIndexMB, vIsMisstypedMB, vAnswerTypeMB, vAnswerValueMB),
						a
					) |> Some
				} else {
					varScore = makeVarDescription(0);
					varNAnswer = makeVarDescription(1);
					varNumVal = makeVarDescription(2);

					WikiBlankAnswersLegacyData(
						WikiBlankLegacyScoring(varScore, varNAnswer, varNumVal),
						a
					) |> Some
				}
			} else {
				None()
			}
		});

		eitherFn(answersData, \a -> v2a(WikiBlankEx(width, matching, a)), sourceAsPlainText)
	}

	element = if (^correctArgs) switch (firstOccurrence.element : WikiTextElement) {
		WikiBaseText(): {
			if (strlen(text) > 0) {
				WikiBaseTextEx(text) |> v2a
			} else {
				[]
			}
		}
		WikiNoWiki() : {
			nowiki = substring(text, i+8, e-i-8-9);
			if (strlen(nowiki) > 0) {
				WikiBaseTextEx(nowiki) |> v2a
			} else {
				[]
			}
		}
		WikiWigi() : {
			nodeText = substring(text, i+6, e-i-6-7);
			maybeApply(getMediaCollector(), \acc -> {
				acc := concat(^acc, either(CallWigiMediaExtractor(nodeText), []))
			});
			WikiWigiEx(nodeText) |> v2a
		}
		WikiAns() : {
			nodeText = substring(text, i + 5, e - i - 5 - 6);
			WikiAnsEx(nodeText) |> v2a
		}
		WikiSmartArt() : {
			nodeText = substring(text, i + 10, e - i - 10 - 11);
			maybeApply(getMediaCollector(), \acc -> {
				media = nodeText |> CallSmartArtCollectMedia;
				acc := concat(^acc, media)
			});
			WikiSmartArtEx(nodeText) |> v2a
		}
		WikiDecoratedImage() : {
			nodeText = substring(text, i + 16, e - i - 16 - 17);
			eitherFn(
				parseImageDecorated2(nodeText),
				\imageDecorated -> {
					maybeApply(getMediaCollector(), \acc -> {
						acc := arrayPush(^acc, imageDecorated.filename)
					});
					WikiDecoratedImageEx(imageDecorated) |> v2a
				},
				sourceAsPlainText
			)
		}
		WikiOneLine() : {
			constructions = substring(text, i + 9, e - i - 9 - 10) |> recCall;
			WikiOneLineEx(constructions) |> v2a
		}
		WikiSpan() : {
			nodeText = substring(text, i, e-i);
			spanTagClose = strIndexOf(nodeText, ">");
			spanAttrs = getXmlNodeAttrs(strLeft(nodeText, spanTagClose)+"/>");
			innerText = substring(nodeText, spanTagClose+1, e-i-spanTagClose-8);

			tooltip = getXmlAttribute(spanAttrs, "title", "") |> htmlUnescapeNL;

			parseFontSizeMultiplier = \st -> {
				if ( endsWith(st, "%") ) Pair(s2d(strLeft(st, strlen(st)-1)) * 0.01, true)
				else if ( st == "smaller" ) Pair(0.83, true)
				else if ( st == "Smaller" ) Pair(0.69, true)
				else if ( st == "larger") Pair(1.2, true)
				else if ( st == "Larger") Pair(1.44, true)
				else Pair(s2d(st), false)
			}

			spanStyle = getXmlAttribute(spanAttrs, "style", "");
			styles = map(strSplit(spanStyle, ";"), \s -> map(strSplit(s, ":"), trim));
			color : Maybe<int> = string2style(styles, "color", parseColor);
			background : Maybe<int> = string2style(styles, "background", parseColor);
			fontFamily : Maybe<string> = string2style(styles, "font-family", idfn);
			fontSizeMultiplier : Maybe<Pair<double, bool>> = string2style(styles, "font-size", parseFontSizeMultiplier);

			WikiSpanEx(
				innerText |> recCall,
				if (isNotSpace(tooltip)) Some(tooltip) else None(),
				color,
				background,
				fontFamily,
				fontSizeMultiplier
			) |> v2a
		}
		WikiTable() : {
			nodeText = substring(text, i, e-i);
			spanTagClose = strIndexOf(nodeText, ">");
			spanAttrs = getXmlNodeAttrs(strLeft(nodeText, spanTagClose)+"/>");
			innerText = substring(nodeText, spanTagClose+1, e-i-spanTagClose-9);

			spanStyle = getXmlAttribute(spanAttrs, "style", "");
			styles = map(strSplit(spanStyle, ";"), \s -> map(strSplit(s, ":"), trim));
			color = string2style(styles, "color", parseColor);
			background = string2style(styles, "background", parseColor);
			border = string2style(styles, "border", \st -> {
				params = map(strSplit(st, " "), trim);
				borderWidth = ref 0.0;
				borderColor = ref 0x000000;
				iter(params, \elem -> {
					if (endsWith(elem, "px"))
						borderWidth := s2d(strLeft(elem, strlen(elem)-2))
					else
						borderColor := parseColor(elem);
				});
				[StrokeWidth(^borderWidth), Stroke(^borderColor)];
			});
			getAligns = \s -> string2style(styles, s, \st -> {
					aligns = strSplit(st, "/");
					additionalAligns = length(aligns) > 1;
					Pair(s2d(aligns[0]), if (additionalAligns) map(strSplit(aligns[1], ","), s2d) else [])
			});

			xAligns = getAligns("xAlign");
			yAligns = getAligns("yAlign");

			vLines = string2style(styles, "vLines", \st -> map(strSplit(st, ","), s2i));
			hLines = string2style(styles, "hLines", \st -> map(strSplit(st, ","), s2i));
			borders = string2style(styles, "cellborders", \st -> map(strSplit(st + ",,,", ","), s2d));
			bracketTypes = string2style(styles, "brackets", \st -> {
				[
					getBracketType(getCharAt(st, 0)),
					getBracketType(getCharAt(st, 1)),
				]
			});

			newWikiTableStyle = WikiTableStyle(
				{
					tempGraphic = eitherMap(background, \k -> arrayPush(tableStyle.graphic, Fill(k)), tableStyle.graphic);
					eitherMap(border, \k -> concat(tempGraphic, k), tempGraphic)
				},
				eitherMap(color, \c -> arrayPush(tableStyle.character, Fill(c)), tableStyle.character),
				eitherMap(xAligns, firstOfPair, 0.0),
				eitherMap(yAligns, firstOfPair, 0.0),
				eitherMap(xAligns, secondOfPair, []),
				eitherMap(yAligns, secondOfPair, []),
				either(vLines, []),
				either(hLines, []),
				eitherMap(bracketTypes, \bt : [WriteBracketType] -> bt[0], WriteNoBracket()),
				eitherMap(bracketTypes, \bt : [WriteBracketType] -> bt[1], WriteNoBracket()),
				eitherMap(borders, \b -> WikiTableCellBorders(b[0], b[1], b[2], b[3]), tableStyle.borders)
			);

			WikiTableEx(
				innerText |> recCall,
				newWikiTableStyle
			) |> v2a
		}
		WikiLearningResource() : {
			lr = substring(text, i + 11, e - i - 11 - 12);
			if (isNotSpace(lr)) {
				sep = "|";
				parts = strSplit(lr, sep);
				data : Pair<string, Maybe<string>> = if (length(parts) == 2) {
					// <lr>New introductory text|id</lr>
					Pair(parts[1], Some(parts[0]))
				} else {
					Pair(lr, None())
				}
				WikiLearningResourceEx(data.first, data.second) |> v2a
			} else {
				sourceAsPlainText()
			}

		}
		WikiDoc() : {
			WikiWriteEx(text) |> v2a
		}
		WikiStory() : {
			writeText = "<doc v=\"1\">" + text + "</doc>";
			WikiWriteEx(writeText)|> v2a
		}
		WikiMedia()  : {
			if (e-i-2 > 0) {
				urlSrc = substring(text, i+1, e-i-2);
				// making IgnoreUnknowPicsTypes as default (case 30879)
				contentType = parseMedia2(urlSrc, true/*contains(wikiStyle, IgnoreUnknowPicsTypes)*/);
				content2Form = \mc : MediaContent2, url : Maybe<string> -> {
					maybeApply(url, \val -> {
						maybeApply(getMediaCollector(), \acc -> {
							acc := arrayPush(^acc, val)
						});
					});
					WikiMediaEx(mc) |> v2a
				}

				switch (contentType : MediaContent) {
					VideoContent(url, options, controls, zoom) : {
						newOptions = if (contains(wikiStyle, SmallContentFillersDuringLoad())) {
							arrayPush(options, SmallVideoSizeDuringLoad())
						} else {
							options
						}
						content2Form(VideoContent(url, newOptions, controls, zoom), Some(url))
					}
					PictureContent(url, __, __) : content2Form(contentType, Some(url));
					ExternalLink(__, __) : content2Form(contentType, None());
					SoundContent(url, __) : content2Form(contentType, Some(url));
					ExpressContent(url, __, __) : content2Form(contentType, Some(toLowerCase(url)));
					NotContent() : recCall("\\[" + urlSrc + "\\]");
				}
			} else {
				WikiBaseTextEx("[]") |> v2a;
			}
		}
		WikiSubscript() : {
			ssText = substring(text, i+1, e-i-2);
			followingTextInsideCurlyBrackets = eitherMap(getArgsList(rest(i + 1), WikiArgsDescription([RequiredArg()]), multilineBlock), \al -> getArgText(al.args[0]), "");
			if (asMathForm && (e-i-2 > 0) || isNotSpace(followingTextInsideCurlyBrackets)) {
				constructions = useFirstTextIfNotEmpty(followingTextInsideCurlyBrackets, ssText) |> recCall;
				WikiSubscriptMathEx(constructions) |> v2a
			} else {
				end := e;
				processFormattingSymbol("_", \src -> WikiSubscriptEx(src)) // this will work with NormalText only
			}
		}
		WikiSuperscript() : {
			ssText = substring(text, i+1, e-i-2);
			followingTextInsideCurlyBrackets = eitherMap(getArgsList(rest(i + 1), WikiArgsDescription([RequiredArg()]), multilineBlock), \al -> getArgText(al.args[0]), "");
			if (asMathForm && (e-i-2 > 0) || isNotSpace(followingTextInsideCurlyBrackets)) {
				constructions = useFirstTextIfNotEmpty(followingTextInsideCurlyBrackets, ssText) |> improveXScriptReadability |> recCall;
				WikiSuperscriptMathEx(constructions) |> v2a
			} else {
				end := e;
				processFormattingSymbol("^", \src -> WikiSuperscriptEx(src)) // this will work with NormalText only
			}
		}
		WikiSubSup() : {
			bodySrc = getNextArg();
			supSrc = getNextArg();
			subSrc = getNextArg();
			left = startsWith(toLowerCase(getNextArg()), "l");
			WikiSubSupEx(recCall(bodySrc), recCall(supSrc), recCall(subSrc), left, getElementsText()) |> v2a
		}
		WikiUnderline() : {
			processFormattingSymbol("+", \src -> WikiUnderlineEx(src))
		}
		WikiBoldItalic() : {
			processFormattingSymbol("***", \src -> WikiBoldItalicEx(recCall(src)))
		}
		WikiBold() : {
			processFormattingSymbol("**", \src -> WikiBoldEx(recCall(src)))
		}
		WikiItalic() : {
			nextChar = getCharAt(text, e);
			fix = isMarkupLetter(nextChar);
			processFormattingSymbol("*", \src -> WikiItalicEx(recCall(src), fix))
		}
		ConditionalWiki(script) : {
			ct = getNextArg() |> addScriptHeaderAndFooter; //condition;
			tt = getNextArg();
			et = getNextArg();
			parseResult = parseWikiVariables(ct);
			if (isCorrectParseResult(parseResult)) {
				condition = parseResult |> getWVSequence;
				if (script) {
					tr = tt |> addScriptHeaderAndFooter |> parseWikiVariables;
					er = et |> addScriptHeaderAndFooter |> parseWikiVariables;
					if (isCorrectParseResult(tr) && isCorrectParseResult(er)) {
						WikiConditionalAssignment(condition, getWVSequence(tr), getWVSequence(er)) |> v2a
					} else {
						sourceAsPlainText()
					}
				} else {
					ConditionalWikiEx(condition, recCall(tt), recCall(et)) |> v2a
				}
			} else {
				sourceAsPlainText()
			}
		}
		MathAssignmentsOnBecameVisible() : {
			pr = getNextArg() |> addScriptHeaderAndFooter |> parseWikiVariables;
			if (isCorrectParseResult(pr)) {
				MathAssignmentsOnBecameVisibleEx(getWVSequence(pr)) |> v2a
			} else {
				sourceAsPlainText()
			}
		}
		WikiWhen() : {
			ct = getNextArg() |> addScriptHeaderAndFooter; //condition;
			tt = getNextArg();
			et = getNextArg();
			parseResult = parseWikiVariables(ct);
			if (isCorrectParseResult(parseResult)) {
				WikiWhenEx(getWVSequence(parseResult), recCall(tt), recCall(et)) |> v2a
			} else {
				sourceAsPlainText()
			}
		}
		WikiEmpty() : {
			[]
		}
		WikiScore() : {
			at = getNextArg(); //condition to show almostCorrect icon
			mt = getNextArg(); //condition to show missing icon
			ct = getNextArg() |> addScriptHeaderAndFooter |> parseWikiVariables; //condition to show correct or incorrect icon
			tooltip = getNextArg();
			vertical = getNextArg() |> isNotSpace;
			inIconTooltip = getNextArg(); //LSTSBU-47

			makeVarsSeqMb = \cond -> {
				if (isNotSpace(cond)) {
					condr = cond |> addScriptHeaderAndFooter |> parseWikiVariables;
					if (isCorrectParseResult(condr)) {
						condr |> getWVSequence |> Some
					} else {
						None()
					}
				} else {
					None()
				};				
			}

			as = at |> makeVarsSeqMb;
			ms = mt |> makeVarsSeqMb;

			if (isCorrectParseResult(ct)) {
				WikiScoreEx(as, ms, getWVSequence(ct), tooltip, vertical, inIconTooltip) |> v2a
			} else {
				sourceAsPlainText()
			}
		}
		WikiCase() : {
			ct = getNextArg() |> addScriptHeaderAndFooter;
			args = getNextListArg();
			parseResult = parseWikiVariables(ct);
			if (isCorrectParseResult(parseResult) && length(args) > 0) {
				WikiCaseEx(getWVSequence(parseResult), map(args, recCall)) |> v2a
			} else {
				sourceAsPlainText()
			}
		}
		WikiDebug() : {
			WikiDebugEx(getNextArg()) |> v2a
		}
		WikiBlank() : {
			parseWikiBlank(false)
		}
		WikiBlank2() : {
			parseWikiBlank(true)
		}
		WikiButton() : {
			defaultWidth = 110.0;
			minWidth = 5.0;
			st = getNextArg(); //width
			ht = getNextArg(); // header
			parseResult = getNextArg() |> addScriptHeaderAndFooter |> parseWikiVariables; // assignments (expected but not restricted to. really any correct script is accepted)
			if (isCorrectParseResult(parseResult)) {
				seq = parseResult |> getWVSequence;
				suggestedWidth = s2d(st);
				width = if (suggestedWidth > 0.0) max(suggestedWidth, minWidth) else defaultWidth;
				WikiButtonEx(ht, seq, width) |> v2a
			} else {
				sourceAsPlainText()
			}
		}
		WikiPicButton() : {
			bt = getNextArg();
			hv = getNextArg();
			pr = getNextArg();
			parseResult = getNextArg() |> addScriptHeaderAndFooter |> parseWikiVariables; // assignments (expected but not restricted to. really any correct script is accepted)
			if (isCorrectParseResult(parseResult)) {
				seq = parseResult |> getWVSequence;
				makeOptPic =  \src -> if (isNotSpace(src)) {
					cs = src |> recCall;
					if (length(cs) > 0) {
						Some(cs)
					} else {
						None()
					}
				} else {
					None()
				}
				eitherFn(makeOptPic(bt), \pic -> WikiPicButtonEx(seq, pic, makeOptPic(hv), makeOptPic(pr)) |> v2a, sourceAsPlainText)
			} else {
				sourceAsPlainText()
			}
		}
		WikiScoringIcon(type) : {
			tooltip = getNextArg();
			WikiScoringIconEx(type, tooltip) |> v2a;
		}
		WikiInlineBullet() : {
			WikiInlineBullet() |> v2a
		}
		WikiNewLine() : {
			WikiNewLine() |> v2a
		}
		WikiCalc() : {
			WikiCalc() |> v2a
		}
		WikiSlider() : {
			defaultSliderLength = 100.0;
			name = getNextArg();
			minSrc = getNextArg() |> addScriptHeaderAndFooter |> parseWikiVariables;
			maxSrc = getNextArg() |> addScriptHeaderAndFooter |> parseWikiVariables;
			stepSrc = getNextArg() |> addScriptHeaderAndFooter |> parseWikiVariables;
			widthSrc = getNextArg() |> addScriptHeaderAndFooter |> parseWikiVariables;
			parameters = [minSrc, maxSrc, stepSrc, widthSrc];
			if (isCorrectWVVarName(name) && all(map(parameters, isCorrectParseResult))) {
				vals = map(parameters, getWVSequence);
				WikiSliderEx(name, vals[0], vals[1], vals[2], vals[3]) |> v2a
			} else {
				sourceAsPlainText()
			}
		}
		WikiForcedExpand() : {
			WikiForcedExpandEx(getNextArg()) |> v2a
		}
		WikiSelect() : {
			args = getNextArg();
			src = getNextArg();
			vars = filter(map(strSplit(args, ","), trim) |> uniq, isCorrectWVVarName);
			cs = recCall(src);
			if (length(cs) > 0) {
				WikiSelectEx(vars, cs) |> v2a
			} else {
				sourceAsPlainText()
			}
		}
		WikiRepeat() : {
			timesSrc = getNextArg() |> addScriptHeaderAndFooter |> parseWikiVariables;
			src = getNextArg();
			if (isCorrectParseResult(timesSrc)) {
				WikiRepeatEx(getWVSequence(timesSrc), recCall(src)) |> v2a
			} else {
				sourceAsPlainText()
			}
		}
		WikiComboBox() : {
			newSizeApproach = getNextArg();
			shuffleSrc = getNextArg();
			varName = getNextArg();
			items = getNextListArg();
			if (isCorrectWVVarName(varName) && length(items) > 0) {
				suggestedWidth = if (isNotSpace(newSizeApproach)) {
					s2d(newSizeApproach)
				} else {
					0.0
				}
				reorderElements = isNotSpace(shuffleSrc);
				WikiComboBoxEx(varName, suggestedWidth, reorderElements, items) |> v2a
			} else {
				sourceAsPlainText()
			}
		}
		WikiRadioButtons() : {
			width = getNextArg() |> addScriptHeaderAndFooter |> parseWikiVariables;
			wrap = getNextArg();
			vertical = getNextArg();
			varName = getNextArg();
			variants = getNextListArg();
			if (isCorrectWVVarName(varName) && isCorrectParseResult(width) && length(variants) > 0) {
				WikiRadioButtonsEx(varName, isNotSpace(wrap), isNotSpace(vertical), getWVSequence(width), map(variants, recCall), variants) |> v2a
			} else {
				sourceAsPlainText()
			}
		}
		WikiTimeline() : {
			defaulttimelineLength = 100.0;
			name = getNextArg();
			loopSrc = getNextArg();
			durationSrc = getNextArg() |> addScriptHeaderAndFooter |> parseWikiVariables;
			maxSrc = getNextArg() |> addScriptHeaderAndFooter |> parseWikiVariables;
			widthSrc = getNextArg() |> addScriptHeaderAndFooter |> parseWikiVariables;
			parameters = [durationSrc, maxSrc, widthSrc];
			if (isCorrectWVVarName(name) && all(map(parameters, isCorrectParseResult))) {
				vals = map(parameters, getWVSequence);
				doLoop = startsWith(toUpperCase(loopSrc), "LOOP");
				maxLoopsCount = eitherMap(
					strIndexOfM(loopSrc, "#"),
					\sp -> substring(loopSrc, sp + 1, strlen(loopSrc) - sp - 1)
						|> addScriptHeaderAndFooter |> parseWikiVariables |> getWVSequence |> processWVSequence |> s2d |> round,
					0
				);
				WikiTimelineEx(name, vals[0], vals[1], vals[2], doLoop, maxLoopsCount) |> v2a
			} else {
				sourceAsPlainText()
			}
		}
		MathSymbol(encoding, sstyle, type) : {
			insertMathSymbol = \ -> {
				styleModificator = if (contains(sstyle, ScriptFont())) {
					\s -> arrayPush(s, FontFamily("MinionItalics"))
				} else if (contains(sstyle, NaturalMathFont())) {
					\s -> arrayPush(s, FontFamily("Minion"))
				} else {
					asDejaVuSans
				}
				WikiSimpleTextEx(encoding, styleModificator([])) |> v2a;
			}
			if (encoding == "&#x222B;") {
				//special case for \int as both \int and \int[from][to]{expression} are correct
				updateArgs(WikiArgsDescription([OptionalArg(""), OptionalArg(""), RequiredArg()]));
				if (^correctArgs) {
					processDefiniteControl(IntegralSign())
				} else {
					insertMathSymbol()
				}
			} else {
				insertMathSymbol()
			}
		}
		MathUserSymbol() : {
			insertSymbolByCode(asDejaVuSans([]))
		}
		UserSymbol() : {
			insertSymbolByCode([])
		}
		ParagraphNbsp() : {
			[GlueFragments(), WikiBaseTextEx(" "), GlueFragments()]
		}
		MathScript() : {
			rest(i) |> parseScript
		}
		MathVariable() : {
			rest(i) |> parseScript
		}
		MathNumber2String() : {
			numberSrc = getNextArg();
			pr = numberSrc |> addScriptHeaderAndFooter |> parseWikiVariables;
			if (isCorrectParseResult(pr)) {
				MathNumber2StringEx(getWVSequence(pr)) |> v2a
			} else {
				sourceAsPlainText()
			}
		}
		MathNumber2SciNot() : {
			numberSrc = getNextArg();
			digitsCountSrc = getNextArg();
			trailingZeroes = isNotSpace(getNextArg());

			numberParseResult = numberSrc |> addScriptHeaderAndFooter |> parseWikiVariables;
			defaultSeq = WV_Sequence([WV_Print([WV_Double("4")])]);
			digitsCountSeq = if (isNotSpace(digitsCountSrc)) {
				pr = digitsCountSrc |> addScriptHeaderAndFooter |> parseWikiVariables;
				if (isCorrectParseResult(pr)) {
					getWVSequence(pr)
				} else {
					defaultSeq
				}
			} else {
				defaultSeq
			}
			if (isCorrectParseResult(numberParseResult)) {
				MathNumber2SciNotEx(getWVSequence(numberParseResult), digitsCountSeq, trailingZeroes) |> v2a
			} else {
				sourceAsPlainText()
			}
		}
		MathNumber2SigDig() : {
			numberSrcTrimmed = getNextArg()	|> trim;
			negative = startsWith(numberSrcTrimmed, "-");
			numberSrc = if (negative) strRight(numberSrcTrimmed, 1) else numberSrcTrimmed;
			srcLen = strlen(numberSrc);

			correctSource = srcLen > 0 && strCountOf(numberSrc, ".") <= 1  && trim2(numberSrc, ".01234567890") == "";
			if (correctSource) {

				dotPos = strIndexOf(numberSrc, ".");
				integerPart = (if (dotPos == -1) {
					numberSrc
				} else {
					strLeft(numberSrc, dotPos)
				}) |> \ip -> {
					ltrim2(ip, "0");
				}

				decimalPart = if (dotPos == -1) {
					""
				} else {
					substring(numberSrc, dotPos + 1, srcLen - dotPos - 1)
				}


				fixEnding = \s -> {
					if (endsWith(s, ".")) {
						strLeft(s, strlen(s) - 1)
					} else {
						s
					}
				}

				ipl = strlen(integerPart);
				dpl = strlen(decimalPart);

				res = if (ipl > 0) {
					ip = if (dotPos != -1) integerPart else rtrim2(integerPart, "0");
					m = getCharAt(ip, 0) + "." + substring(ip, 1, ipl - 1)  + decimalPart |> fixEnding;
					exponent = ipl - 1;
					Pair(m, exponent);
				} else {
					nonZeroPos = strFindFirstOf(decimalPart, "123456789");
					if (nonZeroPos == -1) {
						Pair("", 0)
					} else {
						m = getCharAt(decimalPart, nonZeroPos) + "." + substring(decimalPart, nonZeroPos + 1, dpl - nonZeroPos - 1) |> fixEnding;
						exponent = - (nonZeroPos + 1);
						Pair(m, exponent)
					}
				}
				signS = if (negative) "-" else "";
				if (res.first != "") {
					cs = [
						WikiSimpleTextEx(signS + res.first + " ", []),
						WikiSimpleTextEx("&#215;", asDejaVuSans([])),
						WikiSimpleTextEx(" 10", []),
						WikiSuperscriptEx(i2s(res.second))
					];
					interleave(cs, GlueFragments())
				} else {
					WikiSimpleTextEx("0", []) |> v2a
				}
			} else {
				sourceAsPlainText()
			}
		}
		PredefinedColor(color) : {
			src = getNextArg();
			if (isNotSpace(src)) {
				WikiPredefinedColorEx(color, recCall(src)) |> v2a
			} else {
				sourceAsPlainText()
			}
		}
		MathNaturalSyntax() : {
			eitherFn(
				strIndexOfM(rest(^end),"`"),
				\cb -> {
					beginning = ^end;
					end := ^end + cb + 1;
					MathNaturalSyntaxEx(substring(text, beginning, cb)) |> v2a
				},
				sourceAsPlainText
			)
		}
		MathRoot() : {
			dt = getNextArg() |> recCallAsMath;
			bt = getNextArg() |> recCallAsMath;
			MathRootEx(dt, bt, getElementsText()) |> v2a
		}
		MathLongDivision() : {
			bt = getNextArg() |> recCallAsMath;
			MathLongDivisionEx(bt, getElementsText()) |> v2a
		}
		MathStrike() : {
			dx = getNextArg() |> addScriptHeaderAndFooter |> parseWikiVariables |> getWVSequence;
			dy = getNextArg() |> addScriptHeaderAndFooter |> parseWikiVariables |> getWVSequence;
			bt = getNextArg() |> recCallAsMath;
			colorSrc = getNextArg() |> trim;
			color = if (colorSrc == "red") {
				Some(0xD22D1D)
			} else if (colorSrc == "blue") {
				Some(0x1106f9)
			} else if (colorSrc == "black") {
				Some(0x000000)
			} else if (colorSrc == "green") {
				Some(0x2D8F13)
			} else if (colorSrc == "grey" || colorSrc == "gray") {
				Some(0x898989)
			} else {
				None()
			}
			MathStrikeEx(bt, dx, dy, color, getElementsText()) |> v2a
		}
		WikiUnderline2() : {
			dy = getNextArg() |> addScriptHeaderAndFooter |> parseWikiVariables |> getWVSequence;
			dl = getNextArg() |> addScriptHeaderAndFooter |> parseWikiVariables |> getWVSequence;
			dr = getNextArg() |> addScriptHeaderAndFooter |> parseWikiVariables |> getWVSequence;
			bt = getNextArg();
			if (isNotSpace(bt)) {
				body = bt |> recCall;
				WikiUnderline2Ex(body, dy, dl, dr) |> v2a
			} else {
				sourceAsPlainText()
			}
		}

		WikiRotate() : {
			at = getNextArg();
			bt = getNextArg();
			angleParsed = at |> addScriptHeaderAndFooter |> parseWikiVariables;
			if (isCorrectParseResult(angleParsed)) {
				angle = angleParsed |> getWVSequence;
				body = bt |> recCall;
				WikiRotateEx(body, angle) |> v2a
			} else {
				sourceAsPlainText()
			}
		}
		WikiScale() : {
			st = getNextArg();
			bt = getNextArg();
			scaleParsed = st |> addScriptHeaderAndFooter |> parseWikiVariables;

			if (isCorrectParseResult(scaleParsed)) {
				body = 	bt |> recCall;
				WikiScaleEx(body, getWVSequence(scaleParsed)) |> v2a
			} else {
				sourceAsPlainText()
			}
		}
		WikiMutable() : {
			name = getNextArg();
			WikiMutableEx(name) |> v2a
		}
		MathFrac() : {
			et = getNextArg() |> recCallAsMath;
			dt = getNextArg() |> recCallAsMath;

			MathFracEx(et, dt, getElementsText()) |> v2a
		}
		MathBracket() : {
			lb = getNextArg() |> getBracketType;
			rb = getNextArg() |> getBracketType;
			bt = getNextArg() |> recCallAsMath;

			MathBracketEx(lb, rb, bt, getElementsText()) |> v2a			
		}
		MathSum() : {
			processDefiniteControl(SigmaSign())
		}
		MathProduct() : {
			processDefiniteControl(ProductSign())
		}
		MathIntegral() : {
			processDefiniteControl(IntegralSign())
		}
		MathOverscript() : {
			bt = getNextArg() |> recCallAsMath;
			st = getNextArg() |> recCallAsMath;
			MathScriptEx(MathOverscript(), bt, st, getElementsText()) |> v2a
		}
		MathUnderscript() : {
			bt = getNextArg() |> recCallAsMath;
			st = getNextArg() |> recCallAsMath;
			MathScriptEx(MathUnderscript(), bt, st, getElementsText()) |> v2a
		}
		MathSuperscript() : {
			bt = getNextArg() |> recCallAsMath;
			st = getNextArg() |> recCallAsMath;
			MathScriptEx(MathSuperscript(), bt, st, getElementsText()) |> v2a
		}
		MathSubscript() : {
			bt = getNextArg() |> recCallAsMath;
			st = getNextArg() |> recCallAsMath;
			MathScriptEx(MathSubscript(), bt, st, getElementsText()) |> v2a
		}
		MathDotted() : {
			getDigit = \ -> {
				getNextArg() |> s2i
			}
			sign2bool = \thesign -> thesign == "S" || thesign == "s";
			left = getDigit();
			top = getDigit();
			right = getDigit();
			bottom = getDigit();
			ls = getNextArg() |> sign2bool;
			rs = getNextArg() |> sign2bool;
			bt = getNextArg();
			body   = bt |> recCall;
			MathDottedEx(body, left, top, right, bottom, ls, rs, getElementsText()) |> v2a
		}
		CustomSymbol(symbol) : {
			 CustomSymbol(symbol) |> v2a
		}
		WikiTopModificator(type, size) : {
			source = getNextArg();
			dyS = getNextArg() |> addScriptHeaderAndFooter |> parseWikiVariables;
			dlS = getNextArg() |> addScriptHeaderAndFooter |> parseWikiVariables;
			dxS = getNextArg() |> addScriptHeaderAndFooter |> parseWikiVariables;
			parameters = [dyS, dlS, dxS];
			if (all(map(parameters, isCorrectParseResult))) {
				vals = map(parameters, getWVSequence);
				naturalMath = startsWith(source, "`");
				body = source |> recCall;
				WikiTopModificatorEx(type, size, body, vals[0], vals[1], vals[2], naturalMath) |> v2a
			} else {
				sourceAsPlainText()
			}
		}
		WikiDraggable() : {
			idS = getNextArg() |> addScriptHeaderAndFooter |> parseWikiVariables;
			dwS = getNextArg() |> addScriptHeaderAndFooter |> parseWikiVariables;
			dhS = getNextArg() |> addScriptHeaderAndFooter |> parseWikiVariables;

			wikiS = getNextArg();
			strokeShapeS = getNextArg();
			fillShapeS = getNextArg();
			shapeS = getNextArg();
			feedbackS = getNextArg();

			strkS = strokeShapeS |> addScriptHeaderAndFooter |> parseWikiVariables;
			flS = fillShapeS |> addScriptHeaderAndFooter |> parseWikiVariables;

			parameters = [idS, dwS, dhS, strkS, flS];
			if (all(map(parameters, isCorrectParseResult))) {
				vals = map(parameters, getWVSequence);
				WikiDraggableEx(recCall(wikiS), recCall(shapeS), recCall(feedbackS), strokeShapeS, fillShapeS, vals[0], vals[1], vals[2], vals[3], vals[4]) |> v2a
			} else {
				sourceAsPlainText()
			}
		}
		WikiDroptarget() : {
			idS = getNextArg() |> addScriptHeaderAndFooter |> parseWikiVariables;
			dwS = getNextArg() |> addScriptHeaderAndFooter |> parseWikiVariables;
			dhS = getNextArg() |> addScriptHeaderAndFooter |> parseWikiVariables;
			varName = getNextArg();
			wikiS = getNextArg();
			strokeShapeS = getNextArg();
			fillShapeS = getNextArg();
			feedbackS = getNextArg();

			stkS = strokeShapeS |> addScriptHeaderAndFooter |> parseWikiVariables;
			flS = fillShapeS |> addScriptHeaderAndFooter |> parseWikiVariables;

			parameters = [idS, dwS, dhS, stkS, flS];
			if (all(map(parameters, isCorrectParseResult)) && isCorrectWVVarName(varName)) {
				vals = map(parameters, getWVSequence);
				WikiDroptargetEx(varName, recCall(wikiS), recCall(feedbackS), strokeShapeS, fillShapeS, vals[0], vals[1], vals[2], vals[3], vals[4]) |> v2a
			} else {
				sourceAsPlainText()
			}
		}
		WikiPopup() : {
			wd = getNextArg() |> addScriptHeaderAndFooter |> parseWikiVariables;
			ht = getNextArg() |> addScriptHeaderAndFooter |> parseWikiVariables;
			hA = getNextArg() |> addScriptHeaderAndFooter |> parseWikiVariables;
			vA = getNextArg() |> addScriptHeaderAndFooter |> parseWikiVariables;
			txt = getNextArg();
			gS = getNextArg(); //optional, graphic style, for future

			parameters = [wd, ht, hA, vA];
			if (all(map(parameters, isCorrectParseResult))) {
				vals = map(parameters, getWVSequence);
				WikiPopupEx(recCall(txt), vals[0], vals[1], vals[2], vals[3]) |> v2a
			} else {
				sourceAsPlainText()
			}
		}
		WikiLimiter() : {
			vars = getNextArg();
			resVar = getNextArg();
			cond = getNextArg();
			value = getNextArg() |> addScriptHeaderAndFooter |> parseWikiVariables;
			if (isCorrectParseResult(value)) {
				makeVarsArray = \str : string -> strSplit(str, ",");
				varsArr = vars |> makeVarsArray;
				WikiLimiterEx(varsArr, resVar, cond, getWVSequence(value)) |> v2a;
			} else {
				sourceAsPlainText()
			}
		}
		WikiMessagesCollector() : {
			otherAnswer = getNextArg();
			var = getNextArg();
			correctAnswers = getNextListArg();
			if (isNotSpace(var)) {
				realVar = if (isCorrectWVVarName(var)) var else "$" + var;
				WikiMessagesCollectorEx(otherAnswer, realVar, correctAnswers) |> v2a;
			} else {
				sourceAsPlainText()
			}
		}
		WikiAltTextCollector() : {
			altText = getNextArg();
			if (isNotSpace(altText)) {
				WikiAltTextCollectorEx(altText) |> v2a;
			} else {
				sourceAsPlainText()
			}
		}
		MathUnknownConstruction(representation) : {
			MathUnknownConstruction(representation) |> v2a
		}
	} else {
		sourceAsPlainText()
	}


	if(^correctArgs && ^argsUsed != ^argsCount) {
		if (isDevMode()) println(firstOccurrence.element.structname + " usage of args in code is incosistent with list of args");
	}

	// Put elements into WikiSimple constructions if necessary
	encapsulate = \cond, txt -> \elements -> {
		if (cond && length(elements) > 0) {
			WikiSimpleConstructions(elements, txt) |> v2a
		} else {
			elements
		}
	}

	prefixConstructions = if (i > 0) {
		lastPrefixChar = getCharAt(text, i - 1);
		txt = strLeft(text, i);
		WikiBaseTextEx(txt) |> v2a |> restrictLineBreak(lastPrefixChar) |> encapsulate(true, txt)
	} else {
		[]
	};
	tail_ = rest(^end);
	suffixConstructions = if (strlen(tail_) > 0) recCall(tail_) else [];

	elementConstructions = element |> restrictLineBreak(getCharAt(text, ^end)) |> encapsulate(all(map(element, isSimpleWikiConstruction)), getElementsText());


	constructions = [
		prefixConstructions,
		elementConstructions,
		suffixConstructions
	];

	constructions |> concatA |> mergeSimpleConstructions
}


// Assumption: acc is non empty WikiSimpleConstructions
mergeSimpleConstructionsEx(constructions : [WikiConstruction], acc : WikiSimpleConstructions) -> [WikiConstruction] {
	if (length(constructions) == 0) {
		acc |> v2a
	} else {
		switch(constructions[0] : WikiConstruction) {
			WikiSimpleConstructions(cs, src) : {
				mergeSimpleConstructionsEx(tail(constructions), WikiSimpleConstructions(concat(acc.constructions, cs), acc.src + src))
			}
			default : {
				concat([acc], constructions)
			}
		}
	}
}

mergeSimpleConstructions(constructions : [WikiConstruction]) -> [WikiConstruction] {
	if (length(constructions) == 0) {
		[]
	} else {
		switch(constructions[0] : WikiConstruction) {
			WikiSimpleConstructions(cs, src) : {
				mergeSimpleConstructionsEx(tail(constructions), WikiSimpleConstructions(cs, src))
			}
			default : {
				constructions
			}
		}
	}
}

getXmlNodeAttrs(xml) {
	events : DynamicBehaviour<XmlEvent> = make(XmlEndEvent());
	list = ref makeList();
	us = subscribe2(events, \e -> {
		switch(e : XmlEvent) {
		XmlEmptyElement(tag, attributes) :
			list := Cons(attributes, ^list);
		XmlElementStart(tag, attributes) :
			list := Cons(attributes, ^list);
		default : {}
		}
	});
	parseXml(xml, events);
	us();
	list2array(^list) |> concatA
}

htmlUnescapeNL(s) {
	r = \to,from -> \t -> strReplace(t, from, to);
	s
	|> unescapeHtml
	|> r("\n", "<br/>")
	|> r("\n", "<br />")
}

string2style(styles : [[string]], styleName : string, fn : (string) -> ?) -> Maybe<?> {
	eitherMap(find(styles, \st : [string] -> st[0] == styleName), \st -> if (length(st) > 1) Some(fn(st[1])) else None(), None());
}

