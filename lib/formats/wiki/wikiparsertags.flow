import formats/wiki/wikitextelement;
import trie;

export {
	// finds first wiki tag and closing tag inside wiki src
	findFirstWikiTag(text:string) -> WikiOccurrence;

	isBaseWikiText(text : string) -> bool;

	WikiOccurrence : (start : int, end : int, element : WikiTextElement, args : Maybe<WikiArgsDescription>);
}

//Processes texts that are considered as simple text by Wiki lexer.
wikiTextLexer : ref Maybe<Trie> = ref None();

findFirstWikiTag(text : string) -> WikiOccurrence {
	trie : Trie = onlyOnce(wikiTextLexer, prepareWikiTextLexer);
	lookup : TrieCharwiseSearchProcess = charwiseLookupTrie(trie);
	//list of chars that can start construction
	firstChars = "\\<`{$[*_^+";
	len = strlen(text);
	//TODO:replace with more quick implementation of strFindFirstOf.
	newPos = \seacrhFrom -> {
		pos = strFindFirstOf(strRight(text, seacrhFrom), firstChars);
		Pair(if (pos != -1) pos + seacrhFrom else pos, WikiOccurrence(0, len, WikiBaseText(), None()));
	}
	successfulStop = \start, end, type, args -> {
		Pair(-1, WikiOccurrence(start, end, type, args));
	}
	for(newPos(0), unpairC(\start, result -> start !=-1), unpairC(\start, result -> {
		lookup.reset();
		startedWithSlash = (getCharAt(text, start) == "\\");
		triple = for(
			Triple(start, true, Pair(-1, start)),
			untripleC(\pos, isPrefix, maxKeyAndPrefixEndPos -> pos < len && isPrefix),
			untripleC(\pos, isPrefix, maxKeyAndPrefixEndPos : Pair<int, int> -> {
				currentChar = getCharAt(text, pos);
				sr = lookup.update(currentChar);
				stillPrefix = sr.isPrefix
							|| startedWithSlash && maxKeyAndPrefixEndPos.first == -1 && (isLetter(currentChar) || isDigit(currentChar)); //  \ABC construction should be shown in Wigi as comment.
				Triple(
					pos + 1,
					stillPrefix,
					Pair(
						if (sr.isKey) pos else maxKeyAndPrefixEndPos.first,
						if (stillPrefix) pos else maxKeyAndPrefixEndPos.second
					)
				)
			})
		);
		longetsStartSequenceData = triple.third;
		longetsStartSequenceEnd = longetsStartSequenceData.first;
		longestProcessedPrefixEnd = longetsStartSequenceData.second;
		if (longetsStartSequenceEnd != -1) {
			sequence = substring(text, start, longetsStartSequenceEnd - start + 1);
			eitherFn(
				lookupTrie(trie, sequence),
				\descriptor -> {
					switch (descriptor : WikiTextElementDescription) {
						WikiNestedStruct(ot, ct, mt, type): {
							eitherFn(
								findClosingTagM(strRight(text, start), ot, ct, mt),
								\se -> successfulStop(start + se.first, start + se.second, type, None()),
								\ -> newPos(start + 1)
							)
						}
						WikiFlatStruct(ot, ct, type): {
							eitherFn(
								findMatchingPairM(strRight(text, start), ot, ct),
								\se -> successfulStop(start + se.first, start + se.second, type, None()),
								\ -> newPos(start + 1)
							)
						}
						TeXLikeElement(representation, type, args): {
							successfulStop(start, start + strlen(representation), type, args)
						}
					}
				},
				\ -> newPos(start + 1)
			)
		} else if (startedWithSlash && longestProcessedPrefixEnd > start) {
			// We found sequence of '\' followed by letters and digits and no prefix is known TeXLikeElement
			firstCharAfterPrefixPos = longestProcessedPrefixEnd + 1;
			successfulStop(start, firstCharAfterPrefixPos, MathUnknownConstruction(strSubRange(text, start, firstCharAfterPrefixPos)), None())
		} else {
			newPos(start + 1)
		}
	})).second
}

prepareWikiTextLexer() -> Trie {
	getStartSequence = \sd -> {
		switch (sd : WikiTextElementDescription) {
			WikiNestedStruct(start, __, __, __) : start;
			WikiFlatStruct(start, __, __) : start;
			TeXLikeElement(representation, __, args) : representation;
		}
	};

	descriptors = [
			WikiNestedStruct("<s v", "</s>", ["<s>", "<s "], WikiStory()), //write source. Can contain nested <s>
			WikiNestedStruct("<smartart>", "</smartart>", ["<smartart>"], WikiSmartArt()),
			WikiFlatStruct("<ans>", "</ans>", WikiAns()),
			WikiFlatStruct("<nowiki>", "</nowiki>", WikiNoWiki()),
			WikiFlatStruct("<decoratedimage>", "</decoratedimage>", WikiDecoratedImage()),
			WikiFlatStruct("<lresource>", "</lresource>", WikiLearningResource()), // learning resource
			WikiFlatStruct("<span", "</span>", WikiSpan()), // color
			WikiFlatStruct("<doc", "</doc>", WikiDoc()), // write source. Cannot contain nested <doc>
			WikiFlatStruct("<oneline>", "</oneline>", WikiOneLine()), //replacement for non breaking spaces
			WikiFlatStruct("<table", "</table>", WikiTable()), // table style
			WikiFlatStruct("[", "]", WikiMedia()),   // media
			WikiFlatStruct("*", "*", WikiItalic()),   // italic
			WikiFlatStruct("**", "**", WikiBold()), // bold
			WikiFlatStruct("***", "***", WikiBoldItalic()), // bold italic
			WikiFlatStruct("_", "_", WikiSubscript()),   // subscript
			WikiFlatStruct("^", "^", WikiSuperscript()),   // superscript
			WikiFlatStruct("+", "+", WikiUnderline()),   // underline
			WikiFlatStruct("<wigi>", "</wigi>", WikiWigi())
	];

	fold(concat(descriptors, supportedTeXLikeElements()), makeTrie(), \trie, descriptor -> {
		addTrie(trie, getStartSequence(descriptor), descriptor)
	})
}

isBaseWikiText(text : string) -> bool {
	firstOccurrence = findFirstWikiTag(text);
	switch (firstOccurrence.element) {
		WikiBaseText(): {
			firstOccurrence.start == 0 && firstOccurrence.end == strlen(text)
		}
		default : false
	}
}
