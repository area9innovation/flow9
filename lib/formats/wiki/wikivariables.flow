// Â© Copyright 2012 Area9 Innovation. All rights reserved

import ds/tree;
import behaviour;
import runtime;
import stringmath;
import ds/set;
import flowutils; // isTest

import lingo/peg;
import lingo/pegaction;
import lingo/pegcode/driver;


/* Example of usage

 formula = "{$x = Random(); $x}";
 parsingResult = parseWikiVariables(formula);
 switch(parsingResult : WV_ParseResult) {
	WV_CorrectResult(sequence, remainder) {
		if (remainder == "") {
			// do all the side effects and
			// return string value of result.
			// If formula contais only assignments
			// result is an empty string.
			s = processWVSequence(sequence);
		} else {
			//can be considered as unsuccessful case
			//or a case requiring recursive call
		}

	}
	WV_RemainderOnly(remainder) : {
		//unsuccessful
	}
 }

*/

/*
WikiVars is the name of a simple, embedded expression language which are embedded
in all wiki-text.
*/

export {
	// Parse an program using the grammar of lingo/wiki_variables.lingo
	parseWikiVariables : (src : string) -> WV_ParseResult;

	/* Data structures for variables in wiki */
	WV_ParseResult ::= WV_CorrectResult, WV_RemainderOnly;
		WV_CorrectResult : (sequence : WV_Sequence, remainder : WV_String);
		WV_RemainderOnly : (remainder : WV_String);
	WV_Sequence : (statements : [WV_Statement]);
	WV_Statement ::= WV_Assignment, WV_Print;

	WV_Assignment : (v : WV_NumVar, expression : WV_StandaloneExpression);
	WV_Print : (expressions : [WV_Printable]);

	WV_Printable ::= WV_StandaloneExpression, WV_String;

	WV_Expression ::= WV_Add, WV_Mult, WV_StandaloneExpression;
	WV_StandaloneExpression ::= WV_Double, WV_NumVar, WV_Additive, WV_Multiplicative, WV_Uminus, WV_FunCall, WV_Exponent, WV_ExponentIndex, WV_LogicalExpression;
		WV_Double : (s: string);
		WV_NumVar : (name: string);
		WV_Additive : (expressions: [WV_Expression]);
		WV_Multiplicative : (expressions: [WV_Expression]);
		WV_Add : (sign : string, expression : WV_Expression);
		WV_Mult : (sign : string, expression : WV_Expression);
		WV_Uminus (expression : WV_Expression);
		WV_FunCall (name : string, args : [WV_Expression]);
		WV_String (s : string);
		WV_ExponentIndex (expression : WV_Expression);
		WV_Exponent (expression : WV_Expression, expressions:[WV_Expression]);
	WV_LogicalExpression ::= WV_Comparison;
		WV_Comparison (left : WV_StandaloneExpression, right : WV_StandaloneExpression, sign : ComparisonOp);
		ComparisonOp ::= WV_EQ, WV_NE, WV_GE, WV_GT, WV_LE, WV_LT;
			WV_EQ : ();
			WV_NE : ();
			WV_GE : ();
			WV_GT : ();
			WV_LE : ();
			WV_LT : ();

	// Processes sequence of wiki internal language statements from left to right
	// to make side effects and returns concatenation of all outputs
	processWVSequence(seq : WV_Sequence) -> string;

	// Convert WV_Sequence to string
	wv_sequence2string(sequence: WV_Sequence) -> Pair<string, [string]>;

	WV_Environment : (
		doubles : ref Tree<string, DynamicBehaviour<double>>,
		functions : ref Tree<string, (([double]) -> double)>,
		sfunctions : ref Tree<string, (([double]) -> string)>
	);

	// The variables mentioned in the wikivar code is captured in a global environment
	getGlobalWVEnvironment() -> WV_Environment;

	// Returns new empty environment
	defaultWVEnvironment() -> WV_Environment;
	
	resetWVEnvironmentDoubles() -> void;

	// Initialize the built-in functions
	initWVFunctions(env : WV_Environment) -> void;

	// Initialize the constants
	initWVConstants(env : WV_Environment) -> void;

	// Execute all wiki vars in the entire string
	processWikiVarsInWholeString : (ss : string) ->  string;

	// Execute all wiki vars in the entire string. Assignments are ignored.
	processWikiVarsInWholeStringPreserveOldValues : (ss : string) ->  string;

	isCorrectParseResult(pr : WV_ParseResult) -> bool;

	getWVSequence(pr : WV_ParseResult) -> WV_Sequence;

	getDoubleVarBehaviour(environment : WV_Environment, name : string) -> DynamicBehaviour<double>;
	removeDoubleVar(env : WV_Environment, name : string) -> void;

	//Checks for correctness of name not for existance.
	isCorrectWVVarName(name : string) -> bool;

	WithVarLoggingFunction(logFn : ((string, double, bool) -> void), action : () -> void, passToPrev : bool) -> void;
	WithVarsAssignments(doAssignments: bool) -> ((() -> ?) -> ?);

	// The family of functions below do not know semantics of Wiki.
	// \fillblank{$a}[answer 1][answer 2] gives $a in the set of variables to read.
	// But really it is write only.
	// So, code which introduces rerendering based on list of variables fails. Example - #37571.
	// To fix it we need to implement something like collectWikiMedia, but if mediaCollector requires
	// actions in 2 or 3 cases of WikiConstruction switch, this one requires actions in almost all the cases.
	// So, for now it is workarounded by hack.
	GetAllTheUsedVars(seq : WV_Sequence) -> WikiVarsList;
	GetAllTheUsedVars2(src : string) -> WikiVarsList;
	GetAllTheUsedVarsEx(action : () -> void) -> WikiVarsList; // Action - an fn that uses var related functions
	wikiVarsList2array(varsList : WikiVarsList) -> [string];
	WikiVarsList(read : Set<string>, write : Set<string>);

	evalWikiExpression(src : string) -> double;

	// Conditions to be used with SmartArt
	buildWikiConditionSrc(condition : SaWikiGeneralCondition) -> string;
	SaWikiGeneralCondition ::= SaWikiCondition, SaWikiComparison, SaWikiTrue, SaWikiFalse;
	SaWikiCondition ::= SaWikiBoolCondition, SaWikiSwitch;
	SaWikiBoolCondition ::= SaWikiOr, SaWikiAnd, SaWikiCustomCondition;


	SaWikiComparison : (varName : string, value : double, operation : ComparisonOp);
	SaWikiOr : (conditions : [SaWikiBoolCondition]);
	SaWikiAnd : (conditions : [SaWikiBoolCondition]);
	SaWikiCustomCondition(condition : string);
	SaWikiSwitch : (varName : string);
	SaWikiTrue();
	SaWikiFalse();

	IsComparisonOp(seq : WV_Sequence) -> (op : ComparisonOp) -> bool;
	IsComparisonValue(seq : WV_Sequence) -> (val : double) -> bool;

	wikiRandomCallsCounter : Behaviour<int>;
}

_wikiRandomCallsCounter = make(0);
wikiRandomCallsCounter = cast(_wikiRandomCallsCounter : DynamicBehaviour<int> -> Behaviour<int>);


defaultWVEnvironment() -> WV_Environment {
	WV_Environment(
		ref makeTree(),
		ref makeTree(),
		ref makeTree()
	)
}

wiki_env = defaultWVEnvironment();

resetWVEnvironmentDoubles() -> void {
	wiki_env.doubles := makeTree();
	initWVConstants(wiki_env);
}

wvVarsLoggingFunctionSet = ref false;
logWVVarUsage = ref \name : string, val : double, write : bool -> {};

allowWikiVarsAssignment = ref true;

WithVarLoggingFunction(logFn, action, passToPrev) {
	oldLoggingFn = ^logWVVarUsage;
	oldLoggingState = ^wvVarsLoggingFunctionSet;

	restoreLoggingState = \ -> {
		logWVVarUsage := oldLoggingFn;
		wvVarsLoggingFunctionSet := oldLoggingState;
	}

	logWVVarUsage := \name, val, write -> {
		if (passToPrev) {
			oldLoggingFn(name, val, write);
		}
		logFn(name, val, write)
	};
	wvVarsLoggingFunctionSet := true;
	action();
	restoreLoggingState();
}

WithVarsAssignments(doAssignments : bool) -> ((() -> ?) -> ?) {
	\action -> {
		restoreOldState = {
			oldAllowAssignments = ^allowWikiVarsAssignment;
			allowWikiVarsAssignment := doAssignments;
			\ -> {
				allowWikiVarsAssignment := oldAllowAssignments;
			}
		}
		result = action();
		restoreOldState();
		result
	}
}

UseVarLogginFunction(name, mval) {
	val = switch (mval : Maybe) {
		Some(newVal) : {
			// writing
			newVal
		}
		None() : {
			// reading
			getDoubleVarValue(wiki_env, name)
		}
	}
	^logWVVarUsage(name, val, isSome(mval))
}

toStringWV(v) d2st(v, 8);

getGlobalWVEnvironment() -> WV_Environment {
	wiki_env
}

initWVConstants(env : WV_Environment) {
	env.doubles := setTree(^(env.doubles), "$PI", make(PI));
}

initWVFunctions(env : WV_Environment) {
	//make ((double) -> double) (([double]) -> double)
	useFirstElementOfArrayArg = \fn -> {
		\args -> {
			if (length(args) == 1) {
				fn(args[0])
			} else {
				0.0;
			}
		}
	}

	//make ((double, double) -> double) (([double]) -> double)
	useFirstTwoElementsOfArrayArg = \fn -> {
		\args -> {
			if (length(args) == 2) {
				fn(args[0], args[1])
			} else {
				0.0;
			}
		}
	}

	//make ((double) -> int) ((double) -> double)
	resultToDouble = \fn -> \arg -> fn(arg) |> i2d;

	_decimals = \args -> {
		if (length(args) == 1) {
			round(args[0]) |> i2d
		} else if ((length(args) == 2)) {
			digits = trunc(args[1]);
			if (digits == 0) {
				round(args[0]) |> i2d
			} else if (digits > 0) {
				roundDecimals(args[0], digits)
			} else {
				0.0
			}
		} else {
			0.0
		}
	}

	_decimalsS = \args -> {
		if (length(args) == 1) {
			round(args[0]) |> i2s
		} else if ((length(args) == 2)) {
			digits = trunc(args[1]);
			if (digits == 0) {
				round(args[0]) |> i2s
			} else if (digits > 0) {
				decimals(args[0], digits, true)
			} else {
				""
			}
		} else {
			""
		}
	}

	randomFnEx = if (isTest()) {
		\ -> 0.5
	} else {
		random
	}
	randomFn = \ -> {
		next(_wikiRandomCallsCounter, getValue(_wikiRandomCallsCounter) + 1);
		randomFnEx()
	}

	randomTo = \to -> {
		randomFn() * to;
	}

	randomFromTo = \from, to -> {
		from + randomTo(to-from);
	}

	randomFromToPrecision = \from, to, precision -> {
		_decimals([randomFromTo(from, to), precision]);
	}

	// workaround for recursive lambda calls
	randomExceptEx : ref ((double, double, double, [double]) -> double) = ref \from, to, precision, restrictedList -> 0.0;

	randomExcept = \from, to, precision, restrictedList -> {
		if (from == to && contains(restrictedList, from)) {
			0.0/0.0
		} else {
			val = randomFromToPrecision(from, to, precision);
			if (forall(restrictedList, neq(val))) {
				val
			} else {
				if (!isTest()) {
					(^randomExceptEx)(from, to, precision, restrictedList)
				} else {
					from
				}
			}
		}
	}

	randomExceptEx := randomExcept;

	randomSiginificantDigits = \digitsCount -> {
		r = ref round(randomFromToPrecision(1.0, 9.0, 0.0));
		maxSignificantDigitsCount = 9;
		fori(2, min(trunc(digitsCount), maxSignificantDigitsCount), \i -> r := ^r * 10 + round(randomFromToPrecision(1.0, 9.0, 0.0)));
		i2d(^r)

	}

	randomSign = \__ -> {
		i2d(-1 + round(randomFn()) * 2)
	}

	rnd = \args -> {
		implementations = [
			\ -> randomFn(),
			\ -> randomTo(args[0]),
			\ -> randomFromTo(args[0], args[1]),
			\ -> randomFromToPrecision(args[0], args[1], args[2]),
			\ -> {
				restrictedList = map(subrange(args, 3, length(args) - 3), \d -> _decimals([d, args[2]]));
				randomExcept(args[0], args[1], args[2], restrictedList)
			}
		];
		implementationsCount = length(implementations);
		implId = min(length(args), implementationsCount - 1);
		implementations[implId]()
	}

	_tan = \x -> {
		sin(x) / cos(x)
	}

	_tans = \args -> {
		x = args[0];
		cs = cos(x);
		if (equalDoubles(cs, 0.0)) {
			"Undefined"
		} else {
			sin(x) / cs |> toStringWV
		}
	}

	env.functions := setTree(^(env.functions), "RANDOM", rnd);
	env.functions := setTree(^(env.functions), "RANDOMSIGN", randomSign);
	env.functions := setTree(^(env.functions), "RANDOMSIGNIFICANTDIGITS" , randomSiginificantDigits |> useFirstElementOfArrayArg);
	env.functions := setTree(^(env.functions), "TRUNC" , trunc |> resultToDouble |> useFirstElementOfArrayArg);
	env.functions := setTree(^(env.functions), "CEIL"  , ceil  |> resultToDouble |> useFirstElementOfArrayArg);
	env.functions := setTree(^(env.functions), "FLOOR" , floor |> resultToDouble |> useFirstElementOfArrayArg);
	env.functions := setTree(^(env.functions), "ROUND" , round |> resultToDouble |> useFirstElementOfArrayArg);
	env.functions := setTree(^(env.functions), "DECIMALS" , _decimals);
	env.functions := setTree(^(env.functions), "SQRT" , sqrt |> useFirstElementOfArrayArg);
	env.functions := setTree(^(env.functions), "MAX" , max |> useFirstTwoElementsOfArrayArg);
	env.functions := setTree(^(env.functions), "MIN" , min |> useFirstTwoElementsOfArrayArg);
	env.functions := setTree(^(env.functions), "MOD" , dmod |> useFirstTwoElementsOfArrayArg);
	env.functions := setTree(^(env.functions), "LOG" , log |> useFirstElementOfArrayArg);
	env.functions := setTree(^(env.functions), "SIN" , sin |> useFirstElementOfArrayArg);
	env.functions := setTree(^(env.functions), "COS" , cos |> useFirstElementOfArrayArg);
	env.functions := setTree(^(env.functions), "TAN" , _tan |> useFirstElementOfArrayArg);
	env.functions := setTree(^(env.functions), "ASIN" , asin |> useFirstElementOfArrayArg);
	env.functions := setTree(^(env.functions), "ACOS" , acos |> useFirstElementOfArrayArg);
	env.functions := setTree(^(env.functions), "ATAN" , atan |> useFirstElementOfArrayArg);
	env.functions := setTree(^(env.functions), "ABS" , abs |> useFirstElementOfArrayArg);

	env.sfunctions := setTree(^(env.sfunctions), "DECIMALS", _decimalsS);
	env.sfunctions := setTree(^(env.sfunctions), "TAN", _tans);
	//env.sfunctions := setTree(^(env.sfunctions), "TOSTRING" , toString |> useFirstElementOfSArrayArg);

}

initWVGrammar() -> [PegOp] {
	initWVFunctions(wiki_env);
	initWVConstants(wiki_env);
	wvSrc = "#include lingo/wiki_variables.lingo";
	compilePegGrammar(wvSrc);
}

wvCombined : ref Maybe<[PegOp]> = ref None();

parseWikiVariables(src) {
	grammar = onlyOnce(wvCombined, initWVGrammar);
	parsic(grammar, src, defaultPegActions);
}

getDoubleVarBehaviour(env : WV_Environment, name : string) -> DynamicBehaviour<double> {
	switch(lookupTree(^(env.doubles), name) : Maybe) {
		None(): {
			newVar = make(0.0);
			env.doubles := setTree(^(env.doubles), name, newVar);
			newVar
		}
		Some(v) : v;
	}
}

removeDoubleVar(env : WV_Environment, name : string) -> void {
	env.doubles := removeFromTree(^(env.doubles), name);
}

getDoubleVarValue(env : WV_Environment, name : string) -> double {
	getDoubleVarBehaviour(env, name) |> getValue
}


setDoubleVarValue(env : WV_Environment, name : string, val : double) -> void {
	switch(lookupTree(^(env.doubles), name) : Maybe) {
		None(): {
			newVar = make(val);
			env.doubles := setTree(^(env.doubles), name, newVar);
		}
		Some(v) : nextDistinct(v, val);
	}
}

// Returns false for WV_Add("-", <expr>) and WV_Mult("/", expr<>)
isNextActionDefault(expr : WV_Expression) {
	switch(expr: WV_Expression) {
		WV_Add(thesign, expression) : thesign == "+";
		WV_Mult(thesign, expression) : thesign == "*";
		default : true;
	}
}

getExpressionNumericValue(env : WV_Environment, expr : WV_Expression) -> double {
	switch(expr: WV_Expression) {
		WV_Double (s) : s2d(s);
		WV_NumVar (name) : {
			if (^wvVarsLoggingFunctionSet) {
				UseVarLogginFunction(name, None())
			}
			getDoubleVarValue(env, name);
		}
		WV_Additive (expressions) : {
			fold(
				expressions,
				Pair(0.0, true),
				\acc, e -> {
					nextAction = isNextActionDefault(e);
					val = getExpressionNumericValue(env, e);
					currSum = if (acc.second) {
						acc.first + val
					} else {
						acc.first - val
					}
					Pair(currSum, nextAction)
				}
			) |> firstOfPair;
		}
		WV_Multiplicative (expressions) : {
			fold(
				expressions,
				Pair(1.0, true),
				\acc, e -> {
					nextAction = isNextActionDefault(e);
					val = getExpressionNumericValue(env, e);
					currProduct = if (acc.second) {
						acc.first * val
					} else {
						acc.first / val
					}
					Pair(currProduct, nextAction)
				}
			) |> firstOfPair;
		}
		WV_Add (thesign, expression) : {
			getExpressionNumericValue(env, expression)
		}
		WV_Mult (thesign, expression) : {
			getExpressionNumericValue(env, expression)
		}
		WV_Uminus (expression) : -getExpressionNumericValue(env, expression);
		WV_ExponentIndex (expression) : getExpressionNumericValue(env, expression);
		WV_Exponent (expression, expressions) : {
				fold(
					expressions,
					getExpressionNumericValue(env, expression),
					\base, index -> dpow(base, getExpressionNumericValue(env, index))
				);
		}
		WV_FunCall (name, args) : {
			eitherMap(
				lookupTree(^(env.functions), toUpperCase(name)),
				\fun -> {
					fun(map(args, \arg -> getExpressionNumericValue(env, arg)))
				},
				0.0
			)
		}
		WV_Comparison(left, right, comparisonOp) : {
			leftVal = getExpressionNumericValue(env, left);
			rightVal = getExpressionNumericValue(env, right);
			switch(comparisonOp : ComparisonOp) {
				WV_EQ() : equalDoubles(leftVal, rightVal) |> b2d;
				WV_NE() : !equalDoubles(leftVal, rightVal) |> b2d;
				WV_GE() : geqDoubles(leftVal, rightVal) |> b2d;
				WV_GT() : !leqDoubles(leftVal, rightVal) |> b2d;
				WV_LT() : !geqDoubles(leftVal, rightVal) |> b2d;
				WV_LE() : leqDoubles(leftVal, rightVal) |> b2d;
			}
		}
	}
}

getExpressionStringValue(env : WV_Environment, expression : WV_StandaloneExpression) -> string {
	getExpressionNumericValue(env, expression) |> toStringWV
}

getPrintableStringValue(env : WV_Environment, printable : WV_Printable) -> string {
	switch (printable : WV_Printable) {
		WV_String(s) : s;
		WV_Double(s) : s;
		WV_NumVar(name) : getExpressionStringValue(env, printable);
		WV_Additive(expressions) : getExpressionStringValue(env, printable);
		WV_Multiplicative(expressions) : getExpressionStringValue(env, printable);
		WV_Uminus(expression) : getExpressionStringValue(env, printable);
		WV_Exponent(expression, expressions) : getExpressionStringValue(env, printable);
		WV_ExponentIndex(expression) : getExpressionStringValue(env, printable);
		WV_FunCall(name, args) : {
			eitherMap(
				lookupTree(^(env.sfunctions), toUpperCase(name)),
				\fun -> {
					fun(map(args, \arg -> getExpressionNumericValue(env, arg)))
				},
				getExpressionStringValue(env, printable)
			)
		}
		WV_Comparison(left, right, comparisonOp) : getExpressionStringValue(env, printable);
	}
}

processWVSequenceEx(seq, doAssignments) {
	fold(seq.statements, "", \acc, statement -> {
		switch(statement : WV_Statement) {
			WV_Assignment (v, expression) : {
				if (doAssignments && ^allowWikiVarsAssignment) {
					newVal = getExpressionNumericValue(wiki_env, expression);
					if (^wvVarsLoggingFunctionSet) {
						UseVarLogginFunction(v.name, Some(newVal));
					}
					setDoubleVarValue(wiki_env, v.name, newVal);
				} else {
					if (^wvVarsLoggingFunctionSet) {
						UseVarLogginFunction(v.name, None())
					}
				}
				acc
			}
			WV_Print (expressions) : {
				acc + fold(expressions, "", \toPrint, expression -> toPrint + getPrintableStringValue(wiki_env, expression))
			}
		}
	})
}

processWVSequence(seq) {
	processWVSequenceEx(seq, true)
}

processWVSequencePreserveOldValues(seq) {
	processWVSequenceEx(seq, false)
}

processWikiVarsInWholeStringEx (ss : string, acc : string, fn : ((WV_Sequence) -> string)) ->  string {
	if (ss == "") {
		acc
	} else {
		start = strFindFirstOf(ss, "${");
		if (start == -1) {
			acc + ss;
		} else {
			suffixLen = strlen(ss) - start;
			prefix = strLeft(ss, start);
			suffix = substring(ss, start, suffixLen);
			switch(parseWikiVariables(suffix) : WV_ParseResult) {
				WV_CorrectResult(sequence, remainder) : {
					processWikiVarsInWholeStringEx(remainder.s, acc + prefix + fn(sequence), fn)
				}
				WV_RemainderOnly(remainder) : {
					processWikiVarsInWholeStringEx(substring(suffix, 1, suffixLen - 1), acc + prefix + getCharAt(ss, start), fn)
				}
			}
		}
	}
}

processWikiVarsInWholeString (ss : string) ->  string {
	processWikiVarsInWholeStringEx(ss, "", processWVSequence)
}

processWikiVarsInWholeStringPreserveOldValues (ss : string) ->  string {
	processWikiVarsInWholeStringEx(ss, "", processWVSequencePreserveOldValues)
}

isCorrectParseResult(pr : WV_ParseResult) -> bool {
	switch(pr) {
		WV_CorrectResult(__, __) : true;
		WV_RemainderOnly(__) : false;
	}
}

getWVSequence(pr : WV_ParseResult) -> WV_Sequence {
	switch(pr) {
		WV_CorrectResult(sequence, __) : sequence;
		WV_RemainderOnly(__) : WV_Sequence([]);
	}
}

isCorrectWVVarName(name : string) -> bool {
	l = strlen(name);
	l > 1
	&& startsWith(name, "$")
	&& (isLetter(getCharAt(name, 1)) || getCharAt(name, 1) == "_")
	&& all(generate(2, l, \i -> {
		c = getCharAt(name, i);
		 isLetter(c) || isDigit(c) || c == "_"
		}))
}

wikiVarsList2array(varsList : WikiVarsList) -> [string] {
	mergeSets(varsList.read, varsList.write) |> set2array
}

GetAllTheUsedVars(seq) {
	GetAllTheUsedVarsEx(\ -> processWVSequencePreserveOldValues(seq) |> ignore)
}

GetAllTheUsedVars2(src) {
	GetAllTheUsedVarsEx(\ -> processWikiVarsInWholeStringPreserveOldValues(src) |> ignore)

}

GetAllTheUsedVarsEx(action) {
	setRead = ref makeSet();
	setWrite = ref makeSet();
	addToSet = \name, val, write -> {
		if (write) {
			setWrite := insertSet(^setWrite, name);
		} else {
			setRead := insertSet(^setRead, name);
		}
	}

	WithVarLoggingFunction(addToSet, action, false);

	WikiVarsList(^setRead, ^setWrite);
}

composeConditions(conditions : [SaWikiGeneralCondition], op : string) -> string {
	strGlue(
		map(
			filter(
				map(conditions, buildWikiConditionSrc),
				isNotSpace
			),
			\src -> "(" + src + ")"
		),
		op
	)
}

wikiOrConditions(conditions : [SaWikiGeneralCondition]) -> string {
	composeConditions(conditions, "+")
}

wikiAndConditions(conditions : [SaWikiGeneralCondition]) -> string {
	composeConditions(conditions, "*")
}

buildWikiConditionSrc(condition : SaWikiGeneralCondition) {
	addDollarSign = \src -> {
		if (startsWith(src, "$")) {
			src
		} else {
			"$" + src
		}
	}
	switch (condition : SaWikiGeneralCondition) {
		SaWikiSwitch(var) : var |> addDollarSign;
		SaWikiComparison(var, value, op) : {
			opS = switch (op : ComparisonOp) {
				WV_EQ() : "==";
				WV_NE() : "!=";
				WV_GE() : ">=";
				WV_GT() : ">";
				WV_LE() : "<=";
				WV_LT() : "<";
			}
			addDollarSign(var) + opS + d2s(value)
		}
		SaWikiOr(conditions) : wikiOrConditions(conditions);
		SaWikiAnd(conditions) : wikiAndConditions(conditions);
		SaWikiCustomCondition(src) : src;
		SaWikiTrue() : "1";
		SaWikiFalse() : "0";
	}
}

evalWikiExpression(src) {
	src |> parseWikiVariables |> getWVSequence |> processWVSequence |> s2d
}

IsComparisonOp(seq) {
	\compOp -> if (seq |> GetAllTheUsedVars |> wikiVarsList2array |> length |> eq(1)) {
		either(
			findmap(
				seq.statements,
				\st -> switch(st : WV_Statement) {
					WV_Print(expressions) : Some(
						either(
							findmap(
								expressions,
								\expr -> switch(expr : WV_Printable) {
									WV_Comparison(l, r, s): Some(compOp |> eq(s));
									default: None();
								}
							),
							false
						)
					);
					default : None();
				}
			),
			false
		)
	} else {
		println("Variables number isn't equal to 1.");
		false
	}
}

IsComparisonValue(seq) {
	\val ->	if (seq |> GetAllTheUsedVars |> wikiVarsList2array |> length |> eq(1)) {
		either(
			findmap(
				seq.statements,
				\st -> switch(st : WV_Statement) {
					WV_Print(expressions) : Some(
						either(
							findmap(
								expressions,
								\expr -> switch(expr : WV_Printable) {
									WV_Comparison(l, r, s): switch(r : WV_Expression) {
										WV_Double(s2): Some(s2d(s2) |> eq(val));
										default: None();
									}
									default: None();
								}
							),
							false
						)
					);
					default : None();
				}
			),
			false
		)
	} else {
		println("Variables number isn't equal to 1.");
		false
	}
}

wv_sequence2string(sequence: WV_Sequence) -> Pair<string, [string]> {
	errors = ref [];
	result = strGlue(map(sequence.statements, \statement -> wv_statement2string(statement, errors)), "");
	Pair(result, ^errors)
}

wv_statement2string(statement: WV_Statement, errors: ref [string]) -> string {
	switch(statement) {
		WV_Assignment(v, expression): {
			wv_standaloneExpression2string(v, errors) + " = " + wv_standaloneExpression2string(expression, errors) + ";";
		}
		WV_Print(expressions): {
			strGlue(map(expressions, \expression -> wv_printable2string(expression, errors)), ";")
		}
	}
}

wv_printable2string(printable: WV_Printable, errors: ref [string]) -> string {
	switch(printable) {
		WV_String(s): "\"" + s + "\"";
		WV_Double(s): wv_standaloneExpression2string(printable, errors);
		WV_NumVar(name): wv_standaloneExpression2string(printable, errors);
		WV_Additive(expressions): wv_standaloneExpression2string(printable, errors);
		WV_Multiplicative(expressions): wv_standaloneExpression2string(printable, errors);
		WV_Uminus(expression): wv_standaloneExpression2string(printable, errors);
		WV_FunCall(name, args): wv_standaloneExpression2string(printable, errors);
		WV_ExponentIndex(expression): wv_standaloneExpression2string(printable, errors);
		WV_Exponent(expression, expressions): wv_standaloneExpression2string(printable, errors);
		WV_Comparison(left, right, sig): wv_standaloneExpression2string(printable, errors);
	}
}

wv_expression2string(expr: WV_Expression, errors: ref [string]) -> string {
	switch(expr) {
		WV_Add(sig, expression): wv_expression2string(expression, errors) + " " + sig + " ";
		WV_Mult(sig, expression): wv_expression2string(expression, errors) + " " + sig + " ";
		WV_Double(s): wv_standaloneExpression2string(expr, errors);
		WV_NumVar(name): wv_standaloneExpression2string(expr, errors);
		WV_Additive(expressions): wv_standaloneExpression2string(expr, errors);
		WV_Multiplicative(expressions): wv_standaloneExpression2string(expr, errors);
		WV_Uminus(expression): wv_standaloneExpression2string(expr, errors);
		WV_FunCall(name, args): wv_standaloneExpression2string(expr, errors);
		WV_ExponentIndex(expression): wv_standaloneExpression2string(expr, errors);
		WV_Exponent(expression, expressions): wv_standaloneExpression2string(expr, errors);
		WV_Comparison(left, right, sig): wv_standaloneExpression2string(expr, errors);
	}
}

wv_standaloneExpression2string(standaloneExpression: WV_StandaloneExpression, errors: ref [string]) -> string {
	switch(standaloneExpression) {
		WV_Double(s): s;
		WV_NumVar(name): name;
		WV_Additive(expressions): "(" + strGlue(map(expressions, \expression -> wv_expression2string(expression, errors)), "") + ")";
		WV_Multiplicative(expressions): "(" + strGlue(map(expressions, \expression -> wv_expression2string(expression, errors)), "") + ")";
		WV_Uminus(expression): "-(" + wv_expression2string(expression, errors) + ")";
		WV_FunCall(name, args): name + "(" + strGlue(map(args, \expression -> wv_expression2string(expression, errors)), ", ") + ")";
		WV_ExponentIndex(expression): wv_expression2string(expression, errors);
		WV_Exponent(expression, expressions): wv_expression2string(expression, errors) + "^" + strGlue(map(expressions, \expr -> wv_expression2string(expr, errors)), "");
		WV_Comparison(left, right, sig): {
			sig_str = switch(sig) {
				WV_EQ(): " == ";
				WV_NE(): " != ";
				WV_GE(): " >= ";
				WV_GT(): " > ";
				WV_LE(): " <= ";
				WV_LT(): " < ";
			}
			wv_standaloneExpression2string(left, errors) + sig_str + wv_standaloneExpression2string(right, errors)
		}
	}
}