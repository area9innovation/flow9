// Â© Copyright 2011 Area9 Innovation. All rights reserved

import formats/html/html;
import formats/html/html2form;
import formats/wiki/wikiast;
import formats/wiki/wikibracketedargs;
import formats/wiki/wikitextelement;
import formats/wiki/wikimath;
import formats/wiki/wikiparsershelper;
import formats/wiki/wikiparsertags;
import formats/wiki/wikitools;
import formats/wiki/wikimisc;
import formats/wiki/wikipreprocessor;
import formats/wiki/wikiui;
import formats/wiki/wikivariables;
import formats/wiki/wiki2wikiconstruction;
import formats/wiki/wikistyle;
import formats/write;
import formats/xml; // <span> attributes parsing
import formula_plumbing;
import ui/buttons;
import ui/radio;
import ui/videotimeline;
import ui/tab;

export {
	// Markup based on http://en.wikipedia.org/wiki/Markdown
	// with headings from http://en.wikipedia.org/wiki/Help:Wiki_markup
	// sub- super- scripts: http://www.redmine.org/boards/2/topics/7311

	// Supports full set of Wiki constructions. Returns Form.
	// You can test with tests/slide_editor.flow.
	Wikify : (text : string) -> Form;

	// Wikify with specified set of styles
	// Supports full set of Wiki constructions. Returns Form.
	CustomWikify : (text : string, style : [WikiStyle]) -> Form;


	// Wikify with specified set of styles splitting text on pages
	WikiPages : (text : string, style : [WikiStyle]) -> [Form];

	// Wikify with specified set of styles splitting text on pages, with coach texts and scrolling flag for each page
	CoachedWikiPages : (text : string, style : [WikiStyle]) -> [CoachedWikiPage];
	CoachedWikiPage : (form : Form, name : string, disableCondition : string, texts : [string], scroll : bool, autoScroll : bool, pageNumber : int);

	Wiki2Tabs(text : string, style : [WikiStyle], tab : DynamicBehaviour<int>, tabsFormSize : Behaviour<WidthHeight>, useNewSkin : bool) -> Form;

	// Set basic wiki style. Could be overrided with local arguments.
	setGlobalWikiStyle : (style : [WikiStyle]) -> void;

	// Get basic wiki style.
	getGlobalWikiStyle : () -> [WikiStyle];

	// Apply inline wiki formatting.
	// Sample usage: Paragraph(wikifyText(title, NormalText), [])
	// Supports subset of Wiki constructions. Returns array of ParagraphElements to be used inside Paragraph.
	// Is used to process simple text  by CustomWikify.
	// Does not support \center, headers, indentation, bullets, comments
	// Supports TeX-like elements, bold, italic, underline, Wiki varialbes, SmartArt, media content, Write sources, ...
	wikifyText : (text : string, style : [CharacterStyle]) -> [ParagraphElement];
	wikifyText2 : (text : string, style : [CharacterStyle], wikiStyle : [WikiStyle]) -> [ParagraphElement];

	// collect media: images, video, etc
	collectMedia : (text : string) -> [string];
	collectMediaBlocks(text : string) -> [WigiBlockType];
	// Does not perform checks for type of the content given
	collectWikiMedia : (text : string) -> [string];

	// Calculates word count for given wiki-style text
	WikiGetWordCount(s : string) -> int;

	makeParagraphElement(txt : string, wikiStyle : [WikiStyle], stl : [CharacterStyle]) -> [ParagraphElement];

	withWikiTooltip(form : Form, tooltip : string) -> Form;
	withWikiTooltip2(form : Form, tooltip : Form) -> Form;
	makeWikiTooltip(msg : string) -> Form;
	makeWikiTooltip3(form: Form) -> Pair<Form, Behaviour<bool>>;


	useWikiFormulaTextBuilder : (formula : string) -> Maybe<string>;

	wikiConstruction2pe(construction : WikiConstruction, style : [CharacterStyle], asMathForm : bool , wikiStyle : [WikiStyle]) -> [ParagraphElement];

	// Trims white spaces, basically
	preprocessWikiSource(src: string) -> string;


}

///// Formatted text example:
/*

==Continue with this experiment and obtain three ECGs:==

one with your test subject seated, one with him standing,
and one after he has performed moderate exercise.\n

==But first, let's develop a hypothesis for you to test:==
* Do you expect the ECG to change in the three recordings?\n"
* If so, how will the ECGs be different?\n"

* Correlate any expected ECG changes with corresponding measurements of the cardiac cycle,
 such as heart rate, ventricular systole and ventricular diastole.
* How will these values change?\n"

* Auscultate your test subject before every recording.
* Have the heart sounds changed?

==You will find all the tools you need in the menu on the right.==
==Record your results in the LabSmart Report.==

----
==New Page==

*/
////

/*************************************/

globalWikiStyle : ref [WikiStyle] = ref []; //[NumberedParagraph()];
setGlobalWikiStyle(style : [WikiStyle]) {
	globalWikiStyle := style;
}

// Returns result in any case, prevents from infinite loop when: start < min
countUntilDownMb : (start : int, min : int, predicate : (int) -> bool) -> Maybe;

getGlobalWikiStyle() {
	^globalWikiStyle
}

wikiTableStyle = ref wikiTableDefaultStyle;

/**********************/
/* Exported functions */

Wikify(text : string) { CustomWikify(text, []) }

CustomWikify(wikiText : string, style : [WikiStyle]) {
	text = strReplace(wikiText, "\u000d", "");
	pages = WikiPages(text, style);
	if (length(pages) == 1) pages[0]
	else {
		fonts = getWikiFonts(concat(style, ^globalWikiStyle));
		line = Border(0.0, fonts.interlineSpace * 2.0, 0.0, fonts.interlineSpace * 2.0, HFill(1.0, [Fill(0x000000)]));
		WideLines(interleave(pages, line))
	}
}

WikiPages(text : string, style : [WikiStyle]) {
	map(CoachedWikiPages(text, style), \cwp -> cwp.form)
}

Wiki2Tabs(text : string, style : [WikiStyle], tab : DynamicBehaviour<int>, tabsFormSize : Behaviour<WidthHeight>, useNewSkin : bool) -> Form {
	pages = CoachedWikiPages(text, style);
	tabHeight = 20.0;
	radius = 7.0;
	lBorder = 5.0;
	cropAvailable = \p -> {
		awh = makeWH();
		Inspect(
			[IAvailable2(awh)],
			Available2(
				select(awh, \wh -> WidthHeight(wh.width - lBorder, wh.height)),
				p.form
			)
		)
	}
	forms = map(pages, cropAvailable);
	captions = map(pages, \p -> p.name);

	tabbedForm = customTabControlWH(
		tab,
		tabsFormSize,
		radius,
		tabHeight,
		captions,
		[],
		forms,
		const(true),
		useNewSkin
	);
	Offset(lBorder, 0.0, tabbedForm)
}

preprocessWikiSource(src : string) -> string {
	rtrim2(src, " \n\t");
}

CoachedWikiPages(sourceText : string, style : [WikiStyle]) -> [CoachedWikiPage] {
	text = preprocessWikiSource(sourceText);
	fixup = idfn; //\pages : [CoachedWikiPage] -> map(pages, \p -> CoachedWikiPage(ShowWhenReady(p.form, 100, nop), p.name, p.texts, p.scroll, p.autoScroll));
	switch(ChooseWikiParser(text) : WikiContentType) {
		WikiHtml() : {
			pages = strSplit(text, "----");
			//LSTSBD-291 In most places of our code rightmost style of style array is used. In Wiki for historical reasons - leftmost.
			ts = extractStructMany(style, NormalWikiFonts);
			bc = extractStructMany(style, WikiZoomBackgroundColor(white));
			htmlStyle = [
				if (0 < length(ts)) [HTMLDefaultFont(ts[0].normalText)] else [],
				if (0 < length(bc)) [HTMLZoomBackground(Some(bc[0].color))] else [],
			] |> concatA;

			mapi(pages, \i, p -> {
				form : Form = html2form(SkipLeadingSpaces(p), makeTree(), htmlStyle);
				CoachedWikiPage(form, "", "", [], false, false, i + 1);
			});
		}
		WikiWrite() : {
			pages = strSplit(text, "----");
			mapi(pages, \i, p -> {
				fonts = getWikiFonts(concat(style, ^globalWikiStyle));
				form : Form = write2form(SkipLeadingSpaces(p), fonts.normalText);
				CoachedWikiPage(form, "", "", [], false, false, i + 1)
			});
		}
		WikiStd() : {
			stylemod = concat(style, ^globalWikiStyle);
			renderwiki(tokenize(text, contains(stylemod, NumberedParagraph())), stylemod);
		}
		WikiWigi() : {
			firstOccurrence = findFirstWikiTag(sourceText);
			pages = switch (firstOccurrence.element) {
				WikiWigi() : {
					src = substring(text, 6, strlen(text) - 13);	// Strip <wigi></wigi>
					CallWigiParserS(src, style);	// WikiWigify is called here!
				}

				default: [WigifiedPage(\ -> Text("Wigi closing tag is not found", NormalText), [], "", "", false, false, EmptyMarginContent())]
			}

			pageNumber = ref 0;
			mapi(pages, \i, page -> {
				if (!page.scroll) pageNumber := ^pageNumber + 1;
				CoachedWikiPage(page.form(), page.name, page.disableCondition, page.coachTexts, page.scroll, page.autoScroll, ^pageNumber)
			});
		}
	} |> fixup
}

collectMedia(text : string) -> [string] {
	//Write is not supported currently.
	//We can convert is to Wigi and extract with CallWigiMediaExtractor.
	eitherFn(
		CallWigiMediaExtractor(text),
		idfn,
		\ -> {
			if (startsWith(ltrim(text), "<html>")) { //#37026
				acc = ref [];
				html2form(text, makeTree(), [HTMLMediaCollector(acc)]);
				^acc
			} else {
				collectWikiMedia(text)
			}
		}
	)
}

collectMediaBlocks(text : string) -> [WigiBlockType] {
	eitherFn(
		CallWigiMediaBlocksExtractor(text),
		idfn,
		\ -> {
			println("Cannot extract media elements from wigi: " + text);
			[]
		}
	)
}

collectWikiMedia(text : string) -> [string] {
	acc = ref [];
	wiki2wikiConstruction(text, false, [MediaCollector(acc)], ^wikiTableStyle);
	^acc;
}

/*********************/
/* Library functions */

// apply function to every element of array but last
mapNotLast(a : [?], fn : (?) -> ?) -> [?] {
	l = length(a) - 1;
	mapi(a, \i, el -> if (i < l) fn(el) else el)
}

makeWikiTooltip(msg) {
	makeWikiTooltip2(msg).first
}

makeWikiTooltip2(msg) -> Pair<Form, Behaviour<bool>> {
	if (isNotSpace(msg)) {
		res = CustomWikify(msg, [TooltipWikiFonts, WikiAlign(TightWidth())]);
		makeWikiTooltip3(res)
	} else {
		Pair(Empty(), const(true))
	}
}

makeWikiTooltip3(res: Form) -> Pair<Form, Behaviour<bool>> {
	isEmpty = isEmptyFormB(res);
	hiScale20 = if(mobile) AdaptiveScaleLtdFun(2.0) else idfn;
	form = Offset(-15.0, 15.0,
		Filter(
			[DropShadow([Placement(45.0, 2.0), Color(0x000000, 0.7), Radius(3.0), Spread(1.0)])],
			Rounded(10.0, [Fill(0xDDDDDD)],
				Border(10.0, 10.0, 10.0, 10.0,
					Available2(const(WidthHeight(250.0, 0.0)), isEmpty.first)
				)
			)
		)
	) |> hiScale20;
	Pair(form, isEmpty.second)
}

withWikiTooltip(form, msg) {
	withWikiTooltip2(form, makeWikiTooltip(msg))
}

withWikiTooltip2(form, tooltip) {
	withWikiTooltip3(form, tooltip, const(tooltip == Empty()), None(), false, false)
}

withWikiTooltip3(form : Form, tooltip : Form, isEmpty : Behaviour<bool>, extAW, allowPersistentTooltip, hideWhenDynamicTooltipIsEmpty) {
	persistentTooltip = make(false);
	addPersistentTooltipHandler = if (allowPersistentTooltip) {
		\f -> Button(
			Cursor(
				FingerCursor(),
				Foreground([Fill(white), FillOpacity(0.0)],	f)
			),
			\ -> {
				if (!getValue(isEmpty)) {
					next(persistentTooltip, !getValue(persistentTooltip))
				}
			}
		)
	} else {
		idfn
	}
	if (isConst(isEmpty) && getValue(isEmpty)) {
		form
	} else {
		myAW = make(0.0);
		aw = either(extAW, myAW);
		cf = CustomCursor3(
			Inspect(
				[AvailableWidth(myAW)],
				addPersistentTooltipHandler(tooltip)
			),
			false,
			addPersistentTooltipHandler(form),
			aw,
			true,
			select2(persistentTooltip, isEmpty, \p, e -> p && !e),
			isEmpty
		);
		stalledEmpty = stall(isEmpty, 10);
		result = if (hideWhenDynamicTooltipIsEmpty) {
			Group([
				Size2(zeroSize, Alpha(make(0.0), tooltip)),
				Invisibleb(stalledEmpty, cf)
			])
		} else {
			cf
		}
		Constructor(
			result,
			\ -> {
				subscribe2(stalledEmpty, \empty -> if (empty) nextDistinct(persistentTooltip, false));
			}
		)
	}
}

useWikiFormulaTextBuilder(formula) {
	useFormulaTextBuilder(formula, [LiteraryDecimalPart()])
}

makeParagraphElement(txt, wikiStyle, stl){

	wordDefinitions : Maybe<Tree<string, string>> = fold(wikiStyle, None(), \acc, s -> switch (s : WikiStyle) { Wordlist(defs): Some(defs); default: acc; });

	switch(wordDefinitions : Maybe<Tree<string, string>>) {
		Some(tree) : {
			separators = getTreeKeys(tree);
			spText = strSplit2(txt, separators);
			map(spText, \part ->
				switch(lookupTree(tree, part) : Maybe) {
					Some(definition) : {
						result : ParagraphElement = withWikiTooltip(Text(_(part), stl), definition);
						result
					}
					None() : {  TextFragment(part, stl) }
				}
			)
		}
		default : { [TextFragment(txt, stl)] }
	}
}

/****************************/
/* Wiki rendering functions */

//[color:red] red text [color:] or [color:red|red text]
//[color:green] background green [color:]
//[color:green] background green [color:]
//[tooltip:green] background green



// Parse inline wiki formatting: *italic*, **bold** and other [external content]
// Result is array of Form instead of ParagraphElement
wikifyText2Form(text : string, style : [CharacterStyle], wikiStyle : [WikiStyle]) -> [Form] {
	map(wikifyTextEx(text, style, true, wikiStyle), \pe -> cast(pe : ParagraphElement -> Form))
}


// Parse inline wiki formatting: *italic*, **bold** and other [external content]
wikifyText(text : string, style : [CharacterStyle]) -> [ParagraphElement] {
	wikifyText2(text, style, []);
}

wikifyText2(text : string, style : [CharacterStyle], wikiStyle : [WikiStyle]) -> [ParagraphElement] {
	res = wikifyTextEx(text, style, false, wikiStyle);
	res |> mergeAllTextFragments
}


IndentBullet(aw, bullet, form) {
	w = make(0.0);
	Cols([
		Inspect([Width(w)], bullet),
		Available(select2(aw, w, \aw1, w1 ->  max(0.0, aw1 - w1)), zero, form)
	])
}

RightBullet(aw, bullet, form) {
	w = make(0.0);
	offset = select2(aw, w, \aw1, w1 -> aw1 - w1);
	Group([
		Available(offset, const(0.0), form),
		Translate(offset, const(0.0), Inspect([Width(w)], bullet))
	])
	|> (\f -> FixWidth(aw, f)) // this prevents CenterAlign paragraph from moving form
}

processBullet(aw : Behaviour<double>, bullet: Form, text : string, level : int, fonts : WikiFonts, center : bool, wikiStyle : [WikiStyle]) {
	step = 20;
	border = max(0.0, i2d((level - 1) * step));
	addBorder = \form -> Border(border, 0.0, 7.0, 0.0, form);

	baseParaOptions = [InterlineSpacing(fonts.interlineSpace), TightWidth()];

	paraOptions = baseParaOptions;//if (center) arrayPush(baseParaOptions, TightWidth) else baseParaOptions;

	IndentBullet(aw,
		bullet |> addBorder,
		Paragraph(wikifyText2(text, fonts.normalText, wikiStyle), paraOptions)
	)
}

translate(aw : Behaviour<double>, wikiStyle : [WikiStyle]) -> (t : WikiToken, fonts : WikiFonts, zebraTab : bool) -> [ParagraphElement] {
	\t : WikiToken, fonts : WikiFonts, zebraTab : bool ->
	switch(t : WikiToken) {
		// Do not add "default" branch to this switch for easier further search
		WHeading1(text): wikifyText2(text, fonts.headingText, wikiStyle);
		WHeading2(text): wikifyText2(text, fonts.heading2Text, wikiStyle);
		WBullet1(text): [
				processBullet(aw, fonts.bullet, text, 1, fonts, false, wikiStyle)
			];
		WBullet2(text): [
				processBullet(aw, fonts.bullet, text, 2, fonts, false, wikiStyle)
			];
		WBullet3(text): [
				processBullet(aw, fonts.bullet, text, 3, fonts, false, wikiStyle)
			];
		WNumbered1(n, pretty, dotted, text): [
				processBullet(aw, prettyNumber(n, pretty, dotted, fonts), text, 1, fonts, false, wikiStyle)
			];
		WIndentedFirstLine(text): concat(
				[TextFragment("&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;", fonts.normalText)],
				wikifyText2(text, fonts.normalText, wikiStyle)
			);
		WIndentedText(text): [
				IndentBullet(aw,
					Text("&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;", fonts.normalText),
					Paragraph(wikifyText2(text, fonts.normalText, wikiStyle), [InterlineSpacing(fonts.interlineSpace), TightWidth()])
				)
			];
		WText(text, multiline): {
			newWikiStyle = if (multiline) {
				arrayPush(wikiStyle, AllowSpacesBeetweenBracketedArgs())
			} else {
				wikiStyle
			}
			wikifyText2(text, fonts.normalText, newWikiStyle);
		}
		WNewLine() : [TextFragment("&nbsp;\n", fonts.normalText)];
		WNewPage(__) : [Border(0.0, fonts.interlineSpace * 2.0, 0.0, fonts.interlineSpace * 2.0, HFill(1.0, [Fill(0x000000)]))];
		WPageSeparator(__) : [TextFragment("&nbsp;\n", fonts.normalText)]; // as new line
		WCenter(ctoken) : {
			switch(ctoken : WikiToken) {
				WRightNumbered(n, token) : {
					[
						RightBullet(aw,
							Text("&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;" + i2s(n) + "&nbsp;", fonts.rightNumberingText),
							Paragraph(
								translate(aw, wikiStyle)(token, fonts, zebraTab),
								[InterlineSpacing(fonts.interlineSpace), CenterAlign()]
							)
						)
					]
				}
				WBullet1(text): [
						processBullet(aw, fonts.bullet, text, 1, fonts, true, wikiStyle)
					];
				WBullet2(text): [
						processBullet(aw, fonts.bullet, text, 2, fonts, true, wikiStyle)
					];
				WBullet3(text): [
						processBullet(aw, fonts.bullet, text, 3, fonts, true, wikiStyle)
					];
				WNumbered1(n, pretty, dotted, text): [
						processBullet(aw, prettyNumber(n, pretty, dotted, fonts), text, 1, fonts, true, wikiStyle)
					];
				default : {
					translate(aw, wikiStyle)(ctoken, fonts, zebraTab)
				}
			}
		}
		WRightNumbered(n, token) : [
				RightBullet(aw,
					Text("&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;" + i2s(n) + "&nbsp;", fonts.rightNumberingText),
					Paragraph(
						translate(aw, wikiStyle)(token, fonts, zebraTab),
						[InterlineSpacing(fonts.interlineSpace)]
					)
				)
			];
		WTable(rows) : {
			baseXAlign = ^wikiTableStyle.xAlign;
			baseYAlign = ^wikiTableStyle.yAlign;
			colsAligns = ^wikiTableStyle.xAligns;
			rowsAligns = ^wikiTableStyle.yAligns;
			xAlignsCount = length(colsAligns);
			yAlignsCount = length(rowsAligns);
			getAlign = \row, col -> {
				xAlign = if (col < xAlignsCount) colsAligns[col] else baseXAlign;
				yAlign = if (row < yAlignsCount) rowsAligns[row] else baseYAlign;
				Pair(xAlign, yAlign)
			}
			addCellAlign = \row, col -> \cell -> {
				align = getAlign(row, col);
				xAlign = align.first;
				yAlign = align.second;
				if (xAlign != 0.0 || yAlign != 0.0) {
					Align2(xAlign, yAlign, cell)
				} else {
					cell
				}
			}

			textColor = colorOfText(^wikiTableStyle.character);

			vLines = ^wikiTableStyle.vLines;
			hLines = ^wikiTableStyle.hLines;
			addLines = \row, col -> \cell:Form -> {
				toAdd1 = if (contains(vLines, col)) {
					Size2(zeroSize, VFill(0.0, [StrokeWidth(1.0), Stroke(textColor)]))
				} else {
					Empty()
				}
				toAdd2 = if (contains(hLines, row)) {
					Size2(zeroSize, HFill(0.0, [StrokeWidth(1.0), Stroke(textColor)]))
				} else {
					Empty()
				}
				if (toAdd1 != Empty() || toAdd2 != Empty()) {
					Group([
						cell,
						toAdd1,
						toAdd2
					])
				} else {
					cell
				}
			}

			borders = ^wikiTableStyle.borders;

			baseParaStyle = [TightWidth(), InterlineSpacing(fonts.interlineSpace)];

			result = Background(^wikiTableStyle.graphic, Grid(mapi(rows, \rowi, row -> mapi(row, \coli, cell -> {
				Border(borders.left, borders.top, borders.right, borders.bottom,
					Available(aw, const(0.0),
						inheritedAvailableParagraph(wikifyText2(cell, concat(fonts.normalText, ^wikiTableStyle.character), wikiStyle), baseParaStyle)
					)
					|> addCellAlign(rowi, coli)

				)
				|> addLines(rowi, coli)
				|> NonZeroSize
				|> (\f -> if (zebraTab) {
					wh = makeWH();
					Group([
						Select(
							whenSizeChanged(wh), \wh2 -> {
								if (wh2.width == 0.0 || wh2.height == 0.0) { Empty() }
								else BackgroundWH(wh2.width, wh2.height, [Fill((if (rowi % 2 == 1) 0xffffff else 0xeeeeee)), /*Stroke(0x0)*/])
							}
						),
						Inspect([IAvailable2(wh)], f)
					]);

					}
					else f
				)
			}))))
			|> (\f -> if (^wikiTableStyle.left != WriteNoBracket() || ^wikiTableStyle.right != WriteNoBracket()) {
				brackets2formWithColor(^wikiTableStyle.left, ^wikiTableStyle.right, f, textColor)
			} else {
				f
			})
			|> v2a;
			wikiTableStyle := wikiTableDefaultStyle;
			result
		};
		WSmall() : [];
		WCoach(text): [];
		WEOL(): [];
		WPageName(__, __) : [];
		WComment(__) : [];
		}
	}

renderwiki(lexer : WikiLexer, style : [WikiStyle]) -> [CoachedWikiPage] {
	awh = makeWH();
	aw = select(awh, \wh -> wh.width);

	normalfont = getWikiFonts(style);
	currentfont = ref normalfont;

	restrictLineBreaks = contains(style, RestrictAutoLineBreaks());
	tw = if (contains(style, WikiAlign(TightWidth())) || restrictLineBreaks) [TightWidth()] else [];

	zebraTab = contains(style, TZebraTable());

	isCenter = \el -> switch(el : WikiToken) { WCenter(token) : true; default : false; } || contains(style, WikiAlign(CenterAlign()));

	lineIsOneFormInSimpleEnvironment = \line, needCenter -> {
		length(line) == 1 && peIsForm(line[0]) && !needCenter
	}

	setChildrenAvailable = \line, needCenter -> {
		awhToSet = if (restrictLineBreaks) InfiniteWidthAWH else awh;
		if (!restrictLineBreaks && lineIsOneFormInSimpleEnvironment(line, needCenter)) {
			line
		} else {
			map(line, \el -> setParagraphFormAvailable(awhToSet, el));
		}
	}

	setAvailable = if (restrictLineBreaks) InfiniteWidth else idfn;

	toPara = \line : [ParagraphElement], needCenter : bool -> {
		newLine = setChildrenAvailable(line, needCenter);
		(if (lineIsOneFormInSimpleEnvironment(newLine, needCenter)) {
			cast(newLine[0] : ParagraphElement -> Form)
		} else {
			// New paragraph engine processes Center and TightWidth pair correctly,
			// so let's try
			paraStyle = if (needCenter && !restrictLineBreaks) [CenterAlign()] else tw;
			Paragraph(newLine, concat([InterlineSpacing((^currentfont).interlineSpace)], paraStyle))
		})
		|> setAvailable
		|> \form -> {
			if (needCenter && restrictLineBreaks) {
					Align2(0.5, 0.0, form)
			} else {
				form
			}
		}
	};

	isCoach = \el -> switch(el : WikiToken) { WCoach(s) : true; default : false; };
	getCoachText = \el -> switch(el : WikiToken) { WCoach(s) : Some(s); default : None(); };

	testParFixup = if (isUrlParameterTrue("test34693")) \f -> ShowWhenReady(f, 200, nop) else idfn;

	// Note, that Lines(Available(aw, small paragraph)) is more efficient than one big paragraph
	lexer
	|> lexems
	|> pager
	|> (\pages -> mapi(pages, \pageOffset, pf : Triple<[WikiToken], int, bool> -> untriple(pf, \page, pageNumber, autoScrollFlag -> {
		currentfont := normalfont;
		removeSeparators = \p -> fold(p, [], \acc, t -> switch (t : WikiToken) {
			WPageSeparator(__) : acc;
			default : concat(acc, [t]);
		});

		wpn : WPageName = extractStruct(page, WPageName("Page " + i2s(pageOffset + 1), ""));

		isPageSeparator = \wt -> switch (wt : WikiToken) {
			WPageSeparator(__): true;
			default: false;
		}
		scrollFlag = exists(page, isPageSeparator);
		page
		|> removeSeparators
		|> (\l -> map(l, \token -> {
			if (token == WSmall()) currentfont := makeWikiFonts(normalfont.baseFontSize * 14.0/16.0);

			translate(aw, style)(token, ^currentfont, zebraTab)
			|> (\line -> Available2(awh, toPara(line, isCenter(token))))
			|> testParFixup
		}))
		// Space between paragraphs here
		|> (\lines -> mapNotLast(lines, \el -> Border(0.0, 0.0, 0.0, (^currentfont).interlineSpace, el)))
		|> Lines
		|> (\form -> Inspect([IAvailable(awh)], form))
		//#24777 is almost ready
		//pageNumber is number of page according to requirements #24777
		//pageOffset is number of page if consider each appending as separate page i.e. as it worked before.
		|> (\form -> CoachedWikiPage(form, wpn.name, wpn.disableCondition, filtermap(page, getCoachText), scrollFlag, autoScrollFlag, pageNumber + 1))
	})))
}

WikiGetWordCount(s : string) {
	curWordCount = ref 0;
	a = wikifyText2(s, [], []);
	map(a, \elem -> {
		switch(elem : ParagraphElement) {
			TextFragments(p) : {
				l = list2array(p);
				map(l, \t -> {
					switch(t : WrapElement) {
						Text(z, __) : curWordCount := ^curWordCount + 1;
						default : {}
					}
				});
				{}
			}
			default : {}
		}
	});
	^curWordCount;
}

countUntilDownMb(start, mincount, predicate) {
	if (start < mincount) None()
	else if (predicate(start)) Some(start)
	else countUntilDownMb(start - 1, mincount, predicate);
}

wikifyTextEx(src : string, style : [CharacterStyle], asMathForm : bool , wikiStyle : [WikiStyle]) -> [ParagraphElement] {
	processConstruction = \c -> wikiConstruction2pe(c, style, asMathForm, wikiStyle);
	wikiStyle2 : [WikiParsingStyle] = filtermap(
		wikiStyle,
		\s : WikiStyle -> {
			if (isWikiParsingStyle(s)) {
				ws : WikiParsingStyle = cast(s : WikiStyle -> WikiParsingStyle);
				Some(ws)
			} else {
				None()
			}
		}
	);
	mapConcat(wiki2wikiConstruction(src, asMathForm, wikiStyle2, ^wikiTableStyle), processConstruction);
}

wikiConstruction2pe(construction : WikiConstruction, style : [CharacterStyle], asMathForm : bool , wikiStyle : [WikiStyle]) -> [ParagraphElement] {
	hiScale20 = if(mobile) AdaptiveScaleLtdFun(2.0) else idfn;

	recCall : (WikiConstruction) -> [ParagraphElement] = \c : WikiConstruction -> wikiConstruction2pe(c, style, asMathForm, wikiStyle);

	processConstructions : ([WikiConstruction]) -> [ParagraphElement] = \cs -> map(cs, recCall) |> concatA;
	processConstructionsStyled : ([WikiConstruction], [CharacterStyle]) -> [ParagraphElement] = \cs, s -> {
		map(cs, \c -> wikiConstruction2pe(c, s, asMathForm, wikiStyle))
		|> concatA;
	}
	processConstructionsAsMath = \cs -> {
		s = asMath(style);
		map(cs, \c -> wikiConstruction2pe(c, s, true, wikiStyle))
		|> concatA
	};
	processConstructionsAsSmallMath = \cs -> {
		s = asSmallMath(style);
		map(cs, \c -> wikiConstruction2pe(c, s, true, wikiStyle))
		|> concatA;
	}


	makeTextFragment = \txt, stl -> {
		if (txt != "") {
			makeParagraphElement(txt, wikiStyle, stl)
		} else {
			[]
		}
	}

	makeTextForm = \txt, stl -> {
		if (txt != "") {
			[Text(txt, stl)]
		} else {
			[]
		}
	}

	returnText : (string, [CharacterStyle]) -> [ParagraphElement] = if (asMathForm) makeTextForm else makeTextFragment;

	naturalMathStyle = [FontFamily("Minion")] |> withFillColor(colorOfText(style)) |> withTextSize(sizeOfText(style));

	useFirstTextIfNotEmpty = \s1, s2 -> if (isNotSpace(s1)) s1 else s2;

	//Dirty workaround. Sets baseline to be equal to baseline.
	pushBaseLine = \form -> {
		metrics = getDynamicFormSize(form);
		formM = metrics.first;
		Select(metrics.second, \mb -> {fixBaseline(mb.baseline, formM)})
	}

	addSizeInspector = \wb -> \f -> Inspect([ISize(wb)], f);

	addScriptHeaderAndFooter = \s -> "{" + s + "}";
	addOptionalParameterBrackets = \s -> if (isNotSpace(s)) "[" + s + "]" else "";

	improveLeadingMinus = \t, wiki -> {
		if (startsWith(t, "-") && !startsWith(t, "--")) {
			if (!wiki) {
				"&#x2013;" + strRight(t, 1)
			} else {
				"\\endash" + strRight(t, 1)
			}
		} else {
			t
		}
	}


	processFormattingSymbol2 : (string, (string, [CharacterStyle]) -> [ParagraphElement]) -> [ParagraphElement] = \src, formattingFn -> {
		formattingFn(src |> processWikiVarsInWholeString |> htmlEscape, style)
	}

	parseColor = \s -> {
		if (startsWith(s, "#")) {
			parseHex(substring(s, 1, strlen(s)-1));
		} else {
			s2i(s)
		}
	}

	makeSuperscript = \t,s -> {
		if (isBaseWikiText(t)) {
			Superscript(improveLeadingMinus(t, false), asBold(s)) |> v2a
		} else {
			Superscript(t,s) |> v2a
		}
	}

	makeDefaultSelectUpdateForm = \constructions, isEmpty -> {
		fonts = getWikiFonts(concat(wikiStyle, ^globalWikiStyle));
		\__ -> {
			constructionsToShow = processConstructions(constructions);
			if (0 < length(constructionsToShow)) {
				form = inheritedAvailableParagraph(constructionsToShow, [TightWidth(), InterlineSpacing(fonts.interlineSpace)]);
				visiblyEmptyPair = isEmptyFormB(form);
				Constructor(visiblyEmptyPair.first, \ -> {connect(visiblyEmptyPair.second, isEmpty)})
			} else {
				next(isEmpty, true);
				Empty()
			}
		}
	}

	makeSelect = \vars, updateForm, isEmpty -> {
		environment = getGlobalWVEnvironment();
		varsBehaviours = map(vars, \var -> getDoubleVarBehaviour(environment, var));
		trigger = make(false);

		NonZeroSize2(
			Constructor(
				Select(throttle(trigger, 10.0), updateForm),
				\ -> {
					arraySubscribe2(varsBehaviours, \i, oldVal, newVal -> if (oldVal != newVal) next(trigger, !getValue(trigger)))
				}
			),
			select(isEmpty, \b -> !b)
		)
	}

	makeWikiSwitch = \condition, cond2Id, srcs, isEmpty -> {
		srcId = make(0);
		srcsLen = length(srcs);
		Constructor(
			Select(srcId, \id -> {
				if (0 <= id && id < srcsLen && length(srcs[id]) > 0) {
					makeForm = makeDefaultSelectUpdateForm(srcs[id], isEmpty);
					makeForm(false)
				} else {
					nextDistinct(isEmpty, true);
					Empty()
				}
			}),
			\ -> {
				conditionValue = condition |> processWVSequence |> s2d |> cond2Id;
				nextDistinct(srcId, conditionValue);
				\ -> {
					next(isEmpty, true)
				}
			}
		)
	}

	makeIf = \condition, tc, ec, isEmpty -> makeWikiSwitch(condition, \c -> c |> neq(0.0) |> b2i, [ec, tc], isEmpty);

	getScoringStatsCollector = \ -> findmap(wikiStyle, \ws -> switch(ws : WikiStyle) {
			WikiScoringStatsCollector(stats) : Some(stats);
			default : None();
	});

	makeCommonForm = \constructions -> {
		if (length(constructions) > 0) {
			constructions |> processConstructions |> \pe -> inheritedAvailableParagraph(pe, [TightWidth()])
		} else {
			Empty()
		}
	}

	opacity = 0.7;
	dummyColor = Pair(white, 0.01);
	makeViewForDragAndDropElements = \wikiC, width, height, fill, stroke -> {
		Group([
			Rectangle(width, height, [Fill(fill.first), FillOpacity(fill.second), Stroke(stroke.first), StrokeOpacity(stroke.second)]),
			wikiC |> makeCommonForm |> Center |> \f -> Available(const(width), const(height), f)
		])
	}

	pe : ([ParagraphElement]) -> [ParagraphElement]  = \p : [ParagraphElement] -> p;

	switch (construction : WikiConstruction) {
		WikiSmartArtEx(src) : {
			// Old behaviour is preserved after changes in ParagraphEngine
			forms : [Form] = CallSmartArtParser(src, IuWikiPreprocessor, filter(wikiStyle, neq(WikiAlign(CenterAlign()))));
			pe(interleave(forms, AllowLineBreak)); //Style modifications should be synced with Wigi. Extract function if more modifications are added
		}
		WikiSimpleConstructions(constructions, src) : {
			pe(if (isAlreadyTranslated(wikiStyle)) {
				constructions |> processConstructions
			} else {
				newWikiStyle = arrayPush(wikiStyle, AlreadyTranslated());
				wikifyTextEx(getTranslation(src), style, asMathForm, newWikiStyle);
			});
		}
		WikiBaseTextEx(text): {
			returnText(text |> htmlEscape, style);
		}
		WikiSimpleTextEx(text, styleAddition) : {
			makeTextForm(text, concat(style, styleAddition))
		}
		WikiNoWikiEx(text) : {
			returnText(text |> htmlEscape, style);
		}
		WikiWigiEx(src) : {
			newWS = arrayPush(wikiStyle, characterStyle2WikiFonts(style));
			map(CallWigiParserS(getTranslation(src), newWS), \p -> p.form())
		}
		WikiAnsEx(src) : {
			src |> processWikiVarsInWholeString |> CallAnsParser
		}
		WikiDecoratedImageEx(imageDecorated) : {
			imageDecorated2FormWithZoom(imageDecorated, wikifyText) |> v2a
		}
		WikiOneLineEx(constructions) : {
			makeOneLine = glueElements;
			pe(processConstructions(constructions) |> makeOneLine)
		}
		WikiSpanEx(constructions, tooltip, color, background, fontFamily, fontSizeMultiplier) : {

			withMyTooltip = eitherMap(tooltip, \tt -> \elts -> paramap(elts, \form -> withWikiTooltip(form, tt)), idfn);

			withTextBackground = \c -> \f -> transformText(f, \t ->
				Background([Fill(c)], t) // See #21696
				//Text(t.text, arrayPush(t.style, BackgroundFill(c)))
			);
			withBackground = eitherMap(background, \c -> \elts -> paramap(elts, withTextBackground(c)), idfn);

			newStyle = style
			|> eitherMap(fontFamily, withTextFamily, idfn)
			|> eitherMap(color, withFillColor, idfn)
			|> eitherMap(
				fontSizeMultiplier,
				\fm -> if ( secondOfPair(fm) ) withFontMultiplier(firstOfPair(fm)) else withTextSize(firstOfPair(fm)),
				idfn
			);

			pe(processConstructionsStyled(constructions, newStyle) |> withBackground |> withMyTooltip)
		}
		WikiTableEx(constructions, tableStyle) : {
			// the idea of initial developer was to apply tableStyle to inner constructions
			// but closing tag can be found only in simple text while table is not simple text from
			// lexer's point of view, so we just set up global style for next table.
			wikiTableStyle := tableStyle;
			processConstructions(constructions);
		}
		WikiLearningResourceEx(lr, introduction) : {
			mkForm = either(
				findmap(wikiStyle, \s -> switch (s) {ResourceGenerator(generator) : Some(generator); default : None();}),
				CallDefaultLrPreview
			);
			mkForm(lr, introduction)
		}
		WikiWriteEx(src) : {
			write2form(src, style)|> v2a
		}
		WikiMediaEx(contentType)  : {
			mediaContent2Form(contentType, style, wikiStyle, wikifyText2) |> v2a
		}
		WikiSubscriptMathEx(constructions) : {
			moveDown = \f -> {
				fmSrc = getDynamicFormSize(f);
				fM = fmSrc.first;
				fmB = fmSrc.second;
				Select(fmB, \fm -> {
					ts = sizeOfText(style);
					dy = if (ts > fm.height) {
						fm.height * 0.5
					} else {
						fm.height - ts
					}
					Border(0.0, 0.0, 0.0, dy + 1.0, Offset(0.0, dy, fM))
				});
			}
			processConstructionsAsSmallMath(constructions) |> toOneForm |> moveDown |> v2a
		}
		WikiSubscriptEx(src) : {
			processFormattingSymbol2(src, \t,s -> Subscript(t,s) |> v2a) // this will work with NormalText only
		}
		WikiSuperscriptMathEx(constructions) : {
			moveUp = \f -> {
				fmSrc = getDynamicFormSize(f);
				fM = fmSrc.first;
				fmB = fmSrc.second;
				Select(fmB, \fm -> {
					dy = max(sizeOfText(style) - fm.height * 0.5, fm.height - sizeOfText(style) * 0.5);
					Border(0.0, dy, 0.0, 0.0, Offset(0.0, -dy, fM))
				});
			}
			processConstructionsAsSmallMath(constructions) |> toOneForm |> moveUp |> v2a
		}
		WikiSuperscriptEx(src) : {
			processFormattingSymbol2(src, makeSuperscript) // this will work with NormalText only
		}
		WikiSubSupEx(bodyC, supC, subC, left, src) : {
			makeForm = \pes -> inheritedAvailableParagraph(pes, [TightWidth()]);
			body = processConstructions(bodyC) |> makeForm;
			sub = processConstructionsStyled(subC, asSmallText(style)) |> makeForm;
			sup = processConstructionsStyled(supC, asSmallText(style)) |> makeForm;
			supSubScript2form2(body, sup, sub, left) |> v2a
		}
		WikiUnderlineEx(src) : {
			processFormattingSymbol2(src, \t_, s_ ->  map(returnText(t_, s_), makeUnderline))
		}
		WikiBoldItalicEx(constructions) : {
			processConstructionsStyled(constructions, asBoldItalic(style));
		}
		WikiBoldEx(constructions) : {
			processConstructionsStyled(constructions, asBold(style));
		}
		WikiItalicEx(constructions, fix) : {
			elements = processConstructionsStyled(constructions, asItalic(style));
			pe(if (fix && length(elements) > 0) {
				arrayPush(elements, Fixed(1.0, 0.0))
			} else {
				elements
			})
		}
		WikiConditionalAssignment(condition, ts, es) : {
			conditionValue = condition |> processWVSequence |> s2d |> neq(0.0);
			seq = if (conditionValue) ts else es;
			seq |> processWVSequence |> ignore;
			[];
		}
		MathAssignmentsOnBecameVisibleEx(sequence) : {
			Constructor(
				Empty(),
				\ -> {
					sequence |> processWVSequence |> ignore;
					nop
				}
			) |> v2a
		}
		ConditionalWikiEx(condition, tc, ec) : {
			makeIf(condition, tc, ec, make(true)) |> v2a
		}
		WikiWhenEx(cs, tc, ec) : {
			vars = GetAllTheUsedVars(cs).read |> set2array;
			isEmpty = make(true);
			makeForm = \__ -> makeIf(cs, tc, ec, isEmpty);
			if (length(vars) > 0) {
				makeSelect(vars, makeForm, isEmpty) |> v2a
			} else {
				false |> makeForm |> v2a
			}
		}
		WikiScoreEx(as, ms, cs, tooltip, vertical, inIconTooltip) : {

			feedback = if (isNotSpace(tooltip)) {
				space = if (vertical) [WikiBaseTextEx(" ")] else [GlueFragments(), WikiBaseTextEx(" "), GlueFragments()];
				arrayPush(space, WikiScoringIconEx(WikiScoringFeedback(), tooltip))
			} else {
				[]
			};

			correctIcon = [WikiScoringIconEx(WikiScoringCorrect(), "")]; //correct
			almostCorrectIcon = [WikiScoringIconEx(WikiScoringAlmostCorrect(), inIconTooltip)]; //almost correct
			incorrectIcon = [WikiScoringIconEx(WikiScoringIncorrect(), inIconTooltip)]; //incorrect
			missingIcon = [WikiScoringIconEx(WikiScoringMissing(), inIconTooltip)]; // missing

			correctIncorrectSelector = ConditionalWikiEx(cs, correctIcon, incorrectIcon) |> v2a;
			//We have to simulate if (mc) {\missing} else {if (cs) \correct else \incorrect}
			missingIconSelector = eitherMap(
				ms,
				\seq -> ConditionalWikiEx(seq, missingIcon, correctIncorrectSelector) |> v2a,
				correctIncorrectSelector
			);
			iconSelector = eitherMap(
				as,
				\seq -> ConditionalWikiEx(seq, almostCorrectIcon, missingIconSelector) |> v2a,
				missingIconSelector
			);

			whenCondition = WV_Sequence([WV_Print([WV_Comparison(WV_NumVar(WikiScoringVar), WV_Double("1"), WV_EQ())])]);
			whenConstruction = WikiWhenEx(whenCondition, concat(iconSelector, feedback), []);
			wikiFonts = getWikiFonts(concat(wikiStyle, ^globalWikiStyle));
			newWikiStyle = concat([updateInterlineSpacing(wikiFonts, 1.0)], wikiStyle);
			result = wikiConstruction2pe(whenConstruction, style, asMathForm, newWikiStyle);

			pe(if (vertical) {
				form = Available2(zeroSize, cast(result[0] : ParagraphElement -> Form));
				Baseline(const(sizeOfText(style)), form) |> v2a
			} else {
				result
			});
		}
		WikiCaseEx(cs, args) : {
			vars = GetAllTheUsedVars(cs).read |> set2array;
			isEmpty = make(true);
			makeSelect(vars, \__ -> makeWikiSwitch(cs, floor, args, isEmpty), isEmpty) |> v2a
		}
		WikiDebugEx(src) : {
			src |> processWikiVarsInWholeString |> println;
			[]
		}

		WikiButtonEx(ht, seq, width) : {
			enabled = getInteractivenessSwitch(wikiStyle);
			doAction = \ -> seq |> processWVSequence |> ignore;
			btnF = if (isUrlParameterTrue("paamskin") && isUrlParameterTrue("fix37528")) {
				btnColorStyle = extract(wikiStyle, wikiBtnPaamStyle(white, 0xe5e4e4),
					\ws -> switch(ws : WikiStyle) {
						WikiKaleidoscopeTileButtonStyle(pressCapCol, btnDefCol) : Some(wikiBtnPaamStyle(pressCapCol, btnDefCol));
						default: None();
					}
				);
				makeWikiPaamButton(processWikiVarsInWholeString(_(ht)), [Fill(0x000000), FontFamily("ProximaNova-Semibold")], btnColorStyle, WidthHeight(width, 18.0), doAction)
			} else {
				goButton(width, 18.0, 4.5, processWikiVarsInWholeString(_(ht)), [Fill(0x000000)], lightGrayButtonBrush, lightGrayHoverBrush, lightGrayPressedBrush, enabled, "", doAction)
			}
			Baseline(const(14.0), btnF) |> hiScale20 |> v2a
		}
		WikiPicButtonEx(seq, bt, hv, pr) : {
			enabled = getInteractivenessSwitch(wikiStyle);
			doAction = \ -> seq |> processWVSequence |> ignore;
			makePic = \constructions -> {
					constructions
					|> processConstructions
					|> \pes -> inheritedAvailableParagraph(pes, [TightWidth()])
					|> InfiniteWidthInsteadZero
					|> NonZeroSize;
			}

			formWH = makeWH();
			pic = Inspect([ISize(formWH)], makePic(bt));
			state = make(0);
			hovered = select(state, eq(2)); //magic number from buttons.flow
			hover = eitherFn(hv, makePic, \ -> Select(formWH, \wh -> Graphics(rectangle(0.0, 0.0, wh.width, wh.height), [Fill(lightGray), FillOpacity(0.25)])));

			pressed = select(state, eq(3)); //magic number from buttons.flow
			pressedForm = eitherMap(pr, makePic, Empty());

			form = Group([
				pic,
				Alpha(select(hovered, b2d), hover),
				Alpha(select(pressed, b2d), pressedForm)
			]);
			Size2(formWH, CustomFormButton(form, doAction, "", [BtnManualHovering(state), ButtonEnabled(enabled)])) |> v2a
		}
		WikiSliderEx(name, minSeq, maxSeq, stepSeq, widthSeq) : {
			enabled = getInteractivenessSwitch(wikiStyle);
			defaultSliderLength = 100.0;
			sliderBehaviour = getDoubleVarBehaviour(getGlobalWVEnvironment(), name);
			parameters = [minSeq, maxSeq, stepSeq, widthSeq];
			vals = map(parameters, \p -> p |> processWVSequence |> s2d);
			minVal = vals[0];
			maxVal = vals[1];
			stepVal = vals[2];
			widthVal0 = if (0.0 < vals[3]) {
				vals[3]
			} else {
				defaultSliderLength
			}
			aas20 = min(getAdaptiveScale(), 2.0);
			defaultBW = 18.0;
			widthVal = if(aas20 == 1.0) widthVal0 else {
				widthVal0 / aas20 - 2.0 * defaultBW * (1.0 / aas20 - 1.0) // to give space to buttons also
			}
			makeNumericSlider2(sliderBehaviour, minVal, maxVal, stepVal, widthVal, [SnapOnClick(true), SliderEnabled(enabled)]) |> NonZeroSize |> hiScale20 |> v2a
		}
		WikiForcedExpandEx(src) : {
			wikifyTextEx(processWikiVarsInWholeString(src), style, asMathForm, wikiStyle)
		}
		WikiSelectEx(vars, constructions) : {
			isEmpty = make(true);
			makeSelect(vars, makeDefaultSelectUpdateForm(constructions, isEmpty), isEmpty) |> v2a
		}
		WikiRepeatEx(timesSeq, constructions) : {
			times = timesSeq |> processWVSequence |> s2d |> floor;
			pe(if (times > 0) {
				elements = constructions |> processConstructions;
				generate(0, times, \__ -> elements) |> concatA;
			} else {
				[Empty()]
			});
		}
		WikiComboBoxEx(varName, suggestedWidth, reorderElements, items) : {
			varBehaviour = getDoubleVarBehaviour(getGlobalWVEnvironment(), varName);
			itemsCount = length(items);
			ensureCorrectOffset = \val -> min(itemsCount, max(0, val));
			double2int = round;
			itemsAndHelpers = if (reorderElements && 2 < itemsCount) {
				permutation = generate(1, itemsCount, idfn) |> shuffleArray |> \a -> concat([0], a); //First element is always like "Please select" and should not be shuffleArrayd
				permutedItems = mapi(items, \i, item -> items[permutation[i]]);
				findCorrespondingPosition = \i -> elemIndex(permutation, i, 0); //Not found should not happen, but let's use zero in such a case as default value of Wiki var.
				Triple(permutedItems, \val -> val |> double2int |> ensureCorrectOffset |> findCorrespondingPosition, \i -> permutation[i] |> i2d)
			} else {
				Triple(items, \val -> val |> double2int |> ensureCorrectOffset, i2d)
			}
			finalItems = itemsAndHelpers |> firstOfTriple;
			v2s = itemsAndHelpers |> secondOfTriple;
			s2v = itemsAndHelpers |> thirdOfTriple;
			selected = varBehaviour |> getValue |> v2s |> make;
			makeWikiComboBox(
				finalItems,
				selected,
				suggestedWidth,
				style,
				wikiStyle,
				CustomWikify,
				\-> {
					bidirectionalLink(varBehaviour, selected, v2s, s2v);
				}
			) |> v2a;
		}
		WikiRadioButtonsEx(varName, wrap, vertical, widthSeq, variants, variantsS) : {
			defaultWidth = 80.0;
			minWidth = 10.0;
			width = max(minWidth, widthSeq |> processWVSequence |> s2d);
			varBehaviour = getDoubleVarBehaviour(getGlobalWVEnvironment(), varName);
			makeForms = \i, variant -> {
				if (length(variant) == 0) {
					Triple("", Empty(), Empty())
				} else {
					color = colorOfText(style);
					unselected = Circle(9.0, 6.0, 6.0, [FillOpacity(0.0), Fill(color), Stroke(color), StrokeWidth(2.0)]);
					selected = Group([unselected, Circle(9.0, 6.0, 4.0, [StrokeWidth(0.0), Fill(color)])]);
					addIndicator = \indicator -> \base -> {
						if (vertical) {
							Cols([Align2(0.0, 0.5, indicator), Fixed(10.0, 0.0), base])
						} else {
							Lines([base, Fixed(0.0, 5.0), Align2(0.5, 0.0, indicator)])
						}
					};
					addParagraphAlign = \pes -> {
						if (wrap && vertical)
							Paragraph(pes, [StartAlign()])
						else if (wrap && !vertical)
							Paragraph(pes, [CenterAlign()])
						else if (vertical)
							Align2(0.0, 0.0, toOneForm(pes))
						else
							Align2(0.5, 0.0, toOneForm(pes))
					}
					setAvailable = \f -> Available2(const(WidthHeight(width, 0.0)), f);
					setSize = \f -> MinWidth(const(width), f);
					form = mapConcat(variant, recCall)
						|> addParagraphAlign
						|> setAvailable
						|> setSize;
					Triple(
						variantsS[i],
						form |> addIndicator(unselected),
						form |> addIndicator(selected)
					)
				}
			}
			makeOneForm = \arrF -> {
				if (vertical) WideLines(arrF) else toOneForm(arrF)
			}

			pickedIndex = varBehaviour |> getValue |> round |> make;

			shadowing = isButtonShadow();
			setButtonShadow(false);
			r = CustomRadioGroup3(mapi(variants, \i, v -> makeForms(i, v)), pickedIndex, nop1) |> makeOneForm ;
			setButtonShadow(shadowing);
			Constructor(
				r,
				\ -> bidirectionalLink(varBehaviour, pickedIndex, round, i2d)
			) |> v2a
		}
		WikiTimelineEx(name, durationSeq, maxSeq, widthSeq, doLoop, maxLoopsCount) : {
			parameters = [durationSeq, maxSeq, widthSeq];
			vals = map(parameters, \p -> p |> processWVSequence |> s2d);
			duration = vals[0];
			maxVal = vals[1];
			widthVal = vals[2];
			paused = make(true);
			wikiVar = getDoubleVarBehaviour(getGlobalWVEnvironment(), name);
			timelineBehaviour = make(0.0);
			tl = getTimeline(5);
			tl.stop();
			controls = {
				play_pic = "images/play.swf";
				pause_pic = "images/pause.swf";
				playFn = \ -> {
					tl.start();
					next(paused, false);
				};
				pauseFn = \ -> {
					tl.stop();
					next(paused, true)
				};
				playButton = playerButton(play_pic, const(true), playFn);
				pauseButton = playerButton(pause_pic, const(true), pauseFn);
				CachedSwitch(
					select(paused, b2i),
					[pauseButton, playButton]
				)
			}

			initialOffset = ref 0.0;
			currentLoop = ref 1;
			line = makeScrubber(const(duration), timelineBehaviour, make(false), const(widthVal), \newPos -> {
				tl.reset();
				initialOffset := newPos;
				next(timelineBehaviour, newPos)
			}, false);

			Constructor(
				Cols([FixWidth(const(playerIconSize), controls), Fixed(5.0, 0.0), line]),
				\ -> {
					uns1 = subscribe(timelineBehaviour, \val -> {
						next(wikiVar, val / duration * maxVal)
					});
					uns2 = subscribe(tl.ticker, \val -> {
						newVal = val * 0.001 + ^initialOffset;
						if (newVal > duration) {
							tl.reset();
							initialOffset := 0.0;
							if (doLoop && (maxLoopsCount == 0 || ^currentLoop < maxLoopsCount)) {
								currentLoop := ^currentLoop + 1;
								next(timelineBehaviour, 0.0);
							} else {
								next(paused, true);
								tl.stop();
								next(timelineBehaviour, duration);
							}
						} else {
							next(timelineBehaviour, newVal)
						}
					});
					\ -> {
						uns2();
						uns1();
					}
				}
			) |> v2a
		}
		WikiBlankEx(width, matching, answersData) : {
			makeWikiBlank(width, matching, answersData, style, wikiStyle) |> v2a
		}
		WikiScoringIconEx(type, tooltip) : {
			fontSize = sizeOfText(style);
			baseFontSize = NormalText |> sizeOfText;
			iconDescription = getWikiScoringIconDescription(type);
			scale = iconDescription.getScale(fontSize / baseFontSize);
			form = Scale(const(scale.first), const(scale.second), Baseline(const(iconDescription.baseline), Picture(iconDescription.path, [])));
			tooltipPair = makeWikiTooltip2(tooltip);
			addConstructor = eitherMap(
				getScoringStatsCollector(),
				\stats -> {
					countingBehaviour = switch(type : WikiScoringIconType) {
						WikiScoringCorrect() : stats.correct;
						WikiScoringAlmostCorrect() : stats.almostcorrect;
						WikiScoringIncorrect() : stats.incorrect;
						WikiScoringMissing() : stats.missing;
						WikiScoringFeedback() : make(0);
					}
					\icon -> Constructor(
						icon,
						\ -> {
							next(countingBehaviour, getValue(countingBehaviour) + 1);
							\ -> {
								next(countingBehaviour, getValue(countingBehaviour) - 1)
							}
						}
					)
				},
				idfn
			);
			withWikiTooltip3(form |> addConstructor, tooltipPair.first, tooltipPair.second, None(), true, iconDescription.hideWhenDynamicTooltipIsEmpty) |> v2a
		}
		WikiInlineBullet() : {
			getWikiFonts(wikiStyle).bullet |> v2a
		}
		WikiNewLine() : {
			nl : WrapElement = NewLine();
			sp : WrapElement = makeZeroSpaceElement(style);
			l : List<WrapElement> = Cons(sp, Cons(nl, Cons(sp, EmptyList())));
			//Some of gluing postprocesing is to greedy.
			pe([Empty(), TextFragments(l), Empty()])
		}
		WikiCalc() : {
			f = make(Empty());

			Select(f, \form -> {
				if (form == Empty()) {
					hideCalc = \ -> {
						next(f, Empty())
					}
					showCalc = \ -> {
						next(f, CallWikiCalc(hideCalc))
					}
					AnimatedButton(Picture("images/calculator_icon_normal.png", []),  const(true), "", showCalc)
				} else {
					form
				}
			}) |> v2a
		}
		WikiSequenceEx(sequence) : {
			//Fix for 33964
			// Should be safe as restores old behaviour of Paragraph engine
			// in this specific case
			res = processWVSequence(sequence);
			pe(if (res != "") {
				returnText(res |> htmlEscape, style)
			} else {
				[AllowLineBreak]
			});
		}
		MathNumber2StringEx(seq) : {
			numberM = seq |> processWVSequence |> useWikiFormulaTextBuilder;
			returnText(either(numberM, "Cannot convert number to string"), style);
		}
		MathNumber2SciNotEx(ns, dcs, trailingZeroes) : {
			number = ns |> processWVSequence |> s2d;
			digitsCount = dcs |> processWVSequence |> s2d |> floor;

			pe(unpair(normalizeScientificNumber(number, 0.0), \m, exponent -> {
				ipl = m |> abs |> floor |> i2s |> strlen;

				mantissaString = decimals(m, max(digitsCount - ipl, 0), trailingZeroes);

				hasDot = strIndexOf(mantissaString, ".") != -1;

				mantissaLen = strlen(mantissaString);

				finalMantissa = strLeft(mantissaString, min(mantissaLen, max(1, digitsCount + b2i(hasDot))));

				concatA([
					makeTextForm(finalMantissa + " ", style),
					makeTextForm("&#215;", style |> asBook),
					makeTextForm(" 10", style),
					makeSuperscript(d2s(exponent), style)
				]) |> glueElements
			}));
		}
		WikiPredefinedColorEx(color, constructions) : {
			processConstructionsStyled(constructions, style |> withFillColor(color))
		}
		MathNaturalSyntaxEx(src) : {
			resM : Maybe<Form> = useFormulaFormBuilder(src, style |> colorOfText, style |> sizeOfText);

			pe(eitherFn(
				resM,
				\res -> [res |> NonZeroSize],
				\ -> returnText("`" + src + "`" |> htmlEscape, style)
			))
		}
		MathRootEx(dc, bc, src) : {
			degree = dc |> processConstructionsAsSmallMath |> toOneForm;
			body = bc |> processConstructionsAsMath |> toOneForm;
			[root2formWithColor(degree, body, colorOfText(style))]
		}
		MathLongDivisionEx(bc, src) : {
			body = bc |> processConstructionsAsMath |> toOneForm;
			longDivision2formWithColor(body, colorOfText(style)) |> v2a
		}
		MathStrikeEx(bc, dxSeq, dySeq, mcolor, src) : {
			dx = dxSeq |> processWVSequence |> s2d;
			dy = dySeq |> processWVSequence |> s2d;
			body = bc |> processConstructionsAsMath |> toOneForm;
			color = either(mcolor, colorOfText(style));
			strikeOutWithColor(body, color, -dx, -dy) |> v2a
		}
		WikiUnderline2Ex(bc, dySeq, dlSeq, drSeq) : {
			dy = dySeq |> processWVSequence |> s2d;
			dl = dlSeq |> processWVSequence |> s2d;
			dr = drSeq |> processWVSequence |> s2d;
			body = bc |> processConstructionsAsMath |> toOneForm;
			bw = make(0.0);
			color = colorOfText(style);
			sw = 1.0;
			gs = [Stroke(color), StrokeOpacity(sw)];
			unpair(getDynamicFormSize(body), \bodyM, fm -> {
				Baseline(
					select(fm, \m -> m.baseline),
					Lines([
						Inspect([Width(bw)], bodyM),
						Size2(
							const(WidthHeight(0.0, sw)),
							Offset(-dl, -dy, Select(bw, \w -> Graphics([MoveTo(0.0, 0.0), LineTo(w + dl + dr, 0.0)], gs)))
						)
					])
				)
			}) |> v2a
		}
		WikiRotateEx(bc, angleSeq) : {
			angle = angleSeq |> processWVSequence |> s2d;
			body = bc |> processConstructionsAsMath |> toOneForm;
			wh = makeWH();
			ca = cosinus(angle);
			sa = sinus(angle);

			dx = make(0.0);
			dy = make(0.0);
			newWH = makeWH();

			subscr = \ -> subscribe(wh, \wh_ -> {
				lbx = - wh_.height * sa;
				lby = wh_.height * ca;
				rbx = wh_.width * ca - wh_.height * sa;
				rby = wh_.height * ca + wh_.width * sa;
				rtx = wh_.width * ca;
				rty = wh_.height * sa;

				minX = min3(lbx, rbx, rtx);
				minY = min3(lby, rby, rty);
				maxX = max3(lbx, rbx, rtx);
				maxY = max3(lby, rby, rty);

				nextDistinct(dx, max(0.0, -minX));
				nextDistinct(dy, max(0.0, -minY));
				nextDistinct(newWH, WidthHeight(maxX-minX, maxY-minY));
			});

			Constructor(
				Translate(dx, dy,
					Size2(newWH,
						Rotate(const(angle), Inspect([ISize(wh)], body))
					)
				),
				subscr
			) |> v2a
		}
		WikiScaleEx(bc, scaleSeq) : {
			scale = scaleSeq |> processWVSequence |> s2d;
			if (scale > 0.0 && !equalDoubles(scale, 0.0)) {
				awh_ = makeWH();
				awh = select(whenSizeChanged(awh_), \wh -> WidthHeight(wh.width / scale, wh.height / scale));
				body = 	bc |> processConstructions |> \pes -> inheritedAvailableParagraph(pes, [TightWidth()]);
				Inspect([IAvailable(awh_)], Scale(const(scale), const(scale), Available2(awh, body))) |> v2a
			} else {
				[Empty()]
			}
		}
		WikiMutableEx(name) : {
			tree = either(
				findmap(wikiStyle, \s -> switch (s) {ExternallyGeneratedForms(forms) : Some(forms()); default : None();}),
				makeTree()
			);
			eitherMap(
				lookupTree(tree, name),
				\makeForm -> {
					form : Form = makeForm(wikiStyle);
					form |> v2a
				},
				[Empty()]
			)
		}
		MathFracEx(ec, dc, src) : {
			enumerator =  ec |> processConstructionsAsMath |> toOneForm;
			denumerator = dc |> processConstructionsAsMath |> toOneForm;
			fraction2formWithColor(enumerator, denumerator, colorOfText(style)) |> v2a
		}
		MathBracketEx(lb, rb, bc, src) : {
			body = bc |> processConstructionsAsMath |> toOneForm;
			brackets2formWithColor(lb, rb, body, colorOfText(style)) |> v2a
		}
		DefiniteControlEx(signType, tc, fc, bc) : {
			to   = tc |> processConstructionsAsSmallMath |> toOneForm;
			from = fc |> processConstructionsAsSmallMath |> toOneForm;
			body = bc |> processConstructionsAsMath |> toOneForm;
			definiteControl2formWithColor(signType, to , from, body, colorOfText(style)) |> v2a
		}
		MathScriptEx(type, bc, sc, src) : {
			body   = bc |> processConstructionsAsMath			|> toOneForm;
			script = sc |> processConstructionsAsSmallMath |> toOneForm;
			makeForm = switch(type : MathScriptType) {
				MathOverscript() : overscript2form;
				MathUnderscript() : underscript2form;
				MathSuperscript() : \b, s -> superscript2formWrap3(b, s, DummyMathFormWrappers(), false);
				MathSubscript() : \b, s -> subscript2form(b, s) |> pushBaseLine;
			}
			makeForm(body, script) |> v2a
		}
		MathDottedEx(bc, left, top, right, bottom, ls, rs, src) : {
			body = bc |> processConstructionsAsMath |> toOneForm;
			dotted2formWithColor(body, left, top, right, bottom, ls, rs, colorOfText(style)) |> v2a
		}
		CustomSymbol(symbol) : {
			drawCustomSymbolWithColor(CustomSymbol(symbol), sizeOfText(style), colorOfText(style)) |> v2a
		}
		WikiTopModificatorEx(type, size, bc, dySeq, dlSeq, dxSeq, naturalMath) : {
			dy = dySeq |> processWVSequence |> s2d;
			dl = dlSeq |> processWVSequence |> s2d;
			dx = dxSeq |> processWVSequence |> s2d;
			body = bc |> processConstructionsAsMath |> toOneForm;
			dxCalculated = b2d(naturalMath);
			corrections = WriteTopModificatorCorrections(dx + dxCalculated, dy, dl);
			topModificator2formWithColor(body, type, size, corrections, colorOfText(style)) |> v2a
		}
		WikiDraggableEx(wikiC, shapeC, feedbackC, strokeShapeS, fillShapeS, idSeq, dwSeq, dhSeq, strkSeq, flSeq) : {
			parameters = [idSeq, dwSeq, dhSeq, strkSeq, flSeq];
			vals = map(parameters, \p -> p |> processWVSequence |> s2d);
			idDrag = vals[0] |> trunc |> iabs;
			dragW = vals[1];
			dragH = vals[2];
			dragStroke = vals[3] |> trunc;
			dragFill = vals[4] |> trunc;

			strokeColor = if (strlen(strokeShapeS) > 0) Pair(dragStroke, opacity) else dummyColor;
			fillColor = if (strlen(fillShapeS) > 0) Pair(dragFill, opacity) else dummyColor;

			eitherMap(
				getDragDropBuffer(wikiStyle),
				\DDB -> {
					defaultDraggableWidth = 250.0;
					defaultDraggableHeight = 100.0;

					defStrkCol = -1;
					defFillCol = -1;
					allDrg = DDB.drgForm |> getValue;

					findLastValue = \arrDg : [DragStyle], st : int, condition : (int) -> bool, getVal : (int) -> double, defVal : () -> double -> {
						if (length(arrDg) > 0) {
							eitherFn(countUntilDownMb(st, 0, condition), getVal, defVal)
						} else {
							defVal()
						}
					}

					getDDIndex = \ID, arrForm -> either(findi(arrForm, \oneDDForm : DragStyle -> oneDDForm.ID == ID), -1);
					startPos = getDDIndex(idDrag, allDrg) |> \di -> if (di >= 0) di - 1 else length(allDrg) - 1;

					getDraggableSize : () -> WidthHeight = \ -> {
						dWidth = if (dragW > 0.0) dragW else findLastValue(allDrg, startPos, \ii -> getValue(allDrg[ii].dsize).width > 0.0, \ii -> getValue(allDrg[ii].dsize).width, \ -> defaultDraggableWidth);
						dHeight = if (dragH > 0.0) dragH else findLastValue(allDrg, startPos, \ii -> getValue(allDrg[ii].dsize).height > 0.0, \ii -> getValue(allDrg[ii].dsize).height, \ -> defaultDraggableHeight);

						WidthHeight(dWidth, dHeight)
					}

					dragInd = getDDIndex(idDrag, allDrg);
					currDragT : DragStyle = if (dragInd >= 0) allDrg[dragInd] else DragStyle(idDrag, make(Pair(0, 0)), makeWH(), make(Empty()), make(Empty()));
					next(currDragT.dsize, getDraggableSize());
					next(currDragT.dcolor, Pair(strokeColor.first, fillColor.first));

					feedback = makeCommonForm(feedbackC);

					textPic = makeCommonForm(wikiC);

					picDrag = {
						whp = makeWH();
						whs = makeWH();

						background = Iffe(length(shapeC) > 0,
							\ -> {
								scaleX = make(1.0);
								scaleY = make(1.0);

								Constructors(
									[
										\ -> connectSelect2u(whs, currDragT.dsize, scaleX, \w, dgWH -> if (w.width > 0.0) dgWH.width / w.width else 1.0),
										\ -> connectSelect2u(whs, currDragT.dsize, scaleY, \h, dgWH -> if (h.width > 0.0) dgWH.width / h.width else 1.0)
									],
									Scale(
										scaleX,
										scaleY,
										Inspect([ISize(whs)], makeCommonForm(shapeC))
									)
								)
							},
							\ -> Select2(currDragT.dsize, currDragT.dcolor, \dgWH, dcol -> {
								Rectangle(
									dgWH.width, dgWH.height,
									[Stroke(dcol.first), StrokeOpacity(strokeColor.second), Fill(dcol.second), FillOpacity(fillColor.second), StrokeWidth(1.0)]
								)
							})
						);

						backgroundSize = if (length(shapeC) > 0) whs else currDragT.dsize;
						dy = make(0.0);
						setBaseline = \f -> Constructor(
							shiftBaselineB(dy, f),
							\ -> connectSelect2u(whp, backgroundSize, dy, \h, bs -> 0.5 * max(bs.height - h.height, 0.0))
						);
						addFeedbackBorder = \f -> Border(2.0, 0.0, 2.0, 0.0, f);
						setAlign = \xa, ya -> \f -> Align2(xa, ya, f);
						fs = makeWH();
						setPos = \f -> {
							bw = 5.0;
							dx = make(bw);
							widthHeight = makeWH();

							Constructors(
								[
									\ -> connectSelectu(fs, dx, \wh -> max(wh.width, bw)),
									\ -> connectSelect2u(backgroundSize, dx, widthHeight, \awh, border -> WidthHeight(max(awh.width - border - bw, 0.0), awh.height))
								],
								Translate(
									dx,
									zero,
									Available2(widthHeight, f)
								)
							)
						}


						Available2(backgroundSize,
							Group([
								Baseline(zero, background),
								Baseline(zero, feedback) |> addFeedbackBorder |> addSizeInspector(fs) |> setAlign(0.0, 0.5),
								textPic |> addSizeInspector(whp) |> setAlign(0.5, 0.5) |> setPos
							])
						) |> setBaseline

					}

					stayPic = picDrag;

					picHover = picDrag;

					makeLabel = \lf, df, hdf, location -> {
						_dragging = make(0);
						alpha = make(1.0);
						Constructor(
							Draggable(
								location,
								Cursor(FingerCursor(), Alpha(alpha, lf)),
								Cursor(MoveCursor(), df), // during dragging
								Cursor(MoveCursor(), hdf) // when over dropspot
							),
							\ -> {
								uns1 = connectSelectu(dragging, _dragging, \d -> if (d == location) 1 else 0);
								draggingThis = distinctUntilChangedu(_dragging);
								uns2 = connectSelectu(draggingThis.value, alpha, \d -> if (d == 1) 0.3 else 1.0);

								\ -> {
									uns1();
									draggingThis.dispose();
									uns2();
								}
							}
						)
					};

					dgForm = makeLabel(stayPic, picDrag, picHover, idDrag);

					next(currDragT.form, dgForm);

					newAllDrg = if (dragInd >= 0) {
						replace(allDrg, dragInd, currDragT)
					} else {
						arrayPush(allDrg, currDragT)
					};

					next(DDB.drgForm, newAllDrg);

					setSize = \f -> {
						widthHeight = makeWH();
						Constructor(
							Size2(widthHeight, f),
							\ -> connectSelectu(currDragT.dsize, widthHeight, \wh -> WidthHeight(wh.width + 5.0, wh.height))
						);
					}

					Select(currDragT.connectedF, \currDropF ->  Iffe(currDropF != Empty(),
						\ -> Group([
							Alpha(const(0.0), currDropF |> setSize),
							Alpha(const(0.3), stayPic)
						]),
						\ -> dgForm |> setSize
					))

				},
				makeViewForDragAndDropElements(wikiC, dragW, dragH, fillColor, strokeColor)
			) |> v2a
		}
		WikiDroptargetEx(varName, wikiC, feedbackC, strokeShapeS, fillShapeS, idSeq, dwSeq, dhSeq, stkSeq, flSeq) : {
			parameters = [idSeq, dwSeq, dhSeq, stkSeq, flSeq];
			vals = map(parameters, \p -> p |> processWVSequence |> s2d);
			idDrop = vals[0] |> trunc |> iabs;
			dropW = vals[1];
			dropH = vals[2];
			dropStroke = vals[3] |> trunc;
			dropFill = vals[4] |> trunc;

			strokeColor = if (strlen(strokeShapeS) > 0) Pair(dropStroke, opacity) else dummyColor;
			fillColor = if (strlen(fillShapeS) > 0) Pair(dropFill, opacity) else dummyColor;

			eitherMap(
				getDragDropBuffer(wikiStyle),
				\DDB -> {
					defaultDroptargetWidth = 250.0;
					defaultDroptargetHeight = 100.0;

					defStrkCol = -1;
					defFillCol = -1;
					allDrp = \ -> DDB.drpForm |> getValue;
					allDrg = \ -> DDB.drgForm |> getValue;
					updateDDB = \arrF -> next(DDB.drpForm, arrF);
					varBehaviour = getDoubleVarBehaviour(getGlobalWVEnvironment(), varName);

					findLastValue = \arrDg : [DropStyle], st : int, condition : (int) -> bool, getVal : (int) -> double, defVal : () -> double -> {
						if (length(arrDg) > 0) {
							eitherFn(countUntilDownMb(st, 0, condition), getVal, defVal)
						} else {
							defVal()
						}
					}

					getDDIndex = \ID, arrForm -> either(findi(arrForm, \oneDDForm : DropStyle -> oneDDForm.ID == ID), -1);
					startPos = allDrp() |> \aDp -> {getDDIndex(idDrop, aDp) |> \di -> if (di >= 0) di - 1 else length(aDp) - 1};

					getDroptargetSize : () -> WidthHeight = \ -> {
						allDrp() |> \aDp -> {
							dWidth = if (dropW > 0.0) dropW else findLastValue(aDp, startPos, \ii -> getValue(aDp[ii].dsize).width > 0.0, \ii -> getValue(aDp[ii].dsize).width, \ -> defaultDroptargetWidth);
							dHeight = if (dropH > 0.0) dropH else findLastValue(aDp, startPos, \ii -> getValue(aDp[ii].dsize).height > 0.0, \ii -> getValue(aDp[ii].dsize).height, \ -> defaultDroptargetHeight);

							WidthHeight(dWidth, dHeight)
						}
					}

					getDroptargetColor : () -> Pair = \ -> allDrp() |> \aDp -> Pair(strokeColor.first, fillColor.first);

					getCurrDropT = \dpI,iDDrp -> {
						if (dpI >= 0)
							allDrp()[dpI]
						else
							DropStyle(iDDrp, make(Empty()), make(Pair(0, 0)), makeWH(), \v : double -> next(varBehaviour, v), make(Empty()));
					}

					getCurrDragT = \from : int -> {
						extract(
							allDrg(),
							DragStyle(-1, make(Pair(0, 0)), makeWH(), make(Empty()), make(Empty())),
							\oneDgForm : DragStyle -> if (oneDgForm.ID == from) Some(oneDgForm) else None()
						)
					}

					dropInd = \iDDrp -> getDDIndex(iDDrp, allDrp());

					currDropT : (int) -> DropStyle = \idDp -> getCurrDropT(dropInd(idDp), idDp);
					currDp = currDropT(idDrop);
					next(currDp.dsize, getDroptargetSize());
					next(currDp.dcolor, getDroptargetColor());

					addBorder = \f -> Available2(currDp.dsize, Border(5.0, 0.0, 5.0, 0.0, f));

					feedback = makeCommonForm(feedbackC);
					textPic = makeCommonForm(wikiC) |> addBorder;
					whp = makeWH();

					formDrop = Select2(currDp.dsize, currDp.dcolor, \dpWH, dcol -> {
						Rectangle(dpWH.width, dpWH.height, [Stroke(dcol.first), StrokeOpacity(strokeColor.second), Fill(dcol.second), FillOpacity(fillColor.second), StrokeWidth(1.0)])
					});
					formHover = Select2(currDp.dsize, currDp.dcolor, \dpWH, dcol -> {
						BevelFilter(2.0,
							Behind(\w1, h1 -> Graphics(roundedRect(w1, h1, 2.0), [Stroke(lightGray), StrokeWidth(7.0), StrokeOpacity(0.4)]),
								Rectangle(dpWH.width, dpWH.height, [Stroke(blue), Fill(dcol.second), FillOpacity(fillColor.second), StrokeWidth(2.0)])
							)
						)
					});

					delOldDpConnection = \f -> {
						allDrp() |> \aDp -> {
							idOldDpF = either(findi(aDp, \oneDDForm : DropStyle -> getValue(oneDDForm.form) == f), -1);

							if (idOldDpF >= 0) {
								next((aDp[idOldDpF]).connectedF, Empty());
								(aDp[idOldDpF]).val(0.0);
								aDp |> updateDDB
							}
						}
					}

					dropTargetForm = DropTarget(
						\from -> {
							currDg : DragStyle = getCurrDragT(from);

							if (getValue(currDp.connectedF) == Empty() && getValue(currDg.connectedF) == Empty()) {
								next(currDg.connectedF, getValue(currDp.form));
								currDp.val(i2d(currDg.ID));
								next(currDp.connectedF, getValue(currDg.form));
							} else if (getValue(currDp.connectedF) == getValue(currDg.form)) {
								next(currDg.connectedF, Empty());
								currDp.val(0.0);
								next(currDp.connectedF, Empty());
							} else if (getValue(currDp.connectedF) == Empty() && getValue(currDg.connectedF) != Empty()) {
								getValue(currDg.connectedF) |> delOldDpConnection;
								next(currDg.connectedF, getValue(currDp.form));
								currDp.val(i2d(currDg.ID));
								next(currDp.connectedF, getValue(currDg.form))
							}
						},
						formDrop,
						formHover
					);
					dx = make(0.0);
					dy = make(0.0);
					setBaseline = \f -> shiftBaselineB(dy, f);
					dpForm =
						Constructors(
							[
								\ -> connectSelect2u(whp, currDp.dsize, dx, \w, dpWH -> 0.5 * max(dpWH.width - w.width, 0.0)),
								\ -> connectSelect2u(whp, currDp.dsize, dy, \h, dpWH -> 0.5 * max(dpWH.height - h.height, 0.0))
							],
							Group([
								Baseline(zero, dropTargetForm), //Based on knowledge of baseline calculation process
								Translate(dx, dy, Inspect([ISize(whp)], textPic))
							])
							|> setBaseline
						);

					addFeedback = \form -> {
						unpair(
							getDynamicFormSize(form),
							\formM, metricsB -> {
								baseline = make(0.0);
								Constructor(
									Baseline(
							 			baseline,
							 			Cols([Align2(0.0, 0.5, feedback), Align2(0.0, 0.5, formM)])
									),
									\ -> connectSelectu(metricsB, baseline, \m -> m.baseline)
								)
							}
						)
					}

					next(currDp.form, dpForm);

					newAllDrp = allDrp() |> \aDp -> {
						di = dropInd(idDrop);
						if (di >= 0) {
							replace(aDp, di, currDp)
						} else {
							arrayPush(aDp, currDp)
						}
					}

					newAllDrp |> updateDDB;
					widthHeight = makeWH();
					setSize = \f -> Constructor(
						Size2(widthHeight, f),
						\ -> connectSelectu(currDp.dsize, widthHeight, \wh -> WidthHeight(wh.width + 5.0, wh.height))
					);

					Select(currDp.connectedF, \currDragF -> Iffe(currDragF != Empty(),
						\ -> currDragF |> setSize |> addFeedback,
						\ -> dpForm |> setSize |> addFeedback
					))

				},
				makeViewForDragAndDropElements(wikiC, dropW, dropH, fillColor, strokeColor)
			) |> v2a
		}
		WikiPopupEx(wikiC, wdSeq, htSeq, hASeq, vASeq) : {
			defWidth = 200.0;
			defHeight = 100.0;

			parameters = [wdSeq, htSeq, hASeq, vASeq];
			vals = map(parameters, \p -> p |> processWVSequence |> s2d);
			width = if (vals[0] > 0.0) vals[0] else defWidth;
			height = if (vals[1] > 0.0) vals[1] else defHeight;
			horizontalAlign = vals[2];
			verticalAlign = vals[3];

			textForm = wikiC |> makeCommonForm;

			closeWindow = ref nop;
			okButton = orangeSkinButton("OK", const(true), "Esc", \ -> ^closeWindow());

			addFrame = \ff -> frameAround2(ff, 2.0, 10.0, 0x000000, [Fill(0xffffff)]);

			makeForm = \frm, btn -> Available2(const(WidthHeight(getStageWidth(), getStageHeight())), Center(
				Border(3.0, 3.0, 3.0, 3.0,
					Lines([
						Available2(const(WidthHeight(width, if (height > 18.0) height - 18.0 else height)),
							Center(frm)
						),
						Available2(const(WidthHeight(width, 18.0)),
							Background([Fill(0xF0F0F0)], Align(0.5, 1.0, btn))
						)
					])
				) |> addFrame
			));

			form = makeForm(textForm, okButton);
			closeWindow := showModal(form);
			Disposer(form, \ -> ^closeWindow()) |> v2a
		}
		WikiLimiterEx(vars, resVar, cond, valSeq) : {
			resVal = valSeq |> processWVSequence |> s2d;
			arrayVarBehaviours = map(vars, \ varName -> getDoubleVarBehaviour(getGlobalWVEnvironment(), varName));
			resVarBehaviour = getDoubleVarBehaviour(getGlobalWVEnvironment(), resVar);

			lastChanged = make(-1);

			Constructor(
				Empty(),
			 	\ -> {
					unsubscribeVars =  arraySubscribe2(
						arrayVarBehaviours,
						\ind, before, after -> {
							if (before == 0.0 && after == 1.0) {
								next(lastChanged, ind)
							}
					});

					unsubscribeResVar = subscribe(resVarBehaviour, \rV -> {

						undoVarFunction = \ -> {
							indexOfChanged = getValue(lastChanged);
							if (indexOfChanged >= 0) next(arrayVarBehaviours[indexOfChanged], 0.0)
						};

						addTimer = \nms -> \undoFunction -> {
							timer(nms, undoFunction)
						}

						undoLastVar = \ -> {undoVarFunction |> addTimer(777)};

						if (cond == "<") {if (!(rV < resVal)) undoLastVar()} else {
						if (cond == "<=") {if (!(rV <= resVal)) undoLastVar()} else {
						if (cond == ">") {if (!(rV > resVal)) undoLastVar()} else {
						if (cond == ">=") {if (!(rV >= resVal)) undoLastVar()} else {
						if (cond == "=") {if (!(rV == resVal)) undoLastVar()} else {
						if (cond == "!=") {if (!(rV != resVal)) undoLastVar()}
						}
						}
						}
						}
						}
					});

				    \ -> {
				      unsubscribeVars();
				      unsubscribeResVar();
				    }
			  	}
			 ) |> v2a
		}
		WikiMessagesCollectorEx(otherAnswer, var, correctAnswers) : {
			varForBehaviour = if (isCorrectWVVarName(var)) var else "$" + var;
			varForProcess = strReplace(var, "$", "");
			resVarBehaviour = getDoubleVarBehaviour(getGlobalWVEnvironment(), varForBehaviour);

			messagesB = either(findmap(wikiStyle, \wS -> switch(wS : WikiStyle) { WikiMessages(msgs) : Some(msgs); default : None(); }), make([]));

			Constructor(
				Empty(),
			 	\ -> {
					unsubscribeResVar = subscribe(resVarBehaviour, \rV -> {
						messages = getValue(messagesB);
						idMsg = either(findi(messages, \oneMessage : Pair -> oneMessage.first == varForProcess), -1);
						updateMessages = \newMessages -> next(messagesB, newMessages);
						sortMessages = \newMessages -> sortCustom(newMessages, \oneMessage -> oneMessage.first, true);
						if (rV >= 0.0 && trunc(rV) < length(correctAnswers)) {
							if (idMsg < 0) {
								arrayPush(messages, Pair(varForProcess, correctAnswers[trunc(rV)])) |> sortMessages |> updateMessages
							} else {
								replace(messages, idMsg, Pair(varForProcess, correctAnswers[trunc(rV)])) |> sortMessages |> updateMessages
							}
						} else if (idMsg >= 0) { //if no answer chosen then add other-answer
							replace(messages, idMsg, Pair(varForProcess, otherAnswer)) |> sortMessages |> updateMessages
						} else {
							arrayPush(messages, Pair(varForProcess, otherAnswer)) |> sortMessages |> updateMessages
						}
					});
				    \ -> {
				      unsubscribeResVar();
				    }
			  	}
			 ) |> v2a
		}
		WikiAltTextCollectorEx(altText) : {
			wikiAltTextsB = either(findmap(wikiStyle, \wS -> switch(wS : WikiStyle) { WikiAltText(altTextsB) : Some(altTextsB); default : None(); }), make([]));
			dynArrayPush(wikiAltTextsB, altText);
			Empty() |> v2a;
		}
		GlueFragments() : {
			pe([GlueFragments()])
		}
		MathUnknownConstruction(text) : {
			WikiBaseTextEx(text) |> recCall
		}
	}
} //end wikiConstruction2pe
