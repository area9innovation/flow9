import material/material2tropic;
import material/material_ui;
import formats/dom/conversion/xml2string;
import ds/reducer;

export {
	// Assign this node to this element. Get this with MHTMLStage or makeHTMLStage
	htmlRAssign(element : native, assign : RAssign<IXmlNode>) -> void;
	materialRAssign(manager : MaterialManager, element : native, assign : RAssign<Material>) -> void;

	// Remove this path from this element.
	removeHtmlRValue(element : native, lvalue : RLValue) -> void;
}

/*
prepareHtmlStage() -> Pair<Material, ref native> {
	wh = make(WidthHeight(0.0, 0.0));
	m = MInspect([IAvailable(wh)], 
		MHTMLStage(wh, \stage -> {
			htmlRAssign(stage, assign)
			\ -> {
				// TODO: Add remove
			}
		})
	);
	Pair(m, nat);
}*/

htmlRAssign(element : native, assign : RAssign<IXmlNode>) -> void {
	// println(assign.lvalue);
	dom = findOrMakeHtmlElement(element, "", assign.lvalue);
	html = ixml2string(assign.value);
	setAttribute(dom, "innerHTML", html);
}

materialRAssign(manager : MaterialManager, element : native, assign : RAssign<Material>) -> void {
	dom = findOrMakeHtmlElement(element, "", assign.lvalue);
	id = rlvalue2path(assign.lvalue);

	f = staticTropic2fform(material2tropic(manager, assign.value), emptyStylesheet);
	d = renderFForm(f, const([]));
	addEventListener(d.clips[0], "removed", \ -> applyall(d.disposers));

	assignClip(element, id, d.clips[0]);
}

rlvalue2path(l : RLValue) -> string {
	switch (l) {
		RLeaf(): "";
		RLObject(key, rvalue): {
			"." + key + rlvalue2path(rvalue);
		}
		RLArrayIndex(index, rvalue): {
			"." + i2s(index) + rlvalue2path(rvalue);
		}
	}
}

findOrMakeHtmlElement(element : native, path : string, l : RLValue) -> native {
	switch (l) {
		RLeaf(): element;
		RLObject(key, rvalue): {
			npath = path + "." + key;
			// println("Looking for " + npath);
			elm = getElementById(npath);
			if (isElementNull(elm)) {
				// OK, we have to construct a new element
				nelement = createElement("div");
				appendChild(element, nelement);
				// println("adding div with id " + npath);
				setAttribute(nelement, "id", npath);
				// We have to fix the positioning
				setAttribute(nelement, "style", "position:static");
				findOrMakeHtmlElement(nelement, npath, rvalue);
			} else {
				// println("Found it");
				findOrMakeHtmlElement(elm, npath, rvalue);
			}
		}
		RLArrayIndex(index, rvalue): {
			npath = path + "." + i2s(index);
			// println("Looking for " + npath);
			elm = getElementById(npath);
			if (isElementNull(elm)) {
				// OK, we have to construct a new element
				nelement = createElement("div");
				appendChild(element, nelement);
				// println("adding div with id " + npath);
				setAttribute(nelement, "id", npath);
				// We have to fix the positioning
				setAttribute(nelement, "style", "position:static");
				findOrMakeHtmlElement(nelement, npath, rvalue);
			} else {
				// println("Found it");
				findOrMakeHtmlElement(elm, npath, rvalue);
			}

		}
	}
}

removeHtmlRValue(element : native, lvalue : RLValue) -> void {
	switch (lvalue) {
		RLeaf(): {}
		RLObject(key, value): {
			elm = getElementById(key);
			if (!isElementNull(elm)) {
				// Remove recursively: TODO: Not sure this is required.
				removeHtmlRValue(elm, value);
				removeElementChild(element, elm);
				// TODO: There is also .remove directly on the element, so we do not need to know
				// the parent.
			}
		}
		RLArrayIndex(index, rvalue): {
			println("TODO: Fix array index removal");
		}
	}
}
