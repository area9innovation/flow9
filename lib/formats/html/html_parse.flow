// Â© Copyright 2011 Area9 Technologies.

import formats/html/html;
import lingo/compiler/syntaxtree_util;
import formats/html/lingo_parser/ast;
import formats/html/lingo_parser/parser;
import formats/html/html_node;

export {
	// Following HTML parsing pitfalls are handled:
	// - optionality of closing tags: </li>, </tr>, </td> (may be skipped for certain next opening tags)
	// - stray </br> and </p> tags with no corresponding opening tags
	// - sudden interruption of the flow of tokens by closing </html> tag
	// Returns a pair: the sequence of toplevel HTML nodes and an error message (is empty when no error are found).
 	parseHtml(text: string) -> Pair<[HtmlNode], string>;

	HtmlTagKind ::= HtmlTagOpen, HtmlTagClose, HtmlTagClopen;
		HtmlTagOpen(); HtmlTagClose(); HtmlTagClopen();
	parseHtmlPlain(src : string, err : (string) -> void) -> [Pair<HtmlNode, HtmlTagKind>];
}

parseHtml(text: string) -> Pair<[HtmlNode], string> {
	err = ref "";
	on_err = \s -> err := ^err + (if (^err == "") "" else "\n") + "html parsing error: " + s;
	plain = parseHtmlPlain(text, on_err);
	nodes = parseHtmlStructured(plain, on_err);
	Pair(nodes, ^err);
}

parseHtmlStructured(elems : [Pair<HtmlNode, HtmlTagKind>], err : (string) -> void) -> [HtmlNode] {
	stack = parseHtmlNodeStructured(elems, 0, err, ParseHtmlStack(HtmlTag("html", [], []), makeList(), None()));
	if  (stack.parent != None()) {
		err("non-empty stack at the end of html parsing");
	}
	list2array(stack.elems);
}

ParseHtmlStack(
	tag : HtmlTag,
	elems : List<HtmlNode>,
	parent : Maybe<ParseHtmlStack>
);

closeHtmlTag(depth : int, stack : ParseHtmlStack, err : (string) -> void) -> ParseHtmlStack {
	if (depth == 0) stack else {
		switch (stack.parent) {
			Some(parent): {
				new_stack = ParseHtmlStack(parent with
					elems = Cons(
						HtmlTag(stack.tag with 
							children = list2array(stack.elems)
						),
						parent.elems
					),
				);
				closeHtmlTag(depth - 1, new_stack, err);
			}
			None(): {
				err("no parent of: " + htmlNode2s(stack.tag));
				stack;
			}
		}
	}
}

closeAllHtmlTags(stack : ParseHtmlStack) -> ParseHtmlStack {
	switch (stack.parent) {
		Some(parent): {
			new_stack = ParseHtmlStack(parent with
				elems = Cons(
					HtmlTag(stack.tag with 
						children = list2array(stack.elems)
					),
					parent.elems
				),
			);
			closeAllHtmlTags(new_stack);
		}
		None(): {
			stack;
		}
	}
}

parseHtmlNodeStructured(elems : [Pair<HtmlNode, HtmlTagKind>], i : int, err : (string) -> void, stack : ParseHtmlStack) -> ParseHtmlStack {
	if (i == length(elems)) {
		closeAllHtmlTags(stack); 
	} else {
		elem = elems[i].first;
		stack1 = switch (elem) {
			HtmlTag(tag, attribs, __): {
				switch (elems[i].second) {
					HtmlTagClopen(): {
						ParseHtmlStack(stack with elems = Cons(elem, stack.elems));
					}
					HtmlTagOpen(): {
						if (tag == "br" || tag == "p") {
							ParseHtmlStack(stack with elems = Cons(HtmlTag(tag, [], []), stack.elems));
						} else {
							depth = if (tag == "li") {
								if (stack.tag.tag == "li") 1 else 0;
							} else if (tag == "tr") {
								if (stack.tag.tag == "tr") 1 else
								if (stack.tag.tag == "td") 2 else 0;
							} else if (tag == "td") {
								if (stack.tag.tag == "td") 1 else 0;
							} else {
								0;
							}
							ParseHtmlStack(elem, makeList(), Some(closeHtmlTag(depth, stack, err)));
						}
					}
					HtmlTagClose(): {
						if (tag == "br" || tag == "p") {
							stack;
						} else {
							if (stack.tag.tag != tag) {
								depth = if (tag == "tr") {
									if (stack.tag.tag == "table") 0 else 
									if (stack.tag.tag == "td") 2 else 0;
								} else if (tag == "ul" || tag == "ol") {
									if (stack.tag.tag == "li") 2 else 0;
								} else if (tag == "table") {
									if (stack.tag.tag == "tr") 2 else
									if (stack.tag.tag == "td") 3 else 0;
								} else {
									0;
								}
								closeHtmlTag(depth, stack, err);
							} else {
								closeHtmlTag(1, stack, err);
							}
						}
					}
				}
			}
			default: {
				ParseHtmlStack(stack with elems = Cons(elem, stack.elems));
			}
		}
		parseHtmlNodeStructured(elems, i + 1, err, stack1);
	}
}

parseHtmlPlain(src : string, err : (string) -> void) -> [Pair<HtmlNode, HtmlTagKind>] {
	pr1 = parse_html_source(src);
	st = pr1.first;
	if (st.end != strlen(src)) {
		msg = "met: '" + pr1.second.met + "', while expected: '" + strGlue(pr1.second.expected, ", ") + "'";
		err("Syntax error: " + msg + ", html source:\n" + strIndent(src));
		[]
	} else {
		htmlMakeNodes(st, src, err);
	}
}

htmlMakeNodes(st : SyntaxTree, src : string, err : (string) -> void) -> [Pair<HtmlNode, HtmlTagKind>] {
	synt_trees = get_html_source_html_element_s(st);
	map(synt_trees,
		\elem -> {
			if (elem.rule == st_html_text) {
				Pair(HtmlText(grabSTText(elem, src)), HtmlTagOpen());
			} else if (elem.rule == st_html_comment) {
				comment = grabSTText(get_html_source_html_comment_text(elem), src);
				Pair(HtmlComment(comment), HtmlTagOpen());
			} else if (elem.rule == st_html_entity) {
				prefix = grabSTText(get_html_source_html_entity_prefix(elem), src);
				body = grabSTText(get_html_source_html_entity_body(elem), src);
				Pair(HtmlEntity(prefix, body), HtmlTagOpen());
			} else if (elem.rule == st_html_tag) {
				open = grabSTText(get_html_source_html_tag_open(elem), src);
				close = grabSTText(get_html_source_html_tag_close(elem), src);
				tag = toLowerCase(grabSTText(get_html_source_html_id(elem), src));
				attribs = htmlMakeAttribs(get_html_source_html_attrib_s(elem), src);
				if (open == "<" && close == "/>") {
					Pair(HtmlTag(tag, attribs, []), HtmlTagClopen());
				} else if (open == "<" && close == ">") {
					Pair(HtmlTag(tag, attribs, []), HtmlTagOpen());
				} else if (open == "</" && close == ">") {
					Pair(HtmlTag(tag, attribs, []), HtmlTagClose());
				} else {
					err("Illegal tag: " + grabSTText(elem, src));
					Pair(HtmlComment(""), HtmlTagOpen());
				}
			} else {
				// Shouldn't happen
				Pair(HtmlComment(""), HtmlTagOpen());
			}
		}
	);
}

htmlMakeAttribs(sts : [SyntaxTree], src : string) -> [HtmlAttrib] {
	map(sts,
		\elem -> {
			make_attrib = \v -> {
				key = toLowerCase(grabSTText(get_html_source_html_id(elem), src));
				val = toLowerCase(v);
				HtmlAttrib(key, val);
			}
			if (elem.rule == st_html_attrib1) {
				make_attrib(grabSTText(get_html_source_html_attrib1_val(elem), src));
			} else if (elem.rule == st_html_attrib2) {
				make_attrib(grabSTText(get_html_source_html_attrib2_val(elem), src));
			} else if (elem.rule == st_html_attrib3) {
				make_attrib(grabSTText(get_html_source_html_attrib3_val(elem), src));
			} else if (elem.rule == st_html_attrib4) {
				make_attrib("1");
			} else {
				// Shouldn't happen
				HtmlAttrib("", "");
			}
		}
	);
}
