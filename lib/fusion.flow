import string;
import behaviour;
import runtime;
import binarytree;
import geometry;

// This is a variant of behaviours where transforms are "distinct" and the transform
// functions can be fused together. Things are guaranteed to be leak free when you
// only use these functions and remember to free the result from "fuse" which instantiates
// the transform into a real behaviour.
export {
	// Example: fselect(b, FLift(\bv -> whatever));
	// fselect is distinct.
	fselect : (b : Transform<??>, fn : FFn<??, ?>) -> Transform<?>;
	// fselect2 and friends are distinct.
	fselect2 : (b1 : Transform<??>, b2 : Transform<???>, fn : FFn2<??, ???, ?>) -> Transform<?>;
	fselect3(v1 : Transform<??>, v2 : Transform<???>, v3 : Transform<????>, fn : (??, ???, ????) -> ?) -> Transform<?>;
	fselect4(v1 : Transform<??>, v2 : Transform<???>, v3 : Transform<????>, v4 : Transform<?????>, fn : (??, ???, ????, ?????) -> ?) -> Transform<?>;
	fselect5(v1 : Transform<??>, v2 : Transform<???>, v3 : Transform<????>, v4 : Transform<?????>, v5 : Transform<??????>,
		fn : (??, ???, ????, ?????, ??????) -> ?) -> Transform<?>;
	fsubselect : (b : Transform<??>, fn : FFn<??, Transform<?>>) -> Transform<?>;
	fsubselect2 : (b1 : Transform<??>, b2 : Transform<???>, fn : (??, ???) -> Transform<?>) -> Transform<?>;

	// Converts a Transform to a Behaviour, along with any unsubscribers
	fuse(t : Transform<?>) -> Pair<Behaviour<?>, [() -> void]>;
	ffuseinit(b : Transform<?>, init : DynamicBehaviour<?>) -> Pair<Behaviour<?>, () -> () -> void>;
	fsubscribe(t : Transform<?>, fn : (?) -> void) -> List<() -> void>;
	fsubscribe2(t : Transform<?>, fn : (?) -> void) -> List<() -> void>;

	// Same as when in transforms.flow
	fwhen(t : Transform<bool>, fn : () -> void) -> () -> void;

	// Helpers for fsubscribe that returns () -> void disposer when called.
	// These guys are distinctive, so f will not fire on updating v with the same value.
	makeSubscribe(v : Transform<?>, f : (?) -> void) -> () -> () -> void;
	makeSubscribe2(v : Transform<?>, f : (?) -> void) -> () -> () -> void;

	make2Subscribe(v1 : Transform<?>, v2 : Transform<??>, f : (?, ??) -> void) -> () -> () -> void;
	make2Subscribe2(v1 : Transform<?>, v2 : Transform<??>, f : (?, ??) -> void) -> () -> () -> void;

	make3Subscribe(v1 : Transform<?>, v2 : Transform<??>, v3 : Transform<???>, f : (?, ??, ???) -> void) -> () -> () -> void;
	make3Subscribe2(v1 : Transform<?>, v2 : Transform<??>, v3 : Transform<???>, f : (?, ??, ???) -> void) -> () -> () -> void;

	make4Subscribe(v1 : Transform<?>, v2 : Transform<??>, v3 : Transform<???>, v4 : Transform<????>,
		f : (?, ??, ???, ????) -> void) -> () -> () -> void;
	make4Subscribe2(v1 : Transform<?>, v2 : Transform<??>, v3 : Transform<???>, v4 : Transform<????>,
		f : (?, ??, ???, ????) -> void) -> () -> () -> void;

	make5Subscribe(v1 : Transform<?>, v2 : Transform<??>, v3 : Transform<???>, v4 : Transform<????>, v5 : Transform<?????>,
		f : (?, ??, ???, ????, ?????) -> void) -> () -> () -> void;
	make5Subscribe2(v1 : Transform<?>, v2 : Transform<??>, v3 : Transform<???>, v4 : Transform<????>, v5 : Transform<?????>,
		f : (?, ??, ???, ????, ?????) -> void) -> () -> () -> void;

	// Same as makeSubscribes only you return an array of disposers which are disposed every time transform changes
	makeSubscribeUns(v : Transform<?>, f : (?) -> [() -> void]) -> () -> () -> void;
	makeSubscribeUnsTimer(v : Transform<?>, ms : int, f : (?) -> [() -> void]) -> () -> () -> void;
	makeSubscribe2Uns(v : Transform<?>, f : (?) -> [() -> void]) -> () -> () -> void;
	make2SubscribeUns(v1 : Transform<?>, v2 : Transform<??>, f : (?, ??) -> [() -> void]) -> () -> () -> void;
	make2Subscribe2Uns(v1 : Transform<?>, v2 : Transform<??>, f : (?, ??) -> [() -> void]) -> () -> () -> void;

	// Same as makeSubscribes only you pass a trigger which enables or disables this subscription
	// Useful when you have to watch complex transforms, but need to handle them only when some expression is true
	makeSubscribeTrigger(trigger : Transform<bool>, v : Transform<?>, f : (?) -> void) -> () -> () -> void;
	makeSubscribe2Trigger(trigger : Transform<bool>, v : Transform<?>, f : (?) -> void) -> () -> () -> void;

	make2SubscribeTrigger(trigger : Transform<bool>, v1 : Transform<?>, v2 : Transform<??>, f : (?, ??) -> void) -> () -> () -> void;
	make2Subscribe2Trigger(trigger : Transform<bool>, v1 : Transform<?>, v2 : Transform<??>, f : (?, ??) -> void) -> () -> () -> void;

	make3SubscribeTrigger(trigger : Transform<bool>, v1 : Transform<?>, v2 : Transform<??>, v3 : Transform<???>,
		f : (?, ??, ???) -> void) -> () -> () -> void;
	make3Subscribe2Trigger(trigger : Transform<bool>, v1 : Transform<?>, v2 : Transform<??>, v3 : Transform<???>,
		f : (?, ??, ???) -> void) -> () -> () -> void;

	make4SubscribeTrigger(trigger : Transform<bool>, v1 : Transform<?>, v2 : Transform<??>, v3 : Transform<???>, v4 : Transform<????>,
		f : (?, ??, ???, ????) -> void) -> () -> () -> void;
	make4Subscribe2Trigger(trigger : Transform<bool>, v1 : Transform<?>, v2 : Transform<??>, v3 : Transform<???>, v4 : Transform<????>,
		f : (?, ??, ???, ????) -> void) -> () -> () -> void;

	make5SubscribeTrigger(trigger : Transform<bool>, v1 : Transform<?>, v2 : Transform<??>, v3 : Transform<???>, v4 : Transform<????>,
		v5 : Transform<?????>, f : (?, ??, ???, ????, ?????) -> void) -> () -> () -> void;
	make5Subscribe2Trigger(trigger : Transform<bool>, v1 : Transform<?>, v2 : Transform<??>, v3 : Transform<???>, v4 : Transform<????>,
		v5 : Transform<?????>, f : (?, ??, ???, ????, ?????) -> void) -> () -> () -> void;

	// Helpers for ref unsubscribers disposal
	dispUns(uns : ref () -> void) -> void;
	dispUns2(uns : ref Maybe<() -> void>) -> void;
	dispUnsA(uns : ref [() -> void]) -> void;
	dispUnsTree(uns : ref Tree<?, () -> void>, key : ?) -> void;

	// Relatively expensive if Transform has no subscribers
	fgetValue(t : Transform<?>) -> ?;
	// Extract all dynamic behaviours from the transform
	fgetDynamicBehaviours(t : Transform<?>) -> [DynamicBehaviour];

	// Check if transform has any dynamic behaviours
	isFConst(t : Transform<?>) -> bool;

	// Do not construct FSelect and friends directly - use the functions above instead.
	Transform<?> ::= ConstBehaviour<?>, DynamicBehaviour<?>, FSelect<?>, FSelect2<?>, FSubSelect<?>;

	// Common functions. Use FLift for other functions
	faddition(b1 : Transform<double>, b2 : Transform<double>) -> Transform<double>;
	fsubtract(b1 : Transform<double>, b2 : Transform<double>) -> Transform<double>;
	fmultiply(b1 : Transform<double>, b2 : Transform<double>) -> Transform<double>;

	fadditioni(b1 : Transform<int>, b2 : Transform<int>) -> Transform<int>;
	fsubtracti(b1 : Transform<int>, b2 : Transform<int>) -> Transform<int>;
	fmultiplyi(b1 : Transform<int>, b2 : Transform<int>) -> Transform<int>;

	fgreater(b1 : Transform<double>, b2 : Transform<double>) -> Transform<bool>;
	fless(b1 : Transform<double>, b2 : Transform<double>) -> Transform<bool>;

	fgreateri(b1 : Transform<int>, b2 : Transform<int>) -> Transform<bool>;
	flessi(b1 : Transform<int>, b2 : Transform<int>) -> Transform<bool>;

	// If b2 is 0, then the result is 0
	fdivide(b1 : Transform<double>, b2 : Transform<double>) -> Transform<double>;
	fnegate(b1 : Transform<double>) -> Transform<double>;

	fdividei(b1 : Transform<int>, b2 : Transform<int>) -> Transform<int>;
	fnegatei(b1 : Transform<int>) -> Transform<int>;

	fmax(b1 : Transform<?>, b2 : Transform<?>) -> Transform<?>; // For bools, this is OR
	fmin(b1 : Transform<?>, b2 : Transform<?>) -> Transform<?>; // For bools, this is AND
	fmax3(b1 : Transform<?>, b2 : Transform<?>, b3 : Transform<?>) -> Transform<?>; // For bools, this is OR
	fmin3(b1 : Transform<?>, b2 : Transform<?>, b3 : Transform<?>) -> Transform<?>; // For bools, this is AND
	fmaxA(v : [Transform<?>], def : ?) -> Transform<?>;
	fminA(v : [Transform<?>], def : ?) -> Transform<?>;

	farray(v1 : Transform<?>) -> Transform<[?]>;
	fconcat(v1 : Transform<[?]>, v2 : Transform<[?]>) -> Transform<[?]>;
	farrayPush(v1 : Transform<[?]>, v2 : Transform<?>) -> Transform<[?]>;
	fconcatA(v : Transform<[[?]]>) -> Transform<[?]>;
	fcontains(v1 : Transform<[?]>, v2 : Transform<?>) -> Transform<bool>;

	fcompose(f1 : FFn<flow, ??>, f2 : FFn<?, flow>) -> FFn<?, ??>;
	fif(b1 : Transform<bool>, then1 : Transform<?>, else1 : Transform<?>) -> Transform<?>;
	feq(b : Transform<?>, v : ?) -> Transform<bool>;
	fneq(a : Transform<?>, v : ?) -> Transform<bool>;
	fnot(b : Transform<bool>) -> Transform<bool>;
	fand(a : Transform<bool>, b : Transform<bool>) -> Transform<bool>;
	fOr(a : Transform<bool>, b : Transform<bool>) -> Transform<bool>;
	fxor(a : Transform<bool>, b : Transform<bool>) -> Transform<bool>;

	fpair(v1 : Transform<?>, v2 : Transform<??>) -> Transform<Pair<?, ??>>;
	// ftriple -> see fusion_utils.flow
	// fquadruple -> see fusion_utils.flow

	fwidthheight(wd : Transform<double>, hgt : Transform<double>) -> Transform<WidthHeight>;
	fpoint(x : Transform<double>, y : Transform<double>) -> Transform<Point>;
	fpointX(point : Transform<Point>) -> Transform<double>;
	fpointY(point : Transform<Point>) -> Transform<double>;
	ffactor(x : Transform<double>, y : Transform<double>) -> Transform<Factor>;
	ffactor2(f : Transform<double>) -> Transform<Factor>;
	fwidth(wh : Transform<WidthHeight>) -> Transform<double>;
	fheight(wh : Transform<WidthHeight>) -> Transform<double>;
	fconnect(v1 : Transform<?>, v2 : DynamicBehaviour<?>) -> () -> void;
	fconnectSelect(v1 : Transform<?>, v2 : DynamicBehaviour<??>, fn : (?) -> ??) -> () -> void;
	fconnect2Select(t1 : Transform<?>, t2 : Transform<??>, v : DynamicBehaviour<???>, fn : (?, ??) -> ???) -> () -> void;
	fmerge(v : [Transform<?>]) -> Transform<[?]>;
	ffold(v : [Transform<??>], acc : ?, fn : (acc : ?, item : ??) -> ?) -> Transform<?>;
	fmergeTree(v : Tree<??, Transform<?>>) -> Transform<Tree<??, ?>>;
	fsum(v : [Transform<double>]) -> Transform<double>;
	fsumi(v : [Transform<int>]) -> Transform<int>;
	ftransistor(g : Transform<bool>, v: Transform<?>) -> Transform<?>;
	fthrottle(v : Transform<?>, samplingRate : int) -> Transform<?>;
	fthrottle2(v : Transform<?>, maxDelta : int) -> Transform<?>;
	fselectWithLast(b : Transform<??>, fn : FFn2<??, ??, ?>) -> Transform<?>;
	fdelay(v : Transform<?>, ms : int) -> Transform<?>;
	fstall(v : Transform<?>, ms : int) -> Transform<?>;
	fBidirectionalLink(v1 : Transform<?>, v2 : Transform<??>, fn1 : (?) -> void, fn2 : (??) -> void) -> () -> void;

	// This instantiates a FFn to a real function, performing fusion
	instantiateFn(f : FFn<?, ??>) -> (?) -> ??;
	instantiateFn2(fn : FFn2<?, ??, ???>) -> (?, ??) -> ???;

	// For debugging
	transform2string(s : Transform<?>) -> string;

	// Builtin functions - use the functions above instead
	FFn<?, ??> ::= FLift<?, ??>, FCompose<?, ??>, FIdentity, FNegate,
			FAddConst, FMulConst, FMaxConst, FMinConst, FEqual, FIf<??>;

		// This is for using any other transform function
		FLift(fn : (?) -> ??);
		FAddConst(c : double);
		FMulConst(c : double);
		FMaxConst(c : ?);
		FMinConst(c : ?);
		FIf(then : ?, else_ : ?);

		// Trivial function
		FIdentity();

	FFn2<?, ??, ???> ::= FLift2<?, ??, ???>, FIdentity2, FAddition, FSubtract,
			FMultiply, FDivide, FMax, FMin,
			FusionAnd, FusionOr, FusionXor;

		// This is for using any other transform function
		FLift2(fn : (?, ??) -> ???);
		FMax();
		FMin();
		FIdentity2();
		// f1 o f2 == f1(f2(x))
		FCompose(f1 : FFn<flow, ??>, f2 : FFn<?, flow>);
		FAddition();
		FSubtract();
		FMultiply();
		FDivide();
		FNegate();
		FEqual(v : ?);
		FusionAnd();
		FusionOr();
		FusionXor();
}

FBehaviour<?> ::= FDestroyed, FInitialized<?>;
	FInitialized(subs : ref int, disp : () -> void, dyn : DynamicBehaviour<?>);
	FDestroyed();

// These guys use flow to make sure the Transform union only has one polymorphic variable.
// Since we use the helpers fselect, fselect2, fsubselect, we will inductively get the
// necessary type guarantees anyways.
FSelect(b : Transform<flow>, fn : FFn<flow, ?>, mutable beh : FBehaviour<?>);
FSelect2(b1 : Transform<flow>, b2 : Transform<flow>, fn : FFn2<flow, flow, ?>, mutable beh : FBehaviour<?>);
FSubSelect(b : Transform<flow>, fn : FFn<flow, Transform<?>>, mutable beh : FBehaviour<?>);

fselect(b : Transform<??>, fn : FFn<??, ?>) -> Transform<?> {
	switch (b : Transform<??>) {
		ConstBehaviour(v): ConstBehaviour(instantiateFn(fn)(v));
		DynamicBehaviour(v, s): FSelect(b, fn, FDestroyed());
		FSelect(nb, fn2, __): {
			// select(select(a, f2), f1) = select(a, f1 o f2)
			// OK, try to compose them. If it helps resolve anything, then do it.
			// Notice that this composition might unmask useful stop changes from the first behaviour
			// that map to the same second value.
			c = fcompose(fn, fn2);
			switch (c) {
				FCompose(__, __): FSelect(b, fn, FDestroyed()); // Turns out there was no benefit, so don't do it!
				default: FSelect(nb, c, FDestroyed());
			}
		}
		FSelect2(nb1, nb2, fn2, __): FSelect(b, fn, FDestroyed());
		FSubSelect(sb, f2, __): FSelect(b, fn, FDestroyed());
	}
}

fselect2(b1 : Transform<??>, b2 : Transform<???>, fn : FFn2<??, ???, ?>) -> Transform<?> {
	t = FSelect2(b1, b2, fn, FDestroyed());

	switch (b1 : Transform<??>) {
		ConstBehaviour(v1): {
			ifn = instantiateFn2(fn);

			switch (b2 : Transform<???>) {
				ConstBehaviour(v2): ConstBehaviour(ifn(v1, v2));
				default: fselect(b2, FLift(\v -> ifn(v1, v)));
			}
		}
		FSelect(nb1, nf1, __): {
			ifn = instantiateFn2(fn);

			switch (b2 : Transform<???>) {
				FSelect(nb2, nf2, __): {
					ifn1 = instantiateFn(nf1);
					ifn2 = instantiateFn(nf2);
					FSelect2(nb1, nb2, FLift2(\f, s -> ifn(ifn1(f), ifn2(s))), FDestroyed());
				}
				default: {
					ifn1 = instantiateFn(nf1);
					FSelect2(nb1, b2, FLift2(\f, s -> ifn(ifn1(f), s)), FDestroyed());
				}
			}
		}
		default: {
			switch (b2 : Transform<???>) {
				ConstBehaviour(v2): {
					ifn = instantiateFn2(fn);
					fselect(b1, FLift(\v -> ifn(v, v2)));
				}
				FSelect(nb, nf2, __): {
					ifn = instantiateFn2(fn);
					ifn2 = instantiateFn(nf2);
					FSelect2(b1, nb, FLift2(\f, s -> ifn(f, ifn2(s))), FDestroyed());
				}
				default: {
					FSelect2(b1, b2, fn, FDestroyed());
				}
			}
		}
	}
}

fsubselect(b : Transform<??>, fn : FFn<??, Transform<?>>) -> Transform<?> {
	switch (b) {
		ConstBehaviour(v): {
			instantiateFn(fn)(v);
		}
		FSelect(a, f2, __): {
			c = fcompose(fn, f2);
			switch (c) {
				FCompose(cf1, cf2): FSubSelect(b, fn, FDestroyed());
				default: fsubselect(a, c);
			}
		}
		default: FSubSelect(b, fn, FDestroyed());
	}
}

fselect3(v1 : Transform<??>, v2 : Transform<???>, v3 : Transform<????>, fn : (??, ???, ????) -> ?) -> Transform<?> {
	fselect2(fpair(v1, v2), v3, FLift2(\vv12 : Pair<??, ???>, vv3 : ???? ->
		fn(firstOfPair(vv12), secondOfPair(vv12), vv3))
	)
}

fselect4(v1 : Transform<??>, v2 : Transform<???>, v3 : Transform<????>, v4 : Transform<?????>, fn : (??, ???, ????, ?????) -> ?) -> Transform<?> {
	fselect2(fpair(v1, v2), fpair(v3, v4), FLift2(\vv12 : Pair<??, ???>, vv34 : Pair<????, ?????> ->
		fn(firstOfPair(vv12), secondOfPair(vv12), firstOfPair(vv34), secondOfPair(vv34)))
	)
}

fselect5(v1 : Transform<??>, v2 : Transform<???>, v3 : Transform<????>, v4 : Transform<?????>, v5 : Transform<??????>,
	fn : (??, ???, ????, ?????, ??????) -> ?) -> Transform<?> {
	fselect2(fpair(fpair(v1, v2), fpair(v3, v4)), v5, FLift2(\vv1234 : Pair<Pair<??, ???>, Pair<????, ?????>>, vv5 : ?????? ->
		fn(vv1234.first.first, vv1234.first.second, vv1234.second.first, vv1234.second.second, vv5))
	)
}

fsubselect2(b1 : Transform<??>, b2 : Transform<???>, fn : (??, ???) -> Transform<?>) -> Transform<?> {
	fsubselect(fpair(b1, b2), FLift(\p : Pair<??, ???> -> fn(firstOfPair(p), secondOfPair(p))));
}

//indentation = ref "";

fuse(t : Transform<?>) -> Pair<Behaviour<?>, [() -> void]> {
	// println("Fuse on " + transform2string(t));
	r = doFuse(t);
	// Keep the closure small
	ds = secondOfPair(r);
	Pair(firstOfPair(r), [\ -> ds()]);
}

ffuseinit(t : Transform<?>, init : DynamicBehaviour<?>) -> Pair<Behaviour<?>, () -> () -> void> {
	switch (t : Transform<?>) {
		ConstBehaviour(v): Pair(t, \ -> nop);
		DynamicBehaviour(v, s): Pair(t, \ -> nop);
		default: {
			Pair(
				init,
				\ -> fconnect(t, init)
			)
		}
	}
}

fsubscribe(t : Transform<?>, fn : (?) -> void) -> List<() -> void> {
	r = doFuse(t);
	u = subscribe(firstOfPair(r), fn);
	Cons(u, Cons(secondOfPair(r), EmptyList()))
}

fsubscribe2(t : Transform<?>, fn : (?) -> void) -> List<() -> void> {
	r = doFuse(t);
	u = subscribe2(firstOfPair(r), fn);
	Cons(u, Cons(secondOfPair(r), EmptyList()))
}

fwhen(t : Transform<bool>, fn : () -> void) -> () -> void {
	uns = ref nop;
	uns := makeSubscribe(t, \v -> if (v) { ^uns(); uns := nop; fn(); })();
	\ -> ^uns()
}

makeSubscribe(t : Transform<?>, fn : (?) -> void) -> () -> () -> void {
	\ -> {
		r = doFuse(t);
		u = subscribe(firstOfPair(r), fn);
		\ -> {u(); secondOfPair(r)()}
	}
}

makeSubscribe2(t : Transform<?>, fn : (?) -> void) -> () -> () -> void {
	\ -> {
		r = doFuse(t);
		u = subscribe2(firstOfPair(r), fn);
		\ -> {u(); secondOfPair(r)();}
	}
}

make2Subscribe(v1 : Transform<?>, v2 : Transform<??>, f : (?, ??) -> void) -> () -> () -> void {
	makeSubscribe(fpair(v1, v2), \v12 : Pair<?, ??> -> f(firstOfPair(v12), secondOfPair(v12)))
}

make2Subscribe2(v1 : Transform<?>, v2 : Transform<??>, f : (?, ??) -> void) -> () -> () -> void {
	makeSubscribe2(fpair(v1, v2), \v12 : Pair<?, ??> -> f(firstOfPair(v12), secondOfPair(v12)))
}

make3Subscribe(v1 : Transform<?>, v2 : Transform<??>, v3 : Transform<???>, f : (?, ??, ???) -> void) -> () -> () -> void {
	makeSubscribe(fpair(fpair(v1, v2), v3), \v123 : Pair<Pair<?, ??>, ???> -> f(v123.first.first, v123.first.second, v123.second))
}

make3Subscribe2(v1 : Transform<?>, v2 : Transform<??>, v3 : Transform<???>, f : (?, ??, ???) -> void) -> () -> () -> void {
	makeSubscribe2(fpair(fpair(v1, v2), v3), \v123 : Pair<Pair<?, ??>, ???> -> f(v123.first.first, v123.first.second, v123.second))
}

make4Subscribe(v1 : Transform<?>, v2 : Transform<??>, v3 : Transform<???>, v4 : Transform<????>, f : (?, ??, ???, ????) -> void) -> () -> () -> void {
	makeSubscribe(fpair(fpair(v1, v2), fpair(v3, v4)), \v1234 : Pair<Pair<?, ??>, Pair<???, ????>> ->
		f(v1234.first.first, v1234.first.second, v1234.second.first, v1234.second.second))
}

make4Subscribe2(v1 : Transform<?>, v2 : Transform<??>, v3 : Transform<???>, v4 : Transform<????>, f : (?, ??, ???, ????) -> void) -> () -> () -> void {
	makeSubscribe2(fpair(fpair(v1, v2), fpair(v3, v4)), \v1234 : Pair<Pair<?, ??>, Pair<???, ????>> ->
		f(v1234.first.first, v1234.first.second, v1234.second.first, v1234.second.second))
}

make5Subscribe(v1 : Transform<?>, v2 : Transform<??>, v3 : Transform<???>, v4 : Transform<????>, v5 : Transform<?????>,
	f : (?, ??, ???, ????, ?????) -> void) -> () -> () -> void {
	makeSubscribe(fpair(fpair(v1, v2), fpair(fpair(v3, v4), v5)), \v12345 : Pair<Pair<?, ??>, Pair<Pair<???, ????>, ?????>> ->
		f(v12345.first.first, v12345.first.second, v12345.second.first.first, v12345.second.first.second, v12345.second.second))
}

make5Subscribe2(v1 : Transform<?>, v2 : Transform<??>, v3 : Transform<???>, v4 : Transform<????>, v5 : Transform<?????>,
	f : (?, ??, ???, ????, ?????) -> void) -> () -> () -> void {
	makeSubscribe2(fpair(fpair(v1, v2), fpair(fpair(v3, v4), v5)), \v12345 : Pair<Pair<?, ??>, Pair<Pair<???, ????>, ?????>> ->
		f(v12345.first.first, v12345.first.second, v12345.second.first.first, v12345.second.first.second, v12345.second.second))
}

makeSubscribeUns(v : Transform<?>, f : (?) -> [() -> void]) -> () -> () -> void {
	\ -> {
		uns = ref [];
		uns2 = makeSubscribe(v, \val -> {
			dispUnsA(uns);
			uns := f(val);
		})();

		\ -> {
			uns2();
			dispUnsA(uns);
		}
	}
}

makeSubscribeUnsTimer(v : Transform<?>, ms : int, f : (?) -> [() -> void]) -> () -> () -> void {
	\ -> {
		uns = ref [];
		uns2 = ref nop;
		uns3 = makeSubscribe(v, \val -> {
			dispUns(uns2);
			dispUnsA(uns);
			uns2 := interruptibleTimer(ms, \ -> uns := f(val));
		})();

		\ -> {
			dispUns(uns2);
			uns3();
			dispUnsA(uns);
		}
	}
}

makeSubscribe2Uns(v : Transform<?>, f : (?) -> [() -> void]) -> () -> () -> void {
	\ -> {
		uns = ref [];
		uns2 = makeSubscribe2(v, \val -> {
			dispUnsA(uns);
			uns := f(val);
		})();

		\ -> {
			uns2();
			dispUnsA(uns);
		}
	}
}

make2SubscribeUns(v1 : Transform<?>, v2 : Transform<??>, f : (?, ??) -> [() -> void]) -> () -> () -> void {
	\ -> {
		uns = ref [];
		uns2 = make2Subscribe(v1, v2, \val1, val2 -> {
			dispUnsA(uns);
			uns := f(val1, val2);
		})();

		\ -> {
			uns2();
			dispUnsA(uns);
		}
	}
}

make2Subscribe2Uns(v1 : Transform<?>, v2 : Transform<??>, f : (?, ??) -> [() -> void]) -> () -> () -> void {
	\ -> {
		uns = ref [];
		uns2 = make2Subscribe2(v1, v2, \val1, val2 -> {
			dispUnsA(uns);
			uns := f(val1, val2);
		})();

		\ -> {
			uns2();
			dispUnsA(uns);
		}
	}
}

makeSubscribeTrigger(trigger : Transform<bool>, v : Transform<?>, f : (?) -> void) -> () -> () -> void {
	makeSubscribeUns(trigger, \tr -> if (tr) [makeSubscribe(v, f)()] else []);
}

makeSubscribe2Trigger(trigger : Transform<bool>, v : Transform<?>, f : (?) -> void) -> () -> () -> void {
	makeSubscribeUns(trigger, \tr -> if (tr) [makeSubscribe2(v, f)()] else []);
}

make2SubscribeTrigger(trigger : Transform<bool>, v1 : Transform<?>, v2 : Transform<??>, f : (?, ??) -> void) -> () -> () -> void {
	makeSubscribeUns(trigger, \tr -> if (tr) [make2Subscribe(v1, v2, f)()] else []);
}

make2Subscribe2Trigger(trigger : Transform<bool>, v1 : Transform<?>, v2 : Transform<??>, f : (?, ??) -> void) -> () -> () -> void {
	makeSubscribeUns(trigger, \tr -> if (tr) [make2Subscribe2(v1, v2, f)()] else []);
}

make3SubscribeTrigger(trigger : Transform<bool>, v1 : Transform<?>, v2 : Transform<??>, v3 : Transform<???>,
	f : (?, ??, ???) -> void) -> () -> () -> void {
	makeSubscribeUns(trigger, \tr -> if (tr) [make3Subscribe(v1, v2, v3, f)()] else []);
}

make3Subscribe2Trigger(trigger : Transform<bool>, v1 : Transform<?>, v2 : Transform<??>, v3 : Transform<???>,
	f : (?, ??, ???) -> void) -> () -> () -> void {
	makeSubscribeUns(trigger, \tr -> if (tr) [make3Subscribe2(v1, v2, v3, f)()] else []);
}

make4SubscribeTrigger(trigger : Transform<bool>, v1 : Transform<?>, v2 : Transform<??>, v3 : Transform<???>, v4 : Transform<????>,
	f : (?, ??, ???, ????) -> void) -> () -> () -> void {
	makeSubscribeUns(trigger, \tr -> if (tr) [make4Subscribe(v1, v2, v3, v4, f)()] else []);
}

make4Subscribe2Trigger(trigger : Transform<bool>, v1 : Transform<?>, v2 : Transform<??>, v3 : Transform<???>, v4 : Transform<????>,
	f : (?, ??, ???, ????) -> void) -> () -> () -> void {
	makeSubscribeUns(trigger, \tr -> if (tr) [make4Subscribe2(v1, v2, v3, v4, f)()] else []);
}

make5SubscribeTrigger(trigger : Transform<bool>, v1 : Transform<?>, v2 : Transform<??>, v3 : Transform<???>, v4 : Transform<????>,
	v5 : Transform<?????>, f : (?, ??, ???, ????, ?????) -> void) -> () -> () -> void {
	makeSubscribeUns(trigger, \tr -> if (tr) [make5Subscribe(v1, v2, v3, v4, v5, f)()] else []);
}

make5Subscribe2Trigger(trigger : Transform<bool>, v1 : Transform<?>, v2 : Transform<??>, v3 : Transform<???>, v4 : Transform<????>,
	v5 : Transform<?????>, f : (?, ??, ???, ????, ?????) -> void) -> () -> () -> void {
	makeSubscribeUns(trigger, \tr -> if (tr) [make5Subscribe2(v1, v2, v3, v4, v5, f)()] else []);
}

dispUns(uns : ref () -> void) -> void {
	^uns();
	uns := nop;
}

dispUns2(uns : ref Maybe<() -> void>) -> void {
	// a version of dispUns() without functions comparison
	switch (^uns) {
		Some(f): {
			f();
			uns := None();
		}
		None(): {}
	}
}

dispUnsA(uns : ref [() -> void]) -> void {
	if (length(^uns) > 0) {
		applyall(^uns);
		uns := [];
	}
}

dispUnsTree(uns : ref Tree<?, () -> void>, key : ?) -> void {
	maybeApply(lookupTree(^uns, key), \v -> v());
	uns := removeFromTree(^uns, key);
}

fgetValue(t : Transform<?>) -> ? {
	switch (t : Transform<?>) {
		ConstBehaviour(b):
			b;
		DynamicBehaviour(b, s):
			^b;
		FSelect(b, fn, beh):
			switch (beh) {
				FInitialized(__, __, dyn): getValue(dyn);
				FDestroyed(): instantiateFn(fn)(fgetValue(b));
			}
		FSelect2(b1, b2, fn, beh):
			switch (beh) {
				FInitialized(__, __, dyn): getValue(dyn);
				FDestroyed(): instantiateFn2(fn)(fgetValue(b1), fgetValue(b2));
			}
		FSubSelect(b, fn, beh):
			switch (beh) {
				FInitialized(__, __, dyn): getValue(dyn);
				FDestroyed(): fgetValue(instantiateFn(fn)(fgetValue(b)));
			}
	}
}

fgetDynamicBehaviours(t : Transform<?>) -> [DynamicBehaviour] {
	switch (t) {
		ConstBehaviour(b): [];
		DynamicBehaviour(b, s): [t];
		FSelect(b, f1, __): fgetDynamicBehaviours(b);
		FSelect2(b1, b2, f1, __): concat(fgetDynamicBehaviours(b1), fgetDynamicBehaviours(b2));
		FSubSelect(b, f1, __): fgetDynamicBehaviours(b);
	}
}

isFConst(t : Transform<?>) -> bool {
	switch (t) {
		ConstBehaviour(v): true;
		default: false;
	}
}

doFuse(t : Transform<?>) -> Pair<Behaviour<?>, () -> void> {
	switch (t : Transform<?>) {
		ConstBehaviour(b): Pair(t, nop);
		default: doFuseDynamic(t);
	}
}

doFuseDynamic(t : Transform<?>) -> Pair<DynamicBehaviour<?>, () -> void> {
	switch (t : Transform<?>) {
		ConstBehaviour(b): Pair(make(b), nop);
		DynamicBehaviour(b, s): {
			provider = make(^b);
			// We make all behaviours distinct!
			u = subscribe2(t, \v -> nextDistinct(provider, v));
			Pair(provider, u);
		}
		FSelect(b, fn, beh): {
			switch (beh) {
				FInitialized(subs, disp, dyn): {
					subs := ^subs + 1;
					Pair(dyn, disp);
				}
				FDestroyed(): {
					ifn = instantiateFn(fn);
					switch (b : Transform<??>) {
						DynamicBehaviour(dv, __): {
							subs = ref 1;
							dyn = make(ifn(^dv));
							u = subscribe2(b, \v : ?? -> nextDistinct(dyn, ifn(v)));
							disp = \ -> {subs := ^subs - 1; if (^subs == 0) {u(); t.beh ::= FDestroyed();}};

							t.beh ::= FInitialized(subs, disp, dyn);
							Pair(dyn, disp)
						}
						default: {
							cb = doFuseDynamic(b);

							subs = ref 1;
							dyn = make(ifn(getValue(firstOfPair(cb))));
							u = subscribe2(firstOfPair(cb), \v : ?? -> nextDistinct(dyn, ifn(v)));
							disp = \ -> {subs := ^subs - 1; if (^subs == 0) {u(); secondOfPair(cb)(); t.beh ::= FDestroyed();}};

							t.beh ::= FInitialized(subs, disp, dyn);
							Pair(dyn, disp)
						}
					}
				}
			}
		}
		FSelect2(b1, b2, fn, beh): {
			switch (beh) {
				FInitialized(subs, disp, dyn): {
					subs := ^subs + 1;
					Pair(dyn, disp);
				}
				FDestroyed(): {
					ifn = instantiateFn2(fn);
					switch (b1 : Transform<?>) {
						DynamicBehaviour(dv1, __): {
							switch (b2 : Transform<??>) {
								DynamicBehaviour(dv2, __): {
									subs = ref 1;
									dyn = make(ifn(^dv1, ^dv2));
									disp =
										if (checkEqualTransforms(b1, b2)) {
											u = subscribe2(b1, \b -> nextDistinct(dyn, ifn(b, flow(b))));
											\ -> {subs := ^subs - 1; if (^subs == 0) {u(); t.beh ::= FDestroyed();}};
										} else {
											updating = ref 0;
											u1 = subscribe2(b1, \b -> {
												if (^updating == 0) {
													updating := ^updating + 1;
													nextDistinct(dyn, ifn(b, ^dv2));
													updating := ^updating - 1;
												} else {
													/*println("Nested update, probably wrong layout");
													println(transform2string(t));
													printCallstack();*/
												}
											});
											u2 = subscribe2(b2, \b -> {
												if (^updating == 0) {
													updating := ^updating + 1;
													nextDistinct(dyn, ifn(^dv1, b));
													updating := ^updating - 1;
												} else {
													/*println("Nested update, probably wrong layout");
													println(transform2string(t));
													printCallstack();*/
												}
											});
											\ -> {subs := ^subs - 1; if (^subs == 0) {u1(); u2(); t.beh ::= FDestroyed();}};
										};

									t.beh ::= FInitialized(subs, disp, dyn);
									Pair(dyn, disp)
								}
								default: {
									cb = doFuseDynamic(b2);

									subs = ref 1;
									dyn = make(ifn(^dv1, getValue(firstOfPair(cb))));
									updating = ref 0;
									u1 = subscribe2(b1, \b -> {
										if (^updating == 0) {
											updating := ^updating + 1;
											nextDistinct(dyn, ifn(b, getValue(firstOfPair(cb))));
											updating := ^updating - 1;
										} else {
											/*println("Nested update, probably wrong layout");
											println(transform2string(t));
											printCallstack();*/
										}
									});
									u2 = subscribe2(firstOfPair(cb), \b -> {
										if (^updating == 0) {
											updating := ^updating + 1;
											nextDistinct(dyn, ifn(^dv1, b));
											updating := ^updating - 1;
										} else {
											/*println("Nested update, probably wrong layout");
											println(transform2string(t));
											printCallstack();*/
										}
									});
									disp = \ -> {subs := ^subs - 1; if (^subs == 0) {u1(); u2(); secondOfPair(cb)(); t.beh ::= FDestroyed();}};

									t.beh ::= FInitialized(subs, disp, dyn);
									Pair(dyn, disp)
								}
							}
						}
						default: {
							switch (b2 : Transform<??>) {
								DynamicBehaviour(dv2, __): {
									cb = doFuseDynamic(b1);

									subs = ref 1;
									dyn = make(ifn(getValue(firstOfPair(cb)), ^dv2));
									updating = ref 0;
									u1 = subscribe2(firstOfPair(cb), \b -> {
										if (^updating == 0) {
											updating := ^updating + 1;
											nextDistinct(dyn, ifn(b, ^dv2));
											updating := ^updating - 1;
										} else {
											/*println("Nested update, probably wrong layout");
											println(transform2string(t));
											printCallstack();*/
										}
									});
									u2 = subscribe2(b2, \b -> {
										if (^updating == 0) {
											updating := ^updating + 1;
											nextDistinct(dyn, ifn(getValue(firstOfPair(cb)), b));
											updating := ^updating - 1;
										} else {
											/*println("Nested update, probably wrong layout");
											println(transform2string(t));
											printCallstack();*/
										}
									});
									disp = \ -> {subs := ^subs - 1; if (^subs == 0) {u1(); u2(); secondOfPair(cb)(); t.beh ::= FDestroyed();}};

									t.beh ::= FInitialized(subs, disp, dyn);
									Pair(dyn, disp)
								}
								default: {
									if (checkEqualTransforms(b1, b2)) {
										cb1 = doFuseDynamic(b1);

										subs = ref 1;
										dyn = make(ifn(getValue(firstOfPair(cb1)), getValue(firstOfPair(cb1))));

										u = subscribe2(firstOfPair(cb1), \b -> nextDistinct(dyn, ifn(b, b)));
										disp = \ -> {subs := ^subs - 1; if (^subs == 0) {u(); secondOfPair(cb1)(); t.beh ::= FDestroyed();}};

										t.beh ::= FInitialized(subs, disp, dyn);
										Pair(dyn, disp)
									} else {
										cb1 = doFuseDynamic(b1);
										cb2 = doFuseDynamic(b2);

										subs = ref 1;
										dyn = make(ifn(getValue(firstOfPair(cb1)), getValue(firstOfPair(cb2))));

										updating = ref 0;
										u1 = subscribe2(firstOfPair(cb1), \b -> {
											if (^updating == 0) {
												updating := ^updating + 1;
												nextDistinct(dyn, ifn(b, getValue(firstOfPair(cb2))));
												updating := ^updating - 1;
											} else {
												/*println("Nested update, probably wrong layout");
												println(transform2string(t));
												printCallstack();*/
											}
										});
										u2 = subscribe2(firstOfPair(cb2), \b -> {
											if (^updating == 0) {
												updating := ^updating + 1;
												nextDistinct(dyn, ifn(getValue(firstOfPair(cb1)), b));
												updating := ^updating - 1;
											} else {
												/*println("Nested update, probably wrong layout");
												println(transform2string(t));
												printCallstack();*/
											}
										});
										disp = \ -> {subs := ^subs - 1; if (^subs == 0) {u1(); u2(); secondOfPair(cb1)(); secondOfPair(cb2)();
											t.beh ::= FDestroyed();}};

										t.beh ::= FInitialized(subs, disp, dyn);
										Pair(dyn, disp)
									};
								}
							}
						}
					}
				}
			}
		}
		FSubSelect(b, fn, beh): {
			switch (beh) {
				FInitialized(subs, disp, dyn): {
					subs := ^subs + 1;
					Pair(dyn, disp);
				}
				FDestroyed(): {
					ifn = instantiateFn(fn);
					switch (b : Transform<??>) {
						DynamicBehaviour(dv, __): {
							subs = ref 1;
							bf0 = doFuse(ifn(^dv));
							dyn = make(getValue(firstOfPair(bf0)));
							u0 = subscribe2(firstOfPair(bf0), \v2 -> nextDistinct(dyn, v2));
							disconnect = ref \ -> {
								secondOfPair(bf0)();
								u0();
							}
							u = subscribe2(b, \v1 -> {
								^disconnect();

								bf = doFuse(ifn(v1));
								u2 = subscribe(firstOfPair(bf), \v2 -> nextDistinct(dyn, v2));

								disconnect := \ -> {
									secondOfPair(bf)();
									u2();
								};
							});
							disp = \ -> {subs := ^subs - 1; if (^subs == 0) {u(); ^disconnect(); t.beh ::= FDestroyed();}};

							t.beh ::= FInitialized(subs, disp, dyn);
							Pair(dyn, disp)
						}
						default: {
							cb = doFuseDynamic(b);

							subs = ref 1;
							bf0 = doFuse(ifn(getValue(firstOfPair(cb))));
							dyn = make(getValue(firstOfPair(bf0)));
							u0 = subscribe2(firstOfPair(bf0), \v2 -> nextDistinct(dyn, v2));
							disconnect = ref \ -> {
								secondOfPair(bf0)();
								u0();
							}
							u = subscribe2(firstOfPair(cb), \v1 -> {
								^disconnect();

								bf = doFuse(ifn(v1));
								u2 = subscribe(firstOfPair(bf), \v2 -> nextDistinct(dyn, v2));

								disconnect := \ -> {
									secondOfPair(bf)();
									u2();
								};
							});
							disp = \ -> {subs := ^subs - 1; if (^subs == 0) {u(); ^disconnect(); secondOfPair(cb)(); t.beh ::= FDestroyed();}};

							t.beh ::= FInitialized(subs, disp, dyn);
							Pair(dyn, disp)
						}
					}
				}
			}
		}
	}
}

transform2string(s : Transform<?>) -> string {
	switch (s : Transform<?>) {
		ConstBehaviour(v): {
			dv = v;
			if (isSameStructType(dv, dv))
				"const " + flow(dv).structname + "(...)"
			else {
				"const " + safeToString(dv);
			}
		}
		DynamicBehaviour(v, b): {
			"dyn " + safeToString(^v);
		}
		FSelect(b, fn, __): {
			//"select(" + transform2string(b) + ", " + ffn2string(fn) + ")";
			"S(" + transform2string(b) + " |> " + ffn2string(fn) + ")";
		}
		FSelect2(b1, b2, fn, __): {
			// "select2(" + transform2string(b1) + "," + transform2string(b2) + ", " + ffn2string(fn) + ")";
			"S2(" + transform2string(b1) + ", " + transform2string(b2) + " |> " + ffn22string(fn) + ")";
		}
		FSubSelect(b, fn, __): {
			// "subselect(" + transform2string(b) + ", " + ffn2string(fn) + ")";
			transform2string(b) + "=>" + transform2string(instantiateFn(fn)(fgetValue(b))); // ffn2string(fn);
		}
	}
}

transformLength(s : Transform<?>) -> int {
	switch (s : Transform<?>) {
		ConstBehaviour(v): {
			0;
		}
		DynamicBehaviour(v, b): {
			1;
		}
		FSelect(b, fn, __): {
			transformLength(b);
		}
		FSelect2(b1, b2, fn, __): {
			transformLength(b1) + transformLength(b2);
		}
		FSubSelect(b, fn, __): {
			transformLength(b) + transformLength(instantiateFn(fn)(fgetValue(b)));
		}
	}
}


faddition(b1 : Transform<double>, b2 : Transform<double>) -> Transform<double> {
	if (b1 == b2)
		fselect(b1, FLift(\v : double -> v + v))
	else if (b1 == zero)
		b2
	else if (b2 == zero)
		b1
	else {
		switch (b1) {
			ConstBehaviour(v1): {
				switch (b2) {
					ConstBehaviour(v2): {
						// While the default case effectively reduces to this case,
						// it does so after a lot of garbage is made, so let us just
						// handle this common case directly
						ConstBehaviour(v1 + v2);
					}
					default: {
						fselect(b2, FAddConst(v1))
					}
				}
			}
			default: {
				switch (b2) {
					ConstBehaviour(v): {
						fselect(b1, FAddConst(v))
					}
					default: {
						// println(transform2string(b1) + " + " + transform2string(b2));
						fselect2(b1, b2, FAddition());
					}
				}
			}
		}
	}
}

fsubtract(b1 : Transform<double>, b2 : Transform<double>) -> Transform<double> {
	if (b1 == b2)
		zero
	else if (b1 == zero)
		fnegate(b2)
	else if (b2 == zero)
		b1
	else {
		switch (b1) {
			ConstBehaviour(v): {
				fselect(fnegate(b2), FAddConst(v));
			}
			default: {
				switch (b2) {
					ConstBehaviour(v): {
						fselect(b1, FAddConst(-v));
					}
					default: fselect2(b1, b2, FSubtract());
				}
			}
		}
	}
}

fmultiply(b1 : Transform<double>, b2 : Transform<double>) -> Transform<double> {
	if (b1 == b2)
		fselect(b1, FLift(\v : double -> v * v))
	else if (b1 == zero || b2 == zero)
		zero
	else if (b1 == ConstBehaviour(1.0))
		b2
	else if (b2 == ConstBehaviour(1.0))
		b1
	else {
		switch (b1) {
			ConstBehaviour(v1): {
				switch (b2) {
					ConstBehaviour(v2): {
						// While the default case effectively reduces to this case,
						// it does so after a lot of garbage is made, so let us just
						// handle this common case directly
						ConstBehaviour(v1 * v2);
					}
					default: {
						fselect(b2, FMulConst(v1))
					}
				}
			}
			default: {
				switch (b2) {
					ConstBehaviour(v): {
						fselect(b1, FMulConst(v))
					}
					default: {
						// println(transform2string(b1) + " + " + transform2string(b2));
						fselect2(b1, b2, FMultiply());
					}
				}
			}
		}
	}
}

fadditioni(b1 : Transform<int>, b2 : Transform<int>) -> Transform<int> {
	fselect2(b1, b2, FLift2(\v1, v2 -> v1 + v2));
}

fsubtracti(b1 : Transform<int>, b2 : Transform<int>) -> Transform<int> {
	fselect2(b1, b2, FLift2(\v1, v2 -> v1 - v2));
}

fmultiplyi(b1 : Transform<int>, b2 : Transform<int>) -> Transform<int> {
	fselect2(b1, b2, FLift2(\v1, v2 -> v1 * v2));
}

fgreater(b1 : Transform<double>, b2 : Transform<double>) -> Transform<bool> {
	fselect2(b1, b2, FLift2(\v1, v2 -> v1 > v2));
}

fless(b1 : Transform<double>, b2 : Transform<double>) -> Transform<bool> {
	fselect2(b1, b2, FLift2(\v1, v2 -> v1 < v2));
}

fgreateri(b1 : Transform<int>, b2 : Transform<int>) -> Transform<bool> {
	fselect2(b1, b2, FLift2(\v1, v2 -> v1 > v2));
}

flessi(b1 : Transform<int>, b2 : Transform<int>) -> Transform<bool> {
	fselect2(b1, b2, FLift2(\v1, v2 -> v1 < v2));
}

fdivide(b1 : Transform<double>, b2 : Transform<double>) -> Transform<double> {
	if (b1 == b2)
		fselect(b1, FLift(\v -> if (v == 0.) 0. else 1.))
	else if (b1 == zero || b2 == zero)
		zero
	else if (b2 == ConstBehaviour(1.0))
		b1
	else {
		switch (b2) {
			ConstBehaviour(v): {
				if (v == 0.0) {
					zero
				} else {
					fselect(b1, FMulConst(1.0 / v))
				}
			}
			default: {
				// println(transform2string(b1) + " + " + transform2string(b2));
				fselect2(b1, b2, FDivide());
			}
		}
	}
}


fnegate(b1 : Transform<double>) -> Transform<double> {
	fselect(b1, FNegate())
}

fdividei(b1 : Transform<int>, b2 : Transform<int>) -> Transform<int> {
	fselect2(b1, b2, FLift2(\v1, v2 -> v1 / v2));
}


fnegatei(b1 : Transform<int>) -> Transform<int> {
	fselect(b1, FLift(\v : int -> -v));
}

fmax(b1 : Transform<?>, b2 : Transform<?>) -> Transform<?> {
	if (b1 == b2)
		b1
	else switch (b1 : Transform<?>) {
		ConstBehaviour(v1): {
			switch (b2 : Transform<?>) {
				ConstBehaviour(v2): {
					// While the default case effectively reduces to this case,
					// it does so after a lot of garbage is made, so let us just
					// handle this common case directly
					const(max(v1, v2));
				}
				default: {
					fselect(b2, FMaxConst(v1));
				}
			}
		}
		default: {
			switch (b2) {
				ConstBehaviour(v2): {
					fselect(b1, FMaxConst(v2));
				}
				default: fselect2(b1, b2, FMax());
			}
		}
	}
}

fmax3(b1 : Transform<?>, b2 : Transform<?>, b3 : Transform<?>) -> Transform<?> {
	fmax(b1, fmax(b2, b3));
}

fmin(b1 : Transform<?>, b2 : Transform<?>) -> Transform<?> {
	if (b1 == b2)
		b1
	else switch (b1) {
		ConstBehaviour(v1): {
			switch (b2) {
				ConstBehaviour(v2): {
					// While the default case effectively reduces to this case,
					// it does so after a lot of garbage is made, so let us just
					// handle this common case directly
					ConstBehaviour(min(v1, v2));
				}
				default: {
					fselect(b2, FMinConst(v1));
				}
			}
		}
		default: {
			switch (b2) {
				ConstBehaviour(v2): {
					fselect(b1, FMinConst(v2));
				}
				default: fselect2(b1, b2, FMin());
			}
		}
	}
}

fmin3(b1 : Transform<?>, b2 : Transform<?>, b3 : Transform<?>) -> Transform<?> {
	fmin(b1, fmin(b2, b3));
}

fmaxA(v : [Transform<?>], def : ?) -> Transform<?> {
	if (length(v) > 0)
		fold(tail(v), v[0], \acc, v1 ->
			fmax(acc, v1)
		)
	else
		ConstBehaviour(def)
}

fminA(v : [Transform<?>], def : ?) -> Transform<?> {
	if (length(v) > 0)
		fold(tail(v), v[0], \acc, v1 ->
			fmin(acc, v1)
		)
	else
		ConstBehaviour(def)
}

farray(v1 : Transform<?>) -> Transform<[?]> {
	fselect(v1, FLift(\v -> [v]))
}

fconcat(v1 : Transform<[?]>, v2 : Transform<[?]>) -> Transform<[?]> {
	fselect2(v1, v2, concat |> FLift2)
}

farrayPush(v1 : Transform<[?]>, v2 : Transform<?>) -> Transform<[?]> {
	fselect2(v1, v2, arrayPush |> FLift2)
}

fconcatA(v : Transform<[[?]]>) -> Transform<[?]> {
	fselect(v, concatA |> FLift)
}

fcontains(v1 : Transform<[?]>, v2 : Transform<?>) -> Transform<bool> {
	fselect2(v1, v2, contains |> FLift2)
}

fcompose(f1 : FFn<flow, ??>, f2 : FFn<?, flow>) -> FFn<?, ??> {
	switch (f1 : FFn<flow, ??>) {
		FAddConst(c1): {
			switch (f2 : FFn<?, flow>) {
				FAddConst(c2): {
					FAddConst(c1 + c2);
				}
				FCompose(f3, f4): {
					switch (f3) {
						FAddConst(c3): {
							fcompose(FAddConst(c1 + c3), f4)
						}
						default: {
							FCompose(f1, f2);
						}
					}
				}
				FIdentity(): f1;
				default: {
					FCompose(f1, f2);
				}
			}
		}
		FMulConst(c1): {
			switch (f2 : FFn<?, flow>) {
				FMulConst(c2): {
					FMulConst(c1 * c2);
				}
				FCompose(f3, f4): {
					switch (f3) {
						FMulConst(c3): {
							fcompose(FMulConst(c1 * c3), f4)
						}
						default: {
							FCompose(f1, f2);
						}
					}
				}
				FIdentity(): f1;
				default: {
					FCompose(f1, f2);
				}
			}
		}
		FMaxConst(c1): {
			switch (f2 : FFn<?, flow>) {
				FMaxConst(c2): {
					v : ? = max(c1, c2);
					FMaxConst(v);
				}
				FCompose(f3, f4): {
					switch (f3) {
						FMaxConst(c3): {
							fcompose(FMaxConst(max(c1, c3)), f4)
						}
						default: {
							FCompose(f1, f2);
						}
					}
				}
				FIdentity(): f1;
				default: {
					FCompose(f1, f2);
				}
			}
		}
		FMinConst(c1): {
			switch (f2 : FFn<?, flow>) {
				FMinConst(c2): {
					v : ? = min(c1, c2);
					FMinConst(v);
				}
				FCompose(f3, f4): {
					switch (f3) {
						FMinConst(c3): {
							fcompose(FMinConst(min(c1, c3)), f4)
						}
						default: {
							FCompose(f1, f2);
						}
					}
				}
				FIdentity(): f1;
				default: {
					FCompose(f1, f2);
				}
			}
		}
		FIdentity(): f2;
		default: {
			switch (f2 : FFn<?, flow>) {
				FIdentity(): f1;
				default:{
					// println("Compose: " + ffn2string(f1) + " o " + ffn2string(f2));
					FCompose(f1, f2);
				}
			}
		}
	}
}

fif(b1 : Transform<bool>, then1 : Transform<?>, else1 : Transform<?>) -> Transform<?> {
	if (then1 == else1)
		then1
	else {
		switch (b1) {
			ConstBehaviour(v): {
				if (v) then1 else else1;
			}
			default: {
				tmp : FFn<flow, Transform<?>> = FIf(then1, else1);
				fsubselect(b1, tmp);
			}
		}
	}
}

feq(b : Transform<?>, v : ?) -> Transform<bool> {
	switch (b) {
		ConstBehaviour(c): ConstBehaviour(c == v);
		default: fselect(b, FEqual(v));
	}
}

fneq(b : Transform<?>, v : ?) -> Transform<bool> {
	switch (b) {
		ConstBehaviour(c): ConstBehaviour(c != v);
		default: fnot(fselect(b, FEqual(v)));
	}
}

fnot(b : Transform<bool>) -> Transform<bool> {
	feq(b, false)
}

fand(a : Transform<bool>, b : Transform<bool>) -> Transform<bool> {
	fselect2(a, b, FusionAnd());
}

fOr(a : Transform<bool>, b : Transform<bool>) -> Transform<bool> {
	fselect2(a, b, FusionOr());
}

fxor(a : Transform<bool>, b : Transform<bool>) -> Transform<bool> {
	fselect2(a, b, FusionXor());
}

checkEqualTransforms(b1 : Transform<flow>, b2 : Transform<flow>) -> bool {
	switch (b1) {
		DynamicBehaviour(v1, __) : {
			switch (b2) {
				DynamicBehaviour(v2, __): {
					b1 == b2;
				}
				default: false;
			}
		}
		ConstBehaviour(v1): {
			switch (b2) {
				ConstBehaviour(v2): {
					v1 == v2;
				}
				default: false;
			}
		}
		FSelect(v1, fn1, __) : {
			switch (b2) {
				FSelect(v2, fn2, __) : {
					fn1 == fn2 && checkEqualTransforms(v1, v2);
				}
				default: false;
			}
		}
		FSelect2(v1, v2, fn1, __) : {
			switch (b2) {
				FSelect2(v3, v4, fn2, __) : {
					fn1 == fn2 && checkEqualTransforms(v1, v3) && checkEqualTransforms(v2, v4)
				}
				default: false;
			}
		}
		FSubSelect(v1, fn1, __) : {
			switch (b2) {
				FSubSelect(v2, fn2, __) : {
					fn1 == fn2 && checkEqualTransforms(v1, v2);
				}
				default: false;
			}
		}
	}
}

fpair(v1 : Transform<?>, v2 : Transform<??>) -> Transform<Pair<?, ??>> {
	fselect2(v1, v2, FIdentity2())
}

fwidthheight(wd : Transform<double>, hgt : Transform<double>) -> Transform<WidthHeight> {
	fselect2(wd, hgt, FLift2(\w, h -> WidthHeight(w, h)));
}

fpoint(x : Transform<double>, y : Transform<double>) -> Transform<Point> {
	fselect2(x, y, FLift2(\vx, vy -> Point(vx, vy)));
}

fpointX(point : Transform<Point>) -> Transform<double> {
	fselect(point, FLift(\p -> p.x))
}

fpointY(point : Transform<Point>) -> Transform<double> {
	fselect(point, FLift(\p -> p.y))
}

ffactor(x : Transform<double>, y : Transform<double>) -> Transform<Factor> {
	fselect2(x, y, FLift2(\vx, vy -> Factor(vx, vy)));
}

ffactor2(f : Transform<double>) -> Transform<Factor> {
	fselect(f, FLift(\vf -> Factor(vf, vf)));
}

fwidth(wh : Transform<WidthHeight>) -> Transform<double> {
	fselect(wh, FLift(\whv -> whv.width));
}

fheight(wh : Transform<WidthHeight>) -> Transform<double> {
	fselect(wh, FLift(\whv -> whv.height));
}

fconnect(v1 : Transform<?>, v2 : DynamicBehaviour<?>) -> () -> void {
	makeSubscribe(v1, \v -> nextDistinct(v2, v))();
}

fconnectSelect(v1 : Transform<?>, v2 : DynamicBehaviour<??>, fn : (?) -> ??) -> () -> void {
	makeSubscribe(v1, \v -> nextDistinct(v2, fn(v)))();
}

fconnect2Select(t1 : Transform<?>, t2 : Transform<??>, v : DynamicBehaviour<???>, fn : (?, ??) -> ???) -> () -> void {
	make2Subscribe(t1, t2, \v1, v2 -> nextDistinct(v, fn(v1, v2)))();
}

fmerge(v : [Transform<?>]) -> Transform<[?]> {
	if (length(v) > 0)
		fold(tail(v), fselect(v[0], FLift(\v1 -> [v1])), \acc, v1 ->
			fselect2(acc, v1, FLift2(\acc0, v0 -> arrayPush(acc0, v0)))
		)
	else
		ConstBehaviour([])
}

ffold(v : [Transform<??>], acc : ?, fn : (acc : ?, item : ??) -> ?) -> Transform<?> {
	if (length(v) > 0)
		fold(tail(v), fselect(v[0], FLift(\v1 -> fn(acc, v1))), \acc2, v1 ->
			fselect2(acc2, v1, FLift2(\acc0, v0 -> fn(acc0, v0)))
		)
	else
		ConstBehaviour(acc)
}

fmergeTree(tree : Tree<??, Transform<?>>) -> Transform<Tree<??, ?>> {
	if (sizeTree(tree) > 0)
		fselect(
			foldTree(tree, const([]), \k, val, acc -> fselect2(acc, val, FLift2(\a, v -> arrayPush(a, Pair(k, v))))),
			pairs2tree |> FLift
		)
	else
		ConstBehaviour(makeTree())
}

fsum(v : [Transform<double>]) -> Transform<double> {
	if (length(v) > 0)
		fold(tail(v), fselect(v[0], FIdentity()), \acc, v1 ->
			faddition(acc, v1)
		)
	else
		zero
}

fsumi(v : [Transform<int>]) -> Transform<int> {
	if (length(v) > 0)
		fold(tail(v), fselect(v[0], FIdentity()), \acc, v1 ->
			fadditioni(acc, v1)
		)
	else
		const(0)
}

ftransistor(g : Transform<bool>, v: Transform<?>) -> Transform<?> {
	currentV : ref ? = ref fgetValue(v);

	fsubselect(g, FLift(\b ->
		if (b) {
			fselect(v, FLift(\v0 -> {
				currentV := v0;
				v0
			}))
		} else {
			const(^currentV)
		}
	))
}

fthrottle(v : Transform<?>, samplingRate : int) -> Transform<?> {
	switch (v) {
		ConstBehaviour(__): v;
		default: {
			newV = make(fgetValue(v));
			pendingV = ref None();

			fsubselect(v, FLift(\v0 -> {
				eitherFn(
					^pendingV,
					\pv -> {
						pendingV := Some(v0);
					},
					\ -> {
						pendingV := Some(v0);
						next(newV, v0);

						timer(samplingRate, \ ->
							maybeApply(
								^pendingV,
								\pv -> {
									nextDistinct(newV, pv);
									pendingV := None();
								}
							)
						)
					}
				);

				newV
			}))
		}
	}
}

fthrottle2(v : Transform<?>, maxDelta : int) -> Transform<?> {
	switch (v) {
		ConstBehaviour(__): v;
		default: {
			newV = make(fgetValue(v));
			uns = ref nop;

			fsubselect(v, FLift(\v0 -> {
				^uns();
				uns := interruptibleTimer(maxDelta, \ -> next(newV, v0));

				newV
			}))
		}
	}
}

fselectWithLast(b : Transform<??>, fn : FFn2<??, ??, ?>) -> Transform<?> {
	ifn = instantiateFn2(fn);
	lastV = ref None();

	fselect(b, FLift(\v ->
		switch (^lastV) {
			Some(prevV): {
				r = ifn(prevV, v);
				lastV := Some(v);
				r
			}
			None(): {
				lastV := Some(v);
				ifn(v, v);
			}
		}
	))
}

fdelay(v : Transform<?>, ms : int) -> Transform<?> {
	switch (v) {
		ConstBehaviour(__): v;
		default: {
			provider : DynamicBehaviour<?> = make(fgetValue(v));

			fsubselect(v, FLift(\v0 -> {
				timer(ms, \ -> next(provider, v0));

				provider
			}))
		}
	}
}

fstall(v : Transform<?>, ms : int) -> Transform<?> {
	switch (v) {
		ConstBehaviour(__): v;
		default: {
			provider : DynamicBehaviour<?> = make(fgetValue(v));

			fsubselect(v, FLift(\v0 -> {
				timer(ms, \ -> nextDistinct(provider, fgetValue(v)));

				provider
			}))
		}
	}
}

fBidirectionalLink(v1 : Transform<?>, v2 : Transform<??>, fn1 : (?) -> void, fn2 : (??) -> void) -> () -> void {
	nested = ref false;
	u1 = fsubscribe(v1, \v -> if (!^nested) {
		nested := true;
		fn1(v);
		nested := false;
	});
	u2 = fsubscribe2(v2, \v -> if (!^nested) {
		nested := true;
		fn2(v);
		nested := false;
	});

	\ -> applyList(concatList(u1, u2), apply0)
}

instantiateFn(fn : FFn<?, ??>) -> (?) -> ?? {
	// println(ffn2string(fn));
	switch (fn : FFn<?, ??>) {
		FLift(f): f;
		FCompose(f1, f2): {
			// TODO: If f1 or f2 are lifted, we can do better
			//lf1 : (???) -> ?? = instantiateFn(f1);
			//lf2 : (?) -> ??? = instantiateFn(f2);
			lf1 = instantiateFn(f1);
			lf2 = instantiateFn(f2);
			r : (?)->?? = \v : ? -> lf1(lf2(v));
			r;
		}
		FIdentity(): flow(idfn);
		FNegate(): flow(\p : double -> -p);
		FAddConst(v): flow(\p : double -> p + v);
		FMulConst(v): flow(\p : double -> p * v);
		FMaxConst(v): flow(\p -> max(p, v));
		FMinConst(v): flow(\p -> min(p, v));
		FEqual(v): flow(\p -> p == v);
		FIf(t, e): flow(\c : bool -> if (c) t else e);
	}
}

instantiateFn2(fn : FFn2<?, ??, ???>) -> (?, ??) -> ??? {
	// println(ffn2string(fn));
	switch (fn : FFn2<?, ??, ???>) {
		FLift2(f): f;
		FIdentity2(): flow(\f, s -> Pair(f, s));
		FAddition(): flow(\f: double, s: double -> f + s);
		FSubtract(): flow(\f : double, s : double-> f - s);
		FMultiply(): flow(\f: double, s : double-> f * s);
		FDivide(): {
			flow(\f, s -> if (s == 0.0) 0.0 else f / s);
		}
		FMax(): flow(max);
		FMin(): flow(min);
		FusionAnd() : flow(\a, b -> a && b);
		FusionOr() : flow(\a, b -> a || b);
		FusionXor() : flow(\a, b -> a != b);
	}
}

ffn2string(fn : FFn<?, ??>) -> string {
	switch (fn) {
		FLift(fl): trim2(takeAfter(safeToString(fn), ": ", safeToString(fn)), ")>");
		FCompose(f1, f2): "(" + ffn2string(f1) + ")o(" + ffn2string(f2) + ")";
		FIdentity(): "id";
		FNegate(): "~";
		FAddConst(d): "+#" + d2s(d);
		FMulConst(d): "*#" + d2s(d);
		FMaxConst(d): "max#" + safeToString(d);
		FMinConst(d): "min#" + safeToString(d);
		FEqual(v): "==" + safeToString(v);
		FIf(t, e): "?" + safeToString(t) + ":" + safeToString(e);
	}
}

ffn22string(fn : FFn2<?, ??, ???>) -> string {
	switch (fn) {
		FIdentity2(): "id";
		FLift2(fl): trim2(takeAfter(safeToString(fn), ": ", safeToString(fn)), ")>");
		FAddition(): "+";
		FSubtract(): "-";
		FMultiply(): "*";
		FDivide(): "/";
		FMax(): "max";
		FMin(): "min";
		FusionAnd() : "&&";
		FusionOr() : "||";
		FusionXor() : "^";
	}
}

safeToString(t : flow) -> string {
	if (isSameStructType(t, FLift(idfn))
		|| isSameStructType(t, FLift2(\x, y -> x))) {
		toString(t.fn)
	} else if (isSameStructType(t, zero)) {
		ct : ConstBehaviour<flow> = cast(t : flow -> ConstBehaviour<flow>);
		"const(" + safeToString(getValue(ct)) + ")";
	} else if (isSameStructType(t, FSelect(const(flow(0)), FIdentity(), FDestroyed()))
			|| isSameStructType(t, FSelect2(const(flow(0)), const(flow(0)), FAddition(), FDestroyed()))
			|| isSameStructType(t, FSubSelect(const(flow(0)), FIdentity(), FDestroyed()))
		) {
		ct : Transform<flow> = fselect(cast(t : flow -> Transform<?>), FLift(\v : ? -> cast(v : ? -> flow)));
		transform2string(ct)
	} else if (isArray(t)) "array"
	else if (isSameStructType(t, t)) {
		t.structname + "()"
	} else toString(t);
}

/*
main() {
	a = make(0);
	b = make(1);
	c = fselect2(a, b, FTuple2());
	c0 = fselect(c, FTuple2Get0());
	c1 = fselect(c, FTuple2Get1());

	fc = fuse(c);
	subscribe(fc.first, println);

	fc0 = fuse(c0);
	subscribe(fc0.first, println);

	fc1 = fuse(c1);
	subscribe(fc1.first, println);

	next(a, 2);
	next(b, 5);
}
*/
