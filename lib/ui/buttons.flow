// Â© Copyright 2011 Area9 Technologies.
import basecolors;
import form/textstyles2;
import form/gui;
import ui/skinning;
import form/formtransforms;
import text/translation;
import ui/tooltip;

export {
	// Animated 3D button
	AnimatedButton(content : Form, enabled : Behaviour<bool>, shortcut : string, onClick : () -> void) -> Form;
	AnimatedButton2(content : Form, enabled : Behaviour<bool>, shortcut : string, shortcutHint : string, onClick : () -> void) -> Form;
	AnimatedButtonWithSilhouette(content : Form, silhouette : Form, enabled : Behaviour<bool>, shortcut : string, onClick : () -> void) -> Form;
	AnimatedButtonAdjustable(content : Form, enabled : Behaviour<bool>, shortcut : string, onClick : () -> void, shadow : bool, repeatClickInterval: int, hint: string) -> Form;
	AnimatedButtonAdjustable2(content : Form, enabled : Behaviour<bool>, shortcut : string, onClick : () -> void, shadow : bool, repeatClickInterval: int, hint: string, scEnabled : Behaviour<bool>) -> Form;
	AnimatedButtonAdjustable3(content : Form, silhouette : Form, enabled : Behaviour<bool>, shortcut : string, shortcutHint : string, onClick : () -> void, shadow : bool, repeatClickInterval: int, hint: string, scEnabled : Behaviour<bool>) -> Form;

	goButton(width : double, height : double, corner_radius : double, caption : string,
			style : [CharacterStyle], brush : [GraphicsStyle], hoverBrush : [GraphicsStyle],
			pressedBrush : [GraphicsStyle], enabled : Behaviour<bool>, shortcut : string,
			onClick : () -> void) -> Form;

	goCustomButton(width : double, height : double, corner_radius : double, content : Form,
			brush : [GraphicsStyle], hoverBrush : [GraphicsStyle], pressedBrush : [GraphicsStyle],
			enabled : Behaviour<bool>, disableOpacity : double, shortcut : string, onClick : () -> void) -> Form;

	flatCustomButton(width : double, height : double, corner_radius : double, content : Form,
			brush : [GraphicsStyle], hoverBrush : [GraphicsStyle], pressedBrush : [GraphicsStyle],
			enabled : Behaviour<bool>, disableOpacity : double, shortcut : string, onClick : () -> void) -> Form;

	flatCustomButton2(width : double, height : double, corner_radius : double, content : Form, hoverContent : Form, pressedContent : Form,
			brush : [GraphicsStyle], hoverBrush : [GraphicsStyle], pressedBrush : [GraphicsStyle],
			enabled : Behaviour<bool>, disableOpacity : double, shortcut : string, onClick : () -> void) -> Form;

	veryFlatCustomButton(
			width : double, height : double, corner_radius : double, content : Form,
			brush : [GraphicsStyle], hoverBrush : [GraphicsStyle], pressedBrush : [GraphicsStyle],
			enabled : Behaviour<bool>, disableOpacity : double, shortcut : string, shortcutHint : string,
			onClick : () -> void
	) -> Form;

	GoButton(width : double, height : double, corner_radius : double, caption : string, 
			style : [CharacterStyle], brush : [GraphicsStyle], enabled : Behaviour<bool>, 
			shortcut : string, onClick : () -> void) -> Form;
	GoButton2(width : double, height : double, corner_radius : double, caption : string, 
			style : [CharacterStyle], brush : [GraphicsStyle], enabled : Behaviour<bool>, 
			shortcut : string, shortcutHint : string, onClick : () -> void) -> Form;

	graySkinButton(caption : string, enabled : Behaviour<bool>, shortcut : string, onClick : () -> void) -> Form;
	graySkinButtonWithWidth(width : double, caption : string, enabled : Behaviour<bool>, shortcut : string, onClick : () -> void) -> Form;
	orangeSkinButton(caption : string, enabled : Behaviour<bool>, shortcut : string,  onClick : () -> void) -> Form;
	orangeSkinButtonWithWidth(width:double, caption : string, enabled : Behaviour<bool>, shortcut : string,  onClick : () -> void) -> Form;
	orangeSkinButtonWithWidthHeight(width:double, height: double, caption : string, enabled : Behaviour<bool>, shortcut : string,  onClick : () -> void) -> Form;
	liteSkinOrangeButton(caption : string, enabled : Behaviour<bool>, shortcut : string,  onClick : () -> void) -> Form;
	liteSkinOrangeButtonWithWidth(width:double, caption : string, enabled : Behaviour<bool>, shortcut : string,  onClick : () -> void) -> Form;
	liteSkinRedButtonWithWidth(width:double, caption : string, enabled : Behaviour<bool>, shortcut : string,  onClick : () -> void) -> Form;
	greenSkinButton(caption : string, enabled : Behaviour<bool>, shortcut : string,  onClick : () -> void) -> Form;
	greenSkinButtonWithWidth(width : double, caption : string, enabled : Behaviour<bool>, shortcut : string, onClick : () -> void) -> Form;
	blackSkinButton(caption : string, enabled : Behaviour<bool>, shortcut : string,  onClick : () -> void) -> Form;
	blueBorderFlatButton(minWidth : double, height : double, caption : string, enabled : Behaviour<bool>, shortcut : string, onClick : () -> void) -> Form;

	videoButton(width : double, caption : string, enabled : Behaviour<bool>, shortcut : string,  onClick : () -> void) -> Form;

	stepsButton(scale : double, picture : Form, shortcut : string, onClick : () -> void) -> Form;

	// A button that changes appearance when moused over
	SimpleButton(content : Form, hovered : Form, shortcut : string, fn : () -> void) -> Form;
	// now our simple buttons should be accessible. all buttons should have aria-label tag in ShadowDOM.
	// please be sure to use ButtonDescription style if you don't see it in html structure.
	SimpleButton2(content : Form, shortcut : string, fn : () -> void, style : [FormButtonStyle]) -> Form;
	SimpleButton3(content : Form, shortcut : string, shortcutHint : string, fn : () -> void, style : [FormButtonStyle]) -> Form;

	colorBrush(color1 : int, color2 : int) -> [GradientFill] {
		[ GradientFill(90.0, [ GradientPoint(color1, 1.0, 0.0), GradientPoint(color2, 1.0, 1.0) ]) ]
	}

	colorHoverBrush(color1 : int, color2 : int) -> [GradientFill] {
		colorBrush(color1, color2)
	}

	colorPressedBrush(color1 : int, color2 : int, color3 : int) -> [GradientFill] {
		[GradientFill(90.0, [GradientPoint(color1, 1.0, 0.0), GradientPoint(color2, 1.0, 0.6), GradientPoint(color3, 1.0, 1.0)])]
	}

	grayButtonBrush = colorBrush(0x6D6D6D, 0x444444);
	grayHoverBrush = colorHoverBrush(0x555555, 0x999999);
	grayPressedBrush = colorPressedBrush(0x333333, 0x555555, 0x999999);

	veryLightGrayButtonBrush = colorBrush(0xEEEEEE, 0xCCCCCC);

	lightGrayButtonBrush = colorBrush(0xCDCDCD, 0xB4B4B4);
	lightGrayHoverBrush = colorHoverBrush(0xB5B5B5, 0xE9E9E9);
	lightGrayPressedBrush = colorPressedBrush(0x939393, 0xB5B5B5, 0xE9E9E9);

	greenButtonBrush = colorBrush(0x52AE07, 0x438E06);
	greenHoverBrush = colorHoverBrush(0x438E06, 0x52AE07);
	greenPressedBrush = colorPressedBrush(0x3B7E05, 0x438E06, 0x52AE07);

	redButtonBrush = colorBrush(0xE73F18, 0xB0140C);
	redHoverBrush = colorHoverBrush(0xB0140C, 0xE73F18);
	redPressedBrush = colorPressedBrush(0x8B0C09, 0xB0140C, 0xE73F18);

	orangeButtonBrush = getSkinnableGraphicsStyle("orangeButton", colorBrush(0xe38057, 0xda5521));
	orangeHoverBrush = getSkinnableGraphicsStyle("orangeButtonHover", colorHoverBrush(0xda5521, 0xe38057));
	orangePressedBrush = getSkinnableGraphicsStyle("orangeButtonPressed", colorPressedBrush(0xe24413, 0xda5521, 0xe38057));

	newSkinGray1Brush = [Stroke(newGray1Color), Fill(white)];

	blackButtonBrush = [linearGradient(90.0, [0x626262, 0x000000])];
	blackHoverBrush = blackButtonBrush;
	blackPressedBrush = blackButtonBrush;

	blueButtonBrush = [GradientFill(90.0, [GradientPoint(0x6fb7dc, 1.0, 0.0), GradientPoint(0x2080b0, 1.0 ,1.0)])];

	// Styles for CustomButton
	ButtonStyle ::= ButtonCaption, ButtonBackground, ButtonDescription, ButtonTabindex, OnButtonPressed, OnButtonHovered,
		OnButtonDisabled, ButtonPicture, ButtonEnabled, ButtonRepeatClick, ButtonPadding, ButtonHint, ButtonHintForm;

		ButtonEnabled : (enabled : Behaviour<bool>);
		ButtonTabindex : (tabindex : int);
		ButtonDescription : (description : string); // Accessibility description which is used by AT readers
		ButtonRepeatClick : (interval : int);       // Repeat click event while pressing each interval ms

		ButtonCaption : (text : string, style : [CharacterStyle]);

		ButtonBackground : (style : [ButtonBackgroundStyle]);
			ButtonBackgroundStyle ::= BtnBgMetrics, BtnBgBrush, BtnBgShadow;
				BtnBgMetrics : (width : double, height : double, r : double);   // Wraps content if missing
				BtnBgBrush : (brush : [GraphicsStyle]); // Background brush
				BtnBgShadow : (style : [ButtonBackgroundShadowStyle]);
					ButtonBackgroundShadowStyle ::= BtnBgShadowShow, BtnBgPaamShadowShow, BtnBgShadowParams;
						BtnBgShadowShow : (); // Show background shadow
						BtnBgPaamShadowShow : (width : double, height : double, cornerRadius : double); // Show background PAAM-style shadow
						BtnBgShadowParams : (parameters : [DropShadowParameter]); // Background shadow parameters

		OnButtonPressed : (transform : [ButtonTransform]); // Button transformation when pressed
		OnButtonHovered : (transform : [ButtonTransform]); // Button transformations when hovered
		OnButtonDisabled : (transform : [ButtonTransform]); // Button transformations when disabled
			ButtonTransform ::= ButtonScale, ButtonTranslate, ButtonChangeBackground, ButtonChangeCaption;
				ButtonScale : (scaleX : double, scaleY : double);             // Scales whole button form
				ButtonTranslate : (translateX : double, translateY : double); // Translaets whole button form
				ButtonChangeBackground : (brush : [GraphicsStyle]);
				ButtonChangeCaption : (style : [CharacterStyle]);

		ButtonPicture : (url : string, scaleX : double, scaleY : double, align : ButtonPictureAlign);
			ButtonPictureAlign ::= BtnPictureOnTheLeft, BtnPictureOnTheRight;
				BtnPictureOnTheRight : (); // Relative to caption
				BtnPictureOnTheLeft : ();  // Relative to caption

		ButtonPadding : (left : double, top : double, right : double, bottom : double); // Padding for button content. 0.0 by default
		ButtonHint : (hint : string); // Hint, which appeares when hovered
		ButtonHintForm : (delay : int, hint : Form); //delayed hint form

	// Customizable button which allows to set caption, image, background, metrics, appearance
	// and also transforms for each state
	CustomButton(onClick : () -> void, shortcut : string, style : [ButtonStyle]) -> Form;

	// Works like CustomButton but accepts forms for each state. So it is more flexible
	// if something more than caption + picture + background is needed
	CustomFormButton(form : Form, onClick : () -> void, shortcut : string, style : [FormButtonStyle]) -> Form;
	CustomFormButton2(form : Form, onClick : () -> void, shortcut : string, shortcutHint : string, style : [FormButtonStyle]) -> Form;

	FormButtonStyle ::= BtnDisabledForm, BtnHoveredForm, BtnPressedForm, BtnHighlightedForm, ButtonDescription, ButtonTabindex, ButtonEnabled, ButtonRepeatClick,
						ButtonHint, ButtonHintForm, OnButtonMouseInside, ButtonHighlighted, BtnManualHovering, ButtonShowTooltip, EnableShortcuts;

		BtnDisabledForm : (form : Form);
		BtnHighlightedForm : (form : Form);
		BtnHoveredForm : (form : Form);
		BtnPressedForm : (form : Form);
		BtnManualHovering : (state : DynamicBehaviour<int>);
		ButtonHighlighted : (highlighted : Behaviour<bool>);

		OnButtonMouseInside : (inside : DynamicBehaviour<bool>);

	orangeCustomButton(caption : string, enabled : Behaviour<bool>, shortcut : string, hint : string,  onClick : () -> void) -> Form;
	orangeCustomButtonWithWidth(width : double, caption : string, enabled : Behaviour<bool>, shortcut : string, hint : string,  onClick : () -> void) -> Form;
	orangeCustomButtonWithMetrics(width : double, height : double, cornerRadius : double, caption : string, enabled : Behaviour<bool>, shortcut : string, hint : string, onClick : () -> void) -> Form;

	// Simple base button with listeners, state, and accessibility properties
	AbstractButtonStyle ::= 
		ButtonEnabled, ButtonHovered, ButtonPressed, ButtonShortcut, ButtonShortcut2,
		ButtonTabindex, ButtonDescription, ButtonRepeatClick, ButtonShowTooltip, EnableShortcuts, ButtonGhosted;

		ButtonHovered : (hovered : DynamicBehaviour<bool>);
		ButtonPressed : (pressed : DynamicBehaviour<bool>);
		ButtonShortcut : (shortcut : string);
		ButtonShortcut2 : (shortcut : string, shortcutHint : string);  // hint is a text displayed in tooltip. Use it like this: ButtonShortcut2("Enter", _("Enter"))
		ButtonShowTooltip: (showTooltip : bool);  // show tooltip with keyboard shortcut
		EnableShortcuts : (enabled : Behaviour<bool>);
		ButtonGhosted : (); //Useful for buttons in scrolls for let scroll

	AbstractButton(form : Form, onClick : () -> void, style : [AbstractButtonStyle]) -> Form;

	setButtonShadow(bs : bool) -> void;
	isButtonShadow() -> bool;

	ImageNewButton(dir : string, url : string, text : string, hover : string, pressed : string, onClick : () -> void, shortcut : string, enabled : bool) -> Form;
	ImageNewButton2(dir : string, url : string, text : string, pressed : string, onClick : () -> void, shortcut : string, enabled : bool, close : bool) -> Form;
	ImageNewButton3(dir : string, img : string, text : string, description : string, hover : string, pressed : string, disabled : string, onClick : () -> void, shortcut : string, enabled : bool) -> Form;
	ImageNewGlowingButton(dir : string, img : string, text : string, description : string, hover : string, pressed : string, disabled : string, onClick : () -> void, shortcut : string, enabled : bool, glowImageFn : (Form) -> Form) -> Form;
	ImageNewButtonGeneral(dir : string, img : string, text : string, description : string, hover : string, pressed : string, disabled : string, onClick : () -> void, shortcut : string, enabled : bool, close : bool, diffSkin : bool) -> Form;

	wikiBtnPaamStyle : (pressCaptionColor : int, btnDefaultColor : int);
	makePaamButton(text : string, textStyle : [CharacterStyle], size : WidthHeight, onClick : () -> void, shortcut : string) -> Form;
	makeWikiPaamButton(text : string, textStyle : [CharacterStyle], btnColorStyle : wikiBtnPaamStyle, size : WidthHeight, onClick : () -> void) -> Form;

	defaultGoButtonFont = "Roboto";
	defaultGoButtonFontSize = 13.0;

	ButtonShortcutPrompt : ref ()->string;  // exported because some products (Smartbook) use custom prompt.

	normalShadow : [DropShadowParameter] = [Placement(45.0, 2.0), Color(black, 0.7), Radius(4.0), Spread(0.8)];

	buttonShowTooltipValue = ref true;
}

ButtonShortcutPrompt = ref \ -> _("Keyboard Shortcut: ");

buttonShadow = ref false;
ButtonShadowType ::= ButtonNoShadow, ButtonDefaultShadow, ButtonPaamShadow;
ButtonNoShadow();
ButtonDefaultShadow();
ButtonPaamShadow(width : double, height : double, cornerRadius : double);


setButtonShadow(bs : bool) -> void {
	buttonShadow := bs;
}

isButtonShadow() -> bool {
	^buttonShadow;
}

AbstractButton(form : Form, onClick : () -> void, style : [AbstractButtonStyle]) -> Form {
	pressed = ref make(false);
	hovered = ref make(false);
	enabled = ref make(true);

	auto_click_interval = ref 0;

	// Accessibility things
	tabindex = ref 0;
	shortcut = ref "";
	shortcutHint = ref "";
	description = ref "";
	showTooltip = ref ^buttonShowTooltipValue;
	enableShortcut = ref make(true);
	ghosted = ref false;
	mouseY = ref 0.0;

	listeners : ref [EventHandler] = ref [];

	setShortcut = \shortcut_, shortcutHint_ -> {
		if (shortcut_ != "") {
			shortcut := if (^accessibilityEnabled && toLowerCase(shortcut_) == "enter") {
				println("Shortcut \"enter\" is deprecated for JS target with accessibility enabled. It was replaced with \"Shift+Enter\"");
				"Shift+Enter"
			} else 
				shortcut_;

			shortcutHint := if (^accessibilityEnabled && toLowerCase(shortcut_) == "enter" && toLowerCase(shortcutHint_) == _("enter"))
				"Shift+Enter"|>_
			else
				shortcutHint_;

			scev = parseShortcut(^shortcut);
			refArrayPush(listeners,
				KeyDown2(\handled, e -> {
					if (!handled) {
						if (matchShortcut(e, scev) && getValue(^enableShortcut)) {
							onClick();
							true;
						} else
							false
					} else
						true;
				})
			);
		}
	};

	setPressedAndhovered = \flag -> {
		nextDistinct(^pressed, flag);
		if (mobile) nextDistinct(^hovered, flag);
	}

	iter(style, \s -> {
		switch (s : AbstractButtonStyle) {
			ButtonEnabled(en): {
				enabled := en;
			}
			ButtonHovered(ho): {
				hovered := ho;

				if(!mobile) {
					refArrayPush(listeners,
						RollOver(\e -> nextDistinct(ho, true))
					);
				}

				if(!mobile) {
					refArrayPush(listeners, 
						RollOut(\e -> nextDistinct(ho, false))
					);
				}
			}
			ButtonPressed(pr): pressed := pr;
			ButtonShortcut(sc): setShortcut(sc, sc);
			ButtonShortcut2(sc, sc_hint): setShortcut(sc, sc_hint);
			ButtonTabindex(ti): tabindex := ti;
			ButtonDescription(ds): description := ds;
			ButtonRepeatClick(in): auto_click_interval := in;
			ButtonShowTooltip(show): showTooltip := if (^buttonShowTooltipValue) show else false;
			EnableShortcuts(dis): enableShortcut := dis;
			ButtonGhosted() : {
				refArrayPush(listeners,
					MouseMove(\fn -> {
						if (abs(fn().y - ^mouseY) > 5.0) setPressedAndhovered(false);
						false
					})
				);
				ghosted := true;
			}
		}
	});

	do_auto_click = ref nop;
	do_auto_click := \ -> { // Autoclick to repeat call to onClick while pressing
		if (getValue(^pressed)) {
			onClick();
			timer(^auto_click_interval, ^do_auto_click);
		}
	};

	listeners := concat(^listeners, [
		MouseDown2(\handled, e -> {
			if (!handled) {
				if (e.inside() && getValue(^enabled)) {					
					setPressedAndhovered(true);
					mouseY := e.y;
					if (^auto_click_interval > 0) timer(^auto_click_interval, ^do_auto_click);
					! ^ghosted
				} else {
					false
				}
			} else {
				true;
			}
		}),

		MouseUp2(\handled, e -> {
			r = if (!handled) {
				info = e();
				if (info.inside && getValue(^pressed) && getValue(^enabled)) {
					onClick();
					true;
				} else {
					false
				}
			} else {
				true;
			}
			// Wait while zorder is trying hittest-radius values
			// The next radius value may trigger a click
			deferUntilRender(\ -> setPressedAndhovered(false));
			r
		})
	]);

	// add to all buttons descriptions shortcuts to do it better accessible
	realDescription: string = if (^description != "") ^description else getFormText(form);
	accessibleDescription = realDescription +
		if (^shortcutHint != "" && !strContains(realDescription, ^shortcutHint)) {
			" " + ^ButtonShortcutPrompt() + ^shortcutHint
		} else {
			""
		};
	accessibleTooltipArr = if (^shortcutHint != "" && ^showTooltip) [AccessKbdShortcutString(^ButtonShortcutPrompt() + ^shortcutHint)] else [];

	buttonForm = Access(concatA([[
			AccessEnabled(^enabled),
			AccessRole("button"),
			AccessCallback(onClick),
			AccessDescription(accessibleDescription),
			AccessTabindex(^tabindex)
		],
		accessibleTooltipArr]),
		Cursor(FingerCursor(), Interactive(^listeners, form))
	);

	Constructor(if (^shortcutHint != "" && ^showTooltip) { Tooltip(buttonForm, ^ButtonShortcutPrompt() + ^shortcutHint, []) } else buttonForm, \ -> {
		uns = subscribe2(^enabled, \flag -> if (!flag) setPressedAndhovered(false));
		\ -> {
			uns();
			nextDistinct(^hovered, false);
			nextDistinct(^pressed, false);
		}
	})
}

CustomFormButton(form, onClick, shortcut, style) {
	CustomFormButton2(form, onClick, shortcut, shortcut, style)
}

CustomFormButton2(form : Form, onClick : () -> void, shortcut : string, shortcutHint : string, style : [FormButtonStyle]) -> Form {
	hovered_form = ref form;
	pressed_form = ref form;
	highlighted_form = ref form;
	disabled_form = ref form;

	pressed = make(false);
	hovered = make(false);
	highlighted = make(false);
	enabled = make(true);
	form_case = make(0);

	abstract_button_style = ref [ButtonShortcut2(shortcut, shortcutHint), ButtonPressed(pressed), ButtonHovered(hovered)];

	hoveredTime = make(0);

	hint = ref "";
	hint_delay = ref -1;
	hint_form = ref Empty();

	timeCounterFn = ref nop;
	timeCounterFn := \ -> timer(1000, \-> {
		if (getValue(hovered) && getValue(hoveredTime) < ^hint_delay)  next(hoveredTime, getValue(hoveredTime) + 1);
		^timeCounterFn()
	}); // counts time of hovered by changing hoveredTime

	manualHovering = ref false;

	connections = ref [];

	addConnection = \fn -> refArrayPush(connections, fn);

	addConnection(\ -> subscribe(hovered, \ho -> if (!ho) next(hoveredTime, 0)));
	addConnection(\ -> subscribe(pressed, \pr -> next(hoveredTime, 0))); // any changes hovered or pressed clear hoveredTime

	addConnection(\ -> connectSelect4u(enabled, pressed, hovered, highlighted, form_case, \en, pr, ho, hi -> {
		if (!en) 4 else if (pr) 3 else if (ho) 2 else if (hi) 1 else 0
	}));

	iter(style, \s -> {
		switch (s : FormButtonStyle) {
			BtnDisabledForm(f) : disabled_form := f;
			BtnPressedForm(f) : pressed_form := f;
			BtnHoveredForm(f) : hovered_form := f;
			BtnHighlightedForm(f) : highlighted_form := f;
			BtnManualHovering(state) : {
				manualHovering := true;
				addConnection(\ -> connect(form_case, state));
			}
			ButtonEnabled(en): {
				addConnection(\ -> subscribe(en, \env -> nextDistinct(enabled, env)));
				refArrayPush(abstract_button_style, s);
			}
			ButtonDescription(d): refArrayPush(abstract_button_style, s);
			ButtonTabindex(ti): refArrayPush(abstract_button_style, s);
			ButtonRepeatClick(ms): refArrayPush(abstract_button_style, s);
			ButtonHint(h): hint := h;
			ButtonHintForm(d, frm): {hint_delay := d; hint_form := frm; ^timeCounterFn();}
			ButtonHighlighted(b) : { addConnection(\ -> connect(b, highlighted)); }
			OnButtonMouseInside(inside): { addConnection(\ -> connect(hovered, inside)) }
			ButtonShowTooltip(f) : refArrayPush(abstract_button_style, s);
			EnableShortcuts(en) : refArrayPush(abstract_button_style, s);
		}
	});

	hf_size = makeWH();

	/*
	hintForm = if (^hint == "") {
		Empty()
	} else {
		theHint = makeHintForm(^hint, hf_size);
		Select(hovered, \ho -> if (ho) theHint else Empty())
	}
	*/

	hintForm = {
		textHint = if (^hint == "") Empty() else makeHintForm(^hint, hf_size);
		if ( ^hint_delay < 0 ) Select(hovered, \ho -> if (ho) textHint else Empty())
		else Select2(hovered, hoveredTime, \ho, ht -> if (ho) {if (ht < ^hint_delay) textHint else ^hint_form} else Empty())
	}

	hf = Group([
		Inspect([ISize(hf_size)], ^hovered_form),
		Size2(const(zeroWH), hintForm)
	]);

	result = if (^manualHovering) {
		form
	} else {
		CachedSwitch(form_case, [form, ^highlighted_form, hf, ^pressed_form, ^disabled_form]) |> NonZeroSize
	}
	Constructors(
		^connections,
		AbstractButton(result, onClick, ^abstract_button_style)
	)
}

makeHintForm(hint : string, bg_size : Behaviour<WidthHeight>) -> Form {
	hintWidth = make(0.0);
	dx = make(0.0);
	Constructor(
		Translate(dx, const(-22.0),
			Inspect([Width(hintWidth)],
				Rounded(4.0, [Fill(0xffffff), FillOpacity(0.8)],
					Border(4.0, 4.0, 4.0, 4.0,
						Text(hint, [FontSize(10.0)])
					)
				)
			)
		),
		\ -> connectSelect2Distinctu(hintWidth, bg_size, dx, \w0, bgs -> (bgs.width - w0) * 0.5)
	)
}

// [- split -]
CustomButton(onClick : () -> void, shortcut : string, style : [ButtonStyle]) -> Form {
	caption_form = ref Empty();
	picture_form = ref Empty();
	picture_align = ref BtnPictureOnTheLeft();

	// Fixed metrics for background. By default wraps content
	width = ref 0.0; height = ref 0.0; corner_radius = ref 0.0;
	shadowType : ref ButtonShadowType = ref ButtonNoShadow(); shadowParams : ref [DropShadowParameter] = ref normalShadow;
	shadowTypeB : DynamicBehaviour<ButtonShadowType> = make(ButtonNoShadow());

	// Background brushes for each state
	normal_brush : ref [GraphicsStyle] = ref [Fill(0xffffff), FillOpacity(0.0)]; // Transparent bg by default to get mouse clicks
	hovered_brush = ref [];
	pressed_brush = ref [];
	disabled_brush = ref [];

	hovered_scale_x = ref 1.0; hovered_scale_y = ref 1.0;
	pressed_scale_x = ref 1.0; pressed_scale_y = ref 1.0;
	disabled_scale_x = ref 1.0; disabled_scale_y = ref 1.0;

	hovered_dx = ref 0.0; hovered_dy = ref 0.0;
	pressed_dx = ref 0.0; pressed_dy = ref 0.0;
	disabled_dx = ref 0.0; disabled_dy = ref 0.0;

	normal_caption_style = ref [];
	hovered_caption_style = ref [];
	pressed_caption_style = ref [];
	disabled_caption_style = ref [];

	// Padding of button content. No padding by default
	padding_left = ref 0.0; padding_top = ref 0.0;
	padding_right = ref 0.0; padding_bottom = ref 0.0;

	hint = ref "";

	hint_delay = ref -1;
	hint_form = ref Empty();

	caption_style = make([]);

	// State listeners
	pressed = make(false);
	hovered = make(false);
	disabled = make(false); uns_disabled = ref nop;

	hoveredTime = make(0);

	timeCounterFn = ref nop;
	timeCounterFn := \ -> timer(1000, \-> {
		if (getValue(hovered) && getValue(hoveredTime) < ^hint_delay)  next(hoveredTime, getValue(hoveredTime) + 1);
		^timeCounterFn()
	}); // counts time of hovered by changing hoveredTime

	subscribe(hovered, \ho -> if (!ho) next(hoveredTime, 0));
	subscribe(pressed, \pr -> next(hoveredTime, 0)); // any changes hovered or pressed clear hoveredTime

	base_button_style = ref [ButtonShortcut(shortcut), ButtonPressed(pressed), ButtonHovered(hovered)];

	read_background = \bs : [ButtonBackgroundStyle] ->
		iter(bs, \s -> switch (s : ButtonBackgroundStyle) {
			BtnBgMetrics(w, h, r): { width := w; height := h; corner_radius := r; }
			BtnBgBrush(br): normal_brush := br;
			BtnBgShadow(bgShadowSt): {
				iter(bgShadowSt, \bgShSt -> switch(bgShSt : ButtonBackgroundShadowStyle) {
					BtnBgShadowShow(): shadowType := ButtonDefaultShadow();
					BtnBgPaamShadowShow(w, h, r): shadowType := ButtonPaamShadow(w, h, r);
					BtnBgShadowParams(prs): shadowParams := prs; // for ButtonDefaultShadow
				})
			}
		});

	read_transform = \tr : [ButtonTransform], brush : ref [GraphicsStyle], scale_x : ref double, scale_y : ref double,
			dx : ref double, dy : ref double, cap_style : ref [CharacterStyle] ->
		iter(tr, \t -> {
			switch (t : ButtonTransform) {
				ButtonChangeBackground(b): brush := b;
				ButtonScale(x, y): { scale_x := x; scale_y := y; }
				ButtonTranslate(x, y): { dx := x; dy := y; }
				ButtonChangeCaption(s) : cap_style := s;
			}
		});

	// Process button style
	iter(style, \s -> {
		switch (s : ButtonStyle) {
			ButtonCaption(t, ts): {
				normal_caption_style := ts;
				caption_form := Select(caption_style, \cs -> Text(t, cs));
			}
			ButtonPicture(url, sx, sy, align): {
				picture_form := Scale(const(sx), const(sy), Picture(url, []));
				picture_align := align;
			}
			ButtonBackground(bgs): read_background(bgs);
			OnButtonPressed(tr): read_transform(tr, pressed_brush, pressed_scale_x, pressed_scale_y, pressed_dx, pressed_dy, pressed_caption_style);
			OnButtonHovered(tr): read_transform(tr, hovered_brush, hovered_scale_x, hovered_scale_y, hovered_dx, hovered_dy, hovered_caption_style);
			OnButtonDisabled(tr): read_transform(tr, disabled_brush, disabled_scale_x, disabled_scale_y, disabled_dx, disabled_dy, disabled_caption_style);
			ButtonPadding(l, t, r, b): {
				padding_left := l; padding_top := t;
				padding_right := r; padding_bottom := b;
			}
			ButtonEnabled(en): {
				base_button_style := arrayPush(^base_button_style, ButtonEnabled(en));
				uns_disabled := connect(select(en, \b -> !b), disabled);
			}
			ButtonDescription(d): base_button_style := arrayPush(^base_button_style, ButtonDescription(d));
			ButtonTabindex(ti): base_button_style := arrayPush(^base_button_style, ButtonTabindex(ti));
			ButtonRepeatClick(ms): base_button_style := arrayPush(^base_button_style, ButtonRepeatClick(ms));
			ButtonHint(h): hint := h;
			ButtonHintForm(d, frm): {hint_delay := d; hint_form := frm; ^timeCounterFn();}
		}
	});

	content = Border(^padding_left, ^padding_top, ^padding_right, ^padding_bottom,
		if (^picture_form != Empty() && ^caption_form != Empty()) {
			switch (^picture_align : ButtonPictureAlign) {
				BtnPictureOnTheLeft(): Cols([^picture_form, ^caption_form]);
				BtnPictureOnTheRight(): Cols([^caption_form, ^picture_form]);
			}
		} else if (^picture_form != Empty()) {
			^picture_form;
		} else {
			^caption_form;
		}
	);

	// Set missing state styles to default
	if (^pressed_brush == []) pressed_brush := ^normal_brush;
	if (^hovered_brush == []) hovered_brush := ^normal_brush;
	if (^disabled_brush == []) disabled_brush := ^normal_brush;
	if (^hovered_caption_style == []) hovered_caption_style := ^normal_caption_style;
	if (^pressed_caption_style == []) pressed_caption_style := ^normal_caption_style;
	if (^disabled_caption_style == []) disabled_caption_style := ^normal_caption_style;

	background_brush = make(^normal_brush);
	dx = make(0.0); dy = make(0.0);
	scale_x = make(1.0); scale_y = make(1.0);

	state_changed = \ -> {
		if (getValue(pressed)) {
			next(shadowTypeB, ButtonNoShadow());
			next(background_brush, ^pressed_brush);
			next(caption_style, ^pressed_caption_style);
			nextDistinct(dx, ^pressed_dx); nextDistinct(dy, ^pressed_dy);
			nextDistinct(scale_x, ^pressed_scale_x); nextDistinct(scale_y, ^pressed_scale_y);
		} else if (getValue(hovered)) {
			nextDistinct(shadowTypeB, ^shadowType);
			next(background_brush, ^hovered_brush);
			next(caption_style, ^hovered_caption_style);
			nextDistinct(dx, ^hovered_dx); nextDistinct(dy, ^hovered_dy);
			nextDistinct(scale_x, ^hovered_scale_x); nextDistinct(scale_y, ^hovered_scale_y);
		} else if (getValue(disabled)) {
			next(background_brush, ^disabled_brush);
			next(caption_style, ^disabled_caption_style);
			nextDistinct(dx, ^disabled_dx); nextDistinct(dy, ^disabled_dy);
			nextDistinct(scale_x, ^disabled_scale_x); nextDistinct(scale_y, ^disabled_scale_y);
		} else {
			nextDistinct(shadowTypeB, ^shadowType);
			next(background_brush, ^normal_brush);
			next(caption_style, ^normal_caption_style);
			nextDistinct(dx, 0.0); nextDistinct(dy, 0.0);
			nextDistinct(scale_x, 1.0); nextDistinct(scale_y, 1.0);
		}
	};

	subscribe(pressed, \p -> state_changed());
	subscribe(hovered, \ho -> state_changed());
	subscribe(disabled, \d -> state_changed());

	wh = makeWH();
	cn = Inspect([ISize(wh)], content);

	bg_size = makeWH();
	background = Inspect([ISize(bg_size)], Select(wh, \cwh -> {
			Select2(background_brush, shadowTypeB, \brush, shdwTp -> {
				Graphics(roundedRect(max(cwh.width, ^width), max(cwh.height, ^height), ^corner_radius), brush)
				|> buttonShadowFilter(shdwTp, ^shadowParams)
			})
		})
	);

	/*
	hintForm = if (^hint == "") {
		Empty()
	} else {
		theHint = makeHintForm(^hint, bg_size);
		Select(hovered, \ho -> if (ho) theHint else Empty())
	}
	*/

	hintForm = {
		textHint = if (^hint == "") Empty() else makeHintForm(^hint, bg_size);
		if ( ^hint_delay < 0 ) Select(hovered, \ho -> if (ho) textHint else Empty())
		else Select2(hovered, hoveredTime, \ho, ht -> if (ho) {if (ht < ^hint_delay) textHint else ^hint_form} else Empty())
	}


	button_form = Group([
			background,
			Available2(bg_size,
				Align2(0.5, 0.5, cn)
			),
			Size2(const(zeroWH), hintForm)
		])
		|> if (^hovered_scale_y != 1.0 || ^hovered_scale_x != 1.0 || ^pressed_scale_x != 1.0 || ^pressed_scale_y != 1.0) \f -> Scale(scale_x, scale_y, f) else \f : Form -> f
		|> if (^hovered_dy != 0.0 || ^hovered_dx != 0.0 || ^pressed_dx != 0.0 || ^pressed_dy != 0.0) \sf -> Translate(dx, dy, sf) else \sf -> sf;

	Disposer(
		AbstractButton(button_form, onClick, ^base_button_style),
		\ -> { ^uns_disabled() }
	)
}

orangeCustomButton(caption : string, enabled : Behaviour<bool>, shortcut : string, hint : string, onClick : () -> void) {
	orangeCustomButtonWithWidth(110.0, caption, enabled, shortcut, hint, onClick)
}

orangeCustomButtonWithWidth(width : double, caption : string, enabled : Behaviour<bool>, shortcut : string, hint : string, onClick : () -> void) {
	Filter(
		[Bevel([Placement(45.0, 0.3), Color(0xffffff, 0.9), ShadowColor(0x000000, 0.7), Spread(3.0), Radius(3.0)])],
		CustomButton(onClick, shortcut, [
			ButtonCaption(caption,[FontSize(13.0), Fill(0xffffff)]),
			ButtonBackground([
				BtnBgMetrics(width, 18.0, 4.5),
				BtnBgBrush(orangeButtonBrush)
			]),
			ButtonHint(hint),
			OnButtonHovered([ButtonChangeBackground(orangeHoverBrush)]),
			OnButtonPressed([ButtonChangeBackground(orangePressedBrush)]),
			ButtonEnabled(enabled),
			ButtonDescription(caption)
		])
	);
}

orangeCustomButtonWithMetrics(width : double, height : double, cornerRadius : double, caption : string, enabled : Behaviour<bool>, shortcut : string, hint : string, onClick : () -> void) {
	Filter(
		[Bevel([Placement(45.0, 0.3), Color(0xffffff, 0.9), ShadowColor(0x000000, 0.7), Spread(3.0), Radius(3.0)])],
		CustomButton(onClick, shortcut, [
			ButtonCaption(caption,[FontSize(13.0), Fill(0xffffff)]),
			ButtonBackground([
				BtnBgMetrics(width, height, cornerRadius),
				BtnBgBrush(orangeButtonBrush)
			]),
			ButtonHint(hint),
			OnButtonHovered([ButtonChangeBackground(orangeHoverBrush)]),
			OnButtonPressed([ButtonChangeBackground(orangePressedBrush)]),
			ButtonEnabled(enabled),
			ButtonDescription(caption)
		])
	);
}

AnimatedButton(content, enabled, shortcut, onClick) {
	// AnimatedButtonAdjustable(content, enabled, shortcut, onClick, isButtonShadow(), 0, "")
	AnimatedButton2(content, enabled, shortcut, shortcut, onClick)
}

AnimatedButton2(content, enabled, shortcut, shortcutHint, onClick) {
	AnimatedButtonAdjustable3(content, content, enabled, shortcut, shortcutHint, onClick, isButtonShadow(), 0, "", make(true))
}

AnimatedButtonWithSilhouette(content, silhouette, enabled, shortcut, onClick) {
	AnimatedButtonAdjustable3(content, silhouette, enabled, shortcut, shortcut, onClick, isButtonShadow(), 0, "", make(true))
}

AnimatedButtonAdjustable(content, enabled, shortcut, onClick, shadow, repeatClickInterval, hint) {
	AnimatedButtonAdjustable2(content, enabled, shortcut, onClick, shadow, repeatClickInterval, hint, make(true))
}

AnimatedButtonAdjustable2(content, enabled, shortcut, onClick, shadow, repeatClickInterval, hint, scEnabled) {
	AnimatedButtonAdjustable3(content, content, enabled, shortcut, shortcut, onClick, shadow, repeatClickInterval, hint, scEnabled)
}

AnimatedButtonAdjustable3(
		content : Form, silhouette : Form, enabled : Behaviour<bool>, 
		shortcut : string, shortcutHint : string, 
		onClick : () -> void, shadow : bool, repeatClickInterval: int, hint: string, scEnabled : Behaviour<bool>
) {
	_wh = makeWH();
	whFiltered = whenSizeChanged(_wh);
	shadowType : ButtonShadowType = if (shadow) ButtonDefaultShadow() else ButtonNoShadow();

	cn = Inspect([ISize(_wh)], content |> buttonShadowFilter(shadowType, normalShadow));

	state = make(0); //0 - normal, 1 - highlighted (not possible as we do not pass external highlighting behaviour), 2 - hovered, 3 - pressed
	enabledLocal = make(getValue(enabled));
	overlayVisible = make(false);
	hintVisible = make(false);

	// A white cover for highlighting when hovering and when the button is disabled
	white_overlay = Select2(whFiltered, overlayVisible, \wh, ov -> {
		if (ov) Mask(Rectangle(wh.width, wh.height, [Fill(0xffffff), FillOpacity(0.2)]), takeFormSnapshot(silhouette))
		else Empty();
	});

	hintWidth = make(0.0);
	hintDx = make(0.0);
	hintForm = if (hint == "") {
		Empty()
	} else {
		Rounded(4.0, [Fill(0xffffff), FillOpacity(0.8)], Border(4.0, 4.0, 4.0, 4.0, Text(hint, [FontSize(10.0)])))
		|> \f -> Inspect([Width(hintWidth)], f)
		|> \f1 -> Translate(hintDx, const(-22.0), f1)
		|> \f2 -> Size2(zeroSize, f2);
	}

	isPressed = make(false);
	dx = make(0.0);
	dy = make(0.0);

	construct = \ -> {
		unsArray = [
			connectSelect2u(state, overlayVisible, enabledLocal, \s, e -> s >= 2 || !e),
			connectSelectu(state, hintVisible, \s -> s >= 2),
			if (hint == "")
				nop
			else
				connectSelectu(hintWidth, hintDx, \w0 -> (w0 - getValue(whFiltered).width) * (-0.5)),
			connectSelectu(state, isPressed, eq(3)),
			connectSelectu(isPressed, dx, b2d),
			connectSelectu(isPressed, dy, b2d),
			connect(enabled, enabledLocal) //enabled is sometimes global behaviour
		];
		\ -> applyall(unsArray)
	}

	form = Translate(dx, dy, Group([
		cn,
		Visibleb(overlayVisible, white_overlay),
		Visibleb(hintVisible, hintForm)
	]));

	Constructor(
		CustomFormButton2(form, onClick, shortcut, shortcutHint, [ButtonEnabled(enabled), ButtonRepeatClick(repeatClickInterval),
			BtnManualHovering(state), EnableShortcuts(scEnabled)]),
		construct
	)
}

GoButton(width, height, corner_radius, caption, style, brush, enabled, shortcut, onClick) {
	GoButton2(width, height, corner_radius, caption, style, brush, enabled, shortcut, shortcut, onClick)
}

GoButton2(width, height, corner_radius, caption, style, brush, enabled, shortcut, shortcutHint, onClick) {
	fontFamily = ref defaultGoButtonFont;
	fontSize = ref defaultGoButtonFontSize;
	fillColor = ref 0xffffff;
	iter(style, \s -> {
		switch (s : CharacterStyle) {
			FontFamily(name) : fontFamily := name;
			FontSize(size) : fontSize := size;
			Fill(col): fillColor := col;
			FillOpacity(op): {};
			default : {};
		}
	});

	// this may add some duplication, but no conflicting values
	captionTextStyle = concat(style, [FontFamily(^fontFamily), FontSize(^fontSize), Fill(^fillColor)]);
	content = if (^fontSize > 14.0) {
			Border(0.0, 0.0, 0.0, 2.0, Text(caption, captionTextStyle));
		} else {
			Border(0.0, 0.0, 0.0, 1.0, Text(caption, captionTextStyle));
	}

	AnimatedButton2(
		Group([
			bevelRoundRect(width, height, corner_radius, corner_radius, corner_radius, corner_radius, true, 3.0, brush),
			Available2(const(WidthHeight(width, height)), Align(0.5, 0.5, content))
		]),
		enabled,
		shortcut, shortcutHint,
		onClick,
	)
}

goButton(width_, height_, corner_radius, caption, style, brush, hoverBrush, pressedBrush, enabled, shortcut, onClick) {
	fontFamily = ref defaultGoButtonFont;
	fontSize = ref defaultGoButtonFontSize;
	fillColor = ref 0xffffff;
	iter(style, \s -> {
		switch (s : CharacterStyle) {
		FontFamily(name) : fontFamily := name;
		FontSize(size) : fontSize := size;
		Fill(col): fillColor := col;
		FillOpacity(op): {};
		default : {};
		}
	});

	// this may add some duplication, but no conflicting values
	captionTextStyle = concat(style, [FontFamily(^fontFamily), FontSize(^fontSize), Fill(^fillColor)]);

	content = (if (^fontSize > 14.0) {
			Border(0.0, 0.0, 0.0, 2.0, Text(caption, captionTextStyle));
		} else {
			Border(0.0, 0.0, 0.0, 1.0, Text(caption, captionTextStyle));
	});

	goCustomButton2(width_, height_, corner_radius, content, brush, hoverBrush, pressedBrush, enabled, 0.4, true, shortcut, onClick)
}

goCustomButton(width_, height_, corner_radius, content, brush, hoverBrush, pressedBrush, enabled, disableOpacity, shortcut, onClick) {
	goCustomButton2(width_, height_, corner_radius, content, brush, hoverBrush, pressedBrush, enabled, disableOpacity, true, shortcut, onClick)
}

flatCustomButton(width_, height_, corner_radius, content, brush, hoverBrush, pressedBrush, enabled, disableOpacity, shortcut, onClick) {
	goCustomButton2(width_, height_, corner_radius, content, brush, hoverBrush, pressedBrush, enabled, disableOpacity, false, shortcut, onClick)
}

flatCustomButton2(width_, height_, corner_radius, content, hoverContent, pressedContent, brush, hoverBrush, pressedBrush, enabled, disableOpacity, shortcut, onClick) {
	goCustomButton3(width_, height_, corner_radius, content, hoverContent, pressedContent, brush, hoverBrush, pressedBrush, enabled, disableOpacity, false, shortcut, onClick)
}

veryFlatCustomButton(width_, height_, corner_radius, content, brush, hoverBrush, pressedBrush, enabled, disableOpacity, shortcut, shortcutHint, onClick) {
	w = width_;
	h = height_;
	r = corner_radius;

	pressed = make(false);
	hovered = make(false);

	hoverVisibility = select(hovered, b2i);
	pressedVisibility = select(pressed, b2i);
	disabledVisibility = select(enabled, \e -> if (e) 0 else 1);

	f =	FixSize(w, h, Group([
			customRoundedRect(w, h, r, r, r, r, brush),
			Visible(hoverVisibility,
				customRoundedRect(w, h, r, r, r, r, hoverBrush)
			),
			Visible(pressedVisibility,
				customRoundedRect(w, h, r, r, r, r, pressedBrush)
			),
			Visible(disabledVisibility,
				Graphics(roundedRect(w, h, r), [Fill(0xFFFFFF), FillOpacity(disableOpacity)])
			),
			Available2(const(WidthHeight(w, h)), Align(0.5, 0.5, content))
	]));

	AbstractButton(f, onClick, [ButtonEnabled(enabled), ButtonHovered(hovered), ButtonPressed(pressed), ButtonShortcut2(shortcut, shortcutHint)])
}

goCustomButton2(width_, height_, corner_radius, content : Form, brush, hoverBrush, pressedBrush, enabled : Behaviour<bool>, disableOpacity, useBevel, shortcut, onClick) {
	w = width_;
	h = height_;
	r = corner_radius;

	pressed = make(false);
	hovered = make(false);

	hoverVisibility = select(hovered, b2i);
	pressedVisibility = select(pressed, b2i);
	disabledVisibility = select(enabled, \e -> if (e) 0 else 1);
	bevelRadius = if (useBevel) 3.0 else 0.0;

	f =	FixSize(w, h, Group([
			bevelRoundRect(w, h, r, r, r, r, true, bevelRadius, brush),
			Visible(hoverVisibility,
				bevelRoundRect(w, h, r, r, r, r, true, bevelRadius, hoverBrush)
			),
			Visible(pressedVisibility,
				bevelRoundRect(w, h, r, r, r, r, true, bevelRadius, pressedBrush)
			),
			Visible(disabledVisibility,
				Graphics(roundedRect(w, h, r), [Fill(0xFFFFFF), FillOpacity(disableOpacity)])
			),
			Available2(const(WidthHeight(w, h)), Align(0.5, 0.5, content))
	]));

	AbstractButton(f, onClick, [ButtonEnabled(enabled), ButtonHovered(hovered), ButtonPressed(pressed), ButtonShortcut(shortcut)])
}

goCustomButton3(width_, height_, corner_radius, content : Form, hoverContent : Form, pressedContent : Form, brush, hoverBrush, pressedBrush, enabled : Behaviour<bool>, disableOpacity, useBevel, shortcut, onClick) {
	w = width_;
	h = height_;
	r = corner_radius;

	pressed = make(false);
	hovered = make(false);

	hoverVisibility = select(hovered, b2i);
	pressedVisibility = select(pressed, b2i);
	disabledVisibility = select(enabled, \e -> if (e) 0 else 1);
	bevelRadius = if (useBevel) 3.0 else 0.0;

	content_ = Mutable(select2(hovered, pressed, \hovered_, pressed_ -> if (pressed_) pressedContent else if (hovered_) hoverContent else content));

	f =	FixSize(w, h, Group([
			bevelRoundRect(w, h, r, r, r, r, true, bevelRadius, brush),
			Visible(hoverVisibility,
				bevelRoundRect(w, h, r, r, r, r, true, bevelRadius, hoverBrush)
			),
			Visible(pressedVisibility,
				bevelRoundRect(w, h, r, r, r, r, true, bevelRadius, pressedBrush)
			),
			Visible(disabledVisibility,
				Graphics(roundedRect(w, h, r), [Fill(0xFFFFFF), FillOpacity(disableOpacity)])
			),
			Available2(const(WidthHeight(w, h)), Align(0.5, 0.5, content_))
	]));

	AbstractButton(f, onClick, [ButtonEnabled(enabled), ButtonHovered(hovered), ButtonPressed(pressed), ButtonShortcut(shortcut)])
}

skinButton(caption : string, brush : [GraphicsStyle], hoverBrush : [GraphicsStyle], pressedBrush : [GraphicsStyle], enabled : Behaviour<bool>, shortcut : string, onClick : () -> void) -> Form {
	goButton(110.0, 18.0, 4.5, caption, [], brush, hoverBrush, pressedBrush, enabled, shortcut, onClick);
}
graySkinButton(caption, enabled, shortcut, onClick) skinButton(caption, grayButtonBrush, grayHoverBrush, grayPressedBrush, enabled, shortcut, onClick);
graySkinButtonWithWidth(width, caption, enabled, shortcut, onClick) goButton(width, 18.0, 4.5, caption, [], grayButtonBrush, grayHoverBrush, grayPressedBrush, enabled, shortcut, onClick);
blackSkinButton(caption, enabled, shortcut, onClick) goButton(110.0, 18.0, 6.0, caption, [FontSize(12.0)], blackButtonBrush, blackHoverBrush, blackPressedBrush, enabled, shortcut, onClick);
greenSkinButton(caption, enabled, shortcut, onClick) skinButton(caption, greenButtonBrush, greenHoverBrush, greenPressedBrush, enabled, shortcut, onClick);
greenSkinButtonWithWidth(width, caption, enabled, shortcut, onClick) goButton(width, 18.0, 4.5, caption, [], greenButtonBrush, greenHoverBrush, greenPressedBrush, enabled, shortcut, onClick);
orangeSkinButton(caption, enabled, shortcut, onClick)
	SkinnedForm( \ ->
		skinButton(caption,
			orangeButtonBrush,	orangeHoverBrush, orangePressedBrush,
			enabled, shortcut, onClick
		)
	);
orangeSkinButtonWithWidth(width, caption, enabled, shortcut, onClick) {
	orangeSkinButtonWithWidthHeight(width, 18.0, caption, enabled, shortcut, onClick)
}

orangeSkinButtonWithWidthHeight(width, height, caption, enabled, shortcut, onClick)
	SkinnedForm( \ ->
		goButton(width, height, 4.5, caption, [],
			orangeButtonBrush, orangeHoverBrush, orangePressedBrush,
			enabled, shortcut, onClick
		)
	);
liteSkinOrangeButtonWithWidth(width, caption, enabled, shortcut, onClick)
	SkinnedForm( \ ->
		flatCustomButton(width, 30.0, 5.0, Text(caption, [FontSize(10.0), LetterSpacing(1.), Fill(0xffffff)]),
			[Fill(0xed5235)], [Fill(0xed5235)], [Fill(0xed5235)],
			enabled, 0.4, shortcut, onClick
		)
	);
liteSkinRedButtonWithWidth(width, caption, enabled, shortcut, onClick)
	SkinnedForm( \ ->{
			ui = Rounded(3.0, [Fill(0xee5151)], Available(const(width), const(20.0),
				//In case width isn't enough let's make sure we have some borders
				Align(0.5, 0.5, Border(3.0, 0.0, 3.0, 0.0, Text(caption, [FontFamily("ProximaSemiBold"), FontSize(14.0), Fill(white)])))
			));

		AnimatedButton(ui, enabled, shortcut, onClick)
	});
liteSkinOrangeButton(caption, enabled, shortcut, onClick) liteSkinOrangeButtonWithWidth(110.0, caption, enabled, shortcut, onClick);

videoButton(width_, caption, enabled, shortcut, onClick) goButton(width_, 25.0, 10.0, caption, [], orangeButtonBrush, orangeHoverBrush, orangePressedBrush, enabled, shortcut, onClick);

stepsButton(scale_ : double, picture : Form, shortcut : string, fn : () -> void) -> Form {
	scale = make(scale_);

	posX = make(0.0);
	posY = make(0.0);

	pressed = make(false);
	hovered = make(false);

	increase = \ -> {
		animate([
			DoubleAnimation(scale, scale_ + 0.007, 100.0),
			DoubleAnimation(posX, -1.7, 100.0),
			DoubleAnimation(posY, -1.7, 100.0)
		])
	};

	decrease = \ -> {
		animate([
			DoubleAnimation(scale, scale_, 100.0),
			DoubleAnimation(posX, 0.0, 100.0),
			DoubleAnimation(posY, 0.0, 100.0)
		])
	};

	subscribe(hovered, \ho -> if (ho) {
			if (!getValue(pressed)) increase();
		} else {
			decrease();
	});

	subscribe(pressed, \p -> if (p) decrease() else increase());

	f = Translate(posX, posY,
		Scale(scale, scale,
			picture
		)
	);

	AbstractButton(f, fn, [ButtonHovered(hovered), ButtonPressed(pressed), ButtonShortcut(shortcut)])
};

SimpleButton(content, hovered, shortcut, fn) {
	SimpleButton2(content, shortcut, fn, [BtnHoveredForm(hovered)]);
}

SimpleButton2(content, shortcut, fn, style : [FormButtonStyle]) {
	SimpleButton3(content, shortcut, shortcut, fn, style)
}

SimpleButton3(content, shortcut, shortcutHint, fn, style : [FormButtonStyle]) {
	hover = make(false);
	press = make(false);

	description = extractStruct(style, ButtonDescription(getFormText(content))).description;
	hovered = extractStructMany(style, BtnHoveredForm(content));
	pressed = extractStructMany(style, BtnPressedForm(content));
	enabled = extractStruct(style, ButtonEnabled(const(true))).enabled;

	isHovered = length(hovered) > 0;
	isPressed = length(pressed) > 0;

	hover_case = make(0);
	construct = \ -> {
		if (isHovered && isPressed) {
			connectSelect2u(hover, press, hover_case, \ho, pr -> if (pr) 2 else if (ho) 1 else 0);
		} else if (isHovered) {
			connectSelectu(hover, hover_case, \ho -> if (ho) 1 else 0);
		} else if (isPressed) {
			connectSelectu(press, hover_case, \pr -> if (pr) 1 else 0);
		} else {
			nop
		}
	}

	f =	Background([Fill(0xffffff), FillOpacity(0.0)],
		if (isHovered && isPressed) {
			CachedSwitch(hover_case, [content, hovered[0].form, pressed[0].form])
		} else if (isHovered) {
			CachedSwitch(hover_case, [content, hovered[0].form])
		} else if (isPressed) {
			CachedSwitch(hover_case, [content, pressed[0].form])
		} else {
			content
		} |> NonZeroSize
	);

	Constructor(
		AbstractButton(f, fn, [ButtonHovered(hover), ButtonPressed(press), ButtonShortcut2(shortcut, shortcutHint), ButtonDescription(description), ButtonEnabled(enabled)]),
		construct
	)		
}

blueBorderFlatButton(width : double, height : double, caption : string, enabled : Behaviour<bool>, shortcut : string, onClick : () -> void) {
	brush = [Stroke(lsBlue), StrokeWidth(2.0), Fill(white)];
	hoverBrush = [Stroke(lsBlue), StrokeWidth(2.0), Fill(lsBlue)];
	pressedBrush = [Stroke(lsLightBlue), StrokeWidth(2.0), Fill(lsLightBlue)];
	disabledDrush = [Stroke(0xB4B4B4), StrokeWidth(2.0), Fill(white)];

	pressed = make(false);
	hovered = make(false);

	hoverVisibility = select(hovered, b2i);
	pressedVisibility = select(pressed, b2i);
	disabledVisibility = select(enabled, \e -> if (e) 0 else 1);

	baseStyle = asBold([FontFamily("Condensed"), FontSize(14.0)]);
	border = 5.0;

	contentWidth = getTextSize(caption, baseStyle).width + 2.0 * border;

	captionTextStyle = select2(hovered, enabled, \hover, e -> arrayPush(baseStyle, Fill(if (hover) white else if (!e) 0xB4B4B4 else lsBlue)));
	content = Select(captionTextStyle, \s -> Text(caption, s));

	w = max(width, contentWidth);
	h = height;
	r = 5.0;

	f =	FixSize(w, h,
		Group([
			customRoundedRect(w, h, r, r, r, r, brush),
			Visible(hoverVisibility,
				customRoundedRect(w, h, r, r, r, r, hoverBrush)
			),
			Visible(pressedVisibility,
				customRoundedRect(w, h, r, r, r, r, pressedBrush)
			),
			Visible(disabledVisibility,
				customRoundedRect(w, h, r, r, r, r, disabledDrush)
			),
			Available2(const(WidthHeight(w, h)), Align(0.5, 0.5, content))
		])
	);

	AbstractButton(f, onClick, [ButtonEnabled(enabled), ButtonHovered(hovered), ButtonPressed(pressed), ButtonShortcut(shortcut), ButtonDescription(caption)])
}


ImageNewButton(dir : string, img : string, text : string, hover : string, pressed : string, onClick : () -> void, shortcut : string, enabled : bool) {
	ImageNewButtonGeneral(dir, img, text, text, hover, pressed, "", onClick, shortcut, enabled, false, false)
}

ImageNewButton3(dir : string, img : string, text : string, description : string, hover : string, pressed : string, disabled : string, onClick : () -> void, shortcut : string, enabled : bool) {
	ImageNewButtonGeneral(dir, img, text, description, hover, pressed, disabled, onClick, shortcut, enabled, false, false)
}

ImageNewButton2(dir : string, img : string, text : string, pressed : string, onClick : () -> void, shortcut : string, enabled : bool, close : bool) {
	ImageNewButtonGeneral(dir, img, text, text, img, pressed, "", onClick, shortcut, enabled, close, false)
}

ImageNewButtonGeneral(dir : string, img : string, text : string, description : string, hover : string, pressed : string, disabled : string, onClick : () -> void, shortcut : string, enabled : bool, close : bool, diffSkin : bool) {
	ImageNewButtonGeneral2(dir, img, text, description, hover, pressed, disabled, onClick, shortcut, enabled, close, diffSkin, \f -> f);
}

ImageNewGlowingButton(dir : string, img : string, text : string, description : string, hover : string, pressed : string, disabled : string, onClick : () -> void, shortcut : string, enabled : bool, glowImageFn : (Form) -> Form) {
	ImageNewButtonGeneral2(dir, img, text, description, hover, pressed, disabled, onClick, shortcut, enabled, false, false, glowImageFn);
}

ImageNewButtonGeneral2(dir : string, img : string, text : string, description : string, hover : string, pressed : string, disabled : string, onClick : () -> void, shortcut : string, enabled : bool, close : bool, diffSkin : bool, glowImageFn : (Form) -> Form) {
	err = make(false);
	preloadAndCachePicture(dir + img, nop1);
	preloadAndCachePicture(dir + hover, nop1);
	preloadAndCachePicture(dir + pressed, nop1);
	if (disabled != "") preloadAndCachePicture(dir + disabled, nop1);
	diffSkinResize : (Form) -> Form = if (diffSkin) \f : Form -> Scale(const(0.5), const(0.5), f) else idfn; //in diffSkin always use high res pictures which scale to normal size (and can be scale back elsewhere)

	pic = Picture(dir + img, [
		OnLoadingError(\error -> {
			nextDistinct(err, true);
			println("Error loading picture: " + toString(error))
		}),
		OnLoaded(\-> { nextDistinct(err, false) })
	]) |> diffSkinResize |> glowImageFn;
	picHover = Picture(dir + hover, [
		OnLoadingError(\error -> {
			nextDistinct(err, true);
			println("Error loading picture: " + toString(error))
		}),
		OnLoaded(\-> { nextDistinct(err, false) })
	]) |> diffSkinResize |> glowImageFn;
	picPressed = Picture(dir + pressed, [
		OnLoadingError(\error -> {
			nextDistinct(err, true);
			println("Error loading picture: " + toString(error))
		}),
		OnLoaded(\-> { nextDistinct(err, false) })
	]) |> diffSkinResize |> glowImageFn;
	picDisabled =
		if (disabled != "") {
			Picture(dir + disabled, [
				OnLoadingError(\error -> {
					nextDistinct(err, true);
					println("Error loading picture: " + toString(error))
				}),
				OnLoaded(\-> { nextDistinct(err, false) })
			]);
		} else {
			pic;
		} |> diffSkinResize |> glowImageFn;
	//0 - normal
	//1 - disabled
	//2 - hover
	//3 - pressed
	txt = \p, state -> {
		back = if (diffSkin) {
			if (state ==  0 || state == 1) 0xfbfbfb
			else if (state == 2) 0xedebe9
			else 0x60bfdf
		} else {
			if (state ==  0 || state == 1) 0xf3f3f3
			else if (state == 2) 0xD1D3D2
			else 0x373737
		}
		Group([
			if (diffSkin) Rectangle(165.0, 50.0, [Fill(back)])
			else Rectangle(220.0, 40.0, [Fill(back), Stroke(0xC3CDD1)]),
			Cols([
				p |> if (diffSkin) \f -> Align(0.5 ,0.5, f) else idfn,
				if (diffSkin) Fixed(5.0, 0.0) else Empty(),
				Available2(const(WidthHeight(0.0, if (diffSkin) 50.0 else 40.0)),
					Align(0.0, 0.5, Text(text,
						if (diffSkin) [FontFamily("ProximaSemiBold"), FontSize(12.0), Fill(if (state == 3) white else 0x5f5e5e)]
						else [FontFamily("RobotoMedium"), FontSize(12.0), Fill(if (state == 3) 0xf3f3f3 else if (enabled) 0x373737 else 0xa4acaf)]))
				)
			])
		])
	};
	Select(err, \e ->
		if (e)
			Empty()
		else if (text == "")
			CustomFormButton(
				pic,
				onClick,
				shortcut,
				[
					ButtonShowTooltip(false),
					BtnDisabledForm(picDisabled),
					BtnHoveredForm(picHover),
					BtnPressedForm(picPressed),
					ButtonEnabled(const(enabled)),
					ButtonDescription(description)
				]
			)
		else
			FixHeight(
				const(if (diffSkin) 50.0 else 39.0),
				CustomFormButton(
					txt(pic, 0),
					onClick,
					shortcut,
					[
						ButtonShowTooltip(false),
						BtnDisabledForm(txt(picDisabled, 1)),
						BtnHoveredForm(txt(picHover, 2)),
						BtnPressedForm(txt(picPressed, 3)),
						ButtonEnabled(const(enabled)),
						ButtonDescription(description)
					]
				)
			)
	);
}

//Paam buttons
paamButtonColors : (defCol : int, hvrCol : int, pressCol : int, pressCaptionCol : int);

makePaamButton(text : string, textStyle : [CharacterStyle], size : WidthHeight, onClick : () -> void, shortcut : string) -> Form {
	makePaamButtonCustom(text, textStyle, size, onClick, shortcut, paamButtonColors(0x58b364, 0x79c283, 0x60bfdf, white), false)
}

makeWikiPaamButton(text, textStyle, btnColorStyle, size, onClick) {
	makePaamButtonCustom(text, textStyle, size, onClick, "", paamButtonColors(btnColorStyle.btnDefaultColor, btnColorStyle.btnDefaultColor, 0x262626, btnColorStyle.pressCaptionColor), true)
}

makePaamButtonCustom(text : string, textStyle : [CharacterStyle], size : WidthHeight, onClick : () -> void, shortcut : string, btnColors : paamButtonColors, isSmartbuilder : bool) -> Form {

	makeSmartbuilderPaamButton = \ -> {
		cornerRadius = 4.0;
		CustomButton(
			onClick,
			shortcut,
			[
				ButtonCaption(text, textStyle),
				ButtonBackground([
					BtnBgMetrics(size.width, size.height, cornerRadius),
					BtnBgBrush([Fill(btnColors.defCol), Stroke(black)]),
					BtnBgShadow([BtnBgPaamShadowShow(size.width, size.height, cornerRadius)]),
				]),
				OnButtonPressed([
					ButtonChangeBackground([Fill(btnColors.pressCol), Stroke(black)]),
					ButtonChangeCaption([Fill(btnColors.pressCaptionCol), FontFamily("ProximaNova-Semibold")])
				]),
				OnButtonHovered([
					ButtonChangeBackground([Fill(btnColors.hvrCol), Stroke(black)])
				]),
				ButtonDescription(text)
			]
		)
	}

	makeSmartbookPaamButton = \ -> {
		hovered = make(false);
		pressed = make(false);
		f = Available2(const(size), Group([
			Select2(hovered, pressed, \h, p ->
				Graphics(
					roundedRect(size.width, size.height, 4.0),
					[Fill(if (p) btnColors.pressCaptionCol else if (h) btnColors.hvrCol else btnColors.defCol)]
				)
			),
			Align(0.5, 0.5, Text(text, textStyle))
		]));
		AbstractButton(f, onClick, [ButtonHovered(hovered), ButtonPressed(pressed), ButtonShortcut(shortcut), ButtonDescription(text)])
	}

	if (isSmartbuilder) makeSmartbuilderPaamButton() else makeSmartbookPaamButton()

}

buttonShadowFilter(shadowType : ButtonShadowType, shadowParams : [DropShadowParameter]) -> (Form) -> Form {

	getPaamButtonWithShadow = \f, w, h, r -> {
		Group([
			Offset(2.0, 2.0, Graphics(roundedRect(w, h, r), [Stroke(black), Fill(black)])),
			f
		])
	}

	\f : Form -> switch(shadowType : ButtonShadowType) {
		ButtonNoShadow(): f;
		ButtonDefaultShadow() : Filter([DropShadow(shadowParams)], f);
		ButtonPaamShadow(w, h, r) : getPaamButtonWithShadow(f, w, h, r);
	}
}
