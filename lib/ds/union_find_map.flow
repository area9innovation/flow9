import ds/array;
import ds/set;
import runtime;

export {
	// Make a map of int keys to values of type ?.
	// The keys can form equivalence classes by being merged (union).
	// When we index unknown keys, we give them a default value.
	// When keys merge, we have to merge their values using
	// an associative and commutative function.
	makeUnionFindMap(defaultValue : ?, mergeFn : (?, ?) -> ?) -> UnionFindMap<?>;

	// Find the root set this set belongs to. If i is beyond the end, it is considered a singular set
	findUnionMapRoot(u : UnionFindMap<?>, i : int) -> int;

	// What values does this index have? If we do not have this index, return the def value
	getUnionMapValue(u : UnionFindMap<?>, i : int) -> ?;

	// Set/update the value at this index
	setUnionMapValue(u : UnionFindMap<?>, i : int, value : ?) -> void;

	// Join these two sets
	unionUnionMap(u : UnionFindMap<?>, x : int, y : int) -> int;

	// Iterate all values in the map, with the class they belong to (not necessarily root)
	iterUnionMap(u : UnionFindMap<?>, fn : (int, ?) -> void) -> void;

	// Map over all values in the map
	mapUnionMap(u : UnionFindMap<?>, fn : (int, ?) -> ?) -> void;

	// For each set, what is the parent this set belongs to?
	// If it points to itself, it is the root of a set.
	UnionFindMap(mutable parents : [ref int], mutable values : [ref ?], defaultValue : ?, mergeFn : (?, ?) -> ?);
}

makeUnionFindMap(defaultValue : ?, mergeFn : (?, ?) -> ?) -> UnionFindMap<?> {
	UnionFindMap([], [], defaultValue, mergeFn);
}

findUnionMapRoot(u : UnionFindMap<?>, i : int) -> int {
	unionEnsureMapCapacity(u, i);
	pr : ref int = u.parents[i];
	p = ^pr;
	if (p == i) i
	else {
		rp = findUnionMapRoot(u, p);
		// Path compression
		pr := rp;
		rp;
	}
}

getUnionMapValue(u : UnionFindMap<?>, i : int) -> ? {
	root = findUnionMapRoot(u, i);
	if (root < length(u.values)) {
		^(u.values[root])
	} else u.defaultValue
}

setUnionMapValue(u : UnionFindMap<?>, i : int, value : ?) -> void {
	root = findUnionMapRoot(u, i);
	u.values[root] := value;
}

unionUnionMap(u : UnionFindMap<?>, x : int, y : int) -> int {
	xset = findUnionMapRoot(u, x);
	yset = findUnionMapRoot(u, y);
	if (xset == yset) {
		xset;
	} else if (random() < 0.5) {
		u.parents[xset] := yset;
		u.values[yset] := u.mergeFn(^(u.values[xset]), ^(u.values[yset]));
		u.values[xset] := u.defaultValue;
		yset;
	} else {
		u.parents[yset] := xset;
		u.values[xset] := u.mergeFn(^(u.values[xset]), ^(u.values[yset]));
		u.values[yset] := u.defaultValue;
		xset;
	}
}

unionEnsureMapCapacity(u : UnionFindMap<?>, i : int) -> void {
	n = length(u.parents);
	if (i >= n) {
		// Be sure to at least double capacity
		end = max(2 * n, i + 1);
		newParents = concat(u.parents, generate(n, end, \j -> ref j));
		// println([i, n, end, length(newParents)]);
		u.parents ::= newParents;

		newValues = concat(u.values, generate(n, end, \__ -> ref u.defaultValue));
		u.values ::= newValues;
	}
}

iterUnionMap(u : UnionFindMap<?>, fn : (int, ?) -> void) -> void {
	roots = foldi(u.parents, makeSet(), \i, acc, parent -> {
		if (i == ^parent) {
			insertSet(acc, i)
		} else acc;
	});
	iterSet(roots, \root -> {
		val = ^(u.values[root]);
		fn(root, val)
	});
}

mapUnionMap(u : UnionFindMap<?>, fn : (int, ?) -> ?) -> void {
	roots = foldi(u.parents, makeSet(), \i, acc, parent -> {
		if (i == ^parent) {
			insertSet(acc, i)
		} else acc;
	});
	iterSet(roots, \root -> {
		val = ^(u.values[root]);
		nval = fn(root, val);
		u.values[root] := nval;
	});
}

/*
main() {
	// A map from integers to integers, where we add to merge
	m = makeUnionFindMap(0, \a, b -> a + b);
	setUnionMapValue(m, 0, 1);
	setUnionMapValue(m, 1, 2);
	unionUnionMap(m, 0, 1);
	println(getUnionMapValue(m, 1)); // 3
	println(getUnionMapValue(m, 0)); // 3
}
*/
