import ds/array;

// Cartesian product of arrays: if c = [a_1, a_2, ... , a_n] then
// c is interpreted as a_1 x a_2 x ... x a_n

export {
	// Cartesian product of sets (elements of the array).
	Prod : (sets : [[?]]);

	// Cartesian product initial iterator: all indexes are 0
	initProd(prod : Prod<?>) -> [int];

	// Next state at traversing Cartesian product. If the state is final - returns None().
	nextProd(v : [int], prod : Prod<?>) -> Maybe<[int]>;

	// The number of elements in the Cartesian product
	sizeProd(prod : Prod<?>) -> int;

	isEmptyProd(prod : Prod<?>) -> bool;

	// Map all tuples of product. The result has sizeProd(prod) elements.
	mapProd(prod : Prod<?>, f : ([?]) -> ??) -> [??];

	// Traverse all tuples of product.
	iterProd(prod : Prod<?>, f : ([?]) -> void) -> void;
	foldProd(prod : Prod<?>, init : ??, f : (??, [?]) -> ??) -> ??;
	fltermapProd(prod : Prod<?>, f : ([?]) -> Maybe<??>) -> [??];
}

initProd(prod : Prod<?>) -> [int] {
	map(prod.sets, \__ -> 0);
}

nextProd(v : [int], prod : Prod<?>) -> Maybe<[int]> {
	keep = ref false;
	next = mapi(v, \i, n -> {
		if (^keep) n else 
		if (n + 1 < length(prod.sets[i])) {
			keep := true;
			n + 1;
		} else 0
	});
	if (^keep) Some(next) else None();
}

sizeProd(prod : Prod<?>) -> int {
	fold (prod.sets, 1, \acc, s -> acc * length(s));
}

isEmptyProd(prod : Prod<?>) -> bool {
	prod.sets == [] || exists(prod.sets, \s -> s == []);
}

mapProd(prod : Prod<?>, f : ([?]) -> ??) -> [??] {
	if (sizeProd(prod) == 0) [] else {
		arr = ref [];
		doMapProd(prod, initProd(prod), arr, f);
		^arr;
	}
}

doMapProd(prod : Prod<?>, v : [int], arr : ref [??], f : ([?]) -> ??) -> void {
	d = mapi(v, \i, n -> prod.sets[i][n]);
	refArrayPush(arr, f(d));
	switch (nextProd(v, prod)) {
		Some(next): doMapProd(prod, next, arr, f);
		None(): {};
	}
}

iterProd(prod : Prod<?>, f : ([?]) -> void) -> void {
	if (sizeProd(prod) > 0) {
		doIterProd(prod, initProd(prod), f)
	}
}

doIterProd(prod : Prod<?>, v : [int], f : ([?]) -> void) -> void {
	f(mapi(v, \i, n -> prod.sets[i][n]));
	switch (nextProd(v, prod)) {
		Some(next): doIterProd(prod, next, f);
		None(): {};
	}
}

foldProd(prod : Prod<?>, init : ??, f : (??, [?]) -> ??) -> ?? {
	if (sizeProd(prod) == 0) init else
	doFoldProd(prod, initProd(prod), init, f)
}

doFoldProd(prod : Prod<?>, v : [int], val : ??, f : (??, [?]) -> ??) -> ?? {
	d = mapi(v, \i, n -> prod.sets[i][n]);
	new_val = f(val, d);
	switch (nextProd(v, prod)) {
		Some(next): doFoldProd(prod, next, new_val, f);
		None(): new_val;
	}
}

fltermapProd(prod : Prod<?>, f : ([?]) -> Maybe<??>) -> [??] {
	if (sizeProd(prod) == 0) [] else {
		arr = ref [];
		doFiltermapProd(prod, initProd(prod), arr, f);
		^arr;
	}
}

doFiltermapProd(prod : Prod<?>, v : [int], arr : ref [??], f : ([?]) -> Maybe<??>) -> void {
	d = mapi(v, \i, n -> prod.sets[i][n]);
	maybeApply(f(d), \val -> refArrayPush(arr, val));
	switch (nextProd(v, prod)) {
		Some(next): doFiltermapProd(prod, next, arr, f);
		None(): { };
	}
}
