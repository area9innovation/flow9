// Â© Copyright 2011 Area9 Innovation. All rights reserved
import ds/list;
import ds/tuples;

export {
	// The length of an array
	native length : ([?]) -> int = Native.length;

	// Concatenate two arrays
	native concat : ([?], [?]) -> [?] = Native.concat;

	// Concatenate three arrays
	concat3 : ([?], [?], [?]) -> [?];

	// Concatenate array of arrays
	concatA : ([[?]]) -> [?];

	// Apply a function to each element of an array to give a new array
	native map : ([?], (?) -> ??) -> [??] = Native.map;

	// Apply a function which takes an index and each element of an array to give a new array
	native mapi : ([?], (int, ?) -> ??) -> [??] = Native.mapi;

	// Apply a function to each element of an array to give a new array and concat resulting array of arrays to array
	mapConcat : ([?], (?) -> [??]) -> [??];

	mapiConcat : ([?], (int, ?) -> [??]) -> [??];

	// Apply a collecting function.  This is a left fold, i.e., it folds with the start of
	// the array first, i.e., fold([x1, x2, x3], x0, o) = ((x0 o x1) o x2) o x3
	native fold : (xs : [?], init : ??, fn : (??, ?)->??) -> ?? = Native.fold;

	// Apply a collecting function which takes an index, initial value and each element
	native foldi : (xs : [?], init : ??, fn : (int, ??, ?)->??) -> ?? = Native.foldi;

	// Replace a given element in an array with a new value. Makes a copy. Linear time
	// Appends new element if index points to the end (used in arrayPush)
	native replace : ([?], int, ?) -> [?] = Native.replace;

	// Append an element at the end of an array. Makes a copy. Linear time
	arrayPush : ([?], ?) -> [?];

	// Append an element at the end of an array if Some. Makes a copy. Linear time
	arrayPushMaybe : ([?], Maybe<?>) -> [?];

	// returns array of x, repeated n times
	arrayRepeat : (x : ?, n : int)->[?];

	// Get a subrange of an array from index
	// if index < 0 or length < 1 it returns an empty array
	native subrange : ([?], index : int, length : int) -> [?] = Native.subrange;

	// Take all but the first element of the array
	tail(a : [?]) -> [?];

	// Takes tail from given position, including startIndex
	tailFrom(a: [?], startIndex: int) -> [?];

	// Takes first 'count' elements. If count greater than array length, returns the entire array.
	take(a: [?], count : int) -> [?];

	// Gets first element of array or specified value, if it's empty
	firstElement(a: [?], def: ?) -> ?;

	// Gets last element of array or specified value, if it's empty
	lastElement(a: [?], def: ?) -> ?;

	// Gets the element by index or default value, if specified index doesn't exist in array
	elementAt(a : [?], idx : int, def : ?) -> ?;

	// Appends to the given array, which is updated with the new result. Linear time.
	refArrayPush : (ref [?], ?) -> void;

	// Concats to the given array, which is updated with the new result. Linear time.
	refConcat(x : ref [?], y : [?]) -> void;

	// Puts the element at the start of the array, dropping the last when the limit is full
	pushWithLimit(arr : [?], item : ?, limit : int) -> [?];

	// Generator [start..end]. Please notice:
	// - `end` is included in the resulting array, e.g. enumFromTo(1, 3) returns [1, 2, 3]
	// - if end < start then an empty array is returned, e.g. enumFromTo(1, -1) returns []
	native enumFromTo : (start : int, end : int) -> [int] = Native.enumFromTo;

	// Apply a function to each element of an array
	native iter : ([?], (?)->void) -> void = Native.iter;

	// Apply a function which takes an index and each element of an array
	native iteri : ([?], (int, ?)->void) -> void = Native.iteri;

	// Apply a function which takes an index and each element of an array until it returns true
	// Returns index of last element function was applied to.
	// Returns the size of array if such element was not found.
	native iteriUntil : ([?], (int, ?)->bool) -> int = Native.iteriUntil;

	// zip two lists with given function. The shorter list defines the resulting length
	zipWith : (a : [?], b : [??], fn : (?, ??)->???) -> [???];

	// zip two lists with given function. The longer list defines the resulting length.
	// shorter array is added with default value
	zipWith2 : (a : [?], def_a : ?, b : [??], def_b : ??, fn : (?, ??)->???) -> [???];

	// zip three lists with given function. The shorter list defines the resulting length
	zip3With : ([?], [??], [???], (?, ??, ???) -> ????) -> [????];

	// Creates a new array, whose elements are selected from 'a' with a condition 'test'.
	native filter : (a : [?], test : (?) -> bool) -> [?] = Native.filter;

	// Creates a new array, whose elements are selected from 'a' with a function 'test' returns Some(v).
	filtermap : (a : [?], test : (?) -> Maybe<??>) -> [??];

	// Creates a new array, whose elements are selected from 'a' with a function 'test' returns Some(v).
	filtermapi : (a : [?], test : (int, ?) -> Maybe<??>) -> [??];

	// Insert 'v' element to the 'index' place
	insertArray(a : [?], index : int, v : ?) -> [?];
	insertArray2(a : [?], index : int, v : [?]) -> [?];

	// resizes given array (cut or extend if needed) to be of length=n
	arrayResize(a : [?], n : int, def : ?) -> [?];

	// resizes a to be the same length as base. cut or add missing elements from base
	arrayAlign(a : [?], base : [?]) -> [?];

	// Removes the first occurence of v. Linear time
	removeFirst(a : [?], v : ?) -> [?];

	// Removes all occurences of v. Linear time
	removeAll(a : [?], v : ?) -> [?];

	removeIndex(a : [?], index : int) -> [?];
	removeRange(a : [?], index : int, len : int) -> [?];

	// The elemIndex function returns the index of the first element in the given list
	// which is equal (by ==) to the query element, or illegal if there is no such element.
	elemIndex : (a : [?], elem : ?, illegal : int) -> int;

	// Does this array contain the given element?
	contains : (a : [?], v : ?) -> bool;
	// Does `a` contain any element from `v`?
	containsAny : (a : [?], v : [?]) -> bool;

	// Determine if any element of the list satisfies the predicate.
	exists : (a : [?], fn : (?) -> bool) -> bool;

	// Determine if all elements of the array satisfy the predicate.
	forall : (a : [?], fn : (?) -> bool) -> bool;

	// Counts how much elements satisfies the predicate
	countA : (a : [?], fn : (?) -> bool) -> int;

	// Find an element that obeys the predicate. Returns None if not found
	find : (a : [?], fn : (?) -> bool) -> Maybe<?>;

	// Find an element that obeys the predicate. Returns default value if element is not found
	findDef : (a : [?], fn : (?) -> bool, def : ?) -> ?;

	// Find the index of an element that obeys the predicate. Returns None if not found
	findi : (a : [?], fn : (?) -> bool) -> Maybe<int>;

	// Find the index of an element that obeys the predicate. Returns default index if element is not found
	findiDef : (a : [?], fn : (?) -> bool, def : int) -> int;

	// Find the index of an element starting from i, obeying the predicate. Returns None if not found.
	findiex : (a : [?], fn : (?) -> bool, i : int) -> Maybe<int>;

	// Find the index of an element starting from i, ending at ie (inclusive), obeying the predicate. Returns None if not found.
	findiex2 : (a : [?], fn : (?) -> bool, i : int, ie : int) -> Maybe<int>;

	// Search backwards to find an element that obeys the predicate
	lastfindi : (a : [?], fn : (?) -> bool) -> Maybe<int>;

	// Search backwards to find an element that obeys the predicate
	lastfindiex : (a : [?], fn : (?) -> bool, iStart : int) -> Maybe<int>;

	// Search backwards to find an element that obeys the predicate
	lastfindiex2 : (a : [?], fn : (?) -> bool, iStart : int, iEnd : int) -> Maybe<int>;

	// Composition of find and maybeMap - if item was found then apply function to it.
	findmap : (a : [?], fn : (?) -> Maybe<??>) -> Maybe<??>;

	// Same as findmap but with index
	findmapi(a : [?], fn : (int, ?) -> Maybe<??>) -> Maybe<??>;

	// compareFn(x, y) - should return positive number if x > y, zero or positive num if x == y, negative num if y < x
	// returns -1 if array is empty or index of element that is >= then any other
	findiExtreme(a : [?], compareFn : (?, ?) -> double) -> int;

	// Inserts the given separator between each element of an array
	interleave : (a : [?], separator : ?) -> [?];

	// Returns array based on unique ?? values produced by id(?) -> ??
	uniqCustomByIds : (a : [?], id : (?) -> ??) -> [?];

	// split array by separator
	split : (a : [?], f : (?) -> bool) -> [[?]];

	// splits 1-dimension array to chunks with length less or equal to n
	splitByNumber(a : [?], n : int) -> [[?]];

	// Extract something from an array. Very useful for style arrays:
	//   extract(style, false, \s -> switch(s) { Bold(b): Some(b); default: None()});
	// returns false if there is no Bold style found in the array.
	// See extractStruct in flowstructs, which is much better
	extract(array : [?], defaultValue : ??, extractFn : (?) -> Maybe<??>) -> ??;

	// Call all functions
	applyall(array : [() -> void]) -> void;

	// Apply all synchronously. Expects onDone parameter for each function.
	// Will call them one by one and onAllDone at the end.
	applyAllSync(funcs: [(() -> void) -> void], onAllDone: () -> void) -> void;

	// Calls all functions that have an onDone parameter as fast as possible. When all call onDone, we call onAllDone.
	// (Also known as waitForAll). TODO: Move this to arrayutils.flow.
	applyAllAsync(funcs : [(() -> void) -> void], onAllDone : () -> void) -> void;

	// Apply next function to the result of the previous function
	applyall1(x : ?, fns : [(?) -> ?]) -> ?;

	// reverse array.
	reverseA : ([?]) -> [?];

	// iterates over an array waiting for each iteration to complete
	// will cause stack overflow on large arrays (~1500 items)
	// requires you to call cont inside iterator or it will stop
	// because it is not deferred. also "total" is meaningless and confusing
	// consider using iterDeferred2 from runtime.flow
	// TODO: Move this to array_deferred.flow.
	iterArrayDeferred: (array: [?], iterator: (?, cont: () -> void) -> void, onDone: () -> void, progress: (done: int, total: int) -> void) -> void;

	// Compare arrays when equal arrays must have the same elements, but in any order
	// regardless to their exact position in the array. Useful for style arrays.
	stylesEqual(s1: [?], s2: [?]) -> bool;

	// Check if index exists in array.
	existsIndex : (a : [?], index : int) -> bool;

	// How many elements are identical from the start of these arrays?
	sameStartLength(a : [?], b : [?]) -> int;

	swapIndexes(a : [?], index1 : int, index2 : int) -> [?];

	// Folds over a non-negative integer: peanoFold(3, z, s) == s(s(s(z)))
	peanoFold : (i : int, z : ?, s : (?)->?)->?;

	// Returs a copy of array with one element moved from one index to another
	// Returns array in case fromIndex doesn't exist in it
	moveElement(array : [?], fromIndex : int, toIndex : int) -> [?];

	// Convert an array to a list - notice, it does this in reverse order!
	array2list(a : [?]) -> List<?>;

	// split array into two based on specified criteria. opposite to zipWith
	unzip(xs : [?], fn : (?) -> bool) -> Pair<[?], [?]>;
	// split array into two based on specified criteria with index
	unzipi(xs : [?], fn : (int, ?) -> bool) -> Pair<[?], [?]>;
	// split array of pairs into two;
	unzipA(a: [Pair<?, ??>]) -> Pair<[?], [??]>;
	// split array of triples into three;
	unzipA3(a: [Triple<?, ??, ???>]) -> Triple<[?], [??], [???]>;
	// split array of quadruples into four;
	unzipA4(a: [Quadruple<?, ??, ???, ????>]) -> Quadruple<[?], [??], [???], [????]>;
}

tail(a : [?]) -> [?] {
	subrange(a, 1, length(a) - 1)	// Could be tailFrom(a, 1) for pure beauty
}

tailFrom(a: [?], startIndex: int) {
	subrange(a, startIndex, length(a) - startIndex)
}

take(a, count) {
	if (count <= 0) []
	else if (count >= length(a)) a
	else subrange(a, 0, count)
}

concat3(a1,a2,a3) {
	if (length(a1) < length(a3)) {
		concat(concat(a1, a2), a3);
	} else {
		concat(a1, concat(a2, a3));
	}
}

concatA(a) {
	doConcatA(a, 0, length(a))
}

doConcatA(a : [[?]], i : int, l : int) -> [?] {
	if (l <= 3) {
		if (l == 1) {
			a[i]
		} else if (l == 2) {
			concat(a[i], a[i+1])
		} else if (l == 3) {
			concat3(a[i], a[i+1], a[i+2])
		} else {
			[]
		}
	} else {
		m = l / 2;
		concat(
			doConcatA(a, i, m),
			doConcatA(a, i+m, l-m)
		)
	}
}

mapConcat(l, fn) { map(l, fn) |> concatA }
mapiConcat(l, fn) { mapi(l, fn) |> concatA }

arrayPush(array, value) { replace(array, length(array), value); }
arrayPushMaybe(array, value) { eitherMap(value, \v -> replace(array, length(array), v), array); }
refArrayPush(refArray, elem) { refArray := arrayPush(^refArray, elem); }
refConcat(x : ref [?], y : [?]) -> void { x := concat(^x, y); }

pushWithLimit(arr : [?], item : ?, limit : int) -> [?] {
	first = if (length(arr) >= limit) subrange(arr, 0, limit-1) else arr;
	concat([item], first);
}

zipWith(a, b, fn) {
	if (length(a) >= length(b))
		mapi(b, \i, bi -> fn(a[i], bi))
	else
		mapi(a, \i, ai -> fn(ai, b[i]))
}

zipWith2(a, def_a, b, def_b, fn) {
	if (length(a) >= length(b)) {
		mapi(a, \i, ai -> fn(ai, elementAt(b, i, def_b)))
	} else {
		mapi(b, \i, bi -> fn(elementAt(a, i, def_a), bi))
	}
}

zip3With(a, b, c, fn) {
	// len = min3(length(a), length(b), length(c));
	alen = length(a);
	blen = length(b);
	clen = length(c);
	len =
		if (alen < blen)
			if (alen < clen)
				alen
			else
				clen
		else
			if (blen < clen)
				blen
		else
				clen;
	map(enumFromTo(0, len-1), \i -> fn(a[i], b[i], c[i]))
}

filtermap(a : [?], test : (?) -> Maybe<??>) -> [??] {
	mapped = map(a, test);
	filtered = filter(mapped, isSome);
	map(filtered, \v ->
		cast(v : Maybe<??> -> Some<??>).value
	);
}

filtermapi(a : [?], test : (int, ?) -> Maybe<??>) -> [??] {
	mapped = mapi(a, test);
	filtered = filter(mapped, isSome);
	map(filtered, \v ->
		cast(v : Maybe<??> -> Some<??>).value
	);
}

removeFirst(a, v) {
	removeIndex(a, elemIndex(a, v, -1));
}

removeAll(a, v) {
	filter(a, \x -> x != v)
}

removeIndex(a, index) {
	if (existsIndex(a, index)) {
		concat(subrange(a, 0, index), subrange(a, index + 1, length(a) - index - 1))
	} else {
		a
	}
}

removeRange(a, index, len) {
	if (existsIndex(a, index)) {
		concat(subrange(a, 0, index), subrange(a, index + len, length(a) - index - len))
	} else {
		a
	}
}

insertArray(a : [?], index : int, v : ?) -> [?] {
	insertArray2(a, index, [v])
}

insertArray2(a : [?], index : int, v : [?]) -> [?] {
	concat3(subrange(a, 0, index), v, subrange(a, index, length(a) - index));
}

// implemented by the C++ runner
native elemIndex : (a : [?], elem : ?, illegal : int) -> int = Native.elemIndex;

elemIndex(a, elem, illegal) {
	foundIndex = iteriUntil(a, \i, ai -> ai == elem);
	if (foundIndex == length(a)) {
		illegal;
	} else {
		foundIndex;
	}
}

// implemented by the C++ runner
native exists : (a : [?], fn : (?) -> bool) -> bool = Native.exists;

exists(a, fn) {
	foundIndex = iteriUntil(a, \i, e -> fn(e));
	foundIndex != length(a);
}

countA(a, fn) {
	fold(a, 0, \cnt, e -> if (fn(e)) cnt+1 else cnt)
}

contains(a, v) {
	elemIndex(a, v, -1) != -1;
}

containsAny(a : [?], v : [?]){
	fold(v, false, \r, t -> if (r) r else contains(a, t));
}

// implemented by the C++ runner
native find : (a : [?], fn : (?) -> bool) -> Maybe<?> = Native.find;

find(a, fn) {
	foundIndex = iteriUntil(a, \i, e -> fn(e));
	if (foundIndex == length(a)) {
		None();
	} else {
		Some(a[foundIndex]);
	}
}

findDef(a : [?], fn : (?) -> bool, def : ?) -> ? {
	either(find(a, fn), def)
}

findiex2(a, fn, i, ie) { //findi'
	if (i >= length(a) || i > ie) None()
	else if (ie >= length(a)) findiex2(a, fn, i, length(a) - 1)
	else if (fn(a[i])) Some(i)
	else findiex2(a, fn, i + 1, ie);
}

findiex(a, fn, i) { //findi'
	if (i >= length(a)) None()
	else if (fn(a[i])) Some(i)
	else findiex(a, fn, i + 1);
}

findi(a, fn) {
	findiex(a, fn, 0)
}

findiDef(a : [?], fn : (?) -> bool, def : int) -> int {
	either(findi(a, fn), def)
}

lastfindi(a, fn) {
	maybeMap(findi(reverseA(a), fn), \i -> (length(a)-1) - i)
}

lastfindiex(a, fn, iStart) {
	maybeMap(findiex(reverseA(a), fn, length(a) - iStart - 1), \i -> (length(a)-1) - i)
}

lastfindiex2(a, fn, iStart, iEnd) {
	maybeMap(findiex2(reverseA(a), fn, length(a) - iStart - 1, length(a) - iEnd - 1), \i -> (length(a)-1) - i)
}

findmap(a : [?], fn : (?) -> Maybe<??>) -> Maybe<??> {
	doFindmapi(a, 0, \__, el -> fn(el))
}

findmapi(a : [?], fn : (int, ?) -> Maybe<??>) -> Maybe<??> {
	doFindmapi(a, 0, fn)
}

doFindmapi(a : [?], i : int, fn : (int, ?) -> Maybe<??>) -> Maybe<??> {
	if (i < length(a)) {
		res = fn(i, a[i]);
		if (isSome(res)) res
		else doFindmapi(a, i + 1, fn);
	} else {
		None()
	}
}

forall(a : [?], fn : (?) -> bool) {
	doForall(a, 0, length(a), fn)
}

findiExtreme(a : [?], compareFn : (?, ?) -> double) -> int {
	if (length(a) == 0) -1
	else foldi(a, 0, \i, extreme, elem -> {
		if (compareFn(a[extreme], elem) >= 0.0) extreme
		else i
	})
}

doForall(a : [?], i : int, n : int, fn : (?) -> bool) -> bool {
	if (i < n) {
		if (fn(a[i])) doForall(a, i + 1, n, fn) else false
	} else true
}

// O(N log N)
interleave(a, separator) {
	l = length(a);
	if (l <= 1)
		a
	else if (l == 2)
		[a[0], separator, a[1]]
	else
		concat3(
			interleave(subrange(a, 0, l / 2), separator),
			[separator],
			interleave(subrange(a, l / 2, l - l / 2), separator)
		)
}

	UniqCustomIx(vals : [?], ids : [??]);

uniqCustomByIds(a : [?], id : (?) -> ??) -> [?] {
	fold(a, UniqCustomIx([], []), \res : UniqCustomIx<?, ??>, v : ? -> {
		v2 = id(v);
		if (contains(res.ids, v2)) res else UniqCustomIx(arrayPush(res.vals, v), arrayPush(res.ids, v2));
	}).vals;
}

split(a : [?], f : (?) -> bool) {
	e = findi(a, f);
	l = length(a);
	switch (e : Maybe) {
		None(): [a];
		Some(v): {
				end = v;
				part = subrange(a, 0, end);
				if (end < l) concat([part], split(subrange(a, end+1, l-end-1), f))
				else [part]
		}
	}
}

splitByNumber(a : [?], n : int) -> [[?]]{
	l = length(a);
    if (l <= n || n <= 0) {
		[a]
	} else {
		concat([subrange(a, 0, n)], splitByNumber(subrange(a, n, l-n), n))
	}
};

extract(array, defaultValue, extractFn) {
	fold(array, defaultValue, \acc, v -> {
		v1 = extractFn(v);
		either(v1, acc);
	});
}

applyall(a) {
	iter(a, \f -> f());
}

applyAllSync(funcs: [(() -> void) -> void], onAllDone: () -> void) -> void {
	fold(funcs, \onDoneNothing -> onDoneNothing,
		\doBefore : (() -> void) -> () -> void, func : (() -> void) -> void -> {
			\onDone : () -> void-> {
				doBefore(\ -> func(onDone))
			}
		}
	)(onAllDone)();
}

applyAllAsync(funcs : [(() -> void) -> void], onAllDone : () -> void) -> void {
	if (funcs == []) onAllDone()
	else {
		count = ref length(funcs);
		decfn = \ -> {
			count := ^count - 1;
			if (^count == 0) {
				onAllDone();
			}
		}

		iter(funcs, \f -> {
			f(decfn)
		});
	}
}

applyall1(x : ?, fns : [(?) -> ?]) -> ? {
	fold(fns, x, \acc, fn -> fn(acc))
}

reverseA(a) {
	l = length(a);

	if (l > 1)
		map(enumFromTo(1, l), \i -> a[l - i])
	else
		a;
}

firstElement(a, def) {
	if (length(a) > 0) a[0] else def;
}

iterArrayDeferred(array: [?], iterator: (?, onDone: () -> void) -> void, onDone: () -> void, progress: (done: int, total: int) -> void) {
	if (array == []) {
		onDone();
	} else {
		elem = array[0];
		iterator(elem, \ -> {
			progress(1, length(array));
			iterArrayDeferred(tail(array), iterator, onDone, \done, total -> progress(done + 1, total + 1))
		});
	}
}

lastElement(a: [?], def: ?) -> ? {
	len = length(a);
	if (len > 0) {
		a[len - 1]
	} else {
		def
	}
}

elementAt(a : [?], idx : int, def : ?) -> ? {
	if (existsIndex(a, idx)) {
		a[idx]
	} else {
		def
	}
}

stylesEqual(s1: [?], s2: [?]) -> bool {
	!exists(s1, \e -> !contains(s2, e)) &&
	!exists(s2, \e -> !contains(s1, e))
}

existsIndex(a : [?], i : int) -> bool {
	i >= 0 && i < length(a)
}

sameStartLength(a : [?], b : [?]) -> int {
	sameStartLength2(a, b, 0)
}

sameStartLength2(a : [?], b : [?], before : int) -> int {
	if (length(a) * length(b) == 0) before
	else if (a[0] != b[0]) before
	else sameStartLength2(a |> tail, b |> tail, 1 + before)
}

swapIndexes(a : [?], index1 : int, index2 : int) -> [?] {
	if (index1 < 0 || index1 >= length(a) || index2 < 0 || index2 >= length(a) || index1 == index2)
		a
	else {
		temp = a[index1];
		replace(replace(a, index1, a[index2]), index2, temp);
	}
}

peanoFold(i : int, z : ?, s : (?)->?) {
    if (i <= 0) z
    else peanoFold(i - 1, s(z), s);
}

moveElement(array : [?], fromIndex : int, toIndex : int) -> [?] {
	toIndexFixed =
		if (toIndex < 0)
			0
		else if (existsIndex(array, toIndex))
			toIndex
		else
			length(array) - 1;

	if (existsIndex(array, fromIndex) && fromIndex != toIndexFixed) {
		insertArray(
			removeIndex(array, fromIndex),
			toIndexFixed,
			array[fromIndex]
		);
	} else {
		array;
	}
}

array2list(a : [?]) -> List<?> {
	fold(a, EmptyList(), \ac, e -> Cons(e, ac));
}

unzip(xs : [?], fn : (?) -> bool) -> Pair<[?], [?]> {
	unzipi(xs, \__, x -> fn(x))
}

unzipi(xs : [?], fn : (int, ?) -> bool) -> Pair<[?], [?]> {
	xs0 = mapi(xs, \i, x -> Pair(x, fn(i, x)));
	first = filtermap(xs0, \x -> if (x.second) Some(x.first) else None());
	second = filtermap(xs0, \x -> if (!x.second) Some(x.first) else None());
	Pair(first, second)
}

unzipA(a: [Pair<?, ??>]) -> Pair<[?], [??]> {
	Pair(map(a, firstOfPair), map(a, secondOfPair))
}

unzipA3(a: [Triple<?, ??, ???>]) -> Triple<[?], [??], [???]> {
	Triple(map(a, firstOfTriple), map(a, secondOfTriple), map(a, thirdOfTriple))
}

unzipA4(a: [Quadruple<?, ??, ???, ????>]) -> Quadruple<[?], [??], [???], [????]> {
	Quadruple(map(a, firstOfQuadruple), map(a, secondOfQuadruple), map(a, thirdOfQuadruple), map(a, fourthOfQuadruple))
}

arrayRepeat(x : ?, n : int) -> [?] {
	if (n <= 0) [] else map(enumFromTo(1, n), \__ -> x);
}

arrayResize(a : [?], n : int, def : ?) -> [?] {
	l = length(a);
	if (l == 0) []
	else if (l == n) a
	else if (l > n) subrange(a, 0, n)
	else concat(a, arrayRepeat(def, n - l));
}

arrayAlign(a : [?], base : [?]) -> [?] {
	l = length(a);
	n = length(base);
	if (n == 0) []
	else if (n == l) a
	else if (l > n) subrange(a, 0, n)
	else concat(a, subrange(base, l, n - l));
}
