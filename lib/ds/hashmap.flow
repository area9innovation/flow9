import ds/arrayutils;
import ds/tree;
import ds/dlist;
import string;
import math/math;

export {

/* Benchmarks.
Speedup of HashMap<int, int> operations, compared with Tree<int, int> (x times)
dependent on the sample map size (from 1 000 000 to 10 elements)
           1000000   100000   10000   1000   100   10
Creation    4.6        4.6      4.8    4.4   3.8   1.6
Adding      5.0        5.4      4.3    4.4   3.5   1.5
Removing    8.7        6.0      4.2    2.6   2.5   1.8
Lookup      6.8        4.0      3.3    2.3   1.9   1.4

Speedup of HashMap<string, string> operations, compared with Tree<string, string> (x times)
dependent on the sample map size (from 1 000 000 to 10 elements), using 'fastHashString'
           1000000   100000   10000   1000   100   10
Creation    5.1       4.0       3.5    2.5   1.9   1.2
Adding      5.0       2.9       3.4    2.0   1.9   1.0
Removing    6.4       5.1       3.5    2.4   2.0   1.3
Lookup      4.9       3.6       2.6    1.7   1.3   0.9
*/

	// A hash table, containing key-value pairs: HashMap<?, ??>.
	// USE WITH CAUTION, because it is a mutable data structure,
	// so calls of set/remove functions change their arguments.
	//
	// Tests (tools/flowc/tests/ds/hashmap_test) show, that it is approx. 
	// 5 times faster for integer and string keys, then Tree<?, ??>.
	//
	// Hash collisions are handled with conventional Tree<?, ??> data structure. 
	HashMap(map : native);

	// Creates a hash map with a given hash function.
	makeHashMap(hash : (?) -> int) -> HashMap<?, ??>;

	// Creates a hash map with a given inital capacity
	makeHashMapCap(hash : (?) -> int, init_capacity : int) -> HashMap<?, ??>;

	// Creates a hash map with a given initial capacity and specific load factor
	makeHashMapCapLoad(hash : (?) -> int, init_capacity : int, loadFactor : double) -> HashMap<?, ??>;

	lookupHashMap : (hashMap : HashMap<?, ??>, key : ?) -> Maybe<??>;
	lookupHashMapDef : (hashMap : HashMap<?, ??>, key : ?, defaultValue : ??) -> ??;

	containsKeyHashMap : (hashMap : HashMap<?, ??>, key : ?) -> bool;

	setHashMap : (hashMap : HashMap<?, ??>, key : ?, value : ??) -> void;

	removeFromHashMap : (tree : HashMap<?, ??>, key : ?) -> void;

	// count the number of nodes in tree. Complexity is O(1).
	sizeHashMap : (HashMap<?, ??>) -> int;

	iterHashMap(hashMap : HashMap<?, ??>, fn : (key : ?, value : ??) -> void) -> void;

	foldHashMap(hashMap : HashMap<?, ??>, acc: ???, f: (key: ?, value: ??, acc: ???) -> ???) -> ???;

	mapHashMap(hashMap : HashMap<?, ??>, fn : (key : ?, value : ??) -> ???) -> HashMap<?, ???>;

	// Merges two hash maps. t2 overrides t1 on duplicate entries.
	// (complexity is O(t1+t2))
	mergeHashMap(h1 : HashMap<?, ??>, h2 : HashMap<?, ??>) -> void;

	// Collect all it's keys in an array
	hashMapKeys(hashMap : HashMap<?, ??>) -> [?];

	// Collect all it's values in an array
	hashMapValues(hashMap : HashMap<?, ??>) -> [??];

	pairs2hashMap : (pairs : [Pair<?, ??>], hash : (?) -> int) -> HashMap<?, ??>;
	pairs2hashMapLoad : (pairs : [Pair<?, ??>], hash : (?) -> int, loadFactor : double) -> HashMap<?, ??>;
	hashMap2pairs : (hashMap : HashMap<?, ??>) -> [Pair<?, ??>];
	//pairs2hashMapArray : (pairs : [Pair<?, [??]>], hash : (?) -> int) -> HashMap<?, [??]>;

	// Get bucket (data) index for a given key; returns -1 if there are no buckets
	//hashMapIndex(hashMap : HashMap<?, ??>, key : ?) -> int;

	// If hash map contains any par (x,y), pops it and returns Some(Pair(x, y)), otherwise returns None(). O(n) complexity.
	//popHashMap(hashMap : HashMap<?, ??>) -> Maybe<Pair<?, ??>>;

	// Make a copy of hash map. Since HashMap is mutable, it may make sense.
	copyHashMap(hashMap : HashMap<?, ??>) -> HashMap<?, ??>;

	equalsHashMap(h1 : HashMap<?, ??>, h2 : HashMap<?, ??>) -> bool;


	// Wrapper around HashMap - Java implementation of a thread safe map
	native makeNativeHashMap : (hash :(?) -> int, cap : int, load : double) -> native = NativeHashMap.init;
	native setNativeHashMap : (m : native, key : ?, value : ??) -> void = NativeHashMap.set;
	native getNativeHashMap : (m : native, key : ?, defval : ??) -> ?? = NativeHashMap.get;
	native removeNativeHashMap : (m : native, key : ?) -> void = NativeHashMap.remove;
	native containsNativeHashMap : (m : native, key : ?) -> bool = NativeHashMap.contains;
	//native valuesNativeHashMap : (m : native) -> [??] = NativeHashMap.values;
	//native keysNativeHashMap : (m : native) -> [?] = NativeHashMap.keys;
	native sizeNativeHashMap : (m : native) -> int = NativeHashMap.size;
	native clearNativeHashMap : (m : native) -> void = NativeHashMap.clear;
	native cloneNativeHashMap : (m : native) -> native = NativeHashMap.clone;
	native iterNativeHashMap : (m : native, f : (?, ??) -> void) -> void = NativeHashMap.iter;
}

sizeHashMap(hashMap : HashMap<?, ??>) -> int {
	sizeNativeHashMap(hashMap.map);
}

makeHashMap(hash : (?) -> int) -> HashMap<?, ??> {
	makeHashMapCapLoad(hash, 16, 0.75);
}

makeHashMapCap(hash : (?) -> int, init_capacity : int) -> HashMap<?, ??> {
	makeHashMapCapLoad(hash, init_capacity, 0.75)
}

makeHashMapCapLoad(hash : (?) -> int, init_capacity : int, loadFactor : double) -> HashMap<?, ??> {
	HashMap(makeNativeHashMap(hash, init_capacity, loadFactor));
}

/*makeNativeHashMap(hash : (?) -> int, init_capacity : int, loadFactor : double) -> HashMap<?, ??> {
	// The initial size of hash map is 0
	HashMapImpl(ref arrayRepeatDeferred(\ -> ref makeTree(), init_capacity), hash, ref 0, loadFactor)
}*/

lookupHashMap(hashMap : HashMap<?, ??>, key : ?) -> Maybe<??> {
	getNativeHashMap(hashMap.map, key, None());
}

lookupHashMapDef(hashMap : HashMap<?, ??>, key : ?, defaultValue : ??) -> ?? {
	switch (lookupHashMap(hashMap, key)) {
		Some(v): v;
		None(): defaultValue;
	}
}

containsKeyHashMap(hashMap : HashMap<?, ??>, key : ?) -> bool {
	containsNativeHashMap(hashMap.map, key);
}

setHashMap(hashMap : HashMap<?, ??>, key : ?, value : ??) -> void {
	setNativeHashMap(hashMap.map, key, Some(value));
}

removeFromHashMap(hashMap : HashMap<?, ??>, key : ?) -> void {
	removeNativeHashMap(hashMap.map, key);
}

clearHashMap(hashMap : HashMap<?, ??>) -> void {
	clearNativeHashMap(hashMap.map);
}

iterHashMap(hashMap : HashMap<?, ??>, fn : (key : ?, value : ??) -> void) -> void {
	iterNativeHashMap(hashMap.map, fn);
}

foldHashMap(hashMap : HashMap<?, ??>, acc: ???, f: (key: ?, value: ??, acc: ???) -> ???) -> ??? {
	ac = ref acc;
	iterNativeHashMap(hashMap.map, \k, v -> ac := f(k, v, ^ac));
	^ac;
}

mapHashMap(hashMap : HashMap<?, ??>, f: (key: ?, value: ??) -> ???) -> HashMap<?, ???> {
	mapped = cloneNativeHashMap(hashMap.map);
	iterNativeHashMap(hashMap.map, \key, value -> setNativeHashMap(mapped, key, f(key, value)));
	HashMap(mapped);
}

mergeHashMap(h1 : HashMap<?, ??>, h2 : HashMap<?, ??>) -> void {
	iterNativeHashMap(h2.map, \k, v -> setNativeHashMap(h1.map, k, v));
}

hashMapKeys(hashMap : HashMap<?, ??>) -> [?] {
	res = ref [];
	iterNativeHashMap(hashMap.map, \k, __ -> refArrayPush(res, k));
	^res
}

hashMapValues(hashMap : HashMap<?, ??>) -> [??] {
	res = ref [];
	iterNativeHashMap(hashMap.map, \__, v -> refArrayPush(res, v));
	^res
}

pairs2hashMap(pairs : [Pair<?, ??>], hash : (?) -> int) -> HashMap<?, ??> {
	pairs2hashMapLoad(pairs, hash, 0.75)
}

pairs2hashMapLoad(pairs : [Pair<?, ??>], hash : (?) -> int, loadFactor : double) -> HashMap<?, ??> {
	len = floor(i2d(length(pairs)) / loadFactor) * 2;
	m = makeNativeHashMap(hash, len, loadFactor);
	iter(pairs, \pair -> setNativeHashMap(m, pair.first, pair.second));
	HashMap(m);
}

hashMap2pairs(hashMap : HashMap<?, ??>) -> [Pair<?, ??>] {
	if (sizeHashMap(hashMap) >= 10) {
		list2array(foldHashMap(hashMap, makeList(), \k, v, a -> Cons(Pair(k, v), a)))
	} else {
		foldHashMap(hashMap, [], \k, v, a -> arrayPush(a, Pair(k, v)))
	}
}

copyHashMap(hashMap : HashMap<?, ??>) -> HashMap<?, ??> {
	HashMap(cloneNativeHashMap(hashMap.map));
}

equalsHashMap(h1 : HashMap<?, ??>, h2 : HashMap<?, ??>) -> bool {
	if (sizeHashMap(h1) != sizeHashMap(h2)) false else {
		ret = ref true;
		iterNativeHashMap(h1.map, \k, v1 ->
			switch (getNativeHashMap(h2.map, k, None())) {
				Some(v2): if (v1 != v2) ret := false;
				None(): ret := false;
			}
		);
		^ret;
	}
}

// FALLBACKS FOR NON-NATIVE IMPLEMENTATION

// A hash table, containing key-value pairs: HashMapImpl<?, ??>.
// USE WITH CAUTION, because it is a mutable data structure,
// so calls of set/remove functions change their arguments.
//
// Tests (tools/flowc/tests/ds/hashmap_test) show, that it is approx. 
// 5 times faster for integer and string keys, then Tree<?, ??>.
//
// Hash collisions are handled with conventional Tree<?, ??> data structure. 
HashMapImpl(
	data : ref [ref Tree<?, ??>],
	hash : (?) -> int,
	size : ref int,
	loadFactor : double // By default is 0.75
);


sizeNativeHashMap(hm : native) -> int {
	impl = cast(flow(hm) : flow -> HashMapImpl);
	^(impl.size);
}

clearNativeHashMap(hm : native) -> void {
	impl = cast(flow(hm) : flow -> HashMapImpl);
	impl.size := 0;
	impl.data := arrayRepeatDeferred(\ -> ref makeTree(), length(^(impl.data)));
}

makeNativeHashMap(hash : (?) -> int, init_capacity : int, loadFactor : double) -> native {
	flow(HashMapImpl(ref arrayRepeatDeferred(\ -> ref makeTree(), init_capacity), hash, ref 0, loadFactor));
}

getNativeHashMap(hm : native, key : ?, defval : ??) -> ?? {
	hashMap = cast(flow(hm) : flow -> HashMapImpl);
	index = hashMapIndex(hashMap, key);
	if (index >= 0) {
		lookupTreeDef(^(^(hashMap.data)[index]), key, defval);
	} else {
		defval;
	}
}

containsNativeHashMap(hm : native, key : ?) -> bool {
	hashMap = cast(flow(hm) : flow -> HashMapImpl);
	index = hashMapIndex(hashMap, key);
	index >= 0 && containsKeyTree(^(^(hashMap.data)[index]), key);
}

setNativeHashMap(hm : native, key : ?, value : ??) -> void {
	hashMap = cast(flow(hm) : flow -> HashMapImpl);
	resizeHashMapOnDemand(hashMap);
	i = hashMapIndex(hashMap, key);
	if (i >= 0) {
		bucket = ^(^(hashMap.data)[i]);
		switch (lookupTree(bucket, key)) {
			Some(__): { }
			None(): hashMap.size := ^(hashMap.size) + 1;
		}
		^(hashMap.data)[i] := setTree(bucket, key, value);
	}
}

resizeHashMapOnDemand(hashMap : HashMapImpl<?, ??>) -> void {
	if (i2d(^(hashMap.size) + 1) > i2d(length(^(hashMap.data))) * hashMap.loadFactor) {
		// Double the size of the data vector
		resized_data = arrayRepeatDeferred(\ -> ref makeTree(), length(^(hashMap.data)) * 2);
		iter(^(hashMap.data), 
			\bucket -> {
				traverseInOrder(^bucket, \key, value -> {
						i = hashMapDataIndex(resized_data, hashMap.hash, key);
						if (i >= 0)
							resized_data[i] := setTree(^(resized_data[i]), key, value);
					}
				)
			}
		);
		hashMap.data := resized_data;
	}
}

removeNativeHashMap(hm : native, key : ?) -> void {
	hashMap = cast(flow(hm) : flow -> HashMapImpl);
	i = hashMapIndex(hashMap, key);
	if (i >= 0) {
		bucket = ^(^(hashMap.data)[i]);
		switch (lookupTree(bucket, key)) {
			Some(__): hashMap.size := ^(hashMap.size) - 1;
			None(): { }
		}
		^(hashMap.data)[i] := removeFromTree(bucket, key);
	}
}

iterNativeHashMap(hm : native, fn : (key : ?, value : ??) -> void) -> void {
	hashMap = cast(flow(hm) : flow -> HashMapImpl);
	iter(^(hashMap.data), \tree -> traverseInOrder(^tree, \key, value -> fn(key, value)));
}

/*foldHashMap(hashMap : HashMapImpl<?, ??>, acc: ???, f: (key: ?, value: ??, acc: ???) -> ???) -> ??? {
	fold(^(hashMap.data), acc,
		\ac, tree -> foldTree(^tree, ac, \key, value, a -> f(key, value, a))
	)
}

mapHashMap(hashMap : HashMapImpl<?, ??>, f: (key: ?, value: ??) -> ???) -> HashMapImpl<?, ???> {
	mapped = makeHashMapOfVolume(hashMap.hash, length(^(hashMap.data)), hashMap.loadFactor);
	iterHashMap(hashMap,
		\key, value -> setHashMap(mapped, key, f(key, value))
	);
	mapped
}*/

mergeNativeHashMap(hm1 : native, hm2 : native) -> void {
	iterNativeHashMap(hm2, \key, value -> setNativeHashMap(hm1, key, value));
}


hashMapIndex(hashMap : HashMapImpl<?, ??>, key : ?) -> int {
	hashMapDataIndex(^(hashMap.data), hashMap.hash, key);
}

hashMapDataIndex(data : [ref Tree<?,??>], hash : (?) -> int, key : ?) -> int {
	len = length(data);
	if (len > 0) {
		i = hash(key) % length(data);
		if (i < 0) {
			i + length(data);
		} else {
			i
		}
	} else {
		-1
	}
}
/*
popHashMap(hashMap : HashMapImpl<?, ??>) -> Maybe<Pair<?, ??>> {
	doPopHashMap(hashMap, 0);
}

doPopHashMap(hashMap : HashMapImpl<?, ??>, i : int) -> Maybe<Pair<?, ??>> {
	if (i == length(^(hashMap.data))) None() else {
		switch (^(^(hashMap.data)[i])) {
			TreeEmpty(): {
				doPopHashMap(hashMap, i + 1);
			}
			TreeNode(k, v, __,__,__): {
				^(hashMap.data)[i] := removeFromTree(^(^(hashMap.data)[i]), k);
				hashMap.size := ^(hashMap.size) - 1;
				Some(Pair(k, v));
			}
		}
	}
}
*/

cloneNativeHashMap(hm : native) -> native {
	hashMap = cast(flow(hm) : flow -> HashMapImpl);
	copy = makeNativeHashMap(hashMap.hash, length(^(hashMap.data)), hashMap.loadFactor);
	iterNativeHashMap(hm, \k, v -> setNativeHashMap(copy, k, v));
	copy;
}

/*equalsNativeHashMap(hm : native) -> native {
	copied = makeHashMapOfVolume(hashMap.hash, length(^(hashMap.data)), hashMap.loadFactor);
	iterHashMap(hashMap, \key, value -> { setHashMap(copied, key, value); { }});
	copied
}*/