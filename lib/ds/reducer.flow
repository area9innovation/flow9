import runtime;
import ds/array;
import ds/set;
import math/math;

// See https://github.com/thi-ng/umbrella/tree/develop/packages/transducers for inspiration

/*
TODO:
https://docs.thi.ng/umbrella/transducers/modules/_index_.html
compose(a : Reducer<?, ??>, b : Reducer<??, ???>) -> Reducer<?, ???>
add, count, div, mul, sub, 
dup, duplicate, every, any, some, 

benchmark, cat/concat, choices/random, converge, fill, fillN, frequencies, 
groupBinary, groupbyMap, groupByObject, interleave, interpolate, keep,
permutations, last, line, mapNth, mapKeys, mapVals, matchFirst, matchLast,
mean, min, movingAverage, movingMedian, padLast, padSides, page, 
partition, partitionBy, range, repeat, repeatedly, reverse, run, 
sample, scan, step, 

drop, dropNth, dropWhile, take, takeLast, takeNth, takeWhile, trim

throttle,
toggle, debug/trace, tween, wordWrap, 

parallel/multiplex, 
*/

export {
	// A reducer represents a processing pipeline.
	// The individual values we send in for processing is ?,
	// while the resulting type of the pipeline is ?? (i.e. acc)
	Reducer(
		// The initial value
		init : () -> ??, 
		// Each step is done here
		reduce : (acc : ??, value : ?) -> ReducerResult<??>,
		// The final value is transformed here
		final : (acc : ??) -> ??, 
	);

		// At each processing step, we either get a value or stop processing
		ReducerResult<?> ::= ReduceAcc<?>, Reduced<?>;
			// When the reduction should continue
			ReduceAcc(value : ?);
			// Used when we are fully reduced and should stop
			Reduced(value : ?);

	//
	// Drivers (all linear time)
	//

	// Evaluate a reducer on this array of values
	rreduce(r : Reducer<?, ??>, v : [?]) -> ??;

	// Evaluate a reducer on this list of values
	rreduceList(r : Reducer<?, ??>, v : List<?>) -> ??;

	// Evaluate a reducer on this tree of values
	rreduceTree(r : Reducer<Pair<?, ??>, ???>, v : Tree<?, ??>) -> ???;

	// Evaluate a reducer on the keys from this tree
	rreduceTreeKeys(r : Reducer<?, ???>, v : Tree<?, ??>) -> ???;

	// Evaluate a reducer on this set of values
	rreduceSet(r : Reducer<?, ??>, set : Set<?>) -> ??;

	// TODO: Char-wise iteration
	// rreduceString(r : Reducer<string, ?>, str : string) -> ?;
	// Char-wise iteration as unicode
	// rreduceChars(r : Reducer<int, ?>, str : string) -> ?;

	// TODO: graphs, dlist, behaviour/transforms

	//
	// Reducers
	//

	// Collect items in a list - O(n)
	rlist : () -> Reducer<?, List<?>>;
	// Collect items in array - O(n^2)
	rarray : () -> Reducer<?, [?]>;
	// Collect items in a set - O(n log n)
	rset : () -> Reducer<?, Set<?>>;
	// Collect items in a tree - O(n log n)
	rtree : () -> Reducer<Pair<?, ??>, Tree<?, ??>>;

	// Fold the values using this initial value, and this function
	rfold(init : ??, fn : (??, ?) -> ??) -> Reducer<?, ??>;

	// TODO: Collect chars into a string - O(n^2)
	// rstring : () -> Reducer<string, string>
	// rchars : () -> Reducer<string, int>
	// graphs, dlist, behaviour/transforms

	//
	// Transducers
	//

	// Transforms a reducer by a fn
	rmap(r : Reducer<?, ???>, fn : (??) -> ?) -> Reducer<??, ???>;

	// Keeps only distinct values - n log n
	rdistinct(r : Reducer<?, ??>) -> Reducer<?, ??>;

	// Keeps values that match the condition
	rfilter(r : Reducer<?, ??>, fn : (?) -> bool) -> Reducer<?, ??>;

	// Keeps the maximum result value - this is different from the package, where it is the input values
	rmax(r : Reducer<?, ??>) -> Reducer<?, ??>;
	// This would work with input values:
	// rmax(r : Reducer<?, ?>) -> Reducer<?, ?>;
}

//
// Drivers
//

rreduce(r : Reducer<?, ??>, vs : [?]) -> ?? {
	acc = doRReduce(r, r.init(), vs, 0);
	r.final(acc);
}

doRReduce(r : Reducer<?, ??>, acc : ??, vs : [?], i : int) -> ?? {
	if (i < length(vs)) {
		v = r.reduce(acc, vs[i]);
		switch (v) {
			ReduceAcc(nacc): {
				doRReduce(r, nacc, vs, i + 1)
			}
			Reduced(val): val;
		}
	} else acc;
}

rreduceList(r : Reducer<?, ??>, vs : List<?>) -> ?? {
	acc = doRReduceList(r, r.init(), vs);
	r.final(acc);
}

doRReduceList(r : Reducer<?, ??>, acc : ??, vs : List<?>) -> ?? {
	switch (vs) {
		EmptyList(): acc;
		Cons(v1, t): {
			v = r.reduce(acc, v1);
			switch (v) {
				ReduceAcc(nacc): {
					doRReduceList(r, nacc, t)
				}
				Reduced(val): val;
			}
		}
	}
}

rreduceTree(r : Reducer<Pair<?, ??>, ???>, tree : Tree<?, ??>) -> ??? {
	acc = doRReduceTree(r, r.init(), tree);
	r.final(acc.value);
}

doRReduceTree(r : Reducer<Pair<?, ??>, ???>, acc : ???, tree : Tree<?, ??>) -> ReducerResult<???> {
	switch (tree : Tree) {
		TreeEmpty(): ReduceAcc(acc);
		TreeNode(k, v, left, right, depth): {
			acc1 = doRReduceTree(r, acc, left);
			switch (acc1) {
				ReduceAcc(nacc1): {
					// OK, there is more
					acc2 = r.reduce(nacc1, Pair(k, v));
					switch (acc2) {
						ReduceAcc(nacc2): {
							// OK, there is more
							doRReduceTree(r, nacc2, right);
						}
						Reduced(value): acc2; // We are done
					}
				}
				Reduced(value): acc1;	// We are done
			}
		}
	}
}

rreduceTreeKeys(r : Reducer<?, ???>, tree : Tree<?, ??>) -> ??? {
	acc = doRReduceTreeKeys(r, r.init(), tree);
	r.final(acc.value);
}

doRReduceTreeKeys(r : Reducer<?, ???>, acc : ???, tree : Tree<?, ??>) -> ReducerResult<???> {
	switch (tree : Tree) {
		TreeEmpty(): ReduceAcc(acc);
		TreeNode(k, v, left, right, depth): {
			acc1 = doRReduceTreeKeys(r, acc, left);
			switch (acc1) {
				ReduceAcc(nacc1): {
					// OK, there is more
					acc2 = r.reduce(nacc1, k);
					switch (acc2) {
						ReduceAcc(nacc2): {
							// OK, there is more
							doRReduceTreeKeys(r, nacc2, right);
						}
						Reduced(value): acc2; // We are done
					}
				}
				Reduced(value): acc1;	// We are done
			}
		}
	}
}

rreduceSet(r : Reducer<?, ??>, set : Set<?>) -> ?? {
	rreduceTreeKeys(r, set.tree);
}

//
// Reducers
//

rlist() -> Reducer<?, List<?>> {
	Reducer(\ -> makeList(), \acc : List<?>, v : ? -> ReduceAcc(Cons(v, acc)), \acc : List<?> -> acc);
}

rarray() -> Reducer<?, [?]> {
	Reducer(\ -> [], \acc : [?], v : ? -> ReduceAcc(arrayPush(acc, v)), \acc : [?] -> acc);
}

rset() -> Reducer<?, Set<?>> {
	Reducer(\ -> makeSet(), \acc : Set<?>, v : ? -> ReduceAcc(insertSet(acc, v)), \acc : Set<?> -> acc);
}

rtree() -> Reducer<Pair<?, ??>, Tree<?, ??>> {
	Reducer(\ -> makeTree(), \acc : Tree<?, ??>, v : Pair<?, ??> -> ReduceAcc(setTree(acc, v.first, v.second)), \acc : Tree<?, ??> -> acc);
}

rfold(init : ??, fn : (??, ?) -> ??) -> Reducer<?, ??> {
	Reducer(\ -> init, \acc, v -> ReduceAcc(fn(acc, v)), \acc : ?? -> acc);
}

//
// Transducers
//

rmap(r : Reducer<?, ???>, fn : (??) -> ?) -> Reducer<??, ???> {
	Reducer(
		r.init,
		\acc : ???, v : ?? -> {
            r.reduce(acc, fn(v))
		},
		r.final,
	)
}

rdistinct(r : Reducer<?, ??>) -> Reducer<?, ??> {
	seen = ref makeSet();
	Reducer(
		r.init,
		\acc, v -> {
			if (containsSet(^seen, v)) ReduceAcc(acc)
			else {
				seen := insertSet(^seen, v);
				r.reduce(acc, v)
			}
		},
		r.final,
	)
}

rfilter(r : Reducer<?, ??>, fn : (?) -> bool) -> Reducer<?, ??> {
	Reducer(
		r.init,
		\acc, v -> {
			if (fn(v)) {
				r.reduce(acc, v)
			} else ReduceAcc(acc)
		},
		r.final,
	)
}


rmax(r : Reducer<?, ??>) -> Reducer<?, ??> {
	Reducer(
		r.init,
		\acc, v -> {
			val = r.reduce(acc, v);
			switch (val) {
				Reduced(nacc): Reduced(max(acc, nacc));
				ReduceAcc(nacc): ReduceAcc(max(acc, nacc));
			}
		},
		r.final,
	)
}

/*
main() {
	// To combine into an array
	reducer = rmap(rarray(), i2s);
	f = rreduce(rfilter(rdistinct(reducer), \n -> n % 3 == 0), [1, 1, 2, 3, 2, 5, 2, 1]);
	println(f);	// ["3"]

	f2 = rreduceTree(rarray(), setTree(makeTree1(2, -2), 1, -1));
	println(f2);	// [Pair(1, -1), Pair(2, -2)]

	f3 = rreduceSet(rarray(), buildSet([3,1,2,3,6]));
	println(f3);	// [1,2,3,6]
}
*/
