import ds/tree;
import fusion;

export {
	// Given a dynamic array of values, construct a factory that can produce a tree of it
	getCachedTree(data : Transform<[?]>, getKey : (?) -> ??) -> CachedTree<??, ?>;
	getCachedTreeArray(data : Transform<[?]>, getKey : (?) -> ??) -> CachedTreeArray<??, ?>;

	CachedTree(
		// When you need a tree of the data, call this. It will cache the tree when possible
		getTree : () -> Tree<?, ??>,
		// To free memory, call this
		clear : () -> void,
		// When done, call this
		dispose : () -> void,
		// helper to be used inside MConstruct to construct/descruct
		constructor : () -> () -> void
	);

	CachedTreeArray(
		getTree : () -> Tree<?, [??]>,
		clear : () -> void,
		dispose : () -> void,
		constructor : () -> () -> void
	);
}

connect2TreeDataFn(data : Transform<[?]>, us : ref List<() -> void>, hasData : ref bool, cachedTreeAction : () -> void) -> void {
	us := fsubscribe(data, \__ -> {
		hasData := false;
		cachedTreeAction();
	});
}

disposeTreeFn(hasData : ref bool, cachedTreeAction : () -> void, us : ref List<() -> void>) -> void {
	hasData := false;
	cachedTreeAction();
	callList(^us);
	us := makeList();
}

clearTreeFn(hasData : ref bool, cachedTreeAction : () -> void) -> void {
	hasData := false;
	cachedTreeAction();
}

treeConstructorFn(us : ref List<() -> void>, connect2data : () -> void, dispose : () -> void) -> () -> void {
	// if we already connected then no need to connect again
	if (isEmptyList(^us)) {
		connect2data()
	}
	dispose
}

getCachedTree(data : Transform<[?]>, getKey : (?) -> ??) -> CachedTree<??, ?> {
	hasData = ref false;
	cachedTree = ref makeTree();

	us = ref makeList();

	connect2data = \ -> connect2TreeDataFn(data, us, hasData, \-> cachedTree := makeTree());

	dispose = \ -> disposeTreeFn(hasData, \-> cachedTree := makeTree(), us);

	// we connect it to be immediately available for use
	connect2data();

	CachedTree(
		\ -> {
			if (!^hasData) {
				cdata = fgetValue(data);
				cachedTree := fold(cdata, makeTree(), \acc, d -> {
					setTree(acc, getKey(d), d);
				});
				hasData := true;
			}
			^cachedTree
		},
		\ -> clearTreeFn(hasData, \ -> cachedTree := makeTree()),
		dispose,
		\ -> treeConstructorFn(us, connect2data, dispose)
	)
}

getCachedTreeArray(data : Transform<[?]>, getKey : (?) -> ??) -> CachedTreeArray<??, ?> {
	hasData = ref false;
	cachedTreeArray = ref makeTree();

	us = ref makeList();

	connect2data = \ -> connect2TreeDataFn(data, us, hasData, \-> cachedTreeArray := makeTree());

	dispose = \ -> disposeTreeFn(hasData, \-> cachedTreeArray := makeTree(), us);

	// we connect it to be immediately available for use
	connect2data();

	CachedTreeArray(
		\ -> {
			if (!^hasData) {
				cdata = fgetValue(data);
				cachedTreeArray := fold(cdata, makeTree(), \acc, d -> {
					treePushToArrayUnique(acc, getKey(d), d);
				});
				hasData := true;
			}
			^cachedTreeArray
		},
		\ -> clearTreeFn(hasData, \ -> cachedTreeArray := makeTree()),
		dispose,
		\ -> treeConstructorFn(us, connect2data, dispose)
	)
}