import ds/bitvector;
import math/math;
import text/blueprint;

// Paper describing this here:
// https://www.dcc.uchile.cl/TR/2009/TR_DCC-20090429-005.pdf

// With implementation here: 
// https://github.com/simongog/sdsl-lite/blob/master/include/sdsl/k2_tree.hpp

// At first, we do a k=2 implementation just to get it working

QuadI(
    // How high is the tree in levels? Each level contains *4 more nits
    height : int,
    // These are really just bits. These correspond to the nodes in lexicographic order, except for the leafes
    // If the value is 0, it means that all the leaves below this node are 0.
    nodes : [int],
    // These are really just bits. We keep groups of 4 bits for each leaves which is not 0
    leaves : [int]
);

// Construct a compressed QuadTree for these bools
build1(matrix : [[int]]) -> QuadI {
    n = length(matrix);
    if (n <= 2) {
        xy = \x, y -> elementAt(elementAt(matrix, y, [0]), x, 0);
        leaves = [
                xy(0,0), xy(0, 1),
                xy(1,0), xy(1, 1)
            ];
        if (leaves == [0, 0, 0, 0]) {
            QuadI(1, [0], []);
        } else {
            QuadI(1,
                [1], 
                leaves
            );
        }
    } else {
        height = ceil(log(i2d(length(matrix))) / log(i2d(2)));
        step = pow(2, height);
        half = step / 2;
        nw = build1(map(subrange(matrix, 0, half), \row -> subrange(row, 0, half)));
        ne = build1(map(subrange(matrix, 0, half), \row -> subrange(row, half, half)));
        sw = build1(map(subrange(matrix, half, half), \row -> subrange(row, 0, half)));
        se = build1(map(subrange(matrix, half, half), \row -> subrange(row, half, half)));
        m = mergeQuadI(mergeQuadI(nw, ne), mergeQuadI(sw, se));
        QuadI(
            m.height + 1,
            concat(
                if (m.leaves == []) [0] else [1], 
                m.nodes
            ),
            m.leaves,
        )
    }
}

mergeQuadI(left : QuadI, right : QuadI) -> QuadI {
    QuadI(
        left.height,
        concat(left.nodes, right.nodes),
        concat(left.leaves, right.leaves)
    )
}

// TODO: Implement this correctly
getQuadI(q : QuadI, node : int, leavesOffset : int, x : int, y : int) -> bool {
    // If the root is empty, we know it is false
    if (q.nodes[node] == 0) false
    else {
        step = pow(2, q.height);
        half = step / 2;
        north = y < half;
        west = x < half;

        offset = if (north && west) {
            0
        } else if (north && !west) {
            // NE: Check if the NW is empty or not
            if (q.nodes[node + 1] == 0) 0 else 4;
        } else if (!north && west) {
            if (q.nodes[node + 1] == 0) 0 else 4
            + if (q.nodes[node + 2] == 0) 0 else 4;
        } else {
            if (q.nodes[node + 1] == 0) 0 else 4
            + if (q.nodes[node + 2] == 0) 0 else 4
            + if (q.nodes[node + 3] == 0) 0 else 4;
        };
        getQuadI(q, 
            node + 5, // This is wrong. We should figure out how to do this
            leavesOffset + offset, x, y
        );
    }
}

dumpQuadI(q : QuadI) -> void {
    leaves = superglue(q.leaves, \b -> if (b == 1) "1" else ".", "");
    println("Height: " + i2s(q.height));
    println("Nodes:  ");
    dumpQNodes(q, 0, 0);
    println("Leaves: " + leaves);
}

dumpQNodes(q : QuadI, level : int, node : int) -> void {
    size = pow(4, level);
    println(subrange(q.nodes, node, size));
    if (level + 1 < q.height) {
        dumpQNodes(q, level + 1, node + pow(4, level));
    }
}

main() {
    if (true) {
        q = build1([
                [0,1,0,0, 0,0,0,0],
                [0,0,1,1, 1,0,0,0],
                [0,0,0,0, 0,0,0,0],
                [0,0,0,0, 0,0,0,0],

                [0,0,0,0, 0,0,0,0],
                [0,0,0,0, 0,0,0,0],
                [0,0,0,0, 0,0,0,0],
                [0,0,0,0, 1,0,0,0],
            ]);
        dumpQuadI(q);
    }

    if (false) {
        dumpQuadI( 
            build1([
                [1,1,0,0],
                [0,1,0,0],
                [0,0,1,1],
                [0,0,1,0],
            ])
        );
    }

    if (false) {
        q = build1([
                [0,1],
                [0,0],
            ]);
    }
    quit(0);
}
 