import ds/bitvector;
import math/math;
import text/blueprint;

// Paper describing this here:
// https://www.dcc.uchile.cl/TR/2009/TR_DCC-20090429-005.pdf

// With implementation here: 
// https://github.com/simongog/sdsl-lite/blob/master/include/sdsl/k2_tree.hpp

// And another in Rust here:
// https://github.com/GGabi/k2_tree/blob/master/src/tree/datastore.rs

// We do our own, with each layer of internal nodes in a separate array

// At first, we do a k=2 implementation just to get it working

QuadI(
    // How high is the tree in levels? Each level contains *4 more bits
    height : int,
	// These are really bits, so could be [[bool]]. The bits correspond to the nodes in lexicographic order of the tree,
	// but with a separate array for each level. 
	// The value is 0 when all leaves below this internal node are 0.
	levelNodes : [[int]],
    // These are really just bits, so could be [bool]. We keep groups of 4 bits for each leaf which is not 0
    leaves : [int],
    // Where does the leaf for each leaf quadrant begin in terms of index into leaves?
	// Matches the last level of nodes in length.
    leavesOffset : [int],
);

// Construct a compressed QuadTree for these bools
build1(matrix : [[int]]) -> QuadI {
    n = length(matrix);
    if (n <= 2) {
        xy = \x, y -> elementAt(elementAt(matrix, y, [0]), x, 0);
        leaves = [
                xy(0,0), xy(1, 0),
                xy(0,1), xy(1, 1)
            ];
        if (leaves == [0, 0, 0, 0]) {
            QuadI(1, [[0]], [], [0]);
        } else {
            QuadI(1, [[1]], leaves, [0]);
        }
    } else {
        height = ceil(log(i2d(length(matrix))) / log(i2d(2)));
        width = pow(2, height);
        half = width / 2;
		// TODO: If we send in x and y coordinates, we do not have to construct
		// these temporary subrange arrays
        nw = build1(map(subrange(matrix, 0, half), \row -> subrange(row, 0, half)));
        ne = build1(map(subrange(matrix, 0, half), \row -> subrange(row, half, half)));
        sw = build1(map(subrange(matrix, half, half), \row -> subrange(row, 0, half)));
        se = build1(map(subrange(matrix, half, half), \row -> subrange(row, half, half)));
        m = mergeQuadI(mergeQuadI(mergeQuadI(nw, ne), sw), se);
        QuadI(
            m.height + 1,
			concat(
				if (m.leaves == []) [[0]] else [[1]],
				m.levelNodes,
			),
            m.leaves,
            m.leavesOffset
        )
    }
}

mergeQuadI(left : QuadI, right : QuadI) -> QuadI {
    QuadI(
        left.height,
		mapi(left.levelNodes, \i, ln -> {
			concat(ln, right.levelNodes[i])
		}),
        concat(left.leaves, right.leaves),
        concat(left.leavesOffset, map(right.leavesOffset, \o -> o + length(left.leaves)))
    )
}

// Call with height = 0, node = 0
getQuadI(q : QuadI, height : int, node : int, x : int, y : int, debug : bool) -> bool {
	if (debug) {
		println("Looking for " + i2s(x) + "," + i2s(y) + ". Node offset: " + i2s(node) + " at height " + i2s(height) + "/" + i2s(q.height) + " with nodes " + toString(q.levelNodes[height]));
		println(" has internal node value " + i2s(q.levelNodes[height][node]) + " from layer " + toString(tailFrom(q.levelNodes[height], node)));
	}
    // If the internal node on the way is false, we know the result is false
	if (q.levelNodes[height][node] == 0) false
	else if (height + 1 == q.height) {
		offset = q.leavesOffset[node];
		value = elementAt(q.leaves, offset + x + 2 * y, 0) == 1;
		if (debug) {
			println("We are at leaves at node " + i2s(node) + " with offset " + i2s(offset) + " with value " + b2s(value));
		};
		value
   } else {
		width = pow(2, q.height - height);
		halfWidth = width / 2;
        north = y < halfWidth;
        west = x < halfWidth;

		levelHalf = max(2, pow(2, height));
		offset = (if (west) 0 else levelHalf / 2) + (if (north) 0 else levelHalf); 
		newNode = 4 * node + offset;

		if (debug) {
			println(" with width " + i2s(width) + " and quadrant " + (if (north) "N" else "S") + (if (west) "W" else "E") + " gives node offset " + i2s(offset));
			println(" giving new node " + i2s(newNode) + " with level half " + i2s(levelHalf) );
		}

        getQuadI(q, 
			height + 1,
            newNode,
			// Adjust the coordinates to the smaller quadrant
			x % halfWidth, 
			y % halfWidth,
			debug
        );
    }
}

dumpQuadI(q : QuadI) -> void {
    leaves = supergluei(q.leaves, \i, b -> (if (i % 4 == 0) " " else "") + if (b == 1) "1" else ".", "");
    println("Height: " + i2s(q.height));
	println("Level nodes:");
	iter(q.levelNodes, println);
    println("Leaves: " + leaves);
    println("Leave offsets: " + superglue(q.leavesOffset, i2s, ", "));
	println("");
}

dumpQGrid(q : QuadI, size : int) -> void {
	fori(0, size - 1, \y -> {
		println(foldRange(0, size - 1, "", \acc, x -> {
			acc + (if (getQuadI(q, 0, 0, x, y, false)) "1" else ".")
			+ (if (x % 4 == 3) " " else "")
		}));
		if (y % 4 == 3) println("");
	})
}

main() {
    if (true) {
		// This works
        q = build1([
                [0,1,0,0, 1,0,0,0],
                [0,0,1,1, 1,0,0,0],
                [0,0,1,0, 0,0,0,0],
                [0,0,0,0, 0,0,0,0],

                [0,0,0,0, 0,0,0,0],
                [0,0,0,0, 0,0,0,0],
                [0,1,0,0, 0,0,0,0],
                [0,0,0,0, 1,0,0,0],
            ]);
        dumpQuadI(q);
		println(getQuadI(q, 0, 0, 2, 1, true));
        println("");
		dumpQGrid(q, 8);
		{}
    }

    if (false) {
		// This works
        q = build1([
                [0,1, 0,1],
                [1,1, 0,1],

                [0,0, 0,1],
                [0,0, 1,0],
            ]);
        dumpQuadI( q );

		println(getQuadI(q, 0, 0, 2, 0, true));

		dumpQGrid(q, 4);
    }

    if (false) {
        // This works
        q = build1([
                [0,0],
                [0,0],
            ]);
        dumpQuadI(q);
        dumpQGrid(q, 2);
    }
    quit(0);
}
