import ds/tree;
import math/math;

export {
	//
	// An object oriented API for a trie with just ints
	// 
	makeIntTrie() -> IntTrie;

	IntTrie(
		// Does this trie contain this row?
		contains : (row : [int]) -> bool,
		// Insert this row in the trie (ignoring duplicates)
		insert : (row : [int]) -> void,
		// Merge these two tries
		merge : (IntTrie) -> void,
		// Debug dump of the trie
		print : () -> void,
		// Low level access to/from underlying representation
		toRaw : () -> IntTrieValue,
		fromRaw : (IntTrieValue) -> void,
	);

	//
	// The same, but as a functional API for a trie with just ints
	//

	IntTrieValue(
		values : Tree<int, IntTrieValue>
	);

	// Check if the trie contains this value (starting with i = 0)
	containsIntTrie(trie : IntTrieValue, i : int, values : [int]) -> bool;
	// Insert this value (starting with i = 0)
	insertIntTrie(trie : IntTrieValue, i : int, values : [int]) -> IntTrieValue;
	// Merge these two tries
	mergeIntTries(left : IntTrieValue, right : IntTrieValue) -> IntTrieValue;
	// Fold over the trie, expanding each row to full arrays
	foldIntTrie(acc : ?, t : IntTrieValue, fn : (acc : ?, [int]) -> ?) -> ?;

	// Debug dump of the trie
	printTrie(t : IntTrieValue) -> void;
}


makeIntTrie() -> IntTrie {
	value = ref IntTrieValue(makeTree());
	IntTrie(
		\row -> containsIntTrie(^value, 0, row),
		\row -> value := insertIntTrie(^value, 0, row),
		\trie -> {
			rvalue : IntTrieValue = trie.toRaw();
			value := mergeIntTries(^value, rvalue);
		},
		\ -> printTrie(^value),
		\ -> ^value,
		\v -> value := v,
	)
}

//
// The raw, functional implementation of a trie
//

// Check if the trie contains this value (starting with i = 0)
containsIntTrie(trie : IntTrieValue, i : int, values : [int]) -> bool {
	n = length(values);
	if (i < n) {
		val = values[i];
		mtrie = lookupTree(trie.values, val);
		mtrie ?? {
			containsIntTrie(mtrie, i + 1, values);
		} : {
			false
		}
	} else {
		true;
	}
}

// Insert this value (starting with i = 0)
insertIntTrie(trie : IntTrieValue, i : int, values : [int]) -> IntTrieValue {
	if (i < length(values)) {
		val = values[i];
		mtrie = lookupTree(trie.values, val);
		mtrie ?? {
			ntrie = insertIntTrie(mtrie, i + 1, values);
			IntTrieValue(setTree(trie.values, val, ntrie));
		} : {
			// There is no subtree for this, so make one
			ntrie = insertIntTrie(IntTrieValue(makeTree()), i + 1, values);
			IntTrieValue(setTree(trie.values, val, ntrie));
		}
	} else {
		// We are done
		trie;
	}
}

mergeIntTries(left : IntTrieValue, right : IntTrieValue) -> IntTrieValue {
	foldIntTrie(left, right, \acc, lrow -> {
		insertIntTrie(acc, 0, lrow)
	});
}

// Fold over the trie, expanding each row to full arrays
foldIntTrie(acc : ?, t : IntTrieValue, fn : (acc : ?, [int]) -> ?) -> ? {
	doFoldIntTrie(acc, [], t, fn)
}

doFoldIntTrie(acc : ?, row : [int], t : IntTrieValue, fn : (acc : ?, [int]) -> ?) -> ? {
	foldTree(t.values, acc, \h, tl, acc2 -> {
		nrow = arrayPush(row, h);
		if (isEmptyTree(t.values)) {
			// Leaf
			fn(acc2, nrow);
		} else {
			// OK, there is more
			doFoldIntTrie(acc, nrow, tl, fn)
		}
	});
}
 
printTrie(t : IntTrieValue) -> void {
	println("Trie:");
	doPrintTrie("", t);
}

doPrintTrie(indent : string, t : IntTrieValue) -> void {
	nindent = indent + "  ";
	traverseInOrder(t.values, \val, tt -> {
		println(indent + i2s(val));
		doPrintTrie(nindent, tt)
	});
}
