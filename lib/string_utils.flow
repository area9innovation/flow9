import string;
import text/deserialize_string;
import math/bits;
import math/stringmath;
import math/matrix;

export {
	humpCase(s : string, initial : bool) -> string;
	snakeCase(s : string) -> string;
	humanizeName(s : string) -> string;
	plural2single(s : string) -> string;

	// Capitalize the first letter only
	capitalize(s : string) -> string;
	decapitalize(s : string) -> string;

	// Checks string starts from letter or underscore and continues with same or numbers.
	isValidIdentifier(s : string) -> bool;

	/// Folds over the left-to-right character sequence in s
	stringFoldChar : (s : string, a : ?, f : (a2 : ?, c : string) -> ?) -> ?;
	stringFoldiChar: (s : string, a : ?, f : (i : int, a2 : ?, c : string) -> ?) -> ?;

	// Used in InputFilter, init passed to fold,
	// example in color Picker it starts with "#": strLeft(hexDigitFilter(s, "#"), 7);
	hexDigitFilter: (s: string, init: string) -> string;
	decDigitFilter: (s: string, init: string) -> string;

	// converts UTF32 into sequence of 16 bit chars according to https://www.unicode.org/faq/utf_bom.html
	utf32toUtf16(c : int) -> string;

	// Do a replacement "\n" to "\\n" and so on
	escapeStr(s : string) -> string;

	// Do a backwards replacement "\\n" to "\n" and so on
	unescapeStr(str : string) -> string;

	// Prefix all lines from a string with tab.
	strIndent(lines : string) -> string;

	// Prints the memory size in human-readable (like '45.56 Mb') format.
	memory2s(mem : double) -> string;

	// Smart toString: structures the output with indents
	toStringFormatted : (?) -> string;

	// Checks if all characters in the string are ASCII, i.e. their codes don't exceed 127
	isAsciiString(s : string) -> bool;

	/*
	Formats the input matrix (array of columns, which are arrays of rows) into the output like:

	| # | MPE# | ND Expression                | MPE Translation                        | ND Rationale | MPE Rationale                               |
	-------------------------------------------------------------------------------------------------------------------------------------------------
	| 1 | 5    |  ` ( ( ps /\ ch ) -> th ) `  |  ` ( ph -> ( ( ps /\ ch ) -> th ) ) `  | Given        | $e.                                         |
	-------------------------------------------------------------------------------------------------------------------------------------------------
	| 2 | 2    |  ` ( ch -> ps ) `            |  ` ( ph -> ( ch -> ps ) ) `            | Given        | $e.                                         |
	-------------------------------------------------------------------------------------------------------------------------------------------------
	| 3 | 1    |  ` ch `                      |  ` ( ph -> ch ) `                      | Given        | $e.                                         |
	-------------------------------------------------------------------------------------------------------------------------------------------------
	| 4 | 3    |  ` ps `                      |  ` ( ph -> ps ) `                      |  ` -> `E 2,3 |  ~ mpd , the MPE equivalent of ` -> `E, 1,2 |
	-------------------------------------------------------------------------------------------------------------------------------------------------
	| 5 | 4    |  ` ( ps /\ ch ) `            |  ` ( ph -> ( ps /\ ch ) ) `            |  ` /\ `I 4,3 |  ~ jca , the MPE equivalent of ` /\ `I, 3,1 |

	*/
	stringMatrix2s(m : [[string]], colHeaders : Maybe<[string]>, rowHeadres : Maybe<[string]>) -> string;

	/*
	Formats the input matrix (array of columns, which are arrays of rows) into the output like:

	 #   MPE#   ND Expression                  MPE Translation                          ND Rationale   MPE Rationale                               
	------------------------------------------------------------------------------------------------------------------------------------------------
	 1   5       ` ( ( ps /\ ch ) -> th ) `     ` ( ph -> ( ( ps /\ ch ) -> th ) ) `    Given          $e.                                         
	 2   2       ` ( ch -> ps ) `               ` ( ph -> ( ch -> ps ) ) `              Given          $e.                                         
	 3   1       ` ch `                         ` ( ph -> ch ) `                        Given          $e.                                         
	 4   3       ` ps `                         ` ( ph -> ps ) `                         ` -> `E 2,3    ~ mpd , the MPE equivalent of ` -> `E, 1,2 
	 5   4       ` ( ps /\ ch ) `               ` ( ph -> ( ps /\ ch ) ) `               ` /\ `I 4,3    ~ jca , the MPE equivalent of ` /\ `I, 3,1 

	*/
	stringTable2s(m : [[string]], colHeaders : Maybe<[string]>) -> string;
}

humpCase(s : string, initial : bool) -> string {
	pieces = strSplit(s, "_");
	t = strGlue(map(pieces, toCapitalization), "");
	if (initial) t
	else toLowerCase(getCharAt(t, 0)) + strRight(t, 1);
}

snakeCase(s : string) -> string {
	toLowerCase(getCharAt(s, 0)) +
	stringFoldChar(strRight(s, 1), "", \acc, char -> {
		acc + if (isUpperLetter(char)) "_" + toLowerCase(char) else char
	})
}

humanizeName(s : string) -> string {
	pieces0 = strSplit(s, "_");
	pieces1 = concatA(map(pieces0, \p -> splitLow2High(p, 0, "", [])));
	strGlue(map(pieces1, toCapitalization), " ");
}

// Splits a string from lUl to l Ul where l is lowercase, U is uppercase
splitLow2High(s : string, i : int, word : string, acc : [string]) -> [string] {
	n = strlen(s);
	if (i + 2 < n) {
		if (isLowerLetter(getCharAt(s, i))
			&& isUpperLetter(getCharAt(s, i + 1))
			// && isLowerLetter(getCharAt(s, i + 2))		// GradeUS should stay like that
		) {
			// OK, we can split
			acc2 = arrayPush(acc, word + getCharAt(s, i));
			splitLow2High(s, i + 1, "", acc2)
		} else if (word != "" && isUpperLetter(getCharAt(s, i)) && isLowerLetter(getCharAt(s, i + 1))) {
			acc2 = arrayPush(acc, word);
			splitLow2High(s, i, "", acc2);
		} else {
			splitLow2High(s, i + 1, word + getCharAt(s, i), acc)
		}
	} else {
		arrayPush(acc, word + strRight(s, i))
	}
}

plural2single(s : string) {
	if (endsWith(s, "ies")) {
		strLeft(s, strlen(s) - 3) + "y";
	} else if (endsWith(s, "sses")) { // processes vs cases
		strLeft(s, strlen(s) - 2);
	} else if (endsWith(s, "s")) {
		strLeft(s, strlen(s) - 1);
	} else {
		// don't change the name if it's not in plural form
		s
	}
}

capitalize(s : string) -> string {
	if (s == "") {
		s
	} else {
		toUpperCase(getCharAt(s, 0)) + strRight(s, 1);
	}
}

decapitalize(s : string) -> string {
	if (s == "") {
		s
	} else {
		toLowerCase(getCharAt(s, 0)) + strRight(s, 1);
	}
}

isValidIdentifier(name : string) -> bool {
	goodName = all(mapi(s2a(name), \i, cc -> {
		c = fromCharCode(cc);
		if (i == 0) (isLetter(c) || c == "_")
		else (isDigit(c) || isLetter(c) || c == "_");
	}));

	strlen(name) > 0 && goodName;
}

stringFoldChar(s, a, f) {
	foldRange(0, strlen(s) - 1, a, \a2, i->f(a2, getCharAt(s, i)));
}

stringFoldiChar(s, a, f) {
	foldRange(0, strlen(s) - 1, a, \a2, i->f(i, a2, getCharAt(s, i)));
}

hexDigitFilter(s, init) {
	stringFoldChar(s, init, \acc, ch -> {
		if (isHexDigit(ch)) acc + ch else acc;
	});
}

decDigitFilter(s, init) {
	stringFoldChar(s, init, \acc, ch -> {
		if (isDigit(ch)) acc + ch else acc;
	});
}

utf32toUtf16(c : int) -> string {
	if (c >= 0x10000 && c < 0x110000) {
		c1 = c - 0x10000; //Regarding UTF-16 spec.
		hiSurrogate = 0xD800 + bitUshr(c1, 10);
		loSurrogate = 0xDC00 + bitAnd(c1, 0x3FF);
		fromCharCode(hiSurrogate) + fromCharCode(loSurrogate)
	} else if (c < 0xD800 || (c >= 0xE000 && c < 0x10000)) {
		fromCharCode(c)
	} else {
		"";
	}
}

escapeStr(s : string) -> string {
	strsubsmart(toString(s), 1, -1);
}

unescapeStr(s : string) -> string {
	deserializeString("\"" + s + "\"").first;
}

strIndent(s : string) -> string {
	strGlue(map(strSplit(s, "\n"), \line -> "\t" + line), "\n");
}

memory2s(mem : double) -> string {
	if (mem < kilobyteUnit()) {
		i2s(round(mem)) + " B";
	} else if (mem < megabyteUnit()) {
		d2st(mem / kilobyteUnit(), 1) + " Kb";
	} else if (mem < gigabyteUnit()) {
		d2st(mem / megabyteUnit(), 1) + " Mb";
	} else {
		d2st(mem / gigabyteUnit(), 1) + " Gb";
	}
}

toStringFormatted(v : ?) -> string {
	toStringFormatted2(flow(v));
}

toStringFormatted2(v : flow) -> string {
	type = runtimeValueType(v);
	if (type == "void") {
		// Must not ever happen
		"{}";
	} else if (type == "function" || type == "undef") {
		type;
	} else if (type == "int") {
		i2s(cast(v : flow -> int));
	} else if (type == "double") {
		d2s(cast(v : flow -> double));
	} else if (type == "bool") {
		b2s(cast(v : flow -> bool));
	} else if (type == "string") {
		"\"" + escapeStr(cast(v : flow -> string)) + "\"";
	} else if (type == "array") {
		arr = map(cast(v : flow -> [flow]), toStringFormatted2);
		arr_sl = "[" + strGlue(arr, ", ") + "]";
		if (!strContains(arr_sl, "\n") && strlen(arr_sl) < 64) arr_sl else {
			"[\n" + strIndent(strGlue(arr, ",\n")) + "\n]";
		}

	} else if (type == "ref") {
		"ref " +  toStringFormatted2(^cast(v : flow -> ref flow));
	} else {
		name = extractStructName(v);
		if (name == "") {
			// give up with formatted output
			toString(v);
		} else {
			args = map(extractStructArguments(v), toStringFormatted2);
			struct_sl = name + "(" + strGlue(args, ", ") + ")";
			if (!strContains(struct_sl, "\n") && strlen(struct_sl) < 64) struct_sl else {
				name + "(\n" + strIndent(strGlue(args, ",\n")) + "\n)";
			}
		}
	}
}

isAsciiString(s : string) -> bool {
	forall(s2a(s), \code -> code < 128);
}

// Returns a pair: first is a longest line in the string (lines are separated by a '\n')
// and second is a number of lines in the string.
stringDims(s : string) -> Pair<int, int> {
	lines = strSplit(s, "\n");
	Pair(
		fold(tail(lines), strlen(lines[0]), \acc, line -> max(acc, strlen(line))),
		length(lines)
	);
}

// Makes a complete rectangular cell out of string `s` with a given diensions:
// the length of each line: `dims.first` and number of lines: `dims.second`
fillCell(s : string, dims : Pair<int, int>) -> [string] {
	s_lines = strSplit(s, "\n");
	map(enumFromTo(0, dims.second - 1), \i ->
		if (i < length(s_lines)) {
			line = " " + s_lines[i];
			if (strlen(line) < dims.first) {
				rpad(line, " ", dims.first);
			} else {
				substring(line, 0, dims.first);
			}
		} else {
			strRepeat(" ", dims.first);
		}
	);
}

stringMatrix2s(m : [[string]], colHeaders : Maybe<[string]>, rowHeadres : Maybe<[string]>) -> string {
	if (m == []) "" else {
		m1 = eitherMap(colHeaders, \hs -> mapi(m, \i, col -> concat([if (i < length(hs)) hs[i] else ""], col)), m);
		m2 = eitherMap(rowHeadres, \hs -> concat(if (isNone(colHeaders)) [hs] else [concat([""], hs)], m1), m1);
		matr = completeMatrix(m2, "");
		n_rows = length(matr[0]);
		dims = map(matr, \col -> map(col, \row -> stringDims(row)));
		cols = map(dims, \col -> fold(col, 0, \ac, row -> max(ac, row.first + 2)));
		rows = map(enumFromTo(0, n_rows - 1), \i -> fold(dims, 0, \ac, col -> max(ac, col[i].second)));
		cells = mapi(matr, \i, col -> mapi(col, \j, row -> fillCell(row, Pair(cols[i], rows[j]))));
		leng = fold(cols, 0, \acc, col -> acc + col + 1) + 1;
		strGlue(
			map(enumFromTo(0, n_rows - 1),
				\i -> strGlue(
					map(enumFromTo(0, rows[i] - 1),
						\j -> "|" + strGlue(mapi(cols, \k,__ -> cells[k][i][j]), "|") + "|"
					),
					"\n"
				)
			),
			"\n" + strRepeat("-", leng) + "\n"
		)
	}
}

stringTable2s(m : [[string]], colHeaders : Maybe<[string]>) -> string {
	if (m == []) "" else {
		m1 = eitherMap(colHeaders, \hs -> mapi(m, \i, col -> concat([if (i < length(hs)) hs[i] else ""], col)), m);
		matr = completeMatrix(m1, "");
		n_rows = length(matr[0]);
		dims = map(matr, \col -> map(col, \row -> stringDims(row)));
		cols = map(dims, \col -> fold(col, 0, \ac, row -> max(ac, row.first + 2)));
		rows = map(enumFromTo(0, n_rows - 1), \i -> fold(dims, 0, \ac, col -> max(ac, col[i].second)));
		cells = mapi(matr, \i, col -> mapi(col, \j, row -> fillCell(row, Pair(cols[i], rows[j]))));
		leng = fold(cols, 0, \acc, col -> acc + col + 1);
		foldi(
			map(enumFromTo(0, n_rows - 1),
				\i -> strGlue(
					map(enumFromTo(0, rows[i] - 1),
						\j -> strGlue(mapi(cols, \k,__ -> cells[k][i][j]), " ")
					),
					"\n"
				)
			),
			"",
			\i, acc, s -> {
				if (i != 1 || isNone(colHeaders)) acc + "\n" + s else  {
					acc + "\n" + strRepeat("-", leng) + "\n" + s
				}
			}
		)
	}
}
