import flowstructs;
// TODO: Remove after release.
import net/url_parameter;

export {

	native mbGetMediaDuration : (file : native, cb : (duration : int) -> void) -> void = Mediabunny.getMediaDuration;
	native mbGetMediaDurationFromBase64 : (base64str : string, cb : (duration : int) -> void) -> void = Mediabunny.mbGetMediaDurationFromBase64;
	mbConversion : (file : native, format : MBFormat, params : [MBStyle], cb : (outputFile : native) -> void, onError : (error : string) -> void) -> void;
	native mbGetVideoInfo : (file : native, cb : (width : int, height : int, bitrate : int) -> void) -> void = Mediabunny.getVideoInfo;
	native mbGetVideoInfoFromBase64 : (base64str : string, cb : (width : int, height : int, bitrate : int) -> void) -> void = Mediabunny.getVideoInfoFromBase64;
	native mbConcatMedia : (files : [native], outputName: string, cb : (outputFile : native) -> void, onError : (error : string) -> void) -> void = Mediabunny.concatMedia;

	MBStyle ::= MBSampleRate, MBCrop, MBTrim, MBAudioNumberOfChannels;
		// Audio. Def 16 kHz
		MBSampleRate(sampleRate : int);
		// Video. It is actually enabled if width and height != 0
		MBCrop(left: int, top: int, width: int, height: int);
		MBTrim(start : int, end : int);
		// Perform up/downmixing if this value differs from the number of channels in the input track. 1 for nono, 2 for stereo.
		MBAudioNumberOfChannels(n : int);
	// Output format for conversion
	MBFormat ::= MBAudioMP3, MBAudioWAV, MBVideoMP4, MBVideoWEBM;
		// For encoding: MP3 Slower but smaller, WAV faster but bigger.
		MBAudioMP3();
		MBAudioWAV();
		MBVideoMP4();
		MBVideoWEBM();

	isUrlParameterMediabunny() -> bool;
}

mbGetMediaDuration(file : native, cb : (duration : int) -> void) -> void {
	println("mbGetMediaDuration not supported");
	cb(0);
}

mbGetMediaDurationFromBase64(base64str : string, cb : (duration : int) -> void) -> void {
	println("mbGetMediaDurationFromBase64 not supported");
	cb(0);
}

mbGetVideoInfo(file : native, cb : (width : int, height : int, bitrate : int) -> void) -> void {
	println("mbGetVideoInfo not supported");
	cb(0, 0, 0);
}

mbGetVideoInfoFromBase64(base64str : string, cb : (width : int, height : int, bitrate : int) -> void) -> void {
	println("mbGetVideoInfoFromBase64 not supported");
	cb(0, 0, 0);
}

mbFormatToExt(format : MBFormat) -> string {
	switch (format : MBFormat) {
		MBAudioMP3(): "mp3";
		MBAudioWAV(): "wav";
		MBVideoMP4(): "mp4";
		MBVideoWEBM(): "webm";
	}
}

mbConversion(file : native, format : MBFormat, params : [MBStyle], cb : (audioData : native) -> void, onError : (error : string) -> void) -> void {
	sampleRate = extractStruct(params, MBSampleRate(16000));
	crop = extractStruct(params, MBCrop(0, 0, 0, 0));
	trim = extractStruct(params, MBTrim(0, 0));
	numberOfChannels = extractStruct(params, MBAudioNumberOfChannels(0));

	mbConversionNative(
		file,
		mbFormatToExt(format),
		[
			sampleRate,
			crop,
			trim,
			numberOfChannels,
		],
		cb,
		onError
	)
}

native mbConversionNative : (
	file : native,
	format : string,
	params : [MBStyle],
	cb : (outputFile : native) -> void,
	onError : (error : string) -> void
) -> void = Mediabunny.conversion;

mbConversionNative(
	file : native,
	format : string,
	params : [MBStyle],
	cb : (outputFile : native) -> void,
	onError : (error : string) -> void
) -> void {
	onError("not supported");
}

mbConcatMedia(
	files : [native],
	outputName : string,
	cb : (outputFile : native) -> void,
	onError : (error : string) -> void
) -> void {
	onError("not supported");
}

isUrlParameterMediabunny() -> bool {
	isUrlParameterTrue("mediabunny") || (isUrlParameterTrue("new") && !isUrlParameterFalse("mediabunny"))
}