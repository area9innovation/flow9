import form/paragraphtypes;
import form/line;
import form/baseline;
import text/bidi_text;

import text/blueprint;

export {
	makeAlphabetAwareTextField(txt : string, style : [CharacterStyle]) -> native;
	renderParagraph(p : [ParagraphElement], s : [ParagraphStyle], rtl : bool) -> Form;
	renderParagraphEx(p : [ParagraphElement], s : [ParagraphStyle], rtl : bool, renderedLinesInfoM : Maybe<DynamicBehaviour<[WigiRenderedLinesInfo]>>) -> Form;
	getLineIndent(paraIndent : double, isFirstLine : bool) -> double;
	makeZeroSpaceElement(style : [CharacterStyle]) -> Form;
	general2WrapElement(elem : GeneralWrapElement, style : [CharacterStyle], wordDecorator : (Form) -> Form) -> WrapElement;
	makeWrapElementsFromGeneralTextFragments(fragments : GeneralTextFragments) -> List<WrapElement>;
	generalEmptyLineInspectElement(id : int) -> GeneralInspectElement;
	keepFormTogether(form : Form) -> bool;

	calcParaLineAlignmentOffset(slack : double, lineIndent : double, rtl : bool, alignment : ParaLineAlignment) -> double;

	INF_METRICS = 100000.0;

	isUrlParameterEscUnescHTMLTrue() -> bool;
	// Helper to pass accessibility properties from material to forms
	// Used in material2form
	accessibilityParent : ref Maybe<flow> = ref None();

	// Will be populated when rendering wigi document with real height of all lines from top-level paragraphs
	WigiRenderedLinesInfoStyle(baselines : DynamicBehaviour<[DynamicBehaviour<[WigiRenderedLinesInfo]>]>);
		WigiRenderedLinesInfo(height : double, baseline : double);
		dummyWigiRenderedLinesInfo = WigiRenderedLinesInfo(0.0, 0.0);
}

// TODO:
// - When joining texts, wait with calculating the new metrics until all texts have been joined up
// - Unsubscribe when reflowing

/*
To render a paragraph, we first collect individual words which need to stay together on the same line.
That happens in expandGlueFragments. Each of the words is then categorized as a text or ghost element.
Ghost elements are rendered once, and then moved around when reflows happen. Text elements are
reconstructed on each reflow, because we combine them together to have as few sprites for text as
possible, and because rendering words in the same sprite improves the interword spacing.
*/

// Intermediately used typed as a union of ParagraphElement and WrapElement and ParaOneWord
ParaElement ::= ParagraphElement, WrapElement, ParaAtomic;

// After expanding elements to words
ParaAtomic ::= Form, ParaOneWord, TextElement, InteractiveParaAtomic;
	// A range of elements that need to be on the same line
	ParaOneWord(elements : [Form]);
	InteractiveParaAtomic(elem : ParaAtomic, interactivityId : int);

GhostForm ::= Form, Ghosted; // It is important that GhostForm is a super type of Ghosted
	Ghost(xc : DynamicBehaviour<double>, yc : DynamicBehaviour<double>, form : Form);

// For dynamic elements, we use a ghost to allow reuse of the physical forms
Ghosted ::= Empty, Ghost, CoordinateInspectElement, InspectGhost;
	CoordinateInspectElement(inspector : ParaElementInspector, form : Form);
	InspectGhost(
		inspector : ParaElementInspector,
		form : Form
	);

// Each word to be placed in the paragraph, including the metrics and as well as any ghost constructed
ParaWord(
	word : ParaAtomic,
	metrics : Transform<FormMetrics>,
	ghosted : Ghosted,
	form: GhostForm,
	interactivityIdM : Maybe<int>
);

ParaWordGroup(words : [ParaWord]);

ParaLine(words : [ParaWord], indent : double);
ParaLineAcc(lines : List<Form>, y : double, baseline : double, maxLineWidth : double);

OptimizedLineElement(f : GhostForm, metrics : Transform<FormMetrics>, interactivityIdM : Maybe<int>);
ParaLineInfo(optimizedLine : [OptimizedLineElement], lineAsc : double, lineHeight : double, lineWidth : double, lineIndent : double);
ParaLinesInfos(lines : [ParaLineInfo], maxLineWidth : double, aw : double);
ParaLineResult(form : Form, width : double, height : double, baseline : double);

makeWrapElementsFromGeneralTextFragments(fragments : GeneralTextFragments) -> List<WrapElement> {
	mapList(fragments.elements, \elem -> general2WrapElement(elem, fragments.style, idfn))
}

makeZeroSpaceElement(style : [CharacterStyle]) -> Form {
	spaceMetrics = getStaticFormSize(Text(" ", style));
	fixBaseline(spaceMetrics.baseline, Fixed(0.0, spaceMetrics.height))
}

generalEmptyLineInspectElement(id : int) -> GeneralInspectElement {
	GeneralInspectElement(
		ParaElementInspector(make(id), make(0.), make(0.), makeWH(), make(0.), make(0.), make(0), make(false)),
		EmptyLineElement()
	)
}

general2WrapElement(elem : GeneralWrapElement, style : [CharacterStyle], wordDecorator : (Form) -> Form) -> WrapElement {
	switch (elem) {
		GeneralText(txt) : {
			Text(txt, applyAlphabetStyles(detectAlphabet(txt), style)) |> wordDecorator;
		}
		GeneralDynamicText(txt) : {
			Text(txt, applyAlphabetStyles(detectAlphabet(txt), style)) |> wordDecorator;
		}
		GeneralSpace(txt, alBef, alAft) : {
			Space(Text(txt, apply2AlphabetsScaling(alBef, alAft, style)) |> wordDecorator);
		}
		NewLine() : NewLine();
		GeneralLinePart(f, m, e) : LinePart(Text(f, style) |> wordDecorator, Text(m, style), Text(e, style) |> wordDecorator);
		EmptyLineElement() : makeZeroSpaceElement(style);
		GeneralInspectElement(inspector, element) : InspectElement(
			inspector,
			cast(general2WrapElement(element, style, wordDecorator) : WrapElement -> InspectableElement)
		);
		NonTextElement() : Empty();
	}
}

makeAlphabetAwareTextField(txt : string, style : [CharacterStyle]) -> native {
	overridden = applyAlphabetStyles(detectAlphabet(txt), style);
	textfield = makeTextfield(getMappedFontFamily(overridden));
	rtl = extractStruct(style, SetRTL(getDefaultRtl())).rtl;
	setTextDirection(textfield, if (rtl) "rtl" else "ltr");
	dstyle = getDefinedTextStyle(overridden);
	setTextAndStyle(
		textfield,
		if (isUrlParameterEscUnescHTMLTrue() && cpp) {
			esc = extractStruct(style, EscapeHTML(true)).escape;
			if (esc) xmlEscapeText(txt) else txt;
		} else txt,
		dstyle.face.family,
		dstyle.fontSize,
		dstyle.face.weight,
		dstyle.face.slope,
		dstyle.fillColor,
		dstyle.fillOpacity,
		dstyle.letterSpacing,
		dstyle.backgroundColor,
		dstyle.backgroundOpacity
	);
	textfield
}

renderParagraph(
	p : [ParagraphElement],
	s : [ParagraphStyle],
	rtl : bool
) -> Form {
	renderParagraphEx(p, s, rtl, None());
}

extractParaAtomicForm = \word1 : ParaWord, pos : int -> {
	w : ParaAtomic = word1.word;
	f : Form = switch(w : ParaAtomic) {
		ParaOneWord(__): Empty();
		InspectElement(__, __): Empty();
		LinePart(first, inline, last): if (pos==0) first else if (pos==-1) last else inline;
		Space(s): s;
		default: cast(w : ParaAtomic -> Form);
	};
	f
};

getWordForm = \word1, pos -> {
	g = word1.ghosted;
	switch (g: Ghosted) {
		Empty(): extractParaAtomicForm(word1, pos);
		Ghost(xc, yc, f): f;
		InspectGhost(__, f): f;
		CoordinateInspectElement(__, f): f;
	};
};

defaultFontSizeStyle = FontSize(14.0);
emptyParaWordGroup = ParaWordGroup([]);
emptyParaWord = ParaWord(Empty(), const(zeroMetrics), Empty(), Empty(), None());
paraLinePartFRemake = isUrlParameterTrue("plpf");
paraLinePartFRemakeD = b2d(paraLinePartFRemake);

makeParaWord2(word2 : ParaWord, form2 : Form, pos : int) -> ParaWord {
	g = word2.ghosted;
	replaceWordGhosted = \ -> {
		switch (g : Ghosted) {
			Empty(): Empty();
			Ghost(xc, yc, __): Ghost(xc, yc, form2);
			InspectGhost(inspector, __): InspectGhost(inspector, form2);
			CoordinateInspectElement(inspector, __): CoordinateInspectElement(inspector, form2);
		}
	};

	ghosted = replaceWordGhosted();
	ghostedForm = {
		switch (g : Ghosted) {
			Empty(): extractParaAtomicForm(word2, pos);
			default: ghosted;
		};
	};
	ParaWord(word2.word, const(getStaticFormSize(form2)), ghosted, ghostedForm, word2.interactivityIdM)
};

paragraphElement2string(e : ParagraphElement) -> string {
	switch (e) {
		TextFragments(list): {
			fold(list |> list2array, "", \acc2, e2 -> {
				switch (e2) {
					WordWrapInteractive(e3, __): {
						switch (e3) {
							Text(text, __): acc2 + text;
							Space(__): acc2 + " ";
							Form(): acc2 + getFormText(e3);
							default: acc2;
						}
					}
					Text(text, __): acc2 + text;
					Space(__): acc2 + " ";
					default: acc2;
				}
			})
		}
		default: "";
	}
}

renderParagraphEx(
	p : [ParagraphElement],
	s : [ParagraphStyle],
	rtl : bool,
	renderedLinesInfoM : Maybe<DynamicBehaviour<[WigiRenderedLinesInfo]>>
) -> Form {

	trace = if (isUrlParameterTrue("trace_wigi_paragraph")) {
		rpName0 = if (p == []) ""
		else fold(p, "", \acc, e -> acc + paragraphElement2string(e));
		rpName = if (rpName0 == "") substring(toString(p), 1, 45) else rpName0;

		if (rpName == "") nop1
		else {
			\fn -> {
				text = fn();
				println("renderParagraphEx[" + rpName + "] " + text);
			}
		}
	} else {
		nop1
	}

	trace(\-> "Start");

	alignment : ParaLineAlignment = extractParaLineAlignment(s);
	genIndent = extractStruct(s, GeneralIndent(0.0)).indent;
	needIndent = genIndent != 0.0;

	interactiveStyles = extractStruct(s, ParagraphInteractiveStyleTree(makeTree())).styleTree;

	interlineSpacing = extractStruct(s, InterlineSpacing(0.0)).d;
	interLineHighlighting = containsStruct(s, InterlineHighlighting());
	fitLongWords = containsStruct(s, ParagraphFitLongWords());

	tightWidth = contains(s, TightWidth());

	fill = filtermap(s, \st -> switch (st) {
		Fill(__): Some(st);
		FillOpacity(__): Some(st);
		default: None();
	});

	topLineBaseline = contains(s, TopLineBaseline());

	indent = extractStruct(s, FirstLineIndent(0.0)).indent;
	linesCountB = extractStruct(s, ParagraphLinesCount(make(0))).count;

	isSingleLine = containsStruct(s, ParagraphSingleLine());
	isParagraphMarked = containsStruct(s, ParagraphMarked());
	paragraphBorder = extractStruct(s, ParagraphBorder(0.0, 0.0));

	// Expand elements into word-units
	glued : List<ParaAtomic> = expandGlueFragments(p, false, makeList(), makeList(), 0);
	// Construct our ParaWords
	gluedArr = list2array(glued);
	words : [ParaWord] = mapi(gluedArr, \i, word -> makeParaWord(
		word,
		i + 1 == length(gluedArr) || containsStruct(s, IgnoreLetterspacingOnReflow())
	));

	keepFormTogetherOrWithMark = \form1, i -> keepFormTogether(form1) || (isParagraphMarked && i <= 1);
	addWordToGroup = \group, word -> ParaWordGroup(arrayPush(group.words, word));

	awB = make(if (tightWidth) INF_METRICS else 0.0);
	update = make(0);
	linesB : DynamicBehaviour<ParaLinesInfos> = make(ParaLinesInfos([], 0.0, INF_METRICS));

	wordGroups = foldi(words, makeList(), \i, acc : List<ParaWordGroup>, word -> {
		wordForm = ParaWord(word with form =
			switch (word.ghosted : Ghosted) {
				Empty(): extractParaAtomicForm(word, 1);
				Ghost(xc, yc, fm): word.ghosted;
				InspectGhost(__, fm): word.ghosted;
				CoordinateInspectElement(__, __): word.ghosted;
			}
		);

		group = headList(acc, emptyParaWordGroup);
		lastSpace = switch(lastElement(group.words, emptyParaWord).word) {
			Space(__): true;
			default: false;
		};
		lastChr = strsubsmart(getWordText(lastElement(group.words, emptyParaWord)), -1, 0);
		lastChrIsMath = lastChr != "" && strContains("+-=×/", lastChr);

		if (lastChrIsMath || switch (word.word) {
			NewLine(): true;
			Space(__): false;
			LinePart(st, __, __): lastSpace;
			default: !keepFormTogetherOrWithMark(getWordForm(word, -1), i) || lastSpace;
		}) {
			Cons(
				addWordToGroup(
					if (lastChrIsMath) { makeParaWordGroupForMath(word, lastChr) } else { emptyParaWordGroup },
					wordForm
				),
				acc
			)
		} else {
			Cons(
				addWordToGroup(group, wordForm),
				tailList(acc)
			)
		}
	}) |> list2array;

	renderParaLinesFn = \lines, storyWidth -> {
	}
	paragraphAccessibilityParent = ^accessibilityParent;
	updateLines = \wi-> {
		// Ignore negative widths
		// It's the safest way to simulate single line, because reflowParaWords2 does a lot of useful stuff.
		w = if (isSingleLine) INF_METRICS else max(0.0, wi);

		infos = getParaLineInfos(
			alignment,
			wordGroups,
			w,
			indent,
			rtl,
			fitLongWords,
			extractStruct(s, defaultFontSizeStyle).size
		);
		maxWidth = fold(infos, 0.0, \acc, info -> max(info.lineWidth, acc));
		trace(\-> "updateLines("+toString(w)+") => lines="+toString(length(infos)) + ", maxWidth=" + toString(maxWidth));

		nextDistinct(linesCountB, length(infos));
		// We have to rerender even when lines are identical, at minimum to move things because of potential size changes
		// we pass "w" as availableWidth for wich it was rendered because Select not always sees that the linesB was changed otherwise
		next(linesB, ParaLinesInfos(infos, maxWidth, w));
	};
	// initialize linesB
	updateLines(INF_METRICS);

	renderedParagraph = Select(linesB, \lines -> {
		aw = getValue(awB);
		trace(\ -> "renderedParagraph: " + toString(aw) + ", lines: " + toString(length(lines.lines)) + ", maxWidth: " + toString(lines.maxLineWidth) + ", rendered at " + toString(lines.aw));
		prevAccessibilityParent = ^accessibilityParent;
		accessibilityParent := paragraphAccessibilityParent;
		rendered = renderParaLines(
			aw, lines, tightWidth, alignment, interlineSpacing,
			topLineBaseline, interactiveStyles, rtl, isParagraphMarked,
			interLineHighlighting,
			renderedLinesInfoM
		);

		accessibilityParent := prevAccessibilityParent;
		rendered
	});

	// If there is less or equal than upper limit of dynamic elements, we do not need to postpone updates
	dynamicWords = filter(words, \w -> !isFConst(w.metrics));
	ndynamic = length(dynamicWords);
	ndymamicUpper = extractStruct(s, DynamicBlockDelay(getParagraphDynamicBlockDelay())).n;

	contentGroup = Group(concat(
		[if (fill != []) Background(fill, renderedParagraph) else renderedParagraph],
		filtermap(words, \word -> {
			applyStyles = \form -> eitherMap(
				lookupTree(interactiveStyles, either(word.interactivityIdM, -1)),
				\wordStyles -> {
					applyListenersAndModifiers(wordStyles, form)
					|>(\f -> applyBlockHighlighting(wordStyles, f))
				},
				form
			);
			switch (word.ghosted : Ghosted) {
				Empty(): None();
				Ghost(x, y, f): Some(Translate(x, y, applyStyles(f)));
				InspectGhost(inspector, f): Some(Translate(inspector.x, inspector.y, applyStyles(f)));
				CoordinateInspectElement(__, __): None();
			}
		})
	));

	Constructor(
		Inspect(
			[AvailableWidth2(awB)],
			if (paragraphBorder.top > 0.0 || paragraphBorder.bottom > 0.0) {
				Border(0.0, paragraphBorder.top, 0.0, paragraphBorder.bottom, contentGroup);
			} else {
				contentGroup;
			}
		),
		\ -> {

			uns = concatA([
				[
					subscribe(awB, updateLines),
				],
				if (ndynamic == 0 || ndynamic == ndymamicUpper) [] else
				[
					subscribe2(update, \u -> {
						// When an update from a dynamic element is requested, we do it in the next frame
						if (u == 1) deferUntilNextFrameRendered(\ -> {
							next(update, 0);
							updateLines(getValue(awB))
						})
					})
				],
				mapi(dynamicWords, \i, w -> makeSubscribe2(w.metrics, \m -> {
					trace(\-> "dynamicWords["+i2s(i)+"] -> " + toString(m));
					if (i < ndymamicUpper) updateLines(getValue(awB)) else nextDistinct(update, 1)
				})())
			]);
			\ -> applyall(uns)
		}
	)
	|> (\f -> {
		if (needIndent) {
			if (rtl) Border(0.0, 0.0, genIndent, 0.0, f) else Border(genIndent, 0.0, 0.0, 0.0, f)
		} else {
			f
		}
	})
	|> (\f -> {
		if (isUrlParameterTrue("trace_wigi_paragraph")) {
			wB = make(0.0);
			Constructor(
				Inspect([Width(wB)], f),
				\-> subscribe(wB, \v -> {
					trace(\-> "Paragraph Width -> " + toString(v))
				})
			)
		} else {
			f
		}
	})
}

getParaLineInfo(line : ParaLine, alignment : ParaLineAlignment) -> ParaLineInfo {
	optimizedLine = getOptimizedLine(line.words, alignment);
	metrics = map(optimizedLine, \ole -> fgetValue(ole.metrics));
	lineAsc = fold(metrics, 0.0, \ac, m -> max(ac, m.baseline));
	ParaLineInfo(
		optimizedLine,
		lineAsc,
		fold(metrics, 0.0, \ac, m -> max(ac, m.height + lineAsc - m.baseline)),
		fold(metrics, line.indent, \ac, m -> ac + m.width),
		line.indent,
	)
}

getParaLineInfos(
	alignment : ParaLineAlignment,
	wordGroups : [ParaWordGroup],
	availableWidth : double,
	indent : double,
	rtl : bool,
	shrinkLongWords : bool,
	fontSize : double
) -> [ParaLineInfo] {
	textScale = if (shrinkLongWords && wordGroups != []) {
		maxWidth = foldi(wordGroups, 0.0, \i, maxWidth, wg -> {
			eitherMap(
				wordGroups2ParaLine([wg], getLineIndent(indent, i == 0), 1.0),
				\line -> {
					width = getParaLineInfo(line, alignment).lineWidth;
					if (maxWidth > width) maxWidth else width;
				},
				0.0
			)
		})
		if (maxWidth > availableWidth) {
			availableWidth / maxWidth
		} else 1.0
	} else 1.0;
	reflowResult = reflowParaWords(wordGroups, availableWidth, alignment, indent, rtl, fontSize, textScale);
	map(reflowResult, \line -> getParaLineInfo(line, alignment));
}

// Introduce a ParaOneWord that group the words together, so that we do not have to worry about joins
expandGlueFragments(
	elements : [ParaElement],
	glueNext : bool,
	running : List<ParaAtomic>,
	acc : List<ParaAtomic>,
	runLength : int,
) -> List<ParaAtomic> {

	flush = \ -> {
		if (runLength == 0) {
			acc;
		} else if (runLength == 1) {
			Cons(headList(running, Empty()), acc);
		} else {
			wds = foldList(running, makeList(), \acc2, ra : ParaAtomic -> {
				switch (ra : ParaAtomic) {
					ParaOneWord(wds): acc2;
					NewLine(): acc2;
					Space(f): Cons(f, acc2);
					LinePart(pr, i, po): Cons(i, acc2);
					InspectElement(inspector, e): {
						switch (e : InspectableElement) {
							Space(f): Cons(f, acc2);
							Text(t, s): Cons(e, acc2);
							default: Cons(cast(e : InspectableElement -> Form), acc2);
						}
					}
					InteractiveParaAtomic(ia, id) : {
						Cons(cast(ia : ParaAtomic -> Form), acc2);
					}
					default: {
						Cons(cast(ra : ParaAtomic -> Form), acc2);
					}
				}
			});
			Cons(ParaOneWord(list2array(reverseList(wds))), acc)
		};
	};

	n = length(elements);
	if (n == 0) {
		flush();
	} else {
		rest = tail(elements);
		e = elements[0];
		switch (e : ParaElement) {
			GlueFragments(): expandGlueFragments(rest, true, running, acc, runLength);
			TextFragments(parts): {
				p : [WrapElement] = list2array(parts);
				expandGlueFragments(concat(p, rest), glueNext, running, acc, runLength);
			}
			// TODO rewrite via switch subunion syntax when implemented.
			default: {
				en = switch (e : ParaElement) {
					WordWrapInteractive(wElem, id): {
						InteractiveParaAtomic(cast(wElem : WrapElement -> ParaAtomic), id)
					}
					default: cast(e : ParaElement -> ParaAtomic);
				}
				if (glueNext) {
					expandGlueFragments(rest, false, Cons(en, running), acc, runLength + 1);
				} else {
					expandGlueFragments(rest, false, Cons(en, makeList()), flush(), 1);
				}
			}
		}
	}
}

makeInteractiveParaWord(
	w : ParaAtomic,
	interactivityIdM : Maybe<int>,
	ignoreLetterSpacing : bool
) -> ParaWord {
	s2w = \s : Pair<Form, Transform<FormMetrics>> -> {
		if (!isGhostable(s.first)) {
			ParaWord(s.first, s.second, Empty(), Empty(), interactivityIdM);
		} else {
			x = make(0.0);
			y = make(0.0);
			ParaWord(Empty(), s.second, Ghost(x, y, s.first), Empty(), interactivityIdM);
		}
	}
	switch (w : ParaAtomic) {
		NewLine(): ParaWord(w, const(zeroMetrics), Empty(), Empty(), interactivityIdM);
		// We choose the middle part
		LinePart(f, p, e): {
			dynFormSizePair = getDynamicFormSize2(p, true);
			ParaWord(
				LinePart(f, p, e),
				dynFormSizePair.second,
				CoordinateInspectElement(
					ParaElementInspector(
						make(0),
						make(0.),
						make(0.),
						makeWH(),
						make(0.),
						make(0.),
						make(0),
						make(false)
					),
					dynFormSizePair.first,
				),
				Empty(),
				interactivityIdM
			);
		}
		Space(s): {
			dynFormSizePair = getJoinableTextMetrics(s, true, ignoreLetterSpacing);
			ParaWord(Space(dynFormSizePair.first), dynFormSizePair.second, Empty(), Empty(), interactivityIdM);
		}
		ParaOneWord(wd): {
			oc = optimizeCols(wd);
			line : Form = Line(oc);
			getDynamicFormSize(line) |> s2w;
		}
		InspectElement(inspector, e): {
			makeWord = \word, form -> ParaWord(
				word,
				getJoinableTextMetrics(form, false, ignoreLetterSpacing).second,
				CoordinateInspectElement(inspector, form),
				Empty(),
				interactivityIdM
			);
			switch (e : InspectableElement) {
				Text(t, s): {
					makeWord(e, e);
				}
				LinePart(f, m, l): {
					makeWord(LinePart(f, m, l), m);
				}
				Space(t): {
					makeWord(Space(t), t);
				}
				default: {
					s = getJoinableTextMetrics(
						cast(e : InspectableElement -> Form),
						false,
						ignoreLetterSpacing
					);
					ParaWord(Empty(), s.second, InspectGhost(inspector, s.first), Empty(), interactivityIdM);
				}
			}
		}
		InteractiveParaAtomic(word, id) : {
			makeInteractiveParaWord(word, Some(id), ignoreLetterSpacing);
		}
		default: {
			opt = optimizeForm(cast(w : ParaAtomic -> Form));
			getJoinableTextMetrics(opt, false, ignoreLetterSpacing) |> s2w;
		}
	}
}

getJoinableTextMetrics(
	form: Form,
	getExactTopPoint : bool,
	ignoreLetterSpacing : bool
) -> Pair<Form, Transform<FormMetrics>> {

	getDefault = \-> {
		formSize : Pair<Form, Behaviour<FormMetrics>> = getDynamicFormSize2(form, getExactTopPoint);
		Pair(formSize.first, cast(formSize.second : Behaviour<FormMetrics> -> Transform<FormMetrics>))
	};
	if (ignoreLetterSpacing) {
		getDefault()
	} else switch (form) {
		Text(text, st) : {
			letterSpacing = extractStruct(st, LetterSpacing(0.0)).spacing;
			staticMetrics = getStaticFormSizeCached2(form, getExactTopPoint);

			metrics : Pair<Form, Transform<FormMetrics>> = if (isSafariBrowser() && !isUrlParameterFalse("dynamic_text_metrics")) {
				textWidth = make(staticMetrics.width);
				Pair(
					Text(text, arrayPush(st, TextWidthInspector(textWidth))),
					fselect(textWidth, FLift(\tw -> FormMetrics(staticMetrics with
						width = tw + letterSpacing
					)))
				);
			} else {
				metrics : Behaviour<FormMetrics> = const(FormMetrics(staticMetrics with width = staticMetrics.width + letterSpacing));
				Pair(form, cast(metrics : Behaviour<FormMetrics> -> Transform<FormMetrics>));
			}

			metrics
		}
		default : getDefault()
	}
}

makeParaWord(w : ParaAtomic, ignoreLetterSpacing : bool) -> ParaWord {
	switch (w) {
		InteractiveParaAtomic(word, id): makeInteractiveParaWord(
			word,
			Some(id),
			ignoreLetterSpacing
		);
		default : makeInteractiveParaWord(
			w,
			None(),
			ignoreLetterSpacing
		);
	}
}

isGhostable(f : Form) -> bool {
	switch (f) {
		Text(t, s): false;
		default: {
			true;
		}
	}
}

// We indent the first line if paragraph's first-line indent is positive
// or all of the other lines if the indent is negative.
getLineIndent(paraIndent : double, isFirstLine : bool) -> double {
	if (paraIndent > 0.0 && isFirstLine || paraIndent < 0.0 && !isFirstLine) abs(paraIndent)
	else 0.0;
}

// Given a bunch of words, a constant amount of width for paragraph, a first-line indent, this does the line breaking
reflowParaWords(
	wordGroups : [ParaWordGroup],
	availableParaWidth : double,
	align : ParaLineAlignment,
	paraIndent : double,
	rtl : bool,
	fontSize : double,
	textScale : double,
) -> [ParaLine] {
	firstLineWidth = availableParaWidth - getLineIndent(paraIndent, true);
	reflowResult = reflowParaWords2(
		wordGroups,
		[],
		[],
		firstLineWidth,
		align,
		paraIndent,
		fontSize,
		textScale
	);

	if (rtl)
		zipWith(
			reflowResult,
			reflowTextToBiDi(map(reflowResult, \l -> l.words), isWordEmpty, getWordText, setWordText, idfn, rtl),
			\l, ws -> ParaLine(ws, l.indent),
		)
	else reflowResult;
}

wordGroups2ParaLine(currentLine : [ParaWordGroup], lineIndent : double, textScale : double) -> Maybe<ParaLine> {
	cwords = concatA(mapi(currentLine, \i, g -> g.words));
	cwordslasti = length(cwords)-1;
	if (cwords == []) None() else Some(ParaLine({
		cw = mapi(cwords, \cwordi, cword -> {
			switch(cword.word) {
				LinePart(f, p, e):
					makeParaWord2(cword, if (cwordi==0) f else if (cwordi < cwordslasti) p else e, if (cwordi < cwordslasti) cwordi else -1);
				default: cword;
			}
		});

		if (textScale == 1.0) cw else {
			scale = \f -> Scale(const(textScale), const(textScale), f);
			map(cw, \w -> {
				switch (w.word) {
					Empty(): w;  // Non-text
					default: {
						// Text
						wform = w.form;
						ParaWord(
							w.word,
							fselect(w.metrics, FLift(\fm -> FormMetrics(fm.width*textScale, fm.height*textScale, fm.baseline*textScale, fm.dHeight*textScale))),
							switch (w.ghosted : Ghosted) {
								Empty(): Empty();
								Ghost(x, y, f): Ghost(x, y, scale(f));
								InspectGhost(inspector, f): InspectGhost(inspector, scale(f));
								CoordinateInspectElement(i, f): CoordinateInspectElement(i, scale(f));
							},
							switch (wform) {
								Ghost(xc, yc, form): Ghost(xc, yc, scale(form));
								CoordinateInspectElement(inspector, form): CoordinateInspectElement(inspector, scale(form));
								InspectGhost(inspector, form): InspectGhost(inspector, scale(form));
								Form(): scale(wform);
							},
							w.interactivityIdM
						)
					}
				}
			})
		}},
		lineIndent
	))
}

// here availableWidth is an amount of width for current line
reflowParaWords2(
	wordGroups : [ParaWordGroup],
	currentLine : [ParaWordGroup],
	paraLines : [ParaLine],
	availableWidth : double,
	align : ParaLineAlignment,
	paraIndent : double,
	fontSize : double,
	textScale : double
) -> [ParaLine] {
	lineIndent = getLineIndent(paraIndent, paraLines==[]);

	getParalineLine : ([ParaWordGroup]) -> Maybe<ParaLine> = \currentLine2 -> {
		wordGroups2ParaLine(currentLine2, lineIndent, textScale)
	}

	addLine = \ -> {
		eitherMap(getParalineLine(currentLine), \line -> arrayPush(paraLines, line), paraLines)
	};

	detachWord = \w : ParaWord, detach : bool -> {
		switch (w.ghosted) {
			CoordinateInspectElement(inspector, __): nextDistinct(inspector.detached, detach);
			default: {
				switch (w.form) {
					CoordinateInspectElement(inspector, __): nextDistinct(inspector.detached, detach);
					default: {}
				}
			}
		}
	};

	if (wordGroups == []) {
		addLine()
	} else {
		group = wordGroups[0];
		word = group.words[0];
		isSpc = switch (word.word : ParaAtomic) {
			Space(__): true;
			NewLine(): true;
			default: false;
		};
		restGroups = tail(wordGroups);
		detachWord(word, isSpc);
		isNewLine = switch (word.word : ParaAtomic) {
			NewLine(): true;
			default: {
				// we have to measure current line with additional of the next word group
				// and compare it with availableWidth to deside if we should make new line
				nextWidth = eitherMap(
					getParalineLine(arrayPush(currentLine, group)),
					\line -> getParaLineInfo(line, align).lineWidth,
					0.0
				);
				nextWidth > availableWidth && (isSpc || currentLine != [])
			}
		};
		if (isNewLine) {
			rest = if (isSpc) {
				restGroup = ParaWordGroup(tail(group.words));
				if(restGroup.words == []) restGroups else concat([restGroup], restGroups)
			} else wordGroups;

			reflowParaWords2(
				rest,
				[],
				addLine(),
				availableWidth,
				align,
				paraIndent,
				fontSize,
				textScale
			)
		} else reflowParaWords2(
			restGroups,
			arrayPush(currentLine, group),
			paraLines,
			availableWidth,
			align,
			paraIndent,
			fontSize,
			textScale
		);
	}
}

// This function gets the form and decides, should the next form kept together in the same line or should it be placed on the next line
keepFormTogether(form : Form) -> bool {
	switch (form) {
		Empty(): true;
		Text(t, __): t != " " && t != "­";  // Space or soft hyphen.
		Alpha(__, f): keepFormTogether(f);
		Size2(__, f): keepFormTogether(f);
		Access(__, f): keepFormTogether(f);
		Rotate(__, f): keepFormTogether(f);
		Cursor(__, f): keepFormTogether(f);
		Visible(__, f): keepFormTogether(f);
		Inspect(__, f): keepFormTogether(f);
		Baseline(__, f): keepFormTogether(f);
		Scale(__, __, f): keepFormTogether(f);
		Mask2(f, __, __): keepFormTogether(f);
		SetPending(__, f): keepFormTogether(f);
		Available2(__, f): keepFormTogether(f);
		Filter2(__, f, __): keepFormTogether(f);
		Interactive(__, f): keepFormTogether(f);
		Constructor(f, __): keepFormTogether(f);
		Create2(current, fn): keepFormTogether(if (^current != Empty()) ^current else fn());
		Translate(__, __, f): keepFormTogether(f);
		Mutable2(f, __): keepFormTogether(getValue(f));
		Border(__, __, __, __, f): keepFormTogether(f);
		Crop2(__, __, __, __, f, __): keepFormTogether(f);
		Group(fs): any(map(fs, \f -> keepFormTogether(f)));
		Switch(i, fs): keepFormTogether(if (getValue(i) < length(fs)) fs[getValue(i)] else { println("STRANGE CASE"); Empty(); });
		Grid(__): false; // Unlikely to be a part of a word. But maybe should go recursive.
		Picture(__, __): false;
		Graphics(__, __): false;
		Video(__, __, __, __): false;
		TextInput(__, __, __): false;
		Camera(__, __, __, __): false;
		RealHTML2(__, __, __): false;
		ControlFocus(__, f): keepFormTogether(f);
		FullWindow(__, f): keepFormTogether(f);
		FullScreen(__, f): keepFormTogether(f);
		NativeForm(__, __, __, __): false;
		DynamicGroup2(__, __, __, __) : false; // Placeholder
	};
}

// renders lines and returns resulting forms along with their tight width at the rendering time
renderParaLines(
	availableWidth : double,
	lines : ParaLinesInfos,
	tightWidth : bool,
	alignment: ParaLineAlignment,
	interlineSpacing : double,
	topLineBaseline : bool,
	styleTree : Tree<int, [ParaElementInteractiveStyle]>,
	rtl : bool,
	isMarked : bool,
	interLineHighlighting : bool,
	renderedLinesInfoM : Maybe<DynamicBehaviour<[WigiRenderedLinesInfo]>>
) -> Form {
	lasti = length(lines.lines) - 1;
	a : ParaLineAcc = foldi(lines.lines, ParaLineAcc(EmptyList(), 0.0, 0.0, 0.0), \i : int, acc : ParaLineAcc, lineInfo : ParaLineInfo -> {
		// TODO: IF the line ends with NewLine (which we do not track here), we should consider it a last line and not justify
		lastLine = i == lasti;
		// On the last line, we do not justify.
		// Also if the line is single with TightWidth, any alignment is equal to StartAlign
		lineAlignment =
			if (alignment == Justify() && lastLine) {
				StartAlign()
			} else {
				alignment;
			}
		f = RenderLine(
			acc.y, lineInfo,
			availableWidth, lineAlignment,
			i, styleTree, rtl, isMarked,
			if (interLineHighlighting) {
				if (i == 0) 0. else - interlineSpacing / 2.0
			} else 0.0,
			if (interLineHighlighting){
				if (lastLine || i == 0) interlineSpacing / 2.0 else interlineSpacing
			} else 0.0
		);
		ParaLineAcc(
			Cons(Size2(const(zeroWH), f.form), acc.lines),
			acc.y + f.height + if (lastLine) 0. else interlineSpacing,
			if (i == 0 || !topLineBaseline) f.baseline else acc.baseline,
			if (acc.maxLineWidth < f.width) f.width else acc.maxLineWidth
		);
	});

	maybeApply(
		renderedLinesInfoM,
		\renderedLinesInfo -> {
			nextDistinct(renderedLinesInfo, map(lines.lines, \info : ParaLineInfo -> WigiRenderedLinesInfo(info.lineHeight, info.lineAsc)));
		}
	);

	Baseline(const(a.baseline), Size2(const(WidthHeight(if (tightWidth) a.maxLineWidth else max(availableWidth, lines.maxLineWidth), a.y)),
		Group(list2array(a.lines))
	))
}

getOptimizedLine(words : [ParaWord], alignment : ParaLineAlignment) -> [OptimizedLineElement]{
	if (isBiDiEnabled() || alignment == Justify()) {
		map(words, \w -> OptimizedLineElement(w.form, w.metrics, w.interactivityIdM));
	} else {
		optimizeLine(words);
	};
}

calcParaLineAlignmentOffset(slack : double, lineIndent : double, rtl : bool, alignment : ParaLineAlignment) -> double {
	startOffset = if (rtl) max(slack, 0.) else 0.;
	endOffset = if (rtl) 0. else max(0., slack);
	switch (alignment : ParaLineAlignment) {
		LeftAlign(): if (rtl) endOffset else startOffset;
		RightAlign(): if (rtl) startOffset else endOffset;
		CenterAlign(): max(0.0, slack / 2.0);
		StartAlign(): startOffset;
		EndAlign(): endOffset;
		Justify(): 0.0;
	} + (if (rtl) 0. else lineIndent);
}

// Aligns all elements to the baseline, as well as calculates the height and the baseline
// Send out the result, width, height
RenderLine(
	y : double,
	info : ParaLineInfo,
	width : double,
	alignment : ParaLineAlignment,
	lineNumber : int,
	interactiveStyles : Tree<int, [ParaElementInteractiveStyle]>,
	rtl : bool,
	isMarked : bool,
	highLightOffset : double,
	interlineSpacing : double,
) -> ParaLineResult {
	remaining = width - info.lineWidth;
	alignmentOffset = ref calcParaLineAlignmentOffset(remaining, info.lineIndent, rtl, alignment);

	// Inter-word spacing for justification
	interWord = if (alignment == Justify() && length(info.optimizedLine) > 1) {
		nwords = length(info.optimizedLine);
		min(10.0, remaining / i2d(nwords - 1));
	} else 0.0;

	justifyExtraWidth = ref 0.0;

	// The width and the individual forms
	lo : [Form] = filtermapi(info.optimizedLine, \i : int, elem : OptimizedLineElement -> {
		f = elem.f;
		m = fgetValue(elem.metrics);
		intStyleContains = \st : ParaElementInteractiveStyle -> eitherMap(
			elem.interactivityIdM,
			\id -> containsStruct(
				lookupTreeDef(interactiveStyles, id, []),
				st
			),
			false
		);

		isSuperscript = intStyleContains(ParaElementSuperscript());
		isSubscript = intStyleContains(ParaElementSubscript());

		dy = if (isSuperscript) {
			if (i == 0) -1.0 else info.lineAsc - m.baseline - fgetValue(info.optimizedLine[i - 1].metrics).height * 0.25
		} else info.lineAsc - m.baseline / (if (isSubscript) 2.0 else 1.0);
		applyStylesAndOffset = \fm : Form -> eitherMap(
			elem.interactivityIdM,
			\id -> applyIntStylesAndHighlighting(
				fm,
				lookupTreeDef(interactiveStyles, id, []),
				^alignmentOffset,
				y,
				dy,
				m.width,
				info.lineHeight,
				interWord,
				highLightOffset,
				interlineSpacing
			),
			Translate(const(^alignmentOffset), const(y + dy), fm)
		);

		justifyOffset = if (isMarked && i == 0 && lineNumber == 0) 0.0 else interWord;

		r = switch (f : GhostForm) {
			Empty(): None();
			Ghost(xc, yc, fm): {
				nextDistinct(xc, ^alignmentOffset);
				nextDistinct(yc, y + dy);
				Some(applyStylesAndOffset(Empty()));
			}
			InspectGhost(inspector, fm): {
				nextDistinct(inspector.x, ^alignmentOffset);
				nextDistinct(inspector.y, y + dy);
				nextDistinct(inspector.size, WidthHeight(m.width, m.height));
				nextDistinct(inspector.lineHeight, info.lineHeight);
				nextDistinct(inspector.lineNumber, lineNumber);
				Some(applyStylesAndOffset(Empty()));
			}
			CoordinateInspectElement(inspector, fm): {
				fo = applyStylesAndOffset(fm);
				nextDistinct(inspector.x, ^alignmentOffset);
				nextDistinct(inspector.y, y + dy);
				nextDistinct(inspector.size, WidthHeight(m.width, m.height));
				nextDistinct(inspector.lineHeight, info.lineHeight);
				nextDistinct(inspector.lineNumber, lineNumber);
				Some(fo);
			}
			default: Some(applyStylesAndOffset(cast(f : GhostForm -> Form)))
		}

		if (m.width != 0.0 && !intStyleContains(IgnoreMetrics())) {
			justifyExtraWidth := ^justifyExtraWidth + justifyOffset;
			alignmentOffset := ^alignmentOffset + m.width + justifyOffset;
		}
		r
	});
	ParaLineResult(
		Group(lo),
		info.lineWidth + ^justifyExtraWidth,
		info.lineHeight,
		y + info.lineAsc
	);
}

applyIntStylesAndHighlighting(
	form : Form,
	styles : [ParaElementInteractiveStyle],
	xOffset : double,
	yOffset : double,
	baselineShift : double,
	width : double,
	height : double,
	interWord : double,
	highLightOffset : double,
	interlineSpacing : double,
) -> Form {
	getStyleForBackgroundFromCharStyle = \s -> eitherMap(
		tryExtractStruct(s, BackgroundFill(white)),
		\backFill -> [
			Fill(backFill.color),
			FillOpacity(extractStruct(s, BackgroundFillOpacity(1.0)).opacity)
		],
		[]
	);

	makeBackRect = \defStyle, dynStyle -> Rectangle(
		width + interWord,
		height + interlineSpacing + 0.1,
		replaceStructMany(
			getStyleForBackgroundFromCharStyle(defStyle),
			getStyleForBackgroundFromCharStyle(dynStyle)
		)
	);

	dynamicHighlightStyleBM = tryExtractStruct(styles, DynamicHighlightStyle(make([]), false));

	textAndBackPair = switch(form) {
		Text(txt, txtStyle) : {

			makeTxt = \dynStyle -> Text(
				txt,
				removeAllStructsMany(
					replaceStructMany(txtStyle, dynStyle),
					[BackgroundFill(0), BackgroundFillOpacity(0.0)]
				)
			);

			// We draw custom highlighting to fix gaps for cases of justifying alignment
			// And to have more straight and pretty highlighting.
			eitherMap(
				dynamicHighlightStyleBM,
				\dynHlStyle -> Pair(
					Select(dynHlStyle.styleB, \chStyle -> makeTxt(chStyle)),
					Select(dynHlStyle.styleB, \chStyle -> makeBackRect(txtStyle, chStyle))
				),
				Pair(makeTxt([]), makeBackRect(txtStyle, []))
			)
		}
		default : Pair(
			form,
			eitherMap(
				dynamicHighlightStyleBM,
				\dynHlStyle -> Select(dynHlStyle.styleB, \chStyle -> makeBackRect([], chStyle)),
				Empty()
			)
		);
	}

	modifiedForm = applyListenersAndModifiers(styles, textAndBackPair.first);

	Group([
		Translate(const(xOffset - interWord / 2.), const(yOffset + highLightOffset), textAndBackPair.second),
		Translate(const(xOffset), const(yOffset + baselineShift), modifiedForm),
	]);
}

applyListenersAndModifiers(styles : [ParaElementInteractiveStyle], form : Form) -> Form {
	if (form == Empty()) form else {
		formModifiersM = tryExtractStruct(styles, FormModifiers([]));
		modifiedForm = eitherMap(
			formModifiersM,
			\modifiers -> fold(modifiers.fns, form, \acc, fn -> fn(acc)),
			form
		);

		eventListenersM = tryExtractStruct(styles, EventListeners([]));
		eitherMap(
			eventListenersM,
			\el -> Interactive(el.listeners, modifiedForm),
			modifiedForm
		);
	}
}

applyBlockHighlighting(styles : [ParaElementInteractiveStyle], form : Form) -> Form {
	eitherMap(tryExtractStruct(styles, DynamicHighlightStyle(make([]), false)),
	\dynamicHlStyle -> {
		if (dynamicHlStyle.extraHighlight) {
			getStyleForRectFromCharStyle = \s -> eitherMap(
				tryExtractStruct(s, BackgroundFill(white)),
				\backFill -> [
					Stroke(backFill.color),
					StrokeOpacity(extractStruct(s, BackgroundFillOpacity(1.0)).opacity),
					StrokeWidth(3.0),
				],
				[]
			);

			makeRect = \dynStyle, wh : WidthHeight -> Rectangle(
				wh.width,
				wh.height,
				getStyleForRectFromCharStyle(dynStyle)
			);

			whB = makeWH();
			Group([
				Inspect([ISize(whB)], form),
				Select2(dynamicHlStyle.styleB, whB, makeRect),
			])
		} else form
	},
	form
	)
}

// Joins texts together to a single text element, along with the new metrics
optimizeLine(words : [ParaWord]) -> [OptimizedLineElement] {
	fold(words, makeList(), \acc : List<OptimizedLineElement>, word : ParaWord -> {
		f = word.form;
		metrics = word.metrics;
		intIdM = word.interactivityIdM;
		switch(acc){
			EmptyList(): Cons(OptimizedLineElement(f, metrics, intIdM), acc);
			Cons(p, tail_): {
				switch (p.f : GhostForm) {
					Text(t1, s1): {
						switch (f : GhostForm) {
							Text(t2, s2): {
								join = joinText(t1, s1, t2, s2);
								if (length(join) == 1 && intIdM == p.interactivityIdM) {
									t : Form = join[0];
									// TODO: Do not do this until at the end of the joining fest
									m = getStaticFormSize(t);

									joinedWordMetrics = FormMetrics(m with
										width = m.width + extractStruct(s2, LetterSpacing(0.0)).spacing
									);

									// Replace the last element with the newly joined
									Cons(
										OptimizedLineElement(t, const(joinedWordMetrics), intIdM),
										tail_
									);
								} else Cons(OptimizedLineElement(f, metrics, intIdM), acc);
							}
							default: {
								Cons(OptimizedLineElement(f, metrics, intIdM), acc);
							}
						}
					}
					default: Cons(OptimizedLineElement(f, metrics, intIdM), acc);
				}
			}
		}
	}) |> list2array
}

isWordEmpty(w: ParaWord) -> bool {
	switch(w.word) {
		Text(t, __): t == "";
		default: false;
	}
}

getWordText(w: ParaWord) -> string {
	switch(w.word) {
		Text(t, __): t;
		Empty(): switch (w.form) {
			InspectGhost(__, form): getFormText(form);
			Ghost(__, __, form): getFormText(form);
			default: "";
		};
		default: "";
	}
}

setWordText(w : ParaWord, t : string) -> ParaWord {
	switch(w.word) {
		Text(__, s): ParaWord(
			Text(t, s), w.metrics, w.ghosted,
			switch(w.form) {
				CoordinateInspectElement(inspector, form): CoordinateInspectElement(
					inspector,
					Text(t, getFormTextStyle(form))
				);
				Text(__, fs): Text(t, fs);
				default: w.form;
			},
			w.interactivityIdM
		);
		default: w;
	};
}

makeParaWordGroupForMath(w : ParaWord, s : string) -> ParaWordGroup {
	makeParaWordGroup = \word -> ParaWordGroup([word]);
	switch(w.word) {
		Text(__, st):
			ParaWord(
				LinePart(Text(s, st), Empty(), Empty()),
				w.metrics,
				w.ghosted,
				switch(w.form) {
					CoordinateInspectElement(inspector, form): CoordinateInspectElement(
						inspector,
						Text(s, getFormTextStyle(form))
					);
					Text(__, fs): Text(s, fs);
					default: w.form;
				},
				None()
			) |> makeParaWordGroup;
		LinePart(sf, mf, ef): {
			swt = \f, t -> cast(setWordText(ParaWord(f, w.metrics, w.ghosted, w.form, w.interactivityIdM), t).word : ParaAtomic-> Form);
			ParaWord(w with word=LinePart(swt(sf, s), swt(mf, ""), swt(ef, ""))) |> makeParaWordGroup;
		};
		default: emptyParaWordGroup;
	};
}

// Not with others because referenced from flow9 repo.
isUrlParameterEscUnescHTMLTrue() -> bool {
	isUrlParameterTrue("753");
}
