import form/paragraphtypes;
import form/baseline;
import text/bidi_text;
import form/gui;

export {
	makeAlphabetAwareTextField(txt : string, style : [CharacterStyle]) -> native;
	renderParagraph(p : [ParagraphElement], s : [ParagraphStyle], rtl : bool, widthManager : ParagraphWidthManager) -> Form;
	renderParagraphEx(
		p : [ParagraphElementWithInfo],
		s : [ParagraphStyle],
		rtl : bool,
		widthManager : ParagraphWidthManager,
		renderedLinesInfoM : Maybe<DynamicBehaviour<[RenderedLinesInfo]>>,
		fontWrapper : ([CharacterStyle]) -> [CharacterStyle],
		renderInfo : WigiRenderParameters
	) -> Form;
	getLineIndent(paraIndent : double, isFirstLine : bool) -> double;
	makeZeroSpaceElement(style : [CharacterStyle]) -> Form;
	general2WrapElement(elem : GeneralWrapElement, style : [CharacterStyle], wordDecorator : (Form) -> Form) -> NonInteractiveWrapElement;
	makeWrapElementsFromGeneralTextFragments(fragments : GeneralTextFragments) -> List<NonInteractiveWrapElement>;
	generalEmptyLineInspectElement(id : int) -> GeneralInspectElement;
	keepFormTogether(form : Form) -> bool;

	StoryWidthManager(
		paragraphManagers : [ParagraphWidthManager],
		getParagraphManagerAt : (int) -> ParagraphWidthManager,
		width : Behaviour<double>,
		infoOnly : bool, /* do not control width of paragraphs, just gather their widths */
		constructor : () -> () -> void,
	);
	ParagraphWidthManager(
		storyWidth : Behaviour<double>,
		width : DynamicBehaviour<double>,
		infoOnly : bool
	);

	makeStoryWidthManager(paragraphs : int, infoOnly : bool) -> StoryWidthManager;
	dummyParagraphWidthManager = ParagraphWidthManager(const(0.0), make(0.0), true);
	dummyStoryWidthManager = StoryWidthManager([], \__ -> dummyParagraphWidthManager, zero, true, \ -> nop);

	calcParaLineAlignmentOffset(slack : double, lineIndent : double, rtl : bool, alignment : ParaLineAlignment) -> double;

	INF_METRICS = 100000.0;

	isUrlParameterEscUnescHTMLTrue() -> bool;
	// Helper to pass accessibility properties from material to forms
	// Used in material2form
	accessibilityParent : ref Maybe<flow> = ref None();

	// Will be populated when rendering  document with real height of all lines from top-level paragraphs
	RenderedLinesInfoStyle(baselines : DynamicBehaviour<[DynamicBehaviour<[RenderedLinesInfo]>]>);
		RenderedLinesInfo(height : double, baseline : double, elementsID : [int], y : double);
		dummyRenderedLinesInfo = RenderedLinesInfo(0.0, 0.0, [], 0.0);

	nonBreakableSpace : string = fromCharCode(nonBreakableSpaceCode);
	wordJoiner : string = fromCharCode(wordJoinerCode);
	zeroWidthJoiner : string = fromCharCode(zeroWidthJoinerCode);
	isWordJoiner(char : string) -> bool;

	makeSkipOrderCheck(st : [CharacterStyle]) -> [CharacterStyle];

	WigiTraceApi(
		trace : (() -> string) -> void,
		traceAndNest : (() -> string) -> void,
		traceAndUnnest : (() -> string) -> void,
		unnestAndTrace : (() -> string) -> void,
		nest : () -> void,
		unnest : () -> void,
		makeRenderingId : () -> string,
		traceId : string
	);

	makeWigiTraceIdFn(words : (() -> [?]), word2string : (?) -> string) -> (() -> string);
	makeWigiTraceGeneric(functionName : string, idFn : () -> string, condition : bool) -> WigiTraceApi;

	newJustifyEnabled = js && !isUrlParameterFalse("js_justify");
	// Allow to customize how render should behave
	WigiRenderParameters(inline : bool);
		defaultWigiRenderParameters = WigiRenderParameters(false);

	wigiTextPartsLimit = 10000;

	ParagraphElementWithInfo(
		element: ParagraphElement,
		isFillerFn : () -> bool
	);

	ParaElementWithInfo(
		element: ParaElement,
		isFillerFn : () -> bool
	);

	roundUIMetricsValue = \v -> roundTo(v, 0.01);
}

// TODO:
// - When joining texts, wait with calculating the new metrics until all texts have been joined up
// - Unsubscribe when reflowing

/*
To render a paragraph, we first collect individual words which need to stay together on the same line.
That happens in expandGlueFragments. Each of the words is then categorized as a text or ghost element.
Ghost elements are rendered once, and then moved around when reflows happen. Text elements are
reconstructed on each reflow, because we combine them together to have as few sprites for text as
possible, and because rendering words in the same sprite improves the interword spacing.
*/

// Intermediately used typed as a union of ParagraphElement and WrapElement and ParaWordGlued
ParaElement ::= ParagraphElement, WrapElement, ParaAtomic;

// After expanding elements to words
ParaAtomic ::= Form, ParaWordGlued, TextElement, InteractiveParaAtomic;
	// The word should be kept with previous on the same line
	ParaWordGlued(word : ParaAtomic);
	InteractiveParaAtomic(elem : ParaAtomic, interactivityId : int);

GhostForm ::= Form, Ghosted; // It is important that GhostForm is a super type of Ghosted
	Ghost(xc : DynamicBehaviour<double>, yc : DynamicBehaviour<double>, form : Form);

// For dynamic elements, we use a ghost to allow reuse of the physical forms
Ghosted ::= Empty, Ghost, CoordinateInspectElement, InspectGhost;
	CoordinateInspectElement(inspector : ParaElementInspector, form : Form);
	InspectGhost(
		inspector : ParaElementInspector,
		form : Form
	);

// Each word to be placed in the paragraph, including the metrics and as well as any ghost constructed
ParaWord(
	word : ParaAtomic,
	metrics : Transform<FormMetrics>,
	ghosted : Ghosted,
	form : GhostForm,
	interactivityIdM : Maybe<int>,
	nextWidgetId : DynamicBehaviour<Maybe<int>>,
	glued : bool,
	isFillerFn : () -> bool
);

ParaWordWidth(rigidWidth : double, softWidth : double, finalRigidWidthDelta : double, finalSoftWidthDelta : double);
ParaWordGroup(words : [ParaWord], width : ref ParaWordWidth);

ParaLine(words : [ParaWord], indent : double);
ParaLineAcc(lines : List<Form>, y : double, baseline : double, maxLineWidth : double);

OptimizedLineElement(
	f : GhostForm,
	metrics : Transform<FormMetrics>,
	interactivityIdM : Maybe<int>,
	nextWidgetId : DynamicBehaviour<Maybe<int>>,
	isFillerFn : () -> bool
);
ParaLineInfo(
	optimizedLine : [OptimizedLineElement],
	lineAsc : double,
	lineHeight : double,
	lineWidth : double,
	lineIndent : double,
	containsDynamicElement : bool,
	y : double
);
ParaLinesInfoAcc(lines : List<ParaLineInfo>, y : double);
ParaLinesInfos(lines : [ParaLineInfo], maxLineWidth : double);
ParaLineResult(form : Form, width : double, height : double, baseline : double);

makeWrapElementsFromGeneralTextFragments(fragments : GeneralTextFragments) -> List<NonInteractiveWrapElement> {
	mapList(fragments.elements, \elem -> general2WrapElement(elem, fragments.style, idfn))
}

makeZeroSpaceElement(style : [CharacterStyle]) -> Form {
	spaceMetrics = getStaticFormSize(Text(" ", style));
	fixBaseline(spaceMetrics.baseline, Fixed(0.0, spaceMetrics.height))
}

generalEmptyLineInspectElement(id : int) -> GeneralInspectElement {
	GeneralInspectElement(
		ParaElementInspector(make(id), make(0.), make(0.), makeWH(), make(0.), make(0.), make(0), make(false), make(0.), make(0.), make(WordPositionInLineFirst())),
		EmptyLineElement()
	)
}

general2WrapElement(elem : GeneralWrapElement, style : [CharacterStyle], wordDecorator : (Form) -> Form) -> NonInteractiveWrapElement {
	generateText = \txt, st ->
		Text(txt, st |> makeSkipOrderCheck)
		|> (\t -> if (isSafariBrowser()) {
			// fix for https://trello.com/c/G6ZiBfBc/22452-disappearing-questions-in-mcq-probes
			Inspect([Width(make(0.))], t)
		} else t )
		|> wordDecorator;
	switch (elem) {
		GeneralText(txt) : generateText(txt, applyAlphabetStyles(detectAlphabet(txt), style));
		GeneralDynamicText(txt) : generateText(txt, applyAlphabetStyles(detectAlphabet(txt), style));
		GeneralSpace(txt, alBef, alAft) : Space(generateText(txt, apply2AlphabetsScaling(alBef, alAft, style)));
		NewLine() : elem;
		GeneralLinePart(f, m, e, allowBreakAfter) : {
			st =  makeSkipOrderCheck(style);
			LinePart(Text(f, st) |> wordDecorator, Text(m, st) |> wordDecorator, Text(e, st) |> wordDecorator, allowBreakAfter);
		}
		EmptyLineElement() : makeZeroSpaceElement(style |> makeSkipOrderCheck);
		GeneralInspectElement(inspector, element) : {
			e1 = general2WrapElement(element, style, wordDecorator);
			switch (e1) {
				InspectableElement(): InspectElement(inspector, e1);
				GlueFragments(): Empty();
				InspectElement(__, __): e1;
				NewLine(): e1;
			}
		}
		NonTextElement(__, __) : Empty();
	}
}

makeAlphabetAwareTextField(txt : string, style : [CharacterStyle]) -> native {
	overridden = applyAlphabetStyles(detectAlphabet(txt), style);
	textfield = makeTextfield(getMappedFontFace(overridden));
	if (contains(style, PreventTextNodeWidthCalculation())) {
		setTextPreventCheckTextNodeWidth(textfield, true);
	}
	rtl = extractStruct(style, SetRTL(getDefaultRtl())).rtl;
	setTextDirection(textfield, if (rtl) "rtl" else "ltr");
	dstyle = getDefinedTextStyle(overridden);
	setTextAndStyle(
		textfield,
		if (isUrlParameterEscUnescHTMLTrue() && cpp) {
			esc = extractStruct(style, EscapeHTML(true)).escape;
			if (esc) xmlEscapeText(txt) else txt;
		} else txt,
		dstyle.face.family,
		dstyle.fontSize,
		dstyle.face.weight,
		dstyle.face.slope,
		dstyle.fillColor,
		dstyle.fillOpacity,
		dstyle.letterSpacing,
		dstyle.backgroundColor,
		dstyle.backgroundOpacity
	);
	textfield
}

renderParagraph(
	p : [ParagraphElement],
	s : [ParagraphStyle],
	rtl : bool,
	widthManager : ParagraphWidthManager
) -> Form {
	renderParagraphEx(map(p, \e -> ParagraphElementWithInfo(e, falseFn)), s, rtl, widthManager, None(), idfn, defaultWigiRenderParameters);
}

paraAtomic2form(pa : ParaAtomic, pos : WordPositionInLine) -> Form {
	switch(pa : ParaAtomic) {
		ParaWordGlued(pa2) : paraAtomic2form(pa2, pos);
		InspectElement(__, __) : Empty();
		LinePart(first, middle, end, __) : {
			switch (pos) {
				WordPositionInLineFirst(): first;
				WordPositionInLineMiddle(): middle;
				WordPositionInLineEnd(): end;
			}
		}
		Space(s) : s;
		Form(): pa;
		NewLine(): Empty();
		InteractiveParaAtomic(__, __): Empty();
	};
}

paraWordWord2form(word : ParaWord, pos : WordPositionInLine) -> Form {
	w : ParaAtomic = word.word;
	paraAtomic2form(w, pos)
};

defaultFontSizeStyle = FontSize(14.0);
zeroParaWordWidth = ParaWordWidth(0.0, 0.0, 0.0, 0.0);
emptyParaWordGroup = ParaWordGroup([], ref zeroParaWordWidth);
emptyParaWord = ParaWord(Empty(), const(zeroMetrics), Empty(), Empty(), None(), make(None()), false, falseFn);
paraLinePartFRemake = isUrlParameterTrue("plpf");
paraLinePartFRemakeD = b2d(paraLinePartFRemake);

makeParaWord2(word2 : ParaWord, form2 : Form, pos : WordPositionInLine) -> ParaWord {
	ghosted =
		switch (word2.ghosted : Ghosted) {
			Empty() : Empty();
			Ghost(xc, yc, __) : Ghost(xc, yc, form2);
			InspectGhost(inspector, __) : InspectGhost(inspector, form2);
			CoordinateInspectElement(inspector, __) : CoordinateInspectElement(inspector, form2);
		}
	ghostedForm = {
		switch (word2.ghosted : Ghosted) {
			Empty() : paraWordWord2form(word2, pos);
			default : ghosted;
		};
	};
	ParaWord(word2 with
		metrics = const(getStaticFormSize(form2)),
		ghosted = ghosted,
		form = ghostedForm
	)
};


getParaWordWidth(word : ParaWord, pos : WordPositionInLine) -> ParaWordWidth {
	fgetw = \w -> fgetValue(makeParaWord2(word, w, pos).metrics).width;
	p = switch(word.word) {
		LinePart(f, p, e, __) :
			if (pos == WordPositionInLineFirst()) fgetw(f) |> \h -> Pair(h, h)
			else Pair(fgetw(p), fgetw(e));
		default : fgetValue(word.metrics).width |> \h -> Pair(h, h);
	};
	switch(word.word) {
		// Non-text
		Empty() : ParaWordWidth(p.first, 0.0, paraLinePartFRemakeD*(p.second-p.first), 0.0);
		// Text
		default : ParaWordWidth(0.0, p.first, 0.0, paraLinePartFRemakeD*(p.second-p.first));
	}
};

addParaWordWidth(w1 : ParaWordWidth, w2 : ParaWordWidth) -> ParaWordWidth {
	ParaWordWidth(w1.rigidWidth + w2.rigidWidth, w1.softWidth + w2.softWidth, w2.finalRigidWidthDelta, w2.finalSoftWidthDelta)
}

getParaWordWidthValue(w : ParaWordWidth, textScale : double) -> double {
	w.rigidWidth + w.finalRigidWidthDelta + textScale * (w.softWidth + w.finalSoftWidthDelta)
}

renderParagraphEx(
	p : [ParagraphElementWithInfo],
	s : [ParagraphStyle],
	rtl : bool,
	widthManager : ParagraphWidthManager,
	renderedLinesInfoM : Maybe<DynamicBehaviour<[RenderedLinesInfo]>>,
	fontWrapper : ([CharacterStyle]) -> [CharacterStyle],
	renderInfo : WigiRenderParameters
) -> Form {
	traceApi = makeWigiTrace_Form("renderParagraphEx", p);
	traceApi.trace(\-> "renderParagraphEx "+(if (widthManager==dummyParagraphWidthManager) "dummyWidth" else if (widthManager.infoOnly) "infoOnly" else "storyWidth")+", style: "+toString(s));
	deferredRender = !renderInfo.inline && !isUrlParameterTrue("wigify_render_inline");
	dropStale = !isUrlParameterFalse("wigify_render_drop_stale");

	alignment : ParaLineAlignment = extractParaLineAlignment(s);
	genIndent = extractStruct(s, GeneralIndent(0.0)).indent;
	needIndent = genIndent != 0.0;

	interactiveStyles = extractStruct(s, ParagraphInteractiveStyleTree(makeTree())).styleTree;

	interlineSpacing = extractStruct(s, InterlineSpacing(0.0)).d;
	interLineHighlighting = containsStruct(s, InterlineHighlighting());
	fitLongWords = containsStruct(s, ParagraphFitLongWords());

	tightWidth = contains(s, TightWidth());

	fill = filtermap(s, \st -> switch (st) {
		Fill(__) : Some(st);
		FillOpacity(__) : Some(st);
		default : None();
	});

	topLineBaseline = contains(s, TopLineBaseline());

	indent = extractStruct(s, FirstLineIndent(0.0)).indent;
	linesCountB = extractStruct(s, ParagraphLinesCount(make(0))).count;

	isSingleLine = containsStruct(s, ParagraphSingleLine());
	isParagraphMarked = containsStruct(s, ParagraphMarked());
	paragraphBorder = extractStruct(s, ParagraphBorder(0.0, 0.0));

	accessForceNoMakeClip = tightWidth && isSingleLine;

	// Expand elements into word-units
	glued : List<ParaAtomicWithInfo> = expandGlueFragments(map(p, \e -> ParaElementWithInfo(e.element, e.isFillerFn)), 0, false, makeList(), makeList(), 0);
	// Construct our ParaWords
	gluedArr = list2array(glued);
	words : [ParaWord] = mapi(gluedArr, \i, word -> makeParaWord(
		word,
		i + 1 == length(gluedArr) || containsStruct(s, IgnoreLetterspacingOnReflow()),
		fontWrapper, false
	));

	isUnbreakable = \currentWord, prevWord -> {
		lastChr = strsubsmart(getWordText(prevWord), -1, 0);
		firstChr = strsubsmart(getWordText(currentWord), 0, 1);
		isWordJoiner(lastChr) || isWordJoiner(firstChr)
	};
	paraWordGhosted2form : (ParaWord, WordPositionInLine) -> Form = \word : ParaWord, pos : WordPositionInLine -> {
		g = word.ghosted;
		switch (g : Ghosted) {
			Empty() : paraWordWord2form(word, pos);
			Ghost(xc, yc, f) : f;
			InspectGhost(__, f) : f;
			CoordinateInspectElement(__, f) : f;
		};
	};
	addWordToGroup = \group, word -> ParaWordGroup(arrayPush(group.words, word), ref zeroParaWordWidth);

	awB = make(0.0);
	update = make(0);
	linesB : DynamicBehaviour<ParaLinesInfos> = make(ParaLinesInfos([], 0.0));

	paragraphAccessibilityParent = ^accessibilityParent;
	renderWrapper = \updaterWrapper ->
		\lines, storyWidth -> {
			prevAccessibilityParent = ^accessibilityParent;
			accessibilityParent := paragraphAccessibilityParent;
			rendered = renderParaLines(
				if (storyWidth > 0.0) storyWidth else getValue(awB),
				lines, tightWidth, alignment, interlineSpacing,
				topLineBaseline, interactiveStyles, rtl, isParagraphMarked,
				interLineHighlighting, accessForceNoMakeClip, renderedLinesInfoM
			);
			updaterWrapper(\-> nextDistinct(widthManager.width, lines.maxLineWidth));
			accessibilityParent := prevAccessibilityParent;
			rendered
		};

	renderedParagraph = if (widthManager == dummyParagraphWidthManager) {
		// it renders all words but for dynamics it just reserves space and updates coordinates
		Select(linesB, \lines -> renderWrapper(ignore)(lines, -1.0));
	} else if (widthManager.infoOnly) {
		// in this non-TightWidth case we just inform WidthManager about our width
		// we will not take story width into account in this case, but use availableWidth as usual
		Select(linesB, \lines -> renderWrapper(\fn -> fn())(lines, -1.0));
	} else {
		// we have to notify story about changes in our width.
		// it could alter widthManager.storyWidth if we are new winner so we have to defer
		Select2(linesB, widthManager.storyWidth, renderWrapper(deferUntilNextFrameRendered))
	}

	// If there is less or equal than upper limit of dynamic elements, we do not need to postpone updates
	dynamicWords = filter(words, \w -> !isFConst(w.metrics));
	ndynamic = length(dynamicWords);
	ndymamicUpper = extractStruct(s, DynamicBlockDelay(getParagraphDynamicBlockDelay())).n;

	contentGroup = Group(concat(
		[if (fill != []) Background(fill, renderedParagraph) else renderedParagraph],
		filtermap(words, \word -> {
			applyStyles = \form0 ->
				Access(concat([AccessAttribute("nextWidgetId",
					fselect(word.nextWidgetId, FLift(\idM -> eitherMap(idM, makeWordId, "")))
				)], if (accessForceNoMakeClip) [AccessForceMakeClip(false)] else []), form0)
				|> (\form ->
					eitherMap(
						lookupTree(interactiveStyles, either(word.interactivityIdM, -1)),
						\wordStyles -> {
							applyListenersAndModifiers(wordStyles, form)
							|> (\f -> applyBlockHighlighting(wordStyles, f))
						},
						form
					)
				);
			switch (word.ghosted : Ghosted) {
				Empty() : None();
				Ghost(x, y, f) : Some(Translate(x, y, applyStyles(f)));
				InspectGhost(inspector, f) : Some(Translate(inspector.x, inspector.y, applyStyles(f)));
				CoordinateInspectElement(__, __) : None();
			}
		})
	))
	|> (\f -> {
		if (indent == 0.0) {
			f
		} else {
			awBindent = make(0.0);
			Constructor(
				OverrideAvailableWidthB(awBindent, f),
				\-> connectSelectDistinctu(awB, awBindent, \aw -> aw - abs(indent))
			)
		}
	});

	wordGroups = foldi(words, makeList(), \i, acc : List<ParaWordGroup>, word -> {
		wordForm = ParaWord(word with form =
			switch (word.ghosted : Ghosted) {
				Empty() : paraWordWord2form(word, WordPositionInLineMiddle());
				Ghost(xc, yc, fm) : word.ghosted;
				InspectGhost(__, fm) : word.ghosted;
				CoordinateInspectElement(__, __) : word.ghosted;
			}
		);

		group = headList(acc, emptyParaWordGroup);
		lastWord = lastElement(group.words, emptyParaWord);
		lastSpace = isParaWordSpace(lastWord);
		rightmostWordLastChr = strsubsmart(
			getWordText((if (rtl) firstElement else lastElement)(group.words, emptyParaWord)),
			-1, 0
		);
		lastChrIsMath = rightmostWordLastChr != "" && (strContains("+-=Ã—/", rightmostWordLastChr));
		isUnbreakableSym = isUnbreakable(word, lastWord);

		if (lastChrIsMath && !isUnbreakableSym
			|| switch (word.word) {
				NewLine() : true;
				Space(__) : false;
				LinePart(st, __, __, __) : lastSpace;
				default : {
					(
						!word.glued
						&& (
							word.isFillerFn() || lastWord.isFillerFn()
							|| !keepFormTogether(paraWordGhosted2form(word, WordPositionInLineEnd()))
						)
						&& (!isParagraphMarked || i > 1)
						&& !isUnbreakableSym
					)
					|| lastSpace;
				}
			}
			|| switch (lastWord.word) {
				LinePart(st, __, __, allowBreakAfter) : allowBreakAfter;
				default: false;
			}
		) {
			// make new WG
			Cons(
				addWordToGroup(
					if (lastChrIsMath && !isUnbreakableSym) { makeParaWordGroupForMath(word, rightmostWordLastChr) } else { emptyParaWordGroup },
					wordForm
				),
				acc
			)
		} else {
			// add to current WG
			Cons(
				addWordToGroup(group, wordForm),
				tailList(acc)
			)
		}
	}) |> list2array;

	updateFn = \id, wi-> {
		oldLines = getValue(linesCountB);
		oldMaxLineWidth = getValue(linesB).maxLineWidth;
		w = if (isSingleLine) INF_METRICS else max(0.0, wi);
		traceApi.traceAndNest(\-> "updateFn [" + id + "] START wi: " + toString(wi) + ". w: " + toString(w) + ". maxLineWidth: " + toString(oldMaxLineWidth) + ", lines: " + toString(oldLines));
		// Ignore negative widths
		// It's the safest way to simulate single line, because reflowParaWords2 does a lot of useful stuff.
		iter(wordGroups, \wg ->
			wg.width := foldi(wg.words, zeroParaWordWidth, \i, acc : ParaWordWidth, pw : ParaWord ->
				addParaWordWidth(acc, getParaWordWidth(pw, WordPositionInLineMiddle()))
			)
		);
		ignoreLetterspacing = containsStruct(s, IgnoreLetterspacingOnReflow());
		infos = getParaLineInfos(
			alignment,
			wordGroups,
			w,
			indent,
			isParagraphMarked,
			rtl,
			fitLongWords,
			extractStruct(s, defaultFontSizeStyle).size,
			ignoreLetterspacing,
			interlineSpacing
		);

		nextDistinct(linesCountB, length(infos));
		// We have to rerender even when lines are identical, at minimum to move things because of potential size changes
		maxLineWidth = fold(infos, 0.0, \acc, info -> max(info.lineWidth, acc));
		lineWidths = map(infos, \info -> info.lineWidth);
		if (maxLineWidth > w) {
			traceApi.trace(\-> "DONT_FIT: " + toString(maxLineWidth) + " > " + toString(w));
		}

		traceApi.traceAndNest(\-> "updateFn [" + id + "] lines SET START w: " + toString(w) + ". maxLineWidth " + toString(oldMaxLineWidth) + " -> " + toString(maxLineWidth) + ". lines " + toString(oldLines) + " -> " + toString(getValue(linesCountB)));
		next(linesB, ParaLinesInfos(infos, maxLineWidth));
		traceApi.unnestAndTrace(\-> "updateFn [" + id + "] lines SET END  w: " + toString(w) + ". maxLineWidth " + toString(oldMaxLineWidth) + " -> " + toString(maxLineWidth) + ". lines " + toString(oldLines) + " -> " + toString(getValue(linesCountB)));

		traceApi.unnestAndTrace(\-> "updateFn [" + id + "] END   w: " + toString(w) + ". maxLineWidth " + toString(oldMaxLineWidth) + " -> " + toString(maxLineWidth) + ". lines " + toString(oldLines) + " -> " + toString(getValue(linesCountB)));
	};

	stopDefer = initUnsM();
	deferredUpdate = \wi, immediate -> {
		id = traceApi.makeRenderingId();
		if (deferredRender && !immediate) {
			traceApi.trace(\-> "deferredUpdate [" + id + "] DEFER update wi = " + toString(wi));
			doUpdate = \-> {
				traceApi.traceAndNest(\-> "deferredUpdate [" + id + "] DEFER update START wi = " + toString(wi));
				updateFn(id, wi);
				traceApi.unnestAndTrace(\-> "deferredUpdate [" + id + "] DEFER update END   wi = " + toString(wi));
			}
			if (dropStale) {
				if (isSome(^stopDefer)) {
					traceApi.traceAndNest(\-> "deferredUpdate [" + id + "] CANCELING wi = " + toString(wi));
					dispUnsM(stopDefer);
					traceApi.unnestAndTrace(\-> "deferredUpdate [" + id + "] CANCELING wi = " + toString(wi));
				}
				resetTimer = interruptibleDeferUntilNextFrameRendered(\-> {
					stopDefer := None();
					doUpdate();
				});

				setUnsM(stopDefer, \-> {
					traceApi.trace(\-> "deferredUpdate [" + id + "] CANCELED DEFER wi = " + toString(wi));
					resetTimer();
				})
			} else {
				deferUntilNextFrameRendered(doUpdate);
			}
		} else {
			traceApi.traceAndNest(\-> "deferredUpdate [" + id + "] IMMEDIATE update START wi = " + toString(wi));
			updateFn(id, wi);
			traceApi.unnestAndTrace(\-> "deferredUpdate [" + id + "] IMMEDIATE update END   wi = " + toString(wi));
		}
	}

	wasRendered = ref false;
	Constructor(
		Inspect(
			[AvailableWidth2(awB)],
			if (paragraphBorder.top > 0.0 || paragraphBorder.bottom > 0.0) {
				Border(0.0, paragraphBorder.top, 0.0, paragraphBorder.bottom, contentGroup);
			} else {
				contentGroup;
			}
		),
		\ -> {
			uns = concatA([
				[
					// we can't render inline because of possible loop that would be missed in this case
					// we have to render first time immediate
					makeSubscribeUns(awB, \v -> {
						if (^wasRendered) {
							deferredUpdate(v, false)
						} else {
							wasRendered := true;
							deferredUpdate(v, true);
						}
						[]
					})()
				],
				if (renderInfo.inline || ndynamic == 0 || ndynamic == ndymamicUpper) [] else
				[
					subscribe2(update, \u -> {
						// When an update from a dynamic element is requested, we do it in the next frame
						if (u == 1) {
							id = traceApi.makeRenderingId();
							traceApi.trace(\-> "updateFn["+id+"] TRIGGERED");

							deferUntilNextFrameRendered(\ -> {
								traceApi.traceAndNest(\-> "updateFn["+id+"] DEFERRED START");
								next(update, 0);
								updateFn(id, getValue(awB));
								traceApi.unnestAndTrace(\-> "updateFn["+id+"] DEFERRED END");
							})
						}
					})
				],
				mapi(dynamicWords, \i, w -> makeSubscribe2(w.metrics, \m -> {
					id = traceApi.makeRenderingId();
					if (renderInfo.inline || i < ndymamicUpper) {
						traceApi.traceAndNest(\-> "dynamicWordsMetrics IMMEDIATE updateFn["+id+"] for m = " + toString(m));
						updateFn(id, getValue(awB));
						traceApi.unnestAndTrace(\-> "dynamicWordsMetrics IMMEDIATE updateFn["+id+"] for m = " + toString(m));
					} else {
						traceApi.trace(\-> "dynamicWordsMetrics DEFERRED updateFn["+id+"] for m = " + toString(m));
						nextDistinct(update, 1)
					}
				})())
			]);
			\ -> applyall(uns)
		}
	)
	|> (\f -> {
		if (needIndent) {
			if (rtl) Border(0.0, 0.0, genIndent, 0.0, f) else Border(genIndent, 0.0, 0.0, 0.0, f)
		} else {
			f
		}
	})
	// fix for https://trello.com/c/QFMrOR14/22929-line-breaks-in-wigi-even-though-there-is-enough-space
	|> (\f -> Inspect([Width(make(0.))], f))
}

isSpaceForm(spaceForm : GhostForm) -> bool {
	switch (spaceForm : GhostForm) {
		Text(text, __) : {
			text == " "
		};
		default: false
	};
}

wigiRtrimSpace = !isUrlParameterFalse("wigi_rtrim_space");

isParaWordSpace(w : ParaWord) -> bool {
	switch (w.word) {
		Space(__) : true;
		default : false;
	};
}

isParaWordSpaceForm(w : ParaWord) -> bool {
	switch (w.word) {
		Space(spaceForm) : isSpaceForm(spaceForm);
		default : false;
	};
}

getParaLineInfos(
	alignment : ParaLineAlignment,
	wordGroups : [ParaWordGroup],
	availableWidth : double,
	indent : double,
	isParagraphMarked : bool,
	rtl : bool,
	shrinkLongWords : bool,
	fontSize : double,
	ignoreLetterSpacing : bool,
	interlineSpacing : double
) -> [ParaLineInfo] {
	textScale = if (shrinkLongWords && wordGroups != []) {
		maxWidthGroup : ParaWordGroup = fold(
			tail(wordGroups),
			if (wigiRtrimSpace) rtrimParaWordGroup(wordGroups[0]) else wordGroups[0],
			\maxGroup : ParaWordGroup, group : ParaWordGroup -> {
				trimmedGroup = if (wigiRtrimSpace) rtrimParaWordGroup(group) else group;
				width = getParaWordWidthValue(^(trimmedGroup.width), 1.0);
				if (width > getParaWordWidthValue(^(maxGroup.width), 1.0)) trimmedGroup else maxGroup
			}
		);
		softPart = (^(maxWidthGroup.width).rigidWidth) - paraLinePartFRemakeD*(^(maxWidthGroup.width).finalRigidWidthDelta);

		if (getParaWordWidthValue(^(maxWidthGroup.width), 1.0) > availableWidth && softPart < availableWidth) {
			maxSoftWidth = ((^(maxWidthGroup.width).softWidth) + paraLinePartFRemakeD*(^(maxWidthGroup.width).finalSoftWidthDelta));
			if (maxSoftWidth != 0.0)
				(availableWidth - softPart) / maxSoftWidth
			else 1.0
		} else 1.0
	} else 1.0;
	reflowResult = reflowParaWords(wordGroups, availableWidth, indent, rtl, fontSize, textScale);
	linesCount = length(reflowResult) - 1;
	a : ParaLinesInfoAcc = foldi(reflowResult, ParaLinesInfoAcc(EmptyList(), 0.0), \i : int, acc : ParaLinesInfoAcc, line : ParaLine -> {
		lastLine = linesCount == i;
		// if the first word is filler then we should not justify previous line https://trello.com/c/JLZxfuIW/22099
		lineAlignment = if (alignment != Justify() || lastLine) alignment else eitherMap(
			elementAtM(reflowResult[i + 1].words, 0),
			\w -> if (w.isFillerFn()) StartAlign() else alignment,
			alignment
		);
		words = if ((wigiRtrimSpace || lineAlignment == Justify() && newJustifyEnabled && length(line.words) > 2) && i != linesCount) {
			// we don't need spaces in the end of the line becasue if there is filler element in the line spaces will be out of the available width
			// and we can't move space on the next line because it will break alignment so we just trim spaces in the end.
			endElement = if (rtl) firstElement else lastElement;
			endFold = if (rtl) fold else foldr;
			reverseOrNot = if (rtl) idfn else reverseA;
			if (isParaWordSpaceForm(endElement(line.words, emptyParaWord))) {
				endFold(line.words, makeList(), \acc1, paraWord -> {
					if (acc1 == EmptyList() && isParaWordSpaceForm(paraWord)) acc1
					else Cons(paraWord, acc1);
				}) |> list2array |> reverseOrNot;
			} else line.words;
		} else line.words;
		optimizedLine = getOptimizedLine(
			words,
			lineAlignment,
			availableWidth,
			line.indent,
			i == linesCount,
			ignoreLetterSpacing,
			rtl
		);

		lineAscAndDynamic : Pair<double, bool> = fold(optimizedLine, Pair(0.0, false), \ac : Pair<double, bool>, ole : OptimizedLineElement -> {
			lineAsc = max(ac.first, fgetValue(ole.metrics).baseline);
			containsDynamicElement = ac.second || switch (ole.f : GhostForm) {
				Ghost(__, __, __) : true;
				InspectGhost(__, __) : true;
				CoordinateInspectElement(__, __) : true;
				default : ac.second;
			};
			Pair(lineAsc, containsDynamicElement);
		});

		metrics = map(optimizedLine, \ole -> fgetValue(ole.metrics));
		lineHeightAndWidth : Pair<double, double> = fold(metrics, Pair(0.0, line.indent), \ac : Pair<double, double>, m ->{
			Pair(
				max(ac.first, m.height + lineAscAndDynamic.first - m.baseline),
				ac.second + m.width
			)
		});

		paraLineInfo = ParaLineInfo(
			optimizedLine,
			roundUIMetricsValue(lineAscAndDynamic.first),
			roundUIMetricsValue(lineHeightAndWidth.first),
			roundUIMetricsValue(lineHeightAndWidth.second),
			roundUIMetricsValue(line.indent),
			lineAscAndDynamic.second,
			roundUIMetricsValue(acc.y)
		);
		ParaLinesInfoAcc(
			Cons(paraLineInfo, acc.lines),
			acc.y + lineHeightAndWidth.first + if (i == linesCount) 0. else interlineSpacing,
		);
	});
	list2array(a.lines);
}

ParaAtomicWithInfo(
	element: ParaAtomic,
	isFillerFn: () -> bool
);

// Introduce a ParaOneWord that group the words together, so that we do not have to worry about joins
expandGlueFragments(
	elements : [ParaElementWithInfo],
	currentPosition : int,
	glueNext : bool,
	running : List<ParaAtomicWithInfo>,
	acc : List<ParaAtomicWithInfo>,
	runLength : int,
) -> List<ParaAtomicWithInfo> {

	flush = \ -> {
		if (runLength == 0) {
			acc;
		} else if (runLength == 1) {
			Cons(headList(running, ParaAtomicWithInfo(Empty(), falseFn)), acc);
		} else {
			revRunning = reverseList(running);
			foldList(
				tailList(revRunning),
				Cons(headList(revRunning, ParaAtomicWithInfo(Empty(), falseFn)), acc),
				\acc2, ra : ParaAtomicWithInfo -> Cons(ParaAtomicWithInfo(ra.element |> ParaWordGlued, ra.isFillerFn), acc2)
			);
		};
	};

	n = length(elements);
	if (n - currentPosition == 0) {
		flush();
	} else {
		e = elements[currentPosition];
		switch (e.element : ParaElement) {
			GlueFragments() : expandGlueFragments(elements, currentPosition+1, true, running, acc, runLength);
			TextFragments(parts) : {
				p : [ParaElementWithInfo] = map(list2array(parts), \p -> ParaElementWithInfo(p, e.isFillerFn));
				expandGlueFragments(concat(p, subrange(elements, currentPosition + 1, n - currentPosition)), 0, glueNext, running, acc, runLength);
			}
			WordWrapInteractive(wElem, id) : {
				switch (wElem :  NonInteractiveWrapElement) {
					GlueFragments(): expandGlueFragments(elements, currentPosition+1, true, running, acc, runLength);

					NewLine(): {
						en = InteractiveParaAtomic(wElem, id);
						if (glueNext) {
							expandGlueFragments(elements, currentPosition+1, false, Cons(ParaAtomicWithInfo(en, e.isFillerFn), running), acc, runLength + 1);
						} else {
							expandGlueFragments(elements, currentPosition+1, false, Cons(ParaAtomicWithInfo(en, e.isFillerFn), makeList()), flush(), 1);
						}
					}
					Space(f) : {
						en = InteractiveParaAtomic(wElem, id);
						if (glueNext) {
							expandGlueFragments(elements, currentPosition+1, false, Cons(ParaAtomicWithInfo(en, e.isFillerFn), running), acc, runLength + 1);
						} else {
							expandGlueFragments(elements, currentPosition+1, false, Cons(ParaAtomicWithInfo(en, e.isFillerFn), makeList()), flush(), 1);
						}
					}
					InspectElement(inspector, element): {
						en = InteractiveParaAtomic(element, id);
						if (glueNext) {
							expandGlueFragments(elements, currentPosition+1, false, Cons(ParaAtomicWithInfo(en, e.isFillerFn), running), acc, runLength + 1);
						} else {
							expandGlueFragments(elements, currentPosition+1, false, Cons(ParaAtomicWithInfo(en, e.isFillerFn), makeList()), flush(), 1);
						}

					}
					LinePart(pr, i, po, __): {
						en = InteractiveParaAtomic(wElem, id);
						if (glueNext) {
							expandGlueFragments(elements, currentPosition+1, false, Cons(ParaAtomicWithInfo(en, e.isFillerFn), running), acc, runLength + 1);
						} else {
							expandGlueFragments(elements, currentPosition+1, false, Cons(ParaAtomicWithInfo(en, e.isFillerFn), makeList()), flush(), 1);
						}
					}
					Form(): {
						en = InteractiveParaAtomic(wElem, id);
						if (glueNext) {
							expandGlueFragments(elements, currentPosition+1, false, Cons(ParaAtomicWithInfo(en, e.isFillerFn), running), acc, runLength + 1);
						} else {
							expandGlueFragments(elements, currentPosition+1, false, Cons(ParaAtomicWithInfo(en, e.isFillerFn), makeList()), flush(), 1);
						}
					}
				}
			}
			ParaAtomic(): {
				if (glueNext) {
					expandGlueFragments(elements, currentPosition+1, false, Cons(ParaAtomicWithInfo(e.element, e.isFillerFn), running), acc, runLength + 1);
				} else {
					expandGlueFragments(elements, currentPosition+1, false, Cons(ParaAtomicWithInfo(e.element, e.isFillerFn), makeList()), flush(), 1);
				}
			}
		}
	}
}

makeInteractiveParaWord(
	w : ParaAtomic,
	interactivityIdM : Maybe<int>,
	ignoreLetterSpacing : bool,
	fontWrapper : ([CharacterStyle]) -> [CharacterStyle],
	glued : bool,
	isFillerFn : () -> bool
) -> ParaWord {
	s2w = \s : Pair<Form, Transform<FormMetrics>> -> {
		if (!isGhostable(s.first)) {
			ParaWord(s.first, s.second, Empty(), Empty(), interactivityIdM, make(None()), glued, isFillerFn);
		} else {
			x = make(0.0);
			y = make(0.0);
			ParaWord(Empty(), s.second, Ghost(x, y, s.first), Empty(), interactivityIdM, make(None()), glued, isFillerFn);
		}
	}
	switch (w : ParaAtomic) {
		NewLine() : ParaWord(w, const(zeroMetrics), Empty(), Empty(), interactivityIdM, make(None()), glued, falseFn);
		// We choose the middle part
		LinePart(f, p, e, allowBreakAfter) : {
			dynFormSizePair = getDynamicFormSize2(p, true);
			ParaWord(
				LinePart(f, p, e, allowBreakAfter),
				dynFormSizePair.second,
				CoordinateInspectElement(
					ParaElementInspector(
						make(0),
						make(0.),
						make(0.),
						makeWH(),
						make(0.),
						make(0.),
						make(0),
						make(false),
						make(0.),
						make(0.),
						make(WordPositionInLineFirst())
					),
					dynFormSizePair.first,
				),
				Empty(),
				interactivityIdM,
				make(None()),
				glued,
				isFillerFn
			);
		}
		Space(s) : {
			innerForm = switch(s : Form) {
				Text(t, st): Text(t, fontWrapper(st));
				default: s;
			}
			dynFormSizePair = getJoinableTextMetrics(innerForm, true, ignoreLetterSpacing);
			ParaWord(Space(dynFormSizePair.first), dynFormSizePair.second, Empty(), Empty(), interactivityIdM, make(None()), glued, falseFn);
		}
		ParaWordGlued(wg) : {
			makeInteractiveParaWord(wg, interactivityIdM, ignoreLetterSpacing, fontWrapper, true, isFillerFn);
		}
		InspectElement(inspector, e) : {
			makeWord = \word, form -> ParaWord(
				word,
				getJoinableTextMetrics(form, false, ignoreLetterSpacing).second,
				CoordinateInspectElement(inspector, form),
				Empty(),
				interactivityIdM,
				make(None()),
				glued,
				isFillerFn
			);
			switch (e : InspectableElement) {
				Text(t, s) : {
					makeWord(e, e);
				}
				LinePart(f, m, l, __) : {
					makeWord(e, m);
				}
				Space(t) : {
					makeWord(e, t);
				}
				Form(): {
					s = getJoinableTextMetrics(e, false, ignoreLetterSpacing);
					ParaWord(Empty(), s.second, InspectGhost(inspector, s.first), Empty(), interactivityIdM, make(None()), glued, isFillerFn);
				}
			}
		}
		InteractiveParaAtomic(word, id) : {
			makeInteractiveParaWord(word, Some(id), ignoreLetterSpacing, fontWrapper, glued, isFillerFn);
		}
		Text(t, s) : {
			opt = Text(t, fontWrapper(s)) |> optimizeForm;
			getJoinableTextMetrics(opt, false, ignoreLetterSpacing) |> s2w;
		}
		Form(): {
			opt = optimizeForm(w);
			getJoinableTextMetrics(opt, false, ignoreLetterSpacing) |> s2w;
		}
	}
}

getJoinableTextMetrics(
	form : Form,
	getExactTopPoint : bool,
	ignoreLetterSpacing : bool
) -> Pair<Form, Transform<FormMetrics>> {

	getDefault = \-> {
		formSize : Pair<Form, Behaviour<FormMetrics>> = getDynamicFormSize2(form, getExactTopPoint);
		Pair(formSize.first, formSize.second)
	};
	if (ignoreLetterSpacing) {
		getDefault()
	} else switch (form) {
		Text(text, st) : {
			letterSpacing = extractStruct(st, zeroLetterSpacing).spacing;
			staticMetrics = getStaticFormSizeCached2(form, getExactTopPoint);

			metrics : Pair<Form, Transform<FormMetrics>> = if (use_dynamic_text_metrics) {
				textWidth = make(staticMetrics.width);
				Pair(
					Text(text, arrayPush(st, TextWidthInspector(textWidth))),
					fselect(textWidth, FLift(\tw -> FormMetrics(staticMetrics with
						width = tw + letterSpacing
					)))
				);
			} else {
				Pair(form, const(FormMetrics(staticMetrics with width = staticMetrics.width + letterSpacing)));
			}

			metrics
		}
		default : getDefault()
	}
}

makeParaWord(w : ParaAtomicWithInfo, ignoreLetterSpacing : bool, fontWrapper : ([CharacterStyle]) -> [CharacterStyle], glued : bool) -> ParaWord {
	switch (w.element) {
		ParaWordGlued(w2): {
			makeParaWord(ParaAtomicWithInfo(w2, w.isFillerFn), ignoreLetterSpacing, fontWrapper, true);
		}
		InteractiveParaAtomic(word, id) : makeInteractiveParaWord(
			word,
			Some(id),
			ignoreLetterSpacing,
			fontWrapper,
			glued,
			w.isFillerFn
		);
		default : makeInteractiveParaWord(
			w.element,
			None(),
			ignoreLetterSpacing,
			fontWrapper,
			glued,
			w.isFillerFn
		);
	}
}

isGhostable(f : Form) -> bool {
	switch (f) {
		Text(t, s) : false;
		default : {
			true;
		}
	}
}

// We indent the first line if paragraph's first-line indent is positive
// or all of the other lines if the indent is negative.
getLineIndent(paraIndent : double, isFirstLine : bool) -> double {
	if (paraIndent > 0.0 && isFirstLine || paraIndent < 0.0 && !isFirstLine) abs(paraIndent)
	else 0.0;
}

// Correct metrics of the first word of the line
remeasureFirstWord(wgs : [ParaWordGroup]) -> [ParaWordGroup] {
	if (wgs != []) {
		wg = wgs[0];
		w = wg.words[0];
		oldWW = getParaWordWidth(w, WordPositionInLineEnd());
		newWW = getParaWordWidth(w, WordPositionInLineFirst());
		gw = ^(wg.width);
		wg.width := if (length(wg.words) == 1)
			newWW
		else ParaWordWidth(gw with
			rigidWidth=gw.rigidWidth-oldWW.rigidWidth+newWW.rigidWidth,
			softWidth=gw.softWidth-oldWW.softWidth+newWW.softWidth
		);
	}
	wgs
}

// Given a bunch of words, a constant amount of width for paragraph, a first-line indent, this does the line breaking
reflowParaWords(
	wordGroups : [ParaWordGroup],
	availableParaWidth : double,
	paraIndent : double,
	rtl : bool,
	fontSize : double,
	textScale : double,
) -> [ParaLine] {
	firstLineWidth = availableParaWidth - getLineIndent(paraIndent, true);
	remeasureFirstWord(wordGroups);
	reflowResult = reflowParaWords2(
		wordGroups,
		firstLineWidth,
		firstLineWidth,
		[],
		[],
		paraIndent,
		fontSize,
		textScale
	);

	if (isBiDiEnabled())
		zipWith(
			reflowResult,
			reflowTextToBiDi(map(reflowResult, \l -> l.words), isWordEmpty, getWordText, setWordText, setWordRTL, rtl),
			\l, ws -> ParaLine(ws, l.indent),
		)
	else reflowResult;
}

rtrimParaWordGroup(group : ParaWordGroup) -> ParaWordGroup {
	trimmedWords = foldList(
		group.words |> array2list,
		makeList(),
		\acc, w -> {
			if (isParaWordSpaceForm(w) && isEmptyList(acc)) {
				acc
			} else {
				Cons(w, acc)
			}
		}
	) |> list2array;

	ParaWordGroup(
		trimmedWords,
		ref foldi(trimmedWords, zeroParaWordWidth, \i, acc : ParaWordWidth, pw : ParaWord ->
			addParaWordWidth(acc, getParaWordWidth(pw, WordPositionInLineMiddle()))
		)
	)
}

// here availableWidth is an amount of width for current line
reflowParaWords2(
	wordGroups : [ParaWordGroup],
	availableWidth : double,
	remainingWithSpacing : double,
	currentWordGroups : [ParaWordGroup],
	result : [ParaLine],
	paraIndent : double,
	fontSize : double,
	textScale : double
) -> [ParaLine] {
	remaining = remainingWithSpacing - getUserDefinedWordSpacingPercent() * fontSize;
	lineIndent = getLineIndent(paraIndent, result==[]);

	addLine = \-> {
		cwords = concatA(mapi(currentWordGroups, \i, g -> g.words));
		cwordslasti = length(cwords)-1;
		if (cwords == []) result else arrayPush(result, ParaLine({
			cw = mapi(cwords, \cwordi, cword -> {
				switch(cword.word) {
					LinePart(f, p, e, __) : {
						makeParaWord2(
							cword,
							if (cwordi==0) f else if (cwordi < cwordslasti) p else e,
							if (cwordi==0) WordPositionInLineFirst() else if (cwordi < cwordslasti) WordPositionInLineMiddle() else WordPositionInLineEnd()
						);
					}
					default : cword;
				}
			});

			if (textScale == 1.0) cw else {
				scale = \f -> Scale(const(textScale), const(textScale), f);
				map(cw, \w -> {
					switch (w.word) {
						Empty() : w;  // Non-text
						default : {
							// Text
							wform = w.form;
							ParaWord(w with
								metrics = fselect(w.metrics, FLift(\fm -> FormMetrics(fm.width*textScale, fm.height*textScale, fm.baseline*textScale, fm.dHeight*textScale))),
								ghosted = switch (w.ghosted : Ghosted) {
									Empty() : Empty();
									Ghost(x, y, f) : Ghost(x, y, scale(f));
									InspectGhost(inspector, f) : InspectGhost(inspector, scale(f));
									CoordinateInspectElement(i, f) : CoordinateInspectElement(i, scale(f));
								},
								form = switch (wform) {
									Ghost(xc, yc, form) : Ghost(xc, yc, scale(form));
									CoordinateInspectElement(inspector, form) : CoordinateInspectElement(inspector, scale(form));
									InspectGhost(inspector, form) : InspectGhost(inspector, scale(form));
									Form() : scale(wform);
								}
							)
						}
					}
				})
			}},
			lineIndent
		))
	};

	detachWord = \w : ParaWord, detach : bool -> {
		switch (w.ghosted) {
			CoordinateInspectElement(inspector, __) : nextDistinct(inspector.detached, detach);
			default : {
				switch (w.form) {
					CoordinateInspectElement(inspector, __) : nextDistinct(inspector.detached, detach);
					default : {}
				}
			}
		}
	};

	nextLineWidth = availableWidth + lineIndent - getLineIndent(paraIndent, false);

	if (wordGroups == []) {
		addLine()
	} else {
		group = wordGroups[0];
		word = group.words[0];
		wordWidth = getParaWordWidth(word, if (paraLinePartFRemake) WordPositionInLineFirst() else WordPositionInLineMiddle());
		groupWidth = getParaWordWidthValue(ParaWordWidth(^(group.width) with finalSoftWidthDelta=0.0, finalRigidWidthDelta=0.0), textScale);
		isSpc = switch (word.word : ParaAtomic) {
			Space(__) : true;
			NewLine() : true;
			default : false;
		};
		restGroups = tail(wordGroups);
		rest = if (isSpc) {
			restFinalDeltaOrg = if (length(group.words) > 1 && paraLinePartFRemake) ^(group.width) else zeroParaWordWidth;
			restGroup = ParaWordGroup(
				tail(group.words),
				ref ParaWordWidth((^(group.width)).rigidWidth - wordWidth.rigidWidth, (^(group.width).softWidth) - wordWidth.softWidth, restFinalDeltaOrg.finalRigidWidthDelta, restFinalDeltaOrg.finalSoftWidthDelta)
			);
			if(restGroup.words == []) restGroups else concat([restGroup], restGroups)
		} else wordGroups;
		detachWord(word, isSpc);
		isNewLine = switch (word.word : ParaAtomic) {
			NewLine() : true;
			default : {
				allowBreakAfter = switch (word.word : ParaAtomic) {
					LinePart(__, __, __, allow): allow;
					default: true;
				}
				if (allowBreakAfter && max(getParaWordWidthValue(^(group.width), textScale), groupWidth) > remaining && (isSpc || currentWordGroups != [])) {
					// we should check if the groupd ends with spaces that are not count into width if they are in the end of the line
					if (wigiRtrimSpace) {
						getParaWordWidthValue(^(rtrimParaWordGroup(group).width), textScale) > remaining
					} else {
						true
					}
				} else {
					false
				}
			}
		};
		if (isNewLine) {
			reflowParaWords2(
				remeasureFirstWord(rest), nextLineWidth, nextLineWidth,
				[], addLine(),
				paraIndent, fontSize, textScale
			)
		} else {
			reflowParaWords2(
				restGroups, availableWidth, remaining - groupWidth,
				arrayPush(currentWordGroups, group), result,
				paraIndent, fontSize, textScale
			);
		}
	}
}

// This function gets the form and decides, should the next form kept together in the same line or should it be placed on the next line
keepFormTogether(form : Form) -> bool {
	switch (form) {
		Empty() : true;
		Text(__, __) : true;
		Alpha(__, f) : keepFormTogether(f);
		Size2(__, f) : keepFormTogether(f);
		Access(__, f) : keepFormTogether(f);
		Rotate(__, f) : keepFormTogether(f);
		Cursor(__, f) : keepFormTogether(f);
		Visible(__, f) : keepFormTogether(f);
		Inspect(__, f) : keepFormTogether(f);
		Baseline(__, f) : keepFormTogether(f);
		Scale(__, __, f) : keepFormTogether(f);
		Mask2(f, __, __) : keepFormTogether(f);
		SetPending(__, f) : keepFormTogether(f);
		Available2(__, f) : keepFormTogether(f);
		Filter2(__, f, __) : keepFormTogether(f);
		Interactive(__, f) : keepFormTogether(f);
		Constructor(f, __) : keepFormTogether(f);
		Create2(current, fn) : keepFormTogether(if (^current != Empty()) ^current else fn());
		Translate(__, __, f) : keepFormTogether(f);
		Mutable2(f, __) : keepFormTogether(getValue(f));
		Border(__, __, __, __, f) : keepFormTogether(f);
		Crop2(__, __, __, __, f, __) : keepFormTogether(f);
		Group(fs) : any(map(fs, \f -> keepFormTogether(f)));
		Switch(i, fs) : keepFormTogether(if (getValue(i) < length(fs)) fs[getValue(i)] else { println("STRANGE CASE"); Empty(); });
		Grid(__) : false; // Unlikely to be a part of a word. But maybe should go recursive.
		Picture(__, __) : false;
		Graphics(__, __) : false;
		Video(__, __, __, __) : false;
		TextInput(__, __, __) : false;
		Camera(__, __, __, __) : false;
		RealHTML2(__, __, __) : false;
		ControlFocus(__, f) : keepFormTogether(f);
		FullWindow(__, f) : keepFormTogether(f);
		FullScreen(__, f) : keepFormTogether(f);
		NativeForm(__, __, __, __) : false;
		DynamicGroup2(__, __, __, __) : false; // Placeholder
	};
}

// renders lines and returns resulting forms along with their tight width at the rendering time
renderParaLines(
	availableWidth : double,
	lines : ParaLinesInfos,
	tightWidth : bool,
	alignment : ParaLineAlignment,
	interlineSpacing : double,
	topLineBaseline : bool,
	styleTree : Tree<int, [ParaElementInteractiveStyle]>,
	rtl : bool,
	isMarked : bool,
	interLineHighlighting : bool,
	accessForceNoMakeClip : bool,
	renderedLinesInfoM : Maybe<DynamicBehaviour<[RenderedLinesInfo]>>
) -> Form {
	lasti = length(lines.lines) - 1;
	a : ParaLineAcc = foldi(lines.lines, ParaLineAcc(EmptyList(), 0.0, 0.0, 0.0), \i : int, acc : ParaLineAcc, lineInfo : ParaLineInfo -> {
		// TODO: IF the line ends with NewLine (which we do not track here), we should consider it a last line and not justify
		lastLine = i == lasti;
		// On the last line, we do not justify.
		// Also if the line is single with TightWidth, any alignment is equal to StartAlign
		lineAlignment =
			if (alignment == Justify() && lastLine) {
				StartAlign()
			} else {
				alignment;
			}
		f = RenderLine(
			acc.y, lineInfo,
			availableWidth, lineAlignment,
			i, styleTree, rtl, isMarked,
			if (interLineHighlighting) {
				if (i == 0) 0. else - interlineSpacing / 2.0
			} else 0.0,
			if (interLineHighlighting){
				if (lastLine || i == 0) interlineSpacing / 2.0 else interlineSpacing
			} else 0.0,
			accessForceNoMakeClip
		);
		ParaLineAcc(
			Cons(Size2(const(zeroWH), f.form), acc.lines),
			acc.y + f.height + if (lastLine) 0. else interlineSpacing,
			if (i == 0 || !topLineBaseline) f.baseline else acc.baseline,
			if (acc.maxLineWidth < f.width) f.width else acc.maxLineWidth
		);
	});
	maybeApply(
		renderedLinesInfoM,
		\renderedLinesInfo -> {
			nextDistinct(renderedLinesInfo, map(lines.lines, \info : ParaLineInfo -> {
				elementsID = fold(info.optimizedLine, [] , \acc, elem : OptimizedLineElement -> {
					eitherMap(
						elem.interactivityIdM,
						\interactivityId -> arrayPush(acc, interactivityId),
						acc
					)
				});
				RenderedLinesInfo(info.lineHeight, info.lineAsc, elementsID, info.y)
			}));
		}
	);

	Baseline(const(a.baseline), Size2(const(WidthHeight(if (tightWidth) a.maxLineWidth else max(availableWidth, lines.maxLineWidth), a.y)),
		Group(list2array(a.lines))
	))
}

getOptimizedLine(words : [ParaWord], alignment : ParaLineAlignment, availableWidth : double, indent : double, lastLine : bool, ignoreLetterSpacing : bool, rtl : bool) -> [OptimizedLineElement]{
	optimizeLine(words, alignment, availableWidth, indent, lastLine, ignoreLetterSpacing, rtl);
}

calcParaLineAlignmentOffset(slack : double, lineIndent : double, rtl : bool, alignment : ParaLineAlignment) -> double {
	leftOffset = 0.;
	rightOffset = max(0.0, slack);
	switch (alignment : ParaLineAlignment) {
		LeftAlign(): leftOffset;
		RightAlign(): rightOffset;
		CenterAlign(): max(0.0, slack / 2.0);
		StartAlign(): if (rtl) rightOffset else leftOffset;
		EndAlign(): if (rtl) leftOffset else rightOffset;
		Justify(): 0.0;
	} + (if (rtl) 0. else lineIndent);
}

wordIds = ref 0;
useNextWordId = ref false;

// Aligns all elements to the baseline, as well as calculates the height and the baseline
// Send out the result, width, height
RenderLine(
	y : double,
	info : ParaLineInfo,
	width : double,
	alignment : ParaLineAlignment,
	lineNumber : int,
	interactiveStyles : Tree<int, [ParaElementInteractiveStyle]>,
	rtl : bool,
	isMarked : bool,
	highLightOffset : double,
	interlineSpacing : double,
	accessForceNoMakeClip : bool
) -> ParaLineResult {
	remaining = width - info.lineWidth;
	alignmentOffset = ref calcParaLineAlignmentOffset(remaining, info.lineIndent, rtl, alignment);

	wordsCount = length(info.optimizedLine) - 1;

	// Inter-word spacing for justification
	interWord = if (alignment == Justify() && length(info.optimizedLine) > 1 && !newJustifyEnabled) {
		nSpaces = foldi(info.optimizedLine, 0 , \i, acc, elem : OptimizedLineElement -> {
				lastWord = i == wordsCount;
				if (!lastWord && isSpaceForm(elem.f)) acc + 1 else acc
		});
		if (nSpaces > 0) remaining / i2d(nSpaces) else 0.0
	} else 0.0;  // Inter-word spacing via CSS instead because mobiles are too slow.
	justifyExtraWidth = ref 0.0;

	// The width and the individual forms
	lo : [Form] = filtermapi(info.optimizedLine, \i : int, elem : OptimizedLineElement -> {
		f = elem.f;
		m = fgetValue(elem.metrics);
		wordIds := ^wordIds + 1;
		wordId = makeWordId(^wordIds);

		setNextWidgetId = \ -> {
			nextDistinct(elem.nextWidgetId, Some(^wordIds + 1));
			useNextWordId := true;
		};

		isSuperscript = intStyleContains(ParaElementSuperscript(), elem, interactiveStyles);
		isSubscript = intStyleContains(ParaElementSubscript(), elem, interactiveStyles);

		dy = if (isSuperscript) {
			prevElHeight = prevElementHeight(info.optimizedLine, interactiveStyles, i - 1);
			if (prevElHeight == 0.0) -1.0 else info.lineAsc - m.baseline - prevElHeight * 0.25
		} else info.lineAsc - m.baseline / (if (isSubscript) 2.0 else 1.0);

		addWordId = \fm -> {
			if (^useNextWordId) {
				useNextWordId := false;
				Access(concat([AccessAttribute("id", const(wordId))], if (accessForceNoMakeClip) [AccessForceMakeClip(false)] else []), fm);
			} else fm
		}

		lastWord = i == wordsCount;
		isSpace = !newJustifyEnabled && !lastWord && isSpaceForm(elem.f);

		applyStylesAndOffset = \form : Form ->
			form
			|> (\fm ->
				eitherFn(
					elem.interactivityIdM,
					\id -> applyIntStylesAndHighlighting(
						fm,
						lookupTreeDef(interactiveStyles, id, []),
						^alignmentOffset,
						y,
						dy,
						m.width + if (isSpace) interWord else 0.0,
						info.lineHeight,
						highLightOffset,
						interlineSpacing,
						info.containsDynamicElement
					)
					|> addWordId,
					\ -> Translate(const(^alignmentOffset), const(y + dy), fm |> addWordId)
				)
			);

		justifyOffset = if (isMarked && i == 0 && lineNumber == 0) 0.0
		else if (isSpace) interWord else 0.0;
		r = switch (f : GhostForm) {
			Empty() : None();
			Ghost(xc, yc, fm) : {
				fo = applyStylesAndOffset(Empty());
				nextDistinct(xc, ^alignmentOffset);
				nextDistinct(yc, y + dy);
				setNextWidgetId();
				Some(fo);
			}
			InspectGhost(inspector, fm) : {
				fo = applyStylesAndOffset(Empty());
				nextDistinct(inspector.x, ^alignmentOffset);
				nextDistinct(inspector.y, y + dy);
				nextDistinct(inspector.size, WidthHeight(m.width, m.height));
				nextDistinct(inspector.lineHeight, info.lineHeight);
				nextDistinct(inspector.lineNumber, lineNumber);
				setNextWidgetId();
				Some(fo);
			}
			CoordinateInspectElement(inspector, fm) : {
				fo = applyStylesAndOffset(fm);
				nextDistinct(inspector.x, ^alignmentOffset);
				nextDistinct(inspector.y, y + dy);
				nextDistinct(inspector.size, WidthHeight(m.width, m.height));
				nextDistinct(inspector.lineHeight, info.lineHeight);
				nextDistinct(inspector.lineNumber, lineNumber);
				setNextWidgetId();
				Some(fo);
			}
			Form() : Some(applyStylesAndOffset(f))
		}

		if (m.width != 0.0 && !intStyleContains(IgnoreMetrics(), elem, interactiveStyles)) {
			justifyExtraWidth := ^justifyExtraWidth + justifyOffset;
			alignmentOffset := ^alignmentOffset + m.width + justifyOffset;
		}
		r
	});
	useNextWordId := false;
	ParaLineResult(
		Group(lo),
		info.lineWidth + ^justifyExtraWidth,
		info.lineHeight,
		y + info.lineAsc
	);
}

intStyleContains(style : ParaElementInteractiveStyle, elem : OptimizedLineElement, interactiveStyles : Tree<int, [ParaElementInteractiveStyle]>) -> bool {
	eitherMap(
		elem.interactivityIdM,
		\id -> containsStruct(
			lookupTreeDef(interactiveStyles, id, []),
			style
		),
		false
	)
}

prevElementHeight(optimizedLine : [OptimizedLineElement], interactiveStyles : Tree<int, [ParaElementInteractiveStyle]>, i : int) -> double {
	if (i < 0) 0.0
	else {
		isSuperscript = intStyleContains(ParaElementSuperscript(), optimizedLine[i], interactiveStyles);
		isSubscript = intStyleContains(ParaElementSubscript(), optimizedLine[i], interactiveStyles);
		if (isSuperscript || isSubscript) {
			prevElementHeight(optimizedLine, interactiveStyles, i - 1)
		} else {
			fgetValue(optimizedLine[i].metrics).height
		}
	}
}

applyIntStylesAndHighlighting(
	form : Form,
	styles : [ParaElementInteractiveStyle],
	xOffset : double,
	yOffset : double,
	baselineShift : double,
	width : double,
	height : double,
	highLightOffset : double,
	interlineSpacing : double,
	containsDynamicElement : bool
) -> Form {
	getStyleForBackgroundFromCharStyle = \s -> eitherMap(
		tryExtractStruct(s, BackgroundFill(white)),
		\backFill -> [
			Fill(backFill.color),
			FillOpacity(extractStruct(s, BackgroundFillOpacity(1.0)).opacity)
		],
		[]
	);

	makeBackRect = \defStyle, dynStyle -> {
		rectStyle =
			replaceStructMany(
				getStyleForBackgroundFromCharStyle(defStyle),
				getStyleForBackgroundFromCharStyle(dynStyle)
			);
		if (rectStyle == []) Empty()
		else Rectangle(
			width,
			height + interlineSpacing + 0.1,
			rectStyle
		);
	}

	dynamicHighlightStyleBM = tryExtractStruct(styles, DynamicHighlightStyle(make([]), false));

	textAndBackPair = makeTextAndBackPair(form, dynamicHighlightStyleBM, makeBackRect);

	modifiedForm = applyListenersAndModifiers(styles, textAndBackPair.first);

	Translate(const(xOffset), const(yOffset + baselineShift), modifiedForm)
	|> (\f ->
		switch(textAndBackPair.second) {
			Empty() : f;
			default : {
				textAndBack = Group([
					Translate(const(xOffset), const(yOffset + highLightOffset), textAndBackPair.second),
					f
				]);
				if (containsDynamicElement) Access([AccessRole("group")], textAndBack) else textAndBack
			}
		}
	)
}

makeTextAndBackPair(
	form : Form,
	dynamicHighlightStyleBM : Maybe<DynamicHighlightStyle>,
	makeBackRect : ([CharacterStyle], [CharacterStyle]) -> Form
) -> Pair<Form, Form> {
	switch(form) {
		Access(props, f) : {
			p = makeTextAndBackPair(f, dynamicHighlightStyleBM, makeBackRect);
			Pair(Access(props, p.first), p.second)
		}
		Text(txt, txtStyle) : {

			makeTxt = \dynStyle -> Access([TagName("span")], Text(
				txt,
				removeAllStructsMany(
					replaceStructMany(txtStyle, dynStyle),
					[BackgroundFill(0), BackgroundFillOpacity(0.0)]
				)
			));

			// We draw custom highlighting to fix gaps for cases of justifying alignment
			// And to have more straight and pretty highlighting.
			eitherMap(
				dynamicHighlightStyleBM,
				\dynHlStyle -> Pair(
					Select(dynHlStyle.styleB, \chStyle -> makeTxt(chStyle)),
					Select(dynHlStyle.styleB, \chStyle -> makeBackRect(txtStyle, chStyle))
				),
				Pair(makeTxt([]), makeBackRect(txtStyle, []))
			)
		}
		default : Pair(
			form,
			eitherMap(
				dynamicHighlightStyleBM,
				\dynHlStyle -> Select(dynHlStyle.styleB, \chStyle -> makeBackRect([], chStyle)),
				Empty()
			)
		);
	}
}

applyListenersAndModifiers(styles : [ParaElementInteractiveStyle], form : Form) -> Form {
	if (form == Empty()) form else {
		formModifiersM = tryExtractStruct(styles, FormModifiers([]));
		modifiedForm = eitherMap(
			formModifiersM,
			\modifiers -> fold(modifiers.fns, form, \acc, fn -> fn(acc)),
			form
		);

		eventListenersM = tryExtractStruct(styles, EventListeners([]));
		eitherMap(
			eventListenersM,
			\el -> Interactive(el.listeners, modifiedForm),
			modifiedForm
		);
	}
}

applyBlockHighlighting(styles : [ParaElementInteractiveStyle], form : Form) -> Form {
	eitherMap(tryExtractStruct(styles, DynamicHighlightStyle(make([]), false)),
	\dynamicHlStyle -> {
		if (dynamicHlStyle.extraHighlight) {
			getStyleForRectFromCharStyle = \s -> eitherMap(
				tryExtractStruct(s, BackgroundFill(white)),
				\backFill -> [
					Stroke(backFill.color),
					StrokeOpacity(extractStruct(s, BackgroundFillOpacity(1.0)).opacity),
					StrokeWidth(3.0),
				],
				[]
			);

			makeRect = \dynStyle, wh : WidthHeight -> Rectangle(
				wh.width,
				wh.height,
				getStyleForRectFromCharStyle(dynStyle)
			);

			whB = makeWH();
			Group([
				Inspect([ISize(whB)], form),
				Select2(dynamicHlStyle.styleB, whB, makeRect),
			])
		} else form
	},
	form
	)
}

// Joins texts together to a single text element, along with the new metrics
dummyTextWidthInspector = TextWidthInspector(make(0.0));

optimizeLine(words : [ParaWord], alignment: ParaLineAlignment, availableWidth : double, indent : double, lastLine : bool, ignoreLetterSpacing : bool, rtl : bool) -> [OptimizedLineElement] {
	wordsCount = length(words) - 1;
	useWordSpacing = newJustifyEnabled && alignment == Justify() && !lastLine;

	optimizeLineFn = \width : double -> {
		wordSpacing = if (useWordSpacing) {
			spacesAndWordsWidth : Pair<int, double> = foldi(words, Pair(0, indent), \i, acc : Pair<int, double>, w -> {
				lastWord = i == wordsCount;
				firstWord = i == 0;
				defValue = \ -> Pair(acc.first, acc.second + fgetValue(w.metrics).width);
				spaceIncValue = \inc -> Pair(acc.first + inc, acc.second + fgetValue(w.metrics).width);
				switch (w.form : GhostForm) {
					Text(text, __) : {
						if (text == " " || text == nonBreakableSpace) {
							if (lastWord || firstWord) acc
							else spaceIncValue(1)
						} else if (strContains(text, nonBreakableSpace)) spaceIncValue(strCountOf(text, nonBreakableSpace))
						else defValue()
					};
					default: defValue()
				};
			});
			if (spacesAndWordsWidth.first > 0 && width > spacesAndWordsWidth.second) {
				(width - spacesAndWordsWidth.second) / i2d(spacesAndWordsWidth.first);
			} else 0.0
		} else 0.0;

		foldi(words, makeList(), \i, acc : List<OptimizedLineElement>, word : ParaWord -> {
			f = word.form;
			w = word.word;
			metrics = word.metrics;
			intIdM = word.interactivityIdM;
			nextWidgetId = word.nextWidgetId;
			lastWord = i == wordsCount;
			switch(acc){
				EmptyList() : {
					formMetrics = switch (w) {
						Space(__): {
							metricsWithoutLS = if (ignoreLetterSpacing) {
								switch (f : GhostForm) {
									Text(__, style) : {
										spaceSize = getStaticFormSize(f);
										FormMetrics(spaceSize with width = spaceSize.width - extractStruct(style, zeroLetterSpacing).spacing) |> const
									}
									default: metrics
								}
							} else metrics;
							if (newJustifyEnabled && alignment == Justify()) {
								switch (f : GhostForm) {
									Text(text, __) : {
										if (text == " ") {
											spaceSize = getStaticFormSize(f);
											FormMetrics(spaceSize with width = spaceSize.width + wordSpacing) |> const;
										} else metricsWithoutLS
									}
									default: metricsWithoutLS
								}
							} else metricsWithoutLS
						};
						Text(text, __) : {
							if (newJustifyEnabled && alignment == Justify() && strContains(text, nonBreakableSpace)) {
								metricsV = fgetValue(metrics);
								FormMetrics(metricsV with width = metricsV.width + (wordSpacing * i2d(strCountOf(text, nonBreakableSpace)))) |> const;
							} else metrics;
						};
						default: metrics;
					};
					Cons(OptimizedLineElement(f, formMetrics, intIdM, nextWidgetId, word.isFillerFn), acc)
				};
				Cons(p, tail_) : {
					switch (p.f : GhostForm) {
						Text(t1, s1) : {
							switch (f : GhostForm) {
								Text(t2, s2) : {
									s1_withCorrectLS = if (ignoreLetterSpacing) removeAllStructs(s1, zeroLetterSpacing) else s1;
									s2_withCorrectLS = if (ignoreLetterSpacing) removeAllStructs(s2, zeroLetterSpacing) else s2;
									join = if (use_dynamic_text_metrics) {
										joinText(
											t1,
											removeAllStructs(s1_withCorrectLS, dummyTextWidthInspector),
											t2,
											removeAllStructs(s1_withCorrectLS, dummyTextWidthInspector)
										);
									} else {
										joinText(t1, s1_withCorrectLS, t2, s2_withCorrectLS);
									}

									additionalWidth = if (newJustifyEnabled && alignment == Justify()) {
										switch (f) {
											Text(text, __) : {
												if ((text == " " || text == nonBreakableSpace) && !lastWord) {
													wordSpacing;
												} else if(strContains(text, nonBreakableSpace)) {
													wordSpacing * i2d(strCountOf(text, nonBreakableSpace))
												} else 0.0
											};
											default: 0.0
										};
									} else 0.0;

									if (length(join) == 1 && intIdM == p.interactivityIdM) {
										t : Form = join[0];

										jtf : Pair<Form, Transform<FormMetrics>> = if (use_dynamic_text_metrics) {
											getJoinableTextMetrics(t, false, false)
										} else {
											// TODO: Do not do this until at the end of the joining fest
											m = getStaticFormSize(t);
											optimizedLineElementMetrics : FormMetrics = fgetValue(p.metrics);
											wordWidth = getStaticFormSize(f).width;

											Pair(
												t,
												FormMetrics(m with
													width = optimizedLineElementMetrics.width + wordWidth + (if (ignoreLetterSpacing) 0.0 else extractStruct(s2, zeroLetterSpacing).spacing) + additionalWidth
												) |> const
											);
										}

										// Replace the last element with the newly joined
										Cons(
											OptimizedLineElement(jtf.first, jtf.second, intIdM, nextWidgetId, falseFn),
											tail_
										);
									} else {
										fMetrics : FormMetrics = fgetValue(metrics);
										Cons(
											OptimizedLineElement(
												f,
												FormMetrics(fMetrics with
													width = fMetrics.width + additionalWidth
												) |> const,
												intIdM,
												nextWidgetId,
												falseFn
											),
											acc
										);
									};
								}
								default : {
									Cons(OptimizedLineElement(f, metrics, intIdM, nextWidgetId, word.isFillerFn), acc);
								}
							}
						}
						default : Cons(OptimizedLineElement(f, metrics, intIdM, nextWidgetId, word.isFillerFn), acc);
					}
				}
			}
		}) |> list2array
		|> (\arr : [OptimizedLineElement] -> {
			if (wordSpacing != 0.0) {
				wordSpacingStyle = WordSpacing(const(wordSpacing));
				mapi(arr, \i, e -> {
					switch (e.f : GhostForm) {
						Text(t, s): {
							newText = Text(t, arrayPush(s, wordSpacingStyle));
							// native measure will not take word spacing ' text' into account because it is stand-alone measure
							// but in the end, it will be taken into account by browser if there is other elements before it in the line
							if (!rtl && startsWith(t, " ") && i > 0) {
								metrics = fgetValue(e.metrics);
								OptimizedLineElement(e with
									f = newText,
									metrics = make(FormMetrics(metrics with width = metrics.width + wordSpacing))
								)
							} else {
								OptimizedLineElement(e with f = newText)
							}
						}
						default: e;
					}
				});
			} else {
				arr
			}
		});
	}

	optimizedLine = optimizeLineFn(availableWidth);
	if (useWordSpacing) {
		width_optimized = fold(optimizedLine, 0.0, \acc2, w -> acc2 + fgetValue(w.metrics).width) |> roundUIMetricsValue;
		if (width_optimized > availableWidth) {
			// sometimes optimized line takes more width that original because of some not fully understandable reasons
			// it leads to odd behaviour like blowing and scrolls so we attempt to prevent it here
			width = fold(words, 0.0, \acc2, w -> acc2 + fgetValue(w.metrics).width) |> roundUIMetricsValue;
			if (width < availableWidth) {
				optimizeLineFn(availableWidth - (width_optimized - availableWidth))
			} else {
				optimizedLine
			}
		} else {
			optimizedLine
		}
	} else {
		optimizedLine
	}
}

isWordEmpty(w : ParaWord) -> bool {
	switch(w.word) {
		Text(t, __) : t == "";
		default : false;
	}
}

getWordText(w : ParaWord) -> string {
	switch(w.word) {
		Text(t, __) : t;
		Empty() : switch (w.form) {
			InspectGhost(__, form) : getFormText(form);
			Ghost(__, __, form) : getFormText(form);
			default : "";
		};
		default : "";
	}
}

setWordText(w : ParaWord, t : string) -> ParaWord {
	switch(w.word) {
		Text(__, s) : ParaWord(w with
			word = Text(t, s),
			form = switch(w.form) {
				CoordinateInspectElement(inspector, form) : CoordinateInspectElement(
					inspector,
					Text(t, getFormTextStyle(form))
				);
				Text(__, fs) : Text(t, fs);
				default : w.form;
			}
		);
		default : w;
	};
}

setWordRTL(w : ParaWord, rtl : bool) -> ParaWord {
	switch(w.word) {
		Text(t, s) : ParaWord(w with
			word = Text(t, s),
			form = switch(w.form) {
				CoordinateInspectElement(inspector, form) : CoordinateInspectElement(
					inspector,
					Text(t, replaceStruct(getFormTextStyle(form), SetRTL(rtl)))
				);
				Text(__, fs) : Text(t, replaceStruct(fs, SetRTL(rtl)));
				default : w.form;
			}
		);
		default : w;
	};
}

makeParaWordGroupForMath(w : ParaWord, s : string) -> ParaWordGroup {
	makeParaWordGroup = \word -> ParaWordGroup([word], ref zeroParaWordWidth);
	switch(w.word) {
		Text(__, st) :
			ParaWord(w with
				word = LinePart(Text(s, st), Empty(), Empty(), false),
				form = switch(w.form) {
					CoordinateInspectElement(inspector, form) : CoordinateInspectElement(
						inspector,
						Text(s, getFormTextStyle(form))
					);
					Text(__, fs) : Text(s, fs);
					default : w.form;
				},
				interactivityIdM = None()
			) |> makeParaWordGroup;
		LinePart(sf, mf, ef, allowBreakAfter) : {
			swt = \f, t -> {
				newWord : ParaAtomic = setWordText(ParaWord(w with word = f), t).word;
				switch (newWord) {
					Form(): newWord;
					ParaWordGlued(__): Empty();
					TextElement(): Empty();
					InteractiveParaAtomic(__, __): Empty();
				}
			}
			ParaWord(w with word=LinePart(swt(sf, s), swt(mf, ""), swt(ef, ""), allowBreakAfter)) |> makeParaWordGroup;
		};
		default : emptyParaWordGroup;
	};
}

makeStoryWidthManager(paragraphs : int, infoOnly : bool) -> StoryWidthManager {
	paragraphWidths = generate(0, paragraphs, \__ -> make(0.0));
	storyWidth = make(0.0);

	paragraphManagers = map(paragraphWidths, \pw -> ParagraphWidthManager(storyWidth, pw, infoOnly));
	StoryWidthManager(
		paragraphManagers,
		\i -> elementAt(paragraphManagers, i, dummyParagraphWidthManager),
		storyWidth,
		infoOnly,
		\ -> {
			if (infoOnly) {
				nop
			} else {
				maxWidth = arrayMaxu(paragraphWidths);
				uns = [
					maxWidth.second,
					connectDistinct(maxWidth.first, storyWidth)
				];
				\ -> applyall(uns);
			}
		}
	)
}

makeWordId(id : int) {
	"word_" + i2s(id);
}

// Not with others because referenced from flow9 repo.
isUrlParameterEscUnescHTMLTrue() -> bool {
	isUrlParameterTrue("753");
}

makeSkipOrderCheck(st : [CharacterStyle]) -> [CharacterStyle] {
	replaceStruct(st, SkipOrderCheck());
}

use_dynamic_text_metrics = isSafariBrowser() && !isUrlParameterFalse("dynamic_text_metrics");

paragraphElement2string(e : ParagraphElementWithInfo) -> string {
	handleNonInteractive = \acc, nonintel -> switch (nonintel) {
		Text(text, __): acc + text;
		Space(__): acc + " ";
		Form(): acc + getFormText(nonintel);
		default: acc;
	};
	switch (e.element) {
		TextFragments(list): {
			foldList(list |> reverseList, "", \acc2, e2 -> {
				switch (e2) {
					WordWrapInteractive(e3, __): handleNonInteractive(acc2, e3);
					NonInteractiveWrapElement(): handleNonInteractive(acc2, e2);
				}
			})
		}
		Form(): getFormText(e.element);
		GlueFragments(): "";
	}
}

wigiTraceLevel : ref int = ref 0;

dummyWigiTraceApi = WigiTraceApi(nop1, nop1, nop1, nop1, nop, nop, \->"", "");

makeWigiTraceIdFn(words : (() -> [?]), word2string : (?) -> string) -> (() -> string) {
	\-> fold(words(), "", \acc, w -> acc + word2string(w))
}

wigiTraceRenderingId = ref -1;

makeWigiTraceGeneric(functionName : string, idFn : () -> string, condition : bool) -> WigiTraceApi {
	if (condition) {
		traceId = "[" + idFn() + "] " + functionName + ": ";
		traceFn = \messageFn -> println(strRepeat(" ", 2 * ^wigiTraceLevel) + traceId + messageFn());
		nestFn = \-> wigiTraceLevel := ^wigiTraceLevel + 1;
		unnestFn = \-> if (^wigiTraceLevel > 0) wigiTraceLevel := ^wigiTraceLevel - 1;

		WigiTraceApi(
			traceFn,
			\messageFn -> { traceFn(messageFn); nestFn(); },
			\messageFn -> { traceFn(messageFn); unnestFn(); },
			\messageFn -> { unnestFn(); traceFn(messageFn); },
			nestFn,
			unnestFn,
			\ -> {
				wigiTraceRenderingId := ^wigiTraceRenderingId + 1;
				toString(^wigiTraceRenderingId);
			},
			traceId
		)
	} else {
		dummyWigiTraceApi
	}
}

makeWigiTrace_Form(functionName : string, words : [ParagraphElementWithInfo]) -> WigiTraceApi {
	makeWigiTraceGeneric(
		functionName,
		makeWigiTraceIdFn(\ -> words, paragraphElement2string),
		isUrlParameterTrue("trace_form_render") || isUrlParameterTrue("trace_wigi_render")
	)
}

isWordJoiner(char : string) -> bool {
	char == wordJoiner || char == nonBreakableSpace || char == zeroWidthJoiner
}
