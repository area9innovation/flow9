import form/paragraphtypes;
import form/line;
import form/baseline;
import text/bidi_text;

import text/blueprint;

export {
	makeAlphabetAwareTextField(txt : string, style : [CharacterStyle]) -> native;
	renderParagraph(p : [ParagraphElement], s : [ParagraphStyle], rtl : bool, widthManager : ParagraphWidthManager) -> Form;
	renderParagraphEx(
		p : [ParagraphElement],
		s : [ParagraphStyle],
		rtl : bool,
		widthManager : ParagraphWidthManager,
		renderedLinesInfoM : Maybe<DynamicBehaviour<[RenderedLinesInfo]>>,
		fontWrapper : ([CharacterStyle]) -> [CharacterStyle]
	) -> Form;
	getLineIndent(paraIndent : double, isFirstLine : bool) -> double;
	makeZeroSpaceElement(style : [CharacterStyle]) -> Form;
	general2WrapElement(elem : GeneralWrapElement, style : [CharacterStyle], wordDecorator : (Form) -> Form) -> NonInteractiveWrapElement;
	makeWrapElementsFromGeneralTextFragments(fragments : GeneralTextFragments) -> List<NonInteractiveWrapElement>;
	generalEmptyLineInspectElement(id : int) -> GeneralInspectElement;
	keepFormTogether(form : Form) -> bool;

	StoryWidthManager(
		paragraphManagers : [ParagraphWidthManager],
		getParagraphManagerAt : (int) -> ParagraphWidthManager,
		width : Behaviour<double>,
		infoOnly : bool, /* do not control width of paragraphs, just gather their widths */
		constructor : () -> () -> void,
	);
	ParagraphWidthManager(
		storyWidth : Behaviour<double>,
		width : DynamicBehaviour<double>,
		infoOnly : bool
	);

	makeStoryWidthManager(paragraphs : int, infoOnly : bool) -> StoryWidthManager;
	dummyParagraphWidthManager = ParagraphWidthManager(const(0.0), make(0.0), true);
	dummyStoryWidthManager = StoryWidthManager([], \__ -> dummyParagraphWidthManager, zero, true, \ -> nop);

	calcParaLineAlignmentOffset(slack : double, lineIndent : double, rtl : bool, alignment : ParaLineAlignment) -> double;

	INF_METRICS = 100000.0;

	isUrlParameterEscUnescHTMLTrue() -> bool;
	// Helper to pass accessibility properties from material to forms
	// Used in material2form
	accessibilityParent : ref Maybe<flow> = ref None();

	// Will be populated when rendering  document with real height of all lines from top-level paragraphs
	RenderedLinesInfoStyle(baselines : DynamicBehaviour<[DynamicBehaviour<[RenderedLinesInfo]>]>);
		RenderedLinesInfo(height : double, baseline : double);
		dummyRenderedLinesInfo = RenderedLinesInfo(0.0, 0.0);

	nonBreakableSpace : string = fromCharCode(nonBreakableSpaceCode);
	wordJoiner : string = fromCharCode(wordJoinerCode);

	makeSkipOrderCheck(st : [CharacterStyle]) -> [CharacterStyle];

	WigiTraceApi(
		trace : (() -> string) -> void,
		traceAndNest : (() -> string) -> void,
		traceAndUnnest : (() -> string) -> void,
		unnestAndTrace : (() -> string) -> void,
		nest : () -> void,
		unnest : () -> void
	);

	makeWigiTraceIdFn(words : (() -> [?]), word2string : (?) -> string) -> (() -> string);
	makeWigiTraceGeneric(functionName : string, idFn : () -> string) -> WigiTraceApi;

	newJustifyEnabled = js && !isUrlParameterFalse("js_justify");
}

// TODO:
// - When joining texts, wait with calculating the new metrics until all texts have been joined up
// - Unsubscribe when reflowing

/*
To render a paragraph, we first collect individual words which need to stay together on the same line.
That happens in expandGlueFragments. Each of the words is then categorized as a text or ghost element.
Ghost elements are rendered once, and then moved around when reflows happen. Text elements are
reconstructed on each reflow, because we combine them together to have as few sprites for text as
possible, and because rendering words in the same sprite improves the interword spacing.
*/

// Intermediately used typed as a union of ParagraphElement and WrapElement and ParaWordGlued
ParaElement ::= ParagraphElement, WrapElement, ParaAtomic;

// After expanding elements to words
ParaAtomic ::= Form, ParaWordGlued, TextElement, InteractiveParaAtomic;
	// The word should be kept with previous on the same line
	ParaWordGlued(word : ParaAtomic);
	InteractiveParaAtomic(elem : ParaAtomic, interactivityId : int);

GhostForm ::= Form, Ghosted; // It is important that GhostForm is a super type of Ghosted
	Ghost(xc : DynamicBehaviour<double>, yc : DynamicBehaviour<double>, form : Form);

// For dynamic elements, we use a ghost to allow reuse of the physical forms
Ghosted ::= Empty, Ghost, CoordinateInspectElement, InspectGhost;
	CoordinateInspectElement(inspector : ParaElementInspector, form : Form);
	InspectGhost(
		inspector : ParaElementInspector,
		form : Form
	);

// Each word to be placed in the paragraph, including the metrics and as well as any ghost constructed
ParaWord(
	word : ParaAtomic,
	metrics : Transform<FormMetrics>,
	ghosted : Ghosted,
	form : GhostForm,
	interactivityIdM : Maybe<int>,
	nextWidgetId : DynamicBehaviour<Maybe<int>>,
	glued : bool
);

ParaWordWidth(rigidWidth : double, softWidth : double, finalRigidWidthDelta : double, finalSoftWidthDelta : double);
ParaWordGroup(words : [ParaWord], width : ref ParaWordWidth);

ParaLine(words : [ParaWord], indent : double);
ParaLineAcc(lines : List<Form>, y : double, baseline : double, maxLineWidth : double);

OptimizedLineElement(f : GhostForm, metrics : Transform<FormMetrics>, interactivityIdM : Maybe<int>, nextWidgetId : DynamicBehaviour<Maybe<int>>);
ParaLineInfo(optimizedLine : [OptimizedLineElement], lineAsc : double, lineHeight : double, lineWidth : double, lineIndent : double, containsDynamicElement : bool);
ParaLinesInfos(lines : [ParaLineInfo], maxLineWidth : double);
ParaLineResult(form : Form, width : double, height : double, baseline : double);

makeWrapElementsFromGeneralTextFragments(fragments : GeneralTextFragments) -> List<NonInteractiveWrapElement> {
	mapList(fragments.elements, \elem -> general2WrapElement(elem, fragments.style, idfn))
}

makeZeroSpaceElement(style : [CharacterStyle]) -> Form {
	spaceMetrics = getStaticFormSize(Text(" ", style));
	fixBaseline(spaceMetrics.baseline, Fixed(0.0, spaceMetrics.height))
}

generalEmptyLineInspectElement(id : int) -> GeneralInspectElement {
	GeneralInspectElement(
		ParaElementInspector(make(id), make(0.), make(0.), makeWH(), make(0.), make(0.), make(0), make(false), make(0.), make(0.)),
		EmptyLineElement()
	)
}

general2WrapElement(elem : GeneralWrapElement, style : [CharacterStyle], wordDecorator : (Form) -> Form) -> NonInteractiveWrapElement {
	generateText = \txt, st -> Text(txt, st |> makeSkipOrderCheck) |> wordDecorator;
	switch (elem) {
		GeneralText(txt) : generateText(txt, applyAlphabetStyles(detectAlphabet(txt), style));
		GeneralDynamicText(txt) : generateText(txt, applyAlphabetStyles(detectAlphabet(txt), style));
		GeneralSpace(txt, alBef, alAft) : Space(generateText(txt, apply2AlphabetsScaling(alBef, alAft, style)));
		NewLine() : elem;
		GeneralLinePart(f, m, e) : {
			st =  makeSkipOrderCheck(style);
			LinePart(Text(f, st) |> wordDecorator, Text(m, st), Text(e, st) |> wordDecorator);
		}
		EmptyLineElement() : makeZeroSpaceElement(style |> makeSkipOrderCheck);
		GeneralInspectElement(inspector, element) : {
			e1 = general2WrapElement(element, style, wordDecorator);
			switch (e1) {
				InspectableElement(): InspectElement(inspector, e1);
				GlueFragments(): Empty();
				InspectElement(__, __): e1;
				NewLine(): e1;
			}
		}
		NonTextElement() : Empty();
	}
}

makeAlphabetAwareTextField(txt : string, style : [CharacterStyle]) -> native {
	overridden = applyAlphabetStyles(detectAlphabet(txt), style);
	textfield = makeTextfield(getMappedFontFace(overridden));
	rtl = extractStruct(style, SetRTL(getDefaultRtl())).rtl;
	setTextDirection(textfield, if (rtl) "rtl" else "ltr");
	dstyle = getDefinedTextStyle(overridden);
	setTextAndStyle(
		textfield,
		if (isUrlParameterEscUnescHTMLTrue() && cpp) {
			esc = extractStruct(style, EscapeHTML(true)).escape;
			if (esc) xmlEscapeText(txt) else txt;
		} else txt,
		dstyle.face.family,
		dstyle.fontSize,
		dstyle.face.weight,
		dstyle.face.slope,
		dstyle.fillColor,
		dstyle.fillOpacity,
		dstyle.letterSpacing,
		dstyle.backgroundColor,
		dstyle.backgroundOpacity
	);
	textfield
}

renderParagraph(
	p : [ParagraphElement],
	s : [ParagraphStyle],
	rtl : bool,
	widthManager : ParagraphWidthManager
) -> Form {
	renderParagraphEx(p, s, rtl, widthManager, None(), idfn);
}

paraAtomic2form(pa : ParaAtomic, pos : int) -> Form {
	switch(pa : ParaAtomic) {
		ParaWordGlued(pa2) : paraAtomic2form(pa2, pos);
		InspectElement(__, __) : Empty();
		LinePart(first, inline, last) : if (pos==0) first else if (pos==-1) last else inline;
		Space(s) : s;
		Form(): pa;
		NewLine(): Empty();
		InteractiveParaAtomic(__, __): Empty();
	};
}

paraWordWord2form(word : ParaWord, pos : int) -> Form {
	w : ParaAtomic = word.word;
	paraAtomic2form(w, pos)
};

defaultFontSizeStyle = FontSize(14.0);
zeroParaWordWidth = ParaWordWidth(0.0, 0.0, 0.0, 0.0);
emptyParaWordGroup = ParaWordGroup([], ref zeroParaWordWidth);
emptyParaWord = ParaWord(Empty(), const(zeroMetrics), Empty(), Empty(), None(), make(None()), false);
paraLinePartFRemake = isUrlParameterTrue("plpf");
paraLinePartFRemakeD = b2d(paraLinePartFRemake);

makeParaWord2(word2 : ParaWord, form2 : Form, pos : int) -> ParaWord {
	ghosted =
		switch (word2.ghosted : Ghosted) {
			Empty() : Empty();
			Ghost(xc, yc, __) : Ghost(xc, yc, form2);
			InspectGhost(inspector, __) : InspectGhost(inspector, form2);
			CoordinateInspectElement(inspector, __) : CoordinateInspectElement(inspector, form2);
		}
	ghostedForm = {
		switch (word2.ghosted : Ghosted) {
			Empty() : paraWordWord2form(word2, pos);
			default : ghosted;
		};
	};
	ParaWord(word2 with
		metrics = const(getStaticFormSize(form2)),
		ghosted = ghosted,
		form = ghostedForm
	)
};


getParaWordWidth(word : ParaWord, pos : int) -> ParaWordWidth {
	fgetw = \w -> fgetValue(makeParaWord2(word, w, pos).metrics).width;
	p = switch(word.word) {
		LinePart(f, p, e) :
			if (pos == 0) fgetw(f) |> \h -> Pair(h, h)
			else Pair(fgetw(p), fgetw(e));
		default : fgetValue(word.metrics).width |> \h -> Pair(h, h);
	};
	switch(word.word) {
		// Non-text
		Empty() : ParaWordWidth(p.first, 0.0, paraLinePartFRemakeD*(p.second-p.first), 0.0);
		// Text
		default : ParaWordWidth(0.0, p.first, 0.0, paraLinePartFRemakeD*(p.second-p.first));
	}
};

addParaWordWidth(w1 : ParaWordWidth, w2 : ParaWordWidth) -> ParaWordWidth {
	ParaWordWidth(w1.rigidWidth + w2.rigidWidth, w1.softWidth + w2.softWidth, w2.finalRigidWidthDelta, w2.finalSoftWidthDelta)
}

getParaWordWidthValue(w : ParaWordWidth, textScale : double) -> double {
	w.rigidWidth + w.finalRigidWidthDelta + textScale * (w.softWidth + w.finalSoftWidthDelta)
}

renderParagraphEx(
	p : [ParagraphElement],
	s : [ParagraphStyle],
	rtl : bool,
	widthManager : ParagraphWidthManager,
	renderedLinesInfoM : Maybe<DynamicBehaviour<[RenderedLinesInfo]>>,
	fontWrapper : ([CharacterStyle]) -> [CharacterStyle]
) -> Form {
	traceApi = makeWigiTrace_Form("renderParagraphEx", p);

	alignment : ParaLineAlignment = extractParaLineAlignment(s);
	genIndent = extractStruct(s, GeneralIndent(0.0)).indent;
	needIndent = genIndent != 0.0;

	interactiveStyles = extractStruct(s, ParagraphInteractiveStyleTree(makeTree())).styleTree;

	interlineSpacing = extractStruct(s, InterlineSpacing(0.0)).d;
	interLineHighlighting = containsStruct(s, InterlineHighlighting());
	fitLongWords = containsStruct(s, ParagraphFitLongWords());

	tightWidth = contains(s, TightWidth());

	fill = filtermap(s, \st -> switch (st) {
		Fill(__) : Some(st);
		FillOpacity(__) : Some(st);
		default : None();
	});

	topLineBaseline = contains(s, TopLineBaseline());

	indent = extractStruct(s, FirstLineIndent(0.0)).indent;
	linesCountB = extractStruct(s, ParagraphLinesCount(make(0))).count;

	isSingleLine = containsStruct(s, ParagraphSingleLine());
	isParagraphMarked = containsStruct(s, ParagraphMarked());
	paragraphBorder = extractStruct(s, ParagraphBorder(0.0, 0.0));

	// Expand elements into word-units
	glued : List<ParaAtomic> = expandGlueFragments(p, false, makeList(), makeList(), 0);
	// Construct our ParaWords
	gluedArr = list2array(glued);
	words : [ParaWord] = mapi(gluedArr, \i, word -> makeParaWord(
		word,
		i + 1 == length(gluedArr) || containsStruct(s, IgnoreLetterspacingOnReflow()),
		fontWrapper, false
	));

	isUnbreakable = \currentWord, prevWord -> {
		lastChr = strsubsmart(getWordText(prevWord), -1, 0);
		firstChr = strsubsmart(getWordText(currentWord), 0, 1);
		lastChr == wordJoiner || firstChr == wordJoiner || lastChr == nonBreakableSpace || firstChr == nonBreakableSpace;
	};
	keepFormTogetherOrWithMark = \form1, i -> {
		keepFormTogether(form1) || isParagraphMarked && i <= 1;
	};
	addWordToGroup = \group, word -> ParaWordGroup(arrayPush(group.words, word), ref zeroParaWordWidth);

	paraWordGhosted2form : (ParaWord, int) -> Form = \word : ParaWord, pos : int -> {
		g = word.ghosted;
		switch (g : Ghosted) {
			Empty() : paraWordWord2form(word, pos);
			Ghost(xc, yc, f) : f;
			InspectGhost(__, f) : f;
			CoordinateInspectElement(__, f) : f;
		};
	};

	aw = make(0.0);
	update = make(0);
	linesB : DynamicBehaviour<ParaLinesInfos> = make(ParaLinesInfos([], 0.0));

	paragraphAccessibilityParent = ^accessibilityParent;
	renderWrapper = \updaterWrapper ->
		\lines, storyWidth -> {
			prevAccessibilityParent = ^accessibilityParent;
			accessibilityParent := paragraphAccessibilityParent;
			rendered = renderParaLines(
				if (storyWidth > 0.0) storyWidth else getValue(aw),
				lines, tightWidth, alignment, interlineSpacing,
				topLineBaseline, interactiveStyles, rtl, isParagraphMarked,
				interLineHighlighting, renderedLinesInfoM
			);
			updaterWrapper(\-> nextDistinct(widthManager.width, lines.maxLineWidth));
			accessibilityParent := prevAccessibilityParent;
			rendered
		};

	renderedParagraph = if (widthManager == dummyParagraphWidthManager) {
		// it renders all words but for dynamics it just reserves space and updates coordinates
		Select(linesB, \lines -> renderWrapper(ignore)(lines, -1.0));
	} else if (widthManager.infoOnly) {
		// in this non-TightWidth case we just inform WidthManager about our width
		// we will not take story width into account in this case, but use availableWidth as usual
		Select(linesB, \lines -> renderWrapper(\fn -> fn())(lines, -1.0));
	} else {
		// we have to notify story about changes in our width.
		// it could alter widthManager.storyWidth if we are new winner so we have to defer
		Select2(linesB, widthManager.storyWidth, renderWrapper(deferUntilNextFrameRendered))
	}

	// If there is less or equal than upper limit of dynamic elements, we do not need to postpone updates
	dynamicWords = filter(words, \w -> !isFConst(w.metrics));
	ndynamic = length(dynamicWords);
	ndymamicUpper = extractStruct(s, DynamicBlockDelay(getParagraphDynamicBlockDelay())).n;

	contentGroup = Group(concat(
		[if (fill != []) Background(fill, renderedParagraph) else renderedParagraph],
		filtermap(words, \word -> {
			applyStyles = \form0 ->
				Access([AccessAttribute("nextWidgetId",
					fselect(word.nextWidgetId, FLift(\idM -> eitherMap(idM, makeWordId, "")))
				)], form0)
				|> (\form ->
					eitherMap(
						lookupTree(interactiveStyles, either(word.interactivityIdM, -1)),
						\wordStyles -> {
							applyListenersAndModifiers(wordStyles, form)
							|>(\f -> applyBlockHighlighting(wordStyles, f))
						},
						form
					)
				);
			switch (word.ghosted : Ghosted) {
				Empty() : None();
				Ghost(x, y, f) : Some(Translate(x, y, applyStyles(f)));
				InspectGhost(inspector, f) : Some(Translate(inspector.x, inspector.y, applyStyles(f)));
				CoordinateInspectElement(__, __) : None();
			}
		})
	));

	wordGroups = foldi(words, makeList(), \i, acc : List<ParaWordGroup>, word -> {
		wordForm = ParaWord(word with form =
			switch (word.ghosted : Ghosted) {
				Empty() : paraWordWord2form(word, 1);
				Ghost(xc, yc, fm) : word.ghosted;
				InspectGhost(__, fm) : word.ghosted;
				CoordinateInspectElement(__, __) : word.ghosted;
			}
		);

		group = headList(acc, emptyParaWordGroup);
		lastWord = lastElement(group.words, emptyParaWord);
		lastSpace = isParaWordSpace(lastWord);
		rightmostWordLastChr = strsubsmart(
			getWordText((if (rtl) firstElement else lastElement)(group.words, emptyParaWord)),
			-1, 0
		);
		lastChrIsMath = rightmostWordLastChr != "" && (strContains("+-=×/", rightmostWordLastChr));
		isUnbreakableSym = isUnbreakable(word, lastWord);

		if (lastChrIsMath && !isUnbreakableSym || switch (word.word) {
			NewLine() : true;
			Space(__) : false;
			LinePart(st, __, __) : lastSpace;
			default : (!word.glued && !keepFormTogetherOrWithMark(paraWordGhosted2form(word, -1), i) && !isUnbreakableSym) || lastSpace;
		}) {
			Cons(
				addWordToGroup(
					if (lastChrIsMath && !isUnbreakableSym) { makeParaWordGroupForMath(word, rightmostWordLastChr) } else { emptyParaWordGroup },
					wordForm
				),
				acc
			)
		} else {
			Cons(
				addWordToGroup(group, wordForm),
				tailList(acc)
			)
		}
	}) |> list2array;

	Constructor(
		Inspect(
			[AvailableWidth2(aw)],
			if (paragraphBorder.top > 0.0 || paragraphBorder.bottom > 0.0) {
				Border(0.0, paragraphBorder.top, 0.0, paragraphBorder.bottom, contentGroup);
			} else {
				contentGroup;
			}
		),
		\ -> {
			updateFn = \wi-> {
				oldLines = getValue(linesCountB);
				oldMaxLineWidth = getValue(linesB).maxLineWidth;
				traceApi.trace(\-> "updateFn START " + toString(wi) + ". maxLineWidth: " + toString(oldMaxLineWidth) + ", lines: " + toString(oldLines));
				// Ignore negative widths
				// It's the safest way to simulate single line, because reflowParaWords2 does a lot of useful stuff.
				w = if (isSingleLine) INF_METRICS else max(0.0, wi);
				iter(wordGroups, \wg ->
					wg.width := foldi(wg.words, zeroParaWordWidth, \i, acc : ParaWordWidth, pw : ParaWord ->
						addParaWordWidth(acc, getParaWordWidth(pw, 1))
					)
				);
				infos = getParaLineInfos(
					alignment,
					wordGroups,
					w,
					indent,
					isParagraphMarked,
					rtl,
					fitLongWords,
					extractStruct(s, defaultFontSizeStyle).size
				);

				nextDistinct(linesCountB, length(infos));
				// We have to rerender even when lines are identical, at minimum to move things because of potential size changes
				maxLineWidth = fold(infos, 0.0, \acc, info -> max(info.lineWidth, acc));
				next(linesB, ParaLinesInfos(infos, maxLineWidth));
				traceApi.trace(\-> "updateFn END " + toString(wi) + ". maxLineWidth " + toString(oldMaxLineWidth) + " -> " + toString(maxLineWidth) + ". lines " + toString(oldLines) + " -> " + toString(getValue(linesCountB)));
			};

			uns = concatA([
				[
					subscribe(aw, \v -> {
						traceApi.trace(\-> "aw changed. calling updateFn. aw = " + toString(v));
						updateFn(v);
					}),
				],
				if (ndynamic == 0 || ndynamic == ndymamicUpper) [] else
				[
					subscribe2(update, \u -> {
						// When an update from a dynamic element is requested, we do it in the next frame
						if (u == 1) deferUntilNextFrameRendered(\ -> {
							traceApi.trace(\-> "updateFn DEFERRED STARTED");
							next(update, 0);
							updateFn(getValue(aw))
						})
					})
				],
				mapi(dynamicWords, \i, w -> makeSubscribe2(w.metrics, \m -> {
					if (i < ndymamicUpper) {
						traceApi.trace(\-> "dynamicWordsMetrics IMMEDIATE updateFn for m = " + toString(m));
						updateFn(getValue(aw))
					} else {
						traceApi.trace(\-> "dynamicWordsMetrics DEFERRED updateFn for m = " + toString(m));
						nextDistinct(update, 1)
					}
				})())
			]);
			\ -> applyall(uns)
		}
	)
	|> (\f -> {
		if (needIndent) {
			if (rtl) Border(0.0, 0.0, genIndent, 0.0, f) else Border(genIndent, 0.0, 0.0, 0.0, f)
		} else {
			f
		}
	})
}

isSpaceForm(spaceForm : GhostForm) -> bool {
	switch (spaceForm : GhostForm) {
		Text(text, __) : {
			text == " "
		};
		default: false
	};
}

wigiRtrimSpace = !isUrlParameterFalse("wigi_rtrim_space");

isParaWordSpace(w : ParaWord) -> bool {
	switch (w.word) {
		Space(__) : true;
		default : false;
	};
}

isParaWordSpaceForm(w : ParaWord) -> bool {
	switch (w.word) {
		Space(spaceForm) : isSpaceForm(spaceForm);
		default : false;
	};
}

getParaLineInfos(
	alignment : ParaLineAlignment,
	wordGroups : [ParaWordGroup],
	availableWidth : double,
	indent : double,
	isParagraphMarked : bool,
	rtl : bool,
	shrinkLongWords : bool,
	fontSize : double
) -> [ParaLineInfo] {
	textScale = if (shrinkLongWords && wordGroups != []) {
		maxWidthGroup : ParaWordGroup = fold(
			tail(wordGroups),
			wordGroups[0],
			\maxGroup : ParaWordGroup, group : ParaWordGroup -> {
				width = getParaWordWidthValue(^(group.width), 1.0);
				if (width > getParaWordWidthValue(^(maxGroup.width), 1.0)) group else maxGroup
			}
		);
		if (getParaWordWidthValue(^(maxWidthGroup.width), 1.0) > availableWidth) {
			maxSoftWidth = ((^(maxWidthGroup.width).softWidth) + paraLinePartFRemakeD*(^(maxWidthGroup.width).finalSoftWidthDelta));
			if (maxSoftWidth != 0.0)
				(availableWidth - (^(maxWidthGroup.width).rigidWidth) - paraLinePartFRemakeD*(^(maxWidthGroup.width).finalRigidWidthDelta)) / maxSoftWidth
			else 1.0
		} else 1.0
	} else 1.0;
	reflowResult = reflowParaWords(wordGroups, availableWidth, indent, rtl, fontSize, textScale);
	linesCount = length(reflowResult) - 1;
	mapi(reflowResult, \i, line -> {
		words = if (wigiRtrimSpace || alignment == Justify() && newJustifyEnabled && i != linesCount && length(line.words) > 2) {
			// we don't need spaces in the end of the line becasue if there is filler element in the line spaces will be out of the available width
			// and we can't move space on the next line because it will break alignment so we just trim spaces in the end.
			if (isParaWordSpaceForm(lastElement(line.words, emptyParaWord))) {
				foldr(line.words, makeList(), \acc, paraWord -> {
					if (acc == EmptyList() && isParaWordSpaceForm(paraWord)) acc
					else Cons(paraWord, acc);
				}) |> list2array |> reverseA;
			} else line.words;
		} else line.words;
		optimizedLine = getOptimizedLine(words, alignment, availableWidth, indent, i == linesCount);

		lineAscAndDynamic : Pair<double, bool> = fold(optimizedLine, Pair(0.0, false), \ac : Pair<double, bool>, ole : OptimizedLineElement -> {
			lineAsc = max(ac.first, fgetValue(ole.metrics).baseline);
			containsDynamicElement = ac.second || switch (ole.f : GhostForm) {
				Ghost(__, __, __) : true;
				InspectGhost(__, __) : true;
				CoordinateInspectElement(__, __) : true;
				default : ac.second;
			};
			Pair(lineAsc, containsDynamicElement);
		});

		metrics = map(optimizedLine, \ole -> fgetValue(ole.metrics));
		lineHeightAndWidth : Pair<double, double> = fold(metrics, Pair(0.0, line.indent), \ac : Pair<double, double>, m ->{
			Pair(
				max(ac.first, m.height + lineAscAndDynamic.first - m.baseline),
				ac.second + m.width
			)
		});

		ParaLineInfo(
			optimizedLine,
			lineAscAndDynamic.first,
			lineHeightAndWidth.first,
			lineHeightAndWidth.second,
			line.indent,
			lineAscAndDynamic.second
		)
	});
}

// Introduce a ParaOneWord that group the words together, so that we do not have to worry about joins
expandGlueFragments(
	elements : [ParaElement],
	glueNext : bool,
	running : List<ParaAtomic>,
	acc : List<ParaAtomic>,
	runLength : int,
) -> List<ParaAtomic> {

	flush = \ -> {
		if (runLength == 0) {
			acc;
		} else if (runLength == 1) {
			Cons(headList(running, Empty()), acc);
		} else {
			revRunning = reverseList(running);
			foldList(
				tailList(revRunning),
				Cons(headList(revRunning, Empty()), acc),
				\acc2, ra : ParaAtomic -> Cons(ra |> ParaWordGlued, acc2)
			);
		};
	};

	n = length(elements);
	if (n == 0) {
		flush();
	} else {
		rest : [ParaElement] = tail(elements);
		e = elements[0];
		glueNextFn : (ParaAtomic) -> List<ParaAtomic> = \en -> {
			if (glueNext) {
				expandGlueFragments(rest, false, Cons(en, running), acc, runLength + 1);
			} else {
				expandGlueFragments(rest, false, Cons(en, makeList()), flush(), 1);
			}
		}
		switch (e : ParaElement) {
			GlueFragments() : expandGlueFragments(rest, true, running, acc, runLength);
			TextFragments(parts) : {
				p : [WrapElement] = list2array(parts);
				expandGlueFragments(concat(p, rest), glueNext, running, acc, runLength);
			}
			WordWrapInteractive(wElem, id) : {
				switch (wElem :  NonInteractiveWrapElement) {
					GlueFragments(): expandGlueFragments(rest, true, running, acc, runLength);

					NewLine(): InteractiveParaAtomic(wElem, id) |> glueNextFn;
					Space(f) : InteractiveParaAtomic(wElem, id) |> glueNextFn;
					InspectElement(inspector, element): InteractiveParaAtomic(element, id) |> glueNextFn;
					LinePart(pr, i, po): InteractiveParaAtomic(i, id) |> glueNextFn;
					Form(): InteractiveParaAtomic(wElem, id) |> glueNextFn;
				}
			}
			ParaAtomic(): {
				glueNextFn(e)
			}
		}
	}
}

makeInteractiveParaWord(
	w : ParaAtomic,
	interactivityIdM : Maybe<int>,
	ignoreLetterSpacing : bool,
	fontWrapper : ([CharacterStyle]) -> [CharacterStyle],
	glued : bool
) -> ParaWord {
	s2w = \s : Pair<Form, Transform<FormMetrics>> -> {
		if (!isGhostable(s.first)) {
			ParaWord(s.first, s.second, Empty(), Empty(), interactivityIdM, make(None()), glued);
		} else {
			x = make(0.0);
			y = make(0.0);
			ParaWord(Empty(), s.second, Ghost(x, y, s.first), Empty(), interactivityIdM, make(None()), glued);
		}
	}
	switch (w : ParaAtomic) {
		NewLine() : ParaWord(w, const(zeroMetrics), Empty(), Empty(), interactivityIdM, make(None()), glued);
		// We choose the middle part
		LinePart(f, p, e) : {
			dynFormSizePair = getDynamicFormSize2(p, true);
			ParaWord(
				LinePart(f, p, e),
				dynFormSizePair.second,
				CoordinateInspectElement(
					ParaElementInspector(
						make(0),
						make(0.),
						make(0.),
						makeWH(),
						make(0.),
						make(0.),
						make(0),
						make(false),
						make(0.),
						make(0.)
					),
					dynFormSizePair.first,
				),
				Empty(),
				interactivityIdM,
				make(None()),
				glued
			);
		}
		Space(s) : {
			innerForm = switch(s : Form) {
				Text(t, st): Text(t, fontWrapper(st));
				default: s;
			}
			dynFormSizePair = getJoinableTextMetrics(innerForm, true, ignoreLetterSpacing);
			ParaWord(Space(dynFormSizePair.first), dynFormSizePair.second, Empty(), Empty(), interactivityIdM, make(None()), glued);
		}
		ParaWordGlued(wg) : {
			makeInteractiveParaWord(wg, interactivityIdM, ignoreLetterSpacing, fontWrapper, true);
		}
		InspectElement(inspector, e) : {
			makeWord = \word, form -> ParaWord(
				word,
				getJoinableTextMetrics(form, false, ignoreLetterSpacing).second,
				CoordinateInspectElement(inspector, form),
				Empty(),
				interactivityIdM,
				make(None()),
				glued
			);
			switch (e : InspectableElement) {
				Text(t, s) : {
					makeWord(e, e);
				}
				LinePart(f, m, l) : {
					makeWord(e, m);
				}
				Space(t) : {
					makeWord(e, t);
				}
				Form(): {
					s = getJoinableTextMetrics(e, false, ignoreLetterSpacing);
					ParaWord(Empty(), s.second, InspectGhost(inspector, s.first), Empty(), interactivityIdM, make(None()), glued);
				}
			}
		}
		InteractiveParaAtomic(word, id) : {
			makeInteractiveParaWord(word, Some(id), ignoreLetterSpacing, fontWrapper, glued);
		}
		Text(t, s) : {
			opt = Text(t, fontWrapper(s)) |> optimizeForm;
			getJoinableTextMetrics(opt, false, ignoreLetterSpacing) |> s2w;
		}
		Form(): {
			opt = optimizeForm(w);
			getJoinableTextMetrics(opt, false, ignoreLetterSpacing) |> s2w;
		}
	}
}

getJoinableTextMetrics(
	form : Form,
	getExactTopPoint : bool,
	ignoreLetterSpacing : bool
) -> Pair<Form, Transform<FormMetrics>> {

	getDefault = \-> {
		formSize : Pair<Form, Behaviour<FormMetrics>> = getDynamicFormSize2(form, getExactTopPoint);
		Pair(formSize.first, formSize.second)
	};
	if (ignoreLetterSpacing) {
		getDefault()
	} else switch (form) {
		Text(text, st) : {
			letterSpacing = extractStruct(st, LetterSpacing(0.0)).spacing;
			staticMetrics = getStaticFormSizeCached2(form, getExactTopPoint);

			metrics : Pair<Form, Transform<FormMetrics>> = if (use_dynamic_text_metrics) {
				textWidth = make(staticMetrics.width);
				Pair(
					Text(text, arrayPush(st, TextWidthInspector(textWidth))),
					fselect(textWidth, FLift(\tw -> FormMetrics(staticMetrics with
						width = tw + letterSpacing
					)))
				);
			} else {
				Pair(form, const(FormMetrics(staticMetrics with width = staticMetrics.width + letterSpacing)));
			}

			metrics
		}
		default : getDefault()
	}
}

makeParaWord(w : ParaAtomic, ignoreLetterSpacing : bool, fontWrapper : ([CharacterStyle]) -> [CharacterStyle], glued : bool) -> ParaWord {
	switch (w) {
		ParaWordGlued(w2): {
			makeParaWord(w2, ignoreLetterSpacing, fontWrapper, true);
		}
		InteractiveParaAtomic(word, id) : makeInteractiveParaWord(
			word,
			Some(id),
			ignoreLetterSpacing,
			fontWrapper,
			glued
		);
		default : makeInteractiveParaWord(
			w,
			None(),
			ignoreLetterSpacing,
			fontWrapper,
			glued
		);
	}
}

isGhostable(f : Form) -> bool {
	switch (f) {
		Text(t, s) : false;
		default : {
			true;
		}
	}
}

// We indent the first line if paragraph's first-line indent is positive
// or all of the other lines if the indent is negative.
getLineIndent(paraIndent : double, isFirstLine : bool) -> double {
	if (paraIndent > 0.0 && isFirstLine || paraIndent < 0.0 && !isFirstLine) abs(paraIndent)
	else 0.0;
}

// Correct metrics of the first word of the line
remeasureFirstWord(wgs : [ParaWordGroup]) -> [ParaWordGroup] {
	if (wgs != []) {
		wg = wgs[0];
		w = wg.words[0];
		oldWW = getParaWordWidth(w, 1);
		newWW = getParaWordWidth(w, 0);
		gw = ^(wg.width);
		wg.width := if (length(wg.words) == 1)
			newWW
		else ParaWordWidth(gw with
			rigidWidth=gw.rigidWidth-oldWW.rigidWidth+newWW.rigidWidth,
			softWidth=gw.softWidth-oldWW.softWidth+newWW.softWidth
		);
	}
	wgs
}

// Given a bunch of words, a constant amount of width for paragraph, a first-line indent, this does the line breaking
reflowParaWords(
	wordGroups : [ParaWordGroup],
	availableParaWidth : double,
	paraIndent : double,
	rtl : bool,
	fontSize : double,
	textScale : double,
) -> [ParaLine] {
	firstLineWidth = availableParaWidth - getLineIndent(paraIndent, true);
	remeasureFirstWord(wordGroups);
	reflowResult = reflowParaWords2(
		wordGroups,
		firstLineWidth,
		firstLineWidth,
		[],
		[],
		paraIndent,
		fontSize,
		textScale
	);

	if (isBiDiEnabled())
		zipWith(
			reflowResult,
			reflowTextToBiDi(map(reflowResult, \l -> l.words), isWordEmpty, getWordText, setWordText, setWordRTL, rtl),
			\l, ws -> ParaLine(ws, l.indent),
		)
	else reflowResult;
}

// here availableWidth is an amount of width for current line
reflowParaWords2(
	wordGroups : [ParaWordGroup],
	availableWidth : double,
	remainingWithSpacing : double,
	currentWordGroups : [ParaWordGroup],
	result : [ParaLine],
	paraIndent : double,
	fontSize : double,
	textScale : double
) -> [ParaLine] {
	remaining = remainingWithSpacing - getUserDefinedWordSpacingPercent() * fontSize;
	lineIndent = getLineIndent(paraIndent, result==[]);

	addLine = \-> {
		cwords = concatA(mapi(currentWordGroups, \i, g -> g.words));
		cwordslasti = length(cwords)-1;
		if (cwords == []) result else arrayPush(result, ParaLine({
			cw = mapi(cwords, \cwordi, cword -> {
				switch(cword.word) {
					LinePart(f, p, e) :
						makeParaWord2(cword, if (cwordi==0) f else if (cwordi < cwordslasti) p else e, if (cwordi < cwordslasti) cwordi else -1);
					default : cword;
				}
			});

			if (textScale == 1.0) cw else {
				scale = \f -> Scale(const(textScale), const(textScale), f);
				map(cw, \w -> {
					switch (w.word) {
						Empty() : w;  // Non-text
						default : {
							// Text
							wform = w.form;
							ParaWord(w with
								metrics = fselect(w.metrics, FLift(\fm -> FormMetrics(fm.width*textScale, fm.height*textScale, fm.baseline*textScale, fm.dHeight*textScale))),
								ghosted = switch (w.ghosted : Ghosted) {
									Empty() : Empty();
									Ghost(x, y, f) : Ghost(x, y, scale(f));
									InspectGhost(inspector, f) : InspectGhost(inspector, scale(f));
									CoordinateInspectElement(i, f) : CoordinateInspectElement(i, scale(f));
								},
								form = switch (wform) {
									Ghost(xc, yc, form) : Ghost(xc, yc, scale(form));
									CoordinateInspectElement(inspector, form) : CoordinateInspectElement(inspector, scale(form));
									InspectGhost(inspector, form) : InspectGhost(inspector, scale(form));
									Form() : scale(wform);
								}
							)
						}
					}
				})
			}},
			lineIndent
		))
	};

	detachWord = \w : ParaWord, detach : bool -> {
		switch (w.ghosted) {
			CoordinateInspectElement(inspector, __) : nextDistinct(inspector.detached, detach);
			default : {
				switch (w.form) {
					CoordinateInspectElement(inspector, __) : nextDistinct(inspector.detached, detach);
					default : {}
				}
			}
		}
	};

	nextLineWidth = availableWidth + lineIndent - getLineIndent(paraIndent, false);

	if (wordGroups == []) {
		addLine()
	} else {
		group = wordGroups[0];
		word = group.words[0];
		wordWidth = getParaWordWidth(word, if (paraLinePartFRemake) 0 else 1);
		groupWidth = getParaWordWidthValue(ParaWordWidth(^(group.width) with finalSoftWidthDelta=0.0, finalRigidWidthDelta=0.0), textScale);
		isSpc = switch (word.word : ParaAtomic) {
			Space(__) : true;
			NewLine() : true;
			default : false;
		};
		restGroups = tail(wordGroups);
		rest = if (isSpc) {
			restFinalDeltaOrg = if (length(group.words) > 1 && paraLinePartFRemake) ^(group.width) else zeroParaWordWidth;
			restGroup = ParaWordGroup(
				tail(group.words),
				ref ParaWordWidth((^(group.width)).rigidWidth - wordWidth.rigidWidth, (^(group.width).softWidth) - wordWidth.softWidth, restFinalDeltaOrg.finalRigidWidthDelta, restFinalDeltaOrg.finalSoftWidthDelta)
			);
			if(restGroup.words == []) restGroups else concat([restGroup], restGroups)
		} else wordGroups;
		detachWord(word, isSpc);
		isNewLine = switch (word.word : ParaAtomic) {
			NewLine() : true;
			default :
				max(getParaWordWidthValue(^(group.width), textScale), groupWidth) > remaining
				&& (isSpc || currentWordGroups != [])
		};
		if (isNewLine) {
			reflowParaWords2(
				remeasureFirstWord(rest), nextLineWidth, nextLineWidth,
				[], addLine(),
				paraIndent, fontSize, textScale
			)
		} else reflowParaWords2(
			restGroups, availableWidth, remaining - groupWidth,
			arrayPush(currentWordGroups, group), result,
			paraIndent, fontSize, textScale
		);
	}
}

// This function gets the form and decides, should the next form kept together in the same line or should it be placed on the next line
keepFormTogether(form : Form) -> bool {
	switch (form) {
		Empty() : true;
		Text(t, __) : t != " " && t != "­";  // Space or soft hyphen.
		Alpha(__, f) : keepFormTogether(f);
		Size2(__, f) : keepFormTogether(f);
		Access(__, f) : keepFormTogether(f);
		Rotate(__, f) : keepFormTogether(f);
		Cursor(__, f) : keepFormTogether(f);
		Visible(__, f) : keepFormTogether(f);
		Inspect(__, f) : keepFormTogether(f);
		Baseline(__, f) : keepFormTogether(f);
		Scale(__, __, f) : keepFormTogether(f);
		Mask2(f, __, __) : keepFormTogether(f);
		SetPending(__, f) : keepFormTogether(f);
		Available2(__, f) : keepFormTogether(f);
		Filter2(__, f, __) : keepFormTogether(f);
		Interactive(__, f) : keepFormTogether(f);
		Constructor(f, __) : keepFormTogether(f);
		Create2(current, fn) : keepFormTogether(if (^current != Empty()) ^current else fn());
		Translate(__, __, f) : keepFormTogether(f);
		Mutable2(f, __) : keepFormTogether(getValue(f));
		Border(__, __, __, __, f) : keepFormTogether(f);
		Crop2(__, __, __, __, f, __) : keepFormTogether(f);
		Group(fs) : any(map(fs, \f -> keepFormTogether(f)));
		Switch(i, fs) : keepFormTogether(if (getValue(i) < length(fs)) fs[getValue(i)] else { println("STRANGE CASE"); Empty(); });
		Grid(__) : false; // Unlikely to be a part of a word. But maybe should go recursive.
		Picture(__, __) : false;
		Graphics(__, __) : false;
		Video(__, __, __, __) : false;
		TextInput(__, __, __) : false;
		Camera(__, __, __, __) : false;
		RealHTML2(__, __, __) : false;
		ControlFocus(__, f) : keepFormTogether(f);
		FullWindow(__, f) : keepFormTogether(f);
		FullScreen(__, f) : keepFormTogether(f);
		NativeForm(__, __, __, __) : false;
		DynamicGroup2(__, __, __, __) : false; // Placeholder
	};
}

// renders lines and returns resulting forms along with their tight width at the rendering time
renderParaLines(
	availableWidth : double,
	lines : ParaLinesInfos,
	tightWidth : bool,
	alignment : ParaLineAlignment,
	interlineSpacing : double,
	topLineBaseline : bool,
	styleTree : Tree<int, [ParaElementInteractiveStyle]>,
	rtl : bool,
	isMarked : bool,
	interLineHighlighting : bool,
	renderedLinesInfoM : Maybe<DynamicBehaviour<[RenderedLinesInfo]>>
) -> Form {
	lasti = length(lines.lines) - 1;
	a : ParaLineAcc = foldi(lines.lines, ParaLineAcc(EmptyList(), 0.0, 0.0, 0.0), \i : int, acc : ParaLineAcc, lineInfo : ParaLineInfo -> {
		// TODO: IF the line ends with NewLine (which we do not track here), we should consider it a last line and not justify
		lastLine = i == lasti;
		// On the last line, we do not justify.
		// Also if the line is single with TightWidth, any alignment is equal to StartAlign
		lineAlignment =
			if (alignment == Justify() && lastLine) {
				StartAlign()
			} else {
				alignment;
			}
		f = RenderLine(
			acc.y, lineInfo,
			availableWidth, lineAlignment,
			i, styleTree, rtl, isMarked,
			if (interLineHighlighting) {
				if (i == 0) 0. else - interlineSpacing / 2.0
			} else 0.0,
			if (interLineHighlighting){
				if (lastLine || i == 0) interlineSpacing / 2.0 else interlineSpacing
			} else 0.0
		);
		ParaLineAcc(
			Cons(Size2(const(zeroWH), f.form), acc.lines),
			acc.y + f.height + if (lastLine) 0. else interlineSpacing,
			if (i == 0 || !topLineBaseline) f.baseline else acc.baseline,
			if (acc.maxLineWidth < f.width) f.width else acc.maxLineWidth
		);
	});

	maybeApply(
		renderedLinesInfoM,
		\renderedLinesInfo -> {
			nextDistinct(renderedLinesInfo, map(lines.lines, \info : ParaLineInfo -> RenderedLinesInfo(info.lineHeight, info.lineAsc)));
		}
	);

	Baseline(const(a.baseline), Size2(const(WidthHeight(if (tightWidth) a.maxLineWidth else max(availableWidth, lines.maxLineWidth), a.y)),
		Group(list2array(a.lines))
	))
}

getOptimizedLine(words : [ParaWord], alignment : ParaLineAlignment, availableWidth : double, indent : double, lastLine : bool) -> [OptimizedLineElement]{
	optimizeLine(words, alignment, availableWidth, indent, lastLine);
}

calcParaLineAlignmentOffset(slack : double, lineIndent : double, rtl : bool, alignment : ParaLineAlignment) -> double {
	startOffset = if (rtl) max(slack, 0.) else 0.;
	endOffset = if (rtl) 0. else max(0., slack);
	switch (alignment : ParaLineAlignment) {
		LeftAlign() : if (rtl) endOffset else startOffset;
		RightAlign() : if (rtl) startOffset else endOffset;
		CenterAlign() : max(0.0, slack / 2.0);
		StartAlign() : startOffset;
		EndAlign() : endOffset;
		Justify() : 0.0;
	} + (if (rtl) 0. else lineIndent);
}

wordIds = ref 0;
useNextWordId = ref false;

// Aligns all elements to the baseline, as well as calculates the height and the baseline
// Send out the result, width, height
RenderLine(
	y : double,
	info : ParaLineInfo,
	width : double,
	alignment : ParaLineAlignment,
	lineNumber : int,
	interactiveStyles : Tree<int, [ParaElementInteractiveStyle]>,
	rtl : bool,
	isMarked : bool,
	highLightOffset : double,
	interlineSpacing : double,
) -> ParaLineResult {
	remaining = width - info.lineWidth;
	alignmentOffset = ref calcParaLineAlignmentOffset(remaining, info.lineIndent, rtl, if (newJustifyEnabled && alignment == Justify()) StartAlign() else alignment);

	wordsCount = length(info.optimizedLine) - 1;

	// Inter-word spacing for justification
	interWord = if (alignment == Justify() && length(info.optimizedLine) > 1 && !newJustifyEnabled) {
		nSpaces = foldi(info.optimizedLine, 0 , \i, acc, elem : OptimizedLineElement -> {
				lastWord = i == wordsCount;
				if (!lastWord && isSpaceForm(elem.f)) acc + 1 else acc
		});
		if (nSpaces > 0) remaining / i2d(nSpaces) else 0.0
	} else 0.0;  // Inter-word spacing via CSS instead because mobiles are too slow.
	justifyExtraWidth = ref 0.0;

	// The width and the individual forms
	lo : [Form] = filtermapi(info.optimizedLine, \i : int, elem : OptimizedLineElement -> {
		f = elem.f;
		m = fgetValue(elem.metrics);
		wordIds := ^wordIds + 1;
		wordId = makeWordId(^wordIds);

		setNextWidgetId = \ -> {
			nextDistinct(elem.nextWidgetId, Some(^wordIds + 1));
			useNextWordId := true;
		};

		isSuperscript = intStyleContains(ParaElementSuperscript(), elem, interactiveStyles);
		isSubscript = intStyleContains(ParaElementSubscript(), elem, interactiveStyles);

		dy = if (isSuperscript) {
			prevElHeight = prevElementHeight(info.optimizedLine, interactiveStyles, i - 1);
			if (prevElHeight == 0.0) -1.0 else info.lineAsc - m.baseline - prevElHeight * 0.25
		} else info.lineAsc - m.baseline / (if (isSubscript) 2.0 else 1.0);

		addWordId = \fm -> {
			if (^useNextWordId) {
				useNextWordId := false;
				Access([AccessAttribute("id", const(wordId))], fm);
			} else fm
		}

		lastWord = i == wordsCount;
		isSpace = !newJustifyEnabled && !lastWord && isSpaceForm(elem.f);

		applyStylesAndOffset = \form : Form ->
			form
			|> (\fm ->
				eitherFn(
					elem.interactivityIdM,
					\id -> applyIntStylesAndHighlighting(
						fm,
						lookupTreeDef(interactiveStyles, id, []),
						^alignmentOffset,
						y,
						dy,
						m.width + if (isSpace) interWord else 0.0,
						info.lineHeight,
						highLightOffset,
						interlineSpacing,
						info.containsDynamicElement
					)
					|> addWordId,
					\ -> Translate(const(^alignmentOffset), const(y + dy), fm |> addWordId)
				)
			);

		justifyOffset = if (isMarked && i == 0 && lineNumber == 0) 0.0
		else if (isSpace) interWord else 0.0;

		r = switch (f : GhostForm) {
			Empty() : None();
			Ghost(xc, yc, fm) : {
				fo = applyStylesAndOffset(Empty());
				nextDistinct(xc, ^alignmentOffset);
				nextDistinct(yc, y + dy);
				setNextWidgetId();
				Some(fo);
			}
			InspectGhost(inspector, fm) : {
				fo = applyStylesAndOffset(Empty());
				nextDistinct(inspector.x, ^alignmentOffset);
				nextDistinct(inspector.y, y + dy);
				nextDistinct(inspector.size, WidthHeight(m.width, m.height));
				nextDistinct(inspector.lineHeight, info.lineHeight);
				nextDistinct(inspector.lineNumber, lineNumber);
				setNextWidgetId();
				Some(fo);
			}
			CoordinateInspectElement(inspector, fm) : {
				fo = applyStylesAndOffset(fm);
				nextDistinct(inspector.x, ^alignmentOffset);
				nextDistinct(inspector.y, y + dy);
				nextDistinct(inspector.size, WidthHeight(m.width, m.height));
				nextDistinct(inspector.lineHeight, info.lineHeight);
				nextDistinct(inspector.lineNumber, lineNumber);
				setNextWidgetId();
				Some(fo);
			}
			Form() : Some(applyStylesAndOffset(f))
		}

		if (m.width != 0.0 && !intStyleContains(IgnoreMetrics(), elem, interactiveStyles)) {
			justifyExtraWidth := ^justifyExtraWidth + justifyOffset;
			alignmentOffset := ^alignmentOffset + m.width + justifyOffset;
		}
		r
	});
	useNextWordId := false;
	ParaLineResult(
		Group(lo),
		info.lineWidth + ^justifyExtraWidth,
		info.lineHeight,
		y + info.lineAsc
	);
}

intStyleContains(style : ParaElementInteractiveStyle, elem : OptimizedLineElement, interactiveStyles : Tree<int, [ParaElementInteractiveStyle]>) -> bool {
	eitherMap(
		elem.interactivityIdM,
		\id -> containsStruct(
			lookupTreeDef(interactiveStyles, id, []),
			style
		),
		false
	)
}

prevElementHeight(optimizedLine : [OptimizedLineElement], interactiveStyles : Tree<int, [ParaElementInteractiveStyle]>, i : int) -> double {
	if (i < 0) 0.0
	else {
		isSuperscript = intStyleContains(ParaElementSuperscript(), optimizedLine[i], interactiveStyles);
		isSubscript = intStyleContains(ParaElementSubscript(), optimizedLine[i], interactiveStyles);
		if (isSuperscript || isSubscript) {
			prevElementHeight(optimizedLine, interactiveStyles, i - 1)
		} else {
			fgetValue(optimizedLine[i].metrics).height
		}
	}
}

applyIntStylesAndHighlighting(
	form : Form,
	styles : [ParaElementInteractiveStyle],
	xOffset : double,
	yOffset : double,
	baselineShift : double,
	width : double,
	height : double,
	highLightOffset : double,
	interlineSpacing : double,
	containsDynamicElement : bool
) -> Form {
	getStyleForBackgroundFromCharStyle = \s -> eitherMap(
		tryExtractStruct(s, BackgroundFill(white)),
		\backFill -> [
			Fill(backFill.color),
			FillOpacity(extractStruct(s, BackgroundFillOpacity(1.0)).opacity)
		],
		[]
	);

	makeBackRect = \defStyle, dynStyle -> {
		rectStyle =
			replaceStructMany(
				getStyleForBackgroundFromCharStyle(defStyle),
				getStyleForBackgroundFromCharStyle(dynStyle)
			);
		if (rectStyle == []) Empty()
		else Rectangle(
			width,
			height + interlineSpacing + 0.1,
			rectStyle
		);
	}

	dynamicHighlightStyleBM = tryExtractStruct(styles, DynamicHighlightStyle(make([]), false));

	textAndBackPair = makeTextAndBackPair(form, dynamicHighlightStyleBM, makeBackRect);

	modifiedForm = applyListenersAndModifiers(styles, textAndBackPair.first);

	Translate(const(xOffset), const(yOffset + baselineShift), modifiedForm)
	|> (\f ->
		switch(textAndBackPair.second) {
			Empty() : f;
			default : {
				textAndBack = Group([
					Translate(const(xOffset), const(yOffset + highLightOffset), textAndBackPair.second),
					f
				]);
				if (containsDynamicElement) Access([AccessRole("group")], textAndBack) else textAndBack
			}
		}
	)
}

makeTextAndBackPair(
	form : Form,
	dynamicHighlightStyleBM : Maybe<DynamicHighlightStyle>,
	makeBackRect : ([CharacterStyle], [CharacterStyle]) -> Form
) -> Pair<Form, Form> {
	switch(form) {
		Access(props, f) : {
			p = makeTextAndBackPair(f, dynamicHighlightStyleBM, makeBackRect);
			Pair(Access(props, p.first), p.second)
		}
		Text(txt, txtStyle) : {

			makeTxt = \dynStyle -> Text(
				txt,
				removeAllStructsMany(
					replaceStructMany(txtStyle, dynStyle),
					[BackgroundFill(0), BackgroundFillOpacity(0.0)]
				)
			);

			// We draw custom highlighting to fix gaps for cases of justifying alignment
			// And to have more straight and pretty highlighting.
			eitherMap(
				dynamicHighlightStyleBM,
				\dynHlStyle -> Pair(
					Select(dynHlStyle.styleB, \chStyle -> makeTxt(chStyle)),
					Select(dynHlStyle.styleB, \chStyle -> makeBackRect(txtStyle, chStyle))
				),
				Pair(makeTxt([]), makeBackRect(txtStyle, []))
			)
		}
		default : Pair(
			form,
			eitherMap(
				dynamicHighlightStyleBM,
				\dynHlStyle -> Select(dynHlStyle.styleB, \chStyle -> makeBackRect([], chStyle)),
				Empty()
			)
		);
	}
}

applyListenersAndModifiers(styles : [ParaElementInteractiveStyle], form : Form) -> Form {
	if (form == Empty()) form else {
		formModifiersM = tryExtractStruct(styles, FormModifiers([]));
		modifiedForm = eitherMap(
			formModifiersM,
			\modifiers -> fold(modifiers.fns, form, \acc, fn -> fn(acc)),
			form
		);

		eventListenersM = tryExtractStruct(styles, EventListeners([]));
		eitherMap(
			eventListenersM,
			\el -> Interactive(el.listeners, modifiedForm),
			modifiedForm
		);
	}
}

applyBlockHighlighting(styles : [ParaElementInteractiveStyle], form : Form) -> Form {
	eitherMap(tryExtractStruct(styles, DynamicHighlightStyle(make([]), false)),
	\dynamicHlStyle -> {
		if (dynamicHlStyle.extraHighlight) {
			getStyleForRectFromCharStyle = \s -> eitherMap(
				tryExtractStruct(s, BackgroundFill(white)),
				\backFill -> [
					Stroke(backFill.color),
					StrokeOpacity(extractStruct(s, BackgroundFillOpacity(1.0)).opacity),
					StrokeWidth(3.0),
				],
				[]
			);

			makeRect = \dynStyle, wh : WidthHeight -> Rectangle(
				wh.width,
				wh.height,
				getStyleForRectFromCharStyle(dynStyle)
			);

			whB = makeWH();
			Group([
				Inspect([ISize(whB)], form),
				Select2(dynamicHlStyle.styleB, whB, makeRect),
			])
		} else form
	},
	form
	)
}

// Joins texts together to a single text element, along with the new metrics
dummyTextWidthInspector = TextWidthInspector(make(0.0));

optimizeLine(words : [ParaWord], alignment: ParaLineAlignment, availableWidth : double, indent : double, lastLine : bool) -> [OptimizedLineElement] {
	wordsCount = length(words) - 1;

	wordSpacing = if (newJustifyEnabled && alignment == Justify() && !lastLine) {
		spacesAndWordsWidth : Pair<int, double> = foldi(words, Pair(0, indent), \i, acc : Pair<int, double>, w -> {
			lastWord = i == wordsCount;
			defValue = \ -> Pair(acc.first, acc.second + fgetValue(w.metrics).width);
			switch (w.word) {
				Space(spaceForm): {
					switch (spaceForm : GhostForm) {
						Text(text, __) : {
							if (text == " ") {
								if (lastWord) defValue() else Pair(acc.first + 1, acc.second + fgetValue(w.metrics).width)
							} else defValue()
						};
						default: defValue()
					}
				};
				default: defValue();
			}
		});
		if (spacesAndWordsWidth.first > 0) {
			(availableWidth - spacesAndWordsWidth.second) / i2d(spacesAndWordsWidth.first);
		} else 0.0
	} else 0.0;

	foldi(words, makeList(), \i, acc : List<OptimizedLineElement>, word : ParaWord -> {
		f = word.form;
		w = word.word;
		metrics = word.metrics;
		intIdM = word.interactivityIdM;
		nextWidgetId = word.nextWidgetId;
		lastWord = i == wordsCount;
		switch(acc){
			EmptyList() : {
				formMetrics = switch (w) {
					Space(__): {
						if (newJustifyEnabled && alignment == Justify()) {
							switch (f : GhostForm) {
								Text(text, __) : {
									if (text == " ") {
										spaceSize = getStaticFormSize(f);
										FormMetrics(spaceSize with width = spaceSize.width + wordSpacing) |> const;
									} else metrics
								}
								default: metrics
							}
						} else metrics
					};
					default: metrics;
				};
				Cons(OptimizedLineElement(f, formMetrics, intIdM, nextWidgetId), acc)
			};
			Cons(p, tail_) : {
				switch (p.f : GhostForm) {
					Text(t1, s1) : {
						switch (f : GhostForm) {
							Text(t2, s2) : {
								join = if (use_dynamic_text_metrics) {
									joinText(
										t1,
										removeAllStructs(s1, dummyTextWidthInspector),
										t2,
										removeAllStructs(s1, dummyTextWidthInspector)
									);
								} else {
									joinText(t1, s1, t2, s2);
								}

								additionalWidth = if (newJustifyEnabled && alignment == Justify() && !lastWord) {
									switch (w) {
										Space(spaceForm): {
											switch (spaceForm : GhostForm) {
												Text(text, __) : {
													if (text == " ") {
														wordSpacing;
													} else 0.0
												};
												default: 0.0
											}
										}
										default: 0.0;
									};
								} else 0.0;

								if (length(join) == 1 && intIdM == p.interactivityIdM) {
									t : Form = join[0];

									jtf : Pair<Form, Transform<FormMetrics>> = if (use_dynamic_text_metrics) {
										getJoinableTextMetrics(t, false, false)
									} else {
										// TODO: Do not do this until at the end of the joining fest
										m = getStaticFormSize(t);
										optimizedLineElementMetrics : FormMetrics = fgetValue(p.metrics);
										wordWidth = getStaticFormSize(f).width;

										Pair(
											t,
											FormMetrics(m with
												width = optimizedLineElementMetrics.width + wordWidth + extractStruct(s2, LetterSpacing(0.0)).spacing + additionalWidth
											) |> const
										);
									}

									// Replace the last element with the newly joined
									Cons(
										OptimizedLineElement(jtf.first, jtf.second, intIdM, nextWidgetId),
										tail_
									);
								} else {
									fMetrics : FormMetrics = fgetValue(metrics);
									Cons(
										OptimizedLineElement(
											f,
											FormMetrics(fMetrics with
												width = fMetrics.width + additionalWidth
											) |> const,
											intIdM,
											nextWidgetId
										),
										acc
									);
								};
							}
							default : {
								Cons(OptimizedLineElement(f, metrics, intIdM, nextWidgetId), acc);
							}
						}
					}
					default : Cons(OptimizedLineElement(f, metrics, intIdM, nextWidgetId), acc);
				}
			}
		}
	}) |> list2array
	|> (\arr : [OptimizedLineElement] -> {
		if (wordSpacing != 0.0) {
			wordSpacingStyle = WordSpacing(const(wordSpacing));
			map(arr, \e -> {
				switch (e.f : GhostForm) {
					Text(t, s): {
						fMetrics : FormMetrics = fgetValue(e.metrics);
						OptimizedLineElement(
							e with
							f = Text(t, arrayPush(s, wordSpacingStyle)),
							metrics = FormMetrics(fMetrics with
								width = roundTo(fMetrics.width, 0.01)
							) |> const
						)
					}
					default: e;
				}
			});
		} else {
			arr
		}
	})
}

isWordEmpty(w : ParaWord) -> bool {
	switch(w.word) {
		Text(t, __) : t == "";
		default : false;
	}
}

getWordText(w : ParaWord) -> string {
	switch(w.word) {
		Text(t, __) : t;
		Empty() : switch (w.form) {
			InspectGhost(__, form) : getFormText(form);
			Ghost(__, __, form) : getFormText(form);
			default : "";
		};
		default : "";
	}
}

setWordText(w : ParaWord, t : string) -> ParaWord {
	switch(w.word) {
		Text(__, s) : ParaWord(w with
			word = Text(t, s),
			form = switch(w.form) {
				CoordinateInspectElement(inspector, form) : CoordinateInspectElement(
					inspector,
					Text(t, getFormTextStyle(form))
				);
				Text(__, fs) : Text(t, fs);
				default : w.form;
			}
		);
		default : w;
	};
}

setWordRTL(w : ParaWord, rtl : bool) -> ParaWord {
	switch(w.word) {
		Text(t, s) : ParaWord(w with
			word = Text(t, s),
			form = switch(w.form) {
				CoordinateInspectElement(inspector, form) : CoordinateInspectElement(
					inspector,
					Text(t, replaceStruct(getFormTextStyle(form), SetRTL(rtl)))
				);
				Text(__, fs) : Text(t, replaceStruct(fs, SetRTL(rtl)));
				default : w.form;
			}
		);
		default : w;
	};
}

makeParaWordGroupForMath(w : ParaWord, s : string) -> ParaWordGroup {
	makeParaWordGroup = \word -> ParaWordGroup([word], ref zeroParaWordWidth);
	switch(w.word) {
		Text(__, st) :
			ParaWord(w with
				word = LinePart(Text(s, st), Empty(), Empty()),
				form = switch(w.form) {
					CoordinateInspectElement(inspector, form) : CoordinateInspectElement(
						inspector,
						Text(s, getFormTextStyle(form))
					);
					Text(__, fs) : Text(s, fs);
					default : w.form;
				},
				interactivityIdM = None()
			) |> makeParaWordGroup;
		LinePart(sf, mf, ef) : {
			swt = \f, t -> {
				newWord : ParaAtomic = setWordText(ParaWord(w with word = f), t).word;
				switch (newWord) {
					Form(): newWord;
					ParaWordGlued(__): Empty();
					TextElement(): Empty();
					InteractiveParaAtomic(__, __): Empty();
				}
			}
			ParaWord(w with word=LinePart(swt(sf, s), swt(mf, ""), swt(ef, ""))) |> makeParaWordGroup;
		};
		default : emptyParaWordGroup;
	};
}

makeStoryWidthManager(paragraphs : int, infoOnly : bool) -> StoryWidthManager {
	paragraphWidths = generate(0, paragraphs, \__ -> make(0.0));
	storyWidth = make(0.0);

	paragraphManagers = map(paragraphWidths, \pw -> ParagraphWidthManager(storyWidth, pw, infoOnly));
	StoryWidthManager(
		paragraphManagers,
		\i -> elementAt(paragraphManagers, i, dummyParagraphWidthManager),
		storyWidth,
		infoOnly,
		\ -> {
			if (infoOnly) {
				nop
			} else {
				maxWidth = arrayMaxu(paragraphWidths);
				uns = [
					maxWidth.second,
					connectDistinct(maxWidth.first, storyWidth)
				];
				\ -> applyall(uns);
			}
		}
	)
}

makeWordId(id : int) {
	"word_" + i2s(id);
}

// Not with others because referenced from flow9 repo.
isUrlParameterEscUnescHTMLTrue() -> bool {
	isUrlParameterTrue("753");
}

makeSkipOrderCheck(st : [CharacterStyle]) -> [CharacterStyle] {
	replaceStruct(st, SkipOrderCheck());
}

use_dynamic_text_metrics = isSafariBrowser() && !isUrlParameterFalse("dynamic_text_metrics");

paragraphElement2string(e : ParagraphElement) -> string {
	handleNonInteractive = \acc, nonintel -> switch (nonintel) {
		Text(text, __): acc + text;
		Space(__): acc + " ";
		Form(): acc + getFormText(nonintel);
		default: acc;
	};
	switch (e) {
		TextFragments(list): {
			foldList(list |> reverseList, "", \acc2, e2 -> {
				switch (e2) {
					WordWrapInteractive(e3, __): handleNonInteractive(acc2, e3);
					NonInteractiveWrapElement(): handleNonInteractive(acc2, e2);
				}
			})
		}
		Form(): getFormText(e);
		GlueFragments(): "";
	}
}

wigiTraceLevel : ref int = ref 0;

dummyWigiTraceApi = WigiTraceApi(nop1, nop1, nop1, nop1, nop, nop);

makeWigiTraceIdFn(words : (() -> [?]), word2string : (?) -> string) -> (() -> string) {
	\-> fold(words(), "", \acc, w -> acc + word2string(w))
}

makeWigiTraceGeneric(functionName : string, idFn : () -> string) -> WigiTraceApi {
	if (isUrlParameterTrue("trace_wigi_render")) {
		traceId = "[" + idFn() + "] " + functionName + ": ";
		traceFn = \messageFn -> println(strRepeat(" ", 2 * ^wigiTraceLevel) + traceId + messageFn());
		nestFn = \-> wigiTraceLevel := ^wigiTraceLevel + 1;
		unnestFn = \-> if (^wigiTraceLevel > 0) wigiTraceLevel := ^wigiTraceLevel - 1;
		WigiTraceApi(
			traceFn,
			\messageFn -> { traceFn(messageFn); nestFn(); },
			\messageFn -> { traceFn(messageFn); unnestFn(); },
			\messageFn -> { unnestFn(); traceFn(messageFn); },
			nestFn,
			unnestFn
		)
	} else {
		dummyWigiTraceApi
	}
}

makeWigiTrace_Form(functionName : string, words : [ParagraphElement]) -> WigiTraceApi {
	makeWigiTraceGeneric(functionName, makeWigiTraceIdFn(\ -> words, paragraphElement2string))
}
