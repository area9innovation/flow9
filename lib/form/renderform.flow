// Â© Copyright 2011 Area9 Technologies.

import transforms;
import form/optimizeform;
import sys/fullscreen;
import formats/html/html2text;
import sys/interactive;

export {
	// Render the given form on the screen
	render : (form : Form) -> () -> void;

	renderForm(rform : Form, available : Behaviour<WidthHeight>, zorder : [int], tabOrder: [int]) -> RenderResult;

	preloadAndCachePicture(url : string, onError : (string) -> void) -> void; //To start picture download at moment of Form creation

	// Counter for pictures, videos & ActiveArt forms which are in rendering process state
	loadingContentFilesCount : DynamicBehaviour<int> = make(0);
	increaseFilesCount(filesCount : DynamicBehaviour<int>) -> void;
	decreaseFilesCount(alreadyDecreased : DynamicBehaviour<bool>, filesCount : DynamicBehaviour<int>) -> void;

	getDontCacheSuffix() -> string;
	resetFocus : () -> void;

	// A transform that helps reduce the amount of size changes
	whenSizeChanged(b : Behaviour<WidthHeight>) -> Behaviour<WidthHeight>;
	whenSizeChangedu(b : Behaviour<WidthHeight>) -> Pair<Behaviour<WidthHeight>, () -> void>;

	zeroSize : ConstBehaviour<WidthHeight>;

	//must be in target.flow, but need access to getStage_, so placed here
	isPhoneScreen : () -> bool;
	isPhoneDiagonal(width : double, height : double, ppi : int) -> bool;

	isPicturesDownloadingEnabled() -> bool;


	ScreenOrientation ::= Portrait, Landscape, NoScreenOrientation;
		Portrait();
		Landscape();
		NoScreenOrientation();

	setInterfaceOrientation : (o : ScreenOrientation) -> void;

	accessibilityEnabled : ref bool = ref false;

	globalRenderCount : ref int = ref 0;

	downloadPictures : bool = !isUrlParameterFalse("download_pictures");
	showRedraw : bool = !js && isUrlParameterTrue("redraw");

	makeGlobalCursorListeners(shape : CursorShape2, zorder : Transform<[int]>) -> Pair<[EventHandler], () -> void>;

	getCursorShapeName(cursorShape : CursorShape) -> string;

	setForceZorder(zorder : int) -> void;
	resetForceZorder() -> void;
}

// Automatic Z-order todo:
// - Keep all render's in a DList to know what starting z-order we should use
// - Get rid of all explicit z-order code

forceZorder : ref Maybe<int> = ref None();

setForceZorder(zorder : int) -> void {
	forceZorder := Some(zorder);
}

resetForceZorder() -> void {
	forceZorder := None();
}

resetFocus() -> void {
	if (flash) {
		setFocus(getStage(), true);
	}
}


allClipCapabilities : ClipCapabilities = ClipCapabilities(true, true, true, true, true);

zeroSize = const(zeroWH);

emptyRenderResult : RenderResult = RenderResult([], zeroSize, const(0.0), const(0), [], allClipCapabilities);

isPicturesDownloadingEnabled() {
	downloadPictures
}

isPhoneScreen() {
	if (cgi) {
		false;
	} else {
		phoneScreen = isPhoneDiagonal(getStageWidth(), getStageHeight(), screenDPI) && mobile;
		isUrlParameterTrue("mobile") || (phoneScreen && !isUrlParameterFalse("mobile"))
	}
}

isPhoneDiagonal(width : double, height : double, ppi : int) -> bool {
	screenDiagonal = sqrt(dpow(width, 2.) + dpow(height, 2.)) / i2d(ppi);
	screenDiagonal < 5.9
}

// What do all these result share in capabilities?
sharedCapabilities(rs : [RenderResult]) -> ClipCapabilities {
	moveable = forall(rs, \r : RenderResult -> r.capabilities.move);
	scalable = forall(rs, \r : RenderResult -> r.capabilities.scale);
	alphable = forall(rs, \r : RenderResult -> r.capabilities.alpha);
	single = length(rs) == 1;
	ClipCapabilities(
		moveable,
		single,	// Filters do not commute
		single, // Interactions do not commute
		scalable,
		alphable,
	);
}

// maps AccessGroup's groupId -> Pair<groupTabOrder, [Child TabOrders]>
groupTabOrders : ref Tree<string, Pair<[int], [[int]]>> = ref makeTree();

// Top-level method to render a form on the entire screen
render(form : Form) -> () -> void {
	available = make(zeroWH);
	renCt = ^globalRenderCount;

	d1 = monitorResize(available);
	d2 = optimizeAndRenderForm(mainRenderClip(), form, available, [renCt], [renCt]);

	globalRenderCount := ^globalRenderCount + 1;
	disps = d2.disposers;
	//println(length(disps));
	\ -> { d1(); applyall(disps); if (renCt == ^globalRenderCount - 1) globalRenderCount := renCt};
}

monitorResize(awh : DynamicBehaviour<WidthHeight>) -> () -> void {
	enableResize();
	sendStageSize = \ -> {
		nextDistinct(awh, WidthHeight(getStageWidth(), getStageHeight()));
	};

	// We have to explicitly hold on to this function to keep it alive
	r = ref Some(sendStageSize);
	disposer = addEventListener(currentClip(), "resize", sendStageSize);
	// Send our size
	sendStageSize();
	\ -> { r := Some(nop); disposer(); }
}

optimizeAndRenderForm(parent : native, form : Form, available : Behaviour<WidthHeight>, zorder : [int], tabOrder: [int]) -> RenderResult {
	opfm = optimizeForm(form);
	r = renderForm(opfm, available, zorder, tabOrder);
	attachChildren(parent, r.clips, r.widthHeight, r.baseline, r.pending, r.disposers, r.capabilities);
	// Refresh stage here if required
}

// This dance concerns how to hook up any clips from a child to ourselves
attachChildren(clip : native, children : [native], widthHeight : Behaviour<WidthHeight>, baseline : Behaviour<double>,
			pending : Behaviour<int>, disposers : [() -> void], cap : ClipCapabilities) -> RenderResult {
	iter(children, \c -> {
		addChild(clip, c);
	});
	RenderResult([clip], widthHeight, baseline, pending, concat([\ -> {
			iter(children, \c -> {
				removeChild(clip, c);
			})
		}], disposers)
	, cap);
}

attachChildAndCapability(
		form : Form, d : RenderResult, hasCapability : bool,
		cap : ClipCapabilities, fn : (native) -> [() -> void]
) -> RenderResult {
	if (length(d.clips) > 0) {
		if (hasCapability) {
			disposers = concat(concatA(map(d.clips, fn)), d.disposers);
			RenderResult(d.clips, d.widthHeight, d.baseline, d.pending, disposers, cap);
		} else {
			c = makeClip();
			setClipDebugInfo(c, "form", form);
			u = fn(c);
			attachChildren(
				c, d.clips, d.widthHeight, d.baseline, d.pending,
				concat3(d.disposers, u, [\ -> { deleteNative(c); }]),
				cap
			);
		}
	} else {
		RenderResult(d.clips, d.widthHeight, d.baseline, d.pending, d.disposers, cap);
	}
}

whenSizeChanged(b : Behaviour<WidthHeight>) {
	filterWithLast(b, \l, n -> {
		abs(l.width - n.width) > 0.5 || abs(l.height - n.height) > 0.5
	});
}

whenSizeChangedu(b : Behaviour<WidthHeight>) {
	filterWithLastu(b, \l, n -> {
		abs(l.width - n.width) > 0.5 || abs(l.height - n.height) > 0.5
	});
}

// Init gesture handlers for stage
resetGestureCapture() -> void { pinchCapture := None(); swipeCapture := None(); panCapture := None(); }
intGestureStateToFlowGestureState(state : int) -> GestureState {
	if (state == 1) GestureStateProgress() else if (state == 0) GestureStateBegin() else GestureStateEnd();
}
stagePanDisposer: () -> void = addGestureListener("pan", \state, x, y, dx, dy -> {
	ret = switch(^panCapture) {
		Some(v): v(intGestureStateToFlowGestureState(state), x, y, dx, dy);
		None(): false
	};
	if (state == 2 /* ended */) resetGestureCapture(); // No mouse up for pan
	ret
});
stagePinchDisposer : () -> void = addGestureListener("pinch", \state, x, y, scale, p4 -> {
	ret = switch(^pinchCapture) {
		Some(v): v(intGestureStateToFlowGestureState(state), x, y, scale, p4);
		None(): false
	};
	if (state == 2 /* ended */) resetGestureCapture(); // No mouse up for pinch
	ret
});

increaseFilesCount(filesCount) {
	next(filesCount, getValue(filesCount) + 1)
}
decreaseFilesCount(alreadyDecreased, filesCount) {
	if (!getValue(alreadyDecreased)) {
		//LSTSBD-696 Changed order of lines to prevent calls caused by subscribers of filesCount enter the same function with flag not set.
		next(alreadyDecreased, true);
		next(filesCount, max(getValue(filesCount) - 1, 0));
	}
}

// Render a form with the given space available
renderForm(rform : Form, available : Behaviour<WidthHeight>, zorder : [int], tabOrder: [int]) -> RenderResult {
	res = switch (rform : Form) {
	Empty(): {
		emptyRenderResult;
	}
	Constructor(form, construct): {
		uns = construct();
		d = renderForm(form, available, zorder, tabOrder);
		RenderResult(d.clips, d.widthHeight, d.baseline, d.pending, arrayPush(d.disposers, uns), d.capabilities);
	}
	Create2(current, fn): {
		current := fn();
		d = renderForm(^current, available, zorder, tabOrder);
		RenderResult(d.clips, d.widthHeight, d.baseline, d.pending, d.disposers, d.capabilities);
	}
	Text(text, style): {
		if (!js && extractStruct(style, EscapeHTML(false)).escape) {
			renderText(text |> escapeHtml, style, available, zorder, tabOrder)
		} else if (js && getRendererType() != "html" && !extractStruct(style, EscapeHTML(false)).escape) {
			texts = html2text(text, style);

			if (length(texts) == 0) {
				renderText("", style, available, zorder, tabOrder);
			} else if (length(texts) == 1) {
				renderText(texts[0].text, texts[0].style, available, zorder, tabOrder);
			} else {
				renderTexts(texts, available, zorder, tabOrder);
			}
		} else {
			renderText(text, style, available, zorder, tabOrder)
		}
	}
	Picture(url_, style): {
		if (downloadPictures && strlen(url_) > 0) {
			cache = ref true;
			onlydl = ref false;
			errhndlr = ref nop1;
			onWarning = ref nop1;
			onLoaded = ref nop;
			realSizeFn = ref nop1;
			picAltText = ref "";
			headers = ref [];
			iter(style, \s -> switch(s : PictureStyle) {
				DontCache(): cache := false;
				OnlyDownloadToCache(): onlydl := true;
				OnLoadingError(fn): errhndlr := fn;
				OnWarning(fn): onWarning := fn;
				OnLoaded(fn) : onLoaded := {
					prevOnLoaded = ^onLoaded;
					\->{
						prevOnLoaded();
						fn();
					}
				};
				InspectRealSize(fn): realSizeFn := fn;
				AltText(text): picAltText := text;
				UseCrossOrigin(__) : {}
				ReferrerPolicy(__) : {}
				RequestHeaders(hs) : headers := concat(^headers, map(hs, \h -> [h.key, h.value]));
			});

			widthHeight = make(zeroWH);
			baseline = make(0.0);
			pending = make(1);
			alreadyDecreased = make(false); //Let's use separate variable as pending mcould be updated outside the scope
			increaseFilesCount(loadingContentFilesCount);
			url = applyMediaPathMapping(url_);
			picture = makePicture(addServerPathIfRelative(url), ^cache, \w, h -> {
				CachedPicturesSizes := setTree(^CachedPicturesSizes, url, WidthHeight(w, h));
				nextDistinct(widthHeight, WidthHeight(w, h));
				nextDistinct(baseline, h);
				decreaseFilesCount(alreadyDecreased, loadingContentFilesCount);
				nextDistinct(pending, 0);
				^realSizeFn(WidthHeight(w, h));
				^onLoaded();
			}, \e -> {
				if (startsWith(e, "Warning")) {
					^onWarning(e)
				} else {
					CachedPicturesSizes := setTree(^CachedPicturesSizes, url, zeroWH);
					^errhndlr(e);
					decreaseFilesCount(alreadyDecreased, loadingContentFilesCount);
					nextDistinct(pending, 0);
					if (e != "") {
						println(e);
					}
				}
			}, ^onlydl, ^picAltText, ^headers);

			setPictureUseCrossOrigin(picture, extractStruct(style, UseCrossOrigin(false)).useCrossOrigin);
			setPictureReferrerPolicy(picture, extractStruct(style, ReferrerPolicy("")).referrerpolicy);

			RenderResult(
				[picture], widthHeight, baseline, pending,
				[\ -> {
					//Decrease loading files count if Form is closed until onOK or onError has happened.
					decreaseFilesCount(alreadyDecreased, loadingContentFilesCount); //deleteNative(picture);
				}],
				ClipCapabilities(true, false, false, false, false)
			)
		} else {
			// This branch is a special one. We need it only to increase LR/probe rendering speed
			// when regression testing tool is applied to really big product to look for memory leaks
			// [Investigate] do we need to call one of the following functions
			//onError = extractStruct(style, OnLoadingError(nop1)).fn;
			//onError("download_pictures=0");
			//onLoaded = extractStruct(style, OnLoaded(nop)).fn;
			//onLoaded();
			emptyRenderResult
		}
	}
	Camera(filename, parameters, listeners, controls): {
		vidWidth = ref 1;
		vidHeight = ref 1;
		camWidth = ref 640;
		camHeight = ref 480;
		camFps = ref 30.0;
		camID = ref 0;
		recordMode = ref 3;
		rtmpServerUri = ref "";
		errhndlr = ref \msg -> {};

		iter(parameters, \p -> switch (p : RecordParameter) {
			VideoSize(vw, vh) : {
				vidWidth := vw;
				vidHeight := vh;
			};
			RTMPServer(uri) : {
				rtmpServerUri := uri;
			};
			CameraSize(cw, ch, cf) : {
				camWidth := cw;
				camHeight := ch;
				camFps := cf;
			};
			CameraID(id) : {
				camID := id;
			};
			SoundOnly() : {
				recordMode := 1;
			};
			OnConnectingError(fn): {
				errhndlr := fn;
			};
		});

		pending = make(1);
		widthHeight = make(WidthHeight(i2d(^vidWidth), i2d(^vidHeight)));

		video = ref [];

		cbOnReadyForRecording = \ns -> {
			video := replace(^video, 0, ns);
			nextDistinct(pending, 0);
		};

		cbOnFailed = \msg -> {
			^errhndlr(msg);
			nextDistinct(pending, 0);
		};

		video := makeCamera(^rtmpServerUri, ^camID, ^camWidth, ^camHeight, ^camFps, ^vidWidth, ^vidHeight, ^recordMode, cbOnReadyForRecording, cbOnFailed);

		disposers2 = map(controls, \c -> switch (c: RecordControl) {
			Recording(status): {
				subscribe2(status, \record -> {
					if (record) {
						startRecord(^video[0], filename, "record");
					} else {
						stopRecord(^video[0]);
					}
				});
			}
		});

		RenderResult([^video[1]], widthHeight, const(i2d(^vidHeight)), pending, [\ -> {
			applyall(disposers2);
			closeVideo(^video[0]);
			deleteNative(^video[0]);
		}], ClipCapabilities(true, false, false, false, false));
	}
	Graphics(path, style): {
		// Make a clip and get the graphics
		clip = makeClip();
		setClipDebugInfo(clip, "form", rform);
		size = renderGraphics(clip, path, style);

		widthHeight = const(size);
		RenderResult([clip], widthHeight, const(size.height), const(0), [\ -> { deleteNative(clip); }], allClipCapabilities);
	}
	Translate(x, y, form): {
		d = renderForm(form, available, zorder, tabOrder);
		fn = \clip -> {
			xsub = subscribe(x, \xc -> setClipX(clip, xc));
			ysub = subscribe(y, \yc -> setClipY(clip, yc));
			[ xsub, ysub ]
		};
		attachChildAndCapability(rform, d, d.capabilities.move,
			ClipCapabilities(false, d.capabilities.filters,
				d.capabilities.interactive,
				false, d.capabilities.alpha), fn
		);
	}
	Border(left, top, right, bottom, form): {
		awh = selectu(available, \wh -> WidthHeight(
			max(0.0, wh.width - (left + right)),
			max(0.0, wh.height - (top + bottom))
		));
		d = renderForm(form, awh.first, zorder, tabOrder);

		baseline = selectu(d.baseline, \b -> {
			b + top
		});

		widthHeight = selectu(d.widthHeight, \wh -> {
			WidthHeight(wh.width + left + right,
					wh.height + top + bottom)
		});

		fn = \clip -> {
			if (left != 0.0) {
				setClipX(clip, left);
			};
			if (top != 0.0) {
				setClipY(clip, top);
			};
			[];
		};

		attachChildAndCapability(
			rform,
			RenderResult(
				d.clips, widthHeight.first, baseline.first, d.pending,
				concat(d.disposers, [ awh.second, baseline.second, widthHeight.second ]),
				d.capabilities),
			d.capabilities.move,
			ClipCapabilities(false, d.capabilities.filters, d.capabilities.interactive, false, d.capabilities.alpha),
			fn
		);
	}
	Scale(x, y, form): {
		d = renderForm(form, available, zorder, tabOrder);
		widthHeight = select3u(d.widthHeight, x, y, \wh, xs, ys -> {
			WidthHeight(wh.width * xs, wh.height * ys)
		});
		baseline = select2u(d.baseline, y, \b, ys -> {
			b * ys
		});
		fn = \clip -> {
			xsub = subscribe(x, \xs -> setClipScaleX(clip, xs));
			ysub = subscribe(y, \ys -> setClipScaleY(clip, ys));
			[ xsub, ysub ];
		};
		attachChildAndCapability(
			rform,
			RenderResult(d.clips, widthHeight.first, baseline.first, d.pending,
				concat(d.disposers, [widthHeight.second, baseline.second]), d.capabilities),
			d.capabilities.scale,
			ClipCapabilities(d.capabilities.move, d.capabilities.filters, false, false, d.capabilities.alpha), fn
		);
	}
	Rotate(degrees, form): {
		d = renderForm(form, available, zorder, tabOrder);
		// TODO: Check if the child can be rotated
		clip = makeClip();
		setClipDebugInfo(clip, "form", rform);
		degsub = subscribe(degrees, \de -> setClipRotation(clip, de));
		attachChildren(clip, d.clips, d.widthHeight, d.baseline, d.pending, arrayPush(d.disposers, \ -> { degsub(); deleteNative(clip); }), d.capabilities);
	}
	Alpha(alpha, form): {
		d = renderForm(form, available, zorder, tabOrder);
		fn = \clip -> {
			[subscribe(alpha, \a -> setClipAlpha(clip, a))];
		};
		attachChildAndCapability(rform, d, d.capabilities.alpha,
			ClipCapabilities(d.capabilities.move, d.capabilities.filters, d.capabilities.interactive, d.capabilities.scale, false), fn
		);
	}
	Visible(visible, form): {
		d = renderForm(form, available, zorder, tabOrder);
		widthHeight = select2u(d.widthHeight, visible, \wh, v -> {
			if (v == 0) {
				zeroWH
			} else {
				wh
			}
		});
		baseline = select2u(d.baseline, visible, \b, v -> {
			if (v == 0) 0.0 else b;
		});
		fn = \clip -> {
			u = subscribe(visible, \v -> {
				setClipVisible(clip, v != 0)
			});
			[ u ]
		};
		attachChildAndCapability(
			rform,
			RenderResult(d.clips, widthHeight.first, baseline.first, d.pending,
				concat(d.disposers, [widthHeight.second, baseline.second]), d.capabilities),
				d.capabilities.alpha,
				ClipCapabilities(d.capabilities.move, d.capabilities.filters, d.capabilities.interactive, d.capabilities.scale, false), fn
		);
	}
	Available2(awh, form): {
		renderForm(form, awh, zorder, tabOrder);
	}
	Size2(wh, form): {
		d = renderForm(form, available, zorder, tabOrder);
		baseline = selectu(wh, \m -> m.height);
		RenderResult(d.clips, wh, baseline.first, d.pending, arrayPush(d.disposers, baseline.second), d.capabilities);
	}
	SetPending(pen, form): {
		d = renderForm(form, available, zorder, tabOrder);
		RenderResult(d.clips, d.widthHeight, d.baseline, pen, d.disposers, d.capabilities);
	}
	Baseline(baseline, form): {
		d = renderForm(form, available, zorder, tabOrder);
		RenderResult(d.clips, d.widthHeight, baseline, d.pending, d.disposers, d.capabilities);
	}
	Group(forms) : {
		results : [RenderResult] = mapi(forms, \i, form -> {
			renderForm(form, available, arrayPush(zorder, i), arrayPush(tabOrder, i));
		});
		whu = selectMergeu(map(results, \r -> r.widthHeight), zeroSize, \rwh, lwh -> {
			WidthHeight(max(rwh.width, lwh.width), max(rwh.height, lwh.height))
		});
		widthHeight = whenSizeChangedu(whu.first);

		baseline = arrayMaxu(map(results, \r -> r.baseline));

		pending = arrayISumu(map(results, \r -> r.pending));

		clips = concatA(map(results, \r -> r.clips));

		disposers = concatA(map(results, \r -> r.disposers));
		disps = concat(disposers, [whu.second, widthHeight.second, baseline.second, pending.second]);

		RenderResult(
			clips, widthHeight.first, baseline.first, pending.first,
			[\ -> applyall(disps)],
			sharedCapabilities(results)
		);
	}
	Grid(cells): {
		renderGrid(cells, zorder, tabOrder);
	}
	Mutable2(behaviour, stack): {
		widthHeight = make(zeroWH);
		baseline = make(0.0);
		// TODO: Maybe use an array of disposers here?
		old = ref nop;
		clip = makeClip();
		setClipCallstack(clip, stack);
		setClipDebugInfo(clip, "form", rform);
		nested = ref 0;
		pending = make(0);
		dodisplay = \form -> {
			// Block post-destroy calls
			if (^nested == 0) {
				nested := 1;
				^old();
				result = optimizeAndRenderForm(clip, form, available, zorder, tabOrder);
				cw = connectDistinct(result.widthHeight, widthHeight);
				cb = connectDistinct(result.baseline, baseline);
				cp = connectDistinct(result.pending, pending);

				// Useful hack to see rerender problems
				if (showRedraw) {
					g = getGraphics(clip);

					setLineStyle(g, 1.0, floor(random() * i2d(0xffffff)), 1.0);
					moveTo(g, 0.0, 0.0);
					lineTo(g, getValue(result.widthHeight).width, getValue(result.widthHeight).height);
					endFill(g);
				};

				disposers = result.disposers;
				// println(length(disposers));
				old := \ -> { cw(); cb(); cp(); applyall(disposers); };
				// If re-entrant destroy pending, finish it
				if (^nested < 0) {
					^old();
					deleteNative(clip);
				} else {
					nested := 0;
				}
			}
		};
		unsub = subscribe(behaviour, \form -> {
			// Postpone re-entrant updates if necessary
			if (^nested > 0)
				deferred(\ -> {
					impersonateCallstackItem(stack, 1);
					dodisplay(form);
				})
			else {
				impersonateCallstackItem(stack, 1);
				dodisplay(form);
			}
		});
		RenderResult([clip], widthHeight, baseline, pending, [\ -> {
			unsub();
			if (^nested == 0) {
				impersonateCallstackItem(stack, 1);
				^old();
				deleteNative(clip);
			};
			nested := -1;
		}], allClipCapabilities);
	}
	Switch(index, cases) : {
		selForm = \i -> elementAt(cases, i, Empty());
		if (isConst(index)) {
			renderForm(selForm(getValue(index)), available, zorder, tabOrder);
		} else {
			widthHeight = make(zeroWH);
			baseline = make(0.0);
			pending = make(0);
			// TODO: Consider to make this an array of disposers
			old = ref nop;
			oldCase = ref -1;
			clip = makeClip();
			setClipDebugInfo(clip, "form", rform);
			unsub = subscribe(index, \i -> {
				if (i != ^oldCase) {
					^old(); old := nop;
					newform = selForm(i);
					result = optimizeAndRenderForm(clip, newform, available, zorder, tabOrder);
					oldCase := i;
					cw = connect(result.widthHeight, widthHeight);
					cb = connect(result.baseline, baseline);
					cp = connect(result.pending, pending);
					disposers = result.disposers;
					old := \ -> { cw(); cp(); cb(); applyall(disposers); }
				}
			});
			RenderResult([clip], widthHeight, baseline, pending, [\ -> { unsub(); ^old(); deleteNative(clip); }], allClipCapabilities);
		}
	}

	FullWindow(fullscreen, form) : {
		resize = ref nop;
		availUns = ref nop;

		containerAvailable = make(zeroWH);
		containerWH = make(zeroWH);

		disconnectAvail = ref connect(available, containerAvailable);

		f = renderForm(form, containerAvailable, zorder, tabOrder);

		disconnectWH = ref connect(f.widthHeight, containerWH);
		tmpAvailable = ref getValue(containerAvailable);

		container = makeClip();

		uns = subscribe2(fullscreen, \fs -> {
			setFullWindowTarget(container);

			^disconnectWH();
			^disconnectAvail();
			^resize();
			^availUns();

			if (fs) {
				tmpAvailable := getValue(available);

				next(containerAvailable, WidthHeight(getStageWidth(), getStageHeight()));
				resize := monitorResize(containerAvailable);

				toggleFullWindow(fs);
			} else {
				toggleFullWindow(fs);
				next(cast(available : Behaviour -> DynamicBehaviour), ^tmpAvailable);
				disconnectAvail := connect(available, containerAvailable);
				disconnectWH := connect(f.widthHeight, containerWH);
			}
		});

		attachChildAndCapability(
			rform,
			attachChildren(
				container,
				f.clips,
				containerWH,
				f.baseline,
				f.pending,
				arrayPush(f.disposers, \ -> {
					^disconnectWH();
					^disconnectAvail();
					^resize();
					^availUns();
					uns();
					resetFullWindowTarget();
					deleteNative(container);
				}),
				f.capabilities
			),
			false,
			ClipCapabilities(false, false, false, false, false),
			\__ -> []
		);
	}

	FullScreen(fs, form): {
		fw = make(false);
		nextDistinct(fs, false);

		isCurrentClip = ref false;

		renderForm(Constructor(FullWindow(fw, form), \ -> {
			fsListener = onFullScreen(\change -> {
				if (^isCurrentClip) {
					if (!change) {
						nextDistinct(fs, change);
					};

					isCurrentClip := change;
					nextDistinct(fw, change);
				}
			});

			uns = subscribe2(fs, \fsc -> {
				isCurrentClip := true;

				toggleFullScreen(fsc);

				// For targets without fullscreen available
				if (targetNoFullscreen())
					nextDistinct(fw, fsc);
			});
			\ -> {
				fsListener();
				uns();
			}
		}), available, zorder, tabOrder);
	}

	Interactive(listeners, form) : {
		d = renderForm(form, available, zorder, tabOrder);

		clipalive = ref true;
		fn = \clip -> {
			stage = getStage();
			disposers = map(listeners, \l -> handleRealEvents(l, clip, clipalive, stage, zorder, true, false));
			arrayPush(disposers,
				\ -> { clipalive := false; }
			);
		};

		needMove = fold(listeners, false, \acc, l -> {
			switch (l : EventHandler) {
				MouseMove2(mfn): true;
				default: acc;
			}
		});

		attachChildAndCapability(rform, d,
			d.capabilities.interactive && (!needMove || d.capabilities.move),
			ClipCapabilities(d.capabilities.move, d.capabilities.filters, false, d.capabilities.scale, d.capabilities.alpha), fn
		);
	}

	TextInput(state, listeners, stateaccess): {
		fontStyle = fold(state, [], \acc, s ->
			switch (s : TextInputState) {
				Content(c, style): style;
				default: acc;
			}
		);
		textfield = makeTextfield(getMappedFontFace(fontStyle));
		setTextDirection(textfield, if (getDefaultRtl()) "rtl" else "ltr");
		setTextFieldCropWords(textfield, true);
		alive = ref true;
		// Convert to an input box
		setTextInput(textfield);

		if (^accessibilityEnabled) {
			setAccessAttributes(textfield, [["zorder", toString(zorder[0])]]);
		};

		h = getTextFieldHeight(textfield);

		widthHeight = make(WidthHeight(
			getTextFieldWidth(textfield), h
		));

		baseline = const(h); // Not accurate, but we can not ask for this from text inputs

		// Initial state
		state_disposers = ref [];
		defineTextInputState(textfield, state, widthHeight, state_disposers);

		getModel = \ -> {
			if (^alive) {
				TextInputModel(
					getContent(textfield) /* |> htmlUnescapeStr */,
					getTextFieldWidth(textfield),
					getTextFieldHeight(textfield),
					getCursorPosition(textfield),
					Selection(getSelectionStart(textfield), getSelectionEnd(textfield)),
					getFocus(textfield),
					Some(ScrollInfo(
						getScrollV(textfield),
						getBottomScrollV(textfield),
						getNumLines(textfield)
					))
				);
			} else {
				TextInputModel("", 0.0, 0.0, 0, Selection(-1, -1), false, None());
			}
		};
		sendModelEvent = \fn -> { \ -> fn(getModel()); };
		sendFocusEvent = idfn;

		// Events
		disposers1 = map(listeners, \l -> switch (l : TextInputEvent) {
			TextChange(fn): addEventListener(textfield, "change", sendModelEvent(fn));
			TextScroll(fn): addEventListener(textfield, "scroll", sendModelEvent(fn));
			FocusIn(fn): addEventListener(textfield, "focusin", sendFocusEvent(fn));
			FocusOut(fn): addEventListener(textfield, "focusout", sendFocusEvent(fn));
		});

		// State access
		disposers2 = map(stateaccess, \s -> switch (s : StateAccess) {
			StateChanger(stateBehaviour): {
				subscribe(stateBehaviour, \t -> {
					defineTextInputState(textfield, t, widthHeight, state_disposers);
				});
			}
			StateQuery(reader): {
				reader(getModel);
				nop;
			}
			StateQuery2(reader): {
				reader := getModel;
				nop;
			}
		});

		disposers3 = map(state, \s -> switch (s : TextInputState) {
			EatKeyDownOnFocus() : {
				fn2 = \handled, e -> {
					if (!handled) {
						// If we have focus, eat it
						getFocus(textfield)
					} else handled;
				};
				stage = getStage();
				handleZorderedKeyDownEvent(stage, zorder, fn2);
			}
			default: nop;
		});

		RenderResult([textfield], widthHeight, baseline, const(0), [\ -> {
			applyall(^state_disposers);
			applyall(disposers1);
			applyall(disposers2);
			applyall(disposers3);
			// If we have focus, be sure to move it to something else in order not to lose it
			if (flash && getFocus(textfield)) {
				setFocus(currentClip(), true);
			};
			deleteNative(textfield);
			alive := false;
		}], ClipCapabilities(true, false, true, false, false));
	}
	Video(filename, parameters, listeners, controls): {
		w = ref 0.;
		h = ref 0.;
		looping = ref false;

		startPaused = ref false;

		errhndlr = ref nop;

		startOffset = ref 0.0; // 0.0 is default; code for set and unset values are equal
		endOffset = ref 0.0; // 0.0 is default; special code for nonzero values

		headers = ref [];

		iter(parameters, \p -> switch (p : VideoParameter) {
			VideoSize(vw, vh) : {
				w := i2d(vw);
				h := i2d(vh);
			};
			LoopPlayback(): {
				looping := true;
			};
			NoAutoPlay(): {
				startPaused := true;
			};
			OnVideoLoadingError(fn): {
				errhndlr := fn;
			};
			StreamStartOffset(offset) : {
				startOffset := max(0.0, offset);
			};
			StreamEndOffset(offset) : {
				endOffset := max(0.0, offset);
			}
			RequestHeaders(hs) : {
				headers := concat(^headers, map(hs, \header -> [header.key, header.value]));
			}
		});

		widthHeight = make(WidthHeight(^w, ^h));
		baseline = make(^h);

		pending = make(1);
		alreadyDecreased = make(false); //Let's use separate variable as pending could be updated outside the scope
		if (!cpp) {
			//Loading error is not reported under cpp
			increaseFilesCount(loadingContentFilesCount);
		};
		duration = make(0.0);

		metricsFn = \vw, vh -> {
			nextDistinct(widthHeight, WidthHeight(vw, vh));
			nextDistinct(baseline, vh);

			if (!cpp) {
				decreaseFilesCount(alreadyDecreased, loadingContentFilesCount);
				nextDistinct(pending, 0);
			};
		};
		durationFn = \len -> {
			nextDistinct(duration, len);
			startOffset := min(^startOffset, len);
			if (^endOffset > 0.0) {
				endOffset := min(^endOffset, len);
			}
		};

		video = makeVideo(metricsFn, nop1, durationFn, nop1);

		// Events
		is_playing = make(false);
		cur_position = make(^startOffset);

		stopReplayHandler = \stopBeforeEnd -> {
			if (^looping) {
				if (!targetVideoLooping()) {
					seekVideo(video, ^startOffset);
					// js pauses video when it reaches end
					if (js && getValue(is_playing)) {
						resumeVideo(video);
					}
					nextDistinct(cur_position, ^startOffset);
				}
			} else {
				if (stopBeforeEnd) {
					pauseVideo(video);
				}
				nextDistinct(is_playing, false);
			}
		};

		if (^looping && targetVideoLooping())
			setVideoLooping(video, true);

		disposer = addStreamStatusListener(video, \code -> {
			if (code == "NetStream.Play.StreamNotFound") {
				^errhndlr();
				if (!cpp) {
					decreaseFilesCount(alreadyDecreased, loadingContentFilesCount);
					nextDistinct(pending, 0);
				}
			} else if (code == "NetStream.Play.Start") {
				if (!^startPaused)
					nextDistinct(is_playing, true);
			} else if (code == "NetStream.Play.Stop") {
				stopReplayHandler(false);
			} else if (code == "FlowGL.User.Pause") {
				nextDistinct(is_playing, false);
			} else if (code == "FlowGL.User.Resume") {
				nextDistinct(is_playing, true);
			} else if (code == "FlowGL.User.Stop") {
				nextDistinct(is_playing, false);
				nextDistinct(cur_position, ^startOffset);
			} else if (code == "FlowGL.User.Seek") {
				nextDistinct(cur_position, getVideoPosition(video));
			}
		});

		sizeDisposer =
			if (^w > 0. || ^h > 0.) {
				subscribe(widthHeight, \wh -> {
					if (^w > 0. && wh.width > 0.)
						setClipScaleX(video, ^w / wh.width);

					if (^h > 0. && wh.height > 0.)
						setClipScaleY(video, ^h / wh.height);
				});
			} else {
				nop;
			};

		position_timer_set = ref false;
		position_timer = ref 1000;

		disposers1 = map(listeners, \l -> switch (l : VideoStreamEvent) {
			SynchroCalls(onstart, onstop): {
				user_stop = ref false;
				addStreamStatusListener(video, \code -> {
					if (code == "NetStream.Play.StreamNotFound") {
						onstart();
						timer(1000, onstop); // emulate 1-second playback
					} else if (code == "NetStream.Play.Start") {
						onstart();
					} else if (code == "NetStream.Play.Stop") {
						if (!^looping) onstop();
					} else if (code == "FlowGL.User.Stop") {
						onstop();
						user_stop := true;
					} else if (code == "FlowGL.User.Resume") {
						if (^user_stop) onstart();
						user_stop := false;
					}
				});
			}
			StreamStatus(fn): addStreamStatusListener(video, fn);
			PlayerLength(bvr): connectDistinct(duration, bvr);
			PlayerIsPlaying(bvr): connect(is_playing, bvr);
			PlayerPosition(bvr,delay): {
				if (delay > 0) {
					position_timer_set := true;
					position_timer := min(^position_timer, delay);
				}
				connectDistinct(cur_position, bvr);
			}
			PlayerPosition2(bvr,tmr): {
				sub1 = subscribe2(tmr, \time -> {
					nextDistinct(cur_position, getVideoPosition(video));
				});
				sub2 = connectDistinct(cur_position, bvr);
				\ -> {
					sub1(); sub2();
				}
			}
		});

		kill_timer = ref nop;

		if (^position_timer_set || ^endOffset > 0.0) {
			tmr = controlledTimer(^position_timer, is_playing);
			sub1 = subscribe2(tmr.value, \time -> {
				position = getVideoPosition(video);
				nextDistinct(cur_position, position);
				if (^endOffset > 0.0 && position >= ^endOffset) {
					stopReplayHandler(true);
				}
			});
			kill_timer := \ -> { tmr.dispose(); sub1(); }
		}

		hasFullScreen = ref false;
		isFullscreen = make(false);

		mediaStream = ref None();


		disposers2 = map(controls, \c -> switch (c: VideoControl) {
			PlayerPause(isPaused): {
				startPaused := getValue(isPaused);
				unlink = bidirectionalLink(isPaused, is_playing, \paused -> !paused, \playing -> !playing);

				uns = subscribe2(isPaused, \isP -> {
					if (isP) {
						pauseVideo(video);
					} else {
						startPaused := false;
						resumeVideo(video);
					}
				});

				\ -> {
					unlink();
					uns();
				}
			}
			PlayerSeek(seekPosition): {
				subscribe2(seekPosition, \pos -> {
					seekVideo(video, pos);
					nextDistinct(cur_position, pos);
				});
			}
			PlayerVolume(vol): {
				subscribe(vol, \v -> setVideoVolume(video, v));
			}
			VideoFullScreen(stateInitializer): {
				hasFullScreen := true;
				stateInitializer(isFullscreen);
				uns1 = onFullScreen(\fs -> nextDistinct(isFullscreen, fs));
				uns2 = subscribe2(isFullscreen, \isF -> {
					setFullWindowTarget(video);
					toggleFullWindow(isF);
				});
				\ -> {
					uns1();
					uns2();
				}
			}
			VideoPlayerControls(vctl): {
				if (targetVideoControls()) setVideoControls(video, vctl);
				nop
			}
			VideoPlayerSubtitles(subtitle): {
				subscribe(subtitle, \info -> {
					if (targetVideoControls()) {
						definedTextStyle = getDefinedTextStyle(info.style);
						setVideoSubtitle(video, info.text, definedTextStyle.face.family, definedTextStyle.fontSize, definedTextStyle.face.weight,
							definedTextStyle.face.slope, definedTextStyle.fillColor, definedTextStyle.fillOpacity, definedTextStyle.letterSpacing,
							definedTextStyle.backgroundColor, definedTextStyle.backgroundOpacity, false, -1., false, -1., -1., true
						);
					}
				});
			}
			MediaStream(ms, __, __): {
				mediaStream := Some(ms);
				nop
			}
		});
		eitherFn(^mediaStream,
			\ms -> playVideoFromMediaStream(video, ms, ^startPaused),
			\ -> playVideo(video, addServerPathIfRelative(applyMediaPathMapping(filename)), ^startPaused, ^headers)
		);

		RenderResult([video], if (^w > 0. || ^h > 0.) const(WidthHeight(^w, ^h)) else widthHeight, if (^w > 0. || ^h > 0.) const(^h) else baseline, pending, [\ -> {
			if (!cpp) {
				//Decrease loading files count if Form is closed until onOK or onError has happened.
				decreaseFilesCount(alreadyDecreased, loadingContentFilesCount);
			}
			closeVideo(video);
			nextDistinct(is_playing, false);
			if (^hasFullScreen) resetFullWindowTarget();
			sizeDisposer();
			disposer();
			applyall(disposers1);
			^kill_timer();
			applyall(disposers2);
			deleteNative(video);
		}], ClipCapabilities(true, false, false, false, false));
	}
	Mask2(form, mask, stack): {
		clip = makeClip();
		setClipCallstack(clip, stack);
		setClipDebugInfo(clip, "form", rform);
		d1 = renderForm(form, available, zorder, tabOrder);
		r1 = attachChildren(clip, d1.clips, d1.widthHeight, d1.baseline, d1.pending, d1.disposers, d1.capabilities);

		maskClip = makeClip();
		setClipCallstack(maskClip, stack);
		setClipDebugInfo(maskClip, "form", rform);
		d2 = renderForm(mask, available, zorder, tabOrder);
		r2 = attachChildren(maskClip, d2.clips, d2.widthHeight, d2.baseline, d2.pending, d2.disposers, d2.capabilities);

		setClipMask(clip, maskClip);

		pu = select2u(r1.pending, r2.pending, \p1, p2 -> p1 + p2);

		pudis = pu.second;

		RenderResult([maskClip, clip], d2.widthHeight, d2.baseline, pu.first, concat3(r1.disposers, r2.disposers, [\ -> {
			pudis();
			deleteNative(clip);
			deleteNative(maskClip);
		}]), ClipCapabilities(true, false, false, true, false));
	}
	Filter2(filters, form, stack) : {
		d = renderForm(form, available, zorder, tabOrder);
		if (targetNoFilters()) {
			// Not supported
			d;
		} else if (getRendererType() == "html") {
			fold(filters, d, \acc, f -> {
				fn = \clip -> {
					fils = switch(f : Filters) {
						Bevel(params): {
							angle = ref 45.0;
							distance = ref 3.0;
							radius = ref 3.0;
							spread = ref 1.0;
							color1 = ref 0xffffff;
							alpha1 = ref 1.0;
							color2 = ref 0x000000;
							alpha2 = ref 1.0;
							inner = ref true;
							iter(params, \p -> switch (p : BevelParameter) {
								Placement(a, ds): { angle := a; distance := ds; }
								Radius(r): radius := r;
								Spread(s): spread := s;
								Color(c, a): { color1 := c; alpha1 := a; }
								ShadowColor(c, a): { color2 := c; alpha2 := a; }
								Inner(i): inner := i;
							});
							makeBevel(^angle, ^distance, ^radius, ^spread, ^color1, ^alpha1, ^color2, ^alpha2, ^inner) |> Some;
						}
						DropShadow(params): {
							angle = ref 45.0;
							distance = ref 4.0;
							radius = ref 4.0;
							spread = ref 1.0;
							color = ref 0x000000;
							alpha = ref 1.0;
							inner = ref false;
							useBoxShadow = ref false;
							iter(params, \p -> switch (p : DropShadowParameter) {
								Placement(a, ds): { angle := a; distance := ds; }
								Radius(r): radius := r;
								Spread(s): spread := s;
								Color(c, a): { color := c; alpha := a; }
								Inner(i): inner := i;
								UseBoxShadow(): useBoxShadow := true;
							});
							ds = makeDropShadow(^angle, ^distance, ^radius, ^spread, ^color, ^alpha, ^inner);
							if (^useBoxShadow) setUseBoxShadow(ds);
							Some(ds);
						}
						Blur(params): {
							radius = ref 3.0;
							spread = ref 1.0;
							iter(params, \p -> switch (p : BlurParameter) {
								Radius(r): radius := r;
								Spread(s): spread := s;
							});
							makeBlur(^radius, ^spread) |> Some;
						}
						BackdropBlur(params): {
							if (js) {
								spread = extractStruct(params, Spread(1.)).radius;
								makeBackdropBlur(spread) |> Some
							} else None()
						}
						Glow(params): {
							radius = ref 4.0;
							spread = ref 1.0;
							color = ref 0x000000;
							alpha = ref 1.0;
							inner = ref false;
							iter(params, \p -> switch (p : GlowParameter) {
								Radius(r): radius := r;
								Spread(s): spread := s;
								Color(c, a): { color := c; alpha := a; }
								Inner(i): inner := i;
							});
							makeGlow(^radius, ^spread, ^color, ^alpha, ^inner) |> Some;
						}
						Shader(vertex, fragment, uniforms) : {
							makeShader(
								strSplitLeave(strReplace(vertex, "\t", ""), "\n"),
								strSplitLeave(strReplace(fragment, "\t", ""), "\n"),
								map(uniforms, \u -> [u.name, u.type, u.value])
							) |> Some;
						}
					};
					eitherMap(fils, \fls -> {
						setClipCallstack(clip, stack);
						addFilters(clip, [fls]);

						\ -> deleteNative(fls)
					}, nop) |> v2a
				}
				attachChildAndCapability(rform, acc, acc.capabilities.filters,
					ClipCapabilities(acc.capabilities.move, false, acc.capabilities.interactive, acc.capabilities.scale, acc.capabilities.alpha), fn
				);
			});
		} else {
			fn = \clip -> {
				fils = filtermap(filters, \f -> switch(f : Filters) {
					Bevel(params): {
						angle = ref 45.0;
						distance = ref 3.0;
						radius = ref 3.0;
						spread = ref 1.0;
						color1 = ref 0xffffff;
						alpha1 = ref 1.0;
						color2 = ref 0x000000;
						alpha2 = ref 1.0;
						inner = ref true;
						iter(params, \p -> switch (p : BevelParameter) {
							Placement(a, ds): { angle := a; distance := ds; }
							Radius(r): radius := r;
							Spread(s): spread := s;
							Color(c, a): { color1 := c; alpha1 := a; }
							ShadowColor(c, a): { color2 := c; alpha2 := a; }
							Inner(i): inner := i;
						});
						makeBevel(^angle, ^distance, ^radius, ^spread, ^color1, ^alpha1, ^color2, ^alpha2, ^inner) |> Some;
					}
					DropShadow(params): {
						angle = ref 45.0;
						distance = ref 4.0;
						radius = ref 4.0;
						spread = ref 1.0;
						color = ref 0x000000;
						alpha = ref 1.0;
						inner = ref false;
						useBoxShadow = ref false;
						iter(params, \p -> switch (p : DropShadowParameter) {
							Placement(a, ds): { angle := a; distance := ds; }
							Radius(r): radius := r;
							Spread(s): spread := s;
							Color(c, a): { color := c; alpha := a; }
							Inner(i): inner := i;
							UseBoxShadow(): useBoxShadow := true;
						});
						ds = makeDropShadow(^angle, ^distance, ^radius, ^spread, ^color, ^alpha, ^inner);
						if (^useBoxShadow) setUseBoxShadow(ds);
						Some(ds);
					}
					Blur(params): {
						radius = ref 3.0;
						spread = ref 1.0;
						iter(params, \p -> switch (p : BlurParameter) {
							Radius(r): radius := r;
							Spread(s): spread := s;
						});
						makeBlur(^radius, ^spread) |> Some;
					}
					BackdropBlur(params) : None();
					Glow(params): {
						radius = ref 4.0;
						spread = ref 1.0;
						color = ref 0x000000;
						alpha = ref 1.0;
						inner = ref false;
						iter(params, \p -> switch (p : GlowParameter) {
							Radius(r): radius := r;
							Spread(s): spread := s;
							Color(c, a): { color := c; alpha := a; }
							Inner(i): inner := i;
						});
						makeGlow(^radius, ^spread, ^color, ^alpha, ^inner) |> Some;
					}
					Shader(vertex, fragment, uniforms) : {
						makeShader(
							strSplitLeave(strReplace(vertex, "\t", ""), "\n"),
							strSplitLeave(strReplace(fragment, "\t", ""), "\n"),
							map(uniforms, \u -> [u.name, u.type, u.value])
						) |> Some;
					}
				});
				setClipCallstack(clip, stack);
				addFilters(clip, fils);

				[\ -> { iter(fils, deleteNative); }]
			}
			attachChildAndCapability(rform, d, d.capabilities.filters,
				ClipCapabilities(d.capabilities.move, false, d.capabilities.interactive, d.capabilities.scale, d.capabilities.alpha), fn
			);
		}
	}
	Cursor(shape, form) : {
		if (js) {
			d = renderForm(form, available, zorder, tabOrder);

			attachChildAndCapability(
				rform,
				d,
				false,
				d.capabilities,
				\clip -> {
					switch (shape : CursorShape2) {
						CursorShape(): {
							setClipCursor(clip, getCursorShapeName(shape));
							[];
						}
						DynamicCursor(shape2): {
							[makeSubscribe(shape2, \sh -> setClipCursor(clip, getCursorShapeName(sh)))()];
						}
					}
				}
			);
		} else {
			clip = makeClip();
			setClipDebugInfo(clip, "form", rform);

			cursorListeners = makeGlobalCursorListeners(shape, const(zorder));

			d = renderForm(
				Interactive(
					cursorListeners.first,
					form
				),
				available,
				zorder,
				tabOrder
			);

			attachChildren(clip, d.clips, d.widthHeight, d.baseline, d.pending,
				arrayPush(d.disposers, \ -> { cursorListeners.second(); deleteNative(clip); }),
				allClipCapabilities);
		}
	}
	Inspect(inspectors, form): {
		// Set up inspection before constructing the child
		unsubs1 = filtermap(inspectors, \i -> switch (i : Inspector) {
			IAvailable2(wh): Some(connect(available, wh));
			AvailableWidth2(w): Some(subscribe(available, \awh -> nextDistinct(w, awh.width)));
			AvailableHeight(h): Some(subscribe(available, \awh -> nextDistinct(h, awh.height)));
			default: None();
		});

		d = renderForm(form, available, zorder, tabOrder);
		widthHeight : Behaviour<WidthHeight> = d.widthHeight;
		unsubs2 = filtermap(inspectors, \i -> switch (i : Inspector) {
			Width(w): Some(subscribe(widthHeight, \wh -> nextDistinct(w, wh.width)));
			Height(h): Some(subscribe(widthHeight, \wh -> nextDistinct(h, wh.height)));
			AvailableWidth(w): Some(subscribe(available, \awh -> nextDistinct(w, awh.width)));
			ISize(wh): Some(connect(widthHeight, wh));
			IMetrics(m): {
				// TODO: Figure out dHeight as well!
				metrics = makeDisposable(select2u(widthHeight, d.baseline, \wh, b -> FormMetrics(wh.width, wh.height, b, 0.0)));
				uns = connectDistinct(metrics.value, m);
				Some(\ -> {
					metrics.dispose();
					uns();
				})
			}
			IAvailable(wh): Some(connect(available, wh));
			AvailableHeight(wh): None();
			AvailableWidth2(wh): None();
			IAvailable2(wh): None();
			IPending(p): Some(subscribe(d.pending, \pn -> nextDistinct(p, pn)));
			ITag(id): None();
			ITransformMatrix(setfn): {
				fn = if (length(d.clips) > 0) {
					\ -> { getGlobalTransform(d.clips[0]); }
				} else {
					getDummyTransformMatrix
				}
				deferUntilNextFrameRendered(\ -> setfn(fn)); // Defer to have form built and transforms calculated
				None()
			}
		});

		RenderResult(d.clips, widthHeight, d.baseline, d.pending, concat3(d.disposers, unsubs1, unsubs2), d.capabilities);
	}
	Crop2(left, top, cwidth, cheight, form, stack): {
		d = renderForm(form, available, zorder, tabOrder);
		// TODO: Find out if the child supports clipping
		clip = makeClip();
		setClipCallstack(clip, stack);
		setClipDebugInfo(clip, "form", rform);
		u = select4u(left, top, cwidth, cheight, \l, t, w, h -> {
			setScrollRect(clip, l, t, w, h);
		}).second;
		baseline = make(0.0);
		widthHeight = select2u(cwidth, cheight, \w,h -> {
			nextDistinct(baseline, h);
			WidthHeight(w, h)
		});
		disp = widthHeight.second;
		// Opengl target forbids using any transformation natives on the same clip as setScrollRect
		caps = ClipCapabilities(false, false, false, false, true);
		attachChildren(
			clip, d.clips, widthHeight.first, baseline, d.pending,
			arrayPush(d.disposers, \->{ u(); disp(); deleteNative(clip); }),
			caps
		);
	}
	Access(properties, form) : {
		role = ref "";
		description = ref "";
		stateForSubscription = ref None();
		enabledForSubscription = ref None();
		unsubscribe_state = ref nop;
		unsubscribe_enabled = ref nop;
		tabindex = ref None();
		groupId = ref "";
		access_child_selected_fn = ref None();
		focused_behaviour = ref None();
		shortcut = ref "";
		customTabOrder = ref None();
		customZorder = ref None();
		accessAttributes : ref [Pair<string, Behaviour<string>>] = ref [];
		accessStyles : ref [Pair<string, Behaviour<string>>] = ref [];
		accessCallback : ref () -> void = ref nop;
		tagName = ref None();
		langAttribute = ref None();

		// Grab attributes from Access parameters
		attributes : ref [[string]] = ref filtermap(properties, \p -> {
			switch (p : AccessProperty) {
				AccessRole(r) : { role := r; None() }
				AccessDescription(ds): { description := ds; Some(["description", ds]); }
				AccessTabindex(ti): {
					r : [string] = ["tabindex", i2s(ti)];
					tabindex := if (js && ti >= 0) None() else Some(r);
					None()
				}
				AccessKbdShortcutString(s) : { shortcut := s; None() }
				AccessState(st): { stateForSubscription := Some(st); Some(["state", getValue(st)]) }
				AccessSelectable(): { Some(["selectable", "true"]) }
				AccessCallback(cb): { accessCallback := cb; None() }
				AccessGroup(newGroupId): { groupId := newGroupId; None() }
				AccessChildSelected(acsFn) : { access_child_selected_fn := Some(acsFn); None() }
				AccessFocused(focused) : { focused_behaviour := Some(focused); None() }
				AccessEnabled(en): { enabledForSubscription := Some(en); Some(["enabled", toString(getValue(en))]) }
				AccessAttribute(name, value): {
					refArrayPush(accessAttributes, Pair(name, value)); None()
				}
				AccessStyle(name, value): {
					refArrayPush(accessStyles, Pair(name, value)); None()
				}
				AccessTabOrder(to): {
					customTabOrder := Some(to);
					Some(["nodeindex", strGlue(map(getValue(to), i2s), " ")]);
				}
				AccessZorder(zo): {
					customZorder := Some(zo);
					Some(["zorder", toString(getValue(zo))])
				}
				TagName(tn): {
					tagName := Some(tn);
					None();
				}
				LangAttribute(lang): {
					langAttribute := Some(lang);
					Some(["lang", toString(fgetValue(lang))])
				}
				AccessForceMakeClip(__) : { None(); }
			}
		});

		ownTabOrder : [int] = if (^groupId == "") tabOrder else {
			eitherMap(lookupTree(^groupTabOrders, ^groupId),
				\groupTo -> {
					// adding own's tabOrder as a unique identifier
					concat(groupTo.first, tabOrder);
				},
				tabOrder
			)
		};

		// All TextInputs should have corresponding role. No need to specify it in other places
		if (isSameStructType(form, TextInput([], [], []))) {
			role := "textbox";
		};
		// avoid creating unnecessary empty elements in the hierarchy
		skipMakingElement = ^role == "" && isNone(^tagName) && isNone(^langAttribute);
		if (^role != "") attributes := concat([["role", ^role]], ^attributes); // "role" should be first and will affect element's tag

		if (^groupId != "") {
			// if it's first form from the group which is rendered, save current tabOrder
			curPair = lookupTreeDef(^groupTabOrders, ^groupId, Pair(tabOrder, []));
			// increasing reference count for this group by adding current form's tabOrder
			groupTabOrders := setTree(^groupTabOrders, ^groupId, Pair(curPair.first, arrayPush(curPair.second, tabOrder)));
		}
		groupToDisposer : [ () -> void ] = if (^groupId == "") [ ] else {
			[ \ -> {
				maybeApply(lookupTree(^groupTabOrders, ^groupId),
					\desPair -> if (length(desPair.second) == 1) {
						groupTabOrders := removeFromTree(^groupTabOrders, ^groupId);
					} else {
						// decreasing reference count for this group
						groupTabOrders := setTree(^groupTabOrders, ^groupId, Pair(desPair.first, removeFirst(desPair.second, tabOrder)));
					}
				);
			}]
		};

		// Attach focus even listeners
		set_focus_subscription_fn = \clip -> {
			// Focus listeners
			focused_uns = switch(^focused_behaviour) {
				Some(b) : if (^accessibilityEnabled) {
					focusGate = make(true);
					switchFocus = \focus -> {
						nextDistinct(focusGate, false);
						nextDistinct(b, focus);
						nextDistinct(focusGate, true);
					};

					ignoreGate = ignoreu(focusGate, b);

					[
						subscribe(ignoreGate.value, \v -> setFocus(clip, v)),
						addEventListener(clip, "focusin", \ -> switchFocus(true)),
						addEventListener(clip, "focusout", \ -> switchFocus(false)),
						ignoreGate.dispose
					];
				} else [];
				None() : [];
			};

			// Child focus listener
			child_focused_uns = switch(^access_child_selected_fn) {
				Some(fn) : [addExtendedEventListener(clip, "childfocused", \args : [flow]-> {
					a0 = flow2d(args[0]);
					a1 = flow2d(args[1]);
					a2 = flow2d(args[2]);
					a3 = flow2d(args[3]);
					fn(Point(a0, a1), WidthHeight(a2, a3))
				})];
				None() : [];
			}

			\ -> applyall(concat(focused_uns, child_focused_uns));
		};

		// We just override any access attributes of children
		fn = \clip -> {
			maybeApply(^tagName, \tn -> setClipTagName(clip, tn));

			dispNodeIndex =
				eitherFn(
					^customTabOrder,
					\to -> {
						[subscribe2(to, \to0 -> setAccessAttributes(clip, [["nodeindex", strGlue(map(to0, i2s), " ")]]))]
					},
					\ -> {
						[]
					}
				);

			// Only topmost accessible clips will be available:
			dispZorder =
				eitherFn(
					^customZorder,
					\cz -> {
						[subscribe2(cz, \zo -> setAccessAttributes(clip, [["zorder", toString(zo)]]))]
					},
					\ -> {
						[]
					}
				);

			dispAccessAttributes =
				map(
					^accessAttributes,
					\aa -> {
						refArrayPush(attributes, [aa.first, getValue(aa.second)]);

						subscribe2(aa.second, \v -> setAccessAttributes(clip, [[aa.first, v]]))
					}
				);

			dispAccessStyles =
				map(
					^accessStyles,
					\as -> {
						refArrayPush(attributes, [as.first, getValue(as.second)]);

						subscribe2(as.second, \v -> setClipStyle(clip, as.first, v))
					}
				);

			setAccessAttributes(clip, ^attributes);
			setAccessCallback(clip, ^accessCallback);

			maybeApply(^stateForSubscription, \st -> {
				unsubscribe_state := subscribe2(st, \s -> { setAccessAttributes(clip, [ ["state", s] ]) });
			});

			// TO DO : optimise for const behaviour
			maybeApply(^enabledForSubscription, \en -> {
				unsubscribe_enabled := subscribe2(en, \e -> { setAccessAttributes(clip, [ ["enabled", toString(e)] ]) });
			});

			langAttributeDisposer = eitherMap(^langAttribute, \la -> makeSubscribe2(la, \v -> { setAccessAttributes(clip, [ ["lang", v] ]) })(), nop);

			concatA([
				if (^role == "button" && ^shortcut != "" && ^description != "") {
					dispKeyboardShortcut = addKeyboardShortcut(^shortcut, ^description);
					[\ -> { ^unsubscribe_state(); ^unsubscribe_enabled(); dispKeyboardShortcut()}]
				} else {
					[\ -> { ^unsubscribe_state(); ^unsubscribe_enabled(); } ];
				},
				dispNodeIndex,
				dispZorder,
				dispAccessAttributes,
				dispAccessStyles,
				groupToDisposer,
				[
					set_focus_subscription_fn(clip),
					langAttributeDisposer,
					\ -> {
						setAccessCallback(clip, nop);
						accessCallback := nop;
					}
				]
			])
		};
		dontChangeChildrenFn = \clip -> [ ];

		onlyFocusFn = \clip -> [set_focus_subscription_fn(clip)];

		// there are some Access forms with only TabIndex set around a syled button.
		// such Access forms should not have their own clip(HTML element)
		defMakeAccessClip = (^role != "" && !contains(["button", "checkbox", "textbox", "video", "iframe"], ^role)
			|| isSome(^access_child_selected_fn)) && isNone(^tagName) && isNone(^langAttribute) || contains(["table", "tbody", "thead", "tfoot", "tr", "th", "td"], either(^tagName, ""));
		makeAccessClip = extractStruct(properties, AccessForceMakeClip(defMakeAccessClip)).makeClip;
		d = renderForm(form, available, zorder, ownTabOrder);

		if (makeAccessClip) {
			childRenderResult = attachChildAndCapability(rform, d, true, d.capabilities, dontChangeChildrenFn);
			// making parent element with accesibility features around children
			attachChildAndCapability(rform, childRenderResult, false, d.capabilities, fn);
		} else {
			// overriding children's accessibility attributes
			attachChildAndCapability(rform, d, true, d.capabilities, if (skipMakingElement) onlyFocusFn else fn);
		}
	}
	RealHTML2(url, wh, style): {
		update_cached_content = ref true;
		domain = ref "";
		flow_callback = ref \args -> { "" };
		hostcall_setter = ref \fn -> { };
		eval_js_setters : ref [((string, (string) -> void) -> void) -> void] = ref [];
		on_error = ref \s : string -> { };
		on_page_loaded = ref nop;
		reload_block = ref false;
		zoom_enabled = ref const(false);
		mouse_disabled = ref const(false);
		sandbox = ref None();
		whitelist_domains = ref [];
		shrink2fit = ref false;
		viewBounds = ref None();
		noScroll = ref false;
		passEvents = ref false;

		iter(style, \s -> {
			switch (s : RealHTMLStyle) {
				UpdateCachedContent(u): update_cached_content := u;
				OverridePageDomain(d): domain := d;
				FlowCallback(cb): flow_callback := cb;
				PageHostcallSetter(fn): hostcall_setter := fn;
				PageEvalJS(fn): eval_js_setters := arrayPush(^eval_js_setters, fn);
				OnError(fn): on_error := fn;
				OnPageLoaded(fn): on_page_loaded := fn;
				ZoomEnabled(zoom): zoom_enabled := zoom;
				ReloadBlock(show) : reload_block := show;
				MouseDisabled(disabled) : mouse_disabled := disabled;
				SandBoxJS(sboxes) : sandbox := Some(
					strGlue(map(sboxes, \s_ ->
						switch (s_ : SandBoxJSStyle) {
							AllowSameOrigin()    : "allow-same-origin";
							AllowTopNavigation() : "allow-top-navigation";
							AllowForms()         : "allow-forms";
							AllowScripts()       : "allow-scripts";
						}
					), " ")
				);
				WhitelistDomains(domains) : whitelist_domains := domains;
				RealHtmlShrink2Fit(): shrink2fit := true;
				ViewBounds(bounds): viewBounds := Some(bounds);
				NoScroll(): noScroll := true;
				PassEvents(): passEvents := true;
			}
		});

		callback = \args : [string] -> ^flow_callback(args);
		ondone = \s : string -> if (s == "OK") ^on_page_loaded() else ^on_error(s);

		bridge_clip = makeWebClip(url, ^domain, !^update_cached_content, ^reload_block, callback, ondone, ^shrink2fit);

		switch (^sandbox : Maybe) {
			Some(sb) : setWebClipSandBox(bridge_clip, sb);
			default: {};
		}

		setWebClipDomains(bridge_clip, ^whitelist_domains);
		if (^noScroll) setWebClipNoScroll(bridge_clip);
		if (^passEvents) setWebClipPassEvents(bridge_clip);

		if (^accessibilityEnabled) {
			setAccessAttributes(bridge_clip, [["zorder", toString(zorder[0])]]);
		}

		^hostcall_setter(\name, args -> webClipHostCall(bridge_clip, name, args));
		iter(^eval_js_setters, \eval_js_setter -> {
			eval_js_setter(\code, cb -> webClipEvalJS(bridge_clip, code, cb));
		});

		u2 = subscribe(^zoom_enabled, \zoom -> setWebClipZoomable(bridge_clip, zoom));
		u3 = makeSubscribe(^mouse_disabled, \disabled -> setWebClipDisabled(bridge_clip, disabled))();
		u4 = eitherMap(^viewBounds, \vb -> makeSubscribe(vb, \b -> setClipViewBounds(bridge_clip, b.minX, b.minY, b.maxX, b.maxY))(), nop);

		baseline = make(0.0);
		u1 = subscribe(wh, \whv -> {
				nextDistinct(baseline, whv.height);
				setClipWidth(bridge_clip, whv.width);
				setClipHeight(bridge_clip, whv.height);
			});
		RenderResult([bridge_clip], wh, baseline, const(0), [\ -> { u1(); u2(); u3(); u4(); deleteNative(bridge_clip); }],
			ClipCapabilities(true, false, true, false, true)
		);
	}
	ControlFocus(focus, form): {
		f = renderForm(form, available, zorder, tabOrder);
		newFocus = getUrlParameter("setFocus") == "";
		uns = subscribe(focus, \fc -> {
			// setFocus native isn't implemented in cpp yet
			if (newFocus) {
				if (js || (!cpp && isSameStructType(form, TextInput([], [], []))))
					// platforms should gracefully fallback if focus is applied to a wrong element
					setFocus(f.clips[0], fc);
			} else
			if (!cpp && isSameStructType(form, TextInput([], [], []))) {
				//The function is applied to entity which is not Text for some reason. Changed condition of ad hoc fix from || to &&
				setFocus(f.clips[0], fc);
			}
		});
		RenderResult(
			f.clips,
			f.widthHeight,
			f.baseline,
			f.pending,
			arrayPush(f.disposers, uns),
			f.capabilities
		);
	}
	NativeForm(__, metrics, __, fn): {
		r = fn(available, zorder, tabOrder);

		widthHeight = make(zeroWH);
		baseline = make(0.);

		RenderResult(
			r.clips,
			widthHeight,
			baseline,
			const(0),
			[
				r.dispose,
				subscribe(metrics, \met -> {
					nextDistinct(baseline, met.baseline);
					nextDistinct(widthHeight, WidthHeight(met.width, met.height))
				})
			],
			ClipCapabilities(false, false, false, false, false)
		);
	}
	DynamicGroup2(stackChanges, combiner, currentStack, stack) : {
		parentClip = makeClip();

		setClipCallstack(parentClip, stack);
		setClipDebugInfo(parentClip, "form", rform);

		childItems : DynamicBehaviour<[DynamicGroupItem]> = make([]);

		handleAdd = \form : Form, z : int -> {
			itemIndex : DynamicBehaviour<int> =
				make(z);

			itemPosition : DynamicBehaviour<double> =
				make(0.0);

			childrenAfter : [DynamicGroupItem] =
				tailFrom(getValue(childItems), z);

			iter(childrenAfter, \item : DynamicGroupItem ->
				iter(item.renderResult.clips, \child ->
					removeChild(parentClip, child)
				)
			);

			childResult : RenderResult =
				renderForm(
					if (combiner == LinesCombiner() || combiner == ColsCombiner()) {

						previousItem : Disposable<Behaviour<DynamicGroupItem>> =
							select2u(childItems, itemIndex, \ti, i ->
								elementAt(ti, i - 1, zeroDynamicGroupItem)
							)
								|> toDisposable;

						previousItemPosition : Disposable<Behaviour<double>> =
							subselectSafe(
								previousItem.value,
								\prevItem ->
									positionDynamicGroupItem(
										prevItem,
										combiner
									)
							);

						Constructor(
							Translate(
								if (combiner == ColsCombiner()) {
									itemPosition;
								} else {
									const(0.0);
								},
								if (combiner == LinesCombiner()) {
									itemPosition;
								} else {
									const(0.0);
								},
								form
							),
							\ -> {
								disconnect : () -> void =
									connect(
										previousItemPosition.value,
										itemPosition
									);
								\ -> {
									disconnect();
									previousItemPosition.dispose();
									previousItem.dispose();
								}
							}
						)
					} else {
						form;
					},
					available,
					arrayPush(zorder, z),
					arrayPush(tabOrder, z)
				);

			childItem : DynamicGroupItem =
				DynamicGroupItem(
					childResult,
					itemIndex,
					itemPosition
				);

			iter(
				concat([childItem], childrenAfter),
				\item : DynamicGroupItem ->
					iter(item.renderResult.clips, \clip ->
						addChild(parentClip, clip)
					)
			);

			next(
				childItems,
				insertArray(
					getValue(childItems),
					z,
					childItem
				)
			);

			iteri(
				tailFrom(getValue(childItems), z + 1),
				\i, item -> next(item.index, i + z + 1)
			);
		};

		handleDelete = \z : int -> if (existsIndex( getValue(childItems), z )) {

			iter(
				( getValue(childItems)[z] ).renderResult.clips,
				\clip -> removeChild(parentClip, clip)
			);

			applyall(
				( getValue(childItems)[z] ).renderResult.disposers
			);

			iteri(
				tailFrom(getValue(childItems), z + 1),
				\i, item -> next(item.index, i + z)
			);

			next(
				childItems,
				removeIndex( getValue(childItems), z )
			);
		}

		handleMove = \from, to -> {
			toFixed = forceRange(to, 0, length( getValue(childItems) ) - 1);

			if (existsIndex(getValue(childItems), from) && from != toFixed) {
				childrenFixedOrder : [DynamicGroupItem] =
					moveElement( getValue(childItems), from, toFixed );

				childrenChanged : [DynamicGroupItem] =
					tailFrom(childrenFixedOrder, min(from, toFixed));

				iter(childrenChanged, \item : DynamicGroupItem->
					iter(item.renderResult.clips, \clip ->
						removeChild(parentClip, clip)
					)
				);

				iter(childrenChanged, \item : DynamicGroupItem->
					iter(item.renderResult.clips, \clip ->
						addChild(parentClip, clip)
					)
				);

				next(childItems, childrenFixedOrder);

				iteri(
					getValue(childItems),
					\index, item ->
						nextDistinct(item.index, index)
				);
			}
		}

		iteri(getValue(currentStack), \i, f -> handleAdd(f, i));

		handleChange = \change : GroupChange ->
			switch (change : GroupChange) {
				GroupAdd(form, z) : {
					next(currentStack, insertArray(getValue(currentStack), z, form));
					handleAdd(form, z);
				}
				GroupDelete(z) : {
					next(currentStack, removeIndex(getValue(currentStack), z));
					handleDelete(z);
				}
				GroupMove(from, to) : {
					currentStackValue = getValue(currentStack);
					toFixed = forceRange(to, 0, length(currentStackValue) - 1);

					if (existsIndex(currentStackValue, from) && from != toFixed) {
						next(
							currentStack,
							moveElement(currentStackValue, from, toFixed)
						);

						handleMove(from, toFixed);
					}
				}
			};

		unchange =
			subscribe(stackChanges, \changes -> {
				iter(changes, handleChange);
				nextDistinct(stackChanges, []);
			});

		whu : Disposable<Behaviour<WidthHeight>> =
			subselectArray(
				childItems,
				\item : DynamicGroupItem ->
					item.renderResult.widthHeight,
				\whs : [Behaviour<WidthHeight>] ->
					selectMergeu(whs, zeroSize, \rwh, lwh ->
						WidthHeight(
							max(rwh.width, lwh.width),
							max(rwh.height, lwh.height)
						)
					)
			);

		widthHeight : Disposable<Behaviour<WidthHeight>> =
			whenSizeChangedu(whu.value)
				|> toDisposable;

		baseline : Disposable<Behaviour<double>> =
			subselectArray(
				childItems,
				\item -> item.renderResult.baseline,
				arrayMaxu
			);

		pending : Disposable<Behaviour<int>> =
			subselectArray(
				childItems,
				\item -> item.renderResult.pending,
				arrayISumu
			);

		disposeGroup =
			\ -> {
				unchange();
				whu.dispose();
				widthHeight.dispose();
				baseline.dispose();
				pending.dispose();

				iter(getValue(childItems), \item ->
					iter(item.renderResult.clips,
						\clip -> removeChild(parentClip, clip)
					)
				);

				iter(
					getValue(childItems),
					\item -> applyall(item.renderResult.disposers)
				);
				next(childItems, []);

				deleteNative(parentClip);
			};

		RenderResult(
			[parentClip],
			widthHeight.value,
			baseline.value,
			pending.value,
			[disposeGroup],
			allClipCapabilities
		);
	}
	}

	res;
}

toDisposable(
	pair : Pair<?, () -> void>) -> Disposable<?> {

	Disposable(pair.first, pair.second);
}

DynamicGroupItem : (
	renderResult : RenderResult,
	index : DynamicBehaviour<int>,
	position : DynamicBehaviour<double>
);

zeroDynamicGroupItem : DynamicGroupItem =
	DynamicGroupItem(emptyRenderResult, make(0), make(0.0));

positionDynamicGroupItem(
	previousItem : DynamicGroupItem,
	combiner : DynamicGroupCombiner) -> Disposable<Behaviour<double>> {

	select2u(
		previousItem.position,
		previousItem.renderResult.widthHeight,
		if (combiner == LinesCombiner()) {
			\pos : double, metrics : WidthHeight ->
				pos + metrics.height;
		} else {
			\pos : double, metrics : WidthHeight ->
				pos + metrics.width;
		}
	)
		|> toDisposable;
}

subselectArray(
	array : Behaviour<[?]>,
	key : (?) -> Behaviour<??>,
	combine : ([Behaviour<??>]) -> Pair<Behaviour<??>, () -> void>
) -> Disposable<Behaviour<??>> {
	subselectSafe(array, \a ->
		combine( map(a, key) )
			|> toDisposable
	);
}

subselectSafe(
	b : Behaviour<?>,
	f : (?) -> Disposable<Behaviour<??>>
) -> Disposable<Behaviour<??>> {
	firstBehaviour = f(getValue(b));
	result = make( getValue( firstBehaviour.value ) );
	disconnect = ref connect(firstBehaviour.value, result);
	unsub = ref firstBehaviour.dispose;
	unsub2 =
		subscribe2(b, \v -> {
			^unsub();
			^disconnect();
			mapped = f(v);
			disconnect := connect(mapped.value, result);
			unsub := mapped.dispose;
		});
	Disposable(result, \ -> {
		unsub2();
		^unsub();
		^disconnect();
	})
}

// This is basically htmlEscape, but it wouldn't be good to import formats/wiki/wikiwiki here
htmlEscapeStr(str : string) -> string {
	strReplace(strReplace(strReplace(str, "&", "&amp;"), "<", "&lt;"), ">", "&gt;");
}

htmlUnescapeStr(str : string) -> string {
	strReplace(strReplace(strReplace(str, "&amp;", "&"), "&lt;", "<"), "&gt;", ">");
}

defineTextInputState(textfield : native, state : [TextInputState], wh : DynamicBehaviour<WidthHeight>, state_disposers : ref [() -> void]) -> void {
	disposers = ref [];
	iter(state, \s -> {
		switch (s : TextInputState) {
			TextInputType(inputType) : {
				switch (inputType : InputType) {
					EmailType(): {setTextInputType(textfield, "email")}
					TelType(): {setTextInputType(textfield, "tel")}
					UrlType(): {setTextInputType(textfield, "url")}
					TextType(): {setTextInputType(textfield, "text")}
					NumericType(): {setTextInputType(textfield, "number")}
					SearchType(): {setTextInputType(textfield, "search")}
					PasswordType(): {setTextInputType(textfield, "password")}
				}
			}
			AutoCompleteType(type) : {
				switch (type : ACType) {
					ACUserName(): setTextInputAutoCompleteType(textfield, "username");
					ACNewPassword(): setTextInputAutoCompleteType(textfield, "new-password");
					ACCurrentPassword(): setTextInputAutoCompleteType(textfield, "current-password");
					ACOneTimeCode(): setTextInputAutoCompleteType(textfield, "one-time-code");
				}
			}
			TextInputFilter(f) : {
				prevStr = ref getContent(textfield);
				refArrayPush(disposers, addTextInputFilter(textfield, \str -> {if (f(str)) prevStr := str; ^prevStr;}));
			}
			Multiline(multiline): setMultiline(textfield, multiline);
			WordWrap(wordWrap): setWordWrap(textfield, wordWrap);
			Numeric(numeric): {
				if (numeric) setTextInputType(textfield, "number");
			}
			ReadOnly(readOnly): setReadOnly(textfield, readOnly);
			MaxChars(n): setMaxChars(textfield, n);
			AutoAlign(autoalign): {
				setAutoAlign(textfield,
					switch (autoalign : AutoAlignType) {
					AutoAlignLeft(): "AutoAlignLeft";
					AutoAlignRight(): "AutoAlignRight";
					AutoAlignCenter(): "AutoAlignCenter";
					AutoAlignNone(): "AutoAlignNone";
					}
				);
			}
			PasswordMode(p): {
				if (p) setTextInputType(textfield, "password");
			}
			TabIndex(ind) : setTabIndex(textfield, ind);
			TabEnabled(enabled) : setTabEnabled(textfield, enabled);
			EatKeyDownOnFocus() : {};
			DoNotInvalidateStage(): {
				setDoNotInvalidateStage(textfield, true);
			}
			default: {
				if (isSameStructType(s, ScrollInfo(0, 0, 0))) {
					setScrollV(textfield, cast(s : TextInputState -> ScrollInfo).scrollV);
				} else if (isSameStructType(s, TextSize(0., 0.))) {
					tSize = cast(s : TextInputState -> TextSize);

					setTextFieldWidth(textfield, tSize.width);
					setTextFieldHeight(textfield, tSize.height);
					nextDistinct(wh, WidthHeight(getTextFieldWidth(textfield), getTextFieldHeight(textfield)));
				} else if (isSameStructType(s, Content("", []))) {
					cont = cast(s : TextInputState -> Content);

					escaped = if (flash) htmlEscapeStr(cont.content) else cont.content;
					fontSize = extractStruct(cont.style, FontSize(0.)).size;
					style = if (js) map(cont.style, \style -> {
						switch (style : CharacterStyle) {
							FontFamily(name): FontFamily(getMappedFont(name, fontSize).first);
							default: style;
						}
					}) else cont.style;
					defineTextStyle(textfield, escaped, style);
					nextDistinct(wh, WidthHeight(getTextFieldWidth(textfield), getTextFieldHeight(textfield)));
				} else if (isSameStructType(s, Selection(0, 0))) {
					sele = cast(s : TextInputState -> Selection);

					setSelection(textfield, sele.start, sele.end);
				} else if (isSameStructType(s, Focus(false))) {
					setFocus(textfield, cast(s : TextInputState -> Focus).focus);
				}
			};
		}
	});

	if (length(^disposers) > 0) {
		applyall(^state_disposers);
		state_disposers := ^disposers;
	}
}

// Temporary structures used by grid
RowInfo : (rowInfo : [RenderResult], dispose : () -> void);

// Special case for a switch with two elements, where one of them is Empty()
renderVisibleSwitch(index : Behaviour<int>, cases : [Form]) -> RenderResult {
	// When I grow up, I might be able to implement this
	emptyRenderResult;
}


renderGrid(cells : [[Form]], zorder : [int], tabOrder : [int]) -> RenderResult {
	ys = length(cells);
	if (ys == 1) {
		// TODO: We could special case this
		renderCols(cells[0], zorder, tabOrder);
	} else {
		// Find the widest row in number of cells
		xs = fold(cells, 0, \maxlength, row -> {
			w = length(row);
			max(w, maxlength)
		});
		if (xs == 1) {
			renderLines(cells, zorder, tabOrder);
		} else {
			// Prepare the coordinate streams for the rows
			rowheight : [DynamicBehaviour<double>] = map(cells, \f -> make(0.0));

			xcoords : [DynamicBehaviour<double>] = generate(0, xs + 1, \i -> make(0.0));
			colwidth = generate(0, xs, \i -> make(0.0));

			lastY = ref const(0.0);

			// Render and layout the cells
			rowInfos = mapi(cells, \rowIndex, row -> {
				yc = ^lastY;
				rowInfo = generate(0, xs, \lineIndex -> {
					if (lineIndex >= length(row) || row[lineIndex] == Empty()) {
						emptyRenderResult;
					} else {
						f = if (lineIndex == 0 && rowIndex == 0) { row[lineIndex] } else Translate(xcoords[lineIndex], yc, row[lineIndex]);
						if (availableDependent(f)) {
							// Consider to build these directly somehow instead
							aw = select2u(colwidth[lineIndex], rowheight[rowIndex], \law, lah -> WidthHeight(law, lah));
							renderForm(Constructor(f, \ -> aw.second), aw.first, zorder, concat(tabOrder, [rowIndex, lineIndex]));
						} else {
							renderForm(f, zeroSize, zorder, concat(tabOrder, [rowIndex, lineIndex]));
						}
					}
				});
				// Use heights of the row to calculate the next y coordinate
				heights = map(rowInfo, \i : RenderResult -> selectu(i.widthHeight, \wh -> wh.height));
				// Here, we throttle small changes to avoid excessive infinitesmal updates
				// that cause stack problems
				am = arrayMaxu(map(heights, firstOfPair));
				rowMax = untilChangedu(am.first, 0.5);
				uh = connect(rowMax.first, rowheight[rowIndex]);
				ly = select2u(yc, rowMax.first, \yco, rm -> yco + rm);
				lastY := ly.first;

				disp = concat3(
					map(heights, secondOfPair),
					[am.second, uh, rowMax.second, ly.second],
					concatA(map(rowInfo, \r -> r.disposers))
				);

				RowInfo(rowInfo, \ -> applyall(disp));
			});

			results : [RenderResult] = concatA(map(rowInfos, \rowinfo -> rowinfo.rowInfo));

			caps = sharedCapabilities(results);
			clips = concatA(map(results, \d -> d.clips));

			lastRowheight = lastElement(rowheight, const(0.0));

			baseline = if (rowInfos == []) Pair(const(0.0), []) else {
				ri = rowInfos[length(rowInfos) - 1];
				lastBaseline = arrayMaxu(map(ri.rowInfo, \r -> r.baseline));
				r = select3u(^lastY, lastBaseline.first, lastRowheight, \y, b, r -> b + y - r);
				Pair(r.first, [lastBaseline.second, r.second]);
			}

			pending = arrayISumu(map(results, \r -> r.pending));

			// Now set up the x coordinates
			disposers = generate(0, xs, \x -> {
				// Find the maximum width of column x
				w = ref const(0.0);
				us = map(rowInfos, \r : RowInfo -> {
					ri = (r.rowInfo)[x];
					// Here, we throttle small changes to avoid excessive infinite small updates
					// that cause stack problems
					mwh = select2u(^w, ri.widthHeight, \lw : double, rwh : WidthHeight -> {
						max(lw, rwh.width)
					});
					mw = untilChangedu(mwh.first, 0.5);
					w := mw.first;
					[mwh.second, mw.second]
				}) |> concatA;

				maxWidth = ^w;
				colMax = maxWidth;
				uc = connect(colMax, colwidth[x]);
				nextColX = select2u(xcoords[x], colMax, \xco, cm -> xco + cm);
				ux = connect(nextColX.first, xcoords[x + 1]);
				\ -> { applyall(us); uc(); ux(); nextColX.second() };
			});

			// Hook up the total width and height
			lwh = select2u(xcoords[xs], ^lastY, \w, h -> {
				WidthHeight(w,h)
			});
			wh = whenSizeChangedu(lwh.first);
			disps = concatA([disposers, baseline.second, [lwh.second, wh.second, pending.second], map(rowInfos, \r -> r.dispose)]);
			RenderResult(
				clips, wh.first, baseline.first, pending.first,
				[\ -> applyall(disps)],
				caps
			);
		}
	}
}

renderCols(row : [Form], zorder : [int], tabOrder : [int]) -> RenderResult {
	lastWH : ref Behaviour<WidthHeight> = ref zeroSize;
	// This is to make the available height correct
	height = make(0.0);
	results = mapi(row, \rowIndex, c -> {
		f = if (rowIndex == 0) c else {
			l = selectu(^lastWH, \wh -> wh.width);
			Constructor(Translate(l.first, const(0.0), c), \ -> l.second);
		}
		ri = if (availableDependent(c)) {
			widthHeight = make(zeroWH);
			r = renderForm(f, widthHeight, zorder, arrayPush(tabOrder, rowIndex));
			// Some subtlety in hooking up the available width and height
			u1 = subscribe(r.widthHeight, \wh -> nextDistinct(widthHeight, WidthHeight(wh.width, getValue(height))));
			u2 = subscribe(height, \h -> nextDistinct(widthHeight, WidthHeight((getValue(r.widthHeight)).width, h)));
			RenderResult(r.clips, r.widthHeight, r.baseline, r.pending, concat(r.disposers, [u1, u2]), r.capabilities);
		} else {
			renderForm(f, zeroSize, zorder, arrayPush(tabOrder, rowIndex));
		}

		lwh = select2u(^lastWH, ri.widthHeight,
				\lwh : WidthHeight, rwh : WidthHeight -> {
					WidthHeight(lwh.width + rwh.width, max(lwh.height, rwh.height));
				}
			);

		sc = whenSizeChangedu(lwh.first);

		lastWH := sc.first;
		RenderResult(ri.clips, ri.widthHeight, ri.baseline, ri.pending, concat(ri.disposers, [lwh.second, sc.second]), ri.capabilities);
	});
	un = subscribe(^lastWH, \wh -> nextDistinct(height, wh.height));

	baseline = arrayMaxu(map(results, \r -> r.baseline));

	caps = sharedCapabilities(results);
	clips = concatA(map(results, \d -> d.clips));
	pending = arrayISumu(map(results, \r -> r.pending));
	disposers = concat([un, baseline.second, pending.second], concatA(map(results, \r -> r.disposers)));

	// Hook up the total width and height
	RenderResult(clips, ^lastWH, baseline.first, pending.first, [\ -> applyall(disposers)], caps);
}

renderLines(lines : [[Form]], zorder : [int], tabOrder : [int]) -> RenderResult {
	lastWH : ref Behaviour<WidthHeight> = ref zeroSize;

	// Here, we make the available width correct
	width = make(0.0);

	results = mapi(lines, \lineIndex, row -> {
		if (length(row) == 0) {
			emptyRenderResult;
		} else {
			c = row[0];
			lh = selectu(^lastWH, \wh -> wh.height);
			f = if (lineIndex == 0 || c == Empty()) c else Translate(const(0.0), lh.first, c);
			ri : RenderResult = if (availableDependent(c)) {
				// The available width/height
				widthHeight = make(zeroWH);
				r = renderForm(f, widthHeight, zorder, arrayPush(tabOrder, lineIndex));
				// Some subtlety in hooking up the available width and height
				u1 = subscribe(r.widthHeight, \wh -> nextDistinct(widthHeight, WidthHeight(getValue(width), wh.height)));
				u2 = subscribe(width, \w -> nextDistinct(widthHeight, WidthHeight(w, (getValue(r.widthHeight)).height)));
				RenderResult(r.clips, r.widthHeight, r.baseline, r.pending, concat(r.disposers, [lh.second, u1, u2]), r.capabilities);
			} else {
				r = renderForm(f, zeroSize, zorder, arrayPush(tabOrder, lineIndex));
				RenderResult(r.clips, r.widthHeight, r.baseline, r.pending, arrayPush(r.disposers, lh.second), r.capabilities);
			};
			if (ri != emptyRenderResult) {
				t = select2u(^lastWH, ri.widthHeight,
						\lwh : WidthHeight, rwh : WidthHeight -> {
								WidthHeight(max(lwh.width, rwh.width), lwh.height + rwh.height);
				});
				sc = whenSizeChangedu(t.first);
				lastWH := sc.first;
				RenderResult(ri.clips, ri.widthHeight, ri.baseline, ri.pending, concat(ri.disposers, [t.second, sc.second]), ri.capabilities);
			} else {
				ri;
			}
		}
	});
	lastBaseline = lastElement(map(results, \r -> r.baseline), const(0.0));
	lastMetrics = lastElement(map(results, \r -> r.widthHeight), const(zeroWH));
	baseline = select3u(^lastWH, lastBaseline, lastMetrics, \y, b, m -> {
		b + y.height - m.height
	});
	un = subscribe(^lastWH, \wh -> {
		if (abs(getValue(width) - wh.width) > 0.5) {
			nextDistinct(width, wh.width)
		}
	});

	caps = sharedCapabilities(results);
	clips = concatA(map(results, \d -> d.clips));
	pending = arrayISumu(map(results, \r -> r.pending));
	disposers = concat([un, baseline.second, pending.second], concatA(map(results, \r -> r.disposers)));

	// Hook up the total width and height
	RenderResult(clips, ^lastWH, baseline.first, pending.first, [\ -> applyall(disposers)], caps);
}


renderText(text : string, style : [CharacterStyle], available : Behaviour<WidthHeight>, zorder : [int], tabOrder: [int]) -> RenderResult {
	textfield = makeStyledTextfield(text, style);
	metrics = getTextMetrics(textfield);

	if (contains(style, SkipOrderCheck())) {
		setTextSkipOrderCheck(textfield, true);
	}

	if (contains(style, PreventTextNodeWidthCalculation())) {
		setTextPreventCheckTextNodeWidth(textfield, true);
	}

	uns =
		eitherMap(
			tryExtractStruct(style, WordSpacing(zero)),
			\ws -> [makeSubscribe(ws.spacing, \spacing -> setTextWordSpacing(textfield, spacing))()],
			[]
		);

	disposer = \ -> {
		applyall(uns);
		// Flash is not very helpful: If a text has the focus, but dies, then we effectively lose focus
		if (flash && getFocus(textfield)) {
			setFocus(getStage(), true);
		}
		deleteNative(textfield);
	}

	widthHeight = const(WidthHeight(getTextFieldWidth(textfield), getTextFieldHeight(textfield)));
	caps = ClipCapabilities(true, false, true, false, true);

	uStruct = fold(style, None(), \acc, s -> switch(s) { Underlined(v): Some(s); default: acc});
	if (isSome(uStruct)) {
		uStyle : [GraphicsStyle] = either(uStruct, Underlined([])).style;
		urr = renderForm(
			Graphics(
				[
					// TODO: it is the same as TUnderline. Replace height by underline_position
					// or at least consider to replace by baseline +
					MoveTo(0.0, getValue(widthHeight).height - 1.0),
					LineTo(getValue(widthHeight).width, getValue(widthHeight).height - 1.0),
				],
				// if style for underline is specified then use it,
				// otherwise use the one that is used by text
				if (uStyle != []) uStyle
				else [
					// TODO: add underline_thickness
					Stroke(extractStruct(style, Fill(0x000000)).color)
				]
			),
			available, zorder, tabOrder
		);

		RenderResult(
			arrayPush(urr.clips, textfield), widthHeight, const(metrics[0]), const(0),
			arrayPush(urr.disposers, disposer), caps
		)
	} else {
		RenderResult([textfield], widthHeight, const(metrics[0]), const(0), [disposer], caps)
	}
}

renderTexts(texts : [Text], available : Behaviour<WidthHeight>, zorder : [int], tabOrder: [int]) -> RenderResult {
	// Text is static, so no need in using behaviours to calculate metrics

	results = mapi(texts, \i, t -> renderText(t.text, t.style, available, zorder, tabOrder));

	baseline = fold(map(results, \r -> getValue(r.baseline)), 0.0, max);

	wh = fold(results, zeroWH, \acc, r -> {
		iter(r.clips, \clip -> {
			setClipX(clip, acc.width);
			setClipY(clip, baseline - getValue(r.baseline))
		});

		WidthHeight(
			acc.width + getValue(r.widthHeight).width,
			max(acc.height, getValue(r.widthHeight).height)
		)
	});

	// Movable should be false if we have more than one Text,
	// otherwise we'll lost initial coordinates which were set by setClipX and setClipY previously.
	// And we call renderTexts only for multiple texts, otherwise renderText should be used
	caps = ClipCapabilities(false, false, true, false, true);

	clips = fold(results, [], \ac, d -> concat(ac, d.clips));
	disposers = fold(results, [], \acc, r -> concat(acc, r.disposers));

	// Hook up the total width and height
	RenderResult(clips, const(wh), const(baseline), const(0), disposers, caps);
}


setInterfaceOrientation(o : ScreenOrientation) {
	setInterfaceOrientation0(
		switch (o) {
			Portrait() : "portrait";
			Landscape() : "landscape";
			default: "none";
		}
	)
}
// now we avoid caching only per session
_DontCacheSuffix : string = "?v=" + d2s(random() * 100.0) + "_" + d2s(timestamp());
getDontCacheSuffix() {
	if (AvoidMediaCacheRequest()) _DontCacheSuffix else "";
}

preloadAndCachePicture(url_ : string, errHandler : (string) -> void) -> void {
	url = applyMediaPathMapping(url_);
	metricsFn = \w, h -> {
		CachedPicturesSizes := setTree(^CachedPicturesSizes, url, WidthHeight(w, h));
	}
	errFn = \error -> {
		CachedPicturesSizes := setTree(^CachedPicturesSizes, url, zeroWH);
		errHandler(error)
	}
	if (downloadPictures) {
		makePicture(addServerPathIfRelative(url), true, metricsFn, errFn, true, "", []) |> ignore
	}
}

getCursorShapeName(cursorShape : CursorShape) -> string {
	switch (cursorShape : CursorShape) {
		ArrowCursor(): "arrow";
		FingerCursor(): "finger";
		MoveCursor(): "move";
		TextCursor(): "text";
		CrosshairCursor() : "crosshair";
		HelpCursor() : "help";
		WaitCursor() : "wait";
		ContextMenuCursor() : "context-menu";
		ProgressCursor() : "progress";
		CopyCursor() : "copy";
		NotAllowedCursor() : "not-allowed";
		AllScrollCursor() : "all-scroll";
		ColResizeCursor() : "col-resize";
		RowResizeCursor() : "row-resize";
		NResizeCursor() : "n-resize";
		EResizeCursor() : "e-resize";
		SResizeCursor() : "s-resize";
		WResizeCursor() : "w-resize";
		NEResizeCursor() : "ne-resize";
		NWResizeCursor() : "nw-resize";
		SWResizeCursor() : "sw-resize";
		EWResizeCursor() : "ew-resize";
		NSResizeCursor() : "ns-resize";
		NESWResizeCursor() : "nesw-resize";
		NWSEResizeCursor() : "nwse-resize";
		ZoomInCursor() : "zoom-in";
		ZoomOutCursor() : "zoom-out";
		GrabCursor() : "grab";
		GrabbingCursor() : "grabbing";
		NoCursor(): "none";
		DefaultCursor() : "auto";
		EmptyCursor() : "";
	};
}

globalCursorOrder : ref Tree<[int], Pair<int, string>> = ref makeTree();
globalCursorId : ref int = ref 0;
globalCursorPoint : ref Point = ref Point(-1., -1.);

applyGlobalTopCursor() -> void {
	switch (popmax(^globalCursorOrder)) {
		PopResult(k, v, rest): {
			setCursor(v.second);
		}
		EmptyPopResult(): {
			setCursor("auto")
		}
	}
}

makeGlobalCursorListeners(
	shape : CursorShape2,
	zorder : Transform<[int]>
) -> Pair<[EventHandler], () -> void> {
	curInside = ref false;
	curId = ^globalCursorId;
	globalCursorId := curId + 1;
	shapeName = ref "auto";
	uns = ref nop;

	addCursorToTree = \ -> {
		^uns();
		uns := makeSubscribeUns(zorder, \z -> {
			globalCursorOrder := setTree(^globalCursorOrder, z, Pair(curId, ^shapeName));

			[
				\ -> if (eitherMap(lookupTree(^globalCursorOrder, z), \c -> c.first == curId, false)) {
					globalCursorOrder := removeFromTree(^globalCursorOrder, z);
				}
			]
		})();
	}

	removeCursorFromTree = \ -> {
		^uns();
		uns := nop;
	}

	// Deferred so the rolledOver is called after the rolledOut
	rolledOver = \ -> if (!^curInside) {
		curInside := true;

		if (^shapeName != "") {
			addCursorToTree();
			applyGlobalTopCursor();
		}
	};

	rolledOut = \ -> if (^curInside) {
		curInside := false;

		if (^shapeName != "") {
			removeCursorFromTree();
			applyGlobalTopCursor();
		}
	};

	Pair(
		if ((cpp || js || flash) && !mobile)
			[
				RollOver(\__ -> rolledOver()),
				RollOut(\__ -> rolledOut())
			]
		else
			[
				MouseMove2(\handled, mi -> {
					if (!handled && mi().inside)
						rolledOver()
					else
						rolledOut();

					handled
				})
			],
		switch (shape : CursorShape2) {
			ArrowCursor()       : { shapeName := getCursorShapeName(ArrowCursor());	rolledOut }
			FingerCursor()      : { shapeName := getCursorShapeName(FingerCursor()); rolledOut }
			MoveCursor()        : { shapeName := getCursorShapeName(MoveCursor()); rolledOut }
			TextCursor()        : { shapeName := getCursorShapeName(TextCursor()); rolledOut }
			CrosshairCursor()   : { shapeName := getCursorShapeName(CrosshairCursor()); rolledOut }
			HelpCursor()        : { shapeName := getCursorShapeName(HelpCursor()); rolledOut }
			WaitCursor()        : { shapeName := getCursorShapeName(WaitCursor()); rolledOut }
			ContextMenuCursor() : { shapeName := getCursorShapeName(ContextMenuCursor()); rolledOut }
			ProgressCursor()    : { shapeName := getCursorShapeName(ProgressCursor()); rolledOut }
			CopyCursor()        : { shapeName := getCursorShapeName(CopyCursor()); rolledOut }
			NotAllowedCursor()  : { shapeName := getCursorShapeName(NotAllowedCursor()); rolledOut }
			AllScrollCursor()   : { shapeName := getCursorShapeName(AllScrollCursor()); rolledOut }
			ColResizeCursor()   : { shapeName := getCursorShapeName(ColResizeCursor()); rolledOut }
			RowResizeCursor()   : { shapeName := getCursorShapeName(RowResizeCursor()); rolledOut }
			NResizeCursor()     : { shapeName := getCursorShapeName(NResizeCursor()); rolledOut }
			EResizeCursor()     : { shapeName := getCursorShapeName(EResizeCursor()); rolledOut }
			SResizeCursor()     : { shapeName := getCursorShapeName(SResizeCursor()); rolledOut }
			WResizeCursor()     : { shapeName := getCursorShapeName(WResizeCursor()); rolledOut }
			NEResizeCursor()    : { shapeName := getCursorShapeName(NEResizeCursor()); rolledOut }
			NWResizeCursor()    : { shapeName := getCursorShapeName(NWResizeCursor()); rolledOut }
			SWResizeCursor()    : { shapeName := getCursorShapeName(SWResizeCursor()); rolledOut }
			EWResizeCursor()    : { shapeName := getCursorShapeName(EWResizeCursor()); rolledOut }
			NSResizeCursor()    : { shapeName := getCursorShapeName(NSResizeCursor()); rolledOut }
			NESWResizeCursor()  : { shapeName := getCursorShapeName(NESWResizeCursor()); rolledOut }
			NWSEResizeCursor()  : { shapeName := getCursorShapeName(NWSEResizeCursor()); rolledOut }
			ZoomInCursor()      : { shapeName := getCursorShapeName(ZoomInCursor()); rolledOut }
			ZoomOutCursor()     : { shapeName := getCursorShapeName(ZoomOutCursor()); rolledOut }
			GrabCursor()        : { shapeName := getCursorShapeName(GrabCursor()); rolledOut }
			GrabbingCursor()    : { shapeName := getCursorShapeName(GrabbingCursor()); rolledOut }
			NoCursor()          : { shapeName := getCursorShapeName(NoCursor()); rolledOut }
			DefaultCursor()     : { shapeName := getCursorShapeName(DefaultCursor()); rolledOut }
			EmptyCursor()       : { shapeName := ""; nop }
			DynamicCursor(sn)   : {
				disposeCursor : () -> void =
					makeSubscribe(sn, \sn0 -> {
						prevShapeName = ^shapeName;
						shapeName := sn0 |> getCursorShapeName;

						if (^curInside) {
							if (prevShapeName == "" && ^shapeName != "") {
								addCursorToTree();
							} else if (^shapeName == "") {
								removeCursorFromTree();
							} else {
								globalCursorOrder :=
									mapTree2(
										^globalCursorOrder,
										\k, v -> {
											if (v.first == curId)
												Pair(curId, ^shapeName)
											else
												v
										}
									);
							}

							applyGlobalTopCursor();
						}
					})();

				\ -> {
					disposeCursor();
					rolledOut();
				}
			}
		}
	)
}
