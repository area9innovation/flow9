// Â© Copyright 2011 Area9 Technologies.

import transforms;
import form/optimizeform;
import sys/fullscreen;
import formats/html/html2text;
import sys/interactive;

export {
	// Render the given form on the screen
	render : (form : Form) -> (() -> void);

	renderForm(rform : Form, available : Behaviour<WidthHeight>, zorder : [int], tabOrder: [int]) -> RenderResult;

	preloadAndCachePicture(url : string, onError : (string) -> void) -> void; //To start picture download at moment of Form creation

	// Counter for pictures, videos & ActiveArt forms which are in rendering process state
	loadingContentFilesCount = make(0);
	increaseFilesCount(filesCount : DynamicBehaviour<int>) -> void;
	decreaseFilesCount(alreadyDecreased : DynamicBehaviour<bool>, filesCount : DynamicBehaviour<int>) -> void;

	getDontCacheSuffix() -> string;
	resetFocus : () -> void;

	// A transform that helps reduce the amount of size changes
	whenSizeChanged(b : Behaviour<WidthHeight>) -> Behaviour<WidthHeight>;
	whenSizeChangedu(b : Behaviour<WidthHeight>) -> Pair<Behaviour<WidthHeight>, () -> void>;

	zeroSize : ConstBehaviour<WidthHeight>;

	//must be in target.flow, but need access to getStage_, so placed here
	isPhoneScreen : () -> bool;

	isPicturesDownloadingEnabled() -> bool;


	ScreenOrientation ::= Portrait, Landscape, NoScreenOrientation;
		Portrait();
		Landscape();
		NoScreenOrientation();

	setInterfaceOrientation : (o : ScreenOrientation) -> void;

	accessibilityEnabled = ref false;

	globalRenderCount = ref 0;

	downloadPictures = !isUrlParameterFalse("download_pictures");
	showRedraw = !js && isUrlParameterTrue("redraw");

	makeGlobalCursorListeners(shape : CursorShape2, zorder : Transform<[int]>) -> Pair<[EventHandler], () -> void>;

	getCursorShapeName(cursorShape : CursorShape) -> string;

	setForceZorder(zorder : int) -> void;
	resetForceZorder() -> void;
}

// Automatic Z-order todo:
// - Keep all render's in a DList to know what starting z-order we should use
// - Get rid of all explicit z-order code

forceZorder : ref Maybe<int> = ref None();

setForceZorder(zorder : int) -> void {
	forceZorder := Some(zorder);
}

resetForceZorder() -> void {
	forceZorder := None();
}

resetFocus() -> void {
	if (flash) {
		setFocus(getStage(), true);
	}
}


allClipCapabilities = ClipCapabilities(true, true, true, true, true);

zeroSize = const(zeroWH);

emptyRenderResult = RenderResult([], zeroSize, const(0.0), const(0), [], allClipCapabilities);

isPicturesDownloadingEnabled() {
	downloadPictures
}

isPhoneScreen() {
	if (cgi) {
		false;
	} else {
		screenDiagonal = sqrt(dpow(getStageWidth(),2.0) + dpow(getStageHeight(), 2.0)) / i2d(screenDPI);
		phoneScreen = screenDiagonal < 5.9 && mobile;
		isUrlParameterTrue("mobile") || (phoneScreen && !isUrlParameterFalse("mobile"))
	}
};

// What do all these result share in capabilities?
sharedCapabilities(rs : [RenderResult]) -> ClipCapabilities {
	moveable = forall(rs, \r : RenderResult -> r.capabilities.move);
	scalable = forall(rs, \r : RenderResult -> r.capabilities.scale);
	alphable = forall(rs, \r : RenderResult -> r.capabilities.alpha);
	single = length(rs) == 1;
	ClipCapabilities(
		moveable,
		single,	// Filters do not commute
		single, // Interactions do not commute
		scalable,
		alphable,
	);
}

// maps AccessGroup's groupId -> Pair<groupTabOrder, [Child TabOrders]>
groupTabOrders : ref Tree<string, Pair<[int], [[int]]>> = ref makeTree();

// Top-level method to render a form on the entire screen
render(form : Form) -> (() -> void) {
	available = make(zeroWH);
	renCt = ^globalRenderCount;

	d1 = monitorResize(available);
	d2 = optimizeAndRenderForm(mainRenderClip(), form, available, [renCt], [renCt]);

	globalRenderCount := ^globalRenderCount + 1;
	disps = d2.disposers;
	//println(length(disps));
	\ -> { d1(); applyall(disps); if (renCt == ^globalRenderCount - 1) globalRenderCount := renCt};
}

monitorResize(awh : DynamicBehaviour<WidthHeight>) -> () -> void {
	enableResize();
	sendStageSize = \ -> {
		nextDistinct(awh, WidthHeight(getStageWidth(), getStageHeight()));
	}

	// We have to explicitly hold on to this function to keep it alive
	r = ref Some(sendStageSize);
	disposer = addEventListener(currentClip(), "resize", sendStageSize);
	// Send our size
	sendStageSize();
	\ -> { r := Some(nop); disposer(); }
}

optimizeAndRenderForm(parent : native, form : Form, available : Behaviour<WidthHeight>, zorder : [int], tabOrder: [int]) -> RenderResult {
	opfm = optimizeForm(form);
	r = renderForm(opfm, available, zorder, tabOrder);
	attachChildren(parent, r.clips, r.widthHeight, r.baseline, r.pending, r.disposers, r.capabilities);
	// Refresh stage here if required
}

// This dance concerns how to hook up any clips from a child to ourselves
attachChildren(clip : native, children : [native], widthHeight : Behaviour<WidthHeight>, baseline : Behaviour<double>,
			pending : Behaviour<int>, disposers : [() -> void], cap : ClipCapabilities) -> RenderResult {
	iter(children, \c -> {
		addChild(clip, c);
	});
	RenderResult([clip], widthHeight, baseline, pending, concat([\ -> {
			iter(children, \c -> {
				removeChild(clip, c);
			})
		}], disposers)
	, cap);
}

attachChildAndCapability(
		form : Form, d : RenderResult, hasCapability : bool,
		cap : ClipCapabilities, fn : (native) -> [() -> void]
) -> RenderResult {
	if (length(d.clips) > 0) {
		if (hasCapability) {
			disposers = concat(concatA(map(d.clips, fn)), d.disposers);
			RenderResult(d.clips, d.widthHeight, d.baseline, d.pending, disposers, cap);
		} else {
			c = makeClip();
			setClipDebugInfo(c, "form", form);
			u = fn(c);
			attachChildren(
				c, d.clips, d.widthHeight, d.baseline, d.pending,
				concat3(d.disposers, u, [\ -> { deleteNative(c); }]),
				cap
			);
		}
	} else {
		RenderResult(d.clips, d.widthHeight, d.baseline, d.pending, d.disposers, cap);
	}
}

whenSizeChanged(b : Behaviour<WidthHeight>) {
	filterWithLast(b, \l, n -> {
		abs(l.width - n.width) > 0.5 || abs(l.height - n.height) > 0.5
	});
}

whenSizeChangedu(b : Behaviour<WidthHeight>) {
	filterWithLastu(b, \l, n -> {
		abs(l.width - n.width) > 0.5 || abs(l.height - n.height) > 0.5
	});
}

// Init gesture handlers for stage
resetGestureCapture() { pinchCapture := None(); swipeCapture := None(); panCapture := None(); }
intGestureStateToFlowGestureState = \state -> if (state == 1) GestureStateProgress() else if (state == 0) GestureStateBegin() else GestureStateEnd();
stagePanDisposer = addGestureListener("pan", \state, x, y, dx, dy -> {
	ret = switch(^panCapture) {
		Some(v): v(intGestureStateToFlowGestureState(state), x, y, dx, dy);
		None(): false
	}
	if (state == 2 /* ended */) resetGestureCapture(); // No mouse up for pan
	ret
});
stagePinchDisposer = addGestureListener("pinch", \state, x, y, scale, p4 -> {
	ret = switch(^pinchCapture) {
		Some(v): v(intGestureStateToFlowGestureState(state), x, y, scale, p4);
		None(): false
	}
	if (state == 2 /* ended */) resetGestureCapture(); // No mouse up for pinch
	ret
});
stageSwipeDisposer = addGestureListener("swipe", \state, x, y, dx, dy -> switch (^swipeCapture) { Some(v): v(x, y, dx, dy); None(): false });
gestureEndDisposer = addEventListener(currentClip(), "mouseup", resetGestureCapture);

increaseFilesCount(filesCount) {
	next(filesCount, getValue(filesCount) + 1)
}
decreaseFilesCount(alreadyDecreased, filesCount) {
	if (!getValue(alreadyDecreased)) {
		//LSTSBD-696 Changed order of lines to prevent calls caused by subscribers of filesCount enter the same function with flag not set.
		next(alreadyDecreased, true);
		next(filesCount, max(getValue(filesCount) - 1, 0));
	}
}

// Render a form with the given space available
renderForm(rform : Form, available : Behaviour<WidthHeight>, zorder : [int], tabOrder: [int]) -> RenderResult {
	emptyRenderResult;
}

toDisposable(
	pair : Pair<?, () -> void>) -> Disposable<?> {

	Disposable(pair.first, pair.second);
}

DynamicGroupItem : (
	renderResult : RenderResult,
	index : DynamicBehaviour<int>,
	position : DynamicBehaviour<double>
);

zeroDynamicGroupItem : DynamicGroupItem =
	DynamicGroupItem(emptyRenderResult, make(0), make(0.0));

positionDynamicGroupItem(
	previousItem : DynamicGroupItem,
	combiner : DynamicGroupCombiner) -> Disposable<Behaviour<double>> {

	select2u(
		previousItem.position,
		previousItem.renderResult.widthHeight,
		if (combiner == LinesCombiner()) {
			\pos : double, metrics : WidthHeight ->
				pos + metrics.height;
		} else {
			\pos : double, metrics : WidthHeight ->
				pos + metrics.width;
		}
	)
		|> toDisposable;
}

subselectArray(
	array : Behaviour<[?]>,
	key : (?) -> Behaviour<??>,
	combine : ([Behaviour<??>]) -> Pair<Behaviour<??>, () -> void>
) -> Disposable<Behaviour<??>> {
	subselectSafe(array, \a ->
		combine( map(a, key) )
			|> toDisposable
	);
}

subselectSafe(
	b : Behaviour<?>,
	f : (?) -> Disposable<Behaviour<??>>
) -> Disposable<Behaviour<??>> {
	firstBehaviour = f(getValue(b));
	result = make( getValue( firstBehaviour.value ) );
	disconnect = ref connect(firstBehaviour.value, result);
	unsub = ref firstBehaviour.dispose;
	unsub2 =
		subscribe2(b, \v -> {
			^unsub();
			^disconnect();
			mapped = f(v);
			disconnect := connect(mapped.value, result);
			unsub := mapped.dispose;
		});
	Disposable(result, \ -> {
		unsub2();
		^unsub();
		^disconnect();
	})
}

// This is basically htmlEscape, but it wouldn't be good to import formats/wiki/wikiwiki here
htmlEscapeStr(str) strReplace(strReplace(strReplace(str, "&", "&amp;"), "<", "&lt;"), ">", "&gt;");
htmlUnescapeStr(str) strReplace(strReplace(strReplace(str, "&amp;", "&"), "&lt;", "<"), "&gt;", ">");

defineTextInputState(textfield : native, state : [TextInputState], wh : DynamicBehaviour<WidthHeight>, state_disposers : ref [() -> void]) -> void {
	disposers = ref [];
	iter(state, \s -> {
		switch (s : TextInputState) {
			TextInputType(inputType) : {
				switch (inputType : InputType) {
					EmailType(): {setTextInputType(textfield, "email")}
					TelType(): {setTextInputType(textfield, "tel")}
					UrlType(): {setTextInputType(textfield, "url")}
					TextType(): {setTextInputType(textfield, "text")}
					NumericType(): {setTextInputType(textfield, "number")}
					SearchType(): {setTextInputType(textfield, "search")}
					PasswordType(): {setTextInputType(textfield, "password")}
				}
			}
			AutoCompleteType(type) : {
				switch (type : ACType) {
					ACUserName(): setTextInputAutoCompleteType(textfield, "username");
					ACNewPassword(): setTextInputAutoCompleteType(textfield, "new-password");
					ACCurrentPassword(): setTextInputAutoCompleteType(textfield, "current-password");
					ACOneTimeCode(): setTextInputAutoCompleteType(textfield, "one-time-code");
				}
			}
			TextInputFilter(f) : {
				prevStr = ref getContent(textfield);
				refArrayPush(disposers, addTextInputFilter(textfield, \str -> {if (f(str)) prevStr := str; ^prevStr;}));
			}
			Multiline(multiline): setMultiline(textfield, multiline);
			WordWrap(wordWrap): setWordWrap(textfield, wordWrap);
			Numeric(numeric): {
				if (numeric) setTextInputType(textfield, "number");
			}
			ReadOnly(readOnly): setReadOnly(textfield, readOnly);
			MaxChars(n): setMaxChars(textfield, n);
			AutoAlign(autoalign): {
				setAutoAlign(textfield,
					switch (autoalign : AutoAlignType) {
					AutoAlignLeft(): "AutoAlignLeft";
					AutoAlignRight(): "AutoAlignRight";
					AutoAlignCenter(): "AutoAlignCenter";
					AutoAlignNone(): "AutoAlignNone";
					}
				);
			}
			PasswordMode(p): {
				if (p) setTextInputType(textfield, "password");
			}
			TabIndex(ind) : setTabIndex(textfield, ind);
			TabEnabled(enabled) : setTabEnabled(textfield, enabled);
			EatKeyDownOnFocus() : {};
			DoNotInvalidateStage(): {
				setDoNotInvalidateStage(textfield, true);
			}
			default: {
				if (isSameStructType(s, ScrollInfo(0, 0, 0))) {
					setScrollV(textfield, cast(s : TextInputState -> ScrollInfo).scrollV);
				} else if (isSameStructType(s, TextSize(0., 0.))) {
					tSize = cast(s : TextInputState -> TextSize);

					setTextFieldWidth(textfield, tSize.width);
					setTextFieldHeight(textfield, tSize.height);
					nextDistinct(wh, WidthHeight(getTextFieldWidth(textfield), getTextFieldHeight(textfield)));
				} else if (isSameStructType(s, Content("", []))) {
					cont = cast(s : TextInputState -> Content);

					escaped = if (flash) htmlEscapeStr(cont.content) else cont.content;
					fontSize = extractStruct(cont.style, FontSize(0.)).size;
					style = if (js) map(cont.style, \style -> {
						switch (style : CharacterStyle) {
							FontFamily(name): {
								if (isUrlParameterTrue("fontweight")) {
									FontFamily(htmlFont2familiesString(font2htmlFont(getMappedFont(name, fontSize).first)));
								} else {
									FontFamily(getMappedFont(name, fontSize).first);
								}
							}
							default: style;
						}
					}) else cont.style;
					defineTextStyle(textfield, escaped, style);
					nextDistinct(wh, WidthHeight(getTextFieldWidth(textfield), getTextFieldHeight(textfield)));
				} else if (isSameStructType(s, Selection(0, 0))) {
					sele = cast(s : TextInputState -> Selection);

					setSelection(textfield, sele.start, sele.end);
				} else if (isSameStructType(s, Focus(false))) {
					setFocus(textfield, cast(s : TextInputState -> Focus).focus);
				}
			};
		}
	});

	if (length(^disposers) > 0) {
		applyall(^state_disposers);
		state_disposers := ^disposers;
	}
}

// Temporary structures used by grid
RowInfo : (rowInfo : [RenderResult], dispose : () -> void);

// Special case for a switch with two elements, where one of them is Empty()
renderVisibleSwitch(index : Behaviour<int>, cases : [Form]) -> RenderResult {
	// When I grow up, I might be able to implement this
	emptyRenderResult;
}


renderGrid(cells : [[Form]], zorder : [int], tabOrder : [int]) -> RenderResult {
	ys = length(cells);
	if (ys == 1) {
		// TODO: We could special case this
		renderCols(cells[0], zorder, tabOrder);
	} else {
		// Find the widest row in number of cells
		xs = fold(cells, 0, \maxlength, row -> {
			w = length(row);
			max(w, maxlength)
		});
		if (xs == 1) {
			renderLines(cells, zorder, tabOrder);
		} else {
			// Prepare the coordinate streams for the rows
			rowheight : [DynamicBehaviour<double>] = map(cells, \f -> make(0.0));

			xcoords : [DynamicBehaviour<double>] = generate(0, xs + 1, \i -> make(0.0));
			colwidth = generate(0, xs, \i -> make(0.0));

			lastY = ref const(0.0);

			// Render and layout the cells
			rowInfos = mapi(cells, \rowIndex, row -> {
				yc = ^lastY;
				rowInfo = generate(0, xs, \lineIndex -> {
					if (lineIndex >= length(row) || row[lineIndex] == Empty()) {
						emptyRenderResult;
					} else {
						f = if (lineIndex == 0 && rowIndex == 0) { row[lineIndex] } else Translate(xcoords[lineIndex], yc, row[lineIndex]);
						if (availableDependent(f)) {
							// Consider to build these directly somehow instead
							aw = select2u(colwidth[lineIndex], rowheight[rowIndex], \law, lah -> WidthHeight(law, lah));
							renderForm(Constructor(f, \ -> aw.second), aw.first, zorder, concat(tabOrder, [rowIndex, lineIndex]));
						} else {
							renderForm(f, zeroSize, zorder, concat(tabOrder, [rowIndex, lineIndex]));
						}
					}
				});
				// Use heights of the row to calculate the next y coordinate
				heights = map(rowInfo, \i : RenderResult -> selectu(i.widthHeight, \wh -> wh.height));
				// Here, we throttle small changes to avoid excessive infinitesmal updates
				// that cause stack problems
				am = arrayMaxu(map(heights, firstOfPair));
				rowMax = untilChangedu(am.first, 0.5);
				uh = connect(rowMax.first, rowheight[rowIndex]);
				ly = select2u(yc, rowMax.first, \yco, rm -> yco + rm);
				lastY := ly.first;

				disp = concat3(
					map(heights, secondOfPair),
					[am.second, uh, rowMax.second, ly.second],
					concatA(map(rowInfo, \r -> r.disposers))
				);

				RowInfo(rowInfo, \ -> applyall(disp));
			});

			results : [RenderResult] = concatA(map(rowInfos, \rowinfo -> rowinfo.rowInfo));

			caps = sharedCapabilities(results);
			clips = concatA(map(results, \d -> d.clips));

			lastRowheight = lastElement(rowheight, const(0.0));

			baseline = if (rowInfos == []) Pair(const(0.0), []) else {
				ri = rowInfos[length(rowInfos) - 1];
				lastBaseline = arrayMaxu(map(ri.rowInfo, \r -> r.baseline));
				r = select3u(^lastY, lastBaseline.first, lastRowheight, \y, b, r -> b + y - r);
				Pair(r.first, [lastBaseline.second, r.second]);
			}

			pending = arrayISumu(map(results, \r -> r.pending));

			// Now set up the x coordinates
			disposers = generate(0, xs, \x -> {
				// Find the maximum width of column x
				w = ref const(0.0);
				us = map(rowInfos, \r : RowInfo -> {
					ri = (r.rowInfo)[x];
					// Here, we throttle small changes to avoid excessive infinite small updates
					// that cause stack problems
					mwh = select2u(^w, ri.widthHeight, \lw : double, rwh : WidthHeight -> {
						max(lw, rwh.width)
					});
					mw = untilChangedu(mwh.first, 0.5);
					w := mw.first;
					[mwh.second, mw.second]
				}) |> concatA;

				maxWidth = ^w;
				colMax = maxWidth;
				uc = connect(colMax, colwidth[x]);
				nextColX = select2u(xcoords[x], colMax, \xco, cm -> xco + cm);
				ux = connect(nextColX.first, xcoords[x + 1]);
				\ -> { applyall(us); uc(); ux(); nextColX.second() };
			});

			// Hook up the total width and height
			lwh = select2u(xcoords[xs], ^lastY, \w, h -> {
				WidthHeight(w,h)
			});
			wh = whenSizeChangedu(lwh.first);
			disps = concatA([disposers, baseline.second, [lwh.second, wh.second, pending.second], map(rowInfos, \r -> r.dispose)]);
			RenderResult(
				clips, wh.first, baseline.first, pending.first,
				[\ -> applyall(disps)],
				caps
			);
		}
	}
}

renderCols(row : [Form], zorder : [int], tabOrder : [int]) -> RenderResult {
	lastWH : ref Behaviour<WidthHeight> = ref zeroSize;
	// This is to make the available height correct
	height = make(0.0);
	results = mapi(row, \rowIndex, c -> {
		f = if (rowIndex == 0) c else {
			l = selectu(^lastWH, \wh -> wh.width);
			Constructor(Translate(l.first, const(0.0), c), \ -> l.second);
		}
		ri = if (availableDependent(c)) {
			widthHeight = make(zeroWH);
			r = renderForm(f, widthHeight, zorder, arrayPush(tabOrder, rowIndex));
			// Some subtlety in hooking up the available width and height
			u1 = subscribe(r.widthHeight, \wh -> nextDistinct(widthHeight, WidthHeight(wh.width, getValue(height))));
			u2 = subscribe(height, \h -> nextDistinct(widthHeight, WidthHeight((getValue(r.widthHeight)).width, h)));
			RenderResult(r.clips, r.widthHeight, r.baseline, r.pending, concat(r.disposers, [u1, u2]), r.capabilities);
		} else {
			renderForm(f, zeroSize, zorder, arrayPush(tabOrder, rowIndex));
		}

		lwh = select2u(^lastWH, ri.widthHeight,
				\lwh : WidthHeight, rwh : WidthHeight -> {
					WidthHeight(lwh.width + rwh.width, max(lwh.height, rwh.height));
				}
			);

		sc = whenSizeChangedu(lwh.first);

		lastWH := sc.first;
		RenderResult(ri.clips, ri.widthHeight, ri.baseline, ri.pending, concat(ri.disposers, [lwh.second, sc.second]), ri.capabilities);
	});
	un = subscribe(^lastWH, \wh -> nextDistinct(height, wh.height));

	baseline = arrayMaxu(map(results, \r -> r.baseline));

	caps = sharedCapabilities(results);
	clips = concatA(map(results, \d -> d.clips));
	pending = arrayISumu(map(results, \r -> r.pending));
	disposers = concat([un, baseline.second, pending.second], concatA(map(results, \r -> r.disposers)));

	// Hook up the total width and height
	RenderResult(clips, ^lastWH, baseline.first, pending.first, [\ -> applyall(disposers)], caps);
}

renderLines(lines : [[Form]], zorder : [int], tabOrder : [int]) -> RenderResult {
	lastWH : ref Behaviour<WidthHeight> = ref zeroSize;

	// Here, we make the available width correct
	width = make(0.0);

	results = mapi(lines, \lineIndex, row -> {
		if (length(row) == 0) {
			emptyRenderResult;
		} else {
			c = row[0];
			lh = selectu(^lastWH, \wh -> wh.height);
			f = if (lineIndex == 0 || c == Empty()) c else Translate(const(0.0), lh.first, c);
			ri : RenderResult = if (availableDependent(c)) {
				// The available width/height
				widthHeight = make(zeroWH);
				r = renderForm(f, widthHeight, zorder, arrayPush(tabOrder, lineIndex));
				// Some subtlety in hooking up the available width and height
				u1 = subscribe(r.widthHeight, \wh -> nextDistinct(widthHeight, WidthHeight(getValue(width), wh.height)));
				u2 = subscribe(width, \w -> nextDistinct(widthHeight, WidthHeight(w, (getValue(r.widthHeight)).height)));
				RenderResult(r.clips, r.widthHeight, r.baseline, r.pending, concat(r.disposers, [lh.second, u1, u2]), r.capabilities);
			} else {
				r = renderForm(f, zeroSize, zorder, arrayPush(tabOrder, lineIndex));
				RenderResult(r.clips, r.widthHeight, r.baseline, r.pending, arrayPush(r.disposers, lh.second), r.capabilities);
			}
			if (ri != emptyRenderResult) {
				t = select2u(^lastWH, ri.widthHeight,
						\lwh : WidthHeight, rwh : WidthHeight -> {
								WidthHeight(max(lwh.width, rwh.width), lwh.height + rwh.height);
				});
				sc = whenSizeChangedu(t.first);
				lastWH := sc.first;
				RenderResult(ri.clips, ri.widthHeight, ri.baseline, ri.pending, concat(ri.disposers, [t.second, sc.second]), ri.capabilities);
			} else {
				ri;
			}
		}
	});
	lastBaseline = lastElement(map(results, \r -> r.baseline), const(0.0));
	lastMetrics = lastElement(map(results, \r -> r.widthHeight), const(zeroWH));
	baseline = select3u(^lastWH, lastBaseline, lastMetrics, \y, b, m -> {
		b + y.height - m.height
	});
	un = subscribe(^lastWH, \wh -> {
		if (abs(getValue(width) - wh.width) > 0.5) {
			nextDistinct(width, wh.width)
		}
	});

	caps = sharedCapabilities(results);
	clips = concatA(map(results, \d -> d.clips));
	pending = arrayISumu(map(results, \r -> r.pending));
	disposers = concat([un, baseline.second, pending.second], concatA(map(results, \r -> r.disposers)));

	// Hook up the total width and height
	RenderResult(clips, ^lastWH, baseline.first, pending.first, [\ -> applyall(disposers)], caps);
}


renderText(text : string, style : [CharacterStyle], available : Behaviour<WidthHeight>, zorder : [int], tabOrder: [int]) -> RenderResult {
	textfield = makeTextfield(getFontFamily(style));
	setTextDirection(textfield, if (getDefaultRtl()) "rtl" else "ltr");
	setEscapeHTML(textfield, extractStruct(style, EscapeHTML(false)).escape);
	defineTextStyle(textfield, text, style);

	metrics = getTextMetrics(textfield);

	disposer = \ -> {
		// Flash is not very helpful: If a text has the focus, but dies, then we effectively lose focus
		if (flash && getFocus(textfield)) {
			setFocus(getStage(), true);
		}
		deleteNative(textfield);
	}

	widthHeight = const(WidthHeight(getTextFieldWidth(textfield), getTextFieldHeight(textfield)));
	caps = ClipCapabilities(true, false, true, false, true);

	uStruct = fold(style, None(), \acc, s -> switch(s) { Underlined(v): Some(s); default: acc});
	if (isSome(uStruct)) {
		uStyle = either(uStruct, Underlined([])).style;
		urr = renderForm(
			Graphics(
				[
					// TODO: it is the same as TUnderline. Replace height by underline_position
					// or at least consider to replace by baseline +
					MoveTo(0.0, getValue(widthHeight).height - 1.0),
					LineTo(getValue(widthHeight).width, getValue(widthHeight).height - 1.0),
				],
				// if style for underline is specified then use it,
				// otherwise use the one that is used by text
				if (uStyle != []) uStyle
				else [
					// TODO: add underline_thickness
					Stroke(extractStruct(style, Fill(0x000000)).color)
				]
			),
			available, zorder, tabOrder
		);

		RenderResult(
			arrayPush(urr.clips, textfield), widthHeight, const(metrics[0]), const(0),
			arrayPush(urr.disposers, disposer), caps
		)
	} else {
		RenderResult([textfield], widthHeight, const(metrics[0]), const(0), [disposer], caps)
	}
}

renderTexts(texts : [Text], available : Behaviour<WidthHeight>, zorder : [int], tabOrder: [int]) -> RenderResult {
	// Text is static, so no need in using behaviours to calculate metrics

	results = mapi(texts, \i, t -> renderText(t.text, t.style, available, zorder, tabOrder));

	baseline = fold(map(results, \r -> getValue(r.baseline)), 0.0, max);

	wh = fold(results, zeroWH, \acc, r -> {
		iter(r.clips, \clip -> {
			setClipX(clip, acc.width);
			setClipY(clip, baseline - getValue(r.baseline))
		});

		WidthHeight(
			acc.width + getValue(r.widthHeight).width,
			max(acc.height, getValue(r.widthHeight).height)
		)
	});

	// Movable should be false if we have more than one Text,
	// otherwise we'll lost initial coordinates which were set by setClipX and setClipY previously.
	// And we call renderTexts only for multiple texts, otherwise renderText should be used
	caps = ClipCapabilities(false, false, true, false, true);

	clips = fold(results, [], \ac, d -> concat(ac, d.clips));
	disposers = fold(results, [], \acc, r -> concat(acc, r.disposers));

	// Hook up the total width and height
	RenderResult(clips, const(wh), const(baseline), const(0), disposers, caps);
}


setInterfaceOrientation(o : ScreenOrientation) {
	setInterfaceOrientation0(
		switch (o) {
			Portrait() : "portrait";
			Landscape() : "landscape";
			default: "none";
		}
	)
}
// now we avoid caching only per session
_DontCacheSuffix = "?v=" + d2s(random() * 100.0) + "_" + d2s(timestamp());
getDontCacheSuffix() {
	if (AvoidMediaCacheRequest()) _DontCacheSuffix else "";
}

preloadAndCachePicture(url_ : string, errHandler : (string) -> void) -> void {
	url = applyMediaPathMapping(url_);
	metricsFn = \w, h -> {
		CachedPicturesSizes := setTree(^CachedPicturesSizes, url, WidthHeight(w, h));
	}
	errFn = \error -> {
		CachedPicturesSizes := setTree(^CachedPicturesSizes, url, zeroWH);
		errHandler(error)
	}
	if (downloadPictures) {
		makePicture(addServerPathIfRelative(url), true, metricsFn, errFn, true) |> ignore
	}
}

getCursorShapeName(cursorShape : CursorShape) -> string {
	switch (cursorShape : CursorShape) {
		ArrowCursor(): "arrow";
		FingerCursor(): "finger";
		MoveCursor(): "move";
		TextCursor(): "text";
		CrosshairCursor() : "crosshair";
		HelpCursor() : "help";
		WaitCursor() : "wait";
		ContextMenuCursor() : "context-menu";
		ProgressCursor() : "progress";
		CopyCursor() : "copy";
		NotAllowedCursor() : "not-allowed";
		AllScrollCursor() : "all-scroll";
		ColResizeCursor() : "col-resize";
		RowResizeCursor() : "row-resize";
		NResizeCursor() : "n-resize";
		EResizeCursor() : "e-resize";
		SResizeCursor() : "s-resize";
		WResizeCursor() : "w-resize";
		NEResizeCursor() : "ne-resize";
		NWResizeCursor() : "nw-resize";
		SWResizeCursor() : "sw-resize";
		EWResizeCursor() : "ew-resize";
		NSResizeCursor() : "ns-resize";
		NESWResizeCursor() : "nesw-resize";
		NWSEResizeCursor() : "nwse-resize";
		ZoomInCursor() : "zoom-in";
		ZoomOutCursor() : "zoom-out";
		GrabCursor() : "grab";
		GrabbingCursor() : "grabbing";
		NoCursor(): "none";
		DefaultCursor() : "auto";
		EmptyCursor() : "";
	};
}

globalCursorOrder : ref Tree<[int], Pair<int, string>> = ref makeTree();
globalCursorId : ref int = ref 0;
globalCursorPoint : ref Point = ref Point(-1., -1.);

applyGlobalTopCursor() -> void {
	switch (popmax(^globalCursorOrder)) {
		PopResult(k, v, rest): {
			setCursor(v.second);
		}
		EmptyPopResult(): {
			setCursor("auto")
		}
	}
}

makeGlobalCursorListeners(
	shape : CursorShape2,
	zorder : Transform<[int]>
) -> Pair<[EventHandler], () -> void> {
	curInside = ref false;
	curId = ^globalCursorId;
	globalCursorId := curId + 1;
	shapeName = ref "auto";
	uns = ref nop;

	addCursorToTree = \ -> {
		^uns();
		uns := makeSubscribeUns(zorder, \z -> {
			globalCursorOrder := setTree(^globalCursorOrder, z, Pair(curId, ^shapeName));

			[
				\ -> if (eitherMap(lookupTree(^globalCursorOrder, z), \c -> c.first == curId, false)) {
					globalCursorOrder := removeFromTree(^globalCursorOrder, z);
				}
			]
		})();
	}

	removeCursorFromTree = \ -> {
		^uns();
		uns := nop;
	}

	// Deferred so the rolledOver is called after the rolledOut
	rolledOver = \ -> if (!^curInside) {
		curInside := true;

		if (^shapeName != "") {
			addCursorToTree();
			applyGlobalTopCursor();
		}
	};

	rolledOut = \ -> if (^curInside) {
		curInside := false;

		if (^shapeName != "") {
			removeCursorFromTree();
			applyGlobalTopCursor();
		}
	};

	Pair(
		if ((cpp || js || flash) && !mobile)
			[
				RollOver(\__ -> rolledOver()),
				RollOut(\__ -> rolledOut())
			]
		else
			[
				MouseMove2(\handled, mi -> {
					if (!handled && mi().inside)
						rolledOver()
					else
						rolledOut();

					handled
				})
			],
		switch (shape : CursorShape2) {
			ArrowCursor()       : { shapeName := getCursorShapeName(ArrowCursor());	rolledOut }
			FingerCursor()      : { shapeName := getCursorShapeName(FingerCursor()); rolledOut }
			MoveCursor()        : { shapeName := getCursorShapeName(MoveCursor()); rolledOut }
			TextCursor()        : { shapeName := getCursorShapeName(TextCursor()); rolledOut }
			CrosshairCursor()   : { shapeName := getCursorShapeName(CrosshairCursor()); rolledOut }
			HelpCursor()        : { shapeName := getCursorShapeName(HelpCursor()); rolledOut }
			WaitCursor()        : { shapeName := getCursorShapeName(WaitCursor()); rolledOut }
			ContextMenuCursor() : { shapeName := getCursorShapeName(ContextMenuCursor()); rolledOut }
			ProgressCursor()    : { shapeName := getCursorShapeName(ProgressCursor()); rolledOut }
			CopyCursor()        : { shapeName := getCursorShapeName(CopyCursor()); rolledOut }
			NotAllowedCursor()  : { shapeName := getCursorShapeName(NotAllowedCursor()); rolledOut }
			AllScrollCursor()   : { shapeName := getCursorShapeName(AllScrollCursor()); rolledOut }
			ColResizeCursor()   : { shapeName := getCursorShapeName(ColResizeCursor()); rolledOut }
			RowResizeCursor()   : { shapeName := getCursorShapeName(RowResizeCursor()); rolledOut }
			NResizeCursor()     : { shapeName := getCursorShapeName(NResizeCursor()); rolledOut }
			EResizeCursor()     : { shapeName := getCursorShapeName(EResizeCursor()); rolledOut }
			SResizeCursor()     : { shapeName := getCursorShapeName(SResizeCursor()); rolledOut }
			WResizeCursor()     : { shapeName := getCursorShapeName(WResizeCursor()); rolledOut }
			NEResizeCursor()    : { shapeName := getCursorShapeName(NEResizeCursor()); rolledOut }
			NWResizeCursor()    : { shapeName := getCursorShapeName(NWResizeCursor()); rolledOut }
			SWResizeCursor()    : { shapeName := getCursorShapeName(SWResizeCursor()); rolledOut }
			EWResizeCursor()    : { shapeName := getCursorShapeName(EWResizeCursor()); rolledOut }
			NSResizeCursor()    : { shapeName := getCursorShapeName(NSResizeCursor()); rolledOut }
			NESWResizeCursor()  : { shapeName := getCursorShapeName(NESWResizeCursor()); rolledOut }
			NWSEResizeCursor()  : { shapeName := getCursorShapeName(NWSEResizeCursor()); rolledOut }
			ZoomInCursor()      : { shapeName := getCursorShapeName(ZoomInCursor()); rolledOut }
			ZoomOutCursor()     : { shapeName := getCursorShapeName(ZoomOutCursor()); rolledOut }
			GrabCursor()        : { shapeName := getCursorShapeName(GrabCursor()); rolledOut }
			GrabbingCursor()    : { shapeName := getCursorShapeName(GrabbingCursor()); rolledOut }
			NoCursor()          : { shapeName := getCursorShapeName(NoCursor()); rolledOut }
			DefaultCursor()     : { shapeName := getCursorShapeName(DefaultCursor()); rolledOut }
			EmptyCursor()       : { shapeName := ""; nop }
			DynamicCursor(sn)   : {
				disposeCursor : () -> void =
					makeSubscribe(sn, \sn0 -> {
						prevShapeName = ^shapeName;
						shapeName := sn0 |> getCursorShapeName;

						if (^curInside) {
							if (prevShapeName == "" && ^shapeName != "") {
								addCursorToTree();
							} else if (^shapeName == "") {
								removeCursorFromTree();
							} else {
								globalCursorOrder :=
									mapTree2(
										^globalCursorOrder,
										\k, v -> {
											if (v.first == curId)
												Pair(curId, ^shapeName)
											else
												v
										}
									);
							}

							applyGlobalTopCursor();
						}
					})();

				\ -> {
					disposeCursor();
					rolledOut();
				}
			}
		}
	)
}
