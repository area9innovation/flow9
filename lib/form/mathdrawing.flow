// Â© Copyright 2011 Area9 Technologies.

// Awesome link for LaTeX rendering: http://arachnoid.com/latex/

import form/form;
import form/gui;
import form/formtransforms;
import form/baseline;
import form/formutils;
import ui/table2d; // Table2dd
import form/mathdrawingstructs;

export {
	// Single brackets
	/////////////////////
	createBracket : (WriteBracketType, double) -> Form;
	createBracketWithColor : (WriteBracketType, double, int) -> Form;
	createBracketWithColorAndSize : (WriteBracketType, double, int, double) -> Form;



	// Brackets
	/////////////////////
	brackets2form : (WriteBracketType, WriteBracketType, Form) -> Form;
	brackets2formWithColor : (WriteBracketType, WriteBracketType, Form, int) -> Form;
	brackets2formWithColorAndWrap(lb : WriteBracketType, rb : WriteBracketType, body : Form, color : int, wrappersLeft : MathFormWrappers, wrapppersRight : MathFormWrappers, fontSize : double) -> Form;

	bracket2formSelectedAndWrap(type : WriteBracketType, backColor : Maybe<int>, heightB : Behaviour<double>, wrappers : MathFormWrappers, fontSize : double) -> Form;
	brackets2formSelected(lb : WriteBracketType, rb : WriteBracketType, body : Form, fontColor : int, backColor : Maybe<int>) -> Form;

	// Dotted
	/////////////////////
	dotted2form : (Form, left : int, top : int, right : int, bottom : int, leftSign : bool, rightSign : bool) -> Form;
	dotted2formWithColor : (Form, left : int, top : int, right : int, bottom : int, leftSign : bool, rightSign : bool, int) -> Form;

	// Definite control
	/////////////////////
	definiteControl2form : (DefiniteControlSignType, Form, Form, Form) -> Form;
	definiteControl2formWithColor : (DefiniteControlSignType, Form, Form, Form, int) -> Form;
	evaluatingIntegral2form : (Form, Form, Form) -> Form;
	evaluatingIntegral2formWithColor : (Form, Form, Form, int) -> Form;

	// Fractions
	/////////////////////
	fraction2form : (Form, Form) -> Form;
	fraction2formWithColor : (Form, Form, int) -> Form;
	fraction2formWrap(num : Form, denum : Form, wrappers : MathFormWrappers, fontSize : double) -> Form;
	fraction2formWrapPair(num : Form, denum : Form, wrappers : MathFormWrappers, fontSize : double) -> Pair<Form, Behaviour<double>>; //with denumenator VOffset

	fraction2formTriple(num : Form, middle : Form, denum : Form) -> Form;
	fraction2formTriple2(num : Form, middle : Form, denum : Form) -> Pair<Form, Triple<Behaviour<double>, Behaviour<double>, Behaviour<double>>>;

	// Roots
	/////////////////////
	root2form : (Form, Form) -> Form;
	root2formWithColor : (Form, Form, int) -> Form;
	root2formWrap(degree : Form, body : Form, fontSize : double, wrappers : MathFormWrappers) -> Form;
	// with degree and body offsets
	root2formWrapTriple(degree : Form, body : Form, fontSize : double, wrappers : MathFormWrappers) -> Triple<Form, Behaviour<double>, Behaviour<double>>;

	// Sigma
	/////////////////////
	sigma2formWrap(from : Form, to : Form, body : Form, wrappers : MathFormWrappers, fontSize : double) -> Form;
	// version with from, to and body vOffsets
	sigma2formWrapQuadruple(from : Form, to : Form, body : Form, wrappers : MathFormWrappers, fontSize : double) -> Quadruple<Form, Behaviour<double>, Behaviour<double>, Behaviour<double>>;

	// Long division
	/////////////////////
	longDivision2form : (Form) -> Form;
	longDivision2formWithColor : (Form, int) -> Form;

	// Division symbol
	/////////////////////
	divisionSymbol(fontSize : double) -> Form;
	divisionSymbolWithColor(fontSize : double, color : int) -> Form;

	// Superscript
	/////////////////////
	superscript2form(body : Form, degree : Form) -> Form;

	superscript2form2(body : Form, degree : Form, flipped : bool, left : bool) -> Form;

	superscript2formWrap(body : Form, degree : Form, wrappers : MathFormWrappers) -> Form;

	// could be used to create subscript
	superscript2formWrap2(body : Form, degree : Form, wrappers : MathFormWrappers, flipped : bool, topaligned : bool, left : bool) -> Form;
	// version with body upper margin
	superscript2formWrap2Pair(body : Form, degree : Form, wrappers : MathFormWrappers, flipped : bool, topaligned : bool, left : bool) -> Pair<Form, Behaviour<double>>;

	// could be used to create subscript
	//Old code is necessary to give other rendering result
	superscript2formWrap3(body : Form, degree : Form, wrappers : MathFormWrappers, flipped : bool) -> Form;

	superscript2formTriple(body : Form, middle : Form, degree : Form) -> Form;
	superscript2formTriple2(body : Form, middle : Form, degree : Form) -> Pair<Form, Pair<Behaviour<double>, Behaviour<double>>>;

	// Subscript
	/////////////////////
	subscript2form : (Form, Form) -> Form;

	doubleSubscript2form(body : Form, left : Form, right : Form) -> Form;
	doubleSubscript2form2(body : Form, left : Form, right : Form) -> Pair<Form, Pair<Behaviour<double>, Behaviour<double>>>;

	// Overscript
	/////////////////////
	overscript2form : (Form, Form) -> Form;

	// Underscript
	/////////////////////
	underscript2form : (Form, Form) -> Form;

	// Sup and sub script
	/////////////////////
	supSubScript2form(body : Form, sup : Form, sub : Form, wrappers : MathFormWrappers) -> Form;
	supSubScript2form2(body : Form, sup : Form, sub : Form, left : bool) -> Form;
	supSubScript2form3(body : Form, sup : Form, sub : Form, wrappers : MathFormWrappers, left : bool) -> Form;
	supSubScript2form4(body : Form, sup : Form, sub : Form, wrappers : MathFormWrappers, left : bool) -> Pair<Form, Pair<Behaviour<double>, Behaviour<double>>>;

	// Strike out
	/////////////////////
	strikeOut(Form) -> Form;
	strikeOutWithColor(form : Form, color: int, dx: double, dy : double) -> Form;

	// Signs
	////////////////////
	createSign : (DefiniteControlSignType) -> Form;
	createSignWithColor : (DefiniteControlSignType, int) -> Form;
	createSignWithColorAndSize : (DefiniteControlSignType, int, double) -> Form;

	// Cases
	////////////////////
	cases2formWrap(cases : [[Form]], wrappers : MathFormWrappers, fontSize : double) -> Form;
	// with y-offset of each cell
	cases2formWrap2(cases : [[Form]], wrappers : MathFormWrappers, fontSize : double) -> Pair<Form, [[Behaviour<double>]]>;

	// Top modificators
	////////////////////
	topModificator2form(form : Form, type : WriteTopModificator, size : WriteTopModificatorSize, corrections : WriteTopModificatorCorrections) -> Form;
	topModificator2formWithColor(form : Form, type : WriteTopModificator, size : WriteTopModificatorSize, corrections : WriteTopModificatorCorrections, color : int) -> Form;
	topModificator2formWrap(form : Form, type : WriteTopModificator, size : WriteTopModificatorSize, corrections : WriteTopModificatorCorrections, wrappers : MathFormWrappers) -> Form;
	topModificator2formWrap2(form : Form, type : WriteTopModificator, size : WriteTopModificatorSize, corrections : WriteTopModificatorCorrections, wrappers : MathFormWrappers) -> Pair<Form, Behaviour<double>>;

	// Utils
	////////////////////
	// center this form horizontally over other form
	CenterH(myWidth : Behaviour<double>, otherWidth : Behaviour<double>, form : Form) -> Form;

	// wrappers that could be used to add special behaviour to the form parts including glyph itself and/or fillers around
	MathFormWrappers : (
		wrapGlyph : ((int, Maybe<int>) -> Form) -> Form, // parameters are: front color, back color
		wrapTopLeft : (Form) -> Form,	// top-left filler
		wrapTopRight : (Form) -> Form,	// top-right filler
		wrapBottomLeft : (Form) -> Form,	// bottom-left filler
		wrapBottomRight : (Form) -> Form,	// bottom-right filler
	);

	MathFillersWrappers(wrapTL, wrapTR, wrapBL, wrapBR) -> MathFormWrappers { MathFormWrappers(\fn -> fn(black, None()), wrapTL, wrapTR, wrapBL, wrapBR) }

	MathGlyphWrappers(wrapGlyph) -> MathFormWrappers { MathFormWrappers(wrapGlyph, idfn, idfn, idfn, idfn) }

	ColoredMathGlyphWrappers(color : int) -> MathFormWrappers { MathGlyphWrappers(\fn -> fn(color, None())) }

	DummyMathFormWrappers() -> MathFormWrappers { ColoredMathGlyphWrappers(black) }
}

/////////////////////
// Single brackets
/////////////////////

createBracket(type, height) {
	createBracketWithColor(type, height, black)
}

createBracketWithColor(type, bodyHeight, color) {
	createBracketWithColorAndSize(type, bodyHeight, color, 0.0)
}

createBracketWithColorAndSize(type, bodyHeight, color, fontSize) {
	isSmall = (bodyHeight < 2.0 * fontSize);

	height = if (isSmall) fontSize else bodyHeight;
	deepness = if (isSmall) height / 4.0 else sqrt(height) + 1.0;

	h = 22.0;
	yScale = height / h;

	border = fontSize / 10.0;

	form =
	switch(type : WriteBracketType) {
		WriteAbsSign() : {
			Size2(
				const(WidthHeight(5.0, height)),
				Graphics(
					[
						MoveTo(3.0, 0.0),
						LineTo(3.0, height),
					],
					[Stroke(color)]
				)
			)
		}
		WriteNormSign() : {
			Size2(
				const(WidthHeight(10.0, height)),
				Cols([
					Graphics(
						[
							MoveTo(3.0, 0.0),
							LineTo(3.0, height),
						],
						[Stroke(color)]
					),
					Graphics(
						[
							MoveTo(3.0, 0.0),
							LineTo(3.0, height),
						],
						[Stroke(color)]
					)
				])
			)
		}
		WriteLeftBrace() : {
			Size2(
				const(WidthHeight(deepness, height)),
				Graphics(
					[
						MoveTo(deepness, 0.0),
						CubicBezierTo(deepness / 2.0, 4.0 * yScale, deepness / 2.0, 0.0 * yScale),
						LineTo(deepness / 2.0, 7.0 * yScale),
						CubicBezierTo(deepness / 10.0, height * 0.5, deepness / 2.0, 0.5 * height),
						MoveTo(deepness, h * yScale),
						CubicBezierTo(deepness / 2.0, 18.0 * yScale, deepness / 2.0, h * yScale),
						LineTo(deepness / 2.0, 15.0 * yScale),
						CubicBezierTo(deepness / 10.0, height * 0.5, deepness / 2.0, 0.5 * height),
					],
					[Stroke(color)]
				)
			)
		}
		WriteRightBrace() : {
			Size2(
				const(WidthHeight(deepness, height)),
				Graphics(
					[
						MoveTo(0.0, 0.0),
						CubicBezierTo(deepness / 2.0, 4.0 * yScale, deepness / 2.0, 0.0 * yScale),
						LineTo(deepness / 2.0, 7.0 * yScale),
						CubicBezierTo(deepness * 0.9, height * 0.5, deepness / 2.0, 0.5 * height),
						MoveTo(0.0, h * yScale),
						CubicBezierTo(deepness / 2.0, 18.0 * yScale, deepness / 2.0, h * yScale),
						LineTo(deepness / 2.0, 15.0 * yScale),
						CubicBezierTo(deepness * 0.9, height * 0.5, deepness / 2.0, 0.5 * height),
					],
					[Stroke(color)]
				)
			)
		}
		WriteLeftBracket() : {
			Size2(
				const(WidthHeight(deepness + border, height)),
				Graphics(
					{
						lx1 = - deepness;
						lx2 = lx1 + sqrt(deepness);
						[
							MoveTo(deepness * 0.8 + border, 0.0),
							CubicBezierTo(deepness * 0.8 + border, height, lx2 + border, height / 2.0),
							CubicBezierTo(deepness * 0.8 + border, 0.0, lx1 + border, height / 2.0),
							ClosePath()
						];
					},
					[Fill(color)]
				)
			)
		}
		WriteRightBracket() : {
			Size2(
				const(WidthHeight(deepness + border, height)),
				Graphics(
					{
						lx1 = 2.0 * deepness;
						lx2 = lx1 - sqrt(deepness);
						[
							MoveTo(deepness * 0.2, 0.0),
							CubicBezierTo(deepness * 0.2, height, lx1, height / 2.0),
							CubicBezierTo(deepness * 0.2, 0.0, lx2, height / 2.0),
							ClosePath()
						];
					},
					[Fill(color)]
				)
			)
		}
		WriteLeftSquareBracket() : {
			Size2(
				const(WidthHeight(8.0, height)),
				Graphics(
					[
						MoveTo(7.0, 0.0),
						LineTo(3.0, 0.0),
						LineTo(3.0, height),
						LineTo(7.0, height),
					],
					[Stroke(color)]
				)
			)
		}
		WriteRightSquareBracket() : {
			Size2(
				const(WidthHeight(8.0, height)),
				Graphics(
					[
						MoveTo(1.0, 0.0),
						LineTo(5.0, 0.0),
						LineTo(5.0, height),
						LineTo(1.0, height),
					],
					[Stroke(color)]
				)
			)
		}
		WriteLeftFloorBracket() : {
			Size2(
				const(WidthHeight(8.0, height)),
				Graphics(
					[
						MoveTo(3.0, 0.0),
						LineTo(3.0, height),
						LineTo(7.0, height),
					],
					[Stroke(color)]
				)
			)
		}
		WriteRightFloorBracket() : {
			Size2(
				const(WidthHeight(8.0, height)),
				Graphics(
					[
						MoveTo(5.0, 0.0),
						LineTo(5.0, height),
						LineTo(1.0, height),
					],
					[Stroke(color)]
				)
			)
		}
		WriteLeftCeilBracket() : {
			Size2(
				const(WidthHeight(8.0, height)),
				Graphics(
					[
						MoveTo(7.0, 0.0),
						LineTo(3.0, 0.0),
						LineTo(3.0, height),
					],
					[Stroke(color)]
				)
			)
		}
		WriteRightCeilBracket() : {
			Size2(
				const(WidthHeight(8.0, height)),
				Graphics(
					[
						MoveTo(1.0, 0.0),
						LineTo(5.0, 0.0),
						LineTo(5.0, height),
					],
					[Stroke(color)]
				)
			)
		}
		WriteLeftDoubleSquareBracket() : {
			Size2(
				const(WidthHeight(11.0, height)),
				Graphics(
					[
						MoveTo(10.0, 0.0),
						LineTo(3.0, 0.0),
						LineTo(3.0, height),
						LineTo(10.0, height),
						MoveTo(6.0, 0.0),
						LineTo(6.0, height),
					],
					[Stroke(color)]
				)
			)
		}
		WriteRightDoubleSquareBracket() : {
			Size2(
				const(WidthHeight(11.0, height)),
				Graphics(
					[
						MoveTo(1.0, 0.0),
						LineTo(8.0, 0.0),
						LineTo(8.0, height),
						LineTo(1.0, height),
						MoveTo(5.0, 0.0),
						LineTo(5.0, height),
					],
					[Stroke(color)]
				)
			)
		}
		WriteNoBracket() : {
			Empty()
		}
	};

	if (isSmall && form != Empty()) {
		Offset(0.0, (bodyHeight - height) / 1.5, form)
	} else {
		form
	}
}

bracket2formSelectedAndWrap(
	type : WriteBracketType,
	backColor : Maybe<int>,
	heightB : Behaviour<double>,
	wrappers : MathFormWrappers,
	fontSize : double
) -> Form {
	if (type == WriteNoBracket()) {
		Empty()
	} else {
		wrappers.wrapGlyph(\fc, __ -> Select(heightB, \height -> { BoxBehindMaybe(createBracketWithColorAndSize(type, height, fc, fontSize), backColor) }) )
	}
}

/////////////////////
// Brackets
/////////////////////
brackets2form(lb : WriteBracketType, rb : WriteBracketType, body : Form) -> Form {
	brackets2formWithColor(lb, rb, body, black)
}

brackets2formWithColor(lb : WriteBracketType, rb : WriteBracketType, body : Form, color : int) -> Form {
	brackets2formSelected(lb, rb, body, color, None())
}

brackets2formWithColorAndWrap(lb : WriteBracketType, rb : WriteBracketType, body : Form, color : int, wrappersLeft : MathFormWrappers, wrappersRight : MathFormWrappers, fontSize : double) -> Form {
	brackets2formSelectedAndWrap(lb, rb, body, color, None(), wrappersLeft, wrappersRight, fontSize)
}

brackets2formSelected(lb : WriteBracketType, rb : WriteBracketType, body : Form, fontColor : int, backColor : Maybe<int>) -> Form {
	brackets2formSelectedAndWrap(lb, rb, body, fontColor, backColor, ColoredMathGlyphWrappers(fontColor), ColoredMathGlyphWrappers(fontColor), 0.0);
}

brackets2formSelectedAndWrap(
	lb : WriteBracketType,
	rb : WriteBracketType,
	body : Form,
	fontColor : int,
	backColor : Maybe<int>,
	wrappersLeft : MathFormWrappers,
	wrappersRight : MathFormWrappers,
	fontSize : double
) -> Form {

	// with this constant brackets together with outer content looks more pretty. I could not find general solution.
	bracketsOffset = 5.0;

	unpair(getDynamicFormSize(body), \bodyForm : Form, bodySizeB : Behaviour<FormMetrics> -> {
		heightB = make(0.0);
		baselineB = make(0.0);

		Constructor(
			fixBaselineB(
				baselineB,
				Cols([
					bracket2formSelectedAndWrap(lb, backColor, heightB, wrappersLeft, fontSize),
					bodyForm,
					bracket2formSelectedAndWrap(rb, backColor, heightB, wrappersRight, fontSize)
				])
			),
			makeSubscribe(bodySizeB, \bodySize-> {
				nextDistinct(heightB, bodySize.height);
				nextDistinct(baselineB, bodySize.height / 2.0 + bracketsOffset);
			})
		);
	})
}

/////////////////////
// Dotted
/////////////////////
dotted2form(body, left, top, right, bottom, leftSign, rightSign) {
	dotted2formWithColor(body, left, top, right, bottom, leftSign, rightSign, black)
}

dotted2formWithColor(body, left, top, right, bottom, leftSign, rightSign, color) {
	//todo: change approach to calculation of size. It does not work correctly for big amount of dots.

	calcDottedElementMetrics = \radius, storyWidth, storyHeight -> {

		//********** Calc width of element ***************

		//calc left and right widths
		leftWidth = if (leftSign || left > 0) 4.0 * radius else 0.0;
		rightWidth = if (rightSign || right > 0) 4.0 * radius else 0.0;

		//calc topSpace and width of the top block
		calcBlockSize = \count, space -> {
			i2d(count) * 2.0 * radius + ( if (count > 0) space * i2d(count - 1) else 0.0 );
		};

		topSpaceInitial = 2.0 * radius;
		topWidthInitial = calcBlockSize(top, topSpaceInitial);

		topSpace = if (topWidthInitial > storyWidth) radius else topSpaceInitial;
		topWidth = if (topWidthInitial > storyWidth) calcBlockSize(top, topSpace) else topWidthInitial;


		//calc bottomSpace and width of the bottom block
		bottomSpaceInitial = 2.0 * radius;
		bottomWidthInitial = calcBlockSize(bottom, bottomSpaceInitial);
		bottomSpace = if (bottomWidthInitial > storyWidth ) radius else bottomSpaceInitial;
		bottomWidth = if (bottomWidthInitial > storyWidth ) calcBlockSize(bottom, bottomSpace) else bottomWidthInitial;


		centerWidth = max3(storyWidth, topWidth, bottomWidth);

		//********** Calc height of element ***************

		//calc top and bottom heights
		topHeight = if (top > 0 || leftSign || rightSign) 4.0 * radius else 0.0;
		bottomHeight = if (bottom > 0) 4.0 * radius else 0.0;


		//calc topSpace and width of the top block
		leftSpace = if (left > 2) radius else 2.0 * radius;
		leftHeight = calcBlockSize(left, leftSpace);

		//calc bottomSpace and width of the bottom block
		rightSpace = if (right > 2) radius else 2.0 * radius;
		rightHeight = calcBlockSize(right, rightSpace);

		centerHeight = max3(storyHeight, leftHeight, rightHeight);

		WriteDottedElementMetrics(radius,
					leftWidth, leftHeight,
					rightWidth, rightHeight,
					centerWidth, centerHeight,
					topWidth, topHeight,
					bottomWidth, bottomHeight,
					leftSpace, rightSpace,
					topSpace, bottomSpace
		)
	}


	radiusB = const(1.5);
	bodyMetrics = getDynamicFormSize(body);
	bodyM = bodyMetrics.first;
	bmB = bodyMetrics.second;

	Select(radiusB, \radius -> {

		dmB = select(bmB, \bm -> calcDottedElementMetrics(radius, bm.width, bm.height));

		dotsColor = color; //todo: get from style

		topDots = generate(0, top, \i ->
			Translate(
				select(dmB, \dm -> i2d(i) * (2.0 * radius + dm.topSpace)),
				zero,
				Circle(
					radius ,
					2.0 * radius,
					radius,
					[Fill(dotsColor)]
				)
			)
		) |> Group;

		bottomDots = generate(0, bottom, \i ->
			Translate(
				select(dmB, \dm -> i2d(i) * (2.0 * radius + dm.bottomSpace)),
				zero,
				Circle(
					radius,
					2.0 * radius,
					radius,
					[Fill(dotsColor)]
				)
			)
		) |> Group;

		leftDots = generate(0, left, \i ->
			Translate(
				zero,
				select(dmB, \dm -> i2d(i) * (2.0 * radius + dm.leftSpace)),
				Circle(
					2.0 * radius,
					radius,
					radius,
					[Fill(dotsColor)]
				)
			)
		) |> Group;

		rightDots = generate(0, right, \i ->
			Translate(
				zero,
				select(dmB, \dm -> i2d(i) * (2.0 * radius + dm.rightSpace)),
				Circle(
					2.0 * radius,
					radius,
					radius,
					[Fill(dotsColor)]
				)
			)
		) |> Group;

		signf = Graphics([MoveTo(0.0, 4.0 * radius), LineTo(4.0 * radius, 4.0 * radius), ClosePath()], [Stroke(dotsColor)]);

		fixBaselineB(
			select(dmB, \dm -> {
					bm = getValue(bmB);
					bm.baseline + dm.topHeight
			}),
			Border(1.0, 0.0, 1.0, 0.0,
				Size2(
					select(dmB, \dm -> {
						bm = getValue(bmB);
						WidthHeight(dm.leftWidth + bm.width + dm.rightWidth, dm.leftHeight + bm.height + dm.rightHeight)
					}),
					Group([
						Translate(select(dmB, \dm -> dm.leftWidth + max(0.0, dm.centerWidth - dm.topWidth) * 0.5), zero, topDots),
						Translate(zero, select(dmB, \dm -> dm.topHeight + max(dm.centerHeight - dm.leftHeight, 0.0) * 0.5 + radius), leftDots),
						Translate(select(dmB, \dm -> {bm = getValue(bmB); dm.leftWidth + max(0.0, dm.centerWidth - bm.width) * 0.5}), select(dmB, \dm -> dm.topHeight), bodyM),
						Translate(select(dmB, \dm -> dm.leftWidth + dm.centerWidth), select(dmB, \dm -> dm.topHeight + max(dm.centerHeight - dm.rightHeight, 0.0) * 0.5 + radius), rightDots),
						Translate(select(dmB, \dm -> dm.leftWidth + max(0.0, dm.centerWidth - dm.bottomWidth) * 0.5), select(dmB, \dm -> dm.topHeight + dm.centerHeight), bottomDots),
						if (leftSign) signf else Empty(),
						if (rightSign) Translate(select(dmB, \dm -> dm.leftWidth + dm.centerWidth), zero, signf) else Empty()
					])
				)
			)
		)
	})
}

/////////////////////
// Definite control
/////////////////////
definiteControl2form (signType, to, from, body) {
	definiteControl2formWithColor(signType, to, from, body, black)
}


definiteControl2formWithColor(signType, to, from, body, color) {
	calcOffset = \maxVal : Behaviour<double>, val : Behaviour<double> -> select2(maxVal, val, \m, v -> max(0.0, m - v) * 0.5); //To align centers
	calcOffset2 = \maxVal : Behaviour<double>, val : Behaviour<double> -> select2(maxVal, val, \m, v -> max(0.0, m - v)); //To align arbitrary points

	signf = createSignWithColor(signType, color);
	signSize = getStaticFormSize(signf);
	signBaseline = 0.6 * signSize.height;

	bodyMeasurer = getDynamicFormSize(body);
	mB = bodyMeasurer.second;

	toHeight = make(0.0);
	toWidth = make(0.0);
	fromWidth = make(0.0);
	bodyBaseline = select(mB, \m -> m.baseline);
	maxWidth = arrayMax([toWidth, fromWidth, const(signSize.width)]); // first column
	toAndSignBaseline = select(toHeight, \h -> h + signBaseline);
	maxHeight = arrayMax([bodyBaseline, toAndSignBaseline]);

	toMod = Translate(calcOffset(maxWidth, toWidth), zero, Inspect([Width(toWidth), Height(toHeight)], to));
	fromMod = Translate(calcOffset(maxWidth, fromWidth), zero, Inspect([Width(fromWidth)], from));
	signMod = Translate(calcOffset(maxWidth, const(signSize.width)), zero, signf);

	//We aligns special point of sign and baseline of body
	bodyDy = calcOffset2(maxHeight, bodyBaseline);
	leftPart = Translate(zero, calcOffset2(maxHeight, toAndSignBaseline), Lines([toMod, signMod, fromMod]));
	bodyMod =  Translate(zero, bodyDy, bodyMeasurer.first);

	result = Cols([leftPart, bodyMod]);


	fixBaselineB(
		select2(mB, bodyDy, \m, dy -> m.baseline + dy),
		Border(1.0, 0.0, 1.0,0.0, result)
	)
}

evaluatingIntegral2form (body, to, from) {
	evaluatingIntegral2formWithColor(body, to, from, black)
}

evaluatingIntegral2formWithColor(body, to, from, color) {

	bodyMeasurer = getDynamicFormSize(body);
	mB = bodyMeasurer.second;

	toHeight = make(0.0);
	fromHeight = make(0.0);
	bodyHeight = select(mB, \m -> m.height);

	dx = 1.0;

	toMod = Border(dx, 0.0, 0.0, 0.0, Inspect([Height(toHeight)], to));
	fromMod = Border(dx, 0.0, 0.0, 0.0, Inspect([Height(fromHeight)], from));
	bodyMod = Border(0.0, 0.0, 1.0, 0.0, bodyMeasurer.first);

	setSize = \f -> Size2(zeroSize, f);
	lineLength = select3(bodyHeight, fromHeight, toHeight, \bh, fh, th -> bh + (fh + th) * 0.5);
	vLine = Translate(
		zero, select(toHeight, \th -> -0.5 * th),
		Select(lineLength, \ll -> Graphics([MoveTo(0.0, 0.0), LineTo(0.0, ll)], [Stroke(color)]))
	) |> setSize;

	result = Grid([
		[Empty(), toMod],
		[bodyMod, vLine],
		[Empty(), fromMod]
	]);


	fixBaselineB(
		select2(mB, toHeight, \m, h -> h + m.baseline),
		Border(1.0, 0.0, 1.0,0.0, result)
	)
}

/////////////////////
// Fractions
/////////////////////
fraction2form(num : Form, denum : Form) -> Form {
	fraction2formWithColor(num, denum, black)
}

fraction2formWithColor(num : Form, denum : Form, color : int) -> Form {
	fraction2formWrap(num, denum, ColoredMathGlyphWrappers(color), 0.0)
}

fraction2formWrap(num : Form, denum : Form, wrappers : MathFormWrappers, fontSize : double) -> Form {
	fraction2formWrapPair(num, denum, wrappers, fontSize).first
}

fraction2formWrapPair(num : Form, denum : Form, wrappers : MathFormWrappers, fontSize : double) -> Pair<Form, Behaviour<double>>{

	numWhB = makeWH();
	denumWhB = makeWH();

	countMargin = \wh1, wh2 -> {
		maxWidth = max(wh1.width, wh2.width);
		maxHeight = max(wh1.height, wh2.height);

		isSmall = fontSize == 0.0 || (maxHeight < 2.0 * fontSize);

		smallMargin = fontSize / 5.0;

		if (isSmall) {
			smallMargin
		} else {
 			smallMargin * maxHeight / (2.0 * fontSize);
 		}
	}

	lineW = make(0.0);

	numOB = make(0.0);
	denumOB = make(0.0);

	heightB = make(0.0);
	baselineB = make(0.0);

	numOWB = make(0.0);
	denumOWB = make(0.0);

	numFiller = Select2(numWhB, numOB, \nWh, nO -> {
		ClickableFixed(nO, nWh.height)
	});

	denumFiller = Select2(denumWhB, denumOB, \dnWh, dnO -> {
		ClickableFixed(dnO, dnWh.height)
	});
	numGroupHB = make(0.0);
	centerGroupHB = make(0.0);
	
	halfHeightB = make(0.0);
	form = Constructor(
		Inspect([Height(heightB)], fixBaselineB(
			baselineB,
			Lines([
				Inspect([Height(numGroupHB)], Group([
					wrappers.wrapTopLeft(numFiller),
					Translate(numOB, zero,
						Inspect([ISize(numWhB)],
							Border(0.0, 0.0, 0.0, 1.5, num)
						)
					),
					Translate(numOWB, zero,
						wrappers.wrapTopRight(numFiller)
					)
				])),
				Inspect([Height(centerGroupHB)], wrappers.wrapGlyph(
					\fc, bcM ->
						Select(lineW, \w -> {
							line = Graphics([LineTo(w, 0.0)], [Stroke(fc), StrokeWidth(1.0)]);

							simpleGlyphBackground(line, bcM)
						})
				)),
				Group([
					wrappers.wrapBottomLeft(denumFiller),
					Translate(denumOB, zero,
						Inspect([ISize(denumWhB)],
							Border(0.0, 2.0, 0.0, 0.0, denum)
						),
					),
					Translate(denumOWB, zero,
						wrappers.wrapBottomRight(denumFiller)
					)
				])
			]))
		),
		make3Subscribe(numWhB, denumWhB, heightB, \numWH, denumWH, h -> {
			margin = countMargin(numWH, denumWH);

			nextDistinct(lineW, max(numWH.width, denumWH.width) + margin * 2.0);

			numO = max((denumWH.width - numWH.width) * 0.5, 0.0) + margin;
			denumO = max((numWH.width - denumWH.width) * 0.5, 0.0) + margin;
			nextDistinct(numOB, numO);
			nextDistinct(denumOB,  denumO);

			nextDistinct(baselineB, h / 2.0 + 5.5);

			nextDistinct(numOWB, numO + numWH.width);
			nextDistinct(denumOWB, denumO + denumWH.width);
		})
	);

	Pair(
		Constructor(
			form,
			\ -> connectSelect2Distinctu(
				numGroupHB,
				centerGroupHB,
				halfHeightB,
				\n, c -> n + c
			)
		),
		halfHeightB
	)
}

fraction2formTriple2(num : Form, middle : Form, denum : Form) -> Pair<Form, Triple<Behaviour<double>, Behaviour<double>, Behaviour<double>>> {
	numWh = makeWH();
	middleWh = makeWH();
	denumWh = makeWH();
	margin = 4.0;

	numO = select2(numWh, denumWh, \wh1,wh2 -> max((wh2.width - wh1.width) * 0.5, 0.0) + margin);
	denumO = select2(denumWh, numWh, \wh1,wh2 -> max((wh2.width - wh1.width) * 0.5, 0.0) + margin);

	middleO = select3(numWh, middleWh, denumWh, \wh1,wh2,wh3 -> (max(wh1.width, wh3.width) - wh2.width) * 0.5 + margin);

	baselineB = select2(numWh, middleWh, \wh1, wh2 -> wh1.height + wh2.height * 0.5 + 5.0);

	numRes = Translate(numO, zero, Inspect([ISize(numWh)], num));
	middleRes = Translate(middleO, zero, Inspect([ISize(middleWh)], middle));
	denumRes = Translate(denumO, zero, Inspect([ISize(denumWh)], denum));

	frm = fixBaselineB(
		baselineB,
		Line([numRes, middleRes, denumRes])
	);

	Pair(
		frm,
		Triple(
			numO,
			middleO,
			denumO
		)
	)
};

fraction2formTriple(num : Form, middle : Form, denum : Form) -> Form {
	fraction2formTriple2(num, middle, denum).first
}


/////////////////////
// Roots
/////////////////////
root2form(degree : Form, body : Form) -> Form {
	root2formWithColor(degree, body, black)
}

root2formWithColor(degree : Form, body : Form, color : int) -> Form {
	root2formWrap(degree, body, 20.0, ColoredMathGlyphWrappers(color))
}

/*
     ..............................................
          #################
          #################
          #################                   tfh
          ##### DEGREE ####
     .....#################...../=================....
      mdh #################    / '..............'.|'.gh.
          #################   /' '##############' |'
     .....#################  / ' '##############' '
      s   '     ^           /  ' '##############' '
     .....'..../'\         /'  ' '##############' '
          '   ' ' \       / '  ' '#### BODY ####' '  bh
      lsh '   ' '  \     /  '  ' '##############' '
          '   ' '   \   /   '  ' '##############' '
          '   ' '    \ /    '  ' '##############' '
     .....'...'.'.....V     '  ' '##############'.'....
          '   's'     '   d '  gw'              's'
          '   ' '     '     '  ' '              ' '
          ' lfw 'lsw  '   rsw    '       bw     '
          '     '     '          '              '


                 DEGREE   p3-------p4
                         /         |
                  p1    /    BODY  p5
                 / \\  /
                p0  \\/
                     p2
*/

RootMetrics : (
	p0 : Pair<double, double>,
	p1 : Pair<double, double>,
	p2 : Pair<double, double>,
	p3 : Pair<double, double>,
	p4 : Pair<double, double>,
	p5 : Pair<double, double>,
	q : Pair<double, double>,
	gap : Pair<double, double>,
	height : double,
	width : double,
	baseline : double
);

countRootMetrics(bm : FormMetrics, dm : FormMetrics, fontSize : double) -> RootMetrics {
	minDegreeHeight = 0.6 * bm.height; // mdh
	leftSlashHeight = bm.height  - minDegreeHeight; // lsh
	topFillHeight = max(dm.height - minDegreeHeight, 0.0); // tfh
	s = 0.07 * fontSize; // s

	leftSlashWidth = fontSize * 0.2; // lsw
	rightSlashWidth = fontSize * 0.4; // rsw
	delta = if (bm.height == 0.0) 0.0 else leftSlashWidth * rightSlashWidth / bm.height; // d
	leftFillWidth = max(dm.width - leftSlashWidth - delta, 0.0); // lfw
	gapWidth = sqrt(dpow(bm.height, 2.0) + dpow(bm.width, 2.0)) / 11.0;
	gapHeight = gapWidth / 2.0;

	p1 = Pair(leftFillWidth,                                                                       topFillHeight + minDegreeHeight);
	p0 = Pair(p1.first - s,                                                                        p1.second + s);
	p2 = Pair(leftFillWidth + leftSlashWidth,                                                      topFillHeight + bm.height + gapHeight);
	p3 = Pair(leftFillWidth + leftSlashWidth + rightSlashWidth,                                    topFillHeight);
	p4 = Pair(leftFillWidth + leftSlashWidth + rightSlashWidth + gapWidth + bm.width + 2.0 * s ,   topFillHeight);
	p5 = Pair(p4.first,                                                                            p4.second + s + gapHeight);

	q =  Pair(leftFillWidth + leftSlashWidth + delta - dm.width,                                   topFillHeight + minDegreeHeight - dm.height);
	g =  Pair(gapWidth,                                                                            gapHeight);
/*
	println("body: " + toString(bm));
	println("degree: " + toString(dm));

	println("p0: " + toString(p0));
	println("p1: " + toString(p1));
	println("p2: " + toString(p2));
	println("p3: " + toString(p3));
	println("p4: " + toString(p4));
	println("p5: " + toString(p5));
	println("q: " + toString(q));
	println("g: " + toString(g));
*/
	height = bm.height + gapHeight + topFillHeight;
	width = leftFillWidth + leftSlashWidth + rightSlashWidth + gapWidth + bm.width;

	baseline = bm.baseline + p3.second;

	RootMetrics(p0, p1, p2, p3, p4, p5, q, g, height, width, baseline)
}

root2formWrap(degree : Form, body : Form, fontSize : double, wrappers : MathFormWrappers) -> Form {
	root2formWrapTriple(degree, body, fontSize, wrappers) |> firstOfTriple
}

root2formWrapTriple(degree : Form, body : Form, fontSize : double, wrappers : MathFormWrappers) -> Triple<Form, Behaviour<double>, Behaviour<double>> {
	makeFormWrapLine = \from, to, thickness, frontColor, backColorM -> {
		BoxBehindMaybe(
			Graphics(
				[
					MoveTo(from.first, from.second),
					LineTo(to.first, to.second),
					ClosePath()
				],
				[ Stroke(frontColor), StrokeWidth(thickness) ]
			),
			backColorM
		)
	};

	degree2 = Border(fontSize / 5.0, 0.0, 0.0, 0.0, degree);

	unpair(getDynamicFormSize(body), \bodyForm : Form, bodyFormMB : Behaviour<FormMetrics> -> {
		unpair(getDynamicFormSize(degree2), \degreeForm : Form, degreeFormMB : Behaviour<FormMetrics> -> {

			metricsB : Behaviour<RootMetrics> = select2(bodyFormMB, degreeFormMB, \bm, dm -> countRootMetrics(bm, dm, fontSize));

			signForm = Select(metricsB, \metrics -> {
				buildSign = \fc, bcM -> {
		 			Group([
		 				makeFormWrapLine(metrics.p0, metrics.p1, 1.0, fc, bcM),
		 				makeFormWrapLine(metrics.p1, metrics.p2, 2.0, fc, bcM),
		 				makeFormWrapLine(metrics.p2, metrics.p3, 1.0, fc, bcM),
		 				makeFormWrapLine(metrics.p3, metrics.p4, 1.0, fc, bcM),
		 				makeFormWrapLine(metrics.p4, metrics.p5, 1.0,  fc, bcM)
					])
		 		};

		 		wrappers.wrapGlyph(\fontColor, backColorM ->
					eitherMap(backColorM, \backColor -> {
			 			Group([
			 				buildSign(backColor, backColorM),
			 				buildSign(fontColor, None())
			 			])
			 		}, buildSign(fontColor, None()))
		 		)
			});

			vMargin = 2.0;

			frm = Border(5.0, vMargin, 0.0, 0.0,
				fixBaselineB(
					select(metricsB, \metrics -> metrics.baseline),
					Group([
						Translate(
							select(metricsB, \metrics -> metrics.q.first),
							select(metricsB, \metrics -> metrics.q.second),
							degreeForm
						),
						Translate(
							select(metricsB, \metrics -> metrics.p3.first + metrics.gap.first),
							select(metricsB, \metrics -> metrics.p3.second + metrics.gap.second),
							bodyForm
						),
						signForm,
					])
				)
			);

			Triple(
				frm,
				select(metricsB, \metrics -> metrics.q.second + vMargin),
				select(metricsB, \metrics -> metrics.p3.second + vMargin)
			)
		})
	})
}

/////////////////////
// Sigma
/////////////////////
sigma2formWrap(from : Form, to : Form, body : Form, wrappers : MathFormWrappers, fontSize : double) -> Form {
	sigma2formWrapQuadruple(from, to, body, wrappers, fontSize) |> firstOfQuadruple
}

sigma2formWrapQuadruple(from : Form, to : Form, body : Form, wrappers : MathFormWrappers, fontSize : double) -> Quadruple<Form, Behaviour<double>, Behaviour<double>, Behaviour<double>> {
	smB = makeWH();

	toSizeB = makeWH();
	sigmaHB = make(0.0);

	sigma = wrappers.wrapGlyph(\fontColor, backColorM -> {
		BoxBehindMaybe(
			createSignWithColorAndSize(SigmaSign(), fontColor, fontSize),
			backColorM
		)
	});

	vSkip = 3.0;

	sigmaFromTo =
		fixBaselineB(
			select(toSizeB, \toSize -> toSize.height + fontSize * 1.2),
			Lines([
				Align2(0.6, 0.0,
					Inspect([ISize(toSizeB)], to)
				),
				Align2(0.5, 0.0, Inspect([Height(sigmaHB)], sigma)),
				Fixed(0.0, vSkip),
				Align2(0.6, 0.0, from)
			])
		);

	alignResult : Triple<[Pair<Form, Behaviour<double>>], Behaviour<double>, Behaviour<double>> = alignBaseline2([
		sigmaFromTo,
		Fixed(5.0, 0.0),
		body
	]);

	Quadruple(
		Cols(map(alignResult.first, firstOfPair)),
		select3(toSizeB, sigmaHB, alignResult.first[0].second /* sigma with "from-to" offset */, \wh1, h2, h3 -> wh1.height + h2 + h3 + vSkip),
		alignResult.first[0].second,
		alignResult.first[2].second /* body offset */
	)
}

/////////////////////
// Long division
/////////////////////
longDivision2form(body) {
	longDivision2formWithColor(body, black)
}

longDivision2formWithColor(body, color) {
	radius = 5.0;
	leftOffset = 7.0;
	topOffset = 3.0;
	rightLineLength = 3.0;

	makeLongDivision = \width, height -> {
		path = [
			MoveTo(0.0, height + topOffset),
			CubicBezierTo(0.0, 0.0, 0.0 + radius, (topOffset + height) * 0.5),
			LineTo(width + leftOffset + rightLineLength, 0.0)
		];
		Graphics(path, [Stroke(color), StrokeWidth(2.0)])
	}

	bodyWH = makeWH();

	addBorder = \form -> Border(1.0 + leftOffset, topOffset, rightLineLength + 1.0, 0.0, form);

	unpair(getDynamicFormSize(body), \bodyForm : Form, bodySizeB : Behaviour<FormMetrics> -> {
		fixBaselineB(
			select(bodySizeB, \bodySize -> bodySize.baseline + topOffset),
			Group([
				Select(bodyWH, \wh -> makeLongDivision(wh.width, wh.height)),
				Inspect([ISize(bodyWH)], bodyForm) |> addBorder
			])
		)
	})
}

/////////////////////
// Division symbol
/////////////////////
divisionSymbol(fontSize : double) -> Form {
	divisionSymbolWithColor(fontSize, black)
}

divisionSymbolWithColor(fontSize : double, color : int) -> Form {
	plus = Text("+", [FontSize(fontSize)]);

	t = getStaticFormSizeCached(plus);

	halfh = dround(t.height / 24.0);
	h = 2.0 * halfh; // height of the line
	divh = max(2.0, 1.5 * h); // height of the divider between line and circle
	fillh = t.height - 3.0 * h - 2.0 * divh; // height of the fill on top and bottom

	w = t.width * 0.9;
	fillw = (t.width - w) / 2.0;

	radius = h / 1.5;

	bottom = t.height - t.baseline;
	top = t.height - bottom - h - 4.0 * radius - 2.0 * divh;

	circle = Circle(radius, radius, radius, [Fill(color), StrokeWidth(1.0)]);
	line = Rectangle(w, h, [Fill(color), StrokeWidth(1.0)]);
	div = Fixed(0.0, divh);
	fill = Fixed(0.0, fillh / 2.0);

	Baseline(const(t.baseline),
		Lines([
			Fixed(0.0, top),
			Align2(0.5, 0.0, circle),
			div,
			Align2(0.5, 0.0,
				Border(fillw, 0.0, fillw, 0.0, line)
			),
			div,
			Align2(0.5, 0.0, circle),
			Fixed(0.0, bottom)
		])
	)
}

/////////////////////
// Superscript
/////////////////////
superscript2form(body : Form, degree : Form) -> Form {
	superscript2formWrap(body, degree, DummyMathFormWrappers())
}

superscript2form2(body : Form, degree : Form, flipped : bool, left : bool) -> Form {
	superscript2formWrap2(body, degree, DummyMathFormWrappers(), flipped, false, left)
}

superscript2formWrap(body : Form, degree : Form, wrappers : MathFormWrappers) -> Form {
	superscript2formWrap2(body, degree, wrappers, false, false, false)
}

/*
              ----------
      body    |        |
      fill    | degree |
    ----------|        |
    |        ||        |
    | body   |----------
    |        |  degree
    |        |  lift
    ----------
*/
superscript2formWrap2(body : Form, degree : Form, wrappers : MathFormWrappers, flipped : bool, topaligned : bool, left : bool) -> Form {
	superscript2formWrap2Pair(body, degree, wrappers, flipped, topaligned, left) |> firstOfPair
}

//returns body upper offset in second arg
superscript2formWrap2Pair(body : Form, degree : Form, wrappers : MathFormWrappers, flipped : bool, topaligned : bool, left : bool) -> Pair<Form, Behaviour<double>> {
	// How much to lift the degree from the body baseline
	degreelift = \bs, ds -> {
		if (topaligned && bs.height > ds.height) {
			bs.height - ds.height + ds.height / 5.0
		} else {
			// The x-height of the body is estimated here
			bsx = bs.height - (bs.height - bs.baseline) * 2.0;
			max(
				// The case where the superscript is ABOVE the body
				//bsx * 0.67 + (bs.height - bs.baseline) - (ds.height - ds.baseline),
				bs.height - bs.baseline,
				// For a big body, we top align instead
				max(0.0, bs.height - ds.height)
			)
		}
	};

	// How much space above the body
	bodyfill = \bs, ds -> {
		degreelift(bs, ds) + ds.height - bs.height;
	};

	// For the empty space, we need to split it to make the left and right parts clickable
	splitFiller = \wfactor, wh -> Select(wh, \dwh -> {
		ClickableFixed2(dwh.width * wfactor, dwh.height)
	});

	unpair(getDynamicFormSize(body), \bodyForm : Form, bodySizeB : Behaviour<FormMetrics> -> {
		unpair(getDynamicFormSize(degree), \degreeForm : Form, degreeSizeB : Behaviour<FormMetrics> -> {

			bodyFillSize   = select2(bodySizeB, degreeSizeB, \bs, ds -> WidthHeight(bs.width, bodyfill(bs, ds)));
			degreeLiftSize = select2(bodySizeB, degreeSizeB, \bs, ds -> WidthHeight(ds.width, degreelift(bs, ds)));

			bodyFill = Cols([
				wrappers.wrapTopLeft(splitFiller(0.7, bodyFillSize)),
				wrappers.wrapTopRight(splitFiller(0.3, bodyFillSize)),
			]);

			degreeFill = Cols([
				wrappers.wrapBottomLeft(splitFiller(0.3, degreeLiftSize)),
				wrappers.wrapBottomRight(splitFiller(0.7, degreeLiftSize)),
			]);

			frm = fixBaselineB(
				select2(bodySizeB, degreeSizeB, \bs, ds  -> if (flipped) bs.baseline else bs.baseline + bodyfill(bs, ds)),
				Cols(
					if (flipped) {
						if (left) [
							Lines([	degreeFill,	Offset(0.0, 0.0, degreeForm) ]),
							Fixed(1.0, 1.0),
							Lines([ bodyForm, bodyFill ])
						] else [
							Lines([ bodyForm, bodyFill ]),
							Fixed(1.0, 1.0),
							Lines([	degreeFill,	Offset(0.0, 0.0, degreeForm) ]),
						]
					} else {
						if (left) [
							Lines([ degreeForm, degreeFill ]),
							Fixed(2.0, 2.0),
							Lines([ bodyFill, bodyForm ]),
						] else [
							Lines([ bodyFill, bodyForm ]),
							Fixed(2.0, 2.0),
							Lines([ degreeForm, degreeFill ]),
						]
					}
				)
			);

			Pair(
				frm,
				select2(bodySizeB, degreeSizeB, bodyfill)
			)
		})
	})
}

superscript2formWrap3(body : Form, degree : Form, wrappers : MathFormWrappers, flipped : bool) -> Form {
	degreeWh = makeWH();
	bodyWh = makeWH();

	delta = \dh, bh -> max(dh * 0.5, (dh - bh * 0.2));

	bodyFiller = \wfactor -> Select2(degreeWh, bodyWh, \dwh, bwh -> {
		ClickableFixed(bwh.width * wfactor, delta(dwh.height, bwh.height))
	});

	degreeFiller = \wfactor -> Select2(degreeWh, bodyWh, \dwh, bwh -> {
		ClickableFixed(dwh.width * wfactor, bwh.height - dwh.height + delta(dwh.height, bwh.height))
	});

	unpair(getDynamicFormSize(body), \bodyForm : Form, bodySizeB : Behaviour<FormMetrics> -> {
		fixBaselineB(
			select2(bodySizeB, degreeWh, \bodySize, dwh  -> bodySize.baseline + delta(dwh.height, bodySize.height)),
			Group([
				Lines([
					Inspect([ISize(degreeWh)],
						Select(bodyWh, \bwh -> {
							Offset(bwh.width, 0.0, degree)
						})
					),
					Select2(bodyWh, degreeWh, \bwh, dwh -> {
						Fixed(bwh.width + dwh.width, bwh.height - dwh.height + delta(dwh.height, bwh.height))
					}),
				]),
				Lines([
					Select2(bodyWh, degreeWh, \bwh, dwh -> {
						Fixed(0.0, delta(dwh.height, bwh.height))
					}),
					Inspect([ISize(bodyWh)], bodyForm)
				]),
				wrappers.wrapTopLeft(bodyFiller(0.7)),
				Translate(
					select(bodyWh, \bwh -> bwh.width * 0.7),
					zero,
					wrappers.wrapTopRight(bodyFiller(0.3))
				),
				Translate(
					select(bodyWh, \bwh -> bwh.width),
					select(degreeWh, \dwh -> dwh.height),
					wrappers.wrapBottomLeft(degreeFiller(0.3)),
				),
				Translate(
					select2(bodyWh, degreeWh, \bwh, dwh -> bwh.width + dwh.width * 0.3),
					select(degreeWh, \dwh -> dwh.height),
					wrappers.wrapBottomRight(degreeFiller(0.7)),
				)
			])
		)
	})

}

superscript2formTriple(body : Form, middle : Form, degree : Form) -> Form {
	superscript2formTriple2(body, middle, degree).first
}

superscript2formTriple2(body : Form, middle : Form, degree : Form) -> Pair<Form, Pair<Behaviour<double>, Behaviour<double>>> {
	degree2 = Cols([middle, degree]);

	degreeWh = makeWH();

	delta = \dh, bh -> max(dh * 0.5, (dh - bh * 0.2));

	unpair(getDynamicFormSize(body), \bodyForm : Form, bodySizeB : Behaviour<FormMetrics> -> {
		grp1 : Triple<[Pair<Form, Behaviour<double>>], Behaviour<double>, Behaviour<double>> = [
			Inspect([ISize(degreeWh)],
				Select(bodySizeB, \bodySize -> {
					Offset(bodySize.width, 0.0, degree2)
				})
			),
			Select2(bodySizeB, degreeWh, \bodySize, dwh -> {
				Fixed(bodySize.width + dwh.width, bodySize.height - dwh.height + delta(dwh.height, bodySize.height))
			})
		] |> alignBaseline2;
		grp2 : Triple<[Pair<Form, Behaviour<double>>], Behaviour<double>, Behaviour<double>> = [
			Select2(bodySizeB, degreeWh, \bodySize, dwh -> {
				Fixed(0.0, delta(dwh.height, bodySize.height))
			}),
			bodyForm
		] |> alignBaseline2;

		frm = fixBaselineB(
			select2(bodySizeB, degreeWh, \bodySize, dwh  -> bodySize.baseline + delta(dwh.height, bodySize.height)),
			Group([
				map(grp1.first, firstOfPair) |> Cols,
				map(grp2.first, firstOfPair) |> Cols,
			])
		);

		Pair(frm,
			Pair(grp2.first[1].second, grp1.first[0].second)
		)
	})
}

/////////////////////
// Subscript
/////////////////////
subscriptMiltiplier = 0.4;

subscriptFormDegree(wh : FormMetrics, degree : Form) -> Form {
	Border(0.0, wh.height * (1.0 - subscriptMiltiplier), 0.0, 0.0,
		MinHeight(const(wh.height * subscriptMiltiplier),
			Align2(0.0, 1.0, degree)
		)
	)
}

subscript2form(body : Form, degree : Form) -> Form {
	Attach(body, \b, wh ->
		Cols([
			b,
			Fixed(1.0, 0.0),
			subscriptFormDegree(wh, degree)
		])
	)
}

doubleSubscript2form(body : Form, left : Form, right : Form) -> Form {
	doubleSubscript2form2(body, left, right).first
}

doubleSubscript2form2(body : Form, left : Form, right : Form) -> Pair<Form, Pair<Behaviour<double>, Behaviour<double>>> {
	ah = make(0.0);
	alh = make(0.0);
	arh = make(0.0);

	subscriptOffsetFn = \bh -> select2(bh, ah, \b, h -> max(h * (1.0 - subscriptMiltiplier), h - b));

	Pair(
		Attach(body, \b, wh ->
			Inspect([AvailableHeight(ah)], Cols([
				subscriptFormDegree(wh, Inspect([AvailableHeight(alh)], left)),
				Fixed(1.0, 0.0),
				b,
				Fixed(1.0, 0.0),
				subscriptFormDegree(wh, Inspect([AvailableHeight(arh)], right))
			]))
		),
		Pair(alh |> subscriptOffsetFn, arh |> subscriptOffsetFn)
	)
}

/////////////////////
// Overscript
/////////////////////
overscript2form(maintext:Form, overscript : Form) -> Form {
	unpair(getDynamicFormSize(overscript), \overscriptM : Form, omB : Behaviour<FormMetrics> -> {
		widthO = select(omB, \m -> m.width);
		// TODO: fix overscript size.
		//   See einsteinmt\write\Renderer.hx:OverscriptOffsetMultiplierForSpecialChar

		widthM = make(0.0);

		Lines([
			CenterH(widthO, widthM,
				Size2(select(omB, \m -> WidthHeight(m.width, m.baseline)), overscriptM)
			),
			CenterH(widthM, widthO, Inspect([Width(widthM)], maintext))
		])
	})
}

/////////////////////
// Underscript
/////////////////////
underscript2form(maintext:Form, underscript : Form) -> Form {
	unpair(getDynamicFormSize(maintext), \maintextM : Form, mmB : Behaviour<FormMetrics> -> {
		baselineM = select(mmB, \m -> m.baseline);
		widthM = select(mmB, \m -> m.width);
		heightM = select(mmB, \m -> m.height);

		widthU = make(0.0);

		fixBaselineB(
			baselineM,
			Lines([
				CenterH(widthM, widthU, maintextM),
				Fixed(0.0, 1.0),
				CenterH(widthU, widthM, Inspect([Width(widthU)], underscript))
			])
		)
	})
}

/////////////////////
// Sup and sub script
/////////////////////
/*
              ----------
      top     |        |
      fill    | sup    |
    ----------|        |
    |        ||        |
    | body   |----------
    |        |  delta
    |        |----------
    ----------|        |
      bottom  | sub    |
      fill    |        |
              ----------
*/
supSubScript2form(body : Form, sup : Form, sub : Form, wrappers : MathFormWrappers) -> Form {
	supSubScript2form3(body, sup, sub, wrappers, false)
}
supSubScript2form2(body : Form, sup : Form, sub : Form, left : bool) -> Form {
	supSubScript2form3(body, sup, sub, DummyMathFormWrappers(), left)
}

supSubScript2form3(body : Form, sup : Form,	sub : Form,	wrappers : MathFormWrappers, left : bool) -> Form {
	supSubScript2form4(body, sup, sub, wrappers, left).first
}

// offsets: body, sub
supSubScript2form4(body : Form, sup : Form,	sub : Form,	wrappers : MathFormWrappers, left : bool) -> Pair<Form, Pair<Behaviour<double>, Behaviour<double>>> {
	fillSize = \bs, ss -> {
		max(
			bs.height - bs.baseline,
			max(0.0, bs.height - ss.height)
		)
		+ ss.height - bs.height
	};

	fillSize2 = \bs, ss -> {
		if (bs.height / 2.0 - ss.height + fillSize(bs, ss) < 0.0) {
			ss.height - bs.height/2.0
		} else {
			fillSize(bs, ss)
		}
	};

	// For the empty space, we need to split it to make the left and right parts clickable
	splitFiller = \wfactor, wh : Behaviour -> Select(wh, \dwh -> {
		ClickableFixed2(dwh.width * wfactor, dwh.height)
	});

	unpair(getDynamicFormSize(body), \bodyForm : Form, bodySizeB : Behaviour<FormMetrics> -> {
		unpair(getDynamicFormSize(sup), \supForm : Form, supSizeB : Behaviour<FormMetrics> -> {
			unpair(getDynamicFormSize(sub), \subForm : Form, subSizeB : Behaviour<FormMetrics> -> {

				supFillB = makeWH();
				subFillB = makeWH();
				supFillHeightB = make(0.0);
				baselineB = make(0.0);
				deltaB = makeWH();
				supTotalHeightB = make(0.0);

				topFill = Cols([
					wrappers.wrapTopLeft(splitFiller(0.7, supFillB)),
					wrappers.wrapTopRight(splitFiller(0.3, supFillB)),
				]);

				bottomFill = Cols([
					wrappers.wrapTopLeft(splitFiller(0.3, subFillB)),
					wrappers.wrapTopRight(splitFiller(0.7, subFillB)),
				]);
				addAlign = if (left) \form -> Align2(1.0, 0.0, form) else idfn;
				scriptCol = Lines([ supForm |> addAlign, splitFiller(1.0, deltaB), subForm |> addAlign]);
				bodyCol = Lines([ topFill, bodyForm, bottomFill ]);
				cols = if (left) [scriptCol, bodyCol] else [bodyCol, scriptCol];
				frm = fixBaselineB(baselineB, Cols(cols));

				safeFrm = Constructors(
					[
						make2Subscribe(bodySizeB, supSizeB,
							\bs : FormMetrics, supSize : FormMetrics -> nextDistinct(
								supFillB,
								WidthHeight(bs.width, fillSize2(bs, supSize))
							)
						),
						make2Subscribe(bodySizeB, subSizeB,
							\bs : FormMetrics, subSize -> nextDistinct(
								subFillB,
								WidthHeight(bs.width, fillSize2(bs, subSize))
							)
						),
						make5Subscribe(
							bodySizeB, supSizeB, supFillB, subSizeB, subFillB,
							\bs : FormMetrics, supS: FormMetrics, supL: WidthHeight, subS: FormMetrics, subL: WidthHeight -> {
								nextDistinct(
									deltaB,
									WidthHeight(1.0, bs.height - (subS.height - subL.height) - (supS.height - supL.height))
								);
								nextDistinct(baselineB, bs.baseline + supL.height);
								nextDistinct(supFillHeightB, supL.height);
							}
						),
						make2Subscribe(
							supSizeB,
							deltaB,
							\sm : FormMetrics, dwh -> nextDistinct(supTotalHeightB, sm.height + dwh.height)
						)
					],
					frm
				);

				Pair(safeFrm, Pair(supFillHeightB, supTotalHeightB));
			})
		})
	})
}

/////////////////////
// Strike out
/////////////////////
strikeOut(form) {
	strikeOutWithColor(form, black, 0.0, 0.0)
}

strikeOutWithColor(form, color, dx, dy) {
	unpair(getDynamicFormSize2(form, true), \bodyForm : Form, bodySizeB : Behaviour<FormMetrics> -> {
		fixBaselineB(
			select(bodySizeB, \bodySize -> bodySize.baseline),
			Select(bodySizeB, \bm -> {
				graphicsForm = 	Graphics(
					[
						MoveTo(-2.0 + dx * 0.5, bm.baseline),
						LineTo(bm.width + 2.0 - dx * 0.5, bm.dHeight + 1.0 + dy),
						ClosePath()
					],
					[Stroke(color), StrokeWidth(2.0)]
				);
				Group([
					bodyForm,
					Size2(zeroSize, graphicsForm)
				])
			})
		)
	})
}

/////////////////////
// Signs
////////////////////
createSign(signType) {
	createSignWithColor(signType, black)
}

createSignWithColor(signType, color) {
	createSignWithColorAndSize(signType, color, 23.0)
}

createSignWithColorAndSize(signType, color, fontSize) {
	switch(signType : DefiniteControlSignType) {
		IntegralSign() : {

				height = fontSize * 2.0;
				width = i2d(round(fontSize * 0.6)); //should be even

				bottomLinkX = fontSize * 0.17;
				bottomLinkY = height - fontSize* 0.2;
				topLinkX = width - fontSize * 0.13;
				topLinkY = fontSize * 0.26;
				lcdx = fontSize * 0.04;
				lcdy = fontSize * 0.3;
				d = fontSize * 0.04;

				Graphics(
					[
						//bottomCurve
						MoveTo(d, height),
						CubicBezierTo(bottomLinkX, bottomLinkY, bottomLinkX - lcdx, bottomLinkY + lcdy),
						//topCurve
						MoveTo(width, d),
						CubicBezierTo(topLinkX, topLinkY, topLinkX + lcdx, topLinkY - lcdy),
						//leftBottom part of main line's border
						MoveTo(width * 0.5, height * 0.5),
						CubicBezierTo(bottomLinkX, bottomLinkY, width * 0.5 - lcdx, height * 0.5 + lcdy),
						//rightBottom part of main line's border
						MoveTo(width * 0.5 + d, height * 0.5),
						CubicBezierTo(bottomLinkX, bottomLinkY, width * 0.5 + d - lcdx, height * 0.5 + lcdy),
						//leftTop part of main line's border
						MoveTo(width * 0.5, height * 0.5),
						CubicBezierTo(topLinkX, topLinkY, width * 0.5 + lcdx, height * 0.5 - lcdy + d),
						//rightTop part of main line's border
						MoveTo(width * 0.5 + d, height * 0.5),
						CubicBezierTo(topLinkX, topLinkY, width * 0.5 + d + lcdx, height * 0.5 - lcdy),
						ClosePath()
					],
					[
						Stroke(color)
					]
				)
			 |> \f -> Border(2.0, 2.0, 2.0, 2.0, f)

		}
		OneCharSign(st) : {
			makeForm = \char ->	Text(char, [FontSize(40.0), Fill(color)]);
			fixSignSize = \f -> Offset(0.0, -10.0, FixSize(30.0, 35.0, f));
			form = switch(st) {
				OrdinalInt() : "&#8747;" |> makeForm;
				DoubleInt() : "&#8748;" |> makeForm;
				TripleInt() : "&#8749;" |> makeForm;
				ContourInt() : "&#8750;" |> makeForm;
				SurfaceInt() : "&#8751;" |> makeForm;
				VolumeInt() : "&#8752;" |> makeForm;
				UnionSign() : "&#8746;"  |> makeForm |> fixSignSize;
				IntersectionSign() : "&#8745;" |> makeForm |> fixSignSize;
			}
			form

		}
		SigmaSign() : {
			width = fontSize * 1.13; // 26
			height = fontSize * 1.74; // 40
			serifHeight = fontSize * 0.26; // 6
			serifWidth = fontSize * 0.09; // 2
			x = fontSize * 0.04; // 1
			y = fontSize * 0.09; // 2

			Graphics(
				[
					MoveTo(width, serifHeight),
					LineTo(width, x),
					LineTo(x, x),
					LineTo(fontSize * 0.65, height * 0.5),
					LineTo(x, height),
					LineTo(width, height),
					LineTo(width, height - serifHeight),
					LineTo(width - serifWidth, height - y),
					LineTo(x + y, height - y),
					LineTo(fontSize * 0.72, height * 0.5 - fontSize * 0.06),
					LineTo(fontSize * 0.15, x),
					LineTo(width - serifWidth, x),
					LineTo(width, serifHeight),
					ClosePath()
				],
				[Fill(color), Stroke(color)]
			) |> \f -> Border(2.0, 2.0, 2.0, 2.0, f)
		}
		ProductSign() : {
			width = 36.0;
			height = 36.0;
			verticalLineWidth = 5.0;
			bottomLineLength = 15.0;
			horizontalLinesWidth = 2.0;
			verticalLineDistanceToVerticalBorder = 5.0;
			Graphics(
				[
					MoveTo(1.0, 1.0),
					LineTo(width, 1.0),
					LineTo(width, horizontalLinesWidth),
					LineTo(width - verticalLineDistanceToVerticalBorder + 1.0, horizontalLinesWidth),
					LineTo(width - verticalLineDistanceToVerticalBorder + 1.0, height - horizontalLinesWidth + 1.0),
					LineTo(width, height - horizontalLinesWidth + 1.0),
					LineTo(width, height),
					LineTo(width - bottomLineLength + 1.0, height),
					LineTo(width - bottomLineLength + 1.0, height - horizontalLinesWidth + 1.0),
					LineTo(width - verticalLineDistanceToVerticalBorder - verticalLineWidth + 1.0, height - horizontalLinesWidth + 1.0),
					LineTo(width - verticalLineDistanceToVerticalBorder - verticalLineWidth + 1.0, horizontalLinesWidth),
					LineTo(verticalLineDistanceToVerticalBorder + verticalLineWidth, horizontalLinesWidth),
					LineTo(verticalLineDistanceToVerticalBorder + verticalLineWidth, height - horizontalLinesWidth + 1.0),
					LineTo(bottomLineLength, height - horizontalLinesWidth + 1.0),
					LineTo(bottomLineLength, height),
					LineTo(1.0, height),
					LineTo(1.0, height - horizontalLinesWidth + 1.0),
					LineTo(verticalLineDistanceToVerticalBorder, height - horizontalLinesWidth + 1.0),
					LineTo(verticalLineDistanceToVerticalBorder, horizontalLinesWidth),
					LineTo(1.0, horizontalLinesWidth),
					LineTo(1.0, 1.0),
					ClosePath()
				],
				[Fill(color), Stroke(color)]
			) |> \f -> Border(2.0, 2.0, 2.0, 2.0, f)
		}
	}
}

/////////////////////
// Cases
////////////////////
cases2formWrap(cases : [[Form]], wrappers : MathFormWrappers, fontSize : double) -> Form {
	cases2formWrap2(cases, wrappers, fontSize).first
}

cases2formWrap2(cases : [[Form]], wrappers : MathFormWrappers, fontSize : double) -> Pair<Form, [[Behaviour<double>]]> {
	colSpec = LayoutSpec(fontSize/2.0, [0.0, 0.0]);
	rowSpec = LayoutSpec(fontSize/2.0, map(cases, \case -> 0.0));

	sB = makeWH();

	table : Pair<Form, [[Pair<Behaviour<double>, Behaviour<double>>]]> = Table2dd(colSpec, rowSpec, cases);

	frm = shiftBaselineB(
		select(sB, \s -> - s.height / 2.0 + 3.0),
		Cols([
			wrappers.wrapGlyph(\fontColor, backColorM -> {
				Select(sB, \s -> {
					BoxBehindMaybe(
						createBracketWithColor(WriteLeftBrace(), s.height, fontColor),
						backColorM
					)
				})
			}),
			Fixed(5.0, 0.0),
			Inspect(
				[ISize(sB)],
				table.first
			)
		])
	);

	Pair(
		frm,
		map(table.second, \row -> map(row, \cell : Pair<Behaviour<double>, Behaviour<double>> -> cell.second))
	)
}

/////////////////////
// Top modificators
////////////////////
topModificator2form(form : Form, type : WriteTopModificator, size : WriteTopModificatorSize, corrections : WriteTopModificatorCorrections) -> Form {
	topModificator2formWithColor(form, type, size, corrections, black)
}

topModificator2formWithColor(form : Form, type : WriteTopModificator, size : WriteTopModificatorSize, corrections : WriteTopModificatorCorrections, color : int) -> Form {
	topModificator2formWrap(form, type, size, corrections, ColoredMathGlyphWrappers(color))
}

topModificator2formWrap(form : Form, type : WriteTopModificator, size : WriteTopModificatorSize, corrections : WriteTopModificatorCorrections, wrappers : MathFormWrappers) -> Form {
	topModificator2formWrap2(form, type, size, corrections, wrappers).first
}

topModificator2formWrap2(form : Form, type : WriteTopModificator, size : WriteTopModificatorSize, corrections : WriteTopModificatorCorrections, wrappers : MathFormWrappers) -> Pair<Form, Behaviour<double>> {
	wide = switch (size) {
		WriteModificatorStretch() : true;
		WriteModificatorFixed() : false;
	}

	baseFixedWidth = 8.0;
	hatHeight = 4.0;
	arrowLen = 3.0;

	unpair(getDynamicFormSize2(form, true), \bodyMod : Form, mB : Behaviour<FormMetrics> -> {
		bodyW = select(mB, \m -> m.width);

		modificatorW = if (wide) {
			select(bodyW, \w -> w + corrections.dl)
		} else {
			const(baseFixedWidth + corrections.dl)
		}

		modificatorHeight = ref 0.0;

		modificatorForm =
			wrappers.wrapGlyph(
				\fc, bcM ->
					Select(modificatorW, \w -> {
						path = switch (type) {
							WriteModificatorArrow() : {
								modificatorHeight := 2.0 * arrowLen + 1.0;
								[
									MoveTo(0.0, arrowLen), LineTo(w, arrowLen),
									MoveTo(w - arrowLen, 2.0 * arrowLen), LineTo(w, arrowLen), LineTo(w - arrowLen, 0.0)
								]
							}
							WriteModificatorLeftRightArrow() : {
								modificatorHeight := 2.0 * arrowLen + 1.0;
								[
									MoveTo(arrowLen, 2.0 * arrowLen), LineTo(0.0, arrowLen), LineTo(arrowLen, 0.0),
									MoveTo(0.0, arrowLen), LineTo(w, arrowLen),
									MoveTo(w - arrowLen, 2.0 * arrowLen), LineTo(w, arrowLen), LineTo(w - arrowLen, 0.0)
								]
							}
							WriteModificatorHat() : {
								modificatorHeight := hatHeight + 1.0;
								[MoveTo(0.0, hatHeight), LineTo(w * 0.5, 0.0), LineTo(w, hatHeight)]
							}
							WriteModificatorBar() : {
								modificatorHeight := 1.0;
								if (wide) {
									[MoveTo(0.0, 0.0), LineTo(w, 0.0)]
								} else {
									//#37230
									[MoveTo(2.0, 0.0), LineTo(w - 1.0, 0.0)]
								}
							}
							WriteModificatorDoubleBar() : {
								modificatorHeight := 3.0;
								[
									MoveTo(0.0, 0.0), LineTo(w, 0.0),
									MoveTo(0.0, 2.0), LineTo(w, 2.0)
								]
							}
							WriteModificatorArc() : {
								modificatorHeight := hatHeight + 1.0;
								[MoveTo(0.0, hatHeight), CubicBezierTo(w, hatHeight, w * 0.5, 0.0)]
							}
							WriteModificatorNone() : {
								[]
							}
						}
						simpleGlyphBackground(
							Graphics(path, [Stroke(fc)]),
							bcM
						)
					})
			);
		border = 2.0;

		shiftB = select(mB, \m -> m.baseline + ^modificatorHeight - m.dHeight + border);
		ShiftFormByDHeight = \f -> Translate(zero, select(mB, \m -> -m.dHeight), f);
		// getDynamicFormSize2 can return height not equal to the one used by engine.
		frm = fixBaselineB(shiftB,
			WideLines([
				Fixed(0.0, border + 1.0), // + 1.0 gives good appearance. Is necessary due to (probably)  Graphics size calculation.
				CenterH(modificatorW, bodyW, Offset(corrections.dx, corrections.dy, ShiftFormByDHeight(modificatorForm))),
				CenterH(
					bodyW, modificatorW,
					Size2(
						select(mB, \m -> WidthHeight(m.width, m.height - m.dHeight)),
						ShiftFormByDHeight(bodyMod)
					)
				)
			])
		);

		Pair(frm, shiftB)
	})

}

/////////////////////
// Utils
////////////////////

// center this form horizontally over other form
CenterH(myWidth : Behaviour<double>, otherWidth : Behaviour<double>, form) {
	hOffset = select2(myWidth, otherWidth, \w1 : double, w2 : double -> max(w2-w1, 0.0) * 0.5);

	Translate(hOffset, zero, form)
}

simpleGlyphBackground(form : Form, bcM : Maybe<int>) -> Form {
	s = 4.0;

	eitherMap(bcM, \bc -> {
		Behind(
			\w0, h0 -> {
				Offset(-s, -s,
					BackgroundWH(w0+s*2.0, h0+s*2.0, [Fill(bc)])
				)
			},
			form
		)
	}, form)
}
