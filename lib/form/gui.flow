// Â© Copyright 2011 Area9 Technologies.

import form/form;
import behaviour;
import transforms;
import math/math;
import math/bits;
import form/renderform;
import form/formmetrics;
import string;
import form/gui2;
import sys/target;
import form/graphics;
import form/formtransforms;
import maybe;
import basecolors;
import form/baseline;

export {
	// When removed, the given function is called. Very useful to allow cleanup activities
	Disposer(form : Form, fn : () -> void) -> Form;

	// When created, the constructors-functions are called. When removed, the unsubscribers-functions are called.
	// Analogue TConstruct in Tropic
	Constructors(constructors : [() -> () -> void], form : Form) -> Form;

	// Arrange these in following lines.
	Lines : ([Form]) -> Form;

	// Arrange these next to each others
	Cols : ([Form]) -> Form;

	// Same as Lines(..), but with intervals between neighboring lines
	LinesWithInterval(interval : double, lines : [Form]) -> Form;

	// Same as Cols(..), but with intervals between neighboring columns
	ColsWithInterval(interval : double, columns : [Form]) -> Form;

	// Arrange these in following lines keeping available width. Useful for paragraphs, but Y fillers in the rrows are useless
	WideLines : ([Form]) -> Form;

	// Similar to WideLines, but for the columns
	TallCols : ([Form]) -> Form;

	// Similar to css float:left for the columns
	FloatingCols : ([Form], out_lineCountB: DynamicBehaviour<int>) -> Form;

	// Rotates in degrees around the center of the form
	Rotate2(degree : Behaviour<double>, form : Form) -> Form;

	// CreepingLine (each timeInterval Form make one step left). Line shows in cycle. Force means cycle even if line shorter than width
	CreepingLine : (width : double, form : Form, step : double, timeInterval : int, force : bool) -> Form;

	// A form of fixed size, but otherwise empty
	Fixed(width : double, height : double) -> Form;

	// Force this fixed logical size - does not resize form
	FixSize(width : double, height : double, f : Form) -> Form;

	// Override logical width of the form - does not resize form
	FixWidth(w : Behaviour<double>, f : Form) -> Form;

	// Override logical height of the form - does not resize form
	FixHeight(h : Behaviour<double>, f : Form) -> Form;

	// Convenience for defining the logical size of a form from two individual behaviours
	SelectSize(width : Behaviour<double>, height : Behaviour<double>, form : Form) -> Form;

	Available(width : Behaviour<double>, height : Behaviour<double>, form : Form) -> Form;

	MinAvailableWidth(width : double, form : Form) -> Form;
	MinAvailableHeight(height : double, form : Form) -> Form;

	OverrideAvailable(fn : (WidthHeight) -> WidthHeight, form : Form) -> Form;
	// The same as above but available is additionally recalculated on each update of trigger
	OverrideAvailable2(fn : (WidthHeight, [double]) -> WidthHeight, trigger : Behaviour<[double]>, form : Form) -> Form;

	OverrideAvailableWidth(width : double, form : Form) -> Form {
		OverrideAvailable(\wh -> WidthHeight(width, wh.height), form)
	}

	OverrideAvailableHeight(height : double, form : Form) -> Form {
		OverrideAvailable(\wh -> WidthHeight(wh.width, height), form)
	}

	OverrideSize2(fn : (WidthHeight) -> WidthHeight, enabled : Behaviour<bool>, form : Form) -> Form;

	OverrideAvailableWidthB(width : Behaviour<double>, form : Form) -> Form {
		ah = make(0.0);
		Inspect([AvailableHeight(ah)], Available(width, ah, form));
	}

	OverrideAvailableHeightB(height : Behaviour<double>, form : Form) -> Form {
		aw = make(0.0);
		Inspect([AvailableWidth(aw)], Available(aw, height, form));
	}

	// Sets available width to very big value
	InfiniteWidth(form : Form) -> Form;

	// Sets available width to very big value
	InfiniteWidthInsteadZero(form : Form) -> Form;

	// Form size will be (0.0, 0.0) when zero available is given
	ZeroSizeOnZeroAvailable(form : Form) -> Form;

	// Returns Form which size is overriden to (0.0, 0.0) in case it is visually empty
	// See formtransforms::isEmptyFormB
	FixEmptyFormSize(f : Form) -> Form;

	// Apply some decorating fn to a form if it is not visually empty (see isEmptyFormB)
	// In case of empty form emptyStub is shown instead if given.
	DecorateNonEmptyForm(fn : (Form) -> Form, emptyStub : Maybe<Form>, form : Form) -> Form;

	// Remembers the biggest size this form ever had. Useful when inserting vector graphics in paragraphs
	// where you want the size to be "cached".
	// Note: causes baseline problem when is applied to complicated constructions such as Math stuff
	MaxSize : (form : Form) -> Form;

	// Does not allow form to return zero size more than once
	NonZeroSize : (form : Form) -> Form;

	// Sometimes we know that current size is zero
	NonZeroSize2 : (form : Form, enabled : Behaviour<bool>) -> Form;

	// Updates logical size in 500 ms after last consequental real size change
	ThrottleSize(form : Form)  -> Form;

	ThrottleSize2(form : Form, maxDelta : int)  -> Form;

	// Make sure the form is at least that size
	Minimum(widthHeight : Behaviour<WidthHeight>, form : Form) -> Form;
	MinWidth(width : Behaviour<double>, form : Form) -> Form;
	MinHeight(height : Behaviour<double>, form : Form) -> Form;

	// Exploits the available space, positioning the child accordingly. x, y doubles are 0-1.
	// The size of this is the maximum of the available space and the form - so if used in a Grid,
	// it will NOT shrink again when something else becomes smaller, because Grid will remember
	// the big size. Use Align2 if you need to let the size of this form be reported by the child
	// rather than the available space.
	Align(xalign : double, yalign : double, form : Form) -> Form;

	// Exploits the available space, positioning the child accordingly. x, y doubles are 0-1.
	// The size of this is the size of the child form!
	Align2(xalign : double, yalign : double, form : Form) -> Form;
	Align2d(xalign : Behaviour<double>, yalign : Behaviour<double>, form : Form) -> Form;
	Align2dd(xalign : Behaviour<double>, yalign : Behaviour<double>, form : Form) -> Quadruple<Form, Behaviour<double>, Behaviour<double>, Behaviour<WidthHeight>>;

	Corner ::= TopLeft, TopRight, BottomLeft, BottomRight;
		TopLeft();
		TopRight();
		BottomLeft();
		BottomRight();

	alignCorner(corner : Corner, form : Form) -> Form;

	// Move a form without changing its size
	Offset(x : double, y : double, form : Form) -> Form;

	// Control the visibility of this form
	Invisible(invisible : Behaviour<int>, form : Form) -> Form;

	// Same thing, but uses bool behaviour
	Invisibleb(invisible : Behaviour<bool>, form : Form) -> Form {
		//Might be a global behaviour
		SelectGlobal(invisible, \v -> b2i(!v), \vis -> Visible(vis, form))
	}

	// And boolean version of Visible
	Visibleb(visible : Behaviour<bool>, form : Form) -> Form {
		//Might be a global behaviour
		SelectGlobal(visible, b2i, \vis -> Visible(vis, form))
	}

	// The same as Visibleb but fn will be called only when visible really becomes true
	VisiblebLazy(visible : Behaviour<bool>, fn : () -> Form) -> Form;

	// This waits with the construction of the form until display time and does this by calling the given function.
	// WARNING: fn is called each time LazyForm is rendered or rerendered! Consider using LazyFormOnce instead.
	LazyForm(fn : () -> Form) -> Form;

	// Same as LazyForm but calls fn only once.
	LazyFormOnce(fn : () -> Form) -> Form;

	// Same as LazyFormOnce but specifies what to show while form loads
	LazyFormOnceWithPlaceHolder(fn : () -> Form, placeholder : Form) -> Form;

	// Wait a little, then show; Empty() is showed until.
	Delayed(delay: int, content: Form) -> Form;

	// Same as Delayed, but placeholder is specified.
	Delayed2(delay: int, content: Form, placeholder: Form) -> Form;

	// Once the condition turns true, the given form is displayed
	LoadOnCondition : (b : Behaviour<bool>, form : Form) -> Form;

	// Get a linear fill gradient, with equal spacing and full opacity for the points
	linearGradient(rotation : double, colors : [int]) -> GradientFill;

	linearGradientA(rotation : double, alpha : double, colors : [int]) -> GradientFill;

	// Renders a computed form behind a given form based on a function that gets the size as the input form.
	Behind(fn : (double, double) -> Form, form : Form) -> Form;
	Above(fn : (double, double) -> Form, form : Form) -> Form; // the same but computed form Above given one


	// Decorate the given form with something dependent on the size. The baseline is the baseline of the form.
	// The callback gets the size of form as an argument, as well as the form itself (properly wrapped),
	// You have to place the form f along with your needs in the result of the function, typically in a Group.
	// If you use a Picture as the form to attach to, please wrap it in MaxSize to avoid some size jittering
	// that leads to strange behaviour.
	Attach(form : Form, fn : (f : Form, fm : FormMetrics) -> Form) -> Form;

	// Renders a rounded rectangle behind the given form. Involves strokeCorrection.
	Rounded(radius : double, style : [GraphicsStyle], form : Form) -> Form;
	RoundedForms(radius : double, style : [GraphicsStyle], form : Form) -> [Form];
	// Same as above but without strokeCorrection.
	Rounded2(radius : double, style : [GraphicsStyle], form : Form) -> Form;

	// Renders a rounded rectangle behind the given form
	RoundedTransformBackground(radius : double, style : [GraphicsStyle], transform: (Form) -> Form, form : Form) -> Form;

	// Renders a rectangle behind the given form. It preserves the baseline of the form. NOTE: involves strokeCorrection
	Background(style : [GraphicsStyle], form : Form) -> Form;
	BackgroundWH(w : double, h : double, style : [GraphicsStyle]) -> Form;

	// Same as above but without strokeCorrection
	Background2(style : [GraphicsStyle], form : Form) -> Form;
	BackgroundWH2(w : double, h : double, style : [GraphicsStyle]) -> Form;

	// Renders a rectangle above the given form.
	Foreground(style : [GraphicsStyle], form : Form) -> Form;
	ForegroundWH(w : double, h : double, style : [GraphicsStyle]) -> Form;

	// Attach a header and a footer to a body - such that the body defines the width
	HeaderFooter(header : Form, body : Form, footer : Form) -> Form;

	// Makes a rectangle with a given width, but all available area in the height
	VFill(width : double, style : [GraphicsStyle]) -> Form;

	// Makes a rectangle with a given height, but all available area in the width
	HFill(height : double, style : [GraphicsStyle]) -> Form;

	// Makes a rectangle of all available area
	HVFill(style : [GraphicsStyle]) -> Form;


	// Animation support
	Animation : (start : () -> () -> void);
		AnimationActivity ::= DoubleAnimation, ColorAnimation, DoubleAnimationFn;
		// Change double behaviour "b" to "to" value in time "duration"
		DoubleAnimation : (b : DynamicBehaviour<double>, to : double, duration : double);
		// Change double behaviour "b" to "to" value in time "duration". Function fn is invoked when "to" value is reached.
		DoubleAnimationFn : (b : DynamicBehaviour<double>, to : double, duration : double, fn : () -> void);
		// Change color behaviour
		ColorAnimation  : (b : DynamicBehaviour<int>, to : int, duration : double);

	makeAnimation : (activities : [AnimationActivity]) -> Animation;

	// animation core with the timer data defined externally
	makeAnimationExt : (activities : [AnimationActivity], value : Behaviour<double>, stop : () -> void) -> Animation;

	// Immediate execute animation
	animate : (activities : [AnimationActivity]) -> void;

	// Immediate execute animation, returns stopper
	interruptibleAnimate : (activities : [AnimationActivity]) -> () -> void;

	// Form for loading screen
	// wait until waitResources are ready, executes fn and starts loading of startResources
	// displays generic centered text with percentage
	LoadingForm : (waitResources : [string], startResources : [[string]], fn : () -> void) -> Form;
	// same as above but with custom form
	LoadingForm2 : (makeForm: (percentage: int) -> Form, waitResources: [string], startResources: [[string]], fn: () -> void) -> Form;

	// shows whileLoading form until loading form is loaded, after that onLoad() is called
	WhileLoading : (loading : Form, whileLoading : Form, onLoad : () -> void) -> Form;

	// New version of the helper above. It uses ShowWhenReady2 i.e. both size and loading files number  monitoring instead of only size.
	// So it is usable not only for pictures.
	WhileLoading2(form : Form, loadingForm : Form, onLoad : () -> void) -> Form;

	// Displays the given form when its size stops changing and calls onDone. Pass 500 ms for checkDelay as a default value.
	ShowWhenReady(form : Form, checkDelay : int, onDone : () -> void) -> Form;

	// Similar to previous one but awaits until loading of content is finished before start monitoring of size.
	ShowWhenReady2(form : Form, checkDelay : int, loadingTimeoutSeconds : int, onDone : () -> void) -> Form;




	// Like switch, but caching each case. Notice that the size can be wrong if the
	// cases are of different size. If you need the correct size, then you should not use
	// this helper. (The size is the size of the biggest case shown so far, and this is
	// wrong if you show a big case, and then switch to a small case. The size will not
	// shrink again when the small case is shown.)
	CachedSwitch : (case : Behaviour<int>, cases : [Form]) -> Form;

	// Replacement of Switch(select(bb, b2i), cases)
	// as it produces memory leak when bb is a global behaviour.
	// length(cases) should be exactly 2;
	Switchb : (case : Behaviour<bool>, cases : [Form]) -> Form;

	// Draws a cursor Form over mouse cursor if it is hovering form
	CustomCursor : (cursor : Form, hideSystemCursor : bool, form : Form) -> Form;

	// Almost the same as previous, but renders cursor over all other forms
	CustomCursor2 : (cursor : Form, hideSystemCursor : bool, form : Form) -> Form;

	// Almost the same as previous, but forces cursor to stay in 0..width area
	CustomCursor2WithWidth : (cursor : Form, hideSystemCursor : bool, form : Form, width : Behaviour<double>) -> Form;

	// Almost the same as previous, but you can explicitly define whether the MouseMove2 event
	// on underlying form should be marked as "handled" or not.
	CustomCursor2WithWidthHandled(cursor : Form, hideSystemCursor : bool, form : Form, width : Behaviour<double>, isHandledMouseMove2 : bool) -> Form;

	// The same as above and support of forced Cursor visibility
	CustomCursor3(cursor : Form, hideSystemCursor : bool, form : Form, width : Behaviour<double>, isHandledMouseMove2 : bool, forceShowCursor : Behaviour<bool>, cursorIsEmpty : Behaviour<bool>) -> Form;

	// Resize content to desired size - notice, this will happily stretch the content
	resizeTo(width : double, height : double, form : Form) -> Form;

	// Resize content to desired size - does NOT stretch content
	resizeToFit(width : double, height : double, form : Form) -> Form;
	resizeToFitB(width : Behaviour<double>, height : Behaviour<double>, enabled : Behaviour<bool>, form : Form) -> Form;
	resizeToFitWHB(widthHeight : Behaviour<WidthHeight>, enabled : Behaviour<bool>, form : Form) -> Form;
	resizeToFitWHB2(widthHeight : Behaviour<WidthHeight>, enabled : Behaviour<bool>, form : Form, maxScale : double) -> Form;
	resizeToWidth(width : double, form : Form) -> Form;
	resizeToHeight(height : double, form : Form) -> Form;
	resizeToFitSize(size : double, form : Form) -> Form;

	// Resize content to the available area - notice, this will happily stretch the content
	resizeToAvailableWidthHeight(form : Form) -> Form;
	resizeToAvailableWidth(form : Form) -> Form;
	resizeToAvailableHeight(form : Form) -> Form;

	// Resize content to the available area, without stretching
	resizeToUseWidthHeight(form : Form) -> Form;
	//Resize to max dimension using keeping aspect ration and crop
	resizeAndCropToUseWidthHeight(form : Form) -> Form;
	resizeAndCropToUseMinWidthHeight(form : Form) -> Form;
	// On zero available use form itself
	resizeToUseWidthHeight2(form : Form) -> Form;

	// Resizes and centers the form to make it fit the given size. Always has the given size
	// Notice that this enlarges to fill out the space used.
	resizeToFitKeepAspect(width : double, height : double, form : Form) -> Form;

	resizeToWH(size : Behaviour<WidthHeight>, form : Form) -> Form;
	resizeToWH2(size : Behaviour<WidthHeight>, deltaAspect : double, form : Form) -> Form;

	// Resize content if its size is bigger than width/height
	shrinkToFit(width : double, height : double, form : Form) -> Form;
	shrinkToFitB(widthHeight : Behaviour<WidthHeight>, form : Form) -> Form;
	shrinkToFitAvailableWH(form : Form) -> Form;
	shrinkToFitB2(widthHeight : Behaviour<WidthHeight>, form : Form, enabled : Behaviour<bool>, isNew : bool) -> Form;
	shrinkToAvailableWidth(form : Form) -> Form;

	shrinkToFitWidth(width: Behaviour<double>, form: Form) -> Form;

	// Enlarge to fit available size, but not more than maxScale
	enlargeToFitAvailable(form: Form, maxScale: double) -> Form;
	enlargeToFitB(widthHeight : Behaviour<WidthHeight>, form : Form) -> Form;
	enlargeToFitB2(widthHeight : Behaviour<WidthHeight>, form : Form, enabled : Behaviour<bool>, maxScale : double) -> Form;

	// Helpful for typing reasons
	makeEmpty : () -> DynamicBehaviour<Form>;
	// When f becomes Empty() calls contFn. Does not trigger at start.
	waitForEmpty(f : DynamicBehaviour<Form>, contFn : () -> void) -> Form;

	// This turns 1 if we are running on a really small screen! Notice this is updated by skin so without that, it does not work!
	smallScreen : DynamicBehaviour<int>;


	// A generic button
	Button(content : Form, fn : () -> void) -> Form;

	// A text-based button
	TextButton(text : string, fn : () -> void) -> Form;

	// Converts keys string to KeyEvent. Usage example: parseShortcut("Ctrl+Alt+F1")
	parseShortcut(shortcut : string) -> KeyEvent;
	matchShortcut(event : KeyEvent, shortcut : KeyEvent) -> bool;
	matchShortcutKeyCode(event : KeyEvent, shortcut : KeyEvent) -> bool;

	// Check if URL looks like picture
	isPictureUrl(url : string) -> bool;

	// Check if given ext is one of supported pictures exts
	isPictureExt(ext : string) -> bool;

	// If you have problems with your gui, this helper provides inspection into construction/deconstruction as well as size and available space changes
	Debug(text : string, form : Form) -> Form;
	DebugRed(form : Form) -> Form { DebugColor(form, red); }
	DebugGreen(form : Form) -> Form { DebugColor(form, green); }
	DebugBlue(form : Form) -> Form { DebugColor(form, blue); }
	DebugBaseline(form : Form) -> Form;

	// Explicitly prevent Mouse{Up/Down}2 from falling further. Best used as form |> MouseUD2Catcher
	MouseUD2Catcher : (form : Form) -> Form;

	// A fixed sized empty form that can handle mouse events. Normal Fixed ignores them. Notice the size is 0.0, 0.0
	ClickableFixed(width : double, height : double) -> Form;

	// The same, but with a real size
	ClickableFixed2(width : double, height : double) -> Form;

	// Wraps group into Available so that group members can be aligned properly in any context
	GroupWithSizeFixed(w : double, h : double, forms : [Form]) -> Form;

	getWidth(wh : Behaviour<WidthHeight>) -> Behaviour<double>;
	getHeight(wh : Behaviour<WidthHeight>) -> Behaviour<double>;
	mapWidth(wh : Behaviour<WidthHeight>, fn : (double) -> ?) -> Behaviour<?>;
	mapHeight(wh : Behaviour<WidthHeight>, fn : (double) -> ?) -> Behaviour<?>;

	InfiniteWidthAWH = const(WidthHeight(10000.0, 0.0));

	makePoint() -> DynamicBehaviour<Point>;
	setAvailableWH(width : double, height : double) -> (Form) -> Form;

	// Allows to run onLoaded() exactly at the moment when all the files (for now: video, pictures and ActiveArt forms) are have been successfully loaded.
	// Video is not taken into account under cpp target for now.
	waitForFilesLoaded(timeoutSeconds : int, onLoaded : (onTimeout : bool) -> void) -> void;

	MoveCenter2ZeroPoint(form : Form) -> Form;

	maskImage(form : Form, color : int) -> Form;
	maskImageWithOpacity(form : Form, color : Color) -> Form;

	//Add ellipsis to one line string
	oneLineEllipsis(text : string, style : [CharacterStyle], width : double) -> Form;

	isLiteEditStyle() -> bool;
	setLiteEditStyle(liteEditStyle : bool) -> void;

	// Decorate this form with a global position-finder and get a new Form with a function
	// that can tell the position when called
	addTransformMatrixInspector(form : Form) -> FormInspector;
		FormInspector(
			form : Form,
			inspector : () -> TransformMatrix
		);

	DynamicGroupSkipUpdate(
		combiner : DynamicGroupCombiner,
		init : [Form],
		update : DynamicBehaviour<[GroupChange]>,
		skipUpdate : Behaviour<bool>) -> Form;
}

useLiteEditStyle = ref false;

isLiteEditStyle() {
	^useLiteEditStyle;
}

setLiteEditStyle(liteEditStyle : bool) {
	useLiteEditStyle := liteEditStyle;
}

Available(w, h, f) {
	awh = make(WidthHeight(getValue(w), getValue(h)));
	Constructor(
		Available2(awh, f),
		\ -> connectSelect2Distinctu(w, h, awh, \ww, hh -> WidthHeight(ww, hh))
	);
}

setAvailableWH(w : double, h : double) -> (Form) -> Form {
	\form -> Available2(const(WidthHeight(w, h)), form)
};

SelectSize(width : Behaviour<double>, height : Behaviour<double>, form : Form) -> Form {
	wh = make(WidthHeight(getValue(width), getValue(height)));
	Constructor(
		Size2(wh, form),
		\ -> connectSelect2Distinctu(width, height, wh, \w, h -> WidthHeight(w, h))
	);
}

// When removed, the given function is called. Very useful to allow cleanup activities
Disposer(form : Form, fn : () -> void) -> Form {
	Constructor(form, \ -> fn);
}

Constructors(constructors, form) {
	Constructor(form, \ -> {
		disposers = map(constructors, apply0);
		\ -> applyall(disposers)
	})
}

Lines(rows) {
	n = length(rows);
	if (n == 0) Empty()
	else if (n == 1) rows[0]
	else Grid(map(rows, v2a));
}

Cols(cols) {
	n = length(cols);
	if (n == 0) Empty()
	else if (n == 1) cols[0]
	else Grid([cols]);
}

LinesWithInterval(interval : double, lines : [Form]) -> Form {
	Lines(
		mapi(lines, \i, a -> {
			if (i == 0)
				a
			else
				Border(0.0, interval, 0.0, 0.0, a)
		})
	)
}

ColsWithInterval(interval : double, columns : [Form]) -> Form {
	Cols(
		mapi(columns, \i, a -> {
			if (i == 0)
				a
			else
				Border(interval, 0.0, 0.0, 0.0, a)
		})
	)
}

Rotate2(degree : Behaviour<double>, form : Form) -> Form {
	awh = makeWH();
	x = make(0.0);
	y = make(0.0);

	Constructor(
		Translate(
			x, y,
			Rotate(degree, Inspect([ISize(awh)], form))
		),
		\ -> {
			select2u(awh, degree, \wh, d -> {
				r = sqrt(wh.width*wh.width+wh.height*wh.height);
				beta = atan2(wh.width, wh.height);
				alpha = d / 180.0 * PI;
				x1 = (wh.width - r * cos(alpha + beta)) / 2.0;
				y1 = (wh.width - r * sin(alpha + beta)) / 2.0;
				next(x, x1);
				next(y, y1);
			}).second
		}
	)
}


Fixed(width : double, height : double) {
	// Since we have constant behaviours we could use Size(const(w), const(h), Empty()) instead of Border(...),
	// but the reason not to do that is to preserve baseline.
	// E.g. if you use Cols([Text, Fixed]): with Border, the baseline from the Text is preserved; with Size, it is not.
	Border(0.0, 0.0, width, height, Empty());
}

FixSize(width : double, height : double, f : Form) -> Form {
	Size2(const(WidthHeight(width, height)), f);
}

Align(xalign, yalign, form) {
	awh = makeWH();
	wh = makeWH();

	swh = makeWH();
	tdx = make(0.0);
	tdy = make(0.0);

	Constructor(
		Size2(swh,
			Inspect([IAvailable2(awh), ISize(wh)],
				Translate(tdx, tdy, form)
			)
		),
		\ -> {
			ux = connectSelect2u(awh, wh, tdx, \a, wi -> {
				max((a.width - wi.width) * xalign, 0.0)
			});
			uy = connectSelect2u(awh, wh, tdy, \a, he -> {
				max((a.height - he.height) * yalign, 0.0)
			});
			mwh = select2u(awh, wh, \a, wihe -> {
				WidthHeight(
					max(a.width, wihe.width),
					max(a.height, wihe.height)
				);
			});

			widthHeight = whenSizeChangedu(mwh.first);
			u1 = connect(widthHeight.first, swh);

			us = [mwh.second, widthHeight.second, ux, uy, u1];
			\ -> {
				applyall(us);
			}
		}
	);
}

Align2dd(xalign, yalign, form) {
	awh = makeWH();
	wh = makeWH();

	dx = make(0.0);
	dy = make(0.0);

	construct = \ -> {
		uns1 = connectSelect3u(awh, wh, xalign, dx, \a, wi, xa -> {
			max((a.width - wi.width) * xa, 0.0);
		});
		uns2 = connectSelect3u(awh, wh, yalign, dy, \a, he, ya -> {
			max((a.height - he.height) * ya, 0.0)
		});
		\ -> { uns1(); uns2() }
	}

	Quadruple(
		Constructor(
			Inspect([IAvailable2(awh), ISize(wh)], Translate(dx, dy, form)),
			construct
		),
		dx,
		dy,
		awh
	);
}

Align2d(xalign, yalign, form) {
	Align2dd(xalign, yalign, form).first
}

Align2(xalign, yalign, form) {
	if (xalign == 0.0 && yalign == 0.0) form
	else Align2d(const(xalign), const(yalign), form)
}

alignCorner(corner : Corner, form : Form) -> Form {
	align = switch (corner : Corner) {
		TopLeft() : Pair(0., 0.);
		TopRight() : Pair(1., 0.);
		BottomLeft() : Pair(0., 1.);
		BottomRight() : Pair(1., 1.);
	};

	Align2(align.first, align.second, form);
}

Invisible(invisible, form) {
	SelectGlobal(invisible, \v -> 1 - v, \vis -> Visible(vis, form))
}

VisiblebLazy(visible : Behaviour<bool>, fn : () -> Form) -> Form {
	form = makeEmpty();
	Constructor(
		Mutable(form),
		\ -> {
			isvisible = make(0);
			firsttime = ref true;
			subscribe(visible, \v -> {
				if (v) {
					if (^firsttime) {
						nextDistinct(form, Visible(isvisible, fn()));
						firsttime := false;
					}
				}
				nextDistinct(isvisible, b2i(v));
			});
		}
	)
}

Offset(x, y, form) {
	cx = if (x == 0.0) zero else const(x);
	cy = if (y == 0.0) zero else const(y);
	// Do not use Border here, because that changes size!
	Translate(cx, cy, form);
}

Minimum(widthHeight : Behaviour<WidthHeight>, form : Form) -> Form {
	Group([
		Size2(widthHeight, Empty()),
		form
	]);
}

MinWidth(width : Behaviour<double>, form : Form) -> Form {
	wh = makeWH();
	Constructor(
		Minimum(wh, form),
		\ -> subscribe(width, \w -> next(wh, WidthHeight(w, 0.0)))
	)
}

MinHeight(height : Behaviour<double>, form : Form) -> Form {
	wh = makeWH();
	Constructor(
		Minimum(wh, form),
		\ -> subscribe(height, \h -> next(wh, WidthHeight(0.0, h)))
	)
}

LazyForm(fn : () -> Form) -> Form {
	form = make(Empty());
	Constructor(Mutable(form), \ -> {
		next(form, fn());
		nop
	});
}

LazyFormOnce(fn : () -> Form) -> Form {
	LazyFormOnceWithPlaceHolder(fn, Empty());
}

LazyFormOnceWithPlaceHolder(fn : () -> Form, placeholder : Form) -> Form {
	form = make(placeholder);
	once : ref Maybe<Form> = ref None();
	Constructor(Mutable(form), \ -> {
		next(form, onlyOnce(once, fn));
		nop
	});
}

Delayed(delay: int, content: Form) -> Form {
	Delayed2(delay, content, Empty());
}

Delayed2(delay: int, content: Form, placeholder: Form) -> Form {
	form = make(placeholder);
	once : ref Maybe<Form> = ref None();
	Constructor(Mutable(form), \-> {
		timer(delay, \-> next(form, onlyOnce(once, \-> content)));
		nop
	});
}

Button(content, fn) {
	down = ref false;
	Interactive([
		MouseDown(\info -> {
			if (info.inside()) {
				down := true;
				true;
			} else {
				down := false;
				false;
			}
		}),
		MouseUp2(\handled, e -> {
			r = if (!handled) {
				info = e();
				if (info.inside && ^down) {
					fn();
					true;
				} else false;
			} else false;
			down := false;
			r
		})
	], content);
}

TextButton(text, fn) {
	hover = make(0);
	Access([AccessRole("button"), AccessDescription(text)],
		Cursor(
			FingerCursor(),
			Interactive([
					MouseClick(\gm -> fn()),
					MouseUp(\gm -> gm().inside), // Be sure to eat mouse up events as well
					RollOver(\gm -> nextDistinct(hover, 1)),
					RollOut(\gm -> nextDistinct(hover, 0))
				],
				Switch(hover, [
					Rounded(5.0,
						[Stroke(0x484848), StrokeWidth(2.0), Fill(0xf8f8f8)],
						Border(10.0, 3.0, 10.0, 3.0,
							Text(text, [FontSize(12.0), Fill(0x181818)])
						)
					),
					Rounded(5.0,
						[Stroke(0x484848), StrokeWidth(2.0), Fill(0xa8a8a8)],
						Border(10.0, 3.0, 10.0, 3.0,
							Text(text, [FontSize(12.0), Fill(0x181818)])
						)
					)
				])
			)
		)
	);
}

linearGradient(rotation, colors) {
	li = length(colors);
	if (li == 1) {
		GradientFill(0.0, [GradientPoint(colors[0], 1.0, 0.0), GradientPoint(colors[0], 1.0, 1.0)]);
	} else {
		l = i2d(li - 1);
		GradientFill(rotation, mapi(colors, \i, c -> GradientPoint(c, 1.0, i2d(i) / l)));
	}
}

linearGradientA(rotation, alpha, colors) {
	l = i2d(length(colors) - 1);
	GradientFill(rotation, mapi(colors, \i, c -> GradientPoint(c, alpha, i2d(i) / l)));
}

BehindForms(fn : (double, double)->Form, form : Form) -> [Form] {
	if (isStaticForm(form)) {
		metrics = getStaticFormSize(form);
		[
			fn(metrics.width, metrics.height),
			form,
		]
	} else {
		wh = makeWH();
		[
			Select(
				wh, \wh2 -> {
					if (wh2.width == 0.0 || wh2.height == 0.0) { Empty() }
					else fn(wh2.width, wh2.height)
				}
			),
			Inspect([ISize(wh)], form)
		]
	}
}

// Renders a form behind a given form with the same size as the form
Behind(fn, form) {
	Group(BehindForms(fn, form))
}

// Renders a form above a given form with the same size as the form
Above(fn, form) {
	Group(reverseA(BehindForms(fn, form)))
}

Attach(form : Form, fn : (f : Form, fm : FormMetrics) -> Form) -> Form {
	r = getDynamicFormSize(MaxSize(form));
	baseline = make(0.0);
	wh = makeWH();

	Constructor(
		Baseline(
			baseline,
			Available2(wh, Select(distinctUntilChanged(r.second), \fm -> fn(r.first, fm)))
		),
		\ -> {
			subscribe(r.second, \size -> {
				next(baseline, size.baseline);
				next(wh, WidthHeight(size.width, size.height));
			})
		}
	)
}

RoundedForms(radius, style, form) {
	correction = strokeCorrection(style);
	BehindForms(\w, h -> Size2(zeroSize, Graphics(roundedRect(max(0.0, w - correction), max(0.0, h - correction), radius), style)), form);
}

Rounded(radius, style, form) {
	Group(RoundedForms(radius, style, form));
}

Rounded2(radius, style, form) {
	Behind(\w, h -> Size2(zeroSize, Graphics(roundedRect(w, h, radius), style)), form);
}

RoundedTransformBackground(radius, style, transform, form) {
	correction = strokeCorrection(style);
	Behind(\w, h -> Graphics(roundedRect(w - correction, h - correction, radius), style) |> transform, form);
}

BackgroundWH(w, h, style) {
	Size2(zeroSize, Rectangle(w, h, style));
}

BackgroundWH2(w, h, style) {
	Size2(zeroSize, Rectangle2(w, h, style));
}

Background(style, form) {
	// Let's see if we can use scaling for this guy
	if (onlyFillStyle(style)) {
		// Instead of using Behind, we just stretch a rectangle with Scale.
		wh = makeWH();
		rectSize = 128.0; // Max Flash supported scale factor is 32767. We had a problem with background of height of 35000 pixels.
		invRectSize = 1.0 / rectSize;
		sx = make(0.0);
		sy = make(0.0);
		Constructor(
			Group([
				Size2(zeroSize, Scale(sx, sy, Rectangle(rectSize, rectSize, style))),
				Inspect([ISize(wh)], form),
			]),
			\ -> {
				subscribe(wh, \mwh -> {
					next(sx, mwh.width * invRectSize);
					next(sy, mwh.height * invRectSize);
				});
			}
		)
	} else {
		Behind(\w, h -> BackgroundWH(w, h, style), form);
	}
}

Background2(style, form) {
	if (onlyFillStyle(style)) {
		// When there is only fill, stroke correction is nop, so this is equivalent
		Background(style, form);
	} else {
		Behind(\w, h -> Size2(zeroSize, Graphics(rectangle(0.0, 0.0, w, h), style)), form);
	}
}

onlyFillStyle(style : [GraphicsStyle]) -> bool {
	fold(style, true, \acc, s : GraphicsStyle -> {
		switch (s) {
			// If it is only a fill, then we can scale a small rectangle for a dynamically sized rectangle
			Fill(c): acc;
			FillOpacity(o): acc;
			default: false;
		}
	});
}

ForegroundWH(w, h, style) {
	// We set the size of the graphics to 0.0, 0.0 to preserve the baseline of any text in the form
	Size2(zeroSize, Rectangle(w, h, style));
}

Foreground(style, form) {
	Above(\w, h -> ForegroundWH(w, h, style), form);
}

HeaderFooter(header : Form, body : Form, footer : Form) {
	width = make(0.0);
	Lines([
		Available(width, zero, header),
		Inspect([Width(width)], body),
		Available(width, zero, footer),
	]);
}

VFill(width : double, style) {
	height = make(0.0);
	Inspect(
		[AvailableHeight(height)],
		Select(height, \h -> Rectangle(width, h, style))
	);
}

HFill(height: double, style) {
	width = make(0.0);
	Inspect(
		[AvailableWidth(width)],
		Select(width, \w -> Rectangle(w, height, style))
	);
}

HVFill(style) {
	awh = makeWH();
	Inspect(
		[IAvailable2(awh)],
		Select(awh, \wh -> Rectangle(wh.width, wh.height, style))
	);
}


makeAnimation(activities) {
	tmr = repeatable(if (mobile) 100 else 50);
	makeAnimationExt(activities, tmr.value, tmr.stop)
}

makeAnimationExt(activities, value, stop) {
	//TODO: determine real FPS
	//fps = 30;

	last = map(activities, \a -> switch (a : AnimationActivity) {
			DoubleAnimation(b, to, len) : len;
			DoubleAnimationFn(b, to, len, fn) : len;
			ColorAnimation(b, to, len) : len;
		})
		|> \l -> fold(l, 0.0, max);

	/* commented finishing behaviour

	finished = make({});
	*/

	calledOnce = map(activities, \v -> ref false);
	doStart = \ -> {
		// execute each animation
		start = getValue(value); //timestamp();
		fromValues = map(activities, \a -> switch (a : AnimationActivity) {
			DoubleAnimation(b, to, len) : (getValue(b));
			DoubleAnimationFn(b, to, len, fn) : (getValue(b));
			ColorAnimation(b, to, len) : i2d(getValue(b));
		});

		uns = ref nop;
		uns := subscribe(value, \t -> {
			if (t > start+last) {
				stop();
				^uns();
				iteri(activities, \i, a -> switch (a : AnimationActivity) {
					DoubleAnimation(b, to, len) : {
						nextDistinct(b, to);
					}
					DoubleAnimationFn(b, to, len, fn) : {
						nextDistinct(b, to);
						if (!^(calledOnce[i])) deferred(fn); // execute anyways, even if value was not changed
					}
					ColorAnimation(b, to, len) : {
						nextDistinct(b, to);
					}
				});
			} else {
				iteri(activities, \i, a -> switch (a : AnimationActivity) {
					DoubleAnimation(b, to, len) : {
						from = fromValues[i];
						if (t < start + len) {
							next(b, from + (to-from)*(t-start)/len);
						} else {
							nextDistinct(b, to);
						}
					}
					DoubleAnimationFn(b, to, len, fn) : {
						from = fromValues[i];
						if (t < start + len) {
							next(b, from + (to-from)*(t-start)/len);
						} else {
							nextDistinct(b, to);
							if (!^(calledOnce[i])) {
								calledOnce[i] := true;
								fn(); // execute anyways, even if value was not changed
							}
						}
					}
					ColorAnimation(b, to, len) : {
						from = floor(fromValues[i]);
						nxt = \from_val, to_val -> round(i2d(from_val) + i2d(to_val - from_val) * (t - start)/len);
						if (t < start + len) {
							from_r = bitUshr(from,16) % 256;
							from_g = bitUshr(from,8) % 256;
							from_b = from % 256;

							to_r = bitUshr(to,16) % 256;
							to_g = bitUshr(to,8) % 256;
							to_b = to % 256;

							next(b, bitShl(nxt(from_r, to_r), 16) + bitShl(nxt(from_g, to_g),8) + nxt(from_b, to_b));

						} else {
							nextDistinct(b, to);
						}
					}
				});
			}
		});
		\ -> {
			stop();
			^uns();
		}
	};

	Animation(doStart/*, finished*/)
}

animate(activities) {
	a = makeAnimation(activities);
	stop = a.start();
}

interruptibleAnimate(activities) {
	a = makeAnimation(activities);
	a.start();
}

WideLines(rows) {
	if (length(rows) <= 1) Lines(rows)
	else {
		width = make(0.0);
		Inspect(
			[AvailableWidth(width)],
			Lines(map(rows, \f -> Available(width, zero, f)))
		)
	}
}

TallCols(cols) {
	if (length(cols) <= 1) Cols(cols)
	else {
		height = make(0.0);
		Inspect(
			[AvailableHeight(height)],
			Cols(map(cols, \f -> Available(zero, height, f)))
		)
	}
}

// Be careful, lots of memory leaks here
FloatingCols(forms: [Form], out_lineCountB: DynamicBehaviour<int>) -> Form {
	widthBs = map(forms, \f -> make(0.0));
	awhB = makeWH();

	pair1 = mergeu(widthBs);
	lineNumsB = selectDistinct(select2(awhB, pair1.first, \awh, widths -> {
		res = foldi(widths, Pair(0.0, []), \i, acc, w -> {
			offset0 = acc.first + w;
			Pair(
				if (offset0 > awh.width) w else offset0,
				arrayPush(acc.second, lastElement(acc.second, 0) + (if (offset0 > awh.width) 1 else 0)))
		});

		res.second
	}), idfn);

	linesB = selectDistinct(lineNumsB, \lns -> {
		maxLine = either(maxA(lns), 0);
		res : [ref [Pair<int, Form>]] = map(enumFromTo(0, maxLine), \i -> ref []);
		mapi(lns, \i, ln -> refArrayPush(res[ln], Pair(i, forms[i])))
		|> ignore;

		map(res, \r -> ^r)
	});

	connectDistinct(select(linesB, length), out_lineCountB);

	Select(linesB, \lines ->
		Lines(map(lines, \cols ->
			Cols(map(cols, \col ->
				Inspect([Width(widthBs[col.first])], col.second)
			))
		))
	)
	|> (\f ->
		Select(awhB, \wh ->
			if (wh.width == 0.0)
				Size2(const(zeroWH), f)
			else f)
	)
	|> (\f -> Inspect([IAvailable(awhB)], f))
	|> (\f -> Constructor(f, \-> \-> {
		pair1.second();
	}))
}

LoadOnCondition(b, form) {
	if (getValue(b)) {
		form
	} else {
		delayed = make(Empty());
		uns = ref nop;
		uns := subscribe2(b, \v ->
			if (v) {
				next(delayed, form);
				^uns();
			}
		);

		Mutable(delayed)
	}
}

isPictureExt(ext) {
	normExt = toLowerCase(ltrim2(ext, "."));
	exts = ["swf", "png", "jpg", "jpeg", "gif"];
	contains(exts, normExt)
}

isPictureUrl(url) {
	url |> getUrlExtension |> isPictureExt
}

LoadingForm2(makeForm, waitResources, startResources, onFinish) {
	loadedCount = make(0);
	group = makeEmpty();
	loadingGroup = make(0);

	loadOne = \pic, onComplete -> {
		wh = makeWH();
		complete = ref false;
		uns = ref nop;
		uns := subscribe(select(wh, \wwhh -> wwhh.width * wwhh.height > 0.0),
			\loaded -> if (loaded && !^complete) {
				complete := true;
				^uns();
				next(loadedCount, getValue(loadedCount) + 1);
				onComplete();
			});

		Inspect([ISize(wh)], pic);
	}

	loadGroup = \pics, onComplete -> {
		cnt = length(pics);

		if (cnt == 0) {
			onComplete();
			Empty();
		} else {
			doneCnt = make(0);
			doneOne = \ -> next(doneCnt, getValue(doneCnt) + 1);

			uns = ref nop;
			doneAll = \ -> {
				next(loadingGroup, getValue(loadingGroup) + 1);
				onComplete();
				^uns();
			}
			uns := subscribe(doneCnt, \c -> if (c == cnt) { deferred(doneAll); });

			Group(pics
				|> (\l -> map(l, \p -> if (isPictureUrl(p)) Picture(p, [OnlyDownloadToCache(), OnLoadingError(\e -> doneOne())]) else Video(p, [OnVideoLoadingError(doneOne)], [], [PlayerPause(make(true))])))
				|> (\l -> map(l, \p -> loadOne(p, doneOne)))
				|> (\l -> map(l, \p -> Alpha(zero, p)))
			);
		}
	}

	next(group, loadGroup(waitResources,
		\-> {
			next(group, Group( mapi(startResources, \i, r -> Select(loadingGroup, \g -> if (g == i + 2) loadGroup(r, nop) else Empty()))));
			timer(0, onFinish);
		}
	));

	totalWait = i2d(length(waitResources));
	Group([
		Mutable(group),
		Align(0.5, 0.5,
			Select(loadedCount,
				\cnt -> {
					perc = min(round((i2d(cnt) / totalWait) * 100.0), 100);
					makeForm(perc);
				}
			)
		)
	])
}

LoadingForm(waitResources, startResources, onFinish) {
	LoadingForm2(\percentage -> Text("Loading " + i2s(percentage) + "%", [FontSize(18.0)]), waitResources, startResources, onFinish);
}

WhileLoading(loading, whileLoading, onLoad) {
	wh = makeWH();
	loaded = make(0);

	uns = ref nop;
	uns := subscribe(
		wh,
		\size -> {
			if (size.width * size.height != 0.0) {
				timer(1, \-> {
					next(loaded, 1);
					(^uns)();
					onLoad();
				})
			}
		}
	);

	Switch(
		loaded, [
		Group([
			whileLoading,
			Inspect([ISize(wh)], loading)
		]),
		loading
	])
}

//onDone is not executed if the form is deconstructed until size become stable
ShowWhenReady(form : Form, checkDelay : int, onDone : () -> void) -> Form {
	unpair(ShowWhenReadyEx(form, checkDelay, onDone), \mForm, startMonitoring -> {
		Constructor(mForm, \ -> startMonitoring().first)
	})
}

//onDone is not executed if the form is deconstructed until media content loading is finished and size become stable
ShowWhenReady2(form : Form, checkDelay : int, timeout : int, onDone : () -> void) -> Form {
	unpair(ShowWhenReadyEx(form, checkDelay, onDone), \mForm, startMonitoring -> {
		Constructor(
			mForm,
			\ -> {
				uns = ref nop;
				waitForFilesLoaded(timeout, \onTimeout -> {
					monitoringPair = startMonitoring();
					if (onTimeout) {
						//Force visibility and unsubscribe from size monitoring
						monitoringPair.second();
					} else {
						uns := monitoringPair.first;
					}
				});
				\ -> {
					^uns()
				}
			}
		)
	})
}

// Returns pair of functions:
// 1 - size monitoring unsubscriber. 2 - force visibility
ShowWhenReadyEx(
		form : Form,
		checkDelay : int,    // the form gets shown if it's size doesn't change during this period (milliseconds)
		onDone : () -> void  // called when form is finally shown
) -> Pair<
		Form,
		() -> Pair<() -> void, () -> void>  // call this function to actually start size monitoring
> {
	stop = ref nop;
	alpha = make(0.0);
	size = makeWH();
	uns = ref nop;
	once = ref false;

	showMe = \ -> {
		if (!^once) {
			once := true;
			^uns();
			uns := nop;
			^stop();
			stop := nop;
			next(alpha, 1.0);
			onDone();
		}
	}

	startSizeMonitoring = \ -> {
		uns := subscribe(whenSizeChanged(size), \__ -> {
			^stop();
			stop := interruptibleTimer(checkDelay, showMe)
		});
		Pair(
			\ -> {
				^stop();
				stop := nop;
				^uns()
			},
			showMe
		)
	}

	Pair(
		Inspect([ISize(size)], Alpha(alpha, form)),
		startSizeMonitoring
	)
}

CachedSwitch(case : Behaviour<int>, cases : [Form]) -> Form {
	Group(
		mapi(cases, \i, cf -> {
			visible = make(1);
			form = make(Empty());
			Constructor(
				Visible(visible, Mutable(form)),
				\ -> subscribe(case, \c -> {
					if (c == i) {
						nextDistinct(visible, 1);
						nextDistinct(form, cf);
					} else {
						nextDistinct(visible, 0);
					}
				})
			)
		})
	);
}

Switchb(case : Behaviour<bool>, cases : [Form]) -> Form {
	if (length(cases) != 2) {
		Text("Wrong Switch2", [Fill(0xFF0000)])
	} else {
		Select(case, \c -> {
			cases[b2i(c)]
		})
	}
}

CustomCursor(cursor, hideSystemCursor, form) {
	xPos = make(0.0);
	yPos = make(0.0);
	hover = make(0);
	cursorForm = Switch(stall(hover, 10), [
		Empty(),
		Translate(xPos, yPos, if (hideSystemCursor) Cursor(NoCursor(), cursor) else cursor)
	]);

	Constructor(
		Interactive([
				RollOver(\gm -> {
					next(xPos, getMouseX(getStage()));
					next(yPos, getMouseY(getStage()));
					nextDistinct(hover, 1);
				}),
				RollOut(\gm -> {
					nextDistinct(hover, 0);
				}),
				MouseMove2(\handled, gm -> {
					if (!handled && getValue(hover) == 1) {
						mouseInfo = gm();
						if (mouseInfo.inside) {
							nextDistinct(xPos, getMouseX(getStage()));
							nextDistinct(yPos, getMouseY(getStage()));
							true;
						} else {
							nextDistinct(hover, 0);
							false;
						}
					} else handled;
				})
			],
			form
		),
		\ -> {
			nextDistinct(hover, 0);
			uns = render(cursorForm);
			\-> {nextDistinct(hover, 0); uns();}
		}
	)
}

CustomCursor2(cursor, hideSystemCursor, form) {
	CustomCursor2WithWidth(cursor, hideSystemCursor, form, const(0.0));
}

CustomCursor2WithWidth(cursor, hideSystemCursor, form, width) {
	CustomCursor2WithWidthHandled(cursor, hideSystemCursor, form, width, true);
}

CustomCursor2WithWidthHandled(cursor, hideSystemCursor, form, width, isHandledMouseMove2) {
	CustomCursor3(cursor, hideSystemCursor, form, width, isHandledMouseMove2, const(false), const(false))
}

CustomCursor3(cursor, hideSystemCursor, form, width, isHandledMouseMove2, showCursor, isEmpty) {
	xPos = make(0.0);
	yPos = make(0.0);
	hover = make(false);
	cursorVisible = make(false);
	awh = makeWH();
	aw = make(0.0);

	xRealPos = make(0.0);

	moveTooltip = make(false);
	transistorX = make(0.0);
	transistorY = make(0.0);

	alpha = make(1.0);

	cursorForm = Alpha(
		alpha,
		Inspect(
			[Width(aw)],
			Translate(
				transistorX, transistorY,
				if (hideSystemCursor) Cursor(NoCursor(), cursor) else cursor
			)
		)
	);

	Constructor(
		Interactive([
				RollOver(\gm -> {
					next(xPos, getMouseX(getStage()));
					next(yPos, getMouseY(getStage()));
					nextDistinct(hover, true);
				}),
				RollOut(\gm -> {
					nextDistinct(hover, false);
				}),
				MouseMove2(\handled, gm -> {
					if (!handled) {
						mouseInfo = gm();
						if (mouseInfo.inside) {
							nextDistinct(hover, true);
							nextDistinct(xPos, getMouseX(getStage()));
							nextDistinct(yPos, getMouseY(getStage()));
							isHandledMouseMove2;
						} else {
							nextDistinct(hover, false);
							false;
						}
					} else {
						handled;
					}
				})
			],
			form
		),
		\ -> {
			nextDistinct(hover, false);

			disp1 = transistoru(moveTooltip, xRealPos);
			disp2 = transistoru(moveTooltip, yPos);

			unsArray = [
				connectSelect2u(hover, showCursor, cursorVisible, \h, s -> h || s),
				connectSelect3u(width, aw, xPos, xRealPos, \wv : double, av : double, xv : double -> {
					if (wv > 0.0)
						min(xv, wv - av)
					else
						xv
				}),
				connectSelectu(showCursor, moveTooltip, \sc -> !sc),
				disp1.dispose,
				disp2.dispose,
				connect(disp1.value, transistorX),
				connect(disp2.value, transistorY),
				connectSelectu(isEmpty, alpha, \empty -> b2d(!empty))
			];

			d = ref nop;
			stallCursorVisible = stallu(cursorVisible, 10);
			uns = subscribe(stallCursorVisible.first, \v -> {
				if (v) {
					d := render(cursorForm);
				} else {
					^d(); d := nop;
				}
			});
			\ -> {
				applyall(unsArray);
				stallCursorVisible.second();
				uns();
				^d();
			}
		}
	)
}

resizeToWH(size : Behaviour<WidthHeight>, form : Form) -> Form {
	/*
	wh = make(getValue(size));

	scale = select2(size, wh, \_size, _wh -> {
		if ( _wh.width == 0.0 || _wh.height == 0.0 ) {
			1.0
		} else {
			scaleX = _size.width / _wh.width;
			scaleY = _size.height / _wh.height;
			min(scaleX, scaleY)

		}
	});

	Inspect([ISize(wh)], form)
	|> (\formi ->
		Scale(
			scale,
			scale,
			formi
		)
	)
	*/
	resizeToWH2(size, 1.0, form)
}

resizeToWH2(size : Behaviour<WidthHeight>, deltaAspect : double, form : Form) -> Form {
	wh = make(getValue(size));
	x = make(0.0);
	y = make(0.0);
	construct = \ -> {
		uns1 = connectSelect2u(size, wh, x, \_size, _wh -> {
			if (_wh.width == 0.0 || _wh.height == 0.0) {
				1.0
			} else {
				scaleX = _size.width / _wh.width;
				scaleY = _size.height / _wh.height;
				min(scaleX, deltaAspect * scaleY)
			}
		});
		uns2 = connectSelect2u(size, wh, y, \_size, _wh -> {
			if (_wh.width == 0.0 || _wh.height == 0.0) {
				1.0
			} else {
				scaleX = _size.width / _wh.width;
				scaleY = _size.height / _wh.height;
				min(scaleY, deltaAspect * scaleX)
			}
		});
		\ -> { uns1(); uns2() }
	}

	Constructor(
		Scale(x, y, Inspect([ISize(wh)], form)),
		construct
	)
}

resizeTo(width : double, height : double, form : Form) -> Form {
	wh = make(WidthHeight(width, height));
	x = make(0.0);
	y = make(0.0);

	Constructor(
		FixSize(width, height,
			Scale(
				x, y,
				Inspect([ISize(wh)], form)
			)
		),
		\ -> {
			subscribe(wh, \wh0 -> {
				next(x, if (wh0.width > 0.0 && width >= 0.0) width/wh0.width else 1.0);
				next(y, if (wh0.height > 0.0 && height >= 0.0) height/wh0.height else 1.0);
			})
		}
	)
}

resizeToFit(width : double, height : double, form : Form) -> Form {
	rwh = make(WidthHeight(width, height));
	scale = make(0.0);

	Constructor(
		Scale(
			scale,
			scale,
			Inspect([ISize(rwh)], form)
		),
		\ -> {
			subscribe(rwh, \wh -> {
				sc = if (wh.width * wh.height == 0.0) {
					1.0;
				} else {
					scaleX = if (wh.width > 0.0 && width >= 0.0) width / wh.width else 1.0;
					scaleY = if (wh.height > 0.0 && height >= 0.0) height / wh.height else 1.0;
					min(scaleX, scaleY)
				}
				next(scale, sc);
			})
		}
	)
}

resizeToFitSize(size : double, form : Form) -> Form {
	rwh = make(WidthHeight(size, size));
	scale = make(0.0);
	construct = \ -> connectSelectu(rwh, scale, \wh -> {
		if (wh.width * wh.height == 0.0) {
			1.0;
		} else {
			scaleX = if (wh.width > 0.0 && size >= 0.0) size / wh.width else 1.0;
			scaleY = if (wh.height > 0.0 && size >= 0.0) size / wh.height else 1.0;
			max(scaleX, scaleY)
		}
	});

	Constructor(
		Scale(scale, scale, Inspect([ISize(rwh)], form)),
		construct
	)
}

resizeToFitKeepAspect(width : double, height : double, form : Form) -> Form {
	rwh = make(WidthHeight(width, height));

	scale = make(0.0);
	transX = make(0.0);
	transY = make(0.0);

	construct = \ -> subscribe(rwh, \wh -> {
		w = wh.width;
		h = wh.height;
		if (w * h == 0.0) {
			nextDistinct(scale, 1.0);
			nextDistinct(transX, 0.0);
			nextDistinct(transY, 0.0);
		} else {
			scaleX = width / w;
			scaleY = height / h;
			maxScale = max(scaleX, scaleY);
			nextDistinct(scale, maxScale);
			nextDistinct(transX, ((maxScale - scaleX) * w) * -0.5);
			nextDistinct(transY, ((maxScale - scaleY) * h) * -0.5);
		}
	});

	Constructor(
		FixSize(width, height,
			Translate(transX, transY,
				Scale(scale, scale,
					Inspect([ISize(rwh)], form)
				)
			)
		),
		construct
	)
}

resizeToFitB(width : Behaviour<double>, height : Behaviour<double>, enabled : Behaviour<bool>, form : Form) -> Form {
	wh = make(WidthHeight(getValue(width), getValue(height)));
	construct = \ -> connectSelect2u(width, height, wh, \w, h -> WidthHeight(w, h));

	Constructor(
		resizeToFitWHB(wh, enabled, form),
		construct
	)
}

resizeToFitWHB(widthHeight : Behaviour<WidthHeight>, enabled : Behaviour<bool>, form : Form) -> Form {
	resizeToFitWHB2(widthHeight, enabled, form, 100000.0) //very big number
}

resizeToFitWHB2(widthHeight : Behaviour<WidthHeight>, enabled : Behaviour<bool>, form : Form, maxScale : double) -> Form {
	rwh = make(getValue(widthHeight));
	scale = make(0.0);
	construct = \ -> connectSelect3u(rwh, widthHeight, enabled, scale, \whr, wht, _enabled -> {
		if (whr.width == 0.0 || whr.height == 0.0 || !_enabled
			|| wht.width < 0.0 || wht.height < 0.0) {
			1.0;
		} else {
			scaleX = wht.width / whr.width;
			scaleY = wht.height / whr.height;
			min3(maxScale, scaleX, scaleY)
		}
	});

	Constructor(
		Scale(scale, scale, Inspect([ISize(rwh)], form)),
		construct
	)
}

resizeToWidth(width : double, form : Form) -> Form {
	wh = make(WidthHeight(width, 0.0));
	scale = make(0.0);
	scaleWH = makeWH();
	construct = \ -> {
		uns1 = connectSelectu(wh, scale, \v -> if (v.width > 0.0) width/v.width else 1.0);
		uns2 = connectSelectu(scale, scaleWH, \s -> WidthHeight(width, (getValue(wh)).height * s));
		\ -> { uns1(); uns2() }
	}

	Constructor(
		Size2(scaleWH, Scale(scale, scale, Inspect([ISize(wh)], form))),
		construct
	)
}

resizeToAvailableWidth(form : Form) -> Form {
	aw = make(0.0);
	w = make(0.0);
	scale = make(0.0);
	construct = \ -> connectSelect2u(w, aw, scale, \ws, aws -> if (ws > 0.0 && aws > 0.0) aws/ws else 1.0);

	Constructor(
		Inspect([AvailableWidth(aw)], Scale(scale, scale, Inspect([Width(w)], form))),
		construct
	)
}

resizeToAvailableHeight(form : Form) -> Form {
	ah = make(0.0);
	h = make(0.0);
	scale = make(0.0);
	construct = \ -> connectSelect2u(h, ah, scale, \hs, ahs -> if (hs > 0.0 && ahs >= 0.0) ahs/hs else 1.0);

	Constructor(
		Inspect([AvailableHeight(ah)], Scale(scale, scale, Inspect([Height(h)], form))),
		construct
	)
}

resizeToAvailableWidthHeight(form : Form) -> Form {
	awh = makeWH();
	wh = makeWH();
	scaleW = make(0.0);
	scaleH = make(0.0);
	construct = \ -> {
		uns1 = connectSelect2u(wh, awh, scaleW, \whs, aws -> if (whs.width > 0.0 && aws.width >= 0.0) aws.width/whs.width else 1.0);
		uns2 = connectSelect2u(wh, awh, scaleH, \whs, ahs -> if (whs.height > 0.0 && ahs.height >= 0.0) ahs.height/whs.height else 1.0);
		\ -> { uns1(); uns2() }
	}

	Constructor(
		Inspect([IAvailable2(awh)], Scale(scaleW, scaleH, Inspect([ISize(wh)], form))),
		construct
	)
}

resizeToUseWidthHeight(form : Form) -> Form {
	awh = makeWH();
	wh = makeWH();
	scale = make(0.0);
	construct = \ -> {
		connectSelect2u(awh, wh, scale, \awhs, whs -> {
			min(
				if (whs.width > 0.0 && awhs.width >= 0.0) awhs.width/whs.width else 1.0,
				if (whs.height > 0.0 && awhs.height >= 0.0) awhs.height/whs.height else 1.0
			)
		})
	}

	Constructor(
		Inspect([IAvailable2(awh)], Scale(scale, scale, Inspect([ISize(wh)], form))),
		construct
	)
}

resizeAndCropToUseWidthHeight(form : Form) -> Form {
	awh = makeWH();
	wh = makeWH();
	scale = make(0.0);
	aw = make(0.0);
	ah = make(0.0);
	construct = \ -> {
		uns1 = connectSelect2u(awh, wh, scale, \awhs, whs -> {
			max(
				if (whs.width > 0.0 && awhs.width >= 0.0) awhs.width/whs.width else 1.0,
				if (whs.height > 0.0 && awhs.height >= 0.0) awhs.height/whs.height else 1.0
			)
		});
		uns2 = connectSelectu(awh, aw, \awhs -> awhs.width);
		uns3 = connectSelectu(awh, ah, \awhs -> awhs.height);
		\ -> { uns1(); uns2(); uns3() }
	}

	Constructor(
		Crop(zero, zero, aw, ah, Inspect([IAvailable2(awh)], Scale(scale, scale, Inspect([ISize(wh)], form)))),
		construct
	)
}

resizeAndCropToUseMinWidthHeight(form : Form) -> Form {
	awh = makeWH();
	wh = makeWH();
	scale = make(0.0);
	aw = make(0.0);
	ah = make(0.0);
	construct = \ -> {
		uns1 = connectSelect2u(awh, wh, scale, \awhs, whs -> {
			min(
				if (whs.width > 0.0 && awhs.width >= 0.0) awhs.width/whs.width else 1.0,
				if (whs.height > 0.0 && awhs.height >= 0.0) awhs.height/whs.height else 1.0
			)
		});
		uns2 = connectSelectu(awh, aw, \awhs -> awhs.width);
		uns3 = connectSelectu(awh, ah, \awhs -> awhs.height);
		\ -> { uns1(); uns2(); uns3() }
	}

	Constructor(
		Crop(zero, zero, aw, ah, Inspect([IAvailable2(awh)], Scale(scale, scale, Inspect([ISize(wh)], form)))),
		construct
	)
}

resizeToUseWidthHeight2(form : Form) -> Form {
	awh = makeWH();
	wh = makeWH();
	scale = make(0.0);
	construct = \ -> connectSelect2u(awh, wh, scale, \awhs, whs -> {
		min(
			if (whs.width > 0.0 && awhs.width > 0.0) awhs.width/whs.width else 1.0,
			if (whs.height > 0.0 && awhs.height > 0.0) awhs.height/whs.height else 1.0
		)
	});

	Constructor(
		Inspect([IAvailable2(awh)], Scale(scale, scale, Inspect([ISize(wh)], form))),
		construct
	)
}


resizeToHeight(height : double, form : Form) -> Form {
	wh = make(WidthHeight(0.0, height));
	scale = make(0.0);
	scaleWH = makeWH();
	construct = \ -> {
		uns1 = connectSelectu(wh, scale, \hs -> if (hs.height > 0.0) height/hs.height else 1.0);
		uns2 = connectSelectu(scale, scaleWH, \s -> WidthHeight((getValue(wh)).width * s, height));
		\ -> { uns1(); uns2() }
	}

	Constructor(
		Size2(
			scaleWH,
			Scale(scale, scale, Inspect([ISize(wh)], form))
		),
		construct
	)
}

shrinkToFit(width : double, height : double, form : Form) -> Form {
	shrinkToFitB(const(WidthHeight(width, height)), form)
}

shrinkToFitAvailableWH(form) {
	awhb = makeWH();
	shrinkToFitB(awhb, Inspect([IAvailable(awhb)], form))
}

shrinkToFitB(widthHeight : Behaviour<WidthHeight>, form : Form) -> Form {
	shrinkToFitB2(widthHeight, form, const(true), isUrlParameterTrue("new"))
}

shrinkToFitB2(widthHeight : Behaviour<WidthHeight>, form : Form, enabled : Behaviour<bool>, isNew : bool) -> Form {
	rwh = make(getValue(widthHeight));
	size = makeWH();
	scale = make(0.0);
	stalledSize = if(isNew) stallu(size, 0) else Pair(size, nop);
	stalledScale = if(isNew) stallu(scale, 0) else Pair(scale, nop);

	Constructor(
		Inspect([ISize(rwh)], form)
		|> (\formi -> Size2(
			stalledSize.first,
			Scale(stalledScale.first, stalledScale.first, formi)
		)),
		\ -> {
			uns1 = connectSelectu(scale, size, \s -> WidthHeight(
				roundTo((getValue(rwh)).width * s, 0.01), roundTo((getValue(rwh)).height * s, 0.01))
			);
			uns2 = connectSelect3u(rwh, widthHeight, enabled, scale, \whr, wht, e -> {
				if ( (whr.width * whr.height == 0.0) || (wht.width * wht.height == 0.0) || (whr.width <= wht.width && whr.height <= wht.height) || !e) {
					1.0
				} else {
					scaleX = wht.width / whr.width;
					scaleY = wht.height / whr.height;
					min(scaleX, scaleY)
				}
			});
			\ -> {
				uns1();
				uns2();
				stalledSize.second();
				stalledScale.second();
			}
		}
	)
}

shrinkToAvailableWidth(form : Form) -> Form { // [-REQUEST-] What is the difference between this one and resizeToAvailableWidth?
	aw = make(0.0);
	w = make(0.0);
	scale = make(0.0);

	Constructor(
		Inspect([Width(w)], form)
		|> (\formi -> Scale(scale, scale, formi))
		|> (\formi -> Inspect([AvailableWidth(aw)], formi)),
		\ -> {
			connectSelect2u(w, aw, scale, \ws, aws -> if (ws > aws) aws/ws else 1.0);
		}
	)
}

shrinkToFitWidth(width: Behaviour<double>, form: Form) -> Form {
	widthHeight = makeWH();

	Constructor(
		shrinkToFitB(widthHeight, form),
		\ -> {
			//[-Revise-] Give infinite height, basically
			subscribe(width, \w -> next(widthHeight, WidthHeight(w, 10000.0)))
		}
	)
}

enlargeToFitAvailable(form: Form, maxScale: double) -> Form {
	av = makeWH();
	enlargeToFitB2(av, Inspect([IAvailable(av)], form), const(true), maxScale)
}

enlargeToFitB(widthHeight : Behaviour<WidthHeight>, form : Form) -> Form {
	enlargeToFitB2(widthHeight, form, const(true), 1000.0)
}

enlargeToFitB2(widthHeight : Behaviour<WidthHeight>, form : Form, enabled : Behaviour<bool>, maxScale : double) -> Form {
	rwh = make(getValue(widthHeight));
	scale = make(0.0);
	size = makeWH();

	Constructor(
		Inspect([ISize(rwh)], form)
		|> (\formi -> Size2(
			size,
			Scale(scale, scale, formi)
		)),
		\ -> {
			uns1 = subscribe(scale, \s -> {
				next(size, WidthHeight((getValue(rwh)).width * s, (getValue(rwh)).height * s));
			});
			uns2 = connectSelect3u(rwh, widthHeight, enabled, scale, \whr, wht, e -> {
				if ((whr.width * whr.height == 0.0) || (whr.width >= wht.width || whr.height >= wht.height) || !e) {
					1.0
				} else {
					scaleX = wht.width / whr.width;
					scaleY = wht.height / whr.height;
					min3(scaleX, scaleY, maxScale)
				}
			});
			\ -> {
				uns1();
				uns2();
			}
		}
	)
}

makeEmpty() make(Empty());

// When f becomes Empty() calls contFn. Does not trigger at start.
waitForEmpty(f : DynamicBehaviour<Form>, contFn : () -> void) -> Form {
	uns = ref nop;
	uns := subscribe2(f, \ff -> if (ff == Empty()) {^uns();contFn();});
	Mutable(f);
}

smallScreen = make(0);

parseShortcut(shortcut : string) -> KeyEvent {
	utf = ref "";
	alt = ref false;
	ctrl = ref false;
	shift = ref false;
	meta = ref false;

	if (strlen(shortcut) > 1) {
		// For shift++ and similar to work, we just grab the last char
		utf := strsubsmart(shortcut, -1, 0);
		iter( strSplit(toLowerCase(shortcut), "+"), \key -> {
			if (key == "ctrl") { ctrl := true; }
			else if (key == "alt") { alt := true; }
			else if (key == "shift") { shift := true;}
			else if (key == "win") { meta := true;}
			else if (key == "cmd") { meta := true;}
			else {
				if (key != "") utf := key; // To get something like shift++ to work
			}
		} );
	} else utf := shortcut; // To be able to parse a + by itself

	KeyEvent(^utf, ^ctrl, ^shift, ^alt, ^meta, 0, nop);
}


matchShortcut(event : KeyEvent, shortcut : KeyEvent) -> bool {
	(event.utf != "")
	&& (shortcut.utf != "")
	&& (toLowerCase(event.utf) == toLowerCase(shortcut.utf))
	&& (event.ctrl == shortcut.ctrl)
	&& (event.alt == shortcut.alt)
	&& (event.shift == shortcut.shift)
	&& (event.meta == shortcut.meta)
}

matchShortcutKeyCode(event : KeyEvent, shortcut : KeyEvent) -> bool {
	asciiChar = toAscii(shortcut.utf);
	// KeyEvent keycode is always match the upper case letter
	shortcutKeyCode = if (strlen(asciiChar) == 1) s2a(toUpperCase(asciiChar))[0] else 0;

	(event.keycode != 0)
	&& (shortcutKeyCode != 0)
	&& (event.keycode == shortcutKeyCode)
	&& (event.ctrl == shortcut.ctrl)
	&& (event.alt == shortcut.alt)
	&& (event.shift == shortcut.shift)
	&& (event.meta == shortcut.meta)
}

// Remembers the biggest size this form ever had. Useful when inserting vector graphics in paragraphs
// where you want the size to be "cached".
MaxSize(form) {
	size = getDynamicFormSize(form);

	maxSize = ref getValue(size.second);
	sizeB = make(FormMetrics(0.0, 0.0, 0.0, 0.0));

	Constructor(
		Group([
			// Block to set baseline, and the maximum size.
			Select(
				sizeB,
				\mwhb -> Border(0.0, max(mwhb.baseline, 0.0), mwhb.width, max(mwhb.height - mwhb.baseline, 0.0), Empty())
			),
			// We fix the size of this guy
			FixSize(0.0, 0.0, size.first)
		]),
		\ -> {
			subscribe(size.second, \sz -> {
				maxSize := FormMetrics(
					max(sz.width, ^maxSize.width),
					max(sz.height, ^maxSize.height),
					max(sz.baseline, ^maxSize.baseline),
					0.0
				);
				next(sizeB, ^maxSize);
			})
		}
	)
}

// Unfortunately this is necessary with new Paragraph also.
NonZeroSize(form) {
	NonZeroSize2(form, const(true))
}

NonZeroSize2(form, enabled) {
	unpair(getDynamicFormSize(form), \formM, metrics -> {
		initialMetrics = getValue(metrics);
		effectiveSize = make(WidthHeight(initialMetrics.width, initialMetrics.height));
		effectiveBaseline = make(initialMetrics.baseline);
		Constructor(
			Baseline(effectiveBaseline, Size2(effectiveSize, formM)),
			\ -> {
				select2u(metrics, enabled, \sz, e -> {
					if (!e || sz.width > 0.0 && sz.height > 0.0 && sz.baseline != 0.0) { //Zero baseline might be correct, but we likely do not have such a Forms in our code
						next(effectiveSize, WidthHeight(sz.width, sz.height));
						next(effectiveBaseline, sz.baseline);
					}
				}).second
			}
		)
	})
}


ThrottleSize(form) {
	ThrottleSize2(form, 500)
}

ThrottleSize2(form, maxDelta) {
	wh = makeWH();
	whToUse = makeWH();
	Constructor(
		Size2(
			whToUse,
			Inspect(
				[ISize(wh)],
				form
			)
		),
		\ -> {
			throttledWHPair = throttle2u(wh, maxDelta);
			uns = connect(throttledWHPair.first, whToUse);
			\ -> {
				uns();
				throttledWHPair.second();
			}
		}
	)
}

MinAvailableWidth(width : double, form : Form) -> Form {
	OverrideAvailable(\wh -> WidthHeight(max(width, wh.width), wh.height), form)
}

MinAvailableHeight(height : double, form : Form) -> Form {
	OverrideAvailable(\wh -> WidthHeight(wh.width, max(height, wh.height)), form)
}

OverrideAvailable(fn : (WidthHeight) -> WidthHeight, form : Form) -> Form {
	OverrideAvailable2(\wh, __ -> fn(wh), const([]), form)
}

OverrideAvailable2(fn : (WidthHeight, [double]) -> WidthHeight, trigger : Behaviour<[double]>, form : Form) -> Form {
	awh = makeWH();
	whB = makeWH();
	Constructor(
		Inspect([IAvailable2(awh)], Available2(whB, form)),
		\ -> {
			connectSelect2u(awh, trigger, whB, fn);
		}
	)
}

OverrideSize2(fn : (WidthHeight) -> WidthHeight, enabled : Behaviour<bool>, form : Form) -> Form {
	size = makeWH();
	whB = makeWH();

	Constructor(
		Size2(
			whB,
			Inspect([ISize(size)], form)
		),
		\ -> {
			connectSelect2u(size, enabled, whB, \wh, e -> if (e) fn(wh) else wh);
		}
	)
}

InfiniteWidth(form)  {
	Available2(InfiniteWidthAWH, form)
}

InfiniteWidthInsteadZero(form)  {
	form
}

ZeroSizeOnZeroAvailable(form) {
	awh2 = makeWH();
	wh = makeWH();
	size = makeWH();
	Constructor(
		Inspect(
			[IAvailable2(awh2)],
			Size2(
				size,
				Inspect([ISize(wh)], form)
			)
		),
		\ -> {
			connectSelect2u(awh2, wh, size, \wh1, wh2 -> {
				if (wh1.width != 0.0) wh2 else zeroWH
			});
		}
	)
}

FixEmptyFormSize(f : Form) -> Form {
	ep = isEmptyFormB(f);
	OverrideSize2(\__ -> zeroWH, ep.second, ep.first)
}

DecorateNonEmptyForm(decorate, stub, form) {
	ep = isEmptyFormB(form);
	Switchb(
		ep.second,
		[
			ep.first |> decorate,
			Group([
				Size2(zeroSize, ep.first),
				either(stub, Empty())
			])
		]
	)
}

FixWidth(w : Behaviour<double>, f : Form) {
	height = make(0.0);
	whB = makeWH();

	Constructor(
		Size2(whB, Inspect([Height(height)], f)),
		\ -> {
			connectSelect2u(w, height, whB, \w2, h -> WidthHeight(w2, h));
		}
	)
}

FixHeight(h : Behaviour<double>, f : Form) {
	width = make(0.0);
	whB = makeWH();

	Constructor(
		Size2(whB, Inspect([Width(width)], f)),
		\ -> {
			connectSelect2u(width, h, whB, \w, h2 -> WidthHeight(w, h2));
		}
	)
}

Debug(text : string, form : Form) -> Form {
	wh = makeWH();
	awh = makeWH();
	metrics = make(FormMetrics(0., 0., 0., 0.));
	baselineB = make(0.0);

	Constructor(
		fixBaselineB(
			baselineB,
			Group([
				Select(wh, \wh0 -> Rectangle(wh0.width, wh0.height, [Fill(green), FillOpacity(0.3)])),
				Inspect([ISize(wh), IAvailable2(awh)], form),
			])
		),
		\ -> {
			println(text + " construct");
			u1 = subscribe(wh, \wh2 -> { println("  " + text + " size: " + d2s(wh2.width) + "x" + d2s(wh2.height)); });
			u2 = subscribe(awh, \wh2 -> { println("  " + text + " available: " + d2s(wh2.width) + "x" + d2s(wh2.height)); });
			u3 = connectSelectDistinctu(metrics, baselineB, \m -> m.baseline);
			\ -> { println(text + " destroy"); u1(); u2(); u3(); }
		}
	);
}

DebugColor(form : Form, color : int) -> Form {
	wh = makeWH();
	metrics = make(FormMetrics(0., 0., 0., 0.));
	baselineB = make(0.0);

	Constructor(
		fixBaselineB(
			baselineB,
			Group([
				Inspect([ISize(wh), IMetrics(metrics)], form),
				Select(wh, \wh0 -> Rectangle(wh0.width, wh0.height, [Fill(color), FillOpacity(0.3)])),
				Select(metrics, \met ->
					Graphics([MoveTo(0.0, met.baseline), LineTo(met.width, met.baseline)], [Stroke(black), StrokeWidth(1.0), StrokeOpacity(0.7)])
				)
			])
		),
		\-> connectSelectDistinctu(metrics, baselineB, \m -> m.baseline)
	)
}

DebugBaseline(form : Form) -> Form {
	metrics = make(FormMetrics(0., 0., 0., 0.));
	baselineB = make(0.0);

	Constructor(
		fixBaselineB(
			baselineB,
			Group([
				Inspect([IMetrics(metrics)], form),
				Select(metrics, \met ->
					Graphics([MoveTo(0.0, met.baseline), LineTo(met.width, met.baseline)], [Stroke(black), StrokeWidth(1.0), StrokeOpacity(0.7)])
				)
			])
		),
		\ -> connectSelectDistinctu(metrics, baselineB, \m -> m.baseline)
	)
}

// Explicitly prevent Mouse{Up/Down}2 from falling further. Best used as form |> MouseUD2Catcher.
// To debug, uncomment something you want.
MouseUD2Catcher(f : Form) -> Form {
	Group([
		Interactive(
			// handlers
			[
				MouseDown(\e -> true),
				MouseMove(\e -> true),
				MouseUp(\e -> true),
			],
			// placeholder
			HVFill([
				Fill(0xFFFF00), FillOpacity(0.0) // debug â shock me YEEEEELLOWWWW when needed
			])
		),
		f
	])
}

ClickableFixed(width : double, height : double) -> Form {
	BackgroundWH(width, height, [Fill(0xffffff), FillOpacity(0.0)])
}

ClickableFixed2(width : double, height : double) -> Form {
	Rectangle(width, height, [Fill(0xffffff), FillOpacity(0.0)])
}

CreepingLine (width : double, form : Form, step : double, timeInterval : int, force : bool) -> Form {
	formWidth = getFormWidth(form);
	if (formWidth > width || force) {
		currentOffset = ref 0.0;
		height = getFormHeight(form);
		timesInWidth = ( width + step ) / getFormWidth(form);
		masterForm = Cols(
			generate(0, max(2, ceil(timesInWidth) + 1), \i -> form)
		);
		creepingDeamon = make(false); // false for first call
		outputForm = make(Empty());
		uns = subscribe(creepingDeamon, \flag -> {
			currentOffset := if (flag) dmod(^currentOffset + step, formWidth) else 0.0;
			next(outputForm, Crop(const(^currentOffset), const(0.0), const(width), const(height), masterForm));
			timer(timeInterval, \-> next(creepingDeamon, true));
		});
		Constructor(
			Mutable(outputForm),
			\ -> uns
		);
	} else {
		form
	}
}


GroupWithSizeFixed(w, h, forms) {
	sz = const(WidthHeight(w, h));
	Size2(sz, Available2(sz, Group(forms)))
}

//[-Review-] Search for usage of this leaked version and remove/update them
getWidth(wh : Behaviour<WidthHeight>) -> Behaviour<double> {
	select(wh, \wh0 -> wh0.width)
}

getHeight(wh : Behaviour<WidthHeight>) -> Behaviour<double> {
	select(wh, \wh0 -> wh0.height)
}

mapWidth(wh : Behaviour<WidthHeight>, fn : (double) -> ?) -> Behaviour<?> {
	select(wh, \wh0 -> fn(wh0.width))
}

mapHeight(wh : Behaviour<WidthHeight>, fn : (double) -> ?) -> Behaviour<?> {
	select(wh, \wh0 -> fn(wh0.height))
}

makePoint() -> DynamicBehaviour<Point> {
	make(zeroPoint)
}

waitForFilesLoadedEx(onLoaded) {
	// subscribe(loadingContentFilesCount, ...) crashes simtester for some unclear reason.
	filesCount = getValue(loadingContentFilesCount);
	// println("Files count = " + i2s(filesCount));

	if (filesCount  <= 0) {
		//println("Loaded files ready");
		if (filesCount < 0) {
			println("Bad case in waitForFilesLoadedEx. Debug it!!!");
			next(loadingContentFilesCount, 0);
		}
		deferUntilRender(onLoaded)
	} else {
		//println("Wait one more second");
		timer(1000, \ -> {
			//println("After waiting a tenth of second");
			waitForFilesLoadedEx(onLoaded)
		})
	}
}

waitForFilesLoaded(timeout, onLoaded) {
	stopTimeoutTimer = ref nop;
	once = ref false;

	onFilesReady = \onTimeout -> {
		if (!^once) {
			once := true;
			^stopTimeoutTimer();
			stopTimeoutTimer := nop;
			onLoaded(onTimeout)
		}
	}

	stopTimeoutTimer := interruptibleTimer(timeout * 1000, \ -> {
		println("waitForFilesLoaded. Timeout");
		onFilesReady(true);
		nextDistinct(loadingContentFilesCount, 0);
	});

	deferUntilRender(\ -> waitForFilesLoadedEx(\ -> onFilesReady(false)))
}

MoveCenter2ZeroPoint(form) {
	whb = makeWH();
	x = make(0.0);
	y = make(0.0);

	Constructor(
		Translate(
			x, y,
			Inspect([ISize(whb)], form)
		),
		\ -> {
			subscribe(whb, \wh -> {
				next(x, -wh.width / 2.0);
				next(y, -wh.height / 2.0);
			});
		}
	)
}

WhileLoading2(f : Form, loadingForm : Form, onDone : () -> void) -> Form {
	alpha = make(0.0);
	timer(700, \ -> next(alpha, 1.0)); //
	filesLoading = make(true);
	Group([
		OverrideSize2(
			\__ -> zeroWH,
			filesLoading,
			ShowWhenReady2(f, 50, 15, \ -> {
				nextDistinct(filesLoading, false);
				onDone()
			})
		),
		Visibleb(
			filesLoading,
			Alpha(alpha, loadingForm)
		)
	])
}

maskImage(form : Form, color : int) -> Form {
	maskImageWithOpacity(form, Color(color, 1.0))
}

maskImageWithOpacity(form : Form, color : Color) -> Form {
	imageSize = makeWH();
	Group([
		Mask(
			Select(imageSize, \iS -> Rectangle(iS.width, iS.height, [Fill(color.color), FillOpacity(color.alpha)])),
			Inspect([ISize(imageSize)], form)
		),
	])
}

oneLineEllipsis(text : string, style : [CharacterStyle], width : double) {
	t = if (getTextSize(text, style).width <= width) {
		text
	} else {
		mark = countUntil(1, strlen(text), \i -> getTextSize(rtrim(strLeft(text, i)) + "...", style).width > width) - 1;
		rtrim(substring(text, 0, mark)) + "..."
	}
	Text(t, style)
}

addTransformMatrixInspector(form : Form) -> FormInspector {
	inspector = ref getDummyTransformMatrix;
	inspectedForm = Disposer(
		Inspect([ITransformMatrix(\getTM -> inspector := getTM)], form),
		\ -> inspector := getDummyTransformMatrix
	);
	FormInspector(inspectedForm, \ -> ^inspector())
}

DynamicGroupSkipUpdate(
	combiner : DynamicGroupCombiner,
	init : [Form],
	update : DynamicBehaviour<[GroupChange]>,
	skipUpdate : Behaviour<bool>) -> Form {

	updateFixed : DynamicBehaviour<[GroupChange]> =
		make( mapi(init, \i, el -> GroupAdd(el, i)) );

	Constructor(
		DynamicGroup(updateFixed, combiner),
		\ -> {
			unupdate = subscribe(update, \changes ->
				if (!getValue(skipUpdate)) {
					iter(changes, \change ->
						dynArrayPush(updateFixed, change)
					);
					next(update, []);
				}
			);
			unskip = subscribe(skipUpdate, \skip ->
				if (!skip) {
					iter(getValue(update), \change ->
						dynArrayPush(updateFixed, change)
					);
					next(update, []);
				}
			);
			\ -> {
				unupdate();
				unskip();
			}
		}
	);
}
