import text/gringo/gringo_action;
import text/gringo/dcode_lib;
import ds/tree;

/*
This provides a facility to do typed semantic actions for expression-like types.
In the grammar, you can use these actions:

	s2i		Convert a string to a typed int
	s2d		Convert a string to a typed double
	true	Make the constant "true"
	false	Make the constant "false"
	list	Construct an empty list or array
	cons	Append an element to a list or array

In addition, send in trees of unary and binary operators.

TODO:
- Add ternary operators as well
- Add "swap" and other common stack operations
- Add "hex" parsing
- Add string escaping
*/
export {
	// This is a helper to construct a typed action helper for gringoTypedParse
	gringoTypedAction(
		// Make a string
		makeString : (string) -> ?, 
		// Extract a string from a value (typically a string)
		getString : (?) -> string,
		// Construct a bool
		mkBool : (bool) -> ?, 
		// Convert string to an int
		toInt : (string) -> ?, 
		// Convert string to a double
		toDouble : (string) -> ?, 
		// Make an empty list/array
		mklist : () -> ?, 
		// Append the second element to the first list/array
		push : (?, ?) -> ?,
		// A tree of unary operators
		unops : Tree<string, (?) -> ?>,
		// Binary operators
		binops : Tree<string, (?, ?) -> ?>,
	) -> GringoAction<List<?>>;

	// This does a parse of this text with typed result values of type ?. 
	// If the parse fails, the default value is returned
	gringoTypedParse(
		// The text to parse
		text : string, 
		// The actions - make this with gringoTypedAction
		action : GringoAction<List<?>>, 
		// The generated parser function from Gringo
		parser : (DParseAcc) -> bool, 
		// A default value in case parsing fail
		defaultVal : ?
	) -> ?;
}

gringoTypedAction(
		// Make a string
		makeString : (string) -> ?, 
		// Extract a string from a value (typically a string)
		getString : (?) -> string,
		// Construct a bool
		mkBool : (bool) -> ?, 
		// Convert string to an int
		toInt : (string) -> ?, 
		// Convert string to a double
		toDouble : (string) -> ?, 
		// Make an empty list/array
		mklist : () -> ?, 
		// Append the second element to the first list/array
		push : (?, ?) -> ?,
		// A tree of unary operators
		unops : Tree<string, (?) -> ?>,
		// Binary operators
		binops : Tree<string, (?, ?) -> ?>,
	) -> GringoAction<List<?>> {
	GringoAction(
		\stack : List<?>, command : string -> {
			pop = \s, fn : (h : ?, t : List<?>) -> List<?> -> {
				switch (s) {
					EmptyList(): {
						println("Expected something on stack");
						s;
					}
					Cons(h, t): fn(h, t);
				}
			}
			if (command == "true") {
				Cons(mkBool(true), stack)
			} else if (command == "false") {
				Cons(mkBool(false), stack)
			} else if (command == "s2i") {
				pop(stack, \h, t-> Cons(toInt(getString(h)), t));
			} else if (command == "s2d") {
				pop(stack, \h, t-> Cons(toDouble(getString(h)), t));
			} else if (command == "list") {
				Cons(mklist(), stack)
			} else if (command == "cons") {
				pop(stack, \h1, t1 -> {
					pop(t1, \h2, t2 -> {
						nv = push(h1, h2);
						Cons(nv, t2)
					})
				});
			// TODO: We can add hex parsing, swap, rot and other stack manipulation
			} else {
				munop = lookupTree(unops, command);
				munop ?? {
					pop(stack, \h, t -> {
						val = munop(h);
						Cons(val, t)
					});
				} : {
					mbinop = lookupTree(binops, command);
					switch (mbinop) {
						None(): {
							println("Command " + command);
							stack;
						}
						Some(binop): {
							pop(stack, \h2, t1 -> {
								pop(t1, \h1, t2 -> {
									val = binop(h1, h2);
									Cons(val, t2);
								})
							})
						}
					}
				
				}
			}
		},
		\stack : List<?>, token : string -> {
			Cons(makeString(token), stack)
		}
	);
}

gringoTypedParse(text : string, action : GringoAction<List<?>>, parser : (DParseAcc) -> bool, defaultVal : ?) -> ? {
	pacc : DParseAcc<List<?>> = DParseAcc(text, 
		action,
		0,
		makeList(),
		makeTree(),
		makeList(),
		0
	);
	success = parser(pacc);
	// TODO: We could report errors here
	headList(pacc.output, defaultVal);
}
