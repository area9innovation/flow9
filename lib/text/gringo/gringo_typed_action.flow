import text/gringo/gringo_action;
import text/gringo/dcode_lib;
import lingo/linecolumn;
import ds/tree;

/*
This provides a facility to do typed semantic actions for expression-like types.
In the grammar, you can use these actions:

	s2i		Convert a string to a typed int
	s2d		Convert a string to a typed double
	true	Make the constant "true"
	false	Make the constant "false"
	list	Construct an empty list or array
	cons	Append an element to a list or array

In addition, send in trees of unary and binary operators.

TODO:
- Add ternary operators as well
- Add "swap" and other common stack operations

Typical needs:
- "hex" parsing: Unary that calls parseHex
- string escaping: Unary that calls deserializeString(t).first with quotes preserved
*/
export {
	// This is a helper to construct a typed action helper for gringoTypedParse
	gringoTypedAction(
		// Make a string
		makeString : (string) -> ?, 
		// Extract a string from a value (typically a string)
		getString : (?) -> string,
		// Construct a bool
		mkBool : (bool) -> ?, 
		// Convert string to an int
		toInt : (string) -> ?, 
		// Convert string to a double
		toDouble : (string) -> ?, 
		// Make an empty list/array
		mklist : () -> ?, 
		// Append the second element to the first list/array
		push : (?, ?) -> ?,
		// A tree of unary operators
		unops : Tree<string, (?) -> ?>,
		// Binary operators
		binops : Tree<string, (?, ?) -> ?>,
		// Ternary operators
		ternops : Tree<string, (?, ?, ?) -> ?>,
	) -> GringoAction<List<?>>;

	// This does a parse of this text with typed result values of type ?. 
	// If the parse fails, the default value is returned
	gringoTypedParse(
		// The text to parse
		text : string, 
		// The actions - make this with gringoTypedAction
		action : GringoAction<List<?>>, 
		// The generated parser function from Gringo
		parser : (DParseAcc) -> bool, 
		// A default value in case parsing fail
		defaultVal : ?,
		// For parse errors
		onError : (string) -> void,
	) -> ?;
}

gringoTypedAction(
		makeString : (string) -> ?, 
		getString : (?) -> string,
		mkBool : (bool) -> ?, 
		toInt : (string) -> ?, 
		toDouble : (string) -> ?, 
		mklist : () -> ?, 
		push : (?, ?) -> ?,
		unops : Tree<string, (?) -> ?>,
		binops : Tree<string, (?, ?) -> ?>,
		ternops : Tree<string, (?, ?, ?) -> ?>,
	) -> GringoAction<List<?>> {
	GringoAction(
		\stack : List<?>, command : string -> {
			pop = \s, fn : (h : ?, t : List<?>) -> List<?> -> {
				switch (s) {
					EmptyList(): {
						println("Expected something on stack");
						s;
					}
					Cons(h, t): fn(h, t);
				}
			}
			if (command == "true") {
				Cons(mkBool(true), stack)
			} else if (command == "false") {
				Cons(mkBool(false), stack)
			} else if (command == "s2i") {
				pop(stack, \h, t-> Cons(toInt(getString(h)), t));
			} else if (command == "s2d") {
				pop(stack, \h, t-> Cons(toDouble(getString(h)), t));
			} else if (command == "list") {
				Cons(mklist(), stack)
			} else if (command == "cons") {
				pop(stack, \h1, t1 -> {
					pop(t1, \h2, t2 -> {
						nv = push(h1, h2);
						Cons(nv, t2)
					})
				});
			// TODO: We can add swap, rot and other stack manipulation
			} else {
				munop = lookupTree(unops, command);
				munop ?? {
					pop(stack, \h, t -> {
						val = munop(h);
						Cons(val, t)
					});
				} : {
					mbinop = lookupTree(binops, command);
					switch (mbinop) {
						None(): {
							mternop = lookupTree(ternops, command);
							switch (mternop) {
								None(): {
									println("Unknown Command " + command);
									stack;
								}
								Some(ternop): {
									pop(stack, \h2, t1 -> {
										pop(t1, \h1, t2 -> {
											pop(t2, \h0, t3 -> {
												val = ternop(h0, h1, h2);
												Cons(val, t3);
											})
										})
									})
								}
							}
						}
						Some(binop): {
							pop(stack, \h2, t1 -> {
								pop(t1, \h1, t2 -> {
									val = binop(h1, h2);
									Cons(val, t2);
								})
							})
						}
					}
				
				}
			}
		},
		\stack : List<?>, token : string -> {
			Cons(makeString(token), stack)
		}
	);
}

gringoTypedParse(
		text : string, action : GringoAction<List<?>>, parser : (DParseAcc) -> bool, defaultVal : ?,
		onError : (string) -> void,
	) -> ? {
	pacc : DParseAcc<List<?>> = DParseAcc(text, 
		action,
		0,
		makeList(),
		makeTree(),
		makeList(),
		0
	);
	success = parser(pacc);

	// We report errors here
	traverseInOrder(pacc.errors, \pos, error -> {
		resolver = makeLineResolver(text);
		linecol = findLine(resolver, pos);
		onError(
			i2s(linecol.lineno) + ":" + i2s(linecol.column) + ": " + error
			+ "\n" + linecol.line
			+ "\n" + lpad("^", " ", linecol.lineIndex - 1)
		);
	});

	if (pacc.i < strlen(text) || !success) {
		resolver = makeLineResolver(text);
		linecol = findLine(resolver, pacc.i); // maxi
		onError(
			i2s(linecol.lineno) + ":" + i2s(linecol.column) + ": Parsing ended here"
			+ "\n" + linecol.line
			+ "\n" + lpad("^", " ", linecol.lineIndex - 1)
		);
	}
	switch (pacc.output) {
		EmptyList(): {
			onError("Failing back to default value");
			defaultVal;
		}
		Cons(h, t): {
			if (!isEmptyList(t)) {
				onError("More than one result on stack");
				iterList(t, println);
			}
			h;
		}
	}
}
