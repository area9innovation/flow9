import text/gringo/gringo_action;
import ds/tree;

export {
	// This is a helper to construct a typed action helpers
	gringoTypedAction(
		// Make a string
		makeString : (string) -> ?, 
		// Extract a string from a value (typically a string)
		getString : (?) -> string,
		// Construct a bool
		mkBool : (bool) -> ?, 
		// Convert string to an int
		toInt : (string) -> ?, 
		// Convert string to a double
		toDouble : (string) -> ?, 
		// Make an empty list/array
		mklist : () -> ?, 
		// Append the second element to the first list/array
		push : (?, ?) -> ?,
		// A tree of unary operators
		unops : Tree<string, (?) -> ?>,
		// Binary operators
		binops : Tree<string, (?, ?) -> ?>,
	) -> GringoAction<List<?>>;
}

gringoTypedAction(
		// Make a string
		makeString : (string) -> ?, 
		// Extract a string from a value (typically a string)
		getString : (?) -> string,
		// Construct a bool
		mkBool : (bool) -> ?, 
		// Convert string to an int
		toInt : (string) -> ?, 
		// Convert string to a double
		toDouble : (string) -> ?, 
		// Make an empty list/array
		mklist : () -> ?, 
		// Append the second element to the first list/array
		push : (?, ?) -> ?,
		// A tree of unary operators
		unops : Tree<string, (?) -> ?>,
		// Binary operators
		binops : Tree<string, (?, ?) -> ?>,
	) -> GringoAction<List<?>> {
	GringoAction(
		\stack : List<?>, command : string -> {
			pop = \s, fn : (h : ?, t : List<?>) -> List<?> -> {
				switch (s) {
					EmptyList(): {
						println("Expected something on stack");
						s;
					}
					Cons(h, t): fn(h, t);
				}
			}
			if (command == "true") {
				Cons(mkBool(true), stack)
			} else if (command == "false") {
				Cons(mkBool(false), stack)
			} else if (command == "s2i") {
				pop(stack, \h, t-> Cons(toInt(getString(h)), t));
			} else if (command == "s2d") {
				pop(stack, \h, t-> Cons(toDouble(getString(h)), t));
			} else if (command == "list") {
				Cons(mklist(), stack)
			} else if (command == "cons") {
				pop(stack, \h1, t1 -> {
					pop(t1, \h2, t2 -> {
						nv = push(h1, h2);
						Cons(nv, t2)
					})
				});
			} else {
				munop = lookupTree(unops, command);
				munop ?? {
					pop(stack, \h, t -> {
						val = munop(h);
						Cons(val, t)
					});
				} : {
					mbinop = lookupTree(binops, command);
					switch (mbinop) {
						None(): {
							println("Command " + command);
							stack;
						}
						Some(binop): {
							pop(stack, \h2, t1 -> {
								pop(t1, \h1, t2 -> {
									val = binop(h1, h2);
									Cons(val, t2);
								})
							})
						}
					}
				
				}
			}
		},
		\stack : List<?>, token : string -> {
			Cons(makeString(token), stack)
		}
	);
}
