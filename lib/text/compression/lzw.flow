import string;
import ds/list;
import ds/inttree;
import text/blueprint;
import math/bits;
import loop;

export {
/*
see lib/text/compression/test_lzw.flow
for JS:
 Org.size |Enc.t |Dec.t | Enc.size |%org|?
——————————+——————+——————+——————————+————+—
    239358|    48|    28|     45144| 18%|V
   2393580|   376|    43|    171680|  7%|V
   4787160|   594|    77|    258520|  5%|V
   7180740|  1059|    82|    326628|  4%|V
   9574320|  1434|   109|    388588|  4%|V
  11967900|  2353|   109|    446260|  3%|V
  14361480|  2686|   188|    498548|  3%|V
  16755060|  3818|   157|    547056|  3%|V
  19148640|  4090|   187|    593404|  3%|V
  21542220|  5307|   175|    637988|  2%|V
  23935800|  5358|   214|    680788|  2%|V
*/
  	compressLzw(s : string) -> string;
	decompressLzw(data : string) -> string;
}

EncPhrase(children : ref IntTree<int>);
LZWEncodingAcc(list : List<string>, phraseIdx : int, phraseWidth : int, remainder : int, remainderLen : int);

compressLzw(s : string) -> string {
	dict : ref IntTree<EncPhrase> = makeIntTree();
	makePhrase = \-> EncPhrase(makeIntTree());
	code = ref 65535;

	intAsString : (int) -> string = \i -> {
		fromCharCode(i) + fromCharCode(bitUshr(i, 16));
	};

	pushPhrase : (LZWEncodingAcc, int, int) -> LZWEncodingAcc = \acc, phIdx, newWidth -> {
		next = bitOr(acc.remainder, bitShl(acc.phraseIdx, acc.remainderLen));
		nextLen = acc.remainderLen + acc.phraseWidth;
		if (nextLen >= 32)
			LZWEncodingAcc(Cons(intAsString(next), acc.list), phIdx, newWidth, if (acc.phraseWidth == nextLen) 0 else bitUshr(acc.phraseIdx, acc.phraseWidth + 32 - nextLen), nextLen - 32)
		else if (nextLen >= 16)
			LZWEncodingAcc(Cons(fromCharCode(next), acc.list), phIdx, newWidth, bitUshr(next, 16), nextLen - 16)
		else
			LZWEncodingAcc(acc.list, phIdx, newWidth, next, nextLen)
	};

	out = stringFoldi(s, LZWEncodingAcc(makeList(), getCharCodeAt(s, 0), 32, 0, 0), \i, acc, c -> if (i == 0) acc else {
		phrase = switch (lookupIntTree(dict, acc.phraseIdx)) {
			Some(ph): ph;
			None(): {
				ph = makePhrase();
				dict := addOrUpdateIntTree(dict, acc.phraseIdx, ph);
				ph
			};
		};
		switch (lookupIntTree(phrase.children, c)) {
			Some(phi): LZWEncodingAcc(acc.list, phi, 32, 0, 0)
			None(): {
				code := ^code + 1;
				phrase.children := addOrUpdateIntTree(phrase.children, c, ^code);
				LZWEncodingAcc(Cons(intAsString(acc.phraseIdx), acc.list), c, 32, 0, 0)
			}
		}
	});

	list2string(Cons(intAsString(out.phraseIdx), out.list))
}

decompressLzwRec(
	i : int,
	limit : int,
	code : ref int,
	currChar : ref int,
	oldPhrase : ref string,
	data : (int) -> int,
	dict : ref Tree<int, string>,
	out : ref List<string>
) -> void {
	if (i <= limit) {
		currCode = data(i);
		phrase = if (currCode < 65536) {
			fromCharCode(currCode);
		} else {
			eitherFn(
				lookupTree(^dict, currCode),
				idfn,
				\ -> ^oldPhrase + fromCharCode(^currChar)
			)
		}
		out := Cons(phrase, ^out);
		currChar := getCharCodeAt(phrase, 0);
		dict := setTree(^dict, ^code, ^oldPhrase + fromCharCode(^currChar));
		code := ^code + 1;
		oldPhrase := phrase;

		decompressLzwRec(i + 1, limit, code, currChar, oldPhrase, data, dict, out);
	}
}

// Decompress an LZW-encoded string
decompressLzw(s : string) -> string {
	data = \i : int -> {
		getCharCodeAt(s, 2*i) + bitShl(getCharCodeAt(s, 2*i + 1), 16);
	}

	dict : ref Tree<int, string> = ref makeTree();
	currChar : ref int = ref data(0);
	out : ref List<string> = ref makeList1(getCharAt(s, 0));
	oldPhrase : ref string = ref fromCharCode(^currChar);
	code = ref 65536;

	decompressLzwRec(1, round(i2d(strlen(s))/2.0 - 1.0), code, currChar, oldPhrase, data, dict, out);

	list2string(^out)
}

intAsString(i : int) -> string {
	fromCharCode(i) + fromCharCode(bitUshr(i, 16));
}