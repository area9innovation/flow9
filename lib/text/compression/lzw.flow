import string;
import ds/list;
import ds/inttree;
import text/blueprint;
import math/bits;
import loop;

export {
	// LZW-compress a string. compress time ~ decompress time
	compressLzw(s : string) -> string;
	compressLzwExt(s : string, bitPacking : bool) -> string;

	// Decompress an LZW-encoded string
	decompressLzw(data : string) -> string;
	decompressLzwExt(data : string, bitPacking : bool) -> string;


	// ~2 times slower compressions than compressLzw but ~10 times faster decompression
	compressLzwFp(s : string) -> string;
	decompressLzwFp(s : string) -> string;
}

compressLzw(s : string) -> string {
	compressLzwExt(s, true)
}

decompressLzw(data : string) -> string {
	decompressLzwExt(data, true)
}

EncPhrase(children : ref IntTree<int>);
DecPhrase(parent : int, suffix : int /* char */);

lzw_measure_enc_phrase(p : ref IntTree<int>) -> int {
	switch (^p) {
		IntTreeNode(children): 128 + sum(map(children, lzw_measure_enc_phrase));
		IntTreeValue(__, __): 16;
		IntTreeNone(): 8;
	}
}

lzw_measure_enc_dict(t : IntTree<EncPhrase>) -> int {
	switch (t) {
		IntTreeNode(children): 128 + sum(map(children, \child -> lzw_measure_enc_dict(^child)));
		IntTreeValue(__, phrase): 8 + lzw_measure_enc_phrase(phrase.children);
		IntTreeNone(): 8;
	}
}

lzw_measure_dec_dict(t : IntTree<DecPhrase>) -> int {
	switch (t) {
		IntTreeNode(children): 128 + sum(map(children, \child -> lzw_measure_dec_dict(^child)));
		IntTreeValue(__, __): 32;
		IntTreeNone(): 8;
	}
}

LZWEncodingAcc(list : List<string>, phraseIdx : int, phraseWidth : int, remainder : int, remainderLen : int);
LZWDecodingAcc(list : List<string>, phraseIdx : int, phraseWidth : int, remainder : int, remainderLen : int, phrase : string, skip : bool);

compressLzwExt(s : string, bitPacking : bool) -> string {
	dict : ref IntTree<EncPhrase> = makeIntTree();
	makePhrase = \-> EncPhrase(makeIntTree());
	code = ref 65535;

	intAsString : (int) -> string = \i -> {
		fromCharCode(i) + fromCharCode(bitUshr(i, 16));
	};

	pushPhrase : (LZWEncodingAcc, int, int) -> LZWEncodingAcc = \acc, phIdx, newWidth -> {
		next = bitOr(acc.remainder, bitShl(acc.phraseIdx, acc.remainderLen));
		nextLen = acc.remainderLen + acc.phraseWidth;
		if (nextLen >= 32)
			LZWEncodingAcc(Cons(intAsString(next), acc.list), phIdx, newWidth, if (acc.phraseWidth == nextLen) 0 else bitUshr(acc.phraseIdx, acc.phraseWidth + 32 - nextLen), nextLen - 32)
		else if (nextLen >= 16)
			LZWEncodingAcc(Cons(fromCharCode(next), acc.list), phIdx, newWidth, bitUshr(next, 16), nextLen - 16)
		else
			LZWEncodingAcc(acc.list, phIdx, newWidth, next, nextLen)
	};

	out = if (bitPacking) stringFoldi(s, LZWEncodingAcc(makeList(), getCharCodeAt(s, 0), 16, 0, 0), \i, acc, c -> if (i == 0) acc else {
		phrase = switch (lookupIntTree(dict, acc.phraseIdx)) {
			Some(ph): ph;
			None(): {
				ph = makePhrase();
				dict := addOrUpdateIntTree(dict, acc.phraseIdx, ph);
				ph
			};
		};
		switch (lookupIntTree(phrase.children, c)) {
			Some(phi): LZWEncodingAcc(acc with phraseIdx=phi)
			None(): {
				code := ^code + 1;
				phrase.children := addOrUpdateIntTree(phrase.children, c, ^code);
				pushPhrase(acc, c, acc.phraseWidth + if (acc.phraseWidth == 32) 0 else bitUshr(^code, acc.phraseWidth));
			}
		}
	}) else stringFoldi(s, LZWEncodingAcc(makeList(), getCharCodeAt(s, 0), 32, 0, 0), \i, acc, c -> if (i == 0) acc else {
		phrase = switch (lookupIntTree(dict, acc.phraseIdx)) {
			Some(ph): ph;
			None(): {
				ph = makePhrase();
				dict := addOrUpdateIntTree(dict, acc.phraseIdx, ph);
				ph
			};
		};
		switch (lookupIntTree(phrase.children, c)) {
			Some(phi): LZWEncodingAcc(acc.list, phi, 32, 0, 0)
			None(): {
				code := ^code + 1;
				phrase.children := addOrUpdateIntTree(phrase.children, c, ^code);
				LZWEncodingAcc(Cons(intAsString(acc.phraseIdx), acc.list), c, 32, 0, 0)
			}
		}
	});

	if (bitPacking) {
		tmp = pushPhrase(out, 0, out.phraseWidth);
		list2string(
			if (tmp.remainderLen > 16) Cons(intAsString(tmp.remainder), tmp.list)
			else if (tmp.remainderLen > 0) Cons(fromCharCode(tmp.remainder), tmp.list)
			else tmp.list
		)
	} else
		list2string(Cons(intAsString(out.phraseIdx), out.list))
}

// Decompress an LZW-encoded string
decompressLzwExt(s : string, bitPacking : bool) -> string {

	dict : ref IntTree<DecPhrase> = makeIntTree();
	code = ref 65536;

	getFullPhrase = \idx -> {
		acc = updateWhile(Pair(idx, ""), \p -> {
			phraseM = lookupIntTree(dict, p.first);
			switch (phraseM) {
				Some(phrase): Some(Pair(
					phrase.parent,
					fromCharCode(phrase.suffix) + p.second
				));
				None(): None();
			}
		});
		fromCharCode(acc.first) + acc.second;
	};

	out = stringFold(s, LZWDecodingAcc(makeList(), 0, if (bitPacking) 16 else 32, 0, 0, "", true), \acc, c -> {
		if (acc.remainderLen + 16 >= acc.phraseWidth) {
			remainderLen = 16 + acc.remainderLen - acc.phraseWidth;
			remainder = bitUshr(c, 16 - remainderLen);
			phraseIdx = bitAnd(bitOr(acc.remainder, bitShl(c, acc.remainderLen)), bitUshr(-1, 32-acc.phraseWidth));
			phrase = if (phraseIdx < ^code)
				getFullPhrase(phraseIdx)
			else
				acc.phrase + strsubsmart(acc.phrase, 0, 1);
			if (!acc.skip) {
				dict := addOrUpdateIntTree(dict, ^code, DecPhrase(acc.phraseIdx, getCharCodeAt(phrase, 0)));
				code := ^code + 1;
			};
			LZWDecodingAcc(
				if (acc.skip) acc.list else Cons(acc.phrase, acc.list),
				phraseIdx,
				acc.phraseWidth + if (acc.phraseWidth == 32) 0 else bitUshr(^code, acc.phraseWidth),
				remainder,
				remainderLen,
				phrase,
				false
			)
		} else {
			LZWDecodingAcc(acc with remainder=bitOr(acc.remainder, bitShl(c, acc.remainderLen)), remainderLen=16+acc.remainderLen)
		}
	});

	list2string(Cons(out.phrase, out.list))
}


compressLzwFpRec(s : string, sLength : int, i : int, code : ref int, phrase : ref string, dict : ref Tree<string, int>, storeResult : () -> void) -> void {
	if (i < sLength) {
		currChar = getCharAt(s, i);
		newPhrase = ^phrase + currChar;
		if (isSome(lookupTree(^dict, newPhrase))) {
			phrase := newPhrase;
		} else {
			storeResult();
			dict := setTree(^dict, newPhrase, ^code);
			code := ^code + 1;
			phrase := currChar;
		}
		compressLzwFpRec(s, sLength, i + 1, code, phrase, dict, storeResult)
	} else {
		storeResult()
	}
}

compressLzwFp(s : string) -> string {
	dict : ref Tree<string, int> = ref makeTree();
	out : ref List<string> = ref makeList();
	phrase : ref string= ref (getCharAt(s, 0));
	code = ref 65536;
	zeroCode = fromCharCode(0);

	compressLzwFpRec(s, strlen(s), 1, code, phrase, dict, \ -> {
		out := Cons(
			(if (strlen(^phrase) > 1) {
				intAsString(lookupTreeDef(^dict, ^phrase, 0));
			} else {
				^phrase + zeroCode;
			}),
			^out
		);
	});

	list2string(^out)
}

decompressLzwFpRec(
	i : int,
	limit : int,
	code : ref int,
	currChar : ref int,
	oldPhrase : ref string,
	data : (int) -> int,
	dict : ref Tree<int, string>,
	out : ref List<string>
) -> void {
	if (i <= limit) {
		currCode = data(i);
		phrase = if (currCode < 65536) {
			fromCharCode(currCode);
		} else {
			eitherFn(
				lookupTree(^dict, currCode),
				idfn,
				\ -> ^oldPhrase + fromCharCode(^currChar)
			)
		}
		out := Cons(phrase, ^out);
		currChar := getCharCodeAt(phrase, 0);
		dict := setTree(^dict, ^code, ^oldPhrase + fromCharCode(^currChar));
		code := ^code + 1;
		oldPhrase := phrase;

		decompressLzwFpRec(i + 1, limit, code, currChar, oldPhrase, data, dict, out);
	}
}

// Decompress an LZW-encoded string
decompressLzwFp(s : string) -> string {
	data = \i : int -> {
		getCharCodeAt(s, 2*i) + bitShl(getCharCodeAt(s, 2*i + 1), 16);
	}

	dict : ref Tree<int, string> = ref makeTree();
	currChar : ref int = ref data(0);
	out : ref List<string> = ref makeList1(getCharAt(s, 0));
	oldPhrase : ref string = ref fromCharCode(^currChar);
	code = ref 65536;

	decompressLzwFpRec(1, round(i2d(strlen(s))/2.0 - 1.0), code, currChar, oldPhrase, data, dict, out);

	list2string(^out)
}

intAsString(i : int) -> string {
	fromCharCode(i) + fromCharCode(bitUshr(i, 16));
}