import string;

export {
	// Simple version of Excel wildcards (originaly implemented for Wigi)
	// Supported ? and * in pattern
	matchesWithExcelPattern(s : string, pattern : string) -> bool;

	// Check if str matches glob pattern (originaly implemented for Shift)
	// ? - match exactly one unknown character
	// * - match any number of unknown characters
	// [characters] - match a character as part of a group of characters
	// [!characters] - match any character but specified
	// [a-b] - match a character as part of a character range
	isGlobPattern(str : string) -> bool;

	matchesWithGlobPattern(str : string, glob : string) -> bool;
}

// Wildcard match. ? and * are supported
matchesWithExcelPattern(s : string, pattern : string) -> bool {
	isArrayPattern = startsWith(pattern, "[") && endsWith(pattern, "]");
	patterns = if (isArrayPattern) {
		map(
			strSplit2WithoutLeave(strsubsmart(pattern, 1, strlen(pattern) - 2), [",", ";"]),
			trim
		)
	} else [pattern];

	exists(patterns, \p -> matchesWithExcelPattern2(s2a(s), 0, s2a(p), 0))
}

matchesWithExcelPattern2(s : [int], si : int, pattern : [int], pi : int) -> bool {
	if (pi >= length(pattern)) {
		si >= length(s)
	} else {
		p = pattern[pi];

		if (p == 63) { // ? - matches any character except empty string
			if (si >= length(s)) {
				false
			} else {
				matchesWithExcelPattern2(s, si + 1, pattern, pi + 1)
			}
		} else if (p == 42) { // * - any string inclusive an empty string
			if (matchesWithExcelPattern2(s, si, pattern, pi + 1)) {
				// Can match * to empty string
				true;
			} else if (si < length(s) && matchesWithExcelPattern2(s, si + 1, pattern, pi)) {
				// Can match * to current char
				true
			} else {
				// Can't match anything
				false
			}
		} else {
			if (si < length(s) && s[si] == p) {
				matchesWithExcelPattern2(s, si + 1, pattern, pi + 1)
			} else {
				false
			}
		}
	}
}

isGlobPattern(str : string) -> bool {
	isSome(strFindFirstOfStrings(str, ["*", "?", "["]));
}

matchesWithGlobPattern(str : string, glob : string) -> bool {
	matchesWithGlobPattern2(str, 0, glob, 0)
}

matchesWithGlobPattern2(str : string, si : int, glob : string, gi : int) -> bool {
	strLen = strlen(str);
	globLen = strlen(glob);

	if (gi >= globLen) {
		// End of pattern - must be at end of string too
		si >= strLen
	} else {
		ch = getCharAt(glob, gi);

		if (ch == "*") {
			// Try matching * with 0 or more characters
			// First, skip the * and try to match the rest
			if (matchesWithGlobPattern2(str, si, glob, gi + 1)) {
				true
			} else if (si < strLen) {
				// Try consuming one character from str and keep the *
				matchesWithGlobPattern2(str, si + 1, glob, gi)
			} else {
				false
			}
		} else if (ch == "?") {
			// Match any single character - string must not be exhausted
			if (si < strLen) {
				matchesWithGlobPattern2(str, si + 1, glob, gi + 1)
			} else {
				false
			}
		} else if (ch == "[") {
			// Character class
			closeBracket = strFindFirstOf(strRight(glob, gi), "]");
			if (closeBracket >= 0) {
				// Extract content between [ and ] (closeBracket is the position of ] in the substring)
				rangePattern = substring(glob, gi + 1, closeBracket - 1);
				if (si >= strLen) {
					// Empty string - check if empty character class or negated class matches
					if (_isInRange("", rangePattern)) {
						matchesWithGlobPattern2(str, si, glob, gi + closeBracket + 1)
					} else {
						false
					}
				} else {
					currentChar = getCharAt(str, si);
					if (_isInRange(currentChar, rangePattern)) {
						matchesWithGlobPattern2(str, si + 1, glob, gi + closeBracket + 1)
					} else {
						false
					}
				}
			} else {
				// No closing bracket - invalid pattern, fail the match
				false
			}
		} else {
			// Literal character match
			if (si < strLen && getCharAt(str, si) == ch) {
				matchesWithGlobPattern2(str, si + 1, glob, gi + 1)
			} else {
				false
			}
		}
	}
}

_isInRange(c : string, rangePattern : string) -> bool {
	isNegated = startsWith(rangePattern, "!");
	pattern = if (isNegated) strRight(rangePattern, 1) else rangePattern;

	// Handle empty character case
	if (strlen(c) == 0) {
		// Empty string matches empty pattern []
		// Empty string with negated empty pattern [!] also matches (negation of empty set)
		strlen(pattern) == 0
	} else {
		result = _checkCharInRange(c, pattern, 0);
		if (isNegated) !result else result
	}
}

_checkCharInRange(c : string, pattern : string, i : int) -> bool {
	patternLen = strlen(pattern);
	if (i >= patternLen) {
		false
	} else {
		ch = getCharAt(pattern, i);

		// Check if this is the start of a range pattern like a-z
		// A dash creates a range only if: not at position 0, has a char after it, and that char exists
		if (i + 2 < patternLen && getCharAt(pattern, i + 1) == "-") {
			// This is a range: pattern[i]-pattern[i+2]
			rangeStart = getCharCodeAt(pattern, i);
			rangeEnd = getCharCodeAt(pattern, i + 2);
			charCode = firstElement(s2a(c), 0);

			// Check if it's a valid range (start <= end) and char is in range
			if (rangeStart <= rangeEnd && rangeStart <= charCode && charCode <= rangeEnd) {
				true
			} else {
				// Not in this range, skip past it (past the end char) and continue
				_checkCharInRange(c, pattern, i + 3)
			}
		} else {
			// Single character match (including dash at start or end like "[-" or "-]")
			if (c == ch) {
				true
			} else {
				_checkCharInRange(c, pattern, i + 1)
			}
		}
	}
}
