import string;

export {
	// Simple version of Excel wildcards (originaly implemented for Wigi)
	// Supported ? and * in pattern
	matchesWithExcelPattern(s : string, pattern : string) -> bool;

	// Check if str matches glob pattern (originaly implemented for Shift)
	// ? - match exactly one unknown character
	// * - match any number of unknown characters
	// [characters] - match a character as part of a group of characters
	// [!characters] - match any character but specified
	// [a-b] - match a character as part of a character range
	isGlobPattern(str : string) -> bool;

	matchesWithGlobPattern(str : string, glob : string) -> bool;
}

// Wildcard match. ? and * are supported
matchesWithExcelPattern(s : string, pattern : string) -> bool {
	isArrayPattern = startsWith(pattern, "[") && endsWith(pattern, "]");
	patterns = if (isArrayPattern) {
		map(
			strSplit2WithoutLeave(strsubsmart(pattern, 1, strlen(pattern) - 2), [",", ";"]),
			trim
		)
	} else [pattern];

	exists(patterns, \p -> matchesWithExcelPattern2(s2a(s), 0, s2a(p), 0))
}

matchesWithExcelPattern2(s : [int], si : int, pattern : [int], pi : int) -> bool {
	if (pi >= length(pattern)) {
		si >= length(s)
	} else {
		p = pattern[pi];

		if (p == 63) { // ? - matches any character except empty string
			if (si >= length(s)) {
				false
			} else {
				matchesWithExcelPattern2(s, si + 1, pattern, pi + 1)
			}
		} else if (p == 42) { // * - any string inclusive an empty string
			if (matchesWithExcelPattern2(s, si, pattern, pi + 1)) {
				// Can match * to empty string
				true;
			} else if (si < length(s) && matchesWithExcelPattern2(s, si + 1, pattern, pi)) {
				// Can match * to current char
				true
			} else {
				// Can't match anything
				false
			}
		} else {
			if (si < length(s) && s[si] == p) {
				matchesWithExcelPattern2(s, si + 1, pattern, pi + 1)
			} else {
				false
			}
		}
	}
}

isGlobPattern(str : string) -> bool {
	isSome(strFindFirstOfStrings(str, ["*", "?", "["]));
}

matchesWithGlobPattern(str : string, glob : string) -> bool {
	// Tail-recursive implementation using a work queue
	// Each work item is a pair (str_position, glob_position)
	matchesWithGlobPatternTailRec(str, 0, glob, 0, [])
}

matchesWithGlobPatternTailRec(str : string, strPos : int, glob : string, globPos : int, workQueue : [Pair<int, int>]) -> bool {
	strLen = strlen(str);
	globLen = strlen(glob);

	if (globPos >= globLen) {
		// Pattern exhausted
		if (strPos >= strLen) {
			// Both exhausted - match!
			true
		} else {
			// Try backtracking from work queue
			if (length(workQueue) == 0) {
				false
			} else {
				nextWork = workQueue[0];
				matchesWithGlobPatternTailRec(str, nextWork.first, glob, nextWork.second, tail(workQueue))
			}
		}
	} else {
		f = getCharAt(glob, globPos);

		if (strPos >= strLen) {
			// String exhausted, but pattern remains
			if (f == "*") {
				// Skip the star and continue
				matchesWithGlobPatternTailRec(str, strPos, glob, globPos + 1, workQueue)
			} else if (f == "[") {
				closeBracket = strFindFirstOf(substring(glob, globPos, globLen - globPos), "]");
				if (closeBracket >= 0) {
					rangePattern = substring(glob, globPos + 1, closeBracket - 1);
					if (_isInRangeTailRec("", rangePattern, 0)) {
						matchesWithGlobPatternTailRec(str, strPos, glob, globPos + closeBracket + 1, workQueue)
					} else {
						// Try backtracking
						if (length(workQueue) == 0) {
							false
						} else {
							nextWork = workQueue[0];
							matchesWithGlobPatternTailRec(str, nextWork.first, glob, nextWork.second, tail(workQueue))
						}
					}
				} else {
					// Malformed pattern
					if (length(workQueue) == 0) {
						false
					} else {
						nextWork = workQueue[0];
						matchesWithGlobPatternTailRec(str, nextWork.first, glob, nextWork.second, tail(workQueue))
					}
				}
			} else {
				// Try backtracking
				if (length(workQueue) == 0) {
					false
				} else {
					nextWork = workQueue[0];
					matchesWithGlobPatternTailRec(str, nextWork.first, glob, nextWork.second, tail(workQueue))
				}
			}
		} else {
			// Both string and pattern have characters
			if (f == "*") {
				// Star can match zero or more characters
				// Add backtracking option: try matching star with one more character
				newWorkQueue = concat(workQueue, [Pair(strPos + 1, globPos)]);
				// First try: skip the star (match zero characters)
				matchesWithGlobPatternTailRec(str, strPos, glob, globPos + 1, newWorkQueue)
			} else if (f == "?") {
				// Match any single character
				matchesWithGlobPatternTailRec(str, strPos + 1, glob, globPos + 1, workQueue)
			} else if (f == "[") {
				closeBracket = strFindFirstOf(substring(glob, globPos, globLen - globPos), "]");
				if (closeBracket >= 0) {
					rangePattern = substring(glob, globPos + 1, closeBracket - 1);
					currentChar = getCharAt(str, strPos);
					if (_isInRangeTailRec(currentChar, rangePattern, 0)) {
						matchesWithGlobPatternTailRec(str, strPos + 1, glob, globPos + closeBracket + 1, workQueue)
					} else {
						// Try backtracking
						if (length(workQueue) == 0) {
							false
						} else {
							nextWork = workQueue[0];
							matchesWithGlobPatternTailRec(str, nextWork.first, glob, nextWork.second, tail(workQueue))
						}
					}
				} else {
					// Malformed pattern
					if (length(workQueue) == 0) {
						false
					} else {
						nextWork = workQueue[0];
						matchesWithGlobPatternTailRec(str, nextWork.first, glob, nextWork.second, tail(workQueue))
					}
				}
			} else {
				// Literal character match
				currentChar = getCharAt(str, strPos);
				if (f == currentChar) {
					matchesWithGlobPatternTailRec(str, strPos + 1, glob, globPos + 1, workQueue)
				} else {
					// Try backtracking
					if (length(workQueue) == 0) {
						false
					} else {
						nextWork = workQueue[0];
						matchesWithGlobPatternTailRec(str, nextWork.first, glob, nextWork.second, tail(workQueue))
					}
				}
			}
		}
	}
}

_isInRangeTailRec(c : string, glob : string, i : int) -> bool {
	ch = getCharAt(glob, i);

	if (ch == "-" && i > 0 && i + 1 < strlen(glob)) {
		l = getCharCodeAt(glob, i - 1);
		r = getCharCodeAt(glob, i + 1);
		f = firstElement(s2a(c), 0);
		isInRange = l < f && f < r;

		// Check if negated
		isNegated = getCharAt(glob, 0) == "!";

		if (isInRange) {
			if (isNegated) false else true
		} else {
			_isInRangeTailRec(c, glob, i + 1)
		}
	} else if (ch != "" && ch != "]") {
		if (c == ch) {
			// Check if negated
			isNegated = getCharAt(glob, 0) == "!";
			if (isNegated) false else true
		} else {
			_isInRangeTailRec(c, glob, i + 1)
		}
	} else if (ch == "]" || ch == "") {
		// Reached end without match
		if (i == 0 && strlen(c) == 0) {
			// Empty character matches empty pattern
			isNegated = getCharAt(glob, 0) == "!";
			if (isNegated) true else false
		} else {
			// No match found
			isNegated = getCharAt(glob, 0) == "!";
			if (isNegated) true else false
		}
	} else {
		_isInRangeTailRec(c, glob, i + 1)
	}
}

_isInRange(c : string, glob : string) -> bool {
	_isInRangeTailRec(c, glob, 0)
}
