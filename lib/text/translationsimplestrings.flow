import text/translationutils;
import math/stringmath;
import net/http;

export {
	// Initialize translation api functions with simple strings support only
	setTranslationSimpleStringsApi() -> void;

	doSimpleStringTranslation(s : string) -> string;
	loadSimpleStringsTranslations(
		filePath : string,
		translationTree : ref Tree<string, string>,
		maybeVOTree : Maybe<ref Tree<string, string>>,
		maybeExtractionTime : Maybe<ref string>,
		maybeAttributesTree : Maybe<ref Tree<string, [KeyValue]>>,
		onSuccess : () -> void, onFail : () -> void
	) -> void;
	findSimpleStringTranslation(tree : Tree<string, string>, src : string) -> Maybe<string>;
}

setTranslationSimpleStringsApi() {
	devtrace("translation simple string api");
	fakeTranslationSupport(doSimpleStringTranslation);

	setTexts2XliffContent(simpleTexts2XliffContent);
	setTexts2XliffContentWithLang(simpleTexts2XliffContentWithLang);
	setTexts2XliffContentDeferred(simpleText2XliffContentDeffered);
	setLoadTranslations(loadSimpleStringsTranslations);
	setExtractTranslations(extractSimpleStringsTranslations);
	setFindTranslated(findSimpleStringTranslation);
}

findSimpleStringTranslation(tree : Tree<string, string>, src : string) -> Maybe<string> {
	lookupTree(tree, src)
}

doSimpleStringTranslation(s : string) -> string {
	eitherFn(
		lookupTree(^translations, s),
		idfn,
		\-> eitherMap(lookupTree(^translations, xmlEscapeText(s)), xmlUnescape, s)
	)
}

loadSimpleStringsTranslations(
	filePath : string,
	translationTree : ref Tree<string, string>,
	maybeVOTree : Maybe<ref Tree<string, string>>,
	maybeExtractionTime : Maybe<ref string>,
	maybeAttributesTree : Maybe<ref Tree<string, [KeyValue]>>,
	onSuccess : () -> void, onFail : () -> void
) -> void {

	begin_time = timestamp();
	translationsDebugTrace("Loading " + filePath);

	used_file = filePath + (if (strContains(filePath, "?")) "&" else "?") + "nocache=" + d2st(timestamp(), 8);

	onError = \e -> {
		if (isUrlParameterTrue("dev")) println("Error: Cannot get dictionary " + filePath + ": " + e);
		onFail();
	}

	onLoaded = \data -> {
		if (data == "") {
			// we treat empty dictionary files as not existing
			onError("file is empty");
		} else {
			translationsDebugTrace("Loaded " + used_file + "; size=" + i2s(strlen(data)) + "; loading time=" + toString((timestamp() - begin_time) / 1000.0) + " sec");

			extractTranslations(data, translationTree, maybeVOTree, maybeAttributesTree, \ -> {
				translationsDebugTrace("Translations extracted from " + used_file + "; total initialization time: " + toString((timestamp() - begin_time) / 1000.0) + " sec");
				onSuccess();
			})
		}
	}

	httpRequest3(used_file, onLoaded, onError);
}

extractSimpleStringsTranslations(content : string, translationTree : ref Tree<string, string>, maybeVOTree : Maybe<ref Tree<string, string>>, maybeAttributesTree : Maybe<ref Tree<string, [KeyValue]>>, onDone : ()->void) -> void {
	extractTranslationsFromJson(content, translationTree, onDone);
}

simpleTexts2XliffContent(texts : [ContentUnit], productName : string) -> string {
	simpleTexts2XliffContentWithLang(texts, productName, "EN-US")
}

simpleTexts2XliffContentWithLang(texts : [GeneralContentUnit], productName : string, language : string) -> string {
	// simple text in xml must be escaped
	extendedTexts2XliffContent(texts, productName, language, true, false)
}

simpleText2XliffContentDeffered(texts : [ContentUnit], productName : string, onResult : (string)->void) -> void {
	onResult(simpleTexts2XliffContent(texts, productName))
}
