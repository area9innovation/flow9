import string;
import ds/list;
import ds/tree;
import text/blueprint;

export {
	// LZW-compress a string
	lzw_encode(s : string) -> [int];

	// Decompress an LZW-encoded string
	lzw_decode(data : [int]) -> string;
}

lzw_encode(s : string) -> [int] {
	dict : ref Tree<[int], int> = ref makeTree();
	out : ref List<int> = ref makeList();
	phrase : ref [int]= ref [getCharCodeAt(s, 0)];
	code = ref 65536;

	storeResult = \ -> {
		out := Cons(
			if (length(^phrase) > 1) {
				lookupTreeDef(^dict, ^phrase, 0);
			} else {
				^phrase[0];
			},
			^out
		);
	}
	fori(1, strlen(s)-1, \i -> {
		currChar = getCharCodeAt(s, i);
		newPhrase = arrayPush(^phrase, currChar);
		if (isSome(lookupTree(^dict, newPhrase))) {
			refArrayPush(phrase, currChar);
		} else {
			storeResult();
			dict := setTree(^dict, newPhrase, ^code);
			code := ^code + 1;
			phrase := [currChar];
		}
	});

	storeResult();

	list2array(^out)
}

// Decompress an LZW-encoded string
lzw_decode(data : [int]) -> string {
	dict : ref Tree<int, [int]> = ref makeTree();
	currChar : ref int = ref data[0];
	out : ref List<[int]> = ref makeList1([^currChar]);
	oldPhrase : ref [int] = ref [(^currChar)];
	code = ref 65536;
	fori (1, length(data)-1, \i -> {
		currCode = data[i];
		phrase = if (currCode < 65536) {
			[data[i]];
		} else {
			eitherFn(
				lookupTree(^dict, currCode),
				idfn,
				\ -> arrayPush(^oldPhrase, ^currChar)
			)
		}
		out := Cons(phrase, ^out);
		currChar := phrase[0];
		dict := setTree(^dict, ^code, arrayPush(^oldPhrase, ^currChar));
		code := ^code + 1;
		oldPhrase := phrase;
	});

	superglue(concatA(list2array(^out)), fromCharCode, "");
}
