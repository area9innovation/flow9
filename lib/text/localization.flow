import string;
import ui/fontmapping;
export {
	findBreakAfterAllowPos(s: string) -> int;
	findBreakAfterAllowPos2(s: string, start: int, moreLineBreaks: bool) -> Pair<int, bool>;
}

//CJK consts
wordJoinSymbol : int = 0x2060;

//CJK
isCJKSymbol(c) {
	(0x4E00 <= c && c <= 0x9FCC) || (0x3400 <= c && c <= 0x4DB5)
}

// Katakana & Hiragana
isSyllabarySymbol(c) {
	//   Katakana                   Hiragana
	(0x30A0 <= c && c <= 0x30FF) || (0x3040 <= c && c <= 0x309F)
}

isEnLetterCode(charCode: int) {
	(0x0041 <= charCode && charCode <= 0x005A) || (0x0061 <= charCode && charCode <= 0x007A);
}

isDigitCode(charCode: int) {
	48 <= charCode && charCode <= 57
}

findBreakAfterAllowPos(s: string) -> int {
	findBreakAfterAllowPos2(s, 0, false).first;
}

//Const for not defined language
enBreakAllowAfter = [0x002D, 0x2010, 0x2012, 0x2013, 0x2014];
enSoftBreakAllowAfter = [0x00ad];

//common not begin char for CJK	', ', ': ', 'o 	'
cjkNotBeg = [0xFF0C, 0xFF1A, 0x3002];

//Japanese consts
jpNotBeg = [
			wordJoinSymbol, 0x0021, 0x0025, 0x0029, 0x002C, 0x002E, 0x003F, 0x005D,	0x007D, 0x00A1, 0x00A3, 0x00A4, 0x00A5, 0x00A7, 0x00A8, 0x00A9,
					0x00AA,	0x00AB, 0x00AC, 0x00AD, 0x00AE, 0x00AF, 0x00B0, 0x00DE, 0x00DF, 0x8141, 0x8142, 0x8143, 0x8144, 0x8145, 0x8146,	0x8147,
					0x8148,	0x8149, 0x814A, 0x814B, 0x8152, 0x8153, 0x8154, 0x8155, 0x8158, 0x815B, 0x8166, 0x8168, 0x816A, 0x816C, 0x816E,	0x8170,
					0x8172,	0x8174, 0x8176, 0x8178, 0x817A, 0x818B, 0x818C, 0x818D, 0x818E, 0x8191, 0x8193, 0x81F1, 0x829F, 0x82A1, 0x82A3,	0x82A5,
					0x82A7,	0x82C1, 0x82E1, 0x82E3, 0x82E5, 0x82EC, 0x8340, 0x8342, 0x8344, 0x8346, 0x8348, 0x8362, 0x8383, 0x8385, 0x8387,	0x838E,
					0x8395,	0x8396,
					0x0020, 0x0022, 0x003A, 0x003B, 0x00BB, 0x2010, 0x2013, 0x2019, 0x203C, 0x2047, 0x2048, 0x2049, 0x3001, 0x3002, 0x3005, 0x3009,
					0x300B, 0x300D, 0x300F, 0x3011, 0x3015, 0x3017, 0x3019, 0x301C, 0x301F, 0x303B, 0x3041, 0x3043, 0x3045, 0x3047, 0x3049, 0x3063,
					0x3083, 0x3085, 0x3087, 0x308E, 0x3095, 0x3096, 0x30A0, 0x30A1, 0x30A3, 0x30A5, 0x30A7, 0x30A9, 0x30C3, 0x30E3, 0x30E5, 0x30E7,
					0x30EE, 0x30F5, 0x30F6, 0x30FB, 0x30FC, 0x30FD, 0x30FE, 0x31F0, 0x31F1, 0x31F2, 0x31F3, 0x31F4, 0x31F5, 0x31F6, 0x31F7, 0x31F8,
					0x31F9, 0x31FA, 0x31FB, 0x31FC, 0x31FD, 0x31FE, 0x31FF, 0xFF5D, 0xFF60
		];

jpNotEnd = [
			wordJoinSymbol, 0x0024, 0x0028, 0x005B, 0x005C, 0x007B, 0x00A2, 0x8165,	0x8167, 0x8169, 0x816B, 0x816D, 0x816F, 0x8171, 0x8173,	0x8175,
					0x8177,	0x8179, 0x818F, 0x8190, 0x8192,
					0x0022, 0x00AB, 0x2018, 0x3008, 0x300A, 0x300C, 0x300E, 0x3010, 0x3014, 0x3016, 0x3018, 0x301D, 0xFF5B, 0xFF5F
			];

//Korean consts
krNotBeg = [
			wordJoinSymbol, 0x0021, 0x0025, 0x0029, 0x002C, 0x002E, 0x003A, 0x003B,	0x003F, 0x005D, 0x007D, 0xA1A2, 0xA1AF, 0xA1B1, 0xA1B3,	0xA1B5,
					0xA1B7, 0xA1B9, 0xA1BB, 0xA1BD, 0xA1C6, 0xA1C7,	0xA1C8, 0xA1C9, 0xA1CB, 0xA3A1, 0xA3A5, 0xA3A9, 0xA3AC,	0xA3AE, 0xA3BA, 0xA3BB,
					0xA3BF,	0xA3DC, 0xA3DD, 0xA3FD
		];

krNotEnd = [
			wordJoinSymbol,	0x0028, 0x005B, 0x005C, 0x007B, 0xA1AE, 0xA1B0, 0xA1B2,	0xA1B4, 0xA1B6, 0xA1B8, 0xA1BA, 0xA1BC, 0xA3A4, 0xA3A8,	0xA3DB,
					0xA3DC, 0xA3FB
		];
//Traditional Chinese consts
chtNotBeg = [
			wordJoinSymbol,	0x0021, 0x0029, 0x002C, 0x002E, 0x003A, 0x003B, 0x003F, 0x005D, 0x007D, 0xA141, 0xA142, 0xA143, 0xA144, 0xA145, 0xA146,
					0xA147,	0xA148, 0xA149, 0xA14A, 0xA14B, 0xA14C, 0xA14D, 0xA14E, 0xA14F, 0xA150, 0xA151, 0xA152, 0xA153, 0xA154, 0xA155, 0xA156,
					0xA157,	0xA158, 0xA159, 0xA15A, 0xA15B, 0xA15C, 0xA15D, 0xA15E, 0xA160, 0xA162, 0xA164, 0xA166, 0xA168, 0xA16A, 0xA16C, 0xA16E,
					0xA170,	0xA172, 0xA174, 0xA176, 0xA178, 0xA17A, 0xA17C, 0xA17E, 0xA1A2, 0xA1A2, 0xA1A4, 0xA1A6, 0xA1A8, 0xA1AA, 0xA1AC
		];

chtNotEnd = [
			wordJoinSymbol,	0x0028, 0x005B, 0x007B, 0xA15D, 0xA15F, 0xA161, 0xA163, 0xA165, 0xA167, 0xA169, 0xA16B, 0xA16D, 0xA16F, 0xA171, 0xA173,
			0xA175,	0xA177,	0xA179, 0xA17B, 0xA17D, 0xA1A1, 0xA1A3, 0xA1A5, 0xA1A7, 0xA1A9, 0xA1AB
		];

//Simplified Chinese consts
chsNotBeg = [
			wordJoinSymbol,	0x0021, 0x0029, 0x002C, 0x002E, 0x003A, 0x003B, 0x003F, 0x005D, 0x007D, 0xA1A2, 0xA1A3, 0xA1A4, 0xA1A5, 0xA1A6, 0xA1A7,
					0xA1A8,	0xA1A9, 0xA1AA, 0xA1AB, 0xA1AC, 0xA1AD, 0xA1AF, 0xA1B1, 0xA1B3, 0xA1B5, 0xA1B7, 0xA1B9, 0xA1BB, 0xA1BD, 0xA1BF, 0xA1C3,
					0xA3A1,	0xA158, 0xA159, 0xA15A, 0xA15B, 0xA15C, 0xA15D, 0xA15E, 0xA160, 0xA162, 0xA164, 0xA166, 0xA168, 0xA16A, 0xA16C, 0xA16E,
					0xA170,	0xA3A2, 0xA3A7, 0xA3A9, 0xA3AC, 0xA3AE, 0xA3BA, 0xA3BB, 0xA3BF, 0xA3DD, 0xA3E0, 0xA3FC, 0xA3FD
		];

chsNotEnd = [
			wordJoinSymbol, 0x0028, 0x005B, 0x007B, 0xA1AE, 0xA1B0, 0xA1B2, 0xA1B4, 0xA1B6, 0xA1B8, 0xA1BA, 0xA1BC, 0xA1BE, 0xA3A8, 0xA3AE, 0xA3B0,
					0xA3B1,	0xA3B2,	0xA3B3, 0xA3B4, 0xA3B5, 0xA3B6, 0xA3B7, 0xA3B8, 0xA3B9, 0xA3DB, 0xA3FB
		];

findBreakAfterAllowPos2(s: string, start: int, moreLineBreaks: bool) -> Pair<int, bool> {
	strL = strlen(s);
	if (strL - start < 3)
		Pair(-1, false)
	else {
		endSymb = ref getCharCodeAt(s, start + 0);
		posSymb = ref getCharCodeAt(s, start + 1);
		begSymb = ref getCharCodeAt(s, start + 2);

		lang = getLang();

		stdAction = \ -> {
			containsBreaks = contains(enBreakAllowAfter, ^posSymb);
			containsSoftBreaks = contains(enSoftBreakAllowAfter, ^posSymb);
			Pair((containsBreaks || containsSoftBreaks)
			&& (
				(isEnLetterCode(^begSymb) && isEnLetterCode(^endSymb))  
				||
				(moreLineBreaks && isDigitCode(^begSymb) && isDigitCode(^endSymb)) //Allow breaks in <number>-<number> pattern
			), containsSoftBreaks);
		};

		charAction = {
			if (isCJKLang()) {
				notBeg = {
					if (lang == "ja") jpNotBeg
					else if (lang == "ko") krNotBeg
					else chsNotBeg
				};
				notEnd = {
					if (lang == "ja") jpNotEnd
					else if (lang == "ko") krNotEnd
					else chsNotEnd
				};
				\ -> {
					if (isCJKSymbol(^posSymb) || isSyllabarySymbol(^posSymb)) {
						if (!contains(cjkNotBeg, ^begSymb)) {
							Pair(!(contains(notBeg, ^begSymb) || contains(notEnd, ^endSymb)), false)
						} else {
							Pair(false, false)
						}
					} else {
						stdAction()
					}
				}
			} else {
				stdAction
			}
		};

		fIdxAndSoft = countUntilWithSign(start + 1, strL - 1, \idx -> {
			fStepResult = charAction();				
			endSymb := ^posSymb;
			posSymb := ^begSymb;
			begSymb := getCharCodeAt(s, (idx + 2) % strL);
			fStepResult
		});
		Pair(if (fIdxAndSoft.first < (strL - 1)) fIdxAndSoft.first else -1, fIdxAndSoft.second);
	}
}

countUntilWithSign(start: int, maxcount: int, predicate: (int) -> Pair<bool, bool> ) -> Pair<int, bool> {
	if (start >= maxcount) {
		Pair(maxcount, false)
	} else {
		pr = predicate(start);
		if (pr.first) {
			Pair(start, pr.second)
		} else {
			countUntilWithSign(start + 1, maxcount, predicate)
		}
	}
}

