import string;
import ui/fontmapping;
export {
	findBreakAfterAllowPos(s: string) -> int;
	findBreakAfterAllowPos2(s: string, start: int, moreLineBreaks: bool, allowBreakAtStart : bool, allowAnySoftBreak : bool) -> Pair<int, bool>;

	createSpaceFormOnLang(spaceForm : Form) -> Form;
	doNotSkipSymbolDeltaOnLang(doNotSkip : bool) -> bool;

	// Depending on target show different symbol as hyphenation point, otherwise symbol could be invisible/missing
	softBreakVisualSymbol = fromCharCode(
		if (js) {
			0x2027 // small dot
		} else {
			softBreakAllowAfter
		}
	);

	// These do not yet support different size of digit groups, just character replacements.
	// Maybe it worths to merge into i2s/d2s directly.
	// If there is a need to enable/disable this functionality application-wise,
	// use setUrlParameter("locnum", "1").
	localizeNumbers(s: string) -> string;
}

//CJK consts
wordJoinSymbol : int = 0x2060;

//CJK
isCJKSymbol(c) {
	(0x4E00 <= c && c <= 0x9FCC) || (0x3400 <= c && c <= 0x4DB5)
}

// Katakana & Hiragana
isSyllabarySymbol(c) {
	//   Katakana                   Hiragana
	(0x30A0 <= c && c <= 0x30FF) || (0x3040 <= c && c <= 0x309F)
}

isEnLetterCode(charCode: int) {
	(0x0041 <= charCode && charCode <= 0x005A) || (0x0061 <= charCode && charCode <= 0x007A);
}

isDigitCode(charCode: int) {
	(48 <= charCode && charCode < 58) || (0x660 <= charCode && charCode < 0x66A)
}

localizeNumbers(s: string) -> string {
	if (getLang() == "ar") {
		strReplaces(
			s,
			[
				"0", "٠", "1", "١", "2", "٢", "3", "٣", "4", "٤",
				"5", "٥", "6", "٦", "7", "٧", "8", "٨", "9", "٩",
				"%", "٪"
			]
		)
	} else s
}

findBreakAfterAllowPos(s: string) -> int {
	findBreakAfterAllowPos2(s, 0, false, false, false).first;
}

createSpaceFormOnLang(spaceForm : Form) -> Form {
	// in case of CJKLang we don't show the break symbol
	if (isCJKLang()) {
		Empty()
	} else {
		spaceForm
	}
}

doNotSkipSymbolDeltaOnLang(doNotSkip : bool) -> bool {
	isCJKLang() && doNotSkip;
}

//Const for not defined language
enBreakAllowAfter = [0x002D, 0x2010, 0x2012, 0x2013, 0x2014];

//common not begin char for CJK	', ', ': ', 'o 	'
cjkNotBeg = [0xFF0C, 0xFF1A, 0x3002];

//Japanese consts
jpNotBeg = [
	wordJoinSymbol, 0x0021, 0x0025, 0x0029, 0x002C, 0x002E, 0x003F, 0x005D, 0x007D, 0x00A1, 0x00A3, 0x00A4, 0x00A5, 0x00A7, 0x00A8, 0x00A9,
	0x00AA, 0x00AB, 0x00AC, 0x00AD, 0x00AE, 0x00AF, 0x00B0, 0x00DE, 0x00DF, 0x8141, 0x8142, 0x8143, 0x8144, 0x8145, 0x8146, 0x8147,
	0x8148, 0x8149, 0x814A, 0x814B, 0x8152, 0x8153, 0x8154, 0x8155, 0x8158, 0x815B, 0x8166, 0x8168, 0x816A, 0x816C, 0x816E, 0x8170,
	0x8172, 0x8174, 0x8176, 0x8178, 0x817A, 0x818B, 0x818C, 0x818D, 0x818E, 0x8191, 0x8193, 0x81F1, 0x829F, 0x82A1, 0x82A3, 0x82A5,
	0x82A7, 0x82C1, 0x82E1, 0x82E3, 0x82E5, 0x82EC, 0x8340, 0x8342, 0x8344, 0x8346, 0x8348, 0x8362, 0x8383, 0x8385, 0x8387, 0x838E,
	0x8395, 0x8396,
	0x0020, 0x0022, 0x003A, 0x003B, 0x00BB, 0x2010, 0x2013, 0x2019, 0x203C, 0x2047, 0x2048, 0x2049, 0x3001, 0x3002, 0x3005, 0x3009,
	0x300B, 0x300D, 0x300F, 0x3011, 0x3015, 0x3017, 0x3019, 0x301C, 0x301F, 0x303B, 0x3041, 0x3043, 0x3045, 0x3047, 0x3049, 0x3063,
	0x3083, 0x3085, 0x3087, 0x308E, 0x3095, 0x3096, 0x30A0, 0x30A1, 0x30A3, 0x30A5, 0x30A7, 0x30A9, 0x30C3, 0x30E3, 0x30E5, 0x30E7,
	0x30EE, 0x30F5, 0x30F6, 0x30FB, 0x30FC, 0x30FD, 0x30FE, 0x31F0, 0x31F1, 0x31F2, 0x31F3, 0x31F4, 0x31F5, 0x31F6, 0x31F7, 0x31F8,
	0x31F9, 0x31FA, 0x31FB, 0x31FC, 0x31FD, 0x31FE, 0x31FF, 0xFF5D, 0xFF60
];

jpNotEnd = [
	wordJoinSymbol, 0x0024, 0x0028, 0x005B, 0x005C, 0x007B, 0x00A2, 0x8165, 0x8167, 0x8169, 0x816B, 0x816D, 0x816F, 0x8171, 0x8173, 0x8175,
	0x8177, 0x8179, 0x818F, 0x8190, 0x8192,
	0x0022, 0x00AB, 0x2018, 0x3008, 0x300A, 0x300C, 0x300E, 0x3010, 0x3014, 0x3016, 0x3018, 0x301D, 0xFF5B, 0xFF5F
];

//Korean consts
krNotBeg = [
	wordJoinSymbol, 0x0021, 0x0025, 0x0029, 0x002C, 0x002E, 0x003A, 0x003B, 0x003F, 0x005D, 0x007D, 0xA1A2, 0xA1AF, 0xA1B1, 0xA1B3, 0xA1B5,
	0xA1B7, 0xA1B9, 0xA1BB, 0xA1BD, 0xA1C6, 0xA1C7, 0xA1C8, 0xA1C9, 0xA1CB, 0xA3A1, 0xA3A5, 0xA3A9, 0xA3AC, 0xA3AE, 0xA3BA, 0xA3BB,
	0xA3BF, 0xA3DC, 0xA3DD, 0xA3FD
];

krNotEnd = [
	wordJoinSymbol, 0x0028, 0x005B, 0x005C, 0x007B, 0xA1AE, 0xA1B0, 0xA1B2, 0xA1B4, 0xA1B6, 0xA1B8, 0xA1BA, 0xA1BC, 0xA3A4, 0xA3A8, 0xA3DB,
	0xA3DC, 0xA3FB
];
//Traditional Chinese consts
chtNotBeg = [
	wordJoinSymbol, 0x0021, 0x0029, 0x002C, 0x002E, 0x003A, 0x003B, 0x003F, 0x005D, 0x007D, 0xA141, 0xA142, 0xA143, 0xA144, 0xA145, 0xA146,
	0xA147, 0xA148, 0xA149, 0xA14A, 0xA14B, 0xA14C, 0xA14D, 0xA14E, 0xA14F, 0xA150, 0xA151, 0xA152, 0xA153, 0xA154, 0xA155, 0xA156,
	0xA157, 0xA158, 0xA159, 0xA15A, 0xA15B, 0xA15C, 0xA15D, 0xA15E, 0xA160, 0xA162, 0xA164, 0xA166, 0xA168, 0xA16A, 0xA16C, 0xA16E,
	0xA170, 0xA172, 0xA174, 0xA176, 0xA178, 0xA17A, 0xA17C, 0xA17E, 0xA1A2, 0xA1A2, 0xA1A4, 0xA1A6, 0xA1A8, 0xA1AA, 0xA1AC
];

chtNotEnd = [
	wordJoinSymbol, 0x0028, 0x005B, 0x007B, 0xA15D, 0xA15F, 0xA161, 0xA163, 0xA165, 0xA167, 0xA169, 0xA16B, 0xA16D, 0xA16F, 0xA171, 0xA173,
	0xA175, 0xA177, 0xA179, 0xA17B, 0xA17D, 0xA1A1, 0xA1A3, 0xA1A5, 0xA1A7, 0xA1A9, 0xA1AB
];

//Simplified Chinese consts
chsNotBeg = [
	wordJoinSymbol, 0x0021, 0x0029, 0x002C, 0x002E, 0x003A, 0x003B, 0x003F, 0x005D, 0x007D, 0xA1A2, 0xA1A3, 0xA1A4, 0xA1A5, 0xA1A6, 0xA1A7,
	0xA1A8, 0xA1A9, 0xA1AA, 0xA1AB, 0xA1AC, 0xA1AD, 0xA1AF, 0xA1B1, 0xA1B3, 0xA1B5, 0xA1B7, 0xA1B9, 0xA1BB, 0xA1BD, 0xA1BF, 0xA1C3,
	0xA3A1, 0xA158, 0xA159, 0xA15A, 0xA15B, 0xA15C, 0xA15D, 0xA15E, 0xA160, 0xA162, 0xA164, 0xA166, 0xA168, 0xA16A, 0xA16C, 0xA16E,
	0xA170, 0xA3A2, 0xA3A7, 0xA3A9, 0xA3AC, 0xA3AE, 0xA3BA, 0xA3BB, 0xA3BF, 0xA3DD, 0xA3E0, 0xA3FC, 0xA3FD
];

chsNotEnd = [
	wordJoinSymbol, 0x0028, 0x005B, 0x007B, 0xA1AE, 0xA1B0, 0xA1B2, 0xA1B4, 0xA1B6, 0xA1B8, 0xA1BA, 0xA1BC, 0xA1BE, 0xA3A8, 0xA3AE, 0xA3B0,
	0xA3B1, 0xA3B2, 0xA3B3, 0xA3B4, 0xA3B5, 0xA3B6, 0xA3B7, 0xA3B8, 0xA3B9, 0xA3DB, 0xA3FB
];

findBreakAfterAllowPos2(s: string, start: int, moreLineBreaks: bool, allowBreakAtStart : bool, allowAnySoftBreak : bool) -> Pair<int, bool> {
	strL = strlen(s);
	if (strL - start < 3)
		Pair(-1, false)
	else {
		endSymb = ref getCharCodeAt(s, start + 0);
		fIdxAndSoft = if (allowBreakAtStart && contains(enBreakAllowAfter, ^endSymb)) {
			Pair(start, false)
		} else {
			posSymb = ref getCharCodeAt(s, start + 1);
			begSymb = ref getCharCodeAt(s, start + 2);

			lang = getLang();

			stdAction = \ -> {
				containsBreaks = contains(enBreakAllowAfter, ^posSymb);
				containsSoftBreaks = softBreakAllowAfter == ^posSymb;
				Pair(
					(containsBreaks || containsSoftBreaks)
					&& (
						(allowAnySoftBreak)
						||
						(isEnLetterCode(^begSymb) && isEnLetterCode(^endSymb))
						||
						(moreLineBreaks && isDigitCode(^begSymb) && isDigitCode(^endSymb)) //Allow breaks in <number>-<number> pattern
					),
					containsSoftBreaks
				);
			};

			charAction = {
				if (isCJKLang()) {
					notBeg = {
						if (lang == "ja" || isChinese(lang)) jpNotBeg
						else if (lang == "ko") krNotBeg
						else chsNotBeg
					};
					notEnd = {
						if (lang == "ja" || isChinese(lang)) jpNotEnd
						else if (lang == "ko") krNotEnd
						else chsNotEnd
					};
					\ -> {
						if (isCJKSymbol(^posSymb) || isSyllabarySymbol(^posSymb)) {
							if (!contains(cjkNotBeg, ^begSymb)) {
								Pair(!(contains(notBeg, ^begSymb) || contains(notEnd, ^endSymb)), false)
							} else {
								Pair(false, false)
							}
						} else {
							stdAction()
						}
					}
				} else {
					stdAction
				}
			};

			countUntilWithSign(start + 1, strL - 1, \idx -> {
				fStepResult = charAction();
				endSymb := ^posSymb;
				posSymb := ^begSymb;
				begSymb := getCharCodeAt(s, (idx + 2) % strL);
				fStepResult
			});
		}
		Pair(if (fIdxAndSoft.first < (strL - 1)) fIdxAndSoft.first else -1, fIdxAndSoft.second);
	}
}

countUntilWithSign(start: int, maxcount: int, predicate: (int) -> Pair<bool, bool> ) -> Pair<int, bool> {
	if (start >= maxcount) {
		Pair(maxcount, false)
	} else {
		pr = predicate(start);
		if (pr.first) {
			Pair(start, pr.second)
		} else {
			countUntilWithSign(start + 1, maxcount, predicate)
		}
	}
}
