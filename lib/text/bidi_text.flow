import ds/arrayutils;
import text/unicodecharacters;
import ui/fontmapping;
import formats/html/html;
import loop;
import text/blueprint;

export {
	// TODO refactor due these are used to partial functionality, do not bring
	// semantically complete functionality, but used in some places, which
	// themselves may duplicate each other.
	// Seems text breaking algo needs to be implemented to replace
	// existing in paragraph.flow and tparagraph.flow.

	// Choose leftmost valid string position from two given.
	nextValidStrPos(left: int, right: int) -> int;

	// Determine where to split the text, based on unicode categories.
	getCharCatSplitPos(t: string, i: int, endPos: int) -> int;
	// END TODO

	DirectionAndMajority(d: int, m: int);

	getTextDirectionAndMajority(t: string) -> DirectionAndMajority;

	reflowTextToBiDi(text: [[?]], isEmpty: (?) -> bool, getText: (?) -> string, setText: (?, string) -> ?, setRTL: (?, bool) -> ?, rtl: bool) -> [[?]];

	// Returns a reversed list with elements of original list wrapped into a pair with text flow direction
	markListToBiDiReverse(list: List<?>, getText: (?) -> string) -> List<Pair<?, int>>;
}

nextValidStrPos(left: int, right: int) -> int {
	if (left >= 0 && (right < 0 || left < right)) left else right;
}

getCharCatSplitPos(t: string, i: int, endPos: int) -> int {
	// TODO make these refs part of accumulator in stringFoldi.
	htmlEntity: ref int = ref -1;
	htmlTag: ref int = ref -1;
	stringFoldi(strSubRange(t, i, nextValidStrPos(endPos, strlen(t))), -1, \cur_pspi, pspacc, cur_pspcode -> {
		ppr_pspcode = getCharCodeAt("  "+t, cur_pspi+i);
		pre_pspcode = getCharCodeAt(" "+t, cur_pspi+i);
		if (^htmlEntity != -1) {
			if (pre_pspcode==59) {
				htmlEntity := -1;
				nextValidStrPos(pspacc, cur_pspi+i)
			} else if ((pre_pspcode != 35 && pre_pspcode != 38 && pre_pspcode < 48) || (pre_pspcode > 57 && pre_pspcode < 65) || (pre_pspcode > 90 && pre_pspcode < 97) || pre_pspcode > 122)
				nextValidStrPos(pspacc, cur_pspi+i+1)
			else
				pspacc
		} else if (pre_pspcode == 38) {
			htmlEntity := cur_pspi+i;
			pspacc;
		} else if (^htmlTag != -1) {
			if (pre_pspcode == 62) {
				nextValidStrPos(pspacc, cur_pspi+i)
			} else pspacc;
		} else if (pre_pspcode == 60) {
			htmlTag := cur_pspi+i;
			pspacc;
		} else {
			nxt_pspcode = getCharCodeAt(t+" ", cur_pspi+i+1);
			ppr_cat = getUnicodeCategory(ppr_pspcode);
			pre_cat = getUnicodeCategory(pre_pspcode);
			cur_cat = getUnicodeCategory(cur_pspcode);
			nxt_cat = getUnicodeCategory(nxt_pspcode);
			pre_alp = getUnicodeAlphabet(pre_pspcode);
			cur_alp = getUnicodeAlphabet(cur_pspcode);
			if (
				(isPunct(cur_cat) && !(contains([0x27, 0x2C, 0x2E], cur_pspcode) || pre_cat == uc_decimalDigitNumber || nxt_cat == uc_decimalDigitNumber)) ||
				(isPunct(pre_cat) && (cur_cat != uc_decimalDigitNumber || ppr_cat != uc_decimalDigitNumber)) ||
				(isPunct(cur_cat) && (pre_cat != uc_decimalDigitNumber || nxt_cat != uc_decimalDigitNumber)) ||

				(pre_alp != cur_alp) || (pre_cat == uc_spaceSeparator) || (cur_cat == uc_spaceSeparator) ||
				false
			)
				nextValidStrPos(pspacc, cur_pspi+i)
			else
				pspacc;
		}
	});
}

BiDiWord(word: ?, dm: DirectionAndMajority);
BiDiWordAddress(lno: int, wno: int);

BiDiContext(rtl: bool, formattingStack : ref List<BiDiFormatting>);
BiDiFormatting(kind : BiDiFormattingKind, met: BiDiWordAddress, dm : DirectionAndMajority);
	BiDiFormattingKind ::=
		BiDiDirectionMark, BiDiDirectionEmbedded,
		BiDiDirectionIsolated, BiDiDirectionOverridden;

		BiDiDirectionMark();
		BiDiDirectionEmbedded();
		BiDiDirectionIsolated();
		BiDiDirectionOverridden();  // Not supported yet.

makeBiDiContext(rtl : Maybe<bool>) -> BiDiContext {
	BiDiContext(eitherFn(rtl, idfn, getDefaultRtl), ref EmptyList())
}

_isLetter(ipcat) {
	ipcat == uc_uppercaseLetter || ipcat == uc_lowercaseLetter || ipcat == uc_titlecaseLetter || ipcat == uc_modifierLetter || ipcat == uc_otherLetter || ipcat == uc_nonSpacingMark;
}

isPunct(ipcat) {
	ipcat == uc_openPunctuation || ipcat == uc_closePunctuation || ipcat == uc_initialQuotePunctuation || ipcat == uc_finalQuotePunctuation || ipcat == uc_otherPunctuation;
}

mirrorWordGlyphsForRtl(s: string, rtl: bool) -> string {
	// We have our strings HTML-encoded, so additional replacements needed.
	COUPLED_MULTI_CHARS = if (js)
		["&lt;", "&gt;", "&#60;", "&#62;", "&#x3C;", "&#3E;", "&#x3c;", "&#3e;"]
	else
		[];

	if (rtl) {
		concatStrings(
			map(
				strSplit2(s, COUPLED_MULTI_CHARS),
				\frag -> eitherMap(
					findi(COUPLED_MULTI_CHARS, \el-> el==frag),
					\i -> COUPLED_MULTI_CHARS[if (0==i%2) i+1 else i-1], /* No XOR in flow for a pity */
					frag
				)
			)
		)
	} else s;
}

getCharDirectionAndMajority(code: int) -> DirectionAndMajority {
	cat = getUnicodeCategory(code);
	DirectionAndMajority(getUnicodeDirection(code), if (_isLetter(cat) || contains([0x200D, 0x202B, 0x202E], code)) 2 else b2i(cat == uc_decimalDigitNumber));
}

// Makes one DM pair from two, this function is fold helper.
fold2DMs(first: DirectionAndMajority, second: DirectionAndMajority) -> DirectionAndMajority {
	if (first.m > second.m) first else
	if (second.m > first.m) second else
	DirectionAndMajority(if (first.d == uc_dir_rtl || first.d == uc_dir_ltr) first.d else second.d, max(first.m, second.m));
}

// Makes one DM pair from three, third is default when first two are conflicting.
// Assuming third has RTL or LTR direction so the case is solved.
fold3DMs(first: DirectionAndMajority, second: DirectionAndMajority, third: DirectionAndMajority) -> DirectionAndMajority {
	if (first.m > second.m) first else
	if (second.m > first.m || second.d == first.d) second else
	DirectionAndMajority(
		if (first.d == uc_dir_rtl || first.d == uc_dir_ltr)
			if (second.d == uc_dir_rtl || second.d == uc_dir_ltr)
				third.d
			else
				first.d
		else 
			if (second.d == uc_dir_rtl || second.d == uc_dir_ltr)
				second.d
			else
				third.d,
		max(first.m, second.m)
	);
}

// Returns word direction and majority flag (meaning this direction to be inherited
// by adjacent words with no majority).
getTextDirectionAndMajority(t: string) -> DirectionAndMajority {
	stringFold(
		unescapeHtml(t), DirectionAndMajority(uc_dir_flow, 0), \acc: DirectionAndMajority, code: int ->
			fold2DMs(acc, getCharDirectionAndMajority(code))
	);
}

getWordDirectionAndMajority(w: BiDiWord<?>) -> DirectionAndMajority {w.dm}

getWordsDirectionAndMajority(ws: [BiDiWord<?>]) -> DirectionAndMajority {
	fold(map(ws, \w -> getWordDirectionAndMajority(w)), DirectionAndMajority(uc_dir_flow, 0), fold2DMs);
}

debugWord(w: BiDiWord<?>, getText: (?) -> string) -> string {
	ddm = \dm -> getCharAt("→~←:", dm.d) + toString(dm.m);
	getText(w.word) + ddm(w.dm);
}

groupByCounterDirReverse(ws: [BiDiWord<?>], rtl: bool, getText: (?) -> string) -> [[BiDiWord<?>]] {
	defaultDir = if (rtl) uc_dir_rtl else uc_dir_ltr;
	counterDir = if (rtl) uc_dir_ltr else uc_dir_rtl;
	if (length(ws) < 2) [ws] else fold(
		tail(ws), Pair([[ws[0]]], getWordDirectionAndMajority(ws[0])), \acc: Pair<[[BiDiWord<?>]], DirectionAndMajority>, w: BiDiWord<?> -> {
			wdm = getWordDirectionAndMajority(w);
			Pair(
				if (acc.second.d == counterDir && acc.second.m > 1 && wdm.d != defaultDir)
					insertArray(tail(acc.first), 0, if (rtl) arrayPush(acc.first[0], w) else insertArray(acc.first[0], 0, w))
				else
					insertArray(acc.first, 0, [w]),
				if (wdm.m > 1) wdm else acc.second
			)
		}
	).first;
}

reflowWordsToBiDi(ws: [BiDiWord<?>], isEmpty: (?) -> bool, getText: (?) -> string, setText: (?, string) -> ?, rtl: bool) -> [BiDiWord<?>] {
	// Grouping words with counter-direction into subarrays, and reversing order.
	ltrGrouping = groupByCounterDirReverse(ws, rtl, getText);

	// Repeating same for each group and reverse them back — to cut group trailing punctuation, and counter-directed groups now in reverse order.
	ltrCleanGrouping = concatA(map(ltrGrouping, \lgws -> reverseA(groupByCounterDirReverse(lgws, rtl, getText))));

	// Filtering out empty fragments and joining all groups back together.
	r = filter(
		concatA(
			map(ltrCleanGrouping, \grp -> {
				grpdm = DirectionAndMajority(if ((length(unwrapLine(grp, \x, __ -> x)) == 1) == rtl) uc_dir_rtl else uc_dir_ltr, 0);
				map(grp, \w -> BiDiWord(setText(w.word, mirrorWordGlyphsForRtl(getText(w.word), (fold2DMs(grpdm, w.dm).d != uc_dir_ltr) == rtl)), w.dm));
			})
		),
		\w -> !isEmpty(w.word)
	);

	// Globally, text remains in reverse order after first operation, which only good for RTL.
	if (rtl) r else reverseA(r)
}

unwrapLine(l: [BiDiWord<?>], setRTL: (?, bool) -> ?) -> [?] {
	map(l, \w ->
		if (contains([uc_dir_ltr, uc_dir_rtl], w.dm.d)) setRTL(w.word, w.dm.d == uc_dir_rtl) else w.word
	);
}

reflowTextToBiDi(text: [[?]], isEmpty: (?) -> bool, getText: (?) -> string, setText: (?, string) -> ?, setRTL: (?, bool) -> ?, rtl: bool) -> [[?]] {
	are2AddrsOrdered = \a: BiDiWordAddress, b: BiDiWordAddress -> a.lno < b.lno || (a.lno == b.lno && a.wno <= b.wno);

	defaultDM = DirectionAndMajority(if (rtl) uc_dir_rtl else uc_dir_ltr, 2);

	context = makeBiDiContext(Some(rtl));
	pairings : ref Tree<BiDiWordAddress, Pair<DirectionAndMajority, BiDiWordAddress>> = ref makeTree();
	stackPasser = \keyChar, dir, kind : [BiDiFormattingKind], fn -> Pair(
		keyChar,
		\pos, stack -> fn(dir, kind, pos, stack)
	);
	formattingMark = \dm, __, pos, stack : List<BiDiFormatting> -> Cons(BiDiFormatting(BiDiDirectionMark(), pos, dm), switch(stack) {
		Cons(head, t): switch(head.kind) {
			BiDiDirectionMark(): t;
			default: stack
		};
		EmptyList(): stack
	});
	formattingPush = \dm, kind : [BiDiFormattingKind], pos, stack -> {
		Cons(BiDiFormatting(kind[0], pos, dm), stack);
	};
	formattingPop = \dm, kind : [BiDiFormattingKind], pos, stack -> tailList(updateWhile(stack, \s -> switch(s : List<BiDiFormatting>) {
		EmptyList(): None();
		Cons(head, t): if (contains(kind, head.kind)) None() else Some(t);
	}));
	formatHandlers = pairs2tree([
		// Implemented isolated and marks as most useful yet.
		stackPasser("\u200E", DirectionAndMajority(uc_dir_ltr, 3), [BiDiDirectionMark()], formattingMark),
		stackPasser("\u200F", DirectionAndMajority(uc_dir_rtl, 3), [BiDiDirectionMark()], formattingMark),
		stackPasser("\u2066", DirectionAndMajority(uc_dir_ltr, 3), [BiDiDirectionIsolated()], formattingPush),
		stackPasser("\u2067", DirectionAndMajority(uc_dir_rtl, 3), [BiDiDirectionIsolated()], formattingPush),
		stackPasser("\u2069", DirectionAndMajority(uc_dir_flow, 3), [BiDiDirectionIsolated()], formattingPop),
		// TODO no good support yet, the Overridden behaves the same, but also shows chars in memory order,
		//      Embedded must also somehow differ from Isolated.
		//stackPasser("\u202A", uc_dir_ltr, [BiDiDirectionEmbedded()], formattingPush),
		//stackPasser("\u202B", uc_dir_rtl, [BiDiDirectionEmbedded()], formattingPush),
		//stackPasser("\u202C", uc_dir_flow, [BiDiDirectionEmbedded(), BiDiDirectionOverridden()], formattingPop),
		//stackPasser("\u202D", uc_dir_ltr, [BiDiDirectionOverridden()], formattingPush),
		//stackPasser("\u202E", uc_dir_rtl, [BiDiDirectionOverridden()], formattingPush),
	]);
	pairingO = ["{", "(", "["];
	pairingL = length(pairingO);
	pairingC = ["}", ")", "]"];
	pairingStack : ref List<Pair<BiDiWordAddress, int>> = ref makeList();

	previousDM = ref defaultDM;
	lines0 = mapi(text, \lno, l -> mapi(l, \wno, w -> {
		t = getText(w);
		currentAddr = BiDiWordAddress(lno, wno);

		nearestCloser = switch (^pairingStack) {
			EmptyList(): Triple("", BiDiWordAddress(length(text), 0), ^pairingStack);
			Cons(hd, tl): Triple(pairingC[hd.second], hd.first, tl);
		};
		// Assuming word splitting avoided more than one paired character in a word.
		switch(strFindFirstOfStrings(t, arrayPush(pairingO, nearestCloser.first))) {
			Some(p): pairingStack := if (p.second == pairingL) {
				pairings := setTree(^pairings, nearestCloser.second, Pair(^previousDM, currentAddr));
				nearestCloser.third
			} else
				Cons(Pair(currentAddr, p.second), ^pairingStack);
			None(): {};
		};

		tdm = getTextDirectionAndMajority(t);
		previousDM := if (tdm.d == uc_dir_coupled) ^previousDM else tdm;
		Pair(t, BiDiWord(w, tdm))
	}));
	// TODO: accumulate only those, which change the direction, not each major word.
	forwardMajorWords : ref List<Pair<BiDiWordAddress, DirectionAndMajority>> = ref foldi(
		reverseA(lines0),
		Cons(Pair(BiDiWordAddress(length(lines0), 0), defaultDM), EmptyList()),
		\rlno, lacc, line -> {
			lno = length(lines0) - 1 - rlno;
			foldi(reverseA(line), lacc, \rwno, wacc : Cons<Pair<BiDiWordAddress, DirectionAndMajority>>, word -> {
				wno = length(line) - 1 - rwno;
				curr = getWordDirectionAndMajority(word.second);
				if (curr.m == 2 && contains([uc_dir_ltr, uc_dir_rtl], curr.d)) Cons(Pair(BiDiWordAddress(lno, wno), curr), wacc) else wacc
			})
		}
	);
	/*findMajor : ref (List<Pair<BiDiWordAddress, DirectionAndMajority>>, BiDiWordAddress) -> DirectionAndMajority = ref \__, __ -> defaultDM;
	findMajor := \stk : List<Pair<BiDiWordAddress, DirectionAndMajority>>, adr : BiDiWordAddress -> switch(stk) {
		EmptyList(): defaultDM;
		Cons(h, t): if (h.first.lno > adr.lno || (h.first.lno == adr.lno && h.first.wno >= adr.wno)) h.second else (^findMajor)(t, adr);
	};*/

	previousDM := defaultDM;
	lines1 = mapi(lines0, \lno, l -> mapi(l, \wno, tw -> BiDiWord(tw.second with dm = {
		t = tw.first;
		currentAddr = BiDiWordAddress(lno, wno);
		// Splitters go into separate word, so the following is safe we don't miss any char.
		if (containsKeyTree(formatHandlers, strsubsmart(t, 0, 1))) {
			context.formattingStack := stringCharsFold(
				t, ^(context.formattingStack), \s, c -> lookupTreeDef(formatHandlers, c, \__, stack -> stack)(BiDiWordAddress(lno, wno), s)
			);
		};
		major = switch(^forwardMajorWords) {
			EmptyList(): Pair(BiDiWordAddress(length(lines0), 0), defaultDM);
			Cons(hd, tl): hd;
		};
		tdm = eitherMap(
			lookupTree(^pairings, currentAddr),
			\pair -> {
				pairings := removeFromTree(^pairings, currentAddr);
				if (are2AddrsOrdered(currentAddr, pair.second)) {
					// Opening pair, aggregate next major with already known previous major for closing one.
					dm = if (are2AddrsOrdered(major.first, pair.second)) pair.first else fold2DMs(pair.first, major.second);
					pairings := setTree(^pairings, pair.second, Pair(dm, currentAddr));
					dm
				} else {
					// Closing pair, DM is already calculated in opening one.
					pair.first
				}
			},
			tw.second.dm
		);
		tdmAgg = switch(^(context.formattingStack)) {
			Cons(head, __): if (tdm.m == 2) tdm else fold3DMs(head.dm, ^previousDM, tdm);
			EmptyList(): tdm;
		};
		if (contains([uc_dir_ltr, uc_dir_rtl], tdmAgg.d)) previousDM := tdmAgg;
		if (tdmAgg.d == uc_dir_coupled) ^previousDM else tdmAgg;
	})));
	println("lines1: \n"+superglue(lines1, \l -> superglue(l, \w -> debugWord(w, getText), ", "), "\n"));

	previousDM := defaultDM;
	lines = mapi(
		lines1, \lno, line -> unwrapLine(
			reflowWordsToBiDi(
				mapi(line, \wno, word -> {
					currentAddr = BiDiWordAddress(lno, wno);
					forwardMajorWords := switch(^forwardMajorWords) {
						EmptyList(): EmptyList();
						Cons(h, t): if (are2AddrsOrdered(h.first, currentAddr)) t else ^forwardMajorWords;
					};
					previousDM := if (word.dm.m >= 2) word.dm else ^previousDM;
					majorDM = switch(^forwardMajorWords) {
						EmptyList(): defaultDM;
						Cons(h, t): h.second;
					};
					BiDiWord(word with dm=elementAt([
						\-> fold3DMs(^previousDM, majorDM, defaultDM),
						\-> fold2DMs(majorDM, ^previousDM),
					], word.dm.m, \-> word.dm)());
				}) |> \q -> {
					println(superglue(q, \w -> debugWord(w, getText), ", "));
					q
				},
				isEmpty, getText, setText, rtl
			), setRTL
		)
	);
	lines
}

findListMajor(list: List<?>, getText: (?) -> string) -> List<?> {
	findpList(list, \__, el -> getTextDirectionAndMajority(getText(el)).m > 1);
}

findListMinor(list: List<?>, getText: (?) -> string) -> List<?> {
	findpList(list, \__, el -> getTextDirectionAndMajority(getText(el)).m <= 1);
}

getListDM(l: List<?>, getText: (?) -> string) -> DirectionAndMajority {
	rtl = getDefaultRtl();
	defaultDir = if (rtl) uc_dir_rtl else uc_dir_ltr;
	defaultDM = DirectionAndMajority(defaultDir, 2);
	switch(l) {
		EmptyList(): defaultDM;
		Cons(h, t): getTextDirectionAndMajority(getText(h))
	};
}

// Prepends ituple.first with a reversed list fragment from ituple.third to iiter.
markRange(iiter: List<?>, ituple: Triple<List<Pair<?, int>>, DirectionAndMajority, List<?>>, getText: (?) -> string)
-> Triple<List<Pair<?, int>>, DirectionAndMajority, List<?>> {
	rtl : bool= getDefaultRtl();
	defaultDir : int = if (rtl) uc_dir_rtl else uc_dir_ltr;
	fdir : int = ituple.second.d;
	lDM : DirectionAndMajority = getListDM(iiter, getText);
	dir : int = if (fdir == lDM.d) fdir else defaultDir;

	Triple(
		foldpList(
			ituple.third, Pair(true, ituple.first), \jiter : List<?>, jtuple : Pair<bool, List<Pair<?, int>>>, jw : ? -> {
				if (jtuple.first) {
					jwdm = getTextDirectionAndMajority(getText(jw));
					Pair(
						jiter != iiter,
						Cons(Pair(jw, if (jiter == iiter) lDM.d else if (jwdm.m<1) dir else jwdm.d), jtuple.second)
					)
				} else
					jtuple
			}
		).second,
		lDM,
		switch(iiter) {
			EmptyList(): EmptyList();
			Cons(__, nx): nx;
		},
	)
}

markListToBiDiReverse(list: List<?>, getText: (?) -> string) -> List<Pair<?, int>> {
	rtl = getDefaultRtl();
	defaultDir = if (rtl) uc_dir_rtl else uc_dir_ltr;
	defaultDM = DirectionAndMajority(defaultDir, 2);
	markRange(
		EmptyList(),
		foldpList(
			list,
			Triple(
				EmptyList(),
				defaultDM,
				list,
			),
			\iiter, ituple, iw -> {
				if (getTextDirectionAndMajority(getText(iw)).m <= 1) ituple else markRange(iiter, ituple, getText)
			}
		),
		getText
	).first;
}
