import ds/arrayutils;
import text/unicodecharacters;
import ui/fontmapping;
import formats/html/html;
import loop;

export {
	// TODO refactor due these are used to partial functionality, do not bring
	// semantically complete functionality, but used in some places, which
	// themselves may duplicate each other.
	// Seems text breaking algo needs to be implemented to replace
	// existing in paragraph.flow and tparagraph.flow.

	// Choose leftmost valid string position from two given.
	nextValidStrPos(left: int, right: int) -> int;

	// Determine where to split the text, based on unicode categories.
	getCharCatSplitPos(t: string, i: int, endPos: int) -> int;
	// END TODO

	DirectionAndMajority(d: int, m: int);

	getTextDirectionAndMajority(t: string) -> DirectionAndMajority;

	reflowTextToBiDi(text: [[?]], isEmpty: (?) -> bool, getText: (?) -> string, setText: (?, string) -> ?, setRTL: (?, bool) -> ?, rtl: bool) -> [[?]];

	// Returns a reversed list with elements of original list wrapped into a pair with text flow direction
	markListToBiDiReverse(list: List<?>, getText: (?) -> string) -> List<Pair<?, int>>;
}

BiDiContext(rtl: bool, formattingStack : ref List<BiDiFormatting>);

nextValidStrPos(left: int, right: int) -> int {
	if (left >= 0 && (right < 0 || left < right)) left else right;
}

getCharCatSplitPos(t: string, i: int, endPos: int) -> int {
	// TODO make these refs part of accumulator in stringFoldi.
	htmlEntity: ref int = ref -1;
	htmlTag: ref int = ref -1;
	stringFoldi(strSubRange(t, i, nextValidStrPos(endPos, strlen(t))), -1, \cur_pspi, pspacc, cur_pspcode -> {
		ppr_pspcode = getCharCodeAt("  "+t, cur_pspi+i);
		pre_pspcode = getCharCodeAt(" "+t, cur_pspi+i);
		if (^htmlEntity != -1) {
			if (pre_pspcode==59) {
				htmlEntity := -1;
				nextValidStrPos(pspacc, cur_pspi+i)
			} else if ((pre_pspcode != 35 && pre_pspcode != 38 && pre_pspcode < 48) || (pre_pspcode > 57 && pre_pspcode < 65) || (pre_pspcode > 90 && pre_pspcode < 97) || pre_pspcode > 122)
				nextValidStrPos(pspacc, cur_pspi+i+1)
			else
				pspacc
		} else if (pre_pspcode == 38) {
			htmlEntity := cur_pspi+i;
			pspacc;
		} else if (^htmlTag != -1) {
			if (pre_pspcode == 62) {
				nextValidStrPos(pspacc, cur_pspi+i)
			} else pspacc;
		} else if (pre_pspcode == 60) {
			htmlTag := cur_pspi+i;
			pspacc;
		} else {
			nxt_pspcode = getCharCodeAt(t+" ", cur_pspi+i+1);
			ppr_cat = getUnicodeCategory(ppr_pspcode);
			pre_cat = getUnicodeCategory(pre_pspcode);
			cur_cat = getUnicodeCategory(cur_pspcode);
			nxt_cat = getUnicodeCategory(nxt_pspcode);
			pre_alp = getUnicodeAlphabet(pre_pspcode);
			cur_alp = getUnicodeAlphabet(cur_pspcode);
			if (
				(isPunct(cur_cat) && !(contains([0x27, 0x2C, 0x2E], cur_pspcode) || pre_cat == uc_decimalDigitNumber || nxt_cat == uc_decimalDigitNumber)) ||
				(isPunct(pre_cat) && (cur_cat != uc_decimalDigitNumber || ppr_cat != uc_decimalDigitNumber)) ||
				(isPunct(cur_cat) && (pre_cat != uc_decimalDigitNumber || nxt_cat != uc_decimalDigitNumber)) ||

				(pre_alp != cur_alp) || (pre_cat == uc_spaceSeparator) || (cur_cat == uc_spaceSeparator) ||
				false
			)
				nextValidStrPos(pspacc, cur_pspi+i)
			else
				pspacc;
		}
	});
}

BiDiWord(word: ?, dm: DirectionAndMajority);
BiDiFormatting(kind : BiDiFormattingKind, dmf : () -> DirectionAndMajority);
	BiDiFormattingKind ::=
		BiDiPairedChar,
		BiDiDirectionMark, BiDiDirectionEmbedded,
		BiDiDirectionIsolated, BiDiDirectionOverridden;

		BiDiPairedChar();
		BiDiDirectionMark();
		BiDiDirectionEmbedded();
		BiDiDirectionIsolated();
		BiDiDirectionOverridden();  // Not supported yet.

makeBiDiContext(rtl : Maybe<bool>) -> BiDiContext {
	BiDiContext(eitherFn(rtl, idfn, getDefaultRtl), ref EmptyList())
}

_isLetter(ipcat) {
	ipcat == uc_uppercaseLetter || ipcat == uc_lowercaseLetter || ipcat == uc_titlecaseLetter || ipcat == uc_modifierLetter || ipcat == uc_otherLetter || ipcat == uc_nonSpacingMark;
}

isPunct(ipcat) {
	ipcat == uc_openPunctuation || ipcat == uc_closePunctuation || ipcat == uc_initialQuotePunctuation || ipcat == uc_finalQuotePunctuation || ipcat == uc_otherPunctuation;
}

mirrorWordGlyphsForRtl(s: string, rtl: bool) -> string {
	// We have our strings HTML-encoded, so additional replacements needed.
	COUPLED_MULTI_CHARS = if (js)
		["&lt;", "&gt;", "&#60;", "&#62;", "&#x3C;", "&#3E;", "&#x3c;", "&#3e;"]
	else
		[];

	if (rtl) {
		concatStrings(
			map(
				strSplit2(s, COUPLED_MULTI_CHARS),
				\frag -> eitherMap(
					findi(COUPLED_MULTI_CHARS, \el-> el==frag),
					\i -> COUPLED_MULTI_CHARS[if (0==i%2) i+1 else i-1], /* No XOR in flow for a pity */
					frag
				)
			)
		)
	} else s;
}

getCharDirectionAndMajority(code: int) -> DirectionAndMajority {
	cat = getUnicodeCategory(code);
	DirectionAndMajority(getUnicodeDirection(code), if (_isLetter(cat) || contains([0x200D, 0x202B, 0x202E], code)) 2 else b2i(cat == uc_decimalDigitNumber));
}

// Makes one DM pair from two, this function is fold helper.
fold2DMs(first: DirectionAndMajority, second: DirectionAndMajority) -> DirectionAndMajority {
	if (first.m > second.m) first else
	if (second.m > first.m) second else
	DirectionAndMajority(if (first.d == uc_dir_rtl || first.d == uc_dir_ltr) first.d else second.d, max(first.m, second.m));
}

// Makes one DM pair from three, third is default when first two are conflicting.
// Assuming third has RTL or LTR direction so the case is solved.
fold3DMs(first: DirectionAndMajority, second: DirectionAndMajority, third: DirectionAndMajority) -> DirectionAndMajority {
	if (first.m > second.m) first else
	if (second.m > first.m || second.d == first.d) second else
	DirectionAndMajority(
		if (first.d == uc_dir_rtl || first.d == uc_dir_ltr)
			if (second.d == uc_dir_rtl || second.d == uc_dir_ltr)
				third.d
			else
				first.d
		else 
			if (second.d == uc_dir_rtl || second.d == uc_dir_ltr)
				second.d
			else
				third.d,
		max(first.m, second.m)
	);
}

// Returns word direction and majority flag (meaning this direction to be inherited
// by adjacent words with no majority).
getTextDirectionAndMajority(t: string) -> DirectionAndMajority {
	stringFold(
		unescapeHtml(t), DirectionAndMajority(uc_dir_flow, 0), \acc: DirectionAndMajority, code: int ->
			fold2DMs(acc, getCharDirectionAndMajority(code))
	);
}

getWordDirectionAndMajority(w: BiDiWord<?>) -> DirectionAndMajority {w.dm}

getWordsDirectionAndMajority(ws: [BiDiWord<?>]) -> DirectionAndMajority {
	fold(map(ws, \w -> getWordDirectionAndMajority(w)), DirectionAndMajority(uc_dir_flow, 0), fold2DMs);
}

debugWord(w: BiDiWord<?>, getText: (?) -> string) -> string {
	ddm = \dm -> getCharAt("→~←:", dm.d) + toString(dm.m);
	getText(w.word) + ddm(w.dm);
}

groupByCounterDirReverse(ws: [BiDiWord<?>], rtl: bool, getText: (?) -> string) -> [[BiDiWord<?>]] {
	defaultDir = if (rtl) uc_dir_rtl else uc_dir_ltr;
	counterDir = if (rtl) uc_dir_ltr else uc_dir_rtl;
	(if (length(ws) < 2) [ws] else fold(
		tail(ws), Pair([[ws[0]]], getWordDirectionAndMajority(ws[0])), \acc: Pair<[[BiDiWord<?>]], DirectionAndMajority>, w: BiDiWord<?> -> {
			wdm = getWordDirectionAndMajority(w);
			Pair(
				if (acc.second.d == counterDir && acc.second.m > 1 && wdm.d != defaultDir)
					insertArray(tail(acc.first), 0, if (rtl) arrayPush(acc.first[0], w) else insertArray(acc.first[0], 0, w))
				else
					insertArray(acc.first, 0, [w]),
				if (wdm.m > 1) wdm else acc.second
			)
		}
	).first) |> \q -> {
		println(map(q, \r -> map(r, \s -> debugWord(s, getText))));
		q
	};
}

reflowWordsToBiDi(ws: [BiDiWord<?>], isEmpty: (?) -> bool, getText: (?) -> string, setText: (?, string) -> ?, rtl: bool) -> [BiDiWord<?>] {
	// Grouping words with counter-direction into subarrays, and reversing order.
	ltrGrouping = groupByCounterDirReverse(ws, rtl, getText);

	// Repeating same for each group and reverse them back — to cut group trailing punctuation, and counter-directed groups now in reverse order.
	ltrCleanGrouping = concatA(map(ltrGrouping, \lgws -> reverseA(groupByCounterDirReverse(lgws, rtl, getText))));

	// Filtering out empty fragments and joining all groups back together.
	r = filter(
		concatA(
			map(ltrCleanGrouping, \grp -> {
				grpdm = DirectionAndMajority(if ((length(unwrapLine(grp, \x, __ -> x)) == 1) == rtl) uc_dir_rtl else uc_dir_ltr, 0);
				map(grp, \w -> BiDiWord(setText(w.word, mirrorWordGlyphsForRtl(getText(w.word), (fold2DMs(grpdm, w.dm).d != uc_dir_ltr) == rtl)), w.dm));
			})
		),
		\w -> !isEmpty(w.word)
	);

	// Globally, text remains in reverse order after first operation, which only good for RTL.
	if (rtl) r else reverseA(r)
}

unwrapLine(l: [BiDiWord<?>], setRTL: (?, bool) -> ?) -> [?] {
	map(l, \w ->
		if (contains([uc_dir_ltr, uc_dir_rtl], w.dm.d)) setRTL(w.word, w.dm.d == uc_dir_rtl) else w.word
	);
}

reflowTextToBiDi(text: [[?]], isEmpty: (?) -> bool, getText: (?) -> string, setText: (?, string) -> ?, setRTL: (?, bool) -> ?, rtl: bool) -> [[?]] {
	defaultDM = DirectionAndMajority(if (rtl) uc_dir_rtl else uc_dir_ltr, 2);
	previousDM = ref defaultDM;

	context = makeBiDiContext(Some(rtl));
	stackPasser = \keyChar, dir, kind : [BiDiFormattingKind], fn -> Pair(
		keyChar,
		\stack -> fn(dir, kind, stack)
	);
	formattingMark = \dmf, __, stack : List<BiDiFormatting> -> Cons(BiDiFormatting(BiDiDirectionMark(), dmf), switch(stack) {
		Cons(head, t): switch(head.kind) {
			BiDiDirectionMark(): t;
			default: stack
		};
		EmptyList(): stack
	});
	formattingPush = \dmf, kind : [BiDiFormattingKind], stack -> {
		Cons(BiDiFormatting(kind[0], dmf), stack);
	}
	formattingPop = \dmf, kind : [BiDiFormattingKind], stack -> tailList(updateWhile(stack, \s -> switch(s : List<BiDiFormatting>) {
		EmptyList(): None();
		Cons(head, t): if (contains(kind, head.kind)) {
			if (head.kind == BiDiPairedChar()) {
				previousDM := DirectionAndMajority(head.dmf() with m=3);
				Some(t);
			} else None()
		} else Some(t);
	}));
	formatHandlers = pairs2tree(concat3(
		stringCharsFold("([{", [], \a, c -> {saved = ^previousDM; arrayPush(a, stackPasser(c, \-> saved, [BiDiPairedChar()], formattingPush))}),
		stringCharsFold(")]}", [], \a, c -> arrayPush(a, stackPasser(c, \-> DirectionAndMajority(uc_dir_flow, 0), [BiDiPairedChar()], formattingPop))),
		[
			// Implemented isolated and marks as most useful yet.
			stackPasser("\u200E", \-> DirectionAndMajority(uc_dir_ltr, 3), [BiDiDirectionMark()], formattingMark),
			stackPasser("\u200F", \-> DirectionAndMajority(uc_dir_rtl, 3), [BiDiDirectionMark()], formattingMark),
			stackPasser("\u2066", \-> DirectionAndMajority(uc_dir_ltr, 3), [BiDiDirectionIsolated()], formattingPush),
			stackPasser("\u2067", \-> DirectionAndMajority(uc_dir_rtl, 3), [BiDiDirectionIsolated()], formattingPush),
			stackPasser("\u2069", \-> DirectionAndMajority(uc_dir_flow, 3), [BiDiDirectionIsolated()], formattingPop),
			// TODO no good support yet, the Overridden behaves the same, but also shows chars in memory order,
			//      Embedded must also somehow differ from Isolated.
			//stackPasser("\u202A", uc_dir_ltr, [BiDiDirectionEmbedded()], formattingPush),
			//stackPasser("\u202B", uc_dir_rtl, [BiDiDirectionEmbedded()], formattingPush),
			//stackPasser("\u202C", uc_dir_flow, [BiDiDirectionEmbedded(), BiDiDirectionOverridden()], formattingPop),
			//stackPasser("\u202D", uc_dir_ltr, [BiDiDirectionOverridden()], formattingPush),
			//stackPasser("\u202E", uc_dir_rtl, [BiDiDirectionOverridden()], formattingPush),
		]
	));
	lines0 = map(text, \l -> map(l, \w -> BiDiWord(w, {
		t = getText(w);
		// Splitters go into separate word, so the following is safe we don't miss any char.
		if (containsKeyTree(formatHandlers, strsubsmart(t, 0, 1))) {
			context.formattingStack := stringCharsFold(
				t, ^(context.formattingStack), \s, c -> lookupTreeDef(formatHandlers, c, idfn)(s)
			);
		};
		tdm = getTextDirectionAndMajority(t);
		tdmAgg = switch(^(context.formattingStack)) {
			Cons(head, __): if (((^previousDM)).m == 3) DirectionAndMajority(^previousDM with m=2) else if (tdm.m == 2) tdm else fold3DMs(head.dmf(), ^previousDM, tdm);
			EmptyList(): tdm;
		};
		if (contains([uc_dir_ltr, uc_dir_rtl], tdmAgg.d)) previousDM := tdmAgg;
		if (tdmAgg.d == uc_dir_coupled) ^previousDM else tdmAgg;
	})));
	lines = lines0;
	// TODO: accumulate only those, which change the direction, not each major word.
	forwardMajorWords = ref foldi(
		reverseA(lines),
		Cons(Triple(length(lines), 0, defaultDM), EmptyList()),
		\rlno, lacc, line -> {
			lno = length(lines) - 1 - rlno;
			foldi(reverseA(line), lacc, \rwno, wacc : Cons<Triple<int, int, DirectionAndMajority>>, word -> {
				wno = length(line) - 1 - rwno;
				curr = getWordDirectionAndMajority(word);
				if (curr.m == 2 && contains([uc_dir_ltr, uc_dir_rtl], curr.d)) Cons(Triple(lno, wno, curr), wacc) else wacc
			})
		}
	);

	previousDM := defaultDM;
	mapi(
		lines, \lno, line -> unwrapLine(
			reflowWordsToBiDi(
				mapi(line, \wno, word -> {
					forwardMajorWords := switch(^forwardMajorWords) {
						EmptyList(): EmptyList();
						Cons(h, t): if (lno > h.first || (lno == h.first && wno > h.second)) t else ^forwardMajorWords;
					};
					previousDM := if (word.dm.m >= 2) word.dm else ^previousDM;
					majorDM = switch(^forwardMajorWords) {
						EmptyList(): DirectionAndMajority(1, 0);
						Cons(h, t): h.third;
					};
					BiDiWord(word.word, fold3DMs(majorDM, ^previousDM, fold2DMs(word.dm, defaultDM)));
				}),
				isEmpty, getText, setText, rtl
			), setRTL
		)
	);
}

findListMajor(list: List<?>, getText: (?) -> string) -> List<?> {
	findpList(list, \__, el -> getTextDirectionAndMajority(getText(el)).m > 1);
}

findListMinor(list: List<?>, getText: (?) -> string) -> List<?> {
	findpList(list, \__, el -> getTextDirectionAndMajority(getText(el)).m <= 1);
}

getListDM(l: List<?>, getText: (?) -> string) -> DirectionAndMajority {
	rtl = getDefaultRtl();
	defaultDir = if (rtl) uc_dir_rtl else uc_dir_ltr;
	defaultDM = DirectionAndMajority(defaultDir, 2);
	switch(l) {
		EmptyList(): defaultDM;
		Cons(h, t): getTextDirectionAndMajority(getText(h))
	};
}

// Prepends ituple.first with a reversed list fragment from ituple.third to iiter.
markRange(iiter: List<?>, ituple: Triple<List<Pair<?, int>>, DirectionAndMajority, List<?>>, getText: (?) -> string)
-> Triple<List<Pair<?, int>>, DirectionAndMajority, List<?>> {
	rtl : bool= getDefaultRtl();
	defaultDir : int = if (rtl) uc_dir_rtl else uc_dir_ltr;
	fdir : int = ituple.second.d;
	lDM : DirectionAndMajority = getListDM(iiter, getText);
	dir : int = if (fdir == lDM.d) fdir else defaultDir;

	Triple(
		foldpList(
			ituple.third, Pair(true, ituple.first), \jiter : List<?>, jtuple : Pair<bool, List<Pair<?, int>>>, jw : ? -> {
				if (jtuple.first) {
					jwdm = getTextDirectionAndMajority(getText(jw));
					Pair(
						jiter != iiter,
						Cons(Pair(jw, if (jiter == iiter) lDM.d else if (jwdm.m<1) dir else jwdm.d), jtuple.second)
					)
				} else
					jtuple
			}
		).second,
		lDM,
		switch(iiter) {
			EmptyList(): EmptyList();
			Cons(__, nx): nx;
		},
	)
}

markListToBiDiReverse(list: List<?>, getText: (?) -> string) -> List<Pair<?, int>> {
	rtl = getDefaultRtl();
	defaultDir = if (rtl) uc_dir_rtl else uc_dir_ltr;
	defaultDM = DirectionAndMajority(defaultDir, 2);
	markRange(
		EmptyList(),
		foldpList(
			list,
			Triple(
				EmptyList(),
				defaultDM,
				list,
			),
			\iiter, ituple, iw -> {
				if (getTextDirectionAndMajority(getText(iw)).m <= 1) ituple else markRange(iiter, ituple, getText)
			}
		),
		getText
	).first;
}
