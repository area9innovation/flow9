import runtime;
import ds/dlist;

export {
	FrpCell<?> ::= FrpConst<?>, FrpValue<?>;
	FrpNode<?> ::= FrpCell<?>, FrpArray<?>;

	FrpConst(value : ?);

	FrpValue(
		value : ref ?,
		status : ref bool,
		subscribers : DList<(FrpEventType) -> void>,
		disposers : ref List<() -> void>
	);

	FrpArray(
		values : ref [ref ?],
		status : ref bool,
		subscribers : DList<(FrpEventType) -> void>,
		disposers : ref List<() -> void>
	);

	// construcrors
	rconst(v : ?) -> FrpConst<?>;
	rmake(v : ?) -> FrpValue<?>;
	rmakeA(elements : [?]) -> FrpArray<?>;

	// getters
	rget(cell : FrpCell<?>) -> ?;
	rgetA(v : FrpArray<?>) -> [?];
	rgetElement(v : FrpArray<?>, index : int) -> Maybe<?>;
	rArrayLength(v : FrpArray<?>) -> int;

	// update
	rnext(cell : FrpValue<?>, value : ?) -> void;

	rnext2(
		cell1 : FrpValue<?>,
		cell2 : FrpValue<??>,
		value1 : ?, value2 : ??
	) -> void;

	rnext3(
		cell1 : FrpValue<?>,
		cell2 : FrpValue<??>,
		cell3 : FrpValue<???>,
		value1 : ?,
		value2 : ??,
		value3 : ???
	) -> void;

	rnext4(
		cell1 : FrpValue<?>,
		cell2 : FrpValue<??>,
		cell3 : FrpValue<???>,
		cell4 : FrpValue<????>,
		value1 : ?,
		value2 : ??,
		value3 : ???,
		value4 : ????,
	) -> void;

	rnextMany(updates : [Pair<FrpValue<?>, ?>]) -> void;
	rnextManyFlow(updates : [Pair<FrpValue<flow>, flow>]) -> void;

	rnextA(cell : FrpArray<?>, values : [?]) -> void;
	rnextElement(cell : FrpArray<?>, index : int, value : ?) -> void;

	rnextVA(cell1 : FrpValue<?>, cell2 : FrpArray<??>, value1 : ?, value2 : [??]) -> void;

	// connectors

	rconnect(
		src : FrpCell<?>,
		dst : FrpValue<??>,
		init : bool,
		fn : (?) -> ??,
	) -> void;

	rconnect2(
		src1 : FrpCell<?>,
		src2 : FrpCell<??>,
		dst : FrpValue<??>,
		init : bool,
		fn : (?, ??) -> ???,
	) -> void;

	rconnect3(
		src1 : FrpCell<?>,
		src2 : FrpCell<??>,
		src3 : FrpCell<???>,
		dst : FrpValue<????>,
		init : bool,
		fn : (?, ??, ???) -> ????,
	) -> void;

	rconnect4(
		src1 : FrpCell<?>,
		src2 : FrpCell<??>,
		src3 : FrpCell<???>,
		src4 : FrpCell<????>,
		dst : FrpValue<?????>,
		init : bool,
		fn : (?, ??, ???, ????) -> ?????,
	) -> void;

	rconnectMany(
		sources : [FrpCell<?>],
		dst : FrpValue<??>,
		init : bool,
		fn : ([?]) -> ??,
	) -> void;

	rconnectGate(
		src : FrpCell<?>,
		gate : FrpCell<??>,
		dst : FrpValue<???>,
		init : bool,
		gateFn : (??) -> bool,
		valueFn : (?) -> ???
	) -> void;

	rconnectA(
		src : FrpArray<?>,
		dst : FrpValue<??>,
		init : bool,
		fn : ([?]) -> ??,
	) -> void;

	rconnectARange(
		src : FrpArray<?>,
		dst : FrpValue<??>,
		start : int,
		count : int,
		init : bool,
		fn : ([?]) -> ??,
	) -> void;

	rconnectAMap(
		src : FrpArray<?>,
		dst : FrpArray<??>,
		init : bool,
		fn : (?) -> ??,
	) -> void;

	rconnectARangeMap(
		src : FrpArray<?>,
		dst : FrpArray<??>,
		start : int,
		count : int,
		init : bool,
		fn : (?) -> ??,
	) -> void;

	rconnectARangeDynamic(
		src : FrpArray<?>,
		start : FrpCell<int>,
		count : FrpCell<int>,
		dst : FrpValue<??>,
		init : bool,
		fn : ([?]) -> ??,
	) -> void;

	rconnectARangeMapDynamic(
		src : FrpArray<?>,
		start : FrpCell<int>,
		count : FrpCell<int>,
		dst : FrpArray<??>,
		init : bool,
		fn : (?) -> ??,
	) -> void;

	// rconnectAZip combine 2 arrays into one dst array using fn
	// if sources lengths are different then dst get minimum length of both src
	rconnectAZip(
		src1 : FrpArray<?>,
		src2 : FrpArray<??>,
		dst : FrpArray<???>,
		init : bool,
		fn : (?, ??) -> ???,
	) -> void;

	// rconnectAZipRange works similarly to rconnectAZip
	// but you can specify ranges of elements using start1, start2, count
	// count < 0 means using full src arrays lengths
	// if sources lengths are different then dst get minimum length of both src
	rconnectAZipRange(
		src1 : FrpArray<?>,
		src2 : FrpArray<??>,
		dst : FrpArray<???>,
		start1 : int,
		start2 : int,
		count : int,
		init : bool,
		fn : (?, ??) -> ???,
	) -> void;

	rBidiConnect(
		cell1 : FrpValue<?>,
		cell2 : FrpValue<??>,
		init : bool,
		fn1 : (?) -> ??,
		fn2 : (??) -> ?
	) -> void;

	// selectors

	rselect(
		src : FrpCell<?>,
		fn : (?) -> ??
	) -> FrpValue<??>;

	rselect2(
		src1 : FrpCell<?>,
		src2 : FrpCell<??>,
		fn : (?, ??) -> ???
	) -> FrpValue<???>;

	rselect3(
		src1 : FrpCell<?>,
		src2 : FrpCell<??>,
		src3 : FrpCell<???>,
		fn : (?, ??, ???) -> ????
	) -> FrpValue<????>;

	rselect4(
		src1 : FrpCell<?>,
		src2 : FrpCell<??>,
		src3 : FrpCell<???>,
		src4 : FrpCell<????>,
		fn : (?, ??, ???, ????) -> ?????
	) -> FrpValue<????>;

	rselectMany(
		sources : [FrpCell<?>],
		fn : ([?]) -> ??
	) -> FrpValue<??>;

	rselectGate(
		src : FrpCell<?>,
		gate : FrpCell<??>,
		gateFn : (??) -> bool,
		valueFn : (?) -> ???,
	) -> FrpValue<???>;

	rBidiSelect(
		cell : FrpValue<?>,
		fn1 : (?) -> ??,
		fn2 : (??) -> ?
	) -> FrpValue<??>;

	rselectA(
		src : FrpArray<?>,
		fn : ([?]) -> ??
	) -> FrpValue<??>;

	rselectARange(
		src : FrpArray<?>,
		start : int,
		count : int,
		fn : ([?]) -> ??
	) -> FrpValue<??>;

	rselectAMap(
		src : FrpArray<?>,
		fn : (?) -> ??
	) -> FrpArray<??>;

	rselectARangeMap(
		src : FrpArray<?>,
		start : int,
		count : int,
		fn : (?) -> ??
	) -> FrpArray<??>;

	rselectARangeDynamic(
		src : FrpArray<?>,
		start : FrpCell<int>,
		count : FrpCell<int>,
		fn : ([?]) -> ??
	) -> FrpValue<??>;

	rselectARangeMapDynamic(
		src : FrpArray<?>,
		start : FrpCell<int>,
		count : FrpCell<int>,
		fn : (?) -> ??
	) -> FrpArray<??>;

	rselectAZip(
		src1 : FrpArray<?>,
		src2 : FrpArray<??>,
		fn : (?, ??) -> ???
	) -> FrpArray<???>;

	rselectAZipRange(
		src1 : FrpArray<?>,
		src2 : FrpArray<??>,
		start1 : int,
		start2 : int,
		count : int,
		fn : (?, ??) -> ???
	) -> FrpArray<???>;

	// splitters

	rsplit2(
		cell : FrpCell<?>,
		fn1 : (?) -> ??,
		fn2 : (?) -> ???
	) -> Pair<FrpValue<??>, FrpValue<???>>;

	rsplit3(
		cell : FrpCell<?>,
		fn1 : (?) -> ??,
		fn2 : (?) -> ???,
		fn3 : (?) -> ????,
	) -> Triple<FrpValue<??>, FrpValue<???>, FrpValue<????>>;

	rsplit4(
		cell : FrpCell<?>,
		fn1 : (?) -> ??,
		fn2 : (?) -> ???,
		fn3 : (?) -> ????,
		fn4 : (?) -> ?????
	) -> Quadruple<FrpValue<??>, FrpValue<???>, FrpValue<????>, FrpValue<?????>>;

	rsplitMany(cell : FrpCell<?>, getters: [(?) -> ??]) -> [FrpValue<??>];
	rsplitManyFlow(cell : FrpCell<?>, getters : [(?) -> flow]) -> [FrpValue<flow>];

	// subscribers
	rsubscribe(
		cell : FrpValue<?>,
		init : bool,
		fn : (?) -> void,
	) -> () -> void;

	rsubscribe2(
		cell1 : FrpValue<?>,
		cell2 : FrpValue<??>,
		init : bool,
		fn : (?, ??) -> void,
	) -> () -> void;

	rsubscribe3(
		cell1 : FrpValue<?>,
		cell2 : FrpValue<??>,
		cell3 : FrpValue<???>,
		init : bool,
		fn : (?, ??, ???) -> void,
	) -> () -> void;

	rsubscribe4(
		cell1 : FrpValue<?>,
		cell2 : FrpValue<??>,
		cell3 : FrpValue<???>,
		cell4 : FrpValue<????>,
		init : bool,
		fn : (?, ??, ???, ????) -> void,
	) -> () -> void;

	rsubscribeMany(
		cells : [FrpValue<?>],
		init : bool,
		fn : ([?]) -> void,
	) -> () -> void;

	rsubscribeA(
		cell : FrpArray<?>,
		init : bool,
		fn : ([?]) -> void,
	) -> () -> void;

	rsubscribeARange(
		cell : FrpArray<?>,
		start : int,
		count : int,
		init : bool,
		fn : ([?]) -> void,
	) -> () -> void;

	// disconnectors
	rdisconnect(cell : FrpNode<flow>) -> void;
	rdisconnectMany(cell : [FrpNode<flow>]) -> void;

	// a protected part, is not part of public api, to use in other frp modules or tests ///////////
	rIsUpdated(cell : FrpNode<flow>) -> bool;
	rAddDisposer(cell : FrpNode<flow>, disposerFn : () -> void) -> void;
	rSetOutdated(cell : FrpNode<flow>) -> void;
	rAddEventListeners(cells : [FrpNode<flow>], eventFn : (FrpEventType) -> void) -> () -> void;

	rsubscribeNotify(
		cells : [FrpNode<flow>],
		init : bool,
		onUpdate : () -> void,
	) -> () -> void;
}

FrpEventType ::= FrpEventSetValue, FrpEventOutdated, FrpEventUpdated, FrpEventSetElement;
FrpEventSetValue(); FrpEventOutdated(); FrpEventUpdated(); FrpEventSetElement(index : int);
/*
The FrpEventSetElement event is added to support some optimization in typical cases like update one array element.
Anyway, FrpArray connections must support for FrpEventSetValue event, that must work in any cases but maybe less effective.
Also, this optimization works only if a cell have only one FrpArray source.
*/

dummyFrpArray = rmakeA([]);

//// constructors ////

rconst(v : ?) -> FrpConst<?> {
	FrpConst(v);
}

rmake(v : ?) -> FrpValue<?> {
	FrpValue(ref v, ref true, makeDList(), ref makeList());
}

rmakeA(elements : [?]) -> FrpArray<?> {
	FrpArray(ref map(elements, \a -> ref a), ref true, makeDList(), ref makeList());
}

//// disconnector /////

rdisconnect(cell : FrpNode<flow>) -> void {
	doDisconn = \disposers -> {
		callList(^disposers);
		disposers := makeList();
	}
	switch (cell) {
		FrpConst(__): {}
		FrpValue(__, __, __, disposers): doDisconn(disposers);
		FrpArray(__, __, __, disposers): doDisconn(disposers);
	}
}

rdisconnectMany(cells : [FrpNode<flow>]) -> void {
	iter(cells, rdisconnect);
}

//// getters ////

rget(cell : FrpCell<?>) -> ? {
	switch (cell) {
		FrpConst(v): v;
		FrpValue(v, __, __, __): ^v;
	}
}

rgetA(v : FrpArray<?>) -> [?] {
	map(^(v.values), \r -> ^r);
}

rgetElement(v : FrpArray<?>, index : int) -> Maybe<?> {
	r = ^(v.values);
	if (index >=0 && index < length(r)) Some(^(r[index])) else None();
}

rArrayLength(v : FrpArray<?>) -> int {
	length(^(v.values));
}


//// setters ////

rnext(cell : FrpValue<?>, value : ?) -> void {
	rSetOutdated(cell);
	rSetValue(cell, value);
}

rnextA(cell : FrpArray<?>, values : [?]) -> void {
	rSetOutdated(cell);
	rSetValuesA(cell, values);
}

rnextElement(cell : FrpArray<?>, index : int, value : ?) -> void {
	rSetOutdated(cell);
	rSetElement(cell, index, value);
}


rnext2(cell1 : FrpValue<?>, cell2 : FrpValue<??>, value1 : ?, value2 : ??) -> void {
	rSetOutdated(cell1);
	rSetOutdated(cell2);
	rSetValue(cell1, value1);
	rSetValue(cell2, value2);
}

rnext3(
	cell1 : FrpValue<?>,
	cell2 : FrpValue<??>,
	cell3 : FrpValue<???>,
	value1 : ?,
	value2 : ??,
	value3 : ???
) -> void {
	rSetOutdated(cell1);
	rSetOutdated(cell2);
	rSetOutdated(cell3);
	rSetValue(cell1, value1);
	rSetValue(cell2, value2);
	rSetValue(cell3, value3);
}

rnext4(
	cell1 : FrpValue<?>,
	cell2 : FrpValue<??>,
	cell3 : FrpValue<???>,
	cell4 : FrpValue<????>,
	value1 : ?,
	value2 : ??,
	value3 : ???,
	value4 : ????,
) -> void {
	rSetOutdated(cell1);
	rSetOutdated(cell2);
	rSetOutdated(cell3);
	rSetOutdated(cell4);
	rSetValue(cell1, value1);
	rSetValue(cell2, value2);
	rSetValue(cell3, value3);
	rSetValue(cell4, value4);
}

rnextMany(updates : [Pair<FrpValue<?>, ?>]) -> void {
	iter(updates, unpairC(\cell,__ -> rSetOutdated(cell)));
	iter(updates, unpairC(\cell,value -> rSetValue(cell, value)));
}

rnextManyFlow(updates : [Pair<FrpValue<flow>, flow>]) -> void {
	iter(updates, unpairC(\cell,__ -> rSetOutdated(cell)));
	iter(updates, unpairC(\cell,value -> rSetValue(cell, value)));
}


rnextVA(cell1 : FrpValue<?>, cell2 : FrpArray<??>, value1 : ?, value2 : [??]) -> void {
	rSetOutdated(cell1);
	rSetOutdated(cell2);
	rSetValue(cell1, value1);
	rSetValuesA(cell2, value2);
}


//// subscribers ////

rsubscribe(
	cell : FrpValue<?>,
	init : bool,
	fn : (?) -> void,
) -> () -> void {
	rsubscribeCommon([cell], init, FrpUpdateFnSimple(\-> fn(rget(cell))));
}

rsubscribe2(
	cell1 : FrpValue<?>,
	cell2 : FrpValue<??>,
	init : bool,
	fn : (?, ??) -> void,
) -> () -> void {
	rsubscribeCommon([cell1, cell2], init, FrpUpdateFnSimple(\-> fn(rget(cell1), rget(cell2))));
}

rsubscribe3(
	cell1 : FrpValue<?>,
	cell2 : FrpValue<??>,
	cell3 : FrpValue<???>,
	init : bool,
	fn : (?, ??, ???) -> void,
) -> () -> void {
	rsubscribeCommon([cell1, cell2, cell3], init,
		FrpUpdateFnSimple(\-> fn(rget(cell1), rget(cell2), rget(cell3))));
}

rsubscribe4(
	cell1 : FrpValue<?>,
	cell2 : FrpValue<??>,
	cell3 : FrpValue<???>,
	cell4 : FrpValue<????>,
	init : bool,
	fn : (?, ??, ???, ????) -> void,
) -> () -> void {
	rsubscribeCommon([cell1, cell2, cell3, cell4], init,
		FrpUpdateFnSimple(\-> fn(rget(cell1), rget(cell2), rget(cell3), rget(cell4))));
}

rsubscribeMany(
	cells : [FrpValue<?>],
	init : bool,
	fn : ([?]) -> void,
) -> () -> void {
	rsubscribeCommon(cells, init, FrpUpdateFnSimple(\-> fn(map(cells, rget))));
}

rsubscribeA(
	cell : FrpArray<?>,
	init : bool,
	fn : ([?]) -> void,
) -> () -> void {
	rsubscribeCommon([cell], init, FrpUpdateFnSimple(\-> fn(rgetA(cell))));
}

rsubscribeARange(
	cell : FrpArray<?>,
	start : int,
	count : int,
	init : bool,
	fn : ([?]) -> void,
) -> () -> void {
	onUpdate = \inx : int -> {
		if (inx < 0 || inx >= start && inx < start + count)
			fn(rArrayValuesSubrange(cell, start, count));
	}
	rsubscribeCommon([cell], init, FrpUpdateFnArray(onUpdate));
}

//// connectors ////

rconnect(
	src : FrpCell<?>,
	dst : FrpValue<??>,
	init : bool,
	fn : (?) -> ??,
) -> void {
	rconnectCommon([src], dst, init, FrpUpdateFnSimple(\-> rSetValue(dst, fn(rget(src)))));
}

rconnect2(
	src1 : FrpCell<?>,
	src2 : FrpCell<??>,
	dst : FrpValue<??>,
	init : bool,
	fn : (?, ??) -> ???,
) -> void {
	rconnectCommon([src1, src2], dst, init,
		FrpUpdateFnSimple(\-> rSetValue(dst, fn(rget(src1), rget(src2)))));
}

rconnect3(
	src1 : FrpCell<?>,
	src2 : FrpCell<??>,
	src3 : FrpCell<???>,
	dst : FrpValue<????>,
	init : bool,
	fn : (?, ??, ???) -> ????,
) -> void {
	rconnectCommon([src1, src2, src3], dst, init,
		FrpUpdateFnSimple(\-> rSetValue(dst, fn(rget(src1), rget(src2), rget(src3)))));
}

rconnect4(
	src1 : FrpCell<?>,
	src2 : FrpCell<??>,
	src3 : FrpCell<???>,
	src4 : FrpCell<????>,
	dst : FrpValue<?????>,
	init : bool,
	fn : (?, ??, ???, ????) -> ?????,
) -> void {
	rconnectCommon([src1, src2, src3, src4], dst, init,
		FrpUpdateFnSimple(\-> rSetValue(dst, fn(rget(src1), rget(src2), rget(src3), rget(src4)))));
}

rconnectMany(
	sources : [FrpCell<?>],
	dst : FrpValue<??>,
	init : bool,
	fn : ([?]) -> ??,
) -> void {
	rconnectCommon(sources, dst, init,
		FrpUpdateFnSimple(\-> rSetValue(dst, fn(map(sources, rget)))));
}

rconnectGate(
	src : FrpCell<?>,
	gate : FrpCell<??>,
	dst : FrpValue<???>,
	init : bool,
	gateFn : (??) -> bool,
	valueFn : (?) -> ???
) -> void {
	rconnectCommon([src, gate], dst, init,
		FrpUpdateFnSimple(\-> if (gateFn(rget(gate))) rSetValue(dst, valueFn(rget(src))) else rSetUpdated(dst)));
}

rconnectA(
	src : FrpArray<?>,
	dst : FrpValue<??>,
	init : bool,
	fn : ([?]) -> ??,
) -> void {
	rconnectCommon([src], dst, init, FrpUpdateFnSimple(\-> rSetValue(dst, fn(rgetA(src)))));
}

rconnectARange(
	src : FrpArray<?>,
	dst : FrpValue<??>,
	start : int,
	count : int,
	init : bool,
	fn : ([?]) -> ??,
) -> void {
	updateFn = \updElmIndex : int -> {
		setVal = \-> rSetValue(dst, fn(rArrayValuesSubrange(src, start, count)));

		if (updElmIndex < 0) setVal()
		else if (updElmIndex >= start && updElmIndex < start + count) setVal()
		else rSetUpdated(dst);
	}

	rconnectCommon([src], dst, init, FrpUpdateFnArray(updateFn));
}

rconnectARangeMap(
	src : FrpArray<?>,
	dst : FrpArray<??>,
	start : int,
	count : int,
	init : bool,
	fn : (?) -> ??,
) -> void {
	updateFn = \updElmIndex : int -> {
		if (updElmIndex < 0 || rArrayLength(dst) != count) {
			rRangeMap(src, start, count, dst, fn)
		} else if (updElmIndex >= start && updElmIndex < start + count) {
			rMapElement(src, updElmIndex, dst, updElmIndex - start, fn)
		} else rSetUpdated(dst);
	}

	rconnectCommon([src], dst, init, FrpUpdateFnArray(updateFn));
}

rconnectAMap(
	src : FrpArray<?>,
	dst : FrpArray<??>,
	init : bool,
	fn : (?) -> ??,
) -> void {
	updateFn = \updElmIndex : int -> {
		if (updElmIndex < 0 || rArrayLength(dst) != rArrayLength(src)) {
			rRangeMap(src, 0, -1, dst, fn)
		} else {
			rMapElement(src, updElmIndex, dst, updElmIndex, fn)
		}
	}

	rconnectCommon([src], dst, init, FrpUpdateFnArray(updateFn));
}

rconnectARangeDynamic(
	src : FrpArray<?>,
	start : FrpCell<int>,
	count : FrpCell<int>,
	dst : FrpValue<??>,
	init : bool,
	fn : ([?]) -> ??,
) -> void {
	updateFn = \updateArr : [Pair<int,int>] -> {
		srcUpdPairM = find(updateArr, \p -> p.first == 0);
		inx = eitherMap(srcUpdPairM, secondOfPair, -1); // updated element index, -1 means  whole array is updated
		fv = rget(start);
		cv = rget(count);

		if (inx < 0 || inx >= fv && inx < fv + cv) rSetValue(dst, fn(rArrayValuesSubrange(src, fv, cv)))
		else rSetUpdated(dst);
	}

	rconnectCommon([src, start, count], dst, init, FrpUpdateFnEx(updateFn));
}

rconnectARangeMapDynamic(
	src : FrpArray<?>,
	start : FrpCell<int>,
	count : FrpCell<int>,
	dst : FrpArray<??>,
	init : bool,
	fn : (?) -> ??,
) -> void {
	updateFn = \updateArr : [Pair<int,int>] -> {
		srcUpdPairM = find(updateArr, \p -> p.first == 0);
		inx = eitherMap(srcUpdPairM, secondOfPair, -1); // updated element index, -1 means  whole array is updated
		fv = rget(start);
		cv = rget(count);

		if (inx < 0 || rArrayLength(dst) != cv) rRangeMap(src, fv, cv, dst, fn)
		else if (inx >= fv && inx < fv + cv) rMapElement(src, inx, dst, inx - fv, fn)
		else rSetUpdated(dst);
	}

	rconnectCommon([src, start, count], dst, init, FrpUpdateFnEx(updateFn));
}

rconnectAZip(
	src1 : FrpArray<?>,
	src2 : FrpArray<??>,
	dst : FrpArray<???>,
	init : bool,
	fn : (?, ??) -> ???,
) -> void {
	updateFn = \updateArr : [Pair<int,int>] -> {
		upd1 = find(updateArr, \p -> p.first == 0);
		upd2 = find(updateArr, \p -> p.first == 1);
		inx1 = eitherMap(upd1, secondOfPair, -1);
		inx2 = eitherMap(upd2, secondOfPair, -1);
		slen = min(rArrayLength(src1), rArrayLength(src2));

		fullUpd = isSome(upd1) && inx1 < 0 || isSome(upd2) && inx2 < 0
		|| isSome(upd1) && isSome(upd2) && inx1 != inx2
		|| rArrayLength(dst) != slen;

		if (fullUpd) rZipArrays(src1, src2, dst, fn)
		else rZipElement(src1, inx1, src2, inx1, dst, inx1, fn); // inx1 == inx2 == dst inx
	}

	rconnectCommon([src1, src2], dst, init, FrpUpdateFnEx(updateFn));
}


rconnectAZipRange(
	src1 : FrpArray<?>,
	src2 : FrpArray<??>,
	dst : FrpArray<???>,
	start1 : int,
	start2 : int,
	count : int, // -1 means use whole arrays from start1 and start2 indexes to the array end
	init : bool,
	fn : (?, ??) -> ???,
) -> void {
	updateFn = \updateArr : [Pair<int,int>] -> {
		upd1 = find(updateArr, \p -> p.first == 0); // src1
		upd2 = find(updateArr, \p -> p.first == 1); // src2
		scount = min(rArrayLength(src1) - start1, rArrayLength(src2) - start2);

		if (scount <= 0) {
			rnextA(dst, []);
		} else {
			doUpdate = \inx1,inx2,dstInx -> {
				if (dstInx >= 0) rZipElement(src1, inx1, src2, inx2, dst, dstInx, fn)
				else rZipRange(src1, src2, dst, start1, start2, count, fn);
			}

			slen = if (count < 0) scount else min(count, scount);

			if (rArrayLength(dst) != slen) {
				doUpdate(-1, -1, -1); // mostly for dst initialization
			} else if (isSome(upd1) && isSome(upd2)) {
				inx1 = eitherMap(upd1, secondOfPair, -1);
				inx2 = eitherMap(upd2, secondOfPair, -1);
				// inx1,2 < 0 means whole array is updated
				dinx1 = if (inx1 >= 0) inx1 - start1 else -1;
				dinx2 = if (inx2 >= 0) inx2 - start2 else -1;
				dstInx = if (dinx1 >= 0 && dinx2 >= 0 && dinx1 == dinx2) dinx1 else -1;
				doUpdate(inx1, inx2, dstInx);
			} else if (isSome(upd1)) {
				inx1 = eitherMap(upd1, secondOfPair, -1);
				dstInx = if (inx1 >= 0) inx1 - start1 else -1;
				inx2 = if (dstInx >= 0) dstInx + start2 else -1;
				doUpdate(inx1, inx2, dstInx);
			} else { // isSome(upd2)
				inx2 = eitherMap(upd2, secondOfPair, -1);
				dstInx = if (inx2 >= 0) inx2 - start2 else -1;
				inx1 = if (dstInx >= 0) dstInx + start1 else -1;
				doUpdate(inx1, inx2, dstInx);
			}
		}
	}

	rconnectCommon([src1, src2], dst, init, FrpUpdateFnEx(updateFn));
}


rBidiConnect(
	cell1 : FrpValue<?>,
	cell2 : FrpValue<??>,
	init : bool,
	fn1 : (?) -> ??,
	fn2 : (??) -> ?
) -> void {
	update = ref false;

	fn11 = \event : FrpEventType -> {
		if (!^update) {
			update := true;
			switch(event) {
				FrpEventSetValue(): if (rIsUpdated(cell1)) rSetValue(cell2, fn1(rget(cell1)));
				FrpEventUpdated(): rSetUpdated(cell2);
				FrpEventOutdated(): rSetOutdated(cell2);
				FrpEventSetElement(inx): {}
			}
			update := false;
		}
	};

	fn22 = \event : FrpEventType -> {
		if (!^update) {
			update := true;
			switch(event) {
				FrpEventSetValue(): if (rIsUpdated(cell2)) rSetValue(cell1, fn2(rget(cell2)));
				FrpEventUpdated(): rSetUpdated(cell1);
				FrpEventOutdated(): rSetOutdated(cell1);
				FrpEventSetElement(inx): {}
			}
			update := false;
		}
	};

	if (init) {// set cell2 by cell1 value
		fn11(FrpEventOutdated());
		fn11(FrpEventSetValue());
	}

	uns1 = rAddEventListeners([cell1], fn11);
	rAddDisposer(cell2, uns1);
	uns2  = rAddEventListeners([cell2], fn22);
	rAddDisposer(cell1, uns2);
}


//// selectors ////

rselect(
	src : FrpCell<?>,
	fn : (?) -> ??
) -> FrpValue<??> {
	dst = rmake(fn(rget(src)));
	rconnect(src, dst, false, fn);
	dst;
}

rselect2(
	src1 : FrpCell<?>,
	src2 : FrpCell<??>,
	fn : (?, ??) -> ???
) -> FrpValue<???> {
	dst = rmake(fn(rget(src1), rget(src2)));
	rconnect2(src1, src2, dst, false, fn);
	dst;
}

rselect3(
	src1 : FrpCell<?>,
	src2 : FrpCell<??>,
	src3 : FrpCell<???>,
	fn : (?, ??, ???) -> ????
) -> FrpValue<????> {
	dst = rmake(fn(rget(src1), rget(src2), rget(src3)));
	rconnect3(src1, src2, src3, dst, false, fn);
	dst;
}

rselect4(
	src1 : FrpCell<?>,
	src2 : FrpCell<??>,
	src3 : FrpCell<???>,
	src4 : FrpCell<????>,
	fn : (?, ??, ???, ????) -> ?????
) -> FrpValue<????> {
	dst = rmake(fn(rget(src1), rget(src2), rget(src3), rget(src4)));
	rconnect4(src1, src2, src3, src4, dst, false, fn);
	dst;
}

rselectMany(
	sources : [FrpCell<?>],
	fn : ([?]) -> ??
) -> FrpValue<??> {
	dst = rmake(fn(map(sources, rget)));
	rconnectMany(sources, dst, false, fn);
	dst;
}

rselectGate(
	src : FrpCell<?>,
	gate : FrpCell<??>,
	gateFn : (??) -> bool,
	valueFn : (?) -> ???,
) -> FrpValue<???> {
	dst = rmake(valueFn(rget(src)));
	rconnectGate(src, gate, dst, false, gateFn, valueFn);
	dst;
}

rBidiSelect(
	cell : FrpValue<?>,
	fn1 : (?) -> ??,
	fn2 : (??) -> ?
) -> FrpValue<??> {
	dst = rmake(fn1(rget(cell)));
	rBidiConnect(cell, dst, false, fn1, fn2);
	dst;
}

rselectA(
	src : FrpArray<?>,
	fn : ([?]) -> ??
) -> FrpValue<??> {
	dst = rmake(fn(rgetA(src)));
	rconnectA(src, dst, false, fn);
	dst;
}

rselectARange(
	src : FrpArray<?>,
	start : int,
	count : int,
	fn : ([?]) -> ??
) -> FrpValue<??> {
	dst = rmake(fn(rArrayValuesSubrange(src, start, count)));
	rconnectARange(src, dst, start, count, false, fn);
	dst;
}

rselectAMap(
	src : FrpArray<?>,
	fn : (?) -> ??
) -> FrpArray<??> {
	dst = rmakeA(map(rgetA(src), fn));
	rconnectAMap(src, dst, false, fn);
	dst;
}

rselectARangeMap(
	src : FrpArray<?>,
	start : int,
	count : int,
	fn : (?) -> ??
) -> FrpArray<??> {
	dst = rmakeA(map(rArrayValuesSubrange(src, start, count), fn));
	rconnectARangeMap(src, dst, start, count, false, fn);
	dst;
}

rselectARangeDynamic(
	src : FrpArray<?>,
	start : FrpCell<int>,
	count : FrpCell<int>,
	fn : ([?]) -> ??
) -> FrpValue<??> {
	dst = rmake(fn(rArrayValuesSubrange(src, rget(start), rget(count))));
	rconnectARangeDynamic(src, start, count, dst, false, fn);
	dst;
}

rselectARangeMapDynamic(
	src : FrpArray<?>,
	start : FrpCell<int>,
	count : FrpCell<int>,
	fn : (?) -> ??
) -> FrpArray<??> {
	dst = rmakeA(map(rArrayValuesSubrange(src, rget(start), rget(count)), fn));
	rconnectARangeMapDynamic(src, start, count, dst, false, fn);
	dst;
}

rselectAZip(
	src1 : FrpArray<?>,
	src2 : FrpArray<??>,
	fn : (?, ??) -> ???
) -> FrpArray<???> {
	dst = rmakeA([]);
	rZipRangeARef(src1.values, src2.values, dst.values, 0, 0, -1, fn) |> ignore;
	rconnectAZip(src1, src2, dst, false, fn);
	dst;
}

rselectAZipRange(
	src1 : FrpArray<?>,
	src2 : FrpArray<??>,
	start1 : int,
	start2 : int,
	count : int,
	fn : (?, ??) -> ???
) -> FrpArray<???> {
	dst = rmakeA([]);
	rZipRangeARef(src1.values, src2.values, dst.values, start1, start2, count, fn) |> ignore;
	rconnectAZipRange(src1, src2, dst, start1, start2, count, false, fn);
	dst;
}

//// splitters ////

rsplit2(
	cell : FrpCell<?>,
	fn1 : (?) -> ??,
	fn2 : (?) -> ???
) -> Pair<FrpValue<??>, FrpValue<???>> {
	Pair(rselect(cell, fn1), rselect(cell, fn2));
}

rsplit3(
	cell : FrpCell<?>,
	fn1 : (?) -> ??,
	fn2 : (?) -> ???,
	fn3 : (?) -> ????,
) -> Triple<FrpValue<??>, FrpValue<???>, FrpValue<????>> {
	Triple(rselect(cell, fn1), rselect(cell, fn2), rselect(cell, fn3));
}

rsplit4(
	cell : FrpCell<?>,
	fn1 : (?) -> ??,
	fn2 : (?) -> ???,
	fn3 : (?) -> ????,
	fn4 : (?) -> ?????
) -> Quadruple<FrpValue<??>, FrpValue<???>, FrpValue<????>, FrpValue<?????>> {
	Quadruple(rselect(cell, fn1), rselect(cell, fn2), rselect(cell, fn3), rselect(cell, fn4));
}

rsplitMany(cell : FrpCell<?>, getters: [(?) -> ??]) -> [FrpValue<??>] {
	map(getters, \fn -> rselect(cell, fn));
}

rsplitManyFlow(cell : FrpCell<?>, getters : [(?) -> flow]) -> [FrpValue<flow>] {
	map(getters, \fn -> rselect(cell, fn));
}

//// utils and helpers ////////////////////////////////////////////////////////////////////

// selecting a simplest fn type, suitable for your case, can help to avoid extra memory allocations
FrpUpdateFn ::= FrpUpdateFnSimple, FrpUpdateFnCells, FrpUpdateFnArray, FrpUpdateFnEx;
FrpUpdateFnSimple(fn : () -> void);
FrpUpdateFnCells(fn : ([int]/*updated cells*/) -> void);
FrpUpdateFnArray(fn : (index : int) -> void); // index - updated element, -1 means that whole array is updated
FrpUpdateFnEx(fn : ([Pair<int/*cellInx*/, int/*elementInx*/>]) -> void);

rsubscribeInternal(
	cells : [FrpNode<flow>],
	init : bool,
	updateFn : FrpUpdateFn,
	onStatusChange : (bool) -> void,
) -> () -> void {
	updatedCells = map(cells, \__ -> ref false);
	updatedElements = map(cells, \__ -> ref -1);
	startUpdate = \-> iteri(cells, \i,__ -> {updatedCells[i] := false; updatedElements[i] := -1;});
	hasUpdates = \-> exists(updatedCells, \r -> ^r);

	updateValue = rMakeUpdateFn(updatedCells, updatedElements, updateFn);

	fn = \cellInx, event : FrpEventType -> {
		switch(event) {
			FrpEventSetValue(): {
				updatedCells[cellInx] := true;

				if (forall(cells, rIsUpdated)) updateValue();
				// else waite for update all sources
			}
			FrpEventSetElement(elementInx): {
				updatedCells[cellInx] := true;
				updatedElements[cellInx] := elementInx;

				if (forall(cells, rIsUpdated)) updateValue();
				// else waite for update all sources
			}
			FrpEventUpdated():  {
				if (forall(cells, rIsUpdated)) {
					if (hasUpdates()) updateValue() else onStatusChange(true);
				} // else waiting for update all sources
			}
			FrpEventOutdated(): {
				startUpdate();
				onStatusChange(false);
			};
		}
	};

	if (init) { // run fn on subscribe
		onStatusChange(false);
		if (forall(cells, rIsUpdated)) updateValue();
	}

	rAddEventListenersEx(mapi(cells, \i,cell -> Pair(cell, \evt -> fn(i, evt))));
}

rMakeUpdateFn(updatedCells : [ref bool], updatedElements : [ref int], updateFn : FrpUpdateFn) -> () -> void {
	switch(updateFn) {
		FrpUpdateFnSimple(fn): fn;
		FrpUpdateFnCells(fn): {
			\-> fn(
				filtermapi(updatedCells,
					\i,updFlag -> if (^updFlag) Some(i) else None())
			);
		}
		FrpUpdateFnArray(fn): \-> fn(if (length(updatedElements) > 0) ^(updatedElements[0]) else -1);
		FrpUpdateFnEx(fn): {
			\-> fn(
				filtermapi(updatedCells,
					\i,updFlag -> if (^updFlag) Some(Pair(i, ^(updatedElements[i]))) else None())
			);
		}
	}
}

rsubscribeNotify(
	cells : [FrpNode<flow>],
	init : bool,
	onUpdate : () -> void,
) -> () -> void {
	rsubscribeCommon(cells, init, FrpUpdateFnSimple(onUpdate));
}


rsubscribeCommon(
	cells : [FrpNode<flow>],
	init : bool,
	onValueUpdate : FrpUpdateFn
) -> () -> void {
	rsubscribeInternal(cells, init, onValueUpdate, nop1);
}

rconnectCommon(
	sources : [FrpNode<flow>],
	dst : FrpNode<flow>,
	init : bool,
	updateFn : FrpUpdateFn
) -> void {
	updateStatus = \st -> rSetStatus(dst, st);
	uns = rsubscribeInternal(sources, init, updateFn, updateStatus);
	rAddDisposer(dst, uns);
}

rIsUpdated(cell : FrpNode<flow>) -> bool {
	switch (cell) {
		FrpConst(__): true;
		FrpValue(__, status, __, __): ^status;
		FrpArray(__, status, __, __): ^status;
	}
}

rSetStatus(cell : FrpNode<flow>, status : bool) -> void {
	setFn = \statRef -> {
		if (^statRef != status) {// distinct update, prevent cycles
			statRef := status;
			rNotify(cell, if (status) FrpEventUpdated() else FrpEventOutdated());
		}
	}
	switch(cell) {
		FrpConst(__): {};
		FrpValue(__, st, __, __): setFn(st);
		FrpArray(__, st, __, __): setFn(st);
	}
}

rSetValue(cell : FrpValue<?>, value : ?) -> void {
	update = ^(cell.value) != value;
	if (update) cell.value := value;
	rSetUpdatedAndNotify(cell, update);
}

rSetElement(cell : FrpArray<?>, index : int, value : ?) -> void {
	values = ^(cell.values);
	setFn = \st -> {// distinct update - prevent loops
		if (index >= 0 && index < length(values) && ^(values[index]) != value) {// value updated
			values[index] := value;
			st := true;
			rNotify(cell, FrpEventSetElement(index));
		} else if (!^(st)) { // update status only
			st := true;
			rNotify(cell, FrpEventUpdated());
		} // else  nothing to do
	}
	switch(cell) {
		FrpConst(__): {};
		FrpValue(__,st,__,__): setFn(st);
		FrpArray(__,st,__,__): setFn(st);
	}
}

rSetUpdatedAndNotify(cell : FrpNode, updated : bool) -> void {
	setFn = \st -> {
		if (updated) {// value updated
			st := true;
			rNotify(cell, FrpEventSetValue());
		} else if (!^(st)) { // distinct update, prevent cycles
			st := true;
			rNotify(cell, FrpEventUpdated());
		} // else do nothing
	}
	switch(cell) {
		FrpConst(__): {};
		FrpValue(__,st,__,__): setFn(st);
		FrpArray(__,st,__,__): setFn(st);
	}
}

rSetOutdated(cell : FrpNode<flow>) -> void {
	rSetStatus(cell, false);
}

rSetUpdated(cell : FrpNode<flow>) -> void {
	rSetStatus(cell, true);
}

rSetValuesA(cell : FrpArray<?>, elements : [?]) -> void {
	values = ^(cell.values);

	updated =
		if (length(values) != length(elements)) {// re-create array
			cell.values := map(elements, \e -> ref e);
			true;
		} else if (!eqArrayRefValues(values, elements)) {//update elements
			iteri(values, \i,v ->  v := elements[i]);
			true;
		} else {
			false;
		}
	rSetUpdatedAndNotify(cell, updated);
}

rRangeMap(
	src : FrpArray<?>,
	start : int,
	count : int,
	dst : FrpArray<??>,	fn : (?) -> ??
) -> void {
	dstUpdated = rRangeMapARef(src.values, start, count, dst.values, fn);
	rSetUpdatedAndNotify(dst, dstUpdated);
}

rZipArrays(
	src1 : FrpArray<?>,
	src2 : FrpArray<??>,
	dst : FrpArray<???>,
	fn : (?,??) -> ???
) -> void {
	dstUpdated = rZipRangeARef(src1.values, src2.values, dst.values, 0, 0, -1, fn);
	rSetUpdatedAndNotify(dst, dstUpdated);
}

rZipRange(
	src1 : FrpArray<?>,
	src2 : FrpArray<??>,
	dst : FrpArray<???>,
	start1 : int,
	start2 : int,
	count : int, // count2 < 0 means use full length
	fn : (?,??) -> ???
) -> void {
	dstUpdated = rZipRangeARef(src1.values, src2.values, dst.values, start1, start2, count, fn);
	rSetUpdatedAndNotify(dst, dstUpdated);
}


rZipElement(
	src1 : FrpArray<?>,
	srcIndex1 : int,
	src2 : FrpArray<??>,
	srcIndex2 : int,
	dst : FrpArray<???>,
	dstIndex : int,
	fn : (?,??) -> ???
) -> void {
	newValM =
		maybeBind(rgetElement(dst, dstIndex),
			\oldVal -> maybeBind(rgetElement(src1, srcIndex1),
				\v1 -> maybeBind(rgetElement(src2, srcIndex2),
					\v2 -> Some(fn(v1, v2)))));

	eitherFn(
		newValM,
		\v -> rSetElement(dst, dstIndex, v),
		\-> rSetUpdated(dst) // fallback for wrong index
	);
}

rMapElement(
	src : FrpArray<?>,
	srcIndex : int,
	dst : FrpArray<??>,
	dstIndex : int,	fn : (?) -> ??,
) -> void {
	svals = ^(src.values);

	if (srcIndex >= 0 && srcIndex < length(svals)) {
		newVal = fn(^(svals[srcIndex]));
		rSetElement(dst, dstIndex, newVal);
	}
}

// notification utils and listeners /////////////////////
rNotify(cell : FrpNode<flow>, event : FrpEventType) -> void {
	switch(cell) {
		FrpConst(__): {};
		FrpValue(__, __, subs, __): iterDList(subs, \fn -> fn(event));
		FrpArray(__, __, subs, __): iterDList(subs, \fn -> fn(event));
	}
}

rAddEventListener(src: FrpNode<flow>, eventFn : (FrpEventType) -> void) -> () -> void {
	switch(src) {
		FrpConst(__): nop;
		FrpValue(__, __, subs, __): rAddEventListenerInternal(subs, eventFn);
		FrpArray(__, __, subs, __): rAddEventListenerInternal(subs, eventFn);
	}
}

rAddEventListeners(cells : [FrpNode<flow>], eventFn : (FrpEventType) -> void) -> () -> void {
	map(cells,\r -> rAddEventListener(r, eventFn))
	|> (\arr -> filter(arr, \fn -> fn != nop))
	|> (\arr -> \-> applyall(arr));
}

rAddEventListenersEx(listeners : [Pair<FrpNode<flow>, (FrpEventType) -> void>]) -> () -> void {
	map(listeners, unpairC(\cell, eventFn -> rAddEventListener(cell, eventFn)))
	|> (\arr -> filter(arr, \fn -> fn != nop))
	|> (\arr -> \-> applyall(arr));
}

rAddDisposer(cell : FrpNode<flow>, disposerFn : () -> void) -> void {
	switch(cell) {
		FrpConst(__): {};
		FrpValue(__, __, __, disposers): rAddDisposerInternal(disposers, disposerFn);
		FrpArray(__, __, __, disposers): rAddDisposerInternal(disposers, disposerFn);
	}
}

rAddEventListenerInternal(subs : DList<(FrpEventType) -> void>, eventFn : (FrpEventType) -> void) -> () -> void {
	dl = pushDList(subs, eventFn);
	\-> removeDList(subs, dl);
}

rAddDisposerInternal(disposers : ref List<() -> void>, fn : () -> void) -> void {
	disposers :=  Cons(fn, ^disposers);
}

// low-level utils for FrpArray /////////////////////////////////////////////////////////

eqArrayRefValues(arr1 : [ref ?], arr2 : [?]) -> bool {
	length(arr1) == length(arr2) && {
		last = iteriUntil(arr1, \i,r -> ^r != arr2[i]);
		last == length(arr1);
	}
}

eqArrayRefValues2(arr1 : [ref ?], arr2 : [ref ?]) -> bool {
	length(arr1) == length(arr2) && {
		last = iteriUntil(arr1, \i,r -> ^r != ^(arr2[i]));
		last == length(arr1);
	}
}

rArrayValuesSubrange(cell : FrpArray<?>, start : int, count : int) -> [?] {
	subrange(^(cell.values), start, count)
	|> (\arr -> map(arr, \r -> ^r));
}


rRangeMapARef(
	src : ref [ref ?],
	start : int,
	count : int, // -1 means from start till end
	dst : ref [ref ??],
	fn : (?) -> ??
) -> bool {
	slen = length(^src);
	dlen = length(^dst);
	count2 = if (count < 0) slen - start else min(count, slen - start);

	updated = ref false;

	if (start >= slen) {
		dst := [];
		updated := true;
	} else if (dlen == count2) {//update elements in the place
		svals = ^src;
		iteri(^dst, \i,r -> {
			newVal = fn(^(svals[start + i]));
			if (!^updated && newVal != ^r) {
				// try to avoid comparing values ​​because in many cases it is very expensive
				updated := true;// update dependencies if any element updated
			}
			r := newVal;
		});
	} else {// re-create dst
		src2 = subrange(^src, start, count2);
		dst := map(src2, \r -> ref fn(^r));
		updated := true;
	}

	^updated;
}


rZipRangeARef(
	src1 : ref [ref ?],
	src2 : ref [ref ??],
	dst : ref [ref ???],
	start1 : int,
	start2 : int,
	count : int, // count2 < 0 means from start till end
	fn : (?,??) -> ???
) -> bool {
	updated = ref false;

	vals1 = ^src1;
	vals2 = ^src2;
	len1 = length(vals1);
	len2 = length(vals2);
	slen1 = if (count < 0) len1 - start1 else min(count, len1 - start1);
	slen2 = if (count < 0) len2 - start2 else min(count, len2 - start2);

	dlen = length(^dst);
	slen = min(slen1, slen2);

	if (slen == dlen) {//update in the place
		iteri(^dst, \i,r -> {
			newVal = fn(^(vals1[i + start1]), ^(vals2[i + start2]));
			if (!^updated && newVal != ^r) {
				// try to avoid comparing values ​​because in many cases it is very expensive
				updated := true;// update dependencies if any element updated
			}
			r := newVal;
		});
	} else {// re-create dst
		dst := generate(0, slen, \i -> ref fn(^(vals1[i + start1]), ^(vals2[i + start2])));
		updated := true;
	}

	^updated;
}
