import wigi/editor_types;
import wigi/paragraph_control;
import wigi/escaping;
import wigi/recursive_event;
import wigi/block;
import wigi/modify;
import paragraph;
import formtransforms;
import wigi/table_control;
import wigi/styles;
import wigi/editor_control;
import wigi/spellcheck;
import wigi/recursive;

export {
	makeWigiElementView(state : WigiEditorState, parentView : ParentView, namespace : WigiScope,
			element : WigiElement, preview : bool, registerToEngine : bool) -> WigiView;
}

/*
 Construct a view of this element.
 Since stories can change their position in the document tree without reconstructing, we use a parent view structure
 to learn where this element is placed in the document tree, as well as provide services to the child.

 Each view promises to handle mouse events inside it itself - if necessary, through it's own children.
 Also, views have to monitor the global state.event behaviour to implement some cursor movements if they own the cursor.
 */

updateStyleInParentView(defaultStyles : [WigiStyles], parentView : ParentView, element : WigiElement) -> ParentView {
	ParentView(
		parentView.getPath,
		parentView.getParentCoordinate,
		parentView.local2globalCoordinate,
		parentView.setParentCursor,
		\ -> concatWigiParentStyles(parentView.getStyle(), getDefaultElementStyle(defaultStyles, element)),
		parentView.getTM
	)
}

makeWigiElementView(state : WigiEditorState, parentView : ParentView, namespace : WigiScope,
			element : WigiElement, preview : bool, registerToEngine : bool) -> WigiView {
	newParentView = updateStyleInParentView(state.defaultStyles, parentView, element);

	switch (element : WigiElement) {
		WigiDocument(root, style): {
			localNamespace = refineWigiNamespace(namespace, style);
			makeWigiElementView(state, ParentView(
					\ -> arrayPush(newParentView.getPath(), 0),
					newParentView.getParentCoordinate,
					newParentView.local2globalCoordinate,
					newParentView.setParentCursor,
					newParentView.getStyle,
					newParentView.getTM
				), localNamespace, root, preview, registerToEngine);
		}
		WigiStory(paragraphs, views, style): {
			localNamespace = refineWigiNamespace(namespace, style);
			makeWigiStoryView(state, newParentView, localNamespace, paragraphs, views, style, preview, registerToEngine);
		}
		WigiParagraph(elements, style): {
			localNamespace = refineWigiNamespace(namespace, style);
			makeWigiParagraphView(state, newParentView, localNamespace, element, preview, registerToEngine);
		}
		WigiText(text, style): {
			// TODO: If the cursor is here, do something
			// Above, we try to wrap this in a paragraph ourselves to inherit all that nice behaviour
			// but there are editing problems. Therefore, use this non-editable version
			// This stuff also breaks on editing.
			textStyle = concatWigiTextStyles(parentView.getStyle().textStyle, style);
			zoomedCharStyle = getCharacterStyleFromWigiTextStyle(zoomFontSize(getValue(state.zoom), textStyle));
			f = Text(escapeHtml(text), zoomedCharStyle); // Outside a Paragraph context, a text is not wrapping
			WigiView(
				\ -> f,
				\ -> {
					fm = getStaticFormSize(f);
					WidthHeight(fm.width, fm.height)
				},
				\p, selecting, mouse -> {
					// TODO: Place the cursor somewhere
					false
				},
				\p -> {
					Point(0.0, 0.0)
				},
				// getWigiView
				\p, v -> v,
				// TODO: Should we handle events somehow?
				\e -> false,
			)
		}
		WigiEmpty(): WigiView(\ -> Empty(), \ -> zeroWH, \p, selecting, mouse -> false, \p -> Point(0.0, 0.0), \p, v -> v, \e -> false);
		WigiRecursive(elements, tag, style): {
			localNamespace = refineWigiNamespace(namespace, style);
			makeWigiRecursiveView(state, newParentView, localNamespace, element, preview, registerToEngine);
		}
		WigiBlock(type, style): {
			localNamespace = refineWigiNamespace(namespace, style);
			makeWigiBlockView(state, newParentView, localNamespace, element, registerToEngine)
			|> (\view -> addLockHighlightToView(state, view, element));
		}
	}
}

makeWigiStoryView(state : WigiEditorState, parentView : ParentView, namespace : WigiScope, paragraphs : ref [WigiElement], views : ref [TropicArray<WigiElement>], style : [WigiStoryStyle], preview : bool, registerToEngine : bool) -> WigiView {
	storyViews : ref Tree<int, WigiView> = ref makeTree();

	ps = extractStruct(style, dwps).d;

	localSetCursor = \array : TropicArray<WigiElement>, p, selecting, isMouseEvent -> {
		// We need to place the cursor at the given point.
		// Find if one of our children owns that point
		n = lengthTropicArray(array);
		child = findStoryChild(array, 0, n, p, WidthHeight(getValue(state.viewSize).width, 0.0), ^storyViews, ps);
		if (child == -1) {
			// Could not find it - send to our parent
			pc = parentView.getParentCoordinate(p);
			parentView.setParentCursor(pc, selecting, isMouseEvent);
		} else {
			// We found our child - send it to that in the child coordinate system
			childSize = getStoryPartSize(array, 0, child, zeroWH, ^storyViews, ps);
			childPoint = Point(p.x, p.y - childSize.height);
			// Find our child method to set the cursor, and do it
			childId = getTropicArrayId(array, child);
			childView = lookupTree(^storyViews, childId);
			switch (childView) {
				None(): false;
				Some(view): {
					view.setCursor(Point(childPoint.x, max(childPoint.y, 0.0)), selecting, isMouseEvent);
					true
				}
			}
		}
	};

	parentPath = parentView.getPath();
	cellPath = subrange(parentPath, 0, length(parentPath) - 1);
	defaultSize = Pair(makeWH(), false);
	size = if (cellPath != []) {
		cell = getElementAtPosition(getValue(state.document), cellPath);
		switch (cell) {
			WigiRecursive(__, type, __): {
				switch (type) {
					WigiTableCell(wh, __): Pair(wh, true);
					WigiSpreadsheetCell(wh, __, __): Pair(wh, true);
					default: defaultSize;
				}
			}
			default: defaultSize;
		}
	} else defaultSize;

	// Construct a view here
	view = makeTropicArray(^paragraphs, \index, id, el, array -> {
		// Converts a child coordinate to our system
		child2local = \p -> {
			// Find out how big the children area
			childNo = getTropicArrayIndex(array, id);
			wh = getStoryPartSize(array, 0, childNo, zeroWH, ^storyViews, ps);
			Point(p.x, wh.height + p.y);
		};

		v = makeWigiElementView(state,
			ParentView(
				// getPath
				\ -> {
					// println("Get path for story: " + toString(getPath()));
					arrayPush(parentView.getPath(), getTropicArrayIndex(array, id))
				},
				// getParentCoordinate
				child2local,
				// local2globalCoordinate
				\p -> {
					// println("Story local " + toString(p) + " to global " + toString(parentView.local2globalCoordinate(child2local(p))));
					parentView.local2globalCoordinate(child2local(p))
				},
				// setParentCursor
				\p, selecting, mouse -> localSetCursor(array, p, selecting, mouse),
				// parent's styles
				parentView.getStyle,
				parentView.getTM
			), namespace, el, preview, registerToEngine
		);
		// We save the child infos here
		storyViews := setTree(^storyViews, id, v);

		s = switch (el) {
			WigiParagraph(__, s): s;
			default: [];
		};

		fullStyle = getWigiParagraphStyleFull(state.defaultStyles, el, [], s);

		form = Border(0.0, 0.0, 0.0, ps, v.form());
		TFormAvailable(
			if (size.second && contains(fullStyle, TightWidth()) && (contains(fullStyle, RightAlign()) || contains(fullStyle, CenterAlign()))) {
				aw = make(1000.0);
				awh = make(WidthHeight(1000.0, 1000.0));

				Constructor(
					Inspect([IAvailable(awh)], Available(aw, const(1000.0), form)),
					\ -> {
						rendered = make(false);
						deferUntilRender(\ -> next(rendered, true));
						select4u(rendered, loadingContentFilesCount, size.first, awh, \r, lpc, mw, _awh -> {
							if (r && lpc <= 0) nextDistinct(aw, 1.0 + min(mw.width, _awh.width))
						}).second;
					}
				);
			} else form,
			TFillXY()
		);
	}, TLinesCombiner(), state.updateTropicArray);

	form = \ -> {
		Constructor(
			tropic2nativeForm(view.tropic, emptyStylesheet),
			\ -> {
				// Be sure to clean up the old view on destruction
				refArrayPush(views, view);
				\ -> {
					views := removeFirst(^views, view);
				}
			}
		)
	}

	WigiView(
		form,
		// getSize of this guy
		\ -> {
			n = lengthTropicArray(view);
			getStoryPartSize(view, 0, n, zeroWH, ^storyViews, ps)
		},
		// Place the cursor at this local coordinate
		\p, selecting, mouse -> {
			localSetCursor(view, p, selecting, mouse);
		},
		// Get the global coordinate for this *relative* path
		\path -> {
			if (length(path) > 0 ) {
				child = path[0];
				childId = getTropicArrayId(view, child);
				childView = lookupTree(^storyViews, childId);
				switch(childView) {
					None(): {
						parentView.local2globalCoordinate(Point(0.0, 0.0));
					}
					Some(cv): {
						cv.getGlobalCoordinate(tail(path));
					}
				}
			} else {
				parentView.local2globalCoordinate(Point(0.0, 0.0));
			}
		},
		// getWigiView
		\path : [int], v : WigiView -> {
			if (length(path) > 0 ) {
				child = path[0];
				childId = getTropicArrayId(view, child);
				if (childId != -1) {
					childView = lookupTree(^storyViews, childId);

					switch (childView) {
						None(): {
							println("getWigiView is empty for " + i2s(childId));
							v;
						}
						Some(cv): cv.getWigiView(tail(path), cv);
					}
				} else {
					v
				}
			} else {
				v;
			}
		},
		// Handle events
		\e : WigiEvent -> {
			// TODO: We should handle events here?
			false;
		}
	);
}

// How big is the first `index` elements of this array? Starting from `i` with accumulated size `acc`
getStoryPartSize(formarray : TropicArray<WigiElement>, i : int, index : int, acc : WidthHeight, storyViews : Tree<int, WigiView>, spacing : double) -> WidthHeight {
	if (i == index) acc
	else {
		id = getTropicArrayId(formarray, i);
		view = lookupTree(storyViews, id);
		wh = switch (view) {
			None(): zeroWH;
			Some(v): v.getSize();
		}
		nacc = WidthHeight(max(acc.width, wh.width), acc.height + wh.height + spacing);
		getStoryPartSize(formarray, i + 1, index, nacc, storyViews, spacing);
	}
}

// What story index owns the point p?
findStoryChild(array : TropicArray<WigiElement>, i : int, n : int, p : Point, acc : WidthHeight, storyViews : Tree<int, WigiView>, spacing : double) -> int {
	if (i == n || p.x < 0.0 || p.y < 0.0) -1
	else {
		id = getTropicArrayId(array, i);
		view = lookupTree(storyViews, id);
		wh = switch (view) {
			None(): zeroWH;
			Some(v): v.getSize();
		}

		// Looks like we shouldn't be adding spacing here, because we accumulate it in the recursive call and the first
		// paragraph doesn't have it.
		nacc = WidthHeight(max(acc.width, wh.width), acc.height + wh.height);
		if (p.x < nacc.width && p.y < nacc.height) i
		else findStoryChild(array, i + 1, n, p, WidthHeight(nacc.width, nacc.height + spacing), storyViews, spacing)
	}
}

TextViewAcc(
	// The form to view
	p : ParagraphElement,
	// The view
	view : WigiView,
	// Clean up this view
	disposer : () -> void,
	// Measure the distance to a given point in local coordinates
	pointDistance : (Point) -> PathDistance,
	// Find the point of this local index
	index2point : (int) -> Point,
);

// The view of a paragraph
makeWigiParagraphView(state : WigiEditorState, parentView : ParentView, namespace : WigiScope, element : WigiParagraph, preview : bool, registerToEngine : bool) -> WigiView {
	cursorInside = makeInitialPosition();
	selectionStartInside = makeInitialPosition();
	selectionEndInside = makeInitialPosition();

	click = make(CursorClick(-1.0, -1.0, false, false, 0.0));
	clicksHistory = ref [];

	wh = makeWH();
	// Set the cursor at this point in local coordinates - sending it to the parent if outside our bounds
	setCursorFn = makeCursorSetter(state, parentView, wh, cursorInside, click);

	view = make(Empty());
	childViews : ref [TextViewAcc] = ref [];
	fullySelected = make(false);

	paragraphBorder = extractStruct(element.style, ParagraphBorder(0.0, 0.0));

	form = \ -> Constructor(
		Interactive(makeParagraphHandlers(state, parentView, wh, click, element.style),
			Group([
				Select(state.hasKeyboardFocus, \focus -> {
					if (focus || state.highlightUnfocusedSelection)
						evMakeSelectionForm(fullySelected, wh, element, selectionStartInside, selectionEndInside, focus)
					else
						Empty()
				}),
				Inspect([ISize(wh)], Mutable(view))
			])
		),
		\ -> {
			// Be sure to clean up on disposal of this form again
			disposers : ref [() -> void] = ref [];

			refArrayPush(disposers, subscribe(state.selection, makeSelectionChangeHandler(state, parentView, element, fullySelected)));

			// No click on construction
			next(click, CursorClick(-1.0, -1.0, false, false, 0.0));

			// Track cursor position and height
			unsCursor = ref nop;
			unsCursorHeight = ref nop;

			refArrayPush(disposers, subscribe(cursorInside.directlyInside, \inside -> {
				if (inside == 1) {
					^unsCursor();
					unsCursor := select3u(cursorInside.x, cursorInside.y, state.shouldUpdateUI, \x, y, shouldUpdateUI -> {
						if (shouldUpdateUI) {
							// parentPos = getGlobalCoordinate([]);
							globalCursorPos = parentView.local2globalCoordinate(Point(x, y));
							nextDistinct(state.cursorCoord, globalCursorPos);
						}
					}).second;

					^unsCursorHeight();
					unsCursorHeight := connectDistinct(cursorInside.height, state.cursorHeight);
				} else {
					^unsCursor();
					unsCursor := nop;

					^unsCursorHeight();
					unsCursorHeight := nop;
				}
			}));

			refArrayPush(disposers, \ -> { ^unsCursor(); unsCursor := nop; });
			refArrayPush(disposers, \ -> { ^unsCursorHeight(); unsCursorHeight := nop; });

			// When the cursor moves, we assume we do not have the cursor.
			refArrayPush(disposers, subscribe(state.cursor, \c -> {
				nextDistinct(cursorInside.inside, 0);
				nextDistinct(cursorInside.directlyInside, 0);
			}));

			// When the selection changes, we assume we do not have it
			refArrayPush(disposers, subscribe(state.selection, \s -> {
				nextDistinct(selectionStartInside.inside, 0);
				nextDistinct(selectionStartInside.directlyInside, 0);
				nextDistinct(selectionEndInside.inside, 0);
				nextDistinct(selectionEndInside.directlyInside, 0);
			}));

			// Our obligation as an event monitor to implement cursor navigation when we own the cursor
			eventHandler = \e -> handleParagraphEvent(state, parentView, cursorInside, wh, setCursorFn, e);

			makeTextView = \s, p, e, isLastChild ->
				makeWigiParagraphTextView(s, p, namespace, e, cursorInside, selectionStartInside, selectionEndInside, eventHandler, isLastChild, paragraphBorder.top);
			makeNonTextView = \s, p, e, i ->
				makeWigiParagraphNonTextView(s, p, namespace, e, i, cursorInside, selectionStartInside, selectionEndInside, eventHandler, preview, registerToEngine, paragraphBorder.top);
			// Construct the views of each child element : WigiParagraph
			nChildren = length(element.elements);
			tvs : [TextViewAcc] = mapi(element.elements, \i, e -> makeChildView(parentView, state, i, e, disposers, element, childViews, makeTextView, makeNonTextView, i == nChildren - 1));
			childViews := tvs;

			paraElements = map(tvs, \tv -> tv.p);
			fullStyle = concatWigiParagraphStyles(parentView.getStyle().paragraphStyle, element.style);
			// for listed or generally indented paragraphs we need to make some preparations before rendering

			customDialogs = getWigiEditorCustomDialogs(state.wigiEditorStyle);

			paragraph = prepareParagraphForRendering(
				paraElements,
				fullStyle,
				getValue(state.zoom),
				getListInfo(state, element, parentView.getPath(), parentView.getStyle().paragraphStyle),
				\f, num -> Interactive([
					MouseDown(\mi -> {
						if (mi.inside()) {
							customDialogs.askStringInPopup(_("Starting number"), 200.0, 50.0, if (num == -1 ) "" else i2s(num), \s -> (s2i(s) > 0) || (s == ""), \s -> {
								newNum = if (s == "") -1 else s2i(s);
								changeNumberedIntParagraphStyle(state, newNum);
								// need to do this hack in order to update whole document
								next(state.document, getValue(state.document))
							})
						}
						// allow paragraph to handle this event in order to move cursor here
						false
					})
				], f),
			);
			next(view, paragraph);

			uns = subscribe2(click, makeCursorClickHandler(state, clicksHistory, tvs));

			\ -> {
				uns();
				childViews := [];
				applyall(^disposers);
				disposers := [];
			}
		}
	);

	WigiView(
		form,
		\ -> getValue(wh),// getSize
		\p, selecting, mouse -> setCursorFn(p, false, selecting, mouse),// setCursor
		\p -> getGlobalCoordinate(parentView, element, childViews, p),
		\p : [int], v : WigiView -> {// getWigiView
			if (length(p) > 0) {
				child = p[0];
				// #41075 - ad hoc fix. Added check against zero as child = -1
				if (0 <= child && child < length(^childViews)) {
					cv = (^childViews[child]).view;
					cv.getWigiView(tail(p), cv);
				} else v
			} else {
				v
			}
		},
		\e -> {
			// We do not handle events here
			false;
		}
	)
}

CursorClick : (x : double, y : double, selecting : bool, mouseClick : bool, time : double);

// A path with a distance
PathDistance : (distance : Point, path : [int]);

dummyPathDistance = PathDistance(Point(100000.0, 100000.0), []);

// A text inside a paragraph.
makeWigiParagraphTextView(
	state : WigiEditorState,
	parentView : ParentView,
	namespace : WigiScope, e : WigiText,
	// This function should update the information in these structure if we have the cursor inside
	cursorInside : PositionInside,
	selectionStartInside : PositionInside,
	selectionEndInside : PositionInside, eventHandler : (WigiEvent) -> bool,
	isLastChild : bool, topBorder : double
) -> TextViewAcc {

	// First, we split the text into words, wrapping them with inspectors to allow us to find coordinates
	zoomedTextStyle = zoomFontSize(getValue(state.zoom), concatWigiTextStyles(parentView.getStyle().textStyle, e.style));
	zoomedCharStyle = getCharacterStyleFromWigiTextStyle(adjustFontSizeToBaselineShift(zoomedTextStyle));

	annotationId = extractStruct(e.style, WigiAnnotation(-1)).id;
	withHiglightedAnnotations = if (annotationId == -1) zoomedCharStyle else
		replaceStructMany(
		zoomedCharStyle,
		[BackgroundFill(yellow), BackgroundFillOpacity(0.2)]
	);

	words = breakTextFragment(e.text, withHiglightedAnnotations, false, 0, makeList(), isLastChild);

	// if the last line of the last child ends with \n, we have to add extra empty line InspectElement to be able
	// to position to that line in the editor. the index of the element equals the length of the text
	withLastLine = if (isLastChild && endsWith(e.text, "\n")) Cons(makeEmptyLineInspectElement(strlen(e.text), zoomedCharStyle), words) else words;

	// If the text is empty, we still have to have the cursor height set: Do that by making a fixed size block
	nonEmpty = if (words == EmptyList()) Cons(makeEmptyLineInspectElement(0, zoomedCharStyle), words) else withLastLine;

	uns1 = positionMonitor(parentView.getPath, nonEmpty, state.cursor, cursorInside, topBorder);
	uns1a = {
		selection1 = selectu(state.selection, \s -> if (isEmptySelection(s)) [] else s.start);

		destroyMonitor1 = positionMonitor(parentView.getPath, nonEmpty, selection1.first, selectionStartInside, topBorder);
		\ -> {
			selection1.second();
			destroyMonitor1();
		}
	}

	uns1b = {
		selection2 = selectu(state.selection, \s -> if (isEmptySelection(s)) [] else s.end);

		destroyMonitor2 = positionMonitor(parentView.getPath, nonEmpty, selection2.first, selectionEndInside, topBorder);
		\ -> {
			selection2.second();
			destroyMonitor2();
		}
	}

	annotationHoverMakerM = tryExtractStruct(
		state.wigiEditorStyle,
		WigiEditorAnnotationHover(\__, __ -> \__ -> false)
	);

	styled = fold(zoomedTextStyle, nonEmpty, \elements, style -> {
		switch(style) {
			WigiAnnotation(id) : mapList(elements, \elem -> eitherMap(
				annotationHoverMakerM,
				\ahm -> addModifierToWrapElement(
					elem,
					zoomedTextStyle,
					\f, __ -> Interactive(
						[MouseMove(ahm.makeHoverFn(id, \ -> parentView.local2globalCoordinate(Point(0.0, 0.0))))],
						f
					),
				),
				elem
			));
			Underline(): mapList(elements, \elem -> addModifierToWrapElement(elem, zoomedTextStyle, addUnderlineToForm));
			DoubleUnderline(): mapList(elements, \elem -> addModifierToWrapElement(elem, zoomedTextStyle, addDoubleUnderlineToForm));
			BaselineShift(baselineShift): mapList(elements, \elem -> addModifierToWrapElement(elem, adjustStyleForBaselineModifier(zoomedTextStyle), addBaselineShiftToForm));
			WigiLock(lockType): mapList(elements, \elem ->
				if (state.lock.status == LockEditable()) {
					addModifierToWrapElement(elem, zoomedTextStyle,
						\f, st -> {
							highlightB = make(false);
							Constructor(
								addLockHighlightToForm(highlightB, f, st, false),
								\-> {
									uns = select2u(state.lock.preview, state.lock.highlight, \pv, hl -> {
										next(highlightB, !pv && hl)
									});
									uns.second
								}
							)
					})
				} else {
					elem
				});
			default: elements;
		}
	});

	words2 = escapeXmlCharsInWords(styled);

	TextViewAcc(
		TextFragments(words2),
		WigiView(
			// TODO: We should probably make a real one here!
			\ -> Empty(),
			// getSize
			\ -> zeroWH,
			// setCursor
			\p, b, m -> {
				// ???
				true
			},
			// getGlobalCoordinate
			\p : [int] -> {
				parentView.local2globalCoordinate(Point(0.0, 0.0));
			},
			// getWigiView
			\w, v -> {
				v
			},
			// handleEvent
			eventHandler
		),
		\ -> {
			uns1();
			uns1a();
			uns1b();
		},
		\p : Point -> {
			if (p.x != -1.0 && p.y != -1.0) {
				//println("\nLooking for point at " + toString(p));
				pos = findWigiLinePosition(nonEmpty, parentView.getPath, p.x, p.y, getValue(state.viewSize), topBorder);
				//println("Looking for point at " + toString(p) + " gives " + toString(pos));
				pos
			} else dummyPathDistance;
		},
		\i : int -> {
			pt = findWigiLinePoint(nonEmpty, i);
			Point(pt.x, pt.y + topBorder);
		}
	)
}

// Non text inside a paragraph.
makeWigiParagraphNonTextView(state : WigiEditorState, parentView : ParentView, namespace : WigiScope,
		element : WigiElement, index : int, cursorInside : PositionInside,
		selectionStartInside : PositionInside, selectionEndInside : PositionInside, eventHandler : (WigiEvent) -> bool,
		preview : bool, registerToEngine : bool, topBorder : double) -> TextViewAcc {
	// We have to keep cursorInside, selectionStartInside & selectionEndInside
	// up to date here
	childView = makeWigiElementView(state, parentView, namespace, element, preview, registerToEngine);

	xc = make(0.0);
	yc = make(0.0);
	cwh = makeWH();
	lh = make(0.0);

	// as xc, yc take part in setting global cursor position, if they change after last call of index2point function of resulting TextViewAcc
	// we force cursor updating to be sure that cursor position is correct
	lastPoint = ref Point(0.0, 0.0);
	point = select2u(xc, yc, \x, y -> Point(x, y)) |> makeDisposable;
	u4 = subscribe2(point.value, \p -> {
		if (p != ^lastPoint) nextDistinct(state.cursor, getValue(state.cursor));
	});

	inspect = InspectElement(index, xc, yc, cwh, lh, childView.form());

	u1 = positionViewMonitor(parentView.getPath, inspect, state.cursor, cursorInside, false, topBorder);
	u2 = {
		selection5 = selectu(state.selection, \s -> if (isEmptySelection(s)) [] else s.start);

		destroyMonitor5 = positionViewMonitor(parentView.getPath, inspect, selection5.first, selectionStartInside, true, topBorder);
		\ -> {
			selection5.second();
			destroyMonitor5();
		}
	}

	u3 = {
		selection6 = selectu(state.selection, \s -> if (isEmptySelection(s)) [] else s.end);

		destroyMonitor6 = positionViewMonitor(parentView.getPath, inspect, selection6.first, selectionEndInside, false, topBorder);
		\ -> {
			selection6.second();
			destroyMonitor6();
		}
	}

	list = Cons(inspect, makeList());

	addStyle = \elements, style -> fold(style, elements, \elems, s -> {
		switch(s) {
			Underline(): mapList(elems, \elem -> addModifierToWrapElement(elem, style, addUnderlineToForm));
			DoubleUnderline(): mapList(elems, \elem -> addModifierToWrapElement(elem, style, addDoubleUnderlineToForm));
			BaselineShift(baselineShift): mapList(elems, \elem -> addModifierToWrapElement(elem, style, addBaselineShiftToForm));
			default: elems;
		}
	});

	styled = switch(element) {
		WigiRecursive(elements, type, style): addStyle(list, style);
		WigiBlock(type, style): {
			fullStyle = getWigiBlockStyleFull(state.defaultStyles, getValue(state.document), parentView.getPath(), style);
			addStyle(list, fullStyle);
		}
		default: list;
	};

	// We replace the event handler with our own in this view
	handler : (WigiEvent) -> bool = switch (element : WigiElement) {
		WigiRecursive(__, type, __): \event -> wigiRecursiveEvent(state, type, event);
		default: eventHandler;
	}
	viewWithEvent = WigiView(
		childView.form,
		childView.getSize,
		childView.setCursor,
		childView.getGlobalCoordinate,
		childView.getWigiView,
		handler
	);

	us = [u1, u2, u3, u4, point.dispose];

	TextViewAcc(
		// The form to view
		TextFragments(styled),
		// The view
		viewWithEvent,
		// Clean up this view
		\ -> { applyall(us) },
		// Measure the distance to a given point
		\p -> {
			x = getValue(xc);
			y = getValue(yc) + topBorder;
			twh = getValue(cwh);

			dx = lineDistance(p.x, x, x + twh.width);
			dy = lineDistance(p.y, y, y + twh.height);
			PathDistance(
				Point(dx, dy),
				arrayPush(
					parentView.getPath(),
					b2i(dy > y || p.x > x + twh.width / 2.0)
				)
			);
		},
		\p : int -> {
			lastPoint := Point(getValue(xc), getValue(yc) + topBorder);
			^lastPoint;
		},
	);
}

findWigiLinePosition(words : List<WrapElement>, getElementPath : () -> [int], mx : double, my : double, viewSize : WidthHeight, topBorder : double) -> PathDistance {
	// We just brute force it: Scan for the shortest distance
	lastWord : ref Pair<InspectElement, PathDistance> = ref Pair(dummyInspect, dummyPathDistance);
	element : Pair<InspectElement, PathDistance> = foldList(words, Pair(dummyInspect, dummyPathDistance), \acc : Pair<InspectElement, PathDistance>, w -> {
		switch (w) {
			InspectElement(in, xc, yc, wh, lh, f): {
				switch (f : InspectableElement) {
					Space(__): acc;
					default: {
						x = getValue(xc);
						y = getValue(yc) + topBorder;
						s = getValue(wh);
						l = getValue(lh);
						// Space above the element in case the line is higher than the element!
						dh = l - s.height;

						dx = lineDistance(mx, x, x + s.width);
						dy = lineDistance(my, y - dh, y - dh + l);

						dist = PathDistance(Point(dx, dy), []);

				//		println(toString(w.element) + ":" + toString(dist) + " " + toString(acc.first.element));

						if (isNewDistanceLess(acc.second, dist)) {
							newAcc = Pair(w, dist);
							if (^lastWord.first == dummyInspect) lastWord := newAcc;
							newAcc;
						} else acc;
					}
				}
			}
			default: acc;
		}
	});
	if (element.first != dummyInspect) {
	//	println("Local winner: " + toString(element.first.element) + " " + toString(element.second.distance));
		// If we are out of text, we have to go to the end of the current line instead of the nearest word
		if (element.second.distance.y == 0.0) {
			fineIndex = resolveWigiTextIndex(element.first, mx, my);
			PathDistance(element.second.distance, arrayPush(getElementPath(), fineIndex));
		} else {
			fineIndex = resolveWigiTextIndex(^lastWord.first, viewSize.width, my);
			PathDistance(^lastWord.second.distance, arrayPush(getElementPath(), fineIndex));
		}
	} else dummyPathDistance;
}

findWigiLinePoint(words : List<WrapElement>, index : int) -> Point {
	p = foldList(reverseList(words), Point(-1.0, -1.0), \acc : Point, w -> {
		switch (w : WrapElement) {
			InspectElement(in, xc, yc, wh, lh, f): {
				if (in >= index && acc.x == -1.0) {
					x = getValue(xc);
					y = getValue(yc);

					/*if (in != index) {
						println("TODO: Here, we should look inside our word to find the exact point " +
							toString([in, index])
						);
						switch (f) {
							Text(t, s): println("  " + t);
							Space(fm): println("  space");
							default: println("  <someting else>");
						}
					}*/
					Point(x, y);
				} else acc
			}
			default: acc;
		}
	});
	if (p.x == -1.0) {
		// If we didn't find it, it could be because index is bigger than last word's!
		// That is when we click on the last word in the paragraph. Actually happens a lot.
		// In particular that's what causes http://process.area9.dk/cases/default.asp?33124
		switch (headList(words, Empty()): WrapElement) {
			InspectElement(in, xc, yc, wh, lh, f): {
				if (index > in) {
					Point(getValue(xc) + getValue(wh).width, getValue(yc))
				} else {
					Point(0.0, 0.0)
				}
			}
			default: Point(0.0, 0.0);	// OK, we didn't find it...
		}
	} else {
		p
	}
}

lineDistance(x : double, x1 : double, x2 : double) -> double {
	if (x1 <= x && x < x2) 0.0
	else min(abs(x - x1), abs(x - x2));
}

// Find a real index into this element from a mouse coordinate
resolveWigiTextIndex(i : InspectElement, x : double, y : double) ->  int {
	ix = getValue(i.x);
	iy = getValue(i.y);
	s = getValue(i.size);

	// println("Mouse at " + d2s(x) + "," + d2s(y) + " at element " + i2s(i.index) + " at " +  d2s(ix) + "," + d2s(iy));
	switch (i.element : InspectableElement) {
		Text(txt, style):  {
			iw = resolveTextIndex(txt, style, x - ix);
			i.index + iw;
		}
		Space(f): {
			sz = getStaticFormSize(f);
			i.index + if (x - ix < sz.width / 2.0) 0 else 1;
		}
		default: {
			i.index;
		}
	}
}

resolveTextIndex(t : string, style : [CharacterStyle], x : double) -> int {
	if (t == "") {
		0
	} else {
		// We'll get our string char-by-char until its width grows to hit "x"
		// We should round to nearest character, therefore true "x" position is half-character to the left
		charWidth = getStaticFormSize(Text(escapeXmlChars(t), style)).width / i2d(strlen(t));
		shiftedX = x - charWidth / 2.0;

		try = ref \c -> 0;
		try := \chars -> {
			if (chars < strlen(t)) {
				f = getStaticFormSize(Text(escapeXmlChars(strLeft(t, chars)), style));

				if (f.width >= shiftedX) {
					chars
				} else {
					^try(chars + 1)
				}
			} else {
				strlen(t)
			}
		}

		^try(0)
	}
}

localSetCursorBlock(state : WigiEditorState, parentView : ParentView, wh : DynamicBehaviour<WidthHeight>,
		p : Point, selecting : bool, scrollView : bool, isMouseEvent : bool) -> bool {
	s = getValue(wh);
	if (0.0 <= p.x && p.x < s.width && 0.0 <= p.y && p.y < s.height) {
		pos = if (p.x < s.width / 2.0) 0 else 1;
		path = arrayPush(parentView.getPath(), pos);
		if(isMouseEvent && isWigiPageBreak(getElementAtPosition(getValue(state.document), path)))
			false
		else {
			wigiSetCursor3(state, path, selecting, true, scrollView);
			true
		}
	} else {
		println("TODO: Could not set cursor in block or recursive");
		false
	}
}

isSecondClickOnBlock(state : WigiEditorState, parentView : ParentView, wh : DynamicBehaviour<WidthHeight>, mi : MouseDownInfo) -> bool {
	next(state.cursorWantThisX, -1.0);
	previusCursorState = getValue(state.cursor);
	changed = localSetCursorBlock(state, parentView, wh, Point(mi.x, mi.y), getValue(state.shiftHeld), false, true);
	next(state.mouseSelecting, true);

	changed && previusCursorState == getValue(state.cursor)
}

makeWigiRecursiveView(state : WigiEditorState, parentView : ParentView, namespace : WigiScope, recursive : WigiRecursive, preview : bool, registerToEngine : bool) -> WigiView {
	uniqueId = round(random() * 10000000.0);
	idGenerator = \i -> {
		uniqueId + i
	}

	getFormLocation : ref (int) -> Point = ref \i -> Point(0.0, 0.0);

	len = length(recursive.elements);
	elementSizes = generate(0, len, \__ -> makeWH());
	elementMatrices = generate(0, len, \__ -> ref getDummyTransformMatrix);
	getTM = ref getDummyTransformMatrix;

	isTable = switch (recursive.type) {
		WigiTable(__, __, __, __): true;
		default: false;
	}

	views = mapi(recursive.elements, \i, e -> {
		ev = makeWigiElementView(state, ParentView(
			\ -> arrayPush(parentView.getPath(), i),
			// Translate this local coordinate to a parent coordinate
			\p -> {
				child = (^getFormLocation)(i);
				Point(child.x + p.x, child.y + p.y);
			},
			// local2globalCoordinate
			\p -> {
				child = (^getFormLocation)(i);
				parentView.local2globalCoordinate(Point(child.x + p.x, child.y + p.y));
			},
			// setParentCursor
			\p, s, m -> false,
			// parent's styles
			\-> {
				curStyle = parentView.getStyle();
				switch (recursive.type) {
					WigiVersions(__): WigiParentStyle(
						concatWigiParagraphStyles(curStyle.paragraphStyle, [TightWidth()]),
						curStyle.textStyle,
						curStyle.accRelativeFontSizeChange
					);
					default: curStyle;
				}
			},
			getTM
		), namespace, e, preview, registerToEngine);

		// Now, tag all forms so we can find them again
		m = makeWH();

		form = \ -> {
			form0 = Inspect([ITag(idGenerator(i)), ISize(m)], ev.form());
			form1 = addTransformMatrixInspector(form0);
			elementMatrices[i] := form1.inspector;
			form1.form
		}

		WigiView(
			form,
			\ -> {
				if (isTable)
					getValue(elementSizes[i])
				else
					getValue(m)
			},
			ev.setCursor,
			ev.getGlobalCoordinate,
			ev.getWigiView,
			ev.handleEvent
		)
	});

	wh = makeWH();

	form = \ -> {
		styles = [
			ExtRecUpdateRecursive(\result : Tree<string, string>, children : [WigiElement] -> {
				switch (recursive.type : WigiRecursiveType) {
					WigiExternalRecursive(exType, content): {
						// save cursor and place it to the recursive
						cursor = getValue(state.cursor);
						root = getValue(state.document);
						path = findWigiElement(root, recursive);
						nextDistinct(state.cursor, path);
						nextDistinct(state.selection, wigiClearSelection(root));
						extRec = WigiExternalRecursive(exType, result);
						wigiSendEvent(state, WigiChangeRecursive(WigiRecursive(children, extRec, recursive.style))) |> ignore;

						// return back cursor
						nextDistinct(state.cursor, cursor);

						wigiUpdateCursor(state);
					}
					default: {}
				}
			}),
			ExternalDeleteElement(\ -> {
				root = getValue(state.document);
				path = findWigiElement(root, recursive);
				wigiSendEvent(state, WigiDeleteElement(path));
				wigiUpdateCursor(state);
			}),
			extractStruct(^(state.toolbarStyle), dummyContextMenu())
		];

		// Have a marker that we should not go below this for our parents
		cursorInside = make(false);

		form0 = Constructor(
			Inspect([ITag(-1)],
				wigiRecursiveLayout(
					recursive.type, namespace, recursive.elements, recursive.style, map(views, \v -> v.form),
					// TODO: Here should be preview arg instead of false, but it does not work properly
					// for Template probe. See case 36178 point 1
					\ -> wigiUpdateCursor(state), state.engine, false, registerToEngine, cursorInside, Some(elementSizes),
					styles
				)
			),
			\ -> connectSelectDistinctu(state.cursor, cursorInside, \cursor -> isPositionParentGeneral(parentView.getPath(), cursor))
		);
		form1 = addTransformMatrixInspector(form0);
		getTM := form1.inspector;

		getFormLocation := \i -> {
			if (!useTransformMatrixPositioning) {
				findTaggedFormPosition(form1.form, idGenerator(i))
			} else {
				childTM = ^(elementMatrices[i])();

				if (isSameStructType(recursive.type, dummyWigiTable)) {
					myTM = ^getTM();
					getTransformPosition(getRelativeTransformMatrix(childTM, myTM))
				} else {
					parentTM = ^(parentView.getTM)();
					myRelativeCoord = getTransformPosition(getRelativeTransformMatrix(childTM, parentTM));
					parentCoord = parentView.getParentCoordinate(Point(0.0, 0.0));
					Point(myRelativeCoord.x - parentCoord.x, myRelativeCoord.y - parentCoord.y)
				}
			}
		}

		Group([
			getSelectionView(state, wh, parentView, recursive),

			// Highlight of currently edited formula (see case 34588)
			switch (recursive.type: WigiRecursiveType) {
				WigiSpreadsheetCell(cwh, __, __): {
					Select(state.formulaEditor, \fe -> {
						eitherMap(fe, \feditor -> {
							if (isPositionParent(parentView.getPath(), wigiParentPath(wigiParentPath(feditor.path)))) {
								Select(cwh, \_cwh -> Rectangle(_cwh.width, _cwh.height, [Stroke(black), StrokeWidth(3.0)]));
							} else {
								Empty();
							}
						}, Empty())
					});
				}
				default: Empty()
			},
			Inspect([ISize(wh)], form1.form)
		])
	}

	WigiView(
		// The form
		form,
		// The size of ourselves
		\ -> getValue(wh),
		// Set cursor in local coordinates
		\point, sel, mouse -> {
			// println("Set cursor in recursive: " + toString(point) + " in " + strLeft(element2string(recursive), 100));
			wwh = getValue(wh);

			// Special case, if we are a table cell we always want to handle this click
			// See case http://process.area9.dk/cases/default.asp?38413
			isCell = isSameStructType(recursive.type, dummyWigiTableCell)
						|| isSameStructType(recursive.type, dummyWigiSpreadsheetCell);

			if (isCell || (0.0 <= point.x && point.x < wwh.width && 0.0 <= point.y && point.y < wwh.height)) {
				set = foldi(recursive.elements, Triple(false, -1, dummyPathDistance), \i, acc, e -> {
					// println("#" + i2s(i) + ": " + toString(coord) + ", size: " + toString(size));

					if (!acc.first) {	// We're not done yet
						coord = ^getFormLocation(i);
						size = views[i].getSize();
						if (coord.x <= point.x && point.x < coord.x + size.width
							&& coord.y <= point.y && point.y < coord.y + size.height) {
							local = Point(point.x - coord.x, point.y - coord.y);
							views[i].setCursor(local, sel, mouse);
							Triple(true, i, PathDistance(Point(0.0, 0.0), []))
						} else {
							// Let's measure distance from point to our views[i]
							dx = lineDistance(point.x, coord.x, coord.x + size.width);
							dy = lineDistance(point.y, coord.y, coord.y + size.height);
							dist = PathDistance(Point(dx, dy), []);

							if (isNewDistanceLess(acc.third, dist))
								Triple(false, i, dist)
							else acc;
						}
					} else {	// We're done already
						acc
					}
				});

				if (!set.first) {
					// Now the child number set.second is our friend
					coord = ^getFormLocation(set.second);
					local = Point(point.x - coord.x, point.y - coord.y);

					// We might be outside, so make sure the point is forced inside
					size = views[set.second].getSize();
					bounded = Point(min(size.width - 0.5, local.x), min(size.height - 0.5, local.y));
					bounded2 = Point(max(0.0, bounded.x), max(0.0, bounded.y));
					// println("Bounded position " + toString(bounded2) + " of " + toString(local));

					views[set.second].setCursor(bounded2, sel, mouse)
				} else {
					// println("Handled the click already");
					false
				}
			} else {
				println("Point is outside view, ignored: " + toString(point) + " out of " + toString(wwh));
				// Point is outside of our view, ignore it.
				false
			}
		},
		// Get global coordinates for this relative path
		\path : [int] -> {
			if (path == []) {
				Point(0.0, 0.0)
			} else {
				head = path[0];
				tl = tail(path);
				if (tl == [] || head >= length(views)) {
					owncoord = (^getFormLocation)(head);
					parentView.local2globalCoordinate(owncoord);
				} else {
					childcoord : Point = views[head].getGlobalCoordinate(tl);
					childcoord;
				}
			}
		},
		// getWigiView
		\path : [int], v : WigiView -> {
			if (path == []) {
				v
			} else {
				i = path[0];
				if (i < length(views)) {
					cv = views[i];
					cv.getWigiView(tail(path), cv);
				} else {
					v
				}
			}
		},
		\e -> {
			wigiRecursiveEvent(state, recursive.type, e)
		}
	);
}

makeWigiBlockView(state : WigiEditorState, parentView : ParentView, namespace : WigiScope, block : WigiBlock, registerToEngine : bool) -> WigiView {
	// TODO: We should look for the cursor and shift here
	wh = makeWH();
	zoom = getValue(state.zoom);

	// The form
	form = \ -> {
		blockClickHandler1 = \wigiBlock -> {
			wigiSendEvent(state, WigiChangeBlock(wigiBlock));
			wigiUpdateCursor(state);
		}
		blockClickHandler2 = \wigiBlockType -> blockClickHandler1(WigiBlock(wigiBlockType, []));

		callLegacyBlockAPI = \blockClickedAlready -> {
			if (blockClickedAlready) {
				maybeApply(
					getLegacyBlockAPI(block.type.structname),
					\api -> api.editProperties(
						state, block.type, blockClickHandler2, [namespace]
					)
				);
			}
		}

		form0 = Inspect([ISize(wh)], Interactive([
			MouseDown(\mi -> {
				if (mi.inside()) {
					// Inside the paragraph, but check whether we are visible:
					// Convert the local coordinate to global, and check that we are
					// inside the view of the editor

					globalPoint = parentView.local2globalCoordinate(Point(mi.x, mi.y));
					if (isWigiPointVisible(state, globalPoint)) {
						blockClickedAlready = isSecondClickOnBlock(state, parentView, wh, mi);

						// Special case for WigiFormula, unfortunately, because in block we don't have access to the state
						switch (block.type: WigiBlockType) {
							WigiFormula(formula, style): {
								if (blockClickedAlready) {
									showCalculatedCellDialog(state, formula, \newFormula -> {
										if (newFormula != formula) {
											replaceElementInDocument(state, getValue(state.cursor), (WigiBlock(WigiFormula(newFormula, style), block.style)));
										}
									});
								}
							}
							WigiHistogram(__, __): callLegacyBlockAPI(blockClickedAlready);
							WigiDotplot(__, __): callLegacyBlockAPI(blockClickedAlready);
							WigiHistogramClasses(__, __): callLegacyBlockAPI(blockClickedAlready);
							WigiBoxplot(__, __): callLegacyBlockAPI(blockClickedAlready);
							WigiScatterplot(__, __): callLegacyBlockAPI(blockClickedAlready);
							WigiStackedBar(__, __): callLegacyBlockAPI(blockClickedAlready);
							WigiChoiceBlock(__, __): callLegacyBlockAPI(blockClickedAlready);
							WigiFeedbackBlock(__, __, __, __): callLegacyBlockAPI(blockClickedAlready);
							default: {
								handledEvent = handleBlockClickEvent(
									state,
									blockClickHandler1,
									block,
									blockClickedAlready
								);
								if (handledEvent) {
									next(state.mouseSelecting, false);
								}
							}
						}
						true
					} else false;
				} else false;
			}),
			MouseMove2(\handled, mi -> {
				if (!handled && getValue(state.mouseSelecting)) {
					m = mi();
					if (m.inside
						|| (0.0 <= m.x && m.x < getValue(wh).width
							&& 0.0 <= m.y && m.y < getValue(wh).height )
						) {
						selStartInComap = isInsideComap(getValue(state.document), either(getValue(state.selectionAnchor),[]));
						if (!selStartInComap) {
							localSetCursorBlock(state, parentView, wh, Point(m.x, m.y), true, true, true) |> ignore;
						}
						true
					} else false;
				} else handled
			}),
			MouseUp2(\handled, mi -> {
				if (!handled) {
					s = getValue(state.mouseSelecting);
					nextDistinct(state.mouseSelecting, false);
					false
				} else handled;
			})
		],

		{
			fullStyle = getWigiBlockStyleFull(state.engine.defaultStyles, getValue(state.document), parentView.getPath(), block.style);
			updatedBlock = switch(block.type) {
				WigiCheckBox(__, __): adjustCheckBoxToNextText(state, block, parentView.getPath());
				WigiCalculator(): WigiBlock(WigiCalculator(), fullStyle);
				WigiNaturalMath(formula): WigiBlock(WigiNaturalMath(formula), fullStyle);
				WigiReferenceDocument(title, doc): WigiBlock(WigiReferenceDocument(title, doc), fullStyle);
				WigiSetClipboardButton(title, text): WigiBlock(WigiSetClipboardButton(title, text), fullStyle);
				default: block;
			}
			ignoreLockEditable = make(false);
			ignoreLockB = switch(state.lock.status) {
				LockIgnored(): Some(const(true));
				LockEditable(): Some(ignoreLockEditable);
				LockedContent(): None();
			}

			styles = [
				ExternalDeleteElement(\ -> {
					root = getValue(state.document);
					path = findWigiElement(root, block);
					deleteElementSafely(state, path);
					wigiUpdateCursor(state);
				}),
			];
			block0 = addStylesToBlock(updatedBlock, state.defaultStyles);
			block1 = WigiBlock(block0.type, concat(block0.style, styles));

			view0 = Scale(
				const(zoom), const(zoom),
				wigiBlock2form(
					block1,
					state.engine,
					namespace,
					Some(state.showStructures),
					ignoreLockB,
					false,
					registerToEngine,
					makeBlockWikiStyles(state.noAutoPlay)
				)
			);
			Constructor(view0, \ -> subscribe(state.lock.preview, \p -> nextDistinct(ignoreLockEditable, !p)))
		}));
		Group([getSelectionView(state, wh, parentView, block), form0])
	}

	WigiView(
		form,
		// The size of ourselves
		\ -> getValue(wh),
		// Set cursor in local coordinates
		\p, selecting, mouse -> {
			localSetCursorBlock(state, parentView, wh, p, selecting, true, mouse)
		},
		// local2globalCoordinate
		\p -> parentView.local2globalCoordinate(Point(0.0, 0.0)),
		// getWigiView
		\p : [int], v : WigiView -> {
			v
		},
		\e -> {
			false
		}
	);
}

// for WigiCheckBox sets WigiBlock's font size the same as font size of the following text for them to be vertically aligned
adjustCheckBoxToNextText(state : WigiEditorState, block : WigiBlock, path : [int]) -> WigiBlock {
	switch(block.type){
		WigiCheckBox(val, st): {
			switch(maybeGetNextElementFontSize(state.defaultStyles, getValue(state.document), path)){
				Some(size): WigiBlock(block.type, arrayPush(block.style, FontSize(size)));
				None(): block;
			}
		}
		default : block;
	}
}

handleBlockEvent(state: WigiEditorState, block: WigiBlock, e: WigiEvent) {
	switch (block.type: WigiBlockType) {
		WigiPageBreak(__, __): {
			switch (e: WigiEvent) {
				WigiCursorLeft(selecting): {
					wigiMoveCursor(state, -1, selecting);
					true
				}

				WigiCursorRight(selecting): {
					wigiMoveCursor(state, 1, selecting);
					true
				}

				WigiCursorDown(selecting): {
					// TODO: Ideally, we need to preserve X-coordinate here
					wigiMoveCursor(state, 1, selecting);
					true
				}

				WigiCursorUp(selecting): {
					// TODO: Ideally, we need to preserve X-coordinate here
					wigiMoveCursor(state, -1, selecting);
					true
				}

				default: false;
			}
		}
		default: false;	// Other blocks don't handle events for now
	}
}

// we do not allow CursorClicks when selection starts in a comap node and either a cell cursor set or we are outside the start node
allowCursorClick(state : WigiEditorState, c : CursorClick, path : [int]) -> bool {
	lockedSelecting = \-> {
		lock = getLockAtPosition(getValue(state.document), path);
		lock == WigiReadOnly() || lock == WigiAddOnly()
	};
	lockedMouseSelecting = c.selecting && c.mouseClick && !isLockEditAllowed(state) && lockedSelecting();
	if (lockedMouseSelecting) {
		next(state.selectionAnchor, None());
		false;
	} else if (path != []) {
		if (c.selecting && c.mouseClick) {
			anchor = either(getValue(state.selectionAnchor),[]);
			!(isInsideComap(getValue(state.document), anchor)
				&& (isCellCursor(state) || !inSameComapNode(getValue(state.document), anchor, path)));
		} else {
			true
		}
	} else {
		false
	}
}

adjustCursorForSelection(state : WigiEditorState, cursor : [int]) -> [int] {
	getComapSelectionPos(state, cursor);
}

addLockHighlightToView(state : WigiEditorState, view : WigiView, element : WigiElement) -> WigiView {
	highlightFn : (Behaviour<bool>, Form) -> Form = switch(element){
		WigiBlock(block, style): \b, f -> {
			addLockHighlightToForm(b, f, style, true);
		}
		default: \b, f -> f;
	}
	newForm = \ -> if (state.lock.status == LockEditable()) {
			highlightB = make(false);
			Constructor(
				highlightFn(highlightB, view.form()),
				\-> {
					uns = select2u(state.lock.preview, state.lock.highlight, \pv, hl -> {
						next(highlightB, !pv && hl)
					});
					uns.second
				}
			)
		} else {
			view.form()
		}
	WigiView(newForm, view.getSize, view.setCursor, view.getGlobalCoordinate, view.getWigiView, view.handleEvent);
}

getSelectionView(state : WigiEditorState, wh : DynamicBehaviour<WidthHeight>, parentView : ParentView, el : WigiElement) -> Form {
	res = make(false);
	Constructor(
		Visibleb(res, FixSize(0.0, 0.0,
			if (isWigiTableOrSpreadsheetCell(el)) HVFill([Fill(lightBlue)])
			else Select(wh, \_wh -> Rectangle(_wh.width, _wh.height, [Fill(lightBlue)]))
		)),
		\-> {
			uns = select2u(state.hasKeyboardFocus, state.selection, \focus, selection ->
				next(res, focus && isInsideWigiSelection(selection, parentView.getPath(), el, getValue(state.document), !getValue(state.editMode)))
			);
			uns.second
		}
	);
}

makeBlockWikiStyles(noAP : ref bool) -> [WikiStyle] {
	if (^noAP) [WikiNoAutoplay()] else []
}

isNewDistanceLess(old : PathDistance, new : PathDistance) -> bool {
	new.distance.y < old.distance.y ||
	new.distance.y == old.distance.y && new.distance.x <= old.distance.x
}

evMakeSelectionForm(fullySelected : Behaviour<bool>, wh : Behaviour<WidthHeight>, element : WigiParagraph, selectionStartInside: PositionInside, selectionEndInside: PositionInside, focus : bool) {
	// Draw any selection if in focus
	FixSize(0.0, 0.0,  // Avoid messing with the baseline
		Select2(fullySelected, wh, \f : bool, r : WidthHeight -> {
			selectionColor = if (focus) lightBlue else 0xBDBDBD;

			if (f) {
				Rectangle(r.width, r.height, [Fill(selectionColor)])
				|> \rect ->Align(
					if (contains(element.style, CenterAlign())) 0.5
					else if (contains(element.style, RightAlign())) 1.0
					else 0.0,
					0.0, rect
				)
			} else {
				Select2(selectionStartInside.inside, selectionEndInside.inside, \s, e -> {
					if (s == 1 || e == 1) {
						startX = if (s == 1) selectionStartInside.x else const(r.width);
						startY = if (s == 1) selectionStartInside.y else const(0.0);
						startHeight= if (s == 1) selectionStartInside.height else const(0.0);

						endX = if (e == 1) selectionEndInside.x else const(0.0);
						endY = if (e == 1) selectionEndInside.y else const(r.height);
						endHeight = if (e == 1) selectionEndInside.height else const(0.0);

						Select3(startY, startHeight, endY, \sy, sh, ey -> {
							// Is the start and end on the same line?
							if (sy + sh > ey) {
								// Yep, do one block there
								Translate(startX, const(max(sy, ey)),
									Select3(startX, endX, endHeight, \sx, ex, eh ->
										Rectangle(max(0.0, ex - sx), min(sh, eh), [Fill(selectionColor)])
									)
								)
							} else {
								// No, do three blocks on top of each others
								Group([
									// The first line
									Translate(startX, startY, Select2(startX, startHeight, \sx, h -> {
										Rectangle(r.width - sx, h, [Fill(selectionColor)])
									})),
									// The middle part
									Offset(0.0, sy + sh,
										Rectangle(r.width, ey - (sy + sh), [Fill(selectionColor)])
									),
									// The last line
									Translate(const(0.0), endY, Select2(endX, endHeight, \ex, h -> {
										Rectangle(ex, h, [Fill(selectionColor)])
									})),
								])
							}
						});
					} else
						Empty()
				})
			}
		})
	)
}

makeParagraphHandlers(state : WigiEditorState, parentView : ParentView, wh : Behaviour<WidthHeight>, click : DynamicBehaviour<CursorClick>, style : [WigiParagraphStyle]) {
	[
		MouseDown(\m -> {
			if (m.inside()) {
				nextDistinct(state.mouseSelecting, true);
				next(state.cursorWantThisX, -1.0);
				next(click, CursorClick(m.x, m.y, getValue(state.shiftHeld), true, timestamp()));
				updateKeyboardFocus(^(state.focusId));
				true
			} else {
				false
			}
		}),
		MouseMove2(\handled, mi -> {
			if (!handled && getValue(state.mouseSelecting)) {
				m = mi();
				if (m.inside
					|| (0.0 <= m.x && m.x < getValue(wh).width
						&& 0.0 <= m.y && m.y < getValue(wh).height )
					) {
					next(click, CursorClick(m.x, m.y, true, true, timestamp()));
					true
				} else false;
			} else handled
		}),
		MouseUp2(\handled, mi -> {
			nextDistinct(state.mouseSelecting, false);
			handled;
		})
	]
}

// transform each Text object into Form inside ParagraphElement with transformFn
applyFn2Text(pe: ParagraphElement, transformFn: (Text) -> Form) -> ParagraphElement {
	switch(pe) {
		TextFragments(parts): {
			newParts = mapList(reverseList(parts), \part -> {
				switch(part) {
					InspectElement(i, x, y, s, h, e): {
						newIE = switch (e : InspectableElement) {
							Text(__, __): transformFn(e);
							default: e;
						}
						InspectElement(i, x, y, s, h, newIE);
					}
					default: part
				}
			});
			TextFragments(reverseList(newParts))
		}
		default: pe
	}
}

processParagraphElement(text: string, lang: string, pe: ParagraphElement, replaceFn: (int, int, string) -> void) -> ParagraphElement {
	idx = ref 0;

	applyFn2Text(pe, \textForm -> {
		word = textForm.text;
		if (!contains(spellCheckExceptions, word)) {
			// remove delimeters from start and end of word
			t0 = trim2(word, getWordDelimeters(lang));
			// remove delimeters which are inside the word
			stringFoldSymbols = \s, a, f -> stringFoldi(s, a, \i, a2, code ->f(a2, fromCharCode(code)));
			t1 = stringFoldSymbols(getWordForbiddenSymbols(lang), t0, \acc, symbol -> strReplace(acc, symbol, ""));
			if (!isDigits(t1) && !startsWith(t1, "=") && (t1 != "")) {
				// find start of t0 in source text
				ind = strRangeIndexOf(text, t0, ^idx, strlen(text));
				startPosition = ind;
				endPosition = startPosition + strlen(t0);
				idx := endPosition;
				checkWord(
					t1,
					lang,
					textForm,
					\str -> replaceFn(startPosition, endPosition, str)
				)
			} else {
				textForm
			}
		} else {
			textForm
		}
	})
}

compareTwoClicks(click1, click2) {
	(click1.x == click2.x) && (click1.y == click2.y) && (abs(click2.time - click1.time) < 1000.0);
}

isDoubleClick(clicks) {
	n = length(clicks);
	if (n >= 2) {
		compareTwoClicks(clicks[n-1], clicks[n-2]);
	} else
		false;
}

isTripleClick(clicks) {
	n = length(clicks);
	if (n >= 3) {
		compareTwoClicks(clicks[n-1], clicks[n-2]) && compareTwoClicks(clicks[n-2], clicks[n-3]);
	} else
		false;
}

makeChildView(parentView, state, i, e, disposers, element, childViews, makeTextView, makeNonTextView, isLastChild) -> TextViewAcc {
	childPathFn = \ -> concat(parentView.getPath(), [i]);
	// Special case text to become text fragments for line wrapping
	lvs = ParentView(
		childPathFn,
		parentView.getParentCoordinate,
		\p -> {
			childPoint = getGlobalCoordinate(parentView, element, childViews, [i, 0]);
			Point(childPoint.x + p.x, childPoint.y + p.y)
		},
		parentView.setParentCursor,
		parentView.getStyle,
		parentView.getTM
	);
	switch (e : WigiElement) {
		WigiText(text, textstyle): {
			tv: TextViewAcc = makeTextView(state, lvs, e, isLastChild);
			refArrayPush(disposers, tv.disposer);

			fullTextStyle = concatWigiTextStyles(parentView.getStyle().textStyle, textstyle);
			language = extractStruct(fullTextStyle, Language("")).name;
			lockedContent = state.lock.status == LockedContent();
			if (isSupportedLanguage(language) && !lockedContent) {
				newPE = processParagraphElement(
					text,
					language,
					tv.p,
					\startPosition, endPosition, str -> {
						wigiSetCursor(state, arrayPush(childPathFn(), startPosition), false);
						wigiSetCursor(state, arrayPush(childPathFn(), endPosition), true);
						wigiSendEvent(state, WigiInsertText(str));
						{}
					}
				);
				TextViewAcc(newPE, tv.view, tv.disposer, tv.pointDistance, tv.index2point)
			} else
				tv
		}
		default: {
			p: TextViewAcc = makeNonTextView(state, lvs, e, i);
			refArrayPush(disposers, p.disposer);
			p
		}
	};
}

getGlobalCoordinate(parentView : ParentView, element : WigiElement, childViews : ref [TextViewAcc], p : [int]) -> Point {
	if (p == []) {
		parentView.local2globalCoordinate(Point(0.0, 0.0));
	} else if (length(p) >= 2) {
		child = p[0];
		n = length(^(childViews));
		if (child < n) {
			childView = ^(childViews)[child];

			if (length(p) == 2) {
				// This is a case when we have a text in the paragraph
				parentView.local2globalCoordinate(childView.index2point(p[1]))
			} else {
				// This is most likely a recursive, so it can handle the rest of it
				childView.view.getGlobalCoordinate(tail(p));
			}
		} else if (child > 0) {
			// Let's try to find some similar place instead of throw an error
			getGlobalCoordinate(parentView, element, childViews, concat([child - 1], tail(p)))
		} else {
			println("Broken path " + toString(p) + " in " + element2string(element));
			Point(0.0, 0.0)
		}
	} else {
		devtrace("getGlobalCoordinate in a paragraph defaults to 0.0 for path: " + toString(p));
		Point(0.0, 0.0)
	}
}

makeCursorClickHandler(state : WigiEditorState, clicksHistory : ref [CursorClick], tvs : [TextViewAcc]) -> (CursorClick) -> void {
	\c : CursorClick -> {
		refArrayPush(clicksHistory, c);
		if (length(^clicksHistory) > 3) clicksHistory := tail(^clicksHistory);

		// We scan all children and pick the closest at the current/last line
		md : Pair<PathDistance, Maybe<TextViewAcc>> = fold(tvs, Pair(dummyPathDistance, None()), \acc : Pair<PathDistance, Maybe<TextViewAcc>>, tv : TextViewAcc -> {
			dist = tv.pointDistance(Point(c.x, c.y));
			if (isNewDistanceLess(acc.first, dist))
				Pair(dist, Some(tv))
			else
				acc;
		});

		newCursor = md.first.path;

		if (allowCursorClick(state, c, newCursor)) {
			// If it's recursive, we should go deeper, otherwise we're done
			el = getElementAtPosition(getValue(state.document), newCursor);
			switch (el: WigiElement) {
				WigiRecursive(e, t, s): {
					// convert coordinate to local coordinates
					maybeApply(md.second, \tv -> {
						localPoint = tv.index2point(0);
						point = Point(c.x - localPoint.x, c.y - localPoint.y);
						// println("Recursive point is local " + toString(point) + " while we are supposed to be at " + toString(localPoint));
						tv.view.setCursor(point, c.selecting, c.mouseClick) |> ignore;
					});
				}
				default: {
					if (c.mouseClick) {
						if (c.selecting) {
							cellCursor = adjustCursorForSelection(state, newCursor);
							wigiSetCursor(state, cellCursor, c.selecting);
						} else {
							//handle double and triple clicks
							if (isTripleClick(^clicksHistory)) {
								wigiSendEvent(state, WigiSelectSentence()) |> ignore;
							} else if (isDoubleClick(^clicksHistory)) {
								wigiSendEvent(state, WigiSelectWord()) |> ignore;
							} else {
								wigiSetCursor3(state, newCursor, c.selecting, true, false);
							}
						}
					} else {
						wigiSetCursor(state, newCursor, c.selecting);
					}
				}
			}
		}
	}
}

makeSelectionChangeHandler(state : WigiEditorState, parentView : ParentView, element : WigiParagraph, fullySelected : DynamicBehaviour<bool>) {
	\s -> nextDistinct(fullySelected, {
		if (isEmptySelection(s)) {
			false
		} else {
			isInsideWigiSelection(s, parentView.getPath(), element, getValue(state.document), !getValue(state.editMode))
		}
	})
}

makeInitialPosition() {
	PositionInside(make(0.0), make(0.0), make(0.0), make(0.0), make(0), make(0));
}

makeCursorSetter(state : WigiEditorState, parentView : ParentView, wh : Behaviour<WidthHeight>, cursorInside : PositionInside, click : DynamicBehaviour<CursorClick>) {
	\p : Point, setWant : bool, selecting : bool, isMouseEvent : bool -> {

		ph : WidthHeight = getValue(wh);

		/* This condition probably should be ORed, not ANDed. Is it a mistake or why it is ANDed?
		 * Guess, wantedX should be set anyway if flag is given, and if not, we may or may not give it a value
		 * if it does not have any (-1 means that).
		 * If ANDed, there is no way to change wantedX when navigating with arrow left/right,
		 * whilst that is expected behaviour. Potential change has passed unit tests with no issues.*/
		if (setWant && getValue(state.cursorWantThisX) == -1.0) {
			gp = parentView.local2globalCoordinate(p);
			// println("Setting " + toString(p)  + " to global " + toString(gp));
			next(state.cursorWantThisX, gp.x);
		}

		if (0.0 <= p.y && p.y < ph.height) {
			oldCursor = getValue(state.cursor);
			next(click, CursorClick(p.x, p.y, selecting, isMouseEvent, timestamp()));
			if (oldCursor == getValue(state.cursor)) {
				// we are at the same place after handling CursorClick
				if (p.y > getValue(cursorInside.y)) {
					// but we are going to go down. Probably, we are situated above the shorter line,
					// so go to the last position of the next line
					next(click, CursorClick(0.0, p.y, selecting, isMouseEvent, timestamp()));
					moveCursorToEndOfLine(state, wh, cursorInside, selecting);
				} else if (p.y < getValue(cursorInside.y)) {
					// but we are going to go up. Probably, we are situated under the first line indent,
					// so go to the beginning of the previous line
					moveCursorToStartOfLine(state, cursorInside, selecting);
					wigiMoveCursor(state, -1, selecting);
					moveCursorToStartOfLine(state, cursorInside, selecting);
				}
			}
			true
		} else {
			// Tell our parent that it needs to handle this guy
			pc = parentView.getParentCoordinate(p);
			parentView.setParentCursor(pc, selecting, isMouseEvent)
		}
	}
}

addStylesToBlock(block: WigiBlock, styles: [WigiStyles]) -> WigiBlock {
	documentStyleIndex = findi(styles, \s -> s.type == "WigiDocument");

	switch(documentStyleIndex: Maybe) {
		Some(i): {
			foundStyles = styles[i].textStyle;
			newStyles = mergeStyles(block.style, foundStyles);
			WigiBlock(block.type, newStyles);
		}
		None(): {
			block;
		};
	}
}

mergeStyles(a, b) {
	fold(b, a, \acc, v -> {
		if (exists(acc, \x -> isSameStructType(x, v)))
			acc
		else
			arrayPush(acc, v);
	});
}
