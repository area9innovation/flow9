import wigi/wigi_value;
import wigi/excel_stats;
import wigi/excel_math;
import wigi/excel_logical;
import wigi/excel_text;
import wigi/excel_information;
import wigi/excel_lookup;
import wigi/excel_datetime;
import wigi/excel_common;
import formats/json/json;
import target;

export {
	// Definition of a builtin function. If args is -1, then it is overloaded and takes any number of arguments
	WigiBuiltin : (name : string, args : int, fn : ([WigiValue]) -> WigiValue);

	//see wigi_financial_builtins.flow for additional functionality
	getWigiBuiltIns() -> Tree<string, WigiBuiltin>;

	//be careful, it can rewrite already exists functionality
	addWigiBuiltIns(builtins : Tree<string, WigiBuiltin>) -> void;

	addWigiNumbers(l : WigiValue, r : WigiValue) -> WigiValue;

	compareWigiValues(l : WigiValue, r : WigiValue) -> int;

	isWigiErrorVariableUndefined(error : WigiValue) -> bool;
}

wigiBuiltInsRef : ref Maybe<Tree<string, WigiBuiltin>> = ref None();
getWigiBuiltIns() -> Tree<string, WigiBuiltin> {
	onlyOnce(wigiBuiltInsRef, \ -> {
		values2tree([
				WigiBuiltin("+", -1, \args -> fold(map(args, prepareArg), WigiDefaultValue(), \acc, a -> addWigiNumbers(acc, a))),
				WigiBuiltin("-", -1, \args -> {
						n = length(args);
						if (n == 0) {
							WigiError("Expected at least one argument to -");
						} else if (n <= 1) {
							// Prefix minus
							subtractWigiNumbers(WigiInt(0), args[0])
						} else {
							subtractWigiNumbers(prepareArg(args[0]), prepareArg(args[1]))
						}
					}),
				WigiBuiltin("*", 2, \args -> multiplyWigiNumbers(args[0], args[1])),
				WigiBuiltin("/", 2, \args -> divideWigiNumbers(args[0], args[1])),
				WigiBuiltin("^", 2, \args -> exponentWigiNumbers(args[0], args[1])),
				WigiBuiltin("e", 2, \args -> multiplyWigiNumbers(args[0], exponentWigiNumbers(WigiInt(10), args[1]))),
				WigiBuiltin("=", 2, \args -> WigiBool(compareWigiValues(args[0], args[1]) == 0)),
				WigiBuiltin("==", 2, \args -> WigiBool(compareWigiValues(args[0], args[1]) == 0)),
				WigiBuiltin("<>", 2, \args -> WigiBool(compareWigiValues(args[0], args[1]) != 0)),
				WigiBuiltin("!=", 2, \args -> WigiBool(compareWigiValues(args[0], args[1]) != 0)),
				WigiBuiltin("<=", 2, \args -> WigiBool(compareWigiValues(args[0], args[1]) <= 0)),
				WigiBuiltin(">=", 2, \args -> WigiBool(compareWigiValues(args[0], args[1]) >= 0)),
				WigiBuiltin(">", 2, \args -> WigiBool(compareWigiValues(args[0], args[1]) > 0)),
				WigiBuiltin("<", 2, \args -> WigiBool(compareWigiValues(args[0], args[1]) < 0)),

				WigiBuiltin("&", 2, \args -> addWigiNumbers(args[0], args[1])), // string concatenation

				WigiBuiltin("[", 2, \args -> wigiArrayIndex(args[0], args[1])),
				WigiBuiltin("and", 2, \args -> calculateLogicalExp(args[0], args[1], true)),
				WigiBuiltin("or", 2, \args -> calculateLogicalExp(args[0], args[1], false)),
				WigiBuiltin("not", 1, \args -> calculateNotExp(args[0])),
				// "^" power
				// "%" postfix   percentage

				//////////////////
				// Date and time functions: http://office.microsoft.com/en-001/excel-help/date-and-time-functions-reference-HP010342402.aspx
				//////////////////

				// From date/time
				WigiBuiltin("DATE", -1, \args -> wigiDate(args)), 			// Date (3 numbers) -> serial number
				WigiBuiltin("DATEVALUE", 1, \args -> wigiDateValue(args)), 	// Date (WigiString or WigiDate) -> serial number
				WigiBuiltin("VALUEDATE", 1, \args -> wigiValueDate(args)), 	// Serial number -> date (string)


				WigiBuiltin("TIME", 3, \args -> wigiTime(args)), 			// Time (3 numbers) -> serial number
				WigiBuiltin("TIMEVALUE", 1, \args -> wigiTimeValue(args)), 	// Time (string) -> serial number
				WigiBuiltin("VALUETIME", 1, \args -> wigiValueTime(args)), 	// Serial number -> time (string)

				WigiBuiltin("TODAY", 0, \args -> wigiToday()), 				// Current date in WigiDate format

				WigiBuiltin("NOW", -1, \args -> wigiNow(args)),				// Current time and date -> string (args - for the time offset for particar time zone; if there are no arguments, then function returns local time)

				// You can pass WigiDate, WigiString in Date format, or Serial number to these next functions
				// Calculates the number of days, months, or years between two dates.
				WigiBuiltin("DATEDIF", 3, wigiDateDif),
				WigiBuiltin("SECOND", 1, \args -> wigiSecond(args)), 	// Serial number, or WigiDate, or WigiString in date format -> second
				WigiBuiltin("MINUTE", 1, \args -> wigiMinute(args)), 	// Serial number, or WigiDate, or WigiString in date format -> minute
				WigiBuiltin("HOUR", 1, \args -> wigiHour(args)), 		// Serial number, or WigiDate, or WigiString in date format -> hour
				WigiBuiltin("DAY", 1, \args -> wigiDay(args)), 			// Serial number, or WigiDate, or WigiString in date format -> day of the month
				WigiBuiltin("MONTH", 1, \args -> wigiMonth(args)), 		// Serial number, or WigiDate, or WigiString in date format -> month
				WigiBuiltin("YEAR", 1, \args -> wigiYear(args)), 		// Serial number, or WigiDate, or WigiString in date format -> year

				WigiBuiltin("WEEKDAY", -1, \args -> wigiWeekDay(args)), // Serial number, or WigiDate, or WigiString in date format -> day of the week
				WigiBuiltin("WEEKNUM", -1, \args -> wigiWeekNum(args)), // Serial number, or WigiDate, or WigiString in date format -> number representing where the week falls numerically with a year

				// Misc
				WigiBuiltin("DAYS360", -1, \args -> wigiDays360(args)), // Calculates the number of days between two dates based on a 360-day year
				WigiBuiltin("DAYS", 2, \args -> wigiDays(args)), // Returns the number of days between two dates.
				WigiBuiltin("NETWORKDAYS", -1, \args -> wigiNetworkDays(args)), // Returns the number of whole workdays between two dates
				WigiBuiltin("NETWORKDAYS_INTL", -1, \args -> wigiNetworkDaysIntl(args)), // Returns the number of whole workdays between two dates using parameters to indicate which and how many days are weekend days
				WigiBuiltin("WORKDAY", -1, \args -> wigiWorkDay(args)), // Returns the serial number of the date before or after a specified number of workdays
				WigiBuiltin("WORKDAY_INTL", -1, \args -> wigiWorkDayIntl(args)), // Returns the serial number of the date before or after a specified number of workdays using parameters to indicate which and how many days are weekend days
				WigiBuiltin("YEARFRAC", -1, \args -> wigiYearFrac(args)), // Returns the year fraction representing the number of whole days between start_date and end_date

				WigiBuiltin("EDATE", 2, \args -> wigiEDate(args)), // EDATE	Returns the serial number of the date that is the indicated number of months before or after the start date
				WigiBuiltin("EOMONTH", 2, \args -> wigiEOMonth(args)), // EOMONTH	Returns the serial number of the last day of the month before or after a specified number of months

				// Engineering functions: http://office.microsoft.com/en-001/excel-help/engineering-functions-HP005199996.aspx

				// BESSELI	Returns the modified Bessel function In(x)
				// BESSELJ	Returns the Bessel function Jn(x)
				// BESSELK	Returns the modified Bessel function Kn(x)
				// BESSELY	Returns the Bessel function Yn(x)
				// BIN2DEC	Converts a binary number to decimal
				// BIN2HEX	Converts a binary number to hexadecimal
				// BIN2OCT	Converts a binary number to octal
				// COMPLEX	Converts real and imaginary coefficients into a complex number
				// CONVERT	Converts a number from one measurement system to another
				// DEC2BIN	Converts a decimal number to binary
				// DEC2HEX	Converts a decimal number to hexadecimal
				// DEC2OCT	Converts a decimal number to octal
				// DELTA	Tests whether two values are equal
				WigiBuiltin("ERF", 1, \args -> wigiErf(args)),
				// ERFC	Returns the complementary error function
				// GESTEP	Tests whether a number is greater than a threshold value
				// HEX2BIN	Converts a hexadecimal number to binary
				// HEX2DEC	Converts a hexadecimal number to decimal
				// HEX2OCT	Converts a hexadecimal number to octal
				// IMABS	Returns the absolute value (modulus) of a complex number
				// IMAGINARY	Returns the imaginary coefficient of a complex number
				// IMARGUMENT	Returns the argument theta, an angle expressed in radians
				// IMCONJUGATE	Returns the complex conjugate of a complex number
				// IMCOS	Returns the cosine of a complex number
				// IMDIV	Returns the quotient of two complex numbers
				// IMEXP	Returns the exponential of a complex number
				// IMLN	Returns the natural logarithm of a complex number
				// IMLOG10	Returns the base-10 logarithm of a complex number
				// IMLOG2	Returns the base-2 logarithm of a complex number
				// IMPOWER	Returns a complex number raised to an integer power
				// IMPRODUCT	Returns the product of from 2 to 29 complex numbers
				// IMREAL	Returns the real coefficient of a complex number
				// IMSIN	Returns the sine of a complex number
				// IMSQRT	Returns the square root of a complex number
				// IMSUB	Returns the difference between two complex numbers
				// IMSUM	Returns the sum of complex numbers
				// OCT2BIN	Converts an octal number to binary
				// OCT2DEC	Converts an octal number to decimal
				// OCT2HEX	Converts an octal number to hexadecimal

				// Information functions: http://office.microsoft.com/en-001/excel-help/information-functions-HP005200861.aspx

				// CELL	Returns information about the formatting, location, or contents of a cell
				// ERROR.TYPE	Returns a number corresponding to an error type
				// INFO	Returns information about the current operating environment
				// ISBLANK	Returns TRUE if the value is blank
				// ISERR	Returns TRUE if the value is any error value except #N/A
				// *ISERROR	Returns TRUE if the value is any error value
				// ISEVEN	Returns TRUE if the number is even
				WigiBuiltin("ISLOGICAL", 1, \args -> wigiIsLogical(args[0])),
				// *ISNA	Returns TRUE if the value is the #N/A error value
				// ISNONTEXT	Returns TRUE if the value is not text
				WigiBuiltin("ISNUMBER", 1, \args -> wigiIsNumber(args[0])),
				// ISODD	Returns TRUE if the number is odd
				// ISREF	Returns TRUE if the value is a reference
				WigiBuiltin("ISTEXT", 1, \args -> wigiIsText(args[0])),

				WigiBuiltin("WIGI2TEXT", 1, \args -> wigiValue2Text(args[0])),
				// Check if WigiValue contains letters only
				WigiBuiltin("ISLETTER", 1, \args -> wigiIsLetter(args[0])),
				// N	Returns a value converted to a number
				// NA	Returns the error value #N/A
				// TYPE	Returns a number indicating the data type of a value

				// Lookup and reference functions: http://office.microsoft.com/en-001/excel-help/lookup-and-reference-functions-HP005201149.aspx

				// ADDRESS	Returns a reference as text to a single cell in a worksheet
				// AREAS	Returns the number of areas in a reference
				WigiBuiltin("CHOOSE", -1, \args -> wigiChoose(args)),

				WigiBuiltin("COLUMN", -1, \args -> wigiColumn(args)),
				WigiBuiltin("COLUMNS", -1, \args -> wigiColumns(args)),
				// GETPIVOTDATA	Returns data stored in a PivotTable
				// HLOOKUP	Looks in the top row of an array and returns the value of the indicated cell
				// HYPERLINK	Creates a shortcut or jump that opens a document stored on a network server, an intranet, or the Internet
				WigiBuiltin("INDEX", -1, \args -> wigiIndex(args)),
				// *INDIRECT	Returns a reference indicated by a text value
				WigiBuiltin("LOOKUP", -1, \args -> wigiLookUp(args)),
				// MATCH	Looks up values in a reference or array
				WigiBuiltin("MATCH", -1, \args -> wigiMatch(args)),
				// TAGMATCH returns true if intersection of two sets of tags is not empty. Third argument is optional, default: ','.
				WigiBuiltin("TAGMATCH", -1, wigiTagMatch),
				// OFFSET	Returns a reference offset from a given reference
				WigiBuiltin("ROW", -1, \args -> wigiRow(args)),
				WigiBuiltin("ROWS", -1, \args -> wigiRows(args)),
				// RTD	Retrieves real-time data from a program that supports COM automation
				WigiBuiltin("TRANSPOSE", -1, wigiTranspose),
				// VLOOKUP	Looks in the first column of an array and moves across the row to return the value of a cell


				// Statistical functions: http://office.microsoft.com/en-001/excel-help/statistical-functions-HP005203066.aspx

				WigiBuiltin("AVEDEV", -1, \args -> wigiAvedev(args)),
				WigiBuiltin("AVERAGE", -1, \args -> wigiAverage(args)),
				// AVERAGEA
				// BETADIST
				// BETAINV
				WigiBuiltin("BINOMDIST", 4, \args -> wigiBinomdist(args)),
				WigiBuiltin("CHISQDIST", 3, \args -> wigiChiSqDist(args)),
				WigiBuiltin("CHISQINV", 2, \args -> wigiChiSqInv(args)),
				// CHIDIST
				// CHIINV
				// CHITEST
				// *CONFIDENCE
				// CORREL

				WigiBuiltin("COUNT", -1, \args -> wigiCount(args)),
				WigiBuiltin("COUNTA", 1, \args -> wigiCountA(args)),
				// COUNTBLANK
				WigiBuiltin("COUNTIF", 2, \args -> wigiCountIf(args)),
				// COVAR
				// CRITBINOM
				// DEVSQ
				// EXPONDIST
				WigiBuiltin("FDIST", 3, \args -> wigiFdist(args)),
				WigiBuiltin("FDISTLT", 4, \args -> wigiFdistLT(args)),
				// FINV
				// FISHER
				// FISHERINV
				// FORECAST
				// FREQUENCY
				// FTEST
				// GAMMADIST
				// GAMMAINV	Returns the inverse of the gamma cumulative distribution
				// GAMMALN	Returns the natural logarithm of the gamma function, Î“(x)
				// GEOMEAN	Returns the geometric mean
				// GROWTH	Returns values along an exponential trend
				// HARMEAN	Returns the harmonic mean
				// HYPGEOMDIST	Returns the hypergeometric distribution
				// INTERCEPT	Returns the intercept of the linear regression line
				WigiBuiltin("KURT", -1, \args -> wigiKurt(args)),
				WigiBuiltin("LARGE", -1, \args -> wigiLargeSmall(args, true)),
				// LINEST	Returns the parameters of a linear trend
				// LOGEST	Returns the parameters of an exponential trend
				// LOGINV	Returns the inverse of the lognormal distribution
				// LOGNORMDIST	Returns the cumulative lognormal distribution
				WigiBuiltin("MAX", -1, \args -> wigiMinMax(args, false)),
				// MAXA	Returns the maximum value in a list of arguments, including numbers, text, and logical values
				WigiBuiltin("MEDIAN", -1, \args -> wigiMedian(args)),
				WigiBuiltin("MIN", -1, \args -> wigiMinMax(args, true)),
				// MINA	Returns the smallest value in a list of arguments, including numbers, text, and logical values
				WigiBuiltin("MODE", -1, \args -> wigiMode(args)),
				// NEGBINOMDIST	Returns the negative binomial distribution
				WigiBuiltin("NORMDIST", 4, \args -> wigiNormdist(args)),
				WigiBuiltin("NORMINV", 3, \args -> wigiNormInv(args)),
				// NORMSDIST	Returns the standard normal cumulative distribution
				// NORMSINV	Returns the inverse of the standard normal cumulative distribution
				// PEARSON	Returns the Pearson product moment correlation coefficient
				WigiBuiltin("PERCENTILE", -1, \args -> wigiPercentile(args)),
				// PERCENTRANK	Returns the percentage rank of a value in a data set
				// PERMUT	Returns the number of permutations for a given number of objects
				WigiBuiltin("POISSON", 3, \args -> wigiPoisson(args)),
				// PROB	Returns the probability that values in a range are between two limits
				// QUARTILE	Returns the quartile of a data set
				// RANK	Returns the rank of a number in a list of numbers
				// RSQ	Returns the square of the Pearson product moment correlation coefficient
				WigiBuiltin("SKEW", -1, \args -> wigiSkew(args)),
				// SLOPE	Returns the slope of the linear regression line
				WigiBuiltin("SMALL", -1, \args -> wigiLargeSmall(args, false)),
				// STANDARDIZE	Returns a normalized value
				WigiBuiltin("STDEV", -1, \args -> wigiStdev(args)),
				WigiBuiltin("STDEVA", -1, \args -> wigiStdevA(args)),
				WigiBuiltin("STDEVP", -1, \args -> wigiStdevP(args)),
				WigiBuiltin("STDEVPA", -1, \args -> wigiStdevPa(args)),
				// STEYX	Returns the standard error of the predicted y-value for each x in the regression
				WigiBuiltin("TDIST", 3, \args -> wigiTdist(args)),
				WigiBuiltin("TINV", 2, \args -> wigiTInv(args)),
				// TREND	Returns values along a linear trend
				// TRIMMEAN	Returns the mean of the interior of a data set
				// *TTEST	Returns the probability associated with a Student's t-test
				WigiBuiltin("VAR", -1, \args -> wigiVar(args)),
				WigiBuiltin("VARA", -1, \args -> wigiVarA(args)),
				WigiBuiltin("VARP", -1, \args -> wigiVarP(args)),
				WigiBuiltin("VARPA", -1, \args -> wigiVarPa(args)),
				// WEIBULL	Returns the Weibull distribution
				// ZTEST	Returns the one-tailed probability-value of a z-test


				// Math and Trig functions (http://office.microsoft.com/en-001/excel-help/math-and-trigonometry-functions-HP005201253.aspx)

				WigiBuiltin("ABS", -1, \args -> wigiAbs(args)),
				WigiBuiltin("ACOS", -1, \args -> wigiAcos(args)),
				WigiBuiltin("ACOSH", 1, \args -> wigiAcosh(args)),
				WigiBuiltin("ASIN", -1, \args -> wigiAsin(args)),
				WigiBuiltin("ASINH", 1, \args -> wigiAsinh(args)),
				WigiBuiltin("ATAN", -1, \args -> wigiAtan(args)),
				WigiBuiltin("ATAN2", -1, \args -> wigiAtan2(args)),
				WigiBuiltin("ATANH", 1, \args -> wigiAtanh(args)),
				WigiBuiltin("CEILING", -1, \args -> wigiAtan2(args)),
				WigiBuiltin("COMBIN", 2, \args -> wigiCombin(args)),
				WigiBuiltin("COS", -1, \args -> wigiCos(args)),
				WigiBuiltin("COSH", 1, \args -> wigiCosh(args)),
				WigiBuiltin("DEGREES", 1, \args -> wigiDegrees(args)),
				WigiBuiltin("EVEN", 1, \args -> wigiEven(args)),
				WigiBuiltin("EXP", -1, \args -> wigiExp(args)),
				WigiBuiltin("FACT", -1, \args -> wigiFact(args)),
				WigiBuiltin("FACTDOUBLE", -1, \args -> wigiFactDouble(args)),
				WigiBuiltin("FLOOR", -1, \args -> wigiFloor(args)),
				WigiBuiltin("GCD", -1, \args -> wigiGsd(args)),
				WigiBuiltin("INT", -1, \args -> wigiInt(args)),
				WigiBuiltin("LCM", -1, \args -> wigiLcm(args)),
				WigiBuiltin("LN", -1, \args -> wigiLn(args)),
				WigiBuiltin("LOG", -1, \args -> wigiLog(args)),
				WigiBuiltin("LOG10", -1, \args -> wigiLog10(args)),
				WigiBuiltin("MDETERM", -1, \args -> wigiMDeterm(args)),
				WigiBuiltin("MINVERSE", -1, \args -> wigiMInverse(args)),
				WigiBuiltin("MMULT", -1, \args -> wigiMMult(args)),
				WigiBuiltin("MOD", -1, \args -> wigiMod(args)),
				WigiBuiltin("MROUND", 2, \args -> wigiMRound(args)),
				WigiBuiltin("MULTINOMIAL", -1, \args -> wigiMultinominal(args)),
				WigiBuiltin("ODD", 1, \args -> wigiOdd(args)),
				WigiBuiltin("PI", 0, \args -> wigiPi()),
				WigiBuiltin("POWER", -1, \args -> wigiPower(args)),
				WigiBuiltin("PRODUCT", -1, \args -> wigiProduct(args)),
				WigiBuiltin("QUOTIENT", 2, \args -> wigiQuotient(args)),
				WigiBuiltin("RADIANS", 1, \args -> wigiRadians(args)),
				WigiBuiltin("RAND", 0, \args -> wigiRand()),
				WigiBuiltin("RANDINT", 2, \args -> wigiRandInt(args)),
				WigiBuiltin("RANDBETWEEN", -1, \args -> wigiRandBetween(args)),
				WigiBuiltin("ROMAN", -1, \args -> wigiRoman(args)),
				WigiBuiltin("ROUND", -1, \args -> wigiRound(args)),
				WigiBuiltin("ROUNDDOWN", 2, \args -> wigiRoundDown(args)),
				WigiBuiltin("ROUNDUP", 2, \args -> wigiRoundUp(args)),
				WigiBuiltin("SERIESSUM", 4, \args -> wigiSeriesSum(args)),
				WigiBuiltin("SIGN", -1, \args -> wigiSign(args)),
				WigiBuiltin("SIN", -1, \args -> wigiSin(args)),
				WigiBuiltin("SINH", 1, \args -> wigiSinh(args)),
				WigiBuiltin("SQRT", -1, \args -> wigiSqrt(args)),
				WigiBuiltin("SQRTPI", -1, \args -> wigiSqrtPi(args)),
				WigiBuiltin("SUBTOTAL", 2, \args -> wigiSubtotal(args)),
				WigiBuiltin("SUM", -1, \args -> wigiSum(args)),
				WigiBuiltin("SUMIF", -1, \args -> wigiSumIf(args)),
				WigiBuiltin("SUMPRODUCT", -1, \args -> wigiSumProduct(args)),
				WigiBuiltin("SUMSQ", -1, \args -> wigiSumSQ(args)),
				WigiBuiltin("SUMX2MY2", 2, \args -> wigiSumX2MY2(args)),
				WigiBuiltin("SUMX2PY2", 2, \args -> wigiSumX2PY2(args)),
				WigiBuiltin("TAN", -1, \args -> wigiTan(args)),
				WigiBuiltin("TANH", 1, \args -> wigiTanh(args)),
				WigiBuiltin("TRUNC", -1, \args -> wigiTrunc(args)),


				// Logical functions: http://office.microsoft.com/en-us/excel-help/logical-functions-reference-HP010342666.aspx

				WigiBuiltin("AND", -1, \args -> wigiAnd(args)),
				WigiBuiltin("OR", -1, \args -> wigiOr(args)),
				WigiBuiltin("NOT", -1, \args -> wigiNot(args)),
				WigiBuiltin("IF", 3, wigiIf),
				WigiBuiltin("IFERROR", 2, \args -> wigiIfError(args)),

				// String functions: http://office.microsoft.com/en-001/excel-help/text-functions-reference-HP010079191.aspx

				// ASC (leave out)
				// BAHTTEXT (leave out)
				WigiBuiltin("CHAR", -1, \args -> wigiChar(args)),
				// CLEAN (leave out)
				WigiBuiltin("CODE", -1, \args -> wigiCode(args)),
				//Concatenate WigiValues in a text
				WigiBuiltin("CONCATENATE", -1, \args -> wigiConcatenate(args)),
				// DOLLAR
				WigiBuiltin("EXACT", -1, \args -> wigiExact(args)),
				WigiBuiltin("FIND", -1, \args -> wigiFind(args)),
				// FIXED
				// JIS (leave out)
				WigiBuiltin("LEFT", -1, \args -> wigiLeftRight(args,true)),
				WigiBuiltin("LEN", -1, \args -> wigiLen(args)),
				WigiBuiltin("LOWER", -1, \args -> wigiUpperLower(args, false)),
				WigiBuiltin("MID", -1, \args -> wigiMid(args)),
				// PHONETIC (leave out)
				WigiBuiltin("PROPER", -1, \args -> wigiProper(args)),
				WigiBuiltin("REPLACE", -1, \args -> wigiReplaceExcel(args)),
				WigiBuiltin("REPT", -1, \args -> wigiRept(args)),
				WigiBuiltin("RIGHT", -1, \args -> wigiLeftRight(args,false)),
				// SEARCH
				// SUBSTITUTE
				// T
				WigiBuiltin("TEXT", -1, wigiText),
				WigiBuiltin("TRIM", -1, \args -> wigiTrim(args)),
				WigiBuiltin("UPPER", -1, \args -> wigiUpperLower(args, true)),
				// VALUE
				WigiBuiltin("VALUE", 1, \args -> wigiExcelValue(args[0])),

				//
				// Our own inventions
				//

				WigiBuiltin("FLATTEN", -1, wigiFlatten),
				// TARGET("JS") is true on JS, and so on
				WigiBuiltin("TARGET", 1, \args -> {
					target = toLowerCase(getWigiText(args[0]));
					WigiBool(strContains(toLowerCase(getTargetName()), target));
				}),
				// Returns true if value is default or if it's empty string
				WigiBuiltin("ISEMPTY", 1, \args -> wigiIsEmpty(args[0])),
				//Concatenate two WigiArrays or add WigiValue to WigiArrays
				WigiBuiltin("CONCAT", -1, \args -> concatArrays(args)),
				//Shuffle the elements of the array in random order. Parameters: array
				WigiBuiltin("SHUFFLE", 1, \args -> wigiShuffle(args[0])),
				// Returns subrange of a given array. Parameters: array, index, length
				WigiBuiltin("SUBRANGE", 3, \args -> wigiSubrange(args)),
				// Converts parameter to json and returns it as string
				WigiBuiltin("JSONSTRING", 1, \args -> wigiValue2json(args[0]) |> json2string |> WigiString),
				// Converts json to wigi value
				WigiBuiltin("JSON2WIGI", 1, \args -> wigiValue2String(args[0]) |> parseJson |> json2WigiValue),

				// Returns true if the array contains the given value. Parameters: array, value
				WigiBuiltin("CONTAINS", -1, \args -> wigiContains(args)),
				// Builds array of all fields values of the given record
				// Also can be used to convert JSON style associated array to a normal array
				// {0:"a",1:"b",2:"c"} -> ["a", "b", "c"]
				WigiBuiltin("FIELDSVALUES", -1, \args -> wigiFieldsValues(args)),
				// Builds array of all fields names of the given record
				WigiBuiltin("FIELDSNAMES", -1, \args -> wigiFieldsNames(args)),
				// Cuts string to passed size if string longer then it and adds ellipsis in the end
				WigiBuiltin("ELLIPSIS", 2, \args -> wigiEllipsis(args)),
				// Takes number and generates passed quantity of random chars. If nothing is passed only one char will be generated
				WigiBuiltin("RANDOMCHAR", -1, wigiRandomChar),
				// Takes two wigi records and makes new one with fields both from first and second ones
				WigiBuiltin("MERGERECORDS", -1, wigiMergeRecords),
			],
			\b : WigiBuiltin -> b.name
		)
	})
}

addWigiBuiltIns(builtins : Tree<string, WigiBuiltin>) -> void {
	wigiBuiltInsRef := mergeTree(getWigiBuiltIns(), builtins) |> Some;
};

calculateNotExp(l : WigiValue) -> WigiValue {
	switch (l : WigiValue) {
		WigiBool(v1): WigiBool(!v1);
		default: WigiError("Invalid type of argument. Only bool type is valid.");
	}
}

concatArrays(args : [WigiValue]) -> WigiValue {
	if (length(args) < 1) WigiError("Wrong number of arguments. Expected 1 or more , but got 0.")
	else switch (args[0] : WigiValue) {
		WigiArray(lv): {
			WigiArray(fold(tail(args), lv, \a, b -> {
		       	switch (b : WigiValue) {
					WigiArray(rv): concat(a, rv);
					default: {
						arrayPush(a, b);
					}
				}
			}))
		}
		default: WigiError("Invalid type of first argument. Only array type is valid.");
	}
}


calculateLogicalExp(l : WigiValue, r : WigiValue, isAndOp : bool) -> WigiValue {
	switch (l : WigiValue) {
		WigiBool(v1): {
			switch (r : WigiValue) {
				WigiBool(v2): WigiBool(if (isAndOp) v1 && v2 else v1 || v2);
				default: WigiError("Invalid type of argument. Only bool type is valid.");
			}
		}
		default: WigiError("Invalid type of argument. Only bool type is valid.");
	}
}

makeWigiErrorVariableUndefined(varName : string) -> WigiError {
	WigiError("Variable '" + varName + "' is undefined.");
}

isWigiErrorVariableUndefined(error : WigiValue) -> bool {
	switch (error : WigiValue) {
		WigiError(msg): startsWith(msg, "Variable '") && endsWith(msg, "' is undefined.");
		default: false;
	}
}

addWigiNumbers(l : WigiValue, r : WigiValue) -> WigiValue {
	switch (l : WigiValue) {
		WigiBool(b): WigiError("Can't add bools");
		WigiDouble(lv): {
			switch (r : WigiValue) {
				WigiBool(rv): WigiError("Can't add bools");
				WigiInt(rv): WigiDouble(lv + i2d(rv));
				WigiDouble(rv): WigiDouble(lv + rv);
				WigiString(rv): WigiString(d2s(lv) + rv);
				WigiDate(y, m, d): WigiError("Can't add date");
				WigiTime(h, m, s): WigiError("Can't add time");
				WigiError(m): r;
				WigiArray(vs): WigiError("Can't add array");
				WigiLambda(args, body): WigiError("Can't add function");
				WigiDefaultValue(): l;
				WigiElementValue(e): addWigiNumbers(l, getWigiElementValue(e));
				WigiBuiltInName(n): makeWigiErrorVariableUndefined(n);
				WigiRecord(fs):  WigiError("Can't add record");
			}
		}
		WigiInt(lv): {
			switch (r : WigiValue) {
				WigiBool(rv): WigiError("Can't add bools");
				WigiInt(rv): WigiInt(lv + rv);
				WigiDouble(rv): WigiDouble(i2d(lv) + rv);
				WigiString(rv): WigiString(i2s(lv) + rv);
				WigiDate(y, m, d) : dateValue2WigiDate(lv + getDateValueFromWigi(r));
				WigiTime(h, m, s): WigiError("Can't add time");
				WigiError(m): r;
				WigiArray(vs): WigiError("Can't add array");
				WigiLambda(args, body): WigiError("Can't add function");
				WigiDefaultValue(): l;
				WigiElementValue(e): addWigiNumbers(l, getWigiElementValue(e));
				WigiBuiltInName(n): makeWigiErrorVariableUndefined(n);
				WigiRecord(fs):  WigiError("Can't add record");
			}
		}
		WigiArray(vs): WigiError("Can't add array");
		WigiError(m): l;
		WigiString(s): {
			switch (r : WigiValue) {
				WigiBool(rv): WigiError("Can't add bools");
				WigiInt(rv): WigiString(s + i2s(rv));
				WigiDouble(rv): WigiString(s + d2s(rv));
				WigiString(rv): WigiString(s + rv);
				WigiDate(y, m, d): WigiError("Can't add date");
				WigiTime(h, m, s1): WigiError("Can't add time");
				WigiError(m): r;
				WigiArray(vs): WigiError("Can't add array");
				WigiLambda(args, body): WigiError("Can't add function");
				WigiDefaultValue(): l;
				WigiElementValue(e): addWigiNumbers(l, getWigiElementValue(e));
				WigiBuiltInName(n): makeWigiErrorVariableUndefined(n);
				WigiRecord(fs):  WigiError("Can't add record");
			}
		}
		WigiDate(__, __, __): {
			lv = getDateValueFromWigi(l);
			switch (r : WigiValue) {
				WigiInt(rv) : dateValue2WigiDate(lv + rv);
				WigiDate(__, __, __) : dateValue2WigiDate(lv + getDateValueFromWigi(r));
				default : WigiError("#VALUE!");
			}
		};
		WigiTime(h, m, s): WigiError("Can't add time");
		WigiLambda(args, body): WigiError("Can't add function");
		WigiDefaultValue(): r;
		WigiElementValue(e): addWigiNumbers(getWigiElementValue(e), r);
		WigiBuiltInName(n): makeWigiErrorVariableUndefined(n);
		WigiRecord(fs):  WigiError("Can't add record");
	}
}

subtractWigiNumbers(l : WigiValue, r : WigiValue) -> WigiValue {
	switch (l : WigiValue) {
		WigiBool(b): WigiError("Can't subtract bools");
		WigiDouble(v): {
			// TODO: Here, we should in fact avoid adding errors and bool
			WigiDouble(v - getWigiDouble(r));
		};
		WigiInt(lv): {
			switch (r : WigiValue) {
				WigiBool(rv): WigiError("Can't subtract bools");
				WigiInt(rv): WigiInt(lv - rv);
				WigiDouble(rv): WigiDouble(i2d(lv) - rv);
				WigiString(rv): WigiError("Can't subtract strings");
				WigiDate(y, m, d) : dateValue2WigiDate(lv - getDateValueFromWigi(r));
				WigiTime(h, m, s): WigiError("Can't subtract time");
				WigiError(m): r;
				WigiArray(vs): WigiError("Can't subtract array");
				WigiLambda(args, body): WigiError("Can't subtract function");
				WigiDefaultValue(): l;
				WigiElementValue(e): subtractWigiNumbers(l, getWigiElementValue(e));
				WigiBuiltInName(n): makeWigiErrorVariableUndefined(n);
				WigiRecord(fs):  WigiError("Can't subtract record");
			}
		}
		WigiError(m): l;
		WigiArray(vs): WigiError("Can't subtract array");
		WigiString(rv): WigiError("Can't subtract strings");
		WigiDate(__, __, __): {
			lv = getDateValueFromWigi(l);
			switch (r : WigiValue) {
				WigiInt(rv) : dateValue2WigiDate(lv - rv);
				WigiDate(__, __, __) : dateValue2WigiDate(lv - getDateValueFromWigi(r));
				default : WigiError("#VALUE!");
			}
		};
		WigiTime(h, m, s): WigiError("Can't subtract time");
		WigiLambda(args, body): WigiError("Can't subtract function");
		WigiDefaultValue(): {
			subtractWigiNumbers(WigiInt(0), r)
		}
		WigiElementValue(e): subtractWigiNumbers(getWigiElementValue(e), r);
		WigiBuiltInName(n): makeWigiErrorVariableUndefined(n);
		WigiRecord(fs):  WigiError("Can't subtract record");
	}
}

// multiply or return same value if not possible
multiplyByInt(value : WigiValue, c : int) -> WigiValue {
	switch (value : WigiValue) {
		WigiInt(vi): WigiInt(c * vi);
		WigiDouble(vd): WigiDouble(i2d(c) * vd);
		WigiRecord(vfs): map(vfs, \f -> Pair(f.first, multiplyByInt(f.second, c))) |> WigiRecord;
		WigiArray(vas): map(vas, \v -> multiplyByInt(v, c)) |> WigiArray;
		default: value;
	}
}

// multiply or return error if not possible
multiplyByIntIfPossible(value : WigiValue, c : int) -> WigiValue {
	switch (value : WigiValue) {
		WigiInt(rv): multiplyByInt(value, c);
		WigiDouble(rv): multiplyByInt(value, c);
		WigiArray(vs): multiplyByInt(value, c);
		// misc
		WigiDefaultValue(): WigiInt(c);
		WigiElementValue(e): multiplyWigiNumbers(WigiInt(c), getWigiElementValue(e));
		// error if can't multiply
		WigiError(m): value;
		WigiBool(rv): WigiError("Can't multiply bools");
		WigiString(s): {
			if (isDigits(s)) {
				ri = s2i(s);
				WigiInt(c * ri)
			} else if (isDouble(s)) {
				rd = s2d(s);
				WigiDouble(i2d(c) * rd)
			} else {
				WigiError("Can't multiply strings");
			}
		}
		WigiDate(y, m, d): WigiError("Can't multiply date");
		WigiTime(h, m, s): WigiError("Can't multiply time");
		WigiLambda(args, body): WigiError("Can't multiply function");
		WigiBuiltInName(n): makeWigiErrorVariableUndefined(n);
		WigiRecord(fs):  WigiError("Can't multiply record");
	}
}

multiplyWigiNumbers(l : WigiValue, r : WigiValue) -> WigiValue {
	switch (l : WigiValue) {
		WigiDouble(v): WigiDouble(v * getWigiDouble(r));
		WigiInt(lv): multiplyByIntIfPossible(r, lv);
		WigiString(s): {
			if (isDigits(s)) {
				li = s2i(s);
				multiplyByIntIfPossible(r, li);
			} else if (isDouble(s)) {
				ld = s2d(s);
				WigiDouble(ld * getWigiDouble(r))
			} else {
				WigiError("Can't multiply strings");
			}
		}
		WigiArray(vs): {
			switch(r) {
				WigiInt(rv): multiplyByInt(l, rv);
				WigiString(rs): {
					if (isDigits(rs)) {
						rsi = s2i(rs);
						multiplyByInt(l, rsi);
					} else {
						WigiError("Can't multiply strings");
					}
				}
				default: WigiError("Can't multiply arrays");
			}
		}
		// misc
		WigiDefaultValue(): r;
		WigiElementValue(e): multiplyWigiNumbers(getWigiElementValue(e), r);
		// error if can't multiply
		WigiError(m): l;
		WigiBool(b): WigiError("Can't multiply bools");
		WigiDate(y, m, d): WigiError("Can't multiply date");
		WigiTime(h, m, s): WigiError("Can't multiply time");
		WigiLambda(args, body): WigiError("Can't multiply function");
		WigiBuiltInName(n): makeWigiErrorVariableUndefined(n);
		WigiRecord(fs):  WigiError("Can't multiply record");
	}
}

exponentWigiNumbers(l : WigiValue, r : WigiValue) -> WigiValue {
	switch (l : WigiValue) {
		WigiBool(b): WigiError("Can't exponent bools");
		WigiDouble(v): eitherMap(dpow2(v, getWigiDouble(r)), \d -> WigiDouble(d), WigiError("Can't exponent"));
		WigiInt(lv): {
			switch (r : WigiValue) {
				WigiBool(rv): WigiError("Can't exponent bools");
				WigiInt(rv): eitherMap(dpow2(i2d(lv), i2d(rv)), \d -> WigiDouble(d), WigiError("Can't exponent"));
				WigiDouble(rv): eitherMap(dpow2(i2d(lv), rv), \d -> WigiDouble(d), WigiError("Can't exponent"));
				WigiString(rv): WigiError("Can't exponent strings");
				WigiDate(y, m, d): WigiError("Can't exponent date");
				WigiTime(h, m, s): WigiError("Can't exponent time");
				WigiArray(vs): WigiError("Can't exponent array");
				WigiError(m): r;
				WigiLambda(args, body): WigiError("Can't exponent function");
				WigiDefaultValue(): l;
				WigiElementValue(e): exponentWigiNumbers(l, getWigiElementValue(e));
				WigiBuiltInName(n): makeWigiErrorVariableUndefined(n);
				WigiRecord(fs):  WigiError("Can't exponent record");
			}
		}
		WigiError(m): l;
		WigiArray(vs): WigiError("Can't exponent array");
		WigiString(s): WigiError("Can't exponent strings");
		WigiDate(y, m, d): WigiError("Can't exponent date");
		WigiTime(h, m, s): WigiError("Can't exponent time");
		WigiLambda(args, body): WigiError("Can't exponent function");
		WigiDefaultValue(): r;
		WigiElementValue(e): exponentWigiNumbers(getWigiElementValue(e), r);
		WigiBuiltInName(n): makeWigiErrorVariableUndefined(n);
		WigiRecord(fs):  WigiError("Can't exponent record");
	}
}

divideWigiNumbers(l : WigiValue, r : WigiValue) -> WigiValue {
	switch (l : WigiValue) {
		WigiBool(b): WigiError("Can't divide bools");
		WigiDouble(v): WigiDouble(v / getWigiDouble(r));
		WigiInt(lv): {
			switch (r : WigiValue) {
				WigiBool(rv): WigiError("Can't divide bools");
				WigiInt(rv): WigiDouble(i2d(lv) / i2d(rv)); // Notice the type promotion to double!
				WigiDouble(rv): WigiDouble(i2d(lv) / rv);
				WigiString(rv): WigiError("Can't divide strings");
				WigiDate(y, m, d): WigiError("Can't divide date");
				WigiTime(h, m, s): WigiError("Can't divide time");
				WigiArray(vs): WigiError("Can't divide array");
				WigiError(m): r;
				WigiLambda(args, body): WigiError("Can't divide function");
				WigiDefaultValue(): l;
				WigiElementValue(e): divideWigiNumbers(l, getWigiElementValue(e));
				WigiBuiltInName(n): makeWigiErrorVariableUndefined(n);
				WigiRecord(fs):  WigiError("Can't divide record");
			}
		}
		WigiError(m): l;
		WigiArray(vs): WigiError("Can't divide array");
		WigiString(s): WigiError("Can't divide bools");
		WigiDate(y, m, d): WigiError("Can't divide date");
		WigiTime(h, m, s): WigiError("Can't divide time");
		WigiLambda(args, body): WigiError("Can't divide function");
		WigiDefaultValue(): divideWigiNumbers(WigiInt(1), r);
		WigiElementValue(e): divideWigiNumbers(getWigiElementValue(e), r);
		WigiBuiltInName(n): makeWigiErrorVariableUndefined(n);
		WigiRecord(fs):  WigiError("Can't divide record");
	}
}

compareWigiValues(l : WigiValue, r : WigiValue) -> int {
	lValue = prepareArg(l);
	rValue = prepareArg(r);
	switch (lValue : WigiValue) {
		WigiDouble(lv): {
			switch (rValue : WigiValue) {
				WigiDouble(rv): genericCompare(lv, rv);

				WigiInt(rv): genericCompare(lv, i2d(rv));
				WigiString(rv): genericCompare(lv, s2d(rv));
				WigiBool(rv): genericCompare(i2b(floor(lv)), rv);
				WigiDate(y, m, d) : genericCompare(lv, i2d(getDateValueFromWigi(rValue)));
				default: genericCompare(l, r);
			}
		};
		WigiInt(lv): {
			switch (rValue : WigiValue) {
				WigiInt(rv): genericCompare(lv, rv);

				WigiDouble(rv): genericCompare(i2d(lv), rv);
				WigiString(rv): genericCompare(lv, s2i(rv));
				WigiBool(rv): genericCompare(i2b(lv), rv);
				WigiDate(y, m, d) : genericCompare(lv, getDateValueFromWigi(rValue));
				default: genericCompare(l, r);
			}
		}
		WigiString(lv): {
			switch (rValue : WigiValue) {
				WigiString(rv): genericCompare(lv, rv);

				WigiInt(rv): genericCompare(s2i(lv), rv);
				WigiDouble(rv): genericCompare(s2d(lv), rv);
				WigiBool(rv): genericCompare(s2b(lv), rv);
				WigiDate(y, m, d) : genericCompare(lv, wigiValue2String(rValue));
				default: genericCompare(l, r);
			}
		}
		WigiBool(lv): {
			switch (rValue : WigiValue) {
				WigiBool(rv): genericCompare(lv, rv);

				WigiInt(rv): genericCompare(lv, i2b(rv));
				WigiDouble(rv): genericCompare(lv, i2b(floor(rv)));
				WigiString(rv): genericCompare(lv, s2b(rv));
				WigiDate(y, m, d) : genericCompare(lv, i2b(getDateValueFromWigi(rValue)));
				default: genericCompare(l, r);
			}
		}
		WigiDate(y, m, d) : {
			compareWigiValues(WigiInt(getDateValueFromWigi(lValue)), rValue)
		}

		default: genericCompare(l, r);
	}
}

wigiArrayIndex(l : WigiExpr, r : WigiExpr) -> WigiValue {
	switch (l : WigiExpr) {
		WigiArray(es): {
			switch (r : WigiExpr) {
				WigiInt(i): {
					if (existsIndex(es, i)) es[i]
					else WigiError("Wigi builtin error: Index is out of bounds, got " + toString(r))
				}
				WigiDouble(d): {
					i = floor(d);
					if (existsIndex(es, i)) es[i]
					else WigiError("Wigi builtin error: Index is out of bounds, got " + toString(r))
				}
				default: WigiError("Wigi builtin error: expected WigiInt or WigiDouble as index but got " + toString(r));
			}
		}
		default: WigiError("Wigi builtin error: expected WigiArray to apply \"[\" but got " + toString(l));
	}
}

wigiContains(args : [WigiValue]) -> WigiValue {
	if (length(args) < 2 || length(args) > 3) WigiError("Wrong number of arguments. Expected 2 or 3, but got " + i2s(length(args)))
	else {
		ignoreTypes = if (length(args) == 2) false else {
			switch(args[2]) {
				WigiBool(b) : b;
				default : false;
			}
		};

		switch(args[0]) {
			WigiArray(wa) : {
				WigiBool(
					if (ignoreTypes) fold(wa, false, \res, wv -> res || (compareWigiValues(wv, args[1]) == 0))
					else contains(wa, args[1])
				);
			}
			default : WigiError("Invalid type of arguments. [19]");
		}
	}
}

wigiFieldsValues(args : [WigiValue]) -> WigiValue {
	if (length(args) != 1) WigiError("Wrong number of arguments. Expected 1, but got " + i2s(length(args)))
	else {
		switch(args[0]) {
			WigiRecord(fields) : {
				WigiArray(map(fields, \f -> f.second));
			}
			default : WigiError("Invalid type of arguments. [20]");
		}
	}
}

wigiFieldsNames(args : [WigiValue]) -> WigiValue {
	if (length(args) != 1) WigiError("Wrong number of arguments. Expected 1, but got " + i2s(length(args)))
	else {
		switch(args[0]) {
			WigiRecord(fields) : {
				WigiArray(map(fields, \f -> WigiString(f.first)));
			}
			default : WigiError("Invalid type of arguments. [21]");
		}
	}
}

wigiEllipsis(l : [WigiValue]) -> WigiValue {
	wigiTemplateTextFunction(l, 2, \args ->{
		WigiString(ellipsis(getWigiText(args[0]), wigiValue2Int(args[1])))
	})
}

wigiRandomChar(l : [WigiValue]) -> WigiValue {
	chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789";
	picknFromChars = \n -> {
		generate(0, n, \__ -> {
			idx = floor(random()*i2d(strlen(chars)));
			getCharAt(chars, idx);
		})
	}

	if (length(l) > 1) {
		WigiError("Wrong number of arguments. Expected 1 or 0, but got " + i2s(length(l)))
	} else {
		WigiString(strGlue(
			picknFromChars(if (l==[]) 1 else wigiValue2Int(l[0])),
			""
		))
	}

}

prepareArg(arg : WigiValue) -> WigiValue {
	switch (arg : WigiValue) {
		WigiString(str) :
			if (str == "")
				arg
			else
				parseDateString(str,
					\d -> WigiDate(d.year, d.month, d.day),
					\__ -> arg
				);
		default : arg
	}
}

dateValue2WigiDate(value : int) -> WigiDate {
	d = dateValue2Date(value);
	WigiDate(d.year, d.month, d.day);
}

getDateValueFromWigi (date : WigiDate) -> int {
	getDateValue(Date(date.year, date.month, date.day))
}

wigiValue2Text(value : WigiValue) -> WigiValue {
	switch (value : WigiValue) {
		WigiString(text): {
			if (isWigiContent(text)) {
				eitherFn(string2wigi(wigiOpenTag + text + wigiCloseTag, None()),
					\doc -> WigiString(wigi2text(doc)),
					\ -> value
				);
			} else {
				value;
			}
		}
		default: {
			value;
		}
	}
}

wigiMergeRecords(args : [WigiValue]) -> WigiValue {
	if (length(args) == 0) {
		WigiRecord([])
	} else {
		switch (args[0] : WigiValue) {
			WigiRecord(fieldsFirst) : {
				rightValue = wigiMergeRecords(tail(args));
				switch (rightValue : WigiValue) {
					WigiRecord(fieldsSecond):
						WigiRecord(concat(fieldsFirst, fieldsSecond));
					WigiError(__) :
						rightValue;
					default : WigiError(
						"Invalid argument type in MERGERECORD."
					)
				}
			}
			WigiError(__) :
				args[0];
			default : WigiError(
				"Invalid argument type in MERGERECORD."
			)
		}
	}
}
