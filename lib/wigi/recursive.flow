import gui;
import mathdrawing;

import ui/scrollable;

import wigi/comap_view;
import wigi/code_view;
import wigi/wigi_table;
import wigi/excel_common;
import wigi/wigi2text;
import wigi/styles;
import wigi/interactive_table;
import wigi/external_recursive;
import wigi/wigi_util;

export {
	// Render this recursive, given a nice view for each of the children in views.
	// The updateCursorFn should be called if the cursor changes, for instance when comap nodes collapse
	// The elements child is available for information - you should not make any editable views yourself.
	// Optional 'sizes' parameter to capture table cells size
	wigiRecursiveLayout(
		type : WigiRecursiveType,
		namespace : WigiScope,
		elements : [WigiElement],
		style : [WigiRecursiveStyle],
		views : [() -> Form],
		updateCursorFn : () -> void, engine : WigiEngine,
		preview : bool,
		registerToEngine : bool,
		cursorInside : Behaviour<bool>,
		childInfo : [WigiRecursiveChildInfoStyle],
		extStyles : [ExtRecAPIRecursive2FormStyle]
	) -> Form;
}

wigiReplaceFormText(form : Form, newForm : Form) -> Form {
	switch(form) {
		Empty(): Empty();
		Text(text, style): newForm;
		Translate(x, y, f): Translate(x, y, wigiReplaceFormText(f, newForm));
		Scale(x, y, f): Scale(x, y, wigiReplaceFormText(f, newForm));
		Rotate(d, f): Rotate(d, wigiReplaceFormText(f, newForm));
		Alpha(a, f): Alpha(a, wigiReplaceFormText(f, newForm));
		Visible(v, f): Visible(v, wigiReplaceFormText(f, newForm));
		Available2(wh, f): Available2(wh, wigiReplaceFormText(f, newForm));
		Size2(wh, f): wigiReplaceFormText(f, newForm);
		SetPending(p, f): SetPending(p, wigiReplaceFormText(f, newForm));
		Baseline(b, f): Baseline(b, wigiReplaceFormText(f, newForm));
		Group(fs): Group(mapi(fs, \i ,f -> wigiReplaceFormText(f, newForm)));
		Grid(c): Grid(map(c, \fs -> map(fs, \f -> wigiReplaceFormText(f, newForm))));
		Border(l, t, r, b, f): Border(l, t, r, b, wigiReplaceFormText(f, newForm));
		Mask2(f, m, s): Mask2(wigiReplaceFormText(f, newForm), m, s);
		Interactive(ls, f): Interactive(ls, wigiReplaceFormText(f, newForm));
		Filter2(fs, f, s): Filter2(fs, wigiReplaceFormText(f, newForm), s);
		Cursor(k, f): Cursor(k, wigiReplaceFormText(f, newForm));
		Inspect(is, f): Inspect(is, wigiReplaceFormText(f, newForm));
		Mutable2(bf,s): Select(bf, \f -> wigiReplaceFormText(f, newForm));
		Crop2(l, t, w, h, f, s): Crop2(l, t, w, h, wigiReplaceFormText(f, newForm), s);
		Switch(v, cs): Switch(v, map(cs, \f -> wigiReplaceFormText(f, newForm)));
		Constructor(f, fn): Constructor(wigiReplaceFormText(f, newForm), fn);
		Access(p, f): Access(p, wigiReplaceFormText(f, newForm));
		default: form;
	}
}

wigiRecursiveLayout(
	type : WigiRecursiveType,
	namespace : WigiScope,
	elements : [WigiElement],
	style : [WigiRecursiveStyle],
	views : [() -> Form],
	updateCursorFn : () -> void, engine : WigiEngine,
	preview : bool,
	registerToEngine : bool,
	cursorInside : Behaviour<bool>,
	childInfo : [WigiRecursiveChildInfoStyle],
	extStyles : [ExtRecAPIRecursive2FormStyle]
) -> Form {

	addPlaceholderText = \text : string, form : Form -> {
		width = make(0.0);
		if (text != "" && !preview) {
			showPlaceholderB = make(false);
			Constructor(
				Group([
					// We show placeholder text whenever content is empty AND cursor is not inside
					Select(showPlaceholderB, \s -> Iff(s, \ -> Paragraph(
						[TextFragment(text, [Fill(lightGray), FontSize(14.0)] |> asItalic)],
						extractParagraphStyle(extractWigiAlignment(elements[0])))
					)),
					Inspect([Width(width)], form)
				]),
				\ -> connectSelect2u(width, cursorInside, showPlaceholderB, \w, ci -> isWigiTableCellContentEmpty(elements[0]) && !ci)
			)
		} else form
	}
	enabled = extractStruct(style, WigiEnabled(const(true))).enabled;

	defaultDocumentTextColor = extractStruct(getDefaultDocumentStyle(engine.defaultStyles).textStyle, Fill(0)).color;

	switch (type : WigiRecursiveType) {
		WigiBrackets(leftBracketType, rightBracketType): {
			brackets2formWithColor(leftBracketType, rightBracketType, views[0](), defaultDocumentTextColor);
		}

		WigiComap(collapsed): {
			comap2form(map(views, apply0), collapsed, updateCursorFn);
		}

		WigiDottedElement(left, right, top, bottom, leftSign, rightSign): {
			dotted2formWithColor(views[0](), left, top, right, bottom, leftSign, rightSign, defaultDocumentTextColor);
		}
		WigiFraction(): {
			fraction2formWithColor(
				views[0](),
				views[1](),
				defaultDocumentTextColor
			);
		}
		WigiProduct(): {
			definiteControl2formWithColor(ProductSign(), views[0](), views[1](), views[2](), defaultDocumentTextColor);
		}
		WigiEvaluatingIntegral(): {
			evaluatingIntegral2formWithColor(views[0](), views[1](), views[2](), defaultDocumentTextColor);
		}
		WigiRoot(): {
			degree = views[0]();
			body = views[1]();
			root2formWithColor(degree, body, defaultDocumentTextColor);
		}
		WigiLongDivision(): {
			longDivision2formWithColor(views[0](), defaultDocumentTextColor);
		}
		WigiIntegral(): {
			definiteControl2formWithColor(IntegralSign(), views[0](), views[1](), views[2](), defaultDocumentTextColor);
		}
		WigiIntegral2(signType): {
			definiteControl2formWithColor(OneCharSign(signType), Empty(), views[0](), views[1](), defaultDocumentTextColor);
		}
		WigiTopModificator(t, s): {
			topModificator2formWithColor(views[0](), t, s, WriteTopModificatorCorrections(0.0, 0.0, 0.0), defaultDocumentTextColor);
		}
		WigiSum(): {
			definiteControl2formWithColor(SigmaSign(), views[0](), views[1](), views[2](), defaultDocumentTextColor);
		}
		WigiSupscript(): {
			supSubScript2form(views[0](), views[1](), Empty(), DummyMathFormWrappers());
		}
		WigiSubscript(): {
			supSubScript2form(views[0](), Empty(), views[1](), DummyMathFormWrappers());
		}
		WigiSupSubscript() : {
			supSubScript2form(views[0](), views[1](), views[2](), DummyMathFormWrappers());
		}
		WigiOverscript(): {
			scale = const(SuperSubscriptScalingCoeff);
			views1 : [() -> Form] = mapi(views, \i, v -> {
				if (i == 1) \ -> Scale(scale, scale, v()) else v;
			});
			overscript2form(views1[0](), views1[1]());
		}
		WigiUnderscript(): {
			underscript2form(views[0](), views[1]());
		}
		WigiOverlay(): {
			upper = views[0]();
			lower = views[1]();

			unpair(getDynamicFormSize(lower), \lowerM : Form, lmB : Behaviour<FormMetrics> -> {
				unpair(getDynamicFormSize(upper), \upperM : Form, umB : Behaviour<FormMetrics> -> {
					newBaseline = select(umB, \um -> max(um.baseline, um.height));
					newTop = Size2(
						select(umB, \um -> WidthHeight(um.width, max(um.baseline, um.height))),
						upperM
					);
					newBottom = Size2(
						select(lmB, \lm -> WidthHeight(lm.width, lm.height - lm.baseline)),
						Translate(
							zero,
							select(lmB, \lm -> -lm.baseline),
							lowerM
						)
					);
					Baseline(newBaseline, Lines([newTop, newBottom]))
				})
			});
		}

		WigiAltText(): {
			if (!preview) Rounded(5.0, [Stroke(green)], Border(2.0, 2.0, 2.0, 2.0, views[0]()))
			else {
				alttext = wigi2text(elements[0]);
				// Visibleb(const(false) is a hack to force AccessDescription work with empty form
				Access([AccessRole("note"), AccessDescription(alttext)], Visibleb(const(false), Text(alttext, [])))
			}
		}

		WigiTable(rows, columns, cellSpans, tableStyle): {
			contextMenuVis = extractStruct(extStyles, dummyContextMenu()).visible;
			makeWigiTable(views, type, namespace, elements, style, engine, preview, registerToEngine, childInfo, contextMenuVis);
		}

		WigiInteractiveTable(f, r, s): {
			// There should be exactly one element inside, namely, our row template
			makeInteractiveTable(f, r, views, type, namespace, elements, s, engine, preview, registerToEngine);
		}

		WigiTableCell(widthHeight, cellStyle): {
			cellPadding = extractStruct(cellStyle, DefaultCellPadding);
			innerBorder = extractStruct(cellStyle, DummyCellInnerBorder);
			cellVerticalAlign = extractStruct(cellStyle, DefaultCellVerticalAlign).align;
			addSpacing = \form -> {
				leftPadding = if (getDefaultRtl()) cellPadding.endPadding else cellPadding.startPadding;
				rightPadding = if (getDefaultRtl()) cellPadding.startPadding else cellPadding.endPadding;
				extraSpace = if (innerBorder == DummyCellInnerBorder) 0.0 else innerBorder.padding + innerBorder.thickness;
				Border(leftPadding + extraSpace, cellPadding.topPadding + extraSpace, rightPadding + extraSpace, cellPadding.bottomPadding + extraSpace, form);
			}

			placeholderText = extractStruct(cellStyle, PlaceholderText("")).text;

			addAlign = \form, align : WigiCellAlign-> {
				alignK = switch(align) {
					CellAlignTop(): 0.0;
					CellAlignCenter(): 0.5;
					CellAlignBottom(): 1.0;
				}
				if (align == CellAlignTop()) form
				else {
					height = make(0.0);
					Constructor(
						OverrideAvailableHeightB(height, Align2(0.0, alignK, form)),
						\ -> subscribe(widthHeight, \wh -> nextDistinct(height, wh.height))
					)
				}
			}

			addAlign(addSpacing(addPlaceholderText(placeholderText, views[0]())), cellVerticalAlign)
		}

		WigiSpreadsheetCell(widthHeight, editMode, cellStyle): {
			name = extractStruct(style, WigiName("")).name;
			placeholderText = extractStruct(cellStyle, PlaceholderText("")).text;
			formattingStyle = extractStruct(cellStyle, DefaultCellFormatting);

			valFn = \value : WigiValue, st -> {
				Pair(
					wigiValue2FormCustom(value, st, engine.defaultStyles, formattingStyle),
					\ -> {
						addValueToEngine(engine, namespace, name, const(value), registerToEngine);
					}
				);
			}

			dyn =  \value, st -> {
				form = make(Empty());
				Pair(
					Mutable(form),
					\ -> {
						// TODO: Instead of making an error here, there is good reason to just allow it, but only
						// evaluate once! See Gneiss http://www.cs.cmu.edu/~shihpinc/gneiss.html
						val = if (isCircularReferenceExpr(value, name)) Pair(make(WigiError("Circular Reference: " + name)), [])
							else addFormulaToEngine(engine, namespace, name, namespace, value, registerToEngine, true);

						us = subscribe(val.first, \v -> {
							next(form, wigiValue2FormCustom(v, st, engine.defaultStyles, formattingStyle));
						});
						\-> {
							applyall(val.second);
							us();
						}
					}
				)
			}

			cellPadding = extractStruct(cellStyle, DefaultCellPadding);
			leftPadding = if (getDefaultRtl()) cellPadding.endPadding else cellPadding.startPadding;
			rightPadding = if (getDefaultRtl()) cellPadding.startPadding else cellPadding.endPadding;

			addSpacing = \form -> Border(leftPadding, cellPadding.topPadding, rightPadding, cellPadding.bottomPadding, form);

			defaultDocumentFontSize = getDefaultDocumentFontSize(engine.defaultStyles);

			view = Select(editMode, \em -> {
				alignment = switch (elements[0]) {
					WigiStory(ps, __, __): {
						switch (^ps[0]) {
							WigiParagraph(__, s): {
								fullStyle = getWigiParagraphStyleFull(engine.defaultStyles, ^ps[0], [], s);
								if (contains(fullStyle, RightAlign())) 1.0
								else if (contains(fullStyle, CenterAlign())) 0.5
								else if (contains(fullStyle, LeftAlign())) 0.
								else if (contains(fullStyle, EndAlign())) (if (getDefaultRtl()) 0. else 1.)
								else (if (getDefaultRtl()) 1. else 0.);
							}
							default: 0.0;
						}
					}
					default: 0.0;
				};

				text = switch (simplifyElement(elements[0])) {
						WigiText(t, s) : {
							arr = if (exists(s, \st -> isSameStructType(st, FontSize(0.0)))) s else arrayPush(s, FontSize(defaultDocumentFontSize));
							WigiText(t, if (exists(arr, \st -> isSameStructType(st, Fill(0)))) arr else arrayPush(arr, Fill(defaultDocumentTextColor)));
						}
						default: WigiText("", []);
				};

				parsed = if (text.text == "") WigiError("PARSING FAILED") else parseWigiExpr(text.text);

				form = if (text.text == "") {
					Pair(views[0](), \ -> \ -> {});
				} else if (isWigiValue(parsed)) {
					valFn(cast(parsed : WigiExpr -> WigiValue), text.style)
				} else {
					dyn(parsed, text.style);
				}

				aw = make(1000.0);

				Constructor(
					if (em && !preview) views[0]()
					else {
						switch (parsed : WigiExpr) {
							WigiError(e): views[0]();
							default: {
								wh = makeWH();
								Size2(wh, Available(aw, const(1000.0),
									Group([
										Align2(alignment, 0.0,
										Inspect([ISize(wh)], wigiReplaceFormText(views[0](), form.first)))
								])));
							}
						}
					},
					\ -> {
						rendered = make(false);

						deferUntilRender(\ -> next(rendered, true));

						uns1 = select2u(rendered, widthHeight, \r, _wh -> if (r) next(aw, _wh.width)).second;
						uns2 = form.second();

						\ -> {
							uns1();
							uns2();
						}
					}

				)
			});

			addSpacing(addPlaceholderText(placeholderText, view));
		}

		WigiFrame(width, height, s): {
			noScrollbars = Scrollbars(false, false);
			tightWidth = contains(s, TightWidth());
			tightHeight = contains(s, TightHeight());
			scrolls : Scrollbars = extractStruct(s, noScrollbars);
			m = make(FormMetrics(0.0, 0.0, 0.0, 0.0));
			correction = if (flash) 1.0 else 0.0;
			content = Inspect([IMetrics(m)], Available2(const(WidthHeight(width, height)), views[0]()));

			cropW = if (tightWidth) select(m, \mwh -> min(mwh.width + correction, width)) else const(width);
			cropH = if (tightHeight) select(m, \mwh -> min(mwh.height, height)) else const(height);
			baseline = select(m, \mwh -> min(mwh.baseline, height));
			if (scrolls == noScrollbars) {
				Baseline(baseline, Crop(zero, zero, cropW, cropH, content))
			} else if (scrolls.horizontal && scrolls.vertical) {
				Scrollable(make(0.0), make(0.0), cropW, cropH, content)
			} else if (scrolls.horizontal) {
				HorizontalScrollable(make(0.0), make(0.0), cropW, cropH, content)
			} else {
				VerticalScrollable(make(0.0), make(0.0), cropW, cropH, content);
			}
		}

		WigiRadioOption(id, value): {
			content = views[0]();

			form = if (!preview) {
				// Let's draw a nice(?) frame in the edit mode
				wh = makeWH();

				Group([
					Select(wh, \_wh -> {
						FixSize(0.0, 0.0, Rectangle(_wh.width, _wh.height, [Stroke(pink), StrokeWidth(1.0)]))
					}),
					Inspect([ISize(wh)], content)
				])
			} else content;

			groupValue = ref make(WigiInt(0));

			Constructor(
				Select(enabled, \enabled_ ->
					if (enabled_)
						Interactive([MouseClick(\mi -> {
							nextDistinct(^groupValue, WigiInt(value));
						})], form)
					else form
				),
				\ -> {
					uns = ref [];

					option = make(false);

					groupValueM = getValueFromEngine2(engine, namespace, id, false);

					groupValue := switch (groupValueM) {
						None(): {
							// The value of the whole radio group is not created it. Meaning we're first
							gv = make(WigiInt(value));
							next(option, true);	// TODO: We might not want to set it like this

							refArrayPush(uns, linkValueToEngine(engine, namespace, id, gv, true));
							gv
						}

						Some(group): cast(group: Behaviour -> DynamicBehaviour);
					}

					othersToUs = subscribe(^groupValue, \gv -> {
						nextDistinct(option, gv == WigiInt(value));
					});

					usToOthers = subscribe(option, \opt -> {
						if (opt) {
							nextDistinct(^groupValue, WigiInt(value));
						}
					});

					uns := concat(^uns, [othersToUs, usToOthers]);

					\ -> {
						applyall(^uns);
						uns := [];
					}
				}
			)
		}

		WigiVisible(s): {
			if (preview) {
				uns = registerToWigiEngine(elements[0], engine, namespace);
				Disposer(Empty(), \ -> applyall(uns))
			} else {
				table = WigiTable(1, 1, [WigiCellSpan(1, 1)], [WigiTableBorder(2.0, 5.0, black)]);
				makeWigiTable([views[0]], table, namespace, [elements[0]], [], engine, false, registerToEngine, [], make(false))
			}
		}

		WigiCode(sc, sr): {
			code2form(engine, views[0](), if (elements != []) elements[0] else WigiEmpty(), sc, sr, updateCursorFn, registerToEngine)
		}
		WigiTyped(typ): {
			Lines(concat([Text(typ, []),], map(views, apply0)));
		}
		WigiButton(width, s): {
			wigiName : WigiName = extractStruct(style, WigiName(""));
			backgroundFill = extractStruct(s, BackgroundFill(0xFFFFFF)).color;
			clickFormula = extractStruct(s, OptionalFormula("")).formula;
			expr = if (clickFormula != "") Some(parseWigiExpr(clickFormula))
			else None();

			down = make(WigiInt(0));

			content = Rounded(5.0, [Stroke(0), Fill(backgroundFill)], FixWidth(make(width), Available(make(width), make(0.0), Border(2.0, 2.0, 2.0, 2.0, views[0]()))));
			button = Interactive(
				[
					MouseClick(\mi -> {
						nextDistinct(down, WigiInt(1));
					}),
					MouseUp(\mi -> {
						info = mi();
						nextDistinct(down, WigiInt(0));
						if (info.inside) {
							maybeApply(expr, \e -> { evaluateEngineExpr(engine.env, ^(engine.externalFunctions), namespace, "", e); {} });
							true
						} else false
					}),
				],
			content);

			if (wigiName.name != "") {
				Constructor(
					button,
					\ -> linkValueToEngine(engine, namespace, wigiName.name, down, true)
				)
			} else {
				button
			}
		}
		WigiHyperlink(url): {
			Cursor(FingerCursor(), Interactive([
				MouseClick(\__ -> getUrl(url, "_blank"))],
				views[0]()
			));
		}
		WigiVersions(versions): {
			original = views[0]();
			isOriginalEmpty = forall(elements, isEmptyElement);
			if (versions == [] || (isOriginalEmpty && forall(versions, \v -> isEmptyElement(v.changed)))) original else {
				addForeground = \f, color -> Foreground([Fill(color), FillOpacity(0.4)], f);
				addRounded = \f -> Border(1.0, 0.0, 1.0, 0.0, Rounded(2.0, [Stroke(black), StrokeWidth(1.0)], f));
				defTextStyle = if (engine.defaultStyles != []) engine.defaultStyles[0].textStyle else [];
				eitherEmptyFn = \arr, alternative -> if (arr == []) alternative else arr;
				emptyTextStyle = getCharacterStyleFromWigiTextStyleExt(defTextStyle, makeTree());
				sourceTextStyle = eitherEmptyFn(getFirstTextElementStyle(elements), defTextStyle);

				availB = makeWH();
				expandFn = \form, width -> {
					avail2B = makeWH();
					if (isStaticForm(form)) form else Constructor(Available2(avail2B, form), \-> connectSelectu(availB, avail2B, \av -> WidthHeight(min(av.width, width), av.height)));
				};

				wigi2FormFn = \wigi : WigiElement -> {
					wigi2 = switch(wigi) {
						WigiParagraph(content, contentStyle): WigiParagraph(content, arrayPush(contentStyle, TightWidth()));
						default: wigi;
					}
					wigiValue2Form(WigiElementValue(wigi2), [], engine.defaultStyles);
				}

				versionsInfo = map(versions, \v -> {
					curWigi = if (isEmptyElement(v.changed)) {
						currentElementStyle = eitherEmptyFn(getFirstTextElementStyle([v.changed]), sourceTextStyle);
						WigiText("<" + _("Deleted") + ">", eitherEmptyFn(currentElementStyle, sourceTextStyle));
					} else v.changed;
					Triple(v.id, estimateWigiWidth(curWigi, wigi2FormFn, defTextStyle), wigi2FormFn(curWigi))
				});

				originalWidth = estimateWigiWidth(elementAt(elements, 0, WigiEmpty()), wigi2FormFn, defTextStyle);
				components = concat(
					if (isOriginalEmpty) [original]
					else [addForeground(strikethrough([Stroke(black), StrokeOpacity(0.8)], expandFn(original, originalWidth)), newRedColor)],
					map(versionsInfo, \v -> {
							if (v.first == "") Empty() else addForeground(
								Interactive([MouseClick(\mi -> {
										onClick = lookupTreeDef(^(engine.wigiVersionsClicks), v.first, nop);
										onClick();
									})],
									Border(8.0, 0.0, 8.0, 0.0, expandFn(v.third, v.second + 4.0))
								),
								newGreenColor
							)
					})
				);

				totalWidth = fold(versionsInfo,	originalWidth, \acc, v -> {
					labelSize = if (v.first == "") 0.0 else (getTextSize(v.first, emptyTextStyle).width + 16.0);
					acc + v.second + labelSize + 22.0;
				});
				Inspect([IAvailable(availB)], Select(availB, \av -> if (av.width > totalWidth) Cols(components) else Lines(components)));
			}
		}
		WigiExternalRecursive(exType, content): {
			eitherFn(
				getExternalRecursiveAPI(exType),
				\api -> {
					baselineB = make(-1.0); //invalid value to determine whether the component wants to correct it's baseline
					recursiveForm = api.recursive2form(
						setTree(content, "preview", preview |> b2s),
						engine,
						concat(extStyles, [
							ExtRecWigiRecursiveStyles(style),
							ExtRecChildrenWigi(elements),
							ExtRecChildrenView(views),
							ExtRecBaselineLevel(baselineB),
						])
					);

					if (getValue(baselineB) == -1.0)
						recursiveForm
					else
						fixBaselineB(baselineB, recursiveForm);
				},
				\ -> {
					println("Unsupported external recursive type: " + exType);
					Empty()
				}
			)
		}
	}

}

//estimates upper bound of WigiElement size, required to choose Cols/Lines WigiVersions view
estimateWigiWidth(element : WigiElement, wigi2FormFn : (WigiElement) -> Form, defTextStyle : [WigiTextStyle]) -> double {
	switch(element) {
		WigiText(text, textStyle): {
			fullStyle = fold(defTextStyle, textStyle, \acc, st -> if (containsStruct(acc, st)) acc else arrayPush(acc, st));
			getTextSize(text, getCharacterStyleFromWigiTextStyleExt(fullStyle, makeTree())).width;
		}
		WigiParagraph(elements, style): {
			//can't get closer
			2.0 * fold(elements, 0.0, \acc, el -> acc + estimateWigiWidth(el, wigi2FormFn, defTextStyle));
		}
		WigiRecursive(__, type, __): {
			switch (type) {
				WigiTable(__, __, __, __): doubleMax;
				WigiInteractiveTable(__, __, __): doubleMax;
				default: getFormWidth(wigi2FormFn(element));
			}
		}
		default: getFormWidth(wigi2FormFn(element));
	}
}

getFirstTextElementStyle(elements : [WigiElement]) -> [WigiTextStyle] {
	either(findmap(elements, \e -> {
		currentStyle = switch(e) {
			WigiText(__, style): style;
			WigiParagraph(els, __): getFirstTextElementStyle(els);
			default: [];
		}
		if (currentStyle == []) None() else Some(currentStyle);
	}), []);
}

isWigiTableCellContentEmpty(element : WigiElement) -> bool {
	switch (element: WigiElement) {
		WigiDocument(root, style): isWigiTableCellContentEmpty(root);
		WigiStory(elements, views, style): all(map(^elements, isWigiTableCellContentEmpty));
		WigiParagraph(elements, style): !isListed(style) && all(map(elements, isWigiTableCellContentEmpty));
		WigiText(text, style): text == "";
		WigiEmpty(): true;
		WigiRecursive(elements, type, style): false;
		WigiBlock(type, style): false;
	}
}