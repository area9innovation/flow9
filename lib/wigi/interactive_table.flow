import wigi/wigi_table;
import wigi/register_to_wigi_engine;
import ui/easybutton;

export {
	// Construct a form of an interactive table
	// See case http://process.area9.dk/cases/default.asp?36702
	makeInteractiveTable(formula: string, records: DynamicBehaviour<[WigiRecord]>, views : [() -> Form], table : WigiInteractiveTable, namespace : WigiScope, elements: [WigiElement], style : [InteractiveTableStyle], engine : WigiEngine, preview : bool, registerToEngine : bool) -> Form;

	// Make a row with given values
	makeInteractiveTableRow(template: WigiElement, record: WigiRecord, engine: WigiEngine, namespace: WigiScope) -> Disposable<WigiElement>;
}

makeInteractiveTable(formula: string, records: DynamicBehaviour<[WigiRecord]>, views : [() -> Form], table : WigiInteractiveTable, namespace : WigiScope, elements: [WigiElement], style : [InteractiveTableStyle], engine : WigiEngine, preview : bool, registerToEngine : bool) -> Form {
	if (!preview) {
		makeInteractiveTableEditTime(views, namespace, elements[0], style, engine, registerToEngine)
	} else {
		makeInteractiveTableRuntime(formula, records, views, namespace, elements, style, engine)
	}
}

makeInteractiveTableEditTime(views: [() -> Form], namespace: WigiScope, rowTemplate: WigiElement, style: [InteractiveTableStyle], engine: WigiEngine, registerToEngine: bool) -> Form {
	table = WigiTable(1, 1, [WigiCellSpan(1, 1)], [WigiTableBorder(2.0, 5.0, 0x7F808285)]);

	makeWigiTable(views, table, namespace, [rowTemplate], [], engine, false, registerToEngine, [], make(false))
}

// Here we need to make all those up-down, add/delete buttons
makeInteractiveTableRuntime(formula: string, records: DynamicBehaviour<[WigiRecord]>, views: [() -> Form], namespace: WigiScope, elements: [WigiElement], style: [InteractiveTableStyle], engine: WigiEngine) -> Form {
	addCaption = extractStruct(style, AddButtonCaption("Add")).caption;
	addButton = EasyButton(addCaption, "", white, \ -> {
		// Duplicating last row of the table
		newRecord = lastElement(getValue(records), WigiRecord([]));
		next(records, arrayPush(getValue(records), newRecord));
	}, []);

	upDownEnalbed = fold(style, true, \acc, s -> switch (s) {
		DisableUpDownButtons(): false;
		default: acc;
	});

	deletePicture = Picture("images/delete_button.png", []);
	deleteButton = \i -> AnimatedButton(deletePicture, const(true), "", \ -> {
		next(records, removeIndex(getValue(records), i));
	});

	// Swaps i and i+1 in records
	swapWithNext = \i -> {
		oldRecords = getValue(records);
		newRecords = replace(replace(oldRecords, i, oldRecords[i + 1]), i + 1, oldRecords[i]);

		next(records, newRecords)
	}

	makeElementForm = \i, view -> {
		upBtn = if (upDownEnalbed && i > 0) {
			upPicture = Picture("images/small_arrow_up.png", []);
			AnimatedButton(upPicture, const(true), "", \ -> {
				swapWithNext(i - 1);
			})
		} else Empty();

		downButton = if (upDownEnalbed && i < length(views) - 1) {
			downPicture = Picture("images/small_arrow_down.png", []);
			AnimatedButton(downPicture, const(true), "", \ -> {
				swapWithNext(i);
			})
		} else Empty();

		// This ensures we have the same visual as in edit mode (in principle)
		form = makeInteractiveTableEditTime([view], namespace, elements[i], style, engine, false);

		mainForm = Available(const(1000.0), const(1000.0), form); // Kinda hack, but otherwise nothing is seen because of apparently zero available.

		if (formula == "") {
			Cols([
				mainForm,
				Align(0.0, 0.5, Cols([
					downButton,
					upBtn,
					deleteButton(i)
				]))				
			])
		} else {
			// No controls for formula-based tables
			mainForm
		}
	}

	Lines(
		arrayPush(mapi(views, makeElementForm),
		if (formula == "") addButton else Empty()
	))
}

makeInteractiveTableRow(template: WigiElement, record: WigiRecord, engine: WigiEngine, namespace: WigiScope) -> Disposable<WigiElement> {
	// First, define all our values into the engine
	uns0 = map(record.fields, \p : Pair<string, WigiValue> -> {
		name = p.first;
		recordValue = p.second;
		rowSubnamespace = WigiScope(concat(["bindings"], namespace.names));

		// Note we don't add individual rows variables to wiki world here, because wiki->wigi conversion may change them inadvertently
		linkValueToEngine(engine, rowSubnamespace, name, make(recordValue), false);
	});

	// Then instantiate our template for this row into the engine
	element = wigiForStorage(template, false);
	uns1 = registerToWigiEngine(element, engine, namespace);

	Disposable(element, \ -> applyall(concat(uns0, uns1)));
}
