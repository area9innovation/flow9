import mathdrawingstructs;
import date;
import virtual_screen_types;
import tropic/tropic_array;
import ui/imagedecoratedstructs;
import ui/playeroptions;

forbid gui;
forbid renderform;

export {
	// The model of wigi document.
	WigiElement ::= WigiDocument, WigiStory, WigiParagraph, WigiText, WigiEmpty, WigiRecursive, WigiBlock;

		// DEPRECATED. DON'T USE IT.
		// Invariant: the root is a WigiStory. The type checking is just simpler with the general type.
		WigiDocument(root : WigiElement, style : [WigiDocumentStyle]);
			WigiDocumentStyle ::= WigiName;


		// The root of wigi document.
		// The paragraphs are always WigiParagraph's, but the type checking is just simpler with the general type.
		WigiStory(paragraphs : ref [WigiElement], views : ref [TropicArray<WigiElement>], style : [WigiStoryStyle]);
			WigiStoryStyle ::= WigiName, ParagraphSpacing, WigiReference, WigiConvertToRelativeSize, RemoveAllListSpacing;
				ParagraphSpacing(d : double);
				WigiReference(tree : Tree<string, string>);
				WigiConvertToRelativeSize();
				RemoveAllListSpacing();

		// The elements are WigiText, WigiRecursive, WigiBlock.
		// And it's also better to avoid WigiEmpty. If you need some empty element inside paragraph use WigiText("", []) for this.
		WigiParagraph(elements : [WigiElement], style : [WigiParagraphStyle]);
			// When extend WigiParagraphStyle don't forget to make appropriate changes in clearParagraphFormatting fn
			WigiParagraphStyle ::= ParagraphAlignment, InterlineSpacing, WigiParagraphIndent, FixedWidth, Listed,
					ReplaceTightWidthWithAlign, ReplaceAlignWithTightWidth, WigiStylesName, WigiAspect, DynamicBlockDelay,
					ParagraphBorder, WigiParagraphExternalStyle;

				// opposite to TightWidth to be able to discard TightWidth by concatenation of paragraph styles
				FixedWidth();
				// replaces CenterAlign, Justify or RightAlign with TightWidth if presents
				ReplaceAlignWithTightWidth();
				// the opposite to above, replaces TightWidth with CenterAlign, Justify or RightAlign if present
				ReplaceTightWidthWithAlign();
				// for bulleted or numbered lists
				Listed(type : ListIndexType, style : [WigiTextStyle]);
					ListIndexType ::= Bulleted, Numbered;
						Bulleted(bullet : string);
						Numbered(number : int, type : NumberType);
							NumberType ::= SimpleNumber, DottedNumber, PrettyNumber;
								SimpleNumber();
								DottedNumber();
								PrettyNumber();
				dummyListed = Listed(Bulleted(""), []);

				WigiParagraphIndent ::= GeneralIndent, FirstLineIndent;
					GeneralIndent(indent : double);

				// specifies a WigiStyles for each particular WigiParagraph
				WigiStylesName(name : string);
				// defines specific external blocks as paragraph aspects.
				// Configuration name should be declared as WigiAspectConfiguration at ExternalBlockStyle.
				WigiAspect(exType : string, conf : string);
				dummyWigiAspect = WigiAspect("", "");

				// defines arbitrary custom style to set Json data there.
				// This style can be cleared or not when editing the content or copy/paste a paragraph.
				// You can set Json field "cleared", cleared = true by default.
				WigiParagraphExternalStyle(data : string);

		// Text that will wrap. Notice this can not contain any escaped things like &#123; or &lt;. Only single glyphs work
		WigiText(text : string, style : [WigiTextStyle]);
			WigiTextStyle ::= BaselineShift, BasicCharacterStyle, DoubleUnderline, Language, Underline, WigiHtmlResponsiveFontSize,
				WigiLock, WigiRelativeFontSize, WigiHtmlRelativeFontSizeWithEm, WigiAnnotation;
				Underline();
				DoubleUnderline();
				BaselineShift(shift : double);

				// Use this parameter when you want to change font size for block in relative way up to 50%
				// delta of +1 means +10% to current font size specified in WigiText style
				// WigiRelativeFontSize should not go to CharacterStyle directly, it can be used in WigiBlock
				WigiRelativeFontSize(delta : int);

				// The language parameter is the language code which consists of the two letter ISO 639 language code and an optional two letter ISO 3166 country code after a dash or underscore
				// Example: "en" - english, "none" - skip spellcheck
				Language(name : string);

				// Style to have responsive font sizes in the exported html.
				// When the height or width of the viewport is changed, they are scaled accordingly, based on this calculation:
				// calc(base-font-size px + vw * (viewport-width/100) px + vh * (viewport-height/100) px), where base-font-size = font-size * ratio
				// For example: Default 16 px font-size in a 1280 px width viewport.
				// 				Parameters to set: ratio = 0.25, vw = 0.90, vh = 0.00
				// 				base-font-size = 16 px * 0.25 = 4 px.
				//				At 640 px width viewport, font-size become:
				// 				4 px + 0.90 * (640/100) px ~= 10 px
				WigiHtmlResponsiveFontSize(ratio : double, vw : double, vh : double);

				// Use this parameter when you want specify font size in em, not in px
				// 1em is equal to the default font size or parent font size if it was specified in pixels
				// The size can be calculated from pixels to em using this formula: pixels/dwfs=em
				// Can be used in CharacterStyle or as WigiText style directly
				// If WigiStory or html styles have parameter WigiConvertToRelativeSize() therefore all WigiText styles will have this parameter
				WigiHtmlRelativeFontSizeWithEm(em : double);
				// Style to have possibility assosiate text with any external content
				// Affects on result of Wigifying.
				// Wigified pages will have function that returns positions of annotated texts by this id
				WigiAnnotation(id : int);

		// font size scaling value for superscript/subscript WigiText
		SuperSubscriptScalingCoeff = 0.7;

		WigiEmpty();

		// An element composed of other elements, where the layout is done by some function.
		// The elements are WigiStory, WigiParagraph or other WigiRecursive's.
		WigiRecursive(elements : [WigiElement], type : WigiRecursiveType, style : [WigiRecursiveStyle]);
			// The different recursive types we support
			WigiRecursiveType ::= WigiBrackets, WigiComap, WigiDottedElement, WigiFraction, WigiProduct, WigiEvaluatingIntegral, WigiRoot, WigiLongDivision, WigiIntegral, WigiIntegral2,
									WigiTopModificator, WigiSum, WigiSupscript, WigiSubscript, WigiOverscript, WigiUnderscript, WigiOverlay, WigiTable, WigiInteractiveTable, WigiTableCell,
									WigiSpreadsheetCell, WigiFrame, WigiCode, WigiTyped, WigiButton, WigiHyperlink, WigiAltText, WigiRadioOption, WigiVisible, WigiVersions, WigiExternalRecursive,
									WigiSupSubscript;
				// Brackets like (), {} that resize
				WigiBrackets(leftBracketType : WriteBracketType, rightBracketType : WriteBracketType);
				// A comapping, mindmap element with a parent, and then N children to the right
				WigiComap(collapsed : DynamicBehaviour<bool>);
				// Dotted element
				WigiDottedElement(left : int, right: int, top : int, bottom : int, leftSign : bool, rightSign : bool);
				// A fraction
				WigiFraction();
				// A product
				WigiProduct();
				// A evaluating integral
				WigiEvaluatingIntegral();
				// A root
				WigiRoot();
				// Long division
				WigiLongDivision();
				// Integral
				WigiIntegral();
				// Integral2
				WigiIntegral2(signType : OneCharSignType);
				// Top modificators
				WigiTopModificator(type : WriteTopModificator, size : WriteTopModificatorSize);
				// Sum
				WigiSum();
				// Supscript
				WigiSupscript();
				// Subscript
				WigiSubscript();
				// Combination of Supscript and Subscript
				WigiSupSubscript();
				// Overscript
				WigiOverscript();
				// Underscript
				WigiUnderscript();
				// Overlay
				WigiOverlay();
				// Alt text
				WigiAltText();
				// Table parameters : rows : int, cols : int,
				// array of cell spans - has information about merged cells,
				// table style :
				// 		WigiShowGrid - show table grid,
				// 		WigiSameRowHeight - all rows in a table are as high as the tallest row
				//		WigiTableColumnWidths - array of column widths
				//		WigiTableShowHeaders - show headers in spreadsheet
				//		WigiTableBorder - width of border and corner radius
				//		WigiTableHighlight - column and row to highlight
				//		WigiTableSize - visible size of table
				WigiTable(rows : int, cols : int, cellSpans : [WigiCellSpan], style : [WigiTableStyle]);
					WigiCellSpan : (row : int, col : int);
					WigiTableStyle ::= WigiShowGrid, WigiSameRowHeight, WigiTableColumnWidths, WigiTableRowHeights, WigiTableShowHeaders, WigiTableShowFormulaBar,
						WigiTableBorder, WigiFirstTabColumn, WigiTableHighlight, WigiTableSize,
						WigiTableVisibleFormula, WigiTableTightWidth, WigiTableRigidCols, WigiTableDontFitToAvailableWidth, WigiTableDisableForceShrinkOnMobile;

						WigiShowGrid();
						WigiSameRowHeight();
						WigiTableColumnWidths(widths : [double]);
						WigiTableRowHeights(heights : [double]);
						WigiTableShowHeaders();
						WigiTableShowFormulaBar();
						WigiTableBorder(width : double, radius : double, color : int);
						WigiFirstTabColumn(index : int);
						WigiTableHighlight(column : string, row : string);
						nullWigiTableHighlight = WigiTableHighlight("", "");
						WigiTableSize(columns : int, rows : int);
						WigiTableVisibleFormula(formula : string);
						WigiTableTightWidth();
						WigiTableRigidCols();
						WigiTableDontFitToAvailableWidth();
						WigiTableDisableForceShrinkOnMobile();

				WigiTableCell(widthHeight : DynamicBehaviour<WidthHeight>, cellStyle : [WigiTableCellStyle]);
					WigiTableCellStyle ::=	WigiCellBorder, WigiCellPadding, WigiCellColors, WigiCellTightWidth,
											PlaceholderText, WigiCellInnerBorder, WigiCellFormatting, WigiCellVerticalAlign, WigiCellContentFit, WigiSuppressTableBorder;
						WigiCellBorder(topBorder : double, endBorder : double, bottomBorder : double, startBorder : double);
						WigiCellPadding(startPadding : double, topPadding : double, endPadding : double, bottomPadding : double);
						WigiCellColors(border : int, background : int);
						WigiCellTightWidth();
						PlaceholderText(text : string);
						WigiCellInnerBorder(thickness : double, radius : double, color : int, padding : double);
						WigiCellFormatting(style : WigiCellFormattingStyle);
							WigiCellFormattingStyle ::= WigiCellFormattingGeneral, WigiCellFormattingNumber, WigiCellFormattingCurrency,
														WigiCellFormattingDate, WigiCellFormattingTime, WigiCellFormattingPercentage, WigiCellFormattingSignificant;
								WigiCellFormattingGeneral();
								WigiCellFormattingNumber(decimal: int, useSeparator: bool, negativeFormat: NegativeNumberStyle, scientific: bool);
									NegativeNumberStyle ::= nnNormal, nnRed, nnBrackets, nnBracketsAndRed;
										nnNormal();
										nnRed();
										nnBrackets();
										nnBracketsAndRed();

								WigiCellFormattingCurrency(decimal: int, currencyCode: Maybe<CurrencyCodeStyle>, negativeFormat: NegativeNumberStyle);
									CurrencyCodeStyle ::= ccUSD, ccEUR, ccGBP, ccYEN;
										ccUSD();
										ccEUR();
										ccGBP();
										ccYEN();
								WigiCellFormattingDate(dateFormat: int);
								WigiCellFormattingTime(timeFormat: int);
								WigiCellFormattingPercentage(decimal: int);
								WigiCellFormattingSignificant(digits: int, scientific: bool);
						WigiCellVerticalAlign(align: WigiCellAlign);
							WigiCellAlign ::= CellAlignTop, CellAlignCenter, CellAlignBottom;
								CellAlignTop();
								CellAlignCenter();
								CellAlignBottom();

						WigiCellContentFit(fit : WigiCellFit);
							WigiCellFit ::= CellCrop, CellShrink, CellScroll;
								CellCrop();
								CellShrink();
								CellScroll();

						WigiSuppressTableBorder();

						DefaultCellPadding = WigiCellPadding(5.0, 5.0, 5.0, 5.0);
						DefaultCellBorder = WigiCellBorder(1.0, 1.0, 1.0, 1.0);
						DefaultCellColors = WigiCellColors(0x7F808285, 0xffffff);
						DefaultCellInnerBorder = WigiCellInnerBorder(2.0, 2.0, 2143733446, 5.0);
						DummyCellInnerBorder = WigiCellInnerBorder(0.0, 0.0, -1, 0.0);
						DefaultCellFormatting : WigiCellFormatting = WigiCellFormatting(WigiCellFormattingGeneral());
						DefaultCellVerticalAlign = WigiCellVerticalAlign(CellAlignTop());
						DefaultCellContentFit = WigiCellContentFit(CellCrop());

				WigiSpreadsheetCell(widthHeight : DynamicBehaviour<WidthHeight>, editMode : DynamicBehaviour<bool>, cellStyle : [WigiTableCellStyle]);

				// See case http://process.area9.dk/cases/default.asp?36702
				// And case http://process.area9.dk/cases/default.asp?37031
				WigiInteractiveTable: (formula: string, value: DynamicBehaviour<[WigiRecord]>, style: [InteractiveTableStyle]);
					InteractiveTableStyle ::= AddButtonCaption, DisableUpDownButtons;
						AddButtonCaption: (caption: string);
						DisableUpDownButtons: ();

				WigiFrame(width : double, height : double, style : [WigiFrameStyle]);
					WigiFrameStyle ::= TightWidth, TightHeight, Scrollbars;
						TightHeight();
						Scrollbars(horizontal : bool, vertical : bool);
				// Code for the evaluation engine
				WigiCode(showCode : DynamicBehaviour<bool>, showResult : DynamicBehaviour<bool>);

				// A special construct which can prepare specific editors for values of the listed type
				WigiTyped(type : string);

				// A simple button
				WigiButton(width : double, style : [WigiButtonStyle]);
					WigiButtonStyle ::= BackgroundFill, OptionalFormula;
						OptionalFormula(formula : string);

				WigiHyperlink(url : string);

				WigiRadioOption: (
					id: string,		// Id of the variable that will
					value: int 		// receive this value when the choice is made
				);
				// is used in order to edit WigiRadioOption
				WigiRadioOptionAlign ::= WigiLeft, WigiRight, WigiAbove, WigiBelow, WigiLineStart, WigiLineEnd;
					WigiLeft();      // Absolute. Renders the button always at left, unregarding current language.
					WigiRight();     // Absolute. Renders the button always at right, unregarding current language.
					WigiLineStart(); // BiDi-aware, renders the button at left for LTR and at right for RTL.
					WigiLineEnd();   // BiDi-aware, renders the button at right for LTR and at left for RTL.
					WigiAbove();
					WigiBelow();

				WigiRadioOptionProperties : (
					align : WigiRadioOptionAlign,
					frame : Maybe<WigiFrame>,
					buttonElements : [WigiElement],
					otherElements : [WigiElement],
					paragraphStyle : [WigiParagraphStyle]
				);

				WigiVisible(style : [WigiVisibleStyle]);
					WigiVisibleStyle ::= OptionalFormula;

				// Shows different versions of wigi document,
				// where the child of the recursive is original WigiElement and there might be many its versions in array
				WigiVersions(versions : [WigiVersion]);
					WigiVersion(id : string, changed : WigiElement);

				// Structure to support external recursive in Wigi
				// exType - uniq identifier of recursive type
				// content - all recursive element's properties stored as string
				WigiExternalRecursive(exType : string, content : Tree<string, string>);


			// For future use - styles that are general for all elements. The specific style for each type should go in the specific type
			WigiRecursiveStyle ::= WigiName, Underline, BaselineShift, DoubleUnderline, WigiEnabled, WigiEditorPreview, WigiRecursiveFontStyle;
				WigiEnabled(enabled : Behaviour<bool>);
				WigiRecursiveFontStyle(style : [BasicCharacterStyle]);

			// Use this styles during wigify or editor view to know sizes of rendered recursive's children
			WigiRecursiveChildInfoStyle ::= WigiRecursiveChildrenSizes, WigiRecursiveChildrenOffsets;
				WigiRecursiveChildrenSizes : (sizes : [DynamicBehaviour<WidthHeight>]);
				WigiRecursiveChildrenOffsets : (offsets : [DynamicBehaviour<Point>]);

		// A rectangular element without internal structure
		WigiBlock(type : WigiBlockType, style : [WigiBlockStyle]);

			WigiBlockType ::= WigiPicture, WigiSlider, WigiCheckBox, WigiPositionTag, WigiCustomSymbol, WigiFormdesigner, WigiSmartArt, WigiFormula, WigiPageBreak, WigiPageName,
								WigiVideo, WigiAudio, WigiCoach, WigiNaturalMath, WigiComboBox, WigiNativeWiki, WigiDotplot, WigiHistogram, WigiHistogramClasses, WigiDatepicker, WigiCalculator,
								WigiHTML, WigiReferenceDocument, WigiBoxplot, WigiScatterplot, WigiSetClipboardButton, WigiInputBox, WigiChoiceBlock, WigiRadioButton, WigiExternalBlock,
								WigiFeedback, WigiFeedbackBlock, WigiStackedBar, WigiFillBlankBlock;
				// A picture
				WigiPicture(url : string, style : [WigiPictureStyle]);
					WigiPictureStyle ::= PictureAutomaticResizingToFit, PictureWidthHeight, PictureScale, PictureAllowZoom,
						PictureExtraZoom, PictureDecorations, PictureScaleToWidth, PictureScaleToHeight, PictureScaleBeforeDecorations,
						PictureCustomZoomCloseButton, PictureApplyCropBeforeScale, PictureUnlimitedPreview, VirtualScreenInfo, PictureZoomBackgroundColor;
					PictureAutomaticResizingToFit();
					PictureWidthHeight(width : double, height : double);
					PictureScale(scale : double);
					PictureAllowZoom();
					PictureExtraZoom();
					PictureDecorations(decorations : [ImageDecoration]);
					PictureScaleToWidth(toWidth : double);
					PictureScaleToHeight(toHeight : double);
					PictureScaleBeforeDecorations();
					PictureCustomZoomCloseButton(align : int, formButtonFn : (() -> void) -> Form);
					PictureApplyCropBeforeScale();
					PictureUnlimitedPreview();
					PictureZoomBackgroundColor(color : Color);

				// A video
				WigiVideo: (url : string, style : [WigiVideoStyle]);
					WigiVideoStyle ::= LoopPlayback, PlayerSize, NoAutoPlay, NoControls, ClosedCaptions, PlayerAvailableSize, WigiVideoScale, WigiVideoFormat;
						WigiVideoScale(scale : double);
						WigiVideoFormat(format : string);

				// An audio
				WigiAudio: (url : string, style : [WigiAudioStyle]);
					WigiAudioStyle ::= LoopPlayback, NoAutoPlay, ClosedCaptions;

				// Coach text
				WigiCoach: (text: string);

				// A numeric slider
				WigiSlider(value : DynamicBehaviour<double>, minValue : double, maxValue : double, step : double, width : double, style : [WigiSliderStyle]);
					WigiSliderStyle ::= WigiSliderButtons, WigiSliderMinValueFormula, WigiSliderMaxValueFormula;
						WigiSliderButtons();
						WigiSliderMinValueFormula(formula : string);
						WigiSliderMaxValueFormula(formula : string);
				// A checkbox
				WigiCheckBox(value : DynamicBehaviour<bool>, style : [WigiCheckBoxStyle]);
					WigiCheckBoxStyle ::= NoStyle;
						NoStyle();

				// Radio button itself, makes sense inside WigiRadioOption recursive
				WigiRadioButton(value: DynamicBehaviour<bool>, style: [WigiRadioButtonStyle]);
					WigiRadioButtonStyle ::= NoStyle;

				// This is a tag that is used during editing processing to be able to find specific points
				WigiPositionTag(id : int);
				// Custom symbol
				WigiCustomSymbol(type : WigiCustomSymbolType, size : double);
					WigiCustomSymbolType ::= CustomSymbolType, NonUnicodeSymbolType;
						NonUnicodeSymbolType ::= OOmacronSymbol;
							OOmacronSymbol();

				// A formdesigner object
				WigiFormdesigner(drawing : string, style : [WigiFormdesignerStyle]);
					WigiFormdesignerStyle ::= WigiFormdesignerResizeMode, WigiFormdesignerBackground, WigiFormdesignerAllowZoom;
						WigiFormdesignerResizeMode(mode: FormdesignerResizeMode);
							FormdesignerResizeMode ::= FormdesignerResizeAuto, FormdesignerResizeScale;
								FormdesignerResizeAuto();
								FormdesignerResizeScale(scale: double); // in % of the actual ActiveArt size or the available cell width, whichever is smaller
						WigiFormdesignerBackground(style : [GraphicsStyle]);
						WigiFormdesignerAllowZoom();

				// A SmartArt object
				WigiSmartArt(content : string, style : [WigiSmartArtStyle]);
					WigiSmartArtStyle ::= WigiSmartArtVariablesList;
						WigiSmartArtVariablesList(varsList : [string]);

				WigiFormula(formula : string, style : [WigiFormulaStyle]);
					WigiFormulaStyle ::= WigiCellFormatting;

				WigiPageBreak: (append: bool, autoScroll: bool);

				WigiPageName: (name: string, disableCondition: string); // disableCondition format: "" or "{condition}"

				WigiNaturalMath(formula : string);

				WigiComboBox(selected : DynamicBehaviour<int>, values : string, reorderElements : bool, width : double); // width == 0.0 - autosize


				WigiInputBox(text : DynamicBehaviour<string>, width : double, height : double, style : [WigiInputBoxStyle]);
					WigiInputBoxStyle ::= WigiInputMultiline;
						WigiInputMultiline();
					//	WigiInputLength(minimumChars : int, maximumChars : int);
					//	WigiInputNumber(integer : bool, minimum : double, maximum : double);

				WigiNativeWiki(wiki : string);

				WigiDotplot(range : string, style : [WigiDotplotStyle]);
					WigiDotplotStyle ::= WigiDotplotFormat, WigiDotplotSize, WigiDotStyle, WigiDotplotValueList, WigiDotplotLabels, WigiDotplotNamespace;
						WigiDotplotFormat(min : double, max : double, step : double, csvList : string);
						WigiDotplotSize(height : double, width : double);
						WigiDotStyle(color : int, radius : int, fill : bool, showData : bool, showBorder : bool);
						WigiDotplotValueList(valList : [[string]]);
						WigiDotplotLabels(title : string, axisX : string);
						WigiDotplotNamespace(name : string);

				WigiHistogram(range : string, style : [WigiHistogramStyle]);
					WigiHistogramStyle ::= WigiHistogramFormat, WigiHistogramSize, WigiBarStyle, WigiHistogramGrid, WigiHistogramLabels, WigiHistogramValueList, WigiHistogramNamespace;
						WigiHistogramFormat(minX : double, maxX : double, stepX : double, maxY : double, stepY : double, csvList : string);
						WigiHistogramSize(height : double, width : double);
						WigiBarStyle(color : int, fill : bool, showData : bool, showBorder : bool);
						WigiHistogramGrid(showLines : bool);
						WigiHistogramLabels(title : string, axisX : string, axisY : string);
						WigiHistogramValueList(valList : [[string]]);
						WigiHistogramNamespace(name : string);

				WigiHistogramClasses(range : string, style : [WigiHistogramClassesStyle]);
					WigiHistogramClassesStyle ::= WigiHistogramClassesFormat, WigiHistogramClassesSize, WigiHistogramClassesBarStyle, WigiHistogramClassesGrid,
							WigiHistogramClassesLabels, WigiHistogramClassesValueList, WigiHistogramClassesNamespace;
						WigiHistogramClassesFormat(minX : double, maxX : double, stepY : double, maxY : double,
													lowerBoundary : double, classWide : double, csvList : string);
						WigiHistogramClassesSize(height : double, width : double);
						WigiHistogramClassesBarStyle(color : int, showData : bool, showBorder : bool);
						WigiHistogramClassesGrid(showLines : bool);
						WigiHistogramClassesLabels(title : string, axisX : string, axisY : string);
						WigiHistogramClassesValueList(valList : [[string]]);
						WigiHistogramClassesNamespace(name : string);

				WigiBoxplot(range : string, style : [WigiBoxplotStyle]);
					WigiBoxplotStyle ::= WigiBoxplotFormat, WigiBoxplotSize, WigiBoxplotBoxStyle, WigiBoxplotLabels, WigiBoxplotValueList, WigiBoxplotNamespace;
						WigiBoxplotFormat(minX : double, maxX : double, stepX : double, plotMode : int, csvList : string);
						WigiBoxplotSize(height : double, width : double);
						WigiBoxplotBoxStyle(boxColor : int, pointColor : int, showData : bool, showBorder : bool);
						WigiBoxplotLabels(title : string, axisX : string);
						WigiBoxplotValueList(valList : [[string]]);
						WigiBoxplotNamespace(name : string);

				WigiScatterplot(range : string, style : [WigiScatterplotStyle]);
					WigiScatterplotStyle ::= WigiScatterplotFormat, WigiScatterplotSize, WigiScatterplotDotStyle, WigiScatterplotValueList, WigiScatterplotLabels,
											WigiScatterplotCorrelCoeff,WigiScatterplotDot2Style, WigiScatterplotNamespace,WigiScatterplotDot3Style,
											WigiScatterplotMarkerStyle, WigiScatterplotLegend;
						WigiScatterplotFormat(minX : double, maxX : double, stepX : double, minY : double, maxY : double, stepY : double, csvList : string);
						WigiScatterplotSize(height : double, width : double);
						WigiScatterplotDotStyle(color : int, size : int, fill : bool, showData : bool, showBorder : bool, showCorrel : bool);
						WigiScatterplotDot2Style(color : int, size : int, fill : bool);
						WigiScatterplotDot3Style(color : int, size : int, fill : bool);
						WigiScatterplotMarkerStyle(graph1 : int, graph2 : int, graph3 : int);
						WigiScatterplotLegend(graph1 : string, graph2 : string, graph3 : string);
						WigiScatterplotCorrelCoeff(varName : string, decimal : int);
						WigiScatterplotLabels(title : string, axisX : string, axisY : string);
						WigiScatterplotValueList(valList : [[string]]);
						WigiScatterplotNamespace(name : string);

				WigiStackedBar(range : string, style : [WigiStackedBarStyle]);
					WigiStackedBarStyle ::= WigiStackedBarFormat, WigiStackedBarSize, WigiStackedBarGraphStyle, WigiStackedBarLabels, WigiStackedBarValueList,
											WigiStackedBarNamespace;
						WigiStackedBarFormat(minX : double, maxX : double, stepX : double, maxY : double, stepY : double, csvList : string);
						WigiStackedBarSize(height : double, width : double);
						WigiStackedBarGraphStyle(showGroups : bool, showHorizBar : bool, showValues : bool, showVertLabels : bool, showGridLines : bool,
												showBorder : bool, graph : [StackedBarGraphStyle]);
							StackedBarGraphStyle(color : int, strokeColor : int, legend : string);
						WigiStackedBarLabels(title : string, axisX : string, axisY : string);
						WigiStackedBarValueList(valList : [[string]]);
						WigiStackedBarNamespace(name : string);

				WigiDatepicker(date : DynamicBehaviour<Date>, style : [WigiDatepickerStyle]);
					WigiDatepickerStyle();

				WigiCalculator();

				WigiHTML(url : string, width : double, height : double, style : [WigiHTMLStyle]);
					WigiHTMLStyle ::= HideContentWhenEditing, PageEvalJS, UpdateCachedContent, ReloadBlock, SandBoxJS, MouseDisabled, OnError, OnPageLoaded, RealHtmlShrink2Fit;
						HideContentWhenEditing();

				WigiReferenceDocument(title : string, document : WigiElement);

				WigiSetClipboardButton(title : string, text : string);

				WigiChoiceBlock(formula : string, choices: [WigiChoice]);
					WigiChoice(operator : ChoiceOperator, value : WigiValue, result : WigiElement);
						ChoiceOperator ::= WEquals, WNotEquals, WLessThan, WLessThanOrEqual, WGreaterThan, WGreaterThanOrEqual,
								WInside, WOtherwise, WCustomCondition;

							WEquals();
							WNotEquals();
							WLessThan();
							WLessThanOrEqual();
							WGreaterThan();
							WGreaterThanOrEqual();
							WInside();
							WOtherwise();
							WCustomCondition();

				// Structure to support external blocks in Wigi
				// exType - uniq identifier of block type
				// content - all blocks properties stored as string
				WigiExternalBlock(exType: string, content: Tree<string, string>);
				dummyWigiExternalBlock = WigiExternalBlock("", makeTree());

				// Deprecated, please use WigiFeedbackBlock
				// Implemented based on wiki-code, similar to SmartArt --> Interactive Wiki --> Wiki Feedback --> Basic Feedback
				WigiFeedback(condition : string, description : WigiFeedbackDescription);
					WigiFeedbackDescription(vertical : bool, type : WigiFeedbackType);
						WigiFeedbackType ::= WigiBasicFeedback;
							WigiBasicFeedback(correct : string, incorrect : string, general : string);

				// Wigi own implementation of Feedback
				// formula format: "=combobox1"
				// visibilityCondition format: "combobox1 > 1"
				WigiFeedbackBlock(formula : string, visibilityCondition : string, interactiveType: WigiFeedbackInteractiveType, choices: [WigiFeedbackChoice]);
					WigiFeedbackInteractiveType ::= ComboboxOther, HotspotCheckbox;
						ComboboxOther();
						HotspotCheckbox();
					WigiFeedbackChoice(type : WigiFeedbackChoiceType, operator : ChoiceOperator, value : WigiValue, result : WigiElement);
						WigiFeedbackChoiceType ::= WigiFeedbackCorrect, WigiFeedbackIncorrect, WigiFeedbackMissing;
							WigiFeedbackCorrect();
							WigiFeedbackIncorrect();
							WigiFeedbackMissing();

				// Wigi own implementation of fill-blank
				WigiFillBlankBlock(width: double, caseSensitive: bool, exactMatch: bool, mathFeatures : [WFMathFeatures], answers : [WFFillBlankAnswerType], otherAnswer : WFOtherAnswer);
					WFMathFeatures ::= WFRequiredSymbols, WFRequiredDecimalPlaces;
						WFRequiredSymbols(requiredSymbol : WFRequiredSymbolsType);
							WFRequiredSymbolsType ::= WFRequireDollarSymbolInAnswers, WFRequirePercentSymbolInAnswers;
								WFRequireDollarSymbolInAnswers();
								WFRequirePercentSymbolInAnswers();
						WFRequiredDecimalPlaces(decPlaces : double);
					WFFillBlankAnswerType ::= WFCorrectAnswer, WFAlmostCorrectAnswer, WFWrongAnswer;
						WFCorrectAnswer : (answer : string, remediation : WigiElement);
						WFAlmostCorrectAnswer : (answer : string, remediation : WigiElement);
						WFWrongAnswer : (answer : string, remediation : WigiElement);
					WFOtherAnswer : (remediation : WigiElement);
					WFFillBlankAnswerTypeExtended ::= WFFillBlankAnswerType, WFOtherAnswer;

			// For future use - styles that are general for all elements. The specific style for each type should go in the specific type
			WigiBlockStyle ::= WigiName, WigiTextStyle, ExternalDeleteElement, WigiEditorPreview;
				// style to set callback for deleting certain wigi element (block or recursive)
				ExternalDeleteElement(fn : () -> void);
				// used for preview in wigi editor (preview button in toolbar)
				WigiEditorPreview();

	// It used to be in wigi_expr.flow
	WigiValue ::= WigiBool, WigiInt, WigiDouble, WigiString, WigiError, WigiLambda, WigiDefaultValue,
				WigiElementValue, WigiArray, WigiBuiltInName, WigiDate, WigiTime, WigiRecord;
		WigiBool(v : bool);
		WigiInt(v : int);
		WigiDouble(v : double);
		WigiString(v : string);
		WigiDate(year: int, month : int, day: int);
		WigiTime(hour: int, minute: int, sec: int);
		WigiError(message : string);
		WigiDefaultValue(); // Neutral element
		WigiElementValue(element : WigiElement); // A wigi document!
		WigiBuiltInName(name : string);

		WigiLambda(args : [string], body : WigiExpr);
		WigiArray(values : [WigiValue]);
		WigiRecord(fields : [Pair<string, WigiValue>]);

	WigiExpr ::= /*WigiLet, */ WigiVarRef, WigiCellRefRC, WigiCellRefA1, WigiCall, WigiIf, WigiSequence, WigiMatch, WigiRangeA1,
				WigiRangeRC, WigiValue, WigiField, WigiNamespace, WigiMultiplicative, WigiMult, WigiMakeArray, WigiMakeRecord,
				WigiDatafunList, WigiDatafunInExpr;
		// It's a name of variable, used for all interactive elements, calculated cells and spreadsheet cells
		// Possible values: "formula1", "slider2", "abc1"
		WigiVarRef(x : string);
		// It's a reference to spreadsheet cells in RC notation
		// Possible values:
		// R1C1		=> WigiCellRefRC(AbsRef(1), AbsRef(1))
		// R[-2]C 	=> WigiCellRefRC(RelRef(-2), RelRef(0))
		// R1C[-1]	=> WigiCellRefRC(AbsRef(1), RelRef(-1))
		WigiCellRefRC(r: CellRef, c: CellRef);
			CellRef ::= RelRef, AbsRef;
				RelRef(dx: int);	// relative reference
				AbsRef(x: int);		// absolute reference


		// This can also be a var: x1, y1
		WigiCellRefA1(x : string);

		WigiCall(fn : WigiExpr, args : [WigiExpr]);

		WigiIf(condition : WigiExpr, then : WigiExpr, else_ : WigiExpr);

		WigiSequence(exprs : [WigiExpr]);

		WigiMatch(expr : WigiExpr, cases : [WigiMatchCase]);
			WigiMatchCase(pattern : WigiExpr, body : WigiExpr);

		// Range of cells based on A1 notation, used in spreadsheet
		WigiRangeA1(start : WigiCellRefA1, end : WigiCellRefA1);
		// Range of cells based on RC notation, used in spreadsheet
		WigiRangeRC(start : WigiCellRefRC, end : WigiCellRefRC);

		// Indexing into records
		WigiField(left : WigiExpr, right : [WigiExpr]);

		// Namespace resolving
		WigiNamespace(namespace : [string], right : WigiExpr);

		WigiMultiplicative(exprs : [WigiExpr]);
		WigiMult(op : string, expr : WigiExpr);

		// We need WigiMakeArray and WigiMakeRecord to use expressions inside. Actually, this is a workaround
		// of moving WigiArray and WigiRecord to WigiExpr union (it would require to rework tones of code)
		WigiMakeArray(values : [WigiExpr]);
		WigiMakeRecord(fields : [Pair<string, WigiExpr>]);

		// This structure represents expressions like [X + Y|X in [1,2,3], Y in [2,3,4], (X + Y) >= 5]. The result is [5,5,6,5,6,7].
		WigiDatafunList(mainExpr : WigiExpr, varsExprs : [WigiExpr]);
		// A part of WigiDatafunList. Represents "A in B" expressions
		WigiDatafunInExpr(id : string, valuesExpr : WigiExpr);

	// After wigifying each page becomes this
	WigifiedPage : (
		form: () -> Form,
		coachTexts: [string],
		name: string,
		disableCondition: string,
		scroll : bool,
		autoScroll : bool,
		marginContent : AnnotationsMarginContent
	);

	AnnotationsMarginContent ::= MarginContentAcc, ComposedMarginContent, EmptyMarginContent;

		MarginContentAcc : (composers : [SingleAnnotationComposer]);
			// Structure to collect margin content of single annotation
			// for future composing from different levels of wigi recursives.
			SingleAnnotationComposer : (yCoordCalc : () -> double, annotationId : int);
		// Margin content that is ready to be shown.
		ComposedMarginContent : (marginForm : () -> Form);
		EmptyMarginContent : ();

	ShowStructures: (
		naturalMath: DynamicBehaviour<bool>,
		nativeWiki: DynamicBehaviour<bool>,
		smartArt: DynamicBehaviour<bool>,
		formula: DynamicBehaviour<bool>,
		choice: DynamicBehaviour<bool>,
		feedback: DynamicBehaviour<bool>
	);

	WigiLock(type : WigiLockType);
		WigiLockType ::= WigiReadOnly, WigiSelectOnly, WigiAddOnly, WigiNoLock;
			WigiReadOnly();
			WigiSelectOnly();
			WigiAddOnly();
			WigiNoLock();


	WigiParentStyle : (paragraphStyle: [WigiParagraphStyle], textStyle : [WigiTextStyle], accRelativeFontSizeChange : double);

	// A unifying type for all WigiElement styles
	WigiStyle ::= WigiDocumentStyle, WigiStoryStyle, WigiParagraphStyle, WigiTextStyle,
					WigiRecursiveStyle, WigiBlockStyle;

		WigiName(name : string);

	// Define text and paragraph styles for children of a specific parent.
	// "type" is a structname of the parent.
	// Usually used in an array [WigiStyles] as default styles for Wigi editor or Wigify
	// It is supposed that there is only one WigiStyles of a particular type in the array.
	// Any duplications are ignored and have no effect.
	// Examples:
	// 1) [WigiStyles("WigiDocument", ps, ts)]
	// 		All the paragraphs and texts in the document have styles "ps" and "ts" respectively
	// 2) [WigiStyles("WigiDocument", ps, ts), WigiStyles("WigiFraction", ps1, ts1)]
	// 		All the paragraphs and texts in the document have styles "ps" and "ts",	except for
	//		the paragraphs and texts that are children of WigiFraction. They have styles "ps1" and "ts1".
	// 3) [WigiStyles("WigiDocument", ps, []), WigiStyles("WigiDocument", [], ts)]
	// 		The first WigiStyles works, the second one is ignored,
	//		so all the paragraphs have "ps" style and all the texts have [] (not "ts").
	WigiStyles : (type : string, paragraphStyle : [WigiParagraphStyle], textStyle : [WigiTextStyle]);

	// Helper to make a story
	makeWigiStory(elements : [WigiElement], style : [WigiStoryStyle]) -> WigiStory;

	// return empty story with defined styles
	getEmptyStoryWithDefinedStyles(styles : Triple<[WigiTextStyle], [WigiParagraphStyle], [WigiStoryStyle]>) -> WigiElement;

	// returns WigiStory for sure
	wigiElement2wigiStory(wigi : WigiElement) -> WigiStory;

	// Fairly expensive for stories
	getWigiElementChildren(element : WigiElement, visibleOnly : bool) -> [WigiElement];

	// Fairly cheap
	getWigiChildCount(element : WigiElement, visibleOnly : bool) -> int;

	// Fairly cheap
	indexWigiChildren(element : WigiElement, index : int, default_ : WigiElement) -> WigiElement;

	// How many children should this recursive type have? -1 if it is infinite
	wigiRecursiveChildCount(type : WigiRecursiveType) -> int;

	element2string(element : WigiElement) -> string;

	dummyWigiElement : WigiElement;

	dummyWigiParagraph : WigiParagraph;

	// Simplifies given element to the most precise type available in hierarchy of (Document, Story, Paragraph, Text, Empty())
	simplifyElement(element: WigiElement) -> WigiElement;

	isEmptyElement(element: WigiElement) -> bool;

	isWigiContent(text : string) -> bool;

	// concat two WigiElements
	concatWigi(w1: WigiElement, w2: WigiElement) -> WigiElement;

	isWigiPageBreak(element: WigiElement) -> bool;

	isWigiPageBreak2(append: bool) -> (WigiElement) -> bool;

	isWigiCoach(element: WigiElement) -> bool;

	isWigiEmptyLine(element: WigiElement) -> bool;

	isWigiRadioButton(element: WigiElement) -> bool;

	isWigiStory(element: WigiElement) -> bool;

	isWigiText(element : WigiElement) -> bool;

	isWigiEmptyText(element: WigiElement) -> bool;

	zoomFontSize(zoom : double, fullStyle : [WigiTextStyle]) -> [WigiTextStyle];

	isLockedWigi(lockType: WigiLockType) -> bool;

	dwfs = FontSize(16.0); // default wigi font size
	dwis = InterlineSpacing(2.0); // default wigi interline spacing
	dwps = ParagraphSpacing(3.0); // default wigi paragraph spacing

	// Collects all elements that satisfy a given condition
	collectWigiElements(root: WigiElement, filterFn: (WigiElement) -> bool) -> [WigiElement];

	// General fold on WigiElement
	foldWigiElement(root: WigiElement, initPath: [int], init: ?, fn: (acc: ?, element: WigiElement, path: [int]) -> ?) -> ?;

	emptyWigiText = WigiText("", []);

	getWigiCellContentFitOptions() -> [string];
	getWigiCellContentFitIndex(fit : WigiCellFit) -> int;
	getWigiCellContentFitByIndex(i : int) -> WigiCellFit;

	isWigiBlock(element : WigiElement, types : [WigiBlockType]) -> bool;

	getEmptyTextDocument() -> string;
}

isWigiContent(text : string) -> bool {
	startsWith(text, "Wigi") && (
		startsWith(text, "WigiDocument") ||
		startsWith(text, "WigiStory") ||
		startsWith(text, "WigiParagraph") ||
		startsWith(text, "WigiText") ||
		startsWith(text, "WigiEmpty") ||
		startsWith(text, "WigiRecursive") ||
		startsWith(text, "WigiBlock")
	)
}

makeWigiStory(elements : [WigiElement], style : [WigiStoryStyle]) -> WigiStory {
	WigiStory(ref elements, ref [], style)
}

getEmptyStoryWithDefinedStyles(styles : Triple<[WigiTextStyle], [WigiParagraphStyle], [WigiStoryStyle]>) -> WigiElement {
	makeWigiStory([WigiParagraph([WigiText("", styles.first)], styles.second)], styles.third)
}

wigiElement2wigiStory(wigi : WigiElement) -> WigiStory {
	switch (wigi : WigiElement) {
		WigiDocument(root, style): cast(root : WigiElement -> WigiStory);
		WigiStory(paragraphs, views, style): wigi;
		WigiParagraph(elements, style): makeWigiStory([wigi], []);
		default: makeWigiStory([WigiParagraph([wigi], [])], []);
	}
}

getWigiElementChildren(element : WigiElement, visibleOnly : bool) -> [WigiElement] {
	switch (element : WigiElement) {
		WigiDocument(root, style): [root];
		WigiStory(stories, views, style): ^stories;
		WigiParagraph(elements, style): elements;
		WigiText(text, style): [];
		WigiEmpty(): [];
		WigiRecursive(elements, type, style): {
			if (visibleOnly) {
				switch (type : WigiRecursiveType) {
					WigiCode(sc, sr): if (getValue(sc)) elements else [];

					WigiBrackets(leftBraketType, rightBracketType): elements;
					WigiComap(collapsed): if (getValue(collapsed)) subrange(elements, 0, 1) else elements;
					WigiDottedElement(left, right, top, bottom, leftSign, rightSign): elements;
					WigiFraction(): elements;
					WigiProduct(): elements;
					WigiEvaluatingIntegral() : elements;
					WigiRoot(): elements;
					WigiLongDivision(): elements;
					WigiIntegral(): elements;
					WigiIntegral2(signType): elements;
					WigiTopModificator(t, s): elements;
					WigiSum(): elements;
					WigiSupscript(): elements;
					WigiSubscript(): elements;
					WigiSupSubscript() : elements;
					WigiOverscript(): elements;
					WigiUnderscript(): elements;
					WigiOverlay(): elements;
					WigiAltText(): elements;
					WigiTable(r, c, cs, s): elements;
					WigiTableCell(wh, cs): elements;
					WigiSpreadsheetCell(wh, em, cs): elements;
					WigiFrame(w, h, s): elements;
					WigiTyped(typ): elements;
					WigiButton(w, s): elements;
					WigiHyperlink(u): elements;
					WigiInteractiveTable(f, r, s): elements;
					WigiRadioOption(i, v): elements;
					WigiVisible(__): elements;
					WigiVersions(__): elements;
					WigiExternalRecursive(__, __): elements;
				}
			} else elements;
		}
		WigiBlock(type, style): [];
	}
}

getWigiChildCount(element : WigiElement, visibleOnly : bool) -> int {
	switch (element : WigiElement) {
		WigiDocument(root, style): 1;
		WigiStory(stories, views, style): length(^stories);
		WigiParagraph(elements, style): length(elements);
		WigiText(text, style): strlen(text);
		WigiEmpty(): 0;
		WigiRecursive(elements, type, style): {
			length(if (visibleOnly) getWigiElementChildren(element, true) else elements);
		}
		WigiBlock(type, style): 1;
	}
}

indexWigiChildren(element : WigiElement, index : int, default_ : WigiElement) -> WigiElement {
	switch (element : WigiElement) {
		WigiDocument(root, style): if (index == 0) root else default_;
		WigiStory(stories, view, style): {
			if (0 <= index && index < length(^stories)) {
				(^stories)[index]
			} else default_
		}
		WigiParagraph(elements, style): {
			if (0 <= index && index < length(elements)) {
				elements[index];
			} else default_
		}
		WigiText(text, style): {
			if (0 <= index && index <= strlen(text)) {	// <= is not a typo here, it's fine to select after the end of the text
				WigiText(getCharAt(text, index), style);
			} else default_
		}
		WigiEmpty(): default_;
		WigiRecursive(elements, type, style): {
			if (0 <= index && index < length(elements)) {
				elements[index];
			} else default_
		}
		WigiBlock(type, style): default_;
	}
}


wigiRecursiveChildCount(type : WigiRecursiveType) -> int {
	switch (type : WigiRecursiveType) {
		WigiBrackets(leftBracketType, rightBracketType): 1;
		WigiComap(collapsed): -1;
		WigiDottedElement(left, right, top, bottom, leftSign, rightSign): 1;
		WigiFraction(): 2;
		WigiProduct(): 3;
		WigiEvaluatingIntegral(): 3;
		WigiRoot(): 2;
		WigiLongDivision(): 1;
		WigiIntegral(): 3;
		WigiIntegral2(signType): 2;
		WigiTopModificator(t, s): 1;
		WigiSum(): 3;
		WigiSupscript(): 2;
		WigiSubscript(): 2;
		WigiSupSubscript() : 3;
		WigiOverscript(): 2;
		WigiUnderscript(): 2;
		WigiOverlay(): 2;
		WigiAltText(): 1;
		WigiTable(r, c, cs, s): -1;
		WigiInteractiveTable(f, r, s): 1;
		WigiTableCell(wh, cs): 1;
		WigiSpreadsheetCell(wh, em, cs): 1;
		WigiFrame(w, h, s): 1;
		WigiCode(sc, sr): 1;
		WigiTyped(typ): {
			// TODO: Depending on what type it is, this varies
			-1;
		}
		WigiButton(w, s): 1;
		WigiHyperlink(u): 1;
		WigiRadioOption(o, v): 1;
		WigiVisible(__): 1;
		WigiVersions(__) : 1;
		WigiExternalRecursive(__, __): -1; // to be flexible
	}
}

element2string(element : WigiElement) -> string {
	element2string2(element, "")
}

element2string2(element : WigiElement, prefix: string) -> string {
	prefix + switch (element : WigiElement) {
		WigiDocument(root, style): "document:\n" + element2string2(root, prefix + "  ");
		WigiStory(elements, views, style): {
			fold(^elements, "story:\n", \acc, el -> acc + element2string2(el, prefix + "  ") + "\n");
		}
		WigiParagraph(elements, style): {
			fold(elements, "paragraph:\n", \acc, el -> acc + element2string2(el, prefix + "  ") + "\n");
		}
		WigiText(text, style): "text: " + text + " " + toString(style);
		WigiEmpty(): "empty";
		WigiRecursive(elements, type, style): fold(elements, "recursive: " + toString(type) + "\n", \acc, el -> acc + element2string2(el, prefix + "  ") + "\n");
		WigiBlock(type, style): type.structname;
	}
}

dummyWigiElement = WigiEmpty();

dummyWigiParagraph = WigiParagraph([emptyWigiText], []);

simplifyElement(element: WigiElement) -> WigiElement {
	if (isEmptyElement(element)) {
		WigiEmpty()
	} else {
		simplifyChildren = \elements -> {
			if (elements == []) {
				WigiEmpty()
			} else if (length(elements) == 1) {
				simplifyElement(elements[0])
			} else {
				element
			}
		}

		switch (element: WigiElement) {
			WigiDocument(root, style): simplifyElement(root);
			WigiStory(elements, views, style): simplifyChildren(^elements);
			WigiParagraph(elements, style): simplifyChildren(elements);
			WigiText(text, style): {
				if (text == "") {
					WigiEmpty()
				} else {
					element
				}
			}
			WigiEmpty(): element;
			WigiRecursive(elements, type, style): {
				switch(type) {
					WigiTable(__, __, __, __): element;
					default: WigiRecursive(map(elements, simplifyElement), type, style);
				}
			}
			WigiBlock(type, style): element;
		}
	}
}

isEmptyElement(element: WigiElement) -> bool {
	switch (element: WigiElement) {
		WigiDocument(root, style): isEmptyElement(root);
		WigiStory(elements, views, style): all(map(^elements, isEmptyElement));
		WigiParagraph(elements, style): all(map(elements, isEmptyElement));
		WigiText(text, style): text == "";
		WigiEmpty(): true;
		WigiRecursive(elements, type, style): {
				switch(type) {
					WigiTable(__, __, __, __): false;
					default: all(map(elements, isEmptyElement));
				}
		}
		WigiBlock(type, style): false;
	}
}

isWigiPageBreak(element: WigiElement) -> bool {
	switch(element){
		WigiBlock(type, __): {
			switch(type) {
				WigiPageBreak(__, __): true;
				default: false;
			}
		}
		default : false;
	}
}

isWigiPageBreak2(append: bool) -> (WigiElement) -> bool {
	\element: WigiElement -> {
		switch(element){
			WigiBlock(type, __): {
				switch(type) {
					WigiPageBreak(a, __): a == append;
					default: false;
				}
			}
			default : false;
		}
	}
}

isWigiCoach(element: WigiElement) -> bool {
	switch(element){
		WigiBlock(type, __): {
			switch(type) {
				WigiCoach(__): true;
				default: false;
			}
		}
		default : false;
	}
}

isWigiRadioButton(element: WigiElement) -> bool {
	switch(element){
		WigiBlock(type, __): {
			switch(type) {
				WigiRadioButton(__, __): true;
				default: false;
			}
		}
		default : false;
	}
}

isWigiStory(element: WigiElement) -> bool {
	switch(element) {
		WigiStory(__, __, __): true;
		default: false
	}
}

isWigiText(element : WigiElement) -> bool {
	switch(element : WigiElement) {
		WigiText(__, __): true;
		default: false;
	}
}

isWigiEmptyText(element: WigiElement) -> bool {
	switch(element) {
		WigiText(text, __): text == "";
		default: false
	}
}

isWigiEmptyLine(element: WigiElement) -> bool {
	switch(element){
		WigiParagraph(elements, __): {
			if (length(elements) == 1) {
				switch(elements[0]) {
					WigiText(text, __): text == "";
					default: false
				}
			} else false;
		}
		default : false;
	}
}

zoomFontSize(zoom : double, fullStyle : [WigiTextStyle]) -> [WigiTextStyle] {
	fold(fullStyle, [FontSize(zoom * extractStruct(fullStyle, dwfs).size)], \acc, st ->
		switch (st) {
			FontSize(__): acc;
			default: arrayPush(acc, st);
		});
}

isLockedWigi(lockType: WigiLockType) -> bool{
	lockType != WigiNoLock();
}

// concat two WigiElements
concatWigi(w1: WigiElement, w2: WigiElement) -> WigiElement {
	switch(w1) {
		WigiStory(paragraphs1, views1, style1): {
			switch(w2) {
				WigiStory(paragraphs2, views2, style2): {
					makeWigiStory(concat(^paragraphs1, ^paragraphs2), style2);
				}
				WigiParagraph(elements, style): {
					// Just add this guy at the end of the paragraph in the first element
					makeWigiStory(arrayPush(^paragraphs1, w2), style1);
				}
				default: {
					// Just add this guy at the end of the paragraph in the first element
					makeWigiStory(arrayPush(^paragraphs1, WigiParagraph([w2], [])), style1);
				}
			}
		}
		WigiEmpty(): w2;
		default: {
			if (w2 == WigiEmpty()) {
				w1;
			} else {
				WigiEmpty();
			}
		}
	}
}

collectWigiElements(root: WigiElement, filterFn: (WigiElement) -> bool) -> [WigiElement] {
	children = switch (root) {
		WigiDocument(doc, style): [doc];
		WigiStory(stories, views, style): ^stories;
		WigiParagraph(elements, style): elements;
		WigiText(text, style): [];
		WigiEmpty(): [];
		WigiRecursive(elements, type, style): elements;
		WigiBlock(type, style): [];
	}

	concat((if (filterFn(root)) [root] else []), concatA(map(children, \child -> collectWigiElements(child, filterFn))))
}

foldWigiElement(root: WigiElement, initPath: [int], init: ?, fn: (acc: ?, element: WigiElement, path: [int]) -> ?) -> ? {
	// TODO call getWigiElementChildren?
	children = switch (root) {
		WigiDocument(doc, style): [doc];
		WigiStory(stories, views, style): ^stories;
		WigiParagraph(elements, style): elements;
		WigiText(text, style): [];
		WigiEmpty(): [];
		WigiRecursive(elements, type, style): elements;
		WigiBlock(type, style): [];
	}

	foldi(children, fn(init, root, initPath), \idx, acc, element -> {
		foldWigiElement(element, arrayPush(initPath, idx), acc, fn)
	});
}

getWigiCellContentFitOptions() -> [string] {
	["Crop", "Shrink", "Scroll"]
}

getWigiCellContentFitIndex(fit : WigiCellFit) -> int {
	switch(fit : WigiCellFit) {
		CellCrop(): 0;
		CellShrink(): 1;
		CellScroll(): 2;
	}
}

getWigiCellContentFitByIndex(i : int) -> WigiCellFit {
	if (i == 0) CellCrop()
	else if (i == 1) CellShrink()
	else if (i == 2) CellScroll()
	else DefaultCellContentFit.fit;
}

isWigiBlock(element : WigiElement, types : [WigiBlockType]) -> bool {
	switch (element) {
		WigiBlock(t, s): {
			if (types != []) any(map(types, \type -> switch (t) {
				WigiExternalBlock(extType1, __) : {
					switch (type) {
						WigiExternalBlock(extType2, __) : {
							extType1 == extType2;
						}
						default : false;
					}
				};
				default : isSameStructType(type, t);
			})) else true;
		}
		default: false;
	}
}

getEmptyTextDocument() -> string {
	"WigiStory(ref [WigiParagraph([WigiText(\"\", [])], [CenterAlign()])], ref [], [])"
}
