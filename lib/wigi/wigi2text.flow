import wigi/external_recursive;
import wigi/wigify_types;

export {
	// Convert this Wigi to text as well as possible.
	wigi2text(document : WigiElement) -> string;

	wigi2textExtended(document : WigiElement, styles : [Wigi2TextExtended]) -> string;
		Wigi2TextExtended ::= WigifyEngine, Wigi2TextDetailed, Wigi2TextWithTextStyles, Wigi2TextDynamicValueTag;

		// in case no CalculateBlockFn nor Block2TextFn were defined for the ExternalBlock,
		// show the exType in the output
		Wigi2TextDetailed();
		
		Wigi2TextWithTextStyles();
		// Use this style to surround dynamic parts of text by
		// Special string tag. Dynamic parts of text are defined by
		// external block style Block2TextDynamicFn.
		Wigi2TextDynamicValueTag(tag : string);
}

wigi2text(document : WigiElement) -> string {
	wigi2textExtended(document, [])
}

wigi2textExtended(document : WigiElement, styles : [Wigi2TextExtended]) -> string {
	engine = extractStruct(styles, WigifyEngine(dummyWigiEngine())).engine;
	recursiveCall = \el, sep -> strGlue(map(el, \e -> wigi2textExtended(e, styles)), sep);
	withDetails = contains(styles, Wigi2TextDetailed());
	withTextStyles = contains(styles, Wigi2TextWithTextStyles());
	dynValueTagM = tryExtractStruct(styles, Wigi2TextDynamicValueTag(""));

	switch (document : WigiElement) {
		WigiDocument(root, style): wigi2text(root);
		WigiStory(elements, views, style): recursiveCall(^elements, "\n");
		WigiParagraph(elements, style): recursiveCall(elements, "");
		WigiText(text, style): {
			if (extractStruct(style, BaselineShift(0.0)).shift < 0.0) {
				// it looks like a math power
				formatString(_(" to the power of %1"), [text])
			} else if (withTextStyles) {
				color = eitherMap(tryExtractStruct(style, Fill(0)), \f -> i2s(f.color), "-");
				fontFamily = eitherMap(tryExtractStruct(style, FontFamily("Book")), \ff -> ff.name, "-");
				fontSize = eitherMap(tryExtractStruct(style, FontSize(16.0)), \fs -> d2s(fs.size), "-");
				text + "{" + color + "," + fontFamily + "," + fontSize + "}"
			} else text
		}
		WigiEmpty(): "";
		WigiRecursive(elements, type, style): {
			switch (type : WigiRecursiveType) {
				WigiExternalRecursive(exType, content): {
					eitherFn(
						getExternalRecursiveAPI(exType),
						\api -> {
							recursive2text = extractStruct(api.style, Recursive2TextFn(\__, el, __ -> recursiveCall(el, "\n"))).fn;
							recursive2text(content, elements, engine)
						},
						\ -> {
							println("Unsupported external recursive type: " + exType);
							""
						}
					)
				}
				WigiSum(): wigi3MembersNotation2text(elements, "sum");
				WigiProduct(): wigi3MembersNotation2text(elements, "product");
				WigiRoot(): {
					if (length(elements) == 2) {
						m1 = wigi2text(elements[0]);
						m1prepared = if (isDigits(m1)) i2sTh(s2i(m1)) else m1;
						m2 = wigi2text(elements[1]);
						formatString(_(" %1 root of %2 "), [m1prepared, m2])
					} else "Wigi Root conversion error"
				}
				WigiFraction(): wigi2MembersNotation2text(elements, _(" over "), "Fraction");
				WigiSupscript(): wigi2MembersNotation2text(elements, _(" to the power of "), "Supscript");
				WigiSubscript(): {
					if (length(elements) == 2) {
						m1 = wigi2text(elements[0]);
						m2 = wigi2text(elements[1]);
						formatString(_("%1 subscript %2 "), [m1, m2])
					} else "Wigi Subscript conversion error"
				}
				WigiBrackets(leftBracketType, rightBracketType): {
					openBracket = writeBracket2text(leftBracketType);
					closeBracket = writeBracket2text(rightBracketType);
					openBracket + recursiveCall(elements, "") + closeBracket
				}
				WigiIntegral(): wigi3MembersNotation2text(elements, "integral");
				WigiIntegral2(__): wigi3MembersNotation2text(elements, "");
				WigiTable(rows, cols, cellSpans, tstyle): {
					// TODO. We could read number of columns, rows and such
					recursiveCall(elements, "\n");
				}

				default: recursiveCall(elements, "\n");
			}
		}
		WigiBlock(type, style): { // TODO
			switch(type) {
				WigiNaturalMath(formula): "`" + formula + "`";
				WigiNativeWiki(wiki): wiki; //35823
				WigiPicture(url, __): "[" + url + "]"; //35823
				WigiVideo(url, __): "[" + url + "]"; //35823
				WigiAudio(url, __): "[" + url + "]"; //35823
				WigiSmartArt(content, __): "<sa>" + content + "</sa>"; //35823
				WigiExternalBlock(exType, content): eitherFn(getExternalBlockAPI(exType), \api -> {
					eitherFn(
						dynValueTagM,
						\dynValueTag -> {
							block2textDyn = extractStruct(api.style, Block2TextDynamicFn(\__, __, __ -> "")).fn;
							textDyn = toLowerCase(block2textDyn(content, engine, globalWigiNamespace));
							if (textDyn == "") "" else dynValueTag.tag + textDyn + dynValueTag.tag;
						},
						\ -> {
							calculateFn = extractStruct(api.style, CalculateBlockFn(\__, __, __ -> makeTree())).fn;
							calculated = calculateFn(content, engine, globalWigiNamespace);
							textContent = lookupTreeDef(calculated, "calculatedcontent", "");
							if (calculated == TreeEmpty()) {
							block2text = extractStruct(api.style, Block2TextFn(\__-> if (withDetails) exType else "")).fn;
							block2text(content);
							} else if (textContent != "") textContent
							else lookupTreeDef(calculated, "calculatedvalue", "");
						}
					)
				},
				\ -> {
					println("wigi2textExtended: Unsupported external block type: " + exType);
					""
				});
				default: "";
			}
		}
	}
}

wigi3MembersNotation2text(elements : [WigiElement], notation : string) -> string {
	if (length(elements) == 3) {
		upperLimit = wigi2text(elements[0]);
		lowerLimit = wigi2text(elements[1]);
		typicalElement = wigi2text(elements[2]);
		formatString(_(" the %4 of %1 from %2 to %3 "), [typicalElement, lowerLimit, upperLimit, notation])
	} else formatString("Wigi %1 conversion error", [notation])
}

wigi2MembersNotation2text(elements : [WigiElement], notation : string, error : string) -> string {
	if (length(elements) == 2) {
		m1 = wigi2text(elements[0]);
		m2 = wigi2text(elements[1]);
		m1 + notation + m2
	} else formatString("Wigi %1 conversion error", [error])
}

