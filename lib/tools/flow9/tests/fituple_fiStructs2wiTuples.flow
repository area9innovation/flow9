// Unions
FcBaseType ::= FcTypeVoid, FcTypeBool, FcTypeInt, FcTypeDouble, FcTypeString, FcTypeNative;
FcConst ::= FcVoid, FcDouble, FcInt, FcString, FcBool;
FcExp ::= FcCall, FcIf,  FcCast, FcSeq, FcCallPrim, FcConst, FcRequire;
FcPrim ::= FcOrPrim, FcAndPrim, FcNotPrim, FcEqPrim, FcNePrim, FcLePrim, FcGePrim, FcLtPrim, FcGtPrim, FcPlusPrim, FcMinusPrim, FcMulPrim, FcDivPrim, FcModPrim, FcNegPrim, FcArrayPrim, FcIndexPrim, FcDerefPrim, FcAssignPrim, FcRefPrim, FcStructPrim, FcFieldPrim, FcCreateClosurePrim, FcQuote, FcUnquote;
FcType ::= FcBaseType, FcTypeArray, FcTypeRef, FcTypeParameter, FcTypeFlow, FcTypeName, FcTypeUnion, FcTypeVar;
FiConst ::= FiVoid, FiDouble, FiString, FiBool;
FiExp ::= FiCall, FiVar, FiSwitch, FiCast, FiSeq, FiCallPrim, FiConst, FiRequire, FiUnsafe;
FiStructOrUnion ::= FiTypeStruct, FiTypeUnion;
FiToplevel ::= FiStructOrUnion;
FiType ::= FiTypeArray, FiTypeRef, FiTypeParameter, FiTypeBool, FiTypeInt, FiTypeDouble, FiTypeString, FiTypeFlow, FiTypeVoid, FiTypeNative, FiTypeName;
Maybe<?> ::= None, Some<?>;
Tree<?, ??> ::= TreeNode<?, ??>, TreeEmpty;

// Structs
FcAndPrim();
FcArrayPrim();
FcAssignPrim();
FcBool(b : bool, info : FcInfo);
FcCall(f : FcExp, args : [FcExp], info : FcInfo);
FcCallPrim(op : FcPrim, es : [FcExp], info : FcInfo);
FcCase(struct : string, argNames : [string], body : FcExp, info : FcInfo);
FcCast(e : FcExp, tFrom : FcType, tTo : FcType, info : FcInfo);
FcCreateClosurePrim(structName : string, functionName : string);
FcDerefPrim();
FcDivPrim();
FcDouble(d : double, info : FcInfo);
FcEqPrim();
FcFieldPrim(name1 : string);
FcGePrim();
FcGtPrim();
FcIf(e1 : FcExp, e2 : FcExp, e3 : FcExp, info : FcInfo);
FcIndexPrim();
FcInfo(type : ref Maybe<FcType>, start : int, end : int);
FcInfo2(start : int, end : int);
FcInt(i : int, info : FcInfo);
FcLePrim();
FcLtPrim();
FcMinusPrim();
FcModPrim();
FcMulPrim();
FcNePrim();
FcNegPrim();
FcNotPrim();
FcOrPrim();
FcPlusPrim();
FcQuote();
FcRefPrim();
FcRequire(flowfile : string, e : FcExp, info : FcInfo);
FcSeq(es : [FcExp], info : FcInfo);
FcString(s : string, info : FcInfo);
FcStructPrim(struct_name : string);
FcTypeArray(t : FcType, info : FcInfo2);
FcTypeBool(info : FcInfo2);
FcTypeDouble(info : FcInfo2);
FcTypeFlow(info : FcInfo2);
FcTypeInt(info : FcInfo2);
FcTypeName(name1 : string, typeparameters : [FcType], info : FcInfo2);
FcTypeNative(info : FcInfo2);
FcTypeParameter(n : string, info : FcInfo2);
FcTypeRef(t : FcType, info : FcInfo2);
FcTypeString(info : FcInfo2);
FcTypeUnion(name : string, typeparameters : [FcType], typenames : [FcTypeName], info : FcInfo2);
FcTypeVar(id : int, info : FcInfo2);
FcTypeVoid(info : FcInfo2);
FcUnquote();
FcVoid(info : FcInfo);
FiBool(b : bool, start : int);
FiCall(f : FiExp, args : [FiExp], type : FiType, start : int);
FiCallPrim(op : FcPrim, es : [FiExp], type : FiType, start : int);
FiCase(struct : string, argNames : [string], body : FiExp, start : int);
FiCast(e : FiExp, tFrom : FiType, tTo : FiType, type : FiType, start : int);
FiDouble(d : double, start : int);
FiRequire(flowfile : string, e : FiExp, type : FiType, start : int);
FiSeq(es : [FiExp], type : FiType, start : int);
FiString(s : string, start : int);
FiStructArg(name : string, type : FiType, ismutable : bool);
FiSwitch(x : FiVar, switchType : FiType, cases : [FiCase], type : FiType, start : int);
FiTypeArray(t : FiType);
FiTypeBool();
FiTypeDouble();
FiTypeFlow();
FiTypeInt();
FiTypeName(name1 : string, typeparameters : [FiType]);
FiTypeNative();
FiTypeParameter(n : string);
FiTypeRef(t : FiType);
FiTypeString();
FiTypeStruct(name : string, typars : [FiType], args : [FiStructArg], start : int);
FiTypeUnion(name : string, typeparameters : [FiType], typenames : [FiTypeName], start : int);
FiTypeVoid();
FiUnsafe(name1 : string, fallback : FiExp, type : FiType, start : int);
FiVar(name1 : string, type : FiType, start : int);
FiVoid(start : int);
HashMapImpl(data : ref [ref Tree<?, ??>], hash : (?) -> int, size : ref int, loadFactor : double);
None();
ParsingAcc(data : ?, start : int, finish : int, processed : int);
Some(value : ?);
StructTuple(link : Tree<string, StructTupleArgs>);
StructTupleArg(index : int, type : FiType);
StructTupleArgs(typeParameters : [FiType], args : Tree<string, StructTupleArg>);
TreeEmpty();
TreeNode(key : ?, value : ??, left : Tree<?, ??>, right : Tree<?, ??>, depth : int);
WiseAstStructs(data : StructTuple, table : Tree<string, int>);

values2treeEx(a0:[?], a1:(?) -> ??) -> void {}

fiStructs2wiTuples(unions : [FiTypeUnion]) -> void {
	values2treeEx(unions, \v -> v.name);
}
