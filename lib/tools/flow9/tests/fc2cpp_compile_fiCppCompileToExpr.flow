// Unions
BcDebugKind ::= DebugPosExpr, DebugPosCall, DebugPosStruct, DebugPosFunction, DebugPosFunctionLocals, DebugPosFunctionEnd;
BytecodeTypeCode ::= TCFlow, TCVoid, TCBool, TCInt, TCDouble, TCString, TCArray, TCStruct, TCRefTo, TCTypedArray, TCTypedStruct, TCTypedRefTo, TCSetMutable;
DNode<?> ::= DEnd, DLink<?>;
FcArgType ::= FcStructArg, FcFunArg;
FcBackendConfig ::= FiJsConfig, FiNimConfig, FcRustConfig, FiJavaConfig, FcBytecodeConfig, FiHTMLConfig, FcProtobufConfig, FcSpeedyConfig, FcLISPConfig, FcCppConfig, FcCpp2Config, FiDConfig, FcMLConfig, FiDocConfig, FiWasmConfig, FcIncaConfig, FcFlowConfig, FiTsdConfig, FiWiseConfig, FiCpp3Config;
FcBaseType ::= FcTypeVoid, FcTypeBool, FcTypeInt, FcTypeDouble, FcTypeString, FcTypeNative;
FcCommonConfig ::= FcBackendConfig, CompilerConfig;
FcConst ::= FcVoid, FcDouble, FcInt, FcString, FcBool;
FcDeclaration ::= FcFunctionDec, FcGlobalVar, FcNativeDec;
FcExp ::= FcLambda, FcCall, FcVar, FcLet, FcIf, FcSwitch, FcCast, FcSeq, FcCallPrim, FcConst, FcRequire, FcUnsafe;
FcPreloadedModule ::= FcParsed, FcLoaded;
FcPrim ::= FcOrPrim, FcAndPrim, FcNotPrim, FcEqPrim, FcNePrim, FcLePrim, FcGePrim, FcLtPrim, FcGtPrim, FcPlusPrim, FcMinusPrim, FcMulPrim, FcDivPrim, FcModPrim, FcNegPrim, FcArrayPrim, FcIndexPrim, FcDerefPrim, FcAssignPrim, FcRefPrim, FcStructPrim, FcFieldPrim, FcSetMutablePrim, FcCreateClosurePrim, FcQuote, FcUnquote;
FcType ::= FcBaseType, FcTypeArray, FcTypeFunction, FcTypeRef, FcTypeParameter, FcTypeFlow, FcTypeName, FcTypeStruct, FcTypeUnion, FcTypeVar;
FcTypeCheck ::= FcExpectOneOf, FcCheckStructs, FcCheckMutable, FcNotVoid, FcNotFunction;
FcTypeExpect ::= FcLessOrEqual, FcExpectField, FcVerifyType, FcSetMutableField;
FiConst ::= FiVoid, FiDouble, FiInt, FiString, FiBool;
FiDeclaration ::= FiFunctionDec, FiGlobalVar, FiNativeDec;
FiExp ::= FiLambda, FiCall, FiVar, FiLet, FiIf, FiSwitch, FiCast, FiSeq, FiCallPrim, FiConst, FiRequire, FiUnsafe;
FiExportSignature ::= FiTypeStruct, FiTypeUnion, FiType, FiExportNative;
FiNamed ::= FiDeclaration, FiStructOrUnion;
FiStructOrUnion ::= FiTypeStruct, FiTypeUnion;
FiToplevel ::= FiDeclaration, FiStructOrUnion;
FiType ::= FiTypeArray, FiTypeFunction, FiTypeRef, FiTypeParameter, FiTypeBool, FiTypeInt, FiTypeDouble, FiTypeString, FiTypeFlow, FiTypeVoid, FiTypeNative, FiTypeName;
List<?> ::= EmptyList, Cons<?>;
Maybe<?> ::= None, Some<?>;
Tree<?, ??> ::= TreeNode<?, ??>, TreeEmpty;

// Structs
BCDFunction(pc : int, name : string);
BCDLocal(pc : int, type : int, id : int, name : string);
BCDPosition(pc : int, pos : int, comment : BcDebugKind);
BCDebugInfo(functions : ref List<BCDFunction>, locals : ref List<BCDLocal>, positions : ref List<string>, currentPositions : ref List<BCDPosition>, endByte : ref int);
BCIFunction(name : string);
CDebugInfo(name : string);
CFieldName(name : string);
CNativeFn(name : string, args : int);
COptionalNativeFn(name : string, args : int);
CReserveLocals(locals : int, args : int);
CSetMutableName(name : string);
CStructDef(index : int, name : string, args : [Pair<string, BytecodeTypeCode>]);
CompilerConfig(flowfile : string, includes : [string], objectFolders : [string], verbose : int, jsParams : JSCliParams, config : Tree<string, string>, threadId : int);
ConcurHashMap(map : native, dummy : [Pair<?, ??>]);
Cons(head : ?, tail : List<?>);
DEnd();
DLink(v : ?, before : DNode<?>, after : DNode<?>, attached : bool);
DList(first : DNode<?>, last : DNode<?>);
DebugPosCall();
DebugPosExpr();
DebugPosFunction(name : string, isNative : bool);
DebugPosFunctionEnd(isNative : bool);
DebugPosFunctionLocals(isNative : bool);
DebugPosStruct();
DependencyTracker(dependsUpon : Tree<?, Set<?>>, fileRequires : Tree<?, Set<?>>, nonDependent : Set<?>);
EasyGraph(nodes : Tree<int, GNode<?>>, edges : Tree<int, [GEdge<??>]>, numberOfEdges : int);
EmptyList();
FcAndPrim();
FcArrayPrim();
FcAssignPrim();
FcBool(b : bool, info : FcInfo);
FcBytecodeConfig(flowfile : string, outputfile : string, upload : bool, includes : [string], debug : bool, verbose : int, threadId : int, debugInfo : BCDebugInfo, nargs : bool, debugVerbose : bool);
FcCacheModule(loaded : FcLoaded, outdated : bool);
FcCacheNamed(named : FiNamed, module : string, exported : bool);
FcCachedSource(text : string, modified : double, resolver : Maybe<LineResolver>);
FcCall(f : FcExp, args : [FcExp], info : FcInfo);
FcCallPrim(op : FcPrim, es : [FcExp], info : FcInfo);
FcCase(struct : string, argNames : [string], body : FcExp, info : FcInfo);
FcCast(e : FcExp, tFrom : FcType, tTo : FcType, info : FcInfo);
FcCheckMutable(field : string, type : FcType, info : FcInfo2);
FcCheckStructs(names : [string], open : bool, t : FcType, info : FcInfo2);
FcCpp2Config(flowfile : string, outputFile : string, outputDir : string, generateDir : string, buildExe : bool, includes : [string], debug : bool, verbose : int, threadId : int, extStructDefs : bool, entry : string, useGui : bool);
FcCppConfig(flowfile : string, outputfile : string, includes : [string], debug : bool, verbose : int, threadId : int, fileinfo : FiFileInfo, structIndexes : Tree<string, int>);
FcCreateClosurePrim(structName : string, functionName : string);
FcDerefPrim();
FcDivPrim();
FcDouble(d : double, info : FcInfo);
FcEqPrim();
FcError(message : string, positions : [FcPosition]);
FcExpectField(field : string, fieldType : FcType, t : FcType, info : FcInfo2, e : FcExp);
FcExpectOneOf(types : [FcBaseType], type : FcType, info : FcInfo2);
FcFieldPrim(name : string);
FcFileInfo(flowfile : string, trampstamp : double, fullpath : string, md5sum : string, content : string, gensymid : int, filesize : double);
FcFlowConfig(flowfile : string, outputdir : string, includes : [string], verbose : int, threadId : int);
FcForbid(flowfile : string, start : int, end : int);
FcFunArg(name : string, type : FcType);
FcFunArg2(name : string, type : Maybe<FcType>);
FcFunctionDec(name : string, lambda : Maybe<FcLambda>, declType : FcTypeFunction2, declInfo : FcInfo, defiInfo : FcInfo);
FcGePrim();
FcGlobalNames(struct2module : Tree<string, string>, union2module : Tree<string, string>, function2module : Tree<string, string>, globalVar2module : Tree<string, string>, native2module : Tree<string, string>, structs : Tree<string, FcTypeStruct>, unions : Tree<string, FcTypeUnion>, struct2unions : Tree<string, [string]>, field2structs : Tree<string, [string]>, toplevel : Tree<string, FcDeclaration>, structTypars : Tree<string, int>, moduleImports : Tree<string, Set<string>>);
FcGlobalVar(name : string, value : Maybe<FcExp>, declInfo : FcInfo, bodyInfo : FcInfo);
FcGtPrim();
FcIf(e1 : FcExp, e2 : FcExp, e3 : FcExp, info : FcInfo);
FcImport(flowfile : string, dynamic : bool, start : int, end : int);
FcIncaConfig(flowfile : string, outputdir : string, includes : [string], verbose : int, threadId : int);
FcIndexPrim();
FcInfo(type : ref Maybe<FcType>, start : int, end : int);
FcInfo2(start : int, end : int);
FcInt(i : int, info : FcInfo);
FcLISPConfig(flowfile : string, outputfile : string, includes : [string], debug : bool, verbose : int, threadId : int, fileinfo : FiFileInfo, initVars : string, structNames : Tree<string, int>, structFields : Tree<string, string>);
FcLambda(args : [FcFunArg], body : FcExp, info : FcInfo);
FcLePrim();
FcLessOrEqual(output : FcType, input : FcType, description : string, info : FcInfo2, e : FcExp);
FcLet(name : string, type : FcType, e1 : FcExp, e2 : FcExp, info : FcInfo);
FcLoaded(module : FiModule, dependencyChanged : () -> bool);
FcLtPrim();
FcMLConfig(flowfile : string, outputfile : string, includes : [string], debug : bool, verbose : int, threadId : int, structNames : Tree<string, int>, fileinfo : FiFileInfo, combinedUnions : Tree<string, FiTypeUnion>);
FcMinusPrim();
FcModPrim();
FcModule(fileinfo : FcFileInfo, imports : [FcImport], forbids : [FcForbid], exports : Set<string>, structs : Tree<string, FcTypeStruct>, unions : Tree<string, FcTypeUnion>, functions : Tree<string, FcFunctionDec>, globalVars : Tree<string, FcGlobalVar>, natives : Tree<string, FcNativeDec>, initOrder : [string], stringIncludes : [FiFileInfo], errors : [FcError], typevarid : int, isCached : bool, start : int, end : int, allImports : Set<string>);
FcMulPrim();
FcNativeDec(name : string, io : bool, type : FcType, nativeName : string, flowfallback : Maybe<FcFunctionDec>, info : FcInfo);
FcNePrim();
FcNegPrim();
FcNotFunction(t : FcType, info : FcInfo2);
FcNotPrim();
FcNotVoid(t : FcType, info : FcInfo2);
FcOrPrim();
FcParsed(fileinfo : FcFileInfo, syntaxtree : SyntaxTree, imports : [FcImport], forbids : [FcForbid], oldExports : Tree<string, FiExportSignature>);
FcPlusPrim();
FcPosition(file : string, start : int, end : int);
FcProtobufConfig(flowfile : string, outputfile : string, types : [string], verbose : int, threadId : int);
FcQuote();
FcRefPrim();
FcRequire(flowfile : string, e : FcExp, info : FcInfo);
FcRustConfig(flowfile : string, outputfile : string, includes : [string], debug : bool, verbose : int, threadId : int);
FcSeq(es : [FcExp], info : FcInfo);
FcSetMutableField(struct : FcType, field : string, ftype : FcType, info : FcInfo2);
FcSetMutablePrim(name : string);
FcSpeedyConfig(flowfile : string, outputfile : string, types : [string], verbose : int, threadId : int);
FcString(s : string, info : FcInfo);
FcStructArg(name : string, type : FcType, ismutable : bool);
FcStructPrim(struct_name : string);
FcSwitch(x : FcVar, switchType : FcType, cases : [FcCase], info : FcInfo);
FcTypeArray(t : FcType, info : FcInfo2);
FcTypeBool(info : FcInfo2);
FcTypeDouble(info : FcInfo2);
FcTypeEnv(global : FcTypeEnvGlobal, program : FcTypeEnvProgram, local : FcTypeEnvLocal);
FcTypeEnvGlobal(moduleCache : ConcurHashMap<string, Maybe<FcCacheModule>>, nameCache : ConcurHashMap<string, Maybe<FcCacheNamed>>, sourceCache : ConcurHashMap<string, FcCachedSource>);
FcTypeEnvLocal(expects : ref List<FcTypeExpect>, checks : ref List<FcTypeCheck>, tyvars : ref Tree<int, FcType>, typars : ref Tree<string, FcTypeVar>, varinfo : Tree<string, FcInfo>, debugExpects : ref Set<FcTypeExpect>, debugTyping : ref int, debugIndentation : ref string);
FcTypeEnvProgram(acc : FlowcAcc, types : Tree<string, FcType>, printError : (FcError) -> void, errors : ref int, union2typenamesCache : ConcurHashMap<string, [FcTypeName]>, subtypeGraph : GSubtypeGraph);
FcTypeFlow(info : FcInfo2);
FcTypeFunction(args : [FcFunArg], returnType : FcType, info : FcInfo2);
FcTypeFunction2(args : [FcFunArg2], returnType : Maybe<FcType>, info : FcInfo2);
FcTypeInt(info : FcInfo2);
FcTypeName(name : string, typeparameters : [FcType], info : FcInfo2);
FcTypeNative(info : FcInfo2);
FcTypeParameter(n : string, info : FcInfo2);
FcTypeRef(t : FcType, info : FcInfo2);
FcTypeString(info : FcInfo2);
FcTypeStruct(name : string, typars : [FcType], args : [FcStructArg], info : FcInfo2);
FcTypeUnion(name : string, typeparameters : [FcType], typenames : [FcTypeName], info : FcInfo2);
FcTypeVar(id : int, info : FcInfo2);
FcTypeVoid(info : FcInfo2);
FcUnquote();
FcUnsafe(name : string, fallback : FcExp, info : FcInfo);
FcVar(name : string, info : FcInfo);
FcVerifyType(type : FcType, declared : FcType, description : string, info : FcInfo2, e : FcExp);
FcVoid(info : FcInfo);
FiBool(b : bool, start : int);
FiCall(f : FiExp, args : [FiExp], type : FiType, start : int);
FiCallPrim(op : FcPrim, es : [FiExp], type : FiType, start : int);
FiCase(struct : string, argNames : [string], body : FiExp, start : int);
FiCast(e : FiExp, tFrom : FiType, tTo : FiType, type : FiType, start : int);
FiCpp3Config(outputfile : string, outputdir : string, backendDirs : [string], qtOpts : [string], debug : bool, config : CompilerConfig, verbose : int, threadId : int);
FiCppCompileContext(cfg : FcCppConfig, program : FiProgram, strings : Tree<string, int>, currentFunction : string, lastVarRefs : Set<FiVar>);
FiDConfig(flowfile : string, outputfile : string, includes : [string], debug : bool, verbose : int, threadId : int, fileinfo : FiFileInfo, initVars : string);
FiDocConfig(flowfile : string, outputfolder : string, verbose : int, threadId : int);
FiDouble(d : double, start : int);
FiExpTraverseEnv(parents : List<Pair<FiExp, int>>, locals : Tree<string, FiVar>, args : Tree<string, FiVar>, lets : Tree<string, FiLet>, returns : bool);
FiExportNative(io : bool, type : FiType, nativeName : string);
FiFileInfo(flowfile : string, trampstamp : double, fullpath : string, md5sum : string, filesize : double, lastupdate : double);
FiForbid(flowfile : string, start : int);
FiFunArg(name : string, type : FiType);
FiFunctionDec(name : string, lambda : FiLambda, type : FiTypeFunction, declStart : int, defiStart : int);
FiGlobalNames(struct2module : Tree<string, string>, union2module : Tree<string, string>, function2module : Tree<string, string>, globalVar2module : Tree<string, string>, native2module : Tree<string, string>, structs : Tree<string, FiTypeStruct>, unions : Tree<string, FiTypeUnion>, toplevel : Tree<string, FiDeclaration>);
FiGlobalVar(name : string, value : FiExp, type : FiType, declStart : int, defiStart : int);
FiHTMLConfig(flowfile : string, outputfile : string, includes : [string], jsfile : string, verbose : int, threadId : int, debug : bool, title : string, splash : string, minify : bool, scripts : [string], additionalScripts : [string], predefinedParams : [Pair<string, string>], workingDir : string, manifestFileName : string, noTranslate : bool);
FiIf(e1 : FiExp, e2 : FiExp, e3 : FiExp, type : FiType, start : int);
FiImport(flowfile : string, dynamic : bool, start : int);
FiInt(i : int, start : int);
FiJavaConfig(flowfile : string, outputdir : string, generatedir : string, packageName : string, mainClassName : string, jarfile : string, javaLibrary : Set<string>, includes : [string], debug : bool, verbose : int, threadId : int, dependencies : [string], externNatives : [string], builder : string, builderXmX : string, hostSubstitutions : Tree<string, string>, options : Tree<string, string>);
FiJsConfig(flowfile : string, outputfile : string, includes : [string], jsmode : int, webmodule : bool, jslibrary : Set<string>, jslibraryObject : string, modules : string, comments : bool, code : bool, beautify : bool, sourcemap : bool, compress : bool, haxeRuntime : bool, fontconfig : string, debug : bool, verbose : int, threadId : int, readable : bool, tsProcess : TypeScriptProcessing, callMain : bool, keepDebugNewlines : bool, externLib : string, externNatives : Set<string>, dependencies : [FiJsDependency]);
FiJsDependency(provider : string, host : string, package : string);
FiLambda(args : [FiFunArg], body : FiExp, type : FiTypeFunction, start : int);
FiLet(name : string, type : FiType, e1 : FiExp, e2 : FiExp, type2 : FiType, start : int);
FiModule(fileinfo : FiFileInfo, imports : [FiImport], forbids : [FiForbid], exports : [string], structs : [FiTypeStruct], unions : [FiTypeUnion], functions : [FiFunctionDec], globalVars : [FiGlobalVar], natives : [FiNativeDec], initOrder : [string], stringIncludes : [FiFileInfo], start : int, end : int, allImports : Set<string>, incremental : bool);
FiNativeDec(name : string, io : bool, type : FiType, nativeName : string, fallbackLambda : FiExp, declStart : int, defiStart : int);
FiNimConfig(flowfile : string, outputfile : string, includes : [string], backendDirs : [string], debug : bool, verbose : int, threadId : int, options : Tree<string, string>);
FiProgram(config : CompilerConfig, modules : Tree<string, FiModule>, traversal : [string], names : FiGlobalNames);
FiRequire(flowfile : string, e : FiExp, type : FiType, start : int);
FiSeq(es : [FiExp], type : FiType, start : int);
FiString(s : string, start : int);
FiStructArg(name : string, type : FiType, ismutable : bool);
FiSwitch(x : FiVar, switchType : FiType, cases : [FiCase], type : FiType, start : int);
FiTsdConfig(flowfile : string, jslibrary : Set<string>, jslibraryObject : string, outputfolder : string, verbose : int, threadId : int);
FiTypeArray(t : FiType);
FiTypeBool();
FiTypeDouble();
FiTypeFlow();
FiTypeFunction(args : [FiFunArg], returnType : FiType);
FiTypeInt();
FiTypeName(name : string, typeparameters : [FiType]);
FiTypeNative();
FiTypeParameter(n : string);
FiTypeRef(t : FiType);
FiTypeString();
FiTypeStruct(name : string, typars : [FiType], args : [FiStructArg], start : int);
FiTypeUnion(name : string, typeparameters : [FiType], typenames : [FiTypeName], start : int);
FiTypeVoid();
FiUnsafe(name : string, fallback : FiExp, type : FiType, start : int);
FiVar(name : string, type : FiType, start : int);
FiVoid(start : int);
FiWasmConfig(flowfile : string, outputfile : string, includes : [string], verbose : int, threadId : int, hostfile : string, nodejs : bool, listingFile : string, wasmast : string, memory : int, doinline : bool);
FiWiseConfig(flowfile : string, outputfolder : string, includes : [string], verbose : int, threadId : int);
FlowcAcc(dependency : DependencyTracker<string>, preloaded : Tree<string, FcPreloadedModule>, modules : Tree<string, FiModule>, file2flowfile : Tree<string, string>, traversal : [string], names : FcGlobalNames, config : CompilerConfig, tyvarIdFactory : IdFactory, tyvarIdGroup : IdGroup, tracer : Tracer);
GEdge(from : int, to : int, data : ?, weight : int);
GNode(id : int, data : ?);
GSubtypeGraph(supertypes : SimpleGraph<string, bool>, fieldSupertypes : SimpleGraph<string, bool>, subtypes : SimpleGraph<string, bool>);
IdFactory(id : ref int, bucketsize : int);
IdGroup(id : ref int, lastid : ref int, factory : IdFactory);
JSCliParams(jsfile : string, esfile : string, typescriptFile : string, debug : bool, code : bool, modules : string, comments : bool, node : bool, webmodule : bool, isES6 : bool, isTypeScript : bool, tsProcess : TypeScriptProcessing, readable : bool, beautify : bool, sourcemap : bool, verbose : int, nwjs : bool, fontconfig : string, dcePreservedNames : Set<string>, dceRemoveMain : bool, jslibraryObject : string, callMain : bool);
LineResolver(input : string, linestarts : [int]);
None();
Pair(first : ?, second : ??);
Quadruple(first : ?, second : ??, third : ???, fourth : ????);
Set(tree : Tree<?, bool>);
SimpleGraph(nodes : Tree<?, int>, nnodes : int, graph : EasyGraph<?, ??>);
Some(value : ?);
SyntaxTree(rule : int, choice : int, start : int, end : int, children : [[SyntaxTree]]);
TCArray();
TCBool();
TCDouble();
TCFlow();
TCInt();
TCRefTo();
TCSetMutable(arg : BytecodeTypeCode);
TCString();
TCStruct();
TCTypedArray(arg : BytecodeTypeCode);
TCTypedRefTo(arg : BytecodeTypeCode);
TCTypedStruct(arg : string);
TCVoid();
TraceEntry(name : string, category : string, phase : string, tid : int, time : double);
Tracer(startTime : double, lines : List<TraceEntry>);
TreeEmpty();
TreeNode(key : ?, value : ??, left : Tree<?, ??>, right : Tree<?, ??>, depth : int);
Triple(first : ?, second : ??, third : ???);
TypeScriptProcessing(typeBuffer : string, voidReturn : bool, antiTS : bool);

fiCppLambdaRetType(a2:FiType) -> string{""};

fiCppCompileToExpr(
	expr0 : FiExp, 
) -> string {
	switch (expr0 : FiExp) {
		FiLambda(xs, e0, type, __): {
			rettype = {
					switch (type) {
						FiTypeFunction(__, rettype): fiCppLambdaRetType(rettype);
						default: "TODO";
					}
			}
			"" + rettype
		}
		default: "";
	}
}

