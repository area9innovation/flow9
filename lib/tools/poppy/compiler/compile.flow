import tools/poppy/poppy_types;
import tools/poppy/pretty;
import tools/poppy/utils;
import string_utils;
import tools/runcore/core_lib;
import tools/runcore/core_compile;

// TODO: Separate defines from toplevel
export {
	compilePoppy2file(runCore : RunCore, op : Poppy) -> string;

	PCompileEnv(
		runcore : RunCore,
		toplevel : bool,
		functions : ref string,
		nextIdCnt : ref int,
	);
	compilePoppy(env : PCompileEnv, op : Poppy) -> string;
	isPoppyValue(p : Poppy) -> bool;
	compilePoppy2Value(p : Poppy) -> string;
}

compilePoppy2file(runCore : RunCore, op : Poppy) -> string {
	env = PCompileEnv(runCore, true, ref "", ref 0);
	code = compilePoppy(env, op);
	"// Generated by Poppy compiler\nimport tools/poppy/penv;\n" 
	+ ^(env.functions) + "\n"
	+ blueprint("
		main() -> void {
			env = PEnv(ref makeList());
			%code%;
			quit(0);
		}
		", ["code", code]
	);
}

compilePoppy(env : PCompileEnv, op : Poppy) -> string {
	todo = \ -> {
		println("TODO: Poppy Compile " + op.structname + ":" + prettyPoppy(op));
		"// TODO " + op.structname;
	}
	res = switch (op) {
		PoppyCons(): "pcons(env)";
		PoppyDrop(): "pdrop(env)";
		PoppyDump(): "pdebug(env)";
		PoppyDup(): "pdup(env)";
		PoppyEval(): "peval(env)";
		PoppyIfte(): "pifte(env)";
		PoppyNil(): "pushPEnv(env, makeList())";
		PoppyPrint(): {
			"{ val = popPEnv(env); println(val); pushPEnv(env, val); }"
		}
		PoppySet(word): todo();
		PoppySwap(): "pswap(env)";
		PoppyWhile(): todo();
		PoppyNop(): "";
		PoppyConstructArity(uid, int1): {
			"pconstruct" + i2s(int1) + "(env, " + toString(uid) + ")";
		}
		PoppyDefine(word, poppy): {
			if (isCoreDefined(env.runcore, word)) {
				println("ERROR: Can not redefine runcore fn " + word);
			}
			id = manglePoppyName(word);
			body = compilePoppy(PCompileEnv(env with toplevel = false), poppy);
			env.functions := ^(env.functions) + blueprint("
				%id%(env : PEnv) -> void {
					%body%
				}
				", [
					"id", id,
					"body", body
				]
			);
			"";
		}
		PoppyMakeList(poppy): {
			body = compilePoppy(env, poppy);
			if (body == "") {
				"pushPEnv(env, [])";
			} else if (false && isPoppyValue(poppy)) {
				// This is a pure value
				if (true) {
					seq = poppySeq2Array([], poppy);
					vals = superglue(seq, \p -> compilePoppy2Value(p), ", ");
					"pushPEnv(env, [" + vals + "])";
				} else {
					println("TODO: We should be able to compile this statically");
					top = "top" + i2s(^(env.nextIdCnt));
					env.nextIdCnt := ^(env.nextIdCnt) + 1;
					blueprint("
					{
						%top% = ^(env.stack);
						%code%;
						pushPArray(env, %top%);
					}",
						[
							"top", top,
							"code", body
						]
					)
				}
			} else {
				// OK, this is quoted code. Make a function
				quote = "quote" + i2s(^(env.nextIdCnt));
				env.nextIdCnt := ^(env.nextIdCnt) + 1;
				env.functions := ^(env.functions) + blueprint("
					%quote%(env : PEnv) -> void {
						%body%
					}
					", [
						"quote", quote,
						"body", body,
					]
				);
				"pushPEnv(env, " + quote + ")";
			}
		}
		PoppySequence(poppy1, poppy2): {
			superglue([poppy1, poppy2], \poppy -> compilePoppy(env, poppy), ";\n");
		}
		PoppyBool(bool1): "pushPEnv(env, " + b2s(bool1) + ")";
		PoppyDouble(double1): "pushPEnv(env, " + d2s(double1) + ")"; // TODO: Check if 2.0
		PoppyInt(int1): "pushPEnv(env, " + i2s(int1) + ")";
		PoppyString(string1): "pushPEnv(env, " + toString(string1) + ")";
		PoppyConstructor(uid, args): "pushPEnv(env, " + prettyPoppy(op) + ")";
		PoppyWord(word): {
			if (isCoreDefined(env.runcore, word)) {
				core = compileCoreFn(env.runcore, word);
				arity = getCoreArity(env.runcore, word);
				"pfn" + i2s(arity) + "(env, " + core + ")";
			} else {
				manglePoppyName(word) + "(env)";
			}
		}
	}
	// println(op.structname + " -> " + res);
	res;
}

manglePoppyName(id : string) -> string {
	if (id == "==") "pequal"
	else if (id == "+") "padd"
	else if (id == "-") "psub"
	else if (id == "*") "pmul"
	else if (id == "/") "pdiv"
	else if (id == "println") "pprintln"
	else if (id == "!") "pnot"
	else {
		name = stringFoldChar(id, "", \acc, ch -> {
			if (isValidIdentifier(ch)) acc + ch
			else acc + "c" + i2s(getCharCodeAt(ch, 0)) // + "/*" + id + "*/"
		});
		if (contains(["bool", "int", "double", "string", "ref"], name)) name + "_" else name
	}
}

compilePoppy2Value(p : Poppy) -> string {
	switch (p) {
		PoppyNop(): "";
		PoppyBool(bool1): b2s(bool1);
		PoppyDouble(double1): d2s(double1);
		PoppyInt(int1): i2s(int1);
		PoppyString(string1): toString(string1);
		PoppyConstructor(uid, args): uid + "(" + superglue(args, compilePoppy2Value, ",") + ")";
		default: "";
	}
}

isPoppyValue(p : Poppy) -> bool {
	switch (p) {
		PoppyCons(): false;
		PoppyDrop(): false;
		PoppyDump(): false;
		PoppyDup(): false;
		PoppyEval(): false;
		PoppyIfte(): false;
		PoppyNil(): false;
		PoppyPrint(): false;
		PoppySet(word): false;
		PoppySwap(): false;
		PoppyWhile(): false;
		PoppyNop(): true;
		PoppyConstructArity(uid, int1): false;
		PoppyDefine(word, poppy): false;
		PoppyMakeList(poppy): false;
		PoppySequence(poppy1, poppy2): isPoppyValue(poppy1) && isPoppyValue(poppy2);
		PoppyBool(bool1): true;
		PoppyDouble(double1): true;
		PoppyInt(int1): true;
		PoppyString(string1): true;
		PoppyConstructor(uid, args): forall(args, isPoppyValue);
		PoppyWord(word): false;
	}
}

