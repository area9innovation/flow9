import ds/list;
import runtime;
import text/deserialize_string;
import math/math;

export {
	PEnv(
		stack : ref List<flow>,
	);

	pdebug(env : PEnv) -> void;
	pushPEnv(env : PEnv, value : flow) -> void;
	popPEnv(env : PEnv) -> flow;
	// Expect exactly one element on the stack
	getSinglePEnv(env : PEnv, def : flow) -> flow;
	pushPArray(env : PEnv, top : List<flow>) -> void;
	pprintln(env : PEnv) -> void;
	pifte(env : PEnv) -> void;
	peval(env : PEnv) -> void;
	pdrop(env : PEnv) -> void;
	pdup(env : PEnv) -> void;
	pswap(env : PEnv) -> void;
	pcons(env : PEnv) -> void;
	pfn1(env : PEnv, fn : (flow) -> flow) -> void;
	pfn2(env : PEnv, fn : (flow, flow) -> flow) -> void;
	pconstruct0(env : PEnv, id : string) -> void;
	pconstruct1(env : PEnv, id : string) -> void;
	pconstruct2(env : PEnv, id : string) -> void;
	pconstruct3(env : PEnv, id : string) -> void;
	pconstruct4(env : PEnv, id : string) -> void;
	pconstruct5(env : PEnv, id : string) -> void;
}

pdebug(env : PEnv) -> void {
	println("\nDump of Poppy stack:");
	iter(list2array(^(env.stack)), \p -> {
		println(p)
	});
}

pushPEnv(env : PEnv, value : flow) -> void {
	env.stack := Cons(value, ^(env.stack));
}

popPEnv(env : PEnv) -> flow {
	st = ^(env.stack);
	switch (st) {
		EmptyList(): {
			println("Error: Empty stack");
			0;
		}
		Cons(head, t): {
			env.stack := t;
			head;
		}
	}
}

getSinglePEnv(env : PEnv, def : flow) -> flow {
	st = ^(env.stack);
	switch (st) {
		EmptyList(): def;
		Cons(head, t): {
			if (t != EmptyList()) def
			else head
		}
	}
}

pushPArray(env : PEnv, top : List<flow>) -> void {
	pushPEnv(env, collectPArray(env, top, []));
}

collectPArray(env : PEnv, top : List<flow>, acc : [flow]) -> [flow] {
	if (^(env.stack) == top) acc
	else {
		el = popPEnv(env);
		collectPArray(env, top, arrayPush(acc, el));
	}
}

pprintln(env : PEnv) -> void {
	val = popPEnv(env);
	println(val);
}

pifte(env : PEnv) -> void {
	else_ = popPEnv(env);
	then_ = popPEnv(env);
	cond = popPEnv(env);
	if (cond) then_(env)
	else else_(env)
}

peval(env : PEnv) -> void {
	fn = popPEnv(env);
	fn(env);
}

pequal(env : PEnv) -> void {
	e1 = popPEnv(env);
	e2 = popPEnv(env);
	pushPEnv(env, e1 == e2)
}

pdrop(env : PEnv) -> void {
	st = ^(env.stack);
	switch (st) {
		EmptyList(): {}
		Cons(__, t): env.stack := t;
	}
}
pdup(env : PEnv) -> void {
	st = ^(env.stack);
	switch (st) {
		EmptyList(): {}
		Cons(h, __): env.stack := Cons(h, st);
	}
}
pswap(env : PEnv) -> void {
	e1 = popPEnv(env);
	e2 = popPEnv(env);
	pushPEnv(env, e1);
	pushPEnv(env, e2);
}

pconstruct0(env : PEnv, id : string) -> void {
	pushPEnv(env, makeStructValue(id, [], IllegalStruct()));
}

pconstruct1(env : PEnv, id : string) -> void {
	arg = popPEnv(env);
	pushPEnv(env, makeStructValue(id, [arg], IllegalStruct()));
}

pconstruct2(env : PEnv, id : string) -> void {
	arg2 = popPEnv(env);
	arg1 = popPEnv(env);
	pushPEnv(env, makeStructValue(id, [arg1, arg2], IllegalStruct()));
}

pconstruct3(env : PEnv, id : string) -> void {
	arg3 = popPEnv(env);
	arg2 = popPEnv(env);
	arg1 = popPEnv(env);
	pushPEnv(env, makeStructValue(id, [arg1, arg2, arg3], IllegalStruct()));
}

pconstruct4(env : PEnv, id : string) -> void {
	arg4 = popPEnv(env);
	arg3 = popPEnv(env);
	arg2 = popPEnv(env);
	arg1 = popPEnv(env);
	pushPEnv(env, makeStructValue(id, [arg1, arg2, arg3, arg4], IllegalStruct()));
}

pconstruct5(env : PEnv, id : string) -> void {
	arg5 = popPEnv(env);
	arg4 = popPEnv(env);
	arg3 = popPEnv(env);
	arg2 = popPEnv(env);
	arg1 = popPEnv(env);
	pushPEnv(env, makeStructValue(id, [arg1, arg2, arg3, arg4, arg5], IllegalStruct()));
}

pcons(env : PEnv) -> void {
	h = popPEnv(env);
	t = popPEnv(env);
	pushPEnv(env, Cons(h, t));
}

pfn1(env : PEnv, fn : (flow) -> flow) -> void {
	pushPEnv(env, fn(popPEnv(env)));
}

pfn2(env : PEnv, fn : (flow, flow) -> flow) -> void {
	e2 = popPEnv(env);
	e1 = popPEnv(env);
	pushPEnv(env, fn(e1, e2));
}
