import tools/orbit/sexpr/sexpr_types;
import tools/orbit/ograph;
import tools/orbit/orbit_simple_ograph;
import tools/orbit/sexpr/pretty_sexpr;
import tools/orbit/sexpr/sexp2ograph_sub;
import tools/orbit/sexpr/ograph2sexpr;
import tools/orbit/sexpr/env;
import ds/tree;
import ds/array;
import string;

export {
    // Traverse an OGraph node and evaluate expressions that can be evaluated
    // Similar to quasiquotation in Scheme but operating on the OGraph structure
    // Returns the node ID of the resulting expression after evaluation
    evaluateOGraphQuasiquote(
        graphName : string,   // Name of the OGraph to operate on
        nodeId : int,        // ID of the node to start traversal from
        environment : SExpEnv,     // Environment for evaluation (SExpEnv with runtime functions)
        evaluator : (env : SExpEnv, expr : Sexpr) -> SExpEnv, // Function to use for evaluation
        tracing : bool       // Whether to enable detailed tracing
    ) -> Pair<SExpEnv, int>; // Returns updated environment and resulting node ID
}

//---------- Helper Functions for Node Manipulation and Analysis ----------//

// 1. Consistent Special Form Handling - Check if a node is a specific kind of special form
isSpecialFormNode(graph : OGraph, nodeId : int, formName : string) -> bool {
    switch (lookupOClass(graph, nodeId)) {
        Some(oclass): {
            node = oclass.node;
            if (node.op == "SpecialForm" && length(node.children) > 0) {
                firstChildId = node.children[0];
                switch (lookupOClass(graph, firstChildId)) {
                    Some(childClass): {
                        childNode = childClass.node;
                        if (childNode.op == "Special") {
                            specialName = getNodeStringValue(childNode, "");
                            specialName == formName;
                        } else false;
                    }
                    None(): false;
                }
            } else false;
        }
        None(): false;
    }
}

// 2. Enhanced Constant Value Detection - Check if a node represents a constant value
// Now also considers Lists and Vectors with all constant children as constants
isConstantNode(graph : OGraph, nodeId : int) -> bool {
    switch (lookupOClass(graph, nodeId)) {
        Some(oclass): {
            node = oclass.node;
            // Direct constants
            primitiveTypes = ["Int", "Double", "Bool", "String"];
            if (contains(primitiveTypes, node.op)) {
                true;
            } else if (node.op == "List" || node.op == "Vector") {
                // Check if all children are constants
                forall(node.children, \childId -> isConstantNode(graph, childId));
            } else {
                false;
            }
        }
        None(): false;
    }
}

// Helper for isFunctionCallNode - Get callable name if node represents a callable entity
getCallableName(graph : OGraph, nodeId : int, env : SExpEnv) -> Pair<bool, Maybe<string>> {
    switch (lookupOClass(graph, nodeId)) {
        Some(childClass): {
            childNode = childClass.node;
            if (childNode.op == "Operator") {
                opName = getNodeStringValue(childNode, "");
                if (opName != "" && containsKeyTree(env.runtime, opName)) {
                    Pair(true, Some(opName));
                } else {
                    Pair(false, None());
                }
            } else if (childNode.op == "Identifier") {
                fnName = getNodeStringValue(childNode, "");
                if (fnName != "" && containsKeyTree(env.env, fnName)) {
                    Pair(true, Some(fnName));
                } else {
                    Pair(false, None());
                }
            } else {
                Pair(false, None());
            }
        }
        None(): Pair(false, None());
    }
}

// 7. Value Extraction Helper Functions
// Extract a string value from a node
getNodeStringValue(node : ONode, defaultValue : string) -> string {
    switch (node.value) {
        OrbitString(s): s;
        default: defaultValue;
    }
}

// Extract an int value from a node
getNodeIntValue(node : ONode, defaultValue : int) -> int {
    switch (node.value) {
        OrbitInt(i): i;
        default: defaultValue;
    }
}

// Extract a double value from a node
getNodeDoubleValue(node : ONode, defaultValue : double) -> double {
    switch (node.value) {
        OrbitDouble(d): d;
        default: defaultValue;
    }
}

// Extract a boolean value from a node
getNodeBoolValue(node : ONode, defaultValue : bool) -> bool {
    switch (node.value) {
        OrbitBool(b): b;
        default: defaultValue;
    }
}

// Main function to evaluate quasiquotation in an OGraph
evaluateOGraphQuasiquote(graphName : string, nodeId : int, environment : SExpEnv, evaluator : (env : SExpEnv, expr : Sexpr) -> SExpEnv, tracing : bool) -> Pair<SExpEnv, int> {
    // Get the graph from the registry
    switch (lookupTree(^ographRegistry, graphName)) {
        Some(graph): {
            // Find the canonical representative (root) for this node
            rootId = findORoot(graph, nodeId);
            
            // Process the quasiquote starting at this node
            if (tracing) println("Starting quasiquote evaluation at node ID: " + i2s(rootId));
            evaluateQuasiquoteNode(graph, rootId, environment, evaluator, tracing);
        }
        None(): {
            println("ERROR: OGraph '" + graphName + "' not found");
            Pair(environment, -1); // Return -1 to indicate error
        }
    }
}

// Evaluate an identifier node that maps to a value in the environment
evaluateIdentifierNode(graph : OGraph, nodeId : int, node : ONode, environment : SExpEnv, evaluator : (env : SExpEnv, expr : Sexpr) -> SExpEnv, tracing : bool) -> Pair<SExpEnv, int> {
    // Extract the identifier name
    idName = getNodeStringValue(node, "");
    
    if (idName != "") {
        // Check if this identifier exists in the environment
        switch (lookupTree(environment.env, idName)) {
            Some(value): {
                if (tracing) println("Found identifier '" + idName + "' in environment, evaluating");
                
                // Convert the value to an OGraph node
                resultId = sexp2OGraphWithSubstitution(graph, value, makeTree());
                
                // Merge with the original node
                mergeOClasses(graph, nodeId, resultId);
                
                if (tracing) println("Evaluated identifier to: " + prettySexpr(value));
                
                // Return the environment and result node ID
                Pair(environment, resultId);
            }
            None(): {
                if (tracing) println("Identifier '" + idName + "' not found in environment");
                Pair(environment, nodeId); // Return unchanged
            }
        }
    } else {
        // No valid identifier name
        Pair(environment, nodeId); // Return unchanged
    }
}

// Evaluate a container node (List/Vector) if all children are constants
evaluateBubbleContainer(graph : OGraph, nodeId : int, node : ONode, processedChildren : [int], environment : SExpEnv, tracing : bool) -> int {
    // Check if all children are constants
    if (forall(processedChildren, \childId -> isConstantNode(graph, childId))) {
        if (tracing) println("All children of " + node.op + " are constants, bubble up as constant");
        
        // Keep the container as is with processed children, it's now considered a constant
        newNodeId = insertONode(graph, ONode(node.op, processedChildren, node.belongsTo, node.value));
        
        // Merge with the original node
        mergeOClasses(graph, nodeId, newNodeId);
        newNodeId;
    } else {
        // Not all children are constants
        if (tracing) println("Not all children of " + node.op + " are constants, can't bubble up");
        insertONode(graph, ONode(node.op, processedChildren, node.belongsTo, node.value));
    }
}

// Evaluate quasiquotation for a specific node in the graph
evaluateQuasiquoteNode(graph : OGraph, nodeId : int, environment : SExpEnv, evaluator : (env : SExpEnv, expr : Sexpr) -> SExpEnv, tracing : bool) -> Pair<SExpEnv, int> {
    // Lookup the node in the graph
    switch (lookupOClass(graph, nodeId)) {
        Some(oclass): {
            node = oclass.node;
            
            if (tracing) println("Evaluating node " + i2s(nodeId) + " with op: " + node.op);
            
            // First check if this is a Scheme node that we can process
            if (!isSchemeNode(node)) {
                if (tracing) println("Not a Scheme node, processing children only");
                // Not a Scheme node - just process children recursively
                processNodeChildren(graph, nodeId, node, environment, evaluator, tracing);
            }
            // Check if this is an unquote operation following the protocol
            else if (isSpecialFormNode(graph, nodeId, "unquote")) {
                // Unquote - evaluate the child directly
                if (length(node.children) > 1) { // First child is the special form name, second is the content
                    if (tracing) println("Found unquote, evaluating child");
                    
                    // Get the actual child to evaluate (skip the special form name child)
                    childId = node.children[1]; // Skip the first child which is the special form name
                    childSexpr = ograph2Sexpr(graph, childId);
                    
                    // Evaluate the expression using the provided evaluator function
                    newEnvironment = evaluator(environment, childSexpr);
                    
                    // Extract the result value from the environment
                    result = newEnvironment.value;
                    
                    // Convert the result back to OGraph node
                    resultId = sexp2OGraphWithSubstitution(graph, result, makeTree());
                    
                    // Merge the result with the original node's equivalence class
                    mergeOClasses(graph, nodeId, resultId);
                    
                    if (tracing) println("Evaluated unquote, result: " + prettySexpr(result));
                    
                    // Return the updated environment and the node ID
                    Pair(newEnvironment, resultId);
                } else {
                    if (tracing) println("Unquote node has wrong number of children: " + i2s(length(node.children)));
                    Pair(environment, nodeId); // Return unchanged
                }
            } else if (isSpecialFormNode(graph, nodeId, "unquote-splicing")) {
                // Handle unquote-splicing - special case that needs to be handled by parent
                if (tracing) println("Found unquote-splicing, this should be handled by parent node");
                Pair(environment, nodeId); // Return unchanged
            } else if (node.op == "Identifier") {
                // Try to evaluate identifiers directly
                evaluateIdentifierNode(graph, nodeId, node, environment, evaluator, tracing);
            } else if (isOperatorNode(graph, node, environment)) {
                // For operator nodes or user-defined functions, consider evaluating
                evaluateOperatorNode(graph, nodeId, node, environment, evaluator, tracing);
            } else {
                // Regular node - process children recursively
                processNodeChildren(graph, nodeId, node, environment, evaluator, tracing);
            }
        }
        None(): {
            if (tracing) println("Node ID " + i2s(nodeId) + " not found");
            Pair(environment, nodeId); // Return unchanged
        }
    }
}

// Check if a node represents a Scheme expression that we can potentially evaluate
isSchemeNode(node : ONode) -> bool {
    // These node types are created by sexp2OGraphWithSubstitution and represent Scheme expressions
    schemeNodeTypes = ["List", "SpecialForm", "Int", "Double", "String", "Bool", 
                      "Identifier", "Constructor", "Operator", "Vector"];
    
    contains(schemeNodeTypes, node.op);
}

// Check if a node represents an operator (like +, -, *, /) or user-defined function that can be evaluated
// Updated for cleaner logic, but without calling isFunctionCallNode directly since we need nodeId
isOperatorNode(graph : OGraph, node : ONode, env : SExpEnv) -> bool {
    // First check if it's a Scheme node at all
    if (!isSchemeNode(node)) {
        false;  // Not a Scheme node, can't be an operator
    } else if (node.op == "List" && length(node.children) > 0) {
        // For List nodes, the first child might be an operator or function
        // Get the first child and check if it's an operator or identifier
        firstChildId = node.children[0];
        switch (lookupOClass(graph, firstChildId)) {
            Some(childClass): {
                childNode = childClass.node;
                if (childNode.op == "Operator") {
                    // It's an operator, check if it's in runtime environment
                    opName = getNodeStringValue(childNode, "");
                    containsKeyTree(env.runtime, opName);
                } else if (childNode.op == "Identifier") {
                    // It's an identifier, check if it's a function in user environment
                    fnName = getNodeStringValue(childNode, "");
                    containsKeyTree(env.env, fnName);
                } else {
                    false;
                }
            }
            None(): false;
        }
    } else {
        // Not a list with a function call structure
        false;
    }
}

// Helper function to process children recursively
processChildrenRecursively(graph : OGraph, children : [int], startIndex : int, environment : SExpEnv, 
                           evaluator : (env : SExpEnv, expr : Sexpr) -> SExpEnv, tracing : bool, 
                           areConstants : bool) -> Pair<Pair<SExpEnv, [int]>, bool> {
    if (startIndex >= length(children)) {
        // Done processing all children
        Pair(Pair(environment, []), areConstants);
    } else {
        // Process current child
        childId = children[startIndex];
        result = evaluateQuasiquoteNode(graph, childId, environment, evaluator, tracing);
        newEnvironment = result.first;
        processedChildId = result.second;
        
        // Check if child is a constant using our enhanced helper that handles nested constants
        isConstant = isConstantNode(graph, processedChildId);
        
        // Process remaining children
        remainingResult = processChildrenRecursively(graph, children, startIndex + 1, 
                                                    newEnvironment, evaluator, tracing, 
                                                    areConstants && isConstant);
        
        // Combine results
        remainingEnvironment = remainingResult.first.first;
        remainingProcessedChildren = remainingResult.first.second;
        allConstantsResult = remainingResult.second;
        
        // Return combined result
        Pair(Pair(remainingEnvironment, concat([processedChildId], remainingProcessedChildren)), 
             allConstantsResult);
    }
}

// Helper function to process list children with special handling for unquote-splicing
processListChildrenRecursively(graph : OGraph, children : [int], startIndex : int, environment : SExpEnv, 
                              evaluator : (env : SExpEnv, expr : Sexpr) -> SExpEnv, tracing : bool) -> Pair<SExpEnv, [int]> {
    if (startIndex >= length(children)) {
        Pair(environment, []); // Done processing all children
    } else {
        childId = children[startIndex];
        
        // Check if this child is an unquote-splicing following the protocol
        unquoteSplicingResult = switch (lookupOClass(graph, childId)) {
            Some(childClass): {
                if (isSpecialFormNode(graph, childId, "unquote-splicing")) {
                    if (tracing) println("Found unquote-splicing at index " + i2s(startIndex));
                    
                    // Handle unquote-splicing - evaluate and splice the result
                    // In the protocol, the first child is the special form name, second child is the content
                    if (length(childClass.node.children) > 1) {
                        // Get actual expression to evaluate (skip the special form name child)
                        splicedChildId = childClass.node.children[1];
                        splicedSexpr = ograph2Sexpr(graph, splicedChildId);
                        
                        // Evaluate the expression using the provided evaluator function
                        newEnvironment = evaluator(environment, splicedSexpr);
                        result = newEnvironment.value;
                        
                        // The result should be a list to splice
                        switch (result) {
                            SSList(items): {
                                if (tracing) println("Splicing " + i2s(length(items)) + " items");
                                
                                // Process splice items recursively
                                processSpliceItems(graph, items, 0, newEnvironment, makeTree());
                            }
                            default: {
                                if (tracing) println("Warning: unquote-splicing result is not a list");
                                // Add as a single item
                                itemId = sexp2OGraphWithSubstitution(graph, result, makeTree());
                                Pair(newEnvironment, [itemId]);
                            }
                        }
                    } else {
                        if (tracing) println("unquote-splicing has wrong number of children");
                        // Just add the original child
                        Pair(environment, [childId]);
                    }
                } else {
                    // Regular child - evaluate normally
                    result = evaluateQuasiquoteNode(graph, childId, environment, evaluator, tracing);
                    Pair(result.first, [result.second]);
                }
            }
            None(): {
                // Node not found - just add the original ID
                Pair(environment, [childId]);
            }
        };
        
        // Process remaining children
        remainingResult = processListChildrenRecursively(graph, children, startIndex + 1, 
                                                      unquoteSplicingResult.first, evaluator, tracing);
        
        // Combine results
        remainingEnvironment = remainingResult.first;
        remainingProcessedChildren = remainingResult.second;
        
        // Return combined result
        Pair(remainingEnvironment, concat(unquoteSplicingResult.second, remainingProcessedChildren));
    }
}

// Helper to recursively process splice items
processSpliceItems(graph : OGraph, items : [Sexpr], startIndex : int, environment : SExpEnv, substitutions : Tree<string, int>) -> Pair<SExpEnv, [int]> {
    if (startIndex >= length(items)) {
        Pair(environment, []); // Done processing all items
    } else {
        // Convert current item to OGraph node
        itemId = sexp2OGraphWithSubstitution(graph, items[startIndex], substitutions);
        
        // Process remaining items
        remainingResult = processSpliceItems(graph, items, startIndex + 1, environment, substitutions);
        
        // Return combined result
        Pair(remainingResult.first, concat([itemId], remainingResult.second));
    }
}

// Evaluate an operator node if all children are constants
evaluateOperatorNode(graph : OGraph, nodeId : int, node : ONode, environment : SExpEnv, evaluator : (env : SExpEnv, expr : Sexpr) -> SExpEnv, tracing : bool) -> Pair<SExpEnv, int> {
    if (tracing) println("Checking if operator " + node.op + " can be evaluated");
    
    // Process all children
    processResult = processChildrenRecursively(graph, node.children, 0, environment, evaluator, tracing, true);
    newEnvironment = processResult.first.first;
    processedChildren = processResult.first.second;
    allConstants = processResult.second;
    
    if (allConstants) {
        // All children are constants, so we can evaluate
        if (tracing) println("All children are constants, evaluating " + node.op);
        
        // Convert the expression to Sexpr for evaluation
        expr = createSexprFromNode(graph, node.op, processedChildren, newEnvironment);
        
        // Evaluate the expression using the provided evaluator function
        finalEnvironment = evaluator(newEnvironment, expr);
        
        // Extract the result value from the environment
        result = finalEnvironment.value;
        
        if (tracing) println("Evaluated expression, result: " + prettySexpr(result));
        
        // Convert the result back to OGraph node
        resultId = sexp2OGraphWithSubstitution(graph, result, makeTree());
        
        // Merge the result with the original node's equivalence class
        mergeOClasses(graph, nodeId, resultId);
        
        // Return the updated environment and the node ID
        Pair(finalEnvironment, resultId);
    } else {
        // Not all children are constants, so we can't evaluate completely
        if (tracing) println("Not all children are constants, cannot fully evaluate");
        
        // Create a new node with the processed children
        newNodeId = insertONode(graph, ONode(node.op, processedChildren, node.belongsTo, node.value));
        
        // Merge with the original node
        mergeOClasses(graph, nodeId, newNodeId);
        
        Pair(newEnvironment, newNodeId);
    }
}

// Process children of a regular (non-special) node - implementing improvement #3
processNodeChildren(graph : OGraph, nodeId : int, node : ONode, environment : SExpEnv, evaluator : (env : SExpEnv, expr : Sexpr) -> SExpEnv, tracing : bool) -> Pair<SExpEnv, int> {
    if (tracing) println("Processing children of node " + i2s(nodeId) + " (" + node.op + ")");
    
    // Special handling for container nodes (List/Vector) that might contain unquote-splicing
    if (node.op == "List" || node.op == "Vector") {
        processContainer(graph, nodeId, node, node.op, environment, evaluator, tracing);
    } else {
        // Process all children
        childrenResult = processChildrenRecursively(graph, node.children, 0, environment, evaluator, tracing, false);
        newEnvironment = childrenResult.first.first;
        processedChildren = childrenResult.first.second;
        
        // Check if children were modified (if not, return original node)
        if (node.children == processedChildren) {
            if (tracing) println("No changes to children, returning original node");
            Pair(newEnvironment, nodeId);
        } else {
            // Create a new node with the processed children
            if (tracing) println("Children were modified, creating new node");
            newNodeId = insertONode(graph, ONode(node.op, processedChildren, node.belongsTo, node.value));
            
            // Merge with the original node
            mergeOClasses(graph, nodeId, newNodeId);
            
            Pair(newEnvironment, newNodeId);
        }
    }
}

// Process List and Vector nodes with consistent handling and bubbling up fully evaluated containers
processContainer(graph : OGraph, nodeId : int, node : ONode, containerType : string, 
                 environment : SExpEnv, evaluator : (SExpEnv, Sexpr) -> SExpEnv, 
                 tracing : bool) -> Pair<SExpEnv, int> {
    if (tracing) println("Processing " + containerType + " node with " + i2s(length(node.children)) + " children");
    
    // Process container children (with special handling for unquote-splicing)
    result = processListChildrenRecursively(graph, node.children, 0, environment, evaluator, tracing);
    newEnvironment = result.first;
    processedChildren = result.second;
    
    // Check if children were modified
    if (node.children == processedChildren) {
        if (tracing) println("No changes to " + containerType + " node children, returning original");
        Pair(newEnvironment, nodeId);
    } else {
        // Create a new container node with the processed children
        if (tracing) println("Creating new " + containerType + " node with " + i2s(length(processedChildren)) + " children");
        
        // Use our new bubbling function to evaluate if all children are constants
        newNodeId = evaluateBubbleContainer(graph, nodeId, node, processedChildren, environment, tracing);
        
        Pair(newEnvironment, newNodeId);
    }
}

// Special handling for List nodes (now a wrapper around processContainer)
processListNode(graph : OGraph, nodeId : int, node : ONode, environment : SExpEnv, evaluator : (env : SExpEnv, expr : Sexpr) -> SExpEnv, tracing : bool) -> Pair<SExpEnv, int> {
    // Just delegate to our more general container processor
    processContainer(graph, nodeId, node, "List", environment, evaluator, tracing);
}

// Helper to create a Sexpr from a node for evaluation
createSexprFromNode(graph : OGraph, op : string, childIds : [int], env : SExpEnv) -> Sexpr {
    // Convert all children to Sexpr
    childExprs = map(childIds, \childId -> {
        ograph2Sexpr(graph, childId);
    });
    
    // Determine if it's an operator or function by checking the runtime environment
    if (containsKeyTree(env.runtime, op)) {
        // It's a built-in operator/function in the runtime
        SSList(concat([SSOperator(op)], childExprs));
    } else {
        // For user-defined functions or anything else, create a function call
        SSList(concat([SSVariable(op)], childExprs));
    }
}