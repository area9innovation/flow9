import tools/orbit/sexpr/sexpr_types;
import tools/orbit/sexpr/pretty_sexpr;
import ds/tree;
import string;
import math/math;

export {
	// Pattern matching against a value
	// Returns updated environment if match succeeds, None if it fails
	matchPattern(pattern : Sexpr, value : Sexpr, env : Tree<string, Sexpr>) -> Maybe<Tree<string, Sexpr>>;

	// Pattern matching - returns index of first successful pattern and updated environment
	evalMatch(env : Tree<string, Sexpr>, value : Sexpr, patterns : [Sexpr]) -> Pair<int, Tree<string, Sexpr>>;
}

// Pattern matching - returns index of first successful pattern or -1
// Returns the index and the updated environment
evalMatch(env : Tree<string, Sexpr>, value : Sexpr, patterns : [Sexpr]) -> Pair<int, Tree<string, Sexpr>> {
	if (length(patterns) == 0) {
		Pair(-1, env);
	} else {
		// Check each pattern sequentially using recursion
		evalMatchHelper(env, value, patterns, 0);
	}
}

// Helper for pattern matching - returns the index of the matched pattern and the updated environment
evalMatchHelper(env : Tree<string, Sexpr>, value : Sexpr, patterns : [Sexpr], idx : int) -> Pair<int, Tree<string, Sexpr>> {
	if (idx >= length(patterns)) {
		Pair(-1, env);
	} else if (idx % 2 == 0) { // Even indices are patterns
		pattern = patterns[idx];
		matchResult = matchPattern(pattern, value, env);
		switch (matchResult) {
			Some(newEnv): {
				Pair(idx / 2, newEnv); // Pattern matches - return pattern number and updated env
			}
			None(): {
				evalMatchHelper(env, value, patterns, idx + 1); // Try next pattern
			}
		}
	} else {
		// Skip result expressions
		evalMatchHelper(env, value, patterns, idx + 1);
	}
}

// Pattern matching against a value
// Returns updated environment if match succeeds, None if it fails
matchPattern(pattern : Sexpr, value : Sexpr, env : Tree<string, Sexpr>) -> Maybe<Tree<string, Sexpr>> {
	// println("Matching pattern: " + prettySexpr(pattern) + " against value: " + prettySexpr(value));
	switch (pattern) {
		// Variable pattern - binds value to variable
		SSVariable(name): {
			if (name == "_") {
				// Wildcard matches anything
				Some(env);
			} else {
				// Bind value to variable
				Some(setTree(env, name, value));
			}
		};

		// Literal patterns
		SSBool(b): if (pattern == value) Some(env) else None();
		SSInt(i): if (pattern == value) Some(env) else None();
		SSDouble(d): if (pattern == value) Some(env) else None();
		SSString(s): if (pattern == value) Some(env) else None();
		// Constructor pattern
		SSConstructor(name): if (pattern == value) Some(env) else None();

		// List pattern
		SSList(items): {
			switch (value) {
				SSList(values): {
					if (length(items) == length(values)) {
						// Try to match each item using recursion
						matchListItems(items, values, env, 0);
					} else {
						None(); // Different length lists
					}
				};
				default: None();
			}
		};
		SSOperator(string1): if (pattern == value) Some(env) else None();
		SSSpecialForm(special_name, sexprs): {
			println("TODO: Implement special form pattern matching");
			None();
		}
	}
}

// Helper to match list items recursively
matchListItems(patterns : [Sexpr], values : [Sexpr], env : Tree<string, Sexpr>, idx : int) -> Maybe<Tree<string, Sexpr>> {
	if (idx >= length(patterns)) {
		// Successfully matched all items
		Some(env);
	} else {
		// Match this item
		itemMatch = matchPattern(patterns[idx], values[idx], env);
		switch (itemMatch) {
			Some(newEnv): {
				// Continue matching with updated environment
				matchListItems(patterns, values, newEnv, idx + 1);
			};
			None(): None(); // Match failed
		}
	}
}
