import tools/orbit/ograph;          // For OGraph operations
import tools/orbit/orbit_types;    // For OrbitValue
import tools/orbit/sexpr/sexpr_types; // For Sexpr types
import tools/orbit/orbit_simple_ograph; // For ographRegistry
import tools/orbit/sexpr/pretty_sexpr; // For pretty printing Sexpr
import tools/orbit/sexpr/ograph2sexpr; // For ograph2Sexpr
import tools/orbit/sexpr/sexpr_ograph_utils; // For utility functions

export {
    // Main pattern matching function for S-expressions
    // Finds all matches of the pattern in the graph and calls the callback for each
    matchOGraphSexprPattern(
        graphName : string,                      // Name of the OGraph to search in
        pattern : Sexpr,                        // Pattern to match (with variables)
        callback : (Tree<string, int>, int) -> void,  // Called for each match with bindings and the e-class ID
        tracing : bool                         // Enable detailed tracing for debugging
    ) -> int;  // Returns the number of matches found
    
    // Internal pattern matching types and functions
    OSexprPatternResult ::= OSexprPatternSuccess, OSexprPatternFailure;
        OSexprPatternSuccess(bindings : Tree<string, int>); // Variable name to node ID
        OSexprPatternFailure();
}

// Main function for pattern matching in an OGraph using S-expressions
matchOGraphSexprPattern(graphName : string, pattern : Sexpr, callback : (Tree<string, int>, int) -> void, tracing : bool) -> int {
    // Get the graph from the registry
    matchCount = ref 0;
    
    if (tracing) println("Pattern matching in graph '" + graphName + "'");
    if (tracing) println("Pattern: " + prettySexpr(pattern));
    
    switch (lookupTree(^ographRegistry, graphName)) {
        Some(graph): {
            if (tracing) println("DEBUG: Calling matchOGraphSexprPattern with graph " + graphName);
            // Strategy: Try to match the pattern starting at each node in the graph
            if (tracing) println("DEBUG: Found graph, traversing nodes");
            traverseOGraph(graph, \nodeIndex, node -> {
                if (tracing) println("DEBUG: Checking node ID: " + i2s(nodeIndex) + ", op: " + node.op);
                
                // Try to match the pattern at this node
                switch (matchSexprPatternAtNode(graph, nodeIndex, pattern, tracing)) {
                    OSexprPatternSuccess(bindings): {
                        if (tracing)  {
                            println("DEBUG: Found match at node ID: " + i2s(nodeIndex));
                            println("DEBUG: Found match with " + i2s(sizeTree(bindings)) + " bindings at eclass ID: " + i2s(findORoot(graph, nodeIndex)));

                            // Debug output - log all bindings
                            iter(getTreeKeys(bindings), \key -> {
                                value = lookupTreeDef(bindings, key, -1);
                                println("  " + key + " = " + i2s(value) + " (" + prettySexpr(ograph2Sexpr(graph, value)) + ")");
                            });
                        }
                        
                        // Call the callback directly with the bindings (eclass IDs) and the e-class ID
                        matchCount := ^matchCount + 1;
                        rootId = findORoot(graph, nodeIndex);
                        callback(bindings, rootId);
                    }
                    OSexprPatternFailure(): {
                        // No match at this node, continue searching
                        if (tracing) println("DEBUG: No match at node ID: " + i2s(nodeIndex));
                    }
                }
            });
            
            if (tracing) println("DEBUG: matchOGraphSexprPattern returned " + i2s(^matchCount) + " matches");
            ^matchCount;
        }
        None(): {
            println("ERROR: OGraph '" + graphName + "' not found");
            0;
        }
    }
}

// Match a Sexpr pattern at a specific node
matchSexprPatternAtNode(graph : OGraph, nodeId : int, pattern : Sexpr, tracing : bool) -> OSexprPatternResult {
    root = findORoot(graph, nodeId);
    
    // Use our enhanced decomposition function to get all components
    components = decomposeSexpr(pattern);
    patternOp = components.first;
    patternChildren = components.second;
    patternValue = components.third;
    
    if (tracing) println("DEBUG: Matching pattern with op: " + patternOp + ", at node: " + i2s(root));
    
    // Special case for type annotations: (: expr Domain)
    if (isTypeAnnotation(pattern)) {
        if (tracing) println("DEBUG: Processing type annotation pattern (: operator)");
        
        switch (pattern) {
            SSList(parts): {
                // Extract expression and domain from the pattern
                expressionPattern = parts[1];
                domainPattern = parts[2];
                
                // First match the expression part against this node
                switch (matchSexprPatternAtNode(graph, nodeId, expressionPattern, tracing)) {
                    OSexprPatternSuccess(exprBindings): {
                        // Found a match for the expression part
                        // Now verify domain membership

						// TODO: Instead of constructing an id for the domain pattern,
						// we should just iterate the belongs to and see if any of them
						// matches the domain pattern.
						println("TODO: Implement domain membership check by checking all belongsTo");
                        domainId = getSexprDomainId(graph, domainPattern, tracing);
                        
                        if (domainId == -1) {
                            if (tracing) println("DEBUG: Could not find domain node for: " + prettySexpr(domainPattern));
                            OSexprPatternFailure();
                        } else {
                            // Check domain membership
                            belongsToDomain = onodeBelongsTo(graph, nodeId, domainId);
                            
                            if (tracing) {
                                println("DEBUG: Checking if node " + i2s(nodeId) + " belongs to domain " + i2s(domainId));
                                println("DEBUG: Domain membership result: " + i2s(b2i(belongsToDomain)));
                            }
                            
                            if (belongsToDomain) {
                                if (tracing) println("DEBUG: Node belongs to required domain, match successful");
                                OSexprPatternSuccess(exprBindings);  // Return the expression match bindings
                            } else {
                                if (tracing) println("DEBUG: Node does not belong to required domain, match failed");
                                OSexprPatternFailure();
                            }
                        }
                    }
                    OSexprPatternFailure(): {
                        if (tracing) println("DEBUG: Expression part of type annotation pattern didn't match");
                        OSexprPatternFailure();
                    }
                }
            }
            default: OSexprPatternFailure(); // Should not happen if isTypeAnnotation is true
        }
    } 
    // Special case for pattern variables (SSVariable in pattern context)
    else if (switch(pattern) { SSVariable(__): true; default: false; }) {
        switch(pattern) {
            SSVariable(varName): {
                if (varName != "") {
                    // In pattern matching, variables are treated as pattern variables
                    // that can match any node
                    if (tracing) println("DEBUG: Pattern variable " + varName + " binds to node " + i2s(root));
                    OSexprPatternSuccess(makeTree1(varName, root));
                } else {
                    // Handle the case when varName is empty
                    OSexprPatternFailure();
                }
            }
            default: OSexprPatternFailure(); // Should not happen based on the condition check
        }
    }
    // For all other patterns
    else {
        matchRegularPattern(graph, root, pattern, patternOp, patternChildren, patternValue, tracing);
    }
}

// Match a regular (non-special) pattern
matchRegularPattern(graph : OGraph, nodeId : int, pattern : Sexpr, patternOp : string, 
                   patternChildren : [Sexpr], patternValue : OrbitValue, tracing : bool) -> OSexprPatternResult {
    // Get the ONode for this root
    switch (lookupOClass(graph, nodeId)) {
        Some(oclass): {
            node = oclass.node;
            nodeOp = node.op;
            nodeChildren = node.children;
            
            if (tracing) println("DEBUG: Regular pattern match op: " + patternOp + " vs node op: " + nodeOp);
            
            // We need exact matches with values
            if (patternOp == nodeOp && patternValue == node.value) {
				// Handle regular child matching vs. rest pattern matching
				if (length(patternChildren) == length(nodeChildren)) {
					if (tracing) println("DEBUG: Operator and child count match, matching children");
					// Match all children recursively
					matchSexprAllChildren(graph, nodeChildren, patternChildren, makeTree(), tracing);
				} else {
					if (tracing) println("DEBUG: Child count mismatch: pattern=" + i2s(length(patternChildren)) + ", node=" + i2s(length(nodeChildren)));
					OSexprPatternFailure();
				}
            } else {
                if (tracing) {
                    println("DEBUG: Operator mismatch: pattern=" + patternOp + ", node=" + nodeOp);
                    println(prettySexpr(pattern));
                    printlnONode(node);
                }
                OSexprPatternFailure();
            }
        }
        None(): {
            if (tracing) println("DEBUG: Node not found in graph");
            OSexprPatternFailure();
        }
    }
}

// Helper to print ONode contents for debugging
printlnONode(node : ONode) -> void {
    println("ONode(\"" + node.op + "\", " + i2s(length(node.children)) + " children, " + 
           i2s(length(node.belongsTo)) + " domains, " + orbitValue2String(node.value) + ")");
}

// Helper to get domain ID from a pattern
getSexprDomainId(graph : OGraph, domainPattern : Sexpr, tracing : bool) -> int {
    // In a real implementation, we would need to find existing domain entries
    // This is a simplified approach - in a full implementation, we would use sexp2OGraphWithSubstitution
    domainId = match_Sexpr(domainPattern, graph, tracing);
    
    if (tracing) {
        println("DEBUG: Domain '" + prettySexpr(domainPattern) + "' has ID " + i2s(domainId));
    }
    
    domainId;
}

// Simplified function to add an S-expression to the graph for pattern matching
// In a real implementation, we would use sexp2OGraphWithSubstitution
match_Sexpr(expr : Sexpr, graph : OGraph, tracing : bool) -> int {
    // Use our enhanced decomposition function to get all components
    components = decomposeSexpr(expr);
    nodeType = components.first;
    children = components.second;
    nodeValue = components.third;
    
    // Process based on the node type and value
    if (isONodePrimitive(ONode(nodeType, [], [], nodeValue))) {
        // For primitives, we can directly create and insert the node
        insertONode(graph, ONode(nodeType, [], [], nodeValue));
    } else {
        // For composite nodes, process all children recursively
        childIds = map(children, \child -> match_Sexpr(child, graph, tracing));
        
        if (isTypeAnnotation(expr)) {
            // Special handling for type annotations
            baseId = childIds[0];
            domainId = childIds[1];
            
            // Add the domain to the base node
            addBelongsToONode(graph, baseId, domainId);
            baseId;
        } else {
            // Regular node creation
            insertONode(graph, ONode(nodeType, childIds, [], nodeValue));
        }
    }
}

// Match all children of an operation
matchSexprAllChildren(graph : OGraph, childIds : [int], patterns : [Sexpr], 
                      bindings : Tree<string, int>, tracing : bool) -> OSexprPatternResult {
    if (length(childIds) == 0 && length(patterns) == 0) {
        // All children matched successfully
        OSexprPatternSuccess(bindings);
    } else if (length(childIds) == 0 || length(patterns) == 0) {
        // Mismatched number of children
        OSexprPatternFailure();
    } else {
        // Try to match the first child
        switch (matchSexprPatternAtNode(graph, childIds[0], patterns[0], tracing)) {
            OSexprPatternSuccess(childBindings): {
                // Merge bindings, ensuring consistency
                switch (mergeSexprBindings(graph, bindings, childBindings)) {
                    OSexprPatternSuccess(mergedBindings): {
                        // Continue with remaining children
                        matchSexprAllChildren(graph, tail(childIds), tail(patterns), mergedBindings, tracing);
                    }
                    OSexprPatternFailure(): {
                        OSexprPatternFailure();
                    }
                }
            }
            OSexprPatternFailure(): {
                OSexprPatternFailure();
            }
        }
    }
}

// Merge bindings, ensuring consistency (same variable bound to semantically equivalent nodes)
mergeSexprBindings(graph : OGraph, a : Tree<string, int>, b : Tree<string, int>) -> OSexprPatternResult {
    // Helper to check if two nodes are in the same equivalence class
    areEquivalentNodes = \id1, id2 -> {
        // If they're already in the same equivalence class, they're equivalent
        findORoot(graph, id1) == findORoot(graph, id2);
    };

    result = fold(getTreeKeys(b), OSexprPatternSuccess(a), \acc, key -> {
        switch (acc) {
            OSexprPatternSuccess(bindings): {
                bValue = lookupTreeDef(b, key, -1);
                switch (lookupTree(bindings, key)) {
                    Some(aValue): {
                        // Variable already bound, must be consistent
                        // This is critical for patterns like (+ x x) where the same variable appears multiple times
                        if (areEquivalentNodes(aValue, bValue)) { 
                            // Accept if they're semantically equivalent expressions
                            OSexprPatternSuccess(bindings);
                        } else {
                            OSexprPatternFailure();
                        }
                    }
                    None(): {
                        // New binding
                        OSexprPatternSuccess(setTree(bindings, key, bValue));
                    }
                }
            }
            OSexprPatternFailure(): OSexprPatternFailure();
        }
    });
    
    result;
}