import tools/orbit/ograph;          // For OGraph operations
import tools/orbit/orbit_types;    // For OrbitValue
import tools/orbit/sexpr/sexpr_types; // For Sexpr types
import tools/orbit/orbit_simple_ograph; // For ographRegistry
import tools/orbit/sexpr/pretty_sexpr; // For pretty printing Sexpr
import tools/orbit/sexpr/ograph2sexpr; // For ograph2Sexpr
import tools/orbit/sexpr/sexpr_ograph_utils; // For utility functions
import string; // For string operations

export {
    // One-level pattern matcher for SEXpr implementation
    // Returns a Pair containing success (bool) and updated bindings array
    matchSExprNodeOneLevel(
        graph : OGraph,                      // The graph to search in
        nodeId : int,                        // The node to match against
        pattern : Sexpr,                     // The pattern to match
        bindings : [Pair<string, int>],      // Existing variable bindings (variable name â†’ node ID)
        tracing : bool                       // Enable tracing for debugging
    ) -> Pair<bool, [Pair<string, int>]>;    // success, updated bindings
}

// One-level pattern matcher for SEXpr implementation
// Returns a Pair containing success (bool) and updated bindings array
matchSExprNodeOneLevel(graph : OGraph, nodeId : int, pattern : Sexpr, bindings : [Pair<string, int>], tracing : bool) -> Pair<bool, [Pair<string, int>]> {
    root = findORoot(graph, nodeId);
	switch (pattern) {
		SSVariable(varName): {
			if (varName != "") {
				// Check if this variable is already bound
				existingBinding = find(bindings, \binding -> binding.first == varName);
				
				switch (existingBinding) {
					Some(binding): {
						// Variable is already bound, must be consistent
						if (findORoot(graph, binding.second) == root) {
							// Matched consistently
							if (tracing) println("DEBUG: Consistent binding for " + varName);
							Pair(true, bindings);
						} else {
							// Inconsistent binding
							if (tracing) println("DEBUG: Inconsistent binding for " + varName);
							Pair(false, []);
						}
					}
					None(): {
						// New binding
						if (tracing) println("DEBUG: New binding: " + varName + " = " + i2s(root));
						newBindings = concat(bindings, [Pair(varName, root)]);
						Pair(true, newBindings);
					}
				}
			} else {
				// Empty variable name is not valid
				Pair(false, []);
			}
		}
		default: {
			// Get the ONode for this node
			switch (lookupOClass(graph, root)) {
				Some(oclass): {
					node = oclass.node;
					
					// Use our enhanced decomposition function to get all components
					components = decomposeSexpr(pattern);
					patternOp = components.first;
					patternChildren = components.second;
					patternValue = components.third;
					// Normal pattern matching
					nodeOp = node.op;
					nodeChildren = node.children;
					
					if (patternOp == nodeOp && patternValue == node.value) {
						if (tracing) println("DEBUG: Matching pattern with op: " + patternOp + ", at node: " + i2s(root));
						Pair(true, []);
					} else {
						Pair(false, []);
					}
				}
				None(): {
					if (tracing) println("DEBUG: Node not found in graph");
					Pair(false, []);
				}
			}
		}
	}
}

// Match all children of an operation
matchAllChildrenOneLevel(
    graph : OGraph, 
    childIds : [int], 
    patterns : [Sexpr],
    bindings : [Pair<string, int>],
    tracing : bool
) -> Pair<bool, [Pair<string, int>]> {
    if (length(childIds) == 0 && length(patterns) == 0) {
        // All children matched successfully
        Pair(true, bindings);
    } else if (length(childIds) == 0 || length(patterns) == 0) {
        // Mismatched number of children
        Pair(false, []);
    } else {
        // Try to match the first child
        matchResult = matchSExprNodeOneLevel(graph, childIds[0], patterns[0], bindings, tracing);
        
        if (matchResult.first) {
            // Continue with remaining children
            matchAllChildrenOneLevel(graph, tail(childIds), tail(patterns), matchResult.second, tracing);
        } else {
            Pair(false, []);
        }
    }
}