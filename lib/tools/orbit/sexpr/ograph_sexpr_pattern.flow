import tools/orbit/ograph;          // For OGraph operations
import tools/orbit/orbit_types;    // For OrbitValue
import tools/orbit/sexpr/sexpr_types; // For Sexpr types
import tools/orbit/orbit_simple_ograph; // For ographRegistry
import tools/orbit/sexpr/pretty_sexpr; // For pretty printing Sexpr
import tools/orbit/sexpr/ograph2sexpr; // For ograph2Sexpr
import tools/orbit/sexpr/sexpr_ograph_utils; // For utility functions
import string; // For string operations

export {
    // Main pattern matching function for S-expressions
    // Finds all matches of the pattern in the graph and calls the callback for each
    matchOGraphSexprPattern(
        graphName : string,                      // Name of the OGraph to search in
        pattern : Sexpr,                        // Pattern to match (with variables)
        callback : (Tree<string, int>, int) -> void,  // Called for each match with bindings and the e-class ID
        tracing : bool                         // Enable detailed tracing for debugging
    ) -> int;  // Returns the number of matches found
    
    // Internal pattern matching types and functions
    OSexprPatternResult ::= OSexprPatternSuccess, OSexprPatternFailure;
        OSexprPatternSuccess(bindings : Tree<string, int>); // Variable name to node ID
        OSexprPatternFailure();
        
    // Check if a pattern is a backtick-style operator pattern like `op`(args)
    // Returns a pair with the operator name and variable name for args if matched
    isBacktickOperatorPattern(pattern : Sexpr) -> Maybe<Pair<string, string>>;
}

// Main function for pattern matching in an OGraph using S-expressions
matchOGraphSexprPattern(graphName : string, pattern : Sexpr, callback : (Tree<string, int>, int) -> void, tracing : bool) -> int {
    // Get the graph from the registry
    matchCount = ref 0;
    
    if (tracing) println("Pattern matching in graph '" + graphName + "'");
    if (tracing) println("Pattern: " + prettySexpr(pattern));
    
    switch (lookupTree(^ographRegistry, graphName)) {
        Some(graph): {
            if (tracing) println("DEBUG: Calling matchOGraphSexprPattern with graph " + graphName);
            // Strategy: Try to match the pattern starting at each node in the graph
            if (tracing) println("DEBUG: Found graph, traversing nodes");
            traverseOGraph(graph, \nodeIndex, node -> {
                if (tracing) println("DEBUG: Checking node ID: " + i2s(nodeIndex) + ", op: " + node.op);
                
                // Try to match the pattern at this node
                switch (matchSexprPatternAtNode(graph, nodeIndex, pattern, tracing)) {
                    OSexprPatternSuccess(bindings): {
                        if (tracing)  {
                            println("DEBUG: Found match at node ID: " + i2s(nodeIndex));
                            println("DEBUG: Found match with " + i2s(sizeTree(bindings)) + " bindings at eclass ID: " + i2s(findORoot(graph, nodeIndex)));

                            // Debug output - log all bindings
                            iter(getTreeKeys(bindings), \key -> {
                                value = lookupTreeDef(bindings, key, -1);
                                println("  " + key + " = " + i2s(value) + " (" + prettySexpr(ograph2Sexpr(graph, value)) + ")");
                            });
                        }
                        
                        // Call the callback directly with the bindings (eclass IDs) and the e-class ID
                        matchCount := ^matchCount + 1;
                        rootId = findORoot(graph, nodeIndex);
                        callback(bindings, rootId);
                    }
                    OSexprPatternFailure(): {
                        // No match at this node, continue searching
                        if (tracing) println("DEBUG: No match at node ID: " + i2s(nodeIndex));
                    }
                }
            });
            
            if (tracing) println("DEBUG: matchOGraphSexprPattern returned " + i2s(^matchCount) + " matches");
            ^matchCount;
        }
        None(): {
            println("ERROR: OGraph '" + graphName + "' not found");
            0;
        }
    }
}

// Match a Sexpr pattern at a specific node
matchSexprPatternAtNode(graph : OGraph, nodeId : int, pattern : Sexpr, tracing : bool) -> OSexprPatternResult {
    root = findORoot(graph, nodeId);
    
    // Use our enhanced decomposition function to get all components
    components = decomposeSexpr(pattern);
    patternOp = components.first;
    patternChildren = components.second;
    patternValue = components.third;
    
    if (tracing) println("DEBUG: Matching pattern with op: " + patternOp + ", at node: " + i2s(root));
    
    // Special case for type annotations: (: expr Domain)
    if (isTypeAnnotation(pattern)) {
        if (tracing) println("DEBUG: Processing type annotation pattern (: operator)");
        
        switch (pattern) {
            SSList(parts): {
                // Extract expression and domain from the pattern
                expressionPattern = parts[1];
                domainPattern = parts[2];
                
                // First match the expression part against this node
                switch (matchSexprPatternAtNode(graph, nodeId, expressionPattern, tracing)) {
                    OSexprPatternSuccess(exprBindings): {
						// Found a match for the expression part
						// Now verify domain membership
						nodeClass = lookupOClass(graph, nodeId);
						
						switch (nodeClass) {
						    Some(oclass): {
						        // Get list of domains this node belongs to
						        domainIds = oclass.node.belongsTo;
						        
						        if (tracing) {
						            println("DEBUG: Checking domains for node " + i2s(nodeId));
						            println("DEBUG: Node belongs to " + i2s(length(domainIds)) + " domains");
						        }
						        
						        // Special case: If domain pattern is a variable, just bind to all domains
						        if (switch (domainPattern) { SSVariable(__): true; default: false; }) {
						            // Domain pattern is a variable, bind to all domains
						            domainVar = switch (domainPattern) { SSVariable(name): name; default: ""; };
						            
						            if (length(domainIds) > 0) {
						                // We have at least one domain, bind the variable to the first domain
						                domainBindings = setTree(exprBindings, domainVar, domainIds[0]);
						                if (tracing) println("DEBUG: Binding domain variable " + domainVar + " to domain ID " + i2s(domainIds[0]));
						                OSexprPatternSuccess(domainBindings);
						            } else {
						                // No domains to bind to
						                if (tracing) println("DEBUG: No domains to bind to variable " + domainVar);
						                OSexprPatternFailure();
						            }
						        } else {
						            // Domain pattern is not a variable, check for specific domain match
						            if (length(domainIds) == 0) {
						                if (tracing) println("DEBUG: Node doesn't belong to any domains");
						                OSexprPatternFailure();
						            } else {
						                // Try to match each domain ID against our domain pattern
						                matchFound = exists(domainIds, \domainId -> {
						                    domainSexpr = ograph2Sexpr(graph, domainId);
						                    
						                    if (tracing) {
						                        println("DEBUG: Checking domain ID " + i2s(domainId) + 
						                                ": " + prettySexpr(domainSexpr) + 
						                                " against pattern: " + prettySexpr(domainPattern));
						                    }
						                    
						                    // Match based on pattern type
						                    isMatch = switch (domainPattern) {
						                        SSConstructor(patternName): {
						                            // For constructor patterns, check if the domain has the same constructor
						                            constructorMatch = switch (domainSexpr) {
						                                SSConstructor(actualName): actualName == patternName;
						                                default: false;
						                            };
						                            
						                            if (tracing && constructorMatch) {
						                                println("DEBUG: Domain constructor match found: " + patternName);
						                            }
						                            
						                            constructorMatch;
						                        }
						                        default: {
						                            // Direct equality for other types of patterns
						                            exactMatch = domainSexpr == domainPattern;
						                            
						                            if (tracing && exactMatch) {
						                                println("DEBUG: Domain exact match found");
						                            }
						                            
						                            exactMatch;
						                        }
						                    };
						                    
						                    isMatch;
						                });
						                
						                if (matchFound) {
						                    if (tracing) println("DEBUG: At least one domain matched the pattern");
						                    OSexprPatternSuccess(exprBindings);  // Return the expression match bindings
						                } else {
						                    if (tracing) println("DEBUG: No matching domain found");
						                    OSexprPatternFailure();
						                }
						            }
						        }
						    }
						    None(): {
						        if (tracing) println("DEBUG: Node not found in graph");
						        OSexprPatternFailure();
						    }
						}
                    }
                    OSexprPatternFailure(): {
                        if (tracing) println("DEBUG: Expression part of type annotation pattern didn't match");
                        OSexprPatternFailure();
                    }
                }
            }
            default: OSexprPatternFailure(); // Should not happen if isTypeAnnotation is true
        }
    } 
    // Special case for pattern variables (SSVariable in pattern context)
    else if (switch(pattern) { SSVariable(__): true; default: false; }) {
        switch(pattern) {
            SSVariable(varName): {
                if (varName != "") {
                    // In pattern matching, variables are treated as pattern variables
                    // that can match any node
                    if (tracing) println("DEBUG: Pattern variable " + varName + " binds to node " + i2s(root));
                    OSexprPatternSuccess(makeTree1(varName, root));
                } else {
                    // Handle the case when varName is empty
                    OSexprPatternFailure();
                }
            }
            default: OSexprPatternFailure(); // Should not happen based on the condition check
        }
    }
    // For all other patterns
    else {
        matchRegularPattern(graph, root, pattern, patternOp, patternChildren, patternValue, tracing);
    }
}

// Check if a pattern is a special operator/variable capture pattern
// Handles patterns like (and args) where 'and' is the operator and 'args' captures the arguments
isBacktickOperatorPattern(pattern : Sexpr) -> Maybe<Pair<string, string>> {
    switch (pattern) {
        SSList(parts): {
            // Verify pattern structure: list with 2 elements - operator and variable
            if (length(parts) == 2) {
                // First element should be an operator or variable
                firstPart = parts[0];
                secondPart = parts[1];
                
                // Get operator name from first part
                opName = switch (firstPart) {
                    SSOperator(op): Some(op);
                    SSVariable(name): {
                        // Handle backtick syntax like `&&` if needed
                        if (strlen(name) >= 3 && startsWith(name, "`") && endsWith(name, "`")) {
                            Some(substring(name, 1, strlen(name) - 2));
                        } else {
                            // Normal variable that might be an operator name (like "and")
                            Some(name);
                        }
                    }
                    default: None();
                };
                
                // Second part should be a variable name to capture args
                varName = switch (secondPart) {
                    SSVariable(name): Some(name);
                    default: None();
                };
                
                // If we have both parts, return them as a pair
                switch (opName) {
                    Some(op): {
                        switch (varName) {
                            Some(vName): {
                                // Pattern like (and args) or (`&&` args)
                                Some(Pair(op, vName));
                            }
                            None(): None();
                        }
                    }
                    None(): None();
                }
            } else {
                None();
            }
        }
        default: None();
    }
}

// Match a regular (non-special) pattern
matchRegularPattern(graph : OGraph, nodeId : int, pattern : Sexpr, patternOp : string, 
                   patternChildren : [Sexpr], patternValue : OrbitValue, tracing : bool) -> OSexprPatternResult {
    // First, check if this is a backtick operator pattern
    backtickPattern = isBacktickOperatorPattern(pattern);
    
    // Get the ONode for this root
    switch (lookupOClass(graph, nodeId)) {
        Some(oclass): {
            node = oclass.node;
            nodeOp = node.op;
            nodeChildren = node.children;
            
            // Handle backtick operator patterns specially
            switch(backtickPattern) {
                Some(opAndVar): {
                    operatorName = opAndVar.first;
                    varName = opAndVar.second;
                    
                    if (tracing) println("DEBUG: Pattern match for operator '" + operatorName + "' binding '" + varName + "' vs node op: " + nodeOp);
                    
                    // Special case: Check if we're matching a SpecialForm node with the given operator name
                    if (nodeOp == "SpecialForm" && switch(node.value) {
                            OrbitString(formName): formName == operatorName;
                            default: false;
                        }) {
                        
                        if (tracing) println("DEBUG: Matched special form: " + operatorName + ", binding children to: " + varName);
                        
                        // We found a match - bind all children to the variable
                        // For pattern like (and args), bind the entire node to args
                        OSexprPatternSuccess(makeTree1(varName, findORoot(graph, nodeId)));
                    } 
                    // Check if we're matching a normal operator node
                    else if (operatorName == nodeOp) {
                        if (tracing) println("DEBUG: Matched operator: " + operatorName + ", binding children to: " + varName);
                        
                        // Bind the entire node
                        OSexprPatternSuccess(makeTree1(varName, findORoot(graph, nodeId)));
                    } else {
                        if (tracing) println("DEBUG: Operator pattern mismatch: " + operatorName + " vs " + nodeOp);
                        OSexprPatternFailure();
                    }
                }
                None(): {
                    // Not a backtick pattern, handle normally
                    if (tracing) println("DEBUG: Regular pattern match op: " + patternOp + " vs node op: " + nodeOp);
                    
                    // We need exact matches with values
                    if (patternOp == nodeOp && patternValue == node.value) {
                        // Handle regular child matching vs. rest pattern matching
                        if (length(patternChildren) == length(nodeChildren)) {
                            if (tracing) println("DEBUG: Operator and child count match, matching children");
                            // Match all children recursively
                            matchSexprAllChildren(graph, nodeChildren, patternChildren, makeTree(), tracing);
                        } else {
                            if (tracing) println("DEBUG: Child count mismatch: pattern=" + i2s(length(patternChildren)) + ", node=" + i2s(length(nodeChildren)));
                            OSexprPatternFailure();
                        }
                    } else {
                        if (tracing) {
                            println("DEBUG: Operator mismatch: pattern=" + patternOp + ", node=" + nodeOp);
                            println(pattern);
                            println(patternOp);
                            println(nodeOp);
                            printlnONode(node);
                        }
                        OSexprPatternFailure();
                    }
                }
            }
        }
        None(): {
            if (tracing) println("DEBUG: Node not found in graph");
            OSexprPatternFailure();
        }
    }
}

// Helper to print ONode contents for debugging
printlnONode(node : ONode) -> void {
    println("ONode(\"" + node.op + "\", " + i2s(length(node.children)) + " children, " + 
           i2s(length(node.belongsTo)) + " domains, " + orbitValue2String(node.value) + ")");
}

// Helper to get domain ID from a pattern
getSexprDomainId(graph : OGraph, domainPattern : Sexpr, tracing : bool) -> int {
    // In a real implementation, we would need to find existing domain entries
    // This is a simplified approach - in a full implementation, we would use sexp2OGraphWithSubstitution
    domainId = match_Sexpr(domainPattern, graph, tracing);
    
    if (tracing) {
        println("DEBUG: Domain '" + prettySexpr(domainPattern) + "' has ID " + i2s(domainId));
    }
    
    domainId;
}

// Simplified function to add an S-expression to the graph for pattern matching
// In a real implementation, we would use sexp2OGraphWithSubstitution
match_Sexpr(expr : Sexpr, graph : OGraph, tracing : bool) -> int {
    // Use our enhanced decomposition function to get all components
    components = decomposeSexpr(expr);
    nodeType = components.first;
    children = components.second;
    nodeValue = components.third;
    
    // Process based on the node type and value
    if (isONodePrimitive(ONode(nodeType, [], [], nodeValue))) {
        // For primitives, we can directly create and insert the node
        insertONode(graph, ONode(nodeType, [], [], nodeValue));
    } else {
        // For composite nodes, process all children recursively
        childIds = map(children, \child -> match_Sexpr(child, graph, tracing));
        
        if (isTypeAnnotation(expr)) {
            // Special handling for type annotations
            baseId = childIds[0];
            domainId = childIds[1];
            
            // Add the domain to the base node
            addBelongsToONode(graph, baseId, domainId);
            baseId;
        } else {
            // Regular node creation
            insertONode(graph, ONode(nodeType, childIds, [], nodeValue));
        }
    }
}

// Match all children of an operation
matchSexprAllChildren(graph : OGraph, childIds : [int], patterns : [Sexpr], 
                      bindings : Tree<string, int>, tracing : bool) -> OSexprPatternResult {
    if (length(childIds) == 0 && length(patterns) == 0) {
        // All children matched successfully
        OSexprPatternSuccess(bindings);
    } else if (length(childIds) == 0 || length(patterns) == 0) {
        // Mismatched number of children
        OSexprPatternFailure();
    } else {
        // Try to match the first child
        switch (matchSexprPatternAtNode(graph, childIds[0], patterns[0], tracing)) {
            OSexprPatternSuccess(childBindings): {
                // Merge bindings, ensuring consistency
                switch (mergeSexprBindings(graph, bindings, childBindings)) {
                    OSexprPatternSuccess(mergedBindings): {
                        // Continue with remaining children
                        matchSexprAllChildren(graph, tail(childIds), tail(patterns), mergedBindings, tracing);
                    }
                    OSexprPatternFailure(): {
                        OSexprPatternFailure();
                    }
                }
            }
            OSexprPatternFailure(): {
                OSexprPatternFailure();
            }
        }
    }
}

// Merge bindings, ensuring consistency (same variable bound to semantically equivalent nodes)
mergeSexprBindings(graph : OGraph, a : Tree<string, int>, b : Tree<string, int>) -> OSexprPatternResult {
    // Helper to check if two nodes are in the same equivalence class
    areEquivalentNodes = \id1, id2 -> {
        // If they're already in the same equivalence class, they're equivalent
        findORoot(graph, id1) == findORoot(graph, id2);
    };

    result = fold(getTreeKeys(b), OSexprPatternSuccess(a), \acc, key -> {
        switch (acc) {
            OSexprPatternSuccess(bindings): {
                bValue = lookupTreeDef(b, key, -1);
                switch (lookupTree(bindings, key)) {
                    Some(aValue): {
                        // Variable already bound, must be consistent
                        // This is critical for patterns like (+ x x) where the same variable appears multiple times
                        if (areEquivalentNodes(aValue, bValue)) { 
                            // Accept if they're semantically equivalent expressions
                            OSexprPatternSuccess(bindings);
                        } else {
                            OSexprPatternFailure();
                        }
                    }
                    None(): {
                        // New binding
                        OSexprPatternSuccess(setTree(bindings, key, bValue));
                    }
                }
            }
            OSexprPatternFailure(): OSexprPatternFailure();
        }
    });
    
    result;
}