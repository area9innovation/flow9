import tools/orbit/ograph;          // For OGraph operations
import tools/orbit/orbit_types;    // For OrbitValue
import tools/orbit/sexpr/sexpr_types; // For Sexpr types
import tools/orbit/orbit_simple_ograph; // For ographRegistry
import tools/orbit/sexpr/pretty_sexpr; // For pretty printing Sexpr
import tools/orbit/sexpr/ograph2sexpr; // For ograph2Sexpr
import tools/orbit/sexpr/sexpr_ograph_utils; // For utility functions
import string; // For string operations

export {
    // Main pattern matching function for S-expressions
    // Finds all matches of the pattern in the graph and calls the callback for each
    matchOGraphSexprPattern(
        graphName : string,                      // Name of the OGraph to search in
        pattern : Sexpr,                        // Pattern to match (with variables)
        callback : (Tree<string, int>, int) -> void,  // Called for each match with bindings and the e-class ID
        tracing : bool                         // Enable detailed tracing for debugging
    ) -> int;  // Returns the number of matches found
    
    // One-level pattern matcher for SEXpr implementation
    // Returns a Pair containing success (bool) and updated bindings array
    matchSExprNodeOneLevel(
        graph : OGraph,                      // The graph to search in
        nodeId : int,                        // The node to match against
        pattern : Sexpr,                     // The pattern to match
        bindings : [Pair<string, int>],      // Existing variable bindings (variable name â†’ node ID)
        tracing : bool                       // Enable tracing for debugging
    ) -> Pair<bool, [Pair<string, int>]>;    // success, updated bindings
    
    // Internal pattern matching types and functions
    OSexprPatternResult ::= OSexprPatternSuccess, OSexprPatternFailure;
        OSexprPatternSuccess(bindings : Tree<string, int>); // Variable name to node ID
        OSexprPatternFailure();
}

// Main function for pattern matching in an OGraph using S-expressions
matchOGraphSexprPattern(graphName : string, pattern : Sexpr, callback : (Tree<string, int>, int) -> void, tracing : bool) -> int {
    // Get the graph from the registry
    matchCount = ref 0;
    
    if (tracing) println("Pattern matching in graph '" + graphName + "'");
    if (tracing) println("Pattern: " + prettySexpr(pattern));
    
    switch (lookupTree(^ographRegistry, graphName)) {
        Some(graph): {
            if (tracing) println("DEBUG: Calling matchOGraphSexprPattern with graph " + graphName);
            // Strategy: Try to match the pattern starting at each node in the graph
            if (tracing) println("DEBUG: Found graph, traversing nodes");
            traverseOGraph(graph, \nodeIndex, node -> {
                if (tracing) println("DEBUG: Checking node ID: " + i2s(nodeIndex) + ", op: " + node.op);
                
                // Try to match the pattern at this node
                switch (matchSexprPatternAtNode(graph, nodeIndex, pattern, tracing)) {
                    OSexprPatternSuccess(bindings): {
                        if (tracing)  {
                            println("DEBUG: Found match at node ID: " + i2s(nodeIndex));
                            println("DEBUG: Found match with " + i2s(sizeTree(bindings)) + " bindings at eclass ID: " + i2s(findORoot(graph, nodeIndex)));

                            // Debug output - log all bindings
                            iter(getTreeKeys(bindings), \key -> {
                                value = lookupTreeDef(bindings, key, -1);
                                println("  " + key + " = " + i2s(value) + " (" + prettySexpr(ograph2Sexpr(graph, value)) + ")");
                            });
                        }
                        
                        // Call the callback directly with the bindings (eclass IDs) and the e-class ID
                        matchCount := ^matchCount + 1;
                        rootId = findORoot(graph, nodeIndex);
                        callback(bindings, rootId);
                    }
                    OSexprPatternFailure(): {
                        // No match at this node, continue searching
                        if (tracing) println("DEBUG: No match at node ID: " + i2s(nodeIndex));
                    }
                }
            });
            
            if (tracing) println("DEBUG: matchOGraphSexprPattern returned " + i2s(^matchCount) + " matches");
            ^matchCount;
        }
        None(): {
            println("ERROR: OGraph '" + graphName + "' not found");
            0;
        }
    }
}

// Check if a pattern is a negative domain match (!: expr Domain)
isNegativeDomainMatch(pattern : Sexpr) -> bool {
    switch (pattern) {
        SSList(parts): {
            if (length(parts) == 3) {
                parts[0] == SSOperator("!:");
            } else {
                false;
            }
        }
        default: false;
    }
}

// Function to match domain pattern against a node's domains
matchDomainPattern(graph : OGraph, nodeId : int, domainPattern : Sexpr, negated : bool, exprBindings : Tree<string, int>, tracing : bool) -> OSexprPatternResult {
    nodeClass = lookupOClass(graph, nodeId);
    
    switch (nodeClass) {
        Some(oclass): {
            // Get list of domains this node belongs to
            domainIds = oclass.node.belongsTo;
            
            if (tracing) {
                println("DEBUG: Checking domains for node " + i2s(nodeId));
                println("DEBUG: Node belongs to " + i2s(length(domainIds)) + " domains");
                if (negated) println("DEBUG: Using NEGATIVE domain matching");
            }
			if (domainIds == [] && negated) {
				if (tracing) println("DEBUG: No domains found for node " + i2s(nodeId));
				OSexprPatternSuccess(exprBindings);
			} else {
				// Check if the node belongs to the domain
				dm = fold(domainIds, OSexprPatternFailure(), \acc, domainId -> {
					if (acc != OSexprPatternFailure()) acc
					else {
						if (tracing) println("DEBUG: Domain ID: " + i2s(domainId) + prettySexpr(ograph2Sexpr(graph, domainId)));
						res = matchSexprPatternAtNode(graph, domainId, domainPattern, tracing);
						if (negated) {
							switch (res) {
								OSexprPatternSuccess(_): {
									if (tracing) println("DEBUG: Domain ID " + i2s(domainId) + " matches the pattern - negative match failed");
									OSexprPatternFailure();
								}
								OSexprPatternFailure(): {
									if (tracing) println("DEBUG: Domain ID " + i2s(domainId) + " does not match the pattern - negative match succeeded");
									OSexprPatternSuccess(exprBindings);
								}
							}
						} else res;
					}
				});
				switch (dm) {
					OSexprPatternSuccess(childBindings): {
						// Merge bindings, ensuring consistency
						mergeSexprBindings(graph, exprBindings, childBindings);
					}
					OSexprPatternFailure(): {
						OSexprPatternFailure();
					}		
				}
			}
        }
        None(): {
            if (tracing) println("DEBUG: Node not found in graph");
            OSexprPatternFailure();
        }
    }
}

// Match a Sexpr pattern at a specific node
matchSexprPatternAtNode(graph : OGraph, nodeId : int, pattern : Sexpr, tracing : bool) -> OSexprPatternResult {
    root = findORoot(graph, nodeId);
    
    // Use our enhanced decomposition function to get all components
    components = decomposeSexpr(pattern);
    patternOp = components.first;
    patternChildren = components.second;
    patternValue = components.third;
    
    if (tracing) println("DEBUG: Matching pattern with op: " + patternOp + ", at node: " + i2s(root));
    
    // Handle domain patterns (both positive and negative)
    if (isTypeAnnotation(pattern) || isNegativeDomainMatch(pattern)) {
        // Determine if this is a positive or negative domain match
        negated = isNegativeDomainMatch(pattern);
        operator = if (negated) "!:" else ":";
        
        if (tracing) println("DEBUG: Processing " + (if (negated) "negative" else "positive") + 
                           " domain pattern (" + operator + " operator)");
        
        switch (pattern) {
            SSList(parts): {
                // Extract expression and domain from the pattern
                expressionPattern = parts[1];
                domainPattern = parts[2];
                // First match the expression part against this node
                switch (matchSexprPatternAtNode(graph, nodeId, expressionPattern, tracing)) {
                    OSexprPatternSuccess(exprBindings): {
                        // Found a match for the expression part
                        // Now verify domain membership using our extracted function
                        matchDomainPattern(graph, nodeId, domainPattern, negated, exprBindings, tracing);
                    }
                    OSexprPatternFailure(): {
                        if (tracing) println("DEBUG: Expression part of domain pattern didn't match");
                        OSexprPatternFailure();
                    }
                }
            }
            default: OSexprPatternFailure(); // Should not happen if isTypeAnnotation or isNegativeDomainMatch is true
        }
    } 
    // Special case for pattern variables (SSVariable in pattern context)
    else if (switch(pattern) { SSVariable(__): true; default: false; }) {
        switch(pattern) {
            SSVariable(varName): {
                if (varName != "") {
                    // In pattern matching, variables are treated as pattern variables
                    // that can match any node
                    if (tracing) println("DEBUG: Pattern variable " + varName + " binds to node " + i2s(root));
                    OSexprPatternSuccess(makeTree1(varName, root));
                } else {
                    // Handle the case when varName is empty
                    OSexprPatternFailure();
                }
            }
            default: OSexprPatternFailure(); // Should not happen based on the condition check
        }
    }
    // For all other patterns
    else {
        matchRegularPattern(graph, root, pattern, patternOp, patternChildren, patternValue, tracing);
    }
}

// Check if a pattern is a special operator/variable capture pattern
// Handles patterns like (and args) where 'and' is the operator and 'args' captures the arguments
isBacktickOperatorPattern(pattern : Sexpr) -> Maybe<Pair<string, string>> {
    switch (pattern) {
        SSList(parts): {
            // Verify pattern structure: list with 2 elements - operator and variable
            if (length(parts) == 2) {
                // First element should be an operator or variable
                firstPart = parts[0];
                secondPart = parts[1];
                
                // Get operator name from first part
                opName = switch (firstPart) {
                    SSOperator(op): Some(op);
                    SSVariable(name): {
                        // Handle backtick syntax like `&&` if needed
                        if (strlen(name) >= 3 && startsWith(name, "`") && endsWith(name, "`")) {
                            Some(substring(name, 1, strlen(name) - 2));
                        } else {
                            // Normal variable that might be an operator name (like "and")
                            Some(name);
                        }
                    }
                    default: None();
                };
                
                // Second part should be a variable name to capture args
                varName = switch (secondPart) {
                    SSVariable(name): Some(name);
                    default: None();
                };
                
                // If we have both parts, return them as a pair
                switch (opName) {
                    Some(op): {
                        switch (varName) {
                            Some(vName): {
                                // Pattern like (and args) or (`&&` args)
                                Some(Pair(op, vName));
                            }
                            None(): None();
                        }
                    }
                    None(): None();
                }
            } else {
                None();
            }
        }
        default: None();
    }
}

// Match a regular (non-special) pattern
matchRegularPattern(graph : OGraph, nodeId : int, pattern : Sexpr, patternOp : string, 
                   patternChildren : [Sexpr], patternValue : OrbitValue, tracing : bool) -> OSexprPatternResult {
    // First, check if this is a backtick operator pattern
    backtickPattern = isBacktickOperatorPattern(pattern);
    
    // Get the ONode for this root
    switch (lookupOClass(graph, nodeId)) {
        Some(oclass): {
            node = oclass.node;
            nodeOp = node.op;
            nodeChildren = node.children;
            
            // Handle backtick operator patterns specially
            switch(backtickPattern) {
                Some(opAndVar): {
                    operatorName = opAndVar.first;
                    varName = opAndVar.second;
                    
                    if (tracing) println("DEBUG: Pattern match for operator '" + operatorName + "' binding '" + varName + "' vs node op: " + nodeOp);
                    
                    // Special case: Check if we're matching a SpecialForm node with the given operator name
                    if (nodeOp == "SpecialForm" && switch(node.value) {
                            OrbitString(formName): formName == operatorName;
                            default: false;
                        }) {
                        
                        if (tracing) println("DEBUG: Matched special form: " + operatorName + ", binding children to: " + varName);
                        
                        // We found a match - bind all children to the variable
                        // For pattern like (and args), bind the entire node to args
                        OSexprPatternSuccess(makeTree1(varName, findORoot(graph, nodeId)));
                    } 
                    // Check if we're matching a normal operator node
                    else if (operatorName == nodeOp) {
                        if (tracing) println("DEBUG: Matched operator: " + operatorName + ", binding children to: " + varName);
                        
                        // Bind the entire node
                        OSexprPatternSuccess(makeTree1(varName, findORoot(graph, nodeId)));
                    } else {
                        if (tracing) println("DEBUG: Operator pattern mismatch: " + operatorName + " vs " + nodeOp);
                        OSexprPatternFailure();
                    }
                }
                None(): {
                    // Not a backtick pattern, handle normally
                    if (tracing) println("DEBUG: Regular pattern match op: " + patternOp + " vs node op: " + nodeOp);
                    
                    // We need exact matches with values
                    if (patternOp == nodeOp && patternValue == node.value) {
                        // Handle regular child matching vs. rest pattern matching
                        if (length(patternChildren) == length(nodeChildren)) {
                            if (tracing) println("DEBUG: Operator and child count match, matching children");
                            // Match all children recursively
                            matchSexprAllChildren(graph, nodeChildren, patternChildren, makeTree(), tracing);
                        } else {
                            if (tracing) println("DEBUG: Child count mismatch: pattern=" + i2s(length(patternChildren)) + ", node=" + i2s(length(nodeChildren)));
                            OSexprPatternFailure();
                        }
                    } else {
                        if (tracing) {
                            println("DEBUG: Operator mismatch: pattern=" + patternOp + ", node=" + nodeOp);
                            println(pattern);
                            println(patternOp);
                            println(nodeOp);
                            printlnONode(node);
                        }
                        OSexprPatternFailure();
                    }
                }
            }
        }
        None(): {
            if (tracing) println("DEBUG: Node not found in graph");
            OSexprPatternFailure();
        }
    }
}

// Helper to print ONode contents for debugging
printlnONode(node : ONode) -> void {
    println("ONode(\"" + node.op + "\", " + i2s(length(node.children)) + " children, " + 
           i2s(length(node.belongsTo)) + " domains, " + orbitValue2String(node.value) + ")");
}

// Match all children of an operation
matchSexprAllChildren(graph : OGraph, childIds : [int], patterns : [Sexpr], 
                      bindings : Tree<string, int>, tracing : bool) -> OSexprPatternResult {
    if (length(childIds) == 0 && length(patterns) == 0) {
        // All children matched successfully
        OSexprPatternSuccess(bindings);
    } else if (length(childIds) == 0 || length(patterns) == 0) {
        // Mismatched number of children
        OSexprPatternFailure();
    } else {
        // Try to match the first child
        switch (matchSexprPatternAtNode(graph, childIds[0], patterns[0], tracing)) {
            OSexprPatternSuccess(childBindings): {
                // Merge bindings, ensuring consistency
                switch (mergeSexprBindings(graph, bindings, childBindings)) {
                    OSexprPatternSuccess(mergedBindings): {
                        // Continue with remaining children
                        matchSexprAllChildren(graph, tail(childIds), tail(patterns), mergedBindings, tracing);
                    }
                    OSexprPatternFailure(): {
                        OSexprPatternFailure();
                    }
                }
            }
            OSexprPatternFailure(): {
                OSexprPatternFailure();
            }
        }
    }
}

// Merge bindings, ensuring consistency (same variable bound to semantically equivalent nodes)
mergeSexprBindings(graph : OGraph, a : Tree<string, int>, b : Tree<string, int>) -> OSexprPatternResult {
    // Helper to check if two nodes are in the same equivalence class
    areEquivalentNodes = \id1, id2 -> {
        // If they're already in the same equivalence class, they're equivalent
        findORoot(graph, id1) == findORoot(graph, id2);
    };

    result = fold(getTreeKeys(b), OSexprPatternSuccess(a), \acc, key -> {
        switch (acc) {
            OSexprPatternSuccess(bindings): {
                bValue = lookupTreeDef(b, key, -1);
                switch (lookupTree(bindings, key)) {
                    Some(aValue): {
                        // Variable already bound, must be consistent
                        // This is critical for patterns like (+ x x) where the same variable appears multiple times
                        if (areEquivalentNodes(aValue, bValue)) { 
                            // Accept if they're semantically equivalent expressions
                            OSexprPatternSuccess(bindings);
                        } else {
                            OSexprPatternFailure();
                        }
                    }
                    None(): {
                        // New binding
                        OSexprPatternSuccess(setTree(bindings, key, bValue));
                    }
                }
            }
            OSexprPatternFailure(): OSexprPatternFailure();
        }
    });
    
    result;
}

// One-level pattern matcher for SEXpr implementation
// Returns a Pair containing success (bool) and updated bindings array
matchSExprNodeOneLevel(graph : OGraph, nodeId : int, pattern : Sexpr, bindings : [Pair<string, int>], tracing : bool) -> Pair<bool, [Pair<string, int>]> {
    root = findORoot(graph, nodeId);
	switch (pattern) {
		SSVariable(varName): {
			if (varName != "") {
				// Check if this variable is already bound
				existingBinding = find(bindings, \binding -> binding.first == varName);
				
				switch (existingBinding) {
					Some(binding): {
						// Variable is already bound, must be consistent
						if (findORoot(graph, binding.second) == root) {
							// Matched consistently
							if (tracing) println("DEBUG: Consistent binding for " + varName);
							Pair(true, bindings);
						} else {
							// Inconsistent binding
							if (tracing) println("DEBUG: Inconsistent binding for " + varName);
							Pair(false, []);
						}
					}
					None(): {
						// New binding
						if (tracing) println("DEBUG: New binding: " + varName + " = " + i2s(root));
						newBindings = concat(bindings, [Pair(varName, root)]);
						Pair(true, newBindings);
					}
				}
			} else {
				// Empty variable name is not valid
				Pair(false, []);
			}
		}
		default: {
			// Get the ONode for this node
			switch (lookupOClass(graph, root)) {
				Some(oclass): {
					node = oclass.node;
					
					// Use our enhanced decomposition function to get all components
					components = decomposeSexpr(pattern);
					patternOp = components.first;
					patternChildren = components.second;
					patternValue = components.third;
					// Normal pattern matching
					nodeOp = node.op;
					nodeChildren = node.children;
					
					if (patternOp == nodeOp && patternValue == node.value) {
						if (tracing) println("DEBUG: Matching pattern with op: " + patternOp + ", at node: " + i2s(root));
						Pair(true, []);
					} else {
						Pair(false, []);
					}
				}
				None(): {
					if (tracing) println("DEBUG: Node not found in graph");
					Pair(false, []);
				}
			}
		}
	}
}

// Match all children of an operation
matchAllChildrenOneLevel(
    graph : OGraph, 
    childIds : [int], 
    patterns : [Sexpr],
    bindings : [Pair<string, int>],
    tracing : bool
) -> Pair<bool, [Pair<string, int>]> {
    if (length(childIds) == 0 && length(patterns) == 0) {
        // All children matched successfully
        Pair(true, bindings);
    } else if (length(childIds) == 0 || length(patterns) == 0) {
        // Mismatched number of children
        Pair(false, []);
    } else {
        // Try to match the first child
        matchResult = matchSExprNodeOneLevel(graph, childIds[0], patterns[0], bindings, tracing);
        
        if (matchResult.first) {
            // Continue with remaining children
            matchAllChildrenOneLevel(graph, tail(childIds), tail(patterns), matchResult.second, tracing);
        } else {
            Pair(false, []);
        }
    }
}