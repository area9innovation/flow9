import tools/orbit/orbit_types;
import tools/orbit/ograph;
import tools/orbit/types;
import tools/orbit/sexpr/sexpr_types;
import tools/orbit/sexpr/pretty_sexpr;
import tools/orbit/sexpr/sexpr_ograph_utils;
import ds/tree;
import string;

export {
    // Add an Sexpr to an OGraph, substituting variables with existing eclasses
    // and processing type annotations by adding domains to the "belongs to" field
    // Takes a mapping from variable names to eclass IDs for substitution
    // Returns the eclass ID of the added expression
    sexp2OGraphWithSubstitution(graph : OGraph, expr : Sexpr, varToEclass : Tree<string, int>) -> int;
}

// Add an Sexpr to an OGraph with variable substitution and type annotation handling
sexp2OGraphWithSubstitution(graph : OGraph, expr : Sexpr, varToEclass : Tree<string, int>) -> int {
    // Use the enhanced decomposeSexpr to get all components at once
    components = decomposeSexpr(expr);
    nodeType = components.first;
    children = components.second;
    nodeValue = components.third;
    
    if (nodeType == ":") {
        // Special case for type annotation (: expr Domain)
        // Extract the expression and domain
        baseExpr = children[0];
        domain = children[1];
        
        // Process the domain
        domainId = sexp2OGraphWithSubstitution(graph, domain, varToEclass);
        
        // Process the base expression
        baseId = sexp2OGraphWithSubstitution(graph, baseExpr, varToEclass);
        
        // Add the domain to the "belongs to" field of the base node
        addBelongsToONode(graph, baseId, domainId);
        
        // Return the base node ID as the canonical form
        baseId;
    } else if (nodeType == "Identifier") {
        // Handle variable substitution
        varName = switch (nodeValue) { OrbitString(s): s; default: ""; };
        
        // Check if we have a mapping for this identifier
        switch (lookupTree(varToEclass, varName)) {
            Some(eclassId): {
                // Use the provided eclass ID directly
                eclassId;
            }
            None(): {
                // No substitution - add as a normal identifier
                insertONode(graph, ONode(nodeType, [], [], nodeValue));
            }
        }
    } else {
        // For composite nodes (List, Vector, SpecialForm, or operator expressions)
        // Process all children recursively
        childIds = map(children, \child -> {
            sexp2OGraphWithSubstitution(graph, child, varToEclass);
        });
        
        // Create a node with the processed children
        insertONode(graph, ONode(nodeType, childIds, [], nodeValue));
    }
}