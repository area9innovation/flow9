import tools/orbit/sexpr/sexpr_types;
import tools/orbit/sexpr/sexpr_compiled_parser;
import tools/orbit/sexpr/pretty_sexpr;
import tools/orbit/sexpr/eval_sexpr;
import tools/orbit/sexpr/sexpr_stdlib;
import tools/mango/mcode_lib;
import runtime;
import string;

main() {
	// Create initial environment
	env = addStandardFns(makeEnv());
	
	// Test the pretty printer and evaluator with various expressions
	testExpressions(env);
}

// Test various expressions
testExpressions(env : Tree<string, Sexpr>) -> void {
	// Test expressions and their expected printed results
	tests = [
		// Basic literals
		"42",
		"3.14",
		"\"hello\"",
		"true",
		"false",
		
		// Variables and constructors
		"x",
		"Point",
		
		// Lists
		"()",
		"(1 2 3)",
		"(+ 1 2)",
		
		// Quoting
		"'(1 2 3)",
		"`(1 2 $x)",
		
		// Nested expressions
		"(define x 10)",
		"(+ x 5)",
		"(if true 1 2)",
		
		// Pattern matching
		"(match '(1 2 3) (x y z) (+ x y z))",
		
		// QuasiQuoting with unquote and unquote-splicing
		"(define lst '(2 3))",
		"`(1 $lst 4)",
		"`(1 #lst 4)",
		
		// Closure tests
		"(define y 20)",  // Define a variable to capture
		"(define z 30)",  // Another variable to capture
		"(define add-y (lambda (x) (+ x y)))",  // Create a closure capturing y
		"(add-y 5)",  // Should return 25
		"(define y 100)",  // Change y after closure creation
		"(add-y 5)",  // Should still return 25 because closure captured original y
		
		// Nested closure test
		"(define make-adder (lambda (n) (lambda (x) (+ x n))))",
		"(define add10 (make-adder 10))",
		"(define add20 (make-adder 20))",
		"(add10 5)",  // Should return 15
		"(add20 5)",  // Should return 25
		
		// Multiple variable capture
		"(define calculate (lambda (x) (+ x y z)))",  // Captures both y and z
		"(calculate 5)"  // Should use the captured y (100) and z (30)
	];
	
	// Run each test expression using recursion
	runTests(env, tests, 0);
	quit(0);
}

// Recursively run tests
runTests(env : Tree<string, Sexpr>, tests : [string], idx : int) -> void {
	if (idx < length(tests)) {
		test = tests[idx];
		println("\n> " + test);
		
		// Parse the expression
		result = parseSexpr("test#" + i2s(idx), test);
		switch (result) {
			Some(expr): {
				// Print the AST structure
				println("AST: " + prettySexpr(expr));
				
				// Evaluate the expression
				eval_result = evalSexpr(env, expr);
				println("=> " + prettySexpr(eval_result.value));
				
				// Continue with the next test using the updated environment
				runTests(eval_result.env, tests, idx + 1);
			}
			None(): {
				println("Parse error");
				runTests(env, tests, idx + 1); // Continue with unchanged environment
			}
		}
	}
}

// Parse a string into a Sexpr
parseSexpr(f : string, s : string) -> Maybe<Sexpr> {
	res : Pair<Sexpr, string> = parseCompiledMango(f, s, sexpr_parse_sexpr_compiled, flow(0));
	if (res.second != "") {
		println(f + ": " + res.second);
		None()
	} else {
		Some(res.first);
	}
}
