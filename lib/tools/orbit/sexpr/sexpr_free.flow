import tools/orbit/sexpr/sexpr_types;
import ds/set;
import ds/tree;

export {
    // Returns the set of free variables in an S-expression
    findFreeSexprVars(sExpr : Sexpr, boundVars : Set<string>) -> Set<string>;
    
    // Convenience function that starts with an empty set of bound variables
    findFreeSexprVarsInExpr(expr : Sexpr) -> Set<string>;
    
    // Create environment bindings for free variables using current environment
    createSexprBindings(freeVars : Set<string>, env : Tree<string, Sexpr>) -> [Pair<string, Sexpr>];
}

// Main function to find free variables in S-expressions
findFreeSexprVars(sExpr : Sexpr, boundVars : Set<string>) -> Set<string> {
    switch (sExpr) {
        SSBool(__): makeSet();
        SSDouble(__): makeSet();
        SSInt(__): makeSet();
        SSString(__): makeSet();
        SSConstructor(__): makeSet();
        SSOperator(__): makeSet();
        SSVariable(name): {
            // Variables that are not bound are free
            if (containsSet(boundVars, name) || name == "_") makeSet() else makeSet1(name);
        };
        
        SSList(exprs): {
			// Not a special form, process all expressions
			fold(exprs, makeSet(), \acc, e -> {
				mergeSets(acc, findFreeSexprVars(e, boundVars));
			});
        };
		SSSpecialForm(name, exprs): {
			if (name == "lambda" && length(exprs) >= 2) {
				// Lambda form: (lambda (param1 param2...) body)
				paramList = switch (exprs[0]) {
					SSList(params): params;
					default: [];
				};
				
				// Extract parameter names
				paramNames = filtermap(paramList, \param -> {
					switch (param) {
						SSVariable(pname): Some(pname);
						default: None();
					}
				});
				
				// Add parameter names to bound variables
				newBoundVars = fold(paramNames, boundVars, \acc, pname -> {
					insertSet(acc, pname);
				});
				
				// Find free variables in the body (considering parameters as bound)
				if (length(exprs) > 2) {
					findFreeSexprVars(exprs[1], newBoundVars);
				} else {
					makeSet();
				}
			} else if (name == "define" && length(exprs) >= 2) {
				// Define form: (define name value)
				// Only the value can have free variables
				findFreeSexprVars(exprs[1], boundVars);
			} else if (name == "if" && length(exprs) >= 2) {
				// If form: (if condition then-expr else-expr)
				mergeSets(
					findFreeSexprVars(exprs[0], boundVars),
					mergeSets(
						findFreeSexprVars(exprs[1], boundVars),
						if (length(exprs) > 2) findFreeSexprVars(exprs[2], boundVars) else makeSet()
					)
				);
			} else if ((name == "let" || name == "letrec") && length(exprs) >= 2) {
				// Let form: (let ((var1 val1) (var2 val2)...) body)
				// First find free vars in the bindings
				bindingsList = switch (exprs[0]) {
					SSList(bindings): bindings;
					default: [];
				};
				
				// Process each binding
				bindingFreeVars = fold(bindingsList, makeSet(), \acc, binding -> {
					bindingVars = switch (binding) {
						SSList(bindingParts): {
							if (length(bindingParts) >= 2) {
								findFreeSexprVars(bindingParts[1], boundVars);
							} else {
								makeSet();
							}
						};
						default: makeSet();
					};
					mergeSets(acc, bindingVars);
				});
				
				// Extract binding names to add to bound variables for the body
				bindingNames = filtermap(bindingsList, \binding -> {
					switch (binding) {
						SSList(parts): {
							if (length(parts) >= 2) {
								switch (parts[0]) {
									SSVariable(bname): Some(bname);
									default: None();
								}
							} else {
								None();
							}
						};
						default: None();
					}
				});
				
				// Add binding names to bound variables
				newBoundVars = fold(bindingNames, boundVars, \acc, bname -> {
					insertSet(acc, bname);
				});
				
				// Find free variables in the body (considering binding names as bound)
				if (length(exprs) > 1) {
					bodyFreeVars = findFreeSexprVars(exprs[1], newBoundVars);
					mergeSets(bindingFreeVars, bodyFreeVars);
				} else {
					bindingFreeVars;
				}
			} else if ((name == "quote" || name == "'") && length(exprs) >= 1) {
				// Quote form: (quote expr) or 'expr
				// Quoted expressions have no free variables
				makeSet();
			} else if (name == "quasiquote" && length(exprs) == 1) {
				// Quasiquote form: (quasiquote expr)
				// The inner expression can have free variables
	            // In quasiquote, only unquoted expressions can have free variables
    	        findQuasiQuoteFreeVars(exprs[0], boundVars);
			} else if (name == "unquote" && length(exprs) == 1) {
				// Unquote form: (unquote expr)
				 findFreeSexprVars(exprs[0], boundVars);
			} else if (name == "unquote-splicing" && length(exprs) == 1) {
				// Unquote-splicing form: (unquote-splicing expr)
				findFreeSexprVars(exprs[0], boundVars);
			} else if (name == "match" && length(exprs) >= 2) {
				// Match form: (match expr pattern1 result1 pattern2 result2...)
				// The expr and all results can have free variables
				// Patterns can introduce bindings but we'll simplify by treating them as normal expressions
				if (length(exprs) > 1) {
					mergeSets(
						findFreeSexprVars(exprs[0], boundVars),
						fold(tail(exprs), makeSet(), \acc, e -> {
							mergeSets(acc, findFreeSexprVars(e, boundVars));
						})
					);
				} else {
					makeSet();
				}
			} else if (name == "begin") {
				fold(exprs, makeSet(), \acc, e -> {
					mergeSets(acc, findFreeSexprVars(e, boundVars));
				});
			} else {
				println("TODO: Find free in special form: " + name);
				fold(exprs, makeSet(), \acc, e -> {
					mergeSets(acc, findFreeSexprVars(e, boundVars));
				});
			}
		}
    }
}

// Helper to find free variables in quasiquote expressions
findQuasiQuoteFreeVars(sExpr : Sexpr, boundVars : Set<string>) -> Set<string> {
    switch (sExpr) {
        SSList(items): {
            // Process all expressions in the list
            fold(items, makeSet(), \acc, item -> {
                mergeSets(acc, findQuasiQuoteFreeVars(item, boundVars));
            });
        };
		SSSpecialForm(name, exprs): {
			if (name == "unquote" && length(exprs) == 1) {
				findFreeSexprVars(exprs[0], boundVars);
			} else if (name == "unquote-splicing" && length(exprs) == 1) {
				findFreeSexprVars(exprs[0], boundVars);
			} else {
				fold(exprs, makeSet(), \acc, item -> {
					mergeSets(acc, findQuasiQuoteFreeVars(item, boundVars));
				});
			}
		}
        default: makeSet(); // Other expressions in quasiquote have no free variables
    }
}

// Convenience function that starts with an empty set of bound variables
findFreeSexprVarsInExpr(sExpr : Sexpr) -> Set<string> {
    findFreeSexprVars(sExpr, makeSet());
}

// Create environment bindings for free variables using current environment
createSexprBindings(freeVars : Set<string>, env : Tree<string, Sexpr>) -> [Pair<string, Sexpr>] {
    // Convert the set of free variables to an array
    freeVarsArray = set2array(freeVars);
    
    // Create a binding for each free variable that exists in the environment
    filtermap(freeVarsArray, \id -> {
        lookupResult = lookupTree(env, id);
        switch (lookupResult) {
            Some(value): Some(Pair(id, value));
            None(): None();
        }
    });
}