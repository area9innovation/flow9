import tools/orbit/sexpr/sexpr_types;
import tools/orbit/sexpr/pretty_sexpr;
import tools/orbit/sexpr/sexpr_pattern;
import tools/orbit/sexpr/sexpr_quasi;
import tools/orbit/sexpr/sexpr_stdlib;
import tools/orbit/sexpr/utils;
import ds/tree;
import string;
import math/math;

export {
	// Main evaluation function - returns updated environment and value
	evalSexpr(env : Tree<string, Sexpr>, expr : Sexpr) -> SexprResult;

	// Helper to create an empty environment
	makeEnv() -> Tree<string, Sexpr>;
}

// Create an empty environment with standard functions
makeEnv() -> Tree<string, Sexpr> {
	addStandardFns(makeTree());
}

// Evaluate a Sexpr in the given environment
evalSexpr(env : Tree<string, Sexpr>, expr : Sexpr) -> SexprResult {
	switch (expr) {
		// Simple values return unchanged environment
		SSBool(b): SexprResult(env, expr);
		SSDouble(d): SexprResult(env, expr);
		SSInt(i): SexprResult(env, expr);
		SSString(s): SexprResult(env, expr);
		SSConstructor(name): SexprResult(env, expr);
		SSOperator(op): SexprResult(env, expr);

		// Lookup variable in environment
		SSVariable(name): {
			maybe = lookupTree(env, name);
			switch (maybe) {
				Some(value): SexprResult(env, value);
				None(): {
					// Special forms
					specialForms = ["define", "lambda", "if", "quote", "eval", "match", "_"];
					
					// Check if it's a built-in function from the runtime
					runtimeFuncs = getRuntimeFunctions();
					
					if (contains(specialForms, name) || containsKeyTree(runtimeFuncs, name)) {
						// Return the name as is for first-order functions
						SexprResult(env, expr);
					} else {
						// Error handling for undefined variables
						println("Undefined variable: " + name);
						SexprResult(env, expr);
					}
				}
			}
		};

		// Handle quoted expressions - return as is
		SSQuote(quoted): SexprResult(env, quoted);

		// Handle quasi-quoted expressions (backtick) with possible unquoting
		SSQuasiQuote(quoted): {
			result = evalQuasiQuoteExpr(env, quoted);
			SexprResult(result.env, result.value);
		};

		// Evaluate normal expressions
		SSList(exprs): {
			if (length(exprs) == 0) {
				SexprResult(env, expr); // Empty list
			} else {
				// Evaluate the function
				fnResult = evalSexpr(env, exprs[0]);
				// Evaluate the function call
				evalCall(fnResult.env, fnResult.value, tailFrom(exprs, 1));
			}
		};

		// These shouldn't appear directly - only inside quasiquote
		SSUnquote(inner): {
			println("Unquote ($) outside of quasiquote");
			SexprResult(env, expr);
		};
		SSUnquoteSplicing(inner): {
			println("Unquote-splicing (#) outside of quasiquote");
			SexprResult(env, expr);
		};
	}
}

// Helper for quasiquote evaluation
evalQuasiQuoteExpr(env : Tree<string, Sexpr>, expr : Sexpr) -> SexprResult {
	result = evalQuasiQuote(env, expr, \e, x -> {
		eval = evalSexpr(e, x);
		eval.value;
	});
	SexprResult(env, result);
}

// Evaluate a function call
evalCall(env : Tree<string, Sexpr>, fn : Sexpr, args : [Sexpr]) -> SexprResult {
	switch (fn) {
		SSVariable(name): {
			// Handle special forms first
			if (name == "define") {
				// Define a variable
				if (length(args) >= 2) {
					varName = switch (args[0]) {
						SSVariable(n): n;
						default: {
							println("Invalid define syntax");
							"";
						}
					};
					if (varName != "") {
						valueResult = evalSexpr(env, args[1]);
						// Return the updated environment and the value
						newEnv = setTree(valueResult.env, varName, valueResult.value);
						SexprResult(newEnv, valueResult.value);
					} else {
						SexprResult(env, SSList([]));
					}
				} else {
					println("define requires at least 2 arguments");
					SexprResult(env, SSList([]));
				}
			} else if (name == "lambda") {
				// Create a lambda
				if (length(args) >= 2) {
					// Extract parameter list
					paramList = switch (args[0]) {
						SSList(p): p;
						default: {
							println("Lambda params should be a list");
							[];
						}
					};
					// Get the lambda body
					lambdaBody = args[1];
					// Return a lambda constructor
					SexprResult(env, SSConstructor("Lambda"));
				} else {
					println("lambda requires at least 2 arguments");
					SexprResult(env, SSList([]));
				}
			} else if (name == "if") {
				// Conditional
				if (length(args) >= 2) {
					condResult = evalSexpr(env, args[0]);
					isTrue = switch (condResult.value) {
						SSBool(b): b;
						default: true; // Non-false values are true
					};
					if (isTrue) {
						evalSexpr(condResult.env, args[1]);
					} else if (length(args) > 2) {
						evalSexpr(condResult.env, args[2]);
					} else {
						SexprResult(condResult.env, SSList([]));
					}
				} else {
					println("if requires at least 2 arguments");
					SexprResult(env, SSList([]));
				}
			} else if (name == "quote") {
				// Quote expression
				if (length(args) >= 1) {
					SexprResult(env, args[0]);
				} else {
					SexprResult(env, SSList([]));
				}
			} else if (name == "eval") {
				// Evaluate expression
				if (length(args) >= 1) {
					expResult = evalSexpr(env, args[0]);
					evalSexpr(expResult.env, expResult.value);
				} else {
					SexprResult(env, SSList([]));
				}
			} else if (name == "match") {
				// Pattern matching
				if (length(args) >= 3 && (length(args) % 2) == 1) {
					// match value pattern1 result1 pattern2 result2...
					valueResult = evalSexpr(env, args[0]);
					
					// Pass patterns directly to the matching function without evaluation
					patternsAndResults = tailFrom(args, 1);
					
					// Try each pattern in sequence
					matchResult = evalMatch(valueResult.env, valueResult.value, patternsAndResults);
					matchIndex = matchResult.first;
					updatedEnv = matchResult.second;
					
					if (matchIndex != -1) {
						// Found a matching pattern - evaluate the corresponding result
						resultIndex = matchIndex * 2 + 1; // pattern at even indices (0, 2), results at odd (1, 3)
						resultExpr = patternsAndResults[resultIndex];
						// Use the updated environment with bound variables from the pattern match
						evalSexpr(updatedEnv, resultExpr);
					} else {
						println("No pattern matched");
						SexprResult(valueResult.env, SSList([]));
					}
				} else {
					println("match requires value and pattern-result pairs");
					SexprResult(env, SSList([]));
				}
			} else {
				// Regular function call
				// Evaluate arguments first
				fnResult = evalArgs(env, args, [], env);
				
				// Check if it's a runtime function
				if (containsKeyTree(getRuntimeFunctions(), name)) {
					// Invoke the runtime function with arity checking
					invokeRuntimeFn(name, fnResult);
				} else {
					// Custom user-defined function - try to lookup in environment
					maybeFunction = lookupTree(env, name);
					switch (maybeFunction) {
						Some(function): {
							// Apply the function
							applyFunction(fnResult.env, function, fnResult.args);
						};
						None(): {
							println("Unknown function: " + name);
							SexprResult(env, SSList([]));
						};
					}
				}
			}
		};
		
		SSConstructor(name): {
			// In a real implementation, we'd create a constructor instance with args
			fnResult = evalArgs(env, args, [], env);
			SexprResult(fnResult.env, SSList(concat([fn], fnResult.args)));
		};
		
		SSOperator(name): {
			// Handle operators like +, -, *, /, etc.
			fnResult = evalArgs(env, args, [], env);
			// Invoke the runtime function with arity checking
			if (containsKeyTree(getRuntimeFunctions(), name)) {
				invokeRuntimeFn(name, fnResult);
			} else {
				println("Unknown operator: " + name);
				SexprResult(env, SSList([]));
			}
		};
		
		default: {
			println("Not a callable expression: " + prettySexpr(fn));
			SexprResult(env, SSList([]));
		};
	}
}

// Helper to evaluate a list of arguments
evalArgs(env : Tree<string, Sexpr>, args : [Sexpr], acc : [Sexpr], newEnv : Tree<string, Sexpr>) -> FnArgResult {
	if (length(args) == 0) {
		FnArgResult(newEnv, reverseA(acc));
	} else {
		argResult = evalSexpr(newEnv, args[0]);
		evalArgs(env, tailFrom(args, 1), concat([argResult.value], acc), argResult.env);
	}
}

// Apply a function to arguments
applyFunction(env : Tree<string, Sexpr>, fn : Sexpr, args : [Sexpr]) -> SexprResult {
	// In a real implementation, this would handle closures and lambda expressions
	SexprResult(env, SSList([]));
}