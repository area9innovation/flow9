import tools/orbit/sexpr/sexpr_types;
import tools/orbit/sexpr/pretty_sexpr;
import tools/orbit/sexpr/sexpr_pattern;
import tools/orbit/sexpr/sexpr_quasi;
import tools/orbit/sexpr/sexpr_stdlib;
import tools/orbit/sexpr/utils;
import tools/orbit/sexpr/sexpr_free;
import ds/tree;
import string;
import math/math;
import fs/filesystem;
import tools/orbit/sexpr/sexpr_compiled_parser;
import tools/mango/mcode_lib;

export {
	// Main evaluation function - returns updated environment and value
	evalSexpr(env : Tree<string, Sexpr>, expr : Sexpr) -> SexprResult;

	// Helper to create an empty environment
	makeEnv() -> Tree<string, Sexpr>;
}

// Create an empty environment with standard functions
makeEnv() -> Tree<string, Sexpr> {
	addStandardFns(makeTree());
}

// Parse a string into a Sexpr
_parseSexpr(f : string, s : string) -> Maybe<Sexpr> {
	res : Pair<Sexpr, string> = parseCompiledMango(f, s, sexpr_parse_sexpr_compiled, flow(0));
	if (res.second != "") {
		println(f + ": " + res.second);
		None()
	} else {
		Some(res.first);
	}
}

// Helper to handle imports - loads a file and evaluates its contents
importFile(env : Tree<string, Sexpr>, filePath : string) -> SexprResult {
	// Try to find the file in different locations
	searchPaths = [
		filePath, // Direct path
		pathCombine(getCurrentDirectory(), filePath), // Current directory
		"/home/alstrup/area9/flow9/lib/tools/orbit/" + filePath, // Absolute path
	];
	
	// Find the first path that exists
	path = fold(searchPaths, "", \acc, p -> {
		if (acc != "") acc 
		else if (fileExists(p)) p
		else acc;
	});

	// If we found a valid path, read and evaluate the file
	if (path != "") {
		program = getFileContent(path);
		maybe = _parseSexpr(path, program);
		
		switch (maybe) {
			Some(parsedExpr): {
				// If it's a list (sequence), evaluate each expression
				switch (parsedExpr) {
					SSList(expressions): {
						// Evaluate each expression and accumulate the environment
						envResult = fold(expressions, env, \accEnv, expr -> {
							result = evalSexpr(accEnv, expr);
							result.env;
						});
						
						SexprResult(envResult, SSList([]));
					}
					default: {
						// Not a sequence, just evaluate it directly
						evalSexpr(env, parsedExpr);
					}
				}
			}
			None(): {
				println("Error parsing imported file: " + path);
				SexprResult(env, SSList([]));
			}
		}
	} else {
		println("File not found: " + filePath);
		SexprResult(env, SSList([]));
	}
}

// Evaluate a Sexpr in the given environment
evalSexpr(env : Tree<string, Sexpr>, expr : Sexpr) -> SexprResult {
	switch (expr) {
		// Simple values return unchanged environment
		SSBool(b): SexprResult(env, expr);
		SSDouble(d): SexprResult(env, expr);
		SSInt(i): SexprResult(env, expr);
		SSString(s): SexprResult(env, expr);
		SSConstructor(name): SexprResult(env, expr);
		SSOperator(op): SexprResult(env, expr);

		// Lookup variable in environment
		SSVariable(name): {
			maybe = lookupTree(env, name);
			switch (maybe) {
				Some(value): SexprResult(env, value);
				None(): {
					// Special forms
					specialForms = ["define", "lambda", "if", "quote", "eval", "match", "_", "&&", "||", "import"];
					
					// Check if it's a built-in function from the runtime
					runtimeFuncs = getRuntimeFunctions();
					
					if (contains(specialForms, name) || containsKeyTree(runtimeFuncs, name)) {
						// Return the name as is for first-order functions
						SexprResult(env, expr);
					} else {
						// Error handling for undefined variables
						println("Undefined variable: " + name);
						SexprResult(env, expr);
					}
				}
			}
		};

		// Handle quoted expressions - return as is
		SSQuote(quoted): SexprResult(env, quoted);

		// Handle quasi-quoted expressions (backtick) with possible unquoting
		SSQuasiQuote(quoted): {
			result = evalQuasiQuoteExpr(env, quoted);
			SexprResult(result.env, result.value);
		};

		// Evaluate normal expressions
		SSList(exprs): {
			if (length(exprs) == 0) {
				SexprResult(env, expr); // Empty list
			} else if (length(exprs) >= 4 && 
				(switch (exprs[0]) { SSVariable(fnName): fnName == "closure"; default: false; })) {
				// This is a closure expression - return as is without evaluation
				SexprResult(env, expr);
			} else {
				// Evaluate the function
				fnResult = evalSexpr(env, exprs[0]);
				// Evaluate the function call
				evalCall(fnResult.env, fnResult.value, tailFrom(exprs, 1));
			}
		};

		// These shouldn't appear directly - only inside quasiquote
		SSUnquote(inner): {
			println("Unquote ($) outside of quasiquote");
			SexprResult(env, expr);
		};
		SSUnquoteSplicing(inner): {
			println("Unquote-splicing (#) outside of quasiquote");
			SexprResult(env, expr);
		};
	}
}

// Helper for quasiquote evaluation
evalQuasiQuoteExpr(env : Tree<string, Sexpr>, expr : Sexpr) -> SexprResult {
	result = evalQuasiQuote(env, expr, \e, x -> {
		eval = evalSexpr(e, x);
		eval.value;
	});
	SexprResult(env, result);
}

// Evaluate a function call
evalCall(env : Tree<string, Sexpr>, fn : Sexpr, args : [Sexpr]) -> SexprResult {
	switch (fn) {
		// Direct handling of closure objects
		SSList(fnParts): {
			if (length(fnParts) >= 4 && 
				(switch (fnParts[0]) { SSVariable(fnName): fnName == "closure"; default: false; })) {
				// Evaluate arguments first
				fnResult = evalArgs(env, args, [], env);
				// Apply the closure directly
				applyFunction(fnResult.env, fn, fnResult.args);
			} else {
				println("Not a callable list: " + prettySexpr(fn));
				SexprResult(env, SSList([]));
			}
		};
		SSVariable(name): {
			// Handle special forms first
			if (name == "import") {
				// Import form - load and evaluate a file
				if (length(args) == 1) {
					// Get the path as a string
					pathResult = evalSexpr(env, args[0]);
					pathStr = getSString(pathResult.value, "import path");
					
					// Check if we should add .sexp extension if not present
					filePath = if (!strContains(pathStr, ".sexp")) {
						pathStr + ".sexp";
					} else pathStr;
					
					// Process the import
					importFile(pathResult.env, filePath);
				} else {
					println("import requires 1 argument (path)");
					SexprResult(env, SSList([]));
				}
			} else if (name == "define") {
				// Define a variable
				if (length(args) >= 2) {
					varName = switch (args[0]) {
						SSVariable(n): n;
						default: {
							println("Invalid define syntax");
							"";
						}
					};
					if (varName != "") {
						valueResult = evalSexpr(env, args[1]);
						// Return the updated environment and the value
						newEnv = setTree(valueResult.env, varName, valueResult.value);
						SexprResult(newEnv, valueResult.value);
					} else {
						SexprResult(env, SSList([]));
					}
				} else {
					println("define requires at least 2 arguments");
					SexprResult(env, SSList([]));
				}
			} else if (name == "&&") {
				// Short-circuit AND operator
				if (length(args) < 2) {
					println("&& requires at least 2 arguments");
					SexprResult(env, SSBool(true)); // Empty AND is true
				} else {
					// Evaluate the first argument
					firstResult = evalSexpr(env, args[0]);
					isTrue = getSBool(firstResult.value, "&& condition");
					
					if (!isTrue) {
						// Short-circuit: first argument is false, return false without evaluating the rest
						SexprResult(firstResult.env, SSBool(false));
					} else {
						// First argument is true, evaluate the second argument
						if (length(args) == 2) {
							// Only two arguments
							secondResult = evalSexpr(firstResult.env, args[1]);
							isSecondTrue = getSBool(secondResult.value, "&& condition");
							SexprResult(secondResult.env, SSBool(isSecondTrue));
						} else {
							// More than two arguments, recursively evaluate the rest
							// Create a new && expression with the remaining arguments
							restExpr = SSList(concat([SSVariable("&&")], tailFrom(args, 1)));
							evalSexpr(firstResult.env, restExpr);
						}
					}
				}
			} else if (name == "||") {
				// Short-circuit OR operator
				if (length(args) < 2) {
					println("||| requires at least 2 arguments");
					SexprResult(env, SSBool(false)); // Empty OR is false
				} else {
					// Evaluate the first argument
					firstResult = evalSexpr(env, args[0]);
					isTrue = getSBool(firstResult.value, "|| condition");
					
					if (isTrue) {
						// Short-circuit: first argument is true, return true without evaluating the rest
						SexprResult(firstResult.env, SSBool(true));
					} else {
						// First argument is false, evaluate the second argument
						if (length(args) == 2) {
							// Only two arguments
							secondResult = evalSexpr(firstResult.env, args[1]);
							isSecondTrue = getSBool(secondResult.value, "|| condition");
							SexprResult(secondResult.env, SSBool(isSecondTrue));
						} else {
							// More than two arguments, recursively evaluate the rest
							// Create a new || expression with the remaining arguments
							restExpr = SSList(concat([SSVariable("||")], tailFrom(args, 1)));
							evalSexpr(firstResult.env, restExpr);
						}
					}
				}
			} else if (name == "lambda") {
				// Create a lambda with proper closure capturing free variables
				if (length(args) >= 2) {
					// Extract parameter list
					paramList = switch (args[0]) {
						SSList(p): p;
						default: {
							println("Lambda params should be a list");
							[];
						}
					};
					// Extract parameter names
					paramNames = filtermap(paramList, \param -> {
						switch (param) {
							SSVariable(pname): Some(pname);
							default: None();
						}
					});
					
					// Get the lambda body
					lambdaBody = args[1];
					
					// Find bound vars (the parameters)
					boundVars = fold(paramNames, makeSet(), \acc, paramName -> {
						insertSet(acc, paramName);
					});
					
					// Find free variables in the lambda body
					freeVars = findFreeSexprVars(lambdaBody, boundVars);
					
					// Create bindings for all free variables
					bindings = createSexprBindings(freeVars, env);
					
					// Create a closure as a SSList with special form: (closure bindings params body)
					bindingsList = SSList(map(bindings, \binding -> {
						SSList([SSVariable(binding.first), binding.second]);
					}));
					
					// Return the closure as a list: (closure bindings params body)
					closure = SSList([
						SSVariable("closure"),
						bindingsList,
						args[0],  // Original parameter list
						lambdaBody
					]);
					
					SexprResult(env, closure);
				} else {
					println("lambda requires at least 2 arguments");
					SexprResult(env, SSList([]));
				}
			} else if (name == "if") {
				// Conditional
				if (length(args) >= 2) {
					condResult = evalSexpr(env, args[0]);
					isTrue = switch (condResult.value) {
						SSBool(b): b;
						default: true; // Non-false values are true
					};
					if (isTrue) {
						evalSexpr(condResult.env, args[1]);
					} else if (length(args) > 2) {
						evalSexpr(condResult.env, args[2]);
					} else {
						SexprResult(condResult.env, SSList([]));
					}
				} else {
					println("if requires at least 2 arguments");
					SexprResult(env, SSList([]));
				}
			} else if (name == "quote") {
				// Quote expression
				if (length(args) >= 1) {
					SexprResult(env, args[0]);
				} else {
					SexprResult(env, SSList([]));
				}
			} else if (name == "eval") {
				// Evaluate expression
				if (length(args) >= 1) {
					expResult = evalSexpr(env, args[0]);
					evalSexpr(expResult.env, expResult.value);
				} else {
					SexprResult(env, SSList([]));
				}
			} else if (name == "match") {
				// Pattern matching
				if (length(args) >= 3 && (length(args) % 2) == 1) {
					// match value pattern1 result1 pattern2 result2...
					valueResult = evalSexpr(env, args[0]);
					
					// Pass patterns directly to the matching function without evaluation
					patternsAndResults = tailFrom(args, 1);
					
					// Try each pattern in sequence
					matchResult = evalMatch(valueResult.env, valueResult.value, patternsAndResults);
					matchIndex = matchResult.first;
					updatedEnv = matchResult.second;
					
					if (matchIndex != -1) {
						// Found a matching pattern - evaluate the corresponding result
						resultIndex = matchIndex * 2 + 1; // pattern at even indices (0, 2), results at odd (1, 3)
						resultExpr = patternsAndResults[resultIndex];
						// Use the updated environment with bound variables from the pattern match
						evalSexpr(updatedEnv, resultExpr);
					} else {
						println("No pattern matched");
						SexprResult(valueResult.env, SSList([]));
					}
				} else {
					println("match requires value and pattern-result pairs");
					SexprResult(env, SSList([]));
				}
			} else {
				// Regular function call
				// Evaluate arguments first
				fnResult = evalArgs(env, args, [], env);
				
				// Check if it's a runtime function
				if (containsKeyTree(getRuntimeFunctions(), name)) {
					// Invoke the runtime function with arity checking
					invokeRuntimeFn(name, fnResult);
				} else {
					// Custom user-defined function - try to lookup in environment
					maybeFunction = lookupTree(env, name);
					switch (maybeFunction) {
						Some(function): {
							// Found function in environment
							// Apply the function
							applyFunction(fnResult.env, function, fnResult.args);
						};
						None(): {
							println("Unknown function: " + name);
							SexprResult(env, SSList([]));
						};
					}
				}
			}
		};
		
		SSConstructor(name): {
			// In a real implementation, we'd create a constructor instance with args
			fnResult = evalArgs(env, args, [], env);
			SexprResult(fnResult.env, SSList(concat([fn], fnResult.args)));
		};
		
		SSOperator(name): {
			// Handle operators like +, -, *, /, etc.
			fnResult = evalArgs(env, args, [], env);
			// Invoke the runtime function with arity checking
			if (containsKeyTree(getRuntimeFunctions(), name)) {
				invokeRuntimeFn(name, fnResult);
			} else {
				println("Unknown operator: " + name);
				SexprResult(env, SSList([]));
			}
		};
		
		default: {
			println("Not a callable expression: " + prettySexpr(fn));
			SexprResult(env, SSList([]));
		};
	}
}

// Helper to evaluate a list of arguments
evalArgs(env : Tree<string, Sexpr>, args : [Sexpr], acc : [Sexpr], newEnv : Tree<string, Sexpr>) -> FnArgResult {
	if (length(args) == 0) {
		FnArgResult(newEnv, reverseA(acc));
	} else {
		argResult = evalSexpr(newEnv, args[0]);
		evalArgs(env, tailFrom(args, 1), concat([argResult.value], acc), argResult.env);
	}
}

// Apply a function to arguments
applyFunction(env : Tree<string, Sexpr>, fn : Sexpr, args : [Sexpr]) -> SexprResult {
	switch (fn) {
		SSList(fnParts): {
			// Check if this is a closure: (closure bindings params body)
			if (length(fnParts) >= 4 && 
				(switch (fnParts[0]) { SSVariable(fnName): fnName == "closure"; default: false; })) {
				
				// Extract closure components
				bindings = switch (fnParts[1]) {
					SSList(bindingPairs): bindingPairs;
					default: [];
				};
				
				params = switch (fnParts[2]) {
					SSList(paramList): paramList;
					default: [];
				};
				
				body = fnParts[3];
				
				// Create new environment with bindings from the closure
				callEnv = fold(bindings, env, \accEnv, binding -> {
					switch (binding) {
						SSList(bindingParts): {
							if (length(bindingParts) >= 2) {
								varName = switch (bindingParts[0]) {
									SSVariable(bindingName): bindingName;
									default: "";
								};
								
								if (varName != "") {
									setTree(accEnv, varName, bindingParts[1]);
								} else {
									accEnv;
								}
							} else {
								accEnv;
							}
						};
						default: accEnv;
					}
				});
				
				// Bind arguments to parameters
				finalEnv = foldi(args, callEnv, \i, accEnv, arg -> {
					if (i < length(params)) {
						paramName = switch (params[i]) {
							SSVariable(pName): pName;
							default: "";
						};
						
						if (paramName != "") {
							setTree(accEnv, paramName, arg);
						} else {
							accEnv;
						}
					} else {
						accEnv;
					}
				});
				
				// Evaluate body in the environment with bindings and arguments
				evalSexpr(finalEnv, body);
			} else {
				// Not a recognized function form
				println("Not a callable function: " + prettySexpr(fn));
				SexprResult(env, SSList([]));
			}
		};
		default: {
			println("Not a callable function: " + prettySexpr(fn));
			SexprResult(env, SSList([]));
		};
	}
}