import tools/orbit/sexpr/sexpr_types;
import tools/orbit/sexpr/pretty_sexpr;
import tools/orbit/sexpr/sexpr_pattern;
import ds/tree;
import string;
import math/math;

export {
	// Result of evaluation is a pair of (new environment, result value)
	SexprResult(env : Tree<string, Sexpr>, value : Sexpr);

	// Result of evaluating function arguments
	FnArgResult(env : Tree<string, Sexpr>, args : [Sexpr]);

	// Add standard functions/variables to the environment
	addStandardFns(env : Tree<string, Sexpr>) -> Tree<string, Sexpr>;

	// Basic operations
	addNumbers(evalResult : FnArgResult) -> SexprResult;
	subtractNumbers(evalResult : FnArgResult) -> SexprResult;
	multiplyNumbers(evalResult : FnArgResult) -> SexprResult;
	divideNumbers(evalResult : FnArgResult) -> SexprResult;
	equalsCheck(evalResult : FnArgResult) -> SexprResult;
	
	// List operations
	carFunction(evalResult : FnArgResult) -> SexprResult;
	cdrFunction(evalResult : FnArgResult) -> SexprResult;
	consFunction(evalResult : FnArgResult) -> SexprResult;
	printFunction(evalResult : FnArgResult) -> SexprResult;
}

// Add standard functions/variables to the environment
addStandardFns(env : Tree<string, Sexpr>) -> Tree<string, Sexpr> {
	// Add other built-in functions in a real implementation
	env;
}

// Helper functions for basic operations

// Add numbers
addNumbers(evalResult : FnArgResult) -> SexprResult {
	result = fold(evalResult.args, SSInt(0), \acc, arg -> {
		switch (acc) {
			SSInt(accInt): {
				switch (arg) {
					SSInt(argInt): SSInt(accInt + argInt);
					SSDouble(argDouble): SSDouble(i2d(accInt) + argDouble);
					default: {
						println("Cannot add non-number: " + prettySexpr(arg));
						acc;
					}
				}
			};
			SSDouble(accDouble): {
				switch (arg) {
					SSInt(argInt): SSDouble(accDouble + i2d(argInt));
					SSDouble(argDouble): SSDouble(accDouble + argDouble);
					default: {
						println("Cannot add non-number: " + prettySexpr(arg));
						acc;
					}
				}
			};
			default: acc;
		}
	});
	
	SexprResult(evalResult.env, result);
}

// Subtract numbers
subtractNumbers(evalResult : FnArgResult) -> SexprResult {
	if (length(evalResult.args) == 0) {
		SexprResult(evalResult.env, SSInt(0));
	} else {
		// Get first arg
		first = evalResult.args[0];
		
		// If only one argument, negate it
		if (length(evalResult.args) == 1) {
			result = switch (first) {
				SSInt(i): SSInt(-i);
				SSDouble(d): SSDouble(-d);
				default: {
					println("Cannot negate non-number: " + prettySexpr(first));
					first;
				};
			};
			SexprResult(evalResult.env, result);
		} else {
			// Subtract rest from first
			rest = tailFrom(evalResult.args, 1);
			result = fold(rest, first, \acc, arg -> {
				switch (acc) {
					SSInt(accInt): {
						switch (arg) {
							SSInt(argInt): SSInt(accInt - argInt);
							SSDouble(argDouble): SSDouble(i2d(accInt) - argDouble);
							default: {
								println("Cannot subtract non-number: " + prettySexpr(arg));
								acc;
							}
						}
					};
					SSDouble(accDouble): {
						switch (arg) {
							SSInt(argInt): SSDouble(accDouble - i2d(argInt));
							SSDouble(argDouble): SSDouble(accDouble - argDouble);
							default: {
								println("Cannot subtract non-number: " + prettySexpr(arg));
								acc;
							}
						}
					};
					default: acc;
				}
			});
			SexprResult(evalResult.env, result);
		}
	}
}

// Multiply numbers
multiplyNumbers(evalResult : FnArgResult) -> SexprResult {
	result = fold(evalResult.args, SSInt(1), \acc, arg -> {
		switch (acc) {
			SSInt(accInt): {
				switch (arg) {
					SSInt(argInt): SSInt(accInt * argInt);
					SSDouble(argDouble): SSDouble(i2d(accInt) * argDouble);
					default: {
						println("Cannot multiply non-number: " + prettySexpr(arg));
						acc;
					}
				}
			};
			SSDouble(accDouble): {
				switch (arg) {
					SSInt(argInt): SSDouble(accDouble * i2d(argInt));
					SSDouble(argDouble): SSDouble(accDouble * argDouble);
					default: {
						println("Cannot multiply non-number: " + prettySexpr(arg));
						acc;
					}
				}
			};
			default: acc;
		}
	});
	
	SexprResult(evalResult.env, result);
}

// Divide numbers
divideNumbers(evalResult : FnArgResult) -> SexprResult {
	if (length(evalResult.args) == 0) {
		SexprResult(evalResult.env, SSInt(1));
	} else {
		// Get first arg
		first = evalResult.args[0];
		
		// If only one argument, invert it (1/x)
		if (length(evalResult.args) == 1) {
			result = switch (first) {
				SSInt(i): {
					if (i != 0) SSDouble(1.0 / i2d(i)) else {
						println("Division by zero");
						SSDouble(0.0);
					}
				};
				SSDouble(d): {
					if (d != 0.0) SSDouble(1.0 / d) else {
						println("Division by zero");
						SSDouble(0.0);
					}
				};
				default: {
					println("Cannot invert non-number: " + prettySexpr(first));
					first;
				};
			};
			SexprResult(evalResult.env, result);
		} else {
			// Divide first by rest
			rest = tailFrom(evalResult.args, 1);
			result = fold(rest, first, \acc, arg -> {
				switch (acc) {
					SSInt(accInt): {
						switch (arg) {
							SSInt(argInt): {
								if (argInt != 0) {
									// Convert to double for division
									SSDouble(i2d(accInt) / i2d(argInt));
								} else {
									println("Division by zero");
									acc;
								}
							};
							SSDouble(argDouble): {
								if (argDouble != 0.0) {
									SSDouble(i2d(accInt) / argDouble);
								} else {
									println("Division by zero");
									acc;
								}
							};
							default: {
								println("Cannot divide by non-number: " + prettySexpr(arg));
								acc;
							};
						}
					};
					SSDouble(accDouble): {
						switch (arg) {
							SSInt(argInt): {
								if (argInt != 0) {
									SSDouble(accDouble / i2d(argInt));
								} else {
									println("Division by zero");
									acc;
								}
							};
							SSDouble(argDouble): {
								if (argDouble != 0.0) {
									SSDouble(accDouble / argDouble);
								} else {
									println("Division by zero");
									acc;
								}
							};
							default: {
								println("Cannot divide by non-number: " + prettySexpr(arg));
								acc;
							};
						}
					};
					default: acc;
				}
			});
			SexprResult(evalResult.env, result);
		}
	}
}

// Equality check
equalsCheck(evalResult : FnArgResult) -> SexprResult {
	if (length(evalResult.args) < 2) {
		SexprResult(evalResult.env, SSBool(true));
	} else {
		// Get first arg
		first = evalResult.args[0];
		
		// Check if all arguments are equal to the first
		rest = tailFrom(evalResult.args, 1);
		allEqual = fold(rest, true, \acc, arg -> {
			if (!acc) false else {
				sexprEquals(first, arg);
			}
		});
		
		SexprResult(evalResult.env, SSBool(allEqual));
	}
}

// List operations

carFunction(evalResult : FnArgResult) -> SexprResult {
	if (length(evalResult.args) != 1) {
		SexprResult(evalResult.env, SSList([]));
	} else {
		eval_arg = evalResult.args[0];
		switch (eval_arg) {
			SSList(items): {
				if (length(items) > 0) {
					SexprResult(evalResult.env, items[0]);
				} else {
					println("car: empty list");
					SexprResult(evalResult.env, SSList([]));
				}
			};
			default: {
				println("car requires a list argument");
				SexprResult(evalResult.env, SSList([]));
			};
		}
	}
}

cdrFunction(evalResult : FnArgResult) -> SexprResult {
	if (length(evalResult.args) != 1) {
		SexprResult(evalResult.env, SSList([]));
	} else {
		eval_arg = evalResult.args[0];
		switch (eval_arg) {
			SSList(items): {
				if (length(items) > 0) {
					SexprResult(evalResult.env, SSList(tailFrom(items, 1)));
				} else {
					SexprResult(evalResult.env, SSList([]));
				}
			};
			default: {
				println("cdr requires a list argument");
				SexprResult(evalResult.env, SSList([]));
			};
		}
	}
}

consFunction(evalResult : FnArgResult) -> SexprResult {
	if (length(evalResult.args) != 2) {
		SexprResult(evalResult.env, SSList([]));
	} else {
		elem = evalResult.args[0];
		rest = evalResult.args[1];
		
		switch (rest) {
			SSList(items): {
				SexprResult(evalResult.env, SSList(concat([elem], items)));
			};
			default: {
				// In Scheme, cons can create pairs, but for simplicity
				// we'll just create a list
				SexprResult(evalResult.env, SSList([elem, rest]));
			};
		}
	}
}

// Print function
printFunction(evalResult : FnArgResult) -> SexprResult {
	// Evaluate and print args recursively
	printArgs(evalResult.args, 0);

	SexprResult(evalResult.env, SSList([])); // Default result
}

// Helper for print function
printArgs(args : [Sexpr], idx : int) -> void {
	if (idx >= length(args)) {
	} else {
		// Print it
		println(prettySexpr(args[idx]));
		
		if (idx < length(args) - 1) {
			// Continue with the next argument
			printArgs(args, idx + 1);
		}
	}
}
