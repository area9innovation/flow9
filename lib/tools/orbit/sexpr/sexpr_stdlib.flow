import tools/orbit/sexpr/env;
import tools/orbit/sexpr/pretty_sexpr;
import tools/orbit/sexpr/sexpr_pattern;
import tools/orbit/sexpr/utils;
import ds/tree;
import string;
import math/math;
import net/url_parameter; // For command line args

export {
	// Add standard functions/variables to the environment
	getRuntimeEnv() -> SExpEnv;
	// Helper for invoking runtime functions with arity checking
	invokeRuntimeFn(env : SExpEnv, name : string, result : FnArgResult) -> SExpEnv;
}

getRuntimeEnv() -> SExpEnv {
	SExpEnv(getRuntimeFunctions(), addStandardFns(makeTree()), SSList([]));
}

// Helper for invoking runtime functions with arity checking
invokeRuntimeFn(env : SExpEnv, name : string, result : FnArgResult) -> SExpEnv {
	maybe = lookupTree(env.runtime, name);
	switch (maybe) {
		Some(runtimeFn): {
			// Check arity if expected value is not -1 (variable arity)
			if (runtimeFn.arity != -1 && length(result.args) != runtimeFn.arity) {
				println("ERROR: " + name + " expects " + i2s(runtimeFn.arity) + " arguments, got " + i2s(length(result.args)));
				SExpEnv(env with value = SSList([]));
			} else {
				// Invoke the function implementation
				SExpEnv(env with value = runtimeFn.fn(result));
			}
		}
		None(): {
			println("ERROR: Unknown runtime function: " + name);
			SExpEnv(env with value = SSList([]));
		}
	}
}

// Get the runtime functions map
getRuntimeFunctions() -> Tree<string, RuntimeFn> {
	functionPairs = [
		// Arithmetic operators
		Pair("+", RuntimeFn(-1, \result -> addNumbers(result))),
		Pair("-", RuntimeFn(-1, \result -> subtractNumbers(result))),
		Pair("*", RuntimeFn(-1, \result -> multiplyNumbers(result))),
		Pair("/", RuntimeFn(-1, \result -> divideNumbers(result))),
		Pair("=", RuntimeFn(2, \result -> equalsCheck(result))),
		
		// List operations
		Pair("list", RuntimeFn(-1, \result -> SSList(result.args))),
		Pair("car", RuntimeFn(1, \result -> carFunction(result))),
		Pair("cdr", RuntimeFn(1, \result -> cdrFunction(result))),
		Pair("cons", RuntimeFn(2, \result -> consFunction(result))),
		Pair("print", RuntimeFn(-1, \result -> printFunction(result))),
		
		// Math functions
		Pair("abs", RuntimeFn(1, \result -> absFunction(result))),
		Pair("iabs", RuntimeFn(1, \result -> iabsFunction(result))),
		Pair("sin", RuntimeFn(1, \result -> sinFunction(result))),
		Pair("cos", RuntimeFn(1, \result -> cosFunction(result))),
		Pair("tan", RuntimeFn(1, \result -> tanFunction(result))),
		Pair("asin", RuntimeFn(1, \result -> asinFunction(result))),
		Pair("acos", RuntimeFn(1, \result -> acosFunction(result))),
		Pair("atan", RuntimeFn(1, \result -> atanFunction(result))),
		Pair("atan2", RuntimeFn(2, \result -> atan2Function(result))),
		Pair("sqrt", RuntimeFn(1, \result -> sqrtFunction(result))),
		Pair("exp", RuntimeFn(1, \result -> expFunction(result))),
		Pair("log", RuntimeFn(1, \result -> logFunction(result))),
		Pair("log10", RuntimeFn(1, \result -> log10Function(result))),
		Pair("floor", RuntimeFn(1, \result -> floorFunction(result))),
		Pair("ceil", RuntimeFn(1, \result -> ceilFunction(result))),
		Pair("round", RuntimeFn(1, \result -> roundFunction(result))),
		Pair("dfloor", RuntimeFn(1, \result -> dfloorFunction(result))),
		Pair("dceil", RuntimeFn(1, \result -> dceilFunction(result))),
		Pair("dround", RuntimeFn(1, \result -> droundFunction(result))),
		Pair("sign", RuntimeFn(1, \result -> signFunction(result))),
		Pair("isign", RuntimeFn(1, \result -> isignFunction(result))),
		Pair("even", RuntimeFn(1, \result -> evenFunction(result))),
		Pair("odd", RuntimeFn(1, \result -> oddFunction(result))),
		Pair("mod", RuntimeFn(2, \result -> modFunction(result))),
		Pair("dmod", RuntimeFn(2, \result -> dmodFunction(result))),
		Pair("factorial", RuntimeFn(1, \result -> factorialFunction(result))),
		Pair("gcd", RuntimeFn(2, \result -> gcdFunction(result))),
		Pair("lcm", RuntimeFn(2, \result -> lcmFunction(result))),
		
		// Logic functions
		Pair("not", RuntimeFn(1, \result -> notFunction(result))),
		
		// String operations
		Pair("strlen", RuntimeFn(1, \result -> strlenFunction(result))),
		Pair("substring", RuntimeFn(3, \result -> substringFunction(result))),
		Pair("strIndex", RuntimeFn(2, \result -> strIndexFunction(result))),
		Pair("strContainsAt", RuntimeFn(3, \result -> strContainsAtFunction(result))),
		Pair("parseHex", RuntimeFn(1, \result -> parseHexFunction(result))),
		Pair("unescape", RuntimeFn(1, \result -> unescapeFunction(result))),
		Pair("escape", RuntimeFn(1, \result -> escapeFunction(result))),
		Pair("strGlue", RuntimeFn(2, \result -> strGlueFunction(result))),
		Pair("capitalize", RuntimeFn(1, \result -> capitalizeFunction(result))),
		Pair("decapitalize", RuntimeFn(1, \result -> decapitalizeFunction(result))),
		
		// Type conversions
		Pair("i2s", RuntimeFn(1, \result -> i2sFunction(result))),
		Pair("d2s", RuntimeFn(1, \result -> d2sFunction(result))),
		Pair("i2b", RuntimeFn(1, \result -> i2bFunction(result))),
		Pair("b2i", RuntimeFn(1, \result -> b2iFunction(result))),
		Pair("s2i", RuntimeFn(1, \result -> s2iFunction(result))),
		Pair("s2d", RuntimeFn(1, \result -> s2dFunction(result))),
		
		// Type checking
		Pair("isBool", RuntimeFn(1, \result -> isBoolFunction(result))),
		Pair("isInt", RuntimeFn(1, \result -> isIntFunction(result))),
		Pair("isDouble", RuntimeFn(1, \result -> isDoubleFunction(result))),
		Pair("isString", RuntimeFn(1, \result -> isStringFunction(result))),
		Pair("isArray", RuntimeFn(1, \result -> isArrayFunction(result))),
		
		// Array/list operations
		Pair("length", RuntimeFn(1, \result -> lengthFunction(result))),
		Pair("index", RuntimeFn(2, \result -> indexFunction(result))),
		Pair("subrange", RuntimeFn(3, \result -> subrangeFunction(result))),
		Pair("reverse", RuntimeFn(1, \result -> reverseFunction(result))),
		
		// New functions (ported from orbit)
		Pair("prettySexpr", RuntimeFn(1, \result -> prettySexprFunction(result))),
		Pair("astname", RuntimeFn(1, \result -> astnameFunction(result))),
		Pair("varname", RuntimeFn(1, \result -> varnameFunction(result))),
		Pair("getFileContent", RuntimeFn(1, \result -> getFileContentFunction(result))),
		Pair("setFileContent", RuntimeFn(2, \result -> setFileContentFunction(result))),
		Pair("getCommandLineArgs", RuntimeFn(0, \result -> getCommandLineArgsFunction(result))),
		Pair("parseSexpr", RuntimeFn(1, \result -> parseSexprFunction(result))),
		Pair("uid", RuntimeFn(1, \result -> uidFunction(result)))
	];
	
	pairs2tree(functionPairs);
}

// Add standard functions/variables to the environment
addStandardFns(env : Tree<string, Sexpr>) -> Tree<string, Sexpr> {
	// Get runtime functions registry
	runtimeFunctions = getTreeKeys(getRuntimeFunctions());
	
	// Add operators as operators
	env1 = setTree(env, "+", SSOperator("+"));
	env2 = setTree(env1, "-", SSOperator("-"));
	env3 = setTree(env2, "*", SSOperator("*"));
	env4 = setTree(env3, "/", SSOperator("/"));
	env5 = setTree(env4, "=", SSOperator("="));
	
	// Add other functions as variables
	fold(runtimeFunctions, env5, \acc, name -> {
		if (name == "+" || name == "-" || name == "*" || name == "/" || name == "=") {
			// Already added as operators
			acc;
		} else {
			setTree(acc, name, SSVariable(name));
		}
	});
}

// Helper functions for basic operations

// Add numbers
addNumbers(evalResult : FnArgResult) -> Sexpr {
	fold(evalResult.args, SSInt(0), \acc, arg -> {
		switch (acc) {
			SSInt(accInt): {
				switch (arg) {
					SSInt(argInt): SSInt(accInt + argInt);
					SSDouble(argDouble): SSDouble(i2d(accInt) + argDouble);
					default: {
						println("Cannot add non-number: " + prettySexpr(arg));
						acc;
					}
				}
			};
			SSDouble(accDouble): {
				switch (arg) {
					SSInt(argInt): SSDouble(accDouble + i2d(argInt));
					SSDouble(argDouble): SSDouble(accDouble + argDouble);
					default: {
						println("Cannot add non-number: " + prettySexpr(arg));
						acc;
					}
				}
			};
			default: acc;
		}
	});
}

// Subtract numbers
subtractNumbers(evalResult : FnArgResult) -> Sexpr {
	if (length(evalResult.args) == 0) {
		SSInt(0);
	} else {
		// Get first arg
		first = evalResult.args[0];
		
		// If only one argument, negate it
		if (length(evalResult.args) == 1) {
			switch (first) {
				SSInt(i): SSInt(-i);
				SSDouble(d): SSDouble(-d);
				default: {
					println("Cannot negate non-number: " + prettySexpr(first));
					first;
				};
			};
		} else {
			// Subtract rest from first
			rest = tailFrom(evalResult.args, 1);
			fold(rest, first, \acc, arg -> {
				switch (acc) {
					SSInt(accInt): {
						switch (arg) {
							SSInt(argInt): SSInt(accInt - argInt);
							SSDouble(argDouble): SSDouble(i2d(accInt) - argDouble);
							default: {
								println("Cannot subtract non-number: " + prettySexpr(arg));
								acc;
							}
						}
					};
					SSDouble(accDouble): {
						switch (arg) {
							SSInt(argInt): SSDouble(accDouble - i2d(argInt));
							SSDouble(argDouble): SSDouble(accDouble - argDouble);
							default: {
								println("Cannot subtract non-number: " + prettySexpr(arg));
								acc;
							}
						}
					};
					default: acc;
				}
			});
		}
	}
}

// Multiply numbers
multiplyNumbers(evalResult : FnArgResult) -> Sexpr {
	fold(evalResult.args, SSInt(1), \acc, arg -> {
		switch (acc) {
			SSInt(accInt): {
				switch (arg) {
					SSInt(argInt): SSInt(accInt * argInt);
					SSDouble(argDouble): SSDouble(i2d(accInt) * argDouble);
					default: {
						println("Cannot multiply non-number: " + prettySexpr(arg));
						acc;
					}
				}
			};
			SSDouble(accDouble): {
				switch (arg) {
					SSInt(argInt): SSDouble(accDouble * i2d(argInt));
					SSDouble(argDouble): SSDouble(accDouble * argDouble);
					default: {
						println("Cannot multiply non-number: " + prettySexpr(arg));
						acc;
					}
				}
			};
			default: acc;
		}
	});
}

// Divide numbers
divideNumbers(evalResult : FnArgResult) -> Sexpr {
	if (length(evalResult.args) == 0) {
		SSInt(1);
	} else {
		// Get first arg
		first = evalResult.args[0];
		
		// If only one argument, invert it (1/x)
		if (length(evalResult.args) == 1) {
			switch (first) {
				SSInt(i): {
					if (i != 0) SSDouble(1.0 / i2d(i)) else {
						println("Division by zero");
						SSDouble(0.0);
					}
				};
				SSDouble(d): {
					if (d != 0.0) SSDouble(1.0 / d) else {
						println("Division by zero");
						SSDouble(0.0);
					}
				};
				default: {
					println("Cannot invert non-number: " + prettySexpr(first));
					first;
				};
			};
		} else {
			// Divide first by rest
			rest = tailFrom(evalResult.args, 1);
			fold(rest, first, \acc, arg -> {
				switch (acc) {
					SSInt(accInt): {
						switch (arg) {
							SSInt(argInt): {
								if (argInt != 0) {
									// Convert to double for division
									SSDouble(i2d(accInt) / i2d(argInt));
								} else {
									println("Division by zero");
									acc;
								}
							};
							SSDouble(argDouble): {
								if (argDouble != 0.0) {
									SSDouble(i2d(accInt) / argDouble);
								} else {
									println("Division by zero");
									acc;
								}
							};
							default: {
								println("Cannot divide by non-number: " + prettySexpr(arg));
								acc;
							};
						}
					};
					SSDouble(accDouble): {
						switch (arg) {
							SSInt(argInt): {
								if (argInt != 0) {
									SSDouble(accDouble / i2d(argInt));
								} else {
									println("Division by zero");
									acc;
								}
							};
							SSDouble(argDouble): {
								if (argDouble != 0.0) {
									SSDouble(accDouble / argDouble);
								} else {
									println("Division by zero");
									acc;
								}
							};
							default: {
								println("Cannot divide by non-number: " + prettySexpr(arg));
								acc;
							};
						}
					};
					default: acc;
				}
			});
		}
	}
}

// Equality check
equalsCheck(evalResult : FnArgResult) -> Sexpr {
	allEqual = sexprEquals(evalResult.args[0], evalResult.args[1]);
	SSBool(allEqual);
}

// List operations

carFunction(evalResult : FnArgResult) -> Sexpr {
	switch (evalResult.args[0]) {
		SSList(items): {
			if (length(items) > 0) {
				items[0];
			} else {
				println("car: empty list");
				SSList([]);
			}
		}
		default: {
			println("car requires a list argument");
			SSList([]);
		};
	}
}

cdrFunction(evalResult : FnArgResult) -> Sexpr {
	switch (evalResult.args[0]) {
		SSList(items): {
			if (length(items) > 0) {
				SSList(tailFrom(items, 1));
			} else {
				SSList([]);
			}
		}
		default: {
			println("cdr requires a list argument");
			SSList([]);
		};
	}
}

consFunction(evalResult : FnArgResult) -> Sexpr {
	elem = evalResult.args[0];
	rest = evalResult.args[1];
	
	switch (rest) {
		SSList(items): {
			SSList(concat([elem], items));
		}
		default: {
			// In Scheme, cons can create pairs, but for simplicity
			// we'll just create a list
			SSList([elem, rest]);
		};
	}
}

// Print function
printFunction(evalResult : FnArgResult) -> Sexpr {
	// Evaluate and print args recursively
	iter(evalResult.args, \arg -> {
		println(prettySexpr(arg));
	});

	SSList([]); // Default result
}

// ----- Functions from orbit_runtime -----
// Absolute
// Absolute value for doubles
absFunction(evalResult : FnArgResult) -> Sexpr {
	value = getSDouble(evalResult.args[0], "abs");
	SSDouble(abs(value));
}

// Absolute value for integers
iabsFunction(evalResult : FnArgResult) -> Sexpr {
	value = getSInt(evalResult.args[0], "iabs");
	SSInt(iabs(value));
}

// Sine function
sinFunction(evalResult : FnArgResult) -> Sexpr {
	value = getSDouble(evalResult.args[0], "sin");
	SSDouble(sin(value));
}

// Cosine function
cosFunction(evalResult : FnArgResult) -> Sexpr {
	value = getSDouble(evalResult.args[0], "cos");
	SSDouble(cos(value));
}

// Tangent function
tanFunction(evalResult : FnArgResult) -> Sexpr {
	value = getSDouble(evalResult.args[0], "tan");
	SSDouble(tan(value));
}

// Arc sine function
asinFunction(evalResult : FnArgResult) -> Sexpr {
	value = getSDouble(evalResult.args[0], "asin");
	SSDouble(asin(value));
}

// Arc cosine function
acosFunction(evalResult : FnArgResult) -> Sexpr {
	value = getSDouble(evalResult.args[0], "acos");
	SSDouble(acos(value));
}

// Arc tangent function
atanFunction(evalResult : FnArgResult) -> Sexpr {
	value = getSDouble(evalResult.args[0], "atan");
	SSDouble(atan(value));
}

// Arc tangent of y/x function
atan2Function(evalResult : FnArgResult) -> Sexpr {
	y = getSDouble(evalResult.args[0], "atan2 y");
	x = getSDouble(evalResult.args[1], "atan2 x");
	SSDouble(atan2(y, x));
}

// Square root function
sqrtFunction(evalResult : FnArgResult) -> Sexpr {
	value = getSDouble(evalResult.args[0], "sqrt");
	SSDouble(sqrt(value));
}

// Exponential function
expFunction(evalResult : FnArgResult) -> Sexpr {
	value = getSDouble(evalResult.args[0], "exp");
	SSDouble(exp(value));
}

// Natural logarithm function
logFunction(evalResult : FnArgResult) -> Sexpr {
	value = getSDouble(evalResult.args[0], "log");
	SSDouble(log(value));
}

// Base-10 logarithm function
log10Function(evalResult : FnArgResult) -> Sexpr {
	value = getSDouble(evalResult.args[0], "log10");
	SSDouble(log(value) / log(10.0));
}

// Floor function (returns integer)
floorFunction(evalResult : FnArgResult) -> Sexpr {
	value = getSDouble(evalResult.args[0], "floor");
	SSInt(floor(value));
}

// Ceiling function (returns integer)
ceilFunction(evalResult : FnArgResult) -> Sexpr {
	value = getSDouble(evalResult.args[0], "ceil");
	SSInt(ceil(value));
}

// Round function (returns integer)
roundFunction(evalResult : FnArgResult) -> Sexpr {
	value = getSDouble(evalResult.args[0], "round");
	SSInt(round(value));
}

// Floor function (returns double)
dfloorFunction(evalResult : FnArgResult) -> Sexpr {
	value = getSDouble(evalResult.args[0], "dfloor");
	SSDouble(dfloor(value));
}

// Ceiling function (returns double)
dceilFunction(evalResult : FnArgResult) -> Sexpr {
	value = getSDouble(evalResult.args[0], "dceil");
	SSDouble(dceil(value));
}

// Round function (returns double)
droundFunction(evalResult : FnArgResult) -> Sexpr {
	value = getSDouble(evalResult.args[0], "dround");
	SSDouble(dround(value));
}

// Sign function (returns double)
signFunction(evalResult : FnArgResult) -> Sexpr {
	value = getSDouble(evalResult.args[0], "sign");
	SSDouble(sign(value));
}

// Sign function (returns integer)
isignFunction(evalResult : FnArgResult) -> Sexpr {
	value = getSInt(evalResult.args[0], "isign");
	SSInt(isign(value));
}

// Check if number is even
evenFunction(evalResult : FnArgResult) -> Sexpr {
	value = getSInt(evalResult.args[0], "even");
	SSBool(even(value));
}

// Check if number is odd
oddFunction(evalResult : FnArgResult) -> Sexpr {
	value = getSInt(evalResult.args[0], "odd");
	SSBool(odd(value));
}

// Modulo function for integers
modFunction(evalResult : FnArgResult) -> Sexpr {
	value1 = getSInt(evalResult.args[0], "mod dividend");
	value2 = getSInt(evalResult.args[1], "mod divisor");
	
	if (value2 == 0) {
		println("ERROR: mod division by zero");
		SSInt(0);
	} else {
		SSInt(mod(value1, value2));
	}
}

// Modulo function for doubles
dmodFunction(evalResult : FnArgResult) -> Sexpr {
	value1 = getSDouble(evalResult.args[0], "dmod dividend");
	value2 = getSDouble(evalResult.args[1], "dmod divisor");
	
	if (value2 == 0.0) {
		println("ERROR: dmod division by zero");
		SSDouble(0.0);
	} else {
		SSDouble(dmod(value1, value2));
	}
}

// Factorial function
factorialFunction(evalResult : FnArgResult) -> Sexpr {
	value = getSInt(evalResult.args[0], "factorial");
	
	if (value < 0) {
		println("ERROR: factorial requires a non-negative integer");
		SSInt(0);
	} else {
		SSInt(factorial(value));
	}
}

// Greatest common divisor function
gcdFunction(evalResult : FnArgResult) -> Sexpr {
	value1 = getSInt(evalResult.args[0], "gcd first");
	value2 = getSInt(evalResult.args[1], "gcd second");
	SSInt(gcd(value1, value2));
}

// Least common multiple function
lcmFunction(evalResult : FnArgResult) -> Sexpr {
	value1 = getSInt(evalResult.args[0], "lcm first");
	value2 = getSInt(evalResult.args[1], "lcm second");
	SSInt(lcm(value1, value2));
}

// Logical not function
notFunction(evalResult : FnArgResult) -> Sexpr {
	value = getSBool(evalResult.args[0], "not");
	SSBool(!value);
}

// String length function
strlenFunction(evalResult : FnArgResult) -> Sexpr {
	str = getSString(evalResult.args[0], "strlen");
	SSInt(strlen(str));
}

// Substring function
substringFunction(evalResult : FnArgResult) -> Sexpr {
	str = getSString(evalResult.args[0], "substring string");
	start = getSInt(evalResult.args[1], "substring start");
	length = getSInt(evalResult.args[2], "substring length");
	
	if (start < 0 || start >= strlen(str)) {
		println("ERROR: substring start index out of bounds");
		SSString("");
	} else if (length < 0) {
		println("ERROR: substring length must be non-negative");
		SSString("");
	} else {
		SSString(substring(str, start, length));
	}
}

// Get character at index in string
strIndexFunction(evalResult : FnArgResult) -> Sexpr {
	str = getSString(evalResult.args[0], "strIndex string");
	idx = getSInt(evalResult.args[1], "strIndex index");
	
	if (idx < 0 || idx >= strlen(str)) {
		println("ERROR: strIndex index out of bounds");
		SSString("");
	} else {
		SSString(substring(str, idx, 1));
	}
}

// Check if string contains substring at index
strContainsAtFunction(evalResult : FnArgResult) -> Sexpr {
	str = getSString(evalResult.args[0], "strContainsAt string");
	idx = getSInt(evalResult.args[1], "strContainsAt index");
	sub = getSString(evalResult.args[2], "strContainsAt substring");
	
	if (idx < 0 || idx >= strlen(str)) {
		SSBool(false);
	} else if (idx + strlen(sub) > strlen(str)) {
		SSBool(false);
	} else {
		check = substring(str, idx, strlen(sub));
		SSBool(check == sub);
	}
}

// Parse hexadecimal string
parseHexFunction(evalResult : FnArgResult) -> Sexpr {
	hexStr = getSString(evalResult.args[0], "parseHex");
	// This is a simplified implementation
	// In a real implementation, we would validate and parse hex
	result = fold(strSplit(hexStr, ""), 0, \acc, c -> {
		digit = if (c >= "0" && c <= "9") s2i(c)
			else if (c >= "a" && c <= "f") s2i(c) - s2i("a") + 10 
			else if (c >= "A" && c <= "F") s2i(c) - s2i("A") + 10
			else -1;
		
		if (digit == -1) acc else acc * 16 + digit;
	});
	SSInt(result);
}

// Unescape a string
unescapeFunction(evalResult : FnArgResult) -> Sexpr {
	str = getSString(evalResult.args[0], "unescape");
	// Simplified implementation
	result = strReplace(strReplace(strReplace(strReplace(str, "\\n", "\n"), "\\t", "\t"), "\\\\", "\\"), "\\\"", "\"");
	SSString(result);
}

// Escape a string
escapeFunction(evalResult : FnArgResult) -> Sexpr {
	str = getSString(evalResult.args[0], "escape");
	// Simplified implementation
	result = strReplace(strReplace(strReplace(strReplace(str, "\\", "\\\\"), "\n", "\\n"), "\t", "\\t"), "\"", "\\\"");
	SSString(result);
}

// Join array of strings with separator
strGlueFunction(evalResult : FnArgResult) -> Sexpr {
	switch (evalResult.args[0]) {
		SSList(items): {
			sep = getSString(evalResult.args[1], "strGlue separator");
			// Convert all items to strings
			strs = map(items, \item -> getSString(item, "strGlue item"));
			SSString(strGlue(strs, sep));
		}
		default: {
			println("ERROR: strGlue first argument must be a list");
			SSString("");
		}
	}
}

// Capitalize first letter of string
capitalizeFunction(evalResult : FnArgResult) -> Sexpr {
	str = getSString(evalResult.args[0], "capitalize");
	if (strlen(str) == 0) {
		SSString("");
	} else {
		first = substring(str, 0, 1);
		rest = substring(str, 1, strlen(str) - 1);
		SSString(toUpperCase(first) + rest);
	}
}

// Decapitalize first letter of string
decapitalizeFunction(evalResult : FnArgResult) -> Sexpr {
	str = getSString(evalResult.args[0], "decapitalize");
	if (strlen(str) == 0) {
		SSString("");
	} else {
		first = substring(str, 0, 1);
		rest = substring(str, 1, strlen(str) - 1);
		SSString(toLowerCase(first) + rest);
	}
}

// Convert integer to string
i2sFunction(evalResult : FnArgResult) -> Sexpr {
	value = getSInt(evalResult.args[0], "i2s");
	SSString(i2s(value));
}

// Convert double to string
d2sFunction(evalResult : FnArgResult) -> Sexpr {
	value = getSDouble(evalResult.args[0], "d2s");
	SSString(d2s(value));
}

// Convert integer to boolean
i2bFunction(evalResult : FnArgResult) -> Sexpr {
	value = getSInt(evalResult.args[0], "i2b");
	SSBool(value != 0);
}

// Convert boolean to integer
b2iFunction(evalResult : FnArgResult) -> Sexpr {
	value = getSBool(evalResult.args[0], "b2i");
	SSInt(if (value) 1 else 0);
}

// Convert string to integer
s2iFunction(evalResult : FnArgResult) -> Sexpr {
	str = getSString(evalResult.args[0], "s2i");
	SSInt(s2i(str));
}

// Convert string to double
s2dFunction(evalResult : FnArgResult) -> Sexpr {
	str = getSString(evalResult.args[0], "s2d");
	SSDouble(s2d(str));
}

// Check if value is a boolean
isBoolFunction(evalResult : FnArgResult) -> Sexpr {
	isBool = switch (evalResult.args[0]) {
		SSBool(__): true;
		default: false;
	};
	SSBool(isBool);
}

// Check if value is an integer
isIntFunction(evalResult : FnArgResult) -> Sexpr {
	isInt = switch (evalResult.args[0]) {
		SSInt(__): true;
		default: false;
	};
	SSBool(isInt);
}

// Check if value is a double
isDoubleFunction(evalResult : FnArgResult) -> Sexpr {
	isDouble = switch (evalResult.args[0]) {
		SSDouble(__): true;
		default: false;
	};
	SSBool(isDouble);
}

// Check if value is a string
isStringFunction(evalResult : FnArgResult) -> Sexpr {
	isString = switch (evalResult.args[0]) {
		SSString(__): true;
		default: false;
	};
	SSBool(isString);
}

// Check if value is an array/list
isArrayFunction(evalResult : FnArgResult) -> Sexpr {
	isArray = switch (evalResult.args[0]) {
		SSList(__): true;
		default: false;
	};
	SSBool(isArray);
}

// Get length of array/list
lengthFunction(evalResult : FnArgResult) -> Sexpr {
	switch (evalResult.args[0]) {
		SSList(items): {
			SSInt(length(items));
		}
		SSString(s): {
			// As a convenience, also work on strings
			SSInt(strlen(s));
		}
		default: {
			println("ERROR: length requires a list or string argument");
			SSInt(0);
		}
	}
}

// Get item at index from array/list
indexFunction(evalResult : FnArgResult) -> Sexpr {
	switch (evalResult.args[0]) {
		SSList(items): {
			idx = getSInt(evalResult.args[1], "index index");
			if (idx < 0 || idx >= length(items)) {
				println("ERROR: index out of bounds");
				SSList([]);
			} else {
				items[idx];
			}
		}
		default: {
			println("ERROR: index requires a list argument");
			SSList([]);
		}
	}
}

// Get subrange of array/list
subrangeFunction(evalResult : FnArgResult) -> Sexpr {
	switch (evalResult.args[0]) {
		SSList(items): {
			start = getSInt(evalResult.args[1], "subrange start");
			lengthVal = getSInt(evalResult.args[2], "subrange length");
			itemsLength = length(items);
			
			if (start < 0 || start >= itemsLength) {
				println("ERROR: subrange start index out of bounds");
				SSList([]);
			} else if (lengthVal < 0) {
				println("ERROR: subrange length must be non-negative");
				SSList([]);
			} else {
				SSList(subrange(items, start, lengthVal));
			}
		}
		default: {
			println("ERROR: subrange requires a list argument");
			SSList([]);
		}
	}
}

// Reverse array/list
reverseFunction(evalResult : FnArgResult) -> Sexpr {
	switch (evalResult.args[0]) {
		SSList(items): {
			SSList(reverseA(items));
		}
		default: {
			println("ERROR: reverse requires a list argument");
			SSList([]);
		}
	}
}

// Implementation of prettySexpr function (equivalent to prettyOrbit)
prettySexprFunction(evalResult : FnArgResult) -> Sexpr {
	// Ensure we have exactly 1 argument
	if (length(evalResult.args) != 1) {
		println("ERROR: prettySexpr expects 1 argument");
		SSString("");
	} else {
		// Use the existing prettySexpr function to format the expression
		result = prettySexpr(evalResult.args[0]);
		SSString(result);
	}
}

// Implementation of astname function to get the type of a Sexpr
astnameFunction(evalResult : FnArgResult) -> Sexpr {
	// Ensure we have exactly 1 argument
	if (length(evalResult.args) != 1) {
		println("ERROR: astname expects 1 argument");
		SSString("");
	} else {
		// Return the structure name of the Sexpr
		typename = switch (evalResult.args[0]) {
			SSInt(__): "SSInt";
			SSDouble(__): "SSDouble";
			SSBool(__): "SSBool";
			SSString(__): "SSString";
			SSVariable(__): "SSVariable";
			SSConstructor(__): "SSConstructor";
			SSOperator(__): "SSOperator";
			SSList(__): "SSList";
			SSQuote(__): "SSQuote";
			SSQuasiQuote(__): "SSQuasiQuote";
			SSUnquote(__): "SSUnquote";
			SSUnquoteSplicing(__): "SSUnquoteSplicing";
		}
		SSString(typename);
	}
}

// Implementation of varname function
varnameFunction(evalResult : FnArgResult) -> Sexpr {
	// Ensure we have exactly 1 argument
	if (length(evalResult.args) != 1) {
		println("ERROR: varname expects 1 argument");
		SSString("");
	} else {
		// Extract the name if it's a variable, otherwise return empty string
		name = switch (evalResult.args[0]) {
			SSVariable(id): id;
			SSConstructor(id): id; // Include constructors as well
			SSOperator(id): id;    // Include operators too
			default: "";
		}
		SSString(name);
	}
}

// Implementation of getFileContent function
getFileContentFunction(evalResult : FnArgResult) -> Sexpr {
	// Ensure we have exactly 1 argument
	if (length(evalResult.args) != 1) {
		println("ERROR: getFileContent expects 1 argument");
		SSString("");
	} else {
		// Get the file path
		path = getSString(evalResult.args[0], "getFileContent.path");
		
		// Read the file content (using the Flow9 getFileContent function)
		content = getFileContent(path);
		
		SSString(content);
	}
}

// Implementation of setFileContent function
setFileContentFunction(evalResult : FnArgResult) -> Sexpr {
	// Ensure we have exactly 2 arguments
	if (length(evalResult.args) != 2) {
		println("ERROR: setFileContent expects 2 arguments");
		SSBool(false);
	} else {
		// Get the file path and content
		path = getSString(evalResult.args[0], "setFileContent.path");
		content = getSString(evalResult.args[1], "setFileContent.content");
		
		// Write the content to the file (using the Flow9 setFileContent function)
		success = setFileContent(path, content);
		
		SSBool(success);
	}
}

// Implementation of getCommandLineArgs function
getCommandLineArgsFunction(evalResult : FnArgResult) -> Sexpr {
	// This function doesn't require any arguments
	if (length(evalResult.args) != 0) {
		println("WARNING: getCommandLineArgs doesn't need arguments");
	}
	
	// Get all command line arguments as an array
	commandLineArgs = filtermap(getAllUrlParametersArray(), \a -> 
		if (a[1] == "") Some(a[0]) else None()
	);
	
	// Convert to a list of SSString
	result = SSList(map(commandLineArgs, \arg -> SSString(arg)));
	result;
}

// Implementation of parseSexpr function
parseSexprFunction(evalResult : FnArgResult) -> Sexpr {
	// Ensure we have exactly 1 argument
	if (length(evalResult.args) != 1) {
		println("ERROR: parseSexpr expects 1 argument");
		SSList([]);
	} else {
		// Get the code string
		code = getSString(evalResult.args[0], "parseSexpr.code");
		
		// Note: We need to assume parseSexpr is implemented elsewhere
		// For now, let's create a placeholder implementation that
		// returns a pair with the parsed expression and any error message
		
		// This is a stub - in a real implementation, we'd call a proper parser
		parseSexprImpl = \s -> {
			// This is just a placeholder - actual implementation would parse properly
			println("NOTE: parseSexpr implementation is a stub - importing parser would be required");
			// Return a Pair(parsedExpr, errorMsg)
			SSList([SSString("Parsing not implemented"), SSString("")]);
		};
		
		result = parseSexprImpl(code);
		result;
	}
}

// Global counter for unique IDs with prefixes
globalUidCounters : ref Tree<string, int> = ref makeTree();

// Implementation of uid function
uidFunction(evalResult : FnArgResult) -> Sexpr {
	// Ensure we have exactly 1 argument
	if (length(evalResult.args) != 1) {
		println("ERROR: uid expects 1 argument");
		SSString("");
	} else {
		// Get the prefix
		prefix = getSString(evalResult.args[0], "uid.prefix");
		
		// Generate a unique ID with this prefix
		currentCount = lookupTreeDef(^globalUidCounters, prefix, 0);
		globalUidCounters := setTree(^globalUidCounters, prefix, currentCount + 1);
		result = prefix + i2s(currentCount);
		
		SSString(result);
	}
}