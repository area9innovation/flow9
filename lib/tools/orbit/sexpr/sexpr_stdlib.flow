import tools/orbit/sexpr/env;
import tools/orbit/sexpr/pretty_sexpr;
import tools/orbit/sexpr/sexpr_pattern;
import tools/orbit/sexpr/utils;
import ds/tree;
import string;
import math/math;
import net/url_parameter; // For command line args
import tools/orbit/sexpr/sexpr_compiled_parser;
import tools/mango/mcode_lib;
import text/deserialize_string;

// OGraph and S-expression handling imports
import tools/orbit/ograph;
import tools/orbit/orbit_simple_ograph;

// Use the standard import format for all imports
import tools/orbit/sexpr/sexp2ograph_sub;
import tools/orbit/sexpr/ograph2sexpr;
import tools/orbit/sexpr/ograph_sexpr_pattern;

// Orbit expression handling
import tools/orbit/orbit_types;         // For OrMath_expr type
import tools/orbit/orbit2sexpr;         // For orbit2sexpr and sexpr2orbit converters
import tools/orbit/prettyprint;         // For prettyOrbit

export {
	// Add standard functions/variables to the environment
	getRuntimeEnv() -> SExpEnv;
	// Parse a string into a Sexpr
	parseSexpr(f : string, s : string) -> Maybe<Sexpr>;
	// Helper for invoking runtime functions with arity checking
	invokeRuntimeFn(env : SExpEnv, name : string, result : FnArgResult) -> SExpEnv;
}

getRuntimeEnv() -> SExpEnv {
	SExpEnv(getRuntimeFunctions(), addStandardFns(makeTree()), SSList([]));
}

// Parse a string into a Sexpr
parseSexpr(f : string, s : string) -> Maybe<Sexpr> {
	res : Pair<Sexpr, string> = parseCompiledMango(f, s, sexpr_parse_sexpr_compiled, flow(0));
	if (res.second != "") {
		println(f + ": " + res.second);
		None()
	} else {
		Some(res.first);
	}
}

// Helper for invoking runtime functions with arity checking
invokeRuntimeFn(env : SExpEnv, name : string, result : FnArgResult) -> SExpEnv {
	maybe = lookupTree(env.runtime, name);
	switch (maybe) {
		Some(runtimeFn): {
			// Check arity if expected value is not -1 (variable arity)
			if (runtimeFn.arity != -1 && length(result.args) != runtimeFn.arity) {
				println("ERROR: " + name + " expects " + i2s(runtimeFn.arity) + " arguments, got " + i2s(length(result.args)));
				SExpEnv(env with value = SSList([]));
			} else {
				// Invoke the function implementation
				SExpEnv(env with value = runtimeFn.fn(result));
			}
		}
		None(): {
			println("ERROR: Unknown runtime function: " + name);
			SExpEnv(env with value = SSList([]));
		}
	}
}

// Get the runtime functions map
getRuntimeFunctions() -> Tree<string, RuntimeFn> {
	functionPairs = [
		// OGraph operations
		Pair("makeOGraph", RuntimeFn(1, \result -> makeOGraphSexpr(result))),
		Pair("addSexpr2OGraph", RuntimeFn(2, \result -> addSexpr2OGraphFunction(result))),
		Pair("addSexprWithSub", RuntimeFn(3, \result -> addSexprWithSubFunction(result))),
		Pair("extractOGraphSexpr", RuntimeFn(2, \result -> extractOGraphSexprFunction(result))),
		Pair("matchOGraphSexprPattern", RuntimeFn(3, \result -> matchOGraphSexprPatternFunction(result))),
		Pair("addDomainToNode", RuntimeFn(3, \result -> addDomainToNodeSexpr(result))),
		Pair("mergeOGraphNodes", RuntimeFn(3, \result -> mergeOGraphNodesSexpr(result))),
		
		// Orbit-SExpr conversion functions
		Pair("orbit2sexpr", RuntimeFn(1, \result -> orbit2sexprFunction(result))),
		Pair("sexpr2orbit", RuntimeFn(1, \result -> sexpr2orbitFunction(result))),
		Pair("prettyOrbit", RuntimeFn(1, \result -> prettyOrbitSexp(result))),
		
		// OGraph with Orbit expressions operations
		Pair("addOrbit2OGraph", RuntimeFn(2, \result -> {
			// Extract arguments
			graphName = getSString(result.args[0], "addOrbit2OGraph.name");
			orbitExpr = sexpr2orbit(result.args[1]);
			
			// Call the implementation
			nodeId = addOrbit2OGraph(graphName, orbitExpr);
			
			// Return the node ID
			SSInt(nodeId);
		})),
		Pair("addOrbitWithSub", RuntimeFn(3, \result -> {
			// Extract arguments
			graphName = getSString(result.args[0], "addOrbitWithSub.name");
			orbitExpr = sexpr2orbit(result.args[1]);
			
			// Process bindings
			bindings = switch (result.args[2]) {
				SSList(pairs): {
					// Convert the list of pairs to a tree
					fold(pairs, makeTree(), \acc, pair -> {
						switch (pair) {
							SSList(items): {
								if (length(items) == 2) {
									// Extract key and value
									key = getSString(items[0], "addOrbitWithSub.binding.key");
									value = getSInt(items[1], "addOrbitWithSub.binding.value");
									
									// Add to the bindings map
									setTree(acc, key, value);
								} else {
									println("ERROR: Each binding must be a list of exactly 2 elements");
									acc;
								}
							}
							default: {
								println("ERROR: Each binding must be a list");
								acc;
							}
						}
					});
				}
				default: {
					println("ERROR: addOrbitWithSub third argument must be a list of bindings");
					makeTree();
				}
			};
			
			// Call the implementation
			nodeId = addOrbitWithSub(graphName, orbitExpr, bindings);
			
			// Return the node ID
			SSInt(nodeId);
		})),
		Pair("extractOGraphOrbit", RuntimeFn(2, \result -> {
			// Extract arguments
			graphName = getSString(result.args[0], "extractOGraphOrbit.name");
			nodeId = getSInt(result.args[1], "extractOGraphOrbit.nodeId");
			
			// Call the implementation (with tracing disabled)
			orbitExpr = extractOGraphOrbit(graphName, nodeId, false);
			
			// Convert OrMath_expr back to Sexpr for return
			orbit2sexpr(orbitExpr);
		})),
		Pair("matchOGraphOrbitPattern", RuntimeFn(3, \result -> {
			// Extract arguments
			graphName = getSString(result.args[0], "matchOGraphOrbitPattern.name");
			pattern = sexpr2orbit(result.args[1]);
			callback = result.args[2];
			
			// Check that the callback is a lambda
			switch (callback) {
				SSSpecialForm(form, _): {
					if (form == SLambda()) {
						// Store the results of pattern matching
						results = ref [];
						
						// Create a callback adapter that will be called for each match
						matchCallback = \bindings, eclassId -> {
							// Convert bindings to S-expression friendly format
							bindingsList = map(getTreeKeys(bindings), \key -> {
								value = lookupTreeDef(bindings, key, -1);
								SSList([SSString(key), SSInt(value)]);
							});
							
							// Create the arguments for the callback
							args = [SSList(bindingsList), SSInt(eclassId)];
							
							// Save the binding information
							results := concat(^results, args);
						};
						
						// Call the pattern matcher (with tracing disabled)
						matchCount = matchOGraphOrbitPattern(graphName, pattern, matchCallback, false);
						
						// Return the number of matches and the results
						SSList([SSInt(matchCount), SSList(^results)]);
					} else {
						println("ERROR: matchOGraphOrbitPattern callback must be a lambda");
						SSInt(0);
					}
				}
				default: {
					println("ERROR: matchOGraphOrbitPattern callback must be a lambda");
					SSInt(0);
				}
			}
		})),
		
		// Arithmetic operators
		Pair("+", RuntimeFn(-1, \result -> addNumbers(result))),
		Pair("-", RuntimeFn(-1, \result -> subtractNumbers(result))),
		Pair("*", RuntimeFn(-1, \result -> multiplyNumbers(result))),
		Pair("/", RuntimeFn(-1, \result -> divideNumbers(result))),
		Pair("=", RuntimeFn(2, \result -> equalsCheck(result))),
		Pair("!=", RuntimeFn(2, \result -> notEqualsCheck(result))),
		Pair("<", RuntimeFn(2, \result -> lessThanCheck(result))),
		Pair(">", RuntimeFn(2, \result -> greaterThanCheck(result))),
		Pair("<=", RuntimeFn(2, \result -> lessThanOrEqualCheck(result))),
		Pair(">=", RuntimeFn(2, \result -> greaterThanOrEqualCheck(result))),
		
		// List operations
		Pair("list", RuntimeFn(-1, \result -> SSList(result.args))),
		Pair("car", RuntimeFn(1, \result -> carFunction(result))), // first element of array
		Pair("cdr", RuntimeFn(1, \result -> cdrFunction(result))), // tail of array
		Pair("cons", RuntimeFn(2, \result -> consFunction(result))), // prepend element to array
		Pair("concat", RuntimeFn(2, \result -> concatFunction(result))),
		Pair("println", RuntimeFn(-1, \result -> printFunction(result))),
		
		// Math functions
		Pair("abs", RuntimeFn(1, \result -> absFunction(result))),
		Pair("iabs", RuntimeFn(1, \result -> iabsFunction(result))),
		Pair("sin", RuntimeFn(1, \result -> sinFunction(result))),
		Pair("cos", RuntimeFn(1, \result -> cosFunction(result))),
		Pair("tan", RuntimeFn(1, \result -> tanFunction(result))),
		Pair("asin", RuntimeFn(1, \result -> asinFunction(result))),
		Pair("acos", RuntimeFn(1, \result -> acosFunction(result))),
		Pair("atan", RuntimeFn(1, \result -> atanFunction(result))),
		Pair("atan2", RuntimeFn(2, \result -> atan2Function(result))),
		Pair("sqrt", RuntimeFn(1, \result -> sqrtFunction(result))),
		Pair("exp", RuntimeFn(1, \result -> expFunction(result))),
		Pair("log", RuntimeFn(1, \result -> logFunction(result))),
		Pair("log10", RuntimeFn(1, \result -> log10Function(result))),
		Pair("floor", RuntimeFn(1, \result -> floorFunction(result))),
		Pair("ceil", RuntimeFn(1, \result -> ceilFunction(result))),
		Pair("round", RuntimeFn(1, \result -> roundFunction(result))),
		Pair("dfloor", RuntimeFn(1, \result -> dfloorFunction(result))),
		Pair("dceil", RuntimeFn(1, \result -> dceilFunction(result))),
		Pair("dround", RuntimeFn(1, \result -> droundFunction(result))),
		Pair("sign", RuntimeFn(1, \result -> signFunction(result))),
		Pair("isign", RuntimeFn(1, \result -> isignFunction(result))),
		Pair("even", RuntimeFn(1, \result -> evenFunction(result))),
		Pair("odd", RuntimeFn(1, \result -> oddFunction(result))),
		Pair("gcd", RuntimeFn(2, \result -> gcdFunction(result))),
		Pair("lcm", RuntimeFn(2, \result -> lcmFunction(result))),
		Pair("mod", RuntimeFn(2, \result -> modFunction(result))),
		Pair("dmod", RuntimeFn(2, \result -> dmodFunction(result))),
		
		// Logic functions
		Pair("not", RuntimeFn(1, \result -> notFunction(result))),
		
		// String operations
		Pair("strlen", RuntimeFn(1, \result -> strlenFunction(result))),
		Pair("substring", RuntimeFn(3, \result -> substringFunction(result))),
		Pair("strIndex", RuntimeFn(2, \result -> strIndexFunction(result))),
		Pair("strContainsAt", RuntimeFn(3, \result -> strContainsAtFunction(result))),
		Pair("parseHex", RuntimeFn(1, \result -> parseHexFunction(result))),
		Pair("unescape", RuntimeFn(1, \result -> unescapeFunction(result))),
		Pair("escape", RuntimeFn(1, \result -> escapeFunction(result))),
		Pair("strGlue", RuntimeFn(2, \result -> strGlueFunction(result))),
		Pair("capitalize", RuntimeFn(1, \result -> capitalizeFunction(result))),
		Pair("decapitalize", RuntimeFn(1, \result -> decapitalizeFunction(result))),
		Pair("string2ints", RuntimeFn(1, \result -> {
			// Convert string to list of character codes
			str = getSString(result.args[0], "string2ints");
			SSList(map(s2a(str), \c -> SSInt(c)));
		})),

		Pair("ints2string", RuntimeFn(1, \result -> {
			// Convert list of character codes to string
			switch (result.args[0]) {
				SSList(items): {
					charCodes = map(items, \item -> getSInt(item, "ints2string.item"));
					SSString(strGlue(map(charCodes, \code -> fromCharCode(code)), ""));
				}
				default: {
					println("ERROR: ints2string requires a list argument");
					SSString("");
				}
			}
		})),		
		// Type conversions
		Pair("i2s", RuntimeFn(1, \result -> i2sFunction(result))),
		Pair("d2s", RuntimeFn(1, \result -> d2sFunction(result))),
		Pair("i2b", RuntimeFn(1, \result -> i2bFunction(result))),
		Pair("b2i", RuntimeFn(1, \result -> b2iFunction(result))),
		Pair("s2i", RuntimeFn(1, \result -> s2iFunction(result))),
		Pair("s2d", RuntimeFn(1, \result -> s2dFunction(result))),
		
		// Type checking
		Pair("isBool", RuntimeFn(1, \result -> isBoolFunction(result))),
		Pair("isInt", RuntimeFn(1, \result -> isIntFunction(result))),
		Pair("isDouble", RuntimeFn(1, \result -> isDoubleFunction(result))),
		Pair("isString", RuntimeFn(1, \result -> isStringFunction(result))),
		Pair("isArray", RuntimeFn(1, \result -> isArrayFunction(result))),
		
		// Array/list operations
		Pair("length", RuntimeFn(1, \result -> lengthFunction(result))),
		Pair("index", RuntimeFn(2, \result -> indexFunction(result))),
		Pair("subrange", RuntimeFn(3, \result -> subrangeFunction(result))),
		Pair("reverse", RuntimeFn(1, \result -> reverseFunction(result))),
		
		// New functions (ported from orbit)
		Pair("prettySexpr", RuntimeFn(1, \result -> prettySexprFunction(result))),
		Pair("astname", RuntimeFn(1, \result -> astnameFunction(result))),
		Pair("varname", RuntimeFn(1, \result -> varnameFunction(result))),
		Pair("getFileContent", RuntimeFn(1, \result -> getFileContentFunction(result))),
		Pair("setFileContent", RuntimeFn(2, \result -> setFileContentFunction(result))),
		Pair("getCommandLineArgs", RuntimeFn(0, \result -> getCommandLineArgsFunction(result))),
		Pair("parseSexpr", RuntimeFn(1, \result -> parseSexprFunction(result))),
		Pair("uid", RuntimeFn(1, \result -> uidFunction(result)))
	];
	
	pairs2tree(functionPairs);
}

// Add standard functions/variables to the environment
addStandardFns(env : Tree<string, Sexpr>) -> Tree<string, Sexpr> {
	// Get runtime functions registry
	runtimeFunctions = getTreeKeys(getRuntimeFunctions());
	
	// Add operators as operators
	env1 = setTree(env, "+", SSOperator("+"));
	env2 = setTree(env1, "-", SSOperator("-"));
	env3 = setTree(env2, "*", SSOperator("*"));
	env4 = setTree(env3, "/", SSOperator("/"));
	env5 = setTree(env4, "=", SSOperator("="));
	env6 = setTree(env5, "!=", SSOperator("!="));
	env7 = setTree(env6, "<", SSOperator("<"));
	env8 = setTree(env7, ">", SSOperator(">"));
	env9 = setTree(env8, "<=", SSOperator("<="));
	env10 = setTree(env9, ">=", SSOperator(">="));
	
	// Add other functions as variables
	fold(runtimeFunctions, env10, \acc, name -> {
		if (name == "+" || name == "-" || name == "*" || name == "/" || name == "=" ||
		    name == "!=" || name == "<" || name == ">" || name == "<=" || name == ">=") {
			// Already added as operators
			acc;
		} else {
			setTree(acc, name, SSVariable(name));
		}
	});
}

// Helper functions for basic operations

// Add numbers
addNumbers(evalResult : FnArgResult) -> Sexpr {
	if (length(evalResult.args) == 0) {
		SSInt(0);
	} else {
		// Get first arg
		first = evalResult.args[0];
		initial = switch (first) {
			SSInt(i): SSInt(i);
			SSDouble(d): SSDouble(d);
			SSString(s): SSString(s);
			default: {
				SSString(prettySexpr(first));
			}
		};
		fold(tail(evalResult.args), initial, \acc, arg -> {
			switch (acc) {
				SSBool(accBool): {
					switch (arg) {
						SSString(argString): {
							SSString(b2s(accBool) + argString);
						}
						default: {
							println("Cannot add non-number: " + prettySexpr(arg));
							acc;
						}
					}
				}
				SSInt(accInt): {
					switch (arg) {
						SSInt(argInt): SSInt(accInt + argInt);
						SSDouble(argDouble): SSDouble(i2d(accInt) + argDouble);
						SSString(argString): {
							SSString(i2s(accInt) + argString);
						}
						default: {
							println("Cannot add non-number: " + prettySexpr(arg));
							acc;
						}
					}
				};
				SSDouble(accDouble): {
					switch (arg) {
						SSInt(argInt): SSDouble(accDouble + i2d(argInt));
						SSDouble(argDouble): SSDouble(accDouble + argDouble);
						SSString(argString): {
							SSString(d2s(accDouble) + argString);
						}
						default: {
							println("Cannot add non-number: " + prettySexpr(arg));
							acc;
						}
					}
				};
				SSString(accString): {
					switch (arg) {
						SSString(argString): SSString(accString + argString);
						default: SSString(accString + prettySexpr(arg));
					}
				}
				default: acc;
			}
		});
	}
}

// Subtract numbers
subtractNumbers(evalResult : FnArgResult) -> Sexpr {
	if (length(evalResult.args) == 0) {
		SSInt(0);
	} else {
		// Get first arg
		first = evalResult.args[0];
		
		// If only one argument, negate it
		if (length(evalResult.args) == 1) {
			switch (first) {
				SSInt(i): SSInt(-i);
				SSDouble(d): SSDouble(-d);
				default: {
					println("Cannot negate non-number: " + prettySexpr(first));
					first;
				};
			};
		} else {
			// Subtract rest from first
			rest = tailFrom(evalResult.args, 1);
			fold(rest, first, \acc, arg -> {
				switch (acc) {
					SSInt(accInt): {
						switch (arg) {
							SSInt(argInt): SSInt(accInt - argInt);
							SSDouble(argDouble): SSDouble(i2d(accInt) - argDouble);
							default: {
								println("Cannot subtract non-number: " + prettySexpr(arg));
								acc;
							}
						}
					};
					SSDouble(accDouble): {
						switch (arg) {
							SSInt(argInt): SSDouble(accDouble - i2d(argInt));
							SSDouble(argDouble): SSDouble(accDouble - argDouble);
							default: {
								println("Cannot subtract non-number: " + prettySexpr(arg));
								acc;
							}
						}
					};
					default: acc;
				}
			});
		}
	}
}

// Multiply numbers
multiplyNumbers(evalResult : FnArgResult) -> Sexpr {
	fold(evalResult.args, SSInt(1), \acc, arg -> {
		switch (acc) {
			SSInt(accInt): {
				switch (arg) {
					SSInt(argInt): SSInt(accInt * argInt);
					SSDouble(argDouble): SSDouble(i2d(accInt) * argDouble);
					default: {
						println("Cannot multiply non-number: " + prettySexpr(arg));
						acc;
					}
				}
			};
			SSDouble(accDouble): {
				switch (arg) {
					SSInt(argInt): SSDouble(accDouble * i2d(argInt));
					SSDouble(argDouble): SSDouble(accDouble * argDouble);
					default: {
						println("Cannot multiply non-number: " + prettySexpr(arg));
						acc;
					}
				}
			};
			default: acc;
		}
	});
}

// Divide numbers
divideNumbers(evalResult : FnArgResult) -> Sexpr {
	if (length(evalResult.args) == 0) {
		SSInt(1);
	} else {
		// Get first arg
		first = evalResult.args[0];
		
		// If only one argument, invert it (1/x)
		if (length(evalResult.args) == 1) {
			switch (first) {
				SSInt(i): {
					if (i != 0) SSDouble(1.0 / i2d(i)) else {
						println("Division by zero");
						SSDouble(0.0);
					}
				};
				SSDouble(d): {
					if (d != 0.0) SSDouble(1.0 / d) else {
						println("Division by zero");
						SSDouble(0.0);
					}
				};
				default: {
					println("Cannot invert non-number: " + prettySexpr(first));
					first;
				};
			};
		} else {
			// Divide first by rest
			rest = tailFrom(evalResult.args, 1);
			fold(rest, first, \acc, arg -> {
				switch (acc) {
					SSInt(accInt): {
						switch (arg) {
							SSInt(argInt): {
								if (argInt != 0) {
									// Convert to double for division
									SSDouble(i2d(accInt) / i2d(argInt));
								} else {
									println("Division by zero");
									acc;
								}
							};
							SSDouble(argDouble): {
								if (argDouble != 0.0) {
									SSDouble(i2d(accInt) / argDouble);
								} else {
									println("Division by zero");
									acc;
								}
							};
							default: {
								println("Cannot divide by non-number: " + prettySexpr(arg));
								acc;
							};
						}
					};
					SSDouble(accDouble): {
						switch (arg) {
							SSInt(argInt): {
								if (argInt != 0) {
									SSDouble(accDouble / i2d(argInt));
								} else {
									println("Division by zero");
									acc;
								}
							};
							SSDouble(argDouble): {
								if (argDouble != 0.0) {
									SSDouble(accDouble / argDouble);
								} else {
									println("Division by zero");
									acc;
								}
							};
							default: {
								println("Cannot divide by non-number: " + prettySexpr(arg));
								acc;
							};
						}
					};
					default: acc;
				}
			});
		}
	}
}

// Equality check
equalsCheck(evalResult : FnArgResult) -> Sexpr {
	allEqual = evalResult.args[0] == evalResult.args[1];
	SSBool(allEqual);
}

// Not equal check
notEqualsCheck(evalResult : FnArgResult) -> Sexpr {
	notEqual = evalResult.args[0] != evalResult.args[1];
	SSBool(notEqual);
}

// Less than check
lessThanCheck(evalResult : FnArgResult) -> Sexpr {
	compareResult = genericCompare(evalResult.args[0], evalResult.args[1]);
	SSBool(compareResult < 0);
}

// Greater than check
greaterThanCheck(evalResult : FnArgResult) -> Sexpr {
	compareResult = genericCompare(evalResult.args[0], evalResult.args[1]);
	SSBool(compareResult > 0);
}

// Less than or equal check
lessThanOrEqualCheck(evalResult : FnArgResult) -> Sexpr {
	compareResult = genericCompare(evalResult.args[0], evalResult.args[1]);
	SSBool(compareResult <= 0);
}

// Greater than or equal check
greaterThanOrEqualCheck(evalResult : FnArgResult) -> Sexpr {
	compareResult = genericCompare(evalResult.args[0], evalResult.args[1]);
	SSBool(compareResult >= 0);
}

// List operations

carFunction(evalResult : FnArgResult) -> Sexpr {
	switch (evalResult.args[0]) {
		SSList(items): {
			if (length(items) > 0) {
				items[0];
			} else {
				println("car: empty list");
				SSList([]);
			}
		}
		default: {
			println("car requires a list argument");
			SSList([]);
		};
	}
}

cdrFunction(evalResult : FnArgResult) -> Sexpr {
	switch (evalResult.args[0]) {
		SSList(items): {
			if (length(items) > 0) {
				SSList(tailFrom(items, 1));
			} else {
				SSList([]);
			}
		}
		default: {
			println("cdr requires a list argument");
			SSList([]);
		};
	}
}

consFunction(evalResult : FnArgResult) -> Sexpr {
	elem = evalResult.args[0];
	rest = evalResult.args[1];
	
	switch (rest) {
		SSList(items): {
			SSList(concat([elem], items));
		}
		default: {
			// In Scheme, cons can create pairs, but for simplicity
			// we'll just create a list
			SSList([elem, rest]);
		};
	}
}

concatFunction(evalResult : FnArgResult) -> Sexpr {
	elem = evalResult.args[0];
	rest = evalResult.args[1];
	
	switch (elem) {
		SSList(items1): {
			switch (rest) {
				SSList(items2): {
					// Concatenate the two lists
					SSList(concat(items1, items2));
				}
				default: {
					// In Scheme, cons can create pairs, but for simplicity
					// we'll just create a list
					SSList(concat(items1, [rest]));
				}
			}
		}
		default: {
			switch (rest) {
				SSList(items2): {
					// Concatenate the two lists
					SSList(concat([elem], items2));
				}
				default: {
					// In Scheme, cons can create pairs, but for simplicity
					// we'll just create a list
					SSList([elem, rest]);
				}
			}
		};
	}
}


// Print function
printFunction(evalResult : FnArgResult) -> Sexpr {
	// Evaluate and print args recursively
	iter(evalResult.args, \arg -> {
		switch (arg) {
			SSString(str): {
				println(str);
			}
			default: println(prettySexpr(arg));
		}
	});

	SSInt(0); // Default result
}

// ----- Functions from orbit_runtime -----
// Absolute
// Absolute value for doubles
absFunction(evalResult : FnArgResult) -> Sexpr {
	value = getSDouble(evalResult.args[0], "abs");
	SSDouble(abs(value));
}

// Absolute value for integers
iabsFunction(evalResult : FnArgResult) -> Sexpr {
	value = getSInt(evalResult.args[0], "iabs");
	SSInt(iabs(value));
}

// Sine function
sinFunction(evalResult : FnArgResult) -> Sexpr {
	value = getSDouble(evalResult.args[0], "sin");
	SSDouble(sin(value));
}

// Cosine function
cosFunction(evalResult : FnArgResult) -> Sexpr {
	value = getSDouble(evalResult.args[0], "cos");
	SSDouble(cos(value));
}

// Tangent function
tanFunction(evalResult : FnArgResult) -> Sexpr {
	value = getSDouble(evalResult.args[0], "tan");
	SSDouble(tan(value));
}

// Arc sine function
asinFunction(evalResult : FnArgResult) -> Sexpr {
	value = getSDouble(evalResult.args[0], "asin");
	SSDouble(asin(value));
}

// Arc cosine function
acosFunction(evalResult : FnArgResult) -> Sexpr {
	value = getSDouble(evalResult.args[0], "acos");
	SSDouble(acos(value));
}

// Arc tangent function
atanFunction(evalResult : FnArgResult) -> Sexpr {
	value = getSDouble(evalResult.args[0], "atan");
	SSDouble(atan(value));
}

// Arc tangent of y/x function
atan2Function(evalResult : FnArgResult) -> Sexpr {
	y = getSDouble(evalResult.args[0], "atan2 y");
	x = getSDouble(evalResult.args[1], "atan2 x");
	SSDouble(atan2(y, x));
}

// Square root function
sqrtFunction(evalResult : FnArgResult) -> Sexpr {
	value = getSDouble(evalResult.args[0], "sqrt");
	SSDouble(sqrt(value));
}

// Exponential function
expFunction(evalResult : FnArgResult) -> Sexpr {
	value = getSDouble(evalResult.args[0], "exp");
	SSDouble(exp(value));
}

// Natural logarithm function
logFunction(evalResult : FnArgResult) -> Sexpr {
	value = getSDouble(evalResult.args[0], "log");
	SSDouble(log(value));
}

// Base-10 logarithm function
log10Function(evalResult : FnArgResult) -> Sexpr {
	value = getSDouble(evalResult.args[0], "log10");
	SSDouble(log(value) / log(10.0));
}

// Floor function (returns integer)
floorFunction(evalResult : FnArgResult) -> Sexpr {
	value = getSDouble(evalResult.args[0], "floor");
	SSInt(floor(value));
}

// Ceiling function (returns integer)
ceilFunction(evalResult : FnArgResult) -> Sexpr {
	value = getSDouble(evalResult.args[0], "ceil");
	SSInt(ceil(value));
}

// Round function (returns integer)
roundFunction(evalResult : FnArgResult) -> Sexpr {
	value = getSDouble(evalResult.args[0], "round");
	SSInt(round(value));
}

// Floor function (returns double)
dfloorFunction(evalResult : FnArgResult) -> Sexpr {
	value = getSDouble(evalResult.args[0], "dfloor");
	SSDouble(dfloor(value));
}

// Ceiling function (returns double)
dceilFunction(evalResult : FnArgResult) -> Sexpr {
	value = getSDouble(evalResult.args[0], "dceil");
	SSDouble(dceil(value));
}

// Round function (returns double)
droundFunction(evalResult : FnArgResult) -> Sexpr {
	value = getSDouble(evalResult.args[0], "dround");
	SSDouble(dround(value));
}

// Sign function (returns double)
signFunction(evalResult : FnArgResult) -> Sexpr {
	value = getSDouble(evalResult.args[0], "sign");
	SSDouble(sign(value));
}

// Sign function (returns integer)
isignFunction(evalResult : FnArgResult) -> Sexpr {
	value = getSInt(evalResult.args[0], "isign");
	SSInt(isign(value));
}

// Check if number is even
evenFunction(evalResult : FnArgResult) -> Sexpr {
	value = getSInt(evalResult.args[0], "even");
	SSBool(even(value));
}

// Check if number is odd
oddFunction(evalResult : FnArgResult) -> Sexpr {
	value = getSInt(evalResult.args[0], "odd");
	SSBool(odd(value));
}

// Modulo function for integers
modFunction(evalResult : FnArgResult) -> Sexpr {
	value1 = getSInt(evalResult.args[0], "mod dividend");
	value2 = getSInt(evalResult.args[1], "mod divisor");
	
	if (value2 == 0) {
		println("ERROR: mod division by zero");
		SSInt(0);
	} else {
		SSInt(mod(value1, value2));
	}
}

// Modulo function for doubles
dmodFunction(evalResult : FnArgResult) -> Sexpr {
	value1 = getSDouble(evalResult.args[0], "dmod dividend");
	value2 = getSDouble(evalResult.args[1], "dmod divisor");
	
	if (value2 == 0.0) {
		println("ERROR: dmod division by zero");
		SSDouble(0.0);
	} else {
		SSDouble(dmod(value1, value2));
	}
}

// Greatest common divisor function
gcdFunction(evalResult : FnArgResult) -> Sexpr {
	value1 = getSInt(evalResult.args[0], "gcd first");
	value2 = getSInt(evalResult.args[1], "gcd second");
	SSInt(gcd(value1, value2));
}

// Least common multiple function
lcmFunction(evalResult : FnArgResult) -> Sexpr {
	value1 = getSInt(evalResult.args[0], "lcm first");
	value2 = getSInt(evalResult.args[1], "lcm second");
	SSInt(lcm(value1, value2));
}

// Logical not function
notFunction(evalResult : FnArgResult) -> Sexpr {
	value = getSBool(evalResult.args[0], "not");
	SSBool(!value);
}

// String length function
strlenFunction(evalResult : FnArgResult) -> Sexpr {
	str = getSString(evalResult.args[0], "strlen");
	SSInt(strlen(str));
}

// Substring function
substringFunction(evalResult : FnArgResult) -> Sexpr {
	str = getSString(evalResult.args[0], "substring string");
	start = getSInt(evalResult.args[1], "substring start");
	length = getSInt(evalResult.args[2], "substring length");
	
	if (start < 0 || start >= strlen(str)) {
		println("ERROR: substring start index out of bounds");
		SSString("");
	} else if (length < 0) {
		println("ERROR: substring length must be non-negative");
		SSString("");
	} else {
		SSString(substring(str, start, length));
	}
}

// Get character at index in string
strIndexFunction(evalResult : FnArgResult) -> Sexpr {
	str = getSString(evalResult.args[0], "strIndex string");
	idx = getSInt(evalResult.args[1], "strIndex index");
	
	if (idx < 0 || idx >= strlen(str)) {
		println("ERROR: strIndex index out of bounds");
		SSString("");
	} else {
		SSString(substring(str, idx, 1));
	}
}

// Check if string contains substring at index
strContainsAtFunction(evalResult : FnArgResult) -> Sexpr {
	str = getSString(evalResult.args[0], "strContainsAt string");
	idx = getSInt(evalResult.args[1], "strContainsAt index");
	sub = getSString(evalResult.args[2], "strContainsAt substring");
	
	if (idx < 0 || idx >= strlen(str)) {
		SSBool(false);
	} else if (idx + strlen(sub) > strlen(str)) {
		SSBool(false);
	} else {
		check = substring(str, idx, strlen(sub));
		SSBool(check == sub);
	}
}

// Parse hexadecimal string
parseHexFunction(evalResult : FnArgResult) -> Sexpr {
	hexStr = getSString(evalResult.args[0], "parseHex");
	SSInt(parseHex(hexStr));
}

// Unescape a string
unescapeFunction(evalResult : FnArgResult) -> Sexpr {
	str = getSString(evalResult.args[0], "unescape");
	result = deserializeString(str).first;
	SSString(result);
}

// Escape a string
escapeFunction(evalResult : FnArgResult) -> Sexpr {
	str = getSString(evalResult.args[0], "escape");
	SSString(toString(str));
}

// Join array of strings with separator
strGlueFunction(evalResult : FnArgResult) -> Sexpr {
	switch (evalResult.args[0]) {
		SSList(items): {
			sep = getSString(evalResult.args[1], "strGlue separator");
			// Convert all items to strings
			strs = map(items, \item -> getSString(item, "strGlue item"));
			SSString(strGlue(strs, sep));
		}
		default: {
			println("ERROR: strGlue first argument must be a list");
			SSString("");
		}
	}
}

// Capitalize first letter of string
capitalizeFunction(evalResult : FnArgResult) -> Sexpr {
	str = getSString(evalResult.args[0], "capitalize");
	if (strlen(str) == 0) {
		SSString("");
	} else {
		first = substring(str, 0, 1);
		rest = substring(str, 1, strlen(str) - 1);
		SSString(toUpperCase(first) + rest);
	}
}

// Decapitalize first letter of string
decapitalizeFunction(evalResult : FnArgResult) -> Sexpr {
	str = getSString(evalResult.args[0], "decapitalize");
	if (strlen(str) == 0) {
		SSString("");
	} else {
		first = substring(str, 0, 1);
		rest = substring(str, 1, strlen(str) - 1);
		SSString(toLowerCase(first) + rest);
	}
}

// Convert integer to string
i2sFunction(evalResult : FnArgResult) -> Sexpr {
	value = getSInt(evalResult.args[0], "i2s");
	SSString(i2s(value));
}

// Convert double to string
d2sFunction(evalResult : FnArgResult) -> Sexpr {
	value = getSDouble(evalResult.args[0], "d2s");
	SSString(d2s(value));
}

// Convert integer to boolean
i2bFunction(evalResult : FnArgResult) -> Sexpr {
	value = getSInt(evalResult.args[0], "i2b");
	SSBool(value != 0);
}

// Convert boolean to integer
b2iFunction(evalResult : FnArgResult) -> Sexpr {
	value = getSBool(evalResult.args[0], "b2i");
	SSInt(if (value) 1 else 0);
}

// Convert string to integer
s2iFunction(evalResult : FnArgResult) -> Sexpr {
	str = getSString(evalResult.args[0], "s2i");
	SSInt(s2i(str));
}

// Convert string to double
s2dFunction(evalResult : FnArgResult) -> Sexpr {
	str = getSString(evalResult.args[0], "s2d");
	SSDouble(s2d(str));
}

// Check if value is a boolean
isBoolFunction(evalResult : FnArgResult) -> Sexpr {
	isBool = switch (evalResult.args[0]) {
		SSBool(__): true;
		default: false;
	};
	SSBool(isBool);
}

// Check if value is an integer
isIntFunction(evalResult : FnArgResult) -> Sexpr {
	isInt = switch (evalResult.args[0]) {
		SSInt(__): true;
		default: false;
	};
	SSBool(isInt);
}

// Check if value is a double
isDoubleFunction(evalResult : FnArgResult) -> Sexpr {
	isDouble = switch (evalResult.args[0]) {
		SSDouble(__): true;
		default: false;
	};
	SSBool(isDouble);
}

// Check if value is a string
isStringFunction(evalResult : FnArgResult) -> Sexpr {
	isString = switch (evalResult.args[0]) {
		SSString(__): true;
		default: false;
	};
	SSBool(isString);
}

// Check if value is an array/list
isArrayFunction(evalResult : FnArgResult) -> Sexpr {
	isArray = switch (evalResult.args[0]) {
		SSList(__): true;
		default: false;
	};
	SSBool(isArray);
}

// Get length of array/list
lengthFunction(evalResult : FnArgResult) -> Sexpr {
	switch (evalResult.args[0]) {
		SSList(items): {
			SSInt(length(items));
		}
		SSString(s): {
			// As a convenience, also work on strings
			SSInt(strlen(s));
		}
		default: {
			println("ERROR: length requires a list or string argument");
			SSInt(0);
		}
	}
}

// Get item at index from array/list
indexFunction(evalResult : FnArgResult) -> Sexpr {
	switch (evalResult.args[0]) {
		SSList(items): {
			idx = getSInt(evalResult.args[1], "index index");
			if (idx < 0 || idx >= length(items)) {
				println("ERROR: index out of bounds");
				SSList([]);
			} else {
				items[idx];
			}
		}
		default: {
			println("ERROR: index requires a list argument");
			SSList([]);
		}
	}
}

// Get subrange of array/list
subrangeFunction(evalResult : FnArgResult) -> Sexpr {
	switch (evalResult.args[0]) {
		SSList(items): {
			start = getSInt(evalResult.args[1], "subrange start");
			lengthVal = getSInt(evalResult.args[2], "subrange length");
			itemsLength = length(items);
			
			if (start < 0 ) {
				println("ERROR: subrange start index out of bounds " + i2s(start) + " in " + prettySexpr(evalResult.args[0]));
				SSList([]);
			} else if (start >= itemsLength) {
				SSList([])
			} else if (lengthVal < 0) {
				println("ERROR: subrange length must be non-negative");
				SSList([]);
			} else {
				SSList(subrange(items, start, lengthVal));
			}
		}
		default: {
			println("ERROR: subrange requires a list argument");
			SSList([]);
		}
	}
}

// Reverse array/list
reverseFunction(evalResult : FnArgResult) -> Sexpr {
	switch (evalResult.args[0]) {
		SSList(items): {
			SSList(reverseA(items));
		}
		default: {
			println("ERROR: reverse requires a list argument");
			SSList([]);
		}
	}
}

// Implementation of prettySexpr function (equivalent to prettyOrbit)
prettySexprFunction(evalResult : FnArgResult) -> Sexpr {
	// Ensure we have exactly 1 argument
	if (length(evalResult.args) != 1) {
		println("ERROR: prettySexpr expects 1 argument");
		SSString("");
	} else {
		// Use the existing prettySexpr function to format the expression
		result = prettySexpr(evalResult.args[0]);
		SSString(result);
	}
}

// Implementation of astname function to get the type of a Sexpr
astnameFunction(evalResult : FnArgResult) -> Sexpr {
	// Ensure we have exactly 1 argument
	if (length(evalResult.args) != 1) {
		println("ERROR: astname expects 1 argument");
		SSString("");
	} else {
		// Return the structure name of the Sexpr
		typename = switch (evalResult.args[0]) {
			SSInt(__): "Int";
			SSDouble(__): "Double";
			SSBool(__): "Bool";
			SSString(__): "String";
			SSVariable(__): "Variable";
			SSConstructor(__): "Constructor";
			SSOperator(__): "Operator";
			SSList(__): "List";
			SSSpecialForm(name, __): "Special";
		}
		SSString(typename);
	}
}

// Implementation of varname function
varnameFunction(evalResult : FnArgResult) -> Sexpr {
	// Ensure we have exactly 1 argument
	if (length(evalResult.args) != 1) {
		println("ERROR: varname expects 1 argument");
		SSString("");
	} else {
		// Extract the name if it's a variable, otherwise return empty string
		name = switch (evalResult.args[0]) {
			SSVariable(id): id;
			SSConstructor(id): id; // Include constructors as well
			SSOperator(id): id;    // Include operators too
			default: "";
		}
		SSString(name);
	}
}

// Implementation of getFileContent function
getFileContentFunction(evalResult : FnArgResult) -> Sexpr {
	// Ensure we have exactly 1 argument
	if (length(evalResult.args) != 1) {
		println("ERROR: getFileContent expects 1 argument");
		SSString("");
	} else {
		// Get the file path
		path = getSString(evalResult.args[0], "getFileContent.path");
		
		// Read the file content (using the Flow9 getFileContent function)
		content = getFileContent(path);
		
		SSString(content);
	}
}

// Implementation of setFileContent function
setFileContentFunction(evalResult : FnArgResult) -> Sexpr {
	// Ensure we have exactly 2 arguments
	if (length(evalResult.args) != 2) {
		println("ERROR: setFileContent expects 2 arguments");
		SSBool(false);
	} else {
		// Get the file path and content
		path = getSString(evalResult.args[0], "setFileContent.path");
		content = getSString(evalResult.args[1], "setFileContent.content");
		
		// Write the content to the file (using the Flow9 setFileContent function)
		success = setFileContent(path, content);
		
		SSBool(success);
	}
}

// Implementation of getCommandLineArgs function
getCommandLineArgsFunction(evalResult : FnArgResult) -> Sexpr {
	// This function doesn't require any arguments
	if (length(evalResult.args) != 0) {
		println("WARNING: getCommandLineArgs doesn't need arguments");
	}
	
	// Get all command line arguments as an array
	commandLineArgs = filtermap(getAllUrlParametersArray(), \a -> 
		if (a[1] == "") Some(a[0]) else None()
	);
	
	// Convert to a list of SSString
	result = SSList(map(commandLineArgs, \arg -> SSString(arg)));
	result;
}

// Implementation of parseSexpr function
parseSexprFunction(evalResult : FnArgResult) -> Sexpr {
	// Ensure we have exactly 1 argument
	if (length(evalResult.args) != 1) {
		println("ERROR: parseSexpr expects 1 argument");
		SSList([]);
	} else {
		// Get the code string
		code = getSString(evalResult.args[0], "parseSexpr.code");
		
		// Note: We need to assume parseSexpr is implemented elsewhere
		// For now, let's create a placeholder implementation that
		// returns a pair with the parsed expression and any error message
		mcode = parseSexpr("parseSexpr", code);
		mcode ?? {
			mcode;
		} : {
			SSList([]);
		}
	}
}

// Global counter for unique IDs with prefixes
globalUidCounters : ref Tree<string, int> = ref makeTree();

// Implementation of uid function
uidFunction(evalResult : FnArgResult) -> Sexpr {
	// Ensure we have exactly 1 argument
	if (length(evalResult.args) != 1) {
		println("ERROR: uid expects 1 argument");
		SSString("");
	} else {
		// Get the prefix
		prefix = getSString(evalResult.args[0], "uid.prefix");
		
		// Generate a unique ID with this prefix
		currentCount = lookupTreeDef(^globalUidCounters, prefix, 0);
		globalUidCounters := setTree(^globalUidCounters, prefix, currentCount + 1);
		result = prefix + i2s(currentCount);
		
		SSString(result);
	}
}

// ------ OGraph Functions ------

// Implementation of makeOGraph function
makeOGraphSexpr(evalResult : FnArgResult) -> Sexpr {
	// Ensure we have exactly 1 argument
	if (length(evalResult.args) != 1) {
		println("ERROR: makeOGraph expects 1 argument");
		SSString("");
	} else {
		// Get the graph name
		name = getSString(evalResult.args[0], "makeOGraph.name");
		
		// Create the graph
		createOGraph(name);
		
		// Return the name
		SSString(name);
	}
}

// Implementation of addSexpr2OGraph function
addSexpr2OGraphFunction(evalResult : FnArgResult) -> Sexpr {
	// Ensure we have exactly 2 arguments
	if (length(evalResult.args) != 2) {
		println("ERROR: addSexpr2OGraph expects 2 arguments");
		SSInt(-1);
	} else {
		// Get the graph name
		name = getSString(evalResult.args[0], "addSexpr2OGraph.name");
		
		// Get the S-expression
		sexpr = evalResult.args[1];
		
		// Get the graph from the registry
		switch (lookupTree(^ographRegistry, name)) {
			Some(ograph): {
				// Add the S-expression to the graph
				nodeId = sexp2OGraphWithSubstitution(ograph, sexpr, makeTree());
				
				// Return the node ID
				SSInt(nodeId);
			}
			None(): {
				println("ERROR: OGraph '" + name + "' not found");
				SSInt(-1);
			}
		}
	}
}

// Implementation of addSexprWithSub function
addSexprWithSubFunction(evalResult : FnArgResult) -> Sexpr {
	// Ensure we have exactly 3 arguments
	if (length(evalResult.args) != 3) {
		println("ERROR: addSexprWithSub expects 3 arguments");
		SSInt(-1);
	} else {
		// Get the graph name
		name = getSString(evalResult.args[0], "addSexprWithSub.name");
		
		// Get the S-expression
		sexpr = evalResult.args[1];
		
		// Get the variable bindings (mapping from variable name to node ID)
		switch (evalResult.args[2]) {
			SSList(pairs): {
				// Convert the list of pairs to a tree
				bindings = fold(pairs, makeTree(), \acc, pair -> {
					switch (pair) {
						SSList(items): {
							if (length(items) == 2) {
								// Extract key and value
								key = getSString(items[0], "addSexprWithSub.binding.key");
								value = getSInt(items[1], "addSexprWithSub.binding.value");
								
								// Add to the bindings map
								setTree(acc, key, value);
							} else {
								println("ERROR: Each binding must be a list of exactly 2 elements");
								acc;
							}
						}
						default: {
							println("ERROR: Each binding must be a list");
							acc;
						}
					}
				});
				
				// Get the graph from the registry
				switch (lookupTree(^ographRegistry, name)) {
					Some(ograph): {
						// Add the S-expression to the graph with substitutions
						nodeId = sexp2OGraphWithSubstitution(ograph, sexpr, bindings);
						
						// Return the node ID
						SSInt(nodeId);
					}
					None(): {
						println("ERROR: OGraph '" + name + "' not found");
						SSInt(-1);
					}
				}
			}
			default: {
				println("ERROR: addSexprWithSub third argument must be a list of bindings");
				SSInt(-1);
			}
		}
	}
}

// Implementation of extractOGraphSexpr function
extractOGraphSexprFunction(evalResult : FnArgResult) -> Sexpr {
	// Ensure we have exactly 2 arguments
	if (length(evalResult.args) != 2) {
		println("ERROR: extractOGraphSexpr expects 2 arguments");
		SSString("<ERROR: Invalid arguments>");
	} else {
		// Get the graph name
		name = getSString(evalResult.args[0], "extractOGraphSexpr.name");
		
		// Get the node ID
		nodeId = getSInt(evalResult.args[1], "extractOGraphSexpr.nodeId");
		
		// Extract the S-expression from the graph
		extractOGraphSexpr(name, nodeId, false);
	}
}

// Implementation of matchOGraphSexprPattern function
matchOGraphSexprPatternFunction(evalResult : FnArgResult) -> Sexpr {
	// Ensure we have exactly 3 arguments
	if (length(evalResult.args) != 3) {
		println("ERROR: matchOGraphSexprPattern expects 3 arguments");
		SSInt(0);
	} else {
		// Get the graph name
		name = getSString(evalResult.args[0], "matchOGraphSexprPattern.name");
		
		// Get the pattern
		pattern = evalResult.args[1];
		
		// Get the callback function
		callback = evalResult.args[2];
		
		// Check that the callback is a lambda
		switch (callback) {
			SSSpecialForm(form, _): {
				if (form == SLambda()) {
					// Store the results of pattern matching
					results = ref [];
					
					// Create a callback adapter that will be called for each match
					matchCallback = \bindings, eclassId -> {
						// Convert bindings to S-expression friendly format
						bindingsList = map(getTreeKeys(bindings), \key -> {
							value = lookupTreeDef(bindings, key, -1);
							SSList([SSString(key), SSInt(value)]);
						});
						
						// Create the arguments for the callback
						args = [SSList(bindingsList), SSInt(eclassId)];
						
						// Save the binding information
						results := concat(^results, args);
					};
					
					// Call the pattern matcher
					matchCount = matchOGraphSexprPattern(name, pattern, matchCallback, false);
					
					// Return the number of matches and the results
					SSList([SSInt(matchCount), SSList(^results)]);
				} else {
					println("ERROR: matchOGraphSexprPattern callback must be a lambda");
					SSInt(0);
				}
			}
			default: {
				println("ERROR: matchOGraphSexprPattern callback must be a lambda");
				SSInt(0);
			}
		}
	}
}

// Implementation of addDomainToNode function
addDomainToNodeSexpr(evalResult : FnArgResult) -> Sexpr {
	// Ensure we have exactly 3 arguments
	if (length(evalResult.args) != 3) {
		println("ERROR: addDomainToNode expects 3 arguments");
		SSBool(false);
	} else {
		// Get the graph name
		name = getSString(evalResult.args[0], "addDomainToNode.name");
		
		// Get the node ID
		nodeId = getSInt(evalResult.args[1], "addDomainToNode.nodeId");
		
		// Get the domain node ID
		domainId = getSInt(evalResult.args[2], "addDomainToNode.domainId");
		
		// Add the domain to the node
		success = addDomainToNode(name, nodeId, domainId);
		
		// Return success status
		SSBool(success);
	}
}

// Implementation of mergeOGraphNodes function
mergeOGraphNodesSexpr(evalResult : FnArgResult) -> Sexpr {
	// Ensure we have exactly 3 arguments
	if (length(evalResult.args) != 3) {
		println("ERROR: mergeOGraphNodes expects 3 arguments");
		SSBool(false);
	} else {
		// Get the graph name
		name = getSString(evalResult.args[0], "mergeOGraphNodes.name");
		
		// Get the first node ID
		nodeId1 = getSInt(evalResult.args[1], "mergeOGraphNodes.nodeId1");
		
		// Get the second node ID
		nodeId2 = getSInt(evalResult.args[2], "mergeOGraphNodes.nodeId2");
		
		// Merge the nodes
		success = mergeOGraphNodes(name, nodeId1, nodeId2);
		
		// Return success status
		SSBool(success);
	}
}

// ------ OrMathExp with OGraph Functions ------

// Add an Orbit math expression to an OGraph (converts to S-expression first)
addOrbit2OGraph(graphName : string, expr : OrMath_expr) -> int {
	// Convert the OrMath_expr to Sexpr
	sexpr = orbit2sexpr(expr);
	
	// Get the graph from the registry
	switch (lookupTree(^ographRegistry, graphName)) {
		Some(ograph): {
			// Add the S-expression to the graph
			sexp2OGraphWithSubstitution(ograph, sexpr, makeTree());
		}
		None(): {
			println("ERROR: OGraph '" + graphName + "' not found");
			-1;
		}
	}
}

// Add an Orbit math expression to an OGraph with variable substitutions
addOrbitWithSub(graphName : string, expr : OrMath_expr, bindings : Tree<string, int>) -> int {
	// Convert the OrMath_expr to Sexpr
	sexpr = orbit2sexpr(expr);
	
	// Get the graph from the registry
	switch (lookupTree(^ographRegistry, graphName)) {
		Some(ograph): {
			// Add the S-expression to the graph with substitutions
			sexp2OGraphWithSubstitution(ograph, sexpr, bindings);
		}
		None(): {
			println("ERROR: OGraph '" + graphName + "' not found");
			-1;
		}
	}
}

// Extract an Orbit math expression from an OGraph node (converts from S-expression)
extractOGraphOrbit(graphName : string, nodeId : int, tracing : bool) -> OrMath_expr {
	// Get the graph from the registry
	switch (lookupTree(^ographRegistry, graphName)) {
		Some(ograph): {
			// Extract the S-expression from the graph
			sexpr = extractOGraphSexpr(graphName, nodeId, tracing);
			
			// Convert the S-expression to OrMath_expr
			sexpr2orbit(sexpr);
		}
		None(): {
			println("ERROR: OGraph '" + graphName + "' not found");
			OrInt(0); // Return a simple zero expression as fallback
		}
	}
}

// Match an Orbit math expression pattern in an OGraph
matchOGraphOrbitPattern(graphName : string, pattern : OrMath_expr, callback : (Tree<string, int>, int) -> void, tracing : bool) -> int {
	// Convert the OrMath_expr pattern to Sexpr
	patternSexpr = orbit2sexpr(pattern);
	
	// Use the S-expression pattern matching
	matchOGraphSexprPattern(graphName, patternSexpr, callback, tracing);
}

// Implementation of orbit2sexpr function for the runtime environment
orbit2sexprFunction(evalResult : FnArgResult) -> Sexpr {
	// Ensure we have exactly 1 argument
	if (length(evalResult.args) != 1) {
		println("ERROR: orbit2sexpr expects 1 argument");
		SSList([]);
	} else {
		// Convert the first argument to Orbit expression
		orbitExpr = sexpr2orbit(evalResult.args[0]);
		
		// Convert back to S-expression (normalizing/canonicalizing)
		orbit2sexpr(orbitExpr);
	}
}

// Implementation of sexpr2orbit function for the runtime environment
sexpr2orbitFunction(evalResult : FnArgResult) -> Sexpr {
	// Ensure we have exactly 1 argument
	if (length(evalResult.args) != 1) {
		println("ERROR: sexpr2orbit expects 1 argument");
		SSList([]);
	} else {
		// Convert the S-expression to Orbit expression
		orbitExpr = sexpr2orbit(evalResult.args[0]);
		
		// Convert back to S-expression for return
		orbit2sexpr(orbitExpr);
	}
}

// Implementation of prettyOrbit function
prettyOrbitSexp(evalResult : FnArgResult) -> Sexpr {
	// Ensure we have exactly 1 argument
	if (length(evalResult.args) != 1) {
		println("ERROR: prettyOrbit expects 1 argument");
		SSString("");
	} else {
		// Convert the S-expression to Orbit expression
		orbitExpr = sexpr2orbit(evalResult.args[0]);
		
		// Pretty print the Orbit expression
		SSString(prettyOrbit(orbitExpr));
	}
}