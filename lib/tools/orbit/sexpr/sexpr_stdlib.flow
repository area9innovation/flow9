import tools/orbit/sexpr/sexpr_types;
import tools/orbit/sexpr/pretty_sexpr;
import tools/orbit/sexpr/sexpr_pattern;
import tools/orbit/sexpr/utils;
import ds/tree;
import string;
import math/math;
import net/url_parameter; // For command line args

export {
	// Result of evaluation is a pair of (new environment, result value)
	SexprResult(env : Tree<string, Sexpr>, value : Sexpr);

	// Result of evaluating function arguments
	FnArgResult(env : Tree<string, Sexpr>, args : [Sexpr]);
	
	// Runtime function definition
	RuntimeFn(arity : int, fn : (FnArgResult) -> SexprResult);

	// Add standard functions/variables to the environment
	addStandardFns(env : Tree<string, Sexpr>) -> Tree<string, Sexpr>;
	
	// Get the runtime functions map
	getRuntimeFunctions() -> Tree<string, RuntimeFn>;
	
	// Helper for invoking runtime functions with arity checking
	invokeRuntimeFn(name : string, result : FnArgResult) -> SexprResult;
}

// Helper for invoking runtime functions with arity checking
invokeRuntimeFn(name : string, result : FnArgResult) -> SexprResult {
	maybe = lookupTree(getRuntimeFunctions(), name);
	switch (maybe) {
		Some(runtimeFn): {
			// Check arity if expected value is not -1 (variable arity)
			if (runtimeFn.arity != -1 && length(result.args) != runtimeFn.arity) {
				println("ERROR: " + name + " expects " + i2s(runtimeFn.arity) + " arguments, got " + i2s(length(result.args)));
				SexprResult(result.env, SSList([]));
			} else {
				// Invoke the function implementation
				runtimeFn.fn(result);
			}
		}
		None(): {
			println("ERROR: Unknown runtime function: " + name);
			SexprResult(result.env, SSList([]));
		}
	}
}

// Get the runtime functions map
getRuntimeFunctions() -> Tree<string, RuntimeFn> {
	functionPairs = [
		// Arithmetic operators
		Pair("+", RuntimeFn(-1, \result -> addNumbers(result))),
		Pair("-", RuntimeFn(-1, \result -> subtractNumbers(result))),
		Pair("*", RuntimeFn(-1, \result -> multiplyNumbers(result))),
		Pair("/", RuntimeFn(-1, \result -> divideNumbers(result))),
		Pair("=", RuntimeFn(2, \result -> equalsCheck(result))),
		
		// List operations
		Pair("list", RuntimeFn(-1, \result -> SexprResult(result.env, SSList(result.args)))),
		Pair("car", RuntimeFn(1, \result -> carFunction(result))),
		Pair("cdr", RuntimeFn(1, \result -> cdrFunction(result))),
		Pair("cons", RuntimeFn(2, \result -> consFunction(result))),
		Pair("print", RuntimeFn(-1, \result -> printFunction(result))),
		
		// Math functions
		Pair("abs", RuntimeFn(1, \result -> absFunction(result))),
		Pair("iabs", RuntimeFn(1, \result -> iabsFunction(result))),
		Pair("sin", RuntimeFn(1, \result -> sinFunction(result))),
		Pair("cos", RuntimeFn(1, \result -> cosFunction(result))),
		Pair("tan", RuntimeFn(1, \result -> tanFunction(result))),
		Pair("asin", RuntimeFn(1, \result -> asinFunction(result))),
		Pair("acos", RuntimeFn(1, \result -> acosFunction(result))),
		Pair("atan", RuntimeFn(1, \result -> atanFunction(result))),
		Pair("atan2", RuntimeFn(2, \result -> atan2Function(result))),
		Pair("sqrt", RuntimeFn(1, \result -> sqrtFunction(result))),
		Pair("exp", RuntimeFn(1, \result -> expFunction(result))),
		Pair("log", RuntimeFn(1, \result -> logFunction(result))),
		Pair("log10", RuntimeFn(1, \result -> log10Function(result))),
		Pair("floor", RuntimeFn(1, \result -> floorFunction(result))),
		Pair("ceil", RuntimeFn(1, \result -> ceilFunction(result))),
		Pair("round", RuntimeFn(1, \result -> roundFunction(result))),
		Pair("dfloor", RuntimeFn(1, \result -> dfloorFunction(result))),
		Pair("dceil", RuntimeFn(1, \result -> dceilFunction(result))),
		Pair("dround", RuntimeFn(1, \result -> droundFunction(result))),
		Pair("sign", RuntimeFn(1, \result -> signFunction(result))),
		Pair("isign", RuntimeFn(1, \result -> isignFunction(result))),
		Pair("even", RuntimeFn(1, \result -> evenFunction(result))),
		Pair("odd", RuntimeFn(1, \result -> oddFunction(result))),
		Pair("mod", RuntimeFn(2, \result -> modFunction(result))),
		Pair("dmod", RuntimeFn(2, \result -> dmodFunction(result))),
		Pair("factorial", RuntimeFn(1, \result -> factorialFunction(result))),
		Pair("gcd", RuntimeFn(2, \result -> gcdFunction(result))),
		Pair("lcm", RuntimeFn(2, \result -> lcmFunction(result))),
		
		// Logic functions
		Pair("not", RuntimeFn(1, \result -> notFunction(result))),
		
		// String operations
		Pair("strlen", RuntimeFn(1, \result -> strlenFunction(result))),
		Pair("substring", RuntimeFn(3, \result -> substringFunction(result))),
		Pair("strIndex", RuntimeFn(2, \result -> strIndexFunction(result))),
		Pair("strContainsAt", RuntimeFn(3, \result -> strContainsAtFunction(result))),
		Pair("parseHex", RuntimeFn(1, \result -> parseHexFunction(result))),
		Pair("unescape", RuntimeFn(1, \result -> unescapeFunction(result))),
		Pair("escape", RuntimeFn(1, \result -> escapeFunction(result))),
		Pair("strGlue", RuntimeFn(2, \result -> strGlueFunction(result))),
		Pair("capitalize", RuntimeFn(1, \result -> capitalizeFunction(result))),
		Pair("decapitalize", RuntimeFn(1, \result -> decapitalizeFunction(result))),
		
		// Type conversions
		Pair("i2s", RuntimeFn(1, \result -> i2sFunction(result))),
		Pair("d2s", RuntimeFn(1, \result -> d2sFunction(result))),
		Pair("i2b", RuntimeFn(1, \result -> i2bFunction(result))),
		Pair("b2i", RuntimeFn(1, \result -> b2iFunction(result))),
		Pair("s2i", RuntimeFn(1, \result -> s2iFunction(result))),
		Pair("s2d", RuntimeFn(1, \result -> s2dFunction(result))),
		
		// Type checking
		Pair("isBool", RuntimeFn(1, \result -> isBoolFunction(result))),
		Pair("isInt", RuntimeFn(1, \result -> isIntFunction(result))),
		Pair("isDouble", RuntimeFn(1, \result -> isDoubleFunction(result))),
		Pair("isString", RuntimeFn(1, \result -> isStringFunction(result))),
		Pair("isArray", RuntimeFn(1, \result -> isArrayFunction(result))),
		
		// Array/list operations
		Pair("length", RuntimeFn(1, \result -> lengthFunction(result))),
		Pair("index", RuntimeFn(2, \result -> indexFunction(result))),
		Pair("subrange", RuntimeFn(3, \result -> subrangeFunction(result))),
		Pair("reverse", RuntimeFn(1, \result -> reverseFunction(result))),
		
		// New functions (ported from orbit)
		Pair("prettySexpr", RuntimeFn(1, \result -> prettySexprFunction(result))),
		Pair("astname", RuntimeFn(1, \result -> astnameFunction(result))),
		Pair("varname", RuntimeFn(1, \result -> varnameFunction(result))),
		Pair("getFileContent", RuntimeFn(1, \result -> getFileContentFunction(result))),
		Pair("setFileContent", RuntimeFn(2, \result -> setFileContentFunction(result))),
		Pair("getCommandLineArgs", RuntimeFn(0, \result -> getCommandLineArgsFunction(result))),
		Pair("parseSexpr", RuntimeFn(1, \result -> parseSexprFunction(result))),
		Pair("uid", RuntimeFn(1, \result -> uidFunction(result)))
	];
	
	pairs2tree(functionPairs);
}

// Add standard functions/variables to the environment
addStandardFns(env : Tree<string, Sexpr>) -> Tree<string, Sexpr> {
	// Get runtime functions registry
	runtimeFunctions = getTreeKeys(getRuntimeFunctions());
	
	// Add operators as operators
	env1 = setTree(env, "+", SSOperator("+"));
	env2 = setTree(env1, "-", SSOperator("-"));
	env3 = setTree(env2, "*", SSOperator("*"));
	env4 = setTree(env3, "/", SSOperator("/"));
	env5 = setTree(env4, "=", SSOperator("="));
	
	// Add other functions as variables
	fold(runtimeFunctions, env5, \acc, name -> {
		if (name == "+" || name == "-" || name == "*" || name == "/" || name == "=") {
			// Already added as operators
			acc;
		} else {
			setTree(acc, name, SSVariable(name));
		}
	});
}

// Helper functions for basic operations

// Add numbers
addNumbers(evalResult : FnArgResult) -> SexprResult {
	result = fold(evalResult.args, SSInt(0), \acc, arg -> {
		switch (acc) {
			SSInt(accInt): {
				switch (arg) {
					SSInt(argInt): SSInt(accInt + argInt);
					SSDouble(argDouble): SSDouble(i2d(accInt) + argDouble);
					default: {
						println("Cannot add non-number: " + prettySexpr(arg));
						acc;
					}
				}
			};
			SSDouble(accDouble): {
				switch (arg) {
					SSInt(argInt): SSDouble(accDouble + i2d(argInt));
					SSDouble(argDouble): SSDouble(accDouble + argDouble);
					default: {
						println("Cannot add non-number: " + prettySexpr(arg));
						acc;
					}
				}
			};
			default: acc;
		}
	});
	
	SexprResult(evalResult.env, result);
}

// Subtract numbers
subtractNumbers(evalResult : FnArgResult) -> SexprResult {
	if (length(evalResult.args) == 0) {
		SexprResult(evalResult.env, SSInt(0));
	} else {
		// Get first arg
		first = evalResult.args[0];
		
		// If only one argument, negate it
		if (length(evalResult.args) == 1) {
			result = switch (first) {
				SSInt(i): SSInt(-i);
				SSDouble(d): SSDouble(-d);
				default: {
					println("Cannot negate non-number: " + prettySexpr(first));
					first;
				};
			};
			SexprResult(evalResult.env, result);
		} else {
			// Subtract rest from first
			rest = tailFrom(evalResult.args, 1);
			result = fold(rest, first, \acc, arg -> {
				switch (acc) {
					SSInt(accInt): {
						switch (arg) {
							SSInt(argInt): SSInt(accInt - argInt);
							SSDouble(argDouble): SSDouble(i2d(accInt) - argDouble);
							default: {
								println("Cannot subtract non-number: " + prettySexpr(arg));
								acc;
							}
						}
					};
					SSDouble(accDouble): {
						switch (arg) {
							SSInt(argInt): SSDouble(accDouble - i2d(argInt));
							SSDouble(argDouble): SSDouble(accDouble - argDouble);
							default: {
								println("Cannot subtract non-number: " + prettySexpr(arg));
								acc;
							}
						}
					};
					default: acc;
				}
			});
			SexprResult(evalResult.env, result);
		}
	}
}

// Multiply numbers
multiplyNumbers(evalResult : FnArgResult) -> SexprResult {
	result = fold(evalResult.args, SSInt(1), \acc, arg -> {
		switch (acc) {
			SSInt(accInt): {
				switch (arg) {
					SSInt(argInt): SSInt(accInt * argInt);
					SSDouble(argDouble): SSDouble(i2d(accInt) * argDouble);
					default: {
						println("Cannot multiply non-number: " + prettySexpr(arg));
						acc;
					}
				}
			};
			SSDouble(accDouble): {
				switch (arg) {
					SSInt(argInt): SSDouble(accDouble * i2d(argInt));
					SSDouble(argDouble): SSDouble(accDouble * argDouble);
					default: {
						println("Cannot multiply non-number: " + prettySexpr(arg));
						acc;
					}
				}
			};
			default: acc;
		}
	});
	
	SexprResult(evalResult.env, result);
}

// Divide numbers
divideNumbers(evalResult : FnArgResult) -> SexprResult {
	if (length(evalResult.args) == 0) {
		SexprResult(evalResult.env, SSInt(1));
	} else {
		// Get first arg
		first = evalResult.args[0];
		
		// If only one argument, invert it (1/x)
		if (length(evalResult.args) == 1) {
			result = switch (first) {
				SSInt(i): {
					if (i != 0) SSDouble(1.0 / i2d(i)) else {
						println("Division by zero");
						SSDouble(0.0);
					}
				};
				SSDouble(d): {
					if (d != 0.0) SSDouble(1.0 / d) else {
						println("Division by zero");
						SSDouble(0.0);
					}
				};
				default: {
					println("Cannot invert non-number: " + prettySexpr(first));
					first;
				};
			};
			SexprResult(evalResult.env, result);
		} else {
			// Divide first by rest
			rest = tailFrom(evalResult.args, 1);
			result = fold(rest, first, \acc, arg -> {
				switch (acc) {
					SSInt(accInt): {
						switch (arg) {
							SSInt(argInt): {
								if (argInt != 0) {
									// Convert to double for division
									SSDouble(i2d(accInt) / i2d(argInt));
								} else {
									println("Division by zero");
									acc;
								}
							};
							SSDouble(argDouble): {
								if (argDouble != 0.0) {
									SSDouble(i2d(accInt) / argDouble);
								} else {
									println("Division by zero");
									acc;
								}
							};
							default: {
								println("Cannot divide by non-number: " + prettySexpr(arg));
								acc;
							};
						}
					};
					SSDouble(accDouble): {
						switch (arg) {
							SSInt(argInt): {
								if (argInt != 0) {
									SSDouble(accDouble / i2d(argInt));
								} else {
									println("Division by zero");
									acc;
								}
							};
							SSDouble(argDouble): {
								if (argDouble != 0.0) {
									SSDouble(accDouble / argDouble);
								} else {
									println("Division by zero");
									acc;
								}
							};
							default: {
								println("Cannot divide by non-number: " + prettySexpr(arg));
								acc;
							};
						}
					};
					default: acc;
				}
			});
			SexprResult(evalResult.env, result);
		}
	}
}

// Equality check
equalsCheck(evalResult : FnArgResult) -> SexprResult {
	allEqual = sexprEquals(evalResult.args[0], evalResult.args[1]);
	SexprResult(evalResult.env, SSBool(allEqual));
}

// List operations

carFunction(evalResult : FnArgResult) -> SexprResult {
	switch (evalResult.args[0]) {
		SSList(items): {
			if (length(items) > 0) {
				SexprResult(evalResult.env, items[0]);
			} else {
				println("car: empty list");
				SexprResult(evalResult.env, SSList([]));
			}
		}
		default: {
			println("car requires a list argument");
			SexprResult(evalResult.env, SSList([]));
		};
	}
}

cdrFunction(evalResult : FnArgResult) -> SexprResult {
	switch (evalResult.args[0]) {
		SSList(items): {
			if (length(items) > 0) {
				SexprResult(evalResult.env, SSList(tailFrom(items, 1)));
			} else {
				SexprResult(evalResult.env, SSList([]));
			}
		}
		default: {
			println("cdr requires a list argument");
			SexprResult(evalResult.env, SSList([]));
		};
	}
}

consFunction(evalResult : FnArgResult) -> SexprResult {
	elem = evalResult.args[0];
	rest = evalResult.args[1];
	
	switch (rest) {
		SSList(items): {
			SexprResult(evalResult.env, SSList(concat([elem], items)));
		}
		default: {
			// In Scheme, cons can create pairs, but for simplicity
			// we'll just create a list
			SexprResult(evalResult.env, SSList([elem, rest]));
		};
	}
}

// Print function
printFunction(evalResult : FnArgResult) -> SexprResult {
	// Evaluate and print args recursively
	iter(evalResult.args, \arg -> {
		println(prettySexpr(arg));
	});

	SexprResult(evalResult.env, SSList([])); // Default result
}

// ----- Functions from orbit_runtime -----

// Absolute value for doubles
absFunction(evalResult : FnArgResult) -> SexprResult {
	value = getSDouble(evalResult.args[0], "abs");
	SexprResult(evalResult.env, SSDouble(abs(value)));
}

// Absolute value for integers
iabsFunction(evalResult : FnArgResult) -> SexprResult {
	value = getSInt(evalResult.args[0], "iabs");
	SexprResult(evalResult.env, SSInt(iabs(value)));
}

// Sine function
sinFunction(evalResult : FnArgResult) -> SexprResult {
	value = getSDouble(evalResult.args[0], "sin");
	SexprResult(evalResult.env, SSDouble(sin(value)));
}

// Cosine function
cosFunction(evalResult : FnArgResult) -> SexprResult {
	value = getSDouble(evalResult.args[0], "cos");
	SexprResult(evalResult.env, SSDouble(cos(value)));
}

// Tangent function
tanFunction(evalResult : FnArgResult) -> SexprResult {
	value = getSDouble(evalResult.args[0], "tan");
	SexprResult(evalResult.env, SSDouble(tan(value)));
}

// Arc sine function
asinFunction(evalResult : FnArgResult) -> SexprResult {
	value = getSDouble(evalResult.args[0], "asin");
	SexprResult(evalResult.env, SSDouble(asin(value)));
}

// Arc cosine function
acosFunction(evalResult : FnArgResult) -> SexprResult {
	value = getSDouble(evalResult.args[0], "acos");
	SexprResult(evalResult.env, SSDouble(acos(value)));
}

// Arc tangent function
atanFunction(evalResult : FnArgResult) -> SexprResult {
	value = getSDouble(evalResult.args[0], "atan");
	SexprResult(evalResult.env, SSDouble(atan(value)));
}

// Arc tangent of y/x function
atan2Function(evalResult : FnArgResult) -> SexprResult {
	y = getSDouble(evalResult.args[0], "atan2 y");
	x = getSDouble(evalResult.args[1], "atan2 x");
	SexprResult(evalResult.env, SSDouble(atan2(y, x)));
}

// Square root function
sqrtFunction(evalResult : FnArgResult) -> SexprResult {
	value = getSDouble(evalResult.args[0], "sqrt");
	SexprResult(evalResult.env, SSDouble(sqrt(value)));
}

// Exponential function
expFunction(evalResult : FnArgResult) -> SexprResult {
	value = getSDouble(evalResult.args[0], "exp");
	SexprResult(evalResult.env, SSDouble(exp(value)));
}

// Natural logarithm function
logFunction(evalResult : FnArgResult) -> SexprResult {
	value = getSDouble(evalResult.args[0], "log");
	SexprResult(evalResult.env, SSDouble(log(value)));
}

// Base-10 logarithm function
log10Function(evalResult : FnArgResult) -> SexprResult {
	value = getSDouble(evalResult.args[0], "log10");
	SexprResult(evalResult.env, SSDouble(log(value) / log(10.0)));
}

// Floor function (returns integer)
floorFunction(evalResult : FnArgResult) -> SexprResult {
	value = getSDouble(evalResult.args[0], "floor");
	SexprResult(evalResult.env, SSInt(floor(value)));
}

// Ceiling function (returns integer)
ceilFunction(evalResult : FnArgResult) -> SexprResult {
	value = getSDouble(evalResult.args[0], "ceil");
	SexprResult(evalResult.env, SSInt(ceil(value)));
}

// Round function (returns integer)
roundFunction(evalResult : FnArgResult) -> SexprResult {
	value = getSDouble(evalResult.args[0], "round");
	SexprResult(evalResult.env, SSInt(round(value)));
}

// Floor function (returns double)
dfloorFunction(evalResult : FnArgResult) -> SexprResult {
	value = getSDouble(evalResult.args[0], "dfloor");
	SexprResult(evalResult.env, SSDouble(dfloor(value)));
}

// Ceiling function (returns double)
dceilFunction(evalResult : FnArgResult) -> SexprResult {
	value = getSDouble(evalResult.args[0], "dceil");
	SexprResult(evalResult.env, SSDouble(dceil(value)));
}

// Round function (returns double)
droundFunction(evalResult : FnArgResult) -> SexprResult {
	value = getSDouble(evalResult.args[0], "dround");
	SexprResult(evalResult.env, SSDouble(dround(value)));
}

// Sign function (returns double)
signFunction(evalResult : FnArgResult) -> SexprResult {
	value = getSDouble(evalResult.args[0], "sign");
	SexprResult(evalResult.env, SSDouble(sign(value)));
}

// Sign function (returns integer)
isignFunction(evalResult : FnArgResult) -> SexprResult {
	value = getSInt(evalResult.args[0], "isign");
	SexprResult(evalResult.env, SSInt(isign(value)));
}

// Check if number is even
evenFunction(evalResult : FnArgResult) -> SexprResult {
	value = getSInt(evalResult.args[0], "even");
	SexprResult(evalResult.env, SSBool(even(value)));
}

// Check if number is odd
oddFunction(evalResult : FnArgResult) -> SexprResult {
	value = getSInt(evalResult.args[0], "odd");
	SexprResult(evalResult.env, SSBool(odd(value)));
}

// Modulo function for integers
modFunction(evalResult : FnArgResult) -> SexprResult {
	value1 = getSInt(evalResult.args[0], "mod dividend");
	value2 = getSInt(evalResult.args[1], "mod divisor");
	
	if (value2 == 0) {
		println("ERROR: mod division by zero");
		SexprResult(evalResult.env, SSInt(0));
	} else {
		SexprResult(evalResult.env, SSInt(mod(value1, value2)));
	}
}

// Modulo function for doubles
dmodFunction(evalResult : FnArgResult) -> SexprResult {
	value1 = getSDouble(evalResult.args[0], "dmod dividend");
	value2 = getSDouble(evalResult.args[1], "dmod divisor");
	
	if (value2 == 0.0) {
		println("ERROR: dmod division by zero");
		SexprResult(evalResult.env, SSDouble(0.0));
	} else {
		SexprResult(evalResult.env, SSDouble(dmod(value1, value2)));
	}
}

// Factorial function
factorialFunction(evalResult : FnArgResult) -> SexprResult {
	value = getSInt(evalResult.args[0], "factorial");
	
	if (value < 0) {
		println("ERROR: factorial requires a non-negative integer");
		SexprResult(evalResult.env, SSInt(0));
	} else {
		SexprResult(evalResult.env, SSInt(factorial(value)));
	}
}

// Greatest common divisor function
gcdFunction(evalResult : FnArgResult) -> SexprResult {
	value1 = getSInt(evalResult.args[0], "gcd first");
	value2 = getSInt(evalResult.args[1], "gcd second");
	SexprResult(evalResult.env, SSInt(gcd(value1, value2)));
}

// Least common multiple function
lcmFunction(evalResult : FnArgResult) -> SexprResult {
	value1 = getSInt(evalResult.args[0], "lcm first");
	value2 = getSInt(evalResult.args[1], "lcm second");
	SexprResult(evalResult.env, SSInt(lcm(value1, value2)));
}

// Logical not function
notFunction(evalResult : FnArgResult) -> SexprResult {
	value = getSBool(evalResult.args[0], "not");
	SexprResult(evalResult.env, SSBool(!value));
}

// String length function
strlenFunction(evalResult : FnArgResult) -> SexprResult {
	str = getSString(evalResult.args[0], "strlen");
	SexprResult(evalResult.env, SSInt(strlen(str)));
}

// Substring function
substringFunction(evalResult : FnArgResult) -> SexprResult {
	str = getSString(evalResult.args[0], "substring string");
	start = getSInt(evalResult.args[1], "substring start");
	length = getSInt(evalResult.args[2], "substring length");
	
	if (start < 0 || start >= strlen(str)) {
		println("ERROR: substring start index out of bounds");
		SexprResult(evalResult.env, SSString(""));
	} else if (length < 0) {
		println("ERROR: substring length must be non-negative");
		SexprResult(evalResult.env, SSString(""));
	} else {
		SexprResult(evalResult.env, SSString(substring(str, start, length)));
	}
}

// Get character at index in string
strIndexFunction(evalResult : FnArgResult) -> SexprResult {
	str = getSString(evalResult.args[0], "strIndex string");
	idx = getSInt(evalResult.args[1], "strIndex index");
	
	if (idx < 0 || idx >= strlen(str)) {
		println("ERROR: strIndex index out of bounds");
		SexprResult(evalResult.env, SSString(""));
	} else {
		SexprResult(evalResult.env, SSString(substring(str, idx, 1)));
	}
}

// Check if string contains substring at index
strContainsAtFunction(evalResult : FnArgResult) -> SexprResult {
	str = getSString(evalResult.args[0], "strContainsAt string");
	idx = getSInt(evalResult.args[1], "strContainsAt index");
	sub = getSString(evalResult.args[2], "strContainsAt substring");
	
	if (idx < 0 || idx >= strlen(str)) {
		SexprResult(evalResult.env, SSBool(false));
	} else if (idx + strlen(sub) > strlen(str)) {
		SexprResult(evalResult.env, SSBool(false));
	} else {
		check = substring(str, idx, strlen(sub));
		SexprResult(evalResult.env, SSBool(check == sub));
	}
}

// Parse hexadecimal string
parseHexFunction(evalResult : FnArgResult) -> SexprResult {
	hexStr = getSString(evalResult.args[0], "parseHex");
	// This is a simplified implementation
	// In a real implementation, we would validate and parse hex
	result = fold(strSplit(hexStr, ""), 0, \acc, c -> {
		digit = if (c >= "0" && c <= "9") s2i(c)
			else if (c >= "a" && c <= "f") s2i(c) - s2i("a") + 10 
			else if (c >= "A" && c <= "F") s2i(c) - s2i("A") + 10
			else -1;
		
		if (digit == -1) acc else acc * 16 + digit;
	});
	SexprResult(evalResult.env, SSInt(result));
}

// Unescape a string
unescapeFunction(evalResult : FnArgResult) -> SexprResult {
	str = getSString(evalResult.args[0], "unescape");
	// Simplified implementation
	result = strReplace(strReplace(strReplace(strReplace(str, "\\n", "\n"), "\\t", "\t"), "\\\\", "\\"), "\\\"", "\"");
	SexprResult(evalResult.env, SSString(result));
}

// Escape a string
escapeFunction(evalResult : FnArgResult) -> SexprResult {
	str = getSString(evalResult.args[0], "escape");
	// Simplified implementation
	result = strReplace(strReplace(strReplace(strReplace(str, "\\", "\\\\"), "\n", "\\n"), "\t", "\\t"), "\"", "\\\"");
	SexprResult(evalResult.env, SSString(result));
}

// Join array of strings with separator
strGlueFunction(evalResult : FnArgResult) -> SexprResult {
	switch (evalResult.args[0]) {
		SSList(items): {
			sep = getSString(evalResult.args[1], "strGlue separator");
			// Convert all items to strings
			strs = map(items, \item -> getSString(item, "strGlue item"));
			SexprResult(evalResult.env, SSString(strGlue(strs, sep)));
		}
		default: {
			println("ERROR: strGlue first argument must be a list");
			SexprResult(evalResult.env, SSString(""));
		}
	}
}

// Capitalize first letter of string
capitalizeFunction(evalResult : FnArgResult) -> SexprResult {
	str = getSString(evalResult.args[0], "capitalize");
	if (strlen(str) == 0) {
		SexprResult(evalResult.env, SSString(""));
	} else {
		first = substring(str, 0, 1);
		rest = substring(str, 1, strlen(str) - 1);
		SexprResult(evalResult.env, SSString(toUpperCase(first) + rest));
	}
}

// Decapitalize first letter of string
decapitalizeFunction(evalResult : FnArgResult) -> SexprResult {
	str = getSString(evalResult.args[0], "decapitalize");
	if (strlen(str) == 0) {
		SexprResult(evalResult.env, SSString(""));
	} else {
		first = substring(str, 0, 1);
		rest = substring(str, 1, strlen(str) - 1);
		SexprResult(evalResult.env, SSString(toLowerCase(first) + rest));
	}
}

// Convert integer to string
i2sFunction(evalResult : FnArgResult) -> SexprResult {
	value = getSInt(evalResult.args[0], "i2s");
	SexprResult(evalResult.env, SSString(i2s(value)));
}

// Convert double to string
d2sFunction(evalResult : FnArgResult) -> SexprResult {
	value = getSDouble(evalResult.args[0], "d2s");
	SexprResult(evalResult.env, SSString(d2s(value)));
}

// Convert integer to boolean
i2bFunction(evalResult : FnArgResult) -> SexprResult {
	value = getSInt(evalResult.args[0], "i2b");
	SexprResult(evalResult.env, SSBool(value != 0));
}

// Convert boolean to integer
b2iFunction(evalResult : FnArgResult) -> SexprResult {
	value = getSBool(evalResult.args[0], "b2i");
	SexprResult(evalResult.env, SSInt(if (value) 1 else 0));
}

// Convert string to integer
s2iFunction(evalResult : FnArgResult) -> SexprResult {
	str = getSString(evalResult.args[0], "s2i");
	SexprResult(evalResult.env, SSInt(s2i(str)));
}

// Convert string to double
s2dFunction(evalResult : FnArgResult) -> SexprResult {
	str = getSString(evalResult.args[0], "s2d");
	SexprResult(evalResult.env, SSDouble(s2d(str)));
}

// Check if value is a boolean
isBoolFunction(evalResult : FnArgResult) -> SexprResult {
	isBool = switch (evalResult.args[0]) {
		SSBool(__): true;
		default: false;
	};
	SexprResult(evalResult.env, SSBool(isBool));
}

// Check if value is an integer
isIntFunction(evalResult : FnArgResult) -> SexprResult {
	isInt = switch (evalResult.args[0]) {
		SSInt(__): true;
		default: false;
	};
	SexprResult(evalResult.env, SSBool(isInt));
}

// Check if value is a double
isDoubleFunction(evalResult : FnArgResult) -> SexprResult {
	isDouble = switch (evalResult.args[0]) {
		SSDouble(__): true;
		default: false;
	};
	SexprResult(evalResult.env, SSBool(isDouble));
}

// Check if value is a string
isStringFunction(evalResult : FnArgResult) -> SexprResult {
	isString = switch (evalResult.args[0]) {
		SSString(__): true;
		default: false;
	};
	SexprResult(evalResult.env, SSBool(isString));
}

// Check if value is an array/list
isArrayFunction(evalResult : FnArgResult) -> SexprResult {
	isArray = switch (evalResult.args[0]) {
		SSList(__): true;
		default: false;
	};
	SexprResult(evalResult.env, SSBool(isArray));
}

// Get length of array/list
lengthFunction(evalResult : FnArgResult) -> SexprResult {
	switch (evalResult.args[0]) {
		SSList(items): {
			SexprResult(evalResult.env, SSInt(length(items)));
		}
		SSString(s): {
			// As a convenience, also work on strings
			SexprResult(evalResult.env, SSInt(strlen(s)));
		}
		default: {
			println("ERROR: length requires a list or string argument");
			SexprResult(evalResult.env, SSInt(0));
		}
	}
}

// Get item at index from array/list
indexFunction(evalResult : FnArgResult) -> SexprResult {
	switch (evalResult.args[0]) {
		SSList(items): {
			idx = getSInt(evalResult.args[1], "index index");
			if (idx < 0 || idx >= length(items)) {
				println("ERROR: index out of bounds");
				SexprResult(evalResult.env, SSList([]));
			} else {
				SexprResult(evalResult.env, items[idx]);
			}
		}
		default: {
			println("ERROR: index requires a list argument");
			SexprResult(evalResult.env, SSList([]));
		}
	}
}

// Get subrange of array/list
subrangeFunction(evalResult : FnArgResult) -> SexprResult {
	switch (evalResult.args[0]) {
		SSList(items): {
			start = getSInt(evalResult.args[1], "subrange start");
			lengthVal = getSInt(evalResult.args[2], "subrange length");
			itemsLength = length(items);
			
			if (start < 0 || start >= itemsLength) {
				println("ERROR: subrange start index out of bounds");
				SexprResult(evalResult.env, SSList([]));
			} else if (lengthVal < 0) {
				println("ERROR: subrange length must be non-negative");
				SexprResult(evalResult.env, SSList([]));
			} else {
				SexprResult(evalResult.env, SSList(subrange(items, start, lengthVal)));
			}
		}
		default: {
			println("ERROR: subrange requires a list argument");
			SexprResult(evalResult.env, SSList([]));
		}
	}
}

// Reverse array/list
reverseFunction(evalResult : FnArgResult) -> SexprResult {
	switch (evalResult.args[0]) {
		SSList(items): {
			SexprResult(evalResult.env, SSList(reverseA(items)));
		}
		default: {
			println("ERROR: reverse requires a list argument");
			SexprResult(evalResult.env, SSList([]));
		}
	}
}

// Implementation of prettySexpr function (equivalent to prettyOrbit)
prettySexprFunction(evalResult : FnArgResult) -> SexprResult {
	// Ensure we have exactly 1 argument
	if (length(evalResult.args) != 1) {
		println("ERROR: prettySexpr expects 1 argument");
		SexprResult(evalResult.env, SSString(""));
	} else {
		// Use the existing prettySexpr function to format the expression
		result = prettySexpr(evalResult.args[0]);
		SexprResult(evalResult.env, SSString(result));
	}
}

// Implementation of astname function to get the type of a Sexpr
astnameFunction(evalResult : FnArgResult) -> SexprResult {
	// Ensure we have exactly 1 argument
	if (length(evalResult.args) != 1) {
		println("ERROR: astname expects 1 argument");
		SexprResult(evalResult.env, SSString(""));
	} else {
		// Return the structure name of the Sexpr
		typename = switch (evalResult.args[0]) {
			SSInt(__): "SSInt";
			SSDouble(__): "SSDouble";
			SSBool(__): "SSBool";
			SSString(__): "SSString";
			SSVariable(__): "SSVariable";
			SSConstructor(__): "SSConstructor";
			SSOperator(__): "SSOperator";
			SSList(__): "SSList";
			SSQuote(__): "SSQuote";
			SSQuasiQuote(__): "SSQuasiQuote";
			SSUnquote(__): "SSUnquote";
			SSUnquoteSplicing(__): "SSUnquoteSplicing";
		}
		SexprResult(evalResult.env, SSString(typename));
	}
}

// Implementation of varname function
varnameFunction(evalResult : FnArgResult) -> SexprResult {
	// Ensure we have exactly 1 argument
	if (length(evalResult.args) != 1) {
		println("ERROR: varname expects 1 argument");
		SexprResult(evalResult.env, SSString(""));
	} else {
		// Extract the name if it's a variable, otherwise return empty string
		name = switch (evalResult.args[0]) {
			SSVariable(id): id;
			SSConstructor(id): id; // Include constructors as well
			SSOperator(id): id;    // Include operators too
			default: "";
		}
		SexprResult(evalResult.env, SSString(name));
	}
}

// Implementation of getFileContent function
getFileContentFunction(evalResult : FnArgResult) -> SexprResult {
	// Ensure we have exactly 1 argument
	if (length(evalResult.args) != 1) {
		println("ERROR: getFileContent expects 1 argument");
		SexprResult(evalResult.env, SSString(""));
	} else {
		// Get the file path
		path = getSString(evalResult.args[0], "getFileContent.path");
		
		// Read the file content (using the Flow9 getFileContent function)
		content = getFileContent(path);
		
		SexprResult(evalResult.env, SSString(content));
	}
}

// Implementation of setFileContent function
setFileContentFunction(evalResult : FnArgResult) -> SexprResult {
	// Ensure we have exactly 2 arguments
	if (length(evalResult.args) != 2) {
		println("ERROR: setFileContent expects 2 arguments");
		SexprResult(evalResult.env, SSBool(false));
	} else {
		// Get the file path and content
		path = getSString(evalResult.args[0], "setFileContent.path");
		content = getSString(evalResult.args[1], "setFileContent.content");
		
		// Write the content to the file (using the Flow9 setFileContent function)
		success = setFileContent(path, content);
		
		SexprResult(evalResult.env, SSBool(success));
	}
}

// Implementation of getCommandLineArgs function
getCommandLineArgsFunction(evalResult : FnArgResult) -> SexprResult {
	// This function doesn't require any arguments
	if (length(evalResult.args) != 0) {
		println("WARNING: getCommandLineArgs doesn't need arguments");
	}
	
	// Get all command line arguments as an array
	commandLineArgs = filtermap(getAllUrlParametersArray(), \a -> 
		if (a[1] == "") Some(a[0]) else None()
	);
	
	// Convert to a list of SSString
	result = SSList(map(commandLineArgs, \arg -> SSString(arg)));
	
	SexprResult(evalResult.env, result);
}

// Implementation of parseSexpr function
parseSexprFunction(evalResult : FnArgResult) -> SexprResult {
	// Ensure we have exactly 1 argument
	if (length(evalResult.args) != 1) {
		println("ERROR: parseSexpr expects 1 argument");
		SexprResult(evalResult.env, SSList([]));
	} else {
		// Get the code string
		code = getSString(evalResult.args[0], "parseSexpr.code");
		
		// Note: We need to assume parseSexpr is implemented elsewhere
		// For now, let's create a placeholder implementation that
		// returns a pair with the parsed expression and any error message
		
		// This is a stub - in a real implementation, we'd call a proper parser
		parseSexprImpl = \s -> {
			// This is just a placeholder - actual implementation would parse properly
			println("NOTE: parseSexpr implementation is a stub - importing parser would be required");
			// Return a Pair(parsedExpr, errorMsg)
			SSList([SSString("Parsing not implemented"), SSString("")]);
		};
		
		result = parseSexprImpl(code);
		SexprResult(evalResult.env, result);
	}
}

// Global counter for unique IDs with prefixes
globalUidCounters : ref Tree<string, int> = ref makeTree();

// Implementation of uid function
uidFunction(evalResult : FnArgResult) -> SexprResult {
	// Ensure we have exactly 1 argument
	if (length(evalResult.args) != 1) {
		println("ERROR: uid expects 1 argument");
		SexprResult(evalResult.env, SSString(""));
	} else {
		// Get the prefix
		prefix = getSString(evalResult.args[0], "uid.prefix");
		
		// Generate a unique ID with this prefix
		currentCount = lookupTreeDef(^globalUidCounters, prefix, 0);
		globalUidCounters := setTree(^globalUidCounters, prefix, currentCount + 1);
		result = prefix + i2s(currentCount);
		
		SexprResult(evalResult.env, SSString(result));
	}
}