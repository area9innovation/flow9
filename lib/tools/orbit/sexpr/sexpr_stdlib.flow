import tools/orbit/sexpr/sexpr_types;
import tools/orbit/sexpr/pretty_sexpr;
import tools/orbit/sexpr/sexpr_pattern;
import tools/orbit/sexpr/utils;
import ds/tree;
import string;
import math/math;

export {
	// Result of evaluation is a pair of (new environment, result value)
	SexprResult(env : Tree<string, Sexpr>, value : Sexpr);

	// Result of evaluating function arguments
	FnArgResult(env : Tree<string, Sexpr>, args : [Sexpr]);
	
	// Runtime function definition
	RuntimeFn(arity : int, fn : (FnArgResult) -> SexprResult);

	// Add standard functions/variables to the environment
	addStandardFns(env : Tree<string, Sexpr>) -> Tree<string, Sexpr>;
	
	// Get the runtime functions map
	getRuntimeFunctions() -> Tree<string, RuntimeFn>;
	
	// Helper for invoking runtime functions with arity checking
	invokeRuntimeFn(name : string, result : FnArgResult) -> SexprResult;

	// Centralized arity checking
	checkArity(fnName : string, evalResult : FnArgResult, expected : int, fn : (Tree<string, Sexpr>, [Sexpr]) -> SexprResult) -> SexprResult;

	// Basic operations
	addNumbers(evalResult : FnArgResult) -> SexprResult;
	subtractNumbers(evalResult : FnArgResult) -> SexprResult;
	multiplyNumbers(evalResult : FnArgResult) -> SexprResult;
	divideNumbers(evalResult : FnArgResult) -> SexprResult;
	equalsCheck(evalResult : FnArgResult) -> SexprResult;
	
	// List operations
	carFunction(evalResult : FnArgResult) -> SexprResult;
	cdrFunction(evalResult : FnArgResult) -> SexprResult;
	consFunction(evalResult : FnArgResult) -> SexprResult;
	printFunction(evalResult : FnArgResult) -> SexprResult;
	
	// Math functions imported from orbit_runtime
	absFunction(evalResult : FnArgResult) -> SexprResult;
	iabsFunction(evalResult : FnArgResult) -> SexprResult;
	sinFunction(evalResult : FnArgResult) -> SexprResult;
	cosFunction(evalResult : FnArgResult) -> SexprResult;
	tanFunction(evalResult : FnArgResult) -> SexprResult;
	asinFunction(evalResult : FnArgResult) -> SexprResult;
	acosFunction(evalResult : FnArgResult) -> SexprResult;
	atanFunction(evalResult : FnArgResult) -> SexprResult;
	atan2Function(evalResult : FnArgResult) -> SexprResult;
	sqrtFunction(evalResult : FnArgResult) -> SexprResult;
	expFunction(evalResult : FnArgResult) -> SexprResult;
	logFunction(evalResult : FnArgResult) -> SexprResult;
	log10Function(evalResult : FnArgResult) -> SexprResult;
	floorFunction(evalResult : FnArgResult) -> SexprResult;
	ceilFunction(evalResult : FnArgResult) -> SexprResult;
	roundFunction(evalResult : FnArgResult) -> SexprResult;
	dfloorFunction(evalResult : FnArgResult) -> SexprResult;
	dceilFunction(evalResult : FnArgResult) -> SexprResult;
	droundFunction(evalResult : FnArgResult) -> SexprResult;
	signFunction(evalResult : FnArgResult) -> SexprResult;
	isignFunction(evalResult : FnArgResult) -> SexprResult;
	evenFunction(evalResult : FnArgResult) -> SexprResult;
	oddFunction(evalResult : FnArgResult) -> SexprResult;
	modFunction(evalResult : FnArgResult) -> SexprResult;
	dmodFunction(evalResult : FnArgResult) -> SexprResult;
	factorialFunction(evalResult : FnArgResult) -> SexprResult;
	gcdFunction(evalResult : FnArgResult) -> SexprResult;
	lcmFunction(evalResult : FnArgResult) -> SexprResult;
	
	// Logic functions
	notFunction(evalResult : FnArgResult) -> SexprResult;
	
	// String operations
	strlenFunction(evalResult : FnArgResult) -> SexprResult;
	substringFunction(evalResult : FnArgResult) -> SexprResult;
	strIndexFunction(evalResult : FnArgResult) -> SexprResult;
	strContainsAtFunction(evalResult : FnArgResult) -> SexprResult;
	parseHexFunction(evalResult : FnArgResult) -> SexprResult;
	unescapeFunction(evalResult : FnArgResult) -> SexprResult;
	escapeFunction(evalResult : FnArgResult) -> SexprResult;
	strGlueFunction(evalResult : FnArgResult) -> SexprResult;
	capitalizeFunction(evalResult : FnArgResult) -> SexprResult;
	decapitalizeFunction(evalResult : FnArgResult) -> SexprResult;
	
	// Type conversions
	i2sFunction(evalResult : FnArgResult) -> SexprResult;
	d2sFunction(evalResult : FnArgResult) -> SexprResult;
	i2bFunction(evalResult : FnArgResult) -> SexprResult;
	b2iFunction(evalResult : FnArgResult) -> SexprResult;
	s2iFunction(evalResult : FnArgResult) -> SexprResult;
	s2dFunction(evalResult : FnArgResult) -> SexprResult;
	
	// Type checking
	isBoolFunction(evalResult : FnArgResult) -> SexprResult;
	isIntFunction(evalResult : FnArgResult) -> SexprResult;
	isDoubleFunction(evalResult : FnArgResult) -> SexprResult;
	isStringFunction(evalResult : FnArgResult) -> SexprResult;
	isArrayFunction(evalResult : FnArgResult) -> SexprResult;
	
	// Array/list operations
	lengthFunction(evalResult : FnArgResult) -> SexprResult;
	indexFunction(evalResult : FnArgResult) -> SexprResult;
	subrangeFunction(evalResult : FnArgResult) -> SexprResult;
	reverseFunction(evalResult : FnArgResult) -> SexprResult;
}

// Helper for invoking runtime functions with arity checking
invokeRuntimeFn(name : string, result : FnArgResult) -> SexprResult {
	maybe = lookupTree(getRuntimeFunctions(), name);
	switch (maybe) {
		Some(runtimeFn): {
			// Check arity if expected value is not -1 (variable arity)
			if (runtimeFn.arity != -1 && length(result.args) != runtimeFn.arity) {
				println("ERROR: " + name + " expects " + i2s(runtimeFn.arity) + " arguments, got " + i2s(length(result.args)));
				SexprResult(result.env, SSList([]));
			} else {
				// Invoke the function implementation
				runtimeFn.fn(result);
			}
		}
		None(): {
			println("ERROR: Unknown runtime function: " + name);
			SexprResult(result.env, SSList([]));
		}
	}
}

// Centralized arity checking (kept for backward compatibility)
checkArity(fnName : string, evalResult : FnArgResult, expected : int, fn : (Tree<string, Sexpr>, [Sexpr]) -> SexprResult) -> SexprResult {
	if (length(evalResult.args) != expected) {
		println("ERROR: " + fnName + " expects " + i2s(expected) + " arguments, got " + i2s(length(evalResult.args)));
		SexprResult(evalResult.env, SSList([]));
	} else {
		fn(evalResult.env, evalResult.args);
	}
}

// Get the runtime functions map
getRuntimeFunctions() -> Tree<string, RuntimeFn> {
	functionPairs = [
		// Arithmetic operators
		Pair("+", RuntimeFn(-1, \result -> addNumbers(result))),
		Pair("-", RuntimeFn(-1, \result -> subtractNumbers(result))),
		Pair("*", RuntimeFn(-1, \result -> multiplyNumbers(result))),
		Pair("/", RuntimeFn(-1, \result -> divideNumbers(result))),
		Pair("=", RuntimeFn(2, \result -> equalsCheck(result))),
		
		// List operations
		Pair("list", RuntimeFn(-1, \result -> SexprResult(result.env, SSList(result.args)))),
		Pair("car", RuntimeFn(1, \result -> carFunction(result))),
		Pair("cdr", RuntimeFn(1, \result -> cdrFunction(result))),
		Pair("cons", RuntimeFn(2, \result -> consFunction(result))),
		Pair("print", RuntimeFn(-1, \result -> printFunction(result))),
		
		// Math functions
		Pair("abs", RuntimeFn(1, \result -> absFunction(result))),
		Pair("iabs", RuntimeFn(1, \result -> iabsFunction(result))),
		Pair("sin", RuntimeFn(1, \result -> sinFunction(result))),
		Pair("cos", RuntimeFn(1, \result -> cosFunction(result))),
		Pair("tan", RuntimeFn(1, \result -> tanFunction(result))),
		Pair("asin", RuntimeFn(1, \result -> asinFunction(result))),
		Pair("acos", RuntimeFn(1, \result -> acosFunction(result))),
		Pair("atan", RuntimeFn(1, \result -> atanFunction(result))),
		Pair("atan2", RuntimeFn(2, \result -> atan2Function(result))),
		Pair("sqrt", RuntimeFn(1, \result -> sqrtFunction(result))),
		Pair("exp", RuntimeFn(1, \result -> expFunction(result))),
		Pair("log", RuntimeFn(1, \result -> logFunction(result))),
		Pair("log10", RuntimeFn(1, \result -> log10Function(result))),
		Pair("floor", RuntimeFn(1, \result -> floorFunction(result))),
		Pair("ceil", RuntimeFn(1, \result -> ceilFunction(result))),
		Pair("round", RuntimeFn(1, \result -> roundFunction(result))),
		Pair("dfloor", RuntimeFn(1, \result -> dfloorFunction(result))),
		Pair("dceil", RuntimeFn(1, \result -> dceilFunction(result))),
		Pair("dround", RuntimeFn(1, \result -> droundFunction(result))),
		Pair("sign", RuntimeFn(1, \result -> signFunction(result))),
		Pair("isign", RuntimeFn(1, \result -> isignFunction(result))),
		Pair("even", RuntimeFn(1, \result -> evenFunction(result))),
		Pair("odd", RuntimeFn(1, \result -> oddFunction(result))),
		Pair("mod", RuntimeFn(2, \result -> modFunction(result))),
		Pair("dmod", RuntimeFn(2, \result -> dmodFunction(result))),
		Pair("factorial", RuntimeFn(1, \result -> factorialFunction(result))),
		Pair("gcd", RuntimeFn(2, \result -> gcdFunction(result))),
		Pair("lcm", RuntimeFn(2, \result -> lcmFunction(result))),
		
		// Logic functions
		Pair("not", RuntimeFn(1, \result -> notFunction(result))),
		
		// String operations
		Pair("strlen", RuntimeFn(1, \result -> strlenFunction(result))),
		Pair("substring", RuntimeFn(3, \result -> substringFunction(result))),
		Pair("strIndex", RuntimeFn(2, \result -> strIndexFunction(result))),
		Pair("strContainsAt", RuntimeFn(3, \result -> strContainsAtFunction(result))),
		Pair("parseHex", RuntimeFn(1, \result -> parseHexFunction(result))),
		Pair("unescape", RuntimeFn(1, \result -> unescapeFunction(result))),
		Pair("escape", RuntimeFn(1, \result -> escapeFunction(result))),
		Pair("strGlue", RuntimeFn(2, \result -> strGlueFunction(result))),
		Pair("capitalize", RuntimeFn(1, \result -> capitalizeFunction(result))),
		Pair("decapitalize", RuntimeFn(1, \result -> decapitalizeFunction(result))),
		
		// Type conversions
		Pair("i2s", RuntimeFn(1, \result -> i2sFunction(result))),
		Pair("d2s", RuntimeFn(1, \result -> d2sFunction(result))),
		Pair("i2b", RuntimeFn(1, \result -> i2bFunction(result))),
		Pair("b2i", RuntimeFn(1, \result -> b2iFunction(result))),
		Pair("s2i", RuntimeFn(1, \result -> s2iFunction(result))),
		Pair("s2d", RuntimeFn(1, \result -> s2dFunction(result))),
		
		// Type checking
		Pair("isBool", RuntimeFn(1, \result -> isBoolFunction(result))),
		Pair("isInt", RuntimeFn(1, \result -> isIntFunction(result))),
		Pair("isDouble", RuntimeFn(1, \result -> isDoubleFunction(result))),
		Pair("isString", RuntimeFn(1, \result -> isStringFunction(result))),
		Pair("isArray", RuntimeFn(1, \result -> isArrayFunction(result))),
		
		// Array/list operations
		Pair("length", RuntimeFn(1, \result -> lengthFunction(result))),
		Pair("index", RuntimeFn(2, \result -> indexFunction(result))),
		Pair("subrange", RuntimeFn(3, \result -> subrangeFunction(result))),
		Pair("reverse", RuntimeFn(1, \result -> reverseFunction(result)))
	];
	
	pairs2tree(functionPairs);
}

// Add standard functions/variables to the environment
addStandardFns(env : Tree<string, Sexpr>) -> Tree<string, Sexpr> {
	// Get runtime functions registry
	runtimeFunctions = getTreeKeys(getRuntimeFunctions());
	
	// Add operators as operators
	env1 = setTree(env, "+", SSOperator("+"));
	env2 = setTree(env1, "-", SSOperator("-"));
	env3 = setTree(env2, "*", SSOperator("*"));
	env4 = setTree(env3, "/", SSOperator("/"));
	env5 = setTree(env4, "=", SSOperator("="));
	
	// Add other functions as variables
	fold(runtimeFunctions, env5, \acc, name -> {
		if (name == "+" || name == "-" || name == "*" || name == "/" || name == "=") {
			// Already added as operators
			acc;
		} else {
			setTree(acc, name, SSVariable(name));
		}
	});
}

// Helper functions for basic operations

// Add numbers
addNumbers(evalResult : FnArgResult) -> SexprResult {
	result = fold(evalResult.args, SSInt(0), \acc, arg -> {
		switch (acc) {
			SSInt(accInt): {
				switch (arg) {
					SSInt(argInt): SSInt(accInt + argInt);
					SSDouble(argDouble): SSDouble(i2d(accInt) + argDouble);
					default: {
						println("Cannot add non-number: " + prettySexpr(arg));
						acc;
					}
				}
			};
			SSDouble(accDouble): {
				switch (arg) {
					SSInt(argInt): SSDouble(accDouble + i2d(argInt));
					SSDouble(argDouble): SSDouble(accDouble + argDouble);
					default: {
						println("Cannot add non-number: " + prettySexpr(arg));
						acc;
					}
				}
			};
			default: acc;
		}
	});
	
	SexprResult(evalResult.env, result);
}

// Subtract numbers
subtractNumbers(evalResult : FnArgResult) -> SexprResult {
	if (length(evalResult.args) == 0) {
		SexprResult(evalResult.env, SSInt(0));
	} else {
		// Get first arg
		first = evalResult.args[0];
		
		// If only one argument, negate it
		if (length(evalResult.args) == 1) {
			result = switch (first) {
				SSInt(i): SSInt(-i);
				SSDouble(d): SSDouble(-d);
				default: {
					println("Cannot negate non-number: " + prettySexpr(first));
					first;
				};
			};
			SexprResult(evalResult.env, result);
		} else {
			// Subtract rest from first
			rest = tailFrom(evalResult.args, 1);
			result = fold(rest, first, \acc, arg -> {
				switch (acc) {
					SSInt(accInt): {
						switch (arg) {
							SSInt(argInt): SSInt(accInt - argInt);
							SSDouble(argDouble): SSDouble(i2d(accInt) - argDouble);
							default: {
								println("Cannot subtract non-number: " + prettySexpr(arg));
								acc;
							}
						}
					};
					SSDouble(accDouble): {
						switch (arg) {
							SSInt(argInt): SSDouble(accDouble - i2d(argInt));
							SSDouble(argDouble): SSDouble(accDouble - argDouble);
							default: {
								println("Cannot subtract non-number: " + prettySexpr(arg));
								acc;
							}
						}
					};
					default: acc;
				}
			});
			SexprResult(evalResult.env, result);
		}
	}
}

// Multiply numbers
multiplyNumbers(evalResult : FnArgResult) -> SexprResult {
	result = fold(evalResult.args, SSInt(1), \acc, arg -> {
		switch (acc) {
			SSInt(accInt): {
				switch (arg) {
					SSInt(argInt): SSInt(accInt * argInt);
					SSDouble(argDouble): SSDouble(i2d(accInt) * argDouble);
					default: {
						println("Cannot multiply non-number: " + prettySexpr(arg));
						acc;
					}
				}
			};
			SSDouble(accDouble): {
				switch (arg) {
					SSInt(argInt): SSDouble(accDouble * i2d(argInt));
					SSDouble(argDouble): SSDouble(accDouble * argDouble);
					default: {
						println("Cannot multiply non-number: " + prettySexpr(arg));
						acc;
					}
				}
			};
			default: acc;
		}
	});
	
	SexprResult(evalResult.env, result);
}

// Divide numbers
divideNumbers(evalResult : FnArgResult) -> SexprResult {
	if (length(evalResult.args) == 0) {
		SexprResult(evalResult.env, SSInt(1));
	} else {
		// Get first arg
		first = evalResult.args[0];
		
		// If only one argument, invert it (1/x)
		if (length(evalResult.args) == 1) {
			result = switch (first) {
				SSInt(i): {
					if (i != 0) SSDouble(1.0 / i2d(i)) else {
						println("Division by zero");
						SSDouble(0.0);
					}
				};
				SSDouble(d): {
					if (d != 0.0) SSDouble(1.0 / d) else {
						println("Division by zero");
						SSDouble(0.0);
					}
				};
				default: {
					println("Cannot invert non-number: " + prettySexpr(first));
					first;
				};
			};
			SexprResult(evalResult.env, result);
		} else {
			// Divide first by rest
			rest = tailFrom(evalResult.args, 1);
			result = fold(rest, first, \acc, arg -> {
				switch (acc) {
					SSInt(accInt): {
						switch (arg) {
							SSInt(argInt): {
								if (argInt != 0) {
									// Convert to double for division
									SSDouble(i2d(accInt) / i2d(argInt));
								} else {
									println("Division by zero");
									acc;
								}
							};
							SSDouble(argDouble): {
								if (argDouble != 0.0) {
									SSDouble(i2d(accInt) / argDouble);
								} else {
									println("Division by zero");
									acc;
								}
							};
							default: {
								println("Cannot divide by non-number: " + prettySexpr(arg));
								acc;
							};
						}
					};
					SSDouble(accDouble): {
						switch (arg) {
							SSInt(argInt): {
								if (argInt != 0) {
									SSDouble(accDouble / i2d(argInt));
								} else {
									println("Division by zero");
									acc;
								}
							};
							SSDouble(argDouble): {
								if (argDouble != 0.0) {
									SSDouble(accDouble / argDouble);
								} else {
									println("Division by zero");
									acc;
								}
							};
							default: {
								println("Cannot divide by non-number: " + prettySexpr(arg));
								acc;
							};
						}
					};
					default: acc;
				}
			});
			SexprResult(evalResult.env, result);
		}
	}
}

// Equality check
equalsCheck(evalResult : FnArgResult) -> SexprResult {
	checkArity("=", evalResult, 2, \env, args -> {
		allEqual = sexprEquals(args[0], args[1]);
		SexprResult(env, SSBool(allEqual));
	});
}

// List operations

carFunction(evalResult : FnArgResult) -> SexprResult {
	checkArity("car", evalResult, 1, \env, args -> {
		switch (args[0]) {
			SSList(items): {
				if (length(items) > 0) {
					SexprResult(env, items[0]);
				} else {
					println("car: empty list");
					SexprResult(env, SSList([]));
				}
			}
			default: {
				println("car requires a list argument");
				SexprResult(env, SSList([]));
			};
		}
	});
}

cdrFunction(evalResult : FnArgResult) -> SexprResult {
	checkArity("cdr", evalResult, 1, \env, args -> {
		switch (args[0]) {
			SSList(items): {
				if (length(items) > 0) {
					SexprResult(env, SSList(tailFrom(items, 1)));
				} else {
					SexprResult(env, SSList([]));
				}
			}
			default: {
				println("cdr requires a list argument");
				SexprResult(env, SSList([]));
			};
		}
	});
}

consFunction(evalResult : FnArgResult) -> SexprResult {
	checkArity("cons", evalResult, 2, \env, args -> {
		elem = args[0];
		rest = args[1];
		
		switch (rest) {
			SSList(items): {
				SexprResult(env, SSList(concat([elem], items)));
			}
			default: {
				// In Scheme, cons can create pairs, but for simplicity
				// we'll just create a list
				SexprResult(env, SSList([elem, rest]));
			};
		}
	});
}

// Print function
printFunction(evalResult : FnArgResult) -> SexprResult {
	// Evaluate and print args recursively
	iter(evalResult.args, \arg -> {
		println(prettySexpr(arg));
	});

	SexprResult(evalResult.env, SSList([])); // Default result
}

// ----- Functions from orbit_runtime -----

// Absolute value for doubles
absFunction(evalResult : FnArgResult) -> SexprResult {
	checkArity("abs", evalResult, 1, \env, args -> {
		value = getSDouble(args[0], "abs");
		SexprResult(env, SSDouble(abs(value)));
	});
}

// Absolute value for integers
iabsFunction(evalResult : FnArgResult) -> SexprResult {
	checkArity("iabs", evalResult, 1, \env, args -> {
		value = getSInt(args[0], "iabs");
		SexprResult(env, SSInt(iabs(value)));
	});
}

// Sine function
sinFunction(evalResult : FnArgResult) -> SexprResult {
	checkArity("sin", evalResult, 1, \env, args -> {
		value = getSDouble(args[0], "sin");
		SexprResult(env, SSDouble(sin(value)));
	});
}

// Cosine function
cosFunction(evalResult : FnArgResult) -> SexprResult {
	checkArity("cos", evalResult, 1, \env, args -> {
		value = getSDouble(args[0], "cos");
		SexprResult(env, SSDouble(cos(value)));
	});
}

// Tangent function
tanFunction(evalResult : FnArgResult) -> SexprResult {
	checkArity("tan", evalResult, 1, \env, args -> {
		value = getSDouble(args[0], "tan");
		SexprResult(env, SSDouble(tan(value)));
	});
}

// Arc sine function
asinFunction(evalResult : FnArgResult) -> SexprResult {
	checkArity("asin", evalResult, 1, \env, args -> {
		value = getSDouble(args[0], "asin");
		SexprResult(env, SSDouble(asin(value)));
	});
}

// Arc cosine function
acosFunction(evalResult : FnArgResult) -> SexprResult {
	checkArity("acos", evalResult, 1, \env, args -> {
		value = getSDouble(args[0], "acos");
		SexprResult(env, SSDouble(acos(value)));
	});
}

// Arc tangent function
atanFunction(evalResult : FnArgResult) -> SexprResult {
	checkArity("atan", evalResult, 1, \env, args -> {
		value = getSDouble(args[0], "atan");
		SexprResult(env, SSDouble(atan(value)));
	});
}

// Arc tangent of y/x function
atan2Function(evalResult : FnArgResult) -> SexprResult {
	checkArity("atan2", evalResult, 2, \env, args -> {
		y = getSDouble(args[0], "atan2 y");
		x = getSDouble(args[1], "atan2 x");
		SexprResult(env, SSDouble(atan2(y, x)));
	});
}

// Square root function
sqrtFunction(evalResult : FnArgResult) -> SexprResult {
	checkArity("sqrt", evalResult, 1, \env, args -> {
		value = getSDouble(args[0], "sqrt");
		SexprResult(env, SSDouble(sqrt(value)));
	});
}

// Exponential function
expFunction(evalResult : FnArgResult) -> SexprResult {
	checkArity("exp", evalResult, 1, \env, args -> {
		value = getSDouble(args[0], "exp");
		SexprResult(env, SSDouble(exp(value)));
	});
}

// Natural logarithm function
logFunction(evalResult : FnArgResult) -> SexprResult {
	checkArity("log", evalResult, 1, \env, args -> {
		value = getSDouble(args[0], "log");
		SexprResult(env, SSDouble(log(value)));
	});
}

// Base-10 logarithm function
log10Function(evalResult : FnArgResult) -> SexprResult {
	checkArity("log10", evalResult, 1, \env, args -> {
		value = getSDouble(args[0], "log10");
		SexprResult(env, SSDouble(log(value) / log(10.0)));
	});
}

// Floor function (returns integer)
floorFunction(evalResult : FnArgResult) -> SexprResult {
	checkArity("floor", evalResult, 1, \env, args -> {
		value = getSDouble(args[0], "floor");
		SexprResult(env, SSInt(floor(value)));
	});
}

// Ceiling function (returns integer)
ceilFunction(evalResult : FnArgResult) -> SexprResult {
	checkArity("ceil", evalResult, 1, \env, args -> {
		value = getSDouble(args[0], "ceil");
		SexprResult(env, SSInt(ceil(value)));
	});
}

// Round function (returns integer)
roundFunction(evalResult : FnArgResult) -> SexprResult {
	checkArity("round", evalResult, 1, \env, args -> {
		value = getSDouble(args[0], "round");
		SexprResult(env, SSInt(round(value)));
	});
}

// Floor function (returns double)
dfloorFunction(evalResult : FnArgResult) -> SexprResult {
	checkArity("dfloor", evalResult, 1, \env, args -> {
		value = getSDouble(args[0], "dfloor");
		SexprResult(env, SSDouble(dfloor(value)));
	});
}

// Ceiling function (returns double)
dceilFunction(evalResult : FnArgResult) -> SexprResult {
	checkArity("dceil", evalResult, 1, \env, args -> {
		value = getSDouble(args[0], "dceil");
		SexprResult(env, SSDouble(dceil(value)));
	});
}

// Round function (returns double)
droundFunction(evalResult : FnArgResult) -> SexprResult {
	checkArity("dround", evalResult, 1, \env, args -> {
		value = getSDouble(args[0], "dround");
		SexprResult(env, SSDouble(dround(value)));
	});
}

// Sign function (returns double)
signFunction(evalResult : FnArgResult) -> SexprResult {
	checkArity("sign", evalResult, 1, \env, args -> {
		value = getSDouble(args[0], "sign");
		SexprResult(env, SSDouble(sign(value)));
	});
}

// Sign function (returns integer)
isignFunction(evalResult : FnArgResult) -> SexprResult {
	checkArity("isign", evalResult, 1, \env, args -> {
		value = getSInt(args[0], "isign");
		SexprResult(env, SSInt(isign(value)));
	});
}

// Check if number is even
evenFunction(evalResult : FnArgResult) -> SexprResult {
	checkArity("even", evalResult, 1, \env, args -> {
		value = getSInt(args[0], "even");
		SexprResult(env, SSBool(even(value)));
	});
}

// Check if number is odd
oddFunction(evalResult : FnArgResult) -> SexprResult {
	checkArity("odd", evalResult, 1, \env, args -> {
		value = getSInt(args[0], "odd");
		SexprResult(env, SSBool(odd(value)));
	});
}

// Modulo function for integers
modFunction(evalResult : FnArgResult) -> SexprResult {
	checkArity("mod", evalResult, 2, \env, args -> {
		value1 = getSInt(args[0], "mod dividend");
		value2 = getSInt(args[1], "mod divisor");
		
		if (value2 == 0) {
			println("ERROR: mod division by zero");
			SexprResult(env, SSInt(0));
		} else {
			SexprResult(env, SSInt(mod(value1, value2)));
		}
	});
}

// Modulo function for doubles
dmodFunction(evalResult : FnArgResult) -> SexprResult {
	checkArity("dmod", evalResult, 2, \env, args -> {
		value1 = getSDouble(args[0], "dmod dividend");
		value2 = getSDouble(args[1], "dmod divisor");
		
		if (value2 == 0.0) {
			println("ERROR: dmod division by zero");
			SexprResult(env, SSDouble(0.0));
		} else {
			SexprResult(env, SSDouble(dmod(value1, value2)));
		}
	});
}

// Factorial function
factorialFunction(evalResult : FnArgResult) -> SexprResult {
	checkArity("factorial", evalResult, 1, \env, args -> {
		value = getSInt(args[0], "factorial");
		
		if (value < 0) {
			println("ERROR: factorial requires a non-negative integer");
			SexprResult(env, SSInt(0));
		} else {
			SexprResult(env, SSInt(factorial(value)));
		}
	});
}

// Greatest common divisor function
gcdFunction(evalResult : FnArgResult) -> SexprResult {
	checkArity("gcd", evalResult, 2, \env, args -> {
		value1 = getSInt(args[0], "gcd first");
		value2 = getSInt(args[1], "gcd second");
		SexprResult(env, SSInt(gcd(value1, value2)));
	});
}

// Least common multiple function
lcmFunction(evalResult : FnArgResult) -> SexprResult {
	checkArity("lcm", evalResult, 2, \env, args -> {
		value1 = getSInt(args[0], "lcm first");
		value2 = getSInt(args[1], "lcm second");
		SexprResult(env, SSInt(lcm(value1, value2)));
	});
}

// Logical not function
notFunction(evalResult : FnArgResult) -> SexprResult {
	checkArity("not", evalResult, 1, \env, args -> {
		value = getSBool(args[0], "not");
		SexprResult(env, SSBool(!value));
	});
}

// String length function
strlenFunction(evalResult : FnArgResult) -> SexprResult {
	checkArity("strlen", evalResult, 1, \env, args -> {
		str = getSString(args[0], "strlen");
		SexprResult(env, SSInt(strlen(str)));
	});
}

// Substring function
substringFunction(evalResult : FnArgResult) -> SexprResult {
	checkArity("substring", evalResult, 3, \env, args -> {
		str = getSString(args[0], "substring string");
		start = getSInt(args[1], "substring start");
		length = getSInt(args[2], "substring length");
		
		if (start < 0 || start >= strlen(str)) {
			println("ERROR: substring start index out of bounds");
			SexprResult(env, SSString(""));
		} else if (length < 0) {
			println("ERROR: substring length must be non-negative");
			SexprResult(env, SSString(""));
		} else {
			SexprResult(env, SSString(substring(str, start, length)));
		}
	});
}

// Get character at index in string
strIndexFunction(evalResult : FnArgResult) -> SexprResult {
	checkArity("strIndex", evalResult, 2, \env, args -> {
		str = getSString(args[0], "strIndex string");
		idx = getSInt(args[1], "strIndex index");
		
		if (idx < 0 || idx >= strlen(str)) {
			println("ERROR: strIndex index out of bounds");
			SexprResult(env, SSString(""));
		} else {
			SexprResult(env, SSString(substring(str, idx, 1)));
		}
	});
}

// Check if string contains substring at index
strContainsAtFunction(evalResult : FnArgResult) -> SexprResult {
	checkArity("strContainsAt", evalResult, 3, \env, args -> {
		str = getSString(args[0], "strContainsAt string");
		idx = getSInt(args[1], "strContainsAt index");
		sub = getSString(args[2], "strContainsAt substring");
		
		if (idx < 0 || idx >= strlen(str)) {
			SexprResult(env, SSBool(false));
		} else if (idx + strlen(sub) > strlen(str)) {
			SexprResult(env, SSBool(false));
		} else {
			check = substring(str, idx, strlen(sub));
			SexprResult(env, SSBool(check == sub));
		}
	});
}

// Parse hexadecimal string
parseHexFunction(evalResult : FnArgResult) -> SexprResult {
	checkArity("parseHex", evalResult, 1, \env, args -> {
		hexStr = getSString(args[0], "parseHex");
		// This is a simplified implementation
		// In a real implementation, we would validate and parse hex
		result = fold(strSplit(hexStr, ""), 0, \acc, c -> {
			digit = if (c >= "0" && c <= "9") s2i(c)
				else if (c >= "a" && c <= "f") s2i(c) - s2i("a") + 10 
				else if (c >= "A" && c <= "F") s2i(c) - s2i("A") + 10
				else -1;
			
			if (digit == -1) acc else acc * 16 + digit;
		});
		SexprResult(env, SSInt(result));
	});
}

// Unescape a string
unescapeFunction(evalResult : FnArgResult) -> SexprResult {
	checkArity("unescape", evalResult, 1, \env, args -> {
		str = getSString(args[0], "unescape");
		// Simplified implementation
		result = strReplace(strReplace(strReplace(strReplace(str, "\\n", "\n"), "\\t", "\t"), "\\\\", "\\"), "\\\"", "\"");
		SexprResult(env, SSString(result));
	});
}

// Escape a string
escapeFunction(evalResult : FnArgResult) -> SexprResult {
	checkArity("escape", evalResult, 1, \env, args -> {
		str = getSString(args[0], "escape");
		// Simplified implementation
		result = strReplace(strReplace(strReplace(strReplace(str, "\\", "\\\\"), "\n", "\\n"), "\t", "\\t"), "\"", "\\\"");
		SexprResult(env, SSString(result));
	});
}

// Join array of strings with separator
strGlueFunction(evalResult : FnArgResult) -> SexprResult {
	checkArity("strGlue", evalResult, 2, \env, args -> {
		switch (args[0]) {
			SSList(items): {
				sep = getSString(args[1], "strGlue separator");
				// Convert all items to strings
				strs = map(items, \item -> getSString(item, "strGlue item"));
				SexprResult(env, SSString(strGlue(strs, sep)));
			}
			default: {
				println("ERROR: strGlue first argument must be a list");
				SexprResult(env, SSString(""));
			}
		}
	});
}

// Capitalize first letter of string
capitalizeFunction(evalResult : FnArgResult) -> SexprResult {
	checkArity("capitalize", evalResult, 1, \env, args -> {
		str = getSString(args[0], "capitalize");
		if (strlen(str) == 0) {
			SexprResult(env, SSString(""));
		} else {
			first = substring(str, 0, 1);
			rest = substring(str, 1, strlen(str) - 1);
			SexprResult(env, SSString(toUpperCase(first) + rest));
		}
	});
}

// Decapitalize first letter of string
decapitalizeFunction(evalResult : FnArgResult) -> SexprResult {
	checkArity("decapitalize", evalResult, 1, \env, args -> {
		str = getSString(args[0], "decapitalize");
		if (strlen(str) == 0) {
			SexprResult(env, SSString(""));
		} else {
			first = substring(str, 0, 1);
			rest = substring(str, 1, strlen(str) - 1);
			SexprResult(env, SSString(toLowerCase(first) + rest));
		}
	});
}

// Convert integer to string
i2sFunction(evalResult : FnArgResult) -> SexprResult {
	checkArity("i2s", evalResult, 1, \env, args -> {
		value = getSInt(args[0], "i2s");
		SexprResult(env, SSString(i2s(value)));
	});
}

// Convert double to string
d2sFunction(evalResult : FnArgResult) -> SexprResult {
	checkArity("d2s", evalResult, 1, \env, args -> {
		value = getSDouble(args[0], "d2s");
		SexprResult(env, SSString(d2s(value)));
	});
}

// Convert integer to boolean
i2bFunction(evalResult : FnArgResult) -> SexprResult {
	checkArity("i2b", evalResult, 1, \env, args -> {
		value = getSInt(args[0], "i2b");
		SexprResult(env, SSBool(value != 0));
	});
}

// Convert boolean to integer
b2iFunction(evalResult : FnArgResult) -> SexprResult {
	checkArity("b2i", evalResult, 1, \env, args -> {
		value = getSBool(args[0], "b2i");
		SexprResult(env, SSInt(if (value) 1 else 0));
	});
}

// Convert string to integer
s2iFunction(evalResult : FnArgResult) -> SexprResult {
	checkArity("s2i", evalResult, 1, \env, args -> {
		str = getSString(args[0], "s2i");
		SexprResult(env, SSInt(s2i(str)));
	});
}

// Convert string to double
s2dFunction(evalResult : FnArgResult) -> SexprResult {
	checkArity("s2d", evalResult, 1, \env, args -> {
		str = getSString(args[0], "s2d");
		SexprResult(env, SSDouble(s2d(str)));
	});
}

// Check if value is a boolean
isBoolFunction(evalResult : FnArgResult) -> SexprResult {
	checkArity("isBool", evalResult, 1, \env, args -> {
		isBool = switch (args[0]) {
			SSBool(__): true;
			default: false;
		};
		SexprResult(env, SSBool(isBool));
	});
}

// Check if value is an integer
isIntFunction(evalResult : FnArgResult) -> SexprResult {
	checkArity("isInt", evalResult, 1, \env, args -> {
		isInt = switch (args[0]) {
			SSInt(__): true;
			default: false;
		};
		SexprResult(env, SSBool(isInt));
	});
}

// Check if value is a double
isDoubleFunction(evalResult : FnArgResult) -> SexprResult {
	checkArity("isDouble", evalResult, 1, \env, args -> {
		isDouble = switch (args[0]) {
			SSDouble(__): true;
			default: false;
		};
		SexprResult(env, SSBool(isDouble));
	});
}

// Check if value is a string
isStringFunction(evalResult : FnArgResult) -> SexprResult {
	checkArity("isString", evalResult, 1, \env, args -> {
		isString = switch (args[0]) {
			SSString(__): true;
			default: false;
		};
		SexprResult(env, SSBool(isString));
	});
}

// Check if value is an array/list
isArrayFunction(evalResult : FnArgResult) -> SexprResult {
	checkArity("isArray", evalResult, 1, \env, args -> {
		isArray = switch (args[0]) {
			SSList(__): true;
			default: false;
		};
		SexprResult(env, SSBool(isArray));
	});
}

// Get length of array/list
lengthFunction(evalResult : FnArgResult) -> SexprResult {
	checkArity("length", evalResult, 1, \env, args -> {
		switch (args[0]) {
			SSList(items): {
				SexprResult(env, SSInt(length(items)));
			}
			SSString(s): {
				// As a convenience, also work on strings
				SexprResult(env, SSInt(strlen(s)));
			}
			default: {
				println("ERROR: length requires a list or string argument");
				SexprResult(env, SSInt(0));
			}
		}
	});
}

// Get item at index from array/list
indexFunction(evalResult : FnArgResult) -> SexprResult {
	checkArity("index", evalResult, 2, \env, args -> {
		switch (args[0]) {
			SSList(items): {
				idx = getSInt(args[1], "index index");
				if (idx < 0 || idx >= length(items)) {
					println("ERROR: index out of bounds");
					SexprResult(env, SSList([]));
				} else {
					SexprResult(env, items[idx]);
				}
			}
			default: {
				println("ERROR: index requires a list argument");
				SexprResult(env, SSList([]));
			}
		}
	});
}

// Get subrange of array/list
subrangeFunction(evalResult : FnArgResult) -> SexprResult {
	checkArity("subrange", evalResult, 3, \env, args -> {
		switch (args[0]) {
			SSList(items): {
				start = getSInt(args[1], "subrange start");
				lengthVal = getSInt(args[2], "subrange length");
				itemsLength = length(items);
				
				if (start < 0 || start >= itemsLength) {
					println("ERROR: subrange start index out of bounds");
					SexprResult(env, SSList([]));
				} else if (lengthVal < 0) {
					println("ERROR: subrange length must be non-negative");
					SexprResult(env, SSList([]));
				} else {
					SexprResult(env, SSList(subrange(items, start, lengthVal)));
				}
			}
			default: {
				println("ERROR: subrange requires a list argument");
				SexprResult(env, SSList([]));
			}
		}
	});
}

// Reverse array/list
reverseFunction(evalResult : FnArgResult) -> SexprResult {
	checkArity("reverse", evalResult, 1, \env, args -> {
		switch (args[0]) {
			SSList(items): {
				SexprResult(env, SSList(reverseA(items)));
			}
			default: {
				println("ERROR: reverse requires a list argument");
				SexprResult(env, SSList([]));
			}
		}
	});
}