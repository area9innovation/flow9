import tools/orbit/sexpr/sexpr_types;
import tools/orbit/sexpr/GLSL/glsl_serializer;
import string;
import ds/array;
import fs/filesystem;
import math/math;

export {
	// Generate a GLSL file with the serialized AST and constant pool
	generateProgramGLSL(expr : Sexpr, outputPath : string) -> bool;
}

// Generate a GLSL file containing the serialized program and constant pool as uniform data
generateProgramGLSL(expr : Sexpr, outputPath : string) -> bool {
	// Serialize the expression
	result = sexprToGLSL(expr);
	binaryAST = result.first;
	constantPool = result.second;

	// Create GLSL code with the serialized data
	glslCode = generateGLSLCode(binaryAST, constantPool);

	// Write the GLSL code to the output file
	setFileContent(outputPath, glslCode);

	// Return success
	true;
}

// Generate the GLSL code with the serialized data
generateGLSLCode(binaryAST : [double], constantPool : [double]) -> string {
	// Header with include guard for definitions
	header = "// Auto-generated GLSL code for S-expression interpreter\n" +
		"// AST size: " + i2s(length(binaryAST)) + " elements\n" +
		"// Constant Pool size: " + i2s(length(constantPool)) + " elements\n\n" +
		"#inc" + "lude \"glsl_sexpr_defines.h\"\n\n"; // Include the definitions file

	// Size definitions
	sizes = "// Program size information\n" +
		"#define PROGRAM_AST_SIZE " + i2s(length(binaryAST)) + "\n" +
		"#define CONSTANT_POOL_SIZE " + i2s(length(constantPool)) + "\n\n";

	// Format the arrays as GLSL
	constPoolDecl = formatGLSLArray("u_constant_pool", constantPool, true);
	binaryASTDecl = formatGLSLArray("u_program_ast", binaryAST, true);

	// Combine all parts
	header + sizes + constPoolDecl + "\n\n" + binaryASTDecl + "\n";
}

// Format an array as GLSL code
formatGLSLArray(name : string, values : [double], isConst : bool) -> string {
	qualifier = if (isConst) "const" else "uniform";
    arrayTypeLiteral = "float[]("; // Store this part in a variable
	arrayDecl = qualifier + " float " + name + "[" + i2s(length(values)) + "] = " + arrayTypeLiteral;

	// Format the values
	// Ensure no trailing comma is produced by formatArrayValues itself
	arrayValuesStr = if (length(values) == 0) "" else formatArrayValues(values, 4, "    ");

	// Complete the declaration
	arrayDecl + "\n" + arrayValuesStr + "\n);";
}

// Helper to format array values with proper indentation and line breaks
// This function must ensure it does NOT end with a comma if it's the last value.
formatArrayValues(values : [double], itemsPerLine : int, indent : string) -> string {
    if (length(values) == 0) {
        ""; // Empty array content
    } else {
        numChunks = (length(values) + itemsPerLine - 1) / itemsPerLine; // Ceiling division
        
        lines = generate(0, numChunks, \i -> {
            start = i * itemsPerLine;
            end = min((i + 1) * itemsPerLine, length(values));
            chunk = subrange(values, start, end - start);
            chunkStr = strGlue(map(chunk, \d -> formatGLSLFloat(d)), ", ");
            indent + chunkStr;
        });
        
        // Join lines with ",\n" for all but the last line.
        // The last line should not have a trailing comma from the joiner.
        if (length(lines) == 0) ""
        else if (length(lines) == 1) lines[0]
        else {
            allButLast = take(lines, length(lines) - 1);
            lastLine = lines[length(lines) -1];
            strGlue(allButLast, ",\n") + ",\n" + lastLine;
        }
    }
}

// Format a single float value for GLSL
formatGLSLFloat(value : double) -> string {
	str = d2s(value);
	floatStr = if (strContains(str, ".")) str else str + ".0";
	floatStr + "f";
}
