import tools/orbit/orbit_types;
import tools/orbit/ograph;
import tools/orbit/prettyprint;
import string;
import math/math;

export {
	// Registry for storing ographs and their nodes
	ographRegistry : ref Tree<string, OGraph> = ref makeTree();

	// Create a new ograph and return its name
	createOGraph(name : string) -> string;

	// Add a node to an ograph
	addNodeToOGraph(graphName : string, domainName : string, expr : OrMath_expr) -> int;

	// Add a domain to a node
	addDomainToNode(graphName : string, nodeId : int, domain : string) -> bool;

	// Merge two nodes
	mergeOGraphNodes(graphName : string, nodeId1 : int, nodeId2 : int) -> bool;

	// Extract a node as an Orbit expression
	extractOGraphNode(graphName : string, nodeId : int) -> OrMath_expr;

	// Print information about an ograph
	printOGraph(graphName : string) -> string;
}

// Create a new ograph
createOGraph(name : string) -> string {
	// Create a new ograph
	ograph = makeOGraph();
	
	// Store it in the registry
	ographRegistry := setTree(^ographRegistry, name, ograph);
	
	// Return the name
	name;
}

// Add a node to an ograph
addNodeToOGraph(graphName : string, domainName : string, expr : OrMath_expr) -> int {
	// Get the ograph from the registry
	switch (lookupTree(^ographRegistry, graphName)) {
		Some(ograph): {
			// Create domain
			domain = makeODomain(domainName);
			
			// Create node based on expression type
			node = ONode(domain, expr.structname, [], []);
			nodeId = insertONode(ograph, node);
			
			// Store string representation
			setOClassString(ograph, nodeId, prettyOrbit(expr));
			
			nodeId;
		}
		None(): -1;
	}
}

// Add a domain to a node
addDomainToNode(graphName : string, nodeId : int, domain : string) -> bool {
	// Get the ograph from the registry
	switch (lookupTree(^ographRegistry, graphName)) {
		Some(ograph): {
			// Create a domain node
			domainNode = ONode(makeODomain("meta"), "domain", [], []);
			domainId = insertONode(ograph, domainNode);
			
			// Store domain string
			setOClassString(ograph, domainId, domain);
			
			// Add domain to node
			addDomainToONode(ograph, nodeId, domainId);
			true;
		}
		None(): false;
	}
}

// Merge two nodes
mergeOGraphNodes(graphName : string, nodeId1 : int, nodeId2 : int) -> bool {
	// Get the ograph from the registry
	switch (lookupTree(^ographRegistry, graphName)) {
		Some(ograph): {
			mergeOClasses(ograph, nodeId1, nodeId2);
			true;
		}
		None(): false;
	}
}

// Extract a node as an Orbit expression
extractOGraphNode(graphName : string, nodeId : int) -> OrMath_expr {
	// Get the ograph from the registry
	switch (lookupTree(^ographRegistry, graphName)) {
		Some(ograph): {
			// Get string representation
			switch (getOClassString(ograph, nodeId)) {
				Some(s): OrString(s);
				None(): OrString("Node not found");
			}
		}
		None(): OrString("Graph not found");
	}
}

// Print information about an ograph
printOGraph(graphName : string) -> string {
	// Get the ograph from the registry
	switch (lookupTree(^ographRegistry, graphName)) {
		Some(ograph): {
			// Build a string with all nodes
			result = ref "";
			
			// Traverse all nodes
			traverseOGraph(ograph, \id, node -> {
				// Add node info
				nodeStr = "Node " + i2s(id) + " [" + node.domain.domain + "]: " + node.op;
				
				// Add children if any
				childrenStr = if (length(node.children) > 0) {
					" with children: " + strGlue(map(node.children, i2s), ", ");
				} else {
					"";
				}
				
				// Add to result
				result := ^result + nodeStr + childrenStr + "\n";
			});
			
			^result;
		}
		None(): "Graph not found";
	}
}