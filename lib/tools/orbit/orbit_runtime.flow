import tools/orbit/orbit_types;
import tools/orbit/orbit_env;
import tools/orbit/prettyprint;
import tools/orbit/orbit_pattern;
import tools/orbit/orbit_simple_ograph;
import tools/orbit/ograph2dot;
import tools/orbit/orbit2ograph;
import tools/orbit/ograph_pattern; // For OGraph pattern matching
import tools/orbit/utils; // For access to the original utility functions
import ds/tree;
import string;

// This file provides special internal orbit functions that have the ability to NOT evaluate arguments
// These functions work directly with the AST and are used by the interpreter

export {
    // Define a struct to hold a runtime function
    OrbitRuntimeFn(
        fn: ([OrMath_expr], OrbEnv, (OrbEnv, OrMath_expr) -> OrbEnv) -> OrbEnv
    );

    // Initialize the runtime tree with all special functions
    initOrbitRuntime() -> Tree<string, OrbitRuntimeFn>;
    
    // Type checking for AST nodes (renamed to avoid collision)
    runtimeIsAstType(typeAnnotations : [OrType]) -> bool;
    runtimeIsConstructor(expr : OrMath_expr) -> bool;
}

// Check if a type annotation indicates AST type
runtimeIsAstType(typeAnnotations : [OrType]) -> bool {
    exists(typeAnnotations, \t -> {
        switch (t.math_expr) {
            OrIdentifier(id): id == "ast";
            default: false;
        }
    });
}

// Check if expression is a constructor call
runtimeIsConstructor(expr : OrMath_expr) -> bool {
    switch (expr) {
        OrFunction(fn, __): {
            switch (fn) {
                OrIdentifier(id): {
                    // Check if first character is uppercase (convention for constructors)
                    s = getCharAt(id, 0);
                    s >= "A" && s <= "Z";
                }
                default: false;
            }
        }
        default: false;
    }
}

// Initialize the runtime tree with all special functions
initOrbitRuntime() -> Tree<string, OrbitRuntimeFn> {
    functions = [
        Pair("eval", OrbitRuntimeFn(evalFunction)),
        Pair("prettyOrbit", OrbitRuntimeFn(prettyOrbitFunction)),
        Pair("makeOGraph", OrbitRuntimeFn(makeOGraphFunction)),
        Pair("addOGraph", OrbitRuntimeFn(addFullExpressionToOGraphFunction)),
        Pair("addDomainToNode", OrbitRuntimeFn(addDomainToNodeFunction)),
        Pair("mergeOGraphNodes", OrbitRuntimeFn(mergeOGraphNodesFunction)),
        Pair("ograph2dot", OrbitRuntimeFn(ograph2dotFunction)),
        Pair("extractOGraph", OrbitRuntimeFn(extractOGraphFunction)),
        Pair("matchOGraphPattern", OrbitRuntimeFn(matchOGraphPatternFunction)),
    ];
    
    // Convert the list of pairs to a tree
    fold(functions, makeTree(), \acc, p -> setTree(acc, p.first, p.second));
}

// Implementation of eval function
evalFunction(args : [OrMath_expr], env : OrbEnv, interpret : (OrbEnv, OrMath_expr) -> OrbEnv) -> OrbEnv {
    if (length(args) != 1) {
        println("ERROR: eval expects exactly 1 argument");
        env;
    } else {
        // Direct evaluation of the expression without conversion
        interpret(env, args[0]);
    }
}

// Implementation of prettyOrbit function
prettyOrbitFunction(args : [OrMath_expr], env : OrbEnv, interpret : (OrbEnv, OrMath_expr) -> OrbEnv) -> OrbEnv {
    if (length(args) != 1) {
        println("ERROR: prettyOrbit expects exactly 1 argument");
        env;
    } else {
        // Evaluate the argument first
        envArg = interpret(env, args[0]);
        // Then pretty print it
        pretty = prettyOrbit(envArg.result);
        OrbEnv(envArg with result = OrString(pretty));
    }
}

// Implementation of makeOGraph function
makeOGraphFunction(args : [OrMath_expr], env : OrbEnv, interpret : (OrbEnv, OrMath_expr) -> OrbEnv) -> OrbEnv {
    if (length(args) != 1) {
        println("ERROR: makeOGraph expects exactly 1 argument");
        env;
    } else {
        // Evaluate the name argument
        envName = interpret(env, args[0]);
        name = getOString(envName.result, "makeOGraph");
        
        // Create the graph
        createOGraph(name);
        
        // Return the name
        OrbEnv(envName with result = OrString(name));
    }
}

// Implementation of addDomainToNode function (node ID version)
addDomainToNodeFunction(args : [OrMath_expr], env : OrbEnv, interpret : (OrbEnv, OrMath_expr) -> OrbEnv) -> OrbEnv {
    if (length(args) != 3) {
        println("ERROR: addDomainToNode expects exactly 3 arguments");
        env;
    } else {
        // Evaluate the graph name
        envName = interpret(env, args[0]);
        name = getOString(envName.result, "addDomainToNode.name");
        
        // Evaluate the node ID
        envNodeId = interpret(envName, args[1]);
        nodeId = getOInt(envNodeId.result, "addDomainToNode.nodeId");
        
        // Evaluate the domain node ID
        envDomainId = interpret(envNodeId, args[2]);
        domainId = getOInt(envDomainId.result, "addDomainToNode.domainId");
        
        // Add the domain
        success = addDomainToNode(name, nodeId, domainId);
        OrbEnv(envDomainId with result = OrBool(success));
    }
}



// Implementation of mergeOGraphNodes function
mergeOGraphNodesFunction(args : [OrMath_expr], env : OrbEnv, interpret : (OrbEnv, OrMath_expr) -> OrbEnv) -> OrbEnv {
    if (length(args) != 3) {
        println("ERROR: mergeOGraphNodes expects exactly 3 arguments");
        env;
    } else {
        // Evaluate the graph name
        envName = interpret(env, args[0]);
        name = getOString(envName.result, "mergeOGraphNodes.name");
        
        // Evaluate the first node ID
        envId1 = interpret(envName, args[1]);
        id1 = getOInt(envId1.result, "mergeOGraphNodes.id1");
        
        // Evaluate the second node ID
        envId2 = interpret(envId1, args[2]);
        id2 = getOInt(envId2.result, "mergeOGraphNodes.id2");
        
        // Merge the nodes
        success = mergeOGraphNodes(name, id1, id2);
        OrbEnv(envId2 with result = OrBool(success));
    }
}

// Implementation of addOGraph function
addFullExpressionToOGraphFunction(args : [OrMath_expr], env : OrbEnv, interpret : (OrbEnv, OrMath_expr) -> OrbEnv) -> OrbEnv {
    if (length(args) < 2) {
        println("ERROR: addOGraph expects at least 2 arguments: graph name and expression");
        env;
    } else {
        // Evaluate the graph name
        envName = interpret(env, args[0]);
        name = getOString(envName.result, "addOGraph.name");
        
        // Get the expression (not evaluated - passed as AST)
        astExpr = args[1];
        
        // Debug the AST expression if tracing
        if (env.tracing) println("Adding full expression to ograph: " + prettyOrbit(astExpr));
        
        // Get the graph from the registry
        switch (lookupTree(^ographRegistry, name)) {
            Some(ograph): {
                // Add the full expression recursively
                nodeId = orbit2OGraph(ograph, astExpr);
                if (env.tracing) println("Added full expression, root node ID: " + i2s(nodeId));
                OrbEnv(envName with result = OrInt(nodeId));
            }
            None(): {
                println("ERROR: OGraph '" + name + "' not found");
                OrbEnv(envName with result = OrInt(-1));
            }
        }
    }
}

// Implementation of extractOGraph function
extractOGraphFunction(args : [OrMath_expr], env : OrbEnv, interpret : (OrbEnv, OrMath_expr) -> OrbEnv) -> OrbEnv {
    if (length(args) != 2) {
        println("ERROR: extractOGraph expects exactly 2 arguments: graph name and node ID");
        env;
    } else {
        // Evaluate the graph name
        envName = interpret(env, args[0]);
        name = getOString(envName.result, "extractOGraph.name");
        
        // Evaluate the node ID
        envNodeId = interpret(envName, args[1]);
        nodeId = getOInt(envNodeId.result, "extractOGraph.nodeId");
        
        // Get the graph from the registry
        switch (lookupTree(^ographRegistry, name)) {
            Some(ograph): {
                // Extract the expression from the graph
                expr = ograph2Orbit(ograph, nodeId);
                if (env.tracing) println("Extracted expression from OGraph " + name + ", node " + i2s(nodeId));
                OrbEnv(envNodeId with result = expr);
            }
            None(): {
                println("ERROR: OGraph '" + name + "' not found");
                OrbEnv(envNodeId with result = OrInt(-1));
            }
        }
    }
}

// Implementation of matchOGraphPattern function
matchOGraphPatternFunction(args : [OrMath_expr], env : OrbEnv, interpret : (OrbEnv, OrMath_expr) -> OrbEnv) -> OrbEnv {
    if (length(args) != 3) {
        println("ERROR: matchOGraphPattern expects exactly 3 arguments: graph name, pattern, and callback");
        env;
    } else {
        // Evaluate the graph name
        envName = interpret(env, args[0]);
        name = getOString(envName.result, "matchOGraphPattern.name");
        
        // Get the pattern (not evaluated - passed as AST)
        pattern = args[1];
        
        println("DEBUG: Pattern for matching: " + prettyOrbit(pattern));
        
        // Get the callback function
        callbackEnv = interpret(envName, args[2]);
        callback = callbackEnv.result;
        
        // Debug output if tracing
        if (env.tracing) {
            println("Pattern matching in graph '" + name + "'");
            println("Pattern: " + prettyOrbit(pattern));
        }
        
        // Store the results of pattern matching
        results = ref [];
        
        // Ensure the callback is a function
        switch (callback) {
            OrLambda(__, params, body): {
                if (length(params) != 1) {
                    println("ERROR: matchOGraphPattern callback must take exactly one argument (bindings)");
                    OrbEnv(callbackEnv with result = OrInt(0));
                } else {
                    // Create callback adapter that will be called for each match
                    // Note: This function MUST return void (not OrbEnv) to match the expected callback type
                    matchCallback = \bindings -> {
                        // Convert bindings to Orbit-friendly format - array of pairs
                        bindingsExpr = bindings2OrbitExpr(bindings);
                        
                        println("DEBUG: Found match with " + i2s(sizeTree(bindings)) + " bindings: ");
                        // Print out each binding for debugging
                        keys = getTreeKeys(bindings);
                        iter(keys, \key -> {
                            value = lookupTreeDef(bindings, key, OrInt(0));
                            println("  " + key + " = " + prettyOrbit(value));
                        });
                        
                        // Create new environment with the variables from the bindings
                        newEnv = fold(getTreeKeys(bindings), callbackEnv, \accEnv, key -> {
                            value = lookupTreeDef(bindings, key, OrInt(0));
                            bindVar(accEnv, key, value);
                        });
                        
                        // Interpret the callback with the new environment and save the result
                        callResult = interpret(newEnv, OrFunction(callback, [bindingsExpr]));
                        
                        // Save the result
                        results := arrayPush(^results, callResult.result);
                    };
                    
                    // Call the pattern matcher with the callback
                    println("DEBUG: Calling matchOGraphPattern with graph " + name);
                    matchCount = matchOGraphPattern(name, pattern, matchCallback);
                    println("DEBUG: matchOGraphPattern returned " + i2s(matchCount) + " matches");
                    
                    if (env.tracing) {
                        println("Pattern matching complete - found " + i2s(matchCount) + " matches");
                    }
                    
                    // Return the number of matches as the result
                    OrbEnv(callbackEnv with result = OrInt(matchCount));
                }
            }
            default: {
                println("ERROR: matchOGraphPattern third argument must be a function");
                OrbEnv(callbackEnv with result = OrInt(0));
            }
        }
    }
}

// Convert variable bindings to an Orbit expression (array of pairs)
bindings2OrbitExpr(bindings : Tree<string, OrMath_expr>) -> OrMath_expr {
    pairs = map(getTreeKeys(bindings), \key -> {
        value = lookupTreeDef(bindings, key, OrInt(0));
        OrFunction(OrIdentifier("Pair"), [OrString(key), value])
    });
    
    OrArray(pairs);
}

// Implementation of ograph2dot function
ograph2dotFunction(args : [OrMath_expr], env : OrbEnv, interpret : (OrbEnv, OrMath_expr) -> OrbEnv) -> OrbEnv {
    if (length(args) != 1) {
        println("ERROR: ograph2dot expects exactly 1 argument");
        env;
    } else {
        // Evaluate the graph name
        envName = interpret(env, args[0]);
        name = getOString(envName.result, "ograph2dot.name");
        
        // Get the graph from the registry
        switch (lookupTree(^ographRegistry, name)) {
            Some(ograph): {
                // Convert the graph to DOT format
                dotCode = ograph2dot(ograph);
                if (env.tracing) println("OGraph '" + name + "' converted to DOT format");
                OrbEnv(envName with result = OrString(dotCode));
            }
            None(): {
                println("ERROR: OGraph '" + name + "' not found");
                OrbEnv(envName with result = OrString(""));
            }
        }
    }
}