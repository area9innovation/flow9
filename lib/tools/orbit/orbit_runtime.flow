import tools/orbit/orbit_types;
import tools/orbit/orbit_env;
import tools/orbit/prettyprint;
import tools/orbit/orbit_pattern;
import tools/orbit/orbit_simple_ograph;
import tools/orbit/ograph2dot;
import tools/orbit/orbit2ograph;
import tools/orbit/utils; // For access to the original utility functions
import ds/tree;
import string;

// This file provides special internal orbit functions that have the ability to NOT evaluate arguments
// These functions work directly with the AST and are used by the interpreter

export {
    // Define a struct to hold a runtime function
    OrbitRuntimeFn(
        fn: ([OrMath_expr], OrbEnv, (OrbEnv, OrMath_expr) -> OrbEnv) -> OrbEnv
    );

    // Initialize the runtime tree with all special functions
    initOrbitRuntime() -> Tree<string, OrbitRuntimeFn>;
    
    // Type checking for AST nodes (renamed to avoid collision)
    runtimeIsAstType(typeAnnotations : [OrType]) -> bool;
    runtimeIsConstructor(expr : OrMath_expr) -> bool;
}

// Check if a type annotation indicates AST type
runtimeIsAstType(typeAnnotations : [OrType]) -> bool {
    exists(typeAnnotations, \t -> {
        switch (t.math_expr) {
            OrIdentifier(id): id == "ast";
            default: false;
        }
    });
}

// Check if expression is a constructor call
runtimeIsConstructor(expr : OrMath_expr) -> bool {
    switch (expr) {
        OrFunction(fn, __): {
            switch (fn) {
                OrIdentifier(id): {
                    // Check if first character is uppercase (convention for constructors)
                    s = getCharAt(id, 0);
                    s >= "A" && s <= "Z";
                }
                default: false;
            }
        }
        default: false;
    }
}

// Initialize the runtime tree with all special functions
initOrbitRuntime() -> Tree<string, OrbitRuntimeFn> {
    functions = [
        Pair("eval", OrbitRuntimeFn(evalFunction)),
        Pair("prettyOrbit", OrbitRuntimeFn(prettyOrbitFunction)),
        Pair("makeOGraph", OrbitRuntimeFn(makeOGraphFunction)),
        Pair("addOGraph", OrbitRuntimeFn(addFullExpressionToOGraphFunction)),
        Pair("addDomainToNode", OrbitRuntimeFn(addDomainToNodeFunction)),
        Pair("mergeOGraphNodes", OrbitRuntimeFn(mergeOGraphNodesFunction)),
        Pair("ograph2dot", OrbitRuntimeFn(ograph2dotFunction)),
    ];
    
    // Convert the list of pairs to a tree
    fold(functions, makeTree(), \acc, p -> setTree(acc, p.first, p.second));
}

// Implementation of eval function
evalFunction(args : [OrMath_expr], env : OrbEnv, interpret : (OrbEnv, OrMath_expr) -> OrbEnv) -> OrbEnv {
    if (length(args) != 1) {
        println("ERROR: eval expects exactly 1 argument");
        env;
    } else {
        // Direct evaluation of the expression without conversion
        interpret(env, args[0]);
    }
}

// Implementation of prettyOrbit function
prettyOrbitFunction(args : [OrMath_expr], env : OrbEnv, interpret : (OrbEnv, OrMath_expr) -> OrbEnv) -> OrbEnv {
    if (length(args) != 1) {
        println("ERROR: prettyOrbit expects exactly 1 argument");
        env;
    } else {
        // Evaluate the argument first
        envArg = interpret(env, args[0]);
        // Then pretty print it
        pretty = prettyOrbit(envArg.result);
        OrbEnv(envArg with result = OrString(pretty));
    }
}

// Implementation of makeOGraph function
makeOGraphFunction(args : [OrMath_expr], env : OrbEnv, interpret : (OrbEnv, OrMath_expr) -> OrbEnv) -> OrbEnv {
    if (length(args) != 1) {
        println("ERROR: makeOGraph expects exactly 1 argument");
        env;
    } else {
        // Evaluate the name argument
        envName = interpret(env, args[0]);
        name = getOString(envName.result, "makeOGraph");
        
        // Create the graph
        createOGraph(name);
        
        // Return the name
        OrbEnv(envName with result = OrString(name));
    }
}

// Implementation of addDomainToNode function (node ID version)
addDomainToNodeFunction(args : [OrMath_expr], env : OrbEnv, interpret : (OrbEnv, OrMath_expr) -> OrbEnv) -> OrbEnv {
    if (length(args) != 3) {
        println("ERROR: addDomainToNode expects exactly 3 arguments");
        env;
    } else {
        // Evaluate the graph name
        envName = interpret(env, args[0]);
        name = getOString(envName.result, "addDomainToNode.name");
        
        // Evaluate the node ID
        envNodeId = interpret(envName, args[1]);
        nodeId = getOInt(envNodeId.result, "addDomainToNode.nodeId");
        
        // Evaluate the domain node ID
        envDomainId = interpret(envNodeId, args[2]);
        domainId = getOInt(envDomainId.result, "addDomainToNode.domainId");
        
        // Add the domain
        success = addDomainToNode(name, nodeId, domainId);
        OrbEnv(envDomainId with result = OrBool(success));
    }
}



// Implementation of mergeOGraphNodes function
mergeOGraphNodesFunction(args : [OrMath_expr], env : OrbEnv, interpret : (OrbEnv, OrMath_expr) -> OrbEnv) -> OrbEnv {
    if (length(args) != 3) {
        println("ERROR: mergeOGraphNodes expects exactly 3 arguments");
        env;
    } else {
        // Evaluate the graph name
        envName = interpret(env, args[0]);
        name = getOString(envName.result, "mergeOGraphNodes.name");
        
        // Evaluate the first node ID
        envId1 = interpret(envName, args[1]);
        id1 = getOInt(envId1.result, "mergeOGraphNodes.id1");
        
        // Evaluate the second node ID
        envId2 = interpret(envId1, args[2]);
        id2 = getOInt(envId2.result, "mergeOGraphNodes.id2");
        
        // Merge the nodes
        success = mergeOGraphNodes(name, id1, id2);
        OrbEnv(envId2 with result = OrBool(success));
    }
}

// Implementation of addOGraph function
addFullExpressionToOGraphFunction(args : [OrMath_expr], env : OrbEnv, interpret : (OrbEnv, OrMath_expr) -> OrbEnv) -> OrbEnv {
    if (length(args) < 2) {
        println("ERROR: addOGraph expects at least 2 arguments: graph name and expression");
        env;
    } else {
        // Evaluate the graph name
        envName = interpret(env, args[0]);
        name = getOString(envName.result, "addOGraph.name");
        
        // Get the expression (not evaluated - passed as AST)
        astExpr = args[1];
        
        // Debug the AST expression if tracing
        if (env.tracing) println("Adding full expression to ograph: " + prettyOrbit(astExpr));
        
        // Get the graph from the registry
        switch (lookupTree(^ographRegistry, name)) {
            Some(ograph): {
                // Add the full expression recursively
                nodeId = orbit2OGraph(ograph, astExpr);
                if (env.tracing) println("Added full expression, root node ID: " + i2s(nodeId));
                OrbEnv(envName with result = OrInt(nodeId));
            }
            None(): {
                println("ERROR: OGraph '" + name + "' not found");
                OrbEnv(envName with result = OrInt(-1));
            }
        }
    }
}

// Implementation of ograph2dot function
ograph2dotFunction(args : [OrMath_expr], env : OrbEnv, interpret : (OrbEnv, OrMath_expr) -> OrbEnv) -> OrbEnv {
    if (length(args) != 1) {
        println("ERROR: ograph2dot expects exactly 1 argument");
        env;
    } else {
        // Evaluate the graph name
        envName = interpret(env, args[0]);
        name = getOString(envName.result, "ograph2dot.name");
        
        // Get the graph from the registry
        switch (lookupTree(^ographRegistry, name)) {
            Some(ograph): {
                // Convert the graph to DOT format
                dotCode = ograph2dot(ograph);
                if (env.tracing) println("OGraph '" + name + "' converted to DOT format");
                OrbEnv(envName with result = OrString(dotCode));
            }
            None(): {
                println("ERROR: OGraph '" + name + "' not found");
                OrbEnv(envName with result = OrString(""));
            }
        }
    }
}