import tools/orbit/orbit_types;
import tools/runcore/core_lib;
import tools/runcore/value_types;
import tools/runcore/value_util; // For utility functions
import ds/tree;
import ds/set;

export {
	// Environment for Orbit with bindings and result value
	OrbEnv(
		vars : Tree<string, OrMath_expr>,  // Renamed from bindings to vars for consistency
		result : OrMath_expr,
		runCore : RunCore,  // Added RunCore for standard library functions
		tracing : bool,  // Controls whether to output trace messages during interpretation
		importCache : ref Tree<string, OrMath_expr>,  // Cache of imported files to avoid reparsing
		importedFiles : Set<string>  // Set of files already imported in the current scope
	);

	// A closure wrapping a lambda with captured environment
	OrbClosure(
		capturedEnv : Tree<string, OrMath_expr>,  // Captured variables from definition scope
		params : [OrIdType],                      // Function parameters
		body : OrMath_expr                        // Function body
	);

	// Create an empty environment
	emptyOrbEnv() -> OrbEnv;

	// Helper to retrieve variable from environment
	lookupVar(env : OrbEnv, name : string) -> Maybe<OrMath_expr>;

	// Helper to add a binding to environment
	bindVar(env : OrbEnv, name : string, value : OrMath_expr) -> OrbEnv;

	// Creates a closure from a lambda with captured environment
	makeClosure(capturedEnv : Tree<string, OrMath_expr>, params : [OrIdType], body : OrMath_expr) -> OrbClosure;

	// Check if an expression is a closure
	isClosure(expr : OrMath_expr) -> bool;

	// Gets the closure from an expression, if it is a closure
	getClosure(expr : OrMath_expr) -> Maybe<OrbClosure>;

	// Enable or disable tracing in the environment
	setTracing(env : OrbEnv, enabled : bool) -> OrbEnv;
}

emptyOrbEnv() -> OrbEnv {
	// Create a RunCore instance
	runCore = getRunCore();
	
	// Initialize with standard functions
	OrbEnv(makeTree(), OrInt(0), runCore, false, ref makeTree(), makeSet())
}

lookupVar(env : OrbEnv, name : string) -> Maybe<OrMath_expr> {
	lookupTree(env.vars, name)
}

bindVar(env : OrbEnv, name : string, value : OrMath_expr) -> OrbEnv {
	OrbEnv(setTree(env.vars, name, value), env.result, env.runCore, env.tracing, env.importCache, env.importedFiles)
}

makeClosure(capturedEnv : Tree<string, OrMath_expr>, params : [OrIdType], body : OrMath_expr) -> OrbClosure {
	OrbClosure(capturedEnv, params, body);
}

// We'll use a special case of OrVariable to store closure information
// Pattern: "__closure::" prefix followed by unique id
isClosure(expr : OrMath_expr) -> bool {
	switch (expr) {
		OrVariable(id): strContains(id, "__closure::");
		default: false;
	}
}

// Retrieve a closure from the environment if the expression references one
getClosure(expr : OrMath_expr) -> Maybe<OrbClosure> {
	switch (expr) {
		OrVariable(id): {
			if (strContains(id, "__closure::")) {
				// The id format is: __closure::<capturedEnv>::<params>::<body>
				// For now, we'll create a default closure with empty env
				// In a real implementation, we'd deserialize from the id string or lookup in a registry
				Some(OrbClosure(makeTree(), [], OrInt(0)));
			} else {
				None();
			}
		}
		default: None();
	}
}

// Enable or disable tracing in the environment
setTracing(env : OrbEnv, enabled : bool) -> OrbEnv {
	OrbEnv(env with tracing = enabled);
}