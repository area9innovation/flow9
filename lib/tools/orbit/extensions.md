# Extended Canonical Forms and Rewriting Rules for Mathematical Domains

## Introduction

This document extends the rewriting framework established in `canonical.md` to encompass additional mathematical domains crucial for advanced computational tasks. These extensions include differential calculus, linear algebra, polynomial ideals, homomorphic cryptography, tensor operations, and interval arithmetic. Each domain introduces new operators, canonical forms, and rewrite rules while maintaining compatibility with the existing group-theoretic framework.

## Notation

In addition to the notation established in the primary document, we introduce the following symbols for the extended domains:

### Differential Calculus Symbols
- **d/dx**: Differential operator with respect to x
- **∂/∂xᵢ**: Partial differential operator with respect to xᵢ
- **∇**: Gradient operator (vector of partial derivatives)
- **J(f)**: Jacobian matrix of function f

### Linear Algebra Symbols
- **A^T**: Transpose of matrix A
- **A^{-1}**: Inverse of matrix A
- **det(A)**: Determinant of matrix A
- **tr(A)**: Trace of matrix A
- **GL(n,F)**: General linear group (invertible n×n matrices over field F)
- **SL(n,F)**: Special linear group (n×n matrices with determinant 1 over field F)
- **O(n)**: Orthogonal group (n×n matrices M where M^T·M = I)

### Polynomial Ideals Symbols
- **⟨f₁,...,fₙ⟩**: Ideal generated by polynomials f₁,...,fₙ
- **LT(f)**: Leading term of polynomial f under a monomial ordering
- **S(f,g)**: S-polynomial of f and g
- **NF(f,G)**: Normal form of polynomial f with respect to set G

### Tensor Notation
- **T^{i₁i₂...iₙ}**: Contravariant tensor components
- **T_{i₁i₂...iₙ}**: Covariant tensor components
- **T^{i₁...iₖ}_{j₁...jₗ}**: Mixed tensor components
- **A ⊗ B**: Tensor product of A and B
- **C(T)**: Contraction of tensor T

### Interval Arithmetic Symbols
- **[a,b]**: Interval from a to b, inclusive
- **inf([a,b])**: Lower bound a
- **sup([a,b])**: Upper bound b
- **width([a,b])**: Interval width b-a
- **mid([a,b])**: Interval midpoint (a+b)/2

### Homomorphic Cryptography Symbols
- **E(m)**: Encryption of message m
- **D(c)**: Decryption of ciphertext c
- **mod n**: Modulo n operation
- **φ(n)**: Euler's totient function
- **ℤ/nℤ**: Ring of integers modulo n
- **(ℤ/nℤ)^***: Multiplicative group of units modulo n

## 1. Differential Calculus and Automatic Differentiation

Differential calculus is concerned with the computation of derivatives and their application. Automatic differentiation (AD) is a computational implementation of the chain rule that efficiently computes exact derivatives.

### Basic Differentiation Rules

```
// Constant rule
(d/dx (c)) : Diff => 0 : Canonical if is_constant(c, x);

// Identity rule
(d/dx (x)) : Diff => 1 : Canonical;

// Power rule
(d/dx (x^n)) : Diff => n * x^(n-1) : Canonical if is_constant(n, x);

// Sum rule
(d/dx (f + g)) : Diff => (d/dx (f)) + (d/dx (g)) : Canonical;

// Difference rule
(d/dx (f - g)) : Diff => (d/dx (f)) - (d/dx (g)) : Canonical;

// Product rule
(d/dx (f * g)) : Diff => f * (d/dx (g)) + (d/dx (f)) * g : Canonical;

// Quotient rule
(d/dx (f / g)) : Diff => ((d/dx (f)) * g - f * (d/dx (g))) / (g^2) : Canonical if g != 0;

// Chain rule
(d/dx (f(g(x)))) : Diff => (d/df (f))(g(x)) * (d/dx (g(x))) : Canonical;
```

### Standard Function Derivatives

```
// Exponential function
(d/dx (e^x)) : Diff => e^x : Canonical;
(d/dx (a^x)) : Diff => a^x * ln(a) : Canonical if is_constant(a, x) && a > 0;

// Logarithmic function
(d/dx (ln(x))) : Diff => 1/x : Canonical if x > 0;
(d/dx (log_a(x))) : Diff => 1/(x * ln(a)) : Canonical if is_constant(a, x) && a > 0 && x > 0;

// Trigonometric functions
(d/dx (sin(x))) : Diff => cos(x) : Canonical;
(d/dx (cos(x))) : Diff => -sin(x) : Canonical;
(d/dx (tan(x))) : Diff => sec^2(x) : Canonical if cos(x) != 0;
(d/dx (cot(x))) : Diff => -csc^2(x) : Canonical if sin(x) != 0;
(d/dx (sec(x))) : Diff => sec(x) * tan(x) : Canonical if cos(x) != 0;
(d/dx (csc(x))) : Diff => -csc(x) * cot(x) : Canonical if sin(x) != 0;

// Inverse trigonometric functions
(d/dx (arcsin(x))) : Diff => 1/sqrt(1 - x^2) : Canonical if -1 < x && x < 1;
(d/dx (arccos(x))) : Diff => -1/sqrt(1 - x^2) : Canonical if -1 < x && x < 1;
(d/dx (arctan(x))) : Diff => 1/(1 + x^2) : Canonical;
```

### Multivariate Calculus and Partial Derivatives

```
// Partial derivative of a constant
(∂/∂xᵢ (c)) : Diff => 0 : Canonical if is_constant(c, xᵢ);

// Partial derivative of a variable
(∂/∂xᵢ (xⱼ)) : Diff => 1 : Canonical if i == j;
(∂/∂xᵢ (xⱼ)) : Diff => 0 : Canonical if i != j;

// Partial derivative of a sum
(∂/∂xᵢ (f + g)) : Diff => (∂/∂xᵢ (f)) + (∂/∂xᵢ (g)) : Canonical;

// Partial derivative of a product
(∂/∂xᵢ (f * g)) : Diff => f * (∂/∂xᵢ (g)) + (∂/∂xᵢ (f)) * g : Canonical;
```

### Gradient, Jacobian, and Higher-Order Derivatives

```
// Gradient of a scalar function
(∇(f)) : Diff => {∂f/∂x₁, ∂f/∂x₂, ..., ∂f/∂xₙ} : Canonical;

// Second-order partial derivatives (commutativity) - mixed partials are equal under appropriate smoothness
(∂²f/∂xᵢ∂xⱼ) : Diff => (∂²f/∂xⱼ∂xᵢ) : Canonical if is_smooth(f);

// Higher-order derivative (composite notation simplification)
(d^n/dx^n (f + g)) : Diff => (d^n/dx^n (f)) + (d^n/dx^n (g)) : Canonical;
(d^n/dx^n (c * f)) : Diff => c * (d^n/dx^n (f)) : Canonical if is_constant(c, x);
```

### Automatic Differentiation Rules

```
// Forward-mode dual number representation
(dual(v, dv)) : Dual => (v, dv) : Canonical;

// Dual number addition
(dual(a, da) + dual(b, db)) : Dual => dual(a + b, da + db) : Canonical;

// Dual number multiplication
(dual(a, da) * dual(b, db)) : Dual => dual(a * b, a * db + da * b) : Canonical;

// Dual number function application (chain rule)
(f(dual(x, dx))) : Dual => dual(f(x), f'(x) * dx) : Canonical;

// Reverse-mode accumulation
(backprop(f(x), x)) : Diff => (∂f/∂x) : Canonical;
(backprop(f(g(x)), x)) : Diff => (∂f/∂g) * (∂g/∂x) : Canonical;
```

## 2. Linear Algebra and Matrix Identities

Linear algebra provides a framework for working with vectors, matrices, and linear transformations. This section focuses on canonical forms and rewrite rules for matrix operations.

### Basic Matrix Operations

```
// Matrix addition (element-wise)
(A + B) : Matrix => {A[i,j] + B[i,j]}_{i,j} : Canonical if dimensions(A) == dimensions(B);

// Matrix subtraction
(A - B) : Matrix => {A[i,j] - B[i,j]}_{i,j} : Canonical if dimensions(A) == dimensions(B);

// Scalar multiplication
(c * A) : Matrix => {c * A[i,j]}_{i,j} : Canonical if is_scalar(c);

// Matrix multiplication
(A * B) : Matrix => {∑ₖ A[i,k] * B[k,j]}_{i,j} : Canonical if columns(A) == rows(B);

// Matrix transposition
(A^T) : Matrix => {A[j,i]}_{i,j} : Canonical;

// Matrix inverse (definition only, not computational)
(A * A^{-1}) : Matrix => I : Canonical if is_invertible(A);
(A^{-1} * A) : Matrix => I : Canonical if is_invertible(A);
```

### Matrix Forms and Canonical Representations

```
// Row echelon form (conceptual, not computational)
(rref(A)) : Matrix => A_rref : Canonical;

// Determinant of triangular matrices
(det(A)) : Matrix => ∏ᵢ A[i,i] : Canonical if is_triangular(A);

// Trace definition
(tr(A)) : Matrix => ∑ᵢ A[i,i] : Canonical;

// Matrix transposition rules
((A^T)^T) : Matrix => A : Canonical;
((A + B)^T) : Matrix => A^T + B^T : Canonical;
((c * A)^T) : Matrix => c * A^T : Canonical if is_scalar(c);
((A * B)^T) : Matrix => B^T * A^T : Canonical;
```

### Special Matrices and Their Properties

```
// Identity matrix properties
(A * I) : Matrix => A : Canonical if columns(A) == rows(I);
(I * A) : Matrix => A : Canonical if columns(I) == rows(A);

// Diagonal matrix multiplication (efficiency rewrite)
(diag(v) * A) : Matrix => {v[i] * A[i,j]}_{i,j} : Canonical if is_diagonal(diag(v));
(A * diag(v)) : Matrix => {A[i,j] * v[j]}_{i,j} : Canonical if is_diagonal(diag(v));

// Orthogonal matrix properties
(A^T * A) : Matrix => I : Canonical if is_orthogonal(A);
(A * A^T) : Matrix => I : Canonical if is_orthogonal(A);

// Symmetric matrix properties
(A) : Matrix => A^T : Canonical if is_symmetric(A);
((A^T + A)/2) : Matrix => A : Canonical if is_symmetric(A);

// Skew-symmetric matrix properties
(A) : Matrix => -A^T : Canonical if is_skew_symmetric(A);
((A - A^T)/2) : Matrix => A : Canonical if is_skew_symmetric(A);
```

### Matrix Decompositions

```
// Eigen-decomposition (for diagonalizable matrices)
(A) : Matrix => P * D * P^{-1} : Canonical if is_diagonalizable(A);

// Singular Value Decomposition
(A) : Matrix => U * Σ * V^T : Canonical;

// QR Decomposition
(A) : Matrix => Q * R : Canonical if has_QR_decomposition(A);

// LU Decomposition
(A) : Matrix => L * U : Canonical if has_LU_decomposition(A);

// Cholesky Decomposition
(A) : Matrix => L * L^T : Canonical if is_positive_definite(A);
```

### Vector Operations

```
// Dot product
(u · v) : Vector => ∑ᵢ u[i] * v[i] : Canonical if dimensions(u) == dimensions(v);

// Cross product (3D vectors)
(u × v) : Vector => {
	u[1]*v[2] - u[2]*v[1],
	u[2]*v[0] - u[0]*v[2],
	u[0]*v[1] - u[1]*v[0]
} : Canonical if dimensions(u) == dimensions(v) == 3;

// Vector normalization
(normalize(v)) : Vector => v / |v| : Canonical if |v| != 0;
```

### Linear Transformations

```
// Linear transformation composability
(T₁ ∘ T₂) : LinearTransform => T₁(T₂) : Canonical;

// Matrix representation of composition
(A * B) : LinearTransform => matrix_of(A ∘ B) : Canonical;

// Linear transformation of linear combination
(T(a*u + b*v)) : LinearTransform => a*T(u) + b*T(v) : Canonical;
```

## 3. Polynomial Ideals and Gröbner Basis

Polynomial ideals and Gröbner bases provide a powerful framework for solving systems of polynomial equations and testing ideal membership. This section focuses on rewrite rules for polynomial manipulation and reduction.

### Polynomial Representations and Ordering

```
// Monomial ordering (lexicographic)
(x^a * y^b * z^c) : Lex => ordered_lex(x, y, z, [a, b, c]) : Canonical;

// Monomial ordering (graded lexicographic)
(x^a * y^b * z^c) : Grlex => ordered_grlex(x, y, z, [a, b, c]) : Canonical;

// Monomial ordering (graded reverse lexicographic)
(x^a * y^b * z^c) : Grevlex => ordered_grevlex(x, y, z, [a, b, c]) : Canonical;

// Leading term extraction
(LT(f)) : Poly => max_term(f) : Canonical for monomial ordering;

// Leading coefficient extraction
(LC(f)) : Poly => coefficient(LT(f)) : Canonical;

// Polynomial canonicalization (combining like terms)
(c₁ * x^a * y^b + c₂ * x^a * y^b) : Poly => (c₁ + c₂) * x^a * y^b : Canonical;
```

### Polynomial Arithmetic and Division

```
// Polynomial addition
(f + g) : Poly => sum_by_like_terms(f, g) : Canonical;

// Polynomial multiplication
(f * g) : Poly => sum_of_term_products(f, g) : Canonical;

// Multivariate polynomial division
(f / {g₁, g₂, ..., gₙ}) : Poly => {q₁, q₂, ..., qₙ, r} : Canonical where f = ∑ᵢ qᵢ * gᵢ + r;

// S-polynomial construction
(S(f, g)) : Poly => (lcm(LT(f), LT(g))/LT(f)) * f - (lcm(LT(f), LT(g))/LT(g)) * g : Canonical;
```

### Gröbner Basis Operations

```
// Normal form with respect to a Gröbner basis
(NF(f, G)) : Poly => remainder_after_division(f, G) : Canonical;

// Ideal membership test
(f ∈ ⟨G⟩) : Ideal => true : Canonical if NF(f, G) == 0;
(f ∈ ⟨G⟩) : Ideal => false : Canonical if NF(f, G) != 0;

// Reduced Gröbner basis
(reduced_GB(G)) : Ideal => reduced_basis : Canonical;

// Buchberger's algorithm (conceptual, not computational)
(grobner_basis({f₁, f₂, ..., fₙ})) : Ideal => G : Canonical;
```

### Polynomial Reduction

```
// Polynomial reduction by a single rule
(reduce(f, g)) : Poly => f - c * x^a * g : Canonical if LT(f) == c * x^a * LT(g);

// Full reduction by a set of polynomials
(reduce(f, {g₁, g₂, ..., gₙ})) : Poly => result_of_iterative_reduction : Canonical;

// Elimination ideal
(eliminate({f₁, f₂, ..., fₙ}, {x₁, x₂, ..., xₖ})) : Ideal => G ∩ k[remaining_vars] : Canonical;
```

### Special Polynomial Systems

```
// Resultant computation
(resultant(f, g, x)) : Poly => determinant_of_sylvester_matrix(f, g, x) : Canonical;

// Factorization (conceptual)
(factor(f)) : Poly => f₁ * f₂ * ... * fₖ : Canonical where f = f₁ * f₂ * ... * fₖ;

// Root finding from factorized form
(roots(f₁ * f₂ * ... * fₖ)) : Poly => union(roots(f₁), roots(f₂), ..., roots(fₖ)) : Canonical;
(roots(x - a)) : Poly => {a} : Canonical;
```

## 6. Homomorphic Cryptography and Modular Arithmetic

Homomorphic cryptography allows computation on encrypted data without decryption. Modular arithmetic forms the foundation for many cryptographic systems. This section focuses on rewrite rules for modular operations and homomorphic properties.

### Modular Arithmetic Basics

```
// Basic modular arithmetic (canonicalization)
(a mod n) : Mod => r : Canonical if a = q*n + r, 0 ≤ r < n;

// Modular addition
((a + b) mod n) : Mod => ((a mod n) + (b mod n)) mod n : Canonical;

// Modular subtraction
((a - b) mod n) : Mod => ((a mod n) - (b mod n) + n) mod n : Canonical;

// Modular multiplication
((a * b) mod n) : Mod => ((a mod n) * (b mod n)) mod n : Canonical;

// Modular inverse
(a⁻¹ mod n) : Mod => b : Canonical if (a * b) mod n = 1 and gcd(a, n) = 1;
```

### Modular Exponentiation

```
// Modular exponentiation (direct definition)
(a^b mod n) : Mod => powmod(a, b, n) : Canonical;

// Repeated squaring optimization
(a^(2k) mod n) : Mod => (a^k mod n)^2 mod n : Canonical;
(a^(2k+1) mod n) : Mod => (a * (a^k mod n)^2) mod n : Canonical;

// Euler's theorem application
(a^b mod n) : Mod => a^(b mod φ(n)) mod n : Canonical if gcd(a, n) = 1;

// Fermat's little theorem application
(a^b mod p) : Mod => a^(b mod (p-1)) mod p : Canonical if is_prime(p) and gcd(a, p) = 1;
```

### Chinese Remainder Theorem

```
// Chinese remainder theorem for two moduli
(x ≡ a₁ (mod n₁) ∧ x ≡ a₂ (mod n₂)) : CRT => x ≡ a (mod n₁*n₂) : Canonical if gcd(n₁, n₂) = 1;

// CRT for multiple moduli
(x ≡ a₁ (mod n₁) ∧ ... ∧ x ≡ aₖ (mod nₖ)) : CRT => x ≡ a (mod n₁*...*nₖ) : Canonical if all nᵢ are pairwise coprime;
```

### Homomorphic Properties

```
// Additive homomorphism
(E(a + b)) : HomomorphicAdd => E(a) ⊕ E(b) : Canonical;

// Multiplicative homomorphism
(E(a * b)) : HomomorphicMul => E(a) ⊗ E(b) : Canonical;

// Mixed homomorphism (partially homomorphic)
(E(a)^b) : HomomorphicPaillier => E(a * b) : Canonical;

// Decryption of homomorphic operations
(D(E(a) ⊕ E(b))) : Homomorphic => a + b : Canonical;
(D(E(a) ⊗ E(b))) : Homomorphic => a * b : Canonical;
```

### Ring and Group Structures

```
// The ring structure of ℤ/nℤ
(a + b) : ℤ/nℤ => (a + b) mod n : Ring;
(a * b) : ℤ/nℤ => (a * b) mod n : Ring;

// The multiplicative group (ℤ/nℤ)^*
(a * b) : (ℤ/nℤ)^* => (a * b) mod n : Group if gcd(a, n) = 1 and gcd(b, n) = 1;
(a^-1) : (ℤ/nℤ)^* => inverse(a, n) : Group if gcd(a, n) = 1;
```

### Cryptographic Applications

```
// RSA encryption/decryption
(E_RSA(m)) : RSA => m^e mod n : Canonical;
(D_RSA(c)) : RSA => c^d mod n : Canonical where e*d ≡ 1 (mod φ(n));

// Diffie-Hellman key exchange
(k_A) : DiffieHellman => g^a mod p : Canonical;
(k_B) : DiffieHellman => g^b mod p : Canonical;
(K) : DiffieHellman => (g^a)^b mod p : Canonical;
(K) : DiffieHellman => (g^b)^a mod p : Canonical;
(K) : DiffieHellman => g^(ab) mod p : Canonical;
```

## 7. Tensor Operations

Tensors generalize vectors and matrices to higher dimensions. This section focuses on rewrite rules for tensor contractions, symmetry properties, and index manipulations.

### Tensor Index Notation

```
// Einstein summation convention (automatic contraction over repeated indices)
(A_{ij} B^j) : Tensor => ∑_j A_{ij} B^j : Canonical;

// Index renaming (equivalent expressions)
(A_{ij} B^j) : Tensor => A_{ik} B^k : Canonical;

// Tensor contraction (trace-like operation)
(C(T^{ij}_{ij})) : Tensor => ∑_{i,j} T^{ij}_{ij} : Canonical;

// Symmetrized tensors
(Sym(T)_{ij}) : Tensor => (T_{ij} + T_{ji})/2 : Canonical;
```

### Tensor Products and Direct Products

```
// Tensor product definition
(A ⊗ B)_{ijkl} : Tensor => A_{ij} B_{kl} : Canonical;

// Kronecker product properties
((A ⊗ B) · (C ⊗ D)) : Tensor => (A · C) ⊗ (B · D) : Canonical if dimensions_match;

// Tensor product distributivity
(A ⊗ (B + C)) : Tensor => A ⊗ B + A ⊗ C : Canonical;
((A + B) ⊗ C) : Tensor => A ⊗ C + B ⊗ C : Canonical;
```

### Tensor Symmetry Properties

```
// Symmetric tensor properties
(T_{ij}) : SymmetricTensor => T_{ji} : Canonical;

// Anti-symmetric (skew-symmetric) tensor properties
(T_{ij}) : SkewSymmetricTensor => -T_{ji} : Canonical;
(T_{ii}) : SkewSymmetricTensor => 0 : Canonical;

// Cyclic tensor property
(T_{ijk}) : CyclicTensor => T_{jki} : Canonical;
(T_{ijk}) : CyclicTensor => T_{kij} : Canonical;
```

### Tensor Algebra

```
// Tensor addition
(A + B)_{ij...} : Tensor => A_{ij...} + B_{ij...} : Canonical if same_shape(A, B);

// Scalar multiplication
(c * A)_{ij...} : Tensor => c * A_{ij...} : Canonical;

// Inner product of tensors (full contraction)
(A_{ij} · B^{ij}) : Tensor => ∑_{i,j} A_{ij} B^{ij} : Canonical;
```

### Tensor Calculus

```
// Covariant derivative
(∇_i T^j) : TensorCalculus => ∂_i T^j + Γ^j_{ik} T^k : Canonical;

// Divergence of a tensor
(div T)_i : TensorCalculus => ∇_j T^j_i : Canonical;

// Curl of a vector field (anti-symmetric part of gradient)
(curl v)^i : TensorCalculus => ε^{ijk} ∇_j v_k : Canonical;
```

### Tensor Canonical Ordering of Indices

```
// Canonical order of free indices (lexicographic ordering)
(T_{ji}^{kl}) : Tensor => T_{ij}^{kl} : Canonical if i < j;

// Canonical ordering of dummy indices (lexicographically earliest pairs first)
(A_{ik} B^k_j) : Tensor => A_{im} B^m_j : Canonical;
```

## 8. Interval Arithmetic

Interval arithmetic operates on intervals instead of precise values, providing guaranteed bounds for numerical computations. This section focuses on rewrite rules for interval operations and constraints.

### Basic Interval Operations

```
// Interval canonicalization
([a, b]) : Interval => {} : Canonical if a > b; // Empty interval
([a, b]) : Interval => [a, b] : Canonical if a ≤ b; // Valid interval

// Interval addition
([a, b] + [c, d]) : Interval => [a + c, b + d] : Canonical;

// Interval subtraction
([a, b] - [c, d]) : Interval => [a - d, b - c] : Canonical;

// Interval multiplication
([a, b] * [c, d]) : Interval => [min(a*c, a*d, b*c, b*d), max(a*c, a*d, b*c, b*d)] : Canonical;

// Special case for positive intervals
([a, b] * [c, d]) : Interval => [a*c, b*d] : Canonical if a ≥ 0 && c ≥ 0;

// Interval reciprocal
(1 / [a, b]) : Interval => [1/b, 1/a] : Canonical if 0 ∉ [a, b];

// Interval division
([a, b] / [c, d]) : Interval => [a, b] * [1/d, 1/c] : Canonical if 0 ∉ [c, d];
```

### Interval Functions

```
// Interval square
([a, b]^2) : Interval => [min(a^2, b^2), max(a^2, b^2)] : Canonical if a ≤ 0 && b ≥ 0;
([a, b]^2) : Interval => [a^2, b^2] : Canonical if a ≥ 0 || b ≤ 0;

// Interval square root
(sqrt([a, b])) : Interval => [sqrt(a), sqrt(b)] : Canonical if a ≥ 0;
(sqrt([a, b])) : Interval => [0, sqrt(b)] : Canonical if a < 0 && b ≥ 0;

// Interval exponential
(exp([a, b])) : Interval => [exp(a), exp(b)] : Canonical;

// Interval logarithm
(log([a, b])) : Interval => [log(a), log(b)] : Canonical if a > 0;
```

### Interval Set Operations

```
// Interval intersection
([a, b] ∩ [c, d]) : Interval => [max(a, c), min(b, d)] : Canonical if max(a, c) ≤ min(b, d);
([a, b] ∩ [c, d]) : Interval => {} : Canonical if max(a, c) > min(b, d); // Empty intersection

// Interval union (only if intervals overlap or touch)
([a, b] ∪ [c, d]) : Interval => [min(a, c), max(b, d)] : Canonical if max(a, c) ≤ min(b, d) + epsilon;
```

### Interval Properties and Relations

```
// Interval width
(width([a, b])) : Interval => b - a : Canonical;

// Interval midpoint
(mid([a, b])) : Interval => (a + b) / 2 : Canonical;

// Interval inclusion
([a, b] ⊆ [c, d]) : Interval => true : Canonical if a ≥ c && b ≤ d;
([a, b] ⊆ [c, d]) : Interval => false : Canonical if a < c || b > d;

// Point membership
(x ∈ [a, b]) : Interval => true : Canonical if a ≤ x && x ≤ b;
(x ∈ [a, b]) : Interval => false : Canonical if x < a || x > b;
```

### Interval Constraints and Solutions

```
// Interval constraints intersection
(solve(x ∈ [a, b] ∧ x ∈ [c, d])) : Interval => x ∈ ([a, b] ∩ [c, d]) : Canonical;

// Interval constraints union
(solve(x ∈ [a, b] ∨ x ∈ [c, d])) : Interval => x ∈ ([a, b] ∪ [c, d]) : Canonical if can_form_single_interval;
```

## Domain Interconnections

This section explores relationships and transformations between the extended domains, showcasing how concepts from one domain relate to another.

### Differential Calculus and Linear Algebra

```
// Jacobian matrix definition
(J(f)_{ij}) : DiffLA => ∂f_i/∂x_j : Canonical;

// Gradient as a special case of Jacobian
(∇f) : DiffLA => J(f)^T : Canonical if f is scalar;

// Hessian matrix
(H(f)_{ij}) : DiffLA => ∂²f/∂x_i∂x_j : Canonical;
```

### Differential Calculus and Tensor Calculus

```
// Gradient as a (1,0) tensor
(∇f) : DiffTensor => (∂f/∂x_1, ∂f/∂x_2, ..., ∂f/∂x_n) : Canonical;

// Vector derivative as a (1,1) tensor
(∇v) : DiffTensor => ∂v_i/∂x_j : Canonical;
```

### Linear Algebra and Tensors

```
// Matrix as a (2,0) tensor
(A_{ij}) : LATensor => T^{ij} : Canonical;

// Tensor contraction as matrix multiplication
(T^{ik}_{jl} δ^j_m δ^l_n) : LATensor => A_{mn} : Canonical where A = matrix_of(T);
```

### Linear Algebra and Polynomial Systems

```
// Linear system as polynomial system
(A*x = b) : LAPolynomial => {a_{1,1}*x_1 + ... + a_{1,n}*x_n - b_1, ..., a_{m,1}*x_1 + ... + a_{m,n}*x_n - b_m} : Canonical;

// Matrix characteristic polynomial
(det(A - λI)) : LAPolynomial => p(λ) : Canonical where p is the characteristic polynomial;
```

### Interval Arithmetic and Differential Calculus

```
// Derivative bound for monotonic function
(d/dx(f)(x) ∈ [a, b]) : IntervalDiff => ∀x₁,x₂∈[c,d]: (f(x₂) - f(x₁))/(x₂ - x₁) ∈ [a, b] : Canonical if a > 0 || b < 0;

// Mean value theorem application
(f(y) - f(x)) : IntervalDiff => (y - x) * f'(ξ) : Canonical where ξ ∈ [x, y];
```

## Practical Applications

This section provides examples of how the rewriting rules in this document can be applied to solve practical problems.

### Example 1: Automatic Differentiation

```
// Compute derivative of a composed function
expr = d/dx(sin(x^2 + 3*x))

// Step 1: Apply chain rule
=> (d/dx(sin))(x^2 + 3*x) * d/dx(x^2 + 3*x)

// Step 2: Use standard derivatives
=> cos(x^2 + 3*x) * d/dx(x^2 + 3*x)

// Step 3: Apply sum rule
=> cos(x^2 + 3*x) * (d/dx(x^2) + d/dx(3*x))

// Step 4: Apply power rule and constant multiple rule
=> cos(x^2 + 3*x) * (2*x + 3)

// Final simplified expression
=> (2*x + 3) * cos(x^2 + 3*x)
```

### Example 2: Matrix Operation Optimization

```
// Compute the expression efficiently
expr = A^T * (B + C)^T * D

// Apply transpose of sum
=> A^T * (B^T + C^T) * D

// Apply distributive property
=> A^T * B^T * D + A^T * C^T * D

// Apply transpose of product
=> A^T * B^T * D + A^T * C^T * D
=> A^T * B^T * D + A^T * C^T * D
=> (B * A)^T * D + (C * A)^T * D
=> ((B * A)^T * D) + ((C * A)^T * D)
```

### Example 3: Polynomial Ideal Reduction

```
// Given polynomials in Q[x,y,z]
f = x^2 + y^2 + z^2 - 1
g = x*y - z
h = x^2 - y

// Compute the Gröbner basis G of the ideal <f,g,h>
G = grobner_basis({f, g, h})

// Reduce a polynomial with respect to the Gröbner basis
p = x^3*y^2 + z^4
red_p = NF(p, G)

// Test ideal membership
if NF(p, G) == 0 then p ∈ <f,g,h>
else p ∉ <f,g,h>
```

### Example 4: Interval Constraint Solving

```
// Solve the constraint: x^2 ∈ [1, 4] and x ∈ [-3, 3]

// Step 1: Find interval for x such that x^2 ∈ [1, 4]
// x^2 ∈ [1, 4] => x ∈ [-2, -1] ∪ [1, 2]

// Step 2: Intersect with the constraint x ∈ [-3, 3]
([-2, -1] ∪ [1, 2]) ∩ [-3, 3] => [-2, -1] ∪ [1, 2]

// Result: x ∈ [-2, -1] ∪ [1, 2]
```

### Example 5: Modular Exponentiation Optimization

```
// Compute 7^1000 mod 13 efficiently

// Apply Fermat's little theorem (since 13 is prime)
// 7^(p-1) ≡ 1 (mod p), so 7^12 ≡ 1 (mod 13)
7^1000 mod 13 => 7^(1000 mod 12) mod 13

// Compute 1000 mod 12 = 4
=> 7^4 mod 13

// Use repeated squaring
=> 7^2 mod 13 = 49 mod 13 = 10
=> 10^2 mod 13 = 100 mod 13 = 9

// Result: 7^1000 mod 13 = 9
```

### Example 6: Tensor Index Manipulation

```
// Simplify a tensor expression
expr = A_{ij} B^j_k C^{ki}

// Rename dummy indices for readability
=> A_{ij} B^j_k C^{ki}
=> A_{im} B^m_n C^{ni}

// Recognize as trace of matrix product
=> tr(A * C * B^T)
```

## Conclusion

This document has extended the rewriting framework established in `canonical.md` to encompass six additional mathematical domains. By integrating differential calculus, linear algebra, polynomial ideals, homomorphic cryptography, tensor operations, and interval arithmetic into the e-graph rewriting system, we enable powerful cross-domain optimizations and transformations.

The rewriting rules provided offer a foundation for developing computational systems that can fluidly move between different mathematical structures while preserving semantic equivalence. This capability is essential for advanced applications in scientific computing, symbolic mathematics, cryptography, machine learning, and verified computing.

Future extensions could include domains such as:
1. Probability theory and statistics
2. Boolean algebra and logical circuits
3. Type theory and proof systems
4. Quantum computation
5. Category theory

By continually expanding the range of domains covered by our rewriting system, we strengthen its ability to support increasingly sophisticated computational tasks across the mathematical sciences.