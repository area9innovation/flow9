import tools/orbit/types;
import ds/tree;
import maybe;

export {
    // Create a new, empty OGraph
    makeOGraph() -> OGraph;

    // Find the canonical id (root) of the equivalence class for a node
    findORoot(graph : OGraph, id : int) -> int;

    // Insert a new node into the graph and return its id
    insertONode(graph : OGraph, node : ONode) -> int;

    // Lookup a node in the graph
    lookupOClass(graph : OGraph, id : int) -> Maybe<OClass>;

    // Add a node to an equivalence class
	changeONodeInClass(graph : OGraph, classId : int, node : ONode) -> void;

    // Merge two equivalence classes
    mergeOClasses(graph : OGraph, id1 : int, id2 : int) -> void;

    // Create a new domain
    makeODomain(domain : string) -> ODomain;

    // Find a node in the graph that matches the given domain, op, and children
    findONode(graph : OGraph, domain : ODomain, op : string, children : [int]) -> Maybe<int>;
    
    // Traverse the graph and apply a function to each node
    traverseOGraph(graph : OGraph, fn : (int, ONode) -> void) -> void;
    
    // Insert a node if it doesn't exist, or find its id if it does
    insertOrFindONode(graph : OGraph, node : ONode) -> int;
}

// Create a new, empty OGraph
makeOGraph() -> OGraph {
    OGraph(ref makeTree(), ref makeTree(), ref 1) // Start IDs from 1
}

// Find the root of an equivalence class
findORoot(graph : OGraph, id : int) -> int {
    switch (lookupTree(^(graph.classes), id)) {
        None(): id;  // This is the root
        Some(parentId): {
            // Find the root recursively
            findORoot(graph, parentId);
        }
    }
}

// Lookup a node in the graph
lookupOClass(graph : OGraph, id : int) -> Maybe<OClass> {
    root = findORoot(graph, id);
    lookupTree(^(graph.oclasses), root)
}

// Find a node in the graph that matches the given domain, op, and children
findONode(graph : OGraph, domain : ODomain, op : string, children : [int]) -> Maybe<int> {
    // Find canonical representatives for all children
    canonicalChildren = map(children, \child -> findORoot(graph, child));
    
    // Look through all nodes in the graph to find a match
    foldTree(^(graph.oclasses), None(), \classId, oclass, acc -> {
        if (acc != None()) {
            acc
        } else if (oclass.node.op == op && 
                 oclass.node.domain.domain == domain.domain && 
                 length(oclass.node.children) == length(canonicalChildren)) {
            // Check if all children match
            allMatch = foldi(oclass.node.children, true, \i, match, child -> {
                match && (i < length(canonicalChildren)) && (findORoot(graph, child) == canonicalChildren[i])
            });
            
            if (allMatch) Some(classId) else None();
        } else {
            None()
        }
    })
}

changeONodeInClass(graph : OGraph, classId : int, node : ONode) -> void {
    root = findORoot(graph, classId);
    switch (lookupTree(^(graph.oclasses), root)) {
        None(): { /* Cannot add to non-existent class */ };
        Some(oclass): {
            // Create a new OClass with the same root but the new node
            updatedClass = OClass(root, node);
            graph.oclasses := setTree(^(graph.oclasses), root, updatedClass);
        }
    }
}

// Insert a new node into the graph
insertONode(graph : OGraph, node : ONode) -> int {
	// Get the next available ID
	newId = ^(graph.next_id);
	newClass = OClass(newId, node);
	
	// Add the node to the graph
	graph.oclasses := setTree(^(graph.oclasses), newId, newClass);
	graph.classes := setTree(^(graph.classes), newId, newId); // Points to itself initially
	
	// Increment the ID counter for next use
	graph.next_id := newId + 1;
	
	newId;
}

insertOrFindONode(graph : OGraph, node : ONode) -> int {
    // First check if the node already exists
    existingNode = findONode(graph, node.domain, node.op, node.children);
    switch (existingNode) {
        None(): insertONode(graph, node); // Insert the new node
        Some(id): findORoot(graph, id); // Return the canonical id
    }
}


// Merge two equivalence classes
mergeOClasses(graph : OGraph, id1 : int, id2 : int) -> void {
    root1 = findORoot(graph, id1);
    root2 = findORoot(graph, id2);
    
    if (root1 != root2) {
        // We always use the first as the new root to ensure specificity is preserved
        newRoot = root1;
        oldRoot = root2;
        
        // Update the union-find data structure
        graph.classes := setTree(^(graph.classes), oldRoot, newRoot);
        
        // Also need to update the OClass mapping
        switch (lookupTree(^(graph.oclasses), oldRoot)) {
            None(): {};
            Some(oldClass): {
                // The old class points to the new root
                updatedOldClass = OClass(newRoot, oldClass.node);
                graph.oclasses := setTree(^(graph.oclasses), oldRoot, updatedOldClass);
            }
        }
    }
}

// Create a new domain
makeODomain(domain : string) -> ODomain {
    ODomain(domain)
}

// Traverse the graph and apply a function to each node
traverseOGraph(graph : OGraph, fn : (int, ONode) -> void) -> void {
    traverseInOrder(^(graph.oclasses), \__, oclass -> {
		root = findORoot(graph, oclass.root);
		if (root == oclass.root) {
	        fn(oclass.root, oclass.node);
		}
    });
}