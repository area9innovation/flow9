import tools/runcore/value_types;
import tools/orbit/orbit_types;
import tools/orbit/prettyprint;
import tools/orbit/orbit_decompose;
import runtime;

export {
	// Conversion functions between orbit expressions and CoreValue
	orbit2CoreValue(expr : OrMath_expr) -> CoreValue;
	coreValue2Orbit(val : CoreValue) -> OrMath_expr;
}

// Convert Orbit expression to CoreValue
orbit2CoreValue(expr : OrMath_expr) -> CoreValue {
	// First, handle basic values directly - no need to decompose
	switch (expr) {
		OrInt(i): CoreInt(i);
		OrDouble(d): CoreDouble(d);
		OrString(s): CoreString(s);
		OrBool(b): CoreBool(b);
		OrArray(elements): {
			// For arrays, convert each element to CoreValue
			elements_values = map(elements, orbit2CoreValue);
			CoreArray(elements_values);
		}
		OrIdentifier(id): {
			// For identifiers, we can use the identifier name directly
			CoreConstructor("Identifier", [CoreString(id)]);
		}
		default: {
			// For all other cases, use the decompose function
			pair = decomposeOrbit(expr);
			op = pair.first;
			children = pair.second.first;
			
			// Convert the operator and children to CoreValue
			children_values = map(children, orbit2CoreValue);
			// Create a CoreConstructor with the operator name and args
			CoreConstructor(op, children_values);
		}
	}
}

// Convert CoreValue back to Orbit expression
coreValue2Orbit(val : CoreValue) -> OrMath_expr {
	switch (val) {
		CoreInt(i): OrInt(i);
		CoreDouble(d): OrDouble(d);
		CoreString(s): OrString(s);
		CoreArray(values): OrArray(map(values, coreValue2Orbit));
		CoreBool(b): OrBool(b);
		CoreConstructor(name, args): {
			if (name == "Identifier") {
				// If the name is "Identifier", we can use the first argument as the identifier
				switch (args[0]) {
					CoreString(id): OrIdentifier(id);
					default: OrIdentifier("unknown");
				}
			} else {
				orbit_children = map(args, coreValue2Orbit);
				// Use the constructOrbit function to rebuild the expression
				constructOrbit(name, orbit_children, OrbitNone());
			}
		}
	}
}