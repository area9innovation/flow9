import lib/reflect;
import lib/sort;
import lib/array;

// TODO: The triple order is wrong, and we have to sum the exponents across all variables
fn sort_glex(a) = mergeSort(a, glex_compare);

// Test function for polynomial term sorting using glex ordering
fn test_glex_sorting() = (
    println("Testing Graded Lexicographic Ordering for Polynomials");
    println("=============================================\n");
    
    // Create some polynomial term examples using quote to keep them as AST
    let terms = [
        quote(x^2 * y),
        quote(x * y^2),
        quote(x * y),
        quote(z^3),
        quote(x^3),
        quote(y^3),
        quote(1),
        quote(x),
        quote(y * z),
        quote(x * y * z)
    ];
    
    println("Original terms:");
//    println(strGlue(map(terms, \st.prettyOrbit(st)), "\n"));
	iter(terms, \st. (
		println("Term: " + prettyOrbit(st));
		println(prettyOrbit(extract_term_triples(st)))
	));
    
    // Sort the terms using glex ordering
    let sorted = mergeSort(terms, glex_compare);
    
    println("\nSorted terms (graded lexicographic order):");
    iter(sorted, \st. println(prettyOrbit(st)));

    // Now let's test with a full polynomial expression
    println("\nTest sorting terms in a polynomial expression");
    let poly_expr = quote(x * y + z^3 + 1 + x^3 + y * z + x^2 * y);
    
    // Extract terms (by evaluating the quoted expression)
    let extract_terms = \expr . (
        expr is (
            a + b => extract_terms(a) + extract_terms(b);
            _ => [expr]
        )
    );
    
    let poly_terms = extract_terms(poly_expr);
    println("Extracted terms:");
    println(strGlue(map(poly_terms, \st.prettyOrbit(st)), "\n"));
    
    // Sort the polynomial terms
    let sorted_poly = sort_glex(poly_terms);
    println("\nSorted polynomial terms:");
    println(strGlue(map(sorted_poly, \st.prettyOrbit(st)), "\n"));
    
    // Reconstruct the sorted polynomial
    fn construct_poly(terms, index) = (
        if index >= length(terms) then 
            (0) // Use 0 as the base case
        else if index == length(terms) - 1 then 
            terms[index] // Last term doesn't need a plus
        else 
			// TODO: We have to keep this as AST
            terms[index] + construct_poly(terms, index + 1)
    );
    
    let sorted_poly_expr = construct_poly(sorted_poly, 0);
    println("\nReconstructed sorted polynomial:");
    println(prettyOrbit(sorted_poly_expr));
);

// Run the test function
test_glex_sorting();