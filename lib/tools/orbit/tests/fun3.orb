// fun3.orb: Demonstrates the matchSExprNodeOneLevel function

// Function to create a quoted expression (prevents evaluation)
fn quote(a : ast) = a;

// Create a graph and add a simple expression
let g = makeOGraph("test_graph");
let expr = quote(2*x);
let n = addOGraph(g, expr);

// Print the expression we added
println("Added expression:");
println(extractOGraph(g, n));

// Create a simple pattern with a variable 'a'
let pattern = quote(2*a);
println("Pattern to match:");
println(pattern);

// Use our new one-level matcher with empty bindings
let result = matchSExprNodeOneLevel(g, n, pattern, []);

// Print the result
println("\nMatch result:");
println(result);

// Extract the match status and bindings
let success = result[0];
let bindings = result[1];

println("\nMatch successful? " + if success then "Yes" else "No");
println("Bindings: " + prettyOrbit(bindings));

// Compare with traditional pattern matching
println("\nComparing with traditional matchOGraphPattern:");
matchOGraphPattern(g, pattern, \bindings, eclass -> (
    println("Traditional pattern matched!");
    println("Tree bindings: " + prettyOrbit(bindings));
    println("Matched at eclass: " + i2s(eclass));
));

// Try with non-matching pattern
let nonMatchingPattern = quote(3*a);
println("\nTrying with non-matching pattern: " + prettyOrbit(nonMatchingPattern));
let nonMatchResult = matchSExprNodeOneLevel(g, n, nonMatchingPattern, []);
println("Non-match result: " + prettyOrbit(nonMatchResult));
println("Match successful? " + if nonMatchResult[0] then "Yes - WRONG!" else "No - Correct!");