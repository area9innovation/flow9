// Simplified test for algebraic expression rewriting using orbitRewrite
fn quote(e : ast) = e;

// Test with the distributive property rewrite
// Original expression: d * (e + f)
let expr = quote(d * (e + f));

// Pattern for distributive property: x * (y + z)
let pattern = quote(x * (y + z));

// Replacement: (x * y) + (x * z)
let replacement = quote((x * y) + (x * z));

println("Original expression: " + prettyOrbit(expr));
println("Pattern: " + prettyOrbit(pattern));
println("Replacement: " + prettyOrbit(replacement));

// Create a new OGraph to work with
let graph = makeOGraph("rewrite_graph");

// Add the original expression to the graph
let exprId = addOGraph(graph, expr);

// Apply the rule to the graph
let matchCount = matchOGraphPattern(graph, pattern, \(bindings, eclassId) . (
	println("Found match at eclass ID: " + i2s(eclassId));

	// Process the replacement, evaluating only parts wrapped in eval()
	let result = unquote(replacement, bindings);
	println("Replacement result: " + prettyOrbit(result));
	
	// Add the result to the graph
	let resultId = addOGraph(graph, result);
	
	// Merge the result with the matched node's eclass
	let _ = mergeOGraphNodes(graph, eclassId, resultId);
));

println("Applied " + i2s(matchCount) + " rewrites");

// Extract the rewritten expression
let result = extractOGraph(graph, exprId);

println("Rewritten expression: " + prettyOrbit(result));

result
