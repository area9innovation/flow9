import lib/reflect; // For quote, astname etc.
import lib/array;  // For list operations
// Import the specific tree implementation
import lib/tree;

// ----- S-Expression Constructors (Mirroring sexpr_types.flow) -----
/*
Bool(b : bool);
Constructor(name : string); // Use List([Constructor(name), arg1, ...]) for applied constructors
Double(d : double);
Int(i : int);
List(exprs : [ast]); // General list / function call
Operator(op : string);
SSString(s : string); // Renamed to avoid conflict with Flow9's string
Variable(name : string);
Vector(exprs : [ast]);

// Special form markers (used within List)
And(); Begin(); Define(); Eval(); If(); Import(); Lambda(); Let(); LetRec(); Match(); Or(); Quote(); Set();

// Runtime values
Closure(params : ast, body : ast, captured_env_tree : ast); // Capture the tree directly
Builtin(name : string); // Represents a built-in function

// Environment - Now directly uses the tree structure from tree.orb
// We don't strictly need the Env wrapper anymore, but keep it for structure clarity
// The 'bindings' field now holds an Empty() or Node(...) directly.
Env(bindings : ast);

// Result wrapper
Result(value : ast, new_env : Env);
*/
// ----- Environment Helpers (using tree.orb functions) -----

// lookup uses the imported lookup function directly
fn lookupEnv(env : Env, name : string) -> ast = (
	env is Env(bindings_tree) => (
		// tree.orb::lookup returns Some(value) or None()
		lookup(bindings_tree, name) is (
			Some(value) => value;
			None() => (
				println("Error: Unbound variable: " + name);
				// TODO: Check for builtins if not pre-bound
				List([]) // Return Nil equivalent on error
			)
		)
	)
);

// update uses insertTree, which handles updates if the key exists
fn updateEnv(env : Env, name : string, value : ast) -> Env = (
	env is Env(bindings_tree) => Env(insertTree(bindings_tree, name, value))
);

// Extends with multiple bindings (list of pairs)
fn extendEnv(env : Env, new_bindings : [ast]) -> Env = (
	fold(new_bindings, env, \acc_env, binding ->
		binding is List([Variable(name), value]) => updateEnv(acc_env, name, value)
	)
);

// Check if a key exists in the environment
fn containsKeyEnv(env : Env, name : string) -> bool = (
	env is Env(bindings_tree) => (
		lookup(bindings_tree, name) is (
			Some(_) => true;
			None() => false
		)
	)
);


// ----- List Evaluation Helper -----

// Evaluates a list of expressions, returning evaluated args and final env
fn eval_list(exprs : [ast], env : Env) -> Result([ast], Env) = (
	if length(exprs) = 0 then Result([], env)
	else (
		let first_res = eval(exprs[0], env);
		let rest_res = eval_list(tail(exprs), first_res.new_env);
		Result([first_res.value] + rest_res.value, rest_res.new_env)
	)
);


// ----- Core Evaluation Rules: eval(expr, env) -> Result(value, new_env) -----

// Basic values: return themselves, environment unchanged
eval(i : Int, env : Env)      => Result(i, env);
eval(d : Double, env : Env)   => Result(d, env);
eval(b : Bool, env : Env)     => Result(b, env);
eval(s : SSString, env : Env) => Result(s, env); // Use SSString
eval(c : Constructor, env : Env) => Result(c, env); // Constructors evaluate to themselves
eval(op : Operator, env : Env)   => Result(op, env);   // Operators evaluate to themselves

// Variable lookup using the new helper
eval(Variable(name), env : Env) => Result(lookupEnv(env, name), env);

// Vector evaluation
eval(Vector(exprs), env : Env) => (
	let eval_res = eval_list(exprs, env);
	Result(Vector(eval_res.value), eval_res.new_env)
);

// List evaluation (handles special forms and function calls)
eval(List(items), env : Env) => (
	if length(items) = 0 then Result(List([]), env) // Empty list
	else (
		let head = items[0];
		let tail_args = tail(items);

		// Check for special forms by matching the head
		head is (
			// --- Special Forms ---
			Quote() => if length(tail_args) = 1 then Result(tail_args[0], env)
					   else (println("Error: quote requires 1 argument"); Result(List([]), env));

			If() => (
				if length(tail_args) < 2 || length(tail_args) > 3 then (
					println("Error: if requires 2 or 3 arguments"); Result(List([]), env)
				) else (
					let cond_res = eval(tail_args[0], env);
					cond_res.value is Bool(b) => (
						if b then eval(tail_args[1], cond_res.new_env) // Eval 'then' branch
						else if length(tail_args) = 3 then eval(tail_args[2], cond_res.new_env) // Eval 'else' branch
						else Result(List([]), cond_res.new_env) // No 'else', return Nil
					) else (
						println("Error: if condition not a boolean"); Result(List([]), cond_res.new_env)
					)
				)
			);

			Lambda() => (
				if length(tail_args) != 2 then (
					println("Error: lambda requires params and body"); Result(List([]), env)
				) else (
					// Params should be List([Variable(p1), ...])
					let params = tail_args[0];
					let body = tail_args[1];
					// Capture the *current* environment tree directly
					env is Env(bindings_tree) => Result(Closure(params, body, bindings_tree), env)
				)
			);

			Define() => (
				if length(tail_args) != 2 then (
					println("Error: define requires name and value"); Result(List([]), env)
				) else (
					// Simplified: handles (define name expr)
					tail_args[0] is Variable(name) => (
						let val_res = eval(tail_args[1], env);
						// Use updateEnv helper
						let new_env = updateEnv(val_res.new_env, name, val_res.value);
						Result(val_res.value, new_env) // Return the value defined
					) else (
						println("Error: define name must be a variable"); Result(List([]), env)
					)
				)
			);

			Set() => (
				if length(tail_args) != 2 then (
					println("Error: set! requires name and value"); Result(List([]), env)
				) else (
					tail_args[0] is Variable(name) => (
						// Check if variable exists using containsKeyEnv
						if containsKeyEnv(env, name) then (
							let val_res = eval(tail_args[1], env);
							// Use updateEnv helper
							let new_env = updateEnv(val_res.new_env, name, val_res.value);
							Result(val_res.value, new_env)
						) else (
							println("Error: set! undefined variable: " + name); Result(List([]), env)
						)
					) else (
						println("Error: set! name must be a variable"); Result(List([]), env)
					)
				)
			);

			Begin() => (
				// Evaluate sequence, return last result
				fold(tail_args, Result(List([]), env), \acc_res, expr ->
					eval(expr, acc_res.new_env)
				)
			);

			// TODO: Implement And, Or (with short-circuiting), Let, LetRec, Match, Eval, Import

			// --- Default: Function Call ---
			_ => (
				// Evaluate the head expression to get the function value
				let fn_res = eval(head, env);
				// Evaluate arguments in the resulting environment
				let args_res = eval_list(tail_args, fn_res.new_env);
				// Apply the function
				apply(fn_res.value, args_res.value, args_res.new_env)
			)
		)
	)
);


// ----- Function Application: apply(fn_val, args, env) -> Result(value, new_env) -----

// Closure now holds the captured tree directly
apply(Closure(params, body, captured_bindings_tree), args : [ast], call_env : Env) => (
	// Extract param names
	let param_names = params is List(ps) => filtermap(ps, \p -> p is Variable(n) => Some(n));

	// Check arity
	if length(param_names) != length(args) then (
		println("Error: Arity mismatch. Expected " + i2s(length(param_names)) + ", got " + i2s(length(args)));
		Result(List([]), call_env)
	) else (
		// Create bindings: list of List([Variable(name), value])
		let arg_bindings = mapi(args, \i, arg_val -> List([Variable(param_names[i]), arg_val]));

		// Create a temporary Env wrapper for the captured tree to use extendEnv
		let captured_env_wrapper = Env(captured_bindings_tree);
		// Extend the *captured* environment with arguments
		let extended_env = extendEnv(captured_env_wrapper, arg_bindings);

		// Evaluate the body in the extended environment
		let body_res = eval(body, extended_env);

		// Return the result, but propagate the environment from the call site *outside* the closure's scope
		Result(body_res.value, call_env)
	)
);

apply(Builtin(name), args : [ast], env : Env) => (
	// Placeholder for calling built-in functions
	println("TODO: Implement apply for Builtin: " + name);
	Result(List([]), env)
);

apply(Constructor(name), args : [ast], env : Env) => (
	// Applying a constructor returns a list: (Constructor(Name) arg1 arg2 ...)
	Result(List([Constructor(name)] + args), env)
);


apply(fn_val, args, env) => (
	println("Error: Cannot apply non-function value: " + prettyOrbit(fn_val));
	Result(List([]), env)
);

// ----- Initial Environment -----
fn initial_env() -> Env = (
	// Populate with built-in functions mapped to Builtin constructors
	let builtins = [
		("+", Builtin("+")), ("-", Builtin("-")), ("*", Builtin("*")), ("/", Builtin("/")),
		("=", Builtin("=")), ("<", Builtin("<")), (">", Builtin(">")), // etc.
		("car", Builtin("car")), ("cdr", Builtin("cdr")), ("cons", Builtin("cons")),
		("list", Builtin("list")), ("println", Builtin("println"))
		// ... add all stdlib functions
	];
	// Start with an Empty tree from the imported library
	let initial_tree = fold(builtins, Empty(), \acc_tree, pair -> insertTree(acc_tree, pair[0], pair[1]));
	Env(initial_tree)
);

// ----- Example Usage -----
/*
let code = quote(
	(begin
		(define add (lambda (a b) (+ a b)))
		(add 5 3)
	)
);
let start_env = initial_env();
let final_result = eval(code, start_env);

println("Final Value: " + prettyOrbit(final_result.value));
// Expected: Final Value: 8
*/