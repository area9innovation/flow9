// fun4.orb - OGraph pattern matching in Orbit using the new primitives
import lib/array;

// Helper to find a binding in the bindings list
fn hasBinding(bindings, name) = (
    fold(bindings, false, \acc, pair -> 
        if (acc) then acc
        else pair[0] == name
    )
);

// Add a new binding to the list if not already present
fn addBinding(bindings, name, id) = (
    if (hasBinding(bindings, name)) then bindings  // Already exists
    else arrayPush(bindings, Pair(name, id))
);

// Function to match a pattern against a node with bindings
fn matchPattern(graphName, depth, nodeId, pattern, bindings) = (
	// Also, recurse and do the children independently
	let onodeChildren = getONodeChildren(graphName, nodeId);
	iter(onodeChildren, \childId -> (
		let childMatch = matchPattern(graphName, 0, childId, pattern, bindings);
	));

	pattern is (
		(e : d) => (
			let main = matchPattern(graphName, depth, nodeId, e, bindings);
		    let belongsTo = getONodeBelongsTo(graphName, nodeId);
			println("TODO: Check that domain " + prettySexpr(d) + " is in the list of domains for nodeId " + prettySexpr(belongsTo));
			main;
		);
		(e !: d) => (
			let main = matchPattern(graphName, depth, nodeId, e, bindings);
		    let belongsTo = getONodeBelongsTo(graphName, nodeId);
			println("TODO: Check that domain " + prettySexpr(d) + " is NOT in the list of domains for nodeId " + prettySexpr(belongsTo));
			main;
		);
		e => (
			let match = matchSExprNodeOneLevel(graphName, nodeId, pattern, bindings);
			if (match[0]) then (
				println(i2s(depth) + ": Matched root nodeId " + i2s(nodeId) + " with root of pattern " + prettySexpr(pattern) + " and bindings " + prettySexpr(match[1]) + " node " + extractOGraph(graphName, nodeId));

				// OK, we have to do the children against the children of the pattern
				let decomposed = decomposeSexpr(pattern);
				let patternChildren = decomposed[1];
				let onodeChildren = getONodeChildren(graphName, nodeId);
				if (length(patternChildren) == length(onodeChildren)) then (
					// We have the same number of children, let's match them
					let complete = foldi(patternChildren, match, \i, acc, childPattern -> (
						if (acc[0]) then (
							let childId = onodeChildren[i];
							// println("Matching child nodeId " + i2s(childId) + " with child of pattern " + prettySexpr(childPattern) + " and bindings " + prettySexpr(acc[1]) + " node " + extractOGraph(graphName, childId));
							let childMatch = matchPattern(graphName, depth + 1, childId, childPattern, acc[1]);
							if (childMatch[0]) then (
								// We have a match, let's add the binding
								println("TODO: Add bindings from matched child nodeId " + i2s(childId) + " with child of pattern " + prettySexpr(childPattern) + " and bindings " + prettySexpr(childMatch[1]) + " node " + extractOGraph(graphName, childId));
								[true, concat(acc[1], childMatch[1])];
							) else (
								// println("Child pattern " + prettySexpr(childPattern) + " did not match nodeId " + i2s(childId) + " with pattern " + prettySexpr(pattern) + " node " + extractOGraph(graphName, childId));
								childMatch;
							);
						) else acc
					));
					if (complete[0] && depth == 0) then (
						// We have a complete match, let's add the binding
						println("TODO: We have a complete match for nodeId " + i2s(nodeId) + " with pattern " + prettySexpr(pattern) + " and bindings " + prettySexpr(complete[1]) + " node " + extractOGraph(graphName, nodeId));
						complete
					) else (
						complete
					)
				) else (
					println("Number of children does not match for nodeId " + i2s(nodeId) + " with pattern " + prettySexpr(pattern) + " node " + extractOGraph(graphName, nodeId));
					[false, []]
				);
			) else (
				println("No match for nodeId " + i2s(nodeId) + " with pattern " + prettySexpr(pattern) + " node " + extractOGraph(graphName, nodeId));
				[false, []]
			);
		)
	);
);

// Test it with a simple example
let g = makeOGraph("test");

// Add a complex expression
let expr = '(3.141*x + 3*y);
let exprId = addOGraph(g, expr);

println("Expression added to graph:");
println(extractOGraph(g, exprId));

// Test matching
println("\nTest basic variable matching:");
let pattern1 = '(a*b);
println("Pattern: " + prettyOrbit(pattern1));
let result1 = matchPattern(g, 0, exprId, pattern1, []);
println("Match result: " + prettyOrbit(result1));

/*

println("\nTest operator pattern matching:");
let pattern2 = '(a + b);
println("Pattern: " + prettyOrbit(pattern2));
let result2 = matchPattern(g, exprId, pattern2, []);
println("Match result: " + prettyOrbit(result2));

// Add a domain to part of the expression
let term1 = addOGraph(g, quote(2*x));
let numDomain = addOGraph(g, quote(Number));
addDomainToNode(g, term1, numDomain);

// Test domain matching
println("\nTest domain matching:");
let pattern3 = quote(c : Number);
println("Pattern with domain: " + prettyOrbit(pattern3));
let result3 = matchPattern(g, term1, pattern3, []);
println("Domain match result: " + prettyOrbit(result3));

// Test negative domain matching
println("\nTest negative domain matching:");
let pattern4 = quote(c !: String);
println("Pattern with negative domain: " + prettyOrbit(pattern4));
let result4 = matchPattern(g, term1, pattern4, []);
println("Negative domain match result: " + prettyOrbit(result4));

// Compare with the native Flow implementation
println("\nComparing with native Flow implementation:");
matchOGraphPattern(g, quote(a + b), \bindings, eclass -> (
    println("Native implementation matched!");
    println("Bindings: " + prettyOrbit(bindings));
    println("at eclass: " + i2s(eclass));
));
*/