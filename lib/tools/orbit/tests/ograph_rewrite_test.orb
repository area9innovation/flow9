// Test for algebraic expression rewriting using orbitRewrite
import lib/array;

// The orbitRewrite function takes:
// - rules: a list of rewriting rules as AST expressions
// - expr: the expression to rewrite
// Returns an OGraph with one round of rewriting applied
fn orbitRewrite(rules, expr) = (
    // Create a new OGraph to work with
    let graph = makeOGraph("rewrite_graph");
    // Add the original expression to the graph
    let exprId = addOGraph(graph, expr);
    // Apply each rule to the graph
    let _ = fold(rules, 0, \(count, rule).(
        // For each rule, extract the left-hand side (pattern) and right-hand side (replacement)
        println("Rule: " + prettyOrbit(rule));
        let pattern = rule is ((x => y) => x);
        let replacement = rule is ((x => y) => y);
        println("Pattern: " + prettyOrbit(pattern));
        println("Replacement: " + prettyOrbit(replacement));
        // Match the pattern in the graph and apply transformations
        let matchCount = matchOGraphPattern(graph, pattern, \bindings.(
            // Evaluate the right-hand side with the bindings
            let result = evalWithBindings(replacement, bindings);
            
            // Add the result to the graph
            let resultId = addOGraph(graph, result);
            
            // Merge the result with the original expression's node
            let _ = mergeOGraphNodes(graph, exprId, resultId);
            
            // Could add a domain to track which rules have been applied
//            let appliedDomain = addOGraph(graph, "Applied");
  //          let _ = addDomainToNode(graph, resultId, appliedDomain),
  //          ()
        ));        
        count + matchCount
    ));
    
    // Return the graph and the expression ID
    [graph, exprId]
);

// Test with algebra rewriting

fn quote(e : ast) = e;

// Test expressions that should trigger our rules
let testExpressions = [
    quote(a + 0),            // Should simplify to a
    quote(b * 1),            // Should simplify to b
    quote(c * 0),            // Should simplify to 0
    quote(d * (e + f))       // Should expand to (d * e) + (d * f)
];

// Process each test expression
fold(testExpressions, 0, \(index, expr) . (
    println("\nTest " + (index + 1) + ":");
    println("Original: " + prettyOrbit(expr));
    
    // Apply rewriting
    let result = orbitRewrite([
		// Addition identity: x + 0 => x
		quote(x + 0 => x),
		
		// Multiplication identity: x * 1 => x
		quote(x * 1 => x),
		
		// Multiplication by zero: x * 0 => 0
		quote(x * 0 => 0),
		
		// Distributive property: x * (y + z) => (x * y) + (x * z)
		quote(x * (y + z) => (x * y) + (x * z))
	], expr);
    let graph = result[0];
    let exprId = result[1];
    
    // Extract the rewritten expression
    let rewritten = extractOGraph(graph, exprId);
    
    println("Rewritten: " + prettyOrbit(rewritten));
        
    index + 1
))