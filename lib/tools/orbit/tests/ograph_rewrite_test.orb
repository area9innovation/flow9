// Test for algebraic expression rewriting using orbitRewrite
import lib/array;

fn orbitRewriteRule(ograph, rules, i) = (
	if i < length(rules) then (
        let pattern = rules[i] is ((x => y) => quote(x));
        println("Pattern: " + prettyOrbit(pattern));
        let replacement = rules[i] is ((x => y) => quote(y));
        println("Replacement: " + prettyOrbit(replacement));
        // Match the pattern in the graph and apply transformations
        let matchCount = matchOGraphPattern(graph, pattern, \(bindings, eclassId) . (
			// Use unquote to selectively evaluate parts of the replacement
			// This allows for template metaprogramming with selective evaluation
			// We now receive the eclass ID of the matching node
            println("Found match at eclass ID: " + i2s(eclassId));

            // Process the replacement, evaluating only parts wrapped in eval()
            let result = unquote(replacement, bindings);
			println(prettyOrbit(replacement));
			println(prettyOrbit(bindings));
            
            // Add the result to the graph
            let resultId = addOGraph(graph, result);
            
            // Merge the result with the matched node's eclass
            let _ = mergeOGraphNodes(graph, eclassId, resultId);
        ));        
        count + matchCount
 ) else 0
);

// The orbitRewrite function takes:
// - rules: a list of rewriting rules as AST expressions
// - expr: the expression to rewrite
// Returns an OGraph with one round of rewriting applied
fn orbitRewrite(rules, expr) = (
    // Create a new OGraph to work with
    let graph = makeOGraph("rewrite_graph");
    // Add the original expression to the graph
    let exprId = addOGraph(graph, expr);
    // Apply each rule to the graph
    let _ = foldi(rules, 0, \(i, count, rule).(
		count + orbitRewriteRule(graph, rules, i)
    ));
    
    // Return the graph and the expression ID
    [graph, exprId]
);

// Test with algebra rewriting

fn quote(e : ast) = e;

// Test expressions that should trigger our rules
let testExpressions = [
    quote(a + 0),            // Should simplify to a
    quote(b * 1),            // Should simplify to b
    quote(c * 0),            // Should simplify to 0
    quote(d * (e + f))       // Should expand to (d * e) + (d * f)
];

// Process each test expression
fold(testExpressions, 0, \(index, expr) . (
    println("\nTest " + (index + 1) + ":");
    println("Original: " + prettyOrbit(expr));
    
    // Apply rewriting
    let result = orbitRewrite([
		// Addition identity: x + 0 => x
		quote(x + 0 => x),
		
		// Multiplication identity: x * 1 => x
		quote(x * 1 => x),
		
		// Multiplication by zero: x * 0 => 0
		quote(x * 0 => 0),
		
		// Distributive property: x * (y + z) => (x * y) + (x * z)
		quote(x * (y + z) => (x * y) + (x * z))
	], expr);
    let graph = result[0];
    let exprId = result[1];
    
    // Extract the rewritten expression
    let rewritten = extractOGraph(graph, exprId);
    
    println("Rewritten: " + prettyOrbit(rewritten));
        
    index + 1
))