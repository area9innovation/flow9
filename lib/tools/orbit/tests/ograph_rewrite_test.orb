// Test for algebraic expression rewriting using orbitRewrite
import lib/array;

// This function applies a single rewrite rule to a graph
fn orbitRewriteRule(graph, rule, count) = (
    let pattern = rule is ((x => y) => quote(x));
    println("Pattern: " + prettyOrbit(pattern));
    let replacement = rule is ((x => y) => quote(y));
    println("Replacement: " + prettyOrbit(replacement));
    
    // Match the pattern in the graph and apply transformations
    // IMPORTANT: bindings parameter must be explicitly typed as ast
    let matchCount = matchOGraphPattern(graph, pattern, \(bindings : ast, eclassId) . (
        println("Found match at eclass ID: " + i2s(eclassId));

        // Process the replacement using substituteWithBindings 
        // This performs direct variable substitution without evaluation
        let result = substituteWithBindings(replacement, bindings);
        println("After substitution: " + prettyOrbit(result));
        
        // Add the result to the graph
        let resultId = addOGraph(graph, result);
        
        // CRITICAL: Order matters when merging nodes - result first to make it canonical
        let merged = mergeOGraphNodes(graph, resultId, eclassId);
        let mergeStatus = if merged then "success" else "failed";
        println("Merge result: " + mergeStatus);
    ));
    
    println("Applied " + i2s(matchCount) + " rewrites with this rule");
    count + matchCount
);

// The orbitRewrite function takes:
// - rules: a list of rewriting rules as AST expressions
// - expr: the expression to rewrite
// Returns an OGraph with rewriting applied
fn orbitRewrite(rules, expr) = (
    // Create a new OGraph to work with
    let graph = makeOGraph("rewrite_graph");
    // Add the original expression to the graph
    let exprId = addOGraph(graph, expr);
    
    // Apply each rule to the graph
    let totalRewrites = fold(rules, 0, \(count, rule).(
        orbitRewriteRule(graph, rule, count)
    ));
    
    println("Total rewrites applied: " + i2s(totalRewrites));
    
    // Return the graph and the expression ID
    [graph, exprId]
);

// Test with algebra rewriting
fn quote(e : ast) = e;

// Test expressions that should trigger our rules
let testExpressions = [
    quote(a + 0),            // Should simplify to a
    quote(b * 1),            // Should simplify to b
    quote(c * 0),            // Should simplify to 0
    quote(d * (e + f))       // Should expand to (d * e) + (d * f)
];

// Process each test expression
fold(testExpressions, 0, \(index, expr) . (
    println("\nTest " + i2s(index + 1) + ":");
    println("Original: " + prettyOrbit(expr));
    
    // Apply rewriting
    let result = orbitRewrite([
        // Addition identity: x + 0 => x
        quote(x + 0 => x),
        
        // Multiplication identity: x * 1 => x
        quote(x * 1 => x),
        
        // Multiplication by zero: x * 0 => 0
        quote(x * 0 => 0),
        
        // Distributive property: x * (y + z) => (x * y) + (x * z)
        quote(x * (y + z) => (x * y) + (x * z))
    ], expr);
    
    let graph = result[0];
    let exprId = result[1];
    
    // Extract the rewritten expression
    let rewritten = extractOGraph(graph, exprId);
    
    println("Rewritten: " + prettyOrbit(rewritten));
        
    index + 1
))