import lib/array;
import lib/sort;

fn matchPattern(graphName, nodeId, pattern, matchFn) = (
	matchPatternRec(graphName, 0, nodeId, pattern, [], matchFn);
);

// Function to match a pattern against a node with bindings
fn matchPatternRec(graphName, depth, nodeId, pattern, bindings, matchFn) = (
	// Also, recurse and do the children independently
	let onodeChildren = getONodeChildren(graphName, nodeId);
	iter(onodeChildren, \childId -> (
		let childMatch = matchPatternRec(graphName, 0, childId, pattern, bindings);
	));

	pattern is (
		(e : d) => (
			let main = matchPatternRec(graphName, depth, nodeId, e, bindings);
		    let belongsTo = getONodeBelongsTo(graphName, nodeId);
			println("TODO: Check that domain " + prettySexpr(d) + " is in the list of domains for nodeId " + prettySexpr(belongsTo));
			main;
		);
		(e !: d) => (
			let main = matchPatternRec(graphName, depth, nodeId, e, bindings);
		    let belongsTo = getONodeBelongsTo(graphName, nodeId);
			println("TODO: Check that domain " + prettySexpr(d) + " is NOT in the list of domains for nodeId " + prettySexpr(belongsTo));
			main;
		);
		e => (
			let match = matchSExprNodeOneLevel(graphName, nodeId, pattern, bindings);
			if (match[0]) then (
				// println(i2s(depth) + ": Matched root nodeId " + i2s(nodeId) + " with root of pattern " + prettySexpr(pattern) + " and bindings " + prettySexpr(match[1]) + " node " + extractOGraph(graphName, nodeId));

				// OK, we have to do the children against the children of the pattern
				let decomposed = decomposeSexpr(pattern);
				let patternChildren = decomposed[1];
				let onodeChildren = getONodeChildren(graphName, nodeId);
				if (length(patternChildren) == length(onodeChildren)) then (
					// We have the same number of children, let's match them
					let complete = foldi(patternChildren, match, \i, acc, childPattern -> (
						if (acc[0]) then (
							let childId = onodeChildren[i];
							// println("Matching child nodeId " + i2s(childId) + " with child of pattern " + prettySexpr(childPattern) + " and bindings " + prettySexpr(acc[1]) + " node " + extractOGraph(graphName, childId));
							let childMatch = matchPatternRec(graphName, depth + 1, childId, childPattern, acc[1]);
							if (childMatch[0]) then (
								// We have a match, let's add the bindings together
								[true, mergeUnique(acc[1], childMatch[1], genericCompare)];
							) else (
								// println("Child pattern " + prettySexpr(childPattern) + " did not match nodeId " + i2s(childId) + " with pattern " + prettySexpr(pattern) + " node " + extractOGraph(graphName, childId));
								childMatch;
							);
						) else acc
					));
					if (complete[0] && depth == 0) then (
						matchFn(nodeId, complete[1]);
						complete
					) else (
						complete
					)
				) else (
					// println("Number of children does not match for nodeId " + i2s(nodeId) + " with pattern " + prettySexpr(pattern) + " node " + extractOGraph(graphName, nodeId));
					[false, []]
				);
			) else (
				// println("No match for nodeId " + i2s(nodeId) + " with pattern " + prettySexpr(pattern) + " node " + extractOGraph(graphName, nodeId));
				[false, []]
			);
		)
	);
);
"Match library loaded"