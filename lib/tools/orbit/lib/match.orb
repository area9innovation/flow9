import lib/array;
import lib/sort;

// Gives [bool, bindings] if we match at the top
fn matchPatternTop(graphName, nodeId, pattern, matchFn) = (
	matchPatternRec(graphName, 0, nodeId, pattern, [], matchFn);
);

// Matches all the way down - returns the number of matches
fn matchPattern(graphName, nodeId, pattern, matchFn) = (
	// Also, recurse and do the children independently
	let onodeChildren = getONodeChildren(graphName, nodeId);
	let count = fold(onodeChildren, 0, \acc, childId -> (
		let childMatches = matchPattern(graphName, childId, pattern, matchFn);
		acc + childMatches
	));

	// println("Matching deep pattern " + prettySexpr(pattern) + " against nodeId " + i2s(nodeId));
	let res = matchPatternRec(graphName, 0, nodeId, pattern, [], matchFn);
	count + if res[0] then 1 else 0 
);

// Function to match a pattern against a node with bindings. Returns [bool, bindings]
fn matchPatternRec(graphName, depth, nodeId, pattern, bindings, matchFn) = (
	pattern is (
		(e : d) => (
			let belongsTo = getONodeBelongsTo(graphName, nodeId);
			
			// Use fold to check all domains and accumulate bindings from matches
			let matchResult = fold(belongsTo, [false, []], \acc, dom -> (
				// If we already found a match, just return it
				if (acc[0]) then acc else (
					// Try to match the domain pattern against this domain
					let domainMatch = matchPatternTop(graphName, dom, d, \x, y -> 0);
					if (domainMatch[0]) then (
						// We found a match, return true and the bindings from this match
						[true, domainMatch[1]]
					) else acc
				)
			));
			
			if (matchResult[0]) then (
				// We found a matching domain, merge its bindings with our existing ones
				let combinedBindings = mergeUnique(bindings, matchResult[1], genericCompare);
				
				// Continue matching the expression with the combined bindings
				matchPatternRec(graphName, depth, nodeId, e, combinedBindings, matchFn);
			) else (
				// No matching domain found
				[false, []]
			)
		);
		(e !: d) => (
		    let belongsTo = getONodeBelongsTo(graphName, nodeId);
			if (exists(belongsTo, \dom -> (
				matchPatternTop(graphName, dom, d, \x, y -> 0)[0]
			))) then (
				[false, []]
			) else (
				matchPatternRec(graphName, depth, nodeId, e, bindings);
			)
		);
		(e : d1 â‹¯ d2) => (
			println("TODO: Implement lower");
			matchPatternRec(graphName, depth, nodeId, e, bindings);
		);
		e => (
			let match = matchSExprNodeOneLevel(graphName, nodeId, pattern, bindings);
			if (match[0]) then (
				// println(i2s(depth) + ": Matched root nodeId " + i2s(nodeId) + " with root of pattern " + prettySexpr(pattern) + " and bindings " + prettySexpr(match[1]) + " node " + extractOGraph(graphName, nodeId));

				// OK, we have to do the children against the children of the pattern
				let decomposed = decomposeSexpr(pattern);
				let patternChildren = decomposed[1];
				let onodeChildren = getONodeChildren(graphName, nodeId);
				if (length(patternChildren) == length(onodeChildren)) then (
					// We have the same number of children, let's match them
					let complete = foldi(patternChildren, match, \i, acc, childPattern -> (
						if (acc[0]) then (
							let childId = onodeChildren[i];
							// println("Matching child nodeId " + i2s(childId) + " with child of pattern " + prettySexpr(childPattern) + " and bindings " + prettySexpr(acc[1]) + " node " + extractOGraph(graphName, childId));
							let childMatch = matchPatternRec(graphName, depth + 1, childId, childPattern, acc[1]);
							if (childMatch[0]) then (
								// We have a match, let's add the bindings together
								[true, mergeUnique(acc[1], childMatch[1], genericCompare)];
							) else (
								// println("Child pattern " + prettySexpr(childPattern) + " did not match nodeId " + i2s(childId) + " with pattern " + prettySexpr(pattern) + " node " + extractOGraph(graphName, childId));
								childMatch;
							);
						) else acc
					));
					if (complete[0] && depth == 0) then (
						matchFn(nodeId, complete[1]);
						complete
					) else (
						complete
					)
				) else (
					// println("Number of children does not match for nodeId " + i2s(nodeId) + " with pattern " + prettySexpr(pattern) + " node " + extractOGraph(graphName, nodeId));
					[false, []]
				);
			) else (
				// println("No match for nodeId " + i2s(nodeId) + " with pattern " + prettySexpr(pattern) + " node " + extractOGraph(graphName, nodeId));
				[false, []]
			);
		)
	);
);

"Match library loaded"