import lib/rewrite;
import lib/array;
import lib/reflect;
import lib/sort;
import lib/ast_utils;

/**
 * Canonical Logic Forms: CNF and DNF implementation using gather/scatter
 * 
 * This library demonstrates how to implement Conjunctive Normal Form (CNF)
 * and Disjunctive Normal Form (DNF) in Orbit using gather/scatter operations
 * and rewrite rules to apply group theory concepts.
 */

// ----- REWRITE RULES -----

// Convert an expression to normal form by applying rewrite rules
fn to_normal_form(expr, is_cnf) = (
    // Define the basic logical rules
    let basic_rules = [
        // Double negation elimination
        ["double_negation", quote(!!a), quote(a), true],
        
        // De Morgan's laws
        ["de_morgan_and", quote(!(a && b)), quote(!a || !b), true],
        ["de_morgan_or", quote(!(a || b)), quote(!a && !b), true],
        
        // Contradiction and identity laws
        ["contradiction", quote(a && !a), quote(false), true],
        ["or_with_contradiction", quote(false || a), quote(a), true],
        ["or_with_contradiction2", quote(a || false), quote(a), true],
        ["and_with_identity", quote(true && a), quote(a), true],
        ["and_with_identity2", quote(a && true), quote(a), true],
        
        // Contradiction propagation
        ["contradiction_propagation", quote(a && false), quote(false), true],
        ["contradiction_propagation2", quote(false && a), quote(false), true],
        
        // Idempotent laws
        ["and_idempotent", quote(a && a), quote(a), true],
        ["or_idempotent", quote(a || a), quote(a), true],
        
        // Absorption laws
        ["absorption", quote(a || (a && b)), quote(a), true],
        ["absorption2", quote((a && b) || a), quote(a), true],
    ];
    
    // Choose the appropriate distributivity rules based on the target form
    let dist_rules = if is_cnf then [
        // For CNF: distribute OR over AND
        ["dist_or_over_and", quote(a || (b && c)), quote((a || b) && (a || c)), true],
        ["dist_or_over_and2", quote((a && b) || c), quote((a || c) && (b || c)), true]
    ] else [
        // For DNF: distribute AND over OR
        ["dist_and_over_or", quote(a && (b || c)), quote((a && b) || (a && c)), true],
        ["dist_and_over_or2", quote((a || b) && c), quote((a && c) || (b && c)), true]
    ];
    
    // Apply the rewrite rules until we reach a fixed point
    applyRulesUntilFixedPoint(expr, basic_rules + dist_rules, 100)
);

// ----- GATHER/SCATTER APPROACH -----

// Apply gather/scatter operations to normalize and canonicalize expression
fn apply_canonical_form(expr, is_cnf) = (
    // First, apply the normal form rewriting rules
    let normalized = to_normal_form(expr, is_cnf);
	// println("Normalized: " + prettyOrbit(normalized));
    if is_cnf then (
        // For CNF: AND of ORs - process both levels with gather/sort/scatter
        
        // Process the top-level AND expression
        let gathered = gather(normalized, `&&`);
        gathered is (
            `&&`(clauses_array) => (
                // Process each clause (OR of literals) - normalize inner clauses first
                let processed_clauses = map(clauses_array, \clause -> (
                    // Gather OR terms for this clause
                    let clause_gathered = gather(clause, `||`);
                    clause_gathered is (
                        `||`(literals) => (
                            // Sort and remove duplicates
                            let sorted_unique = uniq(sort(literals));
                            // Recreate the clause with sorted, unique literals
                            makeFoldedAst("||", sorted_unique)
                        );
                        _ => clause  // Not an OR expression
                    )
                ));
                
                // Now sort and remove duplicate clauses
                let sorted_unique_clauses = uniq(sort(processed_clauses));
                
                // Reconstruct the CNF expression
                makeFoldedAst("&&", sorted_unique_clauses)
            );
            _ => normalized  // Not an AND expression
        )
    ) else (
        // For DNF: OR of ANDs - process both levels with gather/sort/scatter
        
        // Process the top-level OR expression
        let gathered = gather(normalized, `||`);
        gathered is (
            `||`(terms_array) => (
                // Process each term (AND of literals) - normalize inner terms first
                let processed_terms = map(terms_array, \term -> (
                    // Gather AND literals for this term
                    let term_gathered = gather(term, `&&`);
                    
                    term_gathered is (
                        `&&`(literals) => (
                            // Sort and remove duplicates
                            let sorted_unique = uniq(sort(literals));
                            
                            // Recreate the term with sorted, unique literals
                            makeFoldedAst("&&", sorted_unique)
                        );
                        _ => term  // Not an AND expression
                    )
                ));
                // Now sort and remove duplicate terms
                let sorted_unique_terms = uniq(sort(processed_terms));
                
                // Reconstruct the DNF expression
                makeFoldedAst("||", sorted_unique_terms)
            );
            _ => normalized  // Not an OR expression
        )
    )
);

// ----- PUBLIC API -----

// Convert an expression to Conjunctive Normal Form (CNF)
fn to_cnf(expr) = (
    // Then, canonicalize the expression using gather/scatter
    apply_canonical_form(expr, true)
);

// Convert an expression to Disjunctive Normal Form (DNF)
fn to_dnf(expr) = (
    // Then, canonicalize the expression using gather/scatter
    apply_canonical_form(expr, false)
);
