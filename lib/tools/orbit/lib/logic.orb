import lib/rewrite;
import lib/array;
import lib/reflect;
import lib/sort;
import lib/ast_utils;

/**
 * Canonical Logic Forms: CNF and DNF implementation using gather/scatter
 * 
 * This library demonstrates how to implement Conjunctive Normal Form (CNF)
 * and Disjunctive Normal Form (DNF) in Orbit using gather/scatter operations
 * and rewrite rules to apply group theory concepts.
 */

// ----- REWRITE RULES -----

// Convert an expression to normal form by applying rewrite rules
fn to_normal_form(expr, is_cnf) = (
    // Define the basic logical rules
    let basic_rules = [
        // Double negation elimination
        ["double_negation", quote(!!a), quote(a), true],
        
        // De Morgan's laws
        ["de_morgan_and", quote(!(a && b)), quote(!a || !b), true],
        ["de_morgan_or", quote(!(a || b)), quote(!a && !b), true],
        
        // Contradiction and tautology laws
        ["contradiction", quote(a && !a), quote(false), true],
        ["tautology", quote(a || !a), quote(true), true],
        
        // Identity laws - with false
        ["or_with_false", quote(false || a), quote(a), true],
        ["or_with_false2", quote(a || false), quote(a), true],
        ["and_with_false", quote(a && false), quote(false), true],
        ["and_with_false2", quote(false && a), quote(false), true],
        
        // Identity laws - with true
        ["and_with_true", quote(true && a), quote(a), true],
        ["and_with_true2", quote(a && true), quote(a), true],
        ["or_with_true", quote(true || a), quote(true), true],
        ["or_with_true2", quote(a || true), quote(true), true],
        
        // Idempotent laws
        ["and_idempotent", quote(a && a), quote(a), true],
        ["or_idempotent", quote(a || a), quote(a), true],
        
        // Absorption laws - all variants
        ["absorption1", quote(a || (a && b)), quote(a), true],
        ["absorption2", quote((a && b) || a), quote(a), true],
        ["absorption3", quote(a && (a || b)), quote(a), true],
        ["absorption4", quote((a || b) && a), quote(a), true],
        
        // Exclusive-or simplification patterns
        ["exclusive_or_simplify", quote((a || b) && (!a || b)), quote(b), true],
        ["exclusive_or_simplify2", quote((a || b) && (a || !b)), quote(a), true],
        ["exclusive_or_simplify3", quote((b || a) && (!a || b)), quote(b), true],
        ["exclusive_or_simplify4", quote((b || a) && (a || !b)), quote(a), true],
        
        // Advanced simplification patterns
        ["advanced_simplify1", quote((a || b) && (a || !b) && (a || c)), quote(a || c), true],
        ["advanced_simplify2", quote((a && b) || (!a && b)), quote(b), true],
        ["advanced_simplify3", quote((a && b) || (a && !b)), quote(a), true],
        ["advanced_simplify4", quote((a || b) && (a || c) && (!a || d)), quote((a && c) || (b && c && d)), true],
    ];
    
    // Choose the appropriate distributivity rules based on the target form
    let dist_rules = if is_cnf then [
        // Special case for CNF: (a ∧ b) ∨ (¬a ∧ c) pattern
        // This rule must come FIRST to handle the pattern before distribution
        ["special_cnf_case", quote((a && b) || (!a && c)), quote((a || !a) && (a || c) && (b || !a) && (b || c)), true],
        
        // Handle CNF tautology elimination (after special_cnf_case produces these)
        ["cnf_tautology_elimination", quote((a || !a) && expr), quote(expr), true],
        ["cnf_tautology_elimination2", quote(expr && (a || !a)), quote(expr), true],
        
        // Handle partially simplified CNF patterns
        ["partial_cnf_simplify", quote((a || b) && (a || !b) && (a || c)), quote(a || c), true],
        ["partial_cnf_simplify2", quote((a || b) && (!a || c) && (!a || d)), quote((!a || (c && d)) && (b || c) && (b || d)), true],
        
        // Standard CNF distribution rules - these should come AFTER the special cases
        ["dist_or_over_and", quote(a || (b && c)), quote((a || b) && (a || c)), true],
        ["dist_or_over_and2", quote((a && b) || c), quote((a || c) && (b || c)), true]
    ] else [
        // Special case for DNF: (a ∨ b) ∧ (¬a ∨ c) pattern
        // This rule must come FIRST to handle the pattern before distribution
        ["special_dnf_case", quote((a || b) && (!a || c)), quote((a && c) || (!a && b)), true],
        
        // Handle the same pattern if it's already partially distributed
        ["partial_dnf_simplify", quote((a && c) || (b && c) || (b && !a)), quote((a && c) || (!a && b)), true],
        ["partial_dnf_simplify2", quote((a && c) || (b && !a)), quote((a && c) || (b && !a)), true],
        
        // More advanced DNF simplification patterns
        ["advanced_dnf_simplify", quote(((a && b) || (a && c)) || (a && d)), quote(a && (b || c || d)), true],
        ["advanced_dnf_simplify2", quote((a && b) || (a && !b) || (c && d)), quote(a || (c && d)), true],
        
        // Standard DNF distribution rules - these should come AFTER the special cases
        ["dist_and_over_or", quote(a && (b || c)), quote((a && b) || (a && c)), true],
        ["dist_and_over_or2", quote((a || b) && c), quote((a && c) || (b && c)), true]
    ];
    
    // Apply the rewrite rules until we reach a fixed point
    applyRulesUntilFixedPoint(expr, basic_rules + dist_rules, 100)
);

// ----- GATHER/SCATTER APPROACH -----

// Apply gather/scatter operations to normalize and canonicalize expression
fn apply_canonical_form(expr, is_cnf) = (
    // First, apply the normal form rewriting rules
    let normalized = to_normal_form(expr, is_cnf);
	// println("Normalized: " + prettyOrbit(normalized));
    if is_cnf then (
        // For CNF: AND of ORs - process both levels with gather/sort/scatter
        
        // Process the top-level AND expression
        let gathered = gather(normalized, `&&`);
        gathered is (
            `&&`(clauses_array) => (
                // Process each clause (OR of literals) - normalize inner clauses first
                let processed_clauses = map(clauses_array, \clause -> (
                    // Gather OR terms for this clause
                    let clause_gathered = gather(clause, `||`);
                    clause_gathered is (
                        `||`(literals) => (
                            // Sort and remove duplicates
                            let sorted_unique = uniq(sort(literals));
                            // Recreate the clause with sorted, unique literals
                            makeFoldedAst("||", sorted_unique)
                        );
                        _ => clause  // Not an OR expression
                    )
                ));
                
                // Now sort and remove duplicate clauses
                let sorted_unique_clauses = uniq(sort(processed_clauses));
                
                // Reconstruct the CNF expression
                makeFoldedAst("&&", sorted_unique_clauses)
            );
            _ => normalized  // Not an AND expression
        )
    ) else (
        // For DNF: OR of ANDs - process both levels with gather/sort/scatter
        
        // Process the top-level OR expression
        let gathered = gather(normalized, `||`);
        gathered is (
            `||`(terms_array) => (
                // Process each term (AND of literals) - normalize inner terms first
                let processed_terms = map(terms_array, \term -> (
                    // Gather AND literals for this term
                    let term_gathered = gather(term, `&&`);
                    
                    term_gathered is (
                        `&&`(literals) => (
                            // Sort and remove duplicates
                            let sorted_unique = uniq(sort(literals));
                            
                            // Recreate the term with sorted, unique literals
                            makeFoldedAst("&&", sorted_unique)
                        );
                        _ => term  // Not an AND expression
                    )
                ));
                // Now sort and remove duplicate terms
                let sorted_unique_terms = uniq(sort(processed_terms));
                
                // Reconstruct the DNF expression
                makeFoldedAst("||", sorted_unique_terms)
            );
            _ => normalized  // Not an OR expression
        )
    )
);

// ----- PUBLIC API -----

// Convert an expression to Conjunctive Normal Form (CNF)
fn to_cnf(expr) = (
    // Then, canonicalize the expression using gather/scatter
    apply_canonical_form(expr, true)
);

// Convert an expression to Disjunctive Normal Form (DNF)
fn to_dnf(expr) = (
    // Then, canonicalize the expression using gather/scatter
    apply_canonical_form(expr, false)
);
