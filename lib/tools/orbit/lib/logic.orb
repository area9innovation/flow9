import lib/rewrite;
import lib/array;

/**
 * Canonical Logic Forms: CNF and DNF implementation using gather/scatter
 * 
 * This library demonstrates how to implement Conjunctive Normal Form (CNF)
 * and Disjunctive Normal Form (DNF) in Orbit using gather/scatter operations
 * and rewrite rules to apply group theory concepts.
 */

// ----- REWRITE RULES -----

// Convert an expression to normal form by applying rewrite rules
fn to_normal_form(expr, is_cnf) = (
    // Define the basic logical rules
    let basic_rules = [
        // Double negation elimination
        ["double_negation", quote(!!a), quote(a), true],
        
        // De Morgan's laws
        ["de_morgan_and", quote(!(a && b)), quote(!a || !b), true],
        ["de_morgan_or", quote(!(a || b)), quote(!a && !b), true],
        
        // Associativity of AND and OR
        ["assoc_and", quote((a && b) && c), quote(a && (b && c)), true],
        ["assoc_or", quote((a || b) || c), quote(a || (b || c)), true],
    ];
    
    // Choose the appropriate distributivity rules based on the target form
    let dist_rules = if is_cnf then [
        // For CNF: distribute OR over AND
        ["dist_or_over_and", quote(a || (b && c)), quote((a || b) && (a || c)), true],
        ["dist_or_over_and2", quote((a && b) || c), quote((a || c) && (b || c)), true]
    ] else [
        // For DNF: distribute AND over OR
        ["dist_and_over_or", quote(a && (b || c)), quote((a && b) || (a && c)), true],
        ["dist_and_over_or2", quote((a || b) && c), quote((a && c) || (b && c)), true]
    ];
    
    // Apply the rewrite rules until we reach a fixed point
    applyRulesUntilFixedPoint(expr, basic_rules + dist_rules, 100)
);

// ----- GATHER/SCATTER APPROACH -----

// Apply gather/scatter operations to normalize and canonicalize expression
fn apply_canonical_form(expr, is_cnf) = (
    if is_cnf then (
        // For CNF, gather AND at the top level
        let and_template = quote(a && b);
        let gathered = gather(expr, and_template);
        
        // Process the gathered structure
        gathered is (
            [clauses] => (
                // Gather OR within each clause
                let or_template = quote(a || b);
                
                // Now process the clauses
                // In a complete implementation, we would also apply S₂ symmetry here
                // by sorting literals in each clause
                
                // For now, just scatter to rebuild the expression
                expr
            );
            _ => expr
        )
    ) else (
        // For DNF, gather OR at the top level
        let or_template = quote(a || b);
        let gathered = gather(expr, or_template);
        
        // Process the gathered structure
        gathered is (
            [terms] => (
                // Gather AND within each term
                let and_template = quote(a && b);
                
                // Now process the terms
                // In a complete implementation, we would also apply S₂ symmetry here
                // by sorting literals in each term
                
                // For now, just scatter to rebuild the expression
                expr
            );
            _ => expr
        )
    )
);

// ----- PUBLIC API -----

// Convert an expression to Conjunctive Normal Form (CNF)
fn to_cnf(expr) = (
    // First, apply rewrite rules to normalize the expression
    let normalized = to_normal_form(expr, true);
    
    // Then, canonicalize the expression using gather/scatter
    apply_canonical_form(normalized, true)
);

// Convert an expression to Disjunctive Normal Form (DNF)
fn to_dnf(expr) = (
    // First, apply rewrite rules to normalize the expression
    let normalized = to_normal_form(expr, false);
    
    // Then, canonicalize the expression using gather/scatter
    apply_canonical_form(normalized, false)
);
