import lib/tree;
import lib/array;

// Graph data structure for Orbit system
// Uses Tree to store nodes and edges efficiently

// Graph(nodes: Tree<Node, int>, edges: Tree<Node, [Edge]>, nodeCount: int)
// Edge(from: Node, to: Node, data: ?)

// Create a new empty graph
fn makeGraph() = (
    Graph(makeTree(), makeTree(), 0)
);

// Check if a node exists in the graph
fn hasNode(graph, node) = (
    graph is (
        Graph(nodes, _, _) => (
            lookup(nodes, node) is (
                Some(_) => true;
                None() => false
            )
        )
    )
);

// Add a node to the graph if it doesn't already exist
fn addNode(graph, node) = (
    graph is (
        Graph(nodes, edges, count) => (
            if (hasNode(graph, node)) then (
                // Node already exists, return graph unchanged
                graph
            ) else (
                // Add new node with next available ID
                let newNodes = insertTree(nodes, node, count);
                Graph(newNodes, edges, count + 1)
            )
        )
    )
);

// Get the ID of a node in the graph
fn getNodeId(graph, node) = (
    graph is (
        Graph(nodes, _, _) => (
            lookup(nodes, node) is (
                Some(id) => id;
                None() => -1  // Return -1 if node doesn't exist
            )
        )
    )
);

// Check if an edge exists between two nodes
fn hasEdge(graph, from, to) = (
    if (hasNode(graph, from) && hasNode(graph, to)) then (
        graph is (
            Graph(_, edges, _) => (
                lookup(edges, from) is (
                    Some(edgeList) => (
                        // Check if any edge in the list has 'to' as destination
                        let matchingEdges = filter(edgeList, \edge -> edge is (
                            Edge(_, toNode, _) => toNode == to
                        ));
                        length(matchingEdges) > 0
                    );
                    None() => false
                )
            )
        )
    ) else (
        false
    )
);

// Add an edge between two nodes
fn addEdge(graph, from, to, data) = (
    // Ensure both nodes exist in the graph
    let graphWithNodes = addNode(addNode(graph, from), to);
    
    // If edge already exists, return graph unchanged
    if (hasEdge(graphWithNodes, from, to)) then (
        graphWithNodes
    ) else (
        graphWithNodes is (
            Graph(nodes, edges, count) => (
                // Get existing edges for 'from' node or empty list
                let existingEdges = lookup(edges, from) is (
                    Some(edgeList) => edgeList;
                    None() => []
                );
                
                // Add new edge to list
                let newEdgeList = arrayPush(existingEdges, Edge(from, to, data));
                
                // Update edges tree
                let newEdges = insertTree(edges, from, newEdgeList);
                
                Graph(nodes, newEdges, count)
            )
        )
    )
);

// Get all adjacent nodes (neighbors) of a given node
fn getNeighbors(graph, node) = (
    if (hasNode(graph, node)) then (
        graph is (
            Graph(_, edges, _) => (
                lookup(edges, node) is (
                    Some(edgeList) => map(edgeList, \edge -> edge is (Edge(_, to, _) => to));
                    None() => []
                )
            )
        )
    ) else (
        []
    )
);

// Get all edges from a specific node
fn getEdgesFrom(graph, node) = (
    if (hasNode(graph, node)) then (
        graph is (
            Graph(_, edges, _) => (
                lookup(edges, node) is (
                    Some(edgeList) => edgeList;
                    None() => []
                )
            )
        )
    ) else (
        []
    )
);

// Helper function to collect all edges from the graph
fn collectAllEdges(graph) = (
    graph is (
        Graph(nodes, edges, _) => (
            let nodeEntries = getEntries(nodes);
            fold(nodeEntries, [], \acc, entry -> (
                entry is (
                    Pair(node, _) => (
                        let nodeEdges = getEdgesFrom(graph, node);
                        acc + nodeEdges
                    )
                )
            ))
        )
    )
);

// Get all edges in the graph
fn getAllEdges(graph) = (
    collectAllEdges(graph)
);

// Get all nodes in the graph
fn getAllNodes(graph) = (
    graph is (
        Graph(nodes, _, _) => getKeys(nodes)
    )
);

// Remove an edge from the graph
fn removeEdge(graph, from, to) = (
    if (hasEdge(graph, from, to)) then (
        graph is (
            Graph(nodes, edges, count) => (
                lookup(edges, from) is (
                    Some(edgeList) => (
                        // Filter out the edge to be removed
                        let newEdgeList = filter(edgeList, \edge -> edge is (
                            Edge(_, toNode, _) => toNode != to
                        ));
                        
                        // Update edges tree
                        let newEdges = insertTree(edges, from, newEdgeList);
                        
                        Graph(nodes, newEdges, count)
                    );
                    None() => graph  // Should not happen if hasEdge is true
                )
            )
        )
    ) else (
        graph
    )
);

// Get the number of nodes in the graph
fn nodeCount(graph) = (
    graph is (
        Graph(_, _, count) => count
    )
);

// Get the number of edges in the graph
fn edgeCount(graph) = (
    length(getAllEdges(graph))
);

// Check if the graph is empty (has no nodes)
fn isEmpty(graph) = (
    nodeCount(graph) == 0
);

// Create a string representation of the graph for debugging
fn graphToString(graph) = (
    let nodes = getAllNodes(graph);
    let edges = getAllEdges(graph);
    
    let nodesStr = fold(nodes, "", \acc, node -> acc + prettyOrbit(node) + " ");
    let edgesStr = fold(edges, "", \acc, edge -> (
        edge is (
            Edge(from, to, data) => (
                acc + "(" + prettyOrbit(from) + " -> " + prettyOrbit(to) + ": " + prettyOrbit(data) + ") "
            )
        )
    ));
    
    "Graph(Nodes: [" + nodesStr + "], Edges: [" + edgesStr + "])"
);