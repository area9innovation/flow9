// Domain-aware rewriting library for OGraph manipulation
// This library provides functions for pattern matching, rewriting, and
// domain annotation handling with the correct sequence of operations.
fn quote(e : ast) = e;

//
// REFLECTION FUNCTIONS
//

// Extract the value from a number node
fn extract_number(expr : ast) = (
    expr is (
        Int(n) => n; 
        Double(n) => n;
        _ => 0 // Default if not a number
    )
);

// Extract the name from a variable node
fn extract_var_name(expr : ast) = (
    expr is (
        Variable(name) => name;
        Identifier(name) => name;
        _ => "" // Default if not a variable
    )
);

// Calculate the degree of a term in a polynomial
fn term_degree(term : ast) = (
    if is_number(term) then 0
    else if is_var(term) then 1
    else term is (
        a * b => term_degree(a) + term_degree(b);
        a ^ b => b is (
            Int(n) => term_degree(a) * n;
            _ => term_degree(a) // Default to simple case if exponent is not an integer
        );
        _ => 0 // Default for other cases
    )
);

// Get variables in a term (as a sorted array of variable names)
fn term_variables(term : ast) = (
    if is_number(term) then []
    else if is_var(term) then [extract_var_name(term)]
    else term is (
        a * b => term_variables(a) + term_variables(b);
        a ^ _ => term_variables(a);
        _ => [] // Default for other cases
    )
);

// Count occurrences of a variable in a term
fn var_count(term : ast, var_name : string) = (
    if is_number(term) then 0
    else if is_var(term) then (
        let name = extract_var_name(term);
        if name == var_name then 1 else 0
    ) else term is (
        a * b => var_count(a, var_name) + var_count(b, var_name);
        a ^ b => b is (
            Int(n) => var_count(a, var_name) * n;
            _ => var_count(a, var_name) // Default case
        );
        _ => 0 // Default for other cases
    )
);

// Compare polynomial terms using graded lexicographic ordering
// Returns -1 if a < b, 0 if a = b, 1 if a > b
fn compare_terms(a : ast, b : ast) = (
    // First compare by total degree (in reverse order - higher degree first)
    let deg_a = term_degree(a);
    let deg_b = term_degree(b);
    
    if deg_a > deg_b then 1
    else if deg_a < deg_b then -1
    else (
        // Same degree, compare lexicographically by variables
        // Get all unique variables from both terms
        let all_vars = sort(term_variables(a) + term_variables(b));
        
        // Helper function to compare variable by variable
        fn compare_by_vars(vars, index) = (
            if index >= length(vars) then 0 // Equal if we've checked all variables
            else (
                let var = vars[index];
                let count_a = var_count(a, var);
                let count_b = var_count(b, var);
                
                if count_a > count_b then 1
                else if count_a < count_b then -1
                else compare_by_vars(vars, index + 1) // Same count, check next variable
            )
        );
        
        compare_by_vars(all_vars, 0)
    )
);

// Graded lexicographic comparison function for polynomial expressions
// Can be used with sort function to order polynomial terms
fn glex_compare(a, b) = (
    compare_terms(a, b) <= 0
);

//
// CORE REWRITING FUNCTIONS
//

// Apply a single rewrite pattern and replacement to a graph,
// correctly handling domain annotations and conditions
fn applyRewriteRule(graph, pattern, replacement, condition, ruleName) = (
//    println("\nApplying rule: " + ruleName);
//    println("Pattern: " + prettyOrbit(pattern));
//    println("Replacement: " + prettyOrbit(replacement));
//    println("Condition: " + prettyOrbit(condition));
    
    // Apply the pattern match
    let matches = matchOGraphPattern(graph, pattern, \(bindings : ast, eclassId) . (
        //println("Match found at ID: " + i2s(eclassId));
        //println("Bindings: " + prettyOrbit(bindings));
        // THE CORRECT SEQUENCE FOR DOMAIN-AWARE REWRITING:
        
        // Step 1: Check if the condition is satisfied
        let shouldApplyRule = if (condition) then (
            // Optimize for the common case of condition=true
            true
        ) else (
            // Substitute bindings into the condition in the graph
            let condId = addOGraphWithSub(graph, condition, bindings);
            
            // Extract for evaluation
            let condExpr = extractOGraph(graph, condId);
            // println("Condition instantiated to: " + prettyOrbit(condExpr));

            // Evaluate the condition
            let condResult = eval(condExpr);
            // println("Condition evaluated to: " + prettyOrbit(condResult));
            
            condResult
        );
        
        if (shouldApplyRule) then (
            // Step 2: Apply the replacement (only if condition is true)
            // Modern approach using direct eclass ID substitution
            // This is more efficient and works directly with eclass IDs
            let newId = addOGraphWithSub(graph, replacement, bindings);
            println("1. After adding with direct substitution, ID: " + i2s(newId) + ": " + prettyOrbit(extractOGraph(graph, newId)));
            
            // Step 3: Merge nodes (result first to make it canonical)
            mergeOGraphNodes(graph, newId, eclassId);
        ) else (
            // println("Condition not satisfied, rule not applied");
			0
        );

		// TODO: Should we not unquote as well?
    ));
    
//    println("Applied " + i2s(matches) + " matches");
    matches
);

// Apply a list of rewrite rules to an expression
// Rules are quadruples: [name, pattern, replacement, condition]
fn applyRules(expr, rules) = (
    // Create a new graph 
    let graph = makeOGraph("transform");
    
    // Add the expression
    let exprId = addOGraph(graph, expr);
    
    // Helper function to apply rules recursively 
    fn applyRulesRecursive(rules, index, totalMatches) = (
        if index < length(rules) then (
            let rule = rules[index];
            let ruleName = rule[0];
            let pattern = rule[1];
            let replacement = rule[2];
            let condition = if (length(rule) >= 4) then rule[3] else true;
            
            // Apply the rule with condition
            let matches = applyRewriteRule(graph, pattern, replacement, condition, ruleName);
            
            // Apply the next rule
            applyRulesRecursive(rules, index + 1, totalMatches + matches)
        ) else (
            // Return total matches when done
            totalMatches
        )
    );
    
    // Apply all rules
    let totalMatches = applyRulesRecursive(rules, 0, 0);
    // Return the final transformed expression
    extractOGraph(graph, exprId);
);

//
// HELPER FUNCTIONS
//

// Prepares a rule with proper domain handling
// Returns a quadruple of [name, pattern, replacement, condition]
fn prepareRule(name, patternExpr : ast, replacementExpr : ast, conditionExpr : ast) = (
	[name, patternExpr, replacementExpr, conditionExpr]
);

// Convenience function for rules without conditions
fn prepareSimpleRule(name, patternExpr, replacementExpr) = (
    prepareRule(name, patternExpr, replacementExpr, true)
);

// Apply a single rule to an expression
fn applyRule(expr, name, pattern, replacement, condition) = (
    applyRules(expr, [[name, pattern, replacement, condition]])
);

// Apply rules until saturation (fixed point)
fn applyRulesUntilFixedPoint(expr, rules, maxIterations) = (
    // Create a graph with the initial expression
    let graph = makeOGraph("fixed_point");
    let exprId = addOGraph(graph, expr);
    
    // Function to apply all rules once and count matches
    fn applyAllRules(id, rules) = (
        fn applyHelper(index, totalMatches) = (
            if index < length(rules) then (
                let rule = rules[index];
                let ruleName = rule[0];
                let pattern = rule[1];
                let replacement = rule[2];
                let condition = if (length(rule) >= 4) then rule[3] else true;
                
                let matches = applyRewriteRule(graph, pattern, replacement, condition, ruleName);
                applyHelper(index + 1, totalMatches + matches)
            ) else totalMatches
        );
        
        applyHelper(0, 0)
    );
    
    // Iterate until fixed point or max iterations
    fn iterate(iteration, prevMatches) = (
        if iteration >= maxIterations then (
            println("Reached max iterations (" + i2s(maxIterations) + ")");
            extractOGraph(graph, exprId)
        ) else (
            let matches = applyAllRules(exprId, rules);
            println("Iteration " + i2s(iteration) + ": applied " + i2s(matches) + " rewrites");
            
            if matches > 0 then (
                // Continue iterating
                iterate(iteration + 1, matches)
            ) else (
                // Fixed point reached
                println("Fixed point reached after " + i2s(iteration) + " iterations");
                extractOGraph(graph, exprId)
            )
        )
    );
    
    iterate(1, -1)
);

// Helper functions to check if expression is a number or variable
fn is_number(expr : ast) = (astname(expr) == "Int" || astname(expr) == "Double");
fn is_var(expr : ast) = (astname(expr) == "Variable" || astname(expr) == "Identifier");
// Check if expression is a generalized linear expression (GLE)
// Using eval() for selective evaluation of AST subexpressions
fn is_glex(expr : ast) = (
	is_var(eval(expr)) || is_number(eval(expr)) ||
	expr is (
		a * b => is_glex(eval(a)) && is_glex(eval(b));
		a ^ b => (
			is_glex(eval(a)) && is_number(eval(b))
		);
		a => false
	)
);
fn leq(a, b) = a <= b;
"Rewrite Library Successfully Loaded"