import lib/reflect;
import lib/array;
import lib/graph;

// Domain-aware rewriting library for OGraph manipulation
// This library provides functions for pattern matching, rewriting, and
// domain annotation handling with the correct sequence of operations.

//
// CORE REWRITING FUNCTIONS
//

// Apply a single rewrite pattern and replacement to a graph,
// correctly handling domain annotations and conditions
fn applyRewriteRule(graph, pattern, replacement, condition, ruleName) = (
    println("\nApplying rule: " + ruleName);
    println("Pattern: " + prettySexpr(pattern));
    println("Replacement: " + prettySexpr(replacement));
    println("Condition: " + prettySexpr(condition));
    
    // Apply the pattern match
    let matches = matchOGraphPattern(graph, pattern, \(bindings : ast, eclassId) . (
        //println("Match found at ID: " + i2s(eclassId));
        //println("Bindings: " + prettyOrbit(bindings));
        // THE CORRECT SEQUENCE FOR DOMAIN-AWARE REWRITING:
        // Step 1: Check if the condition is satisfied
        let shouldApplyRule = if (condition == true) then (
            // Optimize for the common case of condition=true
            true
        ) else (
            // Substitute bindings into the condition in the graph
            let condId = addOGraphWithSub(graph, condition, bindings);
            
            // Extract for evaluation
            let condExpr = extractOGraph(graph, condId);
            // println("Condition instantiated to: " + prettyOrbit(condExpr));

            // Evaluate the condition
            let condResult = eval(condExpr);
            // println("Condition evaluated to: " + prettyOrbit(condResult));
            
            condResult
        );
        
        if (shouldApplyRule) then (
            // Step 2: Apply the replacement (only if condition is true)
            // Modern approach using direct eclass ID substitution
            // This is more efficient and works directly with eclass IDs
            let newId = addOGraphWithSub(graph, replacement, bindings);
            println("Rule '" + ruleName + "' applied. ID: " + i2s(newId) + ": " + prettyOrbit(extractOGraph(graph, newId)) + " was " + prettyOrbit(extractOGraph(graph, eclassId)) + " at " + i2s(eclassId));

            let symbolic = mergeOGraphNodes(graph, newId, eclassId);

			// Do eval in the ograph
			let quasi = evaluateOGraphQuasiquote(graph, newId);

            // Step 3: Merge nodes (result first to make it canonical)
            let success = mergeOGraphNodes(graph, quasi, eclassId);
            // setFileContent("merged" + i2s(newId) + ".dot", ograph2dot(graph));
			success

        ) else (
            // println("Condition not satisfied, rule not applied");
			0
        );
    ));
    
	//  println("Applied " + i2s(matches) + " matches for rule '" + ruleName + "'")
    matches
);

// Initialize the rewrite engine with an expression
fn initRewriteEngine(expr) = (
    // Create a new graph for OGraph operations
    let ograph = makeOGraph("transform");
    // Add the expression
    let exprId = addOGraph(ograph, expr);
    
    // Create a graph to track rule applications
    let graph = makeGraph();
    
    // Create our accumulator structure and track the original expression
    let originalExpr = expr;
    
    // Return the initialized accumulator
    RewriteAcc(ograph, graph, exprId, originalExpr)
);

// Helper function for applying a rule and tracking it in the graph
fn applyAndTrackRule(acc, pattern, replacement, condition, ruleName) = (
    acc is (RewriteAcc(ograph, graph, exprId, originalExpr) => (
        // Track original expression before applying the rule
        let fromExpr = extractOGraph(ograph, exprId);
        
        // Apply the rule
        let matches = applyRewriteRule(ograph, pattern, replacement, condition, ruleName);
        
        // If rule was applied, track it in the graph
        if (matches > 0) then (
            // Get the transformed expression
            let toExpr = extractOGraph(ograph, exprId);
            
            // Add nodes for from and to expressions if they don't exist
            let graphWithNodes = addNode(addNode(graph, fromExpr), toExpr);
            
            // Add an edge with the Rule structure as data
            let graphWithEdge = addEdge(graphWithNodes, fromExpr, toExpr, 
                Rule(ruleName, pattern, replacement, condition));
            
            RewriteAcc(ograph, graphWithEdge, exprId, originalExpr)
        ) else (
            // No change, keep the accumulator as is
            acc
        )
    ))
);

// Apply one round of rewrite rules to the accumulator
fn applyRulesOneRound(acc, rules) = (
    // Apply each rule and track in the graph
    fold(rules, acc, \acc, rule -> (
        acc is (RewriteAcc(ograph, graph, exprId, originalExpr) => (
            rule is (
                Rule(name, (p => q)) => (
                    applyAndTrackRule(acc, p, q, true, name)
                );
                Rule(name, (p => q if cond)) => (
                    applyAndTrackRule(acc, p, q, cond, name)
                );
                (p => q) => (
                    applyAndTrackRule(acc, p, q, true, "Anonymous")
                );
                (p => q if cond) => (
                    applyAndTrackRule(acc, p, q, cond, "Anonymous with condition")
                );
                Rule(name, (p -> q)) => (
                    applyAndTrackRule(acc, p, q, true, name)
                );
                Rule(name, (p -> q if cond)) => (
                    applyAndTrackRule(acc, p, q, cond, name)
                );
                (p -> q) => (
                    applyAndTrackRule(acc, p, q, true, "Anonymous")
                );
                (p -> q if cond) => (
                    applyAndTrackRule(acc, p, q, cond, "Anonymous with condition")
                );
            )
        ))
    ))
);

// Extract the final result and print the rewrite path
fn extractRewriteResult(acc) = (
    acc is (RewriteAcc(ograph, graph, exprId, originalExpr) => (
        let finalExpr = extractOGraph(ograph, exprId);
        
        // Find the shortest path from original to final expression
        let path = shortestPath(graph, originalExpr, finalExpr);
        path is (
            Path(found, nodes, _) => (
                if (found && length(nodes) > 1) then (
                    println("\nRewrite sequence from original to final expression:");
                    
                    // Print each step in the rewrite sequence
                    fold(range(0, length(nodes) - 1), 0, \_, i -> (
                        let from = nodes[i];
                        let to = nodes[i + 1];
                        
                        // Get the rule information from the edge
                        let edges = getEdgesFrom(graph, from);
                        let edge = filter(edges, \e -> e is (Edge(_, edgeTo, _) => edgeTo == to))[0];
                        
                        edge is (
                            Edge(_, _, Rule(name, _, _, _)) => (
                                println(i2s(i + 1) + ". " + name + ": " + 
                                    prettyOrbit(from) + " => " + prettyOrbit(to));
                                0
                            );
                            _ => 0
                        )
                    ));
                ) else if (!found) then (
                    println("No rewrite path found from original to final expression.");
                    0
                ) else (
                    // Only one node, no changes applied
                    println("No rewrites applied - original expression unchanged.");
                    0
                )
            )
        );
        
        // Return the final transformed expression and the rewrite graph
        Pair(finalExpr, graph)
    ))
);

// Apply a list of rewrite rules to an expression
// Rules are quadruples: [name, pattern, replacement, condition]
fn applyRules(expr, rules) = (
    // Initialize the rewrite engine
    let acc = initRewriteEngine(expr);
    
    // Apply one round of rules
    let finalAcc = applyRulesOneRound(acc, rules);

    // Extract and return the result
    extractRewriteResult(finalAcc)
);

// Apply rules until saturation (fixed point)
fn applyRulesUntilFixedPoint(expr, rules, maxIterations) = (
    // Initialize the rewrite engine
    let acc = initRewriteEngine(expr);
    
    // Function to apply rules until fixed point
    fn iterate(acc, iteration) = (
        if (iteration >= maxIterations) then (
            println("Reached max iterations (" + i2s(maxIterations) + ")");
            acc
        ) else (
            // Apply one round of rules
            let newAcc = applyRulesOneRound(acc, rules);
            
            // Get expressions to compare if anything changed
            acc is (RewriteAcc(ograph1, _, exprId1, _) => (
                newAcc is (RewriteAcc(ograph2, _, exprId2, _) => (
                    let beforeExpr = extractOGraph(ograph1, exprId1);
                    let afterExpr = extractOGraph(ograph2, exprId2);
                    
                    // Check if expression changed
                    if (beforeExpr != afterExpr) then (
                        // Continue iterating
                        iterate(newAcc, iteration + 1)
                    ) else (
                        // Fixed point reached
                        println("Fixed point reached after " + i2s(iteration) + " iterations");
                        newAcc
                    )
                ))
            ))
        )
    );
    
    // Run the iteration
    let finalAcc = iterate(acc, 0);
    
    // Extract the result
    extractRewriteResult(finalAcc)
);

//
// HELPER FUNCTIONS
//

// Prepares a rule with proper domain handling
// Returns a quadruple of [name, pattern, replacement, condition]
fn prepareRule(name, patternExpr : ast, replacementExpr : ast, conditionExpr : ast) = (
	Rule(name, patternExpr, replacementExpr, conditionExpr)
);

// Convenience function for rules without conditions
fn prepareSimpleRule(name, patternExpr, replacementExpr) = (
    prepareRule(name, patternExpr, replacementExpr, true)
);

// Apply a single rule to an expression
fn applyRule(expr, rule) = (
    applyRules(expr, [rule])
);

// Prepare rules of this form:
// 	let r = rules("Rewrites", [a => b, c => d if e]);
//  applyRulesUntilFixedPoint(expr, r, 10);
fn rules(namePrefix, quotedRules : ast) = (
	mapi(quotedRules, \i, rule -> (
		rule is (
			// Simple rule: a => b
			(a => b) => [namePrefix + " #" + i2s(i + 1), a, b, true];
			
			// Conditional rule: c => d if e
			(c => d if e) => (
				[namePrefix + " #" + i2s(i + 1), c, d, e]
			);

			// Default case
			_ => (
				println("Invalid rule format: " + prettyOrbit(rule));
				[
					namePrefix + " invalid #" + i2s(i + 1), rule, rule, true
				]
			)
		)
	));
);

"Rewrite Library Successfully Loaded"