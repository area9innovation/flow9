//
// REFLECTION FUNCTIONS
//

fn quote(e : ast) = e;

// Helper functions to check if expression is a number or variable
fn is_number(expr) = (astname(expr) == "Int" || astname(expr) == "Double");
fn is_var(expr) = (astname(expr) == "UId" || astname(expr) == "Identifier");
// Check if expression is a generalized linear expression (GLE)
// Using eval() for selective evaluation of AST subexpressions
fn is_glex(expr) = (
	is_var(expr) || is_number(expr) ||
	expr is (
		a * b => is_glex(a) && is_glex(b);
		a ^ b => (
			is_glex(eval(a)) && is_number(b)
		);
		a => false
	)
);

// Extract the value from a number node
fn extract_number(expr) = (
	if (is_number(expr)) then expr
	else 0
);

// Calculate the degree of a term in a polynomial
fn term_degree(term) = (
    if is_number(term) then 0
    else if is_var(term) then 1
    else term is (
        a * b => term_degree(a) + term_degree(b);
        a ^ b => term_degree(a) * extract_number(b);
        _ => 0 // Default for other cases
    )
);

// Get variables in a term (as a sorted array of variable names)
fn term_variables(term) = (
    if is_number(term) then []
    else if is_var(term) then [varname(term)]
    else term is (
        a * b => term_variables(a) + term_variables(b);
        a ^ _ => term_variables(a);
        _ => [] // Default for other cases
    )
);

// Count occurrences of a variable in a term
fn var_count(term, var_name : string) = (
    if is_number(term) then 0
    else if is_var(term) then (
        let name = varname(term);
        if name == var_name then 1 else 0
    ) else term is (
        a * b => var_count(a, var_name) + var_count(b, var_name);
        a ^ b => b is (
            Int(n) => var_count(a, var_name) * n;
            _ => var_count(a, var_name) // Default case
        );
        _ => 0 // Default for other cases
    )
);

// Compare polynomial terms using graded lexicographic ordering
// Returns -1 if a < b, 0 if a = b, 1 if a > b
fn compare_terms(a, b) = (
    // First compare by total degree (in reverse order - higher degree first)
    let deg_a = term_degree(a);
    let deg_b = term_degree(b);

    if deg_a > deg_b then 1
    else if deg_a < deg_b then -1
    else (
        // Same degree, compare lexicographically by variables
        // Get all unique variables from both terms
		// TODO: This is wrong.
		// We have to deconstruct the multiplicative term into three parts:
		// The coefficient, the variable, and the exponent.
		// and get an array of those three numbers
        let all_vars = sort(term_variables(a) + term_variables(b));
        
        // Helper function to compare variable by variable
        fn compare_by_vars(vars, index) = (
            if index >= length(vars) then 0 // Equal if we've checked all variables
            else (
                let var = vars[index];
                let count_a = var_count(a, var);
                let count_b = var_count(b, var);
                
                if count_a > count_b then 1
                else if count_a < count_b then -1
                else compare_by_vars(vars, index + 1) // Same count, check next variable
            )
        );
        
        compare_by_vars(all_vars, 0)
    )
);

// Graded lexicographic comparison function for polynomial expressions
// Can be used with sort function to order polynomial terms
fn glex_compare(a, b) = (
    compare_terms(a, b) <= 0
);
