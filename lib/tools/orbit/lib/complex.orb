// A library for complex number arithmetic in Orbit.
// Complex numbers are represented using the constructor: Complex(real_part, imaginary_part)

// Constructor: Creates a complex number from its real and imaginary parts.
// Example: complex(3.0, 4.0) represents 3 + 4i
fn complex(re, im) = Complex(re, im);

// Addition: Adds two complex numbers.
// (a + bi) + (c + di) = (a + c) + (b + d)i
fn addC(a, b) = (
    a is (Complex(re_a, im_a) =>
        b is (Complex(re_b, im_b) =>
            Complex(re_a + re_b, im_a + im_b)
        )
    )
);

// Subtraction: Subtracts the second complex number from the first.
// (a + bi) - (c + di) = (a - c) + (b - d)i
fn subC(a, b) = (
    a is (Complex(re_a, im_a) =>
        b is (Complex(re_b, im_b) =>
            Complex(re_a - re_b, im_a - im_b)
        )
    )
);

// Multiplication: Multiplies two complex numbers.
// (a + bi) * (c + di) = (ac - bd) + (ad + bc)i
fn mulC(a, b) = (
    a is (Complex(re_a, im_a) =>
        b is (Complex(re_b, im_b) =>
            Complex(re_a * re_b - im_a * im_b, re_a * im_b + im_a * re_b)
        )
    )
);

// Magnitude: Calculates the magnitude (or modulus) of a complex number.
// |a + bi| = sqrt(a^2 + b^2)
fn magnitudeC(c) = (
    c is (Complex(re, im) => sqrt(re * re + im * im))
);

// Division: Divides the first complex number by the second.
// (a + bi) / (c + di) = [(a + bi) * (c - di)] / |c + di|^2
// Division by zero (0 + 0i) will result in Inf or NaN components based on standard float division.
fn divC(a, b) = (
    a is (Complex(re_a, im_a) =>
        b is (Complex(re_b, im_b) => (
            let denom_sq = re_b * re_b + im_b * im_b;
            let num_re = re_a * re_b + im_a * im_b;
            let num_im = im_a * re_b - re_a * im_b;
            Complex(num_re / denom_sq, num_im / denom_sq)
        ))
    )
);

// Argument: Calculates the argument (or phase) of a complex number in radians.
// arg(a + bi) = atan2(b, a)
fn argumentC(c) = (
    c is (Complex(re, im) => atan2(im, re))
);

// Conjugate: Calculates the complex conjugate.
// conj(a + bi) = a - bi
fn conjugateC(c) = (
    c is (Complex(re, im) => Complex(re, -im))
);

// Polar Constructor: Creates a complex number from polar coordinates (magnitude, argument).
// magnitude * (cos(argument) + i * sin(argument))
fn polarC(magnitude, argument) = (
    Complex(magnitude * cos(argument), magnitude * sin(argument))
);

// Exponential function: Calculates e raised to the power of a complex number.
// exp(a + bi) = exp(a) * (cos(b) + i * sin(b))
fn expC(c) = (
    c is (Complex(re, im) => (
        let mag = exp(re);
        Complex(mag * cos(im), mag * sin(im))
    ))
);

// Natural Logarithm: Calculates the principal value of the natural logarithm of a complex number.
// log(z) = log|z| + i*arg(z)
// log(0 + 0i) is undefined. This implementation returns Complex(-Inf, 0.0) and prints an error for log(0).
// Note: Orbit's standard `log` handles `log(0.0)` by returning -Infinity.
fn logC(c) = (
    c is (Complex(re, im) =>
        if re == 0.0 && im == 0.0 then (
            println("Error: logC(0 + 0i) is undefined.");
            Complex(log(0.0), 0.0) // Matches behavior of log(0.0) -> -Inf
        ) else (
            Complex(log(magnitudeC(c)), argumentC(c))
        )
    )
);

// Complex Power: Calculates the principal value of base raised to the power of exponent (both complex).
// base ^ exponent = expC(mulC(exponent, logC(base)))
fn powC(base, exponent) = (
    expC(mulC(exponent, logC(base)))
);

// String Representation: Converts a complex number to a human-readable string.
// Formats as "a + bi", "a - bi", "a", "bi".
fn complexToString(c) = (
    c is (Complex(re, im) =>
        if im == 0.0 then (
            d2s(re) // Real number
        ) else if re == 0.0 then (
            if im == 1.0 then "i"          // Just i
            else if im == -1.0 then "-i" // Just -i
            else d2s(im) + "i"             // Purely imaginary
        ) else if im > 0.0 then (
            if im == 1.0 then d2s(re) + " + i" // a + i
            else d2s(re) + " + " + d2s(im) + "i" // a + bi
        ) else ( // im < 0.0
            if im == -1.0 then d2s(re) + " - i" // a - i
            else d2s(re) + " - " + d2s(abs(im)) + "i" // a - bi
        )
    )
);
