import tools/orbit/orbit_pattern;  // For existing pattern matching utilities
import tools/orbit/ograph;         // For OGraph operations
import tools/orbit/orbit2ograph;   // For conversion between Orbit and OGraph
import tools/orbit/orbit_types;    // For OrMath_expr types
import tools/orbit/orbit_simple_ograph; // For ographRegistry
import tools/orbit/orbit_decompose; // For centralized decomposition
import ds/tree;                    // For binding maps
import string;                     // For string operations

export {
    // Main pattern matching function
    // Finds all matches of the pattern in the graph and calls the callback for each
    matchOGraphPattern(
        graphName : string,                      // Name of the OGraph to search in
        pattern : OrMath_expr,                   // Pattern to match (with variables)
        callback : (Tree<string, OrMath_expr>, int) -> void,  // Called for each match with bindings and the e-class ID
		tracing : bool
    ) -> int;  // Returns the number of matches found
    
    // Internal helpers
    OPatternResult ::= OPatternSuccess, OPatternFailure;
        OPatternSuccess(bindings : Tree<string, int>); // Variable name to node ID
        OPatternFailure();
}

// Main function for pattern matching in an OGraph
matchOGraphPattern(graphName : string, pattern : OrMath_expr, callback : (Tree<string, OrMath_expr>, int) -> void, tracing : bool) -> int {
    // Get the graph from the registry
    matchCount = ref 0;
    
    switch (lookupTree(^ographRegistry, graphName)) {
        Some(graph): {
            // Strategy: Try to match the pattern starting at each node in the graph
            if (tracing) println("DEBUG: Found graph, traversing nodes");
            traverseOGraph(graph, \nodeIndex, node -> {
                if (tracing) println("DEBUG: Checking node ID: " + i2s(nodeIndex) + ", op: " + node.op);
                
                // Try to match the pattern at this node
                switch (matchPatternAtNode(graph, nodeIndex, pattern, tracing)) {
                    OPatternSuccess(bindings): {
                        if (tracing)  println("DEBUG: Found match at node ID: " + i2s(nodeIndex));
                        // Found a match, convert node IDs to expressions
                        exprBindings = convertBindingsToExpressions(graph, bindings);
                        
                        // Call the callback with the bindings and the e-class ID (root of the matched node)
                        matchCount := ^matchCount + 1;
                        rootId = findORoot(graph, nodeIndex);
                        callback(exprBindings, rootId);
                    }
                    OPatternFailure(): {
                        // No match at this node, continue searching
                        if (tracing) println("DEBUG: No match at node ID: " + i2s(nodeIndex));
                    }
                }
            });
            
            // println("DEBUG: Finished traversing graph, found " + i2s(^matchCount) + " matches");
            ^matchCount;
        }
        None(): {
            println("ERROR: OGraph '" + graphName + "' not found");
            0;
        }
    }
}

// Convert bindings from node IDs to expressions
convertBindingsToExpressions(graph : OGraph, bindings : Tree<string, int>) -> Tree<string, OrMath_expr> {
    mapTree(bindings, \nodeId -> ograph2Orbit(graph, nodeId));
}

// Match a pattern at a specific node
matchPatternAtNode(graph : OGraph, nodeId : int, pattern : OrMath_expr, tracing : bool) -> OPatternResult {
    root = findORoot(graph, nodeId);
    
    // Decompose the pattern using the centralized function
    patternDecomposed = decomposeOrbit(pattern);
    patternOp = patternDecomposed.first;
    patternChildren = patternDecomposed.second.first;
    patternValue = patternDecomposed.second.second;
    
    if (tracing) println("DEBUG: Matching pattern with op: " + patternOp + ", at node: " + i2s(root));
    
    // Special case for pattern variables (identifiers in pattern context)
    if (patternOp == "Identifier") {
        // Extract the variable name
        varName = switch (patternValue) {
            OrbitString(s): s;
            default: "";
        };
        
        if (varName != "") {
            // In pattern matching, identifiers are treated as pattern variables
            // that can match any node (not just concrete identifiers)
            if (tracing) println("DEBUG: Pattern variable " + varName + " binds to node " + i2s(root));
            OPatternSuccess(makeTree1(varName, root));
        } else {
            // Handle the case when varName is empty
            OPatternFailure();
        }
    } else {
        // For all other patterns, get the node information and attempt to match
        switch (lookupOClass(graph, root)) {
            Some(oclass): {
                nodeOp = oclass.node.op;
                nodeChildren = oclass.node.children;
                
                if (tracing) println("DEBUG: Matching pattern op '" + patternOp + "' against node op '" + nodeOp + "'");
                
                // Match operator name
                if (patternOp != nodeOp) {
                    if (tracing) println("DEBUG: Operator mismatch");
                    OPatternFailure();
                } else {
                    // Match primitive values for leaf nodes
                    if (patternOp == "Int") {
                        patternInt = switch (patternValue) { 
                            OrbitInt(i): i; 
                            default: -999999; // Sentinel value indicating no valid pattern value
                        };
                        
                        switch (getOClassInt(graph, root)) {
                            Some(nodeInt): {
                                if (patternInt != -999999 && patternInt != nodeInt) {
                                    if (tracing) println("DEBUG: Int value mismatch: " + i2s(patternInt) + " vs " + i2s(nodeInt));
                                    OPatternFailure();
                                } else {
                                    // Integer value matched or pattern had no specific value constraint
                                    OPatternSuccess(makeTree());
                                }
                            }
                            None(): {
                                if (tracing) println("DEBUG: Node has no int value");
                                OPatternFailure();
                            }
                        }
                    } 
                    else if (patternOp == "Double") {
                        patternDouble = switch (patternValue) { 
                            OrbitDouble(d): d; 
                            default: -999999.0; // Sentinel
                        };
                        
                        switch (getOClassDouble(graph, root)) {
                            Some(nodeDouble): {
                                if (patternDouble != -999999.0 && patternDouble != nodeDouble) {
                                    if (tracing) println("DEBUG: Double value mismatch");
                                    OPatternFailure();
                                } else {
                                    OPatternSuccess(makeTree());
                                }
                            }
                            None(): {
                                if (tracing) println("DEBUG: Node has no double value");
                                OPatternFailure();
                            }
                        }
                    }
                    else if (patternOp == "String") {
                        patternString = switch (patternValue) { 
                            OrbitString(s): s; 
                            default: ""; 
                        };
                        
                        switch (getOClassString(graph, root)) {
                            Some(nodeString): {
                                if (patternString != "" && patternString != nodeString) {
                                    if (tracing) println("DEBUG: String value mismatch");
                                    OPatternFailure();
                                } else {
                                    OPatternSuccess(makeTree());
                                }
                            }
                            None(): {
                                if (tracing) println("DEBUG: Node has no string value");
                                OPatternFailure();
                            }
                        }
                    }
                    else if (patternOp == "Bool") {
                        patternBool = switch (patternValue) { 
                            OrbitBool(b): b; 
                            OrbitInt(i): i != 0;
                            default: false; // Default value without pattern constraint
                        };
                        
                        switch (getOClassInt(graph, root)) {
                            Some(nodeInt): {
                                // Bool is stored as int: 0 = false, non-zero = true
                                nodeBool = nodeInt != 0;
                                if (nodeBool != patternBool) {
                                    if (tracing) println("DEBUG: Bool value mismatch");
                                    OPatternFailure();
                                } else {
                                    OPatternSuccess(makeTree());
                                }
                            }
                            None(): {
                                if (tracing) println("DEBUG: Node has no bool/int value");
                                OPatternFailure();
                            }
                        }
                    }
                    else if (patternOp == "Variable" || patternOp == "Identifier") {
                        patternId = switch (patternValue) { 
                            OrbitString(s): s; 
                            default: ""; 
                        };
                        
                        switch (getOClassString(graph, root)) {
                            Some(nodeStr): {
                                if (patternId != "" && patternId != nodeStr) {
                                    if (tracing) println("DEBUG: Variable/Identifier name mismatch");
                                    OPatternFailure();
                                } else {
                                    OPatternSuccess(makeTree());
                                }
                            }
                            None(): {
                                if (tracing) println("DEBUG: Node has no string value for identifier");
                                OPatternFailure();
                            }
                        }
                    }
                    // For operators that have children, match recursively
                    else if (length(patternChildren) != length(nodeChildren)) {
                        if (tracing) println("DEBUG: Children count mismatch: pattern=" + i2s(length(patternChildren)) + ", node=" + i2s(length(nodeChildren)));
                        OPatternFailure();
                    } else {
                        // If operator and child count match, try to match all children
                        if (tracing) println("DEBUG: Operator and child count match, checking children");
                        matchAllChildren(graph, nodeChildren, patternChildren, makeTree(), tracing);
                    }
                }
            }
            None(): {
                if (tracing) println("DEBUG: Node not found in graph");
                OPatternFailure();
            }
        }
    }
}

// Match all children of an operation
matchAllChildren(graph : OGraph, childIds : [int], patterns : [OrMath_expr], 
                 bindings : Tree<string, int>, tracing : bool) -> OPatternResult {
    if (length(childIds) == 0 && length(patterns) == 0) {
        // All children matched successfully
        // println("DEBUG: All children matched successfully. Final bindings: " + 
        //        superglue(getTreeKeys(bindings), \k -> k + ":" + i2s(lookupTreeDef(bindings, k, -1)), ", "));
        OPatternSuccess(bindings);
    } else if (length(childIds) == 0 || length(patterns) == 0) {
        // Mismatched number of children
        // println("DEBUG: Mismatched number of children. childIds=" + i2s(length(childIds)) + ", patterns=" + i2s(length(patterns)));
        OPatternFailure();
    } else {
        // Try to match the first child
        // println("DEBUG: Matching child " + i2s(childIds[0]) + " with pattern " + prettyOrbit(patterns[0]));
        switch (matchPatternAtNode(graph, childIds[0], patterns[0], tracing)) {
            OPatternSuccess(childBindings): {
                // println("DEBUG: Child match succeeded with bindings: " + 
                //        superglue(getTreeKeys(childBindings), \k -> k + ":" + i2s(lookupTreeDef(childBindings, k, -1)), ", "));
                // Merge bindings, ensuring consistency
                switch (mergeOBindings(graph, bindings, childBindings)) {
                    OPatternSuccess(mergedBindings): {
                        // println("DEBUG: Bindings merged successfully, continuing with remaining children");
                        // Continue with remaining children
                        matchAllChildren(graph, tail(childIds), tail(patterns), mergedBindings, tracing);
                    }
                    OPatternFailure(): {
                        // println("DEBUG: Bindings merge failed - inconsistent variable bindings");
                        OPatternFailure();
                    }
                }
            }
            OPatternFailure(): {
                // println("DEBUG: Child match failed");
                OPatternFailure();
            }
        }
    }
}

// Check if two nodes in the graph are semantically equivalent
nodeEquivalence(graph : OGraph, node1Id : int, node2Id : int) -> bool {
    // Get the canonical IDs
    root1 = findORoot(graph, node1Id);
    root2 = findORoot(graph, node2Id);
    
    // If they are the same node (same equivalence class), they are equivalent
    if (root1 == root2) true
    else {
        // For pattern variables that represent concrete nodes in the graph,
        // we need to check for semantic equivalence, not just ID equality
        
        // Get the nodes from the graph
        node1 = switch (lookupOClass(graph, root1)) {
            Some(oclass): oclass.node;
            None(): ONode("", [], []);
        }
        
        node2 = switch (lookupOClass(graph, root2)) {
            Some(oclass): oclass.node;
            None(): ONode("", [], []);
        }
        
        // Special case for identifiers/variables - check if they have the same name
        if ((node1.op == "Identifier" || node1.op == "Variable") && 
            (node2.op == "Identifier" || node2.op == "Variable")) {
            
            // Get their names
            name1 = switch (getOClassString(graph, root1)) {
                Some(s): s;
                None(): "";
            }
            
            name2 = switch (getOClassString(graph, root2)) {
                Some(s): s;
                None(): "";
            }
            
            // Check if names match
            name1 == name2 && name1 != ""
        } else {
            // For all other node types, we just check if they have the same structure
            if (node1.op == node2.op && length(node1.children) == length(node2.children)) {
                // For nodes with children, we need to check that all children are equivalent
                if (length(node1.children) > 0) {
                    // Check all children recursively
                    foldRange(0, length(node1.children) - 1, true, \acc, i -> {
                        if (!acc) false  // Short-circuit if we already found non-matching children
                        else nodeEquivalence(graph, node1.children[i], node2.children[i])
                    });
                } else {
                    // For leaf nodes with the same operator, they're equivalent
                    true;
                }
            } else {
                // Different operators or different number of children means not equivalent
                false;
            }
        }
    }
}

// Merge bindings, ensuring consistency (same variable bound to semantically equivalent nodes)
mergeOBindings(graph : OGraph, a : Tree<string, int>, b : Tree<string, int>) -> OPatternResult {
    result = fold(getTreeKeys(b), OPatternSuccess(a), \acc, key -> {
        switch (acc) {
            OPatternSuccess(bindings): {
                bValue = lookupTreeDef(b, key, -1);
                switch (lookupTree(bindings, key)) {
                    Some(aValue): {
                        // Variable already bound, must be consistent
                        // This is critical for patterns like x + x where the same variable appears multiple times
                        if (nodeEquivalence(graph, aValue, bValue)) {
                            // println("DEBUG: Consistent binding for " + key + ": already bound to " + i2s(aValue) + 
                            //        ", new node " + i2s(bValue) + " is equivalent");
                            OPatternSuccess(bindings);
                        } else {
                            // println("DEBUG: INCONSISTENT binding for " + key + ": previous=" + i2s(aValue) + 
                            //        ", new=" + i2s(bValue) + " are not equivalent");
                            OPatternFailure();
                        }
                    }
                    None(): {
                        // New binding
                        // println("DEBUG: New binding: " + key + " = " + i2s(bValue));
                        OPatternSuccess(setTree(bindings, key, bValue));
                    }
                }
            }
            OPatternFailure(): OPatternFailure();
        }
    });
    
    result;
}