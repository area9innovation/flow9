import tools/orbit/orbit_pattern;  // For existing pattern matching utilities
import tools/orbit/ograph;         // For OGraph operations
import tools/orbit/orbit2ograph;   // For conversion between Orbit and OGraph
import tools/orbit/orbit_types;    // For OrMath_expr types
import tools/orbit/orbit_simple_ograph; // For ographRegistry
import tools/orbit/orbit_decompose; // For centralized decomposition
import tools/orbit/ograph_decompose; // For OGraph node decomposition
import ds/tree;                    // For binding maps
import string;                     // For string operations

export {
    // Main pattern matching function
    // Finds all matches of the pattern in the graph and calls the callback for each
    matchOGraphPattern(
        graphName : string,                      // Name of the OGraph to search in
        pattern : OrMath_expr,                   // Pattern to match (with variables)
        callback : (Tree<string, OrMath_expr>, int) -> void,  // Called for each match with bindings and the e-class ID
		tracing : bool
    ) -> int;  // Returns the number of matches found
    
    // Internal helpers
    OPatternResult ::= OPatternSuccess, OPatternFailure;
        OPatternSuccess(bindings : Tree<string, int>); // Variable name to node ID
        OPatternFailure();
}

// Main function for pattern matching in an OGraph
matchOGraphPattern(graphName : string, pattern : OrMath_expr, callback : (Tree<string, OrMath_expr>, int) -> void, tracing : bool) -> int {
    // Get the graph from the registry
    matchCount = ref 0;
    
    switch (lookupTree(^ographRegistry, graphName)) {
        Some(graph): {
            // Strategy: Try to match the pattern starting at each node in the graph
            if (tracing) println("DEBUG: Found graph, traversing nodes");
            traverseOGraph(graph, \nodeIndex, node -> {
                if (tracing) println("DEBUG: Checking node ID: " + i2s(nodeIndex) + ", op: " + node.op);
                
                // Try to match the pattern at this node
                switch (matchPatternAtNode(graph, nodeIndex, pattern, tracing)) {
                    OPatternSuccess(bindings): {
                        if (tracing)  println("DEBUG: Found match at node ID: " + i2s(nodeIndex));
                        // Found a match, convert node IDs to expressions
                        exprBindings = convertBindingsToExpressions(graph, bindings);
                        
                        // Call the callback with the bindings and the e-class ID (root of the matched node)
                        matchCount := ^matchCount + 1;
                        rootId = findORoot(graph, nodeIndex);
                        callback(exprBindings, rootId);
                    }
                    OPatternFailure(): {
                        // No match at this node, continue searching
                        if (tracing) println("DEBUG: No match at node ID: " + i2s(nodeIndex));
                    }
                }
            });
            
            // println("DEBUG: Finished traversing graph, found " + i2s(^matchCount) + " matches");
            ^matchCount;
        }
        None(): {
            println("ERROR: OGraph '" + graphName + "' not found");
            0;
        }
    }
}

// Convert bindings from node IDs to expressions
convertBindingsToExpressions(graph : OGraph, bindings : Tree<string, int>) -> Tree<string, OrMath_expr> {
    mapTree(bindings, \nodeId -> ograph2Orbit(graph, nodeId));
}

// Get domain ID from pattern
getDomainId(graph : OGraph, domainPattern : OrMath_expr, domainBindings : Tree<string, int>, tracing : bool) -> int {
    // Decompose pattern to get its operation type
    patternDecomposed = decomposeOrbit(domainPattern);
    patternOp = patternDecomposed.first;
    patternValue = patternDecomposed.second.second;
    
    // Check if it's a direct identifier
    if (patternOp == "Identifier") {
        domainName = switch (patternValue) { 
            OrbitString(s): s;
            default: "";
        };
        
        // Look for this identifier in the graph
        domainId = ref -1;
        if (domainName != "") {
            traverseOGraph(graph, \ecid, onode -> {
                if (onode.op == "Identifier") {
                    switch (getOClassString(graph, ecid)) {
                        Some(name): if (name == domainName) domainId := ecid;
                        None(): {};
                    }
                }
            });
        }
        
        if (tracing && ^domainId != -1) {
            println("DEBUG: Found domain '" + domainName + "' with ID: " + i2s(^domainId));
        }
        
        ^domainId;
    } else {
        // Use the first binding if available
        if (sizeTree(domainBindings) > 0) {
            firstKey = getTreeKeys(domainBindings)[0];
            result = lookupTreeDef(domainBindings, firstKey, -1);
            if (tracing) {
                println("DEBUG: Using domain binding with ID: " + i2s(result));
            }
            result;
        } else -1;
    }
}

// Match a pattern at a specific node
matchPatternAtNode(graph : OGraph, nodeId : int, pattern : OrMath_expr, tracing : bool) -> OPatternResult {
    root = findORoot(graph, nodeId);
    
    // Decompose the pattern using the centralized function
    patternDecomposed = decomposeOrbit(pattern);
    patternOp = patternDecomposed.first;
    patternChildren = patternDecomposed.second.first;
    patternValue = patternDecomposed.second.second;
    
    if (tracing) println("DEBUG: Matching pattern with op: " + patternOp + ", at node: " + i2s(root));
    
    // Special case for TypeAnnotation (: operator)
    if (patternOp == "TypeAnnotation") {
        if (tracing) println("DEBUG: Processing TypeAnnotation pattern (: operator)");
        // TypeAnnotation means the expression should belong to the specified domain
        // Extract the expression and domain from the pattern
        expressionPattern = switch (pattern) {
            OrTypeAnnotation(expr, domain): expr;
            default: pattern; // Should never happen
        };
        
        domainPattern = switch (pattern) {
            OrTypeAnnotation(expr, domain): domain;
            default: pattern; // Should never happen
        };
        
        // First, match the expression part of the pattern
        switch (matchPatternAtNode(graph, nodeId, expressionPattern, tracing)) {
            OPatternSuccess(exprBindings): {
                // Now we need to match the domain part
                // We first need to evaluate the domain part to get its node ID
                switch (matchPatternAtNode(graph, nodeId, domainPattern, tracing)) {
                    OPatternSuccess(domainBindings): {
                        // Get all bindings from domain pattern
                        // Combine all bindings
                        allBindings = mergeOBindings(graph, exprBindings, domainBindings);
                        switch (allBindings) {
                            OPatternSuccess(bindings): {
                                // Get the domain ID
                                domainNodeId = getDomainId(graph, domainPattern, domainBindings, tracing);
                                
                                // Check if the node belongs to this domain
                                if (domainNodeId != -1 && onodeBelongsTo(graph, nodeId, domainNodeId)) {
                                    if (tracing) println("DEBUG: Node belongs to required domain, match successful");
                                    OPatternSuccess(bindings);
                                } else {
                                    if (tracing) println("DEBUG: Node does not belong to required domain, match failed");
                                    OPatternFailure();
                                }
                            }
                            OPatternFailure(): OPatternFailure();
                        }
                    }
                    OPatternFailure(): OPatternFailure();
                }
            }
            OPatternFailure(): OPatternFailure();
        }
    }
    // Special case for NotTypeAnnotation (!: operator)
    else if (patternOp == "NotTypeAnnotation") {
        if (tracing) println("DEBUG: Processing NotTypeAnnotation pattern (!: operator)");
        // NotTypeAnnotation means the expression should NOT belong to the specified domain
        // Extract the expression and domain from the pattern
        expressionPattern = switch (pattern) {
            OrNotTypeAnnotation(expr, domain): expr;
            default: pattern; // Should never happen
        };
        
        domainPattern = switch (pattern) {
            OrNotTypeAnnotation(expr, domain): domain;
            default: pattern; // Should never happen
        };
        
        // First, match the expression part of the pattern
        switch (matchPatternAtNode(graph, nodeId, expressionPattern, tracing)) {
            OPatternSuccess(exprBindings): {
                // Now we need to match the domain part (to get its ID)
                switch (matchPatternAtNode(graph, nodeId, domainPattern, tracing)) {
                    OPatternSuccess(domainBindings): {
                        // Combine all bindings
                        allBindings = mergeOBindings(graph, exprBindings, domainBindings);
                        switch (allBindings) {
                            OPatternSuccess(bindings): {
                                // Get the domain ID
                                domainNodeId = getDomainId(graph, domainPattern, domainBindings, tracing);
                                
                                // Check that the node does NOT belong to the domain
                                if (domainNodeId == -1 || !onodeBelongsTo(graph, nodeId, domainNodeId)) {
                                    if (tracing) println("DEBUG: Node does not belong to the domain, negative match successful");
                                    OPatternSuccess(bindings);
                                } else {
                                    if (tracing) println("DEBUG: Node belongs to the domain we don't want, match failed");
                                    OPatternFailure();
                                }
                            }
                            OPatternFailure(): OPatternFailure();
                        }
                    }
                    OPatternFailure(): OPatternFailure();
                }
            }
            OPatternFailure(): OPatternFailure();
        }
    }
    // Special case for pattern variables (identifiers in pattern context)
    else if (patternOp == "Identifier") {
        // Extract the variable name
        varName = switch (patternValue) {
            OrbitString(s): s;
            default: "";
        };
        
        if (varName != "") {
            // In pattern matching, identifiers are treated as pattern variables
            // that can match any node (not just concrete identifiers)
            if (tracing) println("DEBUG: Pattern variable " + varName + " binds to node " + i2s(root));
            OPatternSuccess(makeTree1(varName, root));
        } else {
            // Handle the case when varName is empty
            OPatternFailure();
        }
    } else {
        // For all other patterns, get the node information and attempt to match
        switch (lookupOClass(graph, root)) {
            Some(oclass): {
                nodeOp = oclass.node.op;
                nodeChildren = oclass.node.children;
                
                if (tracing) println("DEBUG: Matching pattern op '" + patternOp + "' against node op '" + nodeOp + "'");
                
                // Match operator name
                if (patternOp != nodeOp) {
                    if (tracing) println("DEBUG: Operator mismatch");
                    OPatternFailure();
                } else {
                    // Match primitive values for leaf nodes
                    if (patternOp == "Int") {
                        patternInt = switch (patternValue) { 
                            OrbitInt(i): i; 
                            default: -999999; // Sentinel value indicating no valid pattern value
                        };
                        
                        switch (getOClassInt(graph, root)) {
                            Some(nodeInt): {
                                if (patternInt != -999999 && patternInt != nodeInt) {
                                    if (tracing) println("DEBUG: Int value mismatch: " + i2s(patternInt) + " vs " + i2s(nodeInt));
                                    OPatternFailure();
                                } else {
                                    // Integer value matched or pattern had no specific value constraint
                                    OPatternSuccess(makeTree());
                                }
                            }
                            None(): {
                                if (tracing) println("DEBUG: Node has no int value");
                                OPatternFailure();
                            }
                        }
                    } 
                    else if (patternOp == "Double") {
                        patternDouble = switch (patternValue) { 
                            OrbitDouble(d): d; 
                            default: -999999.0; // Sentinel
                        };
                        
                        switch (getOClassDouble(graph, root)) {
                            Some(nodeDouble): {
                                if (patternDouble != -999999.0 && patternDouble != nodeDouble) {
                                    if (tracing) println("DEBUG: Double value mismatch");
                                    OPatternFailure();
                                } else {
                                    OPatternSuccess(makeTree());
                                }
                            }
                            None(): {
                                if (tracing) println("DEBUG: Node has no double value");
                                OPatternFailure();
                            }
                        }
                    }
                    else if (patternOp == "String") {
                        patternString = switch (patternValue) { 
                            OrbitString(s): s; 
                            default: ""; 
                        };
                        
                        switch (getOClassString(graph, root)) {
                            Some(nodeString): {
                                if (patternString != "" && patternString != nodeString) {
                                    if (tracing) println("DEBUG: String value mismatch");
                                    OPatternFailure();
                                } else {
                                    OPatternSuccess(makeTree());
                                }
                            }
                            None(): {
                                if (tracing) println("DEBUG: Node has no string value");
                                OPatternFailure();
                            }
                        }
                    }
                    else if (patternOp == "Bool") {
                        patternBool = switch (patternValue) { 
                            OrbitBool(b): b; 
                            OrbitInt(i): i != 0;
                            default: false; // Default value without pattern constraint
                        };
                        
                        switch (getOClassInt(graph, root)) {
                            Some(nodeInt): {
                                // Bool is stored as int: 0 = false, non-zero = true
                                nodeBool = nodeInt != 0;
                                if (nodeBool != patternBool) {
                                    if (tracing) println("DEBUG: Bool value mismatch");
                                    OPatternFailure();
                                } else {
                                    OPatternSuccess(makeTree());
                                }
                            }
                            None(): {
                                if (tracing) println("DEBUG: Node has no bool/int value");
                                OPatternFailure();
                            }
                        }
                    }
                    else if (patternOp == "Variable" || patternOp == "Identifier") {
                        patternId = switch (patternValue) { 
                            OrbitString(s): s; 
                            default: ""; 
                        };
                        
                        switch (getOClassString(graph, root)) {
                            Some(nodeStr): {
                                if (patternId != "" && patternId != nodeStr) {
                                    if (tracing) println("DEBUG: Variable/Identifier name mismatch");
                                    OPatternFailure();
                                } else {
                                    OPatternSuccess(makeTree());
                                }
                            }
                            None(): {
                                if (tracing) println("DEBUG: Node has no string value for identifier");
                                OPatternFailure();
                            }
                        }
                    }
                    // For operators that have children, match recursively
                    else if (length(patternChildren) != length(nodeChildren)) {
                        if (tracing) println("DEBUG: Children count mismatch: pattern=" + i2s(length(patternChildren)) + ", node=" + i2s(length(nodeChildren)));
                        OPatternFailure();
                    } else {
                        // If operator and child count match, try to match all children
                        if (tracing) println("DEBUG: Operator and child count match, checking children");
                        matchAllChildren(graph, nodeChildren, patternChildren, makeTree(), tracing);
                    }
                }
            }
            None(): {
                if (tracing) println("DEBUG: Node not found in graph");
                OPatternFailure();
            }
        }
    }
}

// Match all children of an operation
matchAllChildren(graph : OGraph, childIds : [int], patterns : [OrMath_expr], 
                 bindings : Tree<string, int>, tracing : bool) -> OPatternResult {
    if (length(childIds) == 0 && length(patterns) == 0) {
        // All children matched successfully
        // println("DEBUG: All children matched successfully. Final bindings: " + 
        //        superglue(getTreeKeys(bindings), \k -> k + ":" + i2s(lookupTreeDef(bindings, k, -1)), ", "));
        OPatternSuccess(bindings);
    } else if (length(childIds) == 0 || length(patterns) == 0) {
        // Mismatched number of children
        // println("DEBUG: Mismatched number of children. childIds=" + i2s(length(childIds)) + ", patterns=" + i2s(length(patterns)));
        OPatternFailure();
    } else {
        // Try to match the first child
        // println("DEBUG: Matching child " + i2s(childIds[0]) + " with pattern " + prettyOrbit(patterns[0]));
        switch (matchPatternAtNode(graph, childIds[0], patterns[0], tracing)) {
            OPatternSuccess(childBindings): {
                // println("DEBUG: Child match succeeded with bindings: " + 
                //        superglue(getTreeKeys(childBindings), \k -> k + ":" + i2s(lookupTreeDef(childBindings, k, -1)), ", "));
                // Merge bindings, ensuring consistency
                switch (mergeOBindings(graph, bindings, childBindings)) {
                    OPatternSuccess(mergedBindings): {
                        // println("DEBUG: Bindings merged successfully, continuing with remaining children");
                        // Continue with remaining children
                        matchAllChildren(graph, tail(childIds), tail(patterns), mergedBindings, tracing);
                    }
                    OPatternFailure(): {
                        // println("DEBUG: Bindings merge failed - inconsistent variable bindings");
                        OPatternFailure();
                    }
                }
            }
            OPatternFailure(): {
                // println("DEBUG: Child match failed");
                OPatternFailure();
            }
        }
    }
}

// Merge bindings, ensuring consistency (same variable bound to semantically equivalent nodes)
mergeOBindings(graph : OGraph, a : Tree<string, int>, b : Tree<string, int>) -> OPatternResult {
    result = fold(getTreeKeys(b), OPatternSuccess(a), \acc, key -> {
        switch (acc) {
            OPatternSuccess(bindings): {
                bValue = lookupTreeDef(b, key, -1);
                switch (lookupTree(bindings, key)) {
                    Some(aValue): {
                        // Variable already bound, must be consistent
                        // This is critical for patterns like x + x where the same variable appears multiple times
                        if (oNodesEquivalent(graph, aValue, bValue)) {
                            // println("DEBUG: Consistent binding for " + key + ": already bound to " + i2s(aValue) + 
                            //        ", new node " + i2s(bValue) + " is equivalent");
                            OPatternSuccess(bindings);
                        } else {
                            // println("DEBUG: INCONSISTENT binding for " + key + ": previous=" + i2s(aValue) + 
                            //        ", new=" + i2s(bValue) + " are not equivalent");
                            OPatternFailure();
                        }
                    }
                    None(): {
                        // New binding
                        // println("DEBUG: New binding: " + key + " = " + i2s(bValue));
                        OPatternSuccess(setTree(bindings, key, bValue));
                    }
                }
            }
            OPatternFailure(): OPatternFailure();
        }
    });
    
    result;
}