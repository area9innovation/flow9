import tools/orbit/orbit_pattern;  // For existing pattern matching utilities
import tools/orbit/ograph;         // For OGraph operations
import tools/orbit/orbit2ograph;   // For conversion between Orbit and OGraph
import tools/orbit/orbit_types;    // For OrMath_expr types
import tools/orbit/orbit_simple_ograph; // For ographRegistry
import ds/tree;                    // For binding maps
import string;                     // For string operations

export {
    // Main pattern matching function
    // Finds all matches of the pattern in the graph and calls the callback for each
    matchOGraphPattern(
        graphName : string,                      // Name of the OGraph to search in
        pattern : OrMath_expr,                   // Pattern to match (with variables)
        callback : (Tree<string, OrMath_expr>) -> void  // Called for each match with bindings
    ) -> int;  // Returns the number of matches found
    
    // Internal helpers
    OPatternResult ::= OPatternSuccess, OPatternFailure;
        OPatternSuccess(bindings : Tree<string, int>); // Variable name to node ID
        OPatternFailure();
    
    // Match a pattern directly against a specific node
    matchPatternAtNode(
        graph : OGraph, 
        nodeId : int, 
        pattern : OrMath_expr
    ) -> OPatternResult;
}

// Main function for pattern matching in an OGraph
matchOGraphPattern(graphName : string, pattern : OrMath_expr, callback : (Tree<string, OrMath_expr>) -> void) -> int {
    // Get the graph from the registry
    matchCount = ref 0;
    
    // println("DEBUG: matchOGraphPattern - looking for pattern: " + prettyOrbit(pattern));
    
    switch (lookupTree(^ographRegistry, graphName)) {
        Some(graph): {
            // Strategy: Try to match the pattern starting at each node in the graph
            // println("DEBUG: Found graph, traversing nodes");
            traverseOGraph(graph, \nodeId, node -> {
                // println("DEBUG: Checking node ID: " + i2s(nodeId) + ", op: " + node.op);
                
                // Try to match the pattern at this node
                switch (matchPatternAtNode(graph, nodeId, pattern)) {
                    OPatternSuccess(bindings): {
                        // println("DEBUG: Found match at node ID: " + i2s(nodeId));
                        // Found a match, convert node IDs to expressions
                        exprBindings = convertBindingsToExpressions(graph, bindings);
                        
                        // Call the callback with the bindings
                        matchCount := ^matchCount + 1;
                        callback(exprBindings);
                    }
                    OPatternFailure(): {
                        // No match at this node, continue searching
                        // println("DEBUG: No match at node ID: " + i2s(nodeId));
                    }
                }
            });
            
            // println("DEBUG: Finished traversing graph, found " + i2s(^matchCount) + " matches");
            ^matchCount;
        }
        None(): {
            // println("ERROR: OGraph '" + graphName + "' not found");
            0;
        }
    }
}

// Convert bindings from node IDs to expressions
convertBindingsToExpressions(graph : OGraph, bindings : Tree<string, int>) -> Tree<string, OrMath_expr> {
    mapTree(bindings, \nodeId -> ograph2Orbit(graph, nodeId));
}

// Match a pattern at a specific node
matchPatternAtNode(graph : OGraph, nodeId : int, pattern : OrMath_expr) -> OPatternResult {
    root = findORoot(graph, nodeId);
    
    // println("DEBUG: matchPatternAtNode - pattern: " + prettyOrbit(pattern) + ", at node: " + i2s(root));
    
    switch (pattern) {
        // Pattern variable - should match ANY node and bind the variable to it
        // This is the key to pattern matching!
        OrIdentifier(id): {
            // In pattern matching, identifiers like x, y, z are treated as pattern variables
            // that can match any node (not just concrete identifiers)
            // println("DEBUG: Pattern variable " + id + " binds to node " + i2s(root));
            OPatternSuccess(makeTree1(id, root));
        }
        
        // Variable reference - match against specific variables
        OrVariable(id): {
            // For variables in expressions, check if the node represents the same variable
            switch (lookupOClass(graph, root)) {
                Some(oclass): {
                    // println("DEBUG: Matching variable " + id + " against node op " + oclass.node.op);
                    if (oclass.node.op == "Variable" || oclass.node.op == "Identifier") {
                        switch (getOClassString(graph, root)) {
                            Some(name): {
                                // println("DEBUG: Comparing variable name " + name + " with " + id);
                                if (name == id) {
                                    OPatternSuccess(makeTree());
                                } else {
                                    OPatternFailure();
                                }
                            }
                            None(): OPatternFailure();
                        }
                    } else {
                        OPatternFailure();
                    }
                }
                None(): OPatternFailure();
            }
        }
        
        // For literals, check if node represents the same value
        OrInt(i): {
            switch (lookupOClass(graph, root)) {
                Some(oclass): {
                    // println("DEBUG: Matching int " + i2s(i) + " against node op " + oclass.node.op);
                    if (oclass.node.op == "Int") {
                        switch (getOClassInt(graph, root)) {
                            Some(val): {
                                // println("DEBUG: Comparing int value " + i2s(val) + " with " + i2s(i));
                                if (val == i) OPatternSuccess(makeTree()) else OPatternFailure();
                            }
                            None(): OPatternFailure();
                        }
                    } else {
                        OPatternFailure();
                    }
                }
                None(): OPatternFailure();
            }
        }
        
        OrDouble(d): {
            switch (lookupOClass(graph, root)) {
                Some(oclass): {
                    // println("DEBUG: Matching double " + d2s(d) + " against node op " + oclass.node.op);
                    if (oclass.node.op == "Double") {
                        switch (getOClassDouble(graph, root)) {
                            Some(val): if (val == d) OPatternSuccess(makeTree()) else OPatternFailure();
                            None(): OPatternFailure();
                        }
                    } else {
                        OPatternFailure();
                    }
                }
                None(): OPatternFailure();
            }
        }
        
        OrString(s): {
            switch (lookupOClass(graph, root)) {
                Some(oclass): {
                    // println("DEBUG: Matching string \"" + s + "\" against node op " + oclass.node.op);
                    if (oclass.node.op == "String") {
                        switch (getOClassString(graph, root)) {
                            Some(val): if (val == s) OPatternSuccess(makeTree()) else OPatternFailure();
                            None(): OPatternFailure();
                        }
                    } else {
                        OPatternFailure();
                    }
                }
                None(): OPatternFailure();
            }
        }
        
        OrBool(b): {
            switch (lookupOClass(graph, root)) {
                Some(oclass): {
                    // println("DEBUG: Matching bool " + (if (b) "true" else "false") + " against node op " + oclass.node.op);
                    if (oclass.node.op == "Bool") {
                        switch (getOClassInt(graph, root)) {
                            Some(val): if ((val != 0) == b) OPatternSuccess(makeTree()) else OPatternFailure();
                            None(): OPatternFailure();
                        }
                    } else {
                        OPatternFailure();
                    }
                }
                None(): OPatternFailure();
            }
        }
        
        // For operations, match structure recursively
        OrAdd(a, b): {
            // println("DEBUG: Matching binary operation + with children");
            matchOperation(graph, root, "+", [a, b]);
        }
        OrSubtract(a, b): matchOperation(graph, root, "-", [a, b]);
        OrMultiply(a, b): {
            // println("DEBUG: Matching binary operation * with children");
            matchOperation(graph, root, "*", [a, b]);
        }
        OrDivide(a, b): matchOperation(graph, root, "/", [a, b]);
        
        // Comparison operations
        OrEquals(a, b): matchOperation(graph, root, "=", [a, b]);
        OrNotEquals(a, b): matchOperation(graph, root, "!=", [a, b]);
        OrGreaterThan(a, b): matchOperation(graph, root, ">", [a, b]);
        OrGreaterEquals(a, b): matchOperation(graph, root, ">=", [a, b]);
        OrLessThan(a, b): matchOperation(graph, root, "<", [a, b]);
        OrLessEquals(a, b): matchOperation(graph, root, "<=", [a, b]);
        
        // Logical operations
        OrLogicalAnd(a, b): matchOperation(graph, root, "&&", [a, b]);
        OrLogicalOr(a, b): matchOperation(graph, root, "||", [a, b]);
        OrLogicalNot(a): matchOperation(graph, root, "!", [a]);
        
        // Unary arithmetic
        OrNegate(a): matchOperation(graph, root, "negate", [a]);
        
        // Function calls
        OrFunction(fn, args): {
            // For function calls
            // println("DEBUG: Matching function call");
            matchOperation(graph, root, "call", concat([fn], args));
        }
        
        // Add more patterns as needed...
        
        default: OPatternFailure();
    }
}

// Match an operation pattern
matchOperation(graph : OGraph, nodeId : int, op : string, subpatterns : [OrMath_expr]) -> OPatternResult {
    // Check if this node has the right operator
    switch (lookupOClass(graph, nodeId)) {
        Some(oclass): {
            // println("DEBUG: Matching operation " + op + " against node op " + oclass.node.op + ". Children count: pattern=" + i2s(length(subpatterns)) + ", node=" + i2s(length(oclass.node.children)));
            if (oclass.node.op == op && length(oclass.node.children) == length(subpatterns)) {
                // Try to match all children
                // println("DEBUG: Operator matches, now checking children");
                matchAllChildren(graph, oclass.node.children, subpatterns, makeTree());
            } else {
                // println("DEBUG: Operation mismatch: expected " + op + ", got " + oclass.node.op);
                OPatternFailure();
            }
        }
        None(): OPatternFailure();
    }
}

// Match all children of an operation
matchAllChildren(graph : OGraph, childIds : [int], patterns : [OrMath_expr], 
                 bindings : Tree<string, int>) -> OPatternResult {
    if (length(childIds) == 0 && length(patterns) == 0) {
        // All children matched successfully
        // println("DEBUG: All children matched successfully. Final bindings: " + 
        //        superglue(getTreeKeys(bindings), \k -> k + ":" + i2s(lookupTreeDef(bindings, k, -1)), ", "));
        OPatternSuccess(bindings);
    } else if (length(childIds) == 0 || length(patterns) == 0) {
        // Mismatched number of children
        // println("DEBUG: Mismatched number of children. childIds=" + i2s(length(childIds)) + ", patterns=" + i2s(length(patterns)));
        OPatternFailure();
    } else {
        // Try to match the first child
        // println("DEBUG: Matching child " + i2s(childIds[0]) + " with pattern " + prettyOrbit(patterns[0]));
        switch (matchPatternAtNode(graph, childIds[0], patterns[0])) {
            OPatternSuccess(childBindings): {
                // println("DEBUG: Child match succeeded with bindings: " + 
                //        superglue(getTreeKeys(childBindings), \k -> k + ":" + i2s(lookupTreeDef(childBindings, k, -1)), ", "));
                // Merge bindings, ensuring consistency
                switch (mergeOBindings(graph, bindings, childBindings)) {
                    OPatternSuccess(mergedBindings): {
                        // println("DEBUG: Bindings merged successfully, continuing with remaining children");
                        // Continue with remaining children
                        matchAllChildren(graph, tail(childIds), tail(patterns), mergedBindings);
                    }
                    OPatternFailure(): {
                        // println("DEBUG: Bindings merge failed - inconsistent variable bindings");
                        OPatternFailure();
                    }
                }
            }
            OPatternFailure(): {
                // println("DEBUG: Child match failed");
                OPatternFailure();
            }
        }
    }
}

// Check if two nodes in the graph are semantically equivalent
nodeEquivalence(graph : OGraph, node1Id : int, node2Id : int) -> bool {
    // Get the canonical IDs
    root1 = findORoot(graph, node1Id);
    root2 = findORoot(graph, node2Id);
    
    // If they are the same node, they are equivalent
    if (root1 == root2) true
    else {
        // For our specific test case of "a + a", we need to check if both nodes
        // are identifiers with the same name
        node1 = switch (lookupOClass(graph, root1)) {
            Some(oclass): oclass.node;
            None(): ONode("", [], []);
        }
        
        node2 = switch (lookupOClass(graph, root2)) {
            Some(oclass): oclass.node;
            None(): ONode("", [], []);
        }
        
        // Check if both are identifiers
        if ((node1.op == "Identifier" || node1.op == "Variable") && 
            (node2.op == "Identifier" || node2.op == "Variable")) {
            
            // Get their names
            name1 = switch (getOClassString(graph, root1)) {
                Some(s): s;
                None(): "";
            }
            
            name2 = switch (getOClassString(graph, root2)) {
                Some(s): s;
                None(): "";
            }
            
            // Check if names match
            // println("DEBUG: Comparing identifiers '" + name1 + "' and '" + name2 + "'");
            name1 == name2 && name1 != ""
        } else {
            // For now, other nodes are equivalent only if they have the same ID
            root1 == root2
        }
    }
}

// Merge bindings, ensuring consistency (same variable bound to semantically equivalent nodes)
mergeOBindings(graph : OGraph, a : Tree<string, int>, b : Tree<string, int>) -> OPatternResult {
    result = fold(getTreeKeys(b), OPatternSuccess(a), \acc, key -> {
        switch (acc) {
            OPatternSuccess(bindings): {
                bValue = lookupTreeDef(b, key, -1);
                switch (lookupTree(bindings, key)) {
                    Some(aValue): {
                        // Variable already bound, must be consistent
                        // This is critical for patterns like x + x where the same variable appears multiple times
                        if (nodeEquivalence(graph, aValue, bValue)) {
                            // println("DEBUG: Consistent binding for " + key + ": already bound to " + i2s(aValue) + 
                            //        ", new node " + i2s(bValue) + " is equivalent");
                            OPatternSuccess(bindings);
                        } else {
                            // println("DEBUG: INCONSISTENT binding for " + key + ": previous=" + i2s(aValue) + 
                            //        ", new=" + i2s(bValue) + " are not equivalent");
                            OPatternFailure();
                        }
                    }
                    None(): {
                        // New binding
                        // println("DEBUG: New binding: " + key + " = " + i2s(bValue));
                        OPatternSuccess(setTree(bindings, key, bValue));
                    }
                }
            }
            OPatternFailure(): OPatternFailure();
        }
    });
    
    result;
}