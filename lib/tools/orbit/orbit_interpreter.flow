import tools/orbit/orbit2core;
import tools/orbit/orbit_env;
import tools/orbit/prettyprint;
import tools/orbit/utils;
import tools/orbit/orbit_pattern;
import tools/runcore/core_lib;
import tools/runcore/value_util;
import ds/tree;
import ds/set;
import math/math;
import string;
import fs/filesystem;
import maybe;
import tools/orbit/orbit_ast;
import tools/orbit/ograph;
import tools/orbit/orbit_simple_ograph;

export {
	// Main interpreter function
	interpretOrbit(env : OrbEnv, expr : OrMath_expr) -> OrbEnv;
	// Closure registry for storing closures during execution
	closureRegistry : ref Tree<string, OrbClosure> = ref makeTree();
}

// Helper to register a closure and get its ID
registerClosure(closure : OrbClosure) -> string {
	id = "__closure::" + i2s(sizeTree(^closureRegistry));
	closureRegistry := setTree(^closureRegistry, id, closure);
	id; // Last expression is the return value
}

// Helper to get a closure from the registry
getClosureFromRegistry(id : string) -> Maybe<OrbClosure> {
	lookupTree(^closureRegistry, id);
}

// Helper function to perform CoreLib operations and convert types
performCoreBinOperation(env : OrbEnv, a : OrMath_expr, b : OrMath_expr, operation : (CoreValue, CoreValue) -> CoreValue) -> OrbEnv {
	// Convert orbit expressions to CoreValues
	aCore = orbit2CoreValue(a);
	bCore = orbit2CoreValue(b);
	
	// Perform the operation using CoreLib
	resultCore = operation(aCore, bCore);
	
	// Convert back to OrMath_expr
	OrbEnv(env with result = coreValue2Orbit(resultCore));
}


// Helper function to perform CoreLib operations and convert types
performCoreUnOperation(env : OrbEnv, a : OrMath_expr, operation : (CoreValue) -> CoreValue) -> OrbEnv {
	// Convert orbit expressions to CoreValues
	aCore = orbit2CoreValue(a);
	
	// Perform the operation using CoreLib
	resultCore = operation(aCore);
	
	// Convert back to OrMath_expr
	OrbEnv(env with result = coreValue2Orbit(resultCore));
}

// Attempt to call a function from RunCore
callRunCoreFunction(env : OrbEnv, id : string, args : [OrMath_expr]) -> Maybe<OrbEnv> {
    // Special case for prettyOrbit function which isn't in RunCore
    if (id == "prettyOrbit" && length(args) == 1) {
        // Convert the AST to a string and return
        pretty = prettyOrbit(args[0]);
        Some(OrbEnv(env with result = OrString(pretty)));
    } else if (isCoreDefined(env.runCore, id)) {
        // Convert orbit args to CoreValues
        coreArgs = map(args, orbit2CoreValue);
        
        // Call the RunCore function
        switch (evalCoreFn(env.runCore, id, coreArgs)) {
            Some(result): {
                // Convert result back to orbit expression
                Some(OrbEnv(env with result = coreValue2Orbit(result)));
            }
            None(): None();
        }
    } else {
        None();
    }
}

// Evaluate a function call with the given arguments
callFunction(env : OrbEnv, fn : OrMath_expr, args : [OrMath_expr]) -> OrbEnv {
	// First determine if we need to lazily evaluate any arguments
	paramTypes = switch (fn) {
		OrLambda(__, params, __): params;
		OrVariable(id): {
			// Check if this is a closure reference
			if (strContains(id, "__closure::")) {
				switch (getClosureFromRegistry(id)) {
					Some(closure): closure.params;
					None(): [];
				};
			} else {
				[];
			}
		}
		default: [];
	};
	
	// Process arguments - either evaluate them or keep as AST
	evaluatedArgs = foldi(args, [], \i, acc, arg -> {
		// Use the environment from the previous argument evaluation
		envArg = if (i == 0) env else OrbEnv(env with vars = acc[i-1].vars);
		
		// Check if this parameter should be lazily evaluated
		lazyEval = i < length(paramTypes) && isAstType(paramTypes[i].type_annotations);
		
		// If lazy evaluation, just wrap the argument, otherwise evaluate it
		resEnv = if (lazyEval) {
			OrbEnv(envArg with result = arg);
		} else {
			interpretOrbit(envArg, arg);
		};
		
		arrayPush(acc, resEnv);
	});
	
	// Extract argument values
	argValues = map(evaluatedArgs, \argEnv -> argEnv.result);
	
	// Get the environment after evaluating all arguments
	finalArgEnv = if (length(evaluatedArgs) > 0) lastElement(evaluatedArgs, env) else env;
	
	// Handle the function based on its type
	switch (fn) {
		OrVariable(id): {
			// First check if this function is defined in RunCore
			switch (callRunCoreFunction(finalArgEnv, id, argValues)) {
				Some(resultEnv): resultEnv;
				None(): {
					// If not in RunCore, check if this is a closure reference
					if (strContains(id, "__closure::")) {
						switch (getClosureFromRegistry(id)) {
							Some(closure): {
								// Create new environment with captured variables
								callEnv = OrbEnv(finalArgEnv with vars = closure.capturedEnv);
								
								// Bind arguments to parameters
								boundEnv = foldi(args, callEnv, \i, accEnv, __ -> {
									if (i < length(closure.params) && i < length(argValues)) {
										// Get parameter name and argument value
										paramName = closure.params[i].id;
										argValue = argValues[i];
										
										// Bind parameter to argument value
										bindVar(accEnv, paramName, argValue);
									} else {
										// If we have more or fewer arguments than parameters, just continue
										accEnv;
									}
								});
								
								// Evaluate the function body in the new environment
								interpretOrbit(boundEnv, closure.body);
							}
							None(): {
								// Closure not found in registry
								println("Closure not found: " + id);
								finalArgEnv;
							}
						}
					} else {
						// Not a closure reference or RunCore function
						println("Cannot call non-function value: " + prettyOrbit(fn));
						finalArgEnv;
					}
				}
			}
		}
		
		OrLambda(bindings, params, body): {
			// First convert the lambda to a closure (captures environment)
			closureEnv = interpretOrbit(finalArgEnv, fn);
			
			// Then call the closure
			callFunction(closureEnv, closureEnv.result, args);
		}
		
		default: {
			// Not a callable expression
			println("Cannot call non-function value: " + prettyOrbit(fn));
			finalArgEnv;
		}
	}
}

// Main interpreter function
interpretOrbit(env : OrbEnv, expr : OrMath_expr) -> OrbEnv {
	todo = \ -> {
		println("TODO: Interpret " + expr.structname + ": " + prettyOrbit(expr));
		env
	};
	ret = \v -> OrbEnv(env with result = v);
	// Handle each expression type
	switch (expr) {
		OrInt(i): ret(expr);
		OrDouble(d): ret(expr);
		OrString(s): ret(expr);
		OrBool(b): ret(expr);
		
		OrIdentifier(id): {
			switch (lookupVar(env, id)) {
				Some(value): ret(value);
				None(): {
					// Check if it's a RunCore function name
					if (isCoreDefined(env.runCore, id)) {
						// Return a variable with the same name - will be resolved when called
						ret(OrVariable(id));
					} else {
						println("Variable not found: " + id);
						ret(OrInt(0));
					}
				}
			}
		}
		OrVariable(uid): {
			switch (lookupVar(env, uid)) {
				Some(value): ret(value);
				None(): {
					// Check if it's a direct closure reference
					if (strContains(uid, "__closure::")) {
						// It's already a closure reference, return as is
						ret(expr);
					} else {
						println("Variable not found: " + uid);
						ret(OrInt(0));
					}
				}
			}
		} 
		
		OrAdd(a, b): {
			envA = interpretOrbit(env, a);
			envB = interpretOrbit(envA, b);
			performCoreBinOperation(env, envA.result, envB.result, addValue);
		}
		
		OrSubtract(a, b): {
			envA = interpretOrbit(env, a);
			envB = interpretOrbit(envA, b);
			performCoreBinOperation(env, envA.result, envB.result, minusValue);
		}
		
		OrMultiply(a, b): {
			envA = interpretOrbit(env, a);
			envB = interpretOrbit(envA, b);
			performCoreBinOperation(env, envA.result, envB.result, mulValue);
		}
		
		OrDivide(a, b): {
			envA = interpretOrbit(env, a);
			envB = interpretOrbit(envA, b);
			performCoreBinOperation(env, envA.result, envB.result, divideValue);
		}
		OrNegate(a): {
			envA = interpretOrbit(env, a);
			performCoreBinOperation(env, OrInt(-1), envA.result, mulValue);
		}
		OrEquals(a, b): {
			envA = interpretOrbit(env, a);
			envB = interpretOrbit(envA, b);
			performCoreBinOperation(env, envA.result, envB.result, eqValue);
		}
		OrGreaterEquals(a, b): {
			envA = interpretOrbit(env, a);
			envB = interpretOrbit(envA, b);
			performCoreBinOperation(env, envA.result, envB.result, geValue);
		}
		OrGreaterThan(a, b): {
			envA = interpretOrbit(env, a);
			envB = interpretOrbit(envA, b);
			performCoreBinOperation(env, envA.result, envB.result, gtValue);
		}
		OrLessEquals(a, b): {
			envA = interpretOrbit(env, a);
			envB = interpretOrbit(envA, b);
			performCoreBinOperation(env, envA.result, envB.result, leValue);
		}
		OrLessThan(a, b): {
			envA = interpretOrbit(env, a);
			envB = interpretOrbit(envA, b);
			performCoreBinOperation(env, envA.result, envB.result, ltValue);
		}
		OrNotEquals(a, b): {
			envA = interpretOrbit(env, a);
			envB = interpretOrbit(envA, b);
			performCoreBinOperation(env, envA.result, envB.result, neqValue);
		}
		OrLogicalAnd(a, b): {
			envA = interpretOrbit(env, a);
			envB = interpretOrbit(envA, b);
			performCoreBinOperation(env, envA.result, envB.result, andValue);
		} 
		OrLogicalNot(a): {
			envA = interpretOrbit(env, a);
			performCoreUnOperation(env, envA.result, notValue);
		}
		OrLogicalOr(a, b): {
			envA = interpretOrbit(env, a);
			envB = interpretOrbit(envA, b);
			performCoreBinOperation(env, envA.result, envB.result, orValue);
		}

		OrLet(idType, val): {
			varName = idType.id;
			envVal = interpretOrbit(env, val);
			// Create new environment with the binding
			bindVar(env, varName, envVal.result);
		}
		OrFnDef(id, id_types, type_annotations, math_expr): {
			// Create a new function definition
			// Safe to skip bindings for top-level.
			fnDef = OrLambda([], id_types, math_expr);
			// Bind the function to the environment
			bindVar(env, id, fnDef);
		}
		
		OrIfElse(cond, thenExpr, elseExpr): {
			envCond = interpretOrbit(env, cond);
			// Convert to CoreValue to evaluate condition
			condCore = orbit2CoreValue(envCond.result);
			condValue = switch (condCore) {
				CoreBool(b): b;
				CoreInt(i): i != 0;
				CoreDouble(d): d != 0.0;
				CoreString(s): s != "";
				default: false;
			};
			
			if (condValue) {
				interpretOrbit(envCond, thenExpr);
			} else {
				interpretOrbit(envCond, elseExpr);
			}
		}
		OrSequence(a, b): {
			env1 = interpretOrbit(env, a);
			// The result of the first expression is discarded
			interpretOrbit(env1, b);
		}
		
		OrFunction(fnExpr, argExprs): {
			// Check if this is a constructor call (starts with uppercase)
			if (isConstructor(expr)) {
				// For constructors, we just evaluate the arguments and keep the constructor as is
				evaluatedArgs = map(argExprs, \arg -> {
					interpretOrbit(env, arg).result;
				});
				ret(OrFunction(fnExpr, evaluatedArgs));
			} else {
				// Direct function name in RunCore?
				switch (fnExpr) {
					OrIdentifier(id): {
						// Special case for eval function
						if (id == "eval" && length(argExprs) == 1) {
							// Directly evaluate the expression without converting to CoreValue
							interpretOrbit(env, argExprs[0]);
						}
						
// Special cases for ograph functions
				else if (id == "makeOGraph" && length(argExprs) == 1) {
					// Get the graph name
					envName = interpretOrbit(env, argExprs[0]);
					name = getOString(envName.result, "makeOGraph");
					
					// Create a new ograph
					graphName = createOGraph(name);
					
					// Return the name
					OrbEnv(envName with result = OrString(graphName));
				}
				else if (id == "addNodeToOGraph" && length(argExprs) >= 3) {
					// Get the graph name
					envName = interpretOrbit(env, argExprs[0]);
					name = getOString(envName.result, "addNodeToOGraph.name");
					
					// Get the domain
					envDomain = interpretOrbit(envName, argExprs[1]);
					domain = getOString(envDomain.result, "addNodeToOGraph.domain");
					
					// Get the expression (not evaluated - passed as AST)
					astExpr = argExprs[2];
					
					// Debug the AST expression
					println("Adding AST expression to ograph: " + prettyOrbit(astExpr));
					
					// Add the node to the graph
					nodeId = addNodeToOGraph(name, domain, astExpr);
					OrbEnv(envDomain with result = OrInt(nodeId));
				}
				else if (id == "addDomainToNode" && length(argExprs) == 3) {
					// Get the graph name
					envName = interpretOrbit(env, argExprs[0]);
					name = getOString(envName.result, "addDomainToNode.name");
					
					// Get the node ID
					envNodeId = interpretOrbit(envName, argExprs[1]);
					nodeId = getOInt(envNodeId.result, "addDomainToNode.nodeId");
					
					// Get the domain
					envDomain = interpretOrbit(envNodeId, argExprs[2]);
					domain = getOString(envDomain.result, "addDomainToNode.domain");
					
					// Add the domain to the node
					success = addDomainToNode(name, nodeId, domain);
					OrbEnv(envDomain with result = OrBool(success));
				}
				else if (id == "mergeOGraphNodes" && length(argExprs) == 3) {
					// Get the graph name
					envName = interpretOrbit(env, argExprs[0]);
					name = getOString(envName.result, "mergeOGraphNodes.name");
					
					// Get the first node ID
					envId1 = interpretOrbit(envName, argExprs[1]);
					id1 = getOInt(envId1.result, "mergeOGraphNodes.id1");
					
					// Get the second node ID
					envId2 = interpretOrbit(envId1, argExprs[2]);
					id2 = getOInt(envId2.result, "mergeOGraphNodes.id2");
					
					// Merge the nodes
					success = mergeOGraphNodes(name, id1, id2);
					OrbEnv(envId2 with result = OrBool(success));
				}
				else if (id == "extractOGraphNode" && length(argExprs) == 2) {
					// Get the graph name
					envName = interpretOrbit(env, argExprs[0]);
					name = getOString(envName.result, "extractOGraphNode.name");
					
					// Get the node ID
					envNodeId = interpretOrbit(envName, argExprs[1]);
					nodeId = getOInt(envNodeId.result, "extractOGraphNode.nodeId");
					
					// Extract the node
					extractedExpr = extractOGraphNode(name, nodeId);
					OrbEnv(envNodeId with result = extractedExpr);
				}
				else if (id == "printOGraph" && length(argExprs) == 1) {
					// Get the graph name
					envName = interpretOrbit(env, argExprs[0]);
					name = getOString(envName.result, "printOGraph.name");
					
					// Print the graph
					str = printOGraph(name);
					println("OGraph '" + name + "':\n" + str);
					OrbEnv(envName with result = OrString(str));
				}
						else {
							// Evaluate arguments first
							evaluatedArgs = map(argExprs, \arg -> {
								interpretOrbit(env, arg).result;
							});
							
							// Try to call from RunCore
							switch (callRunCoreFunction(env, id, evaluatedArgs)) {
								Some(resultEnv): resultEnv;
								None(): {
									// Not in RunCore, proceed with normal function evaluation
									envFn = interpretOrbit(env, fnExpr);
									callFunction(envFn, envFn.result, argExprs);
								}
							}
						}
					}
					default: {
						// Evaluate the function expression
						envFn = interpretOrbit(env, fnExpr);
						
						// Call the function with arguments
						callFunction(envFn, envFn.result, argExprs);
					}
				}
			}
		}
		
		OrLambda(bindings, params, body): {
			// Create capture environment with all free variables from the current scope
			// For now, we'll just capture all variables from the current environment
			// In the future, we can optimize to only capture what's needed
			capturedEnv = env.vars;
			
			// Process explicit environment bindings
			bindingsEnv = fold(bindings, makeTree(), \acc, binding -> {
				// Evaluate the binding expression in the current environment
				bindingResult = interpretOrbit(env, binding.math_expr).result;
				setTree(acc, binding.id, bindingResult);
			});
			
			// Create the runtime closure object and register it
			closure = OrbClosure(mergeTree(capturedEnv, bindingsEnv), params, body);
			closureId = registerClosure(closure);
			
			// Return a variable referring to the closure
			ret(OrVariable(closureId));
		}
		
		OrCompose(math_expr1, math_expr2): todo();
		OrDirectProduct(math_expr1, math_expr2): todo();
		OrElementOf(math_expr1, math_expr2): todo();
		OrEntailment(math_expr1, math_expr2, conditionals): todo();
		OrEquivalence(math_expr1, math_expr2, conditionals): todo();
		OrExists(math_exprs, math_expr): todo();
		OrExponent(math_expr1, math_expr2): todo();
		OrField(math_expr, id): todo();
		OrForall(math_exprs, math_expr): todo();
		OrGreekLetter(greek_letter): todo();
		OrIntersection(math_expr1, math_expr2): todo();
		OrMatch(matchExpr, patterns): {
			// First evaluate the expression to match
			envMatch = interpretOrbit(env, matchExpr);
			exprValue = envMatch.result;
			
			// Execute pattern matching
			resultEnv = executeMatch(envMatch, exprValue, patterns);
			
			// Evaluate the result expression in the updated environment
			interpretOrbit(resultEnv, resultEnv.result);
		}
		OrRule(math_expr1, math_expr2, conditionals): todo();
		OrSetComprehension(math_exprs, math_expr): todo();
		OrSetLiteral(math_exprs): todo();
		OrSubscript(math_expr, subscript): todo();
		OrSubset(math_expr1, math_expr2): todo();
		OrSuperscript(math_expr, superscript): todo();
		OrFunctionType(math_expr1, math_expr2): todo();
		OrTypeAnnotation(math_expr1, math_expr2): todo();
		OrTypeSubstitution(math_expr1, math_expr2, math_expr3): todo();
		OrTypeVar(string1): todo();
		OrUnion(math_expr1, math_expr2): todo();
	}
}