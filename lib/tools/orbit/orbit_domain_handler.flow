import tools/orbit/orbit_types;
import tools/orbit/orbit_env;
import tools/orbit/orbit_simple_ograph;
import tools/orbit/ograph;
import tools/orbit/orbit2ograph;
import tools/orbit/orbit_decompose;
import tools/orbit/prettyprint;
import tools/orbit/orbit_compare;
import string;
import ds/set;

export {
    // Process domain annotations for a specific eclass and its children
    processDomainAnnotationsFromEclass(graphName : string, eclassId : int) -> bool;
}

// Process a domain annotation directly in the ograph
// annotationId should point to a node representing a type annotation (a : B)
// Returns the canonical id of the base node after processing
processDomainAnnotation(graph : OGraph, annotationId : int) -> int {
    // Get the canonical ID for the annotation node
    rootId = findORoot(graph, annotationId);
    
    // Get the node from the graph
    switch (lookupOClass(graph, rootId)) {
        Some(oclass): {
            // Check if this is a type annotation node (should have operator "TypeAnnotation" and 2 children)
            if (oclass.node.op == "TypeAnnotation" && length(oclass.node.children) == 2) {
                // Extract base expression and domain
                baseExprId = oclass.node.children[0];
                domainId = oclass.node.children[1];
                
                println("Processing domain annotation: node " + i2s(baseExprId) + " : " + i2s(domainId));
                
                // Add the domain to the base expression's belongsTo list
                addBelongsToONode(graph, baseExprId, domainId);
                
                // Merge the annotation node (a : B) with the base expression (a)
                // to make them equivalent for canonicalization
                mergeOClasses(graph, baseExprId, rootId);
                
                // Return the canonical ID (which should be the base expression after merging)
                findORoot(graph, baseExprId);
            } else {
                // Not a type annotation node
                println("Node " + i2s(rootId) + " is not a type annotation");
                rootId;
            }
        }
        None(): {
            println("ERROR: Node with ID " + i2s(rootId) + " not found in graph");
            rootId;
        }
    }
}

// Process domain annotations starting from a specific eclass
// This traverses the graph starting from the given eclass and processes any domain annotations found
processDomainAnnotationsFromEclass(graphName : string, eclassId : int) -> bool {
    switch (lookupTree(^ographRegistry, graphName)) {
        Some(graph): {
            // Find all type annotation nodes starting from the given eclass
            println("Processing domain annotations from eclass: " + i2s(eclassId));
            
            // Keep track of nodes we've visited (to avoid cycles)
            visited = ref makeSet();
            
            // Use ref for recursive function
            processNodeFn = ref nop1;
            processNodeFn := \nodeId -> {
                // Skip if already visited
                if (containsSet(^visited, nodeId)) {
                    {}
                } else {
                    // Mark as visited
                    visited := insertSet(^visited, nodeId);
                    
                    // Get the canonical ID and node
                    rootId = findORoot(graph, nodeId);
                    switch (lookupOClass(graph, rootId)) {
                        Some(oclass): {
                            // Check if this is a type annotation
                            if (oclass.node.op == "TypeAnnotation" && length(oclass.node.children) == 2) {
                                println("Found type annotation node: " + i2s(rootId));
                                // Process this annotation and ignore the return value
                                __ = processDomainAnnotation(graph, rootId);
                                {};
                            } else {
                                {};
                            }
                            
                            // Recursively process all children
                            iter(oclass.node.children, ^processNodeFn);
                        }
                        None(): {}
                    }
                }
            };
            
            // Start processing from the given eclass
            (^processNodeFn)(eclassId);
            println("Finished processing domain annotations from eclass: " + i2s(eclassId));
			true;
        }
        None(): {
            println("ERROR: OGraph '" + graphName + "' not found");
			false;
        }
    }
}