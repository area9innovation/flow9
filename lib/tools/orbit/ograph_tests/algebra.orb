// https://alistairsavage.ca/mat1362/notes/MAT1362-Mathematical_reasoning_and_proofs.pdf

// === Chapter 1: Integers ===

// Domain Definition
// Implicitly, we assume a base domain 'Integer'

// --- 1.1 Axioms ---

// Axiom 1.1 (Commutativity, Associativity, Distributivity)
a + b : Integer ↔ b + a : Integer : S₂  // Commutativity of Addition
(a + b) + c : Integer ↔ a + (b + c) : Integer : A // Associativity of Addition
a * (b + c) : Integer → (a * b) + (a * c) : Integer // Distributivity (Left)
// Prop 1.6 covers right distributivity: (a + b) * c → a*c + b*c
a * b : Integer ↔ b * a : Integer : S₂ // Commutativity of Multiplication
(a * b) * c : Integer ↔ a * (b * c) : Integer : A // Associativity of Multiplication

// Axiom 1.2 (Additive Identity)
a + 0 : Integer → a : Integer
0 + a : Integer → a : Integer // Follows from Prop 1.7 & Commutativity

// Axiom 1.3 (Multiplicative Identity)
a * 1 : Integer → a : Integer
1 * a : Integer → a : Integer // Follows from Prop 1.7 & Commutativity
// Constraint: 1 != 0 (Property, not a rewrite rule)

// Axiom 1.4 (Additive Inverse)
a + (-a) : Integer → 0 : Integer
(-a) + a : Integer → 0 : Integer // Follows from Prop 1.8 & Commutativity

// Axiom 1.5 (Cancellation)
// This is tricky as a direct rewrite rule. It's a property about equality.
// Maybe representable conditionally if equality is a term:
// eq(a*b, a*c) : Integer → eq(b, c) : Integer if neq(a, 0)
// Or handled implicitly by the system's congruence.

// --- 1.2 First consequences ---

// Prop 1.6 (Right Distributivity)
(a + b) * c : Integer → (a * c) + (b * c) : Integer

// Prop 1.10 (Uniqueness of Additive Inverse)
// Property, not a rewrite rule. Ensures '-a' is well-defined.

// Prop 1.11 (Various Associativity/Distributivity combinations)
// These are derivable from Axiom 1.1, potentially useful shortcuts.
// (a+b)*(c+d) → (ac + bc) + (ad + bd) // (i)
// a(b+(c+d)) → (ab + ac) + ad // (v) - combines distributivity & associativity

// Prop 1.12, 1.13 (Uniqueness of Additive Identity)
// Properties, not rewrite rules.

// Prop 1.14 (Multiplication by Zero)
a * 0 : Integer → 0 : Integer
0 * a : Integer → 0 : Integer

// Prop 1.15 (Closure of Even numbers)
// Requires 'Even' domain or predicate.
// a:Even, b:Even → a+b : Even
// a:Even, b:Even → a*b : Even
// Definition: n : Even ↔ exists k:Integer . eq(n, 2*k)

// Prop 1.19 (Negative Multiplication 1)
(-a) * b : Integer ↔ -(a*b) : Integer
a * (-b) : Integer ↔ -(a*b) : Integer // Prop 1.24(iii)

// Prop 1.20 (Double Negation)
-(-a) : Integer → a : Integer
-0 : Integer → 0 : Integer

// Prop 1.21 (Negative Multiplication 2)
(-a) * (-b) : Integer ↔ a * b : Integer
(-1) * (-1) : Integer → 1 : Integer // Specific instance

// Prop 1.22 (Existence/Uniqueness of Subtraction Result)
// Property related to solving a+c=b, ensures 'b-a' is well-defined.

// Prop 1.23 (Idempotents)
// eq(a*a, a) : Integer → eq(a, 0) or eq(a, 1) // Requires logic/equality representation

// Prop 1.24 (Properties of Negation)
-(a + b) : Integer ↔ (-a) + (-b) : Integer
-a : Integer ↔ (-1) * a : Integer

// Prop 1.26 (Zero Product Property)
// eq(a*b, 0) : Integer → eq(a, 0) or eq(b, 0) // Requires logic/equality representation

// --- 1.3 Subtraction ---

// Def 1.27 (Subtraction)
a - b : Integer ↔ a + (-b) : Integer

// Prop 1.28 (Properties of Subtraction)
// These can be derived using Def 1.27 and properties of +,-,*. E.g.:
// (a-b)*c → ac - bc // (v)


// === Chapter 2: Natural Numbers and Induction ===

// Domain Definitions
// Natural ⊂ Integer

// --- 2.1 Natural numbers ---

// Axiom 2.1 (Properties of N)
// (i) Closure under Addition
a:Natural, b:Natural → a+b : Natural
// (ii) Closure under Multiplication
a:Natural, b:Natural → a*b : Natural
// (iii) 0 not in N
// 0 !: Natural // Constraint/Property
// (iv) Trichotomy
// a:Integer → a:Natural or eq(a, 0) or -a:Natural // Property, difficult to rewrite

// --- 2.2 Ordering the integers ---

// Definition 2.5 (Order)
// Requires relation 'lt' (less than) or 'gt' (greater than).
// lt(a, b) ↔ b - a : Natural
// gt(b, a) ↔ b - a : Natural
// le(a, b) ↔ lt(a, b) or eq(a, b)
// ge(b, a) ↔ gt(b, a) or eq(b, a)
// Representing these relations and reasoning with them is beyond basic term rewriting.

// Propositions 2.6 - 2.10, 2.14 involve inequalities.

// Prop 2.11 (Square of Non-Zero is Positive)
a:Integer, neq(a, 0) → a*a : Natural

// Prop 2.13 (Divisibility implies positive divisor)
// a:Natural, b:Integer, divides(a, b*a) → b : Natural // Requires divides predicate

// Prop 2.15 (Equivalence of N definition)
// n:Natural ↔ n:Integer and gt(n, 0) // Requires relations

// --- 2.3 Induction ---
// Axiom 2.17 (Induction Axiom) & Thm 2.19, 2.26 (Induction Principle)
// These are proof principles for reasoning *about* the domain Natural/Integer, not term rewrite rules.

// Thm 2.21 (Naturals >= 1)
// Property: a:Natural → ge(a, 1)

// Thm 2.22 (No integer between 0 and 1)
// Property: not exists a:Integer . (gt(a,0) and lt(a,1))

// Prop 2.24 (Divisor <= Dividend for Naturals)
// Property: a:Natural, b:Natural, divides(b, a) → le(b, a)

// --- 2.4 Well-ordering ---
// Thm 2.33 (Well-ordering principle)
// Property of Natural, not a rewrite rule.

// Def 2.36 (gcd)
// Defines a function gcd(a, b). Rules would be about its properties (see Ch 6).


// === Chapter 3: Logic ===
// This chapter describes the meta-language of proofs.
// If rewriting logical formulas themselves:
// not(not P) → P
// not(P or Q) ↔ (not P) and (not Q)
// not(P and Q) ↔ (not P) or (not Q)
// (P implies Q) ↔ (not P) or Q
// not(forall x. P(x)) ↔ exists x. not(P(x))
// not(exists x. P(x)) ↔ forall x. not(P(x))


// === Chapter 4: Finite Series and Strong Induction ===

// --- 4.1 Preliminaries ---
// Sequence definitions are meta-level. Factorial function:
fact(0) → 1
fact(n) → n * fact(n - 1) if n > 0 : Natural // Recursive definition

// Summation/Product notation needs functions: sum(var, lower, upper, expr), product(...)
// Properties from 4.2 could become rules for these functions.

// --- 4.2 Finite series ---
// Prop 4.4 (Sum of first n integers/squares)
sum(j, 1, n, j) → n*(n+1)/2 // Requires division / Rational domain potentially
sum(j, 1, n, j*j) → n*(n+1)*(2*n+1)/6

// Prop 4.5 (Geometric Series)
sum(j, 0, n, pow(x, j)) → (1 - pow(x, n+1)) / (1 - x) if neq(x, 1)

// Prop 4.6 (Sum properties)
sum(j, m, M, c * term(j)) ↔ c * sum(j, m, M, term(j))
sum(j, 1, n, c) → n * c

// Prop 4.7 (Sum properties)
sum(j, a, c, term(j)) ↔ sum(j, a, b, term(j)) + sum(j, b+1, c, term(j)) if a <= b < c
sum(j, a, b, t1(j) + t2(j)) ↔ sum(j, a, b, t1(j)) + sum(j, a, b, t2(j))

// Prop 4.8 (Index Shift)
sum(j, m, M, term(j)) ↔ sum(k, m+r, M+r, term(k-r)) // Using k=j+r

// --- 4.3 The Binomial Theorem ---
// Binomial coefficient function choose(k, m)
choose(k, m) → fact(k) / (fact(m) * fact(k-m)) if 0 <= m <= k : Natural
// Prop 4.11 (Pascal's Identity)
choose(n+1, m) → choose(n, m-1) + choose(n, m) if 1 <= m <= n
// Thm 4.12 (Binomial Theorem)
pow(a+b, k) ↔ sum(m, 0, k, choose(k, m) * pow(a, m) * pow(b, k-m))
// Cor 4.13
sum(m, 0, k, choose(k, m)) → pow(2, k)

// --- 4.4 Strong Induction ---
// Proof principle, not a rewrite rule.


// === Chapter 5: Naive Set Theory ===

// Domain: Set
// Operations: union(A,B), intersect(A,B), difference(A,B), complement(A,X), cartesian_product(A,B)
// Relations: subset(A,B), element(x,A)

// --- 5.1 Subsets and equality ---
// Properties of subset relation (reflexive, transitive).
// Equality definition: eq(A, B) ↔ subset(A, B) and subset(B, A)

// --- 5.2 Intersections and unions ---
// Definitions via elementhood (require logic/predicates).
// Properties:
union(A, B) : Set ↔ union(B, A) : Set : S₂
intersect(A, B) : Set ↔ intersect(B, A) : Set : S₂
union(union(A, B), C) : Set ↔ union(A, union(B, C)) : Set : A
intersect(intersect(A, B), C) : Set ↔ intersect(A, intersect(B, C)) : Set : A

// Thm 5.9 (De Morgan's Laws for Sets)
complement(intersect(A, B), X) ↔ union(complement(A, X), complement(B, X))
complement(union(A, B), X) ↔ intersect(complement(A, X), complement(B, X))

// Props 5.11, 5.12 (Distributivity)
intersect(C, union(A, B)) ↔ union(intersect(C, A), intersect(C, B))
union(C, intersect(A, B)) ↔ intersect(union(C, A), union(C, B))

// Difference/Complement definitions
// difference(A, B) = {x : element(x,A) and not element(x,B)}
// complement(A, X) = difference(X, A)
// symmetric_difference(A, B) = union(difference(A,B), difference(B,A))

// --- 5.3 Cartesian products ---
// Function: cartesian_product(A, B)
// Prop 5.19 (Distributivity over Union/Intersection)
cartesian_product(A, union(B, C)) ↔ union(cartesian_product(A, B), cartesian_product(A, C))
cartesian_product(A, intersect(B, C)) ↔ intersect(cartesian_product(A, B), cartesian_product(A, C))

// --- 5.4 Functions ---
// Domain: Function(DomainA, CodomainB)
// apply(f, x) function application
// composition: compose(g, f)
apply(compose(g, f), a) ↔ apply(g, apply(f, a))
// identity function: id(A)
compose(f, id(A)) → f
compose(id(B), f) → f

// --- 5.5 Russell's Paradox ---
// Meta-level issue about set definitions, not translatable to rules.


// === Chapter 6: Equivalence Relations and Modular Arithmetic ===

// Relations are hard to model directly. Focus on Modular Arithmetic.

// --- 6.3 The integers modulo n ---
// Domain: IntegerMod(n)
// Representation: class(a, n) or mod(a, n) for the canonical representative [0..n-1]
// Definition: eq(class(a,n), class(b,n)) ↔ divides(n, a-b)

// Canonical Representation Rule
class(a, n) : IntegerMod(n) → class(remainder(a, n), n) : IntegerMod(n) : Canonical

// Operations (using canonical reps implicitly or explicitly)
mod(a, n) + mod(b, n) : IntegerMod(n) → mod(a+b, n) : IntegerMod(n) // Using '+' for modular add
mod(a, n) * mod(b, n) : IntegerMod(n) → mod(a*b, n) : IntegerMod(n) // Using '*' for modular mul

// Prop 6.25 Properties (translated for mod(a,n) representation)
mod(a, n) + mod(b, n) ↔ mod(b, n) + mod(a, n) : S₂
(mod(a, n) + mod(b, n)) + mod(c, n) ↔ mod(a, n) + (mod(b, n) + mod(c, n)) : A
mod(a, n) * (mod(b, n) + mod(c, n)) → (mod(a, n)*mod(b, n)) + (mod(a, n)*mod(c, n))
mod(a, n) * mod(b, n) ↔ mod(b, n) * mod(a, n) : S₂
(mod(a, n) * mod(b, n)) * mod(c, n) ↔ mod(a, n) * (mod(b, n) * mod(c, n)) : A
mod(a, n) + mod(0, n) → mod(a, n)
mod(a, n) * mod(1, n) → mod(a, n)
mod(a, n) + mod(-a, n) → mod(0, n)

// --- 6.4 Prime numbers ---
// Domain: Prime ⊂ Natural
// Properties like Euclid's Lemma, Unique Factorization are meta-properties or require predicates.

// gcd function properties
gcd(a, b) ↔ gcd(b, a) : S₂
gcd(a, 0) → abs(a)
gcd(a, b) ↔ gcd(b, remainder(a, b)) if b != 0 // Euclidean Algorithm step
gcd(k*m, k*n) ↔ abs(k) * gcd(m, n)

// Thm 6.35 (Fermat's Little Theorem)
// pow(m, p) ≡ m mod p --> requires modular equivalence relation
pow_mod(m, p, p) → mod(m, p) if p : Prime // Rule for pow_mod function

// Cor 6.36
pow_mod(m, p-1, p) → mod(1, p) if p : Prime and not divides(p, m)


// === Chapter 7: Real Numbers ===

// Domain: Real
// PositiveReal ⊂ Real
// Rational ⊂ Real (Assuming Rational domain defined elsewhere)
// Integer ⊂ Rational (From Chapter 2)
// Natural ⊂ Integer (From Chapter 2)

// --- 7.1 Axioms ---
// Similar to Integer axioms, but with Real domain.
a + b : Real ↔ b + a : Real : S₂
(a + b) + c : Real ↔ a + (b + c) : Real : A
a * (b + c) : Real → (a * b) + (a * c) : Real
a * b : Real ↔ b * a : Real : S₂
(a * b) * c : Real ↔ a * (b * c) : Real : A
a + 0 : Real → a : Real
a * 1 : Real → a : Real
a + (-a) : Real → 0 : Real
// Axiom 7.5 (Multiplicative Inverse)
a * inv(a) : Real → 1 : Real if neq(a, 0)
a * (1 / a) : Real → 1 : Real if neq(a, 0) // Alternative notation
inv(inv(a)) : Real → a : Real if neq(a, 0) // From Cor 7.8
inv(1) : Real → 1 : Real
inv(x * y) : Real ↔ inv(x) * inv(y) : Real if neq(x,0), neq(y,0) // Prop 7.10

// --- Subtraction/Division ---
a - b : Real ↔ a + (-b) : Real
a / b : Real ↔ a * inv(b) : Real if neq(b, 0)

// Rules from Exercises (Examples)
(a / c) + (b / c) → (a + b) / c if neq(c, 0) // 7.1.1
(a / b) + (c / d) → (a*d + b*c) / (b*d) if neq(b,0), neq(d,0) // 7.1.2
inv(-x) → -inv(x) if neq(x, 0) // 7.1.3
-(a / b) ↔ (-a) / b ↔ a / (-b) if neq(b, 0) // 7.1.4

// --- 7.2 Positive real numbers and ordering ---
// Domain PositiveReal ⊂ Real
a:PositiveReal, b:PositiveReal → a+b : PositiveReal
a:PositiveReal, b:PositiveReal → a*b : PositiveReal
// 0 !: PositiveReal
// Trichotomy property: a:Real → a:PositiveReal or eq(a,0) or -a:PositiveReal

// Order definitions:
// lt(x, y) ↔ y - x : PositiveReal
// Inequalities are difficult for term rewriting.

// Prop 7.17 (Inverse of Positive is Positive)
x:PositiveReal → inv(x) : PositiveReal
// x:PositiveReal, y:PositiveReal, lt(x,y) → lt(inv(y), inv(x)) // Requires inequality

// --- 7.3 Real vs Integers ---
// Properties about density (Thm 7.21) or lack of smallest positive (Thm 7.20) are not rewrite rules.

// --- 7.4 Upper and lower bounds ---
// Concepts of sup, inf, max, min relate to sets of reals.
// Axiom 7.35 (Completeness) is a fundamental property of Real, not a rewrite rule. It ensures sup exists for bounded non-empty sets.


// === Chapter 8: Injections, Surjections, Bijections ===

// These are properties of functions.
// Domain: Function(A, B)
// Sub-domains: Injective(A,B), Surjective(A,B), Bijective(A,B)
// Injective(A,B) ⊂ Function(A,B)
// Surjective(A,B) ⊂ Function(A,B)
// Bijective(A,B) ⊂ Injective(A,B)
// Bijective(A,B) ⊂ Surjective(A,B)

// Prop 8.12 (Composition preserves properties)
f:Injective(A,B), g:Injective(B,C) → compose(g, f) : Injective(A,C)
f:Surjective(A,B), g:Surjective(B,C) → compose(g, f) : Surjective(A,C)
f:Bijective(A,B), g:Bijective(B,C) → compose(g, f) : Bijective(A,C)

// Prop 8.16/8.17 (Inverses)
// Need inverse function representation: inverse(f)
f:Bijective(A,B) → compose(inverse(f), f) = id(A)
f:Bijective(A,B) → compose(f, inverse(f)) = id(B)
// The existence of left/right inverses implies injectivity/surjectivity requires richer logic.

// --- 8.2 Embedding Z in R ---
// Defines a function e: Z -> R. Properties show it preserves structure.
// e(m+k) = e(m) + e(k)  -> homomorphism property
// e(m*k) = e(m) * e(k)  -> homomorphism property
// These justify treating Z as a subset of R via this embedding 'e'.


// === Chapter 9: Limits ===

// Function: limit(sequence_expr, var -> infinity)
// where sequence_expr uses var, e.g., limit(1/k, k -> infinity)

// --- Specific Limit Rules ---
// Prop 9.12
limit(1/k, k -> infinity) → 0
// Prop 9.26
limit(1/pow(k, l), k -> infinity) → 0 if l : Natural
// Prop 9.19
limit(pow(x, k), k -> infinity) → 0 if lt(abs(x), 1)

// --- Arithmetic of Limits (Prop 9.25) ---
limit(c, k -> infinity) → c // (i)
limit(c * ak_expr, k -> infinity) ↔ c * limit(ak_expr, k -> infinity) // (ii)
limit(ak_expr + bk_expr, k -> infinity) ↔ limit(ak_expr, k -> infinity) + limit(bk_expr, k -> infinity) // (iii)
limit(ak_expr * bk_expr, k -> infinity) ↔ limit(ak_expr, k -> infinity) * limit(bk_expr, k -> infinity) // (iv)
limit(1 / ak_expr, k -> infinity) ↔ 1 / limit(ak_expr, k -> infinity) if neq(limit(ak_expr, k -> infinity), 0) // (v)

// Prop 9.17 (Ignoring initial terms)
// limit(expr(k+r), k -> infinity) ↔ limit(expr(k), k -> infinity)

// Properties like Monotonic Convergence (Thm 9.21) or Boundedness (Prop 9.24) are meta-properties about sequences and convergence, not direct term rewrites for the limit function itself.

