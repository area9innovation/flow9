// TODO: We probably need more stuff

// Rewrite subtraction to addition for uniformity
u - v => u + (-1) * v;
a = b => a - b = 0;

// Associate and commute sums for GLex ordering
a + (b + c) => (a + b) + c;
(-1) * (-1) => 1;
a * x + b * x => (a + b) * x if is_number(a) && is_number(b);

// Reordering rules to force canonical GLex order
a * x + b * x² => b * x² + a * x if is_number(a) && is_number(b) && is_var(x);
a + b * x => b * x + a if is_number(a) && is_number(b) && is_var(x);
c + b * x + a * x² => a * x² + b * x + c if is_number(a) && is_number(b) && is_number(c) && is_var(x);

// Combine like constants
a + b => eval(a + b) if is_number(a) && is_number(b);
a * b => eval(a * b) if is_number(a) && is_number(b);

// Solve based on discriminant
a * x² + b * x + c = 0 =>
	x ∈ { (-b + sqrt(b² - 4 * a * c)) / (2 * a), (-b - sqrt(b² - 4 * a * c)) / (2 * a) }
	if is_number(a) && is_number(b) && is_number(c) && eval(b² - 4 * a * c) > 0 && is_var(x);

a * x² + b * x + c = 0 =>
	x ∈ { -b / (2 * a) } 
	if is_number(a) && is_number(b) && is_number(c) && eval(b² - 4 * a * c) = 0 && is_var(x);

a * x² + b * x + c = 0 =>
	x ∈ {}
	if is_number(a) && is_number(b) && is_number(c) && eval(b² - 4 * a * c) < 0 && is_var(x);

// Test cases:

1 + 2x + x^2 = 0
x + x^2 + 4= 0
4 + x^2 - 6x= 0
-6x + x^2 + 4= 0
x^2 + x = 2x^2 - 3x + 4
x^2 + x = 2x^2 - 3x + 4
3 + x = x^2 + x^2 + 5
x^2 + 2x = x^2 + 1
x + 1 = x^2 + 2x^2 + 1
2x^2 + 3 = x + x^2 + x^2 + 3
x = x^2 + x + 1
x^2 + x^2 = x + x
