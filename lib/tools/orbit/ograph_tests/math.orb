// Import necessary libraries (assuming they are accessible)
import lib/complex;
import lib/number_theory;
import lib/rewrite;

// Define mathematical constants and the imaginary unit
let pi = 3.141592653589793;
let i = Complex(0.0, 1.0); // Imaginary unit

// ----- Core Mathematical Identity Rules -----

let math_identity_rules = [
	// --- Basic Algebra Simplifications ---
	["div_one", quote(a / 1.0), quote(a), true],
	["div_self", quote(a / a), quote(1.0), eval(a != 0.0)], // Add condition a != 0
	["mul_inverse", quote(a * (1.0 / a)), quote(1.0), eval(a != 0.0)], // Add condition a != 0
	["distribute_mul_add", quote(a * (b + c)), quote((a * b) + (a * c)), true],
	["distribute_mul_sub", quote(a * (b - c)), quote((a * b) - (a * c)), true],
	// Commutativity/Associativity are often handled by Sâ‚‚/A annotations and canonicalization directly

	// --- Power and Logarithm Properties ---
	["pow_zero", quote(powC(a, 0.0)), quote(1.0), true], // a^0 = 1
	["pow_one", quote(powC(a, 1.0)), quote(a), true], // a^1 = a
	["one_pow", quote(powC(1.0, a)), quote(1.0), true], // 1^a = 1
	["pow_add_exp", quote(powC(a, b + c)), quote(powC(a, b) * powC(a, c)), true], // a^(b+c) = a^b * a^c
	["pow_mul_exp", quote(powC(a, b * c)), quote(powC(powC(a, b), c)), true], // a^(bc) = (a^b)^c
	["pow_mul_base", quote(powC(a * b, c)), quote(powC(a, c) * powC(b, c)), true], // (ab)^c = a^c * b^c
	["pow_div_base", quote(powC(a / b, c)), quote(powC(a, c) / powC(b, c)), eval(b != 0.0)], // (a/b)^c = a^c / b^c
	["pow_neg_exp", quote(powC(a, -b)), quote(1.0 / powC(a, b)), eval(a != 0.0)], // a^-b = 1 / a^b
	["exp_log_inverse", quote(expC(logC(a))), quote(a), true], // exp(log(a)) = a (Principal value)
	["log_exp_inverse", quote(logC(expC(a))), quote(a), true], // log(exp(a)) = a (Within principal branch +/- 2*pi*i)
	["log_one", quote(logC(1.0)), quote(0.0), true], // log(1) = 0
	["log_mul", quote(logC(a * b)), quote(logC(a) + logC(b)), true], // log(ab) = log(a)+log(b) (Principal values, modulo 2*pi*i)
	["log_div", quote(logC(a / b)), quote(logC(a) - logC(b)), eval(b != 0.0)], // log(a/b) = log(a)-log(b) (Principal values, modulo 2*pi*i)
	["log_pow", quote(logC(powC(a, b))), quote(b * logC(a)), true], // log(a^b) = b*log(a) (Principal values, modulo 2*pi*i)

	// --- Complex Number Basics ---
	["complex_add", quote(Complex(a, b) + Complex(c, d)), quote(Complex(a + c, b + d)), true],
	["complex_sub", quote(Complex(a, b) - Complex(c, d)), quote(Complex(a - c, b - d)), true],
	["complex_mul", quote(Complex(a, b) * Complex(c, d)), quote(Complex(a*c - b*d, a*d + b*c)), true],
	["i_squared", quote(i * i), quote(Complex(-1.0, 0.0)), true], // Explicitly Complex result for i^2 = -1
	["complex_conjugate", quote(conjugateC(Complex(a, b))), quote(Complex(a, -b)), true],
	["conjugate_add", quote(conjugateC(a + b)), quote(conjugateC(a) + conjugateC(b)), true],
	["conjugate_mul", quote(conjugateC(a * b)), quote(conjugateC(a) * conjugateC(b)), true],
	["conjugate_conjugate", quote(conjugateC(conjugateC(a))), quote(a), true],
	["complex_real_mul", quote(r * Complex(a, b)), quote(Complex(r*a, r*b)), isDouble(r)], // Scalar multiplication
	["complex_real_add", quote(r + Complex(a, b)), quote(Complex(r+a, b)), isDouble(r)], // Real + Complex
	["complex_zero", quote(Complex(0.0, 0.0)), quote(0.0), true], // Simplify complex zero to real zero
	["complex_magnitude_sq", quote(magnitudeC(z)^2), quote(z * conjugateC(z)), true], // |z|^2 = z * conj(z)
	["complex_real_check", quote(Complex(a, 0.0)), quote(a), true], // Simplify Complex(a, 0) to real 'a'

	// --- Euler's Formula and Connections ---
	["euler_formula", quote(expC(i * theta)), quote(Complex(cos(theta), sin(theta))), true],
	["euler_formula_neg", quote(expC(-i * theta)), quote(Complex(cos(theta), -sin(theta))), true], // exp(-i*theta) = cos(theta) - i*sin(theta)
	["cos_from_exp", quote(cos(theta)), quote((expC(i*theta) + expC(-i*theta)) / 2.0), true],
	["sin_from_exp", quote(sin(theta)), quote((expC(i*theta) - expC(-i*theta)) / (2.0*i)), true],
	["tan_from_exp", quote(tan(theta)), quote(i * (expC(-i*theta) - expC(i*theta)) / (expC(i*theta) + expC(-i*theta))), true],

	// --- Exponential Properties ---
	["exp_zero", quote(expC(0.0)), quote(Complex(1.0, 0.0)), true], // exp(0) = 1 (explicitly complex)
	["exp_add", quote(expC(a + b)), quote(expC(a) * expC(b)), true], // exp(a+b) = exp(a)exp(b)
	["exp_integer_mul", quote(expC(n * z)), quote(powC(expC(z), n)), isInt(n)], // exp(nz) = (exp(z))^n for integer n
	["exp_periodicity", quote(expC(z + 2.0 * pi * i)), quote(expC(z)), true], // Periodicity of complex exponential
	["exp_conjugate", quote(conjugateC(expC(z))), quote(expC(conjugateC(z))), true], // conj(exp(z)) = exp(conj(z))

	// --- Trigonometric Properties ---
	// Definitions
	["tan_def", quote(tan(x)), quote(sin(x) / cos(x)), eval(cos(x) != 0.0)],
	["cot_def", quote(cot(x)), quote(cos(x) / sin(x)), eval(sin(x) != 0.0)],
	["sec_def", quote(sec(x)), quote(1.0 / cos(x)), eval(cos(x) != 0.0)],
	["csc_def", quote(csc(x)), quote(1.0 / sin(x)), eval(sin(x) != 0.0)],
	// Special values
	["cos_zero", quote(cos(0.0)), quote(1.0), true],
	["sin_zero", quote(sin(0.0)), quote(0.0), true],
	["tan_zero", quote(tan(0.0)), quote(0.0), true],
	["cos_pi", quote(cos(pi)), quote(-1.0), true],
	["sin_pi", quote(sin(pi)), quote(0.0), true],
	["tan_pi", quote(tan(pi)), quote(0.0), true],
	["cos_pi_half", quote(cos(pi / 2.0)), quote(0.0), true],
	["sin_pi_half", quote(sin(pi / 2.0)), quote(1.0), true],
	["cos_pi_fourth", quote(cos(pi / 4.0)), quote(1.0 / sqrt(2.0)), true],
	["sin_pi_fourth", quote(sin(pi / 4.0)), quote(1.0 / sqrt(2.0)), true],
	["tan_pi_fourth", quote(tan(pi / 4.0)), quote(1.0), true],
	// Periodicity
	["cos_periodicity", quote(cos(x + 2.0 * pi)), quote(cos(x)), true],
	["sin_periodicity", quote(sin(x + 2.0 * pi)), quote(sin(x)), true],
	["tan_periodicity", quote(tan(x + pi)), quote(tan(x)), true],
	["cos_half_periodicity", quote(cos(x + pi)), quote(-cos(x)), true],
	["sin_half_periodicity", quote(sin(x + pi)), quote(-sin(x)), true],
	// Symmetry (Even/Odd)
	["cos_neg_arg", quote(cos(-x)), quote(cos(x)), true],
	["sin_neg_arg", quote(sin(-x)), quote(-sin(x)), true],
	["tan_neg_arg", quote(tan(-x)), quote(-tan(x)), true],
	// Pythagorean Identities
	["pythagorean", quote(cos(x)^2 + sin(x)^2), quote(1.0), true],
	["pythagorean_tan_sec", quote(1.0 + tan(x)^2), quote(sec(x)^2), true],
	["pythagorean_cot_csc", quote(1.0 + cot(x)^2), quote(csc(x)^2), true],
	// Sum/Difference Formulas
	["cos_add", quote(cos(a + b)), quote(cos(a)*cos(b) - sin(a)*sin(b)), true],
	["cos_sub", quote(cos(a - b)), quote(cos(a)*cos(b) + sin(a)*sin(b)), true],
	["sin_add", quote(sin(a + b)), quote(sin(a)*cos(b) + cos(a)*sin(b)), true],
	["sin_sub", quote(sin(a - b)), quote(sin(a)*cos(b) - cos(a)*sin(b)), true],
	["tan_add", quote(tan(a + b)), quote((tan(a) + tan(b)) / (1.0 - tan(a)*tan(b))), true],
	["tan_sub", quote(tan(a - b)), quote((tan(a) - tan(b)) / (1.0 + tan(a)*tan(b))), true],
	// Double Angle Formulas
	["cos_double_angle_1", quote(cos(2.0*a)), quote(cos(a)^2 - sin(a)^2), true],
	["cos_double_angle_2", quote(cos(2.0*a)), quote(2.0*cos(a)^2 - 1.0), true],
	["cos_double_angle_3", quote(cos(2.0*a)), quote(1.0 - 2.0*sin(a)^2), true],
	["sin_double_angle", quote(sin(2.0*a)), quote(2.0*sin(a)*cos(a)), true],
	["tan_double_angle", quote(tan(2.0*a)), quote((2.0*tan(a)) / (1.0 - tan(a)^2)), true],
	// Half Angle Formulas (Expressing in terms of cos(a))
	["cos_half_angle", quote(cos(a/2.0)^2), quote((1.0 + cos(a)) / 2.0), true], // Often preferred form is squared
	["sin_half_angle", quote(sin(a/2.0)^2), quote((1.0 - cos(a)) / 2.0), true], // Often preferred form is squared
	["tan_half_angle_1", quote(tan(a/2.0)), quote((1.0 - cos(a)) / sin(a)), eval(sin(a) != 0.0)],
	["tan_half_angle_2", quote(tan(a/2.0)), quote(sin(a) / (1.0 + cos(a))), eval(cos(a) != -1.0)],
	// Product-to-Sum
	["prod_cos_cos", quote(cos(a)*cos(b)), quote(0.5*(cos(a-b) + cos(a+b))), true],
	["prod_sin_sin", quote(sin(a)*sin(b)), quote(0.5*(cos(a-b) - cos(a+b))), true],
	["prod_sin_cos", quote(sin(a)*cos(b)), quote(0.5*(sin(a+b) + sin(a-b))), true],
	["prod_cos_sin", quote(cos(a)*sin(b)), quote(0.5*(sin(a+b) - sin(a-b))), true],
	// Sum-to-Product
	["sum_cos_cos", quote(cos(a)+cos(b)), quote(2.0*cos((a+b)/2.0)*cos((a-b)/2.0)), true],
	["sum_sin_sin", quote(sin(a)+sin(b)), quote(2.0*sin((a+b)/2.0)*cos((a-b)/2.0)), true],
	["diff_cos_cos", quote(cos(a)-cos(b)), quote(-2.0*sin((a+b)/2.0)*sin((a-b)/2.0)), true],
	["diff_sin_sin", quote(sin(a)-sin(b)), quote(2.0*cos((a+b)/2.0)*sin((a-b)/2.0)), true],


	// --- Hyperbolic Functions ---
	["cosh_def", quote(cosh(z)), quote((expC(z) + expC(-z)) / 2.0), true],
	["sinh_def", quote(sinh(z)), quote((expC(z) - expC(-z)) / 2.0), true],
	["tanh_def", quote(tanh(z)), quote(sinh(z) / cosh(z)), eval(cosh(z) != 0.0)],
	["cosh_squared_minus_sinh_squared", quote(cosh(z)^2 - sinh(z)^2), quote(1.0), true],
	["cosh_neg_arg", quote(cosh(-z)), quote(cosh(z)), true],
	["sinh_neg_arg", quote(sinh(-z)), quote(-sinh(z)), true],
	["cosh_i", quote(cosh(i*z)), quote(cos(z)), true], // Connection to trig
	["sinh_i", quote(sinh(i*z)), quote(i * sin(z)), true], // Connection to trig
	["cos_i", quote(cos(i*z)), quote(cosh(z)), true], // Connection to hyperbolic
	["sin_i", quote(sin(i*z)), quote(i * sinh(z)), true], // Connection to hyperbolic

	// --- Twiddle Factor Specific Rules (W_N^k = exp(-i*2*pi*k/N)) ---
	// Definition
	["twiddle_definition", quote(W(N, k)), quote(expC(-i * 2.0 * pi * k / N)), true],
	// Periodicity in k
	["twiddle_periodicity_k", quote(W(N, k + N)), quote(W(N, k)), true],
	// Periodicity in N (subgroup property)
	["twiddle_periodicity_N", quote(W(N, k)), quote(W(N*m, k*m)), isInt(m) && m > 0], // W_N^k = W_{Nm}^{km}
	// Half-period property (for even N)
	["twiddle_half_period", quote(W(N, k + N / 2)), quote(-W(N, k)), eval(N % 2 == 0)],
	// Core FFT Identity 1
	["fft_identity_even", quote(W(N, 2*j*k)), quote(W(N / 2, j*k)), eval(N % 2 == 0)],
	// Core FFT Identity 2 (decomposition - relies on W_N^(a+b) rule)
	["fft_identity_odd_term", quote(W(N, (2*j+1)*k)), quote(W(N, k) * W(N / 2, j*k)), eval(N % 2 == 0)],
	// Exponent Manipulation
	["twiddle_sum_exp", quote(W(N, a+b)), quote(W(N, a) * W(N, b)), true], // W_N^(a+b) = W_N^a * W_N^b
	["twiddle_mul_exp", quote(W(N, a*b)), quote(powC(W(N, a), b)), true], // W_N^(ab) = (W_N^a)^b (Use carefully)
	// Zero exponent
	["twiddle_zero_k", quote(W(N, 0)), quote(Complex(1.0, 0.0)), true], // W_N^0 = 1 (explicitly complex)
	// Conjugate property
	["twiddle_conjugate", quote(conjugateC(W(N, k))), quote(W(N, -k)), true], // conj(W_N^k) = W_N^{-k}
	["twiddle_neg_k", quote(W(N, -k)), quote(W(N, N-k)), true], // W_N^{-k} = W_N^{N-k}
	// Symmetry Property
	["twiddle_symmetry", quote(W(N, k*j)), quote(W(N, j*k)), true] // W_N^kj = W_N^jk

];

// ----- Example Usage -----

// Example expression involving twiddle factors and complex math
let expr_to_simplify = quote(W(8, 2*j*k) + W(8, k + 4));

// Apply the rules until a fixed point is reached
let simplified_expr = applyRulesUntilFixedPoint(expr_to_simplify, math_identity_rules, 30); // Increase iterations if needed

println("Original: " + prettyOrbit(expr_to_simplify));
println("Simplified: " + prettyOrbit(simplified_expr)); // Should apply twiddle_half_period and fft_identity_even

// Example showing Pythagorean identity
let pythag_example = quote(cos(theta)^2 + sin(theta)^2);
let simplified_pythag = applyRulesUntilFixedPoint(pythag_example, math_identity_rules, 10);
println("Original Pythag: " + prettyOrbit(pythag_example));
println("Simplified Pythag: " + prettyOrbit(simplified_pythag)); // Should simplify to 1.0

"Math Identity Rules Loaded and Expanded"

