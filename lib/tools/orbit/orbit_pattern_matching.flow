import tools/orbit/orbit_types;
import tools/orbit/orbit_ast;
import tools/orbit/prettyprint;

export {
	// Structure to represent a single pattern matching rule with its condition
	PatternRule(
		pattern: OrMath_expr, // The pattern to match against
		result: OrMath_expr,  // The result expression if pattern matches
		condition: OrMath_expr // The condition (or OrBool(true) if not specified)
	);

	// Extract all rules from a pattern matching expression
	// Input: Match expression from AST
	// Output: Array of PatternRule structures
	extractPatternRules(matchExpr: OrMath_expr) -> [PatternRule];
	
	// Pretty print a pattern rule
	prettyPatternRule(rule: PatternRule) -> string;
	
	// Pretty print an array of pattern rules
	prettyPatternRules(rules: [PatternRule]) -> string;
}

// Extract all rules from a pattern matching expression
extractPatternRules(matchExpr: OrMath_expr) -> [PatternRule] {
	switch (matchExpr) {
		OrMatch(expr, patterns): {
			// This is our main pattern matching construct: expr is (patterns)
			extractRulesFromPatterns(patterns);
		}
		default: {
			// If not a pattern matching expression, return empty array
			[];
		}
	}
}

// Extract rules from the patterns part of a Match expression
extractRulesFromPatterns(patterns: OrMath_expr) -> [PatternRule] {
	switch (patterns) {
		OrRule(pattern, result, conditionals): {
			// Handle a single rule: pattern => result if condition
			[	PatternRule(
					pattern,
					result,
					extractConditionFromArray(conditionals)
				)
			];
		}
		OrSequence(first, second): {
			// Handle a sequence of rules: rule1; rule2; ...
			concat(extractRulesFromPatterns(first), extractRulesFromPatterns(second));
		}
		default: {
			// If not a valid pattern structure, return empty array
			[];
		}
	}
}

// Extract the condition from an array of conditionals
// In our simplified model, we only consider the first condition if it exists
extractConditionFromArray(conditionals: [OrConditional]) -> OrMath_expr {
	if (length(conditionals) > 0) {
		// Extract the first condition
		switch (conditionals[0]) {
			OrConditional(cond): cond;
			default: OrBool(true); // Should not happen, but for safety
		}
	} else {
		// If no conditions, use implicit true
		OrBool(true);
	}
}

// Pretty print a pattern rule
prettyPatternRule(rule: PatternRule) -> string {
	condStr = if (rule.condition.structname == "OrBool" && 
				switch (rule.condition) { OrBool(b): b; default: false }) {
		// Don't show condition if it's just 'true'
		"";
	} else {
		" if " + prettyOrbit(rule.condition);
	};
	
	// Format as: pattern => result [if condition]
	prettyOrbit(rule.pattern) + " => " + prettyOrbit(rule.result) + condStr;
}

// Pretty print an array of pattern rules
prettyPatternRules(rules: [PatternRule]) -> string {
	if (rules == []) {
		"[No rules]";
	} else {
		// Join all rules with semicolons and newlines
		ruleStrings = map(rules, prettyPatternRule);
		strGlue(ruleStrings, ";\n");
	}
}