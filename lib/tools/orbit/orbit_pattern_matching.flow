import tools/orbit/orbit_types;
import tools/orbit/orbit_ast;

export {
	// Structure to represent a single pattern matching rule with its condition
	PatternRule(
		pattern: OrMath_expr, // The pattern to match against
		result: OrMath_expr,  // The result expression if pattern matches
		condition: OrMath_expr // The condition (or OrBool(true) if not specified)
	);

	// Extract all rules from a pattern matching expression
	// Input: Match expression from AST
	// Output: Array of PatternRule structures
	extractPatternRules(matchExpr: OrMath_expr) -> [PatternRule];
}

// Extract all rules from a pattern matching expression
extractPatternRules(matchExpr: OrMath_expr) -> [PatternRule] {
	switch (matchExpr) {
		OrMatch(expr, patterns): {
			// This is our main pattern matching construct: expr is (patterns)
			extractRulesFromPatterns(patterns);
		}
		default: {
			// If not a pattern matching expression, return empty array
			[];
		}
	}
}

// Extract rules from the patterns part of a Match expression
extractRulesFromPatterns(patterns: OrMath_expr) -> [PatternRule] {
	switch (patterns) {
		OrRule(pattern, result, conditionals): {
			// Handle a single rule: pattern => result if condition
			[	PatternRule(
					pattern,
					result,
					extractConditionFromArray(conditionals)
				)
			];
		}
		OrSequence(first, second): {
			// Handle a sequence of rules: rule1; rule2; ...
			concat(extractRulesFromPatterns(first), extractRulesFromPatterns(second));
		}
		default: {
			// If not a valid pattern structure, return empty array
			[];
		}
	}
}

// Extract the condition from an array of conditionals
// In our simplified model, we only consider the first condition if it exists
extractConditionFromArray(conditionals: [OrConditional]) -> OrMath_expr {
	if (length(conditionals) > 0) {
		// Extract the first condition
		switch (conditionals[0]) {
			OrConditional(cond): cond;
			default: OrBool(true); // Should not happen, but for safety
		}
	} else {
		// If no conditions, use implicit true
		OrBool(true);
	}
}