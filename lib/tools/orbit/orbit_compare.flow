import tools/orbit/orbit_types;
import tools/orbit/orbit_decompose;
import tools/orbit/ograph;
import tools/orbit/types;
import tools/orbit/ograph_decompose;
import tools/orbit/orbit_simple_ograph; // For ographRegistry
import ds/array;
import maybe;

export {
    // Compare an OrMath_expr with a node in an OGraph
    // Returns true if they represent the same expression
    // Also handles domain membership checks for pattern matching
    compareOrbitWithNode(expr : OrMath_expr, graph : OGraph, nodeId : int) -> bool;
    
    // Helper function to check if a node belongs to a specific domain
    findDomainMatch(graph : OGraph, nodeId : int, domain : OrMath_expr) -> bool;
    
    // Find a node ID in an OGraph that structurally matches the given expression without modifying the graph
    // Returns the ID if found, or -1 if not found
    findOGraphId(graphName : string, expr : OrMath_expr) -> int;
}

// Helper function to check if a node belongs to a domain that matches the given domain expression
findDomainMatch(graph : OGraph, nodeId : int, domain : OrMath_expr) -> bool {
    // Get the canonical representation of the node
    rootId = findORoot(graph, nodeId);
    
    // Get all domains this node belongs to
    domains = getONodeBelongsTo(graph, rootId);
    
    if (length(domains) == 0) {
        // Node doesn't belong to any domain
        false;
    } else {
        // Check if any of the domains structurally match the expected domain
        fold(domains, false, \acc, domainId -> {
            if (acc) acc // Short-circuit if we already found a match
            else {
                // Compare the domain expression directly with the domain node
                compareOrbitWithNode(domain, graph, domainId);
            }
        });
    }
}

// Compare an OrMath_expr with a node in an OGraph
compareOrbitWithNode(expr : OrMath_expr, graph : OGraph, nodeId : int) -> bool {
    // Handle domain type annotations (special case)
    isDomainAnnotation = switch (expr) {
        OrTypeAnnotation(__, __): true;
        default: false;
    };
    
    if (isDomainAnnotation) {
        switch (expr) {
            OrTypeAnnotation(baseExpr, domain): {
                // First check if the base expression matches
                baseMatches = compareOrbitWithNode(baseExpr, graph, nodeId);
                
                if (!baseMatches) {
                    false;
                } else {
                    // Use our helper to check domain membership
                    findDomainMatch(graph, nodeId, domain);
                }
            }
            default: false; // Should never happen due to check above
        }
    } else {
        // Regular non-domain comparison
        // Find the canonical representative for this node
        rootId = findORoot(graph, nodeId);
        
        // Decompose the OrMath_expr
        decomposedExpr = decomposeOrbit(expr);
        opExpr = decomposedExpr.first;
        childrenAndValue = decomposedExpr.second;
        childrenExpr = childrenAndValue.first;
        valueExpr = childrenAndValue.second;
        
        // Get the node's information from the OGraph
        switch (lookupOClass(graph, rootId)) {
            None(): false; // Node doesn't exist
            Some(oclass): {
                // Check if operators match
                if (oclass.node.op != opExpr) {
                    false;
                } else if (length(oclass.node.children) != length(childrenExpr)) {
                    // Check if number of children match
                    false;
                } else if (length(childrenExpr) == 0) {
                    // Handle leaf nodes with primitive values
                    if (opExpr == "Int") {
                        switch (getOClassInt(graph, rootId)) {
                            None(): false;
                            Some(intValue): {
                                switch (valueExpr) {
                                    OrbitInt(exprValue): intValue == exprValue;
                                    default: false;
                                }
                            }
                        }
                    } else if (opExpr == "Double") {
                        switch (getOClassDouble(graph, rootId)) {
                            None(): false;
                            Some(doubleValue): {
                                switch (valueExpr) {
                                    OrbitDouble(exprValue): doubleValue == exprValue;
                                    default: false;
                                }
                            }
                        }
                    } else if (opExpr == "String" || opExpr == "Identifier" || opExpr == "Variable") {
                        switch (getOClassString(graph, rootId)) {
                            None(): false;
                            Some(stringValue): {
                                switch (valueExpr) {
                                    OrbitString(exprValue): stringValue == exprValue;
                                    default: false;
                                }
                            }
                        }
                    } else if (opExpr == "Bool") {
                        // Booleans are typically stored as integers (0/1) in OGraph
                        switch (getOClassInt(graph, rootId)) {
                            None(): false;
                            Some(intValue): {
                                switch (valueExpr) {
                                    OrbitBool(exprValue): (intValue != 0) == exprValue;
                                    default: false;
                                }
                            }
                        }
                    } else {
                        // Other leaf node types without primitive values
                        true;
                    }
                } else {
                    // For non-leaf nodes, recursively compare all children
                    foldRange(0, length(childrenExpr) - 1, true, \acc, i -> {
                        if (!acc) false  // Short-circuit if we already found mismatch
                        else if (i >= length(oclass.node.children)) false
                        else compareOrbitWithNode(childrenExpr[i], graph, oclass.node.children[i]);
                    });
                }
            }
        }
    }
}

// Implementation of findOGraphId function
findOGraphId(graphName : string, expr : OrMath_expr) -> int {
	// Handle special case for domain annotations
    isDomainAnnotation = switch (expr) {
        OrTypeAnnotation(baseExpr, domain): true;
        default: false;
    };
    
    if (isDomainAnnotation) {
        // Extract base expression and domain
        baseExpr = switch (expr) {
            OrTypeAnnotation(be, __): be;
            default: expr; // Should never happen
        };
        
        domain = switch (expr) {
            OrTypeAnnotation(__, dom): dom;
            default: OrInt(0); // Should never happen
        };
        
        // First, find the base expression
        baseId = findOGraphId(graphName, baseExpr);
        if (baseId == -1) {
            -1; // Base expression not found
        } else {
            // Find the domain expression
            domainId = findOGraphId(graphName, domain);
            if (domainId == -1) {
                -1; // Domain not found
            } else {
                // Get the ograph from the registry
                switch (lookupTree(^ographRegistry, graphName)) {
                    Some(ograph): {
                        // Check if base node belongs to domain
                        if (onodeBelongsTo(ograph, baseId, domainId)) {
                            baseId; // Found a match
                        } else {
                            -1; // No match
                        }
                    }
                    None(): -1;
                }
            }
        }    
    } else {
        // Regular case - non-domain expression
        // Get the ograph from the registry
        switch (lookupTree(^ographRegistry, graphName)) {
            Some(ograph): {
                // Use direct comparison without modifying the graph
                foundId = ref -1;
                
                // Look through all nodes in the graph for a match
                traverseOGraph(ograph, \id, __ -> {
                    if (^foundId == -1) { // Stop searching if we found a match
                        if (compareOrbitWithNode(expr, ograph, id)) {
                            foundId := id;
                        }
                    }
                });
                
                // Return the found ID or -1 if not found
                ^foundId;
            }
            None(): -1;
        }
    }
}