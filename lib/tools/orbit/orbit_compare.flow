import tools/orbit/orbit_types;
import tools/orbit/orbit_decompose;
import tools/orbit/ograph;
import tools/orbit/types;
import tools/orbit/ograph_decompose;
import tools/orbit/orbit_simple_ograph; // For ographRegistry
import tools/orbit/orbit2ograph;      // For ograph2Orbit
import tools/orbit/prettyprint;      // For prettyOrbit
import ds/array;
import maybe;

export {
    // Compare an OrMath_expr with a node in an OGraph
    // Returns true if they represent the same expression
    // Also handles domain membership checks for pattern matching
    compareOrbitWithNode(expr : OrMath_expr, graph : OGraph, nodeId : int) -> bool;
    
    // Helper function to check if a node belongs to a specific domain
    findDomainMatch(graph : OGraph, nodeId : int, domain : OrMath_expr) -> bool;
    
    // Find a node ID in an OGraph that structurally matches the given expression without modifying the graph
    // Returns the ID if found, or -1 if not found
    findOGraphId(graphName : string, expr : OrMath_expr) -> int;
    
    // Check if two expressions are equivalent (for domain matching)
    areExpressionsEquivalent(expr1 : OrMath_expr, expr2 : OrMath_expr) -> bool;
}

// Helper function to check if a node belongs to a domain that matches the given domain expression
findDomainMatch(graph : OGraph, nodeId : int, domain : OrMath_expr) -> bool {
    // Get the canonical representation of the node
    rootId = findORoot(graph, nodeId);
    
    // Get all domains this node belongs to
    domains = getONodeBelongsTo(graph, rootId);
    
    if (length(domains) == 0) {
        // Node doesn't belong to any domain
        false;
    } else {
        // Check if any of the domains structurally match the expected domain
        fold(domains, false, \acc, domainId -> {
            if (acc) acc // Short-circuit if we already found a match
            else {
                // Compare the domain expression directly with the domain node
                compareOrbitWithNode(domain, graph, domainId);
            }
        });
    }
}

// Compare an OrMath_expr with a node in an OGraph
compareOrbitWithNode(expr : OrMath_expr, graph : OGraph, nodeId : int) -> bool {
    // Handle domain type annotations (special case)
    isDomainAnnotation = switch (expr) {
        OrTypeAnnotation(__, __): true;
        default: false;
    };
    
    if (isDomainAnnotation) {
        switch (expr) {
            OrTypeAnnotation(baseExpr, domain): {
                // First check if the base expression matches
                baseMatches = compareOrbitWithNode(baseExpr, graph, nodeId);
                
                if (!baseMatches) {
                    false;
                } else {
                    // Use our helper to check domain membership
                    findDomainMatch(graph, nodeId, domain);
                }
            }
            default: false; // Should never happen due to check above
        }
    } else {
        // Regular non-domain comparison
        // Find the canonical representative for this node
        rootId = findORoot(graph, nodeId);
        
        // Decompose the OrMath_expr
        decomposedExpr = decomposeOrbit(expr);
        opExpr = decomposedExpr.first;
        childrenAndValue = decomposedExpr.second;
        childrenExpr = childrenAndValue.first;
        valueExpr = childrenAndValue.second;
        
        // Get the node's information from the OGraph
        switch (lookupOClass(graph, rootId)) {
            None(): false; // Node doesn't exist
            Some(oclass): {
                // Check if operators match
                if (oclass.node.op != opExpr) {
                    false;
                } else if (length(oclass.node.children) != length(childrenExpr)) {
                    // Check if number of children match
                    false;
                } else if (length(childrenExpr) == 0) {
                    // Handle leaf nodes with primitive values
                    if (opExpr == "Int") {
                        switch (getOClassInt(graph, rootId)) {
                            None(): false;
                            Some(intValue): {
                                switch (valueExpr) {
                                    OrbitInt(exprValue): intValue == exprValue;
                                    default: false;
                                }
                            }
                        }
                    } else if (opExpr == "Double") {
                        switch (getOClassDouble(graph, rootId)) {
                            None(): false;
                            Some(doubleValue): {
                                switch (valueExpr) {
                                    OrbitDouble(exprValue): doubleValue == exprValue;
                                    default: false;
                                }
                            }
                        }
                    } else if (opExpr == "String" || opExpr == "Identifier" || opExpr == "Variable") {
                        switch (getOClassString(graph, rootId)) {
                            None(): false;
                            Some(stringValue): {
                                switch (valueExpr) {
                                    OrbitString(exprValue): stringValue == exprValue;
                                    default: false;
                                }
                            }
                        }
                    } else if (opExpr == "Bool") {
                        // Booleans are typically stored as integers (0/1) in OGraph
                        switch (getOClassInt(graph, rootId)) {
                            None(): false;
                            Some(intValue): {
                                switch (valueExpr) {
                                    OrbitBool(exprValue): (intValue != 0) == exprValue;
                                    default: false;
                                }
                            }
                        }
                    } else {
                        // Other leaf node types without primitive values
                        true;
                    }
                } else {
                    // For non-leaf nodes, recursively compare all children
                    foldRange(0, length(childrenExpr) - 1, true, \acc, i -> {
                        if (!acc) false  // Short-circuit if we already found mismatch
                        else if (i >= length(oclass.node.children)) false
                        else compareOrbitWithNode(childrenExpr[i], graph, oclass.node.children[i]);
                    });
                }
            }
        }
    }
}

// Implementation of findOGraphId function
findOGraphId(graphName : string, expr : OrMath_expr) -> int {
    
	// Handle special case for domain annotations
    isDomainAnnotation = switch (expr) {
        OrTypeAnnotation(baseExpr, domain): true;
        default: false;
    };
    
    // Special case: Check if this is a function call applied to a domain annotation
    // Like ((a + b) : Type)("number") which should be treated as (a + b) : Type("number")
    isComplexDomain = switch (expr) {
        OrFunction(fnExpr, args): {
            switch (fnExpr) {
                OrTypeAnnotation(__, __): true;
                default: false;
            }
        }
        default: false;
    };
    
    if (isComplexDomain) {
        // Extract parts from the complex expression
        switch (expr) {
            OrFunction(fnExpr, fnArgs): {
                switch (fnExpr) {
                    OrTypeAnnotation(baseExpr, domainName): {
                        // Create a proper domain annotation with the function call
                        // baseExpr : domainName(fnArgs)
                        domainNameStr = switch (domainName) {
                            OrVariable(id): id;
                            OrIdentifier(id): id;
                            default: "";
                        };
                        
                        // Construct a proper domain function with its arguments
                        domainFunction = OrFunction(domainName, fnArgs);
                        
                        // Create the correct type annotation
                        fixedExpr = OrTypeAnnotation(baseExpr, domainFunction);
                        
                        // Reconstructed the domain annotation with the function call
                        
                        // Call findOGraphId with the fixed expression
                        findOGraphId(graphName, fixedExpr);
                    }
                    default: -1;
                }
            }
            default: -1;
        }
    } else if (isDomainAnnotation) {
        // Extract base expression and domain
        baseExpr = switch (expr) {
            OrTypeAnnotation(be, __): be;
            default: expr; // Should never happen
        };
        
        domain = switch (expr) {
            OrTypeAnnotation(__, dom): dom;
            default: OrInt(0); // Should never happen
        };
        
        // First, find the base expression
        baseId = findOGraphId(graphName, baseExpr);
        if (baseId == -1) {
            -1; // Base expression not found
        } else {
            // Get the ograph from the registry
            switch (lookupTree(^ographRegistry, graphName)) {
                Some(ograph): {
                    // Get all domains this node belongs to
                    rootId = findORoot(ograph, baseId);
                    domains = getONodeBelongsTo(ograph, rootId);
                    
                    if (length(domains) == 0) {
                        -1; // Node doesn't belong to any domain
                    } else {
                        // Check each domain this node belongs to
                        matchFound = ref false;
                        
                        // For each domain the node belongs to
                        iter(domains, \domainId -> {
                            if (!^matchFound) {
                                // Extract the domain expression
                                domainExpr = ograph2Orbit(ograph, domainId);
                                
                                // Compare the extracted domain with the one we're looking for
                                equivalent = areExpressionsEquivalent(domain, domainExpr);
                                
                                if (equivalent) {
                                    matchFound := true;
                                }
                            }
                        });
                        
                        if (^matchFound) baseId else -1;
                    }
                }
                None(): -1;
            }
        }
    } else {
        // Regular case - non-domain expression
        // Get the ograph from the registry
        switch (lookupTree(^ographRegistry, graphName)) {
            Some(ograph): {
                // Use direct comparison without modifying the graph
                foundId = ref -1;
                
                // Look through all nodes in the graph for a match
                traverseOGraph(ograph, \id, __ -> {
                    if (^foundId == -1) { // Stop searching if we found a match
                        if (compareOrbitWithNode(expr, ograph, id)) {
                            foundId := id;
                        }
                    }
                });
                
                // Return the found ID or -1 if not found
                ^foundId;
            }
            None(): -1;
        }
    }
}

// Helper function for domain comparison

// Helper function to check if two expressions are equivalent
// This function handles special cases like function call expressions that need deeper comparison
areExpressionsEquivalent(expr1 : OrMath_expr, expr2 : OrMath_expr) -> bool {
    // Easy case: direct equality
    if (expr1 == expr2) {
        true;
    } else {
        // Get the structnames for both expressions
        structname1 = expr1.structname;
        structname2 = expr2.structname;
        
        if (structname1 != structname2) {
            // Handle special case for OrIdentifier vs OrVariable
            if ((structname1 == "OrIdentifier" && structname2 == "OrVariable") ||
                (structname1 == "OrVariable" && structname2 == "OrIdentifier")) {
                // Get the IDs
                id1 = switch (expr1) {
                    OrIdentifier(id): id;
                    OrVariable(id): id;
                    default: "";
                };
                
                id2 = switch (expr2) {
                    OrIdentifier(id): id;
                    OrVariable(id): id;
                    default: "";
                };
                
                // Check if IDs match
                id1 == id2;
            } else {
                // Different structure types that aren't compatible
                false;
            }
        } else {
            // Same structure types, compare contents
            switch (expr1) {
                OrInt(val1): {
                    switch (expr2) {
                        OrInt(val2): val1 == val2;
                        default: false; // Should never happen due to structname check
                    }
                }
                OrDouble(val1): {
                    switch (expr2) {
                        OrDouble(val2): val1 == val2;
                        default: false;
                    }
                }
                OrString(val1): {
                    switch (expr2) {
                        OrString(val2): val1 == val2;
                        default: false;
                    }
                }
                OrBool(val1): {
                    switch (expr2) {
                        OrBool(val2): val1 == val2;
                        default: false;
                    }
                }
                OrIdentifier(id1): {
                    switch (expr2) {
                        OrIdentifier(id2): id1 == id2;
                        default: false;
                    }
                }
                OrVariable(id1): {
                    switch (expr2) {
                        OrVariable(id2): id1 == id2;
                        default: false;
                    }
                }
                OrFunction(fnExpr1, args1): {
                    switch (expr2) {
                        OrFunction(fnExpr2, args2): {
                            // Check function names first
                            fnMatches = areExpressionsEquivalent(fnExpr1, fnExpr2);
                            
                            if (!fnMatches || length(args1) != length(args2)) {
                                false;
                            } else {
                                // Recursively check all arguments
                                foldRange(0, length(args1) - 1, true, \acc, i -> {
                                    if (!acc) false  // Short-circuit if we already found mismatch
                                    else areExpressionsEquivalent(args1[i], args2[i]);
                                });
                            }
                        }
                        default: false; // Should never happen due to structname check
                    }
                }
                // Handle other expression types as needed
                default: {
                    // For any other types, fall back to direct equality
                    // This could be enhanced for other specific types as needed
                    expr1 == expr2;
                }
            }
        }
    }
}