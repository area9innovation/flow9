// Test case for pattern matching with domain annotations in rewrite rules
// This test specifically tests the new processDomainAnnotations function

// Define quote
fn quote(e : ast) = e;

// Create a test graph
let g = makeOGraph("domain_rewrite_test2");

// Add some basic expressions
let a_id = addOGraph(g, quote(a));
let b_id = addOGraph(g, quote(b));
let expr_id = addOGraph(g, quote(a + b));

// Add domain nodes
let algebra_id = addOGraph(g, quote(Algebra));
let ring_id = addOGraph(g, quote(Ring));

println("Created test graph with nodes:");
println("a with ID: " + i2s(a_id));
println("b with ID: " + i2s(b_id));
println("a + b with ID: " + i2s(expr_id));
println("Algebra domain with ID: " + i2s(algebra_id));
println("Ring domain with ID: " + i2s(ring_id));

// Test 1: Using regular addDomainToNode to verify it works
println("\nTest 1: Using regular addDomainToNode");
let add_result = addDomainToNode(g, expr_id, algebra_id);
println("Added domain directly: " + i2s(b2i(add_result)));

// Check if we can now find the node with domain
let has_domain = findOGraphId(g, quote((a + b) : Algebra));
println("Expression has Algebra domain: " + i2s(has_domain));

// Test 2: Using processDomainAnnotations to add domain (nested annotation)
println("\nTest 2: Using processDomainAnnotations to add domain");

// Create an expression with domain annotation
let expr_with_domain = quote((a + b) : Ring);

// Process it with our new function
let processed_id = processDomainAnnotations(g, expr_with_domain);
println("Processed expression ID: " + i2s(processed_id));

// Check if it has the right domain
let has_ring = findOGraphId(g, quote((a + b) : Ring));
println("Expression has Ring domain: " + i2s(has_ring));

// Test 3: Multiple domain annotations
println("\nTest 3: Multiple domain annotations");

// Create an expression with multiple domain annotations
let multi_domain_expr = quote(((a + b) : Algebra) : Ring);
println("Expression with multiple domains: " + prettyOrbit(multi_domain_expr));

// Process it with our new function
let multi_processed_id = processDomainAnnotations(g, multi_domain_expr);
println("Processed multiple domain expression ID: " + i2s(multi_processed_id));

// Check if it has both domains
let has_both_algebra = findOGraphId(g, quote((a + b) : Algebra));
let has_both_ring = findOGraphId(g, quote((a + b) : Ring));
println("Expression has Algebra domain: " + i2s(has_both_algebra));
println("Expression has Ring domain: " + i2s(has_both_ring));

// Test 4: Using matchOGraphPattern with processDomainAnnotations
println("\nTest 4: Using matchOGraphPattern with processDomainAnnotations");

// Create a new expression
let c_plus_d_id = addOGraph(g, quote(c + d));
println("Added c + d with ID: " + i2s(c_plus_d_id));

// Pattern match and add domain using the new function
let matches = matchOGraphPattern(g, quote(x + y), \(bindings : ast, eclassId) . (
    println("Match found at ID: " + i2s(eclassId));
    
    // Create a replacement expression with domain annotation
    let replacement = substituteWithBindings(quote((x + y) : Ring), bindings);
    println("Replacement expression: " + prettyOrbit(replacement));
    
    // Process the replacement using our new function
    let replacement_id = processDomainAnnotations(g, replacement);
    println("Replacement processed with ID: " + i2s(replacement_id));
    
    // Merge with the original node
    let merged = mergeOGraphNodes(g, replacement_id, eclassId);
    println("Merged nodes: " + i2s(b2i(merged)));
    
    // Check if the node now has the Ring domain
    let node_has_ring = findOGraphId(g, substituteWithBindings(quote((x + y) : Ring), bindings));
    println("Node now has Ring domain: " + i2s(node_has_ring != -1));
));

println("Found " + i2s(matches) + " matches");

// Check if c + d now has the Ring domain
let c_plus_d_has_ring = findOGraphId(g, quote((c + d) : Ring));
println("c + d has Ring domain: " + i2s(c_plus_d_has_ring != -1));

"Domain annotation processing test completed"