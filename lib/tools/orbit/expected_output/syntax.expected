TODO: Interpret OrSetLiteral: { 1, 2, 3, 4 }
TODO: Interpret OrSetComprehension: { x | (x < 10) }
TODO: Interpret OrEllipsis: ...
Variable not found: a
Variable not found: b
Variable not found: a
Variable not found: b
Variable not found: a
Variable not found: b
Variable not found: a
Variable not found: b
ERROR: Division by zero
Variable not found: a
Variable not found: b
ERROR: Modulo by zero
Variable not found: a
Variable not found: b
Variable not found: a
Variable not found: a
Variable not found: b
Variable not found: c
Variable not found: d
Variable not found: e
Variable not found: f
Variable not found: g
ERROR: Modulo by zero
Variable not found: a
Variable not found: b
Variable not found: a
Variable not found: b
Variable not found: a
Variable not found: b
Variable not found: a
Variable not found: b
Variable not found: a
Variable not found: b
Variable not found: a
Variable not found: b
Variable not found: p
Variable not found: p
Variable not found: q
Variable not found: p
Variable not found: p
Variable not found: r
Variable not found: s
Variable not found: condition
Variable not found: value2
Variable not found: a
Variable not found: b
Variable not found: b
Variable not found: c
Variable not found: c
Variable not found: condition
Variable not found: expr
Variable not found: shape
Variable not found: value
Variable not found: data
TODO: Interpret OrField: point.x
TODO: Interpret OrField: point.distance
Variable not found: origin
Cannot call non-function value: 0
Variable not found: expr1
Variable not found: expr2
Variable not found: expr3
Variable not found: expr1
Variable not found: expr2
Variable not found: expr3
Variable not found: expr4
TODO: Interpret OrUnion: (A ∪ B)
TODO: Interpret OrIntersection: (A ∩ B)
TODO: Interpret OrElementOf: (x ∈ S)
TODO: Interpret OrSubset: (A ⊂ B)
TODO: Interpret OrForall: ∀ (x : P)(x);
let existsQuantifier = ∃ (x : P)(x);
let logicalAnd2 = (p ∧ q);
let logicalOr2 = (p ∨ q);
let logicalNot2 = ¬p;
(let implies = p ⇒ q);
(let biconditional = p ⇔ q);
(let entailment = A ⊢ B);
let alpha = α;
let beta = β;
let gamma = Γ;
let pi = π;
let theta = θ;
let lambda = λ;
let omega = Ω;
let integers = ℤ;
let rationals = ℚ;
let reals = ℝ;
let naturals = ℕ;
let complexNumbers = ℂ;
let subscripted = x₁;
let superscripted = x²;
let subscriptedNegative = x₋₁;
let complexExponent = (e^(i * π));
let gradient = ∇f;
let integral = ∫f;
let summation = ∑f;
let derivative = d/dx f;
let partialDerivative = ∂/∂x f;
let tensorProduct = (A ⊗ B);
let directProduct = (G × H);
let composition = (f ∘ g);
let groupOrder = |G|;
let functionType = (A → B);
let typeAnnotation = (expr : Type);
let notTypeAnnotation = (expr !: Type);
let typeSubstitution = (expr[T := U]);
let normalSubgroup = (H ⊲ G);
let isomorphism = (G ≅ H);
let rightSemiDirectProduct = (N ⋇ H);
let leftSemiDirectProduct = (H ⋆ N);
(let simpleRule = (a + b) ⇒ (b + a));
(let conditionalRule = expr ⇒ simplified condition);
(let bidirectionalRule = (a * b) ⇔ (b * a));
let quotedExpr = quote((a + (b * c)));
let makeAstExample = makeAst("+", [a, b]);
let envBindingLambda = λ{x:10, y:20}z.((x + y) + z);
let complexExpr = λx.if (x ∈ ℕ) then 
	∑{ i | (i ∈ { 1, 2, ..., x }) } 
else 
	∫λy.(y^2)(x);
let result = 42;
println(i2s(result));
result;
0
Result: 0
