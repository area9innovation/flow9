import tools/orbit/orbit_types;
import tools/orbit/orbit_decompose; // Keep importing for constructOrbit
import tools/orbit/orbit_gather;
import tools/orbit/sexpr/sexpr_types;
import ds/tree;
import string;
import ds/array;

export {
	// Converts an OrMath_expr to the equivalent Sexpr
	// Performs associativity collapsing for associative operators
	orbit2sexpr(expr : OrMath_expr) -> Sexpr;
	
	// Converts a Sexpr to the equivalent OrMath_expr
	// Expands flattened associative operators to binary operations
	// using conventional associativity rules for each operator
	sexpr2orbit(expr : Sexpr) -> OrMath_expr;
}

// Main conversion function
orbit2sexpr(expr : OrMath_expr) -> Sexpr {
	switch (expr) {
		// Primitive values
		OrInt(i): SSInt(i);
		OrDouble(d): SSDouble(d);
		OrString(s): SSString(s);
		OrBool(b): SSBool(b);
		OrIdentifier(id): SSVariable(id);
		OrUId(id): SSConstructor(id);
		OrOperatorSymbol(symbol): SSOperator(symbol);
		
		// Collection types
		OrArray(items): SSSpecialForm(SList(), map(items, orbit2sexpr));
		
		// Binary operations - Check for associative operations that should be flattened
		OrAdd(a, b): {
			convertedChildren = gatherAssociativeOp(expr, "+");
			SSList(concat([SSOperator("+")], convertedChildren));
		}
		OrMultiply(a, b): {
			convertedChildren = gatherAssociativeOp(expr, "*");
			SSList(concat([SSOperator("*")], convertedChildren));
		}
		OrLogicalAnd(a, b): {
			convertedChildren = gatherAssociativeOp(expr, "and");
			SSSpecialForm(SAnd(), convertedChildren);
		}
		OrLogicalOr(a, b): {
			convertedChildren = gatherAssociativeOp(expr, "or");
			SSSpecialForm(SOr(), convertedChildren);
		}
		OrSequence(a, b): {
			convertedChildren = gatherAssociativeOp(expr, "begin");
			SSSpecialForm(SBegin(), convertedChildren);
		}
		OrCompose(a, b): {
			convertedChildren = gatherAssociativeOp(expr, "∘");
			SSList(concat([SSOperator("∘")], convertedChildren));
		}
		OrUnion(a, b): {
			convertedChildren = gatherAssociativeOp(expr, "∪");
			SSList(concat([SSOperator("∪")], convertedChildren));
		}
		OrIntersection(a, b): {
			convertedChildren = gatherAssociativeOp(expr, "∩");
			SSList(concat([SSOperator("∩")], convertedChildren));
		}
		OrDirectProduct(a, b): {
			convertedChildren = gatherAssociativeOp(expr, "×");
			SSList(concat([SSOperator("×")], convertedChildren));
		}
		OrTensorProduct(a, b): {
			convertedChildren = gatherAssociativeOp(expr, "⊗");
			SSList(concat([SSOperator("⊗")], convertedChildren));
		}
		
		// Other binary operations (non-associative)
		OrSubtract(a, b): SSList([SSOperator("-"), orbit2sexpr(a), orbit2sexpr(b)]);
		OrDivide(a, b): SSList([SSOperator("/"), orbit2sexpr(a), orbit2sexpr(b)]);
		OrExponent(a, b): SSList([SSOperator("^"), orbit2sexpr(a), orbit2sexpr(b)]);
		OrEquals(a, b): SSList([SSOperator("="), orbit2sexpr(a), orbit2sexpr(b)]);
		OrNotEquals(a, b): SSList([SSOperator("!="), orbit2sexpr(a), orbit2sexpr(b)]);
		OrGreaterThan(a, b): SSList([SSOperator(">"), orbit2sexpr(a), orbit2sexpr(b)]);
		OrGreaterEquals(a, b): SSList([SSOperator(">="), orbit2sexpr(a), orbit2sexpr(b)]);
		OrLessThan(a, b): SSList([SSOperator("<"), orbit2sexpr(a), orbit2sexpr(b)]);
		OrLessEquals(a, b): SSList([SSOperator("<="), orbit2sexpr(a), orbit2sexpr(b)]);
		OrModulo(a, b): SSList([SSOperator("mod"), orbit2sexpr(a), orbit2sexpr(b)]);
		OrIndex(a, b): SSList([SSConstructor("Index"), orbit2sexpr(a), orbit2sexpr(b)]);
		OrTypeAnnotation(a, b): SSList([SSConstructor("TypeAnnotation"), orbit2sexpr(a), orbit2sexpr(b)]);
		OrNotTypeAnnotation(a, b): SSList([SSConstructor("NotTypeAnnotation"), orbit2sexpr(a), orbit2sexpr(b)]);
		OrSubset(a, b): SSList([SSConstructor("Subset"), orbit2sexpr(a), orbit2sexpr(b)]);
		OrElementOf(a, b): SSList([SSConstructor("ElementOf"), orbit2sexpr(a), orbit2sexpr(b)]);
		OrHomomorphism(a, b): SSList([SSConstructor("Homomorphism"), orbit2sexpr(a), orbit2sexpr(b)]);
		OrIsomorphism(a, b): SSList([SSConstructor("Isomorphism"), orbit2sexpr(a), orbit2sexpr(b)]);
		OrLeftSemiDirectProduct(a, b): SSList([SSOperator("⋉"), orbit2sexpr(a), orbit2sexpr(b)]);
		OrRightSemiDirectProduct(a, b): SSList([SSOperator("⋊"), orbit2sexpr(a), orbit2sexpr(b)]);
		OrNormalSubgroup(a, b): SSList([SSConstructor("NormalSubgroup"), orbit2sexpr(a), orbit2sexpr(b)]);
		OrFunctionType(a, b): SSList([SSConstructor("FunctionType"), orbit2sexpr(a), orbit2sexpr(b)]);
		
		// Unary operations
		OrNegate(a): SSList([SSOperator("-"), orbit2sexpr(a)]);
		OrLogicalNot(a): SSList([SSOperator("!"), orbit2sexpr(a)]);
		OrSummation(a): SSList([SSConstructor("Summation"), orbit2sexpr(a)]);
		OrIntegral(a): SSList([SSConstructor("Integral"), orbit2sexpr(a)]);
		OrGradient(a): SSList([SSConstructor("Gradient"), orbit2sexpr(a)]);
		OrGroupOrder(a): SSList([SSConstructor("GroupOrder"), orbit2sexpr(a)]);
		
		// Field access and subscripts
		OrField(e, id): SSList([SSConstructor("Field"), orbit2sexpr(e), SSString(id)]);
		OrSuperscript(e, sup): SSList([SSConstructor("Superscript"), orbit2sexpr(e), SSString(sup)]);
		OrSubscript(e, sub): SSList([SSConstructor("Subscript"), orbit2sexpr(e), SSString(sub)]);
		
		// Operations with string identifiers
		OrDerivative(id, e): SSList([SSConstructor("Derivative"), SSString(id), orbit2sexpr(e)]);
		OrPartialDerivative(id, e): SSList([SSConstructor("PartialDerivative"), SSString(id), orbit2sexpr(e)]);
		
		// Special constructs
		OrSetLiteral(exprs): SSList(concat([SSConstructor("SetLiteral")], map(exprs, orbit2sexpr)));
		OrFunction(fn, args): SSList(concat([orbit2sexpr(fn)], map(args, orbit2sexpr))); // Call
		OrIfElse(cond, thenExpr, elseExpr): SSSpecialForm(SIf(), [orbit2sexpr(cond), orbit2sexpr(thenExpr), orbit2sexpr(elseExpr)]);
		OrMatch(expr2, cases): SSSpecialForm(SMatch(), [orbit2sexpr(expr2), orbit2sexpr(cases)]);
		OrLet(idType, evalExpr): SSSpecialForm(SDefine(), [SSVariable(idType.id), orbit2sexpr(evalExpr)]);
		OrRule(m1, m2, m3, b): SSList([SSConstructor("Rule"), orbit2sexpr(m1), orbit2sexpr(m2), orbit2sexpr(m3), SSBool(b)]);
		OrEntailment(m1, m2, m3): SSList([SSConstructor("Entailment"), orbit2sexpr(m1), orbit2sexpr(m2), orbit2sexpr(m3)]);
		OrEquivalence(m1, m2, m3, b): SSList([SSConstructor("Equivalence"), orbit2sexpr(m1), orbit2sexpr(m2), orbit2sexpr(m3), SSBool(b)]);
		OrTypeSubstitution(m1, m2, m3): SSList([SSConstructor("TypeSubstitution"), orbit2sexpr(m1), orbit2sexpr(m2), orbit2sexpr(m3)]);
		OrTypeVar(s): SSList([SSConstructor("TypeVar"), SSString(s)]);
		OrImport(path): SSSpecialForm(SImport(), [SSString(path)]);
		OrEllipsis(): SSConstructor("Ellipsis");
		
		// Complex constructs requiring special handling
		OrFnDef(id, id_types, type_annotations, math_expr): {
			// Convert id_types to Sexpr
			id_type_exprs = map(id_types, \idType -> {
				type_annots = map(idType.type_annotations, \t -> orbit2sexpr(t.math_expr));
				SSList([SSString(idType.id), SSList(type_annots)]);
			});
			
			// Convert type_annotations to Sexpr
			type_annot_exprs = map(type_annotations, \t -> orbit2sexpr(t.math_expr));
			
			SSList([
				SSConstructor("FnDef"), 
				SSString(id),
				SSList(id_type_exprs),
				SSList(type_annot_exprs),
				orbit2sexpr(math_expr)
			]);
		}
		OrLambda(env_bindings, id_types, math_expr): {
			// Convert environment bindings to Sexpr
			env_exprs = map(env_bindings, \binding -> 
				SSList([SSConstructor("EnvBinding"), SSString(binding.id), orbit2sexpr(binding.math_expr)])
			);
			
			// Convert id_types to Sexpr
			id_type_exprs = map(id_types, \idType -> {
				type_annots = map(idType.type_annotations, \t -> orbit2sexpr(t.math_expr));
				SSList([SSString(idType.id), SSList(type_annots)]);
			});
			
			SSSpecialForm(SLambda(), [
				SSList(env_exprs),
				SSList(id_type_exprs),
				orbit2sexpr(math_expr)
			]);
		}
		OrForall(math_exprs, math_expr): SSList([SSConstructor("Forall"), SSList(map(math_exprs, orbit2sexpr)), orbit2sexpr(math_expr)]);
		OrExists(math_exprs, math_expr): SSList([SSConstructor("Exists"), SSList(map(math_exprs, orbit2sexpr)), orbit2sexpr(math_expr)]);
		OrSetComprehension(math_exprs, math_expr): SSList([SSConstructor("SetComprehension"), SSList(map(math_exprs, orbit2sexpr)), orbit2sexpr(math_expr)]);
	}
}

// Check if an operator is associative
isAssociativeOp(op : string) -> bool {
	op == "+" || op == "*" || op == "&&" || op == "||" || op == ";" || 
	op == ";" || 
	op == "∘" || // Composition
	op == "∪" || // Set union
	op == "∩" || // Set intersection
	op == "×" || // Direct product
	op == "⊗"; // Tensor product
}

// Check if an operator is right-associative (standard convention)
isRightAssociativeOp(op : string) -> bool {
	op == "^" || // Exponentiation
	op == "**" || // Alternative exponentiation
	op == "=" || // Assignment 
	op == "∘" ||  // Function composition
	op == "⊗"; // Tensor product (conventionally right-associative in some contexts)
}

// Gather all operands for an associative operation
gatherAssociativeOp(expr : OrMath_expr, targetOp : string) -> [Sexpr] {
	// Recursively flatten the tree for this operation
	gatherAssociativeOpHelper(expr, targetOp, []);
}

// Helper function to recursively gather operands
gatherAssociativeOpHelper(expr : OrMath_expr, targetOp : string, acc : [Sexpr]) -> [Sexpr] {
	// Directly pattern match on the expression type
	switch (expr) {
		OrAdd(a, b): {
			if (targetOp == "+") {
				// Recursively process left and right children
				leftAcc = gatherAssociativeOpHelper(a, targetOp, acc);
				gatherAssociativeOpHelper(b, targetOp, leftAcc);
			} else {
				arrayPush(acc, orbit2sexpr(expr));
			}
		}
		OrMultiply(a, b): {
			if (targetOp == "*") {
				leftAcc = gatherAssociativeOpHelper(a, targetOp, acc);
				gatherAssociativeOpHelper(b, targetOp, leftAcc);
			} else {
				arrayPush(acc, orbit2sexpr(expr));
			}
		}
		OrLogicalAnd(a, b): {
			if (targetOp == "and") {
				leftAcc = gatherAssociativeOpHelper(a, targetOp, acc);
				gatherAssociativeOpHelper(b, targetOp, leftAcc);
			} else {
				arrayPush(acc, orbit2sexpr(expr));
			}
		}
		OrLogicalOr(a, b): {
			if (targetOp == "or") {
				leftAcc = gatherAssociativeOpHelper(a, targetOp, acc);
				gatherAssociativeOpHelper(b, targetOp, leftAcc);
			} else {
				arrayPush(acc, orbit2sexpr(expr));
			}
		}
		OrSequence(a, b): {
			if (targetOp == "begin") {
				leftAcc = gatherAssociativeOpHelper(a, targetOp, acc);
				gatherAssociativeOpHelper(b, targetOp, leftAcc);
			} else {
				arrayPush(acc, orbit2sexpr(expr));
			}
		}
		OrCompose(a, b): {
			if (targetOp == "∘") {
				leftAcc = gatherAssociativeOpHelper(a, targetOp, acc);
				gatherAssociativeOpHelper(b, targetOp, leftAcc);
			} else {
				arrayPush(acc, orbit2sexpr(expr));
			}
		}
		OrUnion(a, b): {
			if (targetOp == "∪") {
				leftAcc = gatherAssociativeOpHelper(a, targetOp, acc);
				gatherAssociativeOpHelper(b, targetOp, leftAcc);
			} else {
				arrayPush(acc, orbit2sexpr(expr));
			}
		}
		OrIntersection(a, b): {
			if (targetOp == "∩") {
				leftAcc = gatherAssociativeOpHelper(a, targetOp, acc);
				gatherAssociativeOpHelper(b, targetOp, leftAcc);
			} else {
				arrayPush(acc, orbit2sexpr(expr));
			}
		}
		OrDirectProduct(a, b): {
			if (targetOp == "×") {
				leftAcc = gatherAssociativeOpHelper(a, targetOp, acc);
				gatherAssociativeOpHelper(b, targetOp, leftAcc);
			} else {
				arrayPush(acc, orbit2sexpr(expr));
			}
		}
		OrTensorProduct(a, b): {
			if (targetOp == "⊗") {
				leftAcc = gatherAssociativeOpHelper(a, targetOp, acc);
				gatherAssociativeOpHelper(b, targetOp, leftAcc);
			} else {
				arrayPush(acc, orbit2sexpr(expr));
			}
		}
		default: {
			// Not the target associative operation - add to accumulator
			arrayPush(acc, orbit2sexpr(expr));
		}
	}
}

// Convert S-expression to Orbit expression
sexpr2orbit(expr : Sexpr) -> OrMath_expr {
	switch (expr) {
		// Primitive values
		SSInt(i): OrInt(i);
		SSDouble(d): OrDouble(d);
		SSString(s): OrString(s);
		SSBool(b): OrBool(b);
		SSVariable(name): OrIdentifier(name);
		SSConstructor(name): OrUId(name); // Treat constructors as UIDs in Orbit
		SSOperator(op): OrOperatorSymbol(op);
		
		// Special forms
		SSSpecialForm(special, items): {
			switch (special) {
				SList(): {
					// Convert list special form to array
					OrArray(map(items, sexpr2orbit));
				}
				SIf(): {
					if (length(items) >= 3) {
						OrIfElse(sexpr2orbit(items[0]), sexpr2orbit(items[1]), sexpr2orbit(items[2]));
					} else {
						// Handle error case: not enough arguments for if
						OrIdentifier("invalid_if_expr");
					}
				}
				SLambda(): {
					if (length(items) >= 3) {
						// Extract environment bindings
						env_bindings = switch (items[0]) {
							SSList(bindings): map(bindings, \binding -> {
								switch (binding) {
									SSList(parts): {
										if (length(parts) >= 3) {
											switch (parts[1]) {
												SSString(id): {
													OrEnvBinding(id, sexpr2orbit(parts[2]));
												}
												default: OrEnvBinding("", OrInt(0)); // Default for invalid
											}
										} else {
											OrEnvBinding("", OrInt(0)); // Default for invalid
										}
									}
									default: OrEnvBinding("", OrInt(0));
								}
							});
							default: [];
						}
						
						// Extract id_types
						id_types = switch (items[1]) {
							SSList(params): map(params, \param -> {
								switch (param) {
									SSList(parts): {
										if (length(parts) >= 2) {
											switch (parts[0]) {
												SSString(id): {
													// Extract type annotations
													type_annots = switch (parts[1]) {
														SSList(annots): map(annots, \a -> OrType(sexpr2orbit(a)));
														default: [];
													}
													OrIdType(id, type_annots);
												}
												default: OrIdType("", []); // Default for invalid
											}
										} else {
											OrIdType("", []); // Default for invalid
										}
									}
									default: OrIdType("", []);
								}
							});
							default: [];
						}
						
						// Create lambda
						OrLambda(env_bindings, id_types, sexpr2orbit(items[2]));
					} else {
						// Handle error case: not enough arguments
						OrIdentifier("invalid_lambda");
					}
				}
				SDefine(): {
					if (length(items) >= 2) {
						switch (items[0]) {
							SSVariable(id): {
								OrLet(OrIdType(id, []), sexpr2orbit(items[1]));
							}
							default: OrIdentifier("invalid_define");
						}
					} else {
						OrIdentifier("invalid_define");
					}
				}
				SMatch(): {
					if (length(items) >= 2) {
						OrMatch(sexpr2orbit(items[0]), sexpr2orbit(items[1]));
					} else {
						OrIdentifier("invalid_match");
					}
				}
				SImport(): {
					if (length(items) >= 1) {
						switch (items[0]) {
							SSString(path): OrImport(path);
							default: OrIdentifier("invalid_import");
						}
					} else {
						OrIdentifier("invalid_import");
					}
				}
				default: {
					// Other special forms - convert as generic function call
					OrIdentifier("unsupported_special_form");
				}
			}
		}
		
		// Lists - the main structure
		SSList(items): {
			if (length(items) == 0) {
				// Empty list becomes an empty array
				OrArray([]);
			} else {
				// Check if first item is an operator (for associative ops)
				switch (items[0]) {
					SSOperator(op): {
						if (isAssociativeOp(op) && length(items) > 2) {
							// We have an associative operation with multiple operands
							// Convert each operand first
							operands = map(tailFrom(items, 1), \item -> sexpr2orbit(item));
							
							// Build the binary tree according to operator's standard associativity
							if (isRightAssociativeOp(op)) {
								// Right-associative: a+(b+(c+d)...)
								buildRightAssociative(operands, op);
							} else {
								// Left-associative (default): ((a+b)+c)+d...
								foldi(tailFrom(operands, 1), operands[0], \i, acc, operand -> 
									makeBinaryOp(op, acc, operand)
								);
							}
						} else {
							// Regular operation with expected arity
							operands = map(tailFrom(items, 1), \item -> sexpr2orbit(item));
							if (length(operands) == 2) {
								// Binary operation
								makeBinaryOp(op, operands[0], operands[1]);
							} else {
								// Function call with operator
								OrFunction(OrOperatorSymbol(op), operands);
							}
						}
					}
					default: {
						// First item is not an operator, so this is a function call
						fn = sexpr2orbit(items[0]);
						args = map(tailFrom(items, 1), \item -> sexpr2orbit(item));
						OrFunction(fn, args);
					}
				}
			}
		}
	}
}

// Helper function to build right-associative binary operations
// e.g., a+(b+(c+d)) for operators like +
buildRightAssociative(operands : [OrMath_expr], op : string) -> OrMath_expr {
	if (length(operands) == 0) {
		// No operands - should not happen
		OrInt(0);
	} else if (length(operands) == 1) {
		// Just one operand, return it
		operands[0];
	} else {
		// Start with the rightmost operand
		revOperands = reverseA(operands);
		
		// Fold from right to left
		fold(tail(revOperands), revOperands[0], \acc, operand -> {
			// Build (operand op acc)
			makeBinaryOp(op, operand, acc);
		});
	}
}

// Helper function to build binary operations from operator symbol and operands
makeBinaryOp(op : string, left : OrMath_expr, right : OrMath_expr) -> OrMath_expr {
	if (op == "+") {
		OrAdd(left, right);
	} else if (op == "*") {
		OrMultiply(left, right);
	} else if (op == "-") {
		OrSubtract(left, right);
	} else if (op == "/") {
		OrDivide(left, right);
	} else if (op == "%%" || op == "%") {
		OrModulo(left, right);
	} else if (op == "^") {
		OrExponent(left, right);
	} else if (op == "=") {
		OrEquals(left, right);
	} else if (op == "!=") {
		OrNotEquals(left, right);
	} else if (op == ">") {
		OrGreaterThan(left, right);
	} else if (op == ">=") {
		OrGreaterEquals(left, right);
	} else if (op == "<") {
		OrLessThan(left, right);
	} else if (op == "<=") {
		OrLessEquals(left, right);
	} else if (op == "&&") {
		OrLogicalAnd(left, right);
	} else if (op == "||") {
		OrLogicalOr(left, right);
	} else if (op == ";") {
		OrSequence(left, right);
	} else if (op == "Seq") {
		OrSequence(left, right);
	} else if (op == "\u2218" || op == "Compose") { // u2218 (function composition)
		OrCompose(left, right);
	} else if (op == "\u222a" || op == "Union") { // u222a (set union)
		OrUnion(left, right);
	} else if (op == "\u2229" || op == "Intersection") { // u2229 (set intersection)
		OrIntersection(left, right);
	} else if (op == "\u00d7" || op == "DirectProduct") { // u00d7 (direct product)
		OrDirectProduct(left, right);
	} else if (op == "\u2297" || op == "TensorProduct") { // u2297 (tensor product)
		OrTensorProduct(left, right);
	} else {
		// Default to function call for other operators
		OrFunction(OrOperatorSymbol(op), [left, right]);
	}
}