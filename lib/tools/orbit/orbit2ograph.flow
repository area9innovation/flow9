import tools/orbit/orbit_types;
import tools/orbit/ograph;
import tools/orbit/prettyprint;
import string;

export {
	// Create ONode from OrMath_expr with specified domain
	orbit2ONode(expr : OrMath_expr, belongs : [int]) -> ONode;

	// Convert a full expression to OGraph nodes recursively
	orbit2OGraph(graph : OGraph, expr : OrMath_expr) -> int;

	// Convert ONode back to Orbit expression
//	ograph2Orbit(graph : OGraph, classId : int) -> OrMath_expr;
}

// Convert OrMath_expr to ONode
orbit2ONode(expr : OrMath_expr, belongs : [int]) -> ONode {
	switch (expr) {
		OrInt(i): {
			// For primitives, we use a simple representation
			ONode("Int", [], belongs);
		}
		OrDouble(d): ONode("Double", [], belongs);
		OrString(s): ONode("String", [], belongs);
		OrBool(b): ONode("Bool", [], belongs);
		OrIdentifier(id): ONode("Identifier", [], belongs);
		OrVariable(id): ONode("Variable", [], belongs);
		
		// Binary operations
		OrAdd(a, b): ONode("+", [], belongs);
		OrSubtract(a, b): ONode("-", [], belongs);
		OrMultiply(a, b): ONode("*", [], belongs);
		OrDivide(a, b): ONode("/", [], belongs);
		OrEquals(a, b): ONode("=", [], belongs);
		OrNotEquals(a, b): ONode("!=", [], belongs);
		OrGreaterThan(a, b): ONode(">", [], belongs);
		OrGreaterEquals(a, b): ONode(">=", [], belongs);
		OrLessThan(a, b): ONode("<", [], belongs);
		OrLessEquals(a, b): ONode("<=", [], belongs);
		OrLogicalAnd(a, b): ONode("&&", [], belongs);
		OrLogicalOr(a, b): ONode("||", [], belongs);
		
		// Unary operations
		OrNegate(a): ONode("negate", [], belongs);
		OrLogicalNot(a): ONode("!", [], belongs);
		
		// Function call
		OrFunction(fn, args): ONode("call", [], belongs);
		
		// Function definition
		OrLambda(env, params, body): ONode("lambda", [], belongs);
		OrFnDef(id, params, type, body): ONode("fndef", [], belongs);
		
		// Control structures
		OrIfElse(cond, thenExpr, elseExpr): ONode("if", [], belongs);
		OrLet(id, val): ONode("let", [], belongs);
		OrSequence(a, b): ONode("seq", [], belongs);
		
		default: {
			// For all other cases, use the struct name as the operator
			ONode(expr.structname, [], belongs);
		}
	}
}

// Convert a full expression to OGraph nodes recursively
orbit2OGraph(graph : OGraph, expr : OrMath_expr) -> int {
	belongs = []; // Will be assigned in the graph
	
	switch (expr) {
		// For primitive values, we need to store the actual values
		OrInt(i): {
			node = ONode("Int", [], belongs);
			nodeId = insertONode(graph, node);
			setOClassInt(graph, nodeId, i);
			nodeId;
		}
		OrDouble(d): {
			node = ONode("Double", [], belongs);
			nodeId = insertONode(graph, node);
			setOClassDouble(graph, nodeId, d);
			nodeId;
		}
		OrString(s): {
			node = ONode("String", [], belongs);
			nodeId = insertONode(graph, node);
			setOClassString(graph, nodeId, s);
			nodeId;
		}
		OrBool(b): {
			node = ONode("Bool", [], belongs);
			nodeId = insertONode(graph, node);
			setOClassInt(graph, nodeId, if (b) 1 else 0); // Store as int: true=1, false=0
			nodeId;
		}
		OrIdentifier(id): {
			node = ONode("Identifier", [], belongs);
			nodeId = insertONode(graph, node);
			setOClassString(graph, nodeId, id);
			nodeId;
		}
		OrVariable(id): {
			node = ONode("Variable", [], belongs);
			nodeId = insertONode(graph, node);
			setOClassString(graph, nodeId, id);
			nodeId;
		}
		
		// Binary operations
		OrAdd(a, b): {
			aId = orbit2OGraph(graph, a);
			bId = orbit2OGraph(graph, b);
			node = ONode("+", [aId, bId], belongs);
			insertONode(graph, node);
		}
		OrSubtract(a, b): {
			aId = orbit2OGraph(graph, a);
			bId = orbit2OGraph(graph, b);
			node = ONode("-", [aId, bId], belongs);
			insertONode(graph, node);
		}
		OrMultiply(a, b): {
			aId = orbit2OGraph(graph, a);
			bId = orbit2OGraph(graph, b);
			node = ONode("*", [aId, bId], belongs);
			insertONode(graph, node);
		}
		OrDivide(a, b): {
			aId = orbit2OGraph(graph, a);
			bId = orbit2OGraph(graph, b);
			node = ONode("/", [aId, bId], belongs);
			insertONode(graph, node);
		}
		OrEquals(a, b): {
			aId = orbit2OGraph(graph, a);
			bId = orbit2OGraph(graph, b);
			node = ONode("=", [aId, bId], belongs);
			insertONode(graph, node);
		}
		OrNotEquals(a, b): {
			aId = orbit2OGraph(graph, a);
			bId = orbit2OGraph(graph, b);
			node = ONode("!=", [aId, bId], belongs);
			insertONode(graph, node);
		}
		OrGreaterThan(a, b): {
			aId = orbit2OGraph(graph, a);
			bId = orbit2OGraph(graph, b);
			node = ONode(">", [aId, bId], belongs);
			insertONode(graph, node);
		}
		OrGreaterEquals(a, b): {
			aId = orbit2OGraph(graph, a);
			bId = orbit2OGraph(graph, b);
			node = ONode(">=", [aId, bId], belongs);
			insertONode(graph, node);
		}
		OrLessThan(a, b): {
			aId = orbit2OGraph(graph, a);
			bId = orbit2OGraph(graph, b);
			node = ONode("<", [aId, bId], belongs);
			insertONode(graph, node);
		}
		OrLessEquals(a, b): {
			aId = orbit2OGraph(graph, a);
			bId = orbit2OGraph(graph, b);
			node = ONode("<=", [aId, bId], belongs);
			insertONode(graph, node);
		}
		OrLogicalAnd(a, b): {
			aId = orbit2OGraph(graph, a);
			bId = orbit2OGraph(graph, b);
			node = ONode("&&", [aId, bId], belongs);
			insertONode(graph, node);
		}
		OrLogicalOr(a, b): {
			aId = orbit2OGraph(graph, a);
			bId = orbit2OGraph(graph, b);
			node = ONode("||", [aId, bId], belongs);
			insertONode(graph, node);
		}
		
		// Unary operations
		OrNegate(a): {
			aId = orbit2OGraph(graph, a);
			node = ONode("negate", [aId], belongs);
			insertONode(graph, node);
		}
		OrLogicalNot(a): {
			aId = orbit2OGraph(graph, a);
			node = ONode("!", [aId], belongs);
			insertONode(graph, node);
		}
		
		// Function call
		OrFunction(fn, args): {
			fnId = orbit2OGraph(graph, fn);
			argIds = map(args, \arg -> orbit2OGraph(graph, arg));
			node = ONode("call", concat([fnId], argIds), belongs);
			insertONode(graph, node);
		}
		
		// Control structures
		OrIfElse(cond, thenExpr, elseExpr): {
			condId = orbit2OGraph(graph, cond);
			thenId = orbit2OGraph(graph, thenExpr);
			elseId = orbit2OGraph(graph, elseExpr);
			node = ONode("if", [condId, thenId, elseId], belongs);
			insertONode(graph, node);
		}
		
		OrSequence(a, b): {
			aId = orbit2OGraph(graph, a);
			bId = orbit2OGraph(graph, b);
			node = ONode("seq", [aId, bId], belongs);
			insertONode(graph, node);
		}
		
		// For anything else, just use a generic representation
		default: {
			// Create node with a generic "unknown" op
			node = ONode("unknown", [], belongs);
			nodeId = insertONode(graph, node);
			// Store the string representation of the expression
			setOClassString(graph, nodeId, prettyOrbit(expr));
			nodeId;
		}
	}
}
/*
// Convert ONode back to Orbit expression
ograph2Orbit(graph : OGraph, classId : int) -> OrMath_expr {
	root = findORoot(graph, classId);
	
	switch (lookupOClass(graph, root)) {
		None(): {
			// Node not found, return a default value
			OrInt(0);
		}
		Some(oclass): {
			switch (oclass.node.op) {
				"Int": {
					switch (getOClassInt(graph, root)) {
						Some(i): OrInt(i);
						None(): OrInt(0);
					}
				}
				"Double": {
					switch (getOClassDouble(graph, root)) {
						Some(d): OrDouble(d);
						None(): OrDouble(0.0);
					}
				}
				"String": {
					switch (getOClassString(graph, root)) {
						Some(s): OrString(s);
						None(): OrString("");
					}
				}
				"Bool": {
					switch (getOClassInt(graph, root)) {
						Some(i): OrBool(i != 0);
						None(): OrBool(false);
					}
				}
				"Identifier": {
					switch (getOClassString(graph, root)) {
						Some(id): OrIdentifier(id);
						None(): OrIdentifier("unknown");
					}
				}
				"Variable": {
					switch (getOClassString(graph, root)) {
						Some(id): OrVariable(id);
						None(): OrVariable("unknown");
					}
				}
				
				// Binary operations
				"+": {
					if (length(oclass.node.children) >= 2) {
						a = ograph2Orbit(graph, oclass.node.children[0]);
						b = ograph2Orbit(graph, oclass.node.children[1]);
						OrAdd(a, b);
					} else {
						OrInt(0); // Default if children missing
					}
				}
				"-": {
					if (length(oclass.node.children) >= 2) {
						a = ograph2Orbit(graph, oclass.node.children[0]);
						b = ograph2Orbit(graph, oclass.node.children[1]);
						OrSubtract(a, b);
					} else {
						OrInt(0);
					}
				}
				"*": {
					if (length(oclass.node.children) >= 2) {
						a = ograph2Orbit(graph, oclass.node.children[0]);
						b = ograph2Orbit(graph, oclass.node.children[1]);
						OrMultiply(a, b);
					} else {
						OrInt(1);
					}
				}
				"/": {
					if (length(oclass.node.children) >= 2) {
						a = ograph2Orbit(graph, oclass.node.children[0]);
						b = ograph2Orbit(graph, oclass.node.children[1]);
						OrDivide(a, b);
					} else {
						OrInt(0);
					}
				}
				"=": {
					if (length(oclass.node.children) >= 2) {
						a = ograph2Orbit(graph, oclass.node.children[0]);
						b = ograph2Orbit(graph, oclass.node.children[1]);
						OrEquals(a, b);
					} else {
						OrBool(false);
					}
				}
				"!=": {
					if (length(oclass.node.children) >= 2) {
						a = ograph2Orbit(graph, oclass.node.children[0]);
						b = ograph2Orbit(graph, oclass.node.children[1]);
						OrNotEquals(a, b);
					} else {
						OrBool(false);
					}
				}
				">": {
					if (length(oclass.node.children) >= 2) {
						a = ograph2Orbit(graph, oclass.node.children[0]);
						b = ograph2Orbit(graph, oclass.node.children[1]);
						OrGreaterThan(a, b);
					} else {
						OrBool(false);
					}
				}
				">=": {
					if (length(oclass.node.children) >= 2) {
						a = ograph2Orbit(graph, oclass.node.children[0]);
						b = ograph2Orbit(graph, oclass.node.children[1]);
						OrGreaterEquals(a, b);
					} else {
						OrBool(false);
					}
				}
				"<": {
					if (length(oclass.node.children) >= 2) {
						a = ograph2Orbit(graph, oclass.node.children[0]);
						b = ograph2Orbit(graph, oclass.node.children[1]);
						OrLessThan(a, b);
					} else {
						OrBool(false);
					}
				}
				"<=": {
					if (length(oclass.node.children) >= 2) {
						a = ograph2Orbit(graph, oclass.node.children[0]);
						b = ograph2Orbit(graph, oclass.node.children[1]);
						OrLessEquals(a, b);
					} else {
						OrBool(false);
					}
				}
				"&&": {
					if (length(oclass.node.children) >= 2) {
						a = ograph2Orbit(graph, oclass.node.children[0]);
						b = ograph2Orbit(graph, oclass.node.children[1]);
						OrLogicalAnd(a, b);
					} else {
						OrBool(false);
					}
				}
				"||": {
					if (length(oclass.node.children) >= 2) {
						a = ograph2Orbit(graph, oclass.node.children[0]);
						b = ograph2Orbit(graph, oclass.node.children[1]);
						OrLogicalOr(a, b);
					} else {
						OrBool(false);
					}
				}
				
				// Unary operations
				"negate": {
					if (length(oclass.node.children) >= 1) {
						a = ograph2Orbit(graph, oclass.node.children[0]);
						OrNegate(a);
					} else {
						OrInt(0);
					}
				}
				"!": {
					if (length(oclass.node.children) >= 1) {
						a = ograph2Orbit(graph, oclass.node.children[0]);
						OrLogicalNot(a);
					} else {
						OrBool(false);
					}
				}
				
				// Function call
				"call": {
					if (length(oclass.node.children) >= 1) {
						fn = ograph2Orbit(graph, oclass.node.children[0]);
						args = map(tail(oclass.node.children), \argId -> ograph2Orbit(graph, argId));
						OrFunction(fn, args);
					} else {
						OrInt(0);
					}
				}
				
				// Control structures
				"if": {
					if (length(oclass.node.children) >= 3) {
						cond = ograph2Orbit(graph, oclass.node.children[0]);
						then = ograph2Orbit(graph, oclass.node.children[1]);
						else = ograph2Orbit(graph, oclass.node.children[2]);
						OrIfElse(cond, then, else);
					} else {
						OrInt(0);
					}
				}
				
				"seq": {
					if (length(oclass.node.children) >= 2) {
						a = ograph2Orbit(graph, oclass.node.children[0]);
						b = ograph2Orbit(graph, oclass.node.children[1]);
						OrSequence(a, b);
					} else {
						OrInt(0);
					}
				}
				
				// For unknown operators, return a default value
				default: {
					// Try to get a string representation
					switch (getOClassString(graph, root)) {
						Some(str): OrString(str);
						None(): OrInt(0);
					}
				}
			}
		}
	}
}
*/