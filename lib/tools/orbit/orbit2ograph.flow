import tools/orbit/orbit_types;
import tools/orbit/ograph;
import tools/orbit/prettyprint;
import string;

export {
	// Create ONode from OrMath_expr with specified domain
	orbit2ONode(expr : OrMath_expr, domainStr : string, belongs : [int]) -> ONode;

	// Convert a full expression to OGraph nodes recursively
	orbit2OGraph(graph : OGraph, expr : OrMath_expr, domainStr : string) -> int;

	// Convert ONode back to Orbit expression
	ograph2Orbit(graph : OGraph, classId : int) -> OrMath_expr;
}

// Convert OrMath_expr to ONode
orbit2ONode(expr : OrMath_expr, domainStr : string, belongs : [int]) -> ONode {
	domain = makeODomain(domainStr);
	
	switch (expr) {
		OrInt(i): {
			// For primitives, we use a simple representation
			ONode(domain, "Int", [], belongs);
		}
		OrDouble(d): ONode(domain, "Double", [], belongs);
		OrString(s): ONode(domain, "String", [], belongs);
		OrBool(b): ONode(domain, "Bool", [], belongs);
		OrIdentifier(id): ONode(domain, "Identifier", [], belongs);
		OrVariable(id): ONode(domain, "Variable", [], belongs);
		
		// Binary operations
		OrAdd(a, b): ONode(domain, "+", [], belongs);
		OrSubtract(a, b): ONode(domain, "-", [], belongs);
		OrMultiply(a, b): ONode(domain, "*", [], belongs);
		OrDivide(a, b): ONode(domain, "/", [], belongs);
		OrEquals(a, b): ONode(domain, "=", [], belongs);
		OrNotEquals(a, b): ONode(domain, "!=", [], belongs);
		OrGreaterThan(a, b): ONode(domain, ">", [], belongs);
		OrGreaterEquals(a, b): ONode(domain, ">=", [], belongs);
		OrLessThan(a, b): ONode(domain, "<", [], belongs);
		OrLessEquals(a, b): ONode(domain, "<=", [], belongs);
		OrLogicalAnd(a, b): ONode(domain, "&&", [], belongs);
		OrLogicalOr(a, b): ONode(domain, "||", [], belongs);
		
		// Unary operations
		OrNegate(a): ONode(domain, "negate", [], belongs);
		OrLogicalNot(a): ONode(domain, "!", [], belongs);
		
		// Function call
		OrFunction(fn, args): ONode(domain, "call", [], belongs);
		
		// Function definition
		OrLambda(env, params, body): ONode(domain, "lambda", [], belongs);
		OrFnDef(id, params, type, body): ONode(domain, "fndef", [], belongs);
		
		// Control structures
		OrIfElse(cond, thenExpr, elseExpr): ONode(domain, "if", [], belongs);
		OrLet(id, val): ONode(domain, "let", [], belongs);
		OrSequence(a, b): ONode(domain, "seq", [], belongs);
		
		default: {
			// For all other cases, use the struct name as the operator
			ONode(domain, expr.structname, [], belongs);
		}
	}
}

// Convert a full expression to OGraph nodes recursively
orbit2OGraph(graph : OGraph, expr : OrMath_expr, domainStr : string) -> int {
	domain = makeODomain(domainStr);
	belongs = []; // Will be assigned in the graph
	
	switch (expr) {
		// For primitive values, we need to store the actual values
		OrInt(i): {
			node = ONode(domain, "Int", [], belongs);
			nodeId = insertONode(graph, node);
			setOClassInt(graph, nodeId, i);
			nodeId;
		}
		OrDouble(d): {
			node = ONode(domain, "Double", [], belongs);
			nodeId = insertONode(graph, node);
			setOClassDouble(graph, nodeId, d);
			nodeId;
		}
		OrString(s): {
			node = ONode(domain, "String", [], belongs);
			nodeId = insertONode(graph, node);
			setOClassString(graph, nodeId, s);
			nodeId;
		}
		OrBool(b): {
			node = ONode(domain, "Bool", [], belongs);
			nodeId = insertONode(graph, node);
			setOClassInt(graph, nodeId, if (b) 1 else 0); // Store as int: true=1, false=0
			nodeId;
		}
		OrIdentifier(id): {
			node = ONode(domain, "Identifier", [], belongs);
			nodeId = insertONode(graph, node);
			setOClassString(graph, nodeId, id);
			nodeId;
		}
		OrVariable(id): {
			node = ONode(domain, "Variable", [], belongs);
			nodeId = insertONode(graph, node);
			setOClassString(graph, nodeId, id);
			nodeId;
		}
		
		// Binary operations
		OrAdd(a, b): {
			aId = orbit2OGraph(graph, a, domainStr);
			bId = orbit2OGraph(graph, b, domainStr);
			node = ONode(domain, "+", [aId, bId], belongs);
			insertONode(graph, node);
		}
		OrSubtract(a, b): {
			aId = orbit2OGraph(graph, a, domainStr);
			bId = orbit2OGraph(graph, b, domainStr);
			node = ONode(domain, "-", [aId, bId], belongs);
			insertONode(graph, node);
		}
		OrMultiply(a, b): {
			aId = orbit2OGraph(graph, a, domainStr);
			bId = orbit2OGraph(graph, b, domainStr);
			node = ONode(domain, "*", [aId, bId], belongs);
			insertONode(graph, node);
		}
		OrDivide(a, b): {
			aId = orbit2OGraph(graph, a, domainStr);
			bId = orbit2OGraph(graph, b, domainStr);
			node = ONode(domain, "/", [aId, bId], belongs);
			insertONode(graph, node);
		}
		OrEquals(a, b): {
			aId = orbit2OGraph(graph, a, domainStr);
			bId = orbit2OGraph(graph, b, domainStr);
			node = ONode(domain, "=", [aId, bId], belongs);
			insertONode(graph, node);
		}
		OrNotEquals(a, b): {
			aId = orbit2OGraph(graph, a, domainStr);
			bId = orbit2OGraph(graph, b, domainStr);
			node = ONode(domain, "!=", [aId, bId], belongs);
			insertONode(graph, node);
		}
		OrGreaterThan(a, b): {
			aId = orbit2OGraph(graph, a, domainStr);
			bId = orbit2OGraph(graph, b, domainStr);
			node = ONode(domain, ">", [aId, bId], belongs);
			insertONode(graph, node);
		}
		OrGreaterEquals(a, b): {
			aId = orbit2OGraph(graph, a, domainStr);
			bId = orbit2OGraph(graph, b, domainStr);
			node = ONode(domain, ">=", [aId, bId], belongs);
			insertONode(graph, node);
		}
		OrLessThan(a, b): {
			aId = orbit2OGraph(graph, a, domainStr);
			bId = orbit2OGraph(graph, b, domainStr);
			node = ONode(domain, "<", [aId, bId], belongs);
			insertONode(graph, node);
		}
		OrLessEquals(a, b): {
			aId = orbit2OGraph(graph, a, domainStr);
			bId = orbit2OGraph(graph, b, domainStr);
			node = ONode(domain, "<=", [aId, bId], belongs);
			insertONode(graph, node);
		}
		OrLogicalAnd(a, b): {
			aId = orbit2OGraph(graph, a, domainStr);
			bId = orbit2OGraph(graph, b, domainStr);
			node = ONode(domain, "&&", [aId, bId], belongs);
			insertONode(graph, node);
		}
		OrLogicalOr(a, b): {
			aId = orbit2OGraph(graph, a, domainStr);
			bId = orbit2OGraph(graph, b, domainStr);
			node = ONode(domain, "||", [aId, bId], belongs);
			insertONode(graph, node);
		}
		
		// Unary operations
		OrNegate(a): {
			aId = orbit2OGraph(graph, a, domainStr);
			node = ONode(domain, "negate", [aId], belongs);
			insertONode(graph, node);
		}
		OrLogicalNot(a): {
			aId = orbit2OGraph(graph, a, domainStr);
			node = ONode(domain, "!", [aId], belongs);
			insertONode(graph, node);
		}
		
		// Function call
		OrFunction(fn, args): {
			fnId = orbit2OGraph(graph, fn, domainStr);
			argIds = map(args, \arg -> orbit2OGraph(graph, arg, domainStr));
			node = ONode(domain, "call", concat([fnId], argIds), belongs);
			insertONode(graph, node);
		}
		
		// Control structures
		OrIfElse(cond, thenExpr, elseExpr): {
			condId = orbit2OGraph(graph, cond, domainStr);
			thenId = orbit2OGraph(graph, thenExpr, domainStr);
			elseId = orbit2OGraph(graph, elseExpr, domainStr);
			node = ONode(domain, "if", [condId, thenId, elseId], belongs);
			insertONode(graph, node);
		}
		
		OrSequence(a, b): {
			aId = orbit2OGraph(graph, a, domainStr);
			bId = orbit2OGraph(graph, b, domainStr);
			node = ONode(domain, "seq", [aId, bId], belongs);
			insertONode(graph, node);
		}
		
		// For anything else, just use a generic representation
		default: {
			// Create node with a generic "unknown" op
			node = ONode(domain, "unknown", [], belongs);
			nodeId = insertONode(graph, node);
			// Store the string representation of the expression
			setOClassString(graph, nodeId, prettyOrbit(expr));
			nodeId;
		}
	}
}

// Convert ONode back to Orbit expression
ograph2Orbit(graph : OGraph, classId : int) -> OrMath_expr {
	root = findORoot(graph, classId);
	
	switch (lookupOClass(graph, root)) {
		None(): {
			// Node not found, return a default value
			OrInt(0);
		}
		Some(oclass): {
			switch (oclass.node.op) {
				"Int": {
					switch (getOClassInt(graph, root)) {
						Some(i): OrInt(i);
						None(): OrInt(0);
					}
				}
				"Double": {
					switch (getOClassDouble(graph, root)) {
						Some(d): OrDouble(d);
						None(): OrDouble(0.0);
					}
				}
				"String": {
					switch (getOClassString(graph, root)) {
						Some(s): OrString(s);
						None(): OrString("");
					}
				}
				"Bool": {
					switch (getOClassInt(graph, root)) {
						Some(i): OrBool(i != 0);
						None(): OrBool(false);
					}
				}
				"Identifier": {
					switch (getOClassString(graph, root)) {
						Some(id): OrIdentifier(id);
						None(): OrIdentifier("unknown");
					}
				}
				"Variable": {
					switch (getOClassString(graph, root)) {
						Some(id): OrVariable(id);
						None(): OrVariable("unknown");
					}
				}
				
				// Binary operations
				"+": {
					if (length(oclass.node.children) >= 2) {
						a = ograph2Orbit(graph, oclass.node.children[0]);
						b = ograph2Orbit(graph, oclass.node.children[1]);
						OrAdd(a, b);
					} else {
						OrInt(0); // Default if children missing
					}
				}
				"-": {
					if (length(oclass.node.children) >= 2) {
						a = ograph2Orbit(graph, oclass.node.children[0]);
						b = ograph2Orbit(graph, oclass.node.children[1]);
						OrSubtract(a, b);
					} else {
						OrInt(0);
					}
				}
				"*": {
					if (length(oclass.node.children) >= 2) {
						a = ograph2Orbit(graph, oclass.node.children[0]);
						b = ograph2Orbit(graph, oclass.node.children[1]);
						OrMultiply(a, b);
					} else {
						OrInt(1);
					}
				}
				"/": {
					if (length(oclass.node.children) >= 2) {
						a = ograph2Orbit(graph, oclass.node.children[0]);
						b = ograph2Orbit(graph, oclass.node.children[1]);
						OrDivide(a, b);
					} else {
						OrInt(0);
					}
				}
				"=": {
					if (length(oclass.node.children) >= 2) {
						a = ograph2Orbit(graph, oclass.node.children[0]);
						b = ograph2Orbit(graph, oclass.node.children[1]);
						OrEquals(a, b);
					} else {
						OrBool(false);
					}
				}
				"!=": {
					if (length(oclass.node.children) >= 2) {
						a = ograph2Orbit(graph, oclass.node.children[0]);
						b = ograph2Orbit(graph, oclass.node.children[1]);
						OrNotEquals(a, b);
					} else {
						OrBool(false);
					}
				}
				">": {
					if (length(oclass.node.children) >= 2) {
						a = ograph2Orbit(graph, oclass.node.children[0]);
						b = ograph2Orbit(graph, oclass.node.children[1]);
						OrGreaterThan(a, b);
					} else {
						OrBool(false);
					}
				}
				">=": {
					if (length(oclass.node.children) >= 2) {
						a = ograph2Orbit(graph, oclass.node.children[0]);
						b = ograph2Orbit(graph, oclass.node.children[1]);
						OrGreaterEquals(a, b);
					} else {
						OrBool(false);
					}
				}
				"<": {
					if (length(oclass.node.children) >= 2) {
						a = ograph2Orbit(graph, oclass.node.children[0]);
						b = ograph2Orbit(graph, oclass.node.children[1]);
						OrLessThan(a, b);
					} else {
						OrBool(false);
					}
				}
				"<=": {
					if (length(oclass.node.children) >= 2) {
						a = ograph2Orbit(graph, oclass.node.children[0]);
						b = ograph2Orbit(graph, oclass.node.children[1]);
						OrLessEquals(a, b);
					} else {
						OrBool(false);
					}
				}
				"&&": {
					if (length(oclass.node.children) >= 2) {
						a = ograph2Orbit(graph, oclass.node.children[0]);
						b = ograph2Orbit(graph, oclass.node.children[1]);
						OrLogicalAnd(a, b);
					} else {
						OrBool(false);
					}
				}
				"||": {
					if (length(oclass.node.children) >= 2) {
						a = ograph2Orbit(graph, oclass.node.children[0]);
						b = ograph2Orbit(graph, oclass.node.children[1]);
						OrLogicalOr(a, b);
					} else {
						OrBool(false);
					}
				}
				
				// Unary operations
				"negate": {
					if (length(oclass.node.children) >= 1) {
						a = ograph2Orbit(graph, oclass.node.children[0]);
						OrNegate(a);
					} else {
						OrInt(0);
					}
				}
				"!": {
					if (length(oclass.node.children) >= 1) {
						a = ograph2Orbit(graph, oclass.node.children[0]);
						OrLogicalNot(a);
					} else {
						OrBool(false);
					}
				}
				
				// Function call
				"call": {
					if (length(oclass.node.children) >= 1) {
						fn = ograph2Orbit(graph, oclass.node.children[0]);
						args = map(tail(oclass.node.children), \argId -> ograph2Orbit(graph, argId));
						OrFunction(fn, args);
					} else {
						OrInt(0);
					}
				}
				
				// Control structures
				"if": {
					if (length(oclass.node.children) >= 3) {
						cond = ograph2Orbit(graph, oclass.node.children[0]);
						then = ograph2Orbit(graph, oclass.node.children[1]);
						else = ograph2Orbit(graph, oclass.node.children[2]);
						OrIfElse(cond, then, else);
					} else {
						OrInt(0);
					}
				}
				
				"seq": {
					if (length(oclass.node.children) >= 2) {
						a = ograph2Orbit(graph, oclass.node.children[0]);
						b = ograph2Orbit(graph, oclass.node.children[1]);
						OrSequence(a, b);
					} else {
						OrInt(0);
					}
				}
				
				// For unknown operators, return a default value
				default: {
					// Try to get a string representation
					switch (getOClassString(graph, root)) {
						Some(str): OrString(str);
						None(): OrInt(0);
					}
				}
			}
		}
	}
}