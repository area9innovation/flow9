import tools/orbit/orbit_types;
import tools/orbit/ograph;
import tools/orbit/prettyprint;
import string;

export {
	// Convert a full expression to OGraph nodes recursively
	orbit2OGraph(graph : OGraph, expr : OrMath_expr) -> int;

	// Convert ONode back to Orbit expression
	ograph2Orbit(graph : OGraph, classId : int) -> OrMath_expr;
}

// Convert a full expression to OGraph nodes recursively
orbit2OGraph(graph : OGraph, expr : OrMath_expr) -> int {
	belongs = []; // Will be assigned in the graph
	
	switch (expr) {
		// For primitive values, we need to store the actual values
		OrInt(i): {
			node = ONode("Int", [], belongs);
			nodeId = insertONode(graph, node);
			setOClassInt(graph, nodeId, i);
			nodeId;
		}
		OrDouble(d): {
			node = ONode("Double", [], belongs);
			nodeId = insertONode(graph, node);
			setOClassDouble(graph, nodeId, d);
			nodeId;
		}
		OrString(s): {
			node = ONode("String", [], belongs);
			nodeId = insertONode(graph, node);
			setOClassString(graph, nodeId, s);
			nodeId;
		}
		OrBool(b): {
			node = ONode("Bool", [], belongs);
			nodeId = insertONode(graph, node);
			setOClassInt(graph, nodeId, if (b) 1 else 0); // Store as int: true=1, false=0
			nodeId;
		}
		OrIdentifier(id): {
			node = ONode("Identifier", [], belongs);
			nodeId = insertONode(graph, node);
			setOClassString(graph, nodeId, id);
			nodeId;
		}
		OrVariable(id): {
			node = ONode("Variable", [], belongs);
			nodeId = insertONode(graph, node);
			setOClassString(graph, nodeId, id);
			nodeId;
		}
		
		// Binary operations
		OrAdd(a, b): {
			aId = orbit2OGraph(graph, a);
			bId = orbit2OGraph(graph, b);
			node = ONode("+", [aId, bId], belongs);
			insertONode(graph, node);
		}
		OrSubtract(a, b): {
			aId = orbit2OGraph(graph, a);
			bId = orbit2OGraph(graph, b);
			node = ONode("-", [aId, bId], belongs);
			insertONode(graph, node);
		}
		OrMultiply(a, b): {
			aId = orbit2OGraph(graph, a);
			bId = orbit2OGraph(graph, b);
			node = ONode("*", [aId, bId], belongs);
			insertONode(graph, node);
		}
		OrDivide(a, b): {
			aId = orbit2OGraph(graph, a);
			bId = orbit2OGraph(graph, b);
			node = ONode("/", [aId, bId], belongs);
			insertONode(graph, node);
		}
		OrEquals(a, b): {
			aId = orbit2OGraph(graph, a);
			bId = orbit2OGraph(graph, b);
			node = ONode("=", [aId, bId], belongs);
			insertONode(graph, node);
		}
		OrNotEquals(a, b): {
			aId = orbit2OGraph(graph, a);
			bId = orbit2OGraph(graph, b);
			node = ONode("!=", [aId, bId], belongs);
			insertONode(graph, node);
		}
		OrGreaterThan(a, b): {
			aId = orbit2OGraph(graph, a);
			bId = orbit2OGraph(graph, b);
			node = ONode(">", [aId, bId], belongs);
			insertONode(graph, node);
		}
		OrGreaterEquals(a, b): {
			aId = orbit2OGraph(graph, a);
			bId = orbit2OGraph(graph, b);
			node = ONode(">=", [aId, bId], belongs);
			insertONode(graph, node);
		}
		OrLessThan(a, b): {
			aId = orbit2OGraph(graph, a);
			bId = orbit2OGraph(graph, b);
			node = ONode("<", [aId, bId], belongs);
			insertONode(graph, node);
		}
		OrLessEquals(a, b): {
			aId = orbit2OGraph(graph, a);
			bId = orbit2OGraph(graph, b);
			node = ONode("<=", [aId, bId], belongs);
			insertONode(graph, node);
		}
		OrLogicalAnd(a, b): {
			aId = orbit2OGraph(graph, a);
			bId = orbit2OGraph(graph, b);
			node = ONode("&&", [aId, bId], belongs);
			insertONode(graph, node);
		}
		OrLogicalOr(a, b): {
			aId = orbit2OGraph(graph, a);
			bId = orbit2OGraph(graph, b);
			node = ONode("||", [aId, bId], belongs);
			insertONode(graph, node);
		}
		
		// Unary operations
		OrNegate(a): {
			aId = orbit2OGraph(graph, a);
			node = ONode("negate", [aId], belongs);
			insertONode(graph, node);
		}
		OrLogicalNot(a): {
			aId = orbit2OGraph(graph, a);
			node = ONode("!", [aId], belongs);
			insertONode(graph, node);
		}
		
		// Function call
		OrFunction(fn, args): {
			fnId = orbit2OGraph(graph, fn);
			argIds = map(args, \arg -> orbit2OGraph(graph, arg));
			node = ONode("call", concat([fnId], argIds), belongs);
			insertONode(graph, node);
		}
		
		// Control structures
		OrIfElse(cond, thenExpr, elseExpr): {
			condId = orbit2OGraph(graph, cond);
			thenId = orbit2OGraph(graph, thenExpr);
			elseId = orbit2OGraph(graph, elseExpr);
			node = ONode("if", [condId, thenId, elseId], belongs);
			insertONode(graph, node);
		}
		
		OrSequence(a, b): {
			aId = orbit2OGraph(graph, a);
			bId = orbit2OGraph(graph, b);
			node = ONode("seq", [aId, bId], belongs);
			insertONode(graph, node);
		}
		
		// For anything else, just use a generic representation
		default: {
			println("TODO: Handle expression type in orbit2ograph: " + prettyOrbit(expr));
			// Create node with a generic "unknown" op
			node = ONode("unknown", [], belongs);
			nodeId = insertONode(graph, node);
			// Store the string representation of the expression
			setOClassString(graph, nodeId, prettyOrbit(expr));
			nodeId;
		}
	}
}

// Convert ONode back to Orbit expression
ograph2Orbit(graph : OGraph, classId : int) -> OrMath_expr {
	root = findORoot(graph, classId);
	
	switch (lookupOClass(graph, root)) {
		None(): {
			// Node not found, return a default value
			OrInt(0);
		}
		Some(oclass): {
			op = oclass.node.op;
			
			if (op == "Int") {
				switch (getOClassInt(graph, root)) {
					Some(i): OrInt(i);
					None(): OrInt(0);
				}
			} else if (op == "Double") {
				switch (getOClassDouble(graph, root)) {
					Some(d): OrDouble(d);
					None(): OrDouble(0.0);
				}
			} else if (op == "String") {
				switch (getOClassString(graph, root)) {
					Some(s): OrString(s);
					None(): OrString("");
				}
			} else if (op == "Bool") {
				switch (getOClassInt(graph, root)) {
					Some(i): OrBool(i != 0);
					None(): OrBool(false);
				}
			} else if (op == "Identifier") {
				switch (getOClassString(graph, root)) {
					Some(id): OrIdentifier(id);
					None(): OrIdentifier("unknown");
				}
			} else if (op == "Variable") {
				switch (getOClassString(graph, root)) {
					Some(id): OrVariable(id);
					None(): OrVariable("unknown");
				}
			} 
			// Binary operations
			else if (op == "+") {
				if (length(oclass.node.children) >= 2) {
					a = ograph2Orbit(graph, oclass.node.children[0]);
					b = ograph2Orbit(graph, oclass.node.children[1]);
					OrAdd(a, b);
				} else {
					OrInt(0); // Default if children missing
				}
			} else if (op == "-") {
				if (length(oclass.node.children) >= 2) {
					a = ograph2Orbit(graph, oclass.node.children[0]);
					b = ograph2Orbit(graph, oclass.node.children[1]);
					OrSubtract(a, b);
				} else {
					OrInt(0);
				}
			} else if (op == "*") {
				if (length(oclass.node.children) >= 2) {
					a = ograph2Orbit(graph, oclass.node.children[0]);
					b = ograph2Orbit(graph, oclass.node.children[1]);
					OrMultiply(a, b);
				} else {
					OrInt(1);
				}
			} else if (op == "/") {
				if (length(oclass.node.children) >= 2) {
					a = ograph2Orbit(graph, oclass.node.children[0]);
					b = ograph2Orbit(graph, oclass.node.children[1]);
					OrDivide(a, b);
				} else {
					OrInt(0);
				}
			} else if (op == "=") {
				if (length(oclass.node.children) >= 2) {
					a = ograph2Orbit(graph, oclass.node.children[0]);
					b = ograph2Orbit(graph, oclass.node.children[1]);
					OrEquals(a, b);
				} else {
					OrBool(false);
				}
			} else if (op == "!=") {
				if (length(oclass.node.children) >= 2) {
					a = ograph2Orbit(graph, oclass.node.children[0]);
					b = ograph2Orbit(graph, oclass.node.children[1]);
					OrNotEquals(a, b);
				} else {
					OrBool(false);
				}
			} else if (op == ">") {
				if (length(oclass.node.children) >= 2) {
					a = ograph2Orbit(graph, oclass.node.children[0]);
					b = ograph2Orbit(graph, oclass.node.children[1]);
					OrGreaterThan(a, b);
				} else {
					OrBool(false);
				}
			} else if (op == ">=") {
				if (length(oclass.node.children) >= 2) {
					a = ograph2Orbit(graph, oclass.node.children[0]);
					b = ograph2Orbit(graph, oclass.node.children[1]);
					OrGreaterEquals(a, b);
				} else {
					OrBool(false);
				}
			} else if (op == "<") {
				if (length(oclass.node.children) >= 2) {
					a = ograph2Orbit(graph, oclass.node.children[0]);
					b = ograph2Orbit(graph, oclass.node.children[1]);
					OrLessThan(a, b);
				} else {
					OrBool(false);
				}
			} else if (op == "<=") {
				if (length(oclass.node.children) >= 2) {
					a = ograph2Orbit(graph, oclass.node.children[0]);
					b = ograph2Orbit(graph, oclass.node.children[1]);
					OrLessEquals(a, b);
				} else {
					OrBool(false);
				}
			} else if (op == "&&") {
				if (length(oclass.node.children) >= 2) {
					a = ograph2Orbit(graph, oclass.node.children[0]);
					b = ograph2Orbit(graph, oclass.node.children[1]);
					OrLogicalAnd(a, b);
				} else {
					OrBool(false);
				}
			} else if (op == "||") {
				if (length(oclass.node.children) >= 2) {
					a = ograph2Orbit(graph, oclass.node.children[0]);
					b = ograph2Orbit(graph, oclass.node.children[1]);
					OrLogicalOr(a, b);
				} else {
					OrBool(false);
				}
			} 
			// Unary operations
			else if (op == "negate") {
				if (length(oclass.node.children) >= 1) {
					a = ograph2Orbit(graph, oclass.node.children[0]);
					OrNegate(a);
				} else {
					OrInt(0);
				}
			} else if (op == "!") {
				if (length(oclass.node.children) >= 1) {
					a = ograph2Orbit(graph, oclass.node.children[0]);
					OrLogicalNot(a);
				} else {
					OrBool(false);
				}
			} 
			// Function call
			else if (op == "call") {
				if (length(oclass.node.children) >= 1) {
					fn = ograph2Orbit(graph, oclass.node.children[0]);
					args = map(tail(oclass.node.children), \argId -> ograph2Orbit(graph, argId));
					OrFunction(fn, args);
				} else {
					OrInt(0);
				}
			} 
			// Control structures
			else if (op == "if") {
				if (length(oclass.node.children) >= 3) {
					cond = ograph2Orbit(graph, oclass.node.children[0]);
					then = ograph2Orbit(graph, oclass.node.children[1]);
					else = ograph2Orbit(graph, oclass.node.children[2]);
					OrIfElse(cond, then, else);
				} else {
					OrInt(0);
				}
			} else if (op == "seq") {
				if (length(oclass.node.children) >= 2) {
					a = ograph2Orbit(graph, oclass.node.children[0]);
					b = ograph2Orbit(graph, oclass.node.children[1]);
					OrSequence(a, b);
				} else {
					OrInt(0);
				}
			} 
			// For unknown operators, return a default value
			else {
				// Try to get a string representation
				switch (getOClassString(graph, root)) {
					Some(str): OrString(str);
					None(): OrInt(0);
				}
			}
		}
	}
}