import tools/orbit/orbit2core;
import tools/orbit/orbit_env;
import tools/orbit/prettyprint; // For prettyOrbit function
import ds/tree;
import string;

export {
	// Result of pattern matching: Either a mapping of variable bindings or a failure
	PatternResult ::= PatternSuccess, PatternFailure;
		PatternSuccess(bindings : Tree<string, OrMath_expr>); // Variable name to value binding
		PatternFailure();

	// Check if an expression is a constructor (capitalized function name)
	isConstructor(expr : OrMath_expr) -> bool;

	// Main unification function: Match a pattern against an expression
	// Returns either PatternSuccess with variable bindings or PatternFailure
	unify(pattern : OrMath_expr, expr : OrMath_expr) -> PatternResult;

	// Apply variable bindings to an expression
	applyBindings(expr : OrMath_expr, bindings : Tree<string, OrMath_expr>) -> OrMath_expr;

	// Execute a match expression
	executeMatch(env : OrbEnv, matchExpr : OrMath_expr, patterns : OrMath_expr, 
		interpreter : (OrbEnv, OrMath_expr) -> OrbEnv) -> OrbEnv;
}

// Check if an expression is a constructor (capitalized function name)
isConstructor(expr : OrMath_expr) -> bool {
	switch (expr) {
		OrFunction(fnExpr, args): {
			switch (fnExpr) {
				OrVariable(id): isUppercase(id);
				OrIdentifier(id): isUppercase(id);
				default: false;
			}
		}
		default: false;
	}
}

// Check if a string starts with an uppercase letter
isUppercase(s : string) -> bool {
	strlen(s) > 0 && isUppercaseChar(substring(s, 0, 1));
}

// Check if a character is uppercase
isUppercaseChar(c : string) -> bool {
	strContains("ABCDEFGHIJKLMNOPQRSTUVWXYZ", c);
}

// Main unification function: Match a pattern against an expression
unify(pattern : OrMath_expr, expr : OrMath_expr) -> PatternResult {
	switch (pattern) {
		// Variable pattern: binds the variable to the expression
		OrVariable(id): PatternSuccess(makeTree1(id, expr));
		OrIdentifier(id): PatternSuccess(makeTree1(id, expr));

		// Constructor pattern
		OrFunction(fnPattern, patternArgs): {
			switch (expr) {
				OrFunction(fnExpr, exprArgs): {
					// Check if function names match
					patternFnName = switch (fnPattern) {
						OrVariable(id): id;
						OrIdentifier(id): id;
						default: "";
					}

					exprFnName = switch (fnExpr) {
						OrVariable(id): id;
						OrIdentifier(id): id;
						default: "";
					}

					if (patternFnName == exprFnName && length(patternArgs) == length(exprArgs)) {
						// Recursively unify all arguments
						unifyArgs(patternArgs, exprArgs, makeTree());
					} else {
						PatternFailure();
					}
				}
				default: PatternFailure();
			}
		}

		// Literals must match exactly
		OrInt(i): switch (expr) { OrInt(j): if (i == j) PatternSuccess(makeTree()) else PatternFailure(); default: PatternFailure(); }
		OrDouble(d): switch (expr) { OrDouble(e): if (d == e) PatternSuccess(makeTree()) else PatternFailure(); default: PatternFailure(); }
		OrString(s): switch (expr) { OrString(t): if (s == t) PatternSuccess(makeTree()) else PatternFailure(); default: PatternFailure(); }
		OrBool(b): switch (expr) { OrBool(c): if (b == c) PatternSuccess(makeTree()) else PatternFailure(); default: PatternFailure(); }

		// Structured patterns - arithmetic operations
		OrAdd(a, b): switch (expr) { OrAdd(c, d): unifyBinary(a, b, c, d); default: PatternFailure(); }
		OrSubtract(a, b): switch (expr) { OrSubtract(c, d): unifyBinary(a, b, c, d); default: PatternFailure(); }
		OrMultiply(a, b): switch (expr) { OrMultiply(c, d): unifyBinary(a, b, c, d); default: PatternFailure(); }
		OrDivide(a, b): switch (expr) { OrDivide(c, d): unifyBinary(a, b, c, d); default: PatternFailure(); }
		OrNegate(a): switch (expr) { OrNegate(b): unify(a, b); default: PatternFailure(); }
		OrExponent(a, b): switch (expr) { OrExponent(c, d): unifyBinary(a, b, c, d); default: PatternFailure(); }

		// Structured patterns - comparison operations
		OrEquals(a, b): switch (expr) { OrEquals(c, d): unifyBinary(a, b, c, d); default: PatternFailure(); }
		OrNotEquals(a, b): switch (expr) { OrNotEquals(c, d): unifyBinary(a, b, c, d); default: PatternFailure(); }
		OrGreaterThan(a, b): switch (expr) { OrGreaterThan(c, d): unifyBinary(a, b, c, d); default: PatternFailure(); }
		OrGreaterEquals(a, b): switch (expr) { OrGreaterEquals(c, d): unifyBinary(a, b, c, d); default: PatternFailure(); }
		OrLessThan(a, b): switch (expr) { OrLessThan(c, d): unifyBinary(a, b, c, d); default: PatternFailure(); }
		OrLessEquals(a, b): switch (expr) { OrLessEquals(c, d): unifyBinary(a, b, c, d); default: PatternFailure(); }

		// Structured patterns - logical operations
		OrLogicalAnd(a, b): switch (expr) { OrLogicalAnd(c, d): unifyBinary(a, b, c, d); default: PatternFailure(); }
		OrLogicalOr(a, b): switch (expr) { OrLogicalOr(c, d): unifyBinary(a, b, c, d); default: PatternFailure(); }
		OrLogicalNot(a): switch (expr) { OrLogicalNot(b): unify(a, b); default: PatternFailure(); }

		// Structured patterns - set operations
		OrUnion(a, b): switch (expr) { OrUnion(c, d): unifyBinary(a, b, c, d); default: PatternFailure(); }
		OrIntersection(a, b): switch (expr) { OrIntersection(c, d): unifyBinary(a, b, c, d); default: PatternFailure(); }
		OrSubset(a, b): switch (expr) { OrSubset(c, d): unifyBinary(a, b, c, d); default: PatternFailure(); }
		OrElementOf(a, b): switch (expr) { OrElementOf(c, d): unifyBinary(a, b, c, d); default: PatternFailure(); }
		OrArray(items): switch (expr) { 
			OrArray(exprItems): {
				if (length(items) == length(exprItems)) {
					unifyArgs(items, exprItems, makeTree());
				} else {
					PatternFailure();
				}
			}
			default: PatternFailure();
		}
		OrSetLiteral(items): switch (expr) { 
			OrSetLiteral(exprItems): {
				if (length(items) == length(exprItems)) {
					unifyArgs(items, exprItems, makeTree());
				} else {
					PatternFailure();
				}
			}
			default: PatternFailure();
		}
		// Pattern matching for SetComprehension
		OrSetComprehension(items, predicate): switch (expr) {
			OrSetComprehension(exprItems, exprPredicate): {
				// Match both items array and the predicate expression
				if (length(items) == length(exprItems)) {
					switch (unifyArgs(items, exprItems, makeTree())) {
						PatternSuccess(itemsBindings): {
							// Now match the predicate
							switch (unify(predicate, exprPredicate)) {
								PatternSuccess(predicateBindings): mergeBindings(itemsBindings, predicateBindings);
								PatternFailure(): PatternFailure();
							}
						}
						PatternFailure(): PatternFailure();
					}
				} else {
					PatternFailure();
				}
			}
			default: PatternFailure();
		}

		// Control flow patterns
		OrIfElse(cond, then, els): switch (expr) { 
			OrIfElse(exprCond, exprThen, exprElse): {
				// Need to unify all three parts
				switch(unify(cond, exprCond)) {
					PatternSuccess(condBindings): {
						switch(unify(then, exprThen)) {
							PatternSuccess(thenBindings): {
								switch(unify(els, exprElse)) {
									PatternSuccess(elseBindings): {
										// Merge all bindings
										switch(mergeBindings(condBindings, thenBindings)) {
											PatternSuccess(merged1): mergeBindings(merged1, elseBindings);
											PatternFailure(): PatternFailure();
										}
									}
									PatternFailure(): PatternFailure();
								}
							}
							PatternFailure(): PatternFailure();
						}
					}
					PatternFailure(): PatternFailure();
				}
			}
			default: PatternFailure();
		}

		// Let binding patterns
		OrLet(idType, val): switch (expr) {
			OrLet(exprIdType, exprVal): {
				// Must match both the id/type and the value
				if (idType.id == exprIdType.id) {
					// For simplicity, we don't match on type annotations yet
					unify(val, exprVal);
				} else {
					PatternFailure();
				}
			}
			default: PatternFailure();
		}
		
		// Function and sequence patterns
		OrSequence(a, b): switch (expr) {
			OrSequence(c, d): unifyBinary(a, b, c, d);
			default: PatternFailure();
		}
		OrLambda(bindings, params, body): switch (expr) {
			OrLambda(exprBindings, exprParams, exprBody): {
				// This is a complex match - for now we'll do a simplified version
				if (length(params) == length(exprParams)) {
					// Match parameters by name
					paramsMatch = foldi(params, true, \i, match, param -> {
						match && param.id == exprParams[i].id;
					});
					
					if (paramsMatch) {
						// If parameters match, unify the bodies
						unify(body, exprBody);
					} else {
						PatternFailure();
					}
				} else {
					PatternFailure();
				}
			}
			default: PatternFailure();
		}

		// Pattern matching for type annotations
		OrTypeAnnotation(expr1, type1): switch (expr) {
			OrTypeAnnotation(expr2, type2): {
				// Match both the expression and its type annotation
				switch (unify(expr1, expr2)) {
					PatternSuccess(exprBindings): {
						switch (unify(type1, type2)) {
							PatternSuccess(typeBindings): mergeBindings(exprBindings, typeBindings);
							PatternFailure(): PatternFailure();
						}
					}
					PatternFailure(): PatternFailure();
				}
			}
			default: PatternFailure();
		}

		// Pattern matching for type substitutions
		OrTypeSubstitution(expr1, id1, replacement1): switch (expr) {
			OrTypeSubstitution(expr2, id2, replacement2): {
				// Match the base expression, the ID being substituted, and the replacement
				switch (unify(expr1, expr2)) {
					PatternSuccess(exprBindings): {
						switch (unify(id1, id2)) {
							PatternSuccess(idBindings): {
								switch (unify(replacement1, replacement2)) {
									PatternSuccess(replBindings): {
										// Need to merge all three binding sets
										switch (mergeBindings(exprBindings, idBindings)) {
											PatternSuccess(temp): mergeBindings(temp, replBindings);
											PatternFailure(): PatternFailure();
										}
									}
									PatternFailure(): PatternFailure();
								}
							}
							PatternFailure(): PatternFailure();
						}
					}
					PatternFailure(): PatternFailure();
				}
			}
			default: PatternFailure();
		}

		// Pattern matching for rewrite rules
		OrRule(lhs1, rhs1, conds1): switch (expr) {
			OrRule(lhs2, rhs2, conds2): {
				// Match left-hand side, right-hand side, and conditions
				switch (unify(lhs1, lhs2)) {
					PatternSuccess(lhsBindings): {
						switch (unify(rhs1, rhs2)) {
							PatternSuccess(rhsBindings): {
								// For conditions, we need to check if they're the same length first
								if (length(conds1) != length(conds2)) {
									PatternFailure();
								} else {
									// Match each condition and accumulate bindings
									condBindings = fold(mapi(conds1, \i, cond1 -> {
										unify(cond1.math_expr, conds2[i].math_expr);
									}), PatternSuccess(makeTree()), \acc, res -> {
										switch (acc) {
											PatternSuccess(accBindings): {
												switch (res) {
													PatternSuccess(newBindings): mergeBindings(accBindings, newBindings);
													PatternFailure(): PatternFailure();
												}
											}
											PatternFailure(): PatternFailure();
										}
									});
									
									// Merge all bindings
									switch (condBindings) {
										PatternSuccess(cBindings): {
											switch (mergeBindings(lhsBindings, rhsBindings)) {
												PatternSuccess(temp): mergeBindings(temp, cBindings);
												PatternFailure(): PatternFailure();
											}
										}
										PatternFailure(): PatternFailure();
									}
								}
							}
							PatternFailure(): PatternFailure();
						}
					}
					PatternFailure(): PatternFailure();
				}
			}
			default: PatternFailure();
		}

		// Pattern matching for Equivalence (same as Rule but symmetric)
		OrEquivalence(lhs1, rhs1, conds1): switch (expr) {
			OrEquivalence(lhs2, rhs2, conds2): {
				// Same implementation as for Rule
				switch (unify(lhs1, lhs2)) {
					PatternSuccess(lhsBindings): {
						switch (unify(rhs1, rhs2)) {
							PatternSuccess(rhsBindings): {
								if (length(conds1) != length(conds2)) {
									PatternFailure();
								} else {
									condBindings = fold(mapi(conds1, \i, cond1 -> {
										unify(cond1.math_expr, conds2[i].math_expr);
									}), PatternSuccess(makeTree()), \acc, res -> {
										switch (acc) {
											PatternSuccess(accBindings): {
												switch (res) {
													PatternSuccess(newBindings): mergeBindings(accBindings, newBindings);
													PatternFailure(): PatternFailure();
												}
											}
											PatternFailure(): PatternFailure();
										}
									});
									
									switch (condBindings) {
										PatternSuccess(cBindings): {
											switch (mergeBindings(lhsBindings, rhsBindings)) {
												PatternSuccess(temp): mergeBindings(temp, cBindings);
												PatternFailure(): PatternFailure();
											}
										}
										PatternFailure(): PatternFailure();
									}
								}
							}
							PatternFailure(): PatternFailure();
						}
					}
					PatternFailure(): PatternFailure();
				}
			}
			default: PatternFailure();
		}

		// Pattern matching for Entailment (same structure as Rule/Equivalence)
		OrEntailment(lhs1, rhs1, conds1): switch (expr) {
			OrEntailment(lhs2, rhs2, conds2): {
				// Same implementation as for Rule/Equivalence
				switch (unify(lhs1, lhs2)) {
					PatternSuccess(lhsBindings): {
						switch (unify(rhs1, rhs2)) {
							PatternSuccess(rhsBindings): {
								if (length(conds1) != length(conds2)) {
									PatternFailure();
								} else {
									condBindings = fold(mapi(conds1, \i, cond1 -> {
										unify(cond1.math_expr, conds2[i].math_expr);
									}), PatternSuccess(makeTree()), \acc, res -> {
										switch (acc) {
											PatternSuccess(accBindings): {
												switch (res) {
													PatternSuccess(newBindings): mergeBindings(accBindings, newBindings);
													PatternFailure(): PatternFailure();
												}
											}
											PatternFailure(): PatternFailure();
										}
									});
									
									switch (condBindings) {
										PatternSuccess(cBindings): {
											switch (mergeBindings(lhsBindings, rhsBindings)) {
												PatternSuccess(temp): mergeBindings(temp, cBindings);
												PatternFailure(): PatternFailure();
											}
										}
										PatternFailure(): PatternFailure();
									}
								}
							}
							PatternFailure(): PatternFailure();
						}
					}
					PatternFailure(): PatternFailure();
				}
			}
			default: PatternFailure();
		}

		// Pattern matching for quantifiers (Forall)
		OrForall(vars1, body1): switch (expr) {
			OrForall(vars2, body2): {
				// Check that we have the same number of variables
				if (length(vars1) != length(vars2)) {
					PatternFailure();
				} else {
					// Match the variables array first
					switch (unifyArgs(vars1, vars2, makeTree())) {
						PatternSuccess(varsBindings): {
							// Then match the body
							switch (unify(body1, body2)) {
								PatternSuccess(bodyBindings): mergeBindings(varsBindings, bodyBindings);
								PatternFailure(): PatternFailure();
							}
						}
						PatternFailure(): PatternFailure();
					}
				}
			}
			default: PatternFailure();
		}

		// Pattern matching for quantifiers (Exists)
		OrExists(vars1, body1): switch (expr) {
			OrExists(vars2, body2): {
				// Same implementation as for Forall
				if (length(vars1) != length(vars2)) {
					PatternFailure();
				} else {
					switch (unifyArgs(vars1, vars2, makeTree())) {
						PatternSuccess(varsBindings): {
							switch (unify(body1, body2)) {
								PatternSuccess(bodyBindings): mergeBindings(varsBindings, bodyBindings);
								PatternFailure(): PatternFailure();
							}
						}
						PatternFailure(): PatternFailure();
					}
				}
			}
			default: PatternFailure();
		}

		// Default case: patterns don't match
		default: PatternFailure();
	}
}

// Helper for unifying binary operations
unifyBinary(patternLeft : OrMath_expr, patternRight : OrMath_expr, exprLeft : OrMath_expr, exprRight : OrMath_expr) -> PatternResult {
	switch (unify(patternLeft, exprLeft)) {
		PatternSuccess(leftBindings): {
			switch (unify(patternRight, exprRight)) {
				PatternSuccess(rightBindings): {
					// Merge bindings, checking for consistency
					mergeBindings(leftBindings, rightBindings);
				}
				PatternFailure(): PatternFailure();
			}
		}
		PatternFailure(): PatternFailure();
	}
}

// Merge two binding sets, checking for consistency
mergeBindings(left : Tree<string, OrMath_expr>, right : Tree<string, OrMath_expr>) -> PatternResult {
	fold(getTreeKeys(right), PatternSuccess(left), \acc, key -> {
		switch (acc) {
			PatternSuccess(accBindings): {
				rightValue = lookupTreeDef(right, key, OrInt(0));
				switch (lookupTree(accBindings, key)) {
					Some(leftValue): {
						// If the same variable is bound to different values, fail
						if (leftValue == rightValue) {
							PatternSuccess(accBindings);
						} else {
							PatternFailure();
						}
					}
					None(): {
						// New binding is fine
						PatternSuccess(setTree(accBindings, key, rightValue));
					}
				}
			}
			PatternFailure(): PatternFailure();
		}
	});
}

// Helper for unifying function/constructor arguments
unifyArgs(patternArgs : [OrMath_expr], exprArgs : [OrMath_expr], accBindings : Tree<string, OrMath_expr>) -> PatternResult {
	if (length(patternArgs) == 0) {
		PatternSuccess(accBindings);
	} else {
		// Unify the first argument
		switch (unify(patternArgs[0], exprArgs[0])) {
			PatternSuccess(firstBindings): {
				// Merge bindings
				switch (mergeBindings(accBindings, firstBindings)) {
					PatternSuccess(mergedBindings): {
						// Recursively unify remaining arguments
						unifyArgs(tail(patternArgs), tail(exprArgs), mergedBindings);
					}
					PatternFailure(): PatternFailure();
				}
			}
			PatternFailure(): PatternFailure();
		}
	}
}

// Apply variable bindings to an expression
applyBindings(expr : OrMath_expr, bindings : Tree<string, OrMath_expr>) -> OrMath_expr {
	switch (expr) {
		// Variable substitution - core of pattern matching
		OrVariable(id): {
			switch (lookupTree(bindings, id)) {
				Some(val): val;
				None(): expr;
			}
		}
		OrIdentifier(id): {
			switch (lookupTree(bindings, id)) {
				Some(val): val;
				None(): expr;
			}
		}

		// Function application and constructors
		OrFunction(fnExpr, args): {
			OrFunction(
				applyBindings(fnExpr, bindings),
				map(args, \arg -> applyBindings(arg, bindings))
			);
		}

		// Arithmetic operations
		OrAdd(a, b): OrAdd(applyBindings(a, bindings), applyBindings(b, bindings));
		OrSubtract(a, b): OrSubtract(applyBindings(a, bindings), applyBindings(b, bindings));
		OrMultiply(a, b): OrMultiply(applyBindings(a, bindings), applyBindings(b, bindings));
		OrDivide(a, b): OrDivide(applyBindings(a, bindings), applyBindings(b, bindings));
		OrNegate(a): OrNegate(applyBindings(a, bindings));
		OrExponent(a, b): OrExponent(applyBindings(a, bindings), applyBindings(b, bindings));

		// Comparison operations
		OrEquals(a, b): OrEquals(applyBindings(a, bindings), applyBindings(b, bindings));
		OrNotEquals(a, b): OrNotEquals(applyBindings(a, bindings), applyBindings(b, bindings));
		OrGreaterThan(a, b): OrGreaterThan(applyBindings(a, bindings), applyBindings(b, bindings));
		OrGreaterEquals(a, b): OrGreaterEquals(applyBindings(a, bindings), applyBindings(b, bindings));
		OrLessThan(a, b): OrLessThan(applyBindings(a, bindings), applyBindings(b, bindings));
		OrLessEquals(a, b): OrLessEquals(applyBindings(a, bindings), applyBindings(b, bindings));

		// Logical operations
		OrLogicalAnd(a, b): OrLogicalAnd(applyBindings(a, bindings), applyBindings(b, bindings));
		OrLogicalOr(a, b): OrLogicalOr(applyBindings(a, bindings), applyBindings(b, bindings));
		OrLogicalNot(a): OrLogicalNot(applyBindings(a, bindings));

		// Control flow
		OrIfElse(cond, thenExpr, elseExpr): OrIfElse(
			applyBindings(cond, bindings),
			applyBindings(thenExpr, bindings),
			applyBindings(elseExpr, bindings)
		);

		// Structure and sequence
		OrLambda(lambdaBindings, params, body): {
			// Transform the lambda bindings
			newBindings = map(lambdaBindings, \binding -> {
				OrEnvBinding(binding.id, applyBindings(binding.math_expr, bindings));
			});
			// Keep parameter names but transform body
			OrLambda(newBindings, params, applyBindings(body, bindings));
		}
		OrSequence(a, b): OrSequence(applyBindings(a, bindings), applyBindings(b, bindings));
		OrLet(idType, val): OrLet(idType, applyBindings(val, bindings));

		// Set operations
		OrArray(items): OrArray(map(items, \item -> applyBindings(item, bindings)));
		OrSetLiteral(items): OrSetLiteral(map(items, \item -> applyBindings(item, bindings)));
		OrUnion(a, b): OrUnion(applyBindings(a, bindings), applyBindings(b, bindings));
		OrIntersection(a, b): OrIntersection(applyBindings(a, bindings), applyBindings(b, bindings));
		OrElementOf(a, b): OrElementOf(applyBindings(a, bindings), applyBindings(b, bindings));
		OrSubset(a, b): OrSubset(applyBindings(a, bindings), applyBindings(b, bindings));
		OrSetComprehension(items, predicate): OrSetComprehension(
			map(items, \item -> applyBindings(item, bindings)),
			applyBindings(predicate, bindings)
		);

		// Type operations
		OrTypeAnnotation(expr1, type1): OrTypeAnnotation(
			applyBindings(expr1, bindings),
			applyBindings(type1, bindings)
		);
		OrTypeSubstitution(expr1, id1, replacement1): OrTypeSubstitution(
			applyBindings(expr1, bindings),
			applyBindings(id1, bindings),
			applyBindings(replacement1, bindings)
		);

		// Rewrite rules
		OrRule(a, b, conds): OrRule(
			applyBindings(a, bindings), 
			applyBindings(b, bindings),
			map(conds, \cond -> OrConditional(applyBindings(cond.math_expr, bindings)))
		);
		OrEquivalence(a, b, conds): OrEquivalence(
			applyBindings(a, bindings), 
			applyBindings(b, bindings),
			map(conds, \cond -> OrConditional(applyBindings(cond.math_expr, bindings)))
		);
		OrEntailment(a, b, conds): OrEntailment(
			applyBindings(a, bindings), 
			applyBindings(b, bindings),
			map(conds, \cond -> OrConditional(applyBindings(cond.math_expr, bindings)))
		);

		// Quantifiers
		OrForall(vars, body): OrForall(
			map(vars, \v -> applyBindings(v, bindings)),
			applyBindings(body, bindings)
		);
		OrExists(vars, body): OrExists(
			map(vars, \v -> applyBindings(v, bindings)),
			applyBindings(body, bindings)
		);

		// Other operations that need variable substitution
		OrMatch(matchExpr, patterns): OrMatch(applyBindings(matchExpr, bindings), applyBindings(patterns, bindings));

		// Default: primitives and unimplemented expressions don't need substitution
		default: expr; // For literals (Int, Double, String, Bool) and other expressions, return as is
	}
}



// Execute a match expression
// Takes the already evaluated expression to match and the patterns to match against
// interpreter parameter: Function to interpret expressions with conditions
executeMatch(env : OrbEnv, exprValue : OrMath_expr, patterns : OrMath_expr, 
	interpreter : (OrbEnv, OrMath_expr) -> OrbEnv) -> OrbEnv {
	// Implement pattern matching with multiple patterns
	tryPatterns(patterns, env, exprValue, interpreter);
}

// Try to match a sequence of patterns
tryPatterns(patterns : OrMath_expr, env : OrbEnv, exprValue : OrMath_expr, 
	interpreter : (OrbEnv, OrMath_expr) -> OrbEnv) -> OrbEnv {
	switch (patterns) {
		// Try a single rule
		OrRule(patternExpr, bodyExpr, conditionals): {
			// Extract the actual body and next pattern if body is a sequence
			actualBodyRef = ref bodyExpr;
			nextRuleRef = ref None();

			if (bodyExpr.structname == "OrSequence") {
				switch (bodyExpr) {
					OrSequence(seqBody, seqNext): {
						actualBodyRef := seqBody;
						nextRuleRef := Some(seqNext);
					}
					default: {}
				}
			}

			// Try to unify the pattern with the expression
			switch (unify(patternExpr, exprValue)) {
				PatternSuccess(bindings): {
					// Check condition if present
					if (isConditionSatisfied(conditionals, bindings, env, interpreter)) {
						// Apply bindings and evaluate the body
						boundBody = applyBindings(^actualBodyRef, bindings);
						
						// Update environment with pattern variables
						boundEnv = fold(getTreeKeys(bindings), env, \accEnv, key -> {
							bindVar(accEnv, key, lookupTreeDef(bindings, key, OrInt(0)));
						});
						
						// Return environment with updated bindings and the body to be evaluated by interpreter
						OrbEnv(boundEnv with result = boundBody);
					} else {
						// If condition failed, try next rule if available
						switch (^nextRuleRef) {
							Some(next): {
								// Extract the next pattern and try it
								tryPatterns(next, env, exprValue, interpreter);
							}
							None(): {
								// No next pattern, return the original expression as fallback
								OrbEnv(env with result = exprValue);
							}
						}
					}
				}
				PatternFailure(): {
					// Pattern didn't match

					// Check if there's a next pattern in a sequence
					switch (^nextRuleRef) {
						Some(next): {
							// Extract the next pattern and try it
							tryPatterns(next, env, exprValue, interpreter);
						}
						None(): {
							// No next pattern, return the original expression as fallback
							OrbEnv(env with result = exprValue);
						}
					}
				}
			}
		}
		
		// Handle a sequence of patterns - try left first, then right if left fails
		OrSequence(left, right): {
			// Try the left pattern first
			leftResult = tryPatterns(left, env, exprValue, interpreter);
			
			// If we get back the original expression, it means no pattern matched
			// Try the right pattern in that case
			if (leftResult.result == exprValue) {
				// Try the right pattern
				tryPatterns(right, leftResult, exprValue, interpreter);
			} else {
				// A pattern matched on the left side
				leftResult;
			}
		}
		
		default: {
			println("Invalid pattern structure in match: " + prettyOrbit(patterns));
			OrbEnv(env with result = exprValue); // Return original as fallback
		}
	}
}

// Evaluate conditions in pattern matching rules
isConditionSatisfied(conditionals : [OrConditional], bindings : Tree<string, OrMath_expr>, env : OrbEnv,
	interpreter : (OrbEnv, OrMath_expr) -> OrbEnv) -> bool {
	if (length(conditionals) == 0) {
		// No conditions means always satisfied
		true;
	} else {
		// Create a new environment with the bindings first
		condEnv = fold(getTreeKeys(bindings), env, \accEnv, key -> {
			bindVar(accEnv, key, lookupTreeDef(bindings, key, OrInt(0)));
		});

		// Evaluate each condition with the bindings applied
		fold(conditionals, true, \allSatisfied, cond -> {
			// Short-circuit if previous condition failed
			if (!allSatisfied) false 
			else {
				// Apply the bindings to the condition
				boundCondition = applyBindings(cond.math_expr, bindings);
				
				
				// Evaluate the condition expression using the passed interpreter function
				evalResult = interpreter(condEnv, boundCondition);
				
				
				// Convert result to boolean
				switch (evalResult.result) {
					OrBool(b): b;
					OrInt(i): i != 0;
					OrDouble(d): d != 0.0;
					OrString(s): s != "";
					default: {
						println("Warning: Non-boolean condition evaluated to " + 
							evalResult.result.structname + ": " + 
							prettyOrbit(evalResult.result));
						false;
					}
				}
			}
		});
	}
}