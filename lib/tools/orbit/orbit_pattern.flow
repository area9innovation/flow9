import tools/orbit/orbit2core;
import tools/orbit/orbit_env;
import tools/orbit/prettyprint; // For prettyOrbit function
import ds/tree;
import string;

export {
	// Result of pattern matching: Either a mapping of variable bindings or a failure
	PatternResult ::= PatternSuccess, PatternFailure;
		PatternSuccess(bindings : Tree<string, OrMath_expr>); // Variable name to value binding
		PatternFailure();

	// Check if an expression is a constructor (capitalized function name)
	isConstructor(expr : OrMath_expr) -> bool;

	// Main unification function: Match a pattern against an expression
	// Returns either PatternSuccess with variable bindings or PatternFailure
	unify(pattern : OrMath_expr, expr : OrMath_expr) -> PatternResult;

	// Apply variable bindings to an expression
	applyBindings(expr : OrMath_expr, bindings : Tree<string, OrMath_expr>) -> OrMath_expr;

	// Execute a match expression
	executeMatch(env : OrbEnv, matchExpr : OrMath_expr, patterns : OrMath_expr) -> OrbEnv;
}

// Check if an expression is a constructor (capitalized function name)
isConstructor(expr : OrMath_expr) -> bool {
	switch (expr) {
		OrFunction(fnExpr, args): {
			switch (fnExpr) {
				OrVariable(id): isUppercase(id);
				OrIdentifier(id): isUppercase(id);
				default: false;
			}
		}
		default: false;
	}
}

// Check if a string starts with an uppercase letter
isUppercase(s : string) -> bool {
	strlen(s) > 0 && isUppercaseChar(substring(s, 0, 1));
}

// Check if a character is uppercase
isUppercaseChar(c : string) -> bool {
	strContains("ABCDEFGHIJKLMNOPQRSTUVWXYZ", c);
}

// Main unification function: Match a pattern against an expression
unify(pattern : OrMath_expr, expr : OrMath_expr) -> PatternResult {
	switch (pattern) {
		// Variable pattern: binds the variable to the expression
		OrVariable(id): PatternSuccess(makeTree1(id, expr));
		OrIdentifier(id): PatternSuccess(makeTree1(id, expr));

		// Constructor pattern
		OrFunction(fnPattern, patternArgs): {
			switch (expr) {
				OrFunction(fnExpr, exprArgs): {
					// Check if function names match
					patternFnName = switch (fnPattern) {
						OrVariable(id): id;
						OrIdentifier(id): id;
						default: "";
					}

					exprFnName = switch (fnExpr) {
						OrVariable(id): id;
						OrIdentifier(id): id;
						default: "";
					}

					if (patternFnName == exprFnName && length(patternArgs) == length(exprArgs)) {
						// Recursively unify all arguments
						unifyArgs(patternArgs, exprArgs, makeTree());
					} else {
						PatternFailure();
					}
				}
				default: PatternFailure();
			}
		}

		// Literals must match exactly
		OrInt(i): switch (expr) { OrInt(j): if (i == j) PatternSuccess(makeTree()) else PatternFailure(); default: PatternFailure(); }
		OrDouble(d): switch (expr) { OrDouble(e): if (d == e) PatternSuccess(makeTree()) else PatternFailure(); default: PatternFailure(); }
		OrString(s): switch (expr) { OrString(t): if (s == t) PatternSuccess(makeTree()) else PatternFailure(); default: PatternFailure(); }
		OrBool(b): switch (expr) { OrBool(c): if (b == c) PatternSuccess(makeTree()) else PatternFailure(); default: PatternFailure(); }

		// Structured patterns - arithmetic operations
		OrAdd(a, b): switch (expr) { OrAdd(c, d): unifyBinary(a, b, c, d); default: PatternFailure(); }
		OrSubtract(a, b): switch (expr) { OrSubtract(c, d): unifyBinary(a, b, c, d); default: PatternFailure(); }
		OrMultiply(a, b): switch (expr) { OrMultiply(c, d): unifyBinary(a, b, c, d); default: PatternFailure(); }
		OrDivide(a, b): switch (expr) { OrDivide(c, d): unifyBinary(a, b, c, d); default: PatternFailure(); }
		OrNegate(a): switch (expr) { OrNegate(b): unify(a, b); default: PatternFailure(); }
		OrExponent(a, b): switch (expr) { OrExponent(c, d): unifyBinary(a, b, c, d); default: PatternFailure(); }

		// Structured patterns - comparison operations
		OrEquals(a, b): switch (expr) { OrEquals(c, d): unifyBinary(a, b, c, d); default: PatternFailure(); }
		OrNotEquals(a, b): switch (expr) { OrNotEquals(c, d): unifyBinary(a, b, c, d); default: PatternFailure(); }
		OrGreaterThan(a, b): switch (expr) { OrGreaterThan(c, d): unifyBinary(a, b, c, d); default: PatternFailure(); }
		OrGreaterEquals(a, b): switch (expr) { OrGreaterEquals(c, d): unifyBinary(a, b, c, d); default: PatternFailure(); }
		OrLessThan(a, b): switch (expr) { OrLessThan(c, d): unifyBinary(a, b, c, d); default: PatternFailure(); }
		OrLessEquals(a, b): switch (expr) { OrLessEquals(c, d): unifyBinary(a, b, c, d); default: PatternFailure(); }

		// Structured patterns - logical operations
		OrLogicalAnd(a, b): switch (expr) { OrLogicalAnd(c, d): unifyBinary(a, b, c, d); default: PatternFailure(); }
		OrLogicalOr(a, b): switch (expr) { OrLogicalOr(c, d): unifyBinary(a, b, c, d); default: PatternFailure(); }
		OrLogicalNot(a): switch (expr) { OrLogicalNot(b): unify(a, b); default: PatternFailure(); }

		// Structured patterns - set operations
		OrUnion(a, b): switch (expr) { OrUnion(c, d): unifyBinary(a, b, c, d); default: PatternFailure(); }
		OrIntersection(a, b): switch (expr) { OrIntersection(c, d): unifyBinary(a, b, c, d); default: PatternFailure(); }
		OrSubset(a, b): switch (expr) { OrSubset(c, d): unifyBinary(a, b, c, d); default: PatternFailure(); }
		OrElementOf(a, b): switch (expr) { OrElementOf(c, d): unifyBinary(a, b, c, d); default: PatternFailure(); }
		OrSetLiteral(items): switch (expr) { 
			OrSetLiteral(exprItems): {
				if (length(items) == length(exprItems)) {
					unifyArgs(items, exprItems, makeTree());
				} else {
					PatternFailure();
				}
			}
			default: PatternFailure();
		}

		// Control flow patterns
		OrIfElse(cond, then, els): switch (expr) { 
			OrIfElse(exprCond, exprThen, exprElse): {
				// Need to unify all three parts
				switch(unify(cond, exprCond)) {
					PatternSuccess(condBindings): {
						switch(unify(then, exprThen)) {
							PatternSuccess(thenBindings): {
								switch(unify(els, exprElse)) {
									PatternSuccess(elseBindings): {
										// Merge all bindings
										switch(mergeBindings(condBindings, thenBindings)) {
											PatternSuccess(merged1): mergeBindings(merged1, elseBindings);
											PatternFailure(): PatternFailure();
										}
									}
									PatternFailure(): PatternFailure();
								}
							}
							PatternFailure(): PatternFailure();
						}
					}
					PatternFailure(): PatternFailure();
				}
			}
			default: PatternFailure();
		}

		// Let binding patterns
		OrLet(idType, val): switch (expr) {
			OrLet(exprIdType, exprVal): {
				// Must match both the id/type and the value
				if (idType.id == exprIdType.id) {
					// For simplicity, we don't match on type annotations yet
					unify(val, exprVal);
				} else {
					PatternFailure();
				}
			}
			default: PatternFailure();
		}
		
		// Function and sequence patterns
		OrSequence(a, b): switch (expr) {
			OrSequence(c, d): unifyBinary(a, b, c, d);
			default: PatternFailure();
		}
		OrLambda(bindings, params, body): switch (expr) {
			OrLambda(exprBindings, exprParams, exprBody): {
				// This is a complex match - for now we'll do a simplified version
				if (length(params) == length(exprParams)) {
					// Match parameters by name
					paramsMatch = foldi(params, true, \i, match, param -> {
						match && param.id == exprParams[i].id;
					});
					
					if (paramsMatch) {
						// If parameters match, unify the bodies
						unify(body, exprBody);
					} else {
						PatternFailure();
					}
				} else {
					PatternFailure();
				}
			}
			default: PatternFailure();
		}

		// Default case: patterns don't match
		default: PatternFailure();
	}
}

// Helper for unifying binary operations
unifyBinary(patternLeft : OrMath_expr, patternRight : OrMath_expr, exprLeft : OrMath_expr, exprRight : OrMath_expr) -> PatternResult {
	switch (unify(patternLeft, exprLeft)) {
		PatternSuccess(leftBindings): {
			switch (unify(patternRight, exprRight)) {
				PatternSuccess(rightBindings): {
					// Merge bindings, checking for consistency
					mergeBindings(leftBindings, rightBindings);
				}
				PatternFailure(): PatternFailure();
			}
		}
		PatternFailure(): PatternFailure();
	}
}

// Merge two binding sets, checking for consistency
mergeBindings(left : Tree<string, OrMath_expr>, right : Tree<string, OrMath_expr>) -> PatternResult {
	fold(getTreeKeys(right), PatternSuccess(left), \acc, key -> {
		switch (acc) {
			PatternSuccess(accBindings): {
				rightValue = lookupTreeDef(right, key, OrInt(0));
				switch (lookupTree(accBindings, key)) {
					Some(leftValue): {
						// If the same variable is bound to different values, fail
						if (leftValue == rightValue) {
							PatternSuccess(accBindings);
						} else {
							PatternFailure();
						}
					}
					None(): {
						// New binding is fine
						PatternSuccess(setTree(accBindings, key, rightValue));
					}
				}
			}
			PatternFailure(): PatternFailure();
		}
	});
}

// Helper for unifying function/constructor arguments
unifyArgs(patternArgs : [OrMath_expr], exprArgs : [OrMath_expr], accBindings : Tree<string, OrMath_expr>) -> PatternResult {
	if (length(patternArgs) == 0) {
		PatternSuccess(accBindings);
	} else {
		// Unify the first argument
		switch (unify(patternArgs[0], exprArgs[0])) {
			PatternSuccess(firstBindings): {
				// Merge bindings
				switch (mergeBindings(accBindings, firstBindings)) {
					PatternSuccess(mergedBindings): {
						// Recursively unify remaining arguments
						unifyArgs(tail(patternArgs), tail(exprArgs), mergedBindings);
					}
					PatternFailure(): PatternFailure();
				}
			}
			PatternFailure(): PatternFailure();
		}
	}
}

// Apply variable bindings to an expression
applyBindings(expr : OrMath_expr, bindings : Tree<string, OrMath_expr>) -> OrMath_expr {
	switch (expr) {
		// Variable substitution - core of pattern matching
		OrVariable(id): {
			switch (lookupTree(bindings, id)) {
				Some(val): val;
				None(): expr;
			}
		}
		OrIdentifier(id): {
			switch (lookupTree(bindings, id)) {
				Some(val): val;
				None(): expr;
			}
		}

		// Function application and constructors
		OrFunction(fnExpr, args): {
			OrFunction(
				applyBindings(fnExpr, bindings),
				map(args, \arg -> applyBindings(arg, bindings))
			);
		}

		// Arithmetic operations
		OrAdd(a, b): OrAdd(applyBindings(a, bindings), applyBindings(b, bindings));
		OrSubtract(a, b): OrSubtract(applyBindings(a, bindings), applyBindings(b, bindings));
		OrMultiply(a, b): OrMultiply(applyBindings(a, bindings), applyBindings(b, bindings));
		OrDivide(a, b): OrDivide(applyBindings(a, bindings), applyBindings(b, bindings));
		OrNegate(a): OrNegate(applyBindings(a, bindings));
		OrExponent(a, b): OrExponent(applyBindings(a, bindings), applyBindings(b, bindings));

		// Comparison operations
		OrEquals(a, b): OrEquals(applyBindings(a, bindings), applyBindings(b, bindings));
		OrNotEquals(a, b): OrNotEquals(applyBindings(a, bindings), applyBindings(b, bindings));
		OrGreaterThan(a, b): OrGreaterThan(applyBindings(a, bindings), applyBindings(b, bindings));
		OrGreaterEquals(a, b): OrGreaterEquals(applyBindings(a, bindings), applyBindings(b, bindings));
		OrLessThan(a, b): OrLessThan(applyBindings(a, bindings), applyBindings(b, bindings));
		OrLessEquals(a, b): OrLessEquals(applyBindings(a, bindings), applyBindings(b, bindings));

		// Logical operations
		OrLogicalAnd(a, b): OrLogicalAnd(applyBindings(a, bindings), applyBindings(b, bindings));
		OrLogicalOr(a, b): OrLogicalOr(applyBindings(a, bindings), applyBindings(b, bindings));
		OrLogicalNot(a): OrLogicalNot(applyBindings(a, bindings));

		// Control flow
		OrIfElse(cond, thenExpr, elseExpr): OrIfElse(
			applyBindings(cond, bindings),
			applyBindings(thenExpr, bindings),
			applyBindings(elseExpr, bindings)
		);

		// Structure and sequence
		OrLambda(lambdaBindings, params, body): {
			// Transform the lambda bindings
			newBindings = map(lambdaBindings, \binding -> {
				OrEnvBinding(binding.id, applyBindings(binding.math_expr, bindings));
			});
			// Keep parameter names but transform body
			OrLambda(newBindings, params, applyBindings(body, bindings));
		}
		OrSequence(a, b): OrSequence(applyBindings(a, bindings), applyBindings(b, bindings));
		OrLet(idType, val): OrLet(idType, applyBindings(val, bindings));

		// Set operations
		OrSetLiteral(items): OrSetLiteral(map(items, \item -> applyBindings(item, bindings)));
		OrUnion(a, b): OrUnion(applyBindings(a, bindings), applyBindings(b, bindings));
		OrIntersection(a, b): OrIntersection(applyBindings(a, bindings), applyBindings(b, bindings));
		OrElementOf(a, b): OrElementOf(applyBindings(a, bindings), applyBindings(b, bindings));
		OrSubset(a, b): OrSubset(applyBindings(a, bindings), applyBindings(b, bindings));

		// Other operations that need variable substitution
		OrMatch(matchExpr, patterns): OrMatch(applyBindings(matchExpr, bindings), applyBindings(patterns, bindings));
		OrRule(a, b, conds): OrRule(
			applyBindings(a, bindings), 
			applyBindings(b, bindings),
			map(conds, \cond -> OrConditional(applyBindings(cond.math_expr, bindings)))
		);

		// Default: primitives and unimplemented expressions don't need substitution
		default: expr; // For literals (Int, Double, String, Bool) and other expressions, return as is
	}
}



// Execute a match expression
// Takes the already evaluated expression to match and the patterns to match against
executeMatch(env : OrbEnv, exprValue : OrMath_expr, patterns : OrMath_expr) -> OrbEnv {
	// Implement pattern matching with multiple patterns
	tryPatterns(patterns, env, exprValue);
}

// Try to match a sequence of patterns
tryPatterns(patterns : OrMath_expr, env : OrbEnv, exprValue : OrMath_expr) -> OrbEnv {
	switch (patterns) {
		// Try a single rule
		OrRule(patternExpr, bodyExpr, conditionals): {
			// Debug information more extensively
			println("Trying to match pattern: " + prettyOrbit(patternExpr));
			println("Against expression: " + prettyOrbit(exprValue));

			// Extract the actual body and next pattern if body is a sequence
			actualBodyRef = ref bodyExpr;
			nextRuleRef = ref None();

			if (bodyExpr.structname == "OrSequence") {
				switch (bodyExpr) {
					OrSequence(seqBody, seqNext): {
						actualBodyRef := seqBody;
						nextRuleRef := Some(seqNext);
					}
					default: {}
				}
			}

			// Try to unify the pattern with the expression
			switch (unify(patternExpr, exprValue)) {
				PatternSuccess(bindings): {
					// Check condition if present (simplified for now)
					if (isConditionSatisfied(conditionals, bindings, env)) {
						println("Pattern matched successfully");
						// Apply bindings and evaluate the body
						boundBody = applyBindings(^actualBodyRef, bindings);
						
						// Update environment with pattern variables
						boundEnv = fold(getTreeKeys(bindings), env, \accEnv, key -> {
							bindVar(accEnv, key, lookupTreeDef(bindings, key, OrInt(0)));
						});
						
						// Return environment with updated bindings and the body to be evaluated by interpreter
						OrbEnv(boundEnv with result = boundBody);
					} else {
						println("Pattern matched but condition failed");
						// Act as if pattern didn't match
						OrbEnv(env with result = exprValue);
					}
				}
				PatternFailure(): {
					// Pattern didn't match
					println("Pattern match failed - falling through to next pattern");

					// Check if there's a next pattern in a sequence
					switch (^nextRuleRef) {
						Some(next): {
							println("Trying next pattern in sequence");
							// Extract the next pattern and try it
							tryPatterns(next, env, exprValue);
						}
						None(): {
							// No next pattern, return the original expression as fallback
							OrbEnv(env with result = exprValue);
						}
					}
				}
			}
		}
		
		// Handle a sequence of patterns - try left first, then right if left fails
		OrSequence(left, right): {
			// Try the left pattern first
			leftResult = tryPatterns(left, env, exprValue);
			
			// If we get back the original expression, it means no pattern matched
			// Try the right pattern in that case
			if (leftResult.result == exprValue) {
				// Try the right pattern
				tryPatterns(right, leftResult, exprValue);
			} else {
				// A pattern matched on the left side
				leftResult;
			}
		}
		
		default: {
			println("Invalid pattern structure in match: " + prettyOrbit(patterns));
			OrbEnv(env with result = exprValue); // Return original as fallback
		}
	}
}

// Simplified conditional evaluation for now
isConditionSatisfied(conditionals : [OrConditional], bindings : Tree<string, OrMath_expr>, env : OrbEnv) -> bool {
	if (length(conditionals) == 0) {
		// No conditions means always satisfied
		true;
	} else {
		// For simplicity, we're just returning true
		// In a real implementation, we'd evaluate each condition
		println("Condition evaluation not fully implemented yet");
		true;
	}
}