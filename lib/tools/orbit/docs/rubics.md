# Rubik's Cubes: Group Structures, Rewriting, and Canonical Forms

## Introduction

Rubik's Cubes and their NxN×N variants are governed by precise mathematical structures, specifically permutation groups. This document outlines how the group-theoretic properties of these puzzles can be leveraged within a rewriting system (like Orbit's OGraph) to simplify states, establish canonical forms, and work towards solving strategies applicable across different cube sizes. We focus on the underlying mathematical concepts and rewrite rules, using a generalized coordinate system for moves.

## Coordinate-Based Representation

To generalize across cube sizes (N×N×N), we avoid traditional face notation (R, U, F, etc.) and use a coordinate system.

1.  **State Representation**: The cube's state can be represented as a mapping from *cubie positions* to *cubie identities* and *orientations*. Positions can be defined by (x, y, z) coordinates, and identities specify the type (corner, edge, center) and original colors/stickers.
2.  **Move Representation**: A move is defined by:
    *   **Axis**: The axis of rotation (e.g., X, Y, Z).
    *   **Layer Index**: Which slice/layer parallel to the axis is being turned (e.g., 0 to N-1). Index 0 might be the "Left" face turn on the X-axis, N-1 the "Right" face turn.
    *   **Direction**: Clockwise (+1) or Counter-clockwise (-1) rotation relative to the axis direction.
    *   **Notation**: `Turn(Axis, LayerIndex, Direction)`

    *Example*: A standard 'R' move on a 3x3 cube could be `Turn(X, 2, +1)` (assuming X-axis points right, Layer 0 is Left, Layer 2 is Right). A slice move 'M' might be `Turn(X, 1, -1)`.

This coordinate system allows defining move semantics consistently for any N.

## Rubik's Cube Groups

The set of all possible states reachable from a solved cube through valid moves forms a mathematical group, where:
*   **Elements**: Permutations and re-orientations of the cubies.
*   **Operation**: Composition of moves (applying one move after another).
*   **Identity**: The solved state.
*   **Inverse**: Reversing a sequence of moves.

### Specific Group Structures

1.  **2×2×2 Cube (Pocket Cube)**:
    *   Involves 8 corner pieces.
    *   The group describes permutations of these 8 pieces (a subgroup of S₈) and the orientation of 7 of them (relative to the 8th, a subgroup of ℤ₃⁷).
    *   The group is isomorphic to **(ℤ₃⁷ ⋊ S₈)**, where ⋊ denotes the semi-direct product. Its order is (3⁷ × 8!) / 3 = 3,674,160. (Division by 3 accounts for fixed total orientation).

2.  **3×3×3 Cube**:
    *   Involves 8 corner pieces and 12 edge pieces (centers are fixed).
    *   The group describes permutations of corners (S₈), orientation of 7 corners (ℤ₃⁷), permutations of edges (S₁₂), and orientation of 11 edges (ℤ₂¹¹).
    *   Constraints: Total corner orientation must be fixed (divides by 3), total edge orientation must be fixed (divides by 2), and the parity of corner and edge permutations must match (divides by 2).
    *   The group is isomorphic to **((ℤ₃⁷ × ℤ₂¹¹) ⋊ (S₈ × S₁₂)) / 2**. Its order is approx 4.3 × 10¹⁹.

3.  **N×N×N Cube (N > 3)**:
    *   The structure becomes significantly more complex, involving multiple types of edge pieces and center pieces in addition to corners.
    *   The group involves permutations and orientations of corners, permutations and orientations of different edge types, and permutations of different center types.
    *   The full group structure is very large and intricate.

### Group Decomposition and Subgroups

Solving larger cubes often relies on decomposing the problem by considering **subgroups**. A subgroup is a subset of group elements that is itself a group. Key subgroups relevant to Rubik's cubes include:

*   **Corner Group**: Permutations and orientations of only the corner pieces.
*   **Edge Group**: Permutations and orientations of only the edge pieces.
*   **Orientation Group**: Operations that only change piece orientations but not their positions.
*   **Permutation Group**: Operations that only change piece positions but not their orientations.
*   **Slice Groups**: Operations generated by turning only inner layers (e.g., M, E, S moves on a 3x3).
*   **Square Group**: Operations that leave specific pieces (like centers) invariant.
*   **Thistlethwaite/Kociemba Subgroups (G₀ ⊃ G₁ ⊃ G₂ ⊃ G₃ ⊃ G₄ = {Identity})**: A nested sequence of subgroups defined by restricting allowed moves. Solving involves finding move sequences within each subgroup to transition to the next smaller one.
    *   G₀: Full cube group.
    *   G₁: Edge orientations are correct. Moves allowed: U, D, R², L², F², B².
    *   G₂: Corner orientations correct, edges in middle layer slice. Moves allowed: U, D, R², L², F₂, B₂, M², E², S².
    *   G₃: Corners and edges in correct orbits (correct piece types in corner/edge positions). Moves allowed: U², D², R², L², F², B². (The "Square Group").
    *   G₄: Solved state {I}.

## Rewrite Rules from Group Relations

The fundamental properties of the group translate directly into rewrite rules that simplify sequences of moves applied to a state. `Apply(Move, State)` represents applying a move to a state.

1.  **Inverse Property**: Applying a move and its inverse results in the original state.
    ```
	Apply(Turn(Axis, Layer, -Dir), Apply(Turn(Axis, Layer, Dir), State))  =>  State
	Apply(Turn(Axis, Layer, Dir), Apply(Turn(Axis, Layer, -Dir), State))  =>  State
```

2.  **Order of Moves**: Applying a move `k` times returns to the original state, where `k` is the order of the move (typically 4 for 90° face turns, 2 for 180° turns).
    ```
	// For a 90-degree turn (order 4)
	Apply(T, Apply(T, Apply(T, Apply(T, State))))  =>  State  where T = Turn(Axis, Layer, Dir)

	// Using exponent notation if available:
	Apply(Move^k, State) => State  if order(Move) = k
```

3.  **Commutation Rules**: If two moves `M₁` and `M₂` affect disjoint sets of cubies (e.g., turns of opposite faces like L and R, or turns of layers that don't overlap), they commute.
    ```
	Apply(M₂, Apply(M₁, State))  <=>  Apply(M₁, Apply(M₂, State))  if AffectsDisjointPieces(M₁, M₂)
```
    *Example*: `Turn(X, 0, D1)` and `Turn(X, N-1, D2)` commute. `Turn(X, L1, D1)` and `Turn(Y, L2, D2)` commute if the layers L1 and L2 don't intersect significantly (more complex for N>3).

4.  **Conjugation Rules**: Conjugation `A ⋅ B ⋅ A⁻¹` transforms the effect of move `B` by move `A`. This is key for algorithms that position or orient pieces without disturbing others.
    ```
	// Representing application of a conjugate B^A = A B A'
	Apply(Conjugate(A, B), State)  <=>  Apply(Inverse(A), Apply(B, Apply(A, State)))
```
    Rewrite rules can be defined for specific useful conjugates that achieve specific state transformations (e.g., 3-cycle of edges).

5.  **Associativity**: Move composition is associative.
    ```
	Apply(M₃, Apply(M₂, Apply(M₁, State))) <=> Apply(Compose(M₃, M₂), Apply(M₁, State))
```
    This rule allows grouping sequences of moves.

## Canonicalization Strategies

The ultimate goal is typically to reach the **solved state**, which serves as the **canonical form** for the entire group (the identity element). However, canonicalization can also be defined *within subgroups*.

1.  **Global Canonical Form**: The unique solved state.
    ```
	State : IsSolved => State : Canonical(G₀)
```
    Rewriting aims to merge any state e-class with the e-class containing the `Canonical(G₀)` node.

2.  **Subgroup Canonical Forms**: A state can be considered "canonical" or "solved" *with respect to a subgroup* if it satisfies the properties defining that subgroup.
    *   **Edge Orientation**: A state where all edges are correctly oriented (e.g., no flipped edges) can be considered canonical for the subgroup G₁.
        ```
		State : EdgesAreOriented => State : Canonical(G₁)
```
    *   **Corner Orientation**: A state where all corners are correctly oriented.
        ```
		State : CornersAreOriented => State : Canonical(CornerOrientationGroup)
```
    *   **Permutation Subgroups**: A state where pieces are in the correct positions, ignoring orientation.

3.  **Rewriting Towards Subgroup Canonical Forms**: Rewrite rules can be designed to specifically achieve these intermediate canonical forms.
    *   Rules that only use moves from subgroup G₁ (e.g., U, D, R², L², F², B²) can transform a state towards `Canonical(G₁)`.
    *   Rules implementing specific algorithms (like edge orientation sequences) can be tagged:
        ```
		Apply(EdgeOrientAlg, State) => NewState : EdgesAreOriented
```

The process of solving via subgroups (like Kociemba's algorithm) involves applying sequences of rules, each designed to reach the canonical form of the next smaller subgroup, using only moves allowed within the current subgroup.

## Synergy Across Cube Sizes

The coordinate-based notation and subgroup approach facilitate solving different cube sizes:

1.  **Generalized Moves**: `Turn(Axis, Layer, Dir)` applies conceptually to any N. The *effect* on the state mapping depends on N, but the move definition is uniform.
2.  **Shared Substructures**:
    *   **Corners**: The 8 corner pieces of any N×N×N cube (N≥2) behave identically under face turns affecting only corners. Rewrite rules manipulating *only* corner state and orientation (perhaps tagged with a `CornerPiece` domain) can potentially be reused across N≥2. The canonicalization for the corner subgroup is similar.
    *   **Edges**: While N>3 introduces multiple edge types, the concept of edge orientation and permutation subgroups exists for all N≥3. Rules for orienting edges or placing them in the correct layer might share structural similarities.
    *   **Centers**: For N>3, center pieces need solving. Rules for cycling center pieces might be generalized based on layer indices.
3.  **Hierarchical Solving Strategy**: Many NxN methods follow a pattern:
    *   Solve Centers (N>3)
    *   Pair Edges (N>3)
    *   Solve as a 3x3 (using the outer layers and paired edges/centers)
    This hierarchical strategy can be modelled using subgroup canonicalization rules. Rules for the "Solve as 3x3" phase would operate on the domains representing the outer layers and effective pieces.
4.  **Domain-Tagged Rules**: By tagging pieces (Corner, EdgeType1, EdgeType2, CenterType1...) and layers (OuterLayer, InnerSlice...) with domains, rewrite rules can be made more general. A rule might apply to `AnyEdge` or only `EdgeType1`.

## Conclusion

Modeling Rubik's Cubes using their group-theoretic structure provides a powerful foundation for simplification and solving within a rewriting system. By using a generalized coordinate-based notation for moves and decomposing the problem into subgroups, we can define rewrite rules that:

*   Simplify move sequences based on group axioms.
*   Work towards canonical forms, both globally (solved state) and within specific subgroups (e.g., oriented edges).
*   Offer potential for synergy across different cube sizes (N×N×N) by focusing on common substructures and hierarchical solving strategies.

While the computational cost of solving large cubes via pure rewriting might be high, this approach provides a formal framework for encoding known algorithms, potentially discovering new simplifications, and reasoning about the combinatorial complexity of these fascinating puzzles in a unified mathematical language.
