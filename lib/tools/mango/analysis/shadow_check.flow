import tools/mango/rules; // findRules is here
import tools/mango/analysis/exponential; // flattenChoice
import tools/mango/mango_interpreter; // For mangoParse

export {
	detectShadowedChoices(grammar: Term) -> [string];
}

// Context for recursive traversal
DetectContext(
	currentRule: Maybe<string>,
	rules: Tree<string, Term>,
	warnings: [string]
);


// --- Main Function ---

detectShadowedChoices(grammar: Term) -> [string] {
	//println("--- Starting Shadow Detection ---");
	rulesMap = findRules(makeTree(), grammar);
	initialContext = DetectContext(None(), rulesMap, []);
	finalContext = traverseForShadowing(grammar, initialContext);
	iter(finalContext.warnings, println);
	finalContext.warnings;
}

// --- Detection Phase ---

// Recursive traversal function
traverseForShadowing(term: Term, context: DetectContext) -> DetectContext {
	switch (term) {
		Choice(t1, t2): {
			// First, check this choice node itself
			alternatives = flattenChoice(term); // Gets [A, B, C] from A | (B | C) etc.
			newWarnings = checkAlternatives(alternatives, context);
			updatedContext = DetectContext(context with warnings = newWarnings);

			// Then, recurse into children
			ctx1 = traverseForShadowing(t1, updatedContext);
			traverseForShadowing(t2, ctx1); // Accumulate warnings
		}
		Rule(id, t1, t2): {
			// Update context with current rule name and recurse
			ruleContext = DetectContext(context with currentRule = Some(id));
			ctx1 = traverseForShadowing(t1, ruleContext);
			traverseForShadowing(t2, ctx1);
		}
		// Recurse into structural nodes
		Sequence(t1, t2): traverseForShadowing(t2, traverseForShadowing(t1, context));
		Optional(t): traverseForShadowing(t, context);
		Plus(t): traverseForShadowing(t, context);
		Star(t): traverseForShadowing(t, context);
		Negate(t): traverseForShadowing(t, context);
		PushMatch(t): traverseForShadowing(t, context);
		Lower(t): traverseForShadowing(t, context);
		Error(t): traverseForShadowing(t, context);
		Precedence(t1, t2): {
			// Pretend it is choice
			traverseForShadowing(Choice(t1, t2), context)
		}
		GrammarFn(__, t1, t2, t3): traverseForShadowing(t3, traverseForShadowing(t2, traverseForShadowing(t1, context)));

		// Base cases: Leaf nodes or nodes without relevant children
		String(__): context;
		Range(__, __): context;
		Variable(__): context;
		Construct(__, __): context;
		StackOp(__): context;
		GrammarCall(__, t): traverseForShadowing(t, context); // Recurse into argument term
	}
}

// Check pairs of alternatives within a single choice
checkAlternatives(alternatives: [Term], context: DetectContext) -> [string] {
	foldi(alternatives, context.warnings, \i, currentWarnings, alt_A -> {
		// Compare alt_A with subsequent alternatives alt_B
		fold(subrange(alternatives, i + 1, length(alternatives) - i - 1), currentWarnings, \innerWarnings, alt_B -> {
			// Use the more comprehensive shadow pair checking
			checkShadowPair(alt_A, alt_B, context, innerWarnings);
		});
	});
}

// Check if termA potentially shadows termB and generate a warning message if needed
checkShadowPair(termA: Term, termB: Term, context: DetectContext, warnings: [string]) -> [string] {
	// Check if termA shadows termB when termB is a string literal
	// This is common with identifier rules (id) shadowing keywords
	variableVsStringWarning = checkTermShadowsString(termA, termB, context);
	switch (variableVsStringWarning) {
		Some(warningText): arrayPush(warnings, warningText);
		None(): warnings;
	}
}

// Build a term with all rules from the environment embedded
// This allows a term to be interpreted in isolation with all necessary rules defined
buildTermWithEnvironment(context: DetectContext, term: Term) -> Term {
	// Build a nested Term with all rules defined and the input term at the end
	foldTree(context.rules, term, \ruleName, ruleDef, acc -> {
		Rule(ruleName, ruleDef, acc);
	});
}

// Check if a term shadows a string literal by using the interpreter
checkTermShadowsString(termA: Term, termB: Term, context: DetectContext) -> Maybe<string> {
	// Function to generate a warning message if a shadow is detected
	makeWarning = \theTermA, theTermB, theString, theContext -> {
		ruleCtx = switch (theContext.currentRule) {
			Some(r): "in rule '" + r + "'";
			None(): "at top level";
		};
		
		// Determine description based on term type
		descriptionA = switch (theTermA) {
			Variable(id): "Identifier rule '" + id + "'";
			String(__): "String literal";
			Range(__, __): "Character range";
			default: "Term";
		};
		
		warningText = "WARNING: " + descriptionA + " shadows string literal " + ruleCtx + ".\n" + 
			"  Alternative 1 (shadowing): " + summarizeTerm(theTermA) + "\n" + 
			"  Alternative 2 (shadowed):  " + summarizeTerm(theTermB) + "\n" + 
			"  Problem: The first alternative will match '" + theString + "' before the second alternative is tried.\n" + 
			"  Suggestion: Consider reordering the alternatives, or making the rule patterns more specific.";
			
		Some(warningText);
	};
	
	// Main function logic
	switch (termB) {
		String(s): {
			if (s == "") {
				// Empty strings don't cause shadowing concerns
				None();
			} else {
				// Create a test environment that will be used for parsing
				env = makeMEnv("", s, \e -> e, 0);
				
				// Build a self-contained term with all rule definitions
				augmentedTerm = buildTermWithEnvironment(context, termA);
				
				// Manually parse using the augmented Term rather than raw termA
				resultEnv = parse(env, augmentedTerm);
				
				// The parse succeeds if we didn't fail and we consumed all input
				if (!resultEnv.fail && resultEnv.i == strlen(s)) {
					// Generate warning since termA successfully consumed all of s
					makeWarning(termA, termB, s, context);
				} else {
					// No shadowing detected
					None();
				}
			}
		}
		default: None(); // Only checking String terms for now
	}
}

