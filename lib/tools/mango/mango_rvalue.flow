import ds/rvalue_api;
import tools/mango/mango_types;

// TODO: This can be generated by Mango/Gringo

export {
	termRecApi() -> RecApi<Term>;
}

termRecApi() -> RecApi<Term> {
	RecApi(
		// clean : (?) -> ?,
		\t : Term -> {
			c = String("");
			switch (t) {
				Choice(term1, term2): Choice(c, c);
				Construct(uid, int_0): t;
				Error(term): Error(c);
				GrammarCall(id, term): GrammarCall(id, c);
				GrammarFn(id, term1, term2, term3): {
					println("Did not expect grammar fn here: " + id);
					t;
				}
				Lower(term): Lower(c);
				Negate(term): Negate(c);
				Optional(term): Optional(c);
				Plus(term): Plus(c);
				Precedence(term1, term2): Precedence(c, c);
				PushMatch(term): PushMatch(c);
				Range(char1, char2): t;
				Rule(id, term1, term2): Rule(id, c, c);
				Sequence(term1, term2): Sequence(c, c);
				StackOp(id): t;
				Star(term): Star(c);
				String(stringq): t;
				Variable(id): t;
			}
		},
		// getChildren : (?) -> [?],
		\t -> {
			switch (t) {
				Choice(term1, term2): [term1, term2];
				Construct(uid, int_0): [];
				Error(term): [term];
				GrammarCall(id, term): [term];
				GrammarFn(id, term1, term2, term3): {
					println("Did not expect grammar fn here: " + id);
					[];
				}
				Lower(term): [term];
				Negate(term): [term];
				Optional(term): [term];
				Plus(term): [term];
				Precedence(term1, term2): [term1, term2];
				PushMatch(term): [term];
				Range(char1, char2): [];
				Rule(id, term1, term2): [term1, term2];
				Sequence(term1, term2): [term1, term2];
				StackOp(id): [];
				Star(term): [term];
				String(stringq): [];
				Variable(id): [];
			}
		},
		// combine : (?, [?]) -> ?
		\t, ch -> {
			c = \i -> elementAt(ch, i, t);
			switch (t) {
				Choice(term1, term2): Choice(c(0), c(1));
				Construct(uid, int_0): t;
				Error(term): Error(c(0));
				GrammarFn(id, term1, term2, term3): {
					println("Did not expect grammar fn here: " + id);
					t;
				}
				GrammarCall(id, term): GrammarCall(id, c(0));
				Lower(term): Lower(c(0));
				Negate(term): Negate(c(0));
				Optional(term): Optional(c(0));
				Plus(term): Plus(c(0));
				Precedence(term1, term2): Precedence(c(0), c(1));
				PushMatch(term): PushMatch(c(0));
				Range(char1, char2): t;
				Rule(id, term1, term2): Rule(id, c(0), c(1));
				Sequence(term1, term2): Sequence(c(0), c(1));
				StackOp(id): t;
				Star(term): Star(c(0));
				String(stringq): t;
				Variable(id): t;
			}
		},
	);
}
