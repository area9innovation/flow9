import tools/mango/type/types;
import text/blueprint;

export {
	union2ts(structs : Tree<string, MTypeConstructor>, t : MTypeUnion) -> string;
	type2ts(t : MType) -> string;
	structArgs2ts(s : MTypeConstructor) -> string;
	mtype2tsName(m : MType) -> string;
	generateTSTypes(types : Tree<string, MType>, structs : Tree<string, MTypeConstructor>) -> string;
}

// Generate TypeScript interface definition for a union type
union2ts(structs : Tree<string, MTypeConstructor>, t : MTypeUnion) -> string {
	typeName = t.name;
	memberTypes = map(t.types, \tt -> {
		n = mtype2tsName(tt);
		if (n == "") "never" else n;
	});
	
	blueprint("
		export type %typeName% = %members%;
		", [
			"typeName", typeName,
			"members", strGlue(memberTypes, " | ")
		]
	);
}

// Convert MType to TypeScript type name
mtype2tsName(m : MType) -> string {
	switch (m) {
		MTypeName(n): n;
		MTypeConstructor(n, __): n;
		default: "";
	}
}

// Generate TypeScript interface for a struct with conventional "kind" field
structArgs2ts(s : MTypeConstructor) -> string {
	structName = s.name;
	
	// Generate field definitions with semantic names and duplicate detection
	fieldNames = generateFieldNames(s);
	fieldDefs = mapi(s.args, \i, st -> {
		fname = fieldNames[i];
		ftype = type2ts(st);
		"  " + fname + ": " + ftype + ";";
	});
	
	blueprint("
		export interface %structName% {
		  kind: '%structName%';
		%fields%
		}
		", [
			"structName", structName,
			"fields", strGlue(fieldDefs, "\n")
		]
	);
}

// Generate semantic field names for a struct, avoiding duplicates
generateFieldNames(s : MTypeConstructor) -> [string] {
	structName = s.name;
	argCount = length(s.args);
	
	// Use semantic names based on common patterns
	semanticNames = if (argCount == 1) {
		// Single argument - use semantic name based on context
		if (contains(["Star", "Plus", "Optional", "Negate", "Lower", "Error", "PushMatch"], structName)) {
			["expression"];
		} else {
			["value"];
		}
	} else if (argCount == 2) {
		// Binary operators - use left/right for most cases
		if (contains(["Choice", "Sequence", "Precedence", "Range"], structName)) {
			["left", "right"];
		} else if (structName == "Construct") {
			["name", "arity"];
		} else if (structName == "GrammarCall") {
			["name", "argument"];
		} else {
			["first", "second"];
		}
	} else if (argCount == 3) {
		// Three arguments
		if (structName == "Rule") {
			["name", "pattern", "body"];
		} else {
			["first", "second", "third"];
		}
	} else if (argCount == 4) {
		// Four arguments
		if (structName == "GrammarFn") {
			["name", "parameter", "definition", "body"];
		} else {
			["first", "second", "third", "fourth"];
		}
	} else {
		// More arguments - use positional names
		mapi(s.args, \i, __ -> "arg" + i2s(i));
	};
	
	// If we don't have enough semantic names, fall back to base names with detection
	if (length(semanticNames) != argCount) {
		// Generate base names and handle duplicates
		baseNames = mapi(s.args, \i, st -> {
			baseName = fieldNameTS(st, i);
			baseName;
		});
		
		// Detect and resolve duplicates
		resolveDuplicateNames(baseNames);
	} else {
		semanticNames;
	}
}

// Resolve duplicate field names by adding numeric suffixes
resolveDuplicateNames(names : [string]) -> [string] {
	counts = fold(names, makeTree(), \acc, name -> {
		setTree(acc, name, lookupTreeDef(acc, name, 0) + 1);
	});
	
	// Add suffixes to duplicates
	counters = ref makeTree();
	map(names, \name -> {
		totalCount = lookupTreeDef(counts, name, 1);
		if (totalCount > 1) {
			currentCount = lookupTreeDef(^counters, name, 0) + 1;
			counters := setTree(^counters, name, currentCount);
			name + i2s(currentCount);
		} else {
			name;
		}
	});
}

// Generate appropriate field name for TypeScript (fallback for base names)
fieldNameTS(t : MType, index : int) -> string {
	switch (t) {
		MTypeField(n, __): n;
		MTypeResult(rule): rule;
		MTypeNil(): "nil";
		MTypeBool(): "value";
		MTypeInt(): "value";
		MTypeDouble(): "value";
		MTypeString(): "value";
		MTypeConstructor(name, args): toLowerCase(name);
		MTypeStar(type): fieldNameTS(type, index) + "s";
		MTypeUnion(name, types): toLowerCase(name);
		MTypeName(name): toLowerCase(name);
	}
}

// Convert MType to TypeScript type syntax
type2ts(t : MType) -> string {
	switch (t) {
		MTypeResult(rule): "any /* result: " + rule + " */";
		MTypeNil(): "null";
		MTypeBool(): "boolean"; 
		MTypeInt(): "number";
		MTypeDouble(): "number";
		MTypeString(): "string";
		MTypeConstructor(name, args): name;
		MTypeStar(type): type2ts(type) + "[]";
		MTypeUnion(name, types): {
			if (name == "") {
				"(" + strGlue(map(types, type2ts), " | ") + ")";
			} else name;
		}
		MTypeName(name): name;
		MTypeField(name, type): type2ts(type);
	}
}

// Generate complete TypeScript type definitions file
generateTSTypes(types : Tree<string, MType>, structs : Tree<string, MTypeConstructor>) -> string {
	// Generate all struct interfaces
	structDefs = foldTree(structs, [], \name, struct, acc -> {
		arrayPush(acc, structArgs2ts(struct));
	});
	
	// Generate all union types
	unionDefs = foldTree(types, [], \name, mtype, acc -> {
		switch (mtype) {
			MTypeUnion(__, __): arrayPush(acc, union2ts(structs, mtype));
			default: acc;
		}
	});
	
	// Combine all definitions
	allDefs = concat(structDefs, unionDefs);
	
	blueprint("
		// Generated TypeScript types from Mango grammar
		// This file contains AST node definitions using the conventional 'kind' field pattern
		
		%definitions%
		
		// Utility type for all AST nodes
		export type ASTNode = %allTypes%;
		
		// Type guard functions
		%typeGuards%
		", [
			"definitions", strGlue(allDefs, "\n"),
			"allTypes", generateUnionOfAllTypes(structs),
			"typeGuards", generateTypeGuards(structs)
		]
	);
}

// Generate union type of all struct types
generateUnionOfAllTypes(structs : Tree<string, MTypeConstructor>) -> string {
	typeNames = getTreeKeys(structs);
	if (length(typeNames) == 0) {
		"never";
	} else {
		strGlue(typeNames, " | ");
	}
}

// Generate TypeScript type guard functions
generateTypeGuards(structs : Tree<string, MTypeConstructor>) -> string {
	guards = foldTree(structs, [], \name, struct, acc -> {
		guard = blueprint("
			export function is%name%(node: any): node is %name% {
			  return node && node.kind === '%name%';
			}
			", [
				"name", name
			]
		);
		arrayPush(acc, guard);
	});
	
	strGlue(guards, "\n");
}