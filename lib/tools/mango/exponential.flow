import tools/mango/mango_types;
import tools/mango/rules;
import tools/mango/mango2string;
import ds/tree;
import string;

export {
	// Detects potential exponential behavior in PEG grammar
	// This happens when multiple choice alternatives have the same first-set
	// or when Star(*) is used with terms that can match empty strings
	detectExponentialBehavior(grammar : Term) -> [string];
}

detectExponentialBehavior(grammar : Term) -> [string] {
	// Build a map of rule names to their terms for potential recursive analysis
	ruleDefinitions = findRules(makeTree(), grammar);
	
	// Detect both types of issues
	warnings1 = traverseForExponentialBehavior(grammar, None(), [], ruleDefinitions);
	warnings2 = detectInfiniteLoopRisks(grammar, None(), [], ruleDefinitions);
	
	concat(warnings1, warnings2);
}

// Context tracks the current rule name being processed
traverseForExponentialBehavior(term : Term, context : Maybe<string>, warnings : [string], 
                                ruleDefinitions : Tree<string, Term>) -> [string] {
	switch(term) {
		Choice(term1, term2): {
			// First analyze this choice
			alternatives = flattenChoice(term);
			newWarnings = checkAlternativesExponential(alternatives, context, warnings);
			
			// Then continue with both branches
			traverseForExponentialBehavior(term1, context, 
				traverseForExponentialBehavior(term2, context, newWarnings, ruleDefinitions), 
				ruleDefinitions);
		}
		Rule(id, term1, term2): {
			// For rules, pass down the rule name as context
			traverseForExponentialBehavior(term1, Some(id), 
				traverseForExponentialBehavior(term2, Some(id), warnings, ruleDefinitions), 
				ruleDefinitions);
		}
		Sequence(term1, term2): {
			// Check both terms in the sequence
			traverseForExponentialBehavior(term1, context, 
				traverseForExponentialBehavior(term2, context, warnings, ruleDefinitions), 
				ruleDefinitions);
		}
		Optional(termInner): traverseForExponentialBehavior(termInner, context, warnings, ruleDefinitions);
		Plus(termInner): traverseForExponentialBehavior(termInner, context, warnings, ruleDefinitions);
		Star(termInner): traverseForExponentialBehavior(termInner, context, warnings, ruleDefinitions);
		Negate(termInner): traverseForExponentialBehavior(termInner, context, warnings, ruleDefinitions);
		PushMatch(termInner): traverseForExponentialBehavior(termInner, context, warnings, ruleDefinitions);
		Error(termInner): traverseForExponentialBehavior(termInner, context, warnings, ruleDefinitions);
		Lower(termInner): traverseForExponentialBehavior(termInner, context, warnings, ruleDefinitions);
		Precedence(term1, term2): {
			traverseForExponentialBehavior(term1, context, 
				traverseForExponentialBehavior(term2, context, warnings, ruleDefinitions), 
				ruleDefinitions);
		}
		GrammarCall(__, termInner): traverseForExponentialBehavior(termInner, context, warnings, ruleDefinitions);
		GrammarFn(__, term1, term2, term3): {
			traverseForExponentialBehavior(term1, context, 
				traverseForExponentialBehavior(term2, context, 
					traverseForExponentialBehavior(term3, context, warnings, ruleDefinitions), 
					ruleDefinitions), 
				ruleDefinitions);
		}
		default: warnings;
	}
}

// Detect potential infinite loops in Star (*) operations where term can match empty string
detectInfiniteLoopRisks(term : Term, context : Maybe<string>, warnings : [string], 
                         ruleDefinitions : Tree<string, Term>) -> [string] {
	switch(term) {
		Star(innerTerm): {
			// Check if the inner term can match empty string
			if (canMatchEmpty(innerTerm, makeTree(), ruleDefinitions)) {
				// This is a potential infinite loop risk
				ruleInfo = switch (context) {
					Some(ruleName): " in rule '" + ruleName + "'";
					None(): "";
				}
				
				warning = "WARNING - Potential infinite loop" + ruleInfo + ": " + 
				         "Star operator (*) applied to term that can match empty string:\n" + 
				         indent(term2string(innerTerm));
				
				// Continue recursively with the inner term
				detectInfiniteLoopRisks(innerTerm, context, arrayPush(warnings, warning), ruleDefinitions);
			} else {
				// No risk here, but continue checking inner term
				detectInfiniteLoopRisks(innerTerm, context, warnings, ruleDefinitions);
			}
		}
		Rule(id, term1, term2): {
			// Check both parts of the rule
			detectInfiniteLoopRisks(term1, Some(id), 
				detectInfiniteLoopRisks(term2, Some(id), warnings, ruleDefinitions), 
				ruleDefinitions);
		}
		Choice(term1, term2): {
			// Check both sides of the choice
			detectInfiniteLoopRisks(term1, context, 
				detectInfiniteLoopRisks(term2, context, warnings, ruleDefinitions), 
				ruleDefinitions);
		}
		Sequence(term1, term2): {
			// Check both terms in the sequence
			detectInfiniteLoopRisks(term1, context, 
				detectInfiniteLoopRisks(term2, context, warnings, ruleDefinitions), 
				ruleDefinitions);
		}
		Optional(termInner): detectInfiniteLoopRisks(termInner, context, warnings, ruleDefinitions);
		Plus(termInner): detectInfiniteLoopRisks(termInner, context, warnings, ruleDefinitions);
		Negate(termInner): detectInfiniteLoopRisks(termInner, context, warnings, ruleDefinitions);
		PushMatch(termInner): detectInfiniteLoopRisks(termInner, context, warnings, ruleDefinitions);
		Error(termInner): detectInfiniteLoopRisks(termInner, context, warnings, ruleDefinitions);
		Lower(termInner): detectInfiniteLoopRisks(termInner, context, warnings, ruleDefinitions);
		Precedence(term1, term2): {
			detectInfiniteLoopRisks(term1, context, 
				detectInfiniteLoopRisks(term2, context, warnings, ruleDefinitions), 
				ruleDefinitions);
		}
		GrammarCall(__, termInner): detectInfiniteLoopRisks(termInner, context, warnings, ruleDefinitions);
		GrammarFn(__, term1, term2, term3): {
			detectInfiniteLoopRisks(term1, context, 
				detectInfiniteLoopRisks(term2, context, 
					detectInfiniteLoopRisks(term3, context, warnings, ruleDefinitions), 
					ruleDefinitions), 
				ruleDefinitions);
		}
		default: warnings;
	}
}

// Determines if a term can match an empty string (zero characters)
// visited is used to avoid infinite recursion through rule references
canMatchEmpty(term : Term, visited : Tree<string, bool>, ruleDefinitions : Tree<string, Term>) -> bool {
	switch(term) {
		// These constructs can always match empty string
		Optional(__): true; // Optional can always match nothing
		Star(__): true;    // Star can always match zero repetitions
		String(s): s == ""; // Empty string matches empty input
		StackOp(__): true; // Stack operations don't consume input
		
		// These constructs depend on their inner terms
		Choice(term1, term2): {
			// A choice can match empty if either branch can
			canMatchEmpty(term1, visited, ruleDefinitions) || 
			canMatchEmpty(term2, visited, ruleDefinitions);
		}
		Sequence(term1, term2): {
			// A sequence can match empty only if both parts can match empty
			canMatchEmpty(term1, visited, ruleDefinitions) && 
			canMatchEmpty(term2, visited, ruleDefinitions);
		}
		PushMatch(innerTerm): {
			// PushMatch behavior depends on its inner term
			canMatchEmpty(innerTerm, visited, ruleDefinitions);
		}
		Variable(id): {
			// Check if we've already visited this rule to prevent infinite recursion
			if (containsKeyTree(visited, id)) {
				// Assume non-empty during recursion to break cycles
				// This is conservative - we might miss some cases but won't have false positives
				false;
			} else {
				// Look up the rule definition
				rulesOpt = lookupTree(ruleDefinitions, id);
				switch (rulesOpt) {
					Some(ruleTerm): {
						// Mark as visited to prevent infinite recursion
						newVisited = setTree(visited, id, true);
						// Check if the rule's definition can match empty
						canMatchEmpty(ruleTerm, newVisited, ruleDefinitions);
					}
					None(): {
						// Unknown rule, conservatively assume it doesn't match empty
						false;
					}
				}
			}
		}
		// Other constructs that generally don't match empty
		Plus(__): false;  // Plus needs at least one match
		Range(__, __): false; // Character ranges need at least one char
		Construct(__, __): false; // Constructor annotations don't affect matching
		Negate(innerTerm): {
			// This is tricky - negating a term that can't match empty might match empty
			// For safety, we assume Negate doesn't match empty
			false;
		}
		// Default assumption: can't match empty string
		default: false;
	}
}

flattenChoice(term : Term) -> [Term] {
	switch(term) {
		Choice(term1, term2): {
			concat(flattenChoice(term1), flattenChoice(term2));
		}
		default: [term];
	}
}

checkAlternativesExponential(alternatives : [Term], context : Maybe<string>, warnings : [string]) -> [string] {
	if (length(alternatives) <= 1) {
		warnings;
	} else {
		// Group alternatives by their first element
		groups = fold(alternatives, makeTree(), \acc, alt -> {
			first = getFirstElement(alt);
			if (first != "") {
				existing = lookupTreeDef(acc, first, []);
				setTree(acc, first, arrayPush(existing, alt));
			} else {
				acc;
			}
		});
		
		// Find groups with multiple alternatives (potential exponential behavior)
		problematicGroups = filtermap(getTreeKeys(groups), \key -> {
			group = lookupTreeDef(groups, key, []);
			if (length(group) > 1) Some(group) else None();
		});
		
		// Generate warnings for each problematic group
		fold(problematicGroups, warnings, \acc, group -> {
			first = getFirstElement(group[0]);
			
			// Include rule name in the warning if available
			ruleInfo = switch (context) {
				Some(ruleName): " in rule '" + ruleName + "'";
				None(): "";
			}
			
			warning = "Potential exponential behavior" + ruleInfo + ": " + 
					 i2s(length(group)) + " choices with the same first element '" + 
					 first + "':\n" + strGlue(map(group, \t -> indent(term2string(t))), ",\n");
			
			arrayPush(acc, warning);
		});
	}
}

// Get the first element of a term (the first terminal or rule reference)
getFirstElement(term : Term) -> string {
	switch(term) {
		String(s): "\"" + s + "\""; // Direct terminal
		Variable(id): id; // Rule reference
		Range(c1, __): "'" + c1 + "'"; // Character range starts with first char
		Sequence(term1, term2): {
			// Skip stack operations and non-terminal first elements in sequence
			switch (term1) {
				PushMatch(innerTerm): {
					// Look inside PushMatch for the actual first element
					firstInPushMatch = getFirstElement(innerTerm);
					if (firstInPushMatch != "") {
						// We found a specific token inside the PushMatch
						firstInPushMatch;
					} else {
						// Move to the next term in the sequence
						getFirstElement(term2);
					}
				}
				StackOp(__): {
					// Skip stack op and look at the next term
					getFirstElement(term2);
				}
				default: {
					// For normal terms, use the first term's first element
					getFirstElement(term1);
				}
			}
		}
		PushMatch(innerTerm): {
			// Look inside PushMatch for the actual first element
			getFirstElement(innerTerm);
		}
		StackOp(__): ""; // No meaningful first element
		Choice(term1, __): {
			// For a choice within a choice, just look at the first alternative
			getFirstElement(term1);
		}
		Optional(innerTerm): {
			// For optional terms, the first element is the same as the inner term
			// This is a simplification as Optional could also match nothing
			getFirstElement(innerTerm);
		}
		Plus(innerTerm): getFirstElement(innerTerm);
		Star(innerTerm): getFirstElement(innerTerm); // Simplification
		Negate(innerTerm): getFirstElement(innerTerm); // Simplified
		// For other terms, we need more sophisticated analysis
		default: "";
	}
}

indent(s : string) -> string {
	"    " + strReplace(s, "\n", "\n    ");
}