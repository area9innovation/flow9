import string;
import tools/poppy/penv;
import tools/mango/line;
import ds/array;

export {
	MoParseAcc(
		input : string,
		// This has the output stack
		env : PEnv,
		mutable i : int,
		mutable stack : List<MCheckpoint>,
		// The last checkpoint for match string
		mutable starti : int,
		// The longest we have matched
		mutable maxi : int,
	);

	MCheckpoint(i : int, poppyStack : List<flow>);

	pushMCheckpoint(acc : MoParseAcc) -> void;
	discardMCheckpoint(acc : MoParseAcc) -> bool;
	restoreMCheckpoint(acc : MoParseAcc) -> bool;

	mparseStar(acc : MoParseAcc, matcher : () -> bool) -> bool;
	mparseStarNobacktrackOrStack(acc : MoParseAcc, matcher : () -> bool) -> bool;
	mparseStarBacktrackOnly(acc : MoParseAcc, matcher : () -> bool) -> bool;

	// New high-level pattern operations
	moNegate(acc : MoParseAcc, op : () -> bool, modifiesStack : bool) -> bool;
	moOptional(acc : MoParseAcc, op : () -> bool, modifiesStack : bool) -> bool;
	moChoice(acc : MoParseAcc, ops : [() -> bool], modifiesStack : bool) -> bool;
	moSequence(acc : MoParseAcc, ops : [() -> bool], modifiesStack : bool) -> bool;

	mmatchString(acc : MoParseAcc, s : string) -> bool;
	mmatchRange(acc : MoParseAcc, l : int, u : int) -> bool;
	moconstruct(acc : MoParseAcc, uid : string, arity : int) -> bool;

	// Driver to parse a compiled mango file
	parseCompiledMango(path : string, content : string, parseFn : (MoParseAcc) -> bool, def : ?) -> Pair<?, string>;
}

pushMCheckpoint(acc : MoParseAcc) -> void {
	acc.stack ::= Cons(MCheckpoint(acc.i, ^(acc.env.stack)), acc.stack);
}

discardMCheckpoint(acc : MoParseAcc) -> bool {
	switch (acc.stack) {
		EmptyList(): true;
		Cons(head, tail_): {
			acc.stack ::= tail_;
			true;
		}
	}
}

restoreMCheckpoint(acc : MoParseAcc) -> bool {
	switch (acc.stack) {
		EmptyList(): false;
		Cons(head, tail_): {
			acc.i ::= head.i;
			acc.env.stack := head.poppyStack;
			acc.stack ::= tail_;
			false;
		}
	}
}

// Negation - succeed if the pattern fails
moNegate(acc : MoParseAcc, op : () -> bool, modifiesStack : bool) -> bool {
	if (modifiesStack) {
		// Full checkpoint for stack-modifying patterns
		pushMCheckpoint(acc);
		if (op()) {
			restoreMCheckpoint(acc);
			false;
		} else {
			restoreMCheckpoint(acc);
			true;
		}
	} else {
		// Position-only tracking for simple patterns
		pos = acc.i;
		if (op()) {
			acc.i ::= pos;
			false;
		} else {
			acc.i ::= pos;
			true;
		}
	}
}

// Optional - try a pattern but succeed regardless
moOptional(acc : MoParseAcc, op : () -> bool, modifiesStack : bool) -> bool {
	if (modifiesStack) {
		// Full checkpoint for stack-modifying patterns
		pushMCheckpoint(acc);
		if (op()) {
			discardMCheckpoint(acc);
		} else {
			restoreMCheckpoint(acc);
		}
		{}
	} else {
		// Position-only tracking for simple patterns
		pos = acc.i;
		if (!op()) {
			acc.i ::= pos;
		}
	}
	true;
}

// Choice - try patterns until one succeeds
moChoice(acc : MoParseAcc, ops : [() -> bool], modifiesStack : bool) -> bool {
	if (length(ops) == 0) {
		false;
	} else if (modifiesStack) {
		// Full checkpoint version
		pushMCheckpoint(acc);
		if (ops[0]()) {
			discardMCheckpoint(acc);
			true;
		} else {
			restoreMCheckpoint(acc);
			moChoice(acc, tail(ops), modifiesStack);
		}
	} else {
		// Position-only version
		pos = acc.i;
		if (ops[0]()) {
			true;
		} else {
			acc.i ::= pos;
			moChoice(acc, tail(ops), modifiesStack);
		}
	}
}

// Sequence - try patterns in sequence, backtracking on failure
moSequence(acc : MoParseAcc, ops : [() -> bool], modifiesStack : bool) -> bool {
	if (length(ops) == 0) {
		true;
	} else if (modifiesStack) {
		// Full checkpoint version
		pushMCheckpoint(acc);
		if (ops[0]() && moSequence(acc, tail(ops), modifiesStack)) {
			discardMCheckpoint(acc);
			true;
		} else {
			restoreMCheckpoint(acc);
			false;
		}
	} else {
		// Position-only version
		pos = acc.i;
		if (ops[0]()) {
			if (moSequence(acc, tail(ops), modifiesStack)) {
				true;
			} else {
				acc.i ::= pos;
				false;
			}
		} else {
			acc.i ::= pos;
			false;
		}
	}
}

mparseStar(acc : MoParseAcc, matcher : () -> bool) -> bool {
	pushMCheckpoint(acc);
	if (matcher()) {
		discardMCheckpoint(acc);
		mparseStar(acc, matcher)
	} else {
		restoreMCheckpoint(acc);
		true;
	};
}

// Optimized version of mparseStar for operations that don't modify the stack
// and don't need full backtracking. This is for simple patterns like character
// classes or simple string matches.
//
// This function avoids creating checkpoints entirely, only tracking position.
mparseStarNobacktrackOrStack(acc : MoParseAcc, matcher : () -> bool) -> bool {
	doMparseStarNobacktrackOrStack(acc, matcher);
	true;  // Star always succeeds
}

doMparseStarNobacktrackOrStack(acc : MoParseAcc, matcher : () -> bool) -> void {
	startPos = acc.i;

	// Try to match
	if (matcher()) {
		// If match succeeds, continue recursively
		doMparseStarNobacktrackOrStack(acc, matcher);
	} else {
		// If match fails, restore position and stop recursion
		acc.i ::= startPos;
	}
}

// Optimized version of mparseStar for operations that don't modify the stack
// but may need position backtracking. This avoids the overhead of managing
// the full checkpoint stack but still handles position tracking.
//
// Good for patterns that might fail and need position restoration but don't
// manipulate the parser value stack.
mparseStarBacktrackOnly(acc : MoParseAcc, matcher : () -> bool) -> bool {
	doMparseStarBacktrackOnly(acc, matcher);
	true;  // Star always succeeds
}

doMparseStarBacktrackOnly(acc : MoParseAcc, matcher : () -> bool) -> void {
	startPos = acc.i;

	// Try to match
	if (matcher()) {
		// Continue matching if successful
		if (acc.i > startPos) {
			// Only recurse if we've advanced to avoid infinite loops
			doMparseStarBacktrackOnly(acc, matcher);
		}
	} else {
		// If match fails, restore position and stop recursion
		acc.i ::= startPos;
	}
}

mmatchString(acc : MoParseAcc, s : string) -> bool {
	if (strContainsAt(acc.input, acc.i, s)) {
		acc.i ::= acc.i + strlen(s);
		if (acc.i > acc.maxi) acc.maxi ::= acc.i;
		// println("Matched " + s);
		true;
	} else false;
}

mmatchRange(acc : MoParseAcc, l : int, u : int) -> bool {
	code = getCharCodeAt(acc.input, acc.i);
	if (acc.i < strlen(acc.input) && l <= code && code <= u) {
		acc.i ::= acc.i + 1;
		if (acc.i > acc.maxi) acc.maxi ::= acc.i;
		// println("Matched range " +  "0x" + formatHex(l) + "-" + formatHex(u) + " as  " + fromCharCode(code));
		true;
	} else false;
}

moconstruct(acc : MoParseAcc, uid : string, arity : int) -> bool {
	args = generate(0, arity, \__ -> {
		popPEnv(acc.env)
	});
	struct = makeStructValue(uid, reverseA(args), IllegalStruct());
	if (struct != IllegalStruct()) {
		pushPEnv(acc.env, struct);
		true;
	} else {
		println("ERROR: Could not construct " + uid + " with args " + toString(args));
		false;
	}
}

parseCompiledMango(path : string, content : string, parseFn : (MoParseAcc) -> bool, def : ?) -> Pair<?, string> {
	macc = MoParseAcc(content, PEnv(ref makeList()), 0, makeList(), 0, 0);
	ok = parseFn(macc);

	value = getSinglePEnv(macc.env, def);

	// If we failed the parse, or did not parse everything, print an error 
	if (!ok || macc.i < strlen(content)) {
		Pair(value, getLinePos(path, content, "Parse error", macc.maxi, 1, 0));
	} else {
		Pair(value, "");
	}
}
