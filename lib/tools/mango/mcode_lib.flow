import string;
import tools/poppy/penv;
import tools/mango/line;
import ds/stack;

export {
	MoParseAcc(
		input : string,
		// This has the output stack
		env : PEnv,
		mutable i : int,
		mutable stack : Stack<MCheckpoint>,
		// The last checkpoint for match string
		mutable starti : int,
		// The longest we have matched
		mutable maxi : int,
		// Position-only backtracking stack (no PEnv state)
		mutable posStack : Stack<int>,
	);

	MCheckpoint(i : int, poppyStack : List<flow>);

	// Optimized checkpoint functions when we do not need the stack
	pushMCheckpointNoStack(acc : MoParseAcc) -> void;
	discardMCheckpointNoStack(acc : MoParseAcc) -> bool;
	restoreMCheckpointNoStack(acc : MoParseAcc) -> bool;
	
	// Always use full stack checkpoints
	pushMCheckpoint(acc : MoParseAcc) -> void;
	discardMCheckpoint(acc : MoParseAcc) -> bool;
	restoreMCheckpoint(acc : MoParseAcc) -> bool;

	mparseStar(acc : MoParseAcc, matcher : () -> bool) -> bool;
	mparseStarNobacktrackOrStack(acc : MoParseAcc, matcher : () -> bool) -> bool;
	mparseStarBacktrackOnly(acc : MoParseAcc, matcher : () -> bool) -> bool;

	mmatchString(acc : MoParseAcc, s : string) -> bool;
	mmatchRange(acc : MoParseAcc, l : int, u : int) -> bool;
	moconstruct(acc : MoParseAcc, uid : string, arity : int) -> bool;

	// Driver to parse a compiled mango file
	parseCompiledMango(path : string, content : string, parseFn : (MoParseAcc) -> bool, def : ?) -> Pair<?, string>;
}

pushMCheckpoint(acc : MoParseAcc) -> void {
	pushStack(acc.stack, MCheckpoint(acc.i, ^(acc.env.stack)));
}

discardMCheckpoint(acc : MoParseAcc) -> bool {
	discardStack(acc.stack);
	true;
}

dummyMCheckpoint : MCheckpoint = MCheckpoint(0, makeList());

restoreMCheckpoint(acc : MoParseAcc) -> bool {
	checkPoint = popStackDef(acc.stack, dummyMCheckpoint);
	acc.i ::= checkPoint.i;
	acc.env.stack := checkPoint.poppyStack;
	false;
}

pushMCheckpointNoStack(acc : MoParseAcc) -> void {
	// Position-only checkpoint (faster)
	pushStack(acc.posStack, acc.i);
}

discardMCheckpointNoStack(acc : MoParseAcc) -> bool {
	discardStack(acc.posStack);
	true;
}

restoreMCheckpointNoStack(acc : MoParseAcc) -> bool {
	// Restore position-only checkpoint
	acc.i ::= popStackDef(acc.posStack, 0);
	false;
}

mparseStar(acc : MoParseAcc, matcher : () -> bool) -> bool {
	pushMCheckpoint(acc);
	if (matcher()) {
		discardMCheckpoint(acc);
		mparseStar(acc, matcher)
	} else {
		restoreMCheckpoint(acc);
		true;
	};
}

// Optimized version of mparseStar for operations that don't modify the stack
// and don't need full backtracking. This is for simple patterns like character
// classes or simple string matches.
//
// This function avoids creating checkpoints entirely, only tracking position.
mparseStarNobacktrackOrStack(acc : MoParseAcc, matcher : () -> bool) -> bool {
	doMparseStarNobacktrackOrStack(acc, matcher);
	true;  // Star always succeeds
}

doMparseStarNobacktrackOrStack(acc : MoParseAcc, matcher : () -> bool) -> void {
	startPos = acc.i;

	// Try to match
	if (matcher()) {
		// If match succeeds, continue recursively
		doMparseStarNobacktrackOrStack(acc, matcher);
	} else {
		// If match fails, restore position and stop recursion
		acc.i ::= startPos;
	}
}

// Optimized version of mparseStar for operations that don't modify the stack
// but may need position backtracking. This avoids the overhead of managing
// the full checkpoint stack but still handles position tracking.
//
// Good for patterns that might fail and need position restoration but don't
// manipulate the parser value stack.
mparseStarBacktrackOnly(acc : MoParseAcc, matcher : () -> bool) -> bool {
	doMparseStarBacktrackOnly(acc, matcher);
	true;  // Star always succeeds
}

doMparseStarBacktrackOnly(acc : MoParseAcc, matcher : () -> bool) -> void {
	startPos = acc.i;

	// Try to match
	if (matcher()) {
		doMparseStarBacktrackOnly(acc, matcher);
	} else {
		// If match fails, restore position and stop recursion
		acc.i ::= startPos;
	}
}

mmatchString(acc : MoParseAcc, s : string) -> bool {
	if (strContainsAt(acc.input, acc.i, s)) {
		acc.i ::= acc.i + strlen(s);
		if (acc.i > acc.maxi) acc.maxi ::= acc.i;
		// println("Matched " + s);
		true;
	} else false;
}

mmatchRange(acc : MoParseAcc, l : int, u : int) -> bool {
	code = getCharCodeAt(acc.input, acc.i);
	if (acc.i < strlen(acc.input) && l <= code && code <= u) {
		acc.i ::= acc.i + 1;
		if (acc.i > acc.maxi) acc.maxi ::= acc.i;
		// println("Matched range " +  "0x" + formatHex(l) + "-" + formatHex(u) + " as  " + fromCharCode(code));
		true;
	} else false;
}

moconstruct(acc : MoParseAcc, uid : string, arity : int) -> bool {
	args = generate(0, arity, \__ -> {
		popPEnv(acc.env)
	});
	struct = makeStructValue(uid, reverseA(args), IllegalStruct());
	if (struct != IllegalStruct()) {
		pushPEnv(acc.env, struct);
		true;
	} else {
		println("ERROR: Could not construct " + uid + " with args " + toString(args));
		false;
	}
}

parseCompiledMango(path : string, content : string, parseFn : (MoParseAcc) -> bool, def : ?) -> Pair<?, string> {
	macc = MoParseAcc(content, PEnv(ref makeList()), 0, makeStack(), 0, 0, makeStack());
	ok = parseFn(macc);

	value = getSinglePEnv(macc.env, def);

	// If we failed the parse, or did not parse everything, print an error 
	if (!ok || macc.i < strlen(content)) {
		Pair(value, getLinePos(path, content, "Parse error", macc.maxi, 1, 0));
	} else {
		Pair(value, "");
	}
}