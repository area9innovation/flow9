import tools/mango/compiler/mopcode;
import tools/mango/mango_types;
import ds/array;
import ds/tree;

export {
	// Structure to track the effects of each MOpCode function
	MOpCodeEffects(
		modifiesStack : bool,     // Whether the operation modifies the value stack
		needsBacktracking : bool  // Whether the operation needs backtracking capabilities
	);

	// Perform fixed-point analysis for mutually recursive functions
	analyzeGrammarEffects(grammar : MOpCode) -> Tree<string, MOpCodeEffects>;

	// Determines if an MOpCode manipulates the value stack, using function effects map
	modifiesStackWithEffects(op : MOpCode, effects : Tree<string, MOpCodeEffects>) -> bool;
	// Determines if an MOpCode needs backtracking capabilities, using function effects map
	needsBacktrackingWithEffects(op : MOpCode, effects : Tree<string, MOpCodeEffects>) -> bool;
	
	// Analyze effects for a Term expression to determine stack and backtracking needs
	analyzeTermEffects(term : Term) -> MOpCodeEffects;
	// Check if a Term modifies the stack
	modifiesStackTerm(term : Term) -> bool;
	// Check if a Term needs backtracking capabilities
	needsBacktrackingTerm(term : Term) -> bool;
}

// Determines if an MOpCode manipulates the value stack, using function effects map
modifiesStackWithEffects(op : MOpCode, effects : Tree<string, MOpCodeEffects>) -> bool {
	switch (op) {
		MoConstruct(__, __): true;  // Creates and pushes a new struct
		MoEvalPoppy(__): true;      // Poppy code can modify stack
		MoMatched(): true;          // Pushes matched text
		MoPushPosition(): true;     // Pushes current position
		MoCaptureI(): false;        // Just updates starti
		MoMatchString(__): false;   // Just advances position
		MoMatchRange(__, __): false; // Just advances position
		MoBool(__): false;          // Constant
		MoFunction(__, code, __): modifiesStackWithEffects(code, effects);
		MoIf(cond, then, else_):
			modifiesStackWithEffects(cond, effects) ||
			modifiesStackWithEffects(then, effects) ||
			modifiesStackWithEffects(else_, effects);
		MoParseStar(term): modifiesStackWithEffects(term, effects);
		MoCall(id): {
			// Use the effects map to determine if the called function modifies the stack
			lookupTreeDef(effects, id, MOpCodeEffects(true, true)).modifiesStack;
		}
		MoSequence(exps): exists(exps, \exp -> modifiesStackWithEffects(exp, effects));
		MoAnd(left, right):
			modifiesStackWithEffects(left, effects) || modifiesStackWithEffects(right, effects);
		MoOr(left, right):
			modifiesStackWithEffects(left, effects) || modifiesStackWithEffects(right, effects);
		// Checkpoint operations themselves don't modify the value stack
		MoPushCheckpoint(withStack): false;
		MoDiscardCheckpoint(withStack): false;
		MoRestoreCheckpoint(withStack): false;
	}
}

// Determines if an MOpCode needs backtracking capabilities, using function effects map
needsBacktrackingWithEffects(op : MOpCode, effects : Tree<string, MOpCodeEffects>) -> bool {
	switch (op) {
		// These definitely need backtracking
		MoOr(__, __): true;  // Choice operator
		MoParseStar(term): needsBacktrackingWithEffects(term, effects);

		// These operations are pure and don't need backtracking
		MoMatchString(__): false;    // Simple string match
		MoMatchRange(__, __): false; // Simple character match
		MoBool(__): false;           // Constant
		MoCaptureI(): false;         // Just sets a marker
		MoPushPosition(): false;     // Just pushes position
		MoMatched(): false;
		MoEvalPoppy(__): false;
		MoConstruct(__, __): false;

		// These depend on their components
		MoFunction(__, code, __): needsBacktrackingWithEffects(code, effects);
		MoIf(cond, then, else_):
			needsBacktrackingWithEffects(cond, effects) ||
			needsBacktrackingWithEffects(then, effects) ||
			needsBacktrackingWithEffects(else_, effects);
		MoSequence(exps): {
			// A sequence needs backtracking if any component does,
			// or if any component can fail after changing the stack
			if (exists(exps, \exp -> needsBacktrackingWithEffects(exp, effects))) true
			else {
				doNeedsBacktrackingSequenceWithEffects(exps, 0, effects);
			}
		}
		MoAnd(left, right):
			// If left modifies stack and right can fail, we need backtracking
			(modifiesStackWithEffects(left, effects) && canFailWithEffects(right, effects)) ||
			needsBacktrackingWithEffects(left, effects) ||
			needsBacktrackingWithEffects(right, effects);

		// Calls to other rules - use the effects map
		MoCall(id): {
			lookupTreeDef(effects, id, MOpCodeEffects(true, true)).needsBacktracking;
		}

		// Checkpoint operations themselves
		MoPushCheckpoint(withStack): true;
		MoDiscardCheckpoint(withStack): true;
		MoRestoreCheckpoint(withStack): true;
	}
}

// Helper for checking sequences with effects map
doNeedsBacktrackingSequenceWithEffects(exps : [MOpCode], i : int, effects : Tree<string, MOpCodeEffects>) -> bool {
	if (i >= length(exps) - 1) {
		false;
	} else if (modifiesStackWithEffects(exps[i], effects) && canFailWithEffects(exps[i+1], effects)) {
		true;
	} else {
		doNeedsBacktrackingSequenceWithEffects(exps, i + 1, effects);
	}
}

// Helper: determines if an operation can fail, using function effects map
canFailWithEffects(op : MOpCode, effects : Tree<string, MOpCodeEffects>) -> bool {
	switch (op) {
		MoMatchString(__): true;      // String match can fail
		MoMatchRange(__, __): true;   // Character match can fail
		MoBool(b): !b;                // Only MoBool(false) always fails
		MoConstruct(__, __): false;   // Always succeeds if args are on stack
		MoMatched(): false;           // Always succeeds
		MoCaptureI(): false;          // Always succeeds
		MoPushPosition(): false;      // Always succeeds

		// These operations depend on their components
		MoFunction(__, code, __): canFailWithEffects(code, effects);
		MoIf(cond, then, else_):
			canFailWithEffects(cond, effects) ||
			canFailWithEffects(then, effects) ||
			canFailWithEffects(else_, effects);
		MoParseStar(__): false;       // Star never fails by definition
		MoCall(id): true;             // Conservative - rules can fail
		MoSequence(exps): exists(exps, \exp -> canFailWithEffects(exp, effects));
		MoAnd(left, right):
			canFailWithEffects(left, effects) || canFailWithEffects(right, effects);
		MoOr(left, right):
			canFailWithEffects(left, effects) && canFailWithEffects(right, effects);

		// Checkpoint operations
		MoPushCheckpoint(withStack): false;
		MoDiscardCheckpoint(withStack): true;  // Can fail if stack is empty
		MoRestoreCheckpoint(withStack): true;  // Can fail if stack is empty

		MoEvalPoppy(__): true;
	}
}

// Analyze the entire grammar to build a map of function effects
// Returns a tree mapping function names to their effects
determineOpcodeEffects(acc : Tree<string, MOpCodeEffects>, m : MOpCode) -> Tree<string, MOpCodeEffects> {
	switch (m) {
		MoFunction(name, code, body): {
			// First analyze the function's body to handle forward references
			newAcc = determineOpcodeEffects(acc, body);

			// Then analyze this function's code
			modifiesStack = modifiesStackWithEffects(code, newAcc);
			needsBacktracking = needsBacktrackingWithEffects(code, newAcc);

			// Store this function's effects
			newAcc2 = setTree(newAcc, name, MOpCodeEffects(modifiesStack, needsBacktracking));

			// Return the updated effects map
			newAcc2;
		}
		MoSequence(exps): {
			// Analyze each expression in the sequence
			fold(exps, acc, \currentAcc, exp -> {
				determineOpcodeEffects(currentAcc, exp)
			});
		}
		// For other operations, just return the accumulated effects
		// since they don't define new functions
		default: acc;
	}
}

// Perform fixed-point analysis using recursion instead of while loop
analyzeGrammarEffects(grammar : MOpCode) -> Tree<string, MOpCodeEffects> {
	doAnalyzeGrammarEffects(makeTree(), grammar, true);
}

// Helper function for fixed-point iteration using recursion
doAnalyzeGrammarEffects(currentEffects : Tree<string, MOpCodeEffects>, grammar : MOpCode,
						isFirstRun : bool) -> Tree<string, MOpCodeEffects> {
	// Analyze with current effects
	newEffects = determineOpcodeEffects(currentEffects, grammar);

	// Check if we've reached a fixed point
	if (isFirstRun || !equalTrees(currentEffects, newEffects)) {
		// Continue iterating if not stable
		doAnalyzeGrammarEffects(newEffects, grammar, false);
	} else {
		// Return the stable effects
		newEffects;
	}
}

// Analyze a Term to determine its effects
analyzeTermEffects(term : Term) -> MOpCodeEffects {
	MOpCodeEffects(
		modifiesStackTerm(term),
		needsBacktrackingTerm(term)
	)
}

// Checks if a Term modifies the stack
modifiesStackTerm(term : Term) -> bool {
	switch (term) {
		String(__): false;  // String literals don't modify stack
		Range(__, __): false;  // Character ranges don't modify stack
		Variable(__): true;  // TODO: We have to be conservative
		
		PushMatch(__): true;  // Explicitly pushes a match
		Construct(__, __): true;  // Creates a structure
		StackOp(__): true;  // Stack operations modify the stack by definition
		
		Choice(t1, t2): modifiesStackTerm(t1) || modifiesStackTerm(t2);
		Sequence(t1, t2): modifiesStackTerm(t1) || modifiesStackTerm(t2);
		Rule(__, t1, t2): modifiesStackTerm(t1) || modifiesStackTerm(t2);
		
		Star(t): modifiesStackTerm(t);
		Plus(t): modifiesStackTerm(t);
		Optional(t): modifiesStackTerm(t);
		Negate(t): modifiesStackTerm(t);
		
		Precedence(t1, t2): modifiesStackTerm(t1) || modifiesStackTerm(t2);
		Error(t): modifiesStackTerm(t);
		Lower(t): modifiesStackTerm(t);
		
		GrammarCall(__, t): modifiesStackTerm(t);
		GrammarFn(__, t1, t2, t3): modifiesStackTerm(t1) || modifiesStackTerm(t2) || modifiesStackTerm(t3);
	}
}

// Checks if a Term needs backtracking capabilities
needsBacktrackingTerm(term : Term) -> bool {
	switch (term) {
		// These always need backtracking
		Choice(__, __): true;  // Choice requires backtracking by definition
		Negate(__): true;  // Negation requires backtracking
		Optional(__): true;  // Optional requires backtracking
		
		// Star doesn't need backtracking if its term doesn't
		Star(t): needsBacktrackingTerm(t);
		Plus(t): needsBacktrackingTerm(t);
		
		// These depend on their components and potential stack modifications
		Sequence(t1, t2): {
			// Sequence needs backtracking if either term needs it
			// or if t1 modifies stack and t2 can fail
			needsBacktrackingTerm(t1) || needsBacktrackingTerm(t2) ||
			(modifiesStackTerm(t1) && canFailTerm(t2))
		};
		
		// Rules/functions depend on their bodies
		Rule(__, t1, t2): needsBacktrackingTerm(t1) || needsBacktrackingTerm(t2);
		Precedence(t1, t2): needsBacktrackingTerm(t1) || needsBacktrackingTerm(t2);
		
		// Simple operations generally don't need backtracking
		String(__): false;  // String literals can fail but don't need backtracking
		Range(__, __): false;  // Character ranges can fail but don't need backtracking
		Variable(__): false;  // Variables depend on what they reference, but conservative: false
		PushMatch(t): needsBacktrackingTerm(t);
		Construct(__, __): false;  // Constructors always succeed
		StackOp(__): false;  // Stack operations don't need backtracking
		
		// Other terms
		Error(t): needsBacktrackingTerm(t);
		Lower(t): needsBacktrackingTerm(t);
		GrammarCall(__, t): needsBacktrackingTerm(t);
		GrammarFn(__, t1, t2, t3): needsBacktrackingTerm(t1) || needsBacktrackingTerm(t2) || needsBacktrackingTerm(t3);
	}
}

// Helper: determines if a Term can fail
canFailTerm(term : Term) -> bool {
	switch (term) {
		String(__): true;  // String literals can fail if they don't match
		Range(__, __): true;  // Character ranges can fail if no match
		Variable(__): true;  // Variables can fail (conservative assumption)
		
		PushMatch(t): canFailTerm(t);
		Construct(__, __): false;  // Constructors always succeed
		StackOp(__): false;  // Most stack operations succeed
		
		Choice(t1, t2): canFailTerm(t1) && canFailTerm(t2);  // Both alternatives must fail
		Sequence(t1, t2): canFailTerm(t1) || canFailTerm(t2);  // Either component can fail
		
		Rule(__, t1, t2): canFailTerm(t1) || canFailTerm(t2);
		Star(__): false;  // Star never fails by definition
		Plus(t): canFailTerm(t);  // Plus can fail if first iteration fails
		Optional(__): false;  // Optional never fails by definition
		Negate(t): !canFailTerm(t);  // Negate fails if inner term succeeds
		
		Precedence(t1, t2): canFailTerm(t1) || canFailTerm(t2);
		Error(t): canFailTerm(t);
		Lower(t): canFailTerm(t);
		
		GrammarCall(__, t): canFailTerm(t);
		GrammarFn(__, t1, t2, t3): canFailTerm(t1) || canFailTerm(t2) || canFailTerm(t3);
	}
}
