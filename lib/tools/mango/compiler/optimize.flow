import tools/mango/compiler/mopcode;
import runtime;
import tools/poppy/compiler/compile;

export {
	optimizeMOpCode(m : MOpCode) -> MOpCode;
}

optimizeMOpCode(m : MOpCode) -> MOpCode {
	todo = \ -> {
		println("TODO: Optimize " + toString(m));
		m;
	}
	switch (m) {
		MoFunction(name, code, body): MoFunction(name, optimizeMOpCode(code), optimizeMOpCode(body));
		MoMatchString(s): m;
		MoMatchRange(lower, upper): m;
		MoIf(cond, then, else_): {
			// Split any prefix in the condition out in front
			oc = optimizeMOpCode(cond);
			split = splitMSequence(oc);

			ot = optimizeMOpCode(then);
			oe = optimizeMOpCode(else_);
			seq = concat(split.first,
				if (isMOpCodeTrue(split.second)) {
					[ot]
				} else if (split.second == MoBool(false)) {
					[oe];
				} else if (ot == MoBool(true) && oe == MoBool(false)) {
					[split.second]
				} else if (isMOpCodeAlwaysTrue(split.second)) {
					// No need for the else, but we keep the condition for side-effect
					[split.second, ot]
				} else {
					[optimizeNestedMIfForOr(optimizeNestedMIfForAnd(MoIf(split.second, ot, oe)))]
				}
			);
			if (length(seq) == 1) seq[0]
			else optimizeMOpCode(MoSequence(seq))
		}
		MoParseStar(term): MoParseStar(optimizeMOpCode(term));
		MoCall(id): m;
		MoCaptureI(): m;
		MoMatched(): m;
		MoBool(b): m;
		MoEvalPoppy(poppy): m;
		MoPushPosition(): m;
		
		// New high-level operations for grammar patterns
		MoNegate(op): {
			nop = optimizeMOpCode(op);
			// Optimize double negation
			if (isMoNegate(nop)) {
				getMoNegateOperand(nop);
			} else if (nop == MoBool(true)) {
				MoBool(false);
			} else if (nop == MoBool(false)) {
				MoBool(true);
			} else {
				MoNegate(nop);
			}
		}
		MoOptional(op): {
			nop = optimizeMOpCode(op);
			// If the operand is a constant, we can simplify
			if (nop == MoBool(true) || nop == MoBool(false)) {
				MoBool(true); // Optional always succeeds
			} else {
				MoOptional(nop);
			}
		}
		MoChoice(ops): {
			// Optimize each choice branch
			optimizedOps = map(ops, optimizeMOpCode);
			
			// Filter out any branches that are syntactically false
			filteredOps = filter(optimizedOps, \op -> op != MoBool(false));
			
			// If no branches remain, the choice fails
			if (filteredOps == []) {
				MoBool(false);
			} else if (length(filteredOps) == 1) {
				// If only one branch remains, return it directly
				filteredOps[0];
			} else if (filteredOps[0] == MoBool(true)) {
				// If the first branch always succeeds, no need for others (committed choice)
				MoBool(true);
			} else {
				// Must preserve order for committed choice semantics
				MoChoice(filteredOps);
			}
		}
		
		MoSequence(exps): {
			seq = concatA(filtermapi(exps, \i, e -> {
				co = optimizeMOpCode(e);
				islast = i == length(exps) - 1;
				
				// We can only remove operations that are syntactically true and have no side effects
				if (!islast && co == MoBool(true)) {
					None();
				} else {
					Some(switch (co) {
						MoSequence(ns): ns;
						default: [co];
					})
				}
			}));
			
			// If a sequence has a syntactic false, the whole sequence will fail
			if (exists(seq, \e -> e == MoBool(false))) {
				// But we need to preserve any operations before the false for side effects
				idx = findiDef(seq, \e -> e == MoBool(false), length(seq) - 1);
				if (idx == 0) {
					MoBool(false);
				} else {
					// Keep operations up to and including the false (for side effects)
					MoSequence(subrange(seq, 0, idx + 1));
				}
			} else if (seq == []) {
				MoBool(true);
			} else if (length(seq) == 1) {
				seq[0];
			} else {
				MoSequence(seq);
			}
		}
		MoConstruct(uid, arity): m;
		MoAnd(left, right): {
			nleft = optimizeMOpCode(left);
			nright = optimizeMOpCode(right);
			
			// We must be careful with side effects
			// Only optimize if we have explicit boolean constants
			if (nleft == MoBool(false)) {
				// Short-circuit evaluation for explicit false
				nleft;
			} else if (nleft == MoBool(true)) {
				// True doesn't affect result, but preserve side effects in right
				nright;
			} else if (nright == MoBool(false)) {
				// Cannot short-circuit - must evaluate left for side effects first
				MoSequence([nleft, MoBool(false)]);
			} else if (nright == MoBool(true)) {
				// Right doesn't affect result
				nleft;
			} else {
				MoAnd(nleft, nright);
			}
		}
		MoOr(left, right): {
			nleft = optimizeMOpCode(left);
			nright = optimizeMOpCode(right);
			
			// We must be careful with side effects
			// Only optimize if we have explicit boolean constants
			if (nleft == MoBool(true)) {
				// Short-circuit evaluation for explicit true
				nleft;
			} else if (nleft == MoBool(false)) {
				// False doesn't affect result, but preserve side effects
				nright;
			} else if (nright == MoBool(true)) {
				// Cannot short-circuit - must evaluate left for side effects first
				MoSequence([nleft, MoBool(true)]);
			} else if (nright == MoBool(false)) {
				// Right doesn't affect result
				nleft;
			} else {
				MoOr(nleft, nright);
			}
		}
	}
}

// Helper function to check if an opcode is MoNegate
isMoNegate(op : MOpCode) -> bool {
	switch (op) {
		MoNegate(__): true;
		default: false;
	}
}

// Helper function to get the operand of MoNegate
getMoNegateOperand(op : MOpCode) -> MOpCode {
	switch (op) {
		MoNegate(inner): inner;
		default: op; // Should never happen if properly checked first
	}
}

// If this is a sequence, split into the head and the tail
splitMSequence(f : MOpCode) -> Pair<[MOpCode], MOpCode> {
	switch (f) {
		MoSequence(exprs): {
			n = length(exprs);
			if (n == 0) Pair([], f)
			else Pair(subrange(exprs, 0, n - 1), exprs[n-1]);
		}
		default: Pair([], f);
	}
}

// Does this always return true?
isMOpCodeTrue(d : MOpCode) -> bool {
	switch (d) {
		MoBool(b): b;
		default: false;
	}
}

/*
	if (<cond1>) {
		if (<cond2>) {
			<something>
		} else {
			<else>
		}
	} else {
		<else>
	}

can be rewritten to be

	if (<cond1> && <cond2>) {
		<something>
	} else {
		<else>
	}
*/
optimizeNestedMIfForAnd(d : MoIf) -> MoIf {
	switch (d.then) {
		MoIf(cond, then, else_): {
			if (existsMOpCode(d.cond, isMNotAndable)
				|| existsMOpCode(cond, isMNotAndable)) {
				d;
			} else if (else_ == d.else_) {
				// OK, we can rewrite to use an and
				MoIf(MoAnd(d.cond, cond), then, else_)
			} else {
				d;
			}
		}
		default: d;
	}
}

/*
Also,

	if (<cond1>) {
		<then>
	} else {
		if (<cond2>) {
			<then>
		} else {
			<else>
		}
	}

can be rewritten to be

	if (<cond1> || <cond2>) {
		<then>
	} else {
		<else>
	}
*/
optimizeNestedMIfForOr(d : MoIf) -> MoIf {
	switch (d.else_) {
		MoIf(cond, then, else_): {
			if (existsMOpCode(d.cond, isMNotAndable)
				|| existsMOpCode(cond, isMNotAndable)) {
				d;
			} else if (then == d.then) {
				// OK, we can rewrite to use an or
				MoIf(MoOr(d.cond, cond), then, else_)
			} else {
				d;
			}
		}
		default: d;
	}
}

isMOpCodeMatch(d : MOpCode) -> bool {
	switch (d) {
		MoMatchString(__): true;
		MoMatchRange(__, __): true;
		MoAnd(left, right): isMOpCodeMatch(left) && isMOpCodeMatch(right);
		MoOr(left, right): isMOpCodeMatch(left) && isMOpCodeMatch(right);
		MoParseStar(t): isMOpCodeMatch(t);
		MoCall(__): false; // This is not trivial if there is prefix overlap
		MoBool(p): true;
		MoNegate(op): isMOpCodeMatch(op);
		MoOptional(op): isMOpCodeMatch(op);
		MoChoice(ops): forall(ops, isMOpCodeMatch);
		default: false;
	}
}

existsMOpCode(d : MOpCode, fn : (MOpCode) -> bool) -> bool {
	fn(d) || switch (d) {
		MoFunction(name, code, body): existsMOpCode(body, fn);
		MoMatchString(s): false;
		MoMatchRange(lower, upper): false;
		MoIf(cond, then, else_): existsMOpCodes([cond, then, else_], fn);
		MoParseStar(term): existsMOpCode(term, fn);
		MoCall(id): false;
		MoCaptureI(): false;
		MoMatched(): false;
		MoBool(poppy): false;
		MoEvalPoppy(poppy): false;
		MoPushPosition(): false;
		MoSequence(exps): existsMOpCodes(exps, fn);
		MoConstruct(uid, arity): false;
		MoAnd(left, right): existsMOpCodes([left, right], fn);
		MoOr(left, right): existsMOpCodes([left, right], fn);
		MoNegate(op): existsMOpCode(op, fn);
		MoOptional(op): existsMOpCode(op, fn);
		MoChoice(ops): existsMOpCodes(ops, fn);
	}
}

existsMOpCodes(d : [MOpCode], fn : (MOpCode) -> bool) -> bool {
	fold(d, false, \acc, dd -> acc || existsMOpCode(dd, fn))
}

// Should this be avoided inside an && construct?
isMNotAndable(d : MOpCode) -> bool {
	switch (d) {
		MoCaptureI(): true;
		MoPushPosition(): true;
		default: false;
	}
}

// Does this opcode always succeed (it might have side effects)
// Does this opcode always succeed (it might have side effects)
isMOpCodeAlwaysTrue(o : MOpCode) -> bool {
	switch (o) {
		MoFunction(name, code, body): false;
		MoMatchString(s): false;
		MoMatchRange(lower, upper): false;
		MoIf(cond, then, else_): false;
		MoParseStar(term): true; // This always succeeds
		MoCall(id): false;
		MoCaptureI(): true;
		MoMatched(): true;
		MoBool(b): b;
		MoEvalPoppy(p): true; // This also always succeeds
		MoPushPosition(): true;
		MoSequence(exps): forall(exps, isMOpCodeAlwaysTrue);
		MoConstruct(uid, arity): true;
		MoAnd(left, right): isMOpCodeAlwaysTrue(left) && isMOpCodeAlwaysTrue(right);
		MoOr(left, right): isMOpCodeAlwaysTrue(left) || isMOpCodeAlwaysTrue(right);
		MoNegate(op): isMOpCodeAlwaysFalse(op); // Negation succeeds if the operand always fails
		MoOptional(op): true; // Optional always succeeds
		MoChoice(ops): exists(ops, isMOpCodeAlwaysTrue); // Choice succeeds if any option always succeeds
	}
}

// Helper function: Does this opcode always fail?
isMOpCodeAlwaysFalse(o : MOpCode) -> bool {
	switch (o) {
		MoFunction(name, code, body): false;
		MoMatchString(s): false;
		MoMatchRange(lower, upper): false;
		MoIf(cond, then, else_): false;
		MoParseStar(term): false; // Star never fails
		MoCall(id): false;
		MoCaptureI(): false;
		MoMatched(): false;
		MoBool(b): !b;
		MoEvalPoppy(p): false;
		MoPushPosition(): false;
		MoSequence(exps): exists(exps, isMOpCodeAlwaysFalse);
		MoConstruct(uid, arity): false;
		MoAnd(left, right): isMOpCodeAlwaysFalse(left) || isMOpCodeAlwaysFalse(right);
		MoOr(left, right): isMOpCodeAlwaysFalse(left) && isMOpCodeAlwaysFalse(right);
		MoNegate(op): isMOpCodeAlwaysTrue(op); // Negation fails if the operand always succeeds
		MoOptional(op): false; // Optional never fails
		MoChoice(ops): forall(ops, isMOpCodeAlwaysFalse); // Choice fails if all options always fail
	}
}
