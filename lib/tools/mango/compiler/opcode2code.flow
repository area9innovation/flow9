import tools/mango/compiler/mopcode;
import tools/mango/compiler/opcode_effects;
import tools/mango/compiler/pretty;
import string;
import text/blueprint;
import net/url_parameter;
import tools/poppy/compiler/compile;
import ds/tree;

export {
	// Function signature with effects tree parameter
	mopcode2code(c : MOpCode, effects : Tree<string, MOpCodeEffects>) -> string;
	
	// Ensures that a piece of code produces a boolean value
	ensureBooleanReturn(code : string) -> string;
	
	// Helper function to generate code for a sequence of operations without lambdas
	generateSequenceCode(ops : [MOpCode], effects : Tree<string, MOpCodeEffects>, checkStack : bool, uniqueId : int) -> string;
	
	// Checks if any operation in the list contains a MoParseStar
	containsMOpStar(ops : [MOpCode]) -> bool;
	
	// Counter for generating unique IDs for variables
	idCounter : ref int = ref 0;
}

// Helper function to ensure code produces a boolean
// If the code already produces a boolean value, leave it as is
// Otherwise, add a "true" at the end to ensure it yields a boolean
ensureBooleanReturn(code : string) -> string {
	code_trim = trim(code);
	
	// Empty code - just use true
	if (code_trim == "") {
		"true";
	} else if (code_trim == "true" || code_trim == "false" ||
	    startsWith(code_trim, "mmatchString") ||
	    startsWith(code_trim, "mmatchRange") ||
	    startsWith(code_trim, "moChoice") ||
	    startsWith(code_trim, "moSequence") ||
	    startsWith(code_trim, "moNegate") ||
	    startsWith(code_trim, "moOptional") ||
	    startsWith(code_trim, "mparseStar") ||
	    startsWith(code_trim, "mparseStarNobacktrackOrStack") ||
	    startsWith(code_trim, "mparseStarBacktrackOnly") ||
	    startsWith(code_trim, "moconstruct")) {
		// These operations already produce boolean values
		code;
	} else if (strContains(code_trim, "::=") ||
	    startsWith(code_trim, "acc.i ::=") ||
	    startsWith(code_trim, "acc.starti ::=")) {
		// Check for assignments and ::= operators - these always yield void
		// Ensure they are wrapped in a block with a boolean result
		"{ " + code_trim + (if (endsWith(code_trim, ";")) " " else "; ") + "true }";
	} else if (!endsWith(code_trim, ";")) {
		// For expressions that don't end with semicolons, assume they produce a boolean
		code;
	} else {
		// For anything else ending with semicolon, add true
		code + " true";
	}
}

// Helper function to generate efficient straight-line code for sequences without lambdas
generateSequenceCode(ops : [MOpCode], effects : Tree<string, MOpCodeEffects>, checkStack : bool, uniqueId : int) -> string {
	if (length(ops) == 0) {
		"true";
	} else if (length(ops) == 1) {
		// For single operation, just return its code directly
		ensureBooleanReturn(mopcode2code(ops[0], effects));
	} else {
		// Create unique variable names with the uniqueId
		okVar = "_seqOk" + i2s(uniqueId);
		
		// Structure code as a sequence of operations with proper control flow
		// First operation followed by a check for the rest
		firstOp = ensureBooleanReturn(mopcode2code(ops[0], effects));
		
		// Build the rest of the sequence
		// Increment the uniqueId for nested operations
		restOps = generateSequenceCode(tail(ops), effects, checkStack, uniqueId + 1);
		
		// Combine with proper flow control
		blueprint("%first%\nif (!%ok%) false else {\n  %rest%\n}", [
			"first", okVar + " = " + firstOp + ";",
			"ok", okVar,
			"rest", strReplace(restOps, "\n", "\n  ")
		]);
	}
}

mopcode2code(c : MOpCode, effects : Tree<string, MOpCodeEffects>) -> string {
	todo = \ -> {
		println("TODO: Produce code for " + toString(c));
		"TODO";
	}
	switch (c) {
		MoFunction(name, code, body): {
			prefix = getUrlParameter("prefix");
			blueprint("
				%id%(acc : MoParseAcc) -> bool {
					// println(\"%id%\");
					%term%
				}

				%body%
				", [
					"id", prefix + "parse_" + name,
					"term", mopcode2code(code, effects),
					"body", mopcode2code(body, effects),
				]
			)
		}
		MoMatchString(s): "mmatchString(acc, " + toString(s) + ")";
		MoMatchRange(lower, upper): "mmatchRange(acc, " + i2s(lower) + ", " + i2s(upper) + ")";
		MoIf(cond, then, else_): {
			blueprint("
				if (%cond%) {
					%then%
				} else {
					%else%
				}", [
					"cond", mopcode2code(cond, effects),
					"then", mopcode2code(then, effects),
					"else", mopcode2code(else_, effects),
			]);
		}
		MoParseStar(term): {
			// Use the effects map for optimization
			generateOptimizedParseStar(term, effects);
		}
		MoCall(id): {
			prefix = getUrlParameter("prefix");
			prefix + "parse_" + id + "(acc)";
		}
		MoCaptureI(): "{ acc.starti ::= acc.i; true }";
		MoMatched(): "pushPEnv(acc.env, substring(acc.input, acc.starti, acc.i - acc.starti))";
		MoBool(b): b2s(b);
		MoEvalPoppy(poppy): {
			if (isPoppyValue(poppy)) {
				val = compilePoppy2Value(poppy);
				"pushPEnv(acc.env, " + val + ")";
			} else {
				env = PCompileEnv(getRunCore(), true, ref "", ref 0);
				code = compilePoppy(env, poppy);
				if (^(env.functions) != "") {
					println("TODO: Implement collection of Poppy functions");
				}
				renameEnv = strReplace(code, "(env", "(acc.env");
				blueprint("{%code%; true}", ["code", renameEnv]);
			}
		}
		MoNegate(op): {
			modifiesStack = modifiesStackWithEffects(op, effects);

			blueprint("
				moNegate(acc, \\ -> {
					%op%
				}, %modifies%)", [
				"op", ensureBooleanReturn(mopcode2code(op, effects)),
				"modifies", b2s(modifiesStack)
			]);
		}
		MoOptional(op): {
			// Get effects analysis
			modifiesStack = modifiesStackWithEffects(op, effects);

			blueprint("
				moOptional(acc, \\ -> {
					%op%
				}, %modifies%)", [
				"op", ensureBooleanReturn(mopcode2code(op, effects)),
				"modifies", b2s(modifiesStack)
			]);
		}
		MoChoice(ops): {
			// Get effects for all operations - check if any modify the stack
			anyModifiesStack = exists(ops, \op -> modifiesStackWithEffects(op, effects));

			blueprint("
				moChoice(acc, [
					%ops%
				], %modifies%)", [
				"ops", superglue(ops, \op ->
					"\\ -> { " + ensureBooleanReturn(mopcode2code(op, effects)) + " }",
					",\n            "),
				"modifies", b2s(anyModifiesStack)
			]);
		}
		MoSequence(ops): {
			// Get effects for all operations
			anyModifiesStack = exists(ops, \op -> modifiesStackWithEffects(op, effects));

			if (length(ops) == 0) {
				"true";
			} else if (anyModifiesStack) {
				// Get a unique ID for this sequence
				idCounter := ^idCounter + 1000;
				seqId = ^idCounter;
				okVar = "_seqOk" + i2s(seqId);

				// Generate code for stack-modifying sequences
				// This requires checkpoints for proper backtracking
				blueprint("{
					pushMCheckpoint(acc);
					%code%
					if (%ok%) {
						discardMCheckpoint(acc);
						true;
					} else {
						restoreMCheckpoint(acc);
						false;
					}
				}", [
					"code", generateSequenceCode(ops, effects, true, seqId),
					"ok", okVar
				]);
			} else if (containsMOpStar(ops)) {
				// If any operation contains MoParseStar, use lambdas for this sequence
				// to avoid variable conflicts in nested code blocks
				blueprint("
					moSequence(acc, [
						%ops%
					], %modifies%)", [
						"ops", superglue(ops, \op ->
							"\\ -> { " + ensureBooleanReturn(mopcode2code(op, effects)) + " }",
							",\n            "),
						"modifies", b2s(anyModifiesStack)
				]);
			} else {
				// Get a unique ID for this sequence
				idCounter := ^idCounter + 1000;
				seqId = ^idCounter;
				okVar = "_seqOk" + i2s(seqId);
				posVar = "_seqPos" + i2s(seqId);

				// Generate code for non-stack-modifying sequences
				// This only needs position tracking for backtracking
				blueprint("{
					%pos% = acc.i;
					%code%
					if (!%ok%) {
						acc.i ::= %pos%;
						false;
					} else {
						true;
					}
				}", [
					"code", generateSequenceCode(ops, effects, false, seqId),
					"ok", okVar,
					"pos", posVar
				]);
			}
		}
		MoConstruct(uid, arity): "moconstruct(acc, " + toString(uid) + ", " + i2s(arity) + ")";
		MoPushPosition(): "pushPEnv(acc.env, acc.i)";
		MoAnd(left, right): {
			"(" + superglue([left, right], \o -> {
				if (needMOpCodeParenthesis(o)) {
					"(" + mopcode2code(o, effects) + ")"
				} else {
					mopcode2code(o, effects)
				}
			}, " && ") + ")"
		}
		MoOr(left, right): {
			superglue([left, right], \o -> {
				if (needMOpCodeParenthesis(o)) {
					"(" + mopcode2code(o, effects) + ")"
				} else {
					mopcode2code(o, effects)
				}
			}, " || ")
		}
	}
}

// Generate optimized code for MoParseStar based on analysis with effects map
generateOptimizedParseStar(term : MOpCode, effects : Tree<string, MOpCodeEffects>) -> string {
	if (!modifiesStackWithEffects(term, effects) && !needsBacktrackingWithEffects(term, effects)) {
		// Fast path: simple repetition with no backtracking needed
		println("No stack, no backtrack for " + prettyMOpCode(term));
		blueprint("
			mparseStarNobacktrackOrStack(acc, \\ -> {
				%term%
			})", [
			"term", ensureBooleanReturn(mopcode2code(term, effects))
		]);
	} else if (!modifiesStackWithEffects(term, effects)) {
		// Medium path: position-only backtracking
		println("No stack for " + prettyMOpCode(term));
		blueprint("
			mparseStarBacktrackOnly(acc, \\ -> {
				%term%
			})", [
			"term", ensureBooleanReturn(mopcode2code(term, effects))
		]);
	} else {
		// Standard mparseStar with full checkpointing
		blueprint("
			mparseStar(acc, \\ -> {
				%term%
			})", [
			"term", ensureBooleanReturn(mopcode2code(term, effects))
		]);
	}
}

// Helper function to check if operations contain MoParseStar recursively
containsMOpStar(ops : [MOpCode]) -> bool {
	exists(ops, isMOpStarOrContainsStar)
}

isMOpStarOrContainsStar(opcode : MOpCode) -> bool {
	switch (opcode) {
		MoFunction(name, code, body): isMOpStarOrContainsStar(code) || isMOpStarOrContainsStar(body);
		MoMatchString(s): false;
		MoMatchRange(lower, upper): false;
		MoIf(cond, then, else_): isMOpStarOrContainsStar(cond) || isMOpStarOrContainsStar(then) || isMOpStarOrContainsStar(else_);
		MoParseStar(term): true;
		MoCall(id): false;
		MoCaptureI(): false;
		MoMatched(): false;
		MoBool(b): false;
		MoEvalPoppy(poppy): false;
		MoPushPosition(): false;
		MoSequence(exps): containsMOpStar(exps);
		MoConstruct(uid, arity): false;
		MoNegate(inner): isMOpStarOrContainsStar(inner);
		MoOptional(inner): isMOpStarOrContainsStar(inner);
		MoChoice(choices): containsMOpStar(choices);
		MoAnd(left, right): isMOpStarOrContainsStar(left) || isMOpStarOrContainsStar(right);
		MoOr(left, right): isMOpStarOrContainsStar(left) || isMOpStarOrContainsStar(right);
	}
}

needMOpCodeParenthesis(o : MOpCode) -> bool {
	switch (o) {
		MoFunction(name, code, body): true;
		MoMatchString(s): false
		MoMatchRange(lower, upper): false
		MoIf(cond, then, else_): true;
		MoParseStar(term): false
		MoCall(id): false
		MoCaptureI(): true;
		MoMatched(): false
		MoBool(b): false;
		MoEvalPoppy(poppy): {
			switch (poppy) {
				PoppyBool(bool1): false;
				PoppyDouble(double1): true;
				PoppyInt(int1): false;
				PoppyString(string1): false;
				default: true;
			}
		}
		MoPushPosition(): false
		MoSequence(exps): length(exps) == 1;
		MoConstruct(uid, arity): false;
		MoNegate(op): false;      // Unary operation, high precedence
		MoOptional(op): false;    // Unary operation, high precedence
		MoChoice(ops): true;      // Multi-way choice, likely needs parentheses in expressions
		MoAnd(left, right): true;
		MoOr(left, right): true;
	}
}