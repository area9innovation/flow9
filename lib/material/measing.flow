import material/material_gui;
import ui/animate/easing;

export {
	MEasingAnimation(manager : MaterialManager, parent : MFocusGroup, duration : Transform<double>, bezier : Transform<CubicBezierEasing>, trigger : Transform<?>, beforeEach : (?) -> Maybe<??>,
		percent : (??, double) -> void, style : [MEasingAnimationStyle<??>], t : Tropic) -> Tropic;
	MMEasingAnimation(duration : Transform<double>, bezier : Transform<CubicBezierEasing>, trigger : Transform<?>, beforeEach : (?) -> Maybe<??>,
		percent : (??, double) -> void, style : [MEasingAnimationStyle<??>], t : Material) -> Material;

		MEasingAnimationStyle<?> ::=
			MLoop, MAutoStart, MContinueOnNone, MForceAnimation, MDelay, MFreezeAnimation,
			MStopOffScreen, MIsAnimationPlayed, MDuration, MBezier;

			MLoop(beforeLoop : (?) -> Maybe<?>);
			MAutoStart();
			MContinueOnNone();
			MForceAnimation();
			MDelay(delay : double);
			// Lets you freeze and unfreeze the animation. When freezed,
			//   it doesn't react to either trigger or timer changes. When
			//   unfreezed, animation starts from same point it finished at
			MFreezeAnimation(freeze : Transform<bool>);
			// Stop if form is off-screen
			MStopOffScreen(stop : bool);

			MIsAnimationPlayed(played : DynamicBehaviour<bool>);
			MDuration(duration : Transform<double>);
			MBezier(bezier : Transform<CubicBezierEasing>);

	MEasing(
		start : () -> void,
		stop : () -> void,
		percent : DynamicBehaviour<double>
	);

	makeMEasing(duration : double, bezier : CubicBezierEasing, deltaTimer : LazyDeltaTimer) -> MEasing;

	MGrabAnimation(manager : MaterialManager, parent : MFocusGroup, content : Tropic) -> Tropic;
	MFadeOutAnimation(manager : MaterialManager, parent : MFocusGroup, content : Tropic) -> Tropic;

	mStepOf5TransitionDuration = \step : int -> easingTransitionDuration * i2d(step) / 5.;

	MAnimatedHide(show : Transform<bool>, content : Material, durationM : Maybe<Transform<double>>) -> Material;
	MAnimatedResizer(width : Transform<double>, height : Transform<double>, style : [MAnimatedResizerStyle]) -> Material; // -1. is for filler
		MAnimatedResizerStyle ::= MAnimationDuration, MResizerMaxWidth, MResizerMaxHeight, MResizerPercent;
			MResizerMaxWidth(width : Transform<double>);
			MResizerMaxHeight(height : Transform<double>);
			MResizerPercent(percent : DynamicBehaviour<double>);

	TSizeAnimation(manager : MaterialManager, parent : MFocusGroup, content : Tropic, style : [MEasingAnimationStyle<Pair<WidthHeight, WidthHeight>>]) -> Tropic;
	MSizeAnimation(content : Material, style : [MEasingAnimationStyle<Pair<WidthHeight, WidthHeight>>]) -> Material;
}

MEasingAnimation(manager : MaterialManager, parent : MFocusGroup, duration : Transform<double>, bezier : Transform<CubicBezierEasing>, trigger : Transform<?>, beforeEach : (?) -> Maybe<??>,
	percent : (??, double) -> void, style : [MEasingAnimationStyle<??>], t : Tropic) -> Tropic {
	animFn = makeMEasingAnimationFn(manager, parent, duration, bezier, trigger, beforeEach, percent, style);
	stopOffScreen = extractStruct(style, MStopOffScreen(false)).stop;

	if (stopOffScreen)
		TConstructRenderable([animFn], t)
	else
		TConstruct([animFn], t)
}

MMEasingAnimation(duration : Transform<double>, bezier : Transform<CubicBezierEasing>, trigger : Transform<?>, beforeEach : (?) -> Maybe<??>,
	percent : (??, double) -> void, style : [MEasingAnimationStyle<??>], t : Material) -> Material {
	MGetManager(\manager -> MGetFocusGroup(\parent -> {
		animFn = makeMEasingAnimationFn(manager, parent, duration, bezier, trigger, beforeEach, percent, style);
		stopOffScreen = extractStruct(style, MStopOffScreen(false)).stop;

		if (stopOffScreen)
			MConstructRenderable([animFn], t)
		else
			MConstruct([animFn], t)
	}))
}

makeMEasingAnimationFn(manager : MaterialManager, parent : MFocusGroup, duration0 : Transform<double>, bezier0 : Transform<CubicBezierEasing>, trigger : Transform<?>, beforeEach : (?) -> Maybe<??>,
	percent0 : (??, double) -> void, style : [MEasingAnimationStyle<??>]) -> () ->  () -> void {
	\ -> {
		duration = extractStruct(style, MDuration(duration0)).duration;
		bezier = extractStruct(style, MBezier(bezier0)).bezier;
		bezierY = ref lerpCurve(0., 1., fgetValue(bezier));
		passed = ref 0.;
		mloop : (??) -> Maybe<??> = extractStruct(style, MLoop(\__ -> None())).beforeLoop;
		autoStart = contains(style, MAutoStart());
		continueOnNone = contains(style, MContinueOnNone());
		context : ref Maybe<??> = ref None();
		forceAnim = contains(style, MForceAnimation());
		delay = extractStruct(style, MDelay(-1.)).delay;
		freeze = extractStruct(style, MFreezeAnimation(const(false))).freeze;
		played = extractStruct(style, MIsAnimationPlayed(make(false))).played;
		percent = \c, p -> {
			if (p == 1.) {
				nextDistinct(played, true);
			} else if (p == 0.) {
				nextDistinct(played, false);
			}
			percent0(c, p);
		};
		animUns = ref nop;
		timerUns = ref nop;
		checkTimerUns = ref nop;

		retriggerFn = ref nop;

		makeCheckTimerFn = \dr -> {
			dispUns(checkTimerUns);

			checkTimerUns := interruptibleTimer(max(floor((dr - ^passed + max(delay, 0.)) * 1000. - 6.), 0), \ -> ^retriggerFn());
		};

		resetPassedFn = \cont -> {
			context := Some(cont);
			passed := 0.;

			makeCheckTimerFn(fgetValue(duration));
			if (delay >= 0.) dispUns(timerUns);
			percent(cont, 0.);
		};

		finishAnimationFn = \ -> {
			if (delay >= 0.) dispUns(timerUns);
			dispUns(animUns);

			maybeApply(^context, \c -> percent(c, 1.));
		};

		retriggerFn := \ -> {
			passed := fgetValue(duration);

			maybeApply(^context, \con ->
				switch (mloop(con)) {
					None(): finishAnimationFn();
					Some(context2): resetPassedFn(context2);
				}
			)
		};

		newPassedFn = \dt -> if (!fgetValue(freeze)) {
			(^passed + dt)
			|> (\newPassed ->
				if (newPassed < fgetValue(duration)) {
					passed := newPassed;

					maybeApply(^context, \con ->
						percent(con, ^bezierY(newPassed / fgetValue(duration)))
					);
				}
			)
		};

		subscribeToDeltaTimerFn = \ -> {
			if (^animUns == nop) {
				manager.manager.deltaTimer.attach();

				animUns :=
					subscribe2(manager.manager.deltaTimer.timer, newPassedFn)
					|> (\f -> \ -> { dispUns(checkTimerUns); f(); manager.manager.deltaTimer.detach(); })
			}
		};

		startingDelayFn = \fn -> {
			if (delay >= 0.) {
				dispUns(timerUns);
				timerUns := interruptibleTimer(floor(delay * 1000.), fn)
			} else
				fn();
		}

		switchTrigger = \tv -> if (!fgetValue(freeze))
			switch (beforeEach(tv)) {
				None(): {
					if (!continueOnNone) {
						if (delay >= 0.) dispUns(timerUns);
						dispUns(animUns);
					}
				}
				Some(cont): {
					startingDelayFn(\ ->
						if (parent.theme.enableAnimations || forceAnim) {
							resetPassedFn(cont);
							subscribeToDeltaTimerFn();
						} else {
							percent(cont, 1.);
						}
					);
				}
			}

		disp =
			if (autoStart)
				makeSubscribe(trigger, switchTrigger)()
			else
				makeSubscribe2(trigger, switchTrigger)();

		dispBezier =
			makeSubscribe2(bezier, \bz ->
				bezierY := lerpCurve(0., 1., bz)
			)();
		dispDuration =
			makeSubscribe2(duration, \dr ->
				if (^animUns != nop) makeCheckTimerFn(dr)
			)();
		dispFreeze =
			makeSubscribe(freeze, \f ->
				if (f) dispUns(checkTimerUns)
				else makeCheckTimerFn(fgetValue(duration))
			)();

		\ -> {
			disp();
			dispBezier();
			dispDuration();
			dispFreeze();
			if (delay >= 0.) dispUns(timerUns);

			if (^animUns != nop) {
				dispUns(animUns);

				maybeApply(^context, \c -> percent(c, 1.));
			}
		}
	}
}

makeMEasing(duration : double, bezier : CubicBezierEasing, deltaTimer : LazyDeltaTimer) -> MEasing {
	bezierY = lerpCurve(0., 1., bezier);
	percent = make(0.);
	uns = ref nop;
	passed = ref 0.;

	fn = \p -> if (^uns != nop) {
		passed := p;

		if (p >= duration) {
			dispUns(uns);
			nextDistinct(percent, 1.);
		} else {
			nextDistinct(percent, bezierY(p / duration))
		}
	};

	MEasing(
		\ -> {
			dispUns(uns);
			passed := 0.;
			nextDistinct(percent, 0.);
			deltaTimer.attach();

			uns := {
				us = subscribe(deltaTimer.timer, \dt -> fn(^passed + dt));
				\ -> {
					us();
					deltaTimer.detach();
				}
			}
		},
		\ -> {
			dispUns(uns);
			nextDistinct(percent, 0.);
		},
		percent
	)
}

MGrabAnimation(manager : MaterialManager, parent : MFocusGroup, content : Tropic) -> Tropic {
	scaleRange = 0.1;
	trigger = make(true);
	scale = make(1.);
	contentWH = makeWH();

	MEasingAnimation(
		manager,
		parent,
		const(easingEnteringDuration),
		fif(trigger, const(easingDecelerationCurve), const(easingAccelerationCurve)),
		trigger,
		\tr ->
			Some(tr),
		\tr, v ->
			nextDistinct(
				scale,
				if (tr)
					lerp(1., 1. + scaleRange, v)
				else
					lerp(1. + scaleRange, 1. + scaleRange * 3. / 4., v)
			),
		[
			MLoop(\tr -> if (tr) Some(!tr) else None()),
			MAutoStart()
		],
		TTranslate(
			fselect2(scale, contentWH, FLift2(\sc, wh -> Point(wh.width * (0.5 - sc / 2.), wh.height * (0.5 - sc / 2.)))),
			TScale(ffactor2(scale), TAttachBox(content, contentWH))
		)
	)
}

MFadeOutAnimation(manager : MaterialManager, parent : MFocusGroup, content : Tropic) -> Tropic {
	transformation = make(1.);

	MEasingAnimation(
		manager,
		parent,
		const(0.5),
		const(easingSharpCurve),
		make(true),
		\tr -> Some(tr),
		\tr, v -> nextDistinct(transformation, v),
		[
			MAutoStart()
		],
		TScale(
			ffactor2(flerp(1., 2., transformation)),
			TAlpha(flerp(0.75, 0., transformation), content)
		)
	)
}

MAnimatedResizer(width : Transform<double>, height : Transform<double>, style : [MAnimatedResizerStyle]) -> Material {
	if (width == const(-1.) && height == const(1.))
		TFillXY()
	else {
		duration = extractStruct(style, MAnimationDuration(const(easingTransitionDuration))).seconds;
		maxWidth = tryExtractStruct(style, MResizerMaxWidth(const(0.)));
		maxHeight = tryExtractStruct(style, MResizerMaxHeight(const(0.)));
		percent = extractStruct(style, MResizerPercent(make(1.))).percent;

		prevWH = ref WidthHeight(fgetValue(width), fgetValue(height));

		MTransformTAcc(\t2a, pi, s, mo -> {
			wd =
				fif(feq(width, -1.), pi.maxX, width)
				|> (\w -> eitherMap(maxWidth, \mw -> fmin(w, mw.width), w));
			hgt =
				fif(feq(height, -1.), pi.maxY, height)
				|> (\h -> eitherMap(maxHeight, \mh -> fmin(h, mh.height), h));

			size = fselect(percent, FLift(\p ->
				WidthHeight(lerp(^prevWH.width, fgetValue(wd), p), lerp(^prevWH.height, fgetValue(hgt), p))
			));

			MMEasingAnimation(
				duration,
				const(easingStandartCurve),
				fwidthheight(wd, hgt),
				\wh -> {
					prevWH := fgetValue(size);
					Some(wh)
				},
				\wh, p -> nextDistinct(percent, p),
				[],
				TSized(size)
			)
			|> (\m -> t2a(m, pi, s, mo))
		})
	}
}

MAnimatedHide(show : Transform<bool>, content : Material, durationM : Maybe<Transform<double>>) -> Material {
	percent = make(b2d(fgetValue(show)));
	duration = either(durationM, const(easingTransitionDuration));

	MMEasingAnimation(
		duration,
		const(easingStandartCurve),
		show,
		\op -> Some(op),
		\op, p -> nextDistinct(percent, if (op) p else 1. - p),
		[],
		MAlpha(percent, content)
	)
	|> (\m -> MTransformTAcc2(\t2a -> {
		b = t2a(m);
		newMetrics =
			TFormMetrics(b.metrics with
				width = fif(show, b.metrics.width, const(0.)),
				height = fif(show, b.metrics.height, const(0.))
			);
		TAcc(b with metrics = newMetrics)
	}))
}

TSizeAnimation(manager : MaterialManager, parent : MFocusGroup, content : Tropic, style : [MEasingAnimationStyle<Pair<WidthHeight, WidthHeight>>]) -> Tropic {
	contentWH = makeWH();
	easedWH = makeWH();

	MEasingAnimation(
		manager,
		parent,
		const(0.3),
		const(easingFastOutSlowIn),
		contentWH,
		\wh ->
			Some(Pair(wh, getValue(easedWH))),
		\wh, v ->
			nextDistinct(
				easedWH,
				WidthHeight(
					wh.second.width + v * (wh.first.width - wh.second.width),
					wh.second.height + v * (wh.first.height - wh.second.height)
				)
			),
		style,
		TFixSize(
			TInspect([ISize(contentWH)], content),
			TSized(easedWH)
		)
	)
}

MSizeAnimation(content : Material, style : [MEasingAnimationStyle<Pair<WidthHeight, WidthHeight>>]) -> Material {
	contentWH = makeWH();
	easedWH = makeWH();

	MMEasingAnimation(
		const(0.3),
		const(easingFastOutSlowIn),
		contentWH,
		\wh ->
			Some(Pair(wh, getValue(easedWH))),
		\wh, v ->
			nextDistinct(
				easedWH,
				WidthHeight(
					wh.second.width + v * (wh.first.width - wh.second.width),
					wh.second.height + v * (wh.first.height - wh.second.height)
				)
			),
		style,
		MCropSize(
			TSized(easedWH),
			MInspect([ISize(contentWH)], content)
		)
	)
}