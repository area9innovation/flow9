import fusion;
import form/form;
import ds/tree;

export {
	// fissome(v : Transform<Maybe>) -> Transform<bool>;
	fifsome(b1 : Transform<Maybe<??>>, then1 : Transform<?>, else1 : Transform<?>)  -> Transform<?>;
	// fifsome2(b1 : Transform<Maybe<??>>, then1 : (??) -> ?, else1 : Transform<?>)  -> Transform<?>;
	ffuse(t : Transform<?>) -> Pair<Behaviour<?>, [() -> () -> void]>;
	applyallsubs(array : [() -> () -> void]) -> [() -> void];

	fselectdelay(b : Transform<?>, fn : (?) -> Pair<int, ??>) -> Transform<??>;

	// Advised dispose helpers
	initUnsM() -> ref Maybe<() -> void>;
	setUnsM(uns : ref Maybe<() -> void>, v : () -> void) -> void;
	dispUnsM(uns : ref Maybe<() -> void>) -> void;
}

fissome(v : Transform<Maybe<?>>) -> Transform<bool> {
	fselect(v, FLift(\v0 -> isSome(v0)))
}

fifsome(b1 : Transform<Maybe<??>>, then1 : Transform<?>, else1 : Transform<?>)  -> Transform<?> {
	fif(fissome(b1), then1, else1)
}

// fifsome2(b1 : Transform<Maybe<??>>, then1 : (??) -> ?, else1 : Transform<?>)  -> Transform<?> {
// 	fsubselect(b1, FLift(\v -> eitherFn(v, \v0 -> const(then1(v0)), \ -> else1)))
// }

ffuse(t : Transform<?>) -> Pair<Behaviour<?>, [() -> () -> void]> {
	switch (t) {
		ConstBehaviour(v): Pair(t, []);
		default: {
			b = make(fgetValue(t));

			Pair(b, [\ -> fconnect(t, b)])
		}
	}
}

applyallsubs(array : [() -> () -> void]) -> [() -> void] {
	map(array, apply0)
}

initUnsM() -> ref Maybe<() -> void> {
	ref None()
}

setUnsM(uns : ref Maybe<() -> void>, v : () -> void) -> void {
	uns := Some(v);
}

dispUnsM(uns : ref Maybe<() -> void>) -> void {
	// a version of dispUns() without functions comparison
	switch (^uns) {
		Some(f): {
			f();
			uns := None();
		}
		None(): {}
	}
}

fselectdelay(b : Transform<?>, fn : (?) -> Pair<int, ??>) -> Transform<??> {
	provider : ref Maybe<DynamicBehaviour<?>> = ref None();
	uns = ref nop;

	fsubselect(b, FLift(\v -> {
		^uns();
		r = fn(v);

		eitherFn(
			^provider,
			\p -> {
				uns :=
					if (r.first > 0) {
						interruptibleTimer(r.first, \ -> nextDistinct(p, r.second));
					} else {
						nextDistinct(p, r.second);
						nop;
					};

				p;
			},
			\ -> {
				provider := Some(make(r.second));
				either(^provider, make(r.second));
			}
		);
	}))
}