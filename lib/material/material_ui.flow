import material/material_dialog;
import material/material_print;
import material/material_snackbar;
import material/internal/material_reorder;
import material/internal/material_moving_point;
import ui/animate/teasing;
import form/realhtmlworkaround;
import net/integration_url_parameter;
import sys/progressivewebtools;

export {
	// A function which constructs a bunch of MRadio that belong to one group
	// first MRadio's index is 0
	MRadios(index : DynamicBehaviour<int>, style : [MCheckableStyle], captions : [Material]) -> [Material];
	MRadiosCombined(index : DynamicBehaviour<int>, style : [MCheckableStyle], params : [MRadioParams], colsCombiner : bool) -> Material;
		MRadioParams(caption : Material, title : Maybe<string>, style : [MCheckableStyle]);

	// Help to create common patterns, when you need to place smth at the top
	// of another material
	MOnTop(base : Material, material : Material) -> Material;
	MRightShift(m : Material) -> Material;

	// Construct material only once when condition is or becomes true.
	MLazyOnCondition(condition : Transform<bool>, fn : () -> Material) -> Material;
	// Lazy sibling of MShow.
	MShowLazy(condition : Transform<bool>, fn : () -> Material) -> Material;
	// Construct lines in list only when they are in visible viewport of scroll. It is expected to be wrapped into MScroll.
	MLazyList(lines : [() -> Material], scrollInspect : TScrollInspectVisible) -> Material;
	// MLazyList with forceLoad - backdoor for loading specific item and items above it without scrolling
	MLazyListExtended(lines : [Pair<() -> Material, Transform<bool>>], scrollInspect : TScrollInspectVisible) -> Material;

	// Helper for standard popup menu
	// topLeft is catched only when isVisible becomes true
	MPopupMenu(topleft : DynamicBehaviour<Point>, isVisible : DynamicBehaviour<bool>, items : [MMenuLine]) -> Material;

	// Helper for lifting element up, above popups and dialogs
	MTopMost(content : Material, style : [MTopMostStyle]) -> Material;
		MTopMostStyle ::= MMovablePosition, MMovableEnabled, MDelay;
			MMovableEnabled(enabled : Transform<bool>);

	// Helper for creating dashed or dotted circle
	MDashedCircle(radius : double, dashNumber : int, color : MColor) -> Material;

	MEditGrid(items : [[MEGItem]], style : [MEGItemStyle]) -> Material;
	MEGItem2M(item : MEGItem, gstyle : [MEGItemStyle]) -> Material;

	makeMRealHTML(key : string, html : MRealHTML) -> Material;

	MRealHTMLCrossDomain(url : string, domain : string, wh : Transform<WidthHeight>, sendChannel : DynamicBehaviour<string>,
		receiveChannel : DynamicBehaviour<string>, targetOrigin : string, key : string, onLoaded : () -> void,
		zoomEnabled : Transform<bool>) -> Material;
	MRealHTMLCrossDomain2(url : string, domain : string, wh : Transform<WidthHeight>, sendChannel : DynamicBehaviour<string>,
		receiveChannel : DynamicBehaviour<string>, targetOrigin : string, key : string, onLoaded : () -> void, onError : (string) -> void,
		zoomEnabled : Transform<bool>, noScroll : bool) -> Material;
	MRealHTMLCrossDomain3(url : string, domain : string, wh : Transform<WidthHeight>, sendChannel : DynamicBehaviour<string>,
		receiveChannel : DynamicBehaviour<string>, targetOrigin : string, key : string, onLoaded : () -> void, onError : (string) -> void,
		zoomEnabled : Transform<bool>, noScroll : bool, style : [FRealHTMLStyle]) -> Material;

	// Changes items on every dragging ends
	MReorderCols(items : DynamicBehaviour<[?]>, materialize : (?) -> Material, style : [MReorderStyle]) -> Material;
	MReorderLines(items : DynamicBehaviour<[?]>, materialize : (?) -> Material,	style : [MReorderStyle]) -> Material;

	// index - position in array, id - unique identifier
	SelectMLines(values : Transform<[?]>, makeMaterialFn : (index :  Transform<int>, id : int, ?) -> Material) -> Material;
	SelectMLinesA(values : Transform<[?]>, makeMaterialFn : (index :  Transform<int>, id : int, ?) -> Material) -> Material;
	SelectMBaselineLines(values : Transform<[?]>, makeMaterialFn : (index :  Transform<int>, id : int, ?) -> Material) -> Material;
	SelectMBaselineLinesA(values : Transform<[?]>, makeMaterialFn : (index :  Transform<int>, id : int, ?) -> Material) -> Material;
	SelectMCols(values : Transform<[?]>, makeMaterialFn : (index :  Transform<int>, id : int, ?) -> Material) -> Material;
	SelectMColsA(values : Transform<[?]>, makeMaterialFn : (index :  Transform<int>, id : int, ?) -> Material) -> Material;
	SelectMBaselineCols(values : Transform<[?]>, makeMaterialFn : (index :  Transform<int>, id : int, ?) -> Material) -> Material;
	SelectMBaselineColsA(values : Transform<[?]>, makeMaterialFn : (index :  Transform<int>, id : int, ?) -> Material) -> Material;
	SelectMGroup(values : Transform<[?]>, makeMaterialFn : (index :  Transform<int>, id : int, ?) -> Material) -> Material;

	MAudioPlayer(filename : string, style : [MAudioPlayerStyle]) -> Material;
		MAudioPlayerStyle ::= MVideoPlayerStyle, MWidth;

	// FVideoTimeRange style disabled
	MMultiAudioPlayer(filenames : [string], mstyle : [MMultiAudioPlayerStyle]) -> Material;
		MMultiAudioPlayerStyle ::= FVideoStyle, IndexInPlaylist, MMultiAudioLength, MMultiAudioTimerange;

		// to switch files (samples) in multiplayer
		IndexInPlaylist(index : DynamicBehaviour<int>);
		// Length of each audio.
		MMultiAudioLength(lengths : [FVideoLength]);
		// Timeranges for each audio
		MMultiAudioTimerange(timeranges : [Maybe<FVideoTimeRange>]);

	// use to place material on top of placeholder over other elements
	MInlinePopup(
		manager : MaterialManager,
		placeholder : Material,
		positionScale : Transform<PositionScale>,
		popup : Material
	) -> Material;

	MInlinePopupPosition(
		manager : MaterialManager,
		placeholder : Material,
		position : Transform<Point>,
		popup : Material
	) -> Material;

	MAddShortcutDialog(manager : MaterialManager, onDismiss : () -> void) -> () -> void;

	MDropDownOrAutoComplete(
		items : [string],
		selected : DynamicBehaviour<int>,
		style : [MDropDownOrAutoCompleteStyle],
	) -> Material;

	MAutoCompleteMultiSelection(
		items : [string],
		selected : DynamicBehaviour<[int]>,
		separator : string
	) -> Material;

	MAutoCompleteMultiSelectionBase(
		items : [string],
		selected : DynamicBehaviour<[int]>,
		separators : [string],
		text : DynamicBehaviour<string>,
		style : [MAutoCompleteStyle],
		state : [MTextInputState]
	) -> Material;

	MSeparatedButton(mainButton : MTextButton, iconButton : MIconButton, menuLines : [MMenuLine], widthByButton : bool) -> Material;

	// MRequiredField, MLabel replace corresponding inner autocomplete styles
	MDropDownOrAutoCompleteStyle ::= MDropDownStyles, MAutoCompleteStyles, MAutoCompleteState, MMultipleSelection,
		MItemsLimit, MRequiredField, MLabel, MShowAnyItem, MCustomAnyItem, MChangeOnClick, MInputInspector,
		MHideBrowseButton, MBrowseDialogStyles, MLazyAutoCompleteDictionary;

		MDropDownStyles(style : [MDropDownStyle]);
		MMultipleSelection(selected : DynamicBehaviour<[int]>, style : [MMultiSelectDropDownStyle]);
		MAutoCompleteStyles(style : [MAutoCompleteStyle]);
		MAutoCompleteState(state : [MTextInputState]);
		MItemsLimit(limit : int);
		MShowAnyItem(); // Adds "Any" option. Doesn`t work with multi-selection.
		MCustomAnyItem(text : string);
		MChangeOnClick(); // Changes selected only when click on autocomplete item.
		// Intended for MAutoComplete case. Can be used as initial autocomplete value.
		MInputInspector(text : DynamicBehaviour<string>);
		MHideBrowseButton(); // Browse button is shown by default in autocomplete mode
		MBrowseDialogStyles(style : [MBrowseDialogStyle]);
			MBrowseDialogStyle ::= MDialogStyle, MDynamicListStyle;
		// We can use MAutoComplete with dynamic dictionary and update the dictionary according to input string
		MLazyAutoCompleteDictionary(dictionaryT : Transform<[string]>, subscribeInput : (Transform<string>) -> () -> void);

	MCollapsingBox(
		content : Material,
		yTrans : Transform<double>,
		expand : Transform<bool>,
		absoluteOffsetMode : bool,
		fade : bool
	) -> Material;

	MFlippingCard(
		front : [MCardBlock],
		back : [MCardBlock],
		style : Transform<[MCardStyle]>,
		state : [MFlippingCardState]
	) -> Material;

		MFlippingCardState ::= MButtonState, MDuration, MTrigger, FAnimationPercent;
			MTrigger(type : MTriggerType);
				MTriggerType ::= MTriggerHover, MTriggerClick;
					MTriggerHover();
					MTriggerClick();

	// If available width is enough, renders text with bigger font, otherwise - with smaller one and starts ellipsing if available width is too small.
	MEllipsisTextTwoFonts(
		font1 : MFontStyle,
		font2 : MFontStyle,
		text : string,
		style : [MEllipsisTextTwoFontsStyle]
	) -> Material;
	MEllipsisTextTwoFontsStyle ::= MEllipsisTextStyle, MEllipsisTextCurrentFont;
		// You can observe the font, but not change it.
		MEllipsisTextCurrentFont(fontB : DynamicBehaviour<MFontStyle>);

	// Helps to define box size and position from the UI. Transparent by default.
	MEditableRectangle(
		position : DynamicBehaviour<Point>,
		size : DynamicBehaviour<WidthHeight>,
		handles : Transform<[MResizableHandle]>,
		style : [MEditableRectangleStyle]
	) -> Material;

		MEditableRectangleStyle ::= MEditableRectangleBackground, MCustomHandle, MResizableOnCreate, MResizableEnabled, MResizableMinMax, MMovableLimits;
			MCustomHandle(fn : (MResizableHandle) -> Material);
			MEditableRectangleBackground(style : Transform<[TGraphicsStyle]>);

	MPopupOpener(button : MaterialButton, popupContent : Material, style : [MPopupOpenerStyle]) -> Material;
		MaterialButton ::= MTextButton, MIconButton;
		MPopupOpenerStyle ::= MPopupAlignment, MOpenMenu;
			MPopupAlignment(type : Transform<MPopupAlignmentType>);
				MPopupAlignmentType ::= MStart, MEnd, MLeft, MRight, MTop, MBottom, MNoAlignment;

	// Construct an HTML stage with the given metrics
	MHTMLStage(wh : Transform<WidthHeight>, constructor : (stage : native) -> () -> void) -> Material;

	MLinesSeparated(values : [Material]) -> Material;
	MColsSeparated(values : [Material]) -> Material;

	MPictureFill(picURL : string, style : [MPictureStyle]) -> Material;
	MPictureFit(picURL : string, style : [MPictureStyle]) -> Material;

	// Tries to fit content into box if the difference between content and box heights is less than threshold, adds a scroll otherwise
	MScrollOrFit(content : Material, box : Material, threshold : double, style : [MScrollStyle]) -> Material;

	// Helper to manipulate element background corners appearance. Look at defaultMaterialShapeMapping to detect what shapeName to use.
	MCustomCorners(m : Material, shapeName : string, corners : MaterialShape) -> Material;

	MTabs(tabs : [MTab], selected : DynamicBehaviour<int>, style : [MTabsStyle]) -> Material {
		MDynamicTabs(const(tabs), selected, style)
		|> MCallstack;
	};

	MDataTable(columns : [MColumnDynamic], rows : [[Material]], style : [MDataTableStyle]) -> Material {
		MDynamicDataTable(columns, const(rows), style)
		|> MCallstack;
	};

	// Use these only if you have no access to MaterialManager of MFocusGroup.
	// Use MTextStyle2CharacterStyle otherwise
	MTextStyle2CharacterStyleRootParent(style : [MParagraphStyle]) -> [CharacterStyle];
	MFontStyle2CharacterStyleRootParent(style : MFontStyle, darkText : bool) -> [BasicCharacterStyle];

	// Intended for preventing iframe from reloading. Not recommended for general use.
	MFullScreenNoReattachments(fs : DynamicBehaviour<bool>, m : Material) -> Material;

	MPositionScaleEnabled(positionScale : DynamicBehaviour<PositionScale>, content : Material, enabled : Transform<bool>) -> Material;
	// Becomes visually highlighted and focused once at the start if something (except input/editor) was in focus just before construction
	// Used for notifying screenreader about changes on the screen
	MInitiallyFocused(mat : Material, buttonTitle : Transform<string>) -> Material;
}

MRadios(index : DynamicBehaviour<int>, style : [MCheckableStyle], captions : [Material]) -> [Material] {
	MRadiosExtended(index, style, map(captions, \cp -> MRadioParams(cp, None(), [])), true)
}

MRadiosCombined(index : DynamicBehaviour<int>, style : [MCheckableStyle], params : [MRadioParams], colsCombiner : bool) -> Material {
	MRadiosExtended(index, style, params, colsCombiner)
	|> (\radios -> if (colsCombiner) MFlexibleGrid(const(radios), [TightWidth()]) else MLinesA(radios))
}

MRadiosExtended(
	index : DynamicBehaviour<int>,
	style : [MCheckableStyle],
	params : [MRadioParams],
	isColsCombiner : bool
) -> [Material] {
	focusedIdx = make(-1);
	focusEnabledIdx = make(0);

	mapi(params, \i, par -> {
		radioStyle = concatA([
			style,
			par.style,
			eitherMap(par.title, \str -> [MButtonTitle(const(str))], []),
		]);

		MArrowNavigationItem(
			i,
			length(params),
			\st -> MRadio(par.caption, i, index, concat(radioStyle, st)),
			focusedIdx,
			focusEnabledIdx,
			\ -> max(0, fgetValue(index)),
			[
				MArrowNavigationSelectItem(\ -> nextDistinct(index, i), true),
				MArrowNavigationResetSelection(\ -> {nextDistinct(index, -1); true}),
				MArrowNavigationDirection(!isColsCombiner)
			]
		)
	})
}

MRightShift(m : Material) -> Material {
	MCols2(TFillX(), m)
}

MOnTop(base : Material, material : Material) -> Material {
	MLet("base", base,
		MGroup2(
			TDisplay("base"),
			MSize(
				TGhost("base"),
				material
			)
		)
	)
}

MLazyOnCondition(condition : Transform<bool>, fn : () -> Material) -> Material {
	if (fgetValue(condition)) {
		fn()
	} else {
		material = make(TEmpty());
		create = ref None();

		MConstruct(
			[\ -> {
				uns = fsubscribe(condition, \c -> if (c) onlyOnce(create, \ -> next(material, fn())));
				\ -> callList(uns)
			}],
			MMutable(material)
		)
	}
}

MShowLazy(condition : Transform<bool>, fn : () -> Material) -> Material {
	MLazyOnCondition(condition, \ -> MShow(condition, fn()))
}

MLazyList(lines : [() -> Material], scrollInspect : TScrollInspectVisible) -> Material {
	MLazyListExtended(map(lines, \line -> Pair(line, const(false))), scrollInspect)
}

MLazyListExtended(lines : [Pair<() -> Material, Transform<bool>>], scrollInspect : TScrollInspectVisible) -> Material {
	height = make(0.0);
	loadState0 : [DynamicBehaviour<bool>] = generate(0, length(lines), \__ -> make(false));
	loadState = mapi(loadState0, \i, loaded -> fOrs(concat([loaded], map(tailFrom(lines, i), \p -> p.second)), true));

	itemHeights : [DynamicBehaviour<double>] = generate(0, length(lines), \__ -> make(0.));

	loadLazy = ref nop;
	loadLazy := \ -> if (getValue(height) <= getValue(scrollInspect.topleft).y + getValue(scrollInspect.widthHeight).height) {
		// scrolled to the end of list
		maybeApply(find(loadState0, \b -> !getValue(b)), // not loaded guy
			\b -> {
				next(b, true); // load him!
				^loadLazy(); // check again
			});
	}

	MConstruct([
		makeSubscribeWithLast(scrollInspect.topleft, \prev, curr -> {
			if (prev.y <= curr.y) ^loadLazy()
		}),
		\ -> subscribe2(scrollInspect.widthHeight, \__ -> ^loadLazy()),
		makeSubscribe2(fstall(fmerge(itemHeights), 0), \__ -> ^loadLazy())
	], TEmpty())
		|> (\m -> arrayPush(mapi(lines, \i, line -> MAttachHeight(MShowLazy(loadState[i], line.first), itemHeights[i])), m))
		|> MLines
		|> (\m -> MAttachHeight(m, height));
}

// this can help to close all currently opened popups to have only latest be visible at a time
mPopupMenuAllVisibility : ref [Pair<int, DynamicBehaviour<bool>>] = ref [];
mPopupMenuAllVisibilityCounter = ref 0;

MPopupMenu(topleft : DynamicBehaviour<Point>, isVisible : DynamicBehaviour<bool>, items : [MMenuLine]) -> Material {
	id = ^mPopupMenuAllVisibilityCounter + 1;
	mPopupMenuAllVisibilityCounter := id;
	m = MTranslate(fselect(isVisible, FLift(\b -> getValue(topleft))), MMenu(TEmpty(), items, [MOpenMenu(isVisible)]));
 	mPopupMenuAllVisibility := arrayPush(^mPopupMenuAllVisibility, Pair(id, isVisible));
 	MConstruct([
 		makeSubscribe(isVisible, \vis -> if (vis) iter(^mPopupMenuAllVisibility, \kv -> if (kv.first != id) nextDistinct(kv.second, false))),
		\-> \-> mPopupMenuAllVisibility := filter(^mPopupMenuAllVisibility, \kv -> kv.first != id),
	], m);

}

MTopMost(content : Material, style : [MTopMostStyle]) -> Material {
	movPosition = extractStruct(style, MMovablePosition(make(zeroPoint))).position;
	movingEnabled = extractStruct(style, MMovableEnabled(const(true))).enabled;
	delay = extractStruct(style, MDelay(0.)).delay * 1000. |> floor;

	dialogBorder = if (mobile) 12. else 24.;

	close : ref DynamicBehaviour<bool> = ref make(false);
	elementClip = ref TEmpty();

	MGetManager(\manager ->
		MMoveClip(
			MComponentGroup(
				MCopySize2(content, \tr, sz ->
					MGroup2(
						MCursor(ArrowCursor(), MTranslate(movPosition, sz |> disableMInteractivesBelow)),
						MMovable(tr, TFillXY(), [MMovablePosition(movPosition), MEnabled(movingEnabled)])
					)
				),
				[MZorder(manager.manager.zorder)]
			),
			None(),
			\el -> elementClip := el
		)
		|> (\m -> MConstruct([
			makeSubscribe2(manager.manager.zorder, \ord -> {
				next(^close, true);
				close := make(false);
				if (ord > 0)
					timer(delay, \ ->
						ShowMDialog(
							manager,
							^close,
							[
								MDialogNonModal(),
								MDialogNoCenter(),
								MDialogNoAnimation(),
								MPassClicks()
							],
							^elementClip
							|> MBorderTop(-dialogBorder)
							|> MBorderLeft(-dialogBorder)
						)
					)
			})
		], m))
	)
}

MDashedCircle(radius : double, dashNumber : int, color : MColor) -> Material {
	stepSize = 180. / i2d(dashNumber);

	TGraphics(
		generate(0, dashNumber, \i ->
			SectorPath(radius, radius, radius, stepSize * i2d(i) * 2., stepSize * (i2d(i) * 2. + 1.), false, false, true)
		)
		|> concatA,
		[MStroke(color)]
	)
}

MEditGrid(items : [[MEGItem]], style : [MEGItemStyle]) -> Material {
	width = extractStruct(style, MWidth(-1.)).width;

	map(items, \it ->
		map(it, \i ->
			MEGItem2M(
				i,
				if (width >= 0. && length(it) > 1)
					replaceStruct(style, MWidth(-1.))
				else
					style
			)
		)
		|> MBaselineCols
		|> (\f ->
			if (width >= 0.)
				MAvailable(f, TFillWY(width))
			else
				f
		)
	)
	|> MLines
}

MEGItem2M(item : MEGItem, gstyle : [MEGItemStyle]) -> Material {
	MGetAll(\__, p, m2t -> MEGItem2T(p, item, gstyle, m2t))
}

makeMRealHTML(key : string, html : MRealHTML) -> Material {
	visValue = make(getValue(isAllRealHTMLDisplayed));

	MConstruct(
		[
			\ -> {
				controlTree := setTree(^controlTree, key, RealHTMLControl(visValue));
				\ -> controlTree := removeFromTree(^controlTree, key);
			}
		],
		MVisible(fmin(isAllRealHTMLDisplayed, visValue), html)
	)
}

MRealHTMLCrossDomain(
	url : string,
	domain : string,
	wh : Transform<WidthHeight>,
	sendChannel : DynamicBehaviour<string>,
	receiveChannel : DynamicBehaviour<string>,
	targetOrigin : string,
	key : string,
	onLoaded : () -> void,
	zoomEnabled : Transform<bool>
) -> Material {
	MRealHTMLCrossDomain2(url, domain, wh, sendChannel, receiveChannel, targetOrigin, key, onLoaded, ignore, zoomEnabled, false);
}

MRealHTMLCrossDomain2(
	url : string,
	domain : string,
	wh : Transform<WidthHeight>,
	sendChannel : DynamicBehaviour<string>,
	receiveChannel : DynamicBehaviour<string>,
	targetOrigin : string,
	key : string,
	onLoaded : () -> void,
	onError : (string) -> void,
	zoomEnabled : Transform<bool>,
	noScroll : bool
) -> Material {
	MRealHTMLCrossDomain3(url, domain, wh, sendChannel, receiveChannel, targetOrigin, key, onLoaded, ignore, zoomEnabled, noScroll, []);
}

MRealHTMLCrossDomain3(
	url : string,
	domain : string,
	wh : Transform<WidthHeight>,
	sendChannel : DynamicBehaviour<string>,
	receiveChannel : DynamicBehaviour<string>,
	targetOrigin : string,
	key : string,
	onLoaded : () -> void,
	onError : (string) -> void,
	zoomEnabled : Transform<bool>,
	noScroll : bool,
	style : [FRealHTMLStyle]
) -> Material {
	sendToJS = ref nop1;
	getHostCall = \hc -> sendToJS := \msg -> hc("postMessage", [msg, targetOrigin]) |> ignore;
	flowCallBack = \args -> {
		if (length(args) == 2 && args[0] == "postMessage")
			next(receiveChannel, args[1]);
		""
	};
	zoomEnabledB = make(fgetValue(zoomEnabled));

	MConstruct(
		[
			\ -> subscribe(sendChannel, \m -> ^sendToJS(m)),
			\ -> fconnect(zoomEnabled, zoomEnabledB)
		],
		makeMRealHTML(
			key,
			MRealHTML(
				url,
				wh,
				concat(style, [
					FlowCallback(flowCallBack),
					PageHostcallSetter(getHostCall),
					OverridePageDomain(domain),
					UpdateCachedContent(true),
					OnPageLoaded(onLoaded),
					OnError(onError),
					ZoomEnabled(zoomEnabledB)
				])
				|> (\st -> ifArrayPush(st, noScroll, NoScroll()))
			)
		)
	)
}

MReorderCols(items : DynamicBehaviour<[?]>, materialize : (?) -> Material, style : [MReorderStyle]) -> Material {
	MReorderTemplate(items, materialize, style, false)
}

MReorderLines(items : DynamicBehaviour<[?]>, materialize : (?) -> Material, style : [MReorderStyle]) -> Material {
	MReorderTemplate(items, materialize, style, true)
}

SelectMLines(values : Transform<[?]>, makeMaterialFn : (index :  Transform<int>, id : int, ?) -> Material) -> Material {
	MGetAll(\manager, parent, m2t ->
		SelectMLines2T(manager, parent, values, \index, id, v, p -> m2t(makeMaterialFn(index, id, v), p))
	)
}

SelectMLinesA(values : Transform<[?]>, makeMaterialFn : (index :  Transform<int>, id : int, ?) -> Material) -> Material {
	MGetAll(\manager, parent, m2t ->
		SelectMLines2AT(manager, parent, values, \index, id, v, p -> m2t(makeMaterialFn(index, id, v), p))
	)
}

SelectMBaselineLines(values : Transform<[?]>, makeMaterialFn : (index :  Transform<int>, id : int, ?) -> Material) -> Material {
	MGetAll(\manager, parent, m2t ->
		SelectMBaselineLines2T(manager, parent, values, \index, id, v, p -> m2t(makeMaterialFn(index, id, v), p))
	)
}

SelectMBaselineLinesA(values : Transform<[?]>, makeMaterialFn : (index :  Transform<int>, id : int, ?) -> Material) -> Material {
	MGetAll(\manager, parent, m2t ->
		SelectMBaselineLines2AT(manager, parent, values, \index, id, v, p -> m2t(makeMaterialFn(index, id, v), p))
	)
}

SelectMCols(values : Transform<[?]>, makeMaterialFn : (index :  Transform<int>, id : int, ?) -> Material) -> Material {
	MGetAll(\manager, parent, m2t ->
		SelectMCols2T(manager, parent, values, \index, id, v, p -> m2t(makeMaterialFn(index, id, v), p))
	)
}

SelectMColsA(values : Transform<[?]>, makeMaterialFn : (index :  Transform<int>, id : int, ?) -> Material) -> Material {
	MGetAll(\manager, parent, m2t ->
		SelectMColsA2T(manager, parent, values, \index, id, v, p -> m2t(makeMaterialFn(index, id, v), p))
	)
}

SelectMBaselineCols(values : Transform<[?]>, makeMaterialFn : (index :  Transform<int>, id : int, ?) -> Material) -> Material {
	MGetAll(\manager, parent, m2t ->
		SelectMBaselineCols2T(manager, parent, values, \index, id, v, p -> m2t(makeMaterialFn(index, id, v), p))
	)
}

SelectMBaselineColsA(values : Transform<[?]>, makeMaterialFn : (index :  Transform<int>, id : int, ?) -> Material) -> Material {
	MGetAll(\manager, parent, m2t ->
		SelectMBaselineColsA2T(manager, parent, values, \index, id, v, p -> m2t(makeMaterialFn(index, id, v), p))
	)
}

SelectMGroup(values : Transform<[?]>, makeMaterialFn : (index :  Transform<int>, id : int, ?) -> Material) -> Material {
	MGetAll(\manager, parent, m2t ->
		SelectMGroup2T(manager, parent, values, \index, id, v, p -> m2t(makeMaterialFn(index, id, v), p))
	)
}

MAudioPlayer(filename : string, style : [MAudioPlayerStyle]) -> Material {
	mWidth = extractStruct(style, MWidth(-1.)).width;
	audioWH = if (mWidth > 0.) make(WidthHeight(mWidth, 0.)) else makeWH();

	videoStyle =
		filtermap(style, \st ->
			switch (st) {
				MVideoPlayerStyle() : {a : Maybe<MVideoPlayerStyle> = Some(st); a};
				default : None()
			}
		);

	MVideoPlayer(
		filename,
		audioWH,
		videoStyle
		|> (\st ->
			eitherMap(
				tryExtractStruct(st, FVideoControls([])),
				\vc -> replaceStruct(st, FVideoControls(removeAllStructs(vc.controls, FullScreenPlayer()))),
				st
			)
		)
		|> (\st ->
			eitherMap(
				tryExtractStruct(st, MPlayerControls([])),
				\pc -> replaceStruct(st, MPlayerControls(removeAllStructs(pc.controls, FullScreenPlayer()))),
				st
			)
		)
		|> (\st -> replaceStruct(st, MPlayerPanelAutoHide(false)))
		|> (\st -> arrayPush(st, FAudio()))
	)
	|> (\audioPlayer ->
		if (mWidth > 0.)
			audioPlayer
		else {
			avW = make(0.);

			MConstruct(
				[
					\ -> fconnectSelect(avW, audioWH, \w -> WidthHeight(w, 0.))
				],
				MAttachAvailableWidth(audioPlayer, avW)
			)
		}
	)
}

SampleStates(
	length : [DynamicBehaviour<double>],
	realLength : [DynamicBehaviour<double>],
	position : [DynamicBehaviour<double>],
	realPosition : [DynamicBehaviour<double>],
	isPlay : [DynamicBehaviour<bool>],
	isReady : [DynamicBehaviour<bool>]
);

MMultiAudioPlayer(filenames : [string], mStyle : [MMultiAudioPlayerStyle]) -> Material {
 	amount = length(filenames);
 	if (amount > 0) {
	  	fvStyle = filtermap(removeAllStructs(mStyle, FVideoTimeRange(const(0.), const(0.))), \st ->
			switch (st) {
				FVideoStyle() : {a : Maybe<FVideoStyle> = Some(st); a};
				default : None()
			}
		);

	  	// FVideoStyle properties
	 	lenEx = extractStruct(fvStyle, FVideoLength(make(0.))).length;
	 	posEx = extractStruct(fvStyle, FVideoPosition(make(0.))).position;
	 	playEx = extractStruct(fvStyle, FVideoPlay(make(false))).play;
	 	loopEx = extractStruct(fvStyle, FVideoLoop(make(false))).loop;
	 	synchrocallEx = extractStruct(fvStyle, SynchroCalls(nop, nop));
		unstoppable = contains(fvStyle, MAudioUnstoppable());
		timeranges = extractStruct(mStyle, MMultiAudioTimerange([])).timeranges;
		hasTimeRanges = exists(timeranges, isSome);

	  	// MMultiAudioPlayerStyle properties
	 	currIndexB = extractStruct(mStyle, IndexInPlaylist(make(0))).index;

	  	// init properties for each audio
	 	states = SampleStates(
			map(filenames, \__ -> make(0.0)),
			map(filenames, \__ -> make(0.0)),
			map(filenames, \__ -> make(0.0)),
			map(filenames, \__ -> make(0.0)),
			map(filenames, \__ -> make(false)),
			map(filenames, \__ -> make(false)),
	 	);

	  	synchrocalls = mapi(filenames, \i, __ ->
	 		SynchroCalls(
	 			// set ready
	 			\-> nextDistinct(states.isReady[i], true),
	 			// play next or stop in the end
	 			\-> {
	 				// reset position (for js)
	 				nextDistinct(states.position[i], 0.);
	 				// if last audio
	 				if (i == amount - 1) {
	 					if (!fgetValue(loopEx)) {
	 						// if not looping
	 						nextDistinct(playEx, false);
	 						synchrocallEx.onStop();
	 					}
	 				}
	 				// next for case with length == 1
	 				next(currIndexB, (i + 1) % amount);
	 			}
	 		)
	 	);

		players = mapi(filenames, \i, url -> eitherFn(
			elementAt(timeranges, i, None()),
			\timerange : FVideoTimeRange -> {
				start = fgetValue(timerange.start);
				timeRangeLength = fgetValue(timerange.end) - start;
				MConstruct(
					[
						\-> fconnectSelect(states.realLength[i], states.length[i],
							\realLength -> if (realLength > 0.0) timeRangeLength else 0.0),
						\-> bidirectionalLink(states.realPosition[i], states.position[i],
							\realPosition -> realPosition - start,
							\position -> position + start
						),
					],
					TVideo(
						url,
						make(WidthHeight(-1., -1.)),		// not to draw
						replaceStructMany(fvStyle,
							[
								FVideoLength(states.realLength[i]),
								FVideoPosition(states.realPosition[i]),
								FVideoPlay(states.isPlay[i]),
								synchrocalls[i],
								FAudio(),
								timerange,
							]
						)
					)
				)
			},
			\-> TVideo(
				url,
				make(WidthHeight(-1., -1.)),		// not to draw
				replaceStructMany(fvStyle,
					[
						FVideoLength(states.length[i]),
						FVideoPosition(states.position[i]),
						FVideoPlay(states.isPlay[i]),
						synchrocalls[i],
						FAudio(),
					]
				)
			)
		));

	  	changeAudioPlaying = \index, isPlay -> {
	 		nextDistinct(states.isPlay[index], isPlay);
	 	}

	  	playerPos = fsubselect(
	 		currIndexB,
	 		FLift(\index ->
	 			faddition(
	 				fsum(subrange(states.length, 0, index)),	// sum of previous lengths
	 				states.position[index]					// current possition
	 			)
	 		)
	 	);
	 	playerPosChange = \pos -> nextDistinct(posEx, pos);
	 	userPosChange = \pos -> {
	 		allLength = fgetValue(fmerge(states.length));
	 		// last index ; length sum of previous audio
	 		lastEnd = foldi(allLength, Pair(-1, 0.), \i, acc, len -> {
	 			newEnd = acc.second + len;
	 			isNext = (acc.first + 1 == i);
	 			if (isNext && newEnd < pos) Pair(i, newEnd)
	 			else acc;
	 		});

	 		currIndex = getValue(currIndexB);
	 		newIndex = lastEnd.first + 1;
	 		if (newIndex != currIndex) {
		  		// reset current player
		 		changeAudioPlaying(currIndex, false);
		 		nextDistinct(states.position[currIndex], 0.);
		 		// start new player
		 		nextDistinct(states.position[newIndex], pos - lastEnd.second);
		 		nextDistinct(currIndexB, newIndex);
	 		} else {
	 			nextDistinct(states.position[newIndex], pos - lastEnd.second);
	 		}
	 	}
		calculateAudioLengthWithTimeRanges = \audioLengths -> {
			dsum(mapi(timeranges, \index, timerange -> eitherMap(
				timerange,
				\t -> fgetValue(t.end) - fgetValue(t.start),
				elementAt(audioLengths, index, 0.0)
			)))
		}

		// rendering (empty)
		MConstruct(
			concat(
				[
					\-> \-> next(currIndexB, 0),
					// when all audios ready
					makeSubscribe(fands(states.isReady, false), \isReady ->
						if (isReady) synchrocallEx.onStart()
					),
					// sum all audio lengths. but refresh total length only after all data is got (all lengths > 0)
					\-> fconnectSelect(fmerge(states.length), lenEx, \lens -> {
							if (hasTimeRanges) calculateAudioLengthWithTimeRanges(lens) 
							else if (all(map(lens, \l -> l > 0.0))) dsum(lens)
							else 0.0
						}),
					// set possition
					\-> fBidirectionalLink(playerPos, posEx, playerPosChange, userPosChange),
					// not make2Subscribe(currIndexB, playEx) due to looping in 1-element array
					makeSubscribeUns(fselectWithLast(currIndexB, FLift2(\old, new -> Pair(old, new))), \oldAndNewIndexes ->
						unpair(oldAndNewIndexes, \oldIndex, newIndex -> {
							if (oldIndex != newIndex) {
								// reset current player before switching
								nextDistinct(states.isPlay[oldIndex], false);
								nextDistinct(states.position[oldIndex], 0.0);
							}
							changeAudioPlaying(newIndex, getValue(playEx));

							[
								fconnect(fdelayUntilNextFrameRendered(states.isPlay[newIndex]), playEx)
							]
						})
					),
					\-> subscribe(playEx, \isPlay -> {
						changeAudioPlaying(getValue(currIndexB), isPlay);
					}),
				],
				filtermapi(extractStruct(mStyle, MMultiAudioLength([])).lengths, \i, length -> {
					elementAtMap(states.length, i,  \l -> Some(\-> fconnect(l, length.length)), None())
				})
			),
			MGroup(players)
		)
		|> (\m -> if (unstoppable) MVisible(make(false), m) else m)
	} else {
		MEmpty();
	}
}

MInlinePopup(
	manager : MaterialManager,
	placeholder : Material,
	positionScale : Transform<PositionScale>,
	popup : Material
) -> Material {
	positionScaleB = make(zeroPositionScale);
	MConstruct(
		[\-> mrender(manager, false, MTranslate(
			fselect2(
				positionScaleB,
				positionScale,
				FLift2(\ps : PositionScale, ps2 : PositionScale -> {
					Point(ps.pos.x + ps2.pos.x * ps.scale.x, ps.pos.y + ps2.pos.y * ps.scale.y)
				})
			),
			MScale(
				fselect2(
					positionScaleB,
					positionScale,
					FLift2(\ps, ps2 -> Factor(ps.scale.x * ps2.scale.x, ps.scale.y * ps2.scale.y))
				),
				popup
			)
		))],
		MPositionScale(positionScaleB, placeholder)
	);
}

MInlinePopupPosition(
	manager : MaterialManager,
	placeholder : Material,
	position : Transform<Point>,
	popup : Material
) -> Material {
	MInlinePopup(manager, placeholder, fselect(position, FLift(\pos -> PositionScale(pos, Point(1.0, 1.0)))), popup);
}

MAddShortcutDialog(manager : MaterialManager, onDismiss : () -> void) -> () -> void {
	if (checkIntegrationShowPwaParameter() && mobile && js && ios() &&
			getKeyValue("progressive_shortcut_dialog_shown", "false") == "false" &&
			!isUrlParameterTrue("progressive_shortcut_dialog_hide")) {

		onClose = ref nop;

		takeSharedKeyValue("progressive_shortcut_dialog_shown", \value -> {
			if (s2b(value)) {
				onDismiss();
				onClose := nop;
			} else {
				closeB = make(false);
				uns = interruptibleDeferUntilNextFrameRendered(\-> {
					showTooltipImageFn = \filename, size, framePos, frameWidth, frameHeight -> {
						imageTooltipVisible = make(false);
						MCenterX(MGroup2(
							MPicture(
								"images/progressive_web/" + filename,
								[
									size,
									OnLoaded(\ -> reverseBehaviour(imageTooltipVisible))
								]
							),
							TTranslate(
								const(framePos),
								TRounded4(4.0, [MStroke(MRed(500)), StrokeWidth(2.0)], TFixed(frameWidth, frameHeight))
							)
							|> (\f -> TVisible(imageTooltipVisible, f))
						));
					}

					ShowMDialog(
						manager,
						closeB,
						[
							MDialogUseFrame(),
							MDialogActions([
								MTextButton(
									_("OK"),
									\ -> {
										onDismiss();
										setKeyValue("progressive_shortcut_dialog_shown", "true");
										storeSharedKeyValue("progressive_shortcut_dialog_shown", "true", nop1);
										nextDistinct(closeB, true);
									},
									[],
									[]
								)
							]),
							MDialogTitle(_("Add to Home Screen")),
							MDialogScroll()
						],
						if (isSafariBrowser()) {
							MLines([
								MParagraph(_("To create a website shortcut on your Home Screen, click on the share button."), []),
								showTooltipImageFn("ios_safari_share_button.png", WidthHeight(60.0, 60.0), Point(0.0, 0.0), 60.0, 60.0),
								MFixedY(20.0),
								MParagraph(_("Then choose \"Add to Home Screen\"."), []),
								MFixedY(12.0),
								showTooltipImageFn("iphone_safari_add_to_home.png", WidthHeight(225.0, 140.0), Point(122.0, 12.0), 80.0, 80.0)
							])
						} else {
							MParagraph(_("Open Safari to create a website shortcut on your Home Screen."), [])
						}
					);
				});
				onClose := \ -> {
					onDismiss();
					uns();
					nextDistinct(closeB, true);
				}
			}
		});
		\ -> {
			^onClose();
			onClose := nop;
		}
	} else {
		onDismiss();
		nop;
	}
}

MDropDownOrAutoComplete(
	items0 : [string],
	selected : DynamicBehaviour<int>,
	style : [MDropDownOrAutoCompleteStyle]
) -> Material {

	limit = extractStruct(style, MItemsLimit(15)).limit;
	isRequired = contains(style, MRequiredField());
	labelM = tryExtractStruct(style, MLabel(""));
	multiSelection = tryExtractStruct(style, MMultipleSelection(make([]), []));
	changeOnlyOnClick = contains(style, MChangeOnClick());
	lazyDictionaryM = tryExtractStruct(style, MLazyAutoCompleteDictionary(const([]), \__ -> nop));

	showAnyItem = contains(style, MShowAnyItem()) && isNone(multiSelection);
	anyItem = extractStruct(style, MCustomAnyItem(_("Any"))).text;
	addAny = \items2 -> concat(if (showAnyItem) [anyItem] else [], items2);
	itemsT0 = eitherFn(
		lazyDictionaryM,
		\lazyDictionary -> lazyDictionary.dictionaryT,
		\ -> {
			eitherFn(
				tryExtractStruct(
					extractStruct(style, MAutoCompleteStyles([])).style,
					MDictionaryDynamic(const([]))
				),
				\st -> st.dictionaries,
				\ -> const(items0)
			);
		}
	);
	itemsT = fselectLift(itemsT0, addAny);

	isError =
		eitherMap(
			multiSelection,
			\ms -> fOr(feq(ms.selected, []), feq(ms.selected, [-1])),
			feq(selected, -1)
		);

	makeMAutoCompleteControl = \manager -> {
		inputInspector = tryExtractStruct(style, MInputInspector(make("")));
		idx2string = \idx -> {
			items = fgetValue(itemsT);
			elementAt(items, idx, if (showAnyItem) items[0] else eitherMap(inputInspector, \inp -> getValue(inp.text), ""));
		}
		trimStr = \s -> trim(s) |> toLowerCase;
		string2idx = \str -> {
			str2 = trimStr(str);
			findiDef(fgetValue(itemsT), \item -> trimStr(item) == str2, -1);
		}

		selectedStrB = make(if (isSome(multiSelection)) "" else idx2string(getValue(selected)));

		autoCompleteStyle0 =
			extractStruct(style, MAutoCompleteStyles([])).style
			|> (\st -> arrayPush(st, MSuggestionsDynamicListMode()))
			|> (\st -> eitherMap(labelM,
				\labelStyle -> replaceStruct(st, MLabel(labelStyle.label)),
				st
			))
			|> (\st -> if (contains(style, MHideBrowseButton())) st else {
				browseDialogStyle = extractStruct(style, MBrowseDialogStyles([MListWidth(-1., 700.)])).style;
				dialogStyle = filtermap(browseDialogStyle, \bdst ->
					switch (bdst) {
						MDialogStyle() : {a : Maybe<MDialogStyle> = Some(bdst); a};
						default : None()
					}
				);
				dynamicListStyle = filtermap(browseDialogStyle, \bdst ->
					switch (bdst) {
						MDynamicListStyle() : {a : Maybe<MDynamicListStyle> = Some(bdst); a};
						default : None()
					}
				);
				onClick = \ -> {
					dialogClose = make(false);

					filterText = make("");
					filterInput = MBaselineCols2A(
						MTooltip(MIcon("filter_list", []), MText("Filter", []), []) |> MBorderEnd(8.),
						MTextInput(filterText, [], [])
					);

					makeFilterItems = \dictionary -> {
						matcher = simpleBuildSentenceMatcher(dictionary);
						fselectLift(filterText, \txt -> {
							itms = if (txt == "") {
								mapi(dictionary, \i, it -> Pair(it, i));
							} else {
								map(
									simpleSentenceMatcher(matcher, txt, intMax, false, false, -1),
									\hit -> {
										index = switch(hit : SentenceMatch) {
											SentenceHit(__, __, __, __) : string2idx(hit.sentence);
											SentenceHitExtended(__, __, __, __, idx) : idx;
										}
										Pair(hit.sentence, index)
									}
								);
							}
							sortCustom(itms, \str -> toLowerCase(str.first), true);
						});
					}
					filteredItems = fsubselect(itemsT, FLift(\dictionary -> {
						makeFilterItems(dictionary);
					}));
					selectedItems = make([]);

					onItemClick = \it -> \ -> {
						idx = it.second;
						eitherFn(
							multiSelection,
							\ms -> {
								if (contains(getValue(ms.selected), idx))
									nextDistinct(ms.selected, filter(getValue(ms.selected), \selIdx -> selIdx != idx))
								else
									dynArrayPush(ms.selected, idx)
							},
							\ -> {
								if (getValue(selected) == idx) {
									nextDistinct(selectedStrB, "");
									nextDistinct(selected, -1);
								} else {
									nextDistinct(selectedStrB, it.first);
									nextDistinct(selected, idx);
								}
								nextDistinct(dialogClose, true);
							}
						)
					}

					list = MDynamicList(
						fmap(filteredItems, \it -> MSingleLine(it.first, [MOnClick(onItemClick(it))])),
						dynamicListStyle,
						[MScrollCropByContent(), MListSelection(const(true), isSome(multiSelection), true, selectedItems)]
					)
					|> (\m -> MConstruct([
						makeSubscribe(filteredItems, \fItems -> {
							selItems = eitherFn(
								multiSelection,
								\ms -> {
									selArr = getValue(ms.selected);
									filtermapi(fItems, \i, it -> if (contains(selArr, it.second)) Some(i) else None());
								},
								\ -> {
									sel = getValue(selected);
									eitherMap(findi(fItems, \it -> sel == it.second), v2a, []);
								}
							);
							nextDistinct(selectedItems, selItems);
						})
					], m));

					listWidth = make(0.);
					dialogContent0 = MLines2A(MAvailableWidth(filterInput, listWidth), MAttachWidth(list, listWidth));
					dialogContent = eitherMap(
						lazyDictionaryM,
						\lazyDictionary -> {
							MConstruct(
								[\ -> lazyDictionary.subscribeInput(filterText)],
								dialogContent0
							);
						},
						dialogContent0
					);

					ShowMDialog(manager, dialogClose, concat(dialogStyle, [
						MDialogUseFrame(),
						MDialogClickOutToClose(),
						MDialogActions([
							MTextButton(_("CLOSE"), \ -> next(dialogClose, true), [], []),
						])
					]), dialogContent)
				};
				concat(st, [MRightCustomButton(
					MIconButton("find_in_page", onClick, [MIconSize(20.), MIconButtonBorder(10.)], [MTooltipText(const(_("Browse Content")))])
				), MShowDropDownArrow(false)])
			})
			|> (\st -> replaceStruct(st, MDictionaryDynamic(itemsT)))
		;
		autoCompleteState0 =
			extractStruct(style, MAutoCompleteState([])).state
			|> (\st ->
				if (isRequired) {
					error = fif(isError, const(Some(Pair("Required field", true))), const(None()));
					replaceStruct(st, MInputError(error, [MRequiredField()]));
				} else
					st
			);

		eitherFn(
			multiSelection,
			\ms ->
				MAutoCompleteMultiSelectionBase(fgetValue(itemsT), ms.selected, [", "], selectedStrB, autoCompleteStyle0, autoCompleteState0),
			\ -> {
				preventSelectedChange = ref false;

				autoCompleteStyle =
					autoCompleteStyle0
					|> (\st -> arrayPush(st, MCompletionFn(\com, isSelected, setWordFn ->
							MGetFocusGroup(\parent -> {
								wrapSetWordFn = \sm -> {
									switch(sm : SentenceMatch) {
										SentenceHit(__, __, __, __) : {
											nextDistinct(selected, string2idx(getValue(selectedStrB)));
											setWordFn(sm);
										}
										SentenceHitExtended(__, __, __, __, idx) : {
											preventSelectedChange := true;
											setWordFn(sm);
											preventSelectedChange := false;
											nextDistinct(selected, idx);
										};
									}
								};
								defaultCompletionFn(manager, parent, st).fn(com, isSelected, wrapSetWordFn)
							})
					)))
				;

				autoCompleteState =
					autoCompleteState0
					|> (\st -> {
						processKeyDown = extractStruct(st, MInputProcessKeyDown(\__ -> true)).fn;
						replaceStruct(st, MInputProcessKeyDown(\ke -> processKeyDown(ke) && ke.keycode != KEY_ENTER))
					});

				MConstruct(
					concat(
						[\ -> bidirectionalLink(selected, selectedStrB,
							\idx -> idx2string(idx),
							\str -> if (changeOnlyOnClick || ^preventSelectedChange) fgetValue(selected) else string2idx(str)
						)],
						eitherMap(
							lazyDictionaryM,
							\lazyDictionary -> [\ -> lazyDictionary.subscribeInput(selectedStrB)],
							[]
						)
					),
					MAutoComplete(selectedStrB, [], autoCompleteStyle, autoCompleteState)
				)
			}
		)
		|> (\m -> eitherMap(
				inputInspector,
				\insp -> MConstruct([makeSubscribe(selectedStrB, \txt -> nextDistinct(insp.text, txt))], m),
				m
			)
		)
	}

	MIfLazy(fOrLazy(const(isSome(lazyDictionaryM)), fgreateri(flength(itemsT0), const(limit))), \longList -> {
		if (longList) {
			MGetManager(makeMAutoCompleteControl)
		} else {
			eitherMap(
				multiSelection,
				\multiSelect -> MMultiSelectDropDown(multiSelect.selected, fgetValue(itemsT), concat(multiSelect.style, [MAddDoneButton(), MAddClearButton()])),
				MConstruct(
					[makeSubscribe(selected, \i -> if (showAnyItem && i == 0) nextDistinct(selected, -1))],
					MDropDown(selected, "", fgetValue(itemsT), extractStruct(style, MDropDownStyles([])).style)
				)
			)
			|> (\m -> eitherMap(labelM,	\labelStyle ->
				MLines2(
					MText(labelStyle.label, [MCaption()]) |> MBorderBottom(4.0),
					m
				),
				m
			))
			|> (\m -> if (isRequired)
				MLines2(
					m,
					MText(_("Required field"), [MErrorColor(), MCaptionSolid()])
					|> (\m2 -> MVisible(isError, m2))
					|> MBorderTop(4.0)
				)
				else m
			)
		}
	});
}

MAutoCompleteMultiSelection(items : [string], selected : DynamicBehaviour<[int]>, separator : string) -> Material {
	MAutoCompleteMultiSelectionBase(items, selected, [separator], make(""), [], [])
}

MAutoCompleteMultiSelectionBase(
	items : [string],
	selected : DynamicBehaviour<[int]>,
	separators : [string],
	text : DynamicBehaviour<string>,
	style : [MAutoCompleteStyle],
	state : [MTextInputState]) -> Material {

	focused = extractStruct(state, MFocused(make(false))).focused;
	currentMatches = make([]);

	idxs2string = \idxs -> concatStrings(map(idxs, \idx -> elementAt(items, idx, "") + elementAt(separators, 0, ", ")));
	trimStr = \s -> trim(s) |> toLowerCase;
	string2idx = \s -> findi(items, \item -> trimStr(item) == trimStr(s));
	string2idxsMulti = \str -> filtermap(strSplit2WithoutLeave(str, separators), string2idx);

	position = extractStruct(state, TTextInputPosition(make(strlen(getValue(text))))).position;

	matchFn = \matcher, input0, maxHits, prefix, exhaustive, pos -> {
		input = trim(takeAfterLastMult(input0, separators, input0));
		if (input == "")
			filtermap(matcher.sentences, \s -> {
				if (s != "") Some(SentenceHit(matcher, s, 0., makeSet()))
				else None()
			})
		else simpleSentenceMatcher(matcher, input, maxHits, prefix, exhaustive, pos);
	}

	lineHeight = make(0.);
	makeChkbox = \sel -> MSelect(lineHeight, \lh -> if (lh == 0.) TEmpty() else MCheckBox(TEmpty(), sel, [MIconSize(lh / 2.)]));

	completionFn = \com, active, __ ->
		MGetManager(\manager -> MGetFocusGroup(\parent -> {
			index = switch(com : SentenceMatch) {
				SentenceHit(__, __, __, __) : string2idx(com.sentence);
				SentenceHitExtended(__, __, __, __, idx) : Some(idx);
			}
			selectedB = make(false);
			isSelected = fselect(selected, FLift(\idxs ->
				eitherMap(
					index,
					\idx -> contains(idxs, idx),
					false
				)
			));

			wrapSetWordFn = \ -> {
				reverseBehaviour(selectedB);
				deferred(\ -> nextDistinct(focused, true))
			}

			MCols2(
				MConstruct([
					\ -> fconnect(isSelected, selectedB),
					makeSubscribe2(selectedB, \sel -> {
						maybeApply(index, \idx ->
							if (sel) {
								if (!contains(getValue(selected), idx)) dynArrayPush(selected, idx)
							}
							else nextDistinct(selected, filter(getValue(selected), \it -> it != idx))
						);
						nextDistinct(position, strlen(getValue(text)));
					})],
					makeChkbox(selectedB)
				),
				MInteractive(
					[KeyDown2(\h, k -> {
						if (!h && active && k.keycode == KEY_ENTER) {
							wrapSetWordFn();
							true
						} else h
					})],
					defaultCompletionFn(manager, parent, style).fn(com, active, \__ -> wrapSetWordFn())
				)
				|> (\m -> MAttachHeight(m, lineHeight))
			)
		}));

	mainCheckboxSelected = make(false);
	mainCheckbox =
		MConstruct(
			[
				\ -> fBidirectionalLink(
					fselect2(fstall(currentMatches, 0), selected, FLift2(\cm, sel ->
						forall(cm, \it : Triple -> contains(sel, it.first))
					)),
					mainCheckboxSelected,
					\sel -> nextDistinct(mainCheckboxSelected, sel),
					\sel -> {
						cm = map(getValue(currentMatches), \m -> m.first);
						nextDistinct(selected,
							if (sel) uniq(concat(fgetValue(selected), cm))
							else subtractA(fgetValue(selected), cm)
						)
					}
				)
			],
			makeChkbox(mainCheckboxSelected)
		)
		|> MBorderTopBottom(-8.);

	MAutoComplete(text, items, concat(style, [
		MStartCustomButtonT(
			TEmpty(),
			mainCheckbox,
			lineHeight,
			false
		),
		MSentenceMatcher(simpleBuildSentenceMatcher, matchFn),
		MCompletionFn(completionFn),
	])
	|> (\st -> {
		external = tryExtractStruct(st, MCurrentMatches(nop1));
		replaceStruct(st, MCurrentMatches(\cm -> {
			nextDistinct(currentMatches, cm);
			maybeApply(external, \ext -> ext.fn(cm));
		}));
	}),
	concat(state, [
		MFocused(focused),
		MPositionOnFocus(\c, p -> strlen(c)),
		TTextInputPosition(position),
		TTextInputSelection(position),
		MInputProcessKeyDown(\k -> k.keycode != KEY_ENTER)
	]))
	|> (\m -> MConstruct([\ -> bidirectionalLink(selected, text, idxs2string, string2idxsMulti)], m))
}

MSeparatedButton(mainButton : MTextButton, iconButton : MIconButton, menuLines : [MMenuLine], widthByButton : bool) -> Material {
	posScale = make(zeroPositionScale);
	buttonWH = makeWH();

	MGetManager(\manager -> {
		iconStyle = eitherMap(tryExtractMColor(manager, iconButton.style), \__ -> iconButton.style, arrayPush(iconButton.style, MPrimaryColor()));

		MCopySize2(MTextButton(mainButton with style = arrayPush(mainButton.style, MButtonPaddings(12.0, 12.0, 12.0, 12.0))), \sz, tr ->
			MColsA([
				tr,
				TRectangle([MThemeFill(manager, MPrimaryColor())], TGroup2(THeight(sz), TFixed(1., 0.))),

				MIconButton(iconButton with
					style = iconStyle,
					state = concat(iconButton.state, [MRippleShape("MTextButton"), MRippleType(const(MRippleFill()))])
				)
				|> (\m -> MMenu(
					m,
					menuLines,
					concatA([
						[MBelowButton(), MMenuCustomPopup(Some(buttonWH), Some(posScale))],
						if (widthByButton) [MWidthByButton()] else []
					])
				))
				|> (\m -> MBorderA(-4., -4., -3., -4., m))
			])
		)
		|> (\m -> MPositionScale(posScale, m))
		|> (\m -> MAttachBox(m, buttonWH))
		|> (\m -> MFrame(0.0, 4.0, [MThemeStroke(manager, MPrimaryColor()), StrokeWidth(1.0)], m))
		|> (\m -> MBorder4(1., m))
	})
}

MCollapsingBox(content : Material, yTrans : Transform<double>, expand : Transform<bool>, absoluteOffsetMode : bool, fade : bool) -> Material {
	MGetAll(\manager, p, m2t ->
		TCollapsingBox(manager, p, m2t(content, p), yTrans, expand, None(), None(), absoluteOffsetMode, fade)
	)
}

MFlippingCard(
	front : [MCardBlock],
	back : [MCardBlock],
	style : Transform<[MCardStyle]>,
	state : [MFlippingCardState],
) -> Material {
	duration = extractStruct(state, MDuration(const(0.4))).duration;
	percent = extractStruct(state, FAnimationPercent(make(0.0))).percent;
	triggerType = extractStruct(state, MTrigger(MTriggerHover())).type;
	isHoverTrigger = isSameStructType(triggerType, MTriggerHover());
	buttonTitle = extractStruct(state, MButtonTitle(const(""))).title;
	isBackSide = make(false);
	flipped = make(false);

	keyframes = [
		FAnimationKeyframe([FScaleValue(Factor(1., 1.))]),
		FAnimationKeyframe([FScaleValue(Factor(1.05, 1.05))]),
		FAnimationKeyframe([FScaleValue(Factor(0.5, 1.05))]),
		FAnimationKeyframe([FScaleValue(Factor(0., 1.05))]),
		FAnimationKeyframe([FScaleValue(Factor(0.5, 1.05))]),
		FAnimationKeyframe([FScaleValue(Factor(1.05, 1.05))]),
		FAnimationKeyframe([FScaleValue(Factor(1., 1.))]),
	];

	MComponent([
		MHighlightOnFocus(const(true)),
		MButtonTitle(fselect2Lift(buttonTitle, isBackSide, \ttl, isBack -> ttl + ". Flipping card (" + (if (isBack) "back" else "front") + " side)")),
		MOnClick(\ -> {
			reverseBehaviour(flipped);
			maybeApply(tryExtractStruct(state, MOnClick(nop)), \onClick -> onClick.click());
		})
	], \foc -> {
		trigger = if (isHoverTrigger) fstall(foc.hover, 0) else flipped;
		MDynamicCard(
			fif(
				isBackSide,
				const(back),
				const(front)
			),
			style,
			extractMButtonState(state)
			|> (\st ->
				if (cpp) replaceStruct(st, MElevation(zero))
				else replaceStruct(st, extractStruct(st, MElevation(fif(fOr(foc.hover, foc.focused), const(6.), const(2.)))))
			)
			|> (\st -> removeAllStructs(st, MOnClick(nop)))
		)
		|> (\m -> MAnimation(m, fif(trigger, const(keyframes), const([])), [FAnimationDuration(duration), FAnimationPercent(percent), FAnimationOnFinish(\ -> nextDistinct(percent, 0.0))]))
		|> (\m -> MOrigin(const(Factor(0.5, 0.5)), m))
		|> (\m -> MOrigin(const(Factor(-0.5, -0.5)), m))

		|> (\m -> MOrigin(const(Factor(0.5, 0.5)), m))
		|> (\m -> MAnimation(m, fif(fselectWithLast(trigger, FLift2(\old, new -> (old == new) || new)), const([]), const(keyframes)), [FAnimationDuration(duration), FAnimationPercent(percent), FAnimationOnFinish(\ -> nextDistinct(percent, 0.0))]))
		|> (\m -> MOrigin(const(Factor(-0.5, -0.5)), m))
		|> (\m -> MConstruct([\ -> fconnect(fequal(trigger, fOr(feq(percent, 0.), fgreater(percent, const(0.5)))), isBackSide)], m))
	})
}

MEllipsisTextTwoFonts(
	font1 : MFontStyle,
	font2 : MFontStyle,
	text : string,
	style : [MEllipsisTextTwoFontsStyle]
) -> Material {
	avWidth = make(0.);
	maxWidth = make(0.);
	currentFontB = extractStruct(style, MEllipsisTextCurrentFont(make(font1))).fontB;

	ellipsisStyle = filtermap(style, \s -> switch (s : MEllipsisTextTwoFontsStyle) {
		MEllipsisTextStyle() : Some(s);
		MEllipsisTextCurrentFont(__) : None();
	});

	MGetFocusGroup(\parent -> {
		size1 = MFontStyle2MFont(parent, font1).size;
		size2 = MFontStyle2MFont(parent, font2).size;

		bigger = if (size1 > size2) font1 else font2;
		smaller = if (size1 > size2) font2 else font1;

		MIfLazy(fless(avWidth, maxWidth), \isSmall -> {
			currentFont = if (isSmall) smaller else bigger;
			nextDistinct(currentFontB, currentFont);
			MEllipsisText(
				text,
				concat(
					ellipsisStyle,
					[
						currentFont,
						MEllipsisTextGetFullWidth(\fw -> deferred(\ -> nextDistinct(maxWidth, max(getValue(maxWidth), fw))))
					]
				)
			)
		})
	})
	|> (\m -> MAttachAvailableWidth(m, avWidth))
}

MEditableRectangle(
	position : DynamicBehaviour<Point>,
	size : DynamicBehaviour<WidthHeight>,
	handles : Transform<[MResizableHandle]>,
	style : [MEditableRectangleStyle]
) -> Material {
	handleSize = 24.;
	mousePosition0 = makePoint();
	avBox = makeWH();
	isHovered = make(false);
	defHandleFn = \__ -> MVisible(isHovered, MCursor(FingerCursor(), movingMIcon("casino", const(handleSize), MYellowA, make(false))));
	handleFn = extractStruct(style, MCustomHandle(defHandleFn)).fn;
	backgroundStyle = extractStruct(style, MEditableRectangleBackground(const(interactiveRectangleStyle))).style;
	onCreate = extractStruct(style, MResizableOnCreate(TSized(cloneBehaviour(size))));
	minMax = extractStruct(style, MResizableMinMax(TEmpty(), TFillXY()));
	resizableEnabled = extractStruct(style, MResizableEnabled(const(true), const(true)));
	limits = extractStruct(style, MMovableLimits(None(), None(), None(), None()));

	mousePosition =
		fselect2Lift(mousePosition0, avBox, \mp, av ->
			Point(
				max(0., min(av.width, mp.x)),
				max(0., min(av.height, mp.y))
			)
		);

	MMovable(
		MResizable(
			MFrameT(zero, zero, backgroundStyle, TFillXY()),
			[
				onCreate,
				resizableEnabled,
				MResizableMinMax(
					MGroup2(minMax.min, TSizedWidthHeight(
						fif(resizableEnabled.x, const(2.* handleSize), zero),
						fif(resizableEnabled.y, const(2.* handleSize), zero)
					)),
					minMax.max
				),
				MMultipleHandlesMode(handles, handleFn, position, mousePosition)
			]
		)
		|> (\m -> MComponent([THovering(isHovered), MPassClicks(), MFocusEnabled(const(false)), MCursorShape(const(ArrowCursor()))], \__ -> m))
		|> (\m -> MAttachBox(m, size)),
		TFillXY(),
		[
			MMovablePosition(position),
			MMousePosition(mousePosition0),
			limits
		]
	)
	|> (\m -> MAttachAvailable(m, avBox))
}

MPopupOpener(button : MaterialButton, popupContent : Material, style : [MPopupOpenerStyle]) -> Material {
	popupOpened = extractStruct(style, MOpenMenu(make(false))).opened;
	posScale = make(zeroPositionScale);
	buttonWH = makeWH();
	popupW = make(0.);
	popupH = make(0.);
	border = 16.;

	mat = switch (button) {
		MIconButton(__, onClick, __, __):
			MIconButton(button with onClick = \ -> {
				reverseBehaviour(popupOpened);
				onClick()
			});
		MTextButton(__, onClick, __, __):
			MTextButton(button with onClick = \ -> {
				reverseBehaviour(popupOpened);
				onClick()
			})
	}
	MGetManager(\manager -> MGetFocusGroup(\p -> MGetMaterial2Tropic(\m2t -> {
		alignment = extractStruct(style, MPopupAlignment(const(MNoAlignment()))).type;
		leftOffset = fnegate(popupW);
		rightOffset = fwidth(buttonWH);
		offset = fsubselect(alignment, FLift(\align -> switch (align) {
			MTop() : fwh(zero, fnegate(faddition(popupH, const(2. * border))));
			MBottom() : fwh(zero, fheight(buttonWH));
			MLeft() : fwh(leftOffset, zero);
			MRight() : fwh(rightOffset, zero);
			MStart() : fwh(if (p.rtl) rightOffset else leftOffset, zero);
			MEnd() : fwh(if (p.rtl) leftOffset else rightOffset, zero);
			default : const(WidthHeight(0., 0.))
		}));

		MConstruct([
			makeSubscribe2(popupOpened, \op ->
				if (op) RenderMPopup(manager, p, MPopup(
						[[popupContent]],
						posScale,
						[
							RMBorders(border),
							MOpenMenu(popupOpened),
							MFocusOnPrevious(true),
							RMOffset(fstall(fselectLift(offset, \o -> Pair(o, 0.)), 0)),
							RMCurrentWidth(popupW),
							RMCurrentHeight(popupH)
						]
					),
					m2t
				)
			)
		], MPositionScale(posScale, MAttachBox(mat, buttonWH)))
		|> (\m -> MCopySize(m, \sz ->
			MInteractive([MouseUp(\__ -> {nextDistinct(popupOpened, false); false;})], sz),
			false
		))
	})))
}

MHTMLStage(wh : Transform<WidthHeight>, constructor : (stage : native) -> () -> void) -> Material {
	MComponentGroup(
		THTMLStage(wh, constructor),
		[MFocusName("MHTMLStage")]
	)
}

MLinesSeparated(values : [Material]) -> Material {
	widthArray = map(values, \__ -> make(0.0));
	maxWidth = fmaxA(widthArray, 0.0);

	MLines(interleave(
		mapi(values, \i, v -> {
			width = widthArray[i];
			MAttachWidth(v, width)
		}),
		MAvailableWidth(MSeparator(true), maxWidth)
	))
}

MColsSeparated(values : [Material]) -> Material {
	heightArray = map(values, \__ -> make(0.0));
	maxHeight = fmaxA(heightArray, 0.0);

	MCols(interleave(
		mapi(values, \i, v -> {
			height = heightArray[i];
			MAttachHeight(v, height)
		}),
		MAvailableHeight(MSeparator(false), maxHeight)
	))
}

MPictureTweak(picURL : string, style : [MPictureStyle]) {
	showLoading = extractStruct(style, MPictureShowLoading(true)).show;
	customLoading = tryExtractStruct(style, MPictureCustomLoading(TEmpty()));
	tstyle = MPictureStyle2TPictureStyle(style);

	if (showLoading || isSome(customLoading)) {
		onPicLoaded = extractStruct(style, OnLoaded(nop)).fn;
		picLoading = make(false);
		uns = interruptibleTimer(100, \ -> next(picLoading, true));

		picSize =
			eitherMap(
				tryExtractStruct(tstyle, TPictureSize(const(WidthHeight(0., 0.)))),
				\ds -> Some(ds.size),
				maybeMap(
					tryExtractStruct(tstyle, WidthHeight(-1.0, -1.0)),
					\cs -> const(cs)
				)
			);

		pstyle = replaceStruct(tstyle, OnLoaded(\ -> {uns(); onPicLoaded(); nextDistinct(picLoading, false);}));

		MGroup2(
			TPicture(picURL, pstyle),
			MShow(
				picLoading,
				eitherMap(
					customLoading,
					\cl -> cl.loading,
					MProgressCircle([])
					|> (\f -> MAlpha(const(0.72), f))
				)
				|> MCenter
			)
		)
	} else {
		TPicture(picURL, tstyle)
	}
}

MPictureFill(picURL : string, style : [MPictureStyle]) {
	MTweak(
		[
			TFillZoom(true)
		],
		MPictureTweak(picURL, style),
		TFillXY()
	)
}

MPictureFit(picURL : string, style : [MPictureStyle]) {
	MTweak(
		[
			TFitZoom(true, false)
		],
		MPictureTweak(picURL, style),
		TFillXY()
	)
}

MScrollOrFit(content : Material, box : Material, threshold : double, style : [MScrollStyle]) -> Material {
	contentHeight = make(0.);
	avBox = makeWH();
	availableHeight = fheight(avBox);
	scale = fselect2(contentHeight, availableHeight, FLift2(\ch, ah ->
		if (ah == 0. || ch - ah > threshold) 1. else min(1., ah / ch)
	));

	scrollEnabled = fgreater(fsubtract(contentHeight, availableHeight), const(threshold));

	content
	|> (\m -> MAttachHeight(m, contentHeight))
	|> (\m -> MAvailableWidth(m, fwidth(avBox)))
	|> (\m -> MScale(ffactor2(scale), m))
	|> (\m -> MScroll(
		m,
		MAttachBox(box, avBox),
		concat(
			style,
			[
				MScrollCropByContent(),
				TScrollEnabled(scrollEnabled),
				MScrollCropEnabled(scrollEnabled)
			]
		)
	))
}

MCustomCorners(m : Material, shapeName : string, corners : MaterialShape) -> Material {
	MComponentGroup(m, [MUpdateShapeCorners(shapeName, corners)])
}

MTextStyle2CharacterStyleRootParent(style : [MParagraphStyle]) -> [CharacterStyle] {
	MTextStyle2CharacterStyle(createRootMFocusGroup([]), style)
}

MFontStyle2CharacterStyleRootParent(style : MFontStyle, darkText : bool) -> [BasicCharacterStyle] {
	MFontStyle2CharacterStyle(createRootMFocusGroup([]), style, darkText)
}

MGetAll(fn : (MaterialManager, MFocusGroup, (Material, MFocusGroup) -> Tropic) -> Tropic) -> Material {
	MGetManager(\manager -> MGetFocusGroup(\parent -> MGetMaterial2Tropic(\m2t ->
		fn(manager, parent, m2t)
	)))
}

MFullScreenNoReattachments(fs : DynamicBehaviour<bool>, m : Material) -> Material {
	MGetManager(\manager -> MTransformTAcc(\m2a, parent, sheet, metricsOnly -> {
		wh0 = makeWH();
		factor = ffactor2(fmultiply(accessibilityZoom, const(screenDensity)));

		// TScale from trender2 is ignored in fullscreen mode, so let`s scale content here
		whF = fselect2(wh0, factor, FLift2(\stage, f -> WidthHeight(stage.width / f.x, stage.height / f.y)));
		wh = fif(fs, whF, wh0);

		b = m2a(
				m,
				TParentInfo(
					fif(fs, fwidth(wh), parent.maxX),
					fif(fs, fheight(wh), parent.maxY),
					parent.environment,
					fif(fs, fselect(parent.transformMatrix, FLift(\tm -> TransformMatrix(tm with tx = 0., ty = 0.))), parent.transformMatrix)
				),
				sheet,
				metricsOnly
			);

		TAcc(b with form =
			FFullScreen2(fs, wh0,
				FAccess(
					[AccessRole("group")],
					FGroup2(
						FMutable(
							fselect2Lift(fs, wh, \show, sz -> if (show) FRectangle(sz.width, sz.height, [Fill(white)]) else FEmpty())
						),
						FScale(
							fif(fs, ffactorX(factor), const(1.)),
							fif(fs, ffactorY(factor), const(1.)),
							b.form
						),
						false
					)
				),
				false
			)
			|> (\f -> FConstructor(f, makeSubscribe(fs, \fss ->
				if (fss) nextDistinct(fullScreenNoReattachmentsModeZorder, getValue(manager.manager.zorder))
				else deferUntilNextFrameRendered(\ -> nextDistinct(fullScreenNoReattachmentsModeZorder, -1))
			)))
		);
	}));
}

MPositionScaleEnabled(positionScale : DynamicBehaviour<PositionScale>, content : Material, enabled : Transform<bool>) -> Material {
	MCopySize(content, \tr -> MShowLazy(enabled, \ -> MPositionScale(positionScale, tr)), true)
}

MInitiallyFocused(mat : Material, buttonTitle : Transform<string>) -> Material {
	focused = make(false);
	framePadding = 2.;
	MComponent([
		MFocused(focused),
		MButtonTitle(buttonTitle),
		AccessRole("none"),
		TagName("div"),
		ClassName("flow_focusable"),
		MHighlightOnFocus(const(true)),
		MCursorShape(const(DefaultCursor()))
	], \__ -> MBorder4(framePadding, MAccess([FAccessHidden()], mat)))
	|> (\m -> MBorder4(-framePadding, m))
	|> (\m -> MGetManager(\manager -> MConstruct([\ -> {
			if (eitherMap(fgetValue(manager.latelyFocused), \lf -> !contains(["MTextInput", "MAutoComplete", "MWEditor", "RhapsodeTemporarilyFocused"], lf.name), false)) {
				deferUntilNextFrameRendered(\ -> nextDistinct(focused, true));
			}
			nop
		}], m)))
}