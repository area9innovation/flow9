import material/material;
import material/internal/material_theme;
import material/internal/tropic_size_util;

export {
	// Bunch of helpers to inspect sizes. Consider using MInspect also.

	MAttachBox(m : Material, box : DynamicBehaviour<WidthHeight>) -> Material;
	MAttachWidth(m : Material, width : DynamicBehaviour<double>) -> Material;
	MAttachHeight(m : Material, height : DynamicBehaviour<double>) -> Material;
	MAttachWidthHeight(m : Material, width : DynamicBehaviour<double>, height : DynamicBehaviour<double>) -> Material;

	MAttachAvailable(m : Material, box : DynamicBehaviour<WidthHeight>) -> Material;
	MAttachAvailableWidth(m : Material, width : DynamicBehaviour<double>) -> Material;
	MAttachAvailableHeight(m : Material, height : DynamicBehaviour<double>) -> Material;
	MAttachAvailableWidthHeight(m : Material, width : DynamicBehaviour<double>, height : DynamicBehaviour<double>) -> Material;

	// Inspects m, draws content
	MAttachBox2(m : Material, box : DynamicBehaviour<WidthHeight>, content : Material) -> Material;
	MAttachWidth2(m : Material, width : DynamicBehaviour<double>, content : Material) -> Material;
	MAttachHeight2(m : Material, height : DynamicBehaviour<double>, content : Material) -> Material;

	// Helpers to inspect metrics from the corresponding item (dominant) and set available for the different one (subdominant)
	// It also prevents affecting dominant item by subdominant one
	// Visit test_first_second_helpers.flow testcase for more info
	MAttachToFirst(first : Material, second : Material) -> Material;
	MAttachToSecond(first : Material, second : Material) -> Material;
	
	MLinesWidthByFirst(first : Material, second : Material) -> Material;
	MLinesAWidthByFirst(first : Material, second : Material) -> Material;
	MLinesWidthBySecond(first : Material, second : Material) -> Material;
	MLinesAWidthBySecond(first : Material, second : Material) -> Material;

	MColsHeightByFirst(first : Material, second : Material) -> Material;
	MColsAHeightByFirst(first : Material, second : Material) -> Material;
	MColsHeightBySecond(first : Material, second : Material) -> Material;
	MColsAHeightBySecond(first : Material, second : Material) -> Material;

	// Special cases to inspect
	MAttachBoxThrottle(m : Material, box : DynamicBehaviour<WidthHeight>, maxDelta : int) -> Material;

	MThrottleMetrics(m : Material, maxDelta : int) -> Material;

	// Helpers to set available for only width, only height, or both
	MAvailableWidth(m : Material, available : Transform<double>) -> Material;
	MAvailableHeight(m : Material, available : Transform<double>) -> Material;
	MAvailableWidthHeight(m : Material, width : Transform<double>, height : Transform<double>) -> Material;

	// MAlign helpers
	// *Start/End takes width of the content when aligned left
	// *StartFill/EndFill takes available width when aligned left

	MAlignStart(m : Material) -> Material; // Align left if LTR, align right if RTL
	MAlignEnd(m : Material) -> Material;   // Align right if LTR, align left if RTL
	MAlignStartFill(m : Material) -> Material;
	MAlignEndFill(m : Material) -> Material;
	MAlignLeft(m : Material) -> Material;
	MAlignTop(m : Material) -> Material;
	MAlignRight(m : Material) -> Material;
	MAlignBottom(m : Material) -> Material;

	MAlignTopLeft(m : Material) -> Material;
	MAlignTopCenter(m : Material) -> Material;
	MAlignTopRight(m : Material) -> Material;
	MAlignCenterLeft(m : Material) -> Material;
	MAlignCenterRight(m : Material) -> Material;
	MAlignBottomLeft(m : Material) -> Material;
	MAlignBottomCenter(m : Material) -> Material;
	MAlignBottomRight(m : Material) -> Material;

	MAlignTopStart(m : Material) -> Material;
	MAlignTopEnd(m : Material) -> Material;
	MAlignCenterStart(m : Material) -> Material;
	MAlignCenterEnd(m : Material) -> Material;
	MAlignBottomStart(m : Material) -> Material;
	MAlignBottomEnd(m : Material) -> Material;

	MAlignTopStartFill(m : Material) -> Material;
	MAlignTopEndFill(m : Material) -> Material;
	MAlignCenterStartFill(m : Material) -> Material;
	MAlignCenterEndFill(m : Material) -> Material;
	MAlignBottomStartFill(m : Material) -> Material;
	MAlignBottomEndFill(m : Material) -> Material;

	// MBorder helpers

	// MBorder with equal borders on all 4 sides
	MBorder4(border : double, m : Material) -> Material;
	MBorder2(horizontalBorder : double, verticalBorder : double, m : Material) -> Material;

	MBorderTop(border : double) -> (Material) -> Material;
	MBorderBottom(border : double) -> (Material) -> Material;
	MBorderLeft(border : double) -> (Material) -> Material;
	MBorderRight(border : double) -> (Material) -> Material;
	MBorderStart(border : double) -> (Material) -> Material;
	MBorderEnd(border : double) -> (Material) -> Material;

	MBorderTopBottom(border : double) -> (Material) -> Material;
	MBorderLeftRight(border : double) -> (Material) -> Material;

	// Dynamic version of MBorder
	MBorderT(start : Transform<double>, top : Transform<double>, end : Transform<double>, bottom : Transform<double>, m : Material) -> Material;
	MBorderTA(start : Transform<double>, top : Transform<double>, end : Transform<double>, bottom : Transform<double>, m : Material) -> Material;

	// Dynamic version of MBorder4
	MBorder4T(border : Transform<double>, m : Material) -> Material;

	// MDebug helpers

	// MDebug that shows metrics on top of the material
	MDebugMetrics(c : int, m : Material) -> Material;
	MDebugPositionScale(c : int, m : Material) -> Material;
	MDebugConstruct(tag : string, m : Material) -> Material;

	MDebugRed(m : Material) -> Material { MDebug(MColor2int(MRed(500)), m); };
	MDebugGreen(m : Material) -> Material { MDebug(MColor2int(MGreen(500)), m); };
	MDebugBlue(m : Material) -> Material { MDebug(MColor2int(MBlue(500)), m); };
	MDebugPurple(m : Material) -> Material { MDebug(MColor2int(MPurple(500)), m); };

	MDebugMetricsRed(m : Material) -> Material { MDebugMetrics(MColor2int(MRed(500)), m); };
	MDebugMetricsGreen(m : Material) -> Material { MDebugMetrics(MColor2int(MGreen(500)), m); };
	MDebugMetricsBlue(m : Material) -> Material { MDebugMetrics(MColor2int(MBlue(500)), m); };
	MDebugMetricsPurple(m : Material) -> Material { MDebugMetrics(MColor2int(MPurple(500)), m); };

	MDebugInteractive(m : Material) -> Material;

	// MGroup with zero metrics
	// Useful inside complicated components with lots of layers, metrics of which aren't used
	MGroupWithoutMetrics(g : [Material]) -> Material;
	MGroup2WithoutMetrics(g1 : Material, g2 : Material) -> Material {MGroupWithoutMetrics([g1, g2])};
	// MGroup that has metrics of the first Material. Doesn't affect visual representation.
	MGroupSameMetrics(g : [Material]) -> Material;
	MGroup2SameMetrics(g1 : Material, g2 : Material) -> Material {MGroupSameMetrics([g1, g2])};

	MFixed(x : double, y : double) -> Material {TFixed(x, y)};
	MFixedX(x : double) -> Material {TFixed(x, 0.)};
	MFixedY(y : double) -> Material {TFixed(0., y)};

	MFillXY() -> Material {TFillXY()};
	MFillX() -> Material {TFillX()};
	MFillY() -> Material {TFillY()};
	MFillXH(h: double) -> Material {TFillXH(h)};
	MFillWY(w: double) -> Material {TFillWY(w)};

	MSelect2(v1 : Transform<?>, v2 : Transform<??>, fn : (?, ??) -> Material) -> Material;
	MSelect3(v1 : Transform<?>, v2 : Transform<??>, v3 : Transform<???>, fn : (?, ??, ???) -> Material) -> Material;
	MSelect4(v1 : Transform<?>, v2 : Transform<??>, v3 : Transform<???>, v4 : Transform<????>, fn : (?, ??, ???, ????) -> Material) -> Material;
	MSelect5(v1 : Transform<?>, v2 : Transform<??>, v3 : Transform<???>, v4 : Transform<????>, v5 : Transform<?????>, fn : (?, ??, ???, ????, ?????) -> Material) -> Material;

	MSelectConstantMetrics(value : Transform<?>, fn : (?) -> Material) -> Material;

	// Copies size of content to copyFn, copyFn result has no effect on overall metrics
	// If above is true result of copyFn is placed on top of content
	// Useful when you need to place TInteractive above or below another one
	MCopySize(content : Material, copyFn : (Tropic) -> Material, above : bool) -> Material;
	// Similar to MCopySize, only resulting material has metrics of copyFn
	// copyFn has two parameters: size of the content, and content itself
	MCopySize2(content : Material, copyFn : (Tropic, Material) -> Material) ->  Material;

	MProportionGrid(c : [[Pair<Transform<Factor>, Material>]]) -> Material;
	MProportionLines(c : [Pair<Transform<double>, Material>]) -> Material;
	MProportionCols(c : [Pair<Transform<double>, Material>]) -> Material;
	MProportionBaselineCols(c : [Pair<Transform<double>, Material>]) -> Material;
	MProportionBaselineColsA(c : [Pair<Transform<double>, Material>]) -> Material;
	MProportionColsA(c : [Pair<Transform<double>, Material>]) -> Material;

	MSizedWidth(width : Transform<double>, height : double) -> Material;
	MSizedHeight(width : double, height : Transform<double>) -> Material;

	// Common helpers of centering a number of materials
	// Centering occurs in the box with the biggest width or height (accordingly to helper name) among the elements
	MColsXCenter(cols : [Material]) -> Material;
	MColsYCenter(cols : [Material]) -> Material;
	MBaselineColsXCenter(cols : [Material]) -> Material;
	MBaselineColsYCenter(cols : [Material]) -> Material;
	MColsYCenterA(cols : [Material]) -> Material;
	MBaselineColsYCenterA(cols : [Material]) -> Material;
	MLinesXCenter(lines : [Material]) -> Material;
	MLinesYCenter(lines : [Material]) -> Material;
	MBaselineLinesXCenter(lines : [Material]) -> Material;
	MBaselineLinesYCenter(lines : [Material]) -> Material;
	// Deprecated. Use MColsYCenter instead.
	MColsCenterY(items : [Material]) -> Material {MColsYCenter(items)};

	// Common helpers for creating groups of elements with the same available width or height
	MColsSameWidth(cols : [Material]) -> Material;
	MColsSameHeight(cols : [Material]) -> Material;
	MLinesSameWidth(lines : [Material]) -> Material;
	MLinesSameHeight(lines : [Material]) -> Material;
	MColsSameWidthA(cols : [Material]) -> Material;
	MColsSameHeightA(cols : [Material]) -> Material;
	MLinesSameWidthA(lines : [Material]) -> Material;
	MLinesSameHeightA(lines : [Material]) -> Material;

	// Same as MLines2, only m1 is above m2 in zorder
	// Useful if you have for example a toolbar with shadow that has to overlap content below
	MLines2InvertZorder(m1 : Material, m2 : Material) -> Material;

	// if the content fits in the box then it returns the content
	// if the content does not fit then it returns a zoomed out content
	// the final metrics is a metrics of the final content
	MZoomToFit(content : Material, box : Material) -> Material;
	MScaleXY(factor : double) -> (Material) -> Material;
	// Helpers for turning Material
	MRotate90(m : Material) -> Material;
	MRotate90Left(m : Material) -> Material;

	// Crops in one direction and forceably set given width/height
	MCropWidth(content : Material, width : Material) -> Material;
	MCropHeight(content : Material, height : Material) -> Material;
	MCropWidth2(content : Material, width : Transform<double>) -> Material;
	MCropHeight2(content : Material, height : Transform<double>) -> Material;
	// Similar to MCrop*, but doesn't forceably increase metric if it is less than given width/height
	MLimitWidth(content : Material, width : Material) -> Material;
	MLimitHeight(content : Material, height : Material) -> Material;
	MLimitWidth2(content : Material, width : Transform<double>) -> Material;
	MLimitHeight2(content : Material, height : Transform<double>) -> Material;

	MEvenGrid(content : [[Material]]) -> Material;
	MEvenGridA(content : [[Material]]) -> Material;

	MFixSizeKeepBaseline(m : Material, size : Material) -> Material;
	MBaseline(baseline : Transform<double>, m : Material) -> Material;

	// Dynamic version of MFrame
	MFrameT(margin : Transform<double>, radius : Transform<double>, style : Transform<[MGraphicsStyle]>, box : Material) -> Material;
	MFrameCustom(l : double, tl : double, tlRounded : bool, t : double, tr : double, trRounded : bool, r : double,
		br : double, brRounded : bool, b : double, bl : double, blRounded : bool, style : [MGraphicsStyle], box : Material) -> Material;
	MFrameCustomT(
		l : Transform<double>, tl : Transform<double>, tlRounded : Transform<bool>,
		t : Transform<double>, tr : Transform<double>, trRounded : Transform<bool>,
		r : Transform<double>, br : Transform<double>, brRounded : Transform<bool>,
		b : Transform<double>, bl : Transform<double>, blRounded : Transform<bool>,
		style : Transform<[MGraphicsStyle]>, box : Material) -> Material;

	MFrameDashed(box : Material, style : Transform<[MGraphicsStyle]>) -> Material;

	// Helper for dynamic text
	MDynamicText(text : Transform<string>, style : [MParagraphStyle]) -> Material;

	// Allows to write html-string like "this is <i>italic</i> and <b>bold</b> text".
	// It works only in JS
	MHTMLText(text : string, style : [MTextStyle]) -> Material;
	MHTMLDynamicText(text : Transform<string>, style : [MParagraphStyle]) -> Material;

	// Show text and progressbar below
 	MLoading(text : string) -> Material;

	// Similar to MConstruct, but constructing/disposing are triggered by changing the rendered state of the corresponding clip.
	// So, for example, it reacts to changes into MVisible or to fullwindow dialog opening, while MConstruct ignores it.
	// See material/tests/test_mconstruct_renderable.flow for the testcase
	MConstructRenderable(constructors : [() -> () -> void], m : Material) -> Material;

	// Zoom material if its available metrics are bigger than threshold
	MZoomMax(m : Material, threshold : Transform<WidthHeight>) -> Material;
	// Zoom material if its available width is bigger than thresholdWidth
	MZoomMaxWidth(m : Material, thresholdWidth : Transform<double>) -> Material;
	// Zoom material if its available height is bigger than thresholdHeight
	MZoomMaxHeight(m : Material, thresholdHeight : Transform<double>) -> Material;

	// Helpers to make Material not transparent for events
	disableMMouseWheelBelow(content : Material) -> Material;
	disableMInteractivesBelow(content : Material) -> Material;

	// Helper to create event blocker layer above element
	blockMInteractives(content : Material) -> Material;
	blockMInteractivesDimmed(m : Material) -> Material;

	MMouseWheelInteractive(m : Material, deltaX : (double) -> bool, deltaY : (double) -> bool) -> Material;

	M3DStage(scene : F3DObject, camera : F3DObject, size : Material, style : [F3DStageStyle]) -> Material;

	// Draws content with 'canvas' renderer
	// Works only in js with 'html' renderer, for other targets identical to regular clip
	// WARNING: Doesn't support native widgets making it applicable only to groups of graphical objects
	MCanvas(content : Material) -> Material;

	MDecorator(m : Material, decorators : [Pair<Transform<bool>, (Transform<WidthHeight>) -> Material>], above : bool) -> Material;

	// Area with borders equal to device notch or other screen inbounds
	MSafeArea(m : Material) -> Material;

	MSafeAreaStart(m : Material) -> Material;
	MSafeAreaTop(m : Material) -> Material;
	MSafeAreaEnd(m : Material) -> Material;
	MSafeAreaBottom(m : Material) -> Material;

	MMoveClip(m : Material, customPosScale : Maybe<Transform<PositionScale>>, fn : (Tropic) -> void) -> Material;

	// Takes Materials with its priority level.
	// When there is not enough available width, hides elements, starting from low-prority.
	MIfFitsCols(items0 : Transform<[MIfFitsColsItem]>, style : [MIfFitsColsStyle]) -> Material;

		MIfFitsColsItem(material : Material, style : [MIfFitsColsItemStyle]);
			MIfFitsColsItemStyle ::= MIfFitsColsItemPriority, MIfFitsColsOverflowView;
				// Medium priority (5) by default.
				MIfFitsColsItemPriority(priority : int);
				// Defines that item should be visible into the 'overflow' items menu.
				MIfFitsColsOverflowView(view : MMenuLine);
		MIfFitsColsIconButton(icon : string, onClick : () -> void, priority : int, menuTitle : string) -> MIfFitsColsItem {
			MIfFitsColsItem(MIconButton(icon, onClick, [], []), [
				MIfFitsColsItemPriority(priority),
				MIfFitsColsOverflowView(MMenuSingleLine(menuTitle, []))
			])
		}

		MIfFitsColsStyle ::= MIfFitsColsFn, MIfFitsColsOverflowItems, MIfFitsColsMenuButton, MIfFitsMenuLine;
			// Defines how items should be wrapped into cols. MCols by default. MColsA, MBaselineColsA are other good choices
			MIfFitsColsFn(fn : ([Material]) -> Material);
			// Returns overflowView of hidden items
			MIfFitsColsOverflowItems(items : DynamicBehaviour<[MMenuLine]>);
			// Collect hidden items and add them to the menu
			MIfFitsColsMenuButton(enabled : Transform<bool>);
			// If you want something to always be in the menu
			MIfFitsMenuLine(line : MMenuLine);

	MIfFitsColsYCenterA(items : Transform<[MIfFitsColsItem]>) -> Material;

	// Shows fullSizeContent only if available space is greater than minimum size required to show it
	// Otherwise shows reducedSizeContent
	MIfFits(fullSizeContent : Material, reducedSizeContent : Material) -> Material;
	MIfFitsWidth(fullSizeContent : Material, reducedSizeContent : Material) -> Material;
	MIfFitsWidthDelay(fullSizeContent : Material, reducedSizeContent : Material, delay : int) -> Material;
	MIfFitsHeight(fullSizeContent : Material, reducedSizeContent : Material) -> Material;

	// Shows content only if available space is greater than minimum size required to show it
	MShowIfFits(content : Material) -> Material;
	MShowIfFitsWidth(content : Material) -> Material;
	MShowIfFitsHeight(content : Material) -> Material;

	MOverride(overriders : [TOverrider], m : Material) -> Material;

	// JS HTML Renderer: Extract rendered static html from the clip
	// Use wrapFlowHTML to wrap resulting html string with root tags, flow stylesheet and Roboto webfonts
	MExtractHTML(m : Material, setfn : (fn : () -> string) -> void) -> Material;
	// JS: Extract clip as png in base64 format
	// Ignores crossorigin images
	// setfn returns a function that recieves callback which gets base64 string when image is ready
	// setfn returns None() if child is destroyed
	MExtractPNG(m : Material, setfn : (fn : Maybe<((png : string) -> void) -> void>) -> void) -> Material;

	MExtractPNG2(m : Material, ready : DynamicBehaviour<bool>, setfn : (fn : Maybe<((png : string) -> void) -> void>) -> void) -> Material;

	MTag2(setfn : (fn : () -> TransformMatrix) -> void, m : Material) -> Material;

	MRectangle(style : [MGraphicsStyle], size : Material) -> Material;
	MRounded(topLeft : double, topRight : double, bottomRight : double, bottomLeft : double, style : [MGraphicsStyle], size : Material) -> Material;
}

// Inner helpers
// DO NOT EXPORT

Material2Tropic(m : Material, fn : (tr : Tropic) -> Material) -> Material {
	MGetFocusGroup(\p -> MGetMaterial2Tropic(\m2t -> fn(m2t(m, p))))
}

Material2Tropic2(m1 : Material, m2 : Material, fn : (tr1 : Tropic, tr2 : Tropic) -> Material) -> Material {
	MGetFocusGroup(\p -> MGetMaterial2Tropic(\m2t -> fn(m2t(m1, p), m2t(m2, p))))
}

Material2TropicA(m : [Material], fn : (tr : [Tropic]) -> Material) -> Material {
	MGetFocusGroup(\p -> MGetMaterial2Tropic(\m2t -> fn(map(m, \_m -> m2t(_m, p)))))
}

MGroupWithoutMetrics(m : [Material]) -> Material {
	Material2TropicA(m, \tr -> TGroupWithoutMetrics(tr))
}

MGroupSameMetrics(m : [Material]) -> Material {
	Material2TropicA(m, \tr -> TGroupSameMetrics(tr))
}

MSelect2(v1 : Transform<?>, v2 : Transform<??>, fn : (?, ??) -> Material) -> Material {
	t = fselect2(v1, v2, FLift2(fn));

	if (isFConst(t)) {
		// If we are constant, let's avoid the mutable altogether
		fgetValue(t)
	} else {
		MMutable(t);
	}
}

MSelect3(v1 : Transform<?>, v2 : Transform<??>, v3 : Transform<???>, fn : (?, ??, ???) -> Material) -> Material {
	t = fselect3(v1, v2, v3, fn);

	if (isFConst(t)) {
		// If we are constant, let's avoid the mutable altogether
		fgetValue(t)
	} else {
		MMutable(t);
	}
}

MSelect4(v1 : Transform<?>, v2 : Transform<??>, v3 : Transform<???>, v4 : Transform<????>, fn : (?, ??, ???, ????) -> Material) -> Material {
	t = fselect4(v1, v2, v3, v4, fn);

	if (isFConst(t)) {
		// If we are constant, let's avoid the mutable altogether
		fgetValue(t)
	} else {
		MMutable(t);
	}
}

MSelect5(v1 : Transform<?>, v2 : Transform<??>, v3 : Transform<???>, v4 : Transform<????>, v5 : Transform<?????>, fn : (?, ??, ???, ????, ?????) -> Material) -> Material {
	t = fselect5(v1, v2, v3, v4, v5, fn);

	if (isFConst(t)) {
		// If we are constant, let's avoid the mutable altogether
		fgetValue(t)
	} else {
		MMutable(t);
	}
}

MCopySize(content : Material, copyFn : (Tropic) -> Material, above : bool) -> Material {
	MGetFocusGroup(\p -> MGetMaterial2Tropic(\m2t ->  TCopySize(m2t(content, p), \sz -> m2t(copyFn(sz), p), above)))
}

MCopySize2(content : Material, copyFn : (Tropic, Material) -> Material) -> Material {
	MGetFocusGroup(\p -> MGetMaterial2Tropic(\m2t ->  TCopySize2(m2t(content, p), \sz, tr -> m2t(copyFn(sz, tr), p))))
}

MAttachBox(m : Material, box : DynamicBehaviour<WidthHeight>) -> Material {
	Material2Tropic(m, \tr -> TAttachBox(tr, box));
}

MAttachWidth(m : Material, width : DynamicBehaviour<double>) -> Material {
	Material2Tropic(m, \tr -> TAttachWidth(tr, width));
}

MAttachHeight(m : Material, height : DynamicBehaviour<double>) -> Material {
	Material2Tropic(m, \tr -> TAttachHeight(tr, height));
}

MAttachWidthHeight(m : Material, width : DynamicBehaviour<double>, height : DynamicBehaviour<double>) -> Material {
	Material2Tropic(m, \tr -> TAttachWidthHeight(tr, width, height));
}

MAttachAvailable(m : Material, box : DynamicBehaviour<WidthHeight>) -> Material {
	Material2Tropic(m, \tr -> TAttachAvailable(tr, box));
}

MAttachAvailableWidth(m : Material, width : DynamicBehaviour<double>) -> Material {
	Material2Tropic(m, \tr -> TAttachAvailableWidth(tr, width));
}

MAttachAvailableHeight(m : Material, height : DynamicBehaviour<double>) -> Material {
	Material2Tropic(m, \tr -> TAttachAvailableHeight(tr, height));
}

MAttachAvailableWidthHeight(m : Material, width : DynamicBehaviour<double>, height : DynamicBehaviour<double>) -> Material {
	Material2Tropic(m, \tr -> TAttachAvailableWidthHeight(tr, width, height));
}

MAttachBox2(m : Material, box : DynamicBehaviour<WidthHeight>, c : Material) -> Material {
	Material2Tropic2(m, c, \tr1, tr2 -> TAttachBox2(tr1, box, tr2));
}

MAttachWidth2(m : Material, width : DynamicBehaviour<double>, c : Material) -> Material {
	Material2Tropic2(m, c, \tr1, tr2 -> TAttachWidth2(tr1, width, tr2));
}

MAttachHeight2(m : Material, height : DynamicBehaviour<double>, c : Material) -> Material {
	Material2Tropic2(m, c, \tr1, tr2 -> TAttachHeight2(tr1, height, tr2));
}

MAttachToFirst(first : Material, second : Material) -> Material {
	wh = makeWH();
	minW = make(0.);
	minH = make(0.);
	MGroup2(
		MAttachBox(first, wh),
		MAvailable(
			MInspect([IMinWidth(minW), IMinWidth(minH)], second),
			TSized(wh)
		)
		|> MSetMinWidth2(minW)
		|> MSetMinHeight2(minH)
	)
}

MAttachToSecond(first : Material, second : Material) -> Material {
	wh = makeWH();
	minW = make(0.);
	minH = make(0.);
	MGroup2(
		MAvailable(
			MInspect([IMinWidth(minW), IMinWidth(minH)], first),
			TSized(wh)
		)
		|> MSetMinWidth2(minW)
		|> MSetMinHeight2(minH),
		MAttachBox(second, wh)
	)
}

MLinesWidthByFirst(first : Material, second : Material) -> Material {
	MLinesWidthByFirstCommon(first, second, false)
}

MLinesAWidthByFirst(first : Material, second : Material) -> Material {
	MLinesWidthByFirstCommon(first, second, true)
}

MLinesWidthByFirstCommon(first : Material, second : Material, supportRTL : bool) -> Material {
	firstWidth = make(0.);
	avWidth = make(0.);

	fn = if (supportRTL) MLines2A else \v1, v2 -> MLines2(v1, v2);

	fn(
		MAvailableWidthPreventFillers(MAttachWidth(first, firstWidth), avWidth),
		MAvailableWidthPreventFillers(second, firstWidth)
	)
	|> (\m -> MAttachAvailableWidth(m, avWidth))
}

MLinesWidthBySecond(first : Material, second : Material) -> Material {
	MLinesWidthBySecondCommon(first, second, false)
}

MLinesAWidthBySecond(first : Material, second : Material) -> Material {
	MLinesWidthBySecondCommon(first, second, true)
}

MLinesWidthBySecondCommon(first : Material, second : Material, supportRTL : bool) -> Material {
	secondWidth = make(0.);
	avWidth = make(0.);

	fn = if (supportRTL) MLines2A else \v1, v2 -> MLines2(v1, v2);

	fn(
		MAvailableWidthPreventFillers(first, secondWidth),
		MAvailableWidthPreventFillers(MAttachWidth(second, secondWidth), avWidth)
	)
	|> (\m -> MAttachAvailableWidth(m, avWidth))
}

MColsHeightByFirst(first : Material, second : Material) -> Material {
	MColsHeightByFirstCommon(first, second, false);
}

MColsAHeightByFirst(first : Material, second : Material) -> Material {
	MColsHeightByFirstCommon(first, second, true);
}

MColsHeightByFirstCommon(first : Material, second : Material, supportRTL : bool) -> Material {
	firstHeight = make(0.);
	avHeight = make(0.);

	fn = if (supportRTL) MCols2A else \v1, v2 -> MCols2(v1, v2);

	fn(
		MAvailableHeightPreventFillers(MAttachHeight(first, firstHeight), avHeight),
		MAvailableHeightPreventFillers(second, firstHeight)
	)
	|> (\m -> MAttachAvailableHeight(m, avHeight))
}

MColsHeightBySecond(first : Material, second : Material) -> Material {
	MColsHeightBySecondCommon(first, second, false);
}

MColsAHeightBySecond(first : Material, second : Material) -> Material {
	MColsHeightBySecondCommon(first, second, true);
}

MColsHeightBySecondCommon(first : Material, second : Material, supportRTL : bool) -> Material {
	secondHeight = make(0.);
	avHeight = make(0.);

	fn = if (supportRTL) MCols2A else \v1, v2 -> MCols2(v1, v2);

	fn(
		MAvailableHeightPreventFillers(first, secondHeight),
		MAvailableHeightPreventFillers(MAttachHeight(second, secondHeight), avHeight)
	)
	|> (\m -> MAttachAvailableHeight(m, avHeight))
}

MAttachBoxThrottle(m : Material, box : DynamicBehaviour<WidthHeight>, maxDelta : int) -> Material {
	Material2Tropic(m, \tr -> TAttachBoxThrottle(tr, box, maxDelta));
}

MThrottleMetrics(m : Material, maxDelta : int) -> Material {
	Material2Tropic(m, \tr -> TThrottleMetrics(tr, maxDelta));
}

MProportionGrid(c : [[Pair<Transform<Factor>, Material>]]) -> Material {
	MGetFocusGroup(\p -> MGetMaterial2Tropic(\m2t -> TProportionGrid(map(c, \r -> map(r, \pr -> Pair(pr.first, m2t(pr.second, p)))))))
}

MProportionLines(c : [Pair<Transform<double>, Material>]) -> Material {
	MGetFocusGroup(\p -> MGetMaterial2Tropic(\m2t -> TProportionLines(map(c, \pr -> Pair(pr.first, m2t(pr.second, p))))))
}

MProportionCols(c : [Pair<Transform<double>, Material>]) -> Material {
	MGetFocusGroup(\p -> MGetMaterial2Tropic(\m2t -> TProportionCols(map(c, \pr -> Pair(pr.first, m2t(pr.second, p))))))
}

MProportionBaselineCols(c : [Pair<Transform<double>, Material>]) -> Material {
	MGetFocusGroup(\p -> MGetMaterial2Tropic(\m2t -> TProportionBaselineCols(map(c, \pr -> Pair(pr.first, m2t(pr.second, p))))))
}

MProportionBaselineColsA(c : [Pair<Transform<double>, Material>]) -> Material {
	MGetFocusGroup(\p -> MGetMaterial2Tropic(\m2t -> TProportionBaselineColsA(map(c, \pr -> Pair(pr.first, m2t(pr.second, p))))))
}

MProportionColsA(c : [Pair<Transform<double>, Material>]) -> Material {
	MGetFocusGroup(\p -> MGetMaterial2Tropic(\m2t -> TProportionColsA(map(c, \pr -> Pair(pr.first, m2t(pr.second, p))), p.rtl)))
}

MSizedWidth(width : Transform<double>, height : double) -> Material {
	TSizedWidth(width, height);
}

MSizedHeight(width : double, height : Transform<double>) -> Material {
	TSizedHeight(width, height);
}

MColsXCenter(m : [Material]) -> Material {
	Material2TropicA(m, \tr -> TColsXCenter(tr))
}

MColsYCenter(m : [Material]) -> Material {
	Material2TropicA(m, \tr -> TColsYCenter(tr))
}

MBaselineColsXCenter(m : [Material]) -> Material {
	Material2TropicA(m, \tr -> TBaselineColsXCenter(tr))
}

MBaselineColsYCenter(m : [Material]) -> Material {
	Material2TropicA(m, \tr -> TBaselineColsYCenter(tr))
}

MColsYCenterA(m : [Material]) -> Material {
	Material2TropicA(m, \tr -> TColsYCenterA(tr))
}

MBaselineColsYCenterA(m : [Material]) -> Material {
	Material2TropicA(m, \tr -> TBaselineColsYCenterA(tr))
}

MLinesXCenter(m : [Material]) -> Material {
	Material2TropicA(m, \tr -> TLinesXCenter(tr))
}

MLinesYCenter(m : [Material]) -> Material {
	Material2TropicA(m, \tr -> TLinesYCenter(tr))
}

MBaselineLinesXCenter(m : [Material]) -> Material {
	Material2TropicA(m, \tr -> TBaselineLinesXCenter(tr))
}

MBaselineLinesYCenter(m : [Material]) -> Material {
	Material2TropicA(m, \tr -> TBaselineLinesYCenter(tr))
}

MColsSameWidth(m : [Material]) -> Material {
	Material2TropicA(m, \tr -> TColsSameWidth(tr))
}

MColsSameHeight(m : [Material]) -> Material {
	Material2TropicA(m, \tr -> TColsSameHeight(tr))
}

MLinesSameWidth(m : [Material]) -> Material {
	Material2TropicA(m, \tr -> TLinesSameWidth(tr))
}

MLinesSameHeight(m : [Material]) -> Material {
	Material2TropicA(m, \tr -> TLinesSameHeight(tr))
}

MColsSameWidthA(m : [Material]) -> Material {
	Material2TropicA(m, \tr -> TColsSameWidthA(tr))
}

MColsSameHeightA(m : [Material]) -> Material {
	Material2TropicA(m, \tr -> TColsSameHeightA(tr))
}

MLinesSameWidthA(m : [Material]) -> Material {
	Material2TropicA(m, \tr -> TLinesSameWidthA(tr))
}

MLinesSameHeightA(m : [Material]) -> Material {
	Material2TropicA(m, \tr -> TLinesSameHeightA(tr))
}

MLines2InvertZorder(m1 : Material, m2 : Material) -> Material {
	MCopySize2(
		m1,
		\sz, c -> MGroup2(MLines2(sz, m2), c)
	)
}

MEvenGrid(content : [[Material]]) -> Material {
	MGetFocusGroup(\p -> MGetMaterial2Tropic(\m2t -> TEvenGrid(map(content, \c -> map(c, \i -> m2t(i, p))), p.rtl)))
}

MEvenGridA(content : [[Material]]) -> Material {
	MGetFocusGroup(\p -> MEvenGrid(if (p.rtl) map(content, reverseA) else content))
}

MSelectConstantMetrics(value : Transform<?>, fn : (?) -> Material) -> Material {
	MTransformTAcc2(\t2a -> {
		bf = t2a(MMutable(fselect(value, FLift(fn))));

		wd = bf.metrics.width |> fgetValue |> const;
		hgt = bf.metrics.height |> fgetValue |> const;

		TAcc(
			bf.form,
			TFormMetrics(
				wd,
				hgt,
				if (bf.yConstant) bf.metrics.baseline |> fgetValue |> const
				else bf.metrics.baseline
			),
			if (bf.xConstant) wd else bf.minWidth,
			if (bf.yConstant) hgt else bf.minHeight,
			if (bf.xConstant) wd else bf.maxWidth,
			if (bf.yConstant) hgt else bf.maxHeight,
			if (bf.xConstant) zero else bf.xFillers,
			if (bf.yConstant) zero else bf.yFillers,
			bf.addFillers,
			bf.xConstant,
			bf.yConstant,
			bf.disposers
		)
	})
}

MAvailableWidth(m : Material, available : Transform<double>) -> Material {
	Material2Tropic(m, \tr -> TAvailableWidth(tr, available))
}

MAvailableHeight(m : Material, available : Transform<double>) -> Material {
	Material2Tropic(m, \tr -> TAvailableHeight(tr, available))
}

MAvailableWidthHeight(m : Material, width : Transform<double>, height : Transform<double>) -> Material {
	Material2Tropic(m, \tr -> TAvailableWidthHeight(tr, width, height))
}

MZoomToFit(content : Material, box : Material) -> Material {
	cwh = makeWH();
	MTweak([TFitZoom(true, true)], MInspect([ISize(cwh)], content), MMinimumGroup2(TSized(cwh), box));
}

MScaleXY(factor : double) -> (Material) -> Material {
	\m -> MScale(ffactor2(const(factor)), m)
}

MCropWidth(content : Material, width : Material) -> Material {
	MGetFocusGroup(\p -> MGetMaterial2Tropic(\m2t -> TCropWidth(m2t(content, p), m2t(width, p))));
}

MCropHeight(content : Material, height : Material) -> Material {
	MGetFocusGroup(\p -> MGetMaterial2Tropic(\m2t -> TCropHeight(m2t(content, p), m2t(height, p))));
}

MCropWidth2(content : Material, width : Transform<double>) -> Material {
	MGetFocusGroup(\p -> MGetMaterial2Tropic(\m2t -> TCropWidth2(m2t(content, p), width)));
}

MCropHeight2(content : Material, height : Transform<double>) -> Material {
	MGetFocusGroup(\p -> MGetMaterial2Tropic(\m2t -> TCropHeight2(m2t(content, p), height)));
}

MLimitWidth(content : Material, width : Material) -> Material {
	MGetFocusGroup(\p -> MGetMaterial2Tropic(\m2t -> TLimitWidth(m2t(content, p), m2t(width, p))));
}

MLimitHeight(content : Material, height : Material) -> Material {
	MGetFocusGroup(\p -> MGetMaterial2Tropic(\m2t -> TLimitHeight(m2t(content, p), m2t(height, p))));
}

MLimitWidth2(content : Material, width : Transform<double>) -> Material {
	MGetFocusGroup(\p -> MGetMaterial2Tropic(\m2t -> TLimitWidth2(m2t(content, p), width)));
}

MLimitHeight2(content : Material, height : Transform<double>) -> Material {
	MGetFocusGroup(\p -> MGetMaterial2Tropic(\m2t -> TLimitHeight2(m2t(content, p), height)));
}

MAlignStart(m : Material) -> Material {
	MGetFocusGroup(\p -> if (p.rtl) MAlignRight(m) else m)
}

MAlignEnd(m : Material) -> Material {
	MGetFocusGroup(\p -> if (!p.rtl) MAlignRight(m) else m)
}

MAlignStartFill(m : Material) -> Material {
	MGetFocusGroup(\p -> if (p.rtl) MAlignRight(m) else MAlignLeft(m))
}

MAlignEndFill(m : Material) -> Material {
	MGetFocusGroup(\p -> if (!p.rtl) MAlignRight(m) else MAlignLeft(m))
}

MAlignLeft(m : Material) -> Material {
	MTweak([TAlign(const(0.0), const(0.0))], m, TFillX())
}

MAlignTop(m : Material) -> Material {
	MTweak([TAlign(const(0.0), const(0.0))], m, TFillY())
}

MAlignRight(m : Material) -> Material {
	MTweak([TAlign(const(1.0), const(0.0))], m, TFillX())
}

MAlignBottom(m : Material) -> Material {
	MTweak([TAlign(const(0.0), const(1.0))], m, TFillY())
}

MAlignTopLeft(m : Material) -> Material {
	MTweak([TAlign(const(0.0), const(0.0))], m, TFillXY())
}

MAlignTopCenter(m : Material) -> Material {
	MTweak([TAlign(const(0.5), const(0.0))], m, TFillXY())
}

MAlignTopRight(m : Material) -> Material {
	MTweak([TAlign(const(1.0), const(0.0))], m, TFillXY())
}

MAlignCenterRight(m : Material) -> Material {
	MTweak([TAlign(const(1.0), const(0.5))], m, TFillXY())
}

MAlignBottomRight(m : Material) -> Material {
	MTweak([TAlign(const(1.0), const(1.0))], m, TFillXY())
}

MAlignBottomCenter(m : Material) -> Material {
	MTweak([TAlign(const(0.5), const(1.0))], m, TFillXY())
}

MAlignBottomLeft(m : Material) -> Material {
	MTweak([TAlign(const(0.0), const(1.0))], m, TFillXY())
}

MAlignCenterLeft(m : Material) -> Material {
	MTweak([TAlign(const(0.0), const(0.5))], m, TFillXY())
}

MAlignTopStart(m : Material) -> Material {
	MGetFocusGroup(\p -> if (!p.rtl) MAlignTop(m) else MAlignTopRight(m))
}

MAlignTopEnd(m : Material) -> Material {
	MGetFocusGroup(\p -> if (!p.rtl) MAlignTopRight(m) else MAlignTop(m))
}

MAlignCenterStart(m : Material) -> Material {
	MGetFocusGroup(\p -> if (!p.rtl) MCenterY(m) else MAlignCenterRight(m))
}

MAlignCenterEnd(m : Material) -> Material {
	MGetFocusGroup(\p -> if (!p.rtl) MAlignCenterRight(m) else MCenterY(m))
}

MAlignBottomStart(m : Material) -> Material {
	MGetFocusGroup(\p -> if (!p.rtl) MAlignBottom(m) else MAlignBottomRight(m))
}

MAlignBottomEnd(m : Material) -> Material {
	MGetFocusGroup(\p -> if (!p.rtl) MAlignBottomRight(m) else MAlignBottom(m))
}

MAlignTopStartFill(m : Material) -> Material {
	MGetFocusGroup(\p -> if (!p.rtl) MAlignTopLeft(m) else MAlignTopRight(m))
}

MAlignTopEndFill(m : Material) -> Material {
	MGetFocusGroup(\p -> if (!p.rtl) MAlignTopRight(m) else MAlignTopLeft(m))
}

MAlignCenterStartFill(m : Material) -> Material {
	MGetFocusGroup(\p -> if (!p.rtl) MAlignCenterLeft(m) else MAlignCenterRight(m))
}

MAlignCenterEndFill(m : Material) -> Material {
	MGetFocusGroup(\p -> if (!p.rtl) MAlignCenterRight(m) else MAlignCenterLeft(m))
}

MAlignBottomStartFill(m : Material) -> Material {
	MGetFocusGroup(\p -> if (!p.rtl) MAlignBottomLeft(m) else MAlignBottomRight(m))
}

MAlignBottomEndFill(m : Material) -> Material {
	MGetFocusGroup(\p -> if (!p.rtl) MAlignBottomRight(m) else MAlignBottomLeft(m))
}

MBorderTop(border : double) -> (Material) -> Material {
	\m -> MBorder(0., border, 0., 0., m)
}

MBorderBottom(border : double) -> (Material) -> Material {
	\m -> MBorder(0., 0., 0., border, m)
}

MBorderLeft(border : double) -> (Material) -> Material {
	\m -> MBorder(border, 0., 0., 0., m)
}

MBorderRight(border : double) -> (Material) -> Material {
	\m -> MBorder(0., 0., border, 0., m)
}

MBorderStart(border : double) -> (Material) -> Material {
	\m -> MBorderA(border, 0., 0., 0., m)
}

MBorderEnd(border : double) -> (Material) -> Material {
	\m -> MBorderA(0., 0., border, 0., m)
}

MBorderTopBottom(border : double) -> (Material) -> Material {
	\m -> MBorder(0., border, 0., border, m)
}

MBorderLeftRight(border : double) -> (Material) -> Material {
	\m -> MBorder(border, 0., border, 0., m)
}

MFixSizeKeepBaseline(m : Material, size : Material) -> Material {
	MTransformTAcc2(\t2a -> {
		bf = t2a(m);
		sf = t2a(size);

		TAcc(
			bf.form,
			TFormMetrics(
				sf.metrics.width,
				sf.metrics.height,
				bf.metrics.baseline
			),
			sf.minWidth,
			sf.minHeight,
			sf.maxWidth,
			sf.maxHeight,
			sf.xFillers,
			sf.yFillers,
			sf.addFillers,
			sf.xConstant,
			sf.yConstant && isFConst(bf.metrics.baseline),
			concat(sf.disposers, bf.disposers)
		)
	})
}

MBaseline(baseline : Transform<double>, m : Material) -> Material {
	Material2Tropic(m, \tr -> TBaseline(baseline, tr))
}

MBorderT(start : Transform<double>, top : Transform<double>, end : Transform<double>, bottom : Transform<double>, m : Material) -> Material {
	Material2Tropic(m, \tr -> TBorderT(start, top, end, bottom, tr))
}

MBorderTA(start : Transform<double>, top : Transform<double>, end : Transform<double>, bottom : Transform<double>, m : Material) -> Material {
	Material2Tropic(m, \tr -> TBorderTDir(start, top, end, bottom, tr, getDefaultRtl()))
}

MBorder4T(border : Transform<double>, m : Material) -> Material {
	MBorderT(border, border, border, border, m)
}

MFrameT(margin : Transform<double>, radius : Transform<double>, style : Transform<[MGraphicsStyle]>, box : Material) -> Material {
	MGetFocusGroup(\parent -> Material2Tropic(box, \tr -> TFrameT(margin, radius, fselectLift(style, \s -> mgraphicsStyle2tgraphicsStyle(parent, s)), tr)))
}

MFrameCustom(l : double, tl : double, tlRounded : bool, t : double, tr : double, trRounded : bool, r : double,
	br : double, brRounded : bool, b : double, bl : double, blRounded : bool, style : [MGraphicsStyle], box : Material) -> Material {
	MGetFocusGroup(\parent -> Material2Tropic(box, \trop -> TFrameCustom(l, tl, tlRounded, t, tr, trRounded, r,	br, brRounded, b, bl, blRounded, mgraphicsStyle2tgraphicsStyle(parent, style), trop)))
}

MFrameCustomT(
	l : Transform<double>, tl : Transform<double>, tlRounded : Transform<bool>,
	t : Transform<double>, tr : Transform<double>, trRounded : Transform<bool>,
	r : Transform<double>, br : Transform<double>, brRounded : Transform<bool>,
	b : Transform<double>, bl : Transform<double>, blRounded : Transform<bool>,
	style : Transform<[MGraphicsStyle]>, box : Material) -> Material {

	MGetFocusGroup(\parent -> Material2Tropic(box, \trop -> TFrameCustomT(l, tl, tlRounded, t, tr, trRounded, r,	br, brRounded, b, bl, blRounded, fselectLift(style, \s -> mgraphicsStyle2tgraphicsStyle(parent, s)), trop)))
};

MFrameDashed(box : Material, style : Transform<[MGraphicsStyle]>) -> Material {
	MGetFocusGroup(\parent -> {
		boxWH = makeWH();
		gStyle = fselectLift(style, \s -> mgraphicsStyle2tgraphicsStyle(parent, s) |> tgraphicsStyle2graphicsStyle);

		MGroup2(
			MAttachBox(box, boxWH),
			TSelect2(boxWH, gStyle, \wh, st ->
				TForm(dottedLineRoundedRect(wh.width, wh.height, 0., 3., 0.4, st))
			)
		)
	})
}

MDynamicText(text : Transform<string>, style : [MParagraphStyle]) -> Material {
	if (text == const(""))
		TEmpty()
	else
		MDynamicParagraph(text, replaceStruct(style, extractStruct(style, MWidth(0.0))));
}

MHTMLText(text : string, style : [MTextStyle]) -> Material {
	MText(text, replaceStruct(style, EscapeHTML(false)));
}

MHTMLDynamicText(text : Transform<string>, style : [MParagraphStyle]) -> Material {
	MDynamicText(text, replaceStruct(style, EscapeHTML(false)));
}

MLoading(text : string) -> Material {
	label = MText(text, [])
		|> MCenterX
		|> MBorderLeftRight(8.);

	MAvailable(
		MGroup2(
			MZoomToFill(MProgressBar([MBlue(200), MProgressBackgroundColor(MWhite()), WidthHeight(100.0, 10.0)]), TFillXY(), false) |> MCenterX,
			TDisplay("Label") |> MCenterX
		),
		TGhost("Label")
	)
	|> (\m -> MLet("Label", label, m))
}

MDebugMetrics(c : int, m : Material) -> Material {
	Material2Tropic(m, \tr -> TDebugMetrics(c, tr))
}

MDebugPositionScale(c : int, m : Material) -> Material {
	Material2Tropic(m, \tr -> TDebugPositionScale(c, tr))
}

MDebugConstruct(tag : string, m : Material) -> Material {
	Material2Tropic(m, \tr -> TDebugConstruct(tag, tr))
}

MDebugInteractive(m : Material) -> Material {
	Material2Tropic(m, TDebugInteractive)
}

MBorder4(border : double, m : Material) -> Material {
	MBorder(border, border, border, border, m)
}

MBorder2(horizontalBorder : double, verticalBorder : double, m : Material) -> Material {
	MBorder(horizontalBorder, verticalBorder, horizontalBorder, verticalBorder, m)
}

MRotate90(m : Material) -> Material {
	Material2Tropic(m, TRotate90)
}

MRotate90Left(m : Material) -> Material {
	Material2Tropic(m, TRotate90Left)
}

MConstructRenderable(constructors : [() -> () -> void], m : Material) -> Material {
	Material2Tropic(m, \tr -> TConstructRenderable(constructors, tr));
}

MZoomMax(m : Material, threshold : Transform<WidthHeight>) -> Material {
	Material2Tropic(m, \tr -> TZoomMax(tr, threshold))
}

MZoomMaxWidth(m : Material, thresholdWidth : Transform<double>) -> Material {
	Material2Tropic(m, \tr -> TZoomMaxWidth(tr, thresholdWidth))
}

MZoomMaxHeight(m : Material, thresholdHeight : Transform<double>) -> Material {
	Material2Tropic(m, \tr -> TZoomMaxHeight(tr, thresholdHeight))
}

disableMMouseWheelBelow(m : Material) -> Material {
	Material2Tropic(m, disableMouseWheelBelow)
}

disableMInteractivesBelow(m : Material) -> Material {
	Material2Tropic(m, disableInteractivesBelow)
}

blockMInteractives(m : Material) -> Material {
	Material2Tropic(m, blockInteractives)
}

blockMInteractivesDimmed(m : Material) -> Material {
	Material2Tropic(MAlpha(const(0.5), m), blockInteractives)
}

MMouseWheelInteractive(m : Material, deltaX : (double) -> bool, deltaY : (double) -> bool) -> Material {
	MGetManager(\manager -> Material2Tropic(m, \tr -> TMouseWheelInteractive(manager.manager, tr, deltaX, deltaY)));
}

M3DStage(scene : F3DObject, camera : F3DObject, size : Material, style : [F3DStageStyle]) -> Material {
	Material2Tropic(size, \sz -> T3DStage(scene, camera, sz, style));
}

MCanvas(content : Material) -> Material {
	Material2Tropic(content, TCanvas)
}

MDecorator(m : Material, decorators : [Pair<Transform<bool>, (Transform<WidthHeight>) -> Material>], above : bool) -> Material {
	MGetFocusGroup(\p -> MGetMaterial2Tropic(\m2t ->
		TDecorator(
			m2t(m, p),
			map(decorators, \d -> Pair(d.first, \wh -> m2t(d.second(wh), p))),
			above
		)
	));
}

MSafeArea(m : Material) -> Material {
	if (mobile)
		MGetManager(\manager -> {
			sa = fselect(manager.stageWH, FLift(\__ -> getSafeArea()));

			MBorderTA(
				felementAt(sa, const(0), const(0.0)),
				felementAt(sa, const(1), const(0.0)),
				felementAt(sa, const(2), const(0.0)),
				felementAt(sa, const(3), const(0.0)),
				m
			);
		})
	else
		m;
}

MSafeAreaStart(m : Material) -> Material {
	if (mobile)
		MGetManager(\manager -> {
			sa = fselect(manager.stageWH, FLift(\__ -> getSafeArea()));

			MBorderTA(
				felementAt(sa, const(0), const(0.0)),
				zero,
				zero,
				zero,
				m
			);
		})
	else
		m;
}

MSafeAreaTop(m : Material) -> Material {
	if (mobile)
		MGetManager(\manager -> {
			sa = fselect(manager.stageWH, FLift(\__ -> getSafeArea()));

			MBorderTA(
				zero,
				felementAt(sa, const(1), const(0.0)),
				zero,
				zero,
				m
			);
		})
	else
		m;
}

MSafeAreaEnd(m : Material) -> Material {
	if (mobile)
		MGetManager(\manager -> {
			sa = fselect(manager.stageWH, FLift(\__ -> getSafeArea()));

			MBorderTA(
				zero,
				zero,
				felementAt(sa, const(2), const(0.0)),
				zero,
				m
			);
		})
	else
		m;
}

MSafeAreaBottom(m : Material) -> Material {
	if (mobile)
		MGetManager(\manager -> {
			sa = fselect(manager.stageWH, FLift(\__ -> getSafeArea()));

			MBorderTA(
				zero,
				zero,
				zero,
				felementAt(sa, const(3), const(0.0)),
				m
			);
		})
	else
		m;
}

MMoveClip(m : Material, customPosScale : Maybe<Transform<PositionScale>>, fn : (Tropic) -> void) -> Material {
	Material2Tropic(m, \t -> TMoveClip(t, customPosScale, fn))
}

MIfFits(fullSizeContent : Material, reducedSizeContent : Material) -> Material {
	Material2Tropic(fullSizeContent, \fs -> Material2Tropic(reducedSizeContent, \rs -> TIfFits(fs, rs)))
}

MIfFitsWidth(fullSizeContent : Material, reducedSizeContent : Material) -> Material {
	Material2Tropic(fullSizeContent, \fs -> Material2Tropic(reducedSizeContent, \rs -> TIfFitsWidth(fs, rs)))
}

MIfFitsWidthDelay(fullSizeContent : Material, reducedSizeContent : Material, delay : int) -> Material {
	Material2Tropic(fullSizeContent, \fs -> Material2Tropic(reducedSizeContent, \rs -> TIfFitsWidthDelay(fs, rs, delay)))
}

MIfFitsHeight(fullSizeContent : Material, reducedSizeContent : Material) -> Material {
	Material2Tropic(fullSizeContent, \fs -> Material2Tropic(reducedSizeContent, \rs -> TIfFitsHeight(fs, rs)))
}

MShowIfFits(content : Material) -> Material {
	Material2Tropic(content, TShowIfFits)
}

MShowIfFitsWidth(content : Material) -> Material {
	Material2Tropic(content, TShowIfFitsWidth)
}

MShowIfFitsHeight(content : Material) -> Material {
	Material2Tropic(content, TShowIfFitsHeight)
}

MIfFitsColsItemInner : (
	material : Material,
	minWidth : DynamicBehaviour<double>,
	priorityIndex : DynamicBehaviour<int>,
	priority : int,
	overflowView : Maybe<MMenuLine>
);

MIfFitsColsYCenterA(items0 : Transform<[MIfFitsColsItem]>) -> Material {
	MIfFitsCols(items0, [MIfFitsColsFn(MColsYCenterA)])
}

MIfFitsCols(items0 : Transform<[MIfFitsColsItem]>, style : [MIfFitsColsStyle]) -> Material {
	availableWidth = make(0.);
	colsFn = extractStruct(style, MIfFitsColsFn(\arr -> MColsA(arr))).fn;

	overflowItems0 = tryExtractStruct(style, MIfFitsColsOverflowItems(make([])));
	menuButton = tryExtractStruct(style, MIfFitsColsMenuButton(const(false)));
	overflowItems : Maybe<DynamicBehaviour<[MMenuLine]>> = eitherMap(overflowItems0, \oi -> Some(oi.items), maybeMap(menuButton, \__ -> make([])));
	menuLines : [MMenuLine] = map(extractStructMany(style, MIfFitsMenuLine(MSeparatorLine())), \l -> l.line);

	MSelect(items0, \itms -> {
		items = map(itms, \it ->
			MIfFitsColsItemInner(
				it.material,
				make(0.),
				make(-1),
				extractStruct(it.style, MIfFitsColsItemPriority(5)).priority,
				maybeMap(tryExtractStruct(it.style, MIfFitsColsOverflowView(MMenuSingleLine("", []))), \v -> v.view)
			)
		);

		priorityOrder = sortCustom(
			items,
			\it -> it.priority,
			false
		);

		iteri(priorityOrder, \i, it -> nextDistinct(it.priorityIndex, i));

		showThreshold =
			fsubselect(fthrottleNextFrame(availableWidth), FLift(\av -> {
				ffoldi(fthrottleNextFrame(fmerge(map(priorityOrder, \it -> it.minWidth))), Pair(0., length(priorityOrder)), \i, acc, minWidth -> {
					s = acc.first + minWidth;
					Pair(s, if (acc.first <= av && s > av) i else acc.second)
				})
				|> fSecondOfPair
			}));

		map(items, \it ->
			MInspect([IMinWidth(it.minWidth)], it.material)
			|> (\m -> MShow(flessi(it.priorityIndex, showThreshold), m))
		)
		|> colsFn
		|> (\m -> eitherMap(overflowItems, \oi ->
			MConstruct([makeSubscribe2(showThreshold, \threshold -> nextDistinct(oi,
				filtermap(items, \it -> if (fgetValue(it.priorityIndex) >= threshold) it.overflowView else None())
			))], m),
			m
		))
	})
	|> (\m -> MInspect([AvailableWidth(availableWidth)], m))
	|> (\m -> eitherMap(menuButton, \mb -> {
		oi1 = either(overflowItems, make([]));
		oi = fselect(oi1, FLift(\l -> concat(menuLines, l)));
		MCols2A(m,
			MShow(
				if (menuLines != []) const(true) else fand(mb.enabled, fselectWithLast(flength(oi), FLift2(\oldLen, len -> len > b2i(oldLen > 1)))),
				MDynamicMenu(MIconButton("more_vert", nop, [], []), oi, [])
			)
		)
	}, m))
}

MOverride(overriders : [TOverrider], m : Material) -> Material {
	Material2Tropic(m, \t -> TOverride(overriders, t))
}

MExtractHTML(m : Material, setfn : (fn : () -> string) -> void) -> Material {
	Material2Tropic(m, \t -> TExtractHTML(t, setfn));
}

MExtractPNG(m : Material, setfn : (fn : Maybe<((png : string) -> void) -> void>) -> void) -> Material {
	Material2Tropic(m, \t -> TExtractPNG(t, setfn));
}

MExtractPNG2(m : Material, ready : DynamicBehaviour<bool>, setfn : (fn : Maybe<((png : string) -> void) -> void>) -> void) -> Material {
	Material2Tropic(m, \t -> TExtractPNG2(t, ready, setfn));
}

MTag2(setfn : (fn : () -> TransformMatrix) -> void, m : Material) -> Material {
	Material2Tropic(m, \t -> TTag2(setfn, t));
}

MRectangle(style : [MGraphicsStyle], size : Material) -> Material {
	MGetFocusGroup(\parent -> Material2Tropic(size, \t -> TRectangle(mgraphicsStyle2tgraphicsStyle(parent, style), t)));
}

MRounded(topLeft : double, topRight : double, bottomRight : double, bottomLeft : double, style : [MGraphicsStyle], size : Material) -> Material {
	MGetFocusGroup(\parent -> Material2Tropic(size, \t -> TRounded(topLeft, topRight, bottomRight, bottomLeft, mgraphicsStyle2tgraphicsStyle(parent, style), t)));
}