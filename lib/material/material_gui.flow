import material/material;

export {
	// Bunch of helpers to inspect sizes. Consider using MInspect also.

	MAttachBox(m : Material, box : DynamicBehaviour<WidthHeight>) -> Material;
	MAttachWidth(m : Material, width : DynamicBehaviour<double>) -> Material;
	MAttachHeight(m : Material, height : DynamicBehaviour<double>) -> Material;
	MAttachWidthHeight(m : Material, width : DynamicBehaviour<double>, height : DynamicBehaviour<double>) -> Material;

	MAttachAvailable(m : Material, box : DynamicBehaviour<WidthHeight>) -> Material;
	MAttachAvailableWidth(m : Material, width : DynamicBehaviour<double>) -> Material;
	MAttachAvailableHeight(m : Material, height : DynamicBehaviour<double>) -> Material;
	MAttachAvailableWidthHeight(m : Material, width : DynamicBehaviour<double>, height : DynamicBehaviour<double>) -> Material;

	// Inspects m, draws content
	MAttachBox2(m : Material, box : DynamicBehaviour<WidthHeight>, content : Material) -> Material;
	MAttachWidth2(m : Material, width : DynamicBehaviour<double>, content : Material) -> Material;
	MAttachHeight2(m : Material, height : DynamicBehaviour<double>, content : Material) -> Material;

	// Special cases to inspect
	MAttachBoxThrottle(m : Material, box : DynamicBehaviour<WidthHeight>, maxDelta : int) -> Material;

	MThrottleMetrics(m : Material, maxDelta : int) -> Material;

	// Helpers to set available for only width, only height, or both
	MAvailableWidth(m : Material, available : Transform<double>) -> Material;
	MAvailableHeight(m : Material, available : Transform<double>) -> Material;
	MAvailableWidthHeight(m : Material, width : Transform<double>, height : Transform<double>) -> Material;

	// MAlign helpers

	MAlignStart(m : Material) -> Material; // Align left if LTR, align right if RTL
	MAlignEnd(m : Material) -> Material;   // Align right if LTR, align left if RTL
	MAlignStartFill(m : Material) -> Material;
	MAlignEndFill(m : Material) -> Material;
	MAlignLeft(m : Material) -> Material;
	MAlignTop(m : Material) -> Material;
	MAlignRight(m : Material) -> Material;
	MAlignBottom(m : Material) -> Material;

	MAlignTopLeft(m : Material) -> Material;
	MAlignTopCenter(m : Material) -> Material;
	MAlignTopRight(m : Material) -> Material;
	MAlignCenterRight(m : Material) -> Material;
	MAlignBottomRight(m : Material) -> Material;
	MAlignBottomCenter(m : Material) -> Material;
	MAlignBottomLeft(m : Material) -> Material;
	MAlignCenterLeft(m : Material) -> Material;

	// MBorder helpers

	// MBorder with equal borders on all 4 sides
	MBorder4(border : double, m : Material) -> Material;

	MBorderTop(border : double) -> (Material) -> Material;
	MBorderBottom(border : double) -> (Material) -> Material;
	MBorderLeft(border : double) -> (Material) -> Material;
	MBorderRight(border : double) -> (Material) -> Material;
	MBorderStart(border : double) -> (Material) -> Material;
	MBorderEnd(border : double) -> (Material) -> Material;

	MBorderTopBottom(border : double) -> (Material) -> Material;
	MBorderLeftRight(border : double) -> (Material) -> Material;

	// Dynamic version of MBorder
	MBorderT(start : Transform<double>, top : Transform<double>, end : Transform<double>, bottom : Transform<double>, m : Material) -> Material;
	MBorderTA(start : Transform<double>, top : Transform<double>, end : Transform<double>, bottom : Transform<double>, m : Material) -> Material;

	// MDebug helpers

	// MDebug that shows metrics on top of the material
	MDebugMetrics(c : int, m : Material) -> Material;
	MDebugPositionScale(c : int, m : Material) -> Material;
	MDebugConstruct(tag : string, m : Material) -> Material;

	MDebugRed(m : Material) -> Material { MDebug(MColor2int(MRed(500)), m); };
	MDebugGreen(m : Material) -> Material { MDebug(MColor2int(MGreen(500)), m); };
	MDebugBlue(m : Material) -> Material { MDebug(MColor2int(MBlue(500)), m); };
	MDebugPurple(m : Material) -> Material { MDebug(MColor2int(MPurple(500)), m); };

	MDebugMetricsRed(m : Material) -> Material { MDebugMetrics(MColor2int(MRed(500)), m); };
	MDebugMetricsGreen(m : Material) -> Material { MDebugMetrics(MColor2int(MGreen(500)), m); };
	MDebugMetricsBlue(m : Material) -> Material { MDebugMetrics(MColor2int(MBlue(500)), m); };
	MDebugMetricsPurple(m : Material) -> Material { MDebugMetrics(MColor2int(MPurple(500)), m); };

	MDebugInteractive(m : Material) -> Material;

	// MGroup with zero metrics
	// Useful inside complicated components with lots of layers, metrics of which aren't used
	MGroupWithoutMetrics(g : [Material]) -> Material;
	MGroup2WithoutMetrics(g1 : Material, g2 : Material) -> Material {MGroupWithoutMetrics([g1, g2])};
	// MGroup that has metrics of the first Material
	MGroupSameMetrics(g : [Material]) -> Material;
	MGroup2SameMetrics(g1 : Material, g2 : Material) -> Material {MGroupSameMetrics([g1, g2])};

	MFixed(x : double, y : double) -> Material {TFixed(x, y)};
	MFixedX(x : double) -> Material {TFixed(x, 0.)};
	MFixedY(y : double) -> Material {TFixed(0., y)};

	MFillXY() -> Material {TFillXY()};
	MFillX() -> Material {TFillX()};
	MFillY() -> Material {TFillY()};
	MFillXH(h: double) -> Material {TFillXH(h)};
	MFillWY(w: double) -> Material {TFillWY(w)};

	MSelect2(v1 : Transform<?>, v2 : Transform<??>, fn : (?, ??) -> Material) -> Material;
	MSelect3(v1 : Transform<?>, v2 : Transform<??>, v3 : Transform<???>, fn : (?, ??, ???) -> Material) -> Material;
	MSelect4(v1 : Transform<?>, v2 : Transform<??>, v3 : Transform<???>, v4 : Transform<????>, fn : (?, ??, ???, ????) -> Material) -> Material;
	MSelect5(v1 : Transform<?>, v2 : Transform<??>, v3 : Transform<???>, v4 : Transform<????>, v5 : Transform<?????>, fn : (?, ??, ???, ????, ?????) -> Material) -> Material;

	MSelectConstantMetrics(value : Transform<?>, fn : (?) -> Material) -> Material;

	// Copies size of content to copyFn, copyFn result has no effect on overall metrics
	// If above is true result of copyFn is placed on top of content
	// Useful when you need to place TInteractive above or below another one
	MCopySize(content : Material, copyFn : (Tropic) -> Material, above : bool) -> Material;
	// Similar to MCopySize, only resulting material has metrics of copyFn
	// copyFn has two parameters: size of the content, and content itself
	MCopySize2(content : Material, copyFn : (Tropic, Material) -> Material) ->  Material;

	MProportionGrid(c : [[Pair<Transform<Factor>, Material>]]) -> Material;
	MProportionLines(c : [Pair<Transform<double>, Material>]) -> Material;
	MProportionCols(c : [Pair<Transform<double>, Material>]) -> Material;
	MProportionBaselineCols(c : [Pair<Transform<double>, Material>]) -> Material;
	MProportionColsA(c : [Pair<Transform<double>, Material>]) -> Material;

	MSizedWidth(width : Transform<double>, height : double) -> Material;
	MSizedHeight(width : double, height : Transform<double>) -> Material;

	// Common helpers of centering a number of tropics
	MColsXCenter(cols : [Material]) -> Material;
	MColsYCenter(cols : [Material]) -> Material;
	MBaselineColsXCenter(cols : [Material]) -> Material;
	MBaselineColsYCenter(cols : [Material]) -> Material;
	MColsYCenterA(cols : [Material]) -> Material;
	MBaselineColsYCenterA(cols : [Material]) -> Material;
	MLinesXCenter(lines : [Material]) -> Material;
	MLinesYCenter(lines : [Material]) -> Material;
	MBaselineLinesXCenter(lines : [Material]) -> Material;
	MBaselineLinesYCenter(lines : [Material]) -> Material;
	// Deprecated. Use MColsYCenter instead.
	MColsCenterY(items : [Material]) -> Material {MColsYCenter(items)};

	// Common helpers for creating groups of elements with the same available width or height
	MColsSameWidth(cols : [Material]) -> Material;
	MColsSameHeight(cols : [Material]) -> Material;
	MLinesSameWidth(lines : [Material]) -> Material;
	MLinesSameHeight(lines : [Material]) -> Material;

	// Same as MLines2, only m1 is above m2 in zorder
	// Useful if you have for example a toolbar with shadow that has to overlap content below
	MLines2InvertZorder(m1 : Material, m2 : Material) -> Material;

	// if the content fits in the box then it returns the content
	// if the content does not fit then it returns a zoomed out content
	// the final metrics is a metrics of the final content
	MZoomToFit(content : Material, box : Material) -> Material;
	MScaleXY(factor : double) -> (Material) -> Material;
	// Helpers for turning Material
	MRotate90(m : Material) -> Material;
	MRotate90Left(m : Material) -> Material;

	MCropWidth(content : Material, width : Material) -> Material;
	MCropHeight(content : Material, height : Material) -> Material;

	MEvenGrid(content : [[Material]]) -> Material;

	MFixSizeKeepBaseline(m : Material, size : Material) -> Material;
	MBaseline(baseline : Transform<double>, m : Material) -> Material;

	// Dynamic version of MFrame
	MFrameT(margin : Transform<double>, radius : Transform<double>, style : [TGraphicsStyle], box : Material) -> Material;
	MFrameCustom(l : double, tl : double, tlRounded : bool, t : double, tr : double, trRounded : bool, r : double,
		br : double, brRounded : bool, b : double, bl : double, blRounded : bool, style : [TGraphicsStyle], box : Material) -> Material;

	// Helper for dynamic text
	MDynamicText(text : Transform<string>, style : [MParagraphStyle]) -> Material;

	// Allows to write html-string like "this is <i>italic</i> and <b>bold</b> text".
	// It works only in JS
	MHTMLText(text : string, style : [MTextStyle]) -> Material;
	MHTMLDynamicText(text : Transform<string>, style : [MParagraphStyle]) -> Material;

	// Show text and progressbar below
 	MLoading(text : string) -> Material;

	// Simplified version of MTransformTAcc
	MTransformTAcc2(fn : ((Material) -> TAcc) -> TAcc) -> Material;

	MConstructRenderable(constructors : [() -> () -> void], m : Material) -> Material;

	// Zoom material if its metrics are bigger than maxWH
	MZoomMax(m : Material, maxWH : Transform<WidthHeight>) -> Material;
	// Zoom material if its width is bigger than maxWidth
	MZoomMaxWidth(m : Material, maxWidth : Transform<double>) -> Material;
	// Zoom material if its height is bigger than maxHeight
	MZoomMaxHeight(m : Material, maxHeight : Transform<double>) -> Material;

	// Helpers to make Material not transparent for events
	disableMMouseWheelBelow(content : Material) -> Material;
	disableMInteractivesBelow(content : Material) -> Material;

	// Helper to create event blocker layer above element
	blockMInteractives(content : Material) -> Material;

	MMouseWheelInteractive(m : Material, deltaX : (double) -> bool, deltaY : (double) -> bool) -> Material;

	M3DStage(scene : F3DObject, camera : F3DObject, size : Material, style : [F3DStageStyle]) -> Material;

	// Draws content with 'canvas' renderer
	// Works only in js with 'html' renderer, for other targets identical to regular clip
	// WARNING: Doesn't support native widgets making it applicable only to groups of graphical objects
	MCanvas(content : Material) -> Material;

	MDecorator(m : Material, decorators : [Pair<Transform<bool>, (Transform<WidthHeight>) -> Material>], above : bool) -> Material;

	// Area with borders equal to device notch or other screen inbounds
	MSafeArea(m : Material) -> Material;

	MSafeAreaStart(m : Material) -> Material;
	MSafeAreaTop(m : Material) -> Material;
	MSafeAreaEnd(m : Material) -> Material;
	MSafeAreaBottom(m : Material) -> Material;

	MMoveClip(m : Material, fn : (Tropic) -> void) -> Material;

	// Takes Materials with its priority level.
	// When there is not enough available width, hides elements, starting from low-prority.
	MIfFitsCols(items0 : Transform<[MIfFitsColsItem]>, style : [MIfFitsColsStyle]) -> Material;

		MIfFitsColsItem(material : Material, style : [MIfFitsColsItemStyle]);
			MIfFitsColsItemStyle ::= MIfFitsColsItemPriority, MIfFitsColsOverflowView;
				// Medium priority (5) by default.
				MIfFitsColsItemPriority(priority : int);
				// Defines that item should be visible into the 'overflow' items menu.
				MIfFitsColsOverflowView(view : MMenuLine);
		MIfFitsColsIconButton(icon : string, onClick : () -> void, priority : int, menuTitle : string) -> MIfFitsColsItem {
			MIfFitsColsItem(MIconButton(icon, onClick, [], []), [
				MIfFitsColsItemPriority(priority),
				MIfFitsColsOverflowView(MMenuSingleLine(menuTitle, []))
			])
		}

		MIfFitsColsStyle ::= MIfFitsColsFn, MIfFitsColsOverflowItems, MIfFitsColsMenuButton;
			// Defines how items should be wrapped into cols. MCols by default. MColsA, MBaselineColsA are other good choices
			MIfFitsColsFn(fn : ([Material]) -> Material);
			// Returns overflowView of hidden items
			MIfFitsColsOverflowItems(items : DynamicBehaviour<[MMenuLine]>);
			// Collect hidden items and add them to the menu
			MIfFitsColsMenuButton(enabled : Transform<bool>);

	MIfFitsColsYCenterA(items : Transform<[MIfFitsColsItem]>) -> Material;

	// Shows fullSizeContent only if available space is greater than minimum size required to show it
	// Otherwise shows reducedSizeContent
	MIfFits(fullSizeContent : Material, reducedSizeContent : Material) -> Material;
	MIfFitsWidth(fullSizeContent : Material, reducedSizeContent : Material) -> Material;
	MIfFitsWidthDelay(fullSizeContent : Material, reducedSizeContent : Material, delay : int) -> Material;
	MIfFitsHeight(fullSizeContent : Material, reducedSizeContent : Material) -> Material;

	// Shows content only if available space is greater than minimum size required to show it
	MShowIfFits(content : Material) -> Material;
	MShowIfFitsWidth(content : Material) -> Material;
	MShowIfFitsHeight(content : Material) -> Material;

	MOverride(overriders : [TOverrider], m : Material) -> Material;

	// JS HTML Renderer: Extract rendered static html from the clip
	// Use wrapFlowHTML to wrap resulting html string with root tags, flow stylesheet and Roboto webfonts
	MExtractHTML(m : Material, setfn : (fn : () -> string) -> void) -> Material;
}

// Inner helpers
// DO NOT EXPORT

Material2Tropic(m : Material, fn : (tr : Tropic) -> Material) -> Material {
	MGetFocusGroup(\p -> MGetMaterial2Tropic(\m2t -> fn(m2t(m, p))))
}

Material2Tropic2(m1 : Material, m2 : Material, fn : (tr1 : Tropic, tr2 : Tropic) -> Material) -> Material {
	MGetFocusGroup(\p -> MGetMaterial2Tropic(\m2t -> fn(m2t(m1, p), m2t(m2, p))))
}

Material2TropicA(m : [Material], fn : (tr : [Tropic]) -> Material) -> Material {
	MGetFocusGroup(\p -> MGetMaterial2Tropic(\m2t -> fn(map(m, \_m -> m2t(_m, p)))))
}

MGroupWithoutMetrics(m : [Material]) -> Material {
	Material2TropicA(m, \tr -> TGroupWithoutMetrics(tr))
}

MGroupSameMetrics(m : [Material]) -> Material {
	Material2TropicA(m, \tr -> TGroupSameMetrics(tr))
}

MSelect2(v1 : Transform<?>, v2 : Transform<??>, fn : (?, ??) -> Material) -> Material {
	t = fselect2(v1, v2, FLift2(fn));

	if (isFConst(t)) {
		// If we are constant, let's avoid the mutable altogether
		fgetValue(t)
	} else {
		MMutable(t);
	}
}

MSelect3(v1 : Transform<?>, v2 : Transform<??>, v3 : Transform<???>, fn : (?, ??, ???) -> Material) -> Material {
	t = fselect3(v1, v2, v3, fn);

	if (isFConst(t)) {
		// If we are constant, let's avoid the mutable altogether
		fgetValue(t)
	} else {
		MMutable(t);
	}
}

MSelect4(v1 : Transform<?>, v2 : Transform<??>, v3 : Transform<???>, v4 : Transform<????>, fn : (?, ??, ???, ????) -> Material) -> Material {
	t = fselect4(v1, v2, v3, v4, fn);

	if (isFConst(t)) {
		// If we are constant, let's avoid the mutable altogether
		fgetValue(t)
	} else {
		MMutable(t);
	}
}

MSelect5(v1 : Transform<?>, v2 : Transform<??>, v3 : Transform<???>, v4 : Transform<????>, v5 : Transform<?????>, fn : (?, ??, ???, ????, ?????) -> Material) -> Material {
	t = fselect5(v1, v2, v3, v4, v5, fn);

	if (isFConst(t)) {
		// If we are constant, let's avoid the mutable altogether
		fgetValue(t)
	} else {
		MMutable(t);
	}
}

MCopySize(content : Material, copyFn : (Tropic) -> Material, above : bool) -> Material {
	MGetFocusGroup(\p -> MGetMaterial2Tropic(\m2t ->  TCopySize(m2t(content, p), \sz -> m2t(copyFn(sz), p), above)))
}

MCopySize2(content : Material, copyFn : (Tropic, Material) -> Material) -> Material {
	MGetFocusGroup(\p -> MGetMaterial2Tropic(\m2t ->  TCopySize2(m2t(content, p), \sz, tr -> m2t(copyFn(sz, tr), p))))
}

MTransformTAcc2(fn : ((Material) -> TAcc) -> TAcc) -> Material {
	MTransformTAcc(\t2a, p, s, mo -> fn(\mat -> t2a(mat, p, s, mo)))
}

MAttachBox(m : Material, box : DynamicBehaviour<WidthHeight>) -> Material {
	Material2Tropic(m, \tr -> TAttachBox(tr, box));
}

MAttachWidth(m : Material, width : DynamicBehaviour<double>) -> Material {
	Material2Tropic(m, \tr -> TAttachWidth(tr, width));
}

MAttachHeight(m : Material, height : DynamicBehaviour<double>) -> Material {
	Material2Tropic(m, \tr -> TAttachHeight(tr, height));
}

MAttachWidthHeight(m : Material, width : DynamicBehaviour<double>, height : DynamicBehaviour<double>) -> Material {
	Material2Tropic(m, \tr -> TAttachWidthHeight(tr, width, height));
}

MAttachAvailable(m : Material, box : DynamicBehaviour<WidthHeight>) -> Material {
	Material2Tropic(m, \tr -> TAttachAvailable(tr, box));
}

MAttachAvailableWidth(m : Material, width : DynamicBehaviour<double>) -> Material {
	Material2Tropic(m, \tr -> TAttachAvailableWidth(tr, width));
}

MAttachAvailableHeight(m : Material, height : DynamicBehaviour<double>) -> Material {
	Material2Tropic(m, \tr -> TAttachAvailableHeight(tr, height));
}

MAttachAvailableWidthHeight(m : Material, width : DynamicBehaviour<double>, height : DynamicBehaviour<double>) -> Material {
	Material2Tropic(m, \tr -> TAttachAvailableWidthHeight(tr, width, height));
}

MAttachBox2(m : Material, box : DynamicBehaviour<WidthHeight>, c : Material) -> Material {
	Material2Tropic2(m, c, \tr1, tr2 -> TAttachBox2(tr1, box, tr2));
}

MAttachWidth2(m : Material, width : DynamicBehaviour<double>, c : Material) -> Material {
	Material2Tropic2(m, c, \tr1, tr2 -> TAttachWidth2(tr1, width, tr2));
}

MAttachHeight2(m : Material, height : DynamicBehaviour<double>, c : Material) -> Material {
	Material2Tropic2(m, c, \tr1, tr2 -> TAttachHeight2(tr1, height, tr2));
}

MAttachBoxThrottle(m : Material, box : DynamicBehaviour<WidthHeight>, maxDelta : int) -> Material {
	Material2Tropic(m, \tr -> TAttachBoxThrottle(tr, box, maxDelta));
}

MThrottleMetrics(m : Material, maxDelta : int) -> Material {
	Material2Tropic(m, \tr -> TThrottleMetrics(tr, maxDelta));
}

MProportionGrid(c : [[Pair<Transform<Factor>, Material>]]) -> Material {
	MGetFocusGroup(\p -> MGetMaterial2Tropic(\m2t -> TProportionGrid(map(c, \r -> map(r, \pr -> Pair(pr.first, m2t(pr.second, p)))))))
}

MProportionLines(c : [Pair<Transform<double>, Material>]) -> Material {
	MGetFocusGroup(\p -> MGetMaterial2Tropic(\m2t -> TProportionLines(map(c, \pr -> Pair(pr.first, m2t(pr.second, p))))))
}

MProportionCols(c : [Pair<Transform<double>, Material>]) -> Material {
	MGetFocusGroup(\p -> MGetMaterial2Tropic(\m2t -> TProportionCols(map(c, \pr -> Pair(pr.first, m2t(pr.second, p))))))
}

MProportionBaselineCols(c : [Pair<Transform<double>, Material>]) -> Material {
	MGetFocusGroup(\p -> MGetMaterial2Tropic(\m2t -> TProportionBaselineCols(map(c, \pr -> Pair(pr.first, m2t(pr.second, p))))))
}

MProportionColsA(c : [Pair<Transform<double>, Material>]) -> Material {
	MGetFocusGroup(\p -> MGetMaterial2Tropic(\m2t -> TProportionColsA(map(c, \pr -> Pair(pr.first, m2t(pr.second, p))), p.rtl)))
}

MSizedWidth(width : Transform<double>, height : double) -> Material {
	TSizedWidth(width, height);
}

MSizedHeight(width : double, height : Transform<double>) -> Material {
	TSizedHeight(width, height);
}

MColsXCenter(m : [Material]) -> Material {
	Material2TropicA(m, \tr -> TColsXCenter(tr))
}

MColsYCenter(m : [Material]) -> Material {
	Material2TropicA(m, \tr -> TColsYCenter(tr))
}

MBaselineColsXCenter(m : [Material]) -> Material {
	Material2TropicA(m, \tr -> TBaselineColsXCenter(tr))
}

MBaselineColsYCenter(m : [Material]) -> Material {
	Material2TropicA(m, \tr -> TBaselineColsYCenter(tr))
}

MColsYCenterA(m : [Material]) -> Material {
	Material2TropicA(m, \tr -> TColsYCenterA(tr))
}

MBaselineColsYCenterA(m : [Material]) -> Material {
	Material2TropicA(m, \tr -> TBaselineColsYCenterA(tr))
}

MLinesXCenter(m : [Material]) -> Material {
	Material2TropicA(m, \tr -> TLinesXCenter(tr))
}

MLinesYCenter(m : [Material]) -> Material {
	Material2TropicA(m, \tr -> TLinesYCenter(tr))
}

MBaselineLinesXCenter(m : [Material]) -> Material {
	Material2TropicA(m, \tr -> TBaselineLinesXCenter(tr))
}

MBaselineLinesYCenter(m : [Material]) -> Material {
	Material2TropicA(m, \tr -> TBaselineLinesYCenter(tr))
}

MColsSameWidth(m : [Material]) -> Material {
	Material2TropicA(m, \tr -> TColsSameWidth(tr))
}

MColsSameHeight(m : [Material]) -> Material {
	Material2TropicA(m, \tr -> TColsSameHeight(tr))
}

MLinesSameWidth(m : [Material]) -> Material {
	Material2TropicA(m, \tr -> TLinesSameWidth(tr))
}

MLinesSameHeight(m : [Material]) -> Material {
	Material2TropicA(m, \tr -> TLinesSameHeight(tr))
}

MLines2InvertZorder(m1 : Material, m2 : Material) -> Material {
	MCopySize2(
		m1,
		\sz, c -> MGroup2(MLines2(sz, m2), c)
	)
}

MEvenGrid(content : [[Material]]) -> Material {
	MGetFocusGroup(\p -> MGetMaterial2Tropic(\m2t -> TEvenGrid(map(content, \c -> map(c, \i -> m2t(i, p))))))
}

MSelectConstantMetrics(value : Transform<?>, fn : (?) -> Material) -> Material {
	MTransformTAcc2(\t2a -> {
		bf = t2a(MMutable(fselect(value, FLift(fn))));

		wd = bf.metrics.width |> fgetValue |> const;
		hgt = bf.metrics.height |> fgetValue |> const;

		TAcc(
			bf.form,
			TFormMetrics(
				wd,
				hgt,
				if (bf.yConstant) bf.metrics.baseline |> fgetValue |> const
				else bf.metrics.baseline
			),
			if (bf.xConstant) wd else bf.minWidth,
			if (bf.yConstant) hgt else bf.minHeight,
			if (bf.xConstant) wd else bf.maxWidth,
			if (bf.yConstant) hgt else bf.maxHeight,
			if (bf.xConstant) zero else bf.xFillers,
			if (bf.yConstant) zero else bf.yFillers,
			bf.addFillers,
			bf.xConstant,
			bf.yConstant,
			bf.disposers
		)
	})
}

MAvailableWidth(m : Material, available : Transform<double>) -> Material {
	Material2Tropic(m, \tr -> TAvailableWidth(tr, available))
}

MAvailableHeight(m : Material, available : Transform<double>) -> Material {
	Material2Tropic(m, \tr -> TAvailableHeight(tr, available))
}

MAvailableWidthHeight(m : Material, width : Transform<double>, height : Transform<double>) -> Material {
	Material2Tropic(m, \tr -> TAvailableWidthHeight(tr, width, height))
}

MZoomToFit(content : Material, box : Material) -> Material {
	cwh = makeWH();
	MTweak([TFitZoom(true, true)], MInspect([ISize(cwh)], content), MMinimumGroup2(TSized(cwh), box));
}

MScaleXY(factor : double) -> (Material) -> Material {
	\m -> MScale(ffactor2(const(factor)), m)
}

MCropWidth(content : Material, width : Material) -> Material {
	MGetFocusGroup(\p -> MGetMaterial2Tropic(\m2t -> TCropSizeX(m2t(content, p), m2t(width, p))));
}

MCropHeight(content : Material, height : Material) -> Material {
	MGetFocusGroup(\p -> MGetMaterial2Tropic(\m2t -> TCropSizeY(m2t(content, p), m2t(height, p))));
}

MAlignStart(m : Material) -> Material {
	MGetFocusGroup(\p -> if (p.rtl) MAlignRight(m) else m)
}

MAlignEnd(m : Material) -> Material {
	MGetFocusGroup(\p -> if (!p.rtl) MAlignRight(m) else m)
}

MAlignStartFill(m : Material) -> Material {
	MGetFocusGroup(\p -> if (p.rtl) MAlignRight(m) else MAlignLeft(m))
}

MAlignEndFill(m : Material) -> Material {
	MGetFocusGroup(\p -> if (!p.rtl) MAlignRight(m) else MAlignLeft(m))
}

MAlignLeft(m : Material) -> Material {
	MTweak([TAlign(const(0.0), const(0.0))], m, TFillX())
}

MAlignTop(m : Material) -> Material {
	MTweak([TAlign(const(0.0), const(0.0))], m, TFillY())
}

MAlignRight(m : Material) -> Material {
	MTweak([TAlign(const(1.0), const(0.0))], m, TFillX())
}

MAlignBottom(m : Material) -> Material {
	MTweak([TAlign(const(0.0), const(1.0))], m, TFillY())
}

MAlignTopLeft(m : Material) -> Material {
	MTweak([TAlign(const(0.0), const(0.0))], m, TFillXY())
}

MAlignTopCenter(m : Material) -> Material {
	MTweak([TAlign(const(0.5), const(0.0))], m, TFillXY())
}

MAlignTopRight(m : Material) -> Material {
	MTweak([TAlign(const(1.0), const(0.0))], m, TFillXY())
}

MAlignCenterRight(m : Material) -> Material {
	MTweak([TAlign(const(1.0), const(0.5))], m, TFillXY())
}

MAlignBottomRight(m : Material) -> Material {
	MTweak([TAlign(const(1.0), const(1.0))], m, TFillXY())
}

MAlignBottomCenter(m : Material) -> Material {
	MTweak([TAlign(const(0.5), const(1.0))], m, TFillXY())
}

MAlignBottomLeft(m : Material) -> Material {
	MTweak([TAlign(const(0.0), const(1.0))], m, TFillXY())
}

MAlignCenterLeft(m : Material) -> Material {
	MTweak([TAlign(const(0.0), const(0.5))], m, TFillXY())
}

MBorderTop(border : double) -> (Material) -> Material {
	\m -> MBorder(0., border, 0., 0., m)
}

MBorderBottom(border : double) -> (Material) -> Material {
	\m -> MBorder(0., 0., 0., border, m)
}

MBorderLeft(border : double) -> (Material) -> Material {
	\m -> MBorder(border, 0., 0., 0., m)
}

MBorderRight(border : double) -> (Material) -> Material {
	\m -> MBorder(0., 0., border, 0., m)
}

MBorderStart(border : double) -> (Material) -> Material {
	\m -> MBorderA(border, 0., 0., 0., m)
}

MBorderEnd(border : double) -> (Material) -> Material {
	\m -> MBorderA(0., 0., border, 0., m)
}

MBorderTopBottom(border : double) -> (Material) -> Material {
	\m -> MBorder(0., border, 0., border, m)
}

MBorderLeftRight(border : double) -> (Material) -> Material {
	\m -> MBorder(border, 0., border, 0., m)
}

MFixSizeKeepBaseline(m : Material, size : Material) -> Material {
	MTransformTAcc2(\t2a -> {
		bf = t2a(m);
		sf = t2a(size);

		TAcc(
			bf.form,
			TFormMetrics(
				sf.metrics.width,
				sf.metrics.height,
				bf.metrics.baseline
			),
			sf.minWidth,
			sf.minHeight,
			sf.maxWidth,
			sf.maxHeight,
			sf.xFillers,
			sf.yFillers,
			sf.addFillers,
			sf.xConstant,
			sf.yConstant && isFConst(bf.metrics.baseline),
			sf.disposers
		)
	})
}

MBaseline(baseline : Transform<double>, m : Material) -> Material {
	Material2Tropic(m, \tr -> TBaseline(baseline, tr))
}

MBorderT(start : Transform<double>, top : Transform<double>, end : Transform<double>, bottom : Transform<double>, m : Material) -> Material {
	Material2Tropic(m, \tr -> TBorderT(start, top, end, bottom, tr))
}

MBorderTA(start : Transform<double>, top : Transform<double>, end : Transform<double>, bottom : Transform<double>, m : Material) -> Material {
	Material2Tropic(m, \tr -> TBorderTDir(start, top, end, bottom, tr, getDefaultRtl()))
}

MFrameT(margin : Transform<double>, radius : Transform<double>, style : [TGraphicsStyle], box : Material) -> Material {
	Material2Tropic(box, \tr -> TFrameT(margin, radius, const(style), tr))
}

MFrameCustom(l : double, tl : double, tlRounded : bool, t : double, tr : double, trRounded : bool, r : double,
	br : double, brRounded : bool, b : double, bl : double, blRounded : bool, style : [TGraphicsStyle], box : Material) -> Material {
	Material2Tropic(box, \trop -> TFrameCustom(l, tl, tlRounded, t, tr, trRounded, r,	br, brRounded, b, bl, blRounded, style, trop))
}

MDynamicText(text : Transform<string>, style : [MParagraphStyle]) -> Material {
	if (text == const(""))
		TEmpty()
	else
		MDynamicParagraph(text, replaceStruct(style, extractStruct(style, MWidth(0.0))));
}

MHTMLText(text : string, style : [MTextStyle]) -> Material {
	MText(text, replaceStruct(style, EscapeHTML(false)));
}

MHTMLDynamicText(text : Transform<string>, style : [MParagraphStyle]) -> Material {
	MDynamicText(text, replaceStruct(style, EscapeHTML(false)));
}

MLoading(text : string) -> Material {
	label = MText(text, [])
		|> MCenterX
		|> MBorderLeftRight(8.);

	MAvailable(
		MGroup2(
			MZoomToFill(MProgressBar([MBlue(200), MProgressBackgroundColor(MWhite()), WidthHeight(100.0, 10.0)]), TFillXY(), false) |> MCenterX,
			TDisplay("Label") |> MCenterX
		),
		TGhost("Label")
	)
	|> (\m -> MLet("Label", label, m))
}

MDebugMetrics(c : int, m : Material) -> Material {
	Material2Tropic(m, \tr -> TDebugMetrics(c, tr))
}

MDebugPositionScale(c : int, m : Material) -> Material {
	Material2Tropic(m, \tr -> TDebugPositionScale(c, tr))
}

MDebugConstruct(tag : string, m : Material) -> Material {
	Material2Tropic(m, \tr -> TDebugConstruct(tag, tr))
}

MDebugInteractive(m : Material) -> Material {
	Material2Tropic(m, TDebugInteractive)
}

MBorder4(border : double, m : Material) -> Material {
	Material2Tropic(m, \tr -> TBorder4(border, tr))
}

MRotate90(m : Material) -> Material {
	Material2Tropic(m, TRotate90)
}

MRotate90Left(m : Material) -> Material {
	Material2Tropic(m, TRotate90Left)
}

MConstructRenderable(constructors : [() -> () -> void], m : Material) -> Material {
	Material2Tropic(m, \tr -> TConstructRenderable(constructors, tr));
}

MZoomMax(m : Material, maxWH : Transform<WidthHeight>) -> Material {
	Material2Tropic(m, \tr -> TZoomMax(tr, maxWH))
}

MZoomMaxWidth(m : Material, maxWidth : Transform<double>) -> Material {
	Material2Tropic(m, \tr -> TZoomMaxWidth(tr, maxWidth))
}

MZoomMaxHeight(m : Material, maxHeight : Transform<double>) -> Material {
	Material2Tropic(m, \tr -> TZoomMaxHeight(tr, maxHeight))
}

disableMMouseWheelBelow(m : Material) -> Material {
	Material2Tropic(m, disableMouseWheelBelow)
}

disableMInteractivesBelow(m : Material) -> Material {
	Material2Tropic(m, disableInteractivesBelow)
}

blockMInteractives(m : Material) -> Material {
	Material2Tropic(m, blockInteractives)
}

MMouseWheelInteractive(m : Material, deltaX : (double) -> bool, deltaY : (double) -> bool) -> Material {
	MGetManager(\manager -> Material2Tropic(m, \tr -> TMouseWheelInteractive(manager.manager, tr, deltaX, deltaY)));
}

M3DStage(scene : F3DObject, camera : F3DObject, size : Material, style : [F3DStageStyle]) -> Material {
	Material2Tropic(size, \sz -> T3DStage(scene, camera, sz, style));
}

MCanvas(content : Material) -> Material {
	Material2Tropic(content, TCanvas)
}

MDecorator(m : Material, decorators : [Pair<Transform<bool>, (Transform<WidthHeight>) -> Material>], above : bool) -> Material {
	MGetFocusGroup(\p -> MGetMaterial2Tropic(\m2t ->
		TDecorator(
			m2t(m, p),
			map(decorators, \d -> Pair(d.first, \wh -> m2t(d.second(wh), p))),
			above
		)
	));
}

MSafeArea(m : Material) -> Material {
	if (mobile)
		MGetManager(\manager -> {
			sa = fselect(manager.stageWH, FLift(\__ -> getSafeArea()));

			MBorderTA(
				felementAt(sa, const(0), const(0.0)),
				felementAt(sa, const(1), const(0.0)),
				felementAt(sa, const(2), const(0.0)),
				felementAt(sa, const(3), const(0.0)),
				m
			);
		})
	else
		m;
}

MSafeAreaStart(m : Material) -> Material {
	if (mobile)
		MGetManager(\manager -> {
			sa = fselect(manager.stageWH, FLift(\__ -> getSafeArea()));

			MBorderTA(
				felementAt(sa, const(0), const(0.0)),
				zero,
				zero,
				zero,
				m
			);
		})
	else
		m;
}

MSafeAreaTop(m : Material) -> Material {
	if (mobile)
		MGetManager(\manager -> {
			sa = fselect(manager.stageWH, FLift(\__ -> getSafeArea()));

			MBorderTA(
				zero,
				felementAt(sa, const(1), const(0.0)),
				zero,
				zero,
				m
			);
		})
	else
		m;
}

MSafeAreaEnd(m : Material) -> Material {
	if (mobile)
		MGetManager(\manager -> {
			sa = fselect(manager.stageWH, FLift(\__ -> getSafeArea()));

			MBorderTA(
				zero,
				zero,
				felementAt(sa, const(2), const(0.0)),
				zero,
				m
			);
		})
	else
		m;
}

MSafeAreaBottom(m : Material) -> Material {
	if (mobile)
		MGetManager(\manager -> {
			sa = fselect(manager.stageWH, FLift(\__ -> getSafeArea()));

			MBorderTA(
				zero,
				zero,
				zero,
				felementAt(sa, const(3), const(0.0)),
				m
			);
		})
	else
		m;
}

MMoveClip(m : Material, fn : (Tropic) -> void) -> Material {
	Material2Tropic(m, \t -> TMoveClip(t, fn))
}

MIfFits(fullSizeContent : Material, reducedSizeContent : Material) -> Material {
	Material2Tropic(fullSizeContent, \fs -> Material2Tropic(reducedSizeContent, \rs -> TIfFits(fs, rs)))
}

MIfFitsWidth(fullSizeContent : Material, reducedSizeContent : Material) -> Material {
	Material2Tropic(fullSizeContent, \fs -> Material2Tropic(reducedSizeContent, \rs -> TIfFitsWidth(fs, rs)))
}

MIfFitsWidthDelay(fullSizeContent : Material, reducedSizeContent : Material, delay : int) -> Material {
	Material2Tropic(fullSizeContent, \fs -> Material2Tropic(reducedSizeContent, \rs -> TIfFitsWidthDelay(fs, rs, delay)))
}

MIfFitsHeight(fullSizeContent : Material, reducedSizeContent : Material) -> Material {
	Material2Tropic(fullSizeContent, \fs -> Material2Tropic(reducedSizeContent, \rs -> TIfFitsHeight(fs, rs)))
}

MShowIfFits(content : Material) -> Material {
	Material2Tropic(content, TShowIfFits)
}

MShowIfFitsWidth(content : Material) -> Material {
	Material2Tropic(content, TShowIfFitsWidth)
}

MShowIfFitsHeight(content : Material) -> Material {
	Material2Tropic(content, TShowIfFitsHeight)
}

MIfFitsColsItemInner : (
	material : Material,
	minWidth : DynamicBehaviour<double>,
	priorityIndex : DynamicBehaviour<int>,
	priority : int,
	overflowView : Maybe<MMenuLine>
);

MIfFitsColsYCenterA(items0 : Transform<[MIfFitsColsItem]>) -> Material {
	MIfFitsCols(items0, [MIfFitsColsFn(MColsYCenterA)])
}

MIfFitsCols(items0 : Transform<[MIfFitsColsItem]>, style : [MIfFitsColsStyle]) -> Material {
	availableWidth = make(0.);
	colsFn = extractStruct(style, MIfFitsColsFn(\arr -> MCols(arr))).fn;

	overflowItems0 = tryExtractStruct(style, MIfFitsColsOverflowItems(make([])));
	menuButton = tryExtractStruct(style, MIfFitsColsMenuButton(const(false)));
	overflowItems : Maybe<DynamicBehaviour<[MMenuLine]>> = eitherMap(overflowItems0, \oi -> Some(oi.items), maybeMap(menuButton, \__ -> make([])));

	MSelect(items0, \itms -> {
		items = map(itms, \it -> 
			MIfFitsColsItemInner(
				it.material,
				make(0.),
				make(-1),
				extractStruct(it.style, MIfFitsColsItemPriority(5)).priority,
				maybeMap(tryExtractStruct(it.style, MIfFitsColsOverflowView(MMenuSingleLine("", []))), \v -> v.view)
			)
		);

		priorityOrder = sortCustom(
			items,
			\it -> it.priority,
			false
		);

		iteri(priorityOrder, \i, it -> nextDistinct(it.priorityIndex, i));

		showThreshold =
			fselect(fstall(availableWidth, 0), FLift(\av ->
				foldi(priorityOrder, Pair(0., length(priorityOrder)), \i, acc, it -> {
					s = acc.first + fgetValue(it.minWidth);
					Pair(s, if (acc.first <= av && s > av) i else acc.second)
				}).second
			));

		map(items, \it ->
			MInspect([IMinWidth(it.minWidth)], it.material)
			|> (\m -> MShow(flessi(it.priorityIndex, showThreshold), m))
		)
		|> colsFn
		|> (\m -> eitherMap(overflowItems, \oi ->
			MConstruct([makeSubscribe2(showThreshold, \threshold -> nextDistinct(oi,
				filtermap(items, \it -> if (fgetValue(it.priorityIndex) >= threshold) it.overflowView else None())
			))], m),
			m
		))
	})
	|> (\m -> MInspect([AvailableWidth(availableWidth)], m))
	|> (\m -> eitherMap(menuButton, \mb -> {
		oi = either(overflowItems, make([]));
		MCols2(m,
			MShow(
				fand(mb.enabled, fselectWithLast(flength(oi), FLift2(\oldLen, len -> len > b2i(oldLen > 1)))),
				MDynamicMenu(MIconButton("more_vert", nop, [], []), oi, [])
			)
		)
	}, m))
}

MOverride(overriders : [TOverrider], m : Material) -> Material {
	Material2Tropic(m, \t -> TOverride(overriders, t))
}

MExtractHTML(m : Material, setfn : (fn : () -> string) -> void) -> Material {
	Material2Tropic(m, \t -> TExtractHTML(t, setfn))
}