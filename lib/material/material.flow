import date;
import tropic/trawbutton;
import tropic/ttextinput;
import tropic/tscroll;
import tropic/tflexiblegrid;
import tropic/tautocomplete_types;
import tropic/tropic_dragdrop;
import tropic/tparagraph;
import material/internal/types;
import material/tests/wigi/uitests_support;
import pebbles/pebbles;

import material/iconic_font;

forbid tropic/tropic_ui;	// Too much stuff comes with this, bloating the binary, so avoid this

export {
	Material ::= MText, MIcon, MLetterIcon, MTextButton, MTextClickable, MIconButton, MFloatingButton, MBackground,
			MList, MDropDown, MMultiSelectDropDown, MDatePicker, MTimePicker, MColorPicker, MColorPickerMultiSelect, MAvatar,
			MProgressBar, MProgressCircle, MProgressBarDeterm, MProgressCircleDeterm,
			MRipple, MRippleCircle, MSeparator, MSeparatorSize, MBaselineCols, MBaselineLines, MGrid,
			MLines, MCols, MGroup, MLines2, MCols2, MGroup2, MBaselineCols2, MBaselineLines2, MMinimumGroup2, MSubtractGroup2,
			MBaselineOffset, MBorder, MLet, MLetMany, MLetAvailable, MAvailable, MAlpha, MCrop, MCropSize, MVisible, MShow,
			MIf, MIfPreRender, MIfLazy, MInteractive, MCursor, MConstruct, MCreate2, MDispose, MTranslate, MRotate, MAttach, MFixSize,
			MCenter, MCenterIn, MCenterX, MCenterY, MCenterXIn, MCenterYIn, MCase, MScroll, MChart, MDynamicChart,
			MCheckBox, MRadio, MSlider, MSwitchControl, MIconToggle, MMutable,
			MTooltip, MToolbar, MAppStructure, MSideNav,
			MCard, MExpander, MAnimatedExpander, MMenu, MDynamicMenu, MDropDownMenu, MMenuPanel, MGridList, MFlexibleGrid, MDynamicGrid, MRecyclerGrid, MTree,
			MEllipsis, MEllipsisText, MSplitter,
			MShadow, MShadowShape, MZoom, MZoomToFill, MScale, MDebug, MSize, MSizeOf, MMovable,
			MResizable, MDraggable, MDropSpot, MDropSpot2, MNavigation,
			MImageMap, MMask, MPicture, MExplicitTheme, MChip, MScaleAvailable, MShift, MComponentGroup, MComponentGroupMutable,
			MDynamicList, MDynamicTabs, MFullWindow, MFullScreen, MSwipe, MGetManager, MGetFocusGroup, MGetMaterial2Tropic,
			MAccess, MPositionScale, MRealHTML, MVideoPlayer, MFilter, MGraphics,

			MBottomNav, MDragDrop, MTransformTAcc,

			MStepper, MCarousel,

			MFrame, MRawButton, MDynamicParagraph, MTextInput, MSmallEditDialog, MDynamicDataTable, MAutoComplete, MTweak,

			MMouseDownAround, MClickable, MComponent, MReorderGrids, MReorderGrid, MDynamicGroup2, MInspect, MBackdrop,

			MAnimator,

			Tropic;

		MButtonState ::= MouseOnDownAroundState, MFocusEnabled, MForceFocusEnabled, MFocusOnPrevious, MShortcut, MShortcutKeyCodeComparison, MShortcutPreventDefault, MDefaultShortcutEnabled,
			AccessRole, FAccessAttribute, MRippleStyle, MFocusOnDown, MHighlightOnFocus, MHighlightOnHover, MHighlightOnSelect, MCursorShape, MClickEnabled, MHoverEnabled, MShortcutFilter,
			MTooltipText, MFocused, MSelected, MActive, MKeepFocusOnClickOut, IScriptBehaviour, IScriptId, IScriptRecordingEnabled, MFocusId,
			MAddFocusGroup, MAccessOneWayConnection, MGetFocus, MElevation, MFocusName, MButtonTitle, MOnFocus;

				MouseOnDownAroundState ::= MOnClick, MOnMiddleClick, MOnRightClick, MMousePosition, MOnDoubleClick, MOnTripleClick, MOnClickAsync, MOnLongClick, MOnLongTouch, MLongTouchDelay, 
					MOnTouch, MDisableHover, MInteractionId, MPassClicks, MAdditionalRollOutCheck, MMobileForceHover, TButtonState, MEnabled, MOnMouseDown, MOnMouseUp, MInteractionsOnTop,
					MRightDown, MMiddleDown;

			// Only one type of MOnClick* is called when several conflicting styles are used.
			// For example if button has MOnClick and MOnTripleClick, only MOnTripleClick on triple click.
			// If click starts some async task, then consider to use MOnClickAsync instead
			MOnClick(click : () -> void);
			MOnDoubleClick(click : () -> void);
			MOnTripleClick(click : () -> void);

 			// Blocks button till the end of async action started by the click
			MOnClickAsync(click : (() -> void) -> void);

			MOnMiddleClick(click : () -> void);
			MOnRightClick(click : () -> void);

			MOnLongClick(click : () -> void);
			MOnLongTouch(touch : () -> void);
			MLongTouchDelay(delay : int); // ms, 500 by default

			MOnTouch(delay : int, touch : () -> void);

			MDisableHover();

			MOnMouseDown(down : (point : Point, inside : bool) -> void);
			MOnMouseUp(up : (point : Point, inside : bool) -> void);

			MRightDown(down : DynamicBehaviour<bool>);
			MMiddleDown(down : DynamicBehaviour<bool>);

			// Disables inner clickable materials in most of the components
			MEnabled(enabled : Transform<bool>);
			// Keyboard shortcut to active the button
			MShortcut(shortcut : string);
			// Compare shortcuts by keycode instead of utf-8 character.
			MShortcutKeyCodeComparison();
			// Function to decide if shortcut should be handled or not
			MShortcutFilter(filterFn : (focused : bool, keyEvent : KeyEvent) -> bool);
			// Call preventDefault
			MShortcutPreventDefault();
			// Enable default enter/space apply shortcut
			// True by default
			MDefaultShortcutEnabled(enabled : Transform<bool>);
			// Set focus to true on mouse down inside
			MFocusOnDown(enabled : ref bool);
			// Add highlight if focused, selected or hovered
			MHighlightOnFocus(enabled : Transform<bool>);
			MHighlightOnHover(enabled : Transform<bool>);
			MHighlightOnSelect(enabled : Transform<bool>);
			// Shape of the cursor inside, disabled if MEnabled is disabled too
			MCursorShape(shape : Transform<CursorShape>);
			// Disable any mouse interaction without making component disabled
			MClickEnabled(enabled : Transform<bool>);
			// Disable hover
			MHoverEnabled(enabled : Transform<bool>);
			// Simple tooltip
			MTooltipText(text : Transform<string>);
			// Shows is this component focused
			// Also allows to set focus
			MFocused(focused : DynamicBehaviour<bool>);
			// Keep focus on clicks outside this component
			MKeepFocusOnClickOut();
			// Mouse coordinates inside component
			MMousePosition(point : DynamicBehaviour<Point>);
			// Force focus enabled
			MForceFocusEnabled(enabled : Transform<bool>);
			// Focus on previously focused item after focus is lost on current
			MFocusOnPrevious();
			// Move interactions on top of the component
			MInteractionsOnTop();
			// Called when component gets or loses focus
			MOnFocus(onFocus : (focus : bool) -> void);

			MRippleStyle ::= MRippleColor, MRippleOpacity, MRippleType, MRipplePosition, MRippleShape, MRippleOverlay, MRippleWidthHeight,
				MRippleFocused, MRippleHovered, MRippleSelected, MEnabled, MRipplePercents;
				// Color of the ripple
				MRippleColor(color : Transform<MColor>);
				// Opacity of the ripple
				MRippleOpacity(opacity : Transform<double>);
				// Position of top left corner of the ripple
				MRipplePosition(position : Transform<Point>);
				MRippleShape(component : string); // Pass component name to get corresponding material shape
				MRippleRoundedCorners(rounded : bool) -> MRippleShape { MRippleShape(if (rounded) "rounded" else ""); };
				MRippleOverlay(overlay : bool); // default: true
				MRippleFocused(focused : Transform<bool>);
				MRippleHovered(hovered : Transform<bool>);
				MRippleSelected(selected : Transform<bool>);
				MRippleWidthHeight(wh : Transform<WidthHeight>);

				MRipplePercents(growth : DynamicBehaviour<double>, fade : DynamicBehaviour<double>); // Inspector

				// Type of the ripple animation
				MRippleType(type : Transform<RippleType>);
					RippleType ::= MRippleFill, MRippleCenter, MNoRipple;
						// Ripple that fills the component
						MRippleFill();
						// Round ripple that starts from the center of the component
						MRippleCenter();
						// Remove ripple that this component has
						MNoRipple();

			IScriptBehaviour(name : string, beh : DynamicBehaviour<flow>, type : IScriptRecordType);
			IScriptRecordingEnabled(enabled : Transform<bool>);
			// Set MFocus id which acts also as taborder inside parent MFocusGroup
			// Components with same MFocusId inside same parent can cause problems
			MFocusId(id : Transform<int>);
			// Wrap constructed MFocus and constructed content with MFocusGroup
			MAddFocusGroup(add : bool);
			MAccessOneWayConnection(focusedPopup : bool);
			// Get contructed inside the component MFocus
			MGetFocus(getFn : (MFocus) -> void);
			// Id used in manager.currentInteractionItemID
			MInteractionId(id : int);
			// Pass clicks to elements below
			MPassClicks();
			// Additional check for roll out
			// Useful in cases when your component translated to different point while mouse inside
			MAdditionalRollOutCheck();
			// Force hover on mobile
			MMobileForceHover();
			MButtonTitle(title : Transform<string>);

		//
		// Text
		//
		MText(text : string, style : [MTextStyle]);
			MTextStyle ::= MFontStyle, MColor, MDynamicColor, MTextDisabled, Underlined, EscapeHTML, LetterSpacing;
				MTextDisabled();
				MDynamicColor(color : Transform<MColor>); // Overrides MColor

		// MParagraphDynamic has unlimited width and behaves like filler. You can restrict width by MWidth style.
		MDynamicParagraph(text : Transform<string>, style : [MParagraphStyle]);
			MParagraphStyle ::= TropicParagraphStyle, MTextStyle, MWidth, Resolution;
				MWidth(width : double);

			MParagraph(text : string, style : [MParagraphStyle]) -> Material { MDynamicParagraph(const(text), style); };

		// If 'full' doesn't fit in 'size', truncate the content and add ellipsis at the end.
		// 'style' is the text style used for the ellipsis characters.
		// If 'showtooltip' is true, also shows the whole 'full' material on a tooltip if it gets truncated.
		MEllipsis(full : Material, size : Material, style : [MEllipsisStyle]);
			MEllipsisStyle ::= MTextStyle, MShowTooltip, MDisableOnDragging, MMinWidth;
				MShowTooltip(show : Transform<bool>);
				MMinWidth(width : double);

		// Displays the given text in the available area
		MEllipsisText(text : string, style : [MEllipsisTextStyle]);
			MEllipsisTextStyle ::= MEllipsisStyle, MMaxLines, MTruncateFromStart, MTooltipMaxWidth, MTextIsTruncated, CenterAlign, RightAlign, MFullWidth, InterlineSpacing, MTextVariants;
				MTooltipMaxWidth(width : double); // 400. by default
				MTextIsTruncated(isTruncated : DynamicBehaviour<bool>);
				MTruncateFromStart();
				MTextVariants(variants: [string]);  // Please provide these in ascending of width order, and all shorter than MEllipsisText.text.

		// Adds a shadow to reflect the z-order as specified in
		// [Material Guidelines | Elevation](https://material.io/design/environment/elevation.html)
		// z is between 0.0 (no shade) to 24.0
		MShadow(z : Transform<double>, m : Material);

		MShadowShape(z : Transform<double>, m : Material, shape: ShadowShape);

			ShadowShape ::= RoundShape, TropicShape, RectangleShape, BottomRectangleShape;
			RoundShape();
			TropicShape(t : Tropic);
			RectangleShape(component : string);
			BottomRectangleShape();

		//
		// Buttons (see also under Icons)
		//
		// [Material Guidelines | Buttons](https://material.io/design/components/buttons.html)
		MTextButton(text : string, onClick : () -> void, style : [MTextButtonStyle], state : [MButtonState]);
			MTextButtonStyle ::= MColor, MContained, MOutlined, MButtonTextColor, MFullWidth, MElevation, MLeftIcon, MRightIcon, MCustomTextStyle,
								MButtonPaddings /* MButtonPaddings(16.0, 10.0, 16.0, 9.0) by default */ ;
				MButtonRaised() -> MContained { MContained(); };
				MContained();
				MOutlined();
				// Forces button text to be white or black, works only on raised buttons.
				// Should be used only in cases where both colors work, MBlue(500) and MOrange(500) for example.
				MButtonTextColor(white : bool);
				MRightIcon(icon : string, style : [MIconStyle]);


		MTextClickable(text : string, onClick : () -> void, style : [MClickableTextStyle], state : [MButtonState]);
			MClickableTextStyle ::= MTextStyle, MFullWidth, MButtonPaddings, MButtonBorders, MBackgroundStyle, MElevation, MLeftIcon, MRightIcon;
				MButtonPaddings(left : double, top : double, right : double, bottom : double); // MButtonPaddings(8., 4., 8., 4.) by default
				// Don't use MButtonBorders, it will be removed soon. Use MButtonPaddings
				MButtonBorders(left : double, top : double, right : double, bottom : double);

		// [Material Guidelines | Floating Action Button](https://material.io/design/components/buttons-floating-action-button.html)
		MFloatingButton(icon : string, style : [MFabStyle], state : [MButtonState]);
			MFabStyle ::= MFabMini, MFabHalfUp, MLeft, MRight, MStart, MEnd, MTop, MBottom, MFabSpeedDial, FillOpacity, MColor, MIconColor, TScrollInspectVisible,
				MElevation;

				MFabMini(mini : bool);
				MFabHalfUp();

				MLeft();
				MRight();
				MTop();
				MBottom();
				MStart();
				MEnd();

				MFabSpeedDial(label : string, actions: [MFabSpeedDialAction], style: [MFabSpeedDialStyle]);

					MFabSpeedDialAction ::= MFabIconButton, MFabAvatar, MFabLetterIcon;
						MFabIconButton(icon : string, label : string, onClick : () -> void, iconStyle : [MFabIconButtonStyle]);
							MFabIconButtonStyle ::= MColor, MIconColor, FillOpacity;
						MFabAvatar(imageurl : string, label : string, onClick : () -> void);
						MFabLetterIcon(text : string, label : string, onClick : () -> void, textStyle : [MTextStyle], bgColor : MColor);

					MFabSpeedDialStyle ::= MColor, MFabLabelsTextStyle, MIconSize, MOpenIcon, MOpenDialDirection;
						MFabLabelsTextStyle(textStyle : [MTextStyle]);
						MIconColor(color : MColor);
						MOpenIcon(icon : string);
						MOpenDialDirection(down : bool);


		// Exhaustive list here:
		// [Icon Font](https://github.com/google/material-design-icons/blob/master/iconfont/codepoints)
		MIcon(
			name : string /* Name of the icon from [Material Icons](https://material.io/resources/icons/) */,
			style : [MIconStyle]
		);

			MIconStyle ::= MColor, FillOpacity, MIconSize, MIconDisabled, MCircleBackground, MElevation, MIconCounter, FontFamily, MIconicFont;
				MIconCounter(value : Transform<int>, style : [MIconCounterStyle]);
					MIconCounterStyle ::= MColor, MEnabled, MIconCounterLimited, MIconSize /* 1/3 of icon size by default*/;
				// Width and height of the icon
				// 24px by default
				MIconSize(size : double);
				MIconDisabled();
				MCircleBackground(color : MColor, size : double);
				// Used to display not yet fully loaded iconic font in the editor
				MIconicFont(font : IconicFont);
				MIconCounterLimited(); // shows "99+" for value > 99

		// Best with single-letter text
		MLetterIcon(text : string, iconStyle : [MIconStyle], textStyle : [MTextStyle]);

		// MIconButton by default has borders that are half of its size, to override this use MIconButtonBorder.
		MIconButton(
			name : string, /* Name of the icon from [Material Icons](https://material.io/resources/icons/) */
			onClick : () -> void,
			style : [MIconButtonStyle],
			state : [MButtonState]
		);

			MIconButtonStyle ::= MIconStyle, MIconButtonBorder;
				// Inner borders of the button
				// Half the size of the icon by default
				MIconButtonBorder(border : double);

		// [Material Guidelines | Toggle Button](https://material.io/design/components/buttons.html#toggle-button)
		MIconToggle(icon : string, style : [MToggleStyle], state : [MToggleState]);
			MToggleStyle ::= MIconButtonStyle, MToggleFalseIcon, MAnimatedIcon;
				MToggleFalseIcon(icon : string, style : [MIconStyle]);
				MAnimatedIcon();
			MToggleState ::= MButtonState, MToggleValue, MToggleValueLink;
				MToggleValue(value : DynamicBehaviour<bool>);
				// Helper to update value with Transform
				// and react to value changes with onChange fn
				MToggleValueLink(value : Transform<bool>, onChange : (bool) -> void);


		// Picture centered and resized to fit circle (18 dp radius by default)
		MAvatar(imageurl : string, style : [MAvatarStyle]);

			MAvatarStyle ::= MIconSize, MNoCrop, OnLoaded;
				MNoCrop();

		// Similar to HTML imagemap: Polygons defining areas. Click to change to the current one
		MImageMap(picture: Tropic, areas: [MArea], current : DynamicBehaviour<int>, style: [MImageMapStyle]);
			MArea(points: [Point]);
			MImageMapStyle ::= MIMHoverColor, MIMSelectedColor, MIMDisableHoverBorder, MIMDisableClickFill;
				MIMHoverColor(c: MColor);
				MIMSelectedColor(c: MColor);
				MIMDisableHoverBorder();
				MIMDisableClickFill();

		//
		// Switches, check boxes, sliders, text input
		//

		// Use MText with MBody style for normal text
		// [Material Guidelines | Checkboxes](https://material.io/design/components/selection-controls.html#checkboxes)
		MCheckBox(caption : Material, value : DynamicBehaviour<bool>, style : [MCheckableStyle]);
			MCheckableStyle ::= MButtonState, MIconButtonStyle, MUncheckedIconStyle, MCaptionPosition, MWidth,
								MLeftIcon, MLabel, MOnNewValue, MIconBorder4;
				MUncheckedIconStyle(style : [MIconStyle]);
				MCaptionPosition(pos : MPosition);
					MPosition ::= MBeforePosition, MAfterPosition, MRightPosition, MLeftPosition, MTopPosition, MBottomPosition;
						MBeforePosition();	// BiDi-aware, renders caption at left for LTR and at right for RTL.
						MAfterPosition();	 // BiDi-aware, renders caption at right for LTR and at left for RTL.
						MRightPosition();	 // Absolute. Renders caption always at right, so, perceived as «after» by european and «before» by arabic people.
						MLeftPosition();	  // Absolute. Renders caption always at left, so, perceived as «before» by european and «after» by arabic people.
						MTopPosition();
						MBottomPosition();
				MOnNewValue(fn : (bool) -> void);
				MIconBorder4(left : double, top : double, right : double, bottom : double);

		// [Material Guidelines | Radio Buttons](https://material.io/design/components/selection-controls.html#radio-buttons)
		// use MRadios to create a group of MRadio at once
		MRadio(caption : Material, thisValue : int, activeValue : DynamicBehaviour<int>, style : [MCheckableStyle]);

		// [Material Guidelines | Switches](https://material.io/design/components/selection-controls.html#switches)
		MSwitchControl(value : DynamicBehaviour<bool>, style : [MSwitchControlStyle]);
			MSwitchControlStyle ::= MButtonState, MColor, MOnOffText, MLabel, MLeftIcon, MWidth;
			// If "off" text equals "", only "on" text is displayed
			// Usefull when you don't need to change text on "off" value, so you can pass only "on" text.
			MOnOffText(on : string, off : string);

		// [Material Guidelines | Sliders](https://material.io/design/components/sliders.html)
		// Value is within 0.0 - 1.0 by default
		// MWidth defines width of the slider itself, regardless of borders or icons. To define width of whole MSlider, wrap it into MAvailableWidth.
		MSlider(value : DynamicBehaviour<double>, style : [MSliderStyle]);
			MSliderStyle ::= MButtonState, MColor, MSliderIconLeft, MSliderIconRight, MSliderRange, MSliderDisplayValue, MSliderDisplayValueEnabled,
				MSliderStep, MSliderSteps, MSliderDiscrete, MWidth, MSliderUndefined, MCondensed, MOutlineOnMinimum, MMaximizeOnHover, MMouseDown,
				MSliderTooltip, MCustomThumb, MSliderShowDiscreteValues, MItemsColor, MSliderChooseRange, MSliderRipple, MSliderEnableArrows;

				MSliderRange(min : double, max : double);
				MSliderDisplayValue(display : bool);
				MSliderDisplayValueEnabled(enabled : Transform<bool>);
				MSliderIconLeft(name : string);
				MSliderIconRight(name : string);
				MSliderStep(value : double);
				MSliderSteps(steps : [double]);
				MSliderChooseRange(start : DynamicBehaviour<double>, end : DynamicBehaviour<double>);
				MSliderDiscrete();
				// By default true on mouse down or on hover if is undefined.
				MSliderShowDiscreteValues(show : Transform<bool>);
				MSliderUndefined(undefined : DynamicBehaviour<bool>);
				// Outline slider handle on minimum value, true by default
				MOutlineOnMinimum(outline : bool);
				// Maximize slider handle when hovered, true by default
				MMaximizeOnHover(maximize : bool);
				// Is mouse down inside slider
				MMouseDown(down : DynamicBehaviour<bool>);
				// Slider tooltip constructed from hovered value
				MSliderTooltip(textFn : (v : double) -> string);
				// Use own material for thumb
				// It's not reasonable to track thumb size to calculate the upper border of slider
				//   since thumb is likely to be animated. So use your own MBorder to set upper border
				//   if you're not satisfied with material spec one
				MCustomThumb(mkThumb : (down : Transform<bool>, focused : Transform<bool>) -> Material);
				// Show halo for thumb.
				MSliderRipple();
				// Change slider value by left/right arrows.
				MSliderEnableArrows();

		// Be sure to make the width a multiple of 8
		// If width < 0, takes all available width
		// [Material Guidelines | Text Fields](https://material.io/design/components/text-fields.html)
		MTextInput(
			content : DynamicBehaviour<string>,
			style : [MTextInputStyle],
			state : [MTextInputState]
		);

		MAutoComplete(
			content : DynamicBehaviour<string>,
			// The words to complete on, separated by newlines.
			// The sentence matcher is called for each line, for each dictionary
			// The best performance comes if you give it just one dictionary,
			// i.e. ["Word1\nWrod2\nWord3"] is better than ["Word1", "Word2", "Word3"]
			dictionaries : [string],
			style : [MAutoCompleteStyle],
			state : [MTextInputState]
		);

		// Link is deprecated. TODO: add appropriate doc link here.
		// [Material Guidelines | Data Table Interactions](https://material.io/archive/guidelines/components/data-tables.html#data-tables-interaction)
		// Text input with edit popup. Intended for usage inside MDataTable.
		MSmallEditDialog(
			content : DynamicBehaviour<string>,
			style : [MTextInputStyle],
			state : [MTextInputState]
		);

			MTextInputStyle ::=
				MWidth /* Width of the input, takes full width if < 0*/, MLabel, MColor,
				TextInputType, AutoCompleteType, Multiline, MMaxLines, ReadOnly, MaxChars, MShowMaxChars, PasswordMode, WordWrap, AutoAlign,
				MFloatingLabel, MDynamicSize, MShowUnderline, MLeftIcon, MShowLeftButton, MLeftCustomButton, MShowClearIcon,
				MShowDropDownArrow,	MShowEditIcon, MCustomTextStyle, MDynamicTextStyle, MLabelTextStyle, MInputFontPadding, MCondensed, MFilterAction,
				MInputBorders, MMaxHeight, MEditDialog, MElevation, MInputBackgroundStyle, MNativeInput, MHaveBeenFocused, MUnderlineUnfocusedStyle,
				MNumericStep, MIconSize, MIconButtonBorder,

				// Text input spec with filled frame.
				// https://material.io/design/components/text-fields.html#filled-text-field
				MFilled,

				// Text input spec with stroke outline.
				// https://material.io/design/components/text-fields.html#outlined-text-field
				MOutlined;

					// Move the label above the input on focus
					MFloatingLabel();
					// Hides max chars info below the input
					MShowMaxChars(show : bool);
					// Sets height of the box if input is multiline
					// Calculates height by the content if lines parameter equals 0 or -1 (affects MTextInput only)
					// If lines parameter < -1, calculates height by the content but limits its height to abs(lines parameter) lines (no limits for MEllipsisText)
					// For example, with MMaxLines(-4) input height can grow from 1 up to 4 lines
					MMaxLines(lines : int);
					// Elevation on focus (8. by default)
					MElevation(elevation : Transform<double>);
					// Show or hide line below input (Works with MTextInput and MAutoComplete)
					MShowUnderline(show : bool);
					// Style of the disabled underline
					MUnderlineUnfocusedStyle(style : [GraphicsStyle]);
					// Show clear icon on focus and/or on hover
					MShowClearIcon(onFocus : bool, onHover : bool);
					// Show left button. Intended for MAutoComplete.
					MShowLeftButton(show : bool);
					// Padding of the font inside input field
					MInputFontPadding(padding : double);
					// Height of input changes corresponding to the floating label and error visibility.
					MDynamicSize();
					// Label in empty input
					MLabel(label : string);
					// Left icon
					// See MShowLeftButton for action button
					MLeftIcon(icon : string, style : [MIconStyle]);
					// Left button
					MLeftCustomButton(closed : Material, open : Material, inputIndent : double);
					// Dropdown arrow on the right
					MShowDropDownArrow(show : bool);
					// Show edit icon
					MShowEditIcon(enabled : bool);
					// Action on enter or selecting of suggested result
					MFilterAction(action : (string) -> void);
					// Make input in dialog, added to MSmallEditDialog by default
					MEditDialog();
					// Text style of MLabel
					MLabelTextStyle(style : [MTextStyle]);
					// Input background, empty for inputs without popups
					MInputBackgroundStyle(normal : [TGraphicsStyle], focused : [TGraphicsStyle]);
					// Borders of the input box
					// textInput/smallEdit : (0., if (hasFloatingLabel) {if (condensed) 20. else 28.} else {if (condensed) 12. else 16.}, 0.,
					// if (condensed) 12. else 16.)
					// autocomplete : (8., if (hasFloatingLabel) {if (condensed) 20. else 28.} else {if (condensed) 12. else 16.}, 8.,
					// if (condensed) 12. else 16.)
					MInputBorders(start : double, top : double, end : double, bottom : double);
					// Set useNativeInput to false for input field written using forms (true by default)
					// Intended only for cpp, in js can't recognize capslock state
					// Also you can set "nativeInputs" url parameter to 0
					MNativeInput(useNativeInput : bool);
					// Intended for using with MInputError only
					MHaveBeenFocused(focused : DynamicBehaviour<bool>);
					// Sets step to increase/decrease value into numeric type textinput
					MNumericStep(step : Transform<double>);
					MFilled();
					MDynamicTextStyle(style : Transform<[MTextStyle]>);

			MAutoCompleteStyle ::=
				MTextInputStyle, MCompletionFn, TCompletionFn, MSentenceMatcher, MPreparedSentenceMatcher, MDictionary,
				MCurrentMatches, TMatchedHandler, MShowAllOnEmpty, MMaxResults, MAutoSelect, MIncludeSpaces, MSuggestionsBackgroundStyle,
				MTextInputOutOfPopup, MInputNoLeftBorder, MSuggestionsPlacement, MSuggestionInLine, MAutoCompleteStartSearch;
				// Material copy of TCompletionFn
				// Use fixed sizes for scroll to work properly
				MCompletionFn(
					fn : (
						match : SentenceMatch,
						selected : bool,
						setWord : (SentenceMatch) -> void
					) -> Material);
				// Custom sentence matching function
				MSentenceMatcher(
					matcher : (sentences : [string]) -> SentenceMatcher,
					fn : (matcher : SentenceMatcher, input : string, maxHits : int, prefix : bool, exhaustive : bool,
						position : int) -> [SentenceMatch]
				);
				// pre-built custom sentence matcher. When it is defined, the 'matcher' function of MSentenceMatcher is not used.
				MPreparedSentenceMatcher(matcher : Transform<SentenceMatcher>);
				// Dictionaries for auto completion
				// See dictionaries field comments in MAutoComplete above for more info
				MDictionary(dictionaries : [string]);
				// Dictionary id, sentence id, sentence hit
				MCurrentMatches(fn : ([Triple<int, int, SentenceMatch>]) -> void);
				// Shows suggestions only if content length >= minChars and wait milliseconds after last key event.
				// (0, 0) by default 
				MAutoCompleteStartSearch(minChars : int, wait : int);
				// Shows all the sentences when input is empty
				// (MMaxResults win over this, i.e., if it's not set, only first 10 sentences will be shown)
				MShowAllOnEmpty();
				// Amount of suggested results (10 by default). -1 to remove limit
				MMaxResults(results : int);
				// Always select one of the possible results
				MAutoSelect();
				// Include spaces in autocompletition
				// False for multiline
				MIncludeSpaces(includeSpaces : bool);
				// Background of the suggestions dropdown
				MSuggestionsBackgroundStyle(style : [TGraphicsStyle]);
				// Defines suggestions area`s location.
				//   MTop/MBottom are strict ones.
				//   MTryTopFirst/MTryBottomFirst will relocate suggestions area in case of limited available space.
				MSuggestionsPlacement(type : MSuggestionsPlacementType); // MTryBottomFirst by default
					MSuggestionsPlacementType ::= MTop, MBottom, MTryTopFirst, MTryBottomFirst; 
						MTryTopFirst();
						MTryBottomFirst();
				// Shows the best suggestion into input area. It may be approved by "enter"
				MSuggestionInLine(showPopup : bool);
				// Do not put MTextInput into popup.
				MTextInputOutOfPopup();
				// Set 0. to left border.
				MInputNoLeftBorder();

			MTextInputState ::= MButtonState, MHelperText, TTextInputState, MInputError, MInputShowPassword, MInputFilter, MPositionOnFocus,
				MSelectionOnFocus, MEatKeyDown, MInputProcessKeyDown;
				// Helper for error without content filtering
				// Also check passwordFilter and emailFilter in material_textinput_state.flow
				// MInputError(text : Transform<Maybe<string>>, style : [MInputErrorStyle]) -> MInputErrorFilter {
				//	MInputErrorFilter(\c, __ -> Pair(c, fselect(text, FLift(\t -> eitherMap(t, \t0 -> Some(Pair(t0, false)), None())))), style)
				// };

				// Can be used to filter the text itself, and get rid of stuff that is not right
				MInputFilter(fn : (content : string, foc : bool) -> string);

				MInputError(
					// Pair(new content, Maybe<Pair<error text, is blocking error (affect MInputIsOk)>>)
					text : Transform<Maybe<Pair<string, bool>>>,
					style : [MInputErrorStyle]
				);
					MInputErrorStyle ::= MMaxLines, MInputErrorColor, MRequiredField, MInputIsOk, MInputErrorFont;
						// error color (MErrorColor by default)
						MInputErrorColor(color : Transform<MColor>);
						// Required Field
						MRequiredField();
						// Are there any errors
						MInputIsOk(ok : DynamicBehaviour<bool>);
						MInputErrorFont(style : MFontStyle);

				// Adds showPassword icon, added by default to PasswordType input
				MInputShowPassword(show : DynamicBehaviour<bool>);
				// Helper text displayed below the input
				// If persistent is false, helper text is hidden when there is no focus on the input
				MHelperText(text : Transform<Maybe<string>>, persistent : bool);
				MPositionOnFocus(fn : (content : string, previous : int) -> int);
				MSelectionOnFocus(fn : (content : string, previous : int) -> int);
				// Style to determine should keyEvent be blocked or not for other components
				// See defEatKeyDown in material_textinput_state for example
				MEatKeyDown(fn : (KeyEvent) -> bool);
				// is key to be processed by input or not
				MInputProcessKeyDown(fn : (KeyEvent) -> bool);

		//
		// Menu
		//
		// [Material Guidelines | Menus](https://material.io/design/components/menus.html)


		// When button is MTextButton or MIconButton MOpenMenu is created automatically, in other cases
		// you should handle menu opening yourself.
		//
		// You can handle onClick actions from whole menu with item id as parameter using MOnListClick or
		// separately for each menu item using MOnClick. Same goes for MSubMenu.
		MMenu(button : Material, items : [MMenuLine], style : [MMenuStyle]);

			MMenuLine ::= MDropDownMenuLine, MSubMenu, MSubMenuDynamic;
				MMenuSingleLine(title : string, style : [MListLineState]);
				MMenuCustomLine(content : Material, style : [MListLineState]);
				MMenuGroupLine(title : string, style : [MListLineState]);
				MSubMenu(title : string, items : [MMenuLine], style : [MSubMenuStyle]);
				MSubMenuDynamic(title : Transform<string>, items : Transform<[MMenuLine]>, style : [MSubMenuStyle]);

			MMenuStyle ::= MListStyle, MOnListClick, MButtonState, MMenuIndent, MSingleSelection, MDataTableFooter, MDataTableRow,
				MOpenMenu, MMaxHeight, MWidthByButton, MBelowButton, MWidth, MSelectedAlwaysOnTop, MMenuNonSpecifiedAlwaysOnTop, MShowTooltip /* Doesn`t work for MMenuCustomLine */,
				MCustomLineHeight, MOpenOnClick, MMenuShift/*, MNoFocus*/, MFixPosition, MCustomScale, MMenuCols, MLabel,
				MLeftIcon, MSameZorder, MForceUpdate, MBlockClicks, MDropDownIconNearTitle, MMenuScrollStyle;

					MOpenMenu(opened : DynamicBehaviour<bool>);
					// Adds indent to every menu item, even if it has no primary action.
					MMenuIndent();
					MMaxHeight(height : double);
					MWidthByButton();
					MBelowButton();
					MDataTableRow();
					MDataTableFooter();
					MSelectedAlwaysOnTop(emptySelection : MMenuLine); // Intended for MDropDownMenu.
					MMenuNonSpecifiedAlwaysOnTop(emptySelection : MMenuLine); // Intended for MDropDownMenu
					MOpenOnClick();
					MMenuShift(shift : Transform<Point>);
					// MNoFocus();
					MCustomLineHeight(height : double);
					// Pin popup y coordinate : top or bottom.
					MFixPosition(top : bool);
					MCustomScale(factor : Transform<Factor>);
					MMenuCols(cols : int);
					// Don't change zorder on open menu
					MSameZorder(same : bool);
					// if present we allow to update current by the same value (other words use `next` instead of `nextDistinct` inside)
					MForceUpdate();
					// Block clicks outside menu
					MBlockClicks();
					// Intended for MDropDownMenu. Get rid of filler between title and icon.
					MDropDownIconNearTitle();
					MMenuScrollStyle(style : [MScrollStyle]); // only MScrollWidthHeight, MScrollPosition, TScrollPersistent are supported now

			MSubMenuStyle ::= MMenuStyle, MPrimaryAction, MDisableHover, MSubMenuOpenOnClick, MCloseParentOnClick;
				MSubMenuOpenOnClick();
				// True by default
				MCloseParentOnClick(close : bool);

		MDynamicMenu(button : Material, items : Transform<[MMenuLine]>, style : [MMenuStyle]);

		// Helper for dropdown like MMenu
		// [Material Guidelines | Dropdown Menu](https://material.io/design/components/menus.html#dropdown-menu)
		MDropDownMenu(items : [MDropDownMenuLine], current : DynamicBehaviour<int>, style : [MDropDownMenuStyle]);
			MDropDownMenuLine ::= MMenuSingleLine, MMenuCustomLine, MSeparatorLine, MMenuGroupLine;
			MDropDownMenuStyle ::= MMenuStyle, MCustomButton, MNonSpecified, MCroppedButton, MSeparators, MAddClearButton,
								MDropDownMenuDisabledOpacity, MNonSpecifiedAlwaysOnTop;

					MNonSpecified(item : MNonSpecifiedLine);
						MNonSpecifiedLine ::= MMenuSingleLine, MMenuCustomLine;
					MCustomButton(button : Material);
					MCroppedButton();
					MSeparators(separators : bool);
					// Adds an icon button, which sets current selection to non-specified (-1 for MDropDownMenu or [] for MMultiSelectDropDown).
					MAddClearButton();
					MDropDownMenuDisabledOpacity(opacity : Transform<double>);
					MNonSpecifiedAlwaysOnTop();

		// Menu panel that takes full width.
		MMenuPanel(items : [Material], style : [MMenuPanelStyle]);
			// MMenuPanelItems ::= MDropDownMenu, MMenu, MDropDown, MTextButton, MIconButton, MSeparator;

			MMenuPanelStyle ::= MMenuPanelBackground, MElevation, MBackgroundStyle, MHeight, MBorders, TScrollCropByContent, TExpandOnHover, MFocusEnabled, MFocused;

				MMenuPanelBackground(color : MColor);
				MHeight(height : double);
				MBorders(borders : double);

		// The non-specified string is used when the current item is outside the range of items
		// Link is deprecated. TODO: add appropriate doc link here.
		// [Material Guidelines | Dropdown Buttons](https://material.io/archive/guidelines/components/buttons.html#buttons-dropdown-buttons)
		MDropDown(current : DynamicBehaviour<int>, nonSpecified : string, items : [string], style : [MDropDownStyle]);
			MDropDownStyle ::= MDropDownMenuStyle, MGroups, MLeftDecorations, MRightDecorations, MDropDownBorder;

				// Unclickable items: first parameter is id of item it should be displayed before, second is caption
				MGroups(groups : [Pair<int, string>]);
				// Place next to item corresponding Material, length of extraItems should be equal length of items.
				MLeftDecorations(extraItems : [Material]);
				MRightDecorations(extraItems : [Material]);
				MDropDownBorder(left : double, top : double, right : double, bottom : double);

		MMultiSelectDropDown(selected : DynamicBehaviour<[int]>, items : [string], style : [MMultiSelectDropDownStyle]);
			MMultiSelectDropDownStyle ::= MNonSpecifiedString, MMaxHeight, MWidth, MCustomLineHeight, MCustomTextStyle, MSelectedItemStyle, MOnItemClick,
				MAddDoneButton, MEnabled, MAddClearButton, MShowTooltip, MDropDownIconNearTitle, MCroppedButton, MCustomButton, MLeftDecorations,
				MRightDecorations, MDropDownMenuDisabledOpacity;

				MSelectedItemStyle(textColor : MColor, bgColor : MColor);
				MNonSpecifiedString(item : string); // "Pick" by default
				MOnItemClick(fn :(index : int, selected : bool) -> void);
				MAddDoneButton();

		//
		// Lists, dropdown, tables
		//
		// [Material Guidelines | Lists](https://material.io/design/components/lists.html)
		MList(lines : [MListLine], style : [MListStyle], state : [MListState]);

			MListStyle ::=
				MColor, MSelectedColor, MBackgroundStyle, MSelectedBackgroundStyle,
				MEmptyMessage, MListWidth, MCondensed, MAddSeparators, MAddScroll,
				MCollapseUnactive, MListMinimize, MListMinimizedWidth, MNoEllipsis,	MSideBorders, MPrimaryActionWidth;

				// When the list is empty, display this in the center
				MEmptyMessage(message : Material);
				// MSelectedX styles works only with MListSelection() state
				MSelectedBackgroundStyle(style : [TGraphicsStyle]);
				MSelectedColor(color : MColor);
				// If width < 0 list takes all available width
				// (-1.0, -1.0 by default)
				MListWidth(minWidth : double, maxWidth : double);
				// Add shadow and separators.
				MAddSeparators();
				// If None(), creates TScrollInspectVisible by default.
				MAddScroll(scrollInpect : Maybe<TScrollInspectVisible>);
				MCollapseUnactive();
				MListMinimize(minimize : Transform<bool>);
				MListMinimizedWidth(width : double); // 72. by default
				MNoEllipsis();
				// Add borders to left and right sides of each line (16.0 by default)
				MSideBorders(borders : Transform<double>);
				// Set width of each line`s primary action (72.0 by default)
				MPrimaryActionWidth(width : Transform<double>);

			MListState ::= MListSelection, MListSelectionEnabled, MOnListClick, MListReorder, MListReorderHideIcon, MGrabDelay,
				MHoverEnabled, MEnabled, IScriptRecordingEnabled, MReorderDropSpot, MReorderCustomDraggingOrder;

				MListSelection(enabled : Transform<bool>, multiple : bool, toggle : bool, selected : DynamicBehaviour<[int]>);
				MListSelectionEnabled(enabled : Transform<[Transform<bool>]>);
				MOnListClick(enabled : Transform<bool>, onClick : (int) -> void);
				MListReorder(order : DynamicBehaviour<[int]>, enabled : Transform<bool>);
				// Hide "drag_handle" icon which added automatically by MListReorder style
				MListReorderHideIcon();

			MListLine ::= MSingleLine, MDoubleLine, MTripleLine, MSubmenuLine, MCustomLine, MSeparatorLine;

				MSingleLine(title : string, state : [MListLineState]);
				MDoubleLine(title : string, subtitle : string, state : [MListLineState]);
				MTripleLine(title : string, subtitle : string, state : [MListLineState]);
				MCustomLine(content : Material, state : [MListLineState]);
				MSubmenuLine(main : MListLine, lines : Transform<[MListLine]>, style : [MSubListStyle], expanded : DynamicBehaviour<bool>);

					MSubListStyle ::= MListState, MColor, MSelectedColor, Fill, FillOpacity, MCustomExpanding, MNoDispose, MSideBorders;
						// MList will not change 'expanded' by user's click
						MCustomExpanding();
						MNoDispose();
				MSeparatorLine();

				MListLineState ::= MButtonState, MPrimaryAction, MSecondaryAction, MLeaveBehind, MAdditionalText,
					MCustomTextStyle, MCustomSecondaryTextStyle, MHeight;

					MPrimaryAction(content : Material);
					MSecondaryAction(content : Material);
					MLeaveBehind ::= MLeftLeaveBehind, MRightLeaveBehind;
						MLeftLeaveBehind(icon : Material, action : () -> void, style : [MLeaveBehindStyle]);
						MRightLeaveBehind(icon : Material, action : () -> void, style : [MLeaveBehindStyle]);

						MLeaveBehindStyle ::= MGapSize, MLeaveBehindPosition;
							MGapSize(size : double, stopOnGap : bool); // MGapSize(56., true) by default
							MLeaveBehindPosition(position : DynamicBehaviour<double>);
					// Intended for shortcuts info.
					MAdditionalText(text : string);

					// Custom size and color, use MCustomFont for custom fontfamilies and opacities.
					MCustomTextStyle(style : [MTextStyle]);
					MCustomSecondaryTextStyle(style : [MTextStyle]);


		MDynamicList(items : Transform<[MListLine]>, style : [MDynamicListStyle], state : [MDynamicListState]);
			MDynamicListStyle ::= MColor, MEmptyMessage, MListWidth, MSelectedColor, MSelectedBackgroundStyle, MCondensed,
				Fill, FillOpacity, MAddSeparators, MSideBorders, MPrimaryActionWidth, MListMinimize, MListMinimizedWidth;
			MDynamicListState ::= IScriptRecordingEnabled, MListSelection, MListSelectionEnabled, MOnListClick,
				MHoverEnabled, MItemsHeights, MScrollStyle, MListReorder, MListReorderHideIcon, MGrabDelay, MNoScroll,
				MReorderDropSpot, MReorderCustomDraggingOrder;

				MItemsHeights(height : (int) -> Transform<double>);

		//
		// Carousel
		//

		MCarousel(contents : [MCarouselContent], activeIdx : DynamicBehaviour<int>, style : [MCarouselStyle]);

			MCarouselContent(content : Material, style : [MCarouselContentStyle]);
				MCarouselContentStyle ::= MCarouselText, MOnClick;
					MCarouselText(title : string, subtitle : string);

			MCarouselStyle ::= MCarouselItemSpan, MBackgroundStyle, MCarouselTextColor, MCarouselFooterColor, MCarouselFooterOpacity,
				MCarouselButtonsColor, MNoProgress, MProgressAtBottom, MProgressColors, MNoChevrons, MEnabled, MDuration, MCarouselNoContentScaling,
				MCarouselEnableArrows, MCarouselCustomPanning, MLoopScroll, MIconSize, MCarouselContentZoom, MCarouselMaximize, TCurrentInteractive,
				MCarouselHeightByContent, MCarouselDisableSideChevrons;

				MCarouselItemSpan(span : int); // defaults to 1
				MCarouselTextColor(color : MColor); // defaults to MWhite
				MCarouselFooterColor(color : MColor); // defaults to MGray(900)
				MCarouselFooterOpacity(opacity : double); // defaults to 0.8
				MCarouselButtonsColor(color : MColor); // useful in case buttons not visible on white images, defaults to MWhite
				MNoChevrons(); // hide navigation buttons
				MCarouselDisableSideChevrons(); // Disable first and last chevrons. Doesn`t work for loop scroll.
				MNoProgress(); // hide progress circles
				MProgressAtBottom(); // progress circles at the bottom of carousel
				MProgressColors(active : MColor, inactive : MColor);
				MCarouselNoContentScaling();
				MCarouselEnableArrows(ignoreFocus : bool);
				// 'shiftX' is a total horizontal shift, not delta. Change of 'mousedown' from true to false fires animated end of panning -
				// similar to user's mousedown
				MCarouselCustomPanning(shiftX : DynamicBehaviour<double>, mousedown : DynamicBehaviour<bool>);
				MLoopScroll();
				MCarouselContentZoom(min : double, max : double, step : double);
				MCarouselMaximize(maximized : DynamicBehaviour<bool>, style : [MCarouselMaximizeStyle]);
					MCarouselMaximizeStyle ::= MNoProgress, MNoChevrons, MShowTextOverlay, MMaximizeFullscreen, MCarouselContentZoom, MDisableSwipe;
						MShowTextOverlay();
						MMaximizeFullscreen();
						MDisableSwipe();

				// Ignore golden ratio and available height, crop by maximum content height instead.
				MCarouselHeightByContent();

		// A table of information
		// [Material Guidelines | Data Tables](https://material.io/design/components/data-tables.html)
		MDataTable(columns : [MColumnDynamic], rows : [[Material]], style : [MDataTableStyle]) -> MDynamicDataTable
			{MDynamicDataTable(columns, const(rows), style);};
		MDynamicDataTable(columns : [MColumnDynamic], rows : Transform<[[Material]]>, style : [MDataTableStyle]);

			// The width should be in a multiple of 8
			MColumn(header : string, tooltip : string, width : int, style : [MColumnStyle]) -> MColumnDynamic {
				MColumnDynamic(const(header), const(tooltip), const(width), style);
			};
			MColumnDynamic(header : Transform<string>, tooltip : Transform<string>, width : Transform<int>, style : [MColumnStyle]);
				MColumnStyle ::= MHeaderStyle, RightAlign, CenterAlign, StartAlign, EndAlign, MSort, MAutoSort, MMaxWidth, MWidthByContent, MWidthByContentLimited;
					// Auto sorting algorithm, works fine with most cases, MSort is needed only in special ones
					MAutoSort();
					// Style for custom sorting
					MSort(colCompares : (int, int) -> int);
					// Max width of the column, should be used with MFullWidth or MFullAdvanced. If less than column width, the latter wins.
					MMaxWidth(width : int);
					// Sets column width by content width. Overrides "width" parameter and MMaxWidth.
					MWidthByContent(); // equal to MWidthByContentLimited(const(-1.), const(-1.))
					MWidthByContentLimited(minWidth : Transform<double>, maxWidth : Transform<double>); // -1. for unlimited

			MDataTableStyle ::= MListSelection, MListSelectionEnabled, MPagination, MPaginationAutoScaling, MCondensed, MSortingDefault, MFullWidth,
				MFullWidthAdvanced, MInCard, MOnListClick, MMinTableHeigth, MSingleSelection, MMultiSelection,
				MSelectedBackgroundStyle, MCurrentPage, MGoToIndex, MHeaderActions, MCheckBoxSelection, MRowHeight, MHeaderRowHeight, MHoverEnabled, MClickEnabled,
				MRowSpacing, MNoSeparators, MNoFooter, MHideAutoPaginationFooter, MExpandRow, TScrollEnabled, TScrollPosition,
				MListReorder /*Disables pagination and sorting*/, MListReorderHideIcon, MHeaderStyle, MFixedRow, MListSorted, MRowBackgroundStyle,
				MExternalSort, MWidthByContent /*Sets this style to all columns*/, MNoCrop /*Do not crop cell content*/,
				MShowRowNumbers, MRowsPerPage, MUpdateSorting, MDataTableInnerScroll, MEnabled;

				// Style adds footer with pagination
				MPagination(current : DynamicBehaviour<int>, rowsPerPage: [int]);
				// Style inspects the available vertical space, and defines the number of rows accordingly -
				// assuming fixed height rows (48 dp default and 32 dp for MCondensed style)
				MPaginationAutoScaling();
				// Style for slimmer rows (height = 32 dp)
				MCondensed(condensed : bool);
				// Style for rows with a specified height
				MRowHeight(height : double);
				MHeaderRowHeight(height : double);
				// Style for default sorting: columnIndex, isAscending
				MSortingDefault(sorting : DynamicBehaviour<MSortingParam>);
					// Sorts by first column by default (without this style). To disable default sorting use -1 for colIndex.
					MSortingParam(colIndex : int, isAsc : bool);
				// Style for expand space between columns to full width
				MFullWidth();
				// Style for increase width of columns (a multiple of 8), keeping the ratio of widths, to full width
				MFullWidthAdvanced();
				// Adds elevation and background to table
				MInCard();
				// Style to define a minimum height
				MMinTableHeigth(height : double);
				// Helpers for easier selection, for advanced stuff use MListSelection
				MSingleSelection(selected : DynamicBehaviour<int>);
				MMultiSelection(selected : DynamicBehaviour<Set<int>>);

				// Allows inspect or change page number
				MCurrentPage(page : DynamicBehaviour<int>);
				// Set number of row to show
				MGoToIndex(index : DynamicBehaviour<int>);
				// Only inspects current rows per page
				MRowsPerPage(rowsPerPage : DynamicBehaviour<int>);

				// Style to define DataTable headers background and text style. textStyleSelected is useless, it is here for compability reasons.
				MHeaderStyle(background : [TGraphicsStyle], textStyle : [MEllipsisTextStyle], textStyleSelected : [MTextStyle]);

				// Adds an additional header to table or replaces current. Avoid using height fillers in actions when MPaginationAutoScaling is present.
				MHeaderActions(actions : Material, style : [MDataTableHeaderActionsStyle]);
					MDataTableHeaderActionsStyle ::= MReplaceHeader;
					MReplaceHeader();

				MCheckBoxSelection(style : [MCheckBoxSelectionStyle]);
					MCheckBoxSelectionStyle ::= MColor;

				MRowSpacing(spacing : double);
				MNoSeparators();
				// Removes footer area. Ignored if pagination is on.
				MNoFooter();
				// Hides footer in case of MPaginationAutoScaling and all rows are on one page.
				MHideAutoPaginationFooter();
				// Enabled or disable row expansion
				MExpandRow(enabled : Transform<bool>);
				// Add this cols as a first fixed row
				MFixedRow(show : Transform<bool>, cols : [Material], style : [MFixedRowStyle]);
					MFixedRowStyle ::= TGraphicsStyle, MOnClick;
				// Returns new sequence of rows indexes if data was sorted
				MListSorted(newOrderCallback : ([int]) -> void);
				// Add background for each row by row number (zero based)
				MRowBackgroundStyle(fn : (rowIndex : int) -> [TGraphicsStyle]);
				// For external sorting (SQL sorting for example). Turns off sorting in MDataTable but keeps column header sorting icon.
				// Sorting params (columnIndex, ascending) use from MSortingDefault
				MExternalSort();
				// Updates sorting every n ms
				MUpdateSorting(delay : int);
				// Adds a column to the left with row numbers
				MShowRowNumbers();
				MDataTableInnerScroll(mode : MDataTableScrollMode, style : [MScrollStyle]);
					MDataTableScrollMode ::= MStandardMode, MGluedFirstColumnMode, MLiftedFirstColumnMode;
						MStandardMode();
						MGluedFirstColumnMode(style : [MGluedFirstColumnModeStyle]);
							MGluedFirstColumnModeStyle ::= MSeparatorVisible;
								MSeparatorVisible(visible : Transform<bool>);
						MLiftedFirstColumnMode();

		//
		// Line Chart
		//
		// [Google Charts | Line Chart](https://developers.google.com/chart/interactive/docs/gallery/linechart)

		// Heigth of the chart is calculated without title and subtitle height
		// Width of the chart is calculated with width of the legend which is 1/4 of the chart width
		MChart(data : MChartData, style : [MChartStyle]);

			MChartStyle ::= MChartTitle, MChartSubtitle, MYAxisCaption, MShowVerticalLines, MShowHorizontalLines, MChartCurve,
				MHideLegend, MXAxisScope, MYAxisScope, MValuesPostfix, MTooltipValuesPostfix, MXAxisIsDate, MChartScale,
				MXAxisVertical, MYAxisValuesOnLines, MInCard, MEmptyMessage, MValuesLabels, MLineLabels, WidthHeight, MChartType, MBarWidth, MOnChartClick,
				MXAxisGridStep, MYAxisGridStep, MChartLinesStyle, MLinesColors, MXAxisValuesMove, MYAxisValuesMove,
				MHideYAxisValues, MHideValueHover, MXAxisStyle, MXAxisValuesTranslate, MHidePoints, EscapeHTML;

				// Color, opacity and width of the chart lines in their order. Opacity by default is 1.0. Width by default is 2.0.
				// Colors by default are taken from standart : MBlue(500), MOrange(500), MGreen(500), MPurple(500),
				// MRed(500), MTeal(500), MLime(500), MBrown(500), MCyan(500)
				MChartLinesStyle : (style : [[MLineStyle]]);
					MLineStyle ::= MColor, FillOpacity, MWidth, MLineType, MHidePoints, MPointLabel, MPointLabelStyle, MPointMarker;
						MLineType(type: MMLineType);
							MMLineType ::= MLineSolid, MLineDashed, MLineDotted;
								MLineSolid();
								MLineDashed();
								MLineDotted();
						MHidePoints();
						// custom values labels
						MPointLabel(getLabel : (value : double) -> string);
						MPointLabelStyle(style : [TParagraphStyle]);
						// custom markers. only for lines
						MPointMarker(getMarker : (index : int, y : double) -> Material);

				// Title displayed at the top of the chart
				MChartTitle(title : string);

				// Subtitle displayed below the title at the top of the chart, can be used without title
				MChartSubtitle(subtitle : string);

				// TODO: Add curve type
				MChartCurve();

				// Caption of the YAxis displayed at the left of the chart
				MYAxisCaption(caption : string);

				// Postfix which is added at the end of every YAxis value
				// For example MValuesPostfix(" s") will produce values like "1 s", "2 s" etc.
				MValuesPostfix(postfix : string);
				// The same as MValuesPostfix but without vertAxis modification
				MTooltipValuesPostfix(postfix : string);

				// Show vertical lines
				MShowVerticalLines();

				// Show horizontal lines
				MShowHorizontalLines();

				// Hides chart legend at the right of the chart
				MHideLegend();

				// Min and max values of the corresponding axis
				MXAxisScope(xAxisMin : double, xAxisMax : double);
				MYAxisScope(yAxisMin : double, yAxisMax : double);

				// XAxis values are timestamps and converted into date
				MXAxisIsDate();

				// Chart items scalling
				MChartScale(scale : double);

				// Display xAxis values vertically
				MXAxisVertical();

				// Move xAxis values
				MXAxisValuesTranslate(point : Transform<Point>);

				// Display yAxis values on lines
				MYAxisValuesOnLines();

				// Adds points value labels
				MValuesLabels(withPostfix : bool);

				// Adds lines labels
				MLineLabels();

				// Width of the bars, 4. by default
				// gapWidth - distance between bars, 1. by default
				MBarWidth(width : double, gapWidth : double);

				MOnChartClick(click : [(int) -> void]);

				MChartType(chartType : [MMChartType]);
					MMChartType ::= MBarChart, MLineChart;
						MBarChart();
						MLineChart();

				// Custom steps for grid
				MXAxisGridStep(step: double);
				MYAxisGridStep(step: double);

				// Obsolete. Use MColor into MChartLinesStyle instead of it. Needs for backward compatibility into cog9platform.
				MLinesColors(colors : [MColor]);

				// Moving of the crossing point of the axes
				MXAxisValuesMove(value : double);
				MYAxisValuesMove(value : double);

				// Hide the values of YAxis
				MHideYAxisValues();

				// Do not show hover for points
				MHideValueHover();

				// styles for MChartData.rows
				// [[MCaptionColumn()], [MTitle(), MRed(700)], ...]
				MXAxisStyle(style : [[MTextStyle]]);

			// Columns are the names of the chart lines in their order, first column is the name of XAxis
			//
			// Rows are the names of the chart rows in their order, can be empty
			//
			// Data is the values of the chart points, first value in every row is XAxis value
			//
			// Use -doubleMax to indicate no value.

			// Example:
			// MChartData(
			// ["YAxis Name", "First Chart Name", "Second Chart Name"],
			// ["First Column Name", "Second Column Name", "Third Column Name", "Fourth Column Name"],
			// [
			//	[1.0, -doubleMax, 20.0],
			//	[2.0, 30.0, 50.0],
			//	[3.0, 20.0, 10.0],
			//	[4.0, 40.0, 70.0]
			// ])
			MChartData(columns : [string], rows : [string], data : [[double]]);

		MDynamicChart(columns : Transform<[MChartColumn]>, rows : Transform<[MChartRow]>, style : [MDynamicChartStyle]);
			// Use -doubleMax to indicate no value.
			MChartColumn ::= MBarChartColumn, MLineChartColumn;
				MBarChartColumn(name : string, data : [double], style : [MBarChartColumnStyle]);
					MBarChartColumnStyle ::= MChartColumnStyle, MBarWidth;

				MLineChartColumn(name : string, data : [double], style : [MLineChartColumnStyle]);
					MLineChartColumnStyle ::= MChartColumnStyle, MWidth, MHidePoints, MPointLabel, MPointLabelStyle, MPointMarker,
						MMLineType, MChartCurve, MColumnRangeData;

						MColumnRangeData(data : [Pair<double, double>]);

					MChartColumnStyle ::= MColor, FillOpacity, MColumnVisible, MColumnShowValuesOnHover, MOnListClick, MHideValueHover,
						MValuesLabels, MValuesPostfix, MTooltipValuesPostfix;

						MColumnVisible(visible : DynamicBehaviour<bool>);
						MColumnShowValuesOnHover(show : Transform<bool>); // Shows all values of the column

			MChartRow(name : string, value : double);

			MDynamicChartStyle ::= MChartTitle, MChartSubtitle, MEmptyMessage, MValuesLabels, MValuesPostfix, MTooltipValuesPostfix, EscapeHTML,
				MAxesStyle, MInCard, MHideLegend, MChartCurve, MHidePoints, MHideValueHover, MLineLabels;

				MAxesStyle(x : [MAxisStyle], y : [MAxisStyle]);
					MAxisStyle ::= MAxisLineVisible, MAxisValuesVisible, MAxisValuesStyle, MAxisValuesVertical, MAxisValuesOnAxis,
						MAxisGridVisible, MAxisGridStep, MAxisGridScope, MAxisGridCenter, MAxisGridZoomEnabled,
						MAxisCaption, MAxisIsDate;

						MAxisLineVisible(visible : Transform<bool>);

						MAxisGridVisible(visible : Transform<bool>);
						MAxisGridStep(step : Transform<double>);
						MAxisGridScope(min : Transform<double>, max : Transform<double>);
						MAxisGridCenter(center : Transform<double>);
						MAxisGridZoomEnabled(enabled : Transform<bool>);

						MAxisValuesVisible(visible : Transform<bool>);
						MAxisValuesStyle(style : Transform<[[MTextStyle]]>);
						MAxisValuesVertical(vertical : Transform<bool>);
						MAxisValuesOnAxis(onAxis : Transform<bool>);
						MAxisValuesTranslate(translate : Transform<Point>);

						MAxisCaption(caption : Transform<string>);
						MAxisIsDate(isDate : Transform<bool>);

		//
		// Time and date picker
		//

		// [Material Guidelines | Pickers](https://material.io/design/components/pickers.html)
		MDatePicker(date : DynamicBehaviour<Date>, style : [MDatePickerStyle]);
			MDatePickerStyle ::= MDateMin, MDateMax, MColor, MDialogAlbum, MDialogButtons, MDateFormat, MMarkDays, MEnabled, MYearDisabled, MUpdateOnClose, MDatePickerFirstWeekDay;
				MDateMin(d : Date);
				MDateMax(d : Date);
				MDialogAlbum(album : bool);
				MDateFormat(f : string);
				MMarkDays(isMarked : (date : Date) -> bool);
				MYearDisabled();
				// Update picker behaviour only when it's closed
				MUpdateOnClose();
				MDatePickerFirstWeekDay(monday : bool); // false by default, starts from Sunday

			MDialogButtons(buttons : [MDialogButton]);
				MDialogButton ::= MButtonOk, MButtonCancel, MTextButton;
					MButtonOk(shortcut : string, fn : () -> void);
					MButtonCancel(shortcut : string, fn : () -> void);


		// [Material Guidelines | Pickers](https://material.io/design/components/pickers.html)
		// Only handles the time part of the time, on update sets seconds to 0
		MTimePicker(time : DynamicBehaviour<Time>, style : [MTimePickerStyle]);
			MTimePickerStyle ::= MTimeAMPM, MColor, MDialogAlbum, MDialogButtons, MEnabled, MTimeMin, MTimeMax, MTimeSeconds, MUpdateOnClose;
				// true - 12 hour time with AM/PM selection
				// false - 24 hour time
				MTimeAMPM(ampm : bool);
				MTimeMin(t : Time);
				MTimeMax(t : Time);
				// Enables seconds in timepicker
				// False by default
				MTimeSeconds(enabled : bool);

		MColorPicker(color : DynamicBehaviour<MColor>, style : [MColorPickerStyle]);
			MColorPickerStyle ::= MColorPickerMultiSelectStyle, MColorPickerType, MShowPreviousColor, MOpacityPicker;
				MColorPickerType ::= MaterialColorPicker, MRGBPicker;
					// Only material colors
					MaterialColorPicker();
					// Picker with sliders
					MRGBPicker(); // by default
				// Show previous color in header
				MShowPreviousColor(show : bool);
				MOpacityPicker(opacity : DynamicBehaviour<double>);

		MColorPickerMultiSelect(colors : DynamicBehaviour<Set<MColor>>, style : [MColorPickerMultiSelectStyle]);
			MColorPickerMultiSelectStyle ::=  MColor, /*MDialogAlbum, */MDialogButtons, MColorPickerAdditionalColors,
				MCustomColorPickerDialog, MEnabled, MUpdateOnClose, MClearCustomColorsButtons, MColorPickerDisableMainPalette;
				// Show additional color palette
				MColorPickerAdditionalColors(colors : Transform<[MColor]>);
				// If this style is present, there are additional colors only.
				MColorPickerDisableMainPalette();
				// Embed custom color picker dialog within material color picker
				MCustomColorPickerDialog(button : MTextButton, pick : (MColor) -> void);
				MClearCustomColorsButtons(removeColor : (MColor) -> void, removeAllColors : () -> void);

		//
		// Cards
		//
		// [Material Guidelines | Cards](https://material.io/design/components/cards.html)
		MCard(blocks : [MCardBlock], style : [MCardStyle], state : [MButtonState]);
			MCardBlock ::= MRichMediaBlock, MActionBlock, MPrimaryTextBlock, MSupportingTextBlock, MCard, MSeparatorBlock, MExpanderBlock, TEmpty;
				// Block for custom material
				MRichMediaBlock(content : Material, style : [MCardStyle]);
				// Block for actions (icon buttons, buttons etc.). left, right - items aligned to the left or right
				MActionBlock(left : [Material], right : [Material], style : [MCardStyle]);
				// Title with subtitle
				MPrimaryTextBlock(title : string, text : string, style : [MCardStyle]);
				// Subtitle
				MSupportingTextBlock(text : string, style : [MCardStyle]);
				// Horizontal or vertical line
				MSeparatorBlock();
				// Expander
				MExpanderBlock(header: Material, details: () -> Material, expander: DynamicBehaviour<bool>, expanderStyle : [MExpanderStyle]);

			// MColor - background color
			// FillOpacity - background opacity
			MCardStyle ::= MBackgroundImage, MElevation, MColor, FillOpacity, MCardWidth, MCardHeight, MCardAlignBottom, MMoreMenu, MCardTextColor,
				MContentBorders, MCardNoOuterBorders;

				// Background image of card or block
				MBackgroundImage(image : string, light : bool);
				// Width of the card or block
				MCardWidth(width : double);
				// Height of the card or block
				MCardHeight(height : double);
				// Force specific text color
				MCardTextColor(color : MColor);
				// Force align to bottom inside block
				MCardAlignBottom();
				// Enable or disable borders (applies to block inside too)
				MContentBorders(borders : bool);
				// Three dot menu at top right corner (see. MMenu for structure)
				MMoreMenu(items : [MMenuLine], state : [MMenuStyle]);
				// Disable outer borders (works only for card itself not blocks)
				MCardNoOuterBorders();

		// Card with title and subtitle only
		MTextCard(title : string, text : string, style : [MCardStyle], state : [MButtonState]) -> MCard {
			MCard([MPrimaryTextBlock(title, text, [])], style, state)
		}

		// Arranges items in grid by theirs sizes and available width
		MFlexibleGrid(items : Transform<[Material]>, style : [MFlexibleGridStyle]);
			MFlexibleGridStyle ::= TFlexibleGridStyle, MEnabled /*Disables reorder*/, MOrdered, MAnimationEnabled;

				MWrapNewRow(wrap : bool) -> TWrapNewRow { TWrapNewRow(wrap); }; // New row should be below all the elements in the previous one (true by default for horizontal grid)
				MWrapNewColumn(wrap : bool) -> TWrapNewColumn { TWrapNewColumn(wrap); }; // New column should be to the right of all the elements in the previous one (true by default for vertical grid)
				MVertical() -> TVertical { TVertical(); }; // Pack elements vertically and bound them with available height
				MAnimationEnabled(enabled : bool); // false for MFlexibleGrid, true for MReorderGrid by default
				MLockWidth(lock : bool) -> TLockWidth { TLockWidth(lock); };	// If true size only grows in height not in width
				                                                            	// (false for MVertical and true for horizontal grid)

				// Don't mix elements order
				// true by default
				MOrdered(ordered : bool);
				MKeepOrder() -> MOrdered { MOrdered(true); }; // OBSOLETE!!
				MMaxRows(rows : int) -> TMaxRows { TMaxRows(rows); }; // Max elements in a first column (Max elements in a first row if MVertical is passed)
				MBaselineAlign() -> TBaselineAlign { TBaselineAlign(); };


		MReorderGrids(items : [[MReorderItem]], order : DynamicBehaviour<[[int]]>, style : [[MReorderGridStyle]], fn : ([Material]) -> Material);
			MReorderItem(content : Material, style : [MReorderItemStyle]);
				MReorderItemStyle ::= MReorderItemVisible, MReorderItemId, MDragging, MEnabled /*Disables dragging*/;
					MReorderItemVisible(visible : DynamicBehaviour<bool>);
					MReorderItemId(id : ref int);

			MReorderGridStyle ::= TFlexibleGridStyle, MDraggingItem, MHoveringItem, MEnabled /*Disables dragging*/,
			                      MGrabDelay, MBorders /*Sets border, which is not draggable*/, MAnimationEnabled,
			                      MReorderDropSpot, MReorderCustomDraggingOrder;
				MDraggingItem(item : DynamicBehaviour<int>);
				MHoveringItem(item : DynamicBehaviour<int>);
				MReorderDropSpot(spot : Material); // Custom drop spot for items
				MReorderCustomDraggingOrder(); // Drop spot is always above the hovered line. Intended for using into MList to prevent "gluing" of lines

		MReorderGrid(items : [MReorderItem], order : DynamicBehaviour<[int]>, style : [MReorderGridStyle]);

		MDynamicGrid(items : Transform<[Material]>, style : [MDynamicGridStyle]);
			MDynamicGridStyle ::= MBoxSize, MItemSize;
				// Scroll box size
				MBoxSize(wh : DynamicBehaviour<WidthHeight>);
				// Set cell height
				MItemSize(wh : Transform<WidthHeight>);

		// Arranges items as grid inside scroll view while rendering only elements visible inside view box
		// Scroll view takes up whole available space
		MRecyclerGrid(items : Transform<[[Material]]>, style : [MRecyclerGridStyle]);
			MRecyclerGridStyle ::= MScrollStyle, TSameSize;
				MSameSize() -> TSameSize { TSameSize(); }; // Use size of the first item as size for all the items, increases performance heavily

		MTree(children : Transform<[MTreeNode<?>]>, style : [MTreeStyle]);
			MTreeStyle ::= MComponentGroupState, MTreeSelection, MTreeOrder, MTreeOnOrderChange, MTreeExpanded, MSingleSelection, MMultiSelection,
				MColor, MItemsLength, MTreeHideSeparators, MTreeLazyLoad, MTreeLazyScrollMode;

				MTreeSelection(selected : DynamicBehaviour<Set<[int]>>);
				MTreeExpanded(expanded : DynamicBehaviour<Set<[int]>>);
				MTreeOrder(order : DynamicBehaviour<[MTreeOrderNode<?>]>);
					MTreeOrderNode(content : ?, children : DynamicBehaviour<[MTreeOrderNode<?>]>);
				MTreeOnOrderChange(onChange : (newOrder : [MTreeOrderNode<?>]) -> void);
				MItemsLength(length : DynamicBehaviour<int>);
				MTreeHideSeparators();
				MTreeLazyLoad(loadCount : int, buildPanelFn : Maybe<(onClick : () -> void) -> Material>); // Content is loaded by button clicking
				MTreeLazyScrollMode(enabled : Transform<bool>); // Content is rendered, when it appears into scroll box.

			MTreeNode(content : ?, content2material : (?) -> Material, children : Transform<[MTreeNode<?>]>, style : [MTreeNodeStyle]);
				MTreeNodeStyle ::= MButtonState, MSelected, MExpanded, MChildSelected, MColor, MShortHighlighter, MTreeNodeCustomIcon,
					MTreeNodeCustomLine, MTreeNodeCustomHighlighter, MTreeNodeCustomHighlighterOnHover, MHighlightOnSelect;

					MSelected(selected : DynamicBehaviour<bool>);
					MExpanded(expanded : DynamicBehaviour<bool>);
					MChildSelected(selected : DynamicBehaviour<bool>);

					// Use shorter highlighting rectangle for MTreeNode that is limited to width of separators between tree rows
					MShortHighlighter : ();
					MTreeNodeCustomIcon(fn : (isExpandedB : DynamicBehaviour<bool>, color : MColor) -> Material);
					MTreeNodeCustomLine(fn : (contentBoxB : DynamicBehaviour<WidthHeight>, color : MColor) -> Material);
					MTreeNodeCustomHighlighter(fn : (Transform<WidthHeight>) -> Material);
					MTreeNodeCustomHighlighterOnHover(fn : (Transform<WidthHeight>) -> Material);

		//
		// Grid List
		//
		// [Material Guidelines | Image Lists](https://material.io/design/components/image-lists.html)
		// A grid list consists of a repeated pattern of cells arrayed in a vertical and horizontal layout.
		// Grid lists are best used on similar data types. They help improve the visual comprehension of the content they contain.
		MGridList(cells : Transform<[MGridListCell]>, style : [MGridListStyle]);

			MGridListCell(
				content : Material,
				text : [string] /* Single line or two lines of text (rest of array is ignored) */,
				style : [MGridListCellStyle]
			);

				MGridListCellStyle ::= MGridListHeader, MGridListFooter, MGridListTextColor, MGridListHeaderFooterColor,
					FillOpacity /*Header/footer background opacity*/, MIconButton, MGridListIconRight, MGridListIconLeft,
					 MGridListZoomContainer;

					// The caption is placed at the top of the cell
					MGridListHeader();
					// The caption is placed at the bottom of the cell
					MGridListFooter();
					// Header/footer text color
					MGridListTextColor(color : MColor);
					// Header/footer background color
					MGridListHeaderFooterColor(color : MColor);
					// Place the secondary action icon at the top/bottom right corner (default)
					MGridListIconRight();
					// Place the secondary action icon at the top/bottom left corner
					MGridListIconLeft();
					// Container for TZoomToFill when making MGridListCell background
					MGridListZoomContainer(container : Tropic);

			MGridListStyle ::= MGridListCellMinWidth, MGridListCellMaxWidth, MGridListColsNumber, MGridListCellHeight,
				MGridListCellAspectRatio, MGridListPadding, MNoScroll /* If present, display the whole grid list. Otherwise create a scroll on a FillXY box (default).*/,
				MSingleSelection, MOnListClick, MOrdered;

				MGridListCellMinWidth(w : double);
				MGridListCellMaxWidth(w : double);
				MGridListColsNumber(n : int);
				MGridListCellHeight(h : double);
				// Ignored if MGridListCellHeight is present
				MGridListCellAspectRatio(ratio : double);
				MGridListPadding(padding : double);

		//
		// Tabs
		//
		// [Material Guidelines | Tabs](https://material.io/design/components/tabs.html)
		// Tabs enable content organization at a high level, such as switching between views, data sets, or functional aspects of an app.
		// Present tabs as a single row above their associated content. Tab labels should succinctly describe the content within.
		// Because swipe gestures are used for navigating between tabs, don't pair tabs with content that also supports swiping.
		MTabs(tabs : [MTab], selected : DynamicBehaviour<int>, style : [MTabsStyle]) -> MDynamicTabs
			{MDynamicTabs(const(tabs), selected, style)};
		MDynamicTabs(
			tabs : Transform<[MTab]>,
			selected : DynamicBehaviour<int> /* Id of the currently selected tab*/,
			style : [MTabsStyle]
		);

			MTab(content : Material, text : Transform<string>, style : [MTabStyle]);
				MTabStyle ::= MButtonState, MTabIcon, MCustomWidth, MTabConfirmSwitch;
					// Icon placed in the middle of the tab above the text
					MTabIcon(icon : Material);
					// Allows asynchronously check condition or save changes before the tab will be switched
					MTabConfirmSwitch(confirm : (callback : (/* approve or cancel */bool) -> void) -> void);

			MTabsStyle ::= MFontStyle, MItemsColor, MBackgroundStyle /* Tab bar background style */, MTabsBackgroundStyle /* Background style of the tabs themselves */,
				MTabsContentBackgroundStyle, MTabsIndicatorColor, MTabIndicatorOnTop, MLargeView, MColor /* equals to MBackgroundStyle([MFill(color)]) */,
				FillOpacity /* equals to MBackgroundStyle([FillOpacity(opacity)]) */, MElevation /* Shadow of the tab (2.0 by default, 0.0 for js) */,
				MNoDispose /* Don't dispose tab content after switching to another one */, MPreRender,
				MCustomWidth, MShowTooltip, MTabsPanelButton, MTabsAddAction, MMaxHeight, MListReorder, MGrabDelay, MNoScroll, TScrollInspectVisible, MWidth,
				MTabsNoDimming, MTabsVerticalSeparators, MTabsHorizontalSeparator, MTabsIconLeftAlign, MTabsAlign;

				// The color of the line under the selected tab
				MTabsIndicatorColor(color : MColor);
				// Sets tab indicator line above the tab label. By default it is situated below.
				MTabIndicatorOnTop();

				// Background style of the tabs
				MTabsBackgroundStyle(style : [TGraphicsStyle]);

				// Background style of the tabs content
				MTabsContentBackgroundStyle(style : [TGraphicsStyle]);

				// For 320dp max width (256dp by default)
				MLargeView();
				MCustomWidth(minWidth : double, maxWidth : double);

				// Pre render content of the tabs and don't dispose it while switching tabs
				MPreRender();
				MTabsPanelButton(button : Material, alignRight : bool);

				MTabsAddAction(action : (int) -> Material);

				// Do not dim tabs without focus
				MTabsNoDimming();

				MTabsVerticalSeparators(width : double, color : MColor);
				MTabsHorizontalSeparator(height : double, selectedColor : MColor, notSelectedColor : MColor);
				MTabsIconLeftAlign();

				MTabsAlign(direction : CommonAlignment); // StartAlign() by default

		//
		// Splitter
		//
		// [Material Guidelines | Android Split-screen](https://material.io/design/platform-guidance/android-split-screen.html)
		MSplitter(m1 : Material, m2 : Material, size : Material, style : [MSplitterStyle]);
			MSplitterStyle ::= MColor, MSplitterHandleColor,MSplitterSeparatorSize, MSplitterSizeWatcher, MSplitterDontHandle,
				MSplitterSize, MEnabled, MSplitterValue, MSplitterHorizontal, MFocusId, MSplitterWidthHeight;

				MSplitterHandleColor(color : MColor);
				MSplitterSeparatorSize(size : double);
				MSplitterSizeWatcher(size : DynamicBehaviour<double>);
				// Do not handle the mouse events, so they are also sent to lower level
				MSplitterDontHandle();
				MSplitterSize(min1 : double, max1 : double, min2 : double, max2 : double);
				// Should grow from 0.0 to 1.0
				MSplitterValue(percent : DynamicBehaviour<double>);
				MSplitterHorizontal();
				MSplitterWidthHeight(left : DynamicBehaviour<WidthHeight>, right : DynamicBehaviour<WidthHeight>);

		//
		// Tooltip, progress, misc
		//

		// [Material Guidelines | Tooltips](https://material.io/design/components/tooltips.html)
		MTooltip(box : Material, tooltip : Material /*Content of the popup*/, style : [MTooltipStyle]);
			MTooltipStyle ::= MEnabled, MDisableOnDragging, MBackgroundStyle, MBlockHover, MTooltipAlignment, MLightBackground, MTranslatePosition, MOpenMenu;

				MTooltipAlignment(type : MTooltipAlignmentType); // MBottom by default
					MTooltipAlignmentType ::= MLeft, MRight, MTop, MBottom, MTryTopFirst, MTryBottomFirst;
				// Background style of the popup
				MBackgroundStyle(style : [TGraphicsStyle]);
				// Hide tooltip if something is being dragged
				MDisableOnDragging();
				// Translate tooltip position
				MTranslatePosition(point : Transform<Point>);
				// Blocks hover to underlying elements
				MBlockHover();

		// [Material Guidelines | Linear Progress Indicators](https://material.io/design/components/progress-indicators.html#linear-progress-indicators)
		// indeterminate
		MProgressBar(style : [MProgressBarStyle]);
			MProgressBarStyle ::= MColor, MProgressBackgroundColor, WidthHeight, MDuration, MBezier, MNoAnimation;
				MProgressBackgroundColor(color : MColor);
				MNoAnimation();

		// [Material Guidelines | Circular Progress Indicators](https://material.io/design/components/progress-indicators.html#circular-progress-indicators)
		MProgressCircle(style : [MProgressCircleStyle]);
			MProgressCircleStyle ::= MColor, MProgressCircleSize, MAddArrow;
				// Stroke is the thickness of the progress circle
				// By default: stroke - 4., radius - 20.
				MProgressCircleSize(stroke : double, radius : double);
				// Add arrow to the tip of the progress circle
				MAddArrow(arrowScale : Transform<double>);

		// determinate, percent should grow from 0.0 to 1.0
		// If size.width < 0, fill x. If size.height < 0, use default height.
		MProgressBarDeterm(percent : Transform<double>, style : [MProgressBarStyle]);
		MProgressCircleDeterm(percent : Transform<double>, style : [MProgressCircleStyle]);

		// TODO: Describe what this is
		MRipple(m : Material);
		MRippleCircle(m : Material);

		// [Material Guidelines | App Bars: Top](https://material.io/design/components/app-bars-top.html)
		// You can add FAB to toolbar just passing it to style. Size of the toolbar stays same.
		// You can extend size of the toolbar or change its content by passing your Material to MToolbarContent.
		MToolbar(expander : DynamicBehaviour<bool>, title : Material, right : [Material], style : [MToolbarStyle]);
			MToolbarStyle ::= MButtonState, MBackgroundStyle, MItemsColor, MElevation, MWidth, MHeight, MBackgroundImage,
				MToolbarContent, MFloatingButton, MCustomExpander, MShowExpander, MToolbarBackButton, MExtendedToolbar;

			MItemsColor(color : MColor);
			// Can be bigger than toolbar size. Displayed below content of the toolbar (menu icon, title etc.).
			MToolbarContent(content : Material, addBorders : bool);
			MToolbarBackButton(button : Material);
			MCustomExpander(expander : Material);
			MShowExpander(show : Transform<bool>);
			// Gives an ability to increase toolbar`s height from current to max (128. by default) and backwards.
			MExtendedToolbar(expand : Transform<bool>, style : [MExtendedToolbarStyle]);
				MExtendedToolbarStyle ::= MMaxHeight, MEnabled, MExpanderProgress;

		// Displays the header. When expanded, displays the details
		// Link is deprecated. TODO: add appropriate doc link here.
		// [Material Guidelines | Expansion Panels](https://material.io/archive/guidelines/components/expansion-panels.html)
		MExpander(header : Material, details : () -> Material, expander : DynamicBehaviour<bool>, style : [MExpanderStyle]);
			MExpanderStyle ::= MExpanderHideSeparator, MExpandByArrowOnly, MColor /*arrow color*/, FillOpacity /*arrow color*/, MExpanderBackgroundStyle,
				MEnabled, MNoDispose, MExpanderNarrowHeader, MExpanderFront, MWidth /*all available space by default, use 0.0 to disable this behaviour*/,
				MDetailsAnimated, MExpanderIcon, CommonAlignment;

				MExpanderHideSeparator();
				// This style is used for MTextInput and another editable controls on header.
				// By default you can expand element by clicking on header.
				MExpandByArrowOnly();
				MExpanderNarrowHeader();
				MExpanderBackgroundStyle(header : [TGraphicsStyle], details : [TGraphicsStyle]);
				// Has the icon in front of the header
				MExpanderFront();
				MDetailsAnimated();
				MExpanderIcon(openIcon : string, closeIcon : string);

		MAnimatedExpander(content : Material, expanded : Transform<bool>, style : [MAnimatedExpanderStyle]);
			MAnimatedExpanderStyle ::= MExpandFromStart, MExpanderHorizontal, MExpanderProgress, MDuration, MNoCrop;
				MExpandFromStart();
				MExpanderHorizontal();
				MExpanderProgress(progress : DynamicBehaviour<double>); // Inspects animation progress
		//
		// Application structure
		//
		// [Material Guidelines | UI Regions](https://material.io/design/layout/responsive-layout-grid.html#ui-regions)
		MAppStructure(parts: [MLayoutPart], style: [MAppStyle]);
			MLayoutPart ::= MAppBar, MNav, MContent, MBottomSheet, MFloatingContent, MBanner;
				// App bar / primary toolbar at the top
				MAppBar(content: Material);
				// Main area
				MContent(content: Material);
				// Side nav on the left or right hand side
				MNav ::= MLeftNav, MRightNav;
					MLeftNav(content: Material, expander: DynamicBehaviour<bool>, style: [MNavStyle]);
					MRightNav(content: Material, expander: DynamicBehaviour<bool>, style: [MNavStyle]);
						MNavStyle ::= MSideNavWidth, MSideNavPersistent, MSideNavMini, MListMinimizedWidth, MFullHeight;
							MSideNavWidth(width : double);
							// Sidebar that constricts MContent.
							// If you dont want it to react on expander pass dummy one instead of real.
							MSideNavPersistent(persistent : Transform<bool>);
							// Sidebar minimizes to mini version.

							// Link is deprecated. TODO: add appropriate doc link here.
							// https://material.io/archive/guidelines/patterns/navigation-drawer.html#navigation-drawer-behavior
							MSideNavMini();
							MFullHeight();
				// On top of everything
				MFloatingContent(content : Material);

				// For showing medium-priority messages. Appears on top of the content.
				// [Material Guidelines | Banner](https://material.io/design/components/banners.html)
				MBanner(banner : Transform<MBannerContent>, enabled : Transform<bool>);
					MBannerContent(text : string, style : [MBannerStyle]);
						MBannerStyle ::= MBannerButtons, MLeftIcon;
							MBannerButtons(buttons : [MBannerButton]);
							MBannerButton(text : string, onClick : () -> void);

				MBottomSheet(
					content : (expanded : Transform<bool>) -> Material,
					style : [MBottomSheetStyle]
				);
					MBottomSheetStyle ::= MExpanded, MCollapsedHeight, MSwipeEnabled, MSwipeDownEnabled, MSwipeGap /*24. by default*/,
										MExpandingBottomSheet, MModalBottomSheet, MEnabled, MAboveFloatingContent;
						MCollapsedHeight(height : Transform<double>); // 56. by default, is restricted by half of the screen height
						MSwipeEnabled(enabled : Transform<bool>); // true by default
						MSwipeDownEnabled(enabled : Transform<bool>); // true by default
						// Note : MExpandingBottomSheet and MModalBottomSheet are not compatible
						// Creates a small info area in the right bottom corner of the screen. Opens by click.
						MExpandingBottomSheet(title : Transform<string>, style : [MExpandingBottomSheetStyle]);
							MExpandingBottomSheetStyle ::= MExpandingBottomSheetIcon, MExpandingBottomSheetAdditional, MColor;
								MExpandingBottomSheetIcon(icon : string);
								MExpandingBottomSheetAdditional(items : [Material]);
						MModalBottomSheet(show : DynamicBehaviour<bool>, closeOnClick : bool); // Bottom sheet, which is normally hidden. Works for mobile only.
						MAboveFloatingContent();

			MAppStyle ::= MComponentGroupState, MNoScroll, MSwipeLeft, MSwipeRight, TScrollInspectVisible, MAppStructureFlexible,
							MFloatingToolbar, MExtendedAppBar, MAppWH, MContentMaxWidth, MAppBarEnabled, MAddSafeArea;
				// Do not add a scroller for the content area
				MNoScroll();

				MSwipeLeftOrRight ::= MSwipeLeft, MSwipeRight;
				// gapLength - distance from the left or right of the screen where swipe is enabled
				// enabled - for swipe disabling in some cases (dialog or loading screens for example)
				MSwipeLeft(gapLength : Transform<double>, enabled : Transform<bool>);
				MSwipeRight(gapLength : Transform<double>, enabled : Transform<bool>);
				// Change sidenav position corresponding to available width
				// MEnabled - turn this on or off (default: const(true))
				// MShowExpander - should the expander toggle be visible when available width is more than required and sidenav is persistant (default: const(false))
				// MShowToolbar - should the toolbar be visible when available width is more than required and sidenav is persistant (default: const(true))
				// MWidth - required width to make sidenav persistent (default: 1296.)
				// MPersistent - monitor current sidenav state based on available width
				// It is advised to use default values
				MAppStructureFlexible(style : [MAppStructureFlexibleStyle]);
					MAppStructureFlexibleStyle ::= MEnabled, MShowExpander, MShowToolbar, MPersistent, MWidth;

					MShowToolbar(show : Transform<bool>);
					MPersistent(persistent : DynamicBehaviour<bool>);
				// Size of the MAppStructure
				MAppWH(wh : DynamicBehaviour<WidthHeight>);
				// Hides toolbar on scrolling down and shows it on scrolling up. Works only for mobile.
				MFloatingToolbar();
				// Extends toolbar by swiping down, when you are on the top of the screen. Default max height is 128.
				MExtendedAppBar(style : [MExtendedAppBarStyle]);
					MExtendedAppBarStyle ::= MExtendedToolbarStyle, MBackgroundImage;
				MAppBarEnabled(enabled : Transform<bool>);

				// Specify max width of the MContent after which it's scaled up
				// See MZoomMaxWidth for more info
				MContentMaxWidth(maxWidth : Transform<double>);

				// Adds safe area around app structure
				// See MSafeArea for more info
				// default: true
				MAddSafeArea(add : bool);

		// Helper for a common kind of left-hand side nav bar
		MSideNav(head: MSNHead, list: Material, expander : Transform<bool>, style: [MSideNavStyle]);
			MSideNavStyle ::= MColor, FillOpacity, MSideNavWidth, MSubList, MSideNavMini, MListMinimizedWidth;
				MSubList(list : Material);

			MSNHead ::= MSNSmallHead, MSNCardHead, MSNCustomHead;
				MSNCardHead(
					background : string,
					photo : MSNHeadPhoto,
					additionalPhotos : [MSNHeadPhoto],
					name : Transform<string>,
					additionalInfo : Transform<string>
				);
				MSNHeadPhoto(url : Transform<string>, onClick : () -> void);
				MSNSmallHead(content: [Material]);
				MSNCustomHead(content: Material);

		MNavigation(list: [MNavigationM], style: [MNavigationStyle]);
			MNavigationM ::= MNavigationMenu, MNavigationMenuCustom;
				MNavigationMenu(title: string, action: [MNavigationMenuAction]);
				MNavigationMenuCustom(m: Material, action: [MNavigationMenuAction]);
					MNavigationMenuAction ::= MNavigationMenu, MNavigationMenuCustom, MNavigationAction, MNavigationSubmenu, MNavigationSubmenuCustom;
						MNavigationAction(onClick: () -> void);
						MNavigationSubmenu(title: string, onClick: () -> void);
						MNavigationSubmenuCustom(m: Material, onClick: () -> void);
			MNavigationStyle ::= MNavigationMenuStyle, MNavigationSubmenuStyle, MNavigationLevelThreeStyle, MNavigationLevelFourStyle,
				Fill, FillOpacity, MNavigationOnSelect, MInCard, MNavigationDynamicBackgroundColor, MNavigationCollapseUnactive;
				MNavigationMenuStyle(style: [MTextStyle]);
				MNavigationSubmenuStyle(style: [MTextStyle]);
				MNavigationLevelThreeStyle(style: [MTextStyle]);
				MNavigationLevelFourStyle(style: [MTextStyle]);
				MNavigationOnSelect(c: DynamicBehaviour<bool>);
				MNavigationDynamicBackgroundColor(f: (i: int) -> int);
				MNavigationCollapseUnactive();

		//
		// Bottom Navigation
		//
		// [Material Guidelines | Bottom Navigation](https://material.io/design/components/bottom-navigation.html)
		MBottomNav(actions: [MBottomNavAction], style: [MBottomNavStyle], selected: DynamicBehaviour<int>, expander: DynamicBehaviour<bool>);
			MBottomNavAction(iconName : string, label : string, style : [MBottomNavActionStyle]);
				MBottomNavActionStyle ::= MOnClick, MIconCounter;
			MBottomNavStyle ::= Fill, FillOpacity, Blur, TScrollInspectVisible, MShowAllLabels, MActiveIconColor, MInactiveIconColor, MBottomNavStaticLabelSize;
				// Fill, FillOpacity, Blur - for background
				// Can expand and hide with TScrollInspectVisible
				MShowAllLabels(); // true by default for actions <= 3
				MBottomNavStaticLabelSize();

		//
		// Chips
		//
		// [Material Guidelines | Chips](https://material.io/design/components/chips.html)
		MChip(title : string, style : [MChipStyle]);
			MChipStyle ::= MCloseButton, MCustomCloseButtonIcon, MChipSelectable, MChipHoverActive, MButtonState, MChipIcon,
							MColor, FillOpacity, MOnClose, MChipVisible, MWidth, MNewChip, MUnselectedColor, MOutlined;
				MChipSelectable(enabled : Transform<bool>, selected : DynamicBehaviour<bool>);
				// MChipHoverActive - translates behaviours to control MChip's appearance
				MChipHoverActive(hover : Transform<int>, active : Transform<bool>);
				MCloseButton();
				MCustomCloseButtonIcon(icon : string);
				// Should MChip be hidden after press on close button
				MOnClose(close : () -> bool);
				// Is MChip visible
				MChipVisible(visible : DynamicBehaviour<bool>);

				MChipIcon ::= MAvatar, MLetterIcon;

				MNewChip(); // updated chip style. Use "new" url-parameter also.
				MUnselectedColor(color : MColor); // MGrey(300) by default

		//
		// Low-level, Tropic-like
		//
		// Draws a white or dark background for the content with a margin, with a shadow according to the depth
		MBackground(depth : int, m : Material);

		// 1dp separator
		// [Material Guidelines | Dividers](https://material.io/design/components/dividers.html)
		MSeparator(horizontal : bool);
		MSeparatorSize(horizontal : bool, minSize : double);

		//
		// A wizard-like stepper
		//

		// [Material Guidelines | Steppers](https://material.io/archive/guidelines/components/steppers.html)
		MStepper(steps : [MStep], selectedId : DynamicBehaviour<int>, type : MStepperType, style : [MStepperStyle]);

			MStep(title : Transform<string>, content : () -> Material, type : [MStepType], state : [MStepState]);

			MStepperType ::= HorizontalStepper, VerticalStepper, MobileStepper;
				HorizontalStepper(type : [MStepsType]);
				VerticalStepper(type : [MStepsType]);
					MStepsType ::= LinearStepper, AlternativeLabel, StepEditableOnComplete;
						//if false Non-linear steppers. used by default
						LinearStepper(linear : bool);
						AlternativeLabel();
						StepEditableOnComplete();

				MobileStepper(type : MobileStepperType, mobileStepperStyle : [MSBottomBarStyle]);
					MobileStepperType ::= MobileStepText, MobileStepDots, MobileStepProgressBar;
						MobileStepText();
						//not implemented yet
						MobileStepDots();
						MobileStepProgressBar(progressBarStyle : [MProgressBarDetermStyle]);
							MSBottomBarStyle::= MSimpleBottomBar, MOnlyContinueButton;
								// [back batton [progresbar/dotbar/nothing] next button]
								MSimpleBottomBar();
								// [progresbar/dotbar/nothing]
								//				[next button]
								MOnlyContinueButton();
								MProgressBarDetermStyle(color : MColor, backgroundColor : MColor, size : WidthHeight);

			MStepType ::= MEditableStep, MClickableStep, MOptionalStep;
				MEditableStep(editable : bool);
				MClickableStep(clickable : Transform<bool>);
				MOptionalStep(text : Transform<string>);

			MStepperStyle ::= MIconSize, MWarningIconColor,
					MActiveIconColor, MInactiveIconColor, MEditIconColor, MCheckCircleIconColor, MBackButton, MContinueButton, MCompleteButton,
					MCancelButton, MStepperAddScroll, MHideCancelButton, MSetIntervalBetweenTitles, MUpdatingStepsNumLabels,
					MHideFirstStepOnStart, MHeaderTextStyles, MHStepperContentBorder, MHStepperFooterBorder, MStepperCustomFooter,
					MStepperTestSupport, MHStepperNoHeaderSeparators;

				MWarningIconColor(color : MColor);
				MActiveIconColor(color : MColor);
				MInactiveIconColor(color : MColor);
				MEditIconColor(color : MColor);
				MCheckCircleIconColor(color : MColor);
				MContinueButton(text : string, style : [MTextButtonStyle], state : [MButtonState]);
				MCompleteButton(text : string, style : [MTextButtonStyle], state : [MButtonState]);
				MBackButton(text : string, style : [MTextButtonStyle], state : [MButtonState]);
				MCancelButton(text : string, style : [MTextButtonStyle], state : [MButtonState]);
				MStepperAddScroll();
				MHideCancelButton();
				MSetIntervalBetweenTitles(size : double);
				// updating steps num labels on steps visibility changing
				MUpdatingStepsNumLabels();
				// allows to keep the first step collapsed on start and open it by clicking on title
				MHideFirstStepOnStart();
				// Font styles of title and subtitle (now used only font color and font size)
				// truncateText - truncate the long text (in title and subtitle) and add ellipsis at the end
				// also tooltips for truncated text will be added
				MHeaderTextStyles(titleStyle : [MTextStyle], subtitleStyle : [MTextStyle], truncateText : bool);
				MHStepperContentBorder(left : double, top : double, right : double, bottom : double);
				MHStepperFooterBorder(left : double, top : double, right : double, bottom : double);
				// Allows to change the footer layout for hstepper
				MStepperCustomFooter(layout : (previous : Material, cancel : Material, next : Material, borders : (Material) -> Material) -> Material);
				MStepperTestSupport(support : MWTestSupport, isTestPlaybackMode : () -> bool);
				// allows to remove upper and lower horizontal lines from the header
				MHStepperNoHeaderSeparators();

			MStepState ::= MStepperFeedback, MultilineErrorState, MContinueFn, MCancelFn, MCompleteStatus, MEnabled,
					MBackButton, MContinueButton, MCompleteButton, MCancelButton;
				MultilineErrorState(text : Transform<string>);
				MContinueFn(fn : () -> bool);
				MCancelFn(fn : () -> void);
				MStepperFeedback(content : () -> Material);
				MCompleteStatus(complete : DynamicBehaviour<bool>);

		//
		// Click helpers
		//

		// Sends down events to lower z-order elements.
		MClickable(m : Material, onClick : () -> void);

		MMouseDownAround(point : Maybe<DynamicBehaviour<Point>>, down : DynamicBehaviour<bool>, hover : DynamicBehaviour<bool>, onClick : () -> void,
			m : Material);

		MComponent(state : [MButtonState], fn : (focus : MFocus) -> Material);
		// Use MComponent instead of MFocusClickable directly
		MFocusClickable(state : [MButtonState], fn : (focus : MFocus) -> Material) -> Material { MComponent(state, fn); };

		MSwipe(content : Material, state : [MSwipeState]);
			MSwipeState ::= MOnSwipeDown, MOnSwipeUp, MOnSwipeLeft, MOnSwipeRight, MOnSwipe, 
				TCurrentInteractive, TPressed, MEnabled, MSwipeGap, MInteractionsOnTop;
				
				MOnSwipeDown(onSwipe : (point : Point, delta : Point) -> bool);
				MOnSwipeUp(onSwipe : (point : Point, delta : Point) -> bool);
				MOnSwipeLeft(onSwipe : (point : Point, delta : Point) -> bool);
				MOnSwipeRight(onSwipe : (point : Point, delta : Point) -> bool);
				MOnSwipe(fn : (swiping : bool) -> void);
				MSwipeGap(gap : double); // 3px by default

		// Draggable and DropSpot in one
		MDragDrop(id : Transform<int>, content : Material, style : [MDragDropStyle]);
			MDragDropStyle ::= MDraggingEnabled, MHoveringEnabled, MDroppingEnabled, MDragging, MHoveringId, MDroppingId,
				MOnDrag, MOnHover, MOnDrop, TPressed, THovering, MMousePosition, MLocalMousePosition, MGrabPosition,
				MDraggingContent, MDraggingPlaceholder, MContentVisibleOnDrag, MGrabDelay, MDragLowestPriority, MDisablePassingClicks;

				MDraggingEnabled(enabled : Transform<bool>);
				MHoveringEnabled(enabled : Transform<bool>);
				MDroppingEnabled(enabled : Transform<bool>);

				MDragging(dragging : DynamicBehaviour<bool>);
				MHoveringId(hovering : DynamicBehaviour<int>);
				MDroppingId(dropping : DynamicBehaviour<int>);

				MOnDrag(fn : (isDragging : bool) -> void); // Fired once when this MDragDrop is dragged or dropped
				MOnHover(fn : (id : int) -> void); // Fired when another MDragDrop is held over this one
				MOnDrop(fn : (id : int) -> void); // Fired when another MDragDrop is dropped inside this one

				MLocalMousePosition(point : DynamicBehaviour<Point>);
				MGrabPosition(point : DynamicBehaviour<Point>);

				MDraggingContent(content : Material);
				MDraggingPlaceholder(content : Material);
				MContentVisibleOnDrag(visible : Transform<bool>);
				MGrabDelay(delay : int); // 300 ms by default
				// Handle click events in the content primarily.
				MDragLowestPriority();
				MDisablePassingClicks();


		MRealHTML(url : string, wh : Transform<WidthHeight>, style : [RealHTMLStyle]);

		// Supports YouTube and Vimeo links (creates iframe instead of video)
		MVideoPlayer(filename : string, wh : Transform<WidthHeight>, style : [MVideoPlayerStyle]);
			// Ignores OnVideoLoadingError and FVideoControls
			MVideoPlayerStyle ::= FVideoStyle, MColor, MPlayerBackground, MEnabled, MPlayerShowPanel, MPlayerPanelAutoHide, MPlayerControls, MPlayerVisibleRange;
				MPlayerBackground(color : MColor);
				MPlayerShowPanel(show : Transform<bool>);
				MPlayerPanelAutoHide(); // Hides panel 1 sec after playing was started, returns it on pause.
				MPlayerControls : (controls : [MPlayerControl]); // [VolumeControl()] by default
					MPlayerControl ::= BasicPlayerControl, SubtitlesControl;

				// video range displayed in UI
				MPlayerVisibleRange(start : Transform<double>, end : Transform<double>);
		MVideo(filename : string, wh : DynamicBehaviour<WidthHeight>, style : [FVideoStyle]) -> Material {
			TVideo(filename, wh, style);
		};

		// These more or less work exactly like Tropic, except they accept Material

		MEmpty() -> Material { TEmpty(); };

		// If you want Material, which automatically mirrors content in case of RTL layout, see versions with -A suffix below.
		MLines(m : [Material]);
		MCols(m : [Material]);
		MLines2(m1 : Material, m2 : Material);
		MCols2(m1 : Material, m2 : Material);
		MBaselineLines(m : [Material]);
		MBaselineCols(m : [Material]);
		MBaselineLines2(m1 : Material, m2 : Material);
		MBaselineCols2(m1 : Material, m2 : Material);
		MBorder(left : double, top : double, right : double, bottom : double, m : Material); // See also MBorder* helpers into material_gui.flow
		MPad(x : double, y : double, content : Material) -> Material { MBorder(x, y, 0., 0., content) };
		MGroup(m : [Material]);
		MGroup2(m1 : Material, m2 : Material);
		MGrid(m : [[Material]]);
		MMinimumGroup2(m1 : Material, m2 : Material);
		MSubtractGroup2(m1 : Material, m2 : Material);
		MBaselineOffset(offset : Transform<double>, m : Material);
		MAvailable(box : Material, avail : Material); // See also MAvailable* helpers into material_gui.flow
		MAlpha(alpha : Transform<double>, m : Material);
		MCrop(topleft : Transform<Point>, widthHeight : Transform<WidthHeight>, m : Material);
		MCropSize(s : Material, m : Material);
		// Preserves the size when invisible
		MVisible(value : Transform<bool>, m : Material);
		// Destroys and reconstructs, and is 0 size when invisible
		MShow(show : Transform<bool>, m : Material);
		MMutable(m : Transform<Material>);
		MIf(condition : Transform<bool>, then : Material, elset : Material);
		// Workaround for MIf to prerender inner stuff, use only in special cases
		MIfPreRender(condition : Transform<bool>, then : Material, elset : Material, sameSize : bool);
		// Be careful, f is called 2 times as a maximum, results of these calls are cached.
		// Check out tests/test_mif_lazy.flow for illustration.
		MIfLazy(condition : Transform<bool>, f : (bool) -> Material);
		MInteractive(interactivity: [TInteractivity], form : Material);
		MCursor(kind : CursorShape2, m : Material);
		MFilter(filters : [Filters], m : Material);

		MGraphics(shape : Transform<GShape>, style : Transform<[TGraphicsStyle]>);
			GShape ::= GRect, GRoundedRect, GEllipse, GCircle, GPath;
				// GRect : (x : double, y : double, width : double, height : double);
				// GRoundedRect : (x : double, y : double, width : double, height : double, radius : double);
				// GEllipse : (x : double, y : double, width : double, height : double);
				// GCircle : (x : double, y : double, radius : double);
				GPath(path : [StaticGraphicOp]);

		MConstruct(constructors : [() -> () -> void], m : Material);
		MCreate2(current : ref Material, fn : () -> Material);
		MCreate(fn : () -> Material) -> MCreate2 {
			MCreate2(ref TEmpty(), fn);
		}
		MDispose(disposers : [() -> void], m : Material);
		MTranslate(point : Transform<Point>, form : Material);
		MOffset(dx : double, dy : double, content : Material) -> Material { MTranslate(const(Point(dx, dy)), content) };
		MRotate(degree : Transform<double>, mat : Material);
		MShift(m : Material, distance : Material);
		MCenter(m : Material);
		MCenterIn(m : Material, box : Material);
		MCenterX(m : Material);
		MCenterY(m : Material);
		MCenterXIn(m : Material, box : Material);
		MCenterYIn(m : Material, box : Material);
		// Render content which depends on available area.
		// Not very convenient in this signature, only use if you know what you're doing.
		MCase(sizes : [Material], m: [Material]);
		MScroll(content : Material, box : Material, style : [MScrollStyle]);
			MScrollStyle ::= TScrollStyle, MScrollToFocusEnabled, MComponentGroupState;

				MScrollToFocusEnabled(enabled : Transform<bool>);

				MScrollPosition(position : DynamicBehaviour<Point>) -> TScrollPosition { TScrollPosition(position); };
				MExpandOnHover(expand : bool) -> TExpandOnHover { TExpandOnHover(expand); };
				MReverseMouseWheel() -> TReverseMouseWheel { TReverseMouseWheel(); };
				MScrollCropByContent() -> TScrollCropByContent { TScrollCropByContent(); };
				// Returns distance by which scroll positon is out of bounds
				// Positive for position below scroll and negative for above. 0 if scroll is in bounds.
				MScrollOutOfBounds(x : DynamicBehaviour<double>, y : DynamicBehaviour<double>) -> TScrollOutOfBounds { TScrollOutOfBounds(x, y); };
				MScrollbars(x : TScrollbarStyle, y : TScrollbarStyle) -> TScrollbars { TScrollbars(x, y); };
				// Tells are scrollbars visible on corresponding axes. On mobile its true even if scrollbars are hidden because of scroll
				// position isn't changing.
				// In other words shows if content is bigger that the box. False when scroll is disabled.
				MScrollbarsVisible(x : DynamicBehaviour<bool>, y : DynamicBehaviour<bool>) -> TScrollbarsVisible { TScrollbarsVisible(x, y); };
				MScrollWidthHeight(content : DynamicBehaviour<WidthHeight>, box : DynamicBehaviour<WidthHeight>) -> TScrollWidthHeight { TScrollWidthHeight(content, box); };
				MScrollDisableOutOfBounds(disable : Transform<bool>) -> TScrollDisableOutOfBounds { TScrollDisableOutOfBounds(disable); };
				MScrollMouseEnabled(enabled : Transform<bool>) -> TScrollMouseEnabled { TScrollMouseEnabled(enabled); };
				MCurrentInteractive(current : DynamicBehaviour<Maybe<bool>>) -> TCurrentInteractive { TCurrentInteractive(current); };
				MScrollBound(x : Transform<bool>, y : Transform<bool>) -> TScrollBound { TScrollBound(x, y); };
				// Event which fires when scrolled to bottom.
				// May be useful when loading stuff in chunks.
				MOnScrolledToBottom(event : () -> void) -> TOnScrolledToBottom { TOnScrolledToBottom(event); };
				// Event which fires when scrolled to side
				// (right for LTR, left for RTL)
				MOnScrolledToSide(event : () -> void) -> TOnScrolledToSide { TOnScrolledToSide(event); };
				// Puts vertical scrollbar to the left.
				// May be useful for arabic layout.
				MScrollBarStart() -> TScrollBarStart { TScrollBarStart(); };
				// Puts horizontal scrollbar to the top.
				MScrollBarTop() -> TScrollBarTop { TScrollBarTop(); };
				// Enables keys handling by MScroll. True by default
				MScrollKeysEnabled(enabled : Transform<bool>) -> TScrollKeysEnabled { TScrollKeysEnabled(enabled); };
				MScrollFadeContent(color : int, width : double) -> TScrollFadeContent { TScrollFadeContent(color, width); };

				// Allows scrollbars to be on the top of the content.
				// True by default.
				// Use "scroll_overlap_debug=1" url-parameter to set MScrollbarOverlapContent(false) by default for all scrolls.
				MScrollbarOverlapContent(overlap : bool) -> TScrollbarOverlapContent { TScrollbarOverlapContent(overlap); };

		MScrollBox(content : Material) -> Material { MScroll(content, TFillXY(), []); };


		MTweak(style : [TTweakStyle], content : Material, size : Material);

		// Draws rectangles : actual size - given color, minimum size - blue, maximum size - green, available space from parent - red, baseline - black line
		// For special cases see MDebug* into material_gui.flow
		MDebug(c : int, box : Material);

		// Inspects metrics of m. See MAttach* helpers into material_gui also.
		MInspect(inspectors : [TInspector], m : Material);

		MAttach(ghost : Material, fn : (TFormMetrics) -> Material);
		// Overrides logical size (doesn't effect display!). Use only in specific cases
		MFixSize(m : Material, size : Material);
		// Deprecated. Use MFixSize instead of MSize.
		MSize(size : Material, m : Material);
		MSizeOf(m : Material);
		MZoom(content : Material, container : Material, keepAspect : bool);
		MZoomToFill(content : Material, container : Material, crop : bool);
		MScale(factor : Transform<Factor>, m : Material);
		MMask(content : Material, mask : Material);
		MFullWindow(fw : DynamicBehaviour<bool>, m : Material);
		MFullScreen(fs : DynamicBehaviour<bool>, m : Material);

		MFrame(margin : double, radius : double, style : [TGraphicsStyle], box : Material);
		// Use MComponent instead of MRawButton
		// MRawButton is left here for backward compatibility
		MRawButton(normal : Material, hover : Material, pressed : Material, disabled : Material, shortcut : string, style : [TButtonStyle],
			state : [MRawButtonState]);

			MRawButtonState ::= MButtonState, TButtonState;

		// Use MDragDrop instead of MDraggable and MDropSpot
		// MDraggable and MDropSpot are left here for backward compatibility
		MDraggable(id : int, stationary : Material, style : [MDragStyle]);
			MDragStyle ::= MDragShape, TDragStyle;
				MDragShape(shape : Material);
		MDropSpot(onHover : DynamicBehaviour<int>, onDrop : DynamicBehaviour<int>, dropTropic : Material);
		MDropSpot2(onHover : DynamicBehaviour<int>, onDrop : DynamicBehaviour<int>, dropTropic : Material, handle : bool);

		MMovable(target : Material, movableArea : Material, style : [MMovableStyle]);
			MMovableStyle ::= MMovablePosition, MMovableExpandArea, MMovableGrabArea;
				MMovablePosition(position : DynamicBehaviour<Point>);
				//The target can be moved partially out of the area
				MMovableExpandArea();
				// Area with which you can grab target, padding is the distance from top-left corner.
				MMovableGrabArea(padding : Material, area : Material);

		MPicture(picURL : string, style : [MPictureStyle]);
			MPictureStyle ::= TPictureStyle, MPictureShowLoading, MPictureCustomLoading, MPictureSize;
				MPictureShowLoading(show : bool);
				MPictureCustomLoading(loading : Material);
				MPictureSize(size : Transform<WidthHeight>); // Scales to available area for WidthHeight(-1., -1.)

		MResizable(content : Material, style : [MResizableStyle]);
			MResizableStyle ::= MResizableMinMax, MResizableOnCreate;
				MResizableMinMax(min : Material, max : Material);
				MResizableOnCreate(size : Material);

		// Scales available space
		MScaleAvailable(factor : Transform<Factor>, m : Material);

		//Set a specific theme for the target
		MExplicitTheme(target : Material, light : Transform<bool>, state : [MComponentGroupState]);


		// [ Material Guidelines | Backdrop ](https://material.io/design/components/backdrop.html)
		MBackdrop(header : Material, content : Material, style : [MBackdropStyle]);
			MBackdropStyle ::= MBackdropTitle, MBackdropSubtitle, MBackdropOpened, MBackdropItems, MBackdropLeftIcon;
				MBackdropTitle(title : Transform<string>);
				MBackdropSubtitle(subtitle : Transform<string>);
				MBackdropOpened(opened : DynamicBehaviour<bool>);
				MBackdropLeftIcon(opened : string, closed : string);
				MBackdropItems(items : [Material]);

		//
		// Helpers for implementing custom elements
		//

		// Helper to create simple animations. Try MMEasingAnimation for complicated ones.
		MAnimator(m : Material, trigger : Transform<bool>, style : [MAnimatorStyle]);
			MAnimatorStyle ::= MDuration, MAnimatorCropType, MExpanderProgress, MBezier, MAnimatorLazy,
			                   MFadeAnimation, MScaleAnimation, MTranslateAnimation, MRotateAnimation;

				MBezier(bezier : Transform<CubicBezierEasing>);
				MDuration(duration : Transform<double>);
				MFadeAnimation();
				MScaleAnimation(style : [MScaleAnimationStyle]);
					MScaleAnimationStyle ::= MCenterMode, MScaleAnimationCustomFactor;
						MCenterMode();
						MScaleAnimationCustomFactor(factor : Transform<Factor>);

				MRotateAnimation(style : [MRotateAnimationStyle]);
					MRotateAnimationStyle ::= MCenterMode, MRotateAnimationCustomAngle;
						MRotateAnimationCustomAngle(angle : Transform<double>); // in degrees

				MTranslateAnimation(type : MTranslateAnimationType, style : [MTranslateAnimationStyle]);
					MTranslateAnimationType ::= MTop, MBottom, MLeft, MRight, MTranslatePosition;
					MTranslateAnimationStyle ::= MExpandFromStart;

				// Dispose content when progress is 0.
				MAnimatorLazy();

				MAnimatorCropType ::= MNoCrop, MAnimatorCropByContent;
					MAnimatorCrop();
					MAnimatorCropByContent();

		MTransformTAcc(
			fn : (
				tropic2acc : (mat : Material, parentInfo : TParentInfo, sheet : Stylesheet, metricsOnly : bool) -> TAcc,
				parentInfo : TParentInfo,
				sheet : Stylesheet,
				metricsOnly : bool
			) -> TAcc
		);

		MGetManager(fn : (MaterialManager) -> Material);
		MGetFocusGroup(fn : (MFocusGroup) -> Material);
		MGetMaterial2Tropic(fn : ((Material, MFocusGroup) -> Tropic) -> Material);

		MAccess(prop : [FAccessProperty], m : Material);
		MPositionScale(positionScale : DynamicBehaviour<PositionScale>, m : Material);

		MDynamicGroup2(stackChanges : DynamicBehaviour<[MGroupChange]>, currentStack : ref [Material], combiner : TCombiner);
			MGroupChange ::= MGroupAdd, MGroupDelete, MGroupMove, MGroupReplace;

				MGroupAdd(mat : Material, z : int);
				MGroupDelete(z : int);
				MGroupMove(from : int, to : int);
				MGroupReplace(mat : Material, z : int);

		MDynamicGroup(stackChanges : DynamicBehaviour<[MGroupChange]>) -> MDynamicGroup2 {
			MDynamicGroup2(stackChanges, ref [], TGroupCombiner());
		}

		// Enables or disables components inside or focus interactions
		MComponentGroup(content : Material, state : [MComponentGroupState]);
			MComponentGroupState ::= MEnabled, MFocusEnabled, MClickEnabled, IScriptBehaviour, MFocusName, MActive, MChildActive, MFocusId, MFocused,
				AccessRole, FAccessAttribute, IScriptId, IScriptRecordingEnabled, MFocusVertical, MFocusHorizontal, MZorder, MAccessOneWayConnection,
				MaterialTheme, MLightBackground, MGetParent, MSetParent, UpdateMaterialTheme, MSetRTL;

			// Switch focus using up and down arrows
			MFocusVertical(vertical : bool);
			// Switch focus using left and right arrows
			MFocusHorizontal(horizontal : bool);

			MFocusName(name : string);

			MActive(active : DynamicBehaviour<bool>);

			// Is there any child being focused, hovered or pressed (i.e. interacted by user)
			MChildActive(active : DynamicBehaviour<bool>);
			// Change material dark/light theme
			MLightBackground(light : bool);
			MZorder(zorder : Transform<int>);

			MGetParent(parent : DynamicBehaviour<Maybe<MFocusGroup>>);
			MSetParent(parent : Transform<Maybe<MFocusGroup>>);

			// Create new MaterialTheme from the parent's one
			UpdateMaterialTheme(fn : (MaterialTheme) -> MaterialTheme);

		MComponentGroupMutable(content : Transform<Material>, state : [MComponentGroupState]);

		MActivate(content : Material, state : [MComponentGroupState]) -> Material { MComponentGroup(content, state); }
		MActivateMutable(content : Transform<Material>, state : [MComponentGroupState]) -> Material { MComponentGroupMutable(content, state); }
		MActivateSelect(value : Transform<?>, fn : (?) -> Material, state : [MComponentGroupState]) -> Material {
			MComponentGroupMutable(fselect(value, FLift(fn)), state);
		}

	//
	// To avoid making Material polymorphic, these are not a part of the union
	//

	MSelect(value : Transform<?>, fn : (?) -> Material) -> Material {MMutable(fselect(value, FLift(fn)))};
	MComponentGroupSelect(value : Transform<?>, fn : (?) -> Material, state : [MComponentGroupState]) -> Material
		{ MComponentGroupMutable(fselect(value, FLift(fn)), state); };

	// Defines a named value in the given scope. This can be used with MDisplay and MGhost.
	// Notice MGhost only works if the named thing is displayed.
	MLet(name : string, value : Material, scope : Material);
	MLetMany(items : [Pair<string, Material>], scope : Material);
	MLetAvailable(name : string, scope : Material);
	MGhost(name : string) -> Material {TGhost(name)};
	MDisplay(name : string) -> Material {TDisplay(name)};

	// Creates a Material with width or height of m. Be careful : usually MGhost is the only optimal way to use into this.
	// Also consider using MAttachWidth / MAttachHeight instead.
	MWidthOf(m : Material) -> Material {MScale(const(Factor(1.0, 0.0)), m)};
	MHeightOf(m : Material) -> Material {MScale(const(Factor(0.0, 1.0)), m)};

	// Aligns content to the right if RTL language chosen.
	MLinesA(arr : [Material]) -> Material {MGetFocusGroup(\p -> MGetMaterial2Tropic(\m2t -> TLinesDir(map(arr, \m -> m2t(m, p)), p.rtl)))}
	MLines2A(m1 : Material, m2 : Material) -> Material {MLinesA([m1, m2])}
	MBaselineLinesA(arr : [Material]) -> Material {MGetFocusGroup(\p -> MGetMaterial2Tropic(\m2t -> TBaselineLinesDir(map(arr, \m -> m2t(m, p)), p.rtl)))}
	MBaselineLines2A(m1 : Material, m2 : Material) -> Material {MBaselineLinesA([m1, m2])}

	// Reverses order of the content columns if RTL language chosen.
	MColsA(m : [Material]) -> Material {MGetFocusGroup(\p -> MCols(if (p.rtl) reverseA(m) else m))}
	MCols2A(m1 : Material, m2 : Material) -> Material {MColsA([m1, m2])}
	MBaselineColsA(m : [Material]) -> Material {MGetFocusGroup(\p -> MBaselineCols(if (p.rtl) reverseA(m) else m))}
	MBaselineCols2A(m1 : Material, m2 : Material) -> Material {MBaselineColsA([m1, m2])}

	MGridA(arr : [[Material]]) -> Material {MGetFocusGroup(\p -> MGrid(if (p.rtl) reverseA(arr) else arr))}

	// BiDi-aware, puts start and end borders to left and right in order regarding to global text direction.
	MBorderA(start : double, top : double, end : double, bottom : double, m : Material) -> Material {
		MGetFocusGroup(\p -> MGetMaterial2Tropic(\m2t -> TBorderDir(start, top, end, bottom, m2t(m, p), p.rtl)))
	}
	MPadA(x : double, y : double, content : Material) -> Material {MBorderA(x, y, 0., 0., content)}

	extractCommonAlignmentFromMParagraphStyles(styles: [MParagraphStyle]) -> CommonAlignment;
}

extractCommonAlignmentFromMParagraphStyles(styles: [MParagraphStyle]) -> CommonAlignment {
	fold(styles, StartAlign(), \acc, style ->
		switch (style) {
			EndAlign(): style;
			LeftAlign(): style;
			RightAlign(): style;
			CenterAlign(): style;
			default: acc;
		}
	)
}
