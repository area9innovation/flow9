import date;
import tropic/trawbutton;
import tropic/ttextinput;
import tropic/tscroll;
import tropic/tflexiblegrid;
import tropic/tautocomplete_types;
import tropic/tropic_dragdrop;
import tropic/tparagraph;
import material/internal/types;
import material/tests/wigi/uitests_support;
import pebbles/pebbles;

import material/iconic_font;

forbid tropic/tropic_ui;	// Too much stuff comes with this, bloating the binary, so avoid this

export {
	Material ::=
		MText, MIcon, MLetterIcon, MTextButton, MTextClickable, MIconButton, MFloatingButton, MBackground,
		MList, MDropDown, MMultiSelectDropDown, MDatePicker, MTimePicker, MColorPicker, MColorPickerMultiSelect, MAvatar,
		MProgressBar, MProgressCircle, MProgressBarDeterm, MProgressCircleDeterm,
		MRipple, MRippleCircle, MSeparator, MSeparatorSize, MBaselineCols, MBaselineLines, MGrid,
		MLines, MCols, MGroup, MLines2, MCols2, MGroup2, MBaselineCols2, MBaselineLines2, MMinimumGroup2, MSubtractGroup2,
		MBaselineOffset, MBorder, MLet, MLetMany, MLetAvailable, MAvailable, MAlpha, MCrop, MCropSize, MVisible, MShow, MRenderable,
		MIf, MIfPreRender, MIfLazy, MInteractive, MCursor, MConstruct, MCreate2, MDispose, MTranslate, MRotate, MOrigin, MAttach, MFixSize,
		MCenter, MCenterIn, MCenterX, MCenterY, MCenterXIn, MCenterYIn, MCenterYInA, MCase, MScroll, MChart, MDynamicChart,
		MCheckBox, MRadio, MSlider, MSwitchControl, MIconToggle, MMutable,
		MTooltip, MToolbar, MAppStructure, MSideNav, MCard, MDynamicCard,
		MExpander, MAnimatedExpander, MMenu, MDynamicMenu, MDropDownMenu, MMenuPanel, MGridList, MFlexibleGrid, MDynamicGrid, MRecyclerGrid,
		MTree, MDynamicArrayTree, MEllipsis, MEllipsisText, MSplitter,
		MShadow, MShadowShape, MZoom, MZoomToFill, MScale, MDebug, MSize, MSizeOf, MMovable,
		MResizable, MDraggable, MDropSpot, MDropSpot2, MNavigation,
		MImageMap, MMask, MPicture, MExplicitTheme, MChip, MScaleAvailable, MShift, MComponentGroup, MComponentGroupMutable,
		MDynamicList, MDynamicTabs, MFullWindow, MFullScreen, MSwipe, MGetManager, MGetFocusGroup, MGetMaterial2Tropic, MSetFocusGroup,
		MAccess, MPositionScale, MRealHTML, MVideoPlayer, MFilter, MGraphics, MAnimation,

		MBottomNav, MDragDrop, MTransformTAcc,

		MStepper, MCarousel,

		MFrame, MRawButton, MDynamicParagraph, MTextInput, MSmallEditDialog, MDynamicDataTable, MLightweightDataTable, MSpannableDataTable, MAutoComplete, MTweak,

		MMouseDownAround, MClickable, MComponent, MReorderGrids, MReorderGrid, MDynamicGroup2, MInspect, MBackdrop,

		MAnimator,

		Tropic;

		MButtonState ::= FAccessProperty, MouseOnDownAroundState, MFocusEnabled, MForceFocusEnabled, MFocusOnPrevious, MShortcut, MShortcutKeyCodeComparison,
		                 MShortcutPreventDefault, MDefaultShortcutEnabled, MRippleStyle, MFocusOnDown, MKeepFocusOnDown, MHighlightOnFocus, MHighlightOnHover, MHighlightOnSelect, MCursorShape,
		                 MClickEnabled, MShortcutFilter, MTooltipText, MTooltipAlignmentDynamic, MTooltipMobileScreenreaderSupport, MFocused, MSelected, MSelectionEnabled, MActive, MKeepFocusOnClickOut, IScriptBehaviour, IScriptId,
		                 IScriptRecordingEnabled, MFocusId, MAddFocusGroup, MGetFocus, MElevation, MFocusName, MButtonTitle, MOnFocus, MForceTooltipEnabled, MImportantFocus;

				MouseOnDownAroundState ::= MOnClick, MOnMiddleClick, MOnRightClick, MMousePosition, MOnDoubleClick, MOnTripleClick, MOnClickAsync, MOnLongClick,
					MOnLongTouch, MLongTouchDelay, MOnTouch, MDisableHover, MInteractionId, MPassClicks, MAdditionalRollOutCheck, MMobileForceHover, TButtonState,
					MEnabled, MOnMouseDown, MOnMouseUp, MInteractionsOnTop, MRightDown, MMiddleDown;

			// Only one type of MOnClick* is called when several conflicting styles are used.
			// For example if button has MOnClick and MOnTripleClick, only MOnTripleClick on triple click.
			// If click starts some async task, then consider to use MOnClickAsync instead
			MOnClick(click : () -> void);
			MOnDoubleClick(click : () -> void);
			MOnTripleClick(click : () -> void);

			// Blocks button till the end of async action started by the click
			MOnClickAsync(click : (() -> void) -> void);

			MOnMiddleClick(click : () -> void);
			MOnRightClick(click : () -> void);

			MOnLongClick(click : () -> void);
			MOnLongTouch(touch : () -> void);
			MLongTouchDelay(delay : int); // ms, 500 by default

			MOnTouch(delay : int, touch : () -> void);

			MDisableHover();

			MOnMouseDown(down : (point : Point, inside : bool) -> void);
			MOnMouseUp(up : (point : Point, inside : bool) -> void);

			MRightDown(down : DynamicBehaviour<bool>);
			MMiddleDown(down : DynamicBehaviour<bool>);

			// Disables inner clickable materials in most of the components
			MEnabled(enabled : Transform<bool>);
			// Keyboard shortcut to active the button
			MShortcut(shortcut : string);
			// Compare shortcuts by keycode instead of utf-8 character.
			MShortcutKeyCodeComparison();
			// Function to decide if shortcut should be handled or not
			MShortcutFilter(filterFn : (focused : bool, keyEvent : KeyEvent) -> bool);
			// Call preventDefault
			MShortcutPreventDefault();
			// Enable default enter/space apply shortcut
			// True by default
			MDefaultShortcutEnabled(enabled : Transform<bool>);
			// Set focus to true on mouse down inside
			MFocusOnDown(enabled : ref bool);
			// Doen't drop focus on mouse down inside
			MKeepFocusOnDown(enabled : ref bool);
			// Add highlight if focused, selected or hovered
			MHighlightOnFocus(enabled : Transform<bool>);
			MHighlightOnHover(enabled : Transform<bool>);
			MHighlightOnSelect(enabled : Transform<bool>);
			// Shape of the cursor inside, disabled if MEnabled is disabled too
			MCursorShape(shape : Transform<CursorShape>);
			// Disable any mouse interaction without making component disabled
			MClickEnabled(enabled : Transform<bool>);
			// Disable any keyboard interaction without making component disabled
			MKeysEnabled(enabled : Transform<bool>);
			// Simple tooltip
			MTooltipText(text : Transform<string>);
			// Shows is this component focused
			// Also allows to set focus
			MFocused(focused : DynamicBehaviour<bool>);
			// Keep focus on clicks outside this component
			MKeepFocusOnClickOut();
			// Mouse coordinates inside component
			MMousePosition(point : DynamicBehaviour<Point>);
			// Force focus enabled
			MForceFocusEnabled(enabled : Transform<bool>);
			// Focus on previously focused item after focus is lost on current
			MFocusOnPrevious(enabled : bool);
			// Move interactions on top of the component
			MInteractionsOnTop();
			// Called when component gets or loses focus
			MOnFocus(onFocus : (focus : bool) -> void);
			// Show tooltip for disabled elements
			MForceTooltipEnabled(enabled : Transform<bool>);
			// When use TAB, it will be focused first
			MImportantFocus();

			MRippleStyle ::=
				MRippleColor, MRippleOutlineColor, MRippleOutlineStyle, MRippleOutlineEnabled, MRippleOpacity, MRippleType, MRipplePosition, MRippleShape, MRippleOverlay, MRippleWidthHeight, MRippleTrigger,
				MRippleFocused, MRippleHovered, MRippleSelected, MEnabled, MRipplePercents;
				// Color of the ripple
				MRippleColor(color : Transform<MThemeColor>);
				MRippleOutlineColor(color : Transform<MThemeColor>);
				MRippleOutlineStyle(style : [GraphicsStyle]);
				MRippleOutlineEnabled(enabled : Transform<bool>);
				// Opacity of the ripple
				MRippleOpacity(opacity : Transform<double>);
				// Position of top left corner of the ripple
				MRipplePosition(position : Transform<Point>);
				MRippleShape(component : string); // Pass component name to get corresponding material shape
				MRippleRoundedCorners(rounded : bool) -> MRippleShape { MRippleShape(if (rounded) "rounded" else ""); };
				MRippleOverlay(overlay : bool); // default: true
				MRippleFocused(focused : Transform<bool>);
				MRippleHovered(hovered : Transform<bool>);
				MRippleSelected(selected : Transform<bool>);
				MRippleWidthHeight(wh : Transform<WidthHeight>);
				MRippleTrigger(trigger : Transform<bool>);

				MRipplePercents(growth : DynamicBehaviour<double>, fade : DynamicBehaviour<double>); // Inspector

				// Type of the ripple animation
				MRippleType(type : Transform<RippleType>);
					RippleType ::= MRippleFill, MRippleCenter, MNoRipple;
						// Ripple that fills the component
						MRippleFill();
						// Round ripple that starts from the center of the component
						MRippleCenter();
						// Remove ripple that this component has
						MNoRipple();

			IScriptBehaviour(name : string, beh : DynamicBehaviour<flow>, type : IScriptRecordType);
			IScriptRecordingEnabled(enabled : Transform<bool>);
			// Set MFocus id which acts also as taborder inside parent MFocusGroup
			// Components with same MFocusId inside same parent can cause problems
			MFocusId(id : Transform<int>);
			// Wrap constructed MFocus and constructed content with MFocusGroup
			MAddFocusGroup(add : bool);
			// Get contructed inside the component MFocus
			MGetFocus(getFn : (MFocus) -> void);
			// Id used in manager.manager.currentInteractionItemID
			MInteractionId(id : int);
			// Pass clicks to elements below
			MPassClicks();
			// Additional check for roll out
			// Useful in cases when your component translated to different point while mouse inside
			MAdditionalRollOutCheck();
			// Force hover on mobile
			MMobileForceHover();
			MButtonTitle(title : Transform<string>);
			MSelectionEnabled(enabled : Transform<bool>);

		//
		// Text
		//
		MText(text : string, style : [MTextStyle]);
			MTextStyle ::= MFontStyle, MThemeColor, MDynamicColor, MTextDisabled, Underlined, EscapeHTML, NeedBaseline,
				LetterSpacing, WordSpacing, LineHeightPercent, TagName, LangAttribute, LocalizationEnabled, FillOpacity, SetRTL;

				MTextDisabled();
				MDynamicColor(color : Transform<MThemeColor>); // Overrides MColor/MThemeColor

		// MDynamicParagraph with CenterAlign()/RightAlign() has unlimited width and behaves like filler.
		// Use FullWidth() to fill all available width by default
		MDynamicParagraph(text : Transform<string>, style : [MParagraphStyle]);
			MParagraphStyle ::= TropicParagraphStyle, FullWidth, MTextStyle, MWidth, ParagraphMetrics, Resolution, Justify /*JS only*/;
				MWidth(width : double); // Restricts available width for paragraph.

			MParagraph(text : string, style : [MParagraphStyle]) -> Material { MDynamicParagraph(const(text), style); };

		// If 'full' doesn't fit in 'size', truncate the content and add ellipsis at the end.
		// 'style' is the text style used for the ellipsis characters.
		// If 'showtooltip' is true, also shows the whole 'full' material on a tooltip if it gets truncated.
		MEllipsis(full : Material, size : Material, style : [MEllipsisStyle]);
			MEllipsisStyle ::= MTextStyle, MShowTooltip, MDisableOnDragging, MMinWidth;
				MShowTooltip(show : Transform<bool>);
				MMinWidth(width : double);

		// Displays the given text in the available area
		MEllipsisText(text : string, style : [MEllipsisTextStyle]);
			MEllipsisTextStyle ::= MEllipsisStyle, MMaxLines, MMaxHeight, MTruncateFromStart, MTooltipMaxWidth, MTextIsTruncated, LeftAlign, CenterAlign, RightAlign,
			MFullWidth, MEllipsisTextGetFullWidth, InterlineSpacing, MTextVariants, MEllipsisTextAlignment, MTooltipExternalFocused;
				MTooltipMaxWidth(width : double); // 400. by default
				MTextIsTruncated(isTruncated : DynamicBehaviour<bool>);
				MTruncateFromStart();
				MTextVariants(variants: [string]);  // Please provide these in ascending of width order, and all shorter than MEllipsisText.text.
				MEllipsisTextGetFullWidth(fn : (double) -> void);
				MEllipsisTextAlignment(alignment : CommonAlignment); // Alignment for each text line

		// Adds a shadow to reflect the z-order as specified in
		// [Material Guidelines | Elevation](https://material.io/design/environment/elevation.html)
		// z is between 0.0 (no shade) to 24.0
		MShadow(z : Transform<double>, m : Material);

		MShadowShape(z : Transform<double>, m : Material, shape: ShadowShape);

			ShadowShape ::= RoundShape, RoundCenteredShape, TropicShape, RectangleShape, RectangleCenteredShape, BottomRectangleShape;
			RoundShape();
			RoundCenteredShape();
			TropicShape(t : Tropic);
			RectangleShape(component : string);
			RectangleCenteredShape(component : string);
			BottomRectangleShape();

		//
		// Buttons (see also under Icons)
		//
		// [Material Guidelines | Buttons](https://material.io/design/components/buttons.html)
		MTextButton(text : string, onClick : () -> void, style : [MTextButtonStyle], state : [MButtonState]);
			MTextButtonStyle ::= MThemeColor, MContained, MOutlined, MButtonTextColor, MFullWidth, MElevation, MLeftIcon, MRightIcon, MIconNearTitleEnabled, MCustomTextStyle,
			                     MButtonPaddings /* MButtonPaddings(16.0, 10.0, 16.0, 9.0) by default */, MButtonPaddingsA, MOutlineColor, MOutlineOpacity, MOutlineWidth,
			                     MTextAlignment, MButtonProgress;
				MButtonRaised() -> MContained { MContained(); };
				MContained();
				MOutlined();
				// Forces button text to be white or black, works only on raised buttons.
				// Should be used only in cases where both colors work, MBlue(500) and MOrange(500) for example.
				MButtonTextColor(white : bool);
				// Works only with MOutlined()
				MOutlineColor(color : MThemeColor);
				MOutlineOpacity(opacity : double);
				MOutlineWidth(width : double);
				// Works only with MFullWidth()
				MTextAlignment(alignment : CommonAlignment);
				MIconNearTitleEnabled(enabled : bool); // true by default

				MRightIcon(icon : string, style : [MIconStyle]);
				// Use it for button which triggers async request. It shows progress circle until 'activated' is returned to false.
				MButtonProgress(activated : DynamicBehaviour<bool>, activateOnClick : bool);
				MTextButtonProgress(activated, activateOnClick) { MButtonProgress(activated, activateOnClick); }


		MTextClickable(text : string, onClick : () -> void, style : [MClickableTextStyle], state : [MButtonState]);
			MClickableTextStyle ::= MTextStyle, MFullWidth, MButtonPaddings, MButtonPaddingsA, MButtonBorders, MBackgroundStyle, MElevation, MLeftIcon, MRightIcon;
				MButtonPaddings(left : double, top : double, right : double, bottom : double); // MButtonPaddings(8., 4., 8., 4.) by default
				MButtonPaddingsA(start : double, top : double, end : double, bottom : double); // MButtonPaddingsA has a higher priority than MButtonPaddings.
				// Don't use MButtonBorders, it will be removed soon. Use MButtonPaddings
				MButtonBorders(left : double, top : double, right : double, bottom : double);

		// [Material Guidelines | Floating Action Button](https://material.io/design/components/buttons-floating-action-button.html)
		MFloatingButton(icon : string, style : [MFabStyle], state : [MButtonState]);
			MFabStyle ::= MFabMini, MFabHalfUp, MLeft, MRight, MStart, MEnd, MTop, MBottom, MFabSpeedDial, FillOpacity, MThemeColor, MIconColor, TScrollInspectVisible,
			              MElevation, MFabSize, MFloatingButtonCenteredShape;

				MFabMini(mini : bool);
				MFabHalfUp();
				MFabSize(size : double);
				MFloatingButtonCenteredShape();

				MLeft();
				MRight();
				MTop();
				MBottom();
				MStart();
				MEnd();

				MFabSpeedDial(label : string, actions: [MFabSpeedDialAction], style: [MFabSpeedDialStyle]);

					MFabSpeedDialAction ::= MFabIconButton, MFabAvatar, MFabLetterIcon;
						MFabIconButton(icon : string, label : string, onClick : () -> void, iconStyle : [MFabIconButtonStyle]);
							MFabIconButtonStyle ::= MThemeColor, MIconColor, FillOpacity;
						MFabAvatar(imageurl : string, label : string, onClick : () -> void);
						MFabLetterIcon(text : string, label : string, onClick : () -> void, textStyle : [MTextStyle], bgColor : MThemeColor);

					MFabSpeedDialStyle ::= MThemeColor, MFabLabelsTextStyle, MIconSize, MOpenIcon, MOpenDialDirection;
						MFabLabelsTextStyle(textStyle : [MTextStyle]);
						MIconColor(color : MThemeColor);
						MOpenIcon(icon : string);
						MOpenDialDirection(down : bool);


		// Exhaustive list here:
		// [Icon Font](https://github.com/google/material-design-icons/blob/master/iconfont/codepoints)
		MIcon(
			name : string /* Name of the icon from [Material Icons](https://material.io/resources/icons/) */,
			style : [MIconStyle]
		);

			MIconStyle ::= MThemeColor, FillOpacity, MIconSize, MIconDisabled, MCircleBackground, MElevation, MIconCounter,
				FontFamily, MIconicFont, MIconType, MIconDescription;

				MIconCounter(value : Transform<int>, style : [MIconCounterStyle]);
					MIconCounterStyle ::= MThemeColor, MEnabled, MIconCounterLimited, MIconSize /* 1/3 of icon size by default*/, LocalizationEnabled;
				// Width and height of the icon
				// 24px by default
				MIconSize(size : double);
				MIconDisabled();
				MCircleBackground(color : MThemeColor, size : double);
				// Used to display not yet fully loaded iconic font in the editor
				MIconicFont(font : IconicFont);
				// Type of material icon. Filled by default.
				MIconType(type : MIconTypeStyle);
				MIconCounterLimited(); // shows "99+" for value > 99
				// Text for screenreaders
				MIconDescription(description : string);

		// Best with single-letter text
		MLetterIcon(text : string, iconStyle : [MIconStyle], textStyle : [MTextStyle]);

		// MIconButton by default has borders that are half of its size, to override this use MIconButtonBorder.
		MIconButton(
			name : string, /* Name of the icon from [Material Icons](https://material.io/resources/icons/) */
			onClick : () -> void,
			style : [MIconButtonStyle],
			state : [MButtonState]
		);

			MIconButtonStyle ::= MIconStyle, MIconButtonBorder, MIconButtonBorders, MButtonProgress;
				// Inner borders of the button
				// Half the size of the icon by default
				MIconButtonBorder(border : double);
				MIconButtonBorders(left : double, top : double, right : double, bottom : double);

		// [Material Guidelines | Toggle Button](https://material.io/design/components/buttons.html#toggle-button)
		MIconToggle(icon : string, style : [MToggleStyle], state : [MToggleState]);
			MToggleStyle ::= MIconButtonStyle, MToggleFalseIcon, MAnimatedIcon;
				MToggleFalseIcon(icon : string, style : [MIconStyle]);
				MAnimatedIcon();
			MToggleState ::= MButtonState, MToggleValue, MToggleValueLink;
				MToggleValue(value : DynamicBehaviour<bool>);
				// Helper to update value with Transform
				// and react to value changes with onChange fn
				MToggleValueLink(value : Transform<bool>, onChange : (bool) -> void);


		// Picture centered and resized to fit circle (18 dp radius by default)
		MAvatar(imageurl : string, style : [MAvatarStyle]);

			MAvatarStyle ::= MIconSize, MNoCrop, OnLoaded;
				MNoCrop();

		// Similar to HTML imagemap: Polygons defining areas. Click to change to the current one
		MImageMap(picture: Tropic, areas: [MArea], current : DynamicBehaviour<int>, style: [MImageMapStyle]);
			MArea(points: [Point]);
			MImageMapStyle ::= MIMHoverColor, MIMSelectedColor, MIMDisableHoverBorder, MIMDisableClickFill;
				MIMHoverColor(c: MThemeColor);
				MIMSelectedColor(c: MThemeColor);
				MIMDisableHoverBorder();
				MIMDisableClickFill();

		//
		// Switches, check boxes, sliders, text input
		//

		// Use MText with MBody style for normal text
		// [Material Guidelines | Checkboxes](https://material.io/design/components/selection-controls.html#checkboxes)
		MCheckBox(caption : Material, value : DynamicBehaviour<bool>, style : [MCheckableStyle]);
			MCheckableStyle ::= MButtonState, MIconButtonStyle, MUncheckedIconStyle, MCaptionPosition, MWidth,
			                    MLeftIcon, MLabel, MOnNewValue, MOnNewValue2, MIconBorder4, MCaptionNonClickable;
				MUncheckedIconStyle(style : [MIconStyle]);
				MCaptionPosition(pos : MPosition);
					MPosition ::= MBeforePosition, MAfterPosition, MRightPosition, MLeftPosition, MTopPosition, MBottomPosition,
						MBeforeCenteredPosition, MAfterCenteredPosition;

						MBeforePosition();	// BiDi-aware, renders caption at left for LTR and at right for RTL.
						MAfterPosition();	 // BiDi-aware, renders caption at right for LTR and at left for RTL.
						MRightPosition();	 // Absolute. Renders caption always at right, so, perceived as «after» by european and «before» by arabic people.
						MLeftPosition();	  // Absolute. Renders caption always at left, so, perceived as «before» by european and «after» by arabic people.
						MTopPosition();
						MBottomPosition();
						MBeforeCenteredPosition(); //Centered by height
						MAfterCenteredPosition(); //Centered by height
				// MOnNewValue calls fn on initialization, MOnNewValue2 doesn`t
				MOnNewValue(fn : (bool) -> void);
				MOnNewValue2(fn : (bool) -> void);
				MIconBorder4(left : double, top : double, right : double, bottom : double);
				MCaptionNonClickable();

		// [Material Guidelines | Radio Buttons](https://material.io/design/components/selection-controls.html#radio-buttons)
		// use MRadios to create a group of MRadio at once
		MRadio(caption : Material, thisValue : int, activeValue : DynamicBehaviour<int>, style : [MCheckableStyle]);

		// [Material Guidelines | Switches](https://material.io/design/components/selection-controls.html#switches)
		MSwitchControl(value : DynamicBehaviour<bool>, style : [MSwitchControlStyle]);
			MSwitchControlStyle ::= MButtonState, MThemeColor, MOnOffText, MOnOffTextFont, MLabel, MLeftIcon, MWidth;
			// If "off" text equals "", only "on" text is displayed
			// Usefull when you don't need to change text on "off" value, so you can pass only "on" text.
			MOnOffText(on : string, off : string);
			MOnOffTextFont(font : MFontStyle);

		// [Material Guidelines | Sliders](https://material.io/design/components/sliders.html)
		// Value is within 0.0 - 1.0 by default
		// MWidth defines width of the slider itself, regardless of borders or icons. To define width of whole MSlider, wrap it into MAvailableWidth.
		MSlider(value : DynamicBehaviour<double>, style : [MSliderStyle]);
			MSliderStyle ::= MButtonState, MComponentGroupState, MThemeColor, MSliderIconLeft, MSliderIconRight, MSliderRange, MSliderShowValue, MSliderShowValueInput,
				MSliderShowValueInputEnabled, MDynamicColor, MSliderHighlightedRanges, MSliderCaption, MSliderUpdateOnEnd, MSliderCurrentValue,
				MSliderStep, MSliderSteps, MSliderDiscrete, MWidth, MSliderUndefined, MCondensed, MMouseDown, MSliderStepDescription, MSliderLabel,
				MSliderTooltip, MCustomThumb, MCustomBar, MSliderShowDiscreteValues, MItemsColor, MSliderChooseRange, MSliderThumbRadius, MInactiveAreaColor;

				MSliderRange(min : double, max : double);
				MSliderShowValue(show : bool);
				MSliderShowValueInput(show : bool);
				MSliderShowValueInputEnabled(enabled : Transform<bool>);
				MSliderIconLeft(name : string);
				MSliderIconRight(name : string);
				MSliderStep(value : double);
				MSliderSteps(steps : [double]);
				MSliderChooseRange(start : DynamicBehaviour<double>, end : DynamicBehaviour<double>, style : [MSliderChooseRangeStyle]);
					MSliderChooseRangeStyle ::= MSliderShowMainValue, MSliderShowMainValueInput, MSliderMainThumbStyle;
						MSliderShowMainValue(show : Transform<bool>);
						MSliderShowMainValueInput(show : bool);
						MSliderMainThumbStyle(style : (enabled : bool) -> Transform<[TGraphicsStyle]>);
				MSliderThumbRadius(radius : Transform<double>);
				MSliderDiscrete(discrete : bool);
				// By default true on mouse down or on hover if is undefined.
				MSliderShowDiscreteValues(show : Transform<bool>);
				MSliderUndefined(undefined : DynamicBehaviour<bool>);
				// Is mouse down inside slider
				MMouseDown(down : DynamicBehaviour<bool>);
				// Slider tooltip constructed from hovered value
				MSliderTooltip(textFn : (v : double) -> string);
				MSliderLabel(textFn : (v : double) -> string, style : [MTextStyle]);
				// Draws a caption under tick for each step
				MSliderCaption(fn : (v : double) -> Material);
				// Intended for accessibility
				MSliderStepDescription(description : (v : double) -> string);
				// Use own material for thumb
				// It's not reasonable to track thumb size to calculate the upper border of slider
				//   since thumb is likely to be animated. So use your own MBorder to set upper border
				//   if you're not satisfied with material spec one
				MCustomThumb(mkThumb : (down : Transform<bool>, focused : Transform<bool>) -> Material);
				MCustomBar(makeBar : (type : MSliderBarType, length : Transform<double>, style : [TGraphicsStyle]) -> Material);
				MInactiveAreaColor(color : MThemeColor);
				// Intended for MVideoPlayer
				MSliderHighlightedRanges(ranges : Transform<[MSliderHighlightedRange]>);
					MSliderHighlightedRange(start : DynamicBehaviour<double>, end : DynamicBehaviour<double>, style : [MSliderHighlightedRangeStyle]);
						MSliderHighlightedRangeStyle ::= MEnabled, MCustomMarker, MMarkersEnabled, MThemeColor, MTooltipText, MTooltipAlignmentDynamic,
							TExpandOnHover, MCustomBarStyle, MRangeCaption;

							MCustomMarker(fn : (hovered : Transform<bool>, isStart : bool) -> Material);
							MRangeCaption(text : string, onClick : () -> void);
							MCustomBarStyle(fn : (hovered : bool) -> [TGraphicsStyle]);
							MMarkersEnabled(enabled : Transform<bool>);
				// Do not update outer value every time it changes inside slider. Update only when slider is unfocused / pointer is up.
				MSliderUpdateOnEnd();
				// Inspector for the current visible slider position. Can be useful when MSliderUpdateOnEnd() is used.
				MSliderCurrentValue(currentValue : DynamicBehaviour<double>);

			MSliderBarType ::= LeftBar, ActiveBar, RightBar;
				LeftBar();
				ActiveBar();
				RightBar();

		// Be sure to make the width a multiple of 8
		// If width < 0, takes all available width
		// [Material Guidelines | Text Fields](https://material.io/design/components/text-fields.html)
		MTextInput(
			content : DynamicBehaviour<string>,
			style : [MTextInputStyle],
			state : [MTextInputState]
		);

		MAutoComplete(
			content : DynamicBehaviour<string>,
			// The words to complete on, separated by newlines.
			// The sentence matcher is called for each line, for each dictionary
			// The best performance comes if you give it just one dictionary,
			// i.e. ["Word1\nWrod2\nWord3"] is better than ["Word1", "Word2", "Word3"]
			dictionaries : [string],
			style : [MAutoCompleteStyle],
			state : [MTextInputState]
		);

		// Link is deprecated. TODO: add appropriate doc link here.
		// [Material Guidelines | Data Table Interactions](https://material.io/archive/guidelines/components/data-tables.html#data-tables-interaction)
		// Text input with edit popup. Intended for usage inside MDataTable.
		MSmallEditDialog(
			content : DynamicBehaviour<string>,
			style : [MTextInputStyle],
			state : [MTextInputState]
		);

			MTextInputStyle ::=
				MWidth /* Width of the input, takes full width if < 0*/, MLabel, MThemeColor, MInputCursor, MFloatingLabel, MFloatingLabelAlwaysOnTop,
				TextInputType, AutoCompleteType, Multiline, MMaxLines, ReadOnly, MaxChars, MShowMaxChars, MInlineMaxChars, PasswordMode, WordWrap, AutoAlign,
				MDynamicSize, MShowUnderline, MLeftIcon, MShowLeftButton, MStartCustomButtonT, MRightCustomButton, MShowClearIcon2, MOnClearIconClick,
				MShowDropDownArrow,	MShowEditIcon, MCustomTextStyle, MDynamicTextStyle, MLabelTextStyle, MInputFontPadding, MCondensed, MFilterAction,
				MInputBorders, MMaxHeight, MEditDialog, MElevation, MInputBackgroundStyle, MNativeInput, MHaveBeenFocused,
				MUnderlineUnfocusedStyle, MTextInputLeftIconUnderlineEnabled, MNumericStep, MIconSize, MIconButtonBorder, MTextInputScrollStyle,
				MFloatingLabelStyle, MCustomDisabledOpacity, MTextInputAllowEmojis, MTextInputNoNumericArrows,

				// Text input spec with filled frame.
				// https://material.io/design/components/text-fields.html#filled-text-field
				MFilled,

				// Text input spec with stroke outline.
				// https://material.io/design/components/text-fields.html#outlined-text-field
				MOutlined, MOutlineOpacity;

					// Move the label above the input on focus
					MFloatingLabel();
					MFloatingLabelAlwaysOnTop();
					// Hides max chars info below the input
					MShowMaxChars(show : bool);
					MInlineMaxChars();
					// Sets height of the box if input is multiline
					// Calculates height by the content if lines parameter equals 0 or -1 (affects MTextInput only)
					// If lines parameter < -1, calculates height by the content but limits its height to abs(lines parameter) lines (no limits for MEllipsisText)
					// For example, with MMaxLines(-4) input height can grow from 1 up to 4 lines
					MMaxLines(lines : int);
					// Elevation on focus (8. by default)
					MElevation(elevation : Transform<double>);
					// Show or hide line below input (Works with MTextInput and MAutoComplete)
					MShowUnderline(show : bool);
					// Style of the disabled underline
					MUnderlineUnfocusedStyle(style : [GraphicsStyle]);
					MTextInputLeftIconUnderlineEnabled(enabled : bool); // false by default
					// Show clear icon on focus and/or on hover
					MShowClearIcon(onFocus : bool, onHover : bool) { MShowClearIcon2(onFocus, onHover, false) };
					MShowClearIcon2(onFocus : bool, onHover : bool, always : bool); // always - always for non-empty content
					MOnClearIconClick(onClick : () -> void);
					// Show left button. Intended for MAutoComplete.
					MShowLeftButton(show : bool);
					// Height of input changes corresponding to the floating label and error visibility.
					MDynamicSize();
					// Label in empty input
					MLabel(label : string);
					// Left icon
					// See MShowLeftButton for action button
					MLeftIcon(icon : string, style : [MIconStyle]);
					// Left button
					MStartCustomButton(closed : Material, open : Material, inputIndent : double, useOverlay : bool) {
						MStartCustomButtonT(closed, open, const(inputIndent), useOverlay)
					}
					MStartCustomButtonT(closed : Material, open : Material, inputIndent : Transform<double>, useOverlay : bool);
					// Right button
					MRightCustomButton(button : Material);
					// Dropdown arrow on the right
					MShowDropDownArrow(show : bool);
					// Show edit icon
					MShowEditIcon(enabled : bool);
					// Action on enter or selecting of suggested result
					MFilterAction(action : (string) -> void);
					// Make input in dialog, added to MSmallEditDialog by default
					MEditDialog();
					// Text style of MLabel
					MLabelTextStyle(style : [MTextStyle]);
					MFloatingLabelStyle(style : [MTextStyle]);
					// Input background, empty for inputs without popups
					MInputBackgroundStyle(normal : [TGraphicsStyle], focused : [TGraphicsStyle]);
					MInputCursor(style : [MInputCursorStyle]);
						MInputCursorStyle ::= MThemeColor, FillOpacity, MWidth;
					// Borders of the input box
					// textInput/smallEdit : (0., if (hasFloatingLabel) {if (condensed) 20. else 28.} else {if (condensed) 12. else 16.}, 0.,
					// if (condensed) 12. else 16.)
					// autocomplete : (8., if (hasFloatingLabel) {if (condensed) 20. else 28.} else {if (condensed) 12. else 16.}, 8.,
					// if (condensed) 12. else 16.)
					MInputBorders(start : double, top : double, end : double, bottom : double);
					// Set useNativeInput to false for input field written using forms (true by default)
					// Intended only for cpp, in js can't recognize capslock state
					// Also you can set "nativeInputs" url parameter to 0
					MNativeInput(useNativeInput : bool);
					// Intended for using with MInputError only
					MHaveBeenFocused(focused : DynamicBehaviour<bool>);
					// Sets step to increase/decrease value into numeric type textinput
					MNumericStep(step : Transform<double>);
					// Disables standard browser numeric input arrows
					MTextInputNoNumericArrows();
					MFilled();
					MDynamicTextStyle(style : Transform<[MTextStyle]>);
					// scroll style when text is in preview mode
					MTextInputScrollStyle(style : [MScrollStyle]);
					MCustomDisabledOpacity(opacity : Transform<double>);
					// Allow emojis regardless of emoji flag
					MTextInputAllowEmojis(allowEmojis : bool);
					// Deprecated. Do not use.
					MInputFontPadding(padding : double);

			MAutoCompleteStyle ::=
				MTextInputStyle, MCompletionFn, TCompletionFn, MSentenceMatcher, MPreparedSentenceMatcher, MDictionaryDynamic,
				MCurrentMatches, TMatchedHandler, MShowAllOnEmpty, MMaxResults, MAutoSelect, MIncludeSpaces, MTextInputOutOfPopup, MInputNoLeftBorder,
				MSuggestionsBackgroundStyle, MSuggestionsPlacement, MSuggestionInLine, MSuggestionsDynamicListMode, MSuggestionsSameZorderMode,
				MAutoCompleteStartSearch, MCustomPopup, MPopupOutterBorder, MAutoCompleteShowMoreButton, MAutoCompleteAsync, MSetSelectedOnUnfocus, MKeepFocusOnSelect;
				// Material copy of TCompletionFn
				// Use fixed sizes for scroll to work properly
				MCompletionFn(
					fn : (
						match : SentenceMatch,
						selected : bool,
						setWord : (SentenceMatch) -> void
					) -> Material);
				// Custom sentence matching function
				// If you have a need to use auxiliary fields of SentenceMatcher (any except 'sentences') into MCompletionFn/MCurrentMatches/MSentenceMatcher.fn,
				// consider using MSentenceMatcher(buildSentenceMatcher, ...)
				// MSentenceMatcher(simpleBuildSentenceMatcher, simpleSentenceMatcher) by default
				MSentenceMatcher(
					matcher : (sentences : [string]) -> SentenceMatcher,
					fn : (matcher : SentenceMatcher, input : string, maxHits : int, prefix : bool, exhaustive : bool,
						position : int) -> [SentenceMatch]
				);
				// pre-built custom sentence matcher. When it is defined, the 'matcher' function of MSentenceMatcher is not used.
				MPreparedSentenceMatcher(matcher : Transform<SentenceMatcher>);
				// Dictionaries for auto completion
				// See dictionaries field comments in MAutoComplete above for more info
				MDictionary(dictionaries : [string]) { MDictionaryDynamic(const(dictionaries)); };
				MDictionaryDynamic(dictionaries : Transform<[string]>);
				// Dictionary id, sentence id, sentence hit
				MCurrentMatches(fn : ([Triple<int, int, SentenceMatch>]) -> void);
				// Shows suggestions only if content length >= minChars and wait milliseconds after last key event.
				// (0, 0) by default
				MAutoCompleteStartSearch(minChars : int, wait : int);
				// Shows all the sentences when input is empty
				// (MMaxResults win over this, i.e., if it's not set, only first 10 sentences will be shown)
				MShowAllOnEmpty();
				// Amount of suggested results (10 by default). -1 to remove limit
				MMaxResults(results : int);
				// Always select one of the possible results
				MAutoSelect();
				MSetSelectedOnUnfocus();
				MKeepFocusOnSelect();
				// Include spaces in autocompletition
				// False for multiline
				MIncludeSpaces(includeSpaces : bool);
				// Background of the suggestions dropdown
				MSuggestionsBackgroundStyle(style : [TGraphicsStyle]);
				// Defines suggestions area`s location.
				//   MTop/MBottom are strict ones.
				//   MTryTopFirst/MTryBottomFirst will relocate suggestions area in case of limited available space.
				MSuggestionsPlacement(type : MSuggestionsPlacementType); // MTryBottomFirst by default
					MSuggestionsPlacementType ::= MTop, MBottom, MTryTopFirst, MTryBottomFirst;
						MTryTopFirst();
						MTryBottomFirst();
				// Shows the best suggestion into input area. It may be approved by "enter"
				MSuggestionInLine(showPopup : bool);
				// Optimization for long lists
				MSuggestionsDynamicListMode();
				// Show suggestions under an input, not in popup
				MSuggestionsSameZorderMode();
				// Do not put MTextInput into popup.
				MTextInputOutOfPopup();
				// Set 0. to left border.
				MInputNoLeftBorder();
				MCustomPopup(
					offsetX : Maybe<Transform<double>>,
					offsetY : Maybe<Transform<double>>,
					width : Maybe<Transform<double>>
				);
				MPopupOutterBorder(border : double);
				MAutoCompleteShowMoreButton();
				// Makes a request on each input change; shows items, based on response array. 'dictionaries' is ignored.
				// Compatible with MAutoCompleteStartSearch
				MAutoCompleteAsync(makeRequest : (txt : string, onResponse : ([string]) -> void) -> void);

			MTextInputState ::= MButtonState, MHelperText, TTextInputState, MInputError, MInputShowPassword, MInputFilter, MPositionOnFocus,
				MSelectionOnFocus, MEatKeyDown, MInputProcessKeyDown, MInputPreventContextMenu;
				// Helper for error without content filtering
				// Also check passwordFilter and emailFilter in material_textinput_state.flow
				// MInputError(text : Transform<Maybe<string>>, style : [MInputErrorStyle]) -> MInputErrorFilter {
				//	MInputErrorFilter(\c, __ -> Pair(c, fselect(text, FLift(\t -> eitherMap(t, \t0 -> Some(Pair(t0, false)), None())))), style)
				// };

				// Can be used to filter the text itself, and get rid of stuff that is not right
				MInputFilter(fn : (content : string, foc : bool) -> string);

				MInputError(
					// Pair(new content, Maybe<Pair<error text, is blocking error (affect MInputIsOk)>>)
					text : Transform<Maybe<Pair<string, bool>>>,
					style : [MInputErrorStyle]
				);
					MInputErrorStyle ::= MMaxLines, MInputErrorColor, MRequiredField, MInputIsOk, MInputErrorFont;
						// error color (MErrorColor by default)
						MInputErrorColor(color : Transform<MThemeColor>);
						// Required Field
						MRequiredField();
						// Are there any errors
						MInputIsOk(ok : DynamicBehaviour<bool>);
						MInputErrorFont(style : MFontStyle);

				// Adds showPassword icon, added by default to PasswordType input
				MInputShowPassword(show : DynamicBehaviour<bool>);
				// Helper text displayed below the input
				// If persistent is false, helper text is hidden when there is no focus on the input
				MHelperText(text : Transform<Maybe<string>>, persistent : bool);
				MPositionOnFocus(fn : (content : string, previous : int) -> int);
				MSelectionOnFocus(fn : (content : string, previous : int) -> int);
				// Style to determine should keyEvent be blocked or not for other components
				// See defEatKeyDown in material_textinput_state for example
				MEatKeyDown(fn : (KeyEvent) -> bool);
				// is key to be processed by input or not
				MInputProcessKeyDown(fn : (KeyEvent) -> bool);
				// JS. Do not show context menu on right button click
				MInputPreventContextMenu();

		//
		// Menu
		//
		// [Material Guidelines | Menus](https://material.io/design/components/menus.html)


		// When button is MTextButton or MIconButton MOpenMenu is created automatically, in other cases
		// you should handle menu opening yourself.
		//
		// You can handle onClick actions from whole menu with item id as parameter using MOnListClick or
		// separately for each menu item using MOnClick. Same goes for MSubMenu.
		MMenu(button : Material, items : [MMenuLine], style : [MMenuStyle]);

			MMenuLine ::= MDropDownMenuLine, MSubMenu, MSubMenuDynamic, MSubMenuCustom;
				MMenuSingleLine(title : string, style : [MListLineState]);
				MMenuCustomLine(content : Material, style : [MListLineState]);
				MMenuGroupLine(title : string, style : [MListLineState]);
				MSubMenu(title : string, items : [MMenuLine], style : [MSubMenuStyle]);
				MSubMenuDynamic(title : Transform<string>, items : Transform<[MMenuLine]>, style : [MSubMenuStyle]);
				MSubMenuCustom(content : Material, items : Transform<[MMenuLine]>, style : [MSubMenuStyle]);

			MMenuStyle ::= MListStyle, MOnListClick, MButtonState, MMenuIndent, MSingleSelection, MSingleSelectionToggle, MDataTableFooter, MDataTableRow,
				MOpenMenu, MMaxHeight, MWidthByButton, MMenuWidthLimits, MBelowButton, MWidth, MSelectedAlwaysOnTop, MMenuNonSpecifiedAlwaysOnTop, MShowTooltip /* Doesn`t work for MMenuCustomLine */,
				MCustomLineHeight, MOpenOnClick, MMenuShift/*, MNoFocus*/, MFixPosition, MCustomScale, MMenuCols, MLabel, MMenuNoSnapSize, MMenuExpandingAnimation,
				MLeftIcon, MSameZorder, MForceUpdate, MBlockClicks, MDropDownIconNearTitle, MDropDownMenuIconBorders, MMenuLineBorders, MMenuPopupBorders,
				MMenuScrollStyle, MMenuCustomPopup, MMenuOpenDelay, MOutlined, MCloseOnClickEnabled, MMenuUseFocusInspector;

					MOpenMenu(opened : DynamicBehaviour<bool>);
					// Adds indent to every menu item, even if it has no primary action.
					MMenuIndent();
					MMaxHeight(height : double);
					MWidthByButton();
					MMenuWidthLimits(minWidth : Transform<double>, maxWidth : Transform<double>); // Works only with MWidth(-1.) or MWidth(0.)
					MBelowButton();
					MDataTableRow();
					MDataTableFooter();
					MSelectedAlwaysOnTop(emptySelection : MMenuLine); // Intended for MDropDownMenu.
					MMenuNonSpecifiedAlwaysOnTop(emptySelection : MMenuLine); // Intended for MDropDownMenu
					MOpenOnClick(); // False by default, true for dropdown's custom button
					MMenuShift(shift : Transform<Point>);
					// MNoFocus();
					MCustomLineHeight(height : double);
					// Pin popup y coordinate : top or bottom.
					MFixPosition(top : bool);
					MCustomScale(factor : Transform<Factor>);
					MMenuCols(cols : int);
					// Don't change zorder on open menu
					MSameZorder(same : bool);
					// if present we allow to update current by the same value (other words use `next` instead of `nextDistinct` inside)
					MForceUpdate();
					// Block clicks outside menu
					MBlockClicks();
					// Intended for MDropDownMenu. Get rid of filler between title and icon.
					MDropDownIconNearTitle();
					// Left/right borders
					MMenuLineBorders(borders : double);
					// Top/bottom borders
					MMenuPopupBorders(borders : double);
					MMenuNoSnapSize();
					MMenuScrollStyle(style : [MScrollStyle]); // only MScrollWidthHeight, MScrollPosition, TScrollPersistent are supported now
					MMenuExpandingAnimation();
					MMenuCustomPopup(buttonWH : Maybe<DynamicBehaviour<WidthHeight>>, positionScale : Maybe<Transform<PositionScale>>);
					// Unselect item if it was previously selected
					MSingleSelectionToggle();
					// Popup opening delay, ms
					MMenuOpenDelay(delay : int);
					// Should we close popup after line is clicked? By default, true for single/custom and false for submenu.
					MCloseOnClickEnabled(enabled : Transform<bool>);
					// Additional focus inspector to close popup on blur. Helpful for handling clicks inside iframe area.
					MMenuUseFocusInspector();

			MSubMenuStyle ::= MMenuStyle, MPrimaryAction, MSecondaryAction, MDisableHover, MSubMenuOpenOnClick, MCloseParentOnClick, MExpanding, MCustomTextStyle;
				MSubMenuOpenOnClick();
				// True by default
				MCloseParentOnClick(close : bool);
				// Children will be shown in the existing popup instead of opening new one.
				MExpanding();

		MDynamicMenu(button : Material, items : Transform<[MMenuLine]>, style : [MMenuStyle]);

		// Helper for dropdown like MMenu
		// [Material Guidelines | Dropdown Menu](https://material.io/design/components/menus.html#dropdown-menu)
		MDropDownMenu(items : [MDropDownMenuLine], current : DynamicBehaviour<int>, style : [MDropDownMenuStyle]);
			MDropDownMenuLine ::= MNonSpecifiedLine, MSeparatorLine, MMenuGroupLine;
			MDropDownMenuStyle ::= MMenuStyle, MCustomButton, MDontOpenOnClick, MDropDownMenuButtonBorder, MNonSpecified, MCroppedButton, MSeparators, MSeparatorsColor, MAddClearButton,
								   MDropDownMenuDisabledOpacity, MNonSpecifiedAlwaysOnTop, MOutlined, MOutlineColor, MOutlineOpacity, MOutlineWidth, MFilled,
								   MDropDownMenuIconColor, MDropDownMenuCropByContent, MDropDownMenuButtonBackground, FAccessStyle;

					MNonSpecified(item : MNonSpecifiedLine);
						MNonSpecifiedLine ::= MMenuSingleLine, MMenuCustomLine;
					MCustomButton(button : Material);
					MDontOpenOnClick(); // Intended for custom button
					MCroppedButton();
					MSeparators(separators : bool);
					MSeparatorsColor(color : MColor);
					// Adds an icon button, which sets current selection to non-specified (-1 for MDropDownMenu or [] for MMultiSelectDropDown).
					MAddClearButton();
					MDropDownMenuDisabledOpacity(opacity : Transform<double>);
					MNonSpecifiedAlwaysOnTop();
					MDropDownMenuButtonBorder(border : double);
					MDropDownMenuButtonBackground(fn : (active : bool) -> [TGraphicsStyle]);
					MDropDownMenuIconBorders(borders : MIconBorder4);
					MDropDownMenuIconColor(color : MColor);
					// applies only to the selected item
					MDropDownMenuCropByContent();

		// Menu panel that takes full width.
		MMenuPanel(items : [Material], style : [MMenuPanelStyle]);
			// MMenuPanelItems ::= MDropDownMenu, MMenu, MDropDown, MTextButton, MIconButton, MSeparator;

			MMenuPanelStyle ::= MMenuPanelBackground, MElevation, MBackgroundStyle, MHeight, MBorders, TScrollCropByContent,
				TExpandOnHover, MComponentGroupState;

				MMenuPanelBackground(color : MThemeColor);
				MHeight(height : double);
				MBorders(borders : double);

		// The non-specified string is used when the current item is outside the range of items
		// Link is deprecated. TODO: add appropriate doc link here.
		// [Material Guidelines | Dropdown Buttons](https://material.io/archive/guidelines/components/buttons.html#buttons-dropdown-buttons)
		MDropDown(current : DynamicBehaviour<int>, nonSpecified : string, items : [string], style : [MDropDownStyle]);
			MDropDownStyle ::= MDropDownMenuStyle, MGroups, MLeftDecorations, MRightDecorations, MDropDownBorder, MDropDownItemsEnabled;

				// Unclickable items: first parameter is id of item it should be displayed before, second is caption
				MGroups(groups : [Pair<int, string>]);
				// Place next to item corresponding Material, length of extraItems should be equal length of items.
				MLeftDecorations(extraItems : [Material]);
				MRightDecorations(extraItems : [Material]);
				MDropDownItemsEnabled(enabled : [Transform<bool>]);
				MDropDownBorder(left : double, top : double, right : double, bottom : double);

		MMultiSelectDropDown(selected : DynamicBehaviour<[int]>, items : [string], style : [MMultiSelectDropDownStyle]);
			MMultiSelectDropDownStyle ::= MNonSpecifiedString, MMaxHeight, MWidth, MCustomLineHeight, MCustomTextStyle, MSelectedItemStyle, MOnItemClick, MDataTableFooter, MDataTableRow, MSeparators,
				MAddDoneButton, MAdditionalButtons, MEnabled, MAddClearButton, MShowTooltip, MDropDownIconNearTitle, MCroppedButton, MCustomButton, MDontOpenOnClick, MBelowButton, MDropDownMenuButtonBackground,
				MLeftDecorations, MRightDecorations, MDropDownMenuDisabledOpacity, MMenuLineBorders, MOutlined, MFilled, MButtonState, MOpenMenu, MShowSelectedIcon, MListSelectionEnabled, MMenuOpenDelay;

				MSelectedItemStyle(textColor : MThemeColor, bgColor : MThemeColor);
				MNonSpecifiedString(item : string); // "Pick" by default
				MOnItemClick(fn :(index : int, selected : bool) -> void);
				MAddDoneButton();
				MAdditionalButtons(buttons : [Material]);
				MShowSelectedIcon(show : bool); // true by default

		//
		// Lists, dropdown, tables
		//
		// [Material Guidelines | Lists](https://material.io/design/components/lists.html)
		MList(lines : [MListLine], style : [MListStyle], state : [MListState]);

			MListStyle ::=
				MThemeColor, MSelectedColor, MBackgroundStyle, MSelectedBackgroundStyle,
				MEmptyMessage, MListWidth, MCondensed, MAddSeparators, MAddScroll,
				MCollapseUnactive, MListMinimize, MListMinimizedWidth, MNoEllipsis,	MSideBorders, MPrimaryActionWidth,
				MVerticalFillersSupport;

				// When the list is empty, display this in the center
				MEmptyMessage(message : Material);
				// MSelectedX styles works only with MListSelection() state
				MSelectedBackgroundStyle(style : [TGraphicsStyle]);
				MSelectedColor(color : MThemeColor);
				// If width < 0 list takes all available width
				// (-1.0, -1.0 by default)
				MListWidth(minWidth : double, maxWidth : double);
				// Add shadow and separators.
				MAddSeparators();
				// If None(), creates TScrollInspectVisible by default.
				MAddScroll(scrollInpect : Maybe<TScrollInspectVisible>);
				MCollapseUnactive();
				MListMinimize(minimize : Transform<bool>);
				MListMinimizedWidth(width : double); // 72. by default
				MNoEllipsis();
				// Add borders to left and right sides of each line (16.0 by default)
				MSideBorders(borders : Transform<double>);
				// Set width of each line`s primary action (72.0 by default)
				MPrimaryActionWidth(width : Transform<double>);
				// Do not supress vertical fillers into lines in case of MHeight(-1.) or unset MHeight
				MVerticalFillersSupport();


			MListState ::= MListSelection, MListSelectionEnabled, MOnListClick, MListReorder, MListReorderHideIcon, MGrabDelay,
			               MHoverEnabled, MEnabled, IScriptRecordingEnabled, MReorderDropSpot, MReorderCustomDraggingOrder, MReorderOnDragEnd;

				MListSelection(enabled : Transform<bool>, multiple : bool, toggle : bool, selected : DynamicBehaviour<[int]>);
				MListSelectionEnabled(enabled : Transform<[Transform<bool>]>);
				MOnListClick(enabled : Transform<bool>, onClick : (int) -> void);
				MListReorder(order : DynamicBehaviour<[int]>, enabled : Transform<bool>);
				// Hide standard "drag_handle" icon which added automatically by MListReorder style
				MListReorderHideIcon();
				// Substitutes standard "drag_handle" icon with custom one
				MListCustomReorderHandle(handle : Material, alignment : RelativeOrAbsoluteAlignment);
				// Disable hover
				MHoverEnabled(enabled : Transform<bool>);

			MListLine ::= MSingleLine, MDoubleLine, MTripleLine, MSubmenuLine, MCustomLine, MSeparatorLine;

				MSingleLine(title : string, state : [MListLineState]);
				MDoubleLine(title : string, subtitle : string, state : [MListLineState]);
				MTripleLine(title : string, subtitle : string, state : [MListLineState]);
				MCustomLine(content : Material, state : [MListLineState]);
				MSubmenuLine(main : MListLine, lines : Transform<[MListLine]>, style : [MSubListStyle], expanded : DynamicBehaviour<bool>);

					MSubListStyle ::= MListState, MThemeColor, MSelectedColor, Fill, FillOpacity, MCustomExpanding, MNoDispose, MSideBorders;
						// MList will not change 'expanded' by user's click
						MCustomExpanding();
						MNoDispose();
				MSeparatorLine();

				MListLineState ::= MButtonState, MPrimaryAction, MSecondaryAction, MLeaveBehind, MAdditionalText,
				                   MCustomTextStyle, MCustomSecondaryTextStyle, MHeight, MCustomLineCenterActions;

					MPrimaryAction(content : Material);
					MSecondaryAction(content : Material);
					MLeaveBehind ::= MLeftLeaveBehind, MRightLeaveBehind;
						MLeftLeaveBehind(icon : Material, action : () -> void, style : [MLeaveBehindStyle]);
						MRightLeaveBehind(icon : Material, action : () -> void, style : [MLeaveBehindStyle]);

						MLeaveBehindStyle ::= MGapSize, MLeaveBehindPosition;
							MGapSize(size : double, stopOnGap : bool); // MGapSize(56., true) by default
							MLeaveBehindPosition(position : DynamicBehaviour<double>);
					// Intended for shortcuts info.
					MAdditionalText(text : string);

					// Custom size and color, use MCustomFont for custom fontfamilies and opacities.
					MCustomTextStyle(style : [MTextStyle]);
					MCustomSecondaryTextStyle(style : [MTextStyle]);
					MCustomLineCenterActions();


		MDynamicList(items : Transform<[MListLine]>, style : [MDynamicListStyle], state : [MDynamicListState]);
			MDynamicListStyle ::= MThemeColor, MEmptyMessage, MListWidth, MSelectedColor, MBackgroundStyle, MSelectedBackgroundStyle, MCondensed,
			                      MAddSeparators, MSideBorders, MPrimaryActionWidth, MListMinimize, MListMinimizedWidth, MListGap;
			MDynamicListState ::= IScriptRecordingEnabled, MListSelection, MListSelectionEnabled, MOnListClick,
			                      MHoverEnabled, MItemsHeights, MScrollStyle, MListReorder, MListReorderHideIcon, MListCustomReorderHandle,
			                      MGrabDelay, MNoScroll, MReorderDropSpot, MReorderCustomDraggingOrder, MButtonTitle;

				MItemsHeights(height : (int) -> Transform<double>);
				MListGap(gap : double); // Add a gap between lines

		//
		// Carousel
		//

		MCarousel(contents : [MCarouselContent], activeIdx : DynamicBehaviour<int>, style : [MCarouselStyle]);

			MCarouselContent(content : Material, style : [MCarouselContentStyle]);
				MCarouselContentStyle ::= MCarouselText, MOnClick, MCarouselTextStyle;
					MCarouselText(title : string, subtitle : string);
					MCarouselTextStyle(title : [MTextStyle], subtitle : [MTextStyle]);

			MCarouselStyle ::= MCarouselItemSpan, MBackgroundStyle, MCarouselTextColor, MCarouselFooterColor, MCarouselFooterOpacity,
				MCarouselButtonsColor, MNoProgress, MProgressAtBottom, MProgressColors, MCarouselProgressSpacing, MNoChevrons, MEnabled, MDuration,
				MCarouselEnableArrows, MCarouselCustomPanning, MLoopScroll, MIconSize, MCarouselContentZoom, MCarouselMaximize, TCurrentInteractive,
				MCarouselHeightByContent, MCarouselDisableSideChevrons, MCarouselSidesOffset, MCarouselChevronTunes, MCarouselChevronStyle,
				MCarouselNoContentScaling, MSingleSelection, MCarouselAvailableTweaksEnabled, MCarouselSwipeEnabled;

				MCarouselItemSpan(span : int); // defaults to 1
				MCarouselTextColor(color : MThemeColor); // defaults to MWhite
				MCarouselFooterColor(color : MThemeColor); // defaults to MGray(900)
				MCarouselFooterOpacity(opacity : double); // defaults to 0.8
				MCarouselButtonsColor(color : MThemeColor); // useful in case buttons not visible on white images, defaults to MWhite
				MNoChevrons(); // hide navigation buttons
				MCarouselDisableSideChevrons(); // Disable first and last chevrons. Doesn`t work for loop scroll.
				MNoProgress(); // hide progress circles
				MProgressAtBottom(); // progress circles at the bottom of carousel
				MProgressColors(active : MThemeColor, inactive : MThemeColor);
				MCarouselProgressSpacing(spacing : double); // 2.0 by default
				MCarouselNoContentScaling();
				MCarouselEnableArrows(ignoreFocus : bool);
				// 'shiftX' is a total horizontal shift, not delta. Change of 'mousedown' from true to false fires animated end of panning -
				// similar to user's mousedown
				MCarouselCustomPanning(shiftX : DynamicBehaviour<double>, mousedown : DynamicBehaviour<bool>);
				MLoopScroll();
				MCarouselContentZoom(min : double, max : double, step : double);
				MCarouselMaximize(maximized : DynamicBehaviour<bool>, style : [MCarouselMaximizeStyle]);
					MCarouselMaximizeStyle ::= MNoProgress, MNoChevrons, MShowTextOverlay, MMaximizeFullscreen, MCarouselContentZoom, MDisableSwipe;
						MShowTextOverlay();
						MMaximizeFullscreen();
						MDisableSwipe();

				// Ignore golden ratio and available height, crop by maximum content height instead.
				MCarouselHeightByContent();
				MCarouselSidesOffset(sideOffset : double);
				MCarouselChevronTunes(shadows : bool, positionY : double);
				MCarouselChevronStyle(style : [MIconButtonStyle]);
				// Temporary style to disable inner available box changes. True by default, false under new=1. Intended to be deleted if no issues will be found
				MCarouselAvailableTweaksEnabled(enabled : bool);
				// By default - true if number of elements is bigger than number of slots
				MCarouselSwipeEnabled(enabled : bool);

		// Improved version of data table, which uses less memory for big amount of data, but doesn't support some styles
		// Is recommended one by default, use MDynamicDataTable only if you need unsupported styles
		MLightweightDataTable(columns : [MColumnDynamic], data : Transform<[?]>, rowsFn : (?) -> [Material], style : [MLightweightDataTableStyle]);

		// Same as above, but you can additionally define colspan/rowspan for specific table cell
		MSpannableDataTable(columns : [MColumnDynamic], data : Transform<[?]>, rowsFn : (?) -> [MCell], style : [MLightweightDataTableStyle]);
			MCell(content : Material, colspan : int, rowspan : int);

			// The width should be in a multiple of 8
			MColumn(header : string, tooltip : string, width : int, style : [MColumnStyle]) -> MColumnDynamic {
				MColumnDynamic(const(header), const(tooltip), const(width), style);
			};
			MColumnDynamic(header : Transform<string>, tooltip : Transform<string>, width : Transform<int>, style : [MColumnStyle]);
				MColumnStyle ::= MHeaderStyle, CommonAlignment, MSort, MSortByValue, MAutoSort, MAutoSortCaseInsensitive, MAutoSortByRowData, MMaxWidth,
				                 MWidthByContent, MWidthByContentLimited, MColumnCustomTitle, MColumnWidthInspector, MEnabled;

					// Intended for MLightweightDataTable. With this style corresponding row from 'data' will be used for comparison.
					// Otherwise rowsFn will be applied, and rows will be compared, using their Material representation.
					MAutoSortByRowData();
					// Sort data as string regardless of capitalization.
					// Consider combining with MAutoSortByRowData to prevent calling rowsFn for each row. Use MSortByValue as alternative.
					MAutoSortCaseInsensitive();
					// Style for custom sorting
					MSort(colCompares : (int, int) -> int);
					// Intended for MLightweightDataTable. Function receives data row and should return a value to sort by.
					// For MDynamicDataTable function receives row : [Material]
					MSortByValue(getValueFn : (?) -> ??);
					// Max width of the column, should be used with MFullWidth or MFullAdvanced. If less than column width, the latter wins.
					MMaxWidth(width : int);
					// Sets column width by content width. Overrides "width" parameter and MMaxWidth.
					MWidthByContent(); // equal to MWidthByContentLimited(const(-1.), const(-1.))
					MWidthByContentLimited(minWidth : Transform<double>, maxWidth : Transform<double>); // -1. for unlimited
					MColumnCustomTitle(fn : (selected : bool) -> Material);
					MColumnWidthInspector(width : DynamicBehaviour<double>);

					// ---------------- WARNING: DEPRECATED STYLE ----------------
					// Use it only you do need to sort rows by their material representation
					MAutoSort();
					// -----------------------------------------------------------


			MLightweightDataTableStyle ::= MListSelection, MListSelectionEnabled, MPagination, MPaginationAutoScaling, MCondensed, MSortingDefault, MFullWidth,
								MFullWidthAdvanced, MInCard, MOnListClick, MMinTableHeight, MCropPageByVisibleLines, MSingleSelection, MMultiSelection,
								MSelectedBackgroundStyle, MCurrentPage, MGoToIndex, MHeaderActions, MCheckBoxSelection, MRowHeight, MHeaderRowHeight, MHoverEnabled, MClickEnabled,
								MRowSpacing, MNoSeparators, MNoFooter, MHideAutoPaginationFooter, MHeaderStyle, MListSorted, MRowBackgroundStyle,
								MExternalSort, MWidthByContent /*Sets this style to all columns*/, MNoCrop /*Do not crop cell content*/,
								MShowRowNumbers, MRowsPerPage, MUpdateSorting, MDataTableInnerScroll, MEnabled,
								MDataTableScrollStyle, MDataTableScrollByPage, MDataTableScrollByRow, TScrollPosition, TScrollEnabled;

			MDataTableStyle ::= MLightweightDataTableStyle, MListReorder /*Disables pagination and sorting*/, MListReorderHideIcon, MReorderOnDragEnd,
								MFixedRow, MExpandRow;

				// Style adds footer with pagination
				MPagination(current : DynamicBehaviour<int>, rowsPerPage: [int]);
				// Style inspects the available vertical space, and defines the number of rows accordingly -
				// assuming fixed height rows (48 dp default and 32 dp for MCondensed style)
				MPaginationAutoScaling();
				// Style for slimmer rows (height = 32 dp)
				MCondensed(condensed : bool);
				// Style for rows with a specified height
				MRowHeight(height : double);
				MHeaderRowHeight(height : double);
				// Style for default sorting: columnIndex, isAscending
				MSortingDefault(sorting : DynamicBehaviour<MSortingParam>);
					// Sorts by first column by default (without this style). To disable default sorting use -1 for colIndex.
					MSortingParam(colIndex : int, isAsc : bool);
				// Style for expand space between columns to full width
				MFullWidth();
				// Style for increase width of columns (a multiple of 8), keeping the ratio of widths, to full width
				MFullWidthAdvanced();
				// Adds elevation and background to table
				MInCard();
				// Style to define a minimum height
				MMinTableHeigth(height) -> MMinTableHeight { MMinTableHeight(height); }
				MMinTableHeight(height : double);
				// Crops page height, if there are fewer lines than available on page.
				MCropPageByVisibleLines();
				// Helpers for easier selection, for advanced stuff use MListSelection
				MSingleSelection(selected : DynamicBehaviour<int>);
				MMultiSelection(selected : DynamicBehaviour<Set<int>>);

				// Allows inspect or change page number
				MCurrentPage(page : DynamicBehaviour<int>);
				// Set number of row to show
				MGoToIndex(index : DynamicBehaviour<int>);
				// Only inspects current rows per page
				MRowsPerPage(rowsPerPage : DynamicBehaviour<int>);

				// Style to define DataTable headers background and text style. textStyleSelected is useless, it is here for compability reasons.
				MHeaderStyle(background : [TGraphicsStyle], textStyle : [MEllipsisTextStyle], textStyleSelected : [MTextStyle]);

				// Adds an additional header to table or replaces current. Avoid using height fillers in actions when MPaginationAutoScaling is present.
				MHeaderActions(actions : Material, style : [MDataTableHeaderActionsStyle]);
					MDataTableHeaderActionsStyle ::= MReplaceHeader;
					MReplaceHeader();

				MCheckBoxSelection(style : [MCheckBoxSelectionStyle]);
					MCheckBoxSelectionStyle ::= MThemeColor, MIconSize, MCheckboxSelectAllPages;
						// When true, 'Select All' checkbox select all selectable items in the table
						// By default, it selects only current page
						MCheckboxSelectAllPages(enabled : Transform<bool>);

				MRowSpacing(spacing : double);
				MNoSeparators();
				// Removes footer area. Ignored if pagination is on.
				MNoFooter();
				// Hides footer in case of MPaginationAutoScaling and all rows are on one page.
				MHideAutoPaginationFooter();
				// Enabled or disable row expansion
				MExpandRow(enabled : Transform<bool>);
				// Add this cols as a first fixed row
				MFixedRow(show : Transform<bool>, cols : [Material], style : [MFixedRowStyle]);
					MFixedRowStyle ::= TGraphicsStyle, MOnClick;
				// Returns new sequence of rows indexes if data was sorted
				MListSorted(newOrderCallback : ([int]) -> void);
				// Add background for each row by row number (zero based)
				MRowBackgroundStyle(fn : (rowIndex : int) -> [TGraphicsStyle]);
				// For external sorting (SQL sorting for example). Turns off sorting in MDataTable but keeps column header sorting icon.
				// Sorting params (columnIndex, ascending) use from MSortingDefault
				MExternalSort();
				// Updates sorting every n ms
				MUpdateSorting(delay : int);
				// Adds a column to the left with row numbers
				MShowRowNumbers();
				// Vertical scroll
				MDataTableScrollStyle(style : [MScrollStyle]);
				// Vertical scroll position will be rounded by page/row height
				MDataTableScrollByPage();
				MDataTableScrollByRow();
				// Horizontal scroll
				MDataTableInnerScroll(mode : MDataTableScrollMode, style : [MScrollStyle]);
					MDataTableScrollMode ::= MStandardMode, MGluedFirstColumnMode, MLiftedFirstColumnMode;
						MStandardMode();
						MGluedFirstColumnMode(style : [MGluedFirstColumnModeStyle]);
							MGluedFirstColumnModeStyle ::= MSeparatorVisible, MGluedColumns;
								MSeparatorVisible(visible : Transform<bool>);
								MGluedColumns(columns : int);
						MLiftedFirstColumnMode();

		//
		// Line Chart
		//
		// [Google Charts | Line Chart](https://developers.google.com/chart/interactive/docs/gallery/linechart)

		// Heigth of the chart is calculated without title and subtitle height
		// Width of the chart is calculated with width of the legend which is 1/4 of the chart width
		MChart(data : MChartData, style : [MChartStyle]);

			MChartStyle ::= MChartTitle, MChartSubtitle, MYAxisCaption, MShowVerticalLines, MShowHorizontalLines, MChartCurve,
			                MHideLegend, MXAxisScope, MYAxisScope, MValuesPostfix, MTooltipValuesPostfix, MXAxisIsDate2, MChartScale,
			                MXAxisVertical, MYAxisValuesOnLines, MInCard, MEmptyMessage, MValuesLabels, MLineLabels, WidthHeight, MChartType, MBarWidth, MOnChartClick,
			                MXAxisGridStep, MYAxisGridStep, MChartLinesStyle, MLinesColors, MXAxisValuesMove, MYAxisValuesMove,
			                MHideYAxisValues, MHideValueHover, MXAxisStyle, MXAxisValuesTranslate, MHidePoints, EscapeHTML;

				// Color, opacity and width of the chart lines in their order. Opacity by default is 1.0. Width by default is 2.0.
				// Colors by default are taken from standart : MBlue(500), MOrange(500), MGreen(500), MPurple(500),
				// MRed(500), MTeal(500), MLime(500), MBrown(500), MCyan(500)
				MChartLinesStyle : (style : [[MLineStyle]]);
					MLineStyle ::= MThemeColor, FillOpacity, MWidth, MLineType, MHidePoints, MPointLabel, MPointLabelStyle, MPointMarker;
						MLineType(type: MMLineType);
							MMLineType ::= MLineSolid, MLineDashed, MLineDotted;
								MLineSolid();
								MLineDashed();
								MLineDotted();
						MHidePoints();
						// custom values labels
						MPointLabel(getLabel : (value : double) -> string);
						MPointLabelStyle(style : [TParagraphStyle]);
						// custom markers. only for lines
						MPointMarker(getMarker : (index : int, y : double) -> Material);

				// Title displayed at the top of the chart
				MChartTitle(title : string);

				// Subtitle displayed below the title at the top of the chart, can be used without title
				MChartSubtitle(subtitle : string);

				// TODO: Add curve type
				MChartCurve();

				// Caption of the YAxis displayed at the left of the chart
				MYAxisCaption(caption : string);

				// Postfix which is added at the end of every YAxis value
				// For example MValuesPostfix(" s") will produce values like "1 s", "2 s" etc.
				MValuesPostfix(postfix : string);
				// The same as MValuesPostfix but without vertAxis modification
				MTooltipValuesPostfix(postfix : string);

				// Show vertical lines
				MShowVerticalLines();

				// Show horizontal lines
				MShowHorizontalLines();

				// Hides chart legend at the right of the chart
				MHideLegend();

				// Min and max values of the corresponding axis
				MXAxisScope(xAxisMin : double, xAxisMax : double);
				MYAxisScope(yAxisMin : double, yAxisMax : double);

				// XAxis values are timestamps and converted into date
				MXAxisIsDate() { MXAxisIsDate2(false) };
				MXAxisIsDate2(showYear : bool);

				// Chart items scalling
				MChartScale(scale : double);

				// Display xAxis values vertically
				MXAxisVertical();

				// Move xAxis values
				MXAxisValuesTranslate(point : Transform<Point>);

				// Display yAxis values on lines
				MYAxisValuesOnLines();

				// Adds points value labels
				MValuesLabels(withPostfix : bool);

				// Adds lines labels. Use MPointLabelStyle to customize line label style.
				MLineLabels();

				// Width of the bars, 4. by default
				// gapWidth - distance between bars, 1. by default
				MBarWidth(width : double, gapWidth : double);

				MOnChartClick(click : [(int) -> void]);

				MChartType(chartType : [MMChartType]);
					MMChartType ::= MBarChart, MLineChart;
						MBarChart();
						MLineChart();

				// Custom steps for grid
				MXAxisGridStep(step: double);
				MYAxisGridStep(step: double);

				// Obsolete. Use MThemeColor into MChartLinesStyle instead of it. Needs for backward compatibility into cog9platform.
				MLinesColors(colors : [MThemeColor]);

				// Moving of the crossing point of the axes
				MXAxisValuesMove(value : double);
				MYAxisValuesMove(value : double);

				// Hide the values of YAxis
				MHideYAxisValues();

				// Do not show hover for points
				MHideValueHover();

				// styles for MChartData.rows
				// [[MCaptionColumn()], [MTitle(), MRed(700)], ...]
				MXAxisStyle(style : [[MTextStyle]]);

			// Columns are the names of the chart lines in their order, first column is the name of XAxis
			//
			// Rows are the names of the chart rows in their order, can be empty
			//
			// Data is the values of the chart points, first value in every row is XAxis value
			//
			// Use -doubleMax to indicate no value.

			// Example:
			// MChartData(
			// ["YAxis Name", "First Chart Name", "Second Chart Name"],
			// ["First Column Name", "Second Column Name", "Third Column Name", "Fourth Column Name"],
			// [
			//	[1.0, -doubleMax, 20.0],
			//	[2.0, 30.0, 50.0],
			//	[3.0, 20.0, 10.0],
			//	[4.0, 40.0, 70.0]
			// ])
			MChartData(columns : [string], rows : [string], data : [[double]]);

		MDynamicChart(columns : Transform<[MChartColumn]>, rows : Transform<[MChartRow]>, style : [MDynamicChartStyle]);
			// Use -doubleMax to indicate no value.
			MChartColumn ::= MBarChartColumn, MLineChartColumn;
				MBarChartColumn(name : string, data : [double], style : [MBarChartColumnStyle]);
					MBarChartColumnStyle ::= MChartColumnStyle, MBarWidth;

				MLineChartColumn(name : string, data : [double], style : [MLineChartColumnStyle]);
					MLineChartColumnStyle ::= MChartColumnStyle, MWidth, MHidePoints, MPointMarker,
					                          MLineType, MChartCurve, MColumnRangeData, MLineTypeChanges;

						MColumnRangeData(data : [Pair<double, double>]);
						// Changes line type after point with defined index.
						MLineTypeChanges(changes : [MLineTypeChange]);
							MLineTypeChange(index : int, type : MMLineType);

					MChartColumnStyle ::= MThemeColor, FillOpacity, MColumnVisible, MColumnShowValuesOnHover, MOnListClick, MHideValueHover,
					                      MValuesLabels, MValuesPostfix, MTooltipValuesPostfix, MPointLabel, MPointLabelStyle;

						MColumnVisible(visible : DynamicBehaviour<bool>);
						MColumnShowValuesOnHover(show : Transform<bool>); // Shows all values of the column

			MChartRow(name : string, value : double);

			MDynamicChartStyle ::= MChartTitle, MChartSubtitle, MEmptyMessage, MValuesLabels, MValuesPostfix, MTooltipValuesPostfix, EscapeHTML,
			                       MAxesStyle, MInCard, MHideLegend, MChartCurve, MHidePoints, MHideValueHover, MLineLabels;

				MAxesStyle(x : [MAxisStyle], y : [MAxisStyle]);
					MAxisStyle ::= MAxisLineVisible, MAxisValuesVisible, MAxisValuesStyle, MAxisValuesVertical, MAxisValuesOnAxis,
					               MAxisGridVisible, MAxisGridStep, MAxisGridScope, MAxisGridCenter, MAxisGridZoomEnabled,
					               MAxisCaption, MAxisIsDate;

						MAxisLineVisible(visible : Transform<bool>);

						MAxisGridVisible(visible : Transform<bool>);
						MAxisGridStep(step : Transform<double>);
						MAxisGridScope(min : Transform<double>, max : Transform<double>);
						MAxisGridCenter(center : Transform<double>);
						MAxisGridZoomEnabled(enabled : Transform<bool>);

						MAxisValuesVisible(visible : Transform<bool>);
						MAxisValuesStyle(style : Transform<[[MTextStyle]]>);
						MAxisValuesVertical(vertical : Transform<bool>);
						MAxisValuesOnAxis(onAxis : Transform<bool>);
						MAxisValuesTranslate(translate : Transform<Point>);

						MAxisCaption(caption : Transform<string>);
						MAxisIsDate(isDate : Transform<bool>);

		//
		// Time and date picker
		//

		// [Material Guidelines | Pickers](https://material.io/design/components/pickers.html)
		MDatePicker(date : DynamicBehaviour<Date>, style : [MDatePickerStyle]);
			MDatePickerStyle ::= MDateMin, MDateMax, MThemeColor, MDialogAlbum, MDialogButtons, MDateFormat, MMarkDays, MCustomMark,
								MEnabled, MYearDisabled, MUpdateOnClose, MNoHeader, MDatePickerFirstWeekDay, MMultipleDate, MOnDateClick;
				MDateMin(d : Date);
				MDateMax(d : Date);
				MDialogAlbum(album : bool);
				MDateFormat(f : string);
				MMarkDays(isMarked : (date : Date) -> bool);
				MCustomMark(addMark : (date : Transform<Date>, color : Transform<MThemeColor>, text : Material) -> Material);
				MYearDisabled();
				// Update picker behaviour only when it's closed
				MUpdateOnClose();
				MDatePickerFirstWeekDay(monday : bool); // false by default, starts from Sunday
				MNoHeader();
				MMultipleDate(dates : DynamicBehaviour<[Date]>, style : [MMultipleDateStyle]);
				MOnDateClick(onDateClick : (date : Date) -> void);

			MMultipleDateStyle ::= MThemeColor, MNoChanges;
				// Prevents dates changes by user interaction
				MNoChanges();

			MDialogButtons(buttons : [MDialogButton]);
				MDialogButton ::= MButtonOk, MButtonCancel, MTextButton;
					MButtonOk(shortcut : string, fn : () -> void);
					MButtonCancel(shortcut : string, fn : () -> void);


		// [Material Guidelines | Pickers](https://material.io/design/components/pickers.html)
		// Only handles the time part of the time, on update sets seconds to 0
		MTimePicker(time : DynamicBehaviour<Time>, style : [MTimePickerStyle]);
			MTimePickerStyle ::= MTimeAMPM, MThemeColor, MDialogAlbum, MDialogButtons, MEnabled, MTimeMin, MTimeMax, MTimeSeconds, MUpdateOnClose;
				// true - 12 hour time with AM/PM selection
				// false - 24 hour time
				MTimeAMPM(ampm : bool);
				MTimeMin(t : Time);
				MTimeMax(t : Time);
				// Enables seconds in timepicker
				// False by default
				MTimeSeconds(enabled : bool);

		MColorPicker(color : DynamicBehaviour<MColor>, style : [MColorPickerStyle]);
			MColorPickerStyle ::= MColorPickerMultiSelectStyle, MColorPickerType, MShowPreviousColor, MOpacityPicker;
				MColorPickerType ::= MaterialColorPicker, MRGBPicker;
					// Only material colors
					MaterialColorPicker();
					// Picker with sliders
					MRGBPicker(); // by default
				// Show previous color in header
				MShowPreviousColor(show : bool);
				MOpacityPicker(opacity : DynamicBehaviour<double>);

		MColorPickerMultiSelect(colors : DynamicBehaviour<Set<MColor>>, style : [MColorPickerMultiSelectStyle]);
			MColorPickerMultiSelectStyle ::=  MThemeColor, /*MDialogAlbum, */MDialogButtons, MColorPickerAdditionalColors,
				MCustomColorPickerDialog, MEnabled, MUpdateOnClose, MClearCustomColorsButtons, MColorPickerDisableMainPalette;
				// Show additional color palette
				MColorPickerAdditionalColors(colors : Transform<[MColor]>);
				// If this style is present, there are additional colors only.
				MColorPickerDisableMainPalette();
				// Embed custom color picker dialog within material color picker
				MCustomColorPickerDialog(button : MTextButton, pick : (MColor) -> void);
				MClearCustomColorsButtons(removeColor : (MColor) -> void, removeAllColors : () -> void);

		//
		// Cards
		//
		// [Material Guidelines | Cards](https://material.io/design/components/cards.html)
		MCard(blocks : [MCardBlock], style : [MCardStyle], state : [MButtonState]);
		MDynamicCard(blocks : Transform<[MCardBlock]>, style : Transform<[MCardStyle]>, state : [MButtonState]);
			MCardBlock ::= MRichMediaBlock, MActionBlock, MPrimaryTextBlock, MSupportingTextBlock, MCard, MDynamicBlock, MSeparatorBlock, MExpanderBlock, TEmpty;
				// Block for custom material
				MRichMediaBlock(content : Material, style : [MCardStyle]);
				// Block for actions (icon buttons, buttons etc.). left, right - items aligned to the left or right
				MActionBlock(left : [Material], right : [Material], style : [MCardStyle]);
				// Title with subtitle
				MPrimaryTextBlock(title : string, text : string, style : [MCardStyle]);
				// Subtitle
				MSupportingTextBlock(text : string, style : [MCardStyle]);
				// Horizontal or vertical line
				MSeparatorBlock();
				// Expander
				MExpanderBlock(header: Material, details: () -> Material, expander: DynamicBehaviour<bool>, expanderStyle : [MExpanderStyle]);
				MDynamicBlock(blocks : Transform<[MCardBlock]>);

			// MThemeColor - background color
			// FillOpacity - background opacity
			MCardStyle ::= MBackgroundImage, MThemeColor, FillOpacity, MWidthByContent, MCardWidth, MCardHeight, MCardAlignBottom, MMoreMenu, MCardTextColor,
				MContentBorders, MCardBlockBorders, MCardNoOuterBorders, MCardCorners;

				// Background image of card or block
				MBackgroundImage(image : string, light : bool);
				// Width of the card or block
				MCardWidth(width : double);
				// Height of the card or block
				MCardHeight(height : double);
				// Force specific text color
				MCardTextColor(color : MThemeColor);
				// Force align to bottom inside block
				MCardAlignBottom();
				// Enable or disable borders (applies to block inside too). True by default.
				MContentBorders(borders : bool);
				// Custom borders for card block. MContentBorders(false) will switch it off.
				// start/end are defaultCardMargin by default.
				// top/bottom are defaultCardMarginBorders or defaultCardMargin (in case of first/last block). Also top is 0 for text block under richMedia.
				MCardBlockBorders(start : double, top : double, end : double, bottom : double);
				// Three dot menu at top right corner (see. MMenu for structure)
				MMoreMenu(items : [MMenuLine], state : [MMenuStyle], buttonStyle : [MIconButtonStyle]);
				// Disable outer borders (works only for card itself not blocks)
				MCardNoOuterBorders();
				MCardCorners(leftTop : MaterialShapeCorner, rightTop : MaterialShapeCorner, rightBottom : MaterialShapeCorner, leftBottom : MaterialShapeCorner);

		// Card with title and subtitle only
		MTextCard(title : string, text : string, style : [MCardStyle], state : [MButtonState]) -> MCard {
			MCard([MPrimaryTextBlock(title, text, [])], style, state)
		}

		// Arranges items in grid by theirs sizes and available width
		MFlexibleGrid(items : Transform<[Material]>, style : [MFlexibleGridStyle]);
			MFlexibleGridStyle ::= TFlexibleGridStyle, MEnabled /*Disables reorder*/, MOrdered, MAnimationEnabled;

				MWrapNewRow(wrap : bool) -> TWrapNewRow { TWrapNewRow(wrap); }; // New row should be below all the elements in the previous one (true by default for horizontal grid)
				MWrapNewColumn(wrap : bool) -> TWrapNewColumn { TWrapNewColumn(wrap); }; // New column should be to the right of all the elements in the previous one (true by default for vertical grid)
				MVertical() -> TVertical { TVertical(); }; // Pack elements vertically and bound them with available height
				MAnimationEnabled(enabled : bool); // false for MFlexibleGrid, true for MReorderGrid by default
				MLockWidth(lock : bool) -> TLockWidth { TLockWidth(lock); };	// If true size only grows in height not in width
				                                                            	// (false for MVertical and true for horizontal grid)

				// Don't mix elements order
				// true by default
				MOrdered(ordered : bool);
				MKeepOrder() -> MOrdered { MOrdered(true); }; // OBSOLETE!!
				MMaxRows(rows : int) -> TMaxRows { TMaxRows(rows); }; // Max elements in a first column (Max elements in a first row if MVertical is passed)
				MBaselineAlign() -> TBaselineAlign { TBaselineAlign(); };


		MReorderGrids(items : [[MReorderItem]], order : DynamicBehaviour<[[int]]>, style : [[MReorderGridStyle]], fn : ([Material]) -> Material);
			MReorderItem(content : Material, style : [MReorderItemStyle]);
				MReorderItemStyle ::= MReorderItemVisible, MReorderItemId, MDragging, MEnabled /*Disables dragging*/;
					MReorderItemVisible(visible : DynamicBehaviour<bool>);
					MReorderItemId(id : ref int);

			MReorderGridStyle ::= TFlexibleGridStyle, MDraggingItem, MHoveringItem, MEnabled /*Disables dragging*/,
			                      MGrabDelay, MBorders /*Sets border, which is not draggable*/, MAnimationEnabled,
			                      MReorderDropSpot, MReorderCustomDraggingOrder, MDragLowestPriority, MReorderOnDragEnd;
				MDraggingItem(item : DynamicBehaviour<int>);
				MHoveringItem(item : DynamicBehaviour<int>);
				MReorderDropSpot(spot : Material); // Custom drop spot for items
				MReorderCustomDraggingOrder(); // Drop spot is always above the hovered line. Intended for using into MList to prevent "gluing" of lines
				MReorderOnDragEnd(); // Don`t update order before element is dropped

		MReorderGrid(items : [MReorderItem], order : DynamicBehaviour<[int]>, style : [MReorderGridStyle]);

		MDynamicGrid(items : Transform<[Material]>, style : [MDynamicGridStyle]);
			MDynamicGridStyle ::= MBoxSize, MItemSize, TScrollPosition, TScrollInspectVisible;
				// Scroll box size
				MBoxSize(wh : DynamicBehaviour<WidthHeight>);
				// Set cell height
				MItemSize(wh : Transform<WidthHeight>);

		// Arranges items as grid inside scroll view while rendering only elements visible inside view box
		// Scroll view takes up whole available space
		MRecyclerGrid(items : Transform<[[Material]]>, style : [MRecyclerGridStyle]);
			MRecyclerGridStyle ::= MScrollStyle, TSameSize, MScrollToItem, MRecyclerGridInspectContentSize, MNoProgress;
				MSameSize() -> TSameSize { TSameSize(); }; // Use size of the first item as size for all the items, increases performance heavily
				MScrollToItem(fn : ref (row : int, col : int) -> void); // Replaces 'fn' with function that allows to scroll to an item on the specific row and column
				MRecyclerGridInspectContentSize(size : DynamicBehaviour<WidthHeight>);

		MTree(children : Transform<[MTreeNode<?>]>, style : [MTreeStyle]);
			MTreeStyle ::= MComponentGroupState, MTreeSelection, MTreeOrder, MTreeOnOrderChange, MTreeExpanded, MSingleSelection, MMultiSelection, MTreeSimplifiedView,
			               MThemeColor, MItemsLength, MTreeHideSeparators, MTreeDisableSelection, MTreeDisableExpanded, MTreeLazyLoad, MTreeLazyScrollMode,
						   MListSelection;

				// It`s better to set MSelected into MTreeNode in order to make MTreeSelection keep working after children change
				MTreeSelection(selected : DynamicBehaviour<Set<[int]>>);
				MTreeExpanded(expanded : DynamicBehaviour<Set<[int]>>);
				MTreeOrder(order : DynamicBehaviour<[MTreeOrderNode<?>]>);
					MTreeOrderNode(content : ?, children : DynamicBehaviour<[MTreeOrderNode<?>]>);
				MTreeOnOrderChange(onChange : (newOrder : [MTreeOrderNode<?>]) -> void);
				MItemsLength(length : DynamicBehaviour<int>);
				MTreeHideSeparators();
				MTreeDisableSelection();
				MTreeDisableExpanded();
				// Hide unforld panel and side line
				MTreeSimplifiedView();
				MTreeLazyLoad(loadCount : int, buildPanelFn : Maybe<(onClick : () -> void) -> Material>); // Content is loaded by button clicking
				// Content is rendered, when it appears into scroll box.
				MTreeLazyScrollMode(
					enabled : Transform<bool>,
					style : [MTreeLazyScrollModeStyle]
				);
					MTreeLazyScrollModeStyle ::= MTreeLazyScrollModeExternalInfo, MTreeLazyScrollModeSameHeight;
						MTreeLazyScrollModeExternalInfo(
							scrollPosition : DynamicBehaviour<Point>,
							contentWH : DynamicBehaviour<WidthHeight>,
							minHeight : Transform<double>
						);
						// Optimization for a case when all lines have same height
						// If None(), height will be inspected from the first rendered line.
						MTreeLazyScrollModeSameHeight(sameHeight : Maybe<double>);

			MTreeNode(content : ?, content2material : (?) -> Material, children : Transform<[MTreeNode<?>]>, style : [MTreeNodeStyle]);
				MTreeNodeStyle ::= MButtonState, MSelected, MExpanded, MChildSelected, MThemeColor, MShortHighlighter, MTreeNodeCustomIcon,
				                   MTreeNodeCustomLine, MTreeNodeCustomSeparator, MTreeNodeCustomHighlighter, MTreeNodeCustomHighlighterOnHover, MHighlightOnSelect;

					MSelected(selected : DynamicBehaviour<bool>);
					MExpanded(expanded : DynamicBehaviour<bool>);
					MChildSelected(selected : DynamicBehaviour<bool>);

					// Use shorter highlighting rectangle for MTreeNode that is limited to width of separators between tree rows
					MShortHighlighter : ();
					MTreeNodeCustomIcon(fn : (isExpandedB : DynamicBehaviour<bool>, color : MThemeColor) -> Material);
					MTreeNodeCustomLine(fn : (contentBoxB : DynamicBehaviour<WidthHeight>, color : MThemeColor) -> Material);
					MTreeNodeCustomSeparator(separator : Material);
					MTreeNodeCustomHighlighter(fn : (Transform<WidthHeight>) -> Material);
					MTreeNodeCustomHighlighterOnHover(fn : (Transform<WidthHeight>) -> Material);

		MDynamicArrayTree(children : DynamicArray<MDynamicArrayTreeNode<?>>, style : [MDynamicArrayTreeStyle]);
			MDynamicArrayTreeStyle ::= MComponentGroupState, MDynamicArrayTreeSelection, MDynamicArrayTreeOrder, MDynamicArrayTreeOnOrderChange, MDynamicArrayTreeExpanded, MSingleSelection, MDynamicArrayTreeMultiSelection,
			               MThemeColor, MItemsLength, MTreeHideSeparators, MTreeDisableSelection, MTreeDisableExpanded, MTreeLazyLoad, MTreeLazyScrollMode;

				MDynamicArrayTreeSelection(selected : DynamicArray<[int]>);
				MDynamicArrayTreeExpanded(expanded : DynamicArray<[int]>);
				MDynamicArrayTreeMultiSelection(selected : DynamicArray<int>);
				MDynamicArrayTreeOrder(order : DynamicArray<MDynamicArrayTreeOrderNode<?>>);
					MDynamicArrayTreeOrderNode(content : ?, children : DynamicArray<MDynamicArrayTreeOrderNode<?>>);
				MDynamicArrayTreeOnOrderChange(onChange : (newOrder : [MDynamicArrayTreeOrderNode<?>]) -> void);

			MDynamicArrayTreeNode(content : ?, content2material : (?) -> Material, children : DynamicArray<MDynamicArrayTreeNode<?>>, style : [MDynamicArrayTreeNodeStyle]);
				MDynamicArrayTreeNodeStyle ::= MTreeNodeStyle, MDynamicArrayTreeChildren2Material, MDynamicArrayTreeNode2Material;
					MDynamicArrayTreeChildren2Material(fn : (DynamicArray<Material>) -> Material);
					MDynamicArrayTreeNode2Material(fn : (node : Tropic, children : Tropic) -> Material);

		//
		// Grid List
		//
		// [Material Guidelines | Image Lists](https://material.io/design/components/image-lists.html)
		// A grid list consists of a repeated pattern of cells arrayed in a vertical and horizontal layout.
		// Grid lists are best used on similar data types. They help improve the visual comprehension of the content they contain.
		MGridList(cells : Transform<[MGridListCell]>, style : [MGridListStyle]);

			MGridListCell(
				content : Material,
				text : [string] /* Single line or two lines of text (rest of array is ignored) */,
				style : [MGridListCellStyle]
			);

				MGridListCellStyle ::= MGridListHeader, MGridListFooter, MGridListTextColor, MGridListHeaderFooterColor,
				                       FillOpacity /*Header/footer background opacity*/, MIconButton, MGridListIconRight, MGridListIconLeft,
				                       MGridListZoomContainer;

					// The caption is placed at the top of the cell
					MGridListHeader();
					// The caption is placed at the bottom of the cell
					MGridListFooter();
					// Header/footer text color
					MGridListTextColor(color : MThemeColor);
					// Header/footer background color
					MGridListHeaderFooterColor(color : MThemeColor);
					// Place the secondary action icon at the top/bottom right corner (default)
					MGridListIconRight();
					// Place the secondary action icon at the top/bottom left corner
					MGridListIconLeft();
					// Container for TZoomToFill when making MGridListCell background
					MGridListZoomContainer(container : Tropic);

			MGridListStyle ::= MGridListCellMinWidth, MGridListCellMaxWidth, MGridListColsNumber, MGridListCellHeight,
			                   MGridListCellAspectRatio, MGridListPadding, MNoScroll /* If present, display the whole grid list. Otherwise create a scroll on a FillXY box (default).*/,
			                   MSingleSelection, MOnListClick, MOrdered;

				MGridListCellMinWidth(w : double);
				MGridListCellMaxWidth(w : double);
				MGridListColsNumber(n : int);
				MGridListCellHeight(h : double);
				// Ignored if MGridListCellHeight is present
				MGridListCellAspectRatio(ratio : double);
				MGridListPadding(padding : double);

		//
		// Tabs
		//
		// [Material Guidelines | Tabs](https://material.io/design/components/tabs.html)
		// Tabs enable content organization at a high level, such as switching between views, data sets, or functional aspects of an app.
		// Present tabs as a single row above their associated content. Tab labels should succinctly describe the content within.
		// Because swipe gestures are used for navigating between tabs, don't pair tabs with content that also supports swiping.
		MDynamicTabs(
			tabs : Transform<[MTab]>,
			selected : DynamicBehaviour<int> /* Id of the currently selected tab*/,
			style : [MTabsStyle]
		);

			MTab(content : Material, text : Transform<string>, style : [MTabStyle]);
				MTabStyle ::= MButtonState, MTabIcon, MTabConfirmSwitch, MTabWidthLimited, MWidthByContent, MTabTitleRescaleEnabled, MMaxLines;
					// Icon placed in the middle of the tab above the text
					MTabIcon(icon : Material);
					// Allows asynchronously check condition or save changes before the tab will be switched
					MTabConfirmSwitch(confirm : (callback : (/* approve or cancel */bool) -> void) -> void);
					// Use -1. for unlimited width. MTabWidthLimited(128., 256.) by default.
					MTabWidthLimited(minWidth : double, maxWidth : double);
					// Enables title text rescaling when available width is too narrow. const(true) by default
					MTabTitleRescaleEnabled(enabled : Transform<bool>);

			MTabsStyle ::= MFontStyle, MItemsColor, MBackgroundStyle /* Tab bar background style */, MTabsBackgroundStyle /* Background style of the tabs themselves */,
			               MTabsContentBackgroundStyle, MTabsIndicatorColor, MTabsIndicatorHeight, MTabIndicatorOnTop, MLargeView, MThemeColor /* equals to MBackgroundStyle([MFill(color)]) */,
			               FillOpacity /* equals to MBackgroundStyle([FillOpacity(opacity)]) */, MElevation /* Shadow of the tab (2.0 by default, 0.0 for js) */,
			               MNoDispose /* Don't dispose tab content after switching to another one */, MPreRender, MTabTitleRescaleEnabled,
			               MTabWidthLimited, MShowTooltip, MTabsPanelButton, MTabsAddAction, MMaxHeight, MListReorder, MGrabDelay, MNoScroll, MWidth, MScrollStyle /*for content area scroll*/,
			               MTabsNoDimming, MTabsVerticalSeparators, MTabsHorizontalSeparator, MTabsIconAlign, MTabsAlign, MTabsNoCapitalization,
			               MTabChangeIndicatorColor, MTabsIconTitleAlign, MTabIconHideable, MTabsPanelShow;

				// The color of the line under the selected tab
				MTabsIndicatorColor(color : MThemeColor);
				// The height of the line under the selected tab
				MTabsIndicatorHeight(height : double);
				// Sets tab indicator line above the tab label. By default it is situated below.
				MTabIndicatorOnTop();

				// Background style of the tabs
				MTabsBackgroundStyle(style : [TGraphicsStyle]);

				// Background style of the tabs content
				MTabsContentBackgroundStyle(style : [TGraphicsStyle]);

				// For 320dp max width (256dp by default)
				MLargeView();

				// Pre render content of the tabs and don't dispose it while switching tabs
				MPreRender();
				MTabsPanelButton(button : Material, alignOppositeSide : bool, showSeparator : bool);

				MTabsAddAction(action : (int) -> Material);

				// Do not dim tabs without focus
				MTabsNoDimming();

				MTabsVerticalSeparators(width : double, color : MThemeColor);
				MTabsHorizontalSeparator(height : double, selectedColor : MThemeColor, notSelectedColor : MThemeColor);
				// Deprecated. It has a slightly inaccurate name.
				MTabsIconLeftAlign() { MTabsIconAlign(StartAlign()) };
				// Aligns icon relatively to the text in one line. Icon will be located above the text if none of this or MTabsIconTitleAlign is present.
				MTabsIconAlign(align : MTabsIconAlignType);
					MTabsIconAlignType ::= AbsoluteAlignment, RelativeAlignment;
				// The icon will be located immediately next to the text
				MTabsIconTitleAlign();

				// Aligns group of tab headers horizontally into header area
				MTabsAlign(direction : CommonAlignment); // StartAlign() by default
				MTabsNoCapitalization();
				// Changes the color of the tab text when selected
				MTabChangeIndicatorColor();
				// Hide MTabIcons for all tabs when available width is too narrow
				MTabIconHideable();
				MTabsPanelShow(show : Transform<bool>);
		//
		// Splitter
		//
		// [Material Guidelines | Android Split-screen](https://material.io/design/platform-guidance/android-split-screen.html)
		MSplitter(m1 : Material, m2 : Material, size : Material, style : [MSplitterStyle]);
			MSplitterStyle ::= MThemeColor, FillOpacity, MSplitterHandleColor, MSplitterShowHandle, MSplitterSeparatorSize, MSplitterSizeWatcher, MSplitterDontHandle,
			                   MSplitterSize, MEnabled, MSplitterValue, MSplitterHorizontal, MFocusId, MSplitterWidthHeight, MSplitterScrollStyle, MSplitterSeparatorEnabled;

				MSplitterHandleColor(color : MThemeColor);
				// Show/hide handle inside separator
				MSplitterShowHandle(show : Transform<bool>);
				// Show/hide separator and enable/disable dragging
				MSplitterSeparatorEnabled(enabled : Transform<bool>);
				MSplitterSeparatorSize(size : double);
				MSplitterSizeWatcher(size : DynamicBehaviour<double>);
				// Do not handle the mouse events, so they are also sent to lower level
				MSplitterDontHandle();
				MSplitterSize(min1 : double, max1 : double, min2 : double, max2 : double);
				// Should grow from 0.0 to 1.0
				MSplitterValue(percent : DynamicBehaviour<double>);
				MSplitterHorizontal();
				MSplitterWidthHeight(left : DynamicBehaviour<WidthHeight>, right : DynamicBehaviour<WidthHeight>);
				MSplitterScrollStyle(style : [MScrollStyle]);

		//
		// Tooltip, progress, misc
		//

		// [Material Guidelines | Tooltips](https://material.io/design/components/tooltips.html)
		MTooltip(box : Material, tooltip : Material /*Content of the popup*/, style : [MTooltipStyle]);
			MTooltipStyle ::= MEnabled, MDisableOnDragging, MBackgroundStyle, MBlockHover, MTooltipAlignmentDynamic, MLightBackground, MTranslatePosition,
				MVirtualScreen, MOpenMenu, MTooltipExternalFocused, MTooltipCustomId, MTooltipScreenreaderText, MTooltipMobileScreenreaderSupport, MTooltipSwitchByClick;

				MTooltipAlignmentDynamic(type : Transform<MTooltipAlignmentType>); // MBottom by default
				MTooltipAlignment(type : MTooltipAlignmentType) -> MTooltipAlignmentDynamic { MTooltipAlignmentDynamic(const(type)) };
					MTooltipAlignmentType ::= MStart, MEnd, MLeft, MRight, MTop, MBottom, MTryTopFirst, MTryBottomFirst, MBottomStart, MBottomEnd, MTopStart, MTopEnd, MNoAlignment;
						MBottomStart();
						MBottomEnd();
						MTopStart();
						MTopEnd();
						MNoAlignment();
				// Limit tooltip by virtual screen instead of real one
				MVirtualScreen(size : Transform<WidthHeight>, position : Transform<PositionScale>);
				// Background style of the popup
				MBackgroundStyle(style : [TGraphicsStyle]);
				// Hide tooltip if something is being dragged
				MDisableOnDragging();
				// Translate tooltip position
				MTranslatePosition(point : Transform<Point>);
				// Blocks hover to underlying elements
				MBlockHover();
				MTooltipExternalFocused(focused : Transform<bool>);
				MTooltipCustomId(id : int);
				// If present, screenreader will read this text instead of rendered tooltip
				MTooltipScreenreaderText(text : Transform<string>);
				// Always render invisible copy of tooltip to trigger mobile screenreader (VO on iOS, TalkBack) to read it.
				MTooltipMobileScreenreaderSupport();
				// Shows and hides tooltip by click. Mobile only.
				MTooltipSwitchByClick();

		// [Material Guidelines | Linear Progress Indicators](https://material.io/design/components/progress-indicators.html#linear-progress-indicators)
		// indeterminate
		MProgressBar(style : [MProgressBarStyle]);
			MProgressBarStyle ::= MThemeColor,  MProgressBackgroundColor, MProgressBackgroundOpacity, WidthHeight, MDuration, MBezier, MNoAnimation;
				MProgressBackgroundColor(color : MThemeColor);
				MProgressBackgroundOpacity(opacity : double);
				MNoAnimation();

		// [Material Guidelines | Circular Progress Indicators](https://material.io/design/components/progress-indicators.html#circular-progress-indicators)
		MProgressCircle(style : [MProgressCircleStyle]);
			MProgressCircleStyle ::= MThemeColor, MProgressCircleSize, MAddArrow, MNoRotation;
				// Stroke is the thickness of the progress circle
				// By default: stroke - 4., radius - 20.
				MProgressCircleSize(stroke : double, radius : double);
				// Add arrow to the tip of the progress circle
				MAddArrow(arrowScale : Transform<double>);
				MNoRotation();

		// determinate, percent should grow from 0.0 to 1.0
		// If size.width < 0, fill x. If size.height < 0, use default height.
		MProgressBarDeterm(percent : Transform<double>, style : [MProgressBarStyle]);
		MProgressCircleDeterm(percent : Transform<double>, style : [MProgressCircleStyle]);

		// TODO: Describe what this is
		MRipple(m : Material);
		MRippleCircle(m : Material);

		// [Material Guidelines | App Bars: Top](https://material.io/design/components/app-bars-top.html)
		// You can add FAB to toolbar just passing it to style. Size of the toolbar stays same.
		// You can extend size of the toolbar or change its content by passing your Material to MToolbarContent.
		MToolbar(expander : DynamicBehaviour<bool>, title : Material, right : [Material], style : [MToolbarStyle]);
			MToolbarStyle ::= MButtonState, MBackgroundStyle, MItemsColor, MElevation, MWidth, MHeight, MBackgroundImage, MToolbarTransparent,
			                  MToolbarContent, MFloatingButton, MCustomExpander, MShowExpander, MToolbarBackButton, MExtendedToolbar;

			MItemsColor(color : MThemeColor);
			MToolbarTransparent();
			// Can be bigger than toolbar size. Displayed below content of the toolbar (menu icon, title etc.).
			MToolbarContent(content : Material, addBorders : bool);
			MToolbarBackButton(button : Material);
			MCustomExpander(expander : Material);
			MShowExpander(show : Transform<bool>);
			// Gives an ability to increase toolbar`s height from current to max (128. by default) and backwards.
			MExtendedToolbar(expand : Transform<bool>, style : [MExtendedToolbarStyle]);
				MExtendedToolbarStyle ::= MMaxHeight, MEnabled, MExpanderProgress;

		// Displays the header. When expanded, displays the details
		// Link is deprecated. TODO: add appropriate doc link here.
		// [Material Guidelines | Expansion Panels](https://material.io/archive/guidelines/components/expansion-panels.html)
		MExpander(header : Material, details : () -> Material, expander : DynamicBehaviour<bool>, style : [MExpanderStyle]);
			MExpanderStyle ::= MExpanderHideSeparator, MExpandByArrowOnly, MIconStyle /*arrow color/opacity/size*/, MExpanderBackgroundStyle,
			                   MEnabled, MNoDispose, MExpanderNarrowHeader, MExpanderFront, MWidth /*all available space by default, use 0.0 to disable this behaviour*/,
			                   MDetailsAnimated, MExpanderIcon, CommonAlignment, MIconTranslate, MExpanderHeaderCustomColsFn, MButtonTitle;

				MExpanderHideSeparator();
				// This style is used for MTextInput and another editable controls on header.
				// By default you can expand element by clicking on header.
				MExpandByArrowOnly();
				MExpanderNarrowHeader();
				MExpanderBackgroundStyle(header : [TGraphicsStyle], details : [TGraphicsStyle]);
				// Has the icon in front of the header
				MExpanderFront();
				MDetailsAnimated();
				MExpanderIcon(openIcon : string, closeIcon : string, show : Transform<bool>);
				MIconTranslate(point : Transform<Point>);
				MExpanderHeaderCustomColsFn(fn : (header : Tropic, arrow : Tropic, isRTL : bool) -> Tropic);

		MAnimatedExpander(content : Material, expanded : Transform<bool>, style : [MAnimatedExpanderStyle]);
			MAnimatedExpanderStyle ::= MExpandFromStart, MExpanderHorizontal, MExpanderProgress, MDuration, MNoCrop;
				MExpandFromStart();
				MExpanderHorizontal();
				MExpanderProgress(progress : DynamicBehaviour<double>); // Inspects animation progress
		//
		// Application structure
		//
		// [Material Guidelines | UI Regions](https://material.io/design/layout/responsive-layout-grid.html#ui-regions)
		MAppStructure(parts: [MLayoutPart], style: [MAppStyle]);
			MLayoutPart ::= MAppBar, MNav, MContent, MBottomSheet, MFloatingContent, MBanner;
				// App bar / primary toolbar at the top
				MAppBar(content: Material);
				// Main area
				MContent(content: Material);
				// Side nav on the left or right hand side
				MNav ::= MLeftNav, MRightNav;
					MLeftNav(content: Material, expander: DynamicBehaviour<bool>, style: [MNavStyle]);
					MRightNav(content: Material, expander: DynamicBehaviour<bool>, style: [MNavStyle]);
						MNavStyle ::= MSideNavWidth, MSideNavWidthDynamic, MSideNavPersistent, MSideNavMini, MListMinimizedWidth, MFullHeight, MElevation, MFocusOnPrevious;
							MSideNavWidth(width : double);
							MSideNavWidthDynamic(width : Transform<double>);
							// Sidebar that constricts MContent.
							// If you dont want it to react on expander pass dummy one instead of real.
							MSideNavPersistent(persistent : Transform<bool>);
							// Sidebar minimizes to mini version.

							// Link is deprecated. TODO: add appropriate doc link here.
							// https://material.io/archive/guidelines/patterns/navigation-drawer.html#navigation-drawer-behavior
							MSideNavMini();
							MFullHeight();
				// On top of everything
				MFloatingContent(content : Material);

				// For showing medium-priority messages. Appears on top of the content.
				// [Material Guidelines | Banner](https://material.io/design/components/banners.html)
				MBanner(banner : Transform<MBannerContent>, enabled : Transform<bool>);
					MBannerContent(text : string, style : [MBannerStyle]);
						MBannerStyle ::= MBannerButtons, MLeftIcon, MBannerTitleStyle;
							MBannerButtons(buttons : [MBannerButton]);
							MBannerButton(text : string, onClick : () -> void);
							MBannerTitleStyle(style : [MParagraphStyle]);

				MBottomSheet(
					content : (expanded : Transform<bool>) -> Material,
					style : [MBottomSheetStyle]
				);
					MBottomSheetStyle ::= MExpanded, MCollapsedHeight, MSwipeEnabled, MSwipeDownEnabled, MSwipeGap /*24. by default*/,
					                      MExpandingBottomSheet, MModalBottomSheet, MModalBottomProgress, MEnabled, MAboveFloatingContent, MBackgroundEnabled;
						MCollapsedHeight(height : Transform<double>); // 56. by default, is restricted by half of the screen height
						MSwipeEnabled(enabled : Transform<bool>); // true by default
						MSwipeDownEnabled(enabled : Transform<bool>); // true by default
						// Note : MExpandingBottomSheet and MModalBottomSheet are not compatible
						// Creates a small info area in the right bottom corner of the screen. Opens by click.
						MExpandingBottomSheet(title : Transform<string>, style : [MExpandingBottomSheetStyle]);
							MExpandingBottomSheetStyle ::= MExpandingBottomSheetIcon, MExpandingBottomSheetAdditional, MThemeColor;
								MExpandingBottomSheetIcon(icon : string);
								MExpandingBottomSheetAdditional(items : [Material]);
						MModalBottomSheet(show : DynamicBehaviour<bool>, closeOnClick : bool); // Bottom sheet, which is normally hidden. Works for mobile only.
						MModalBottomProgress(progress : DynamicBehaviour<double>);
						MAboveFloatingContent();
						MNoBackground() { MBackgroundEnabled(const(false)) };
						MBackgroundEnabled(enabled : Transform<bool>); // const(true) by default

			MAppStyle ::= MComponentGroupState, MNoScroll, MSwipeLeft, MSwipeRight, TScrollInspectVisible, MAppStructureFlexible,
			              MFloatingToolbar, MExtendedAppBar, MAppWH, MContentMaxWidth, MAppBarEnabled, MAddSafeArea;
				// Do not add a scroller for the content area
				MNoScroll();

				MSwipeLeftOrRight ::= MSwipeLeft, MSwipeRight;
				// gapLength - distance from the left or right of the screen where swipe is enabled
				// enabled - for swipe disabling in some cases (dialog or loading screens for example)
				MSwipeLeft(gapLength : Transform<double>, enabled : Transform<bool>);
				MSwipeRight(gapLength : Transform<double>, enabled : Transform<bool>);
				// Change sidenav position corresponding to available width
				// MEnabled - turn this on or off (default: const(true))
				// MShowExpander - should the expander toggle be visible when available width is more than required and sidenav is persistant (default: const(false))
				// MShowToolbar - should the toolbar be visible when available width is more than required and sidenav is persistant (default: const(true))
				// MWidth - required width to make sidenav persistent (default: 1296.)
				// MPersistent - monitor current sidenav state based on available width
				// It is advised to use default values
				MAppStructureFlexible(style : [MAppStructureFlexibleStyle]);
					MAppStructureFlexibleStyle ::= MEnabled, MShowExpander, MShowToolbar, MPersistent, MWidth;

					MShowToolbar(show : Transform<bool>);
					MPersistent(persistent : DynamicBehaviour<bool>);
				// Size of the MAppStructure
				MAppWH(wh : DynamicBehaviour<WidthHeight>);
				// Hides toolbar on scrolling down and shows it on scrolling up. Works only for mobile.
				MFloatingToolbar();
				// Extends toolbar by swiping down, when you are on the top of the screen. Default max height is 128.
				MExtendedAppBar(style : [MExtendedAppBarStyle]);
					MExtendedAppBarStyle ::= MExtendedToolbarStyle, MBackgroundImage;
				MAppBarEnabled(enabled : Transform<bool>);

				// Specify max width of the MContent after which it's scaled up
				// See MZoomMaxWidth for more info
				MContentMaxWidth(maxWidth : Transform<double>);

				// Adds safe area around app structure
				// See MSafeArea for more info
				// default: true
				MAddSafeArea(add : bool);

		// Helper for a common kind of left-hand side nav bar
		MSideNav(head: MSNHead, list: Material, expander : Transform<bool>, style: [MSideNavStyle]);
			MSideNavStyle ::= MThemeColor, FillOpacity, MSideNavWidth, MSubList, MSideNavMini, MListMinimizedWidth;
				MSubList(list : Material);

			MSNHead ::= MSNSmallHead, MSNCardHead, MSNCustomHead;
				MSNCardHead(
					background : string,
					photo : MSNHeadPhoto,
					additionalPhotos : [MSNHeadPhoto],
					name : Transform<string>,
					additionalInfo : Transform<string>
				);
				MSNHeadPhoto(url : Transform<string>, onClick : () -> void);
				MSNSmallHead(content: [Material]);
				MSNCustomHead(content: Material);

		MNavigation(list: [MNavigationM], style: [MNavigationStyle]);
			MNavigationM ::= MNavigationMenu, MNavigationMenuCustom;
				MNavigationMenu(title: string, action: [MNavigationMenuAction]);
				MNavigationMenuCustom(m: Material, action: [MNavigationMenuAction]);
					MNavigationMenuAction ::= MNavigationM, MNavigationAction, MNavigationSubmenu, MNavigationSubmenuCustom;
						MNavigationAction(onClick: () -> void);
						MNavigationSubmenu(title: string, onClick: () -> void);
						MNavigationSubmenuCustom(m: Material, onClick: () -> void);
			MNavigationStyle ::= MNavigationMenuStyle, MNavigationSubmenuStyle, MNavigationLevelThreeStyle, MNavigationLevelFourStyle,
			                     Fill, FillOpacity, MNavigationOnSelect, MInCard, MNavigationDynamicBackgroundColor, MNavigationCollapseUnactive;
				MNavigationMenuStyle(style: [MTextStyle]);
				MNavigationSubmenuStyle(style: [MTextStyle]);
				MNavigationLevelThreeStyle(style: [MTextStyle]);
				MNavigationLevelFourStyle(style: [MTextStyle]);
				MNavigationOnSelect(c: DynamicBehaviour<bool>);
				MNavigationDynamicBackgroundColor(f: (i: int) -> int);
				MNavigationCollapseUnactive();

		//
		// Bottom Navigation
		//
		// [Material Guidelines | Bottom Navigation](https://material.io/design/components/bottom-navigation.html)
		MBottomNav(actions: [MBottomNavAction], style: [MBottomNavStyle], selected: DynamicBehaviour<int>, expander: DynamicBehaviour<bool>);
			MBottomNavAction(iconName : string, label : string, style : [MBottomNavActionStyle]);
				MBottomNavActionStyle ::= MOnClick, MIconCounter;
			MBottomNavStyle ::= Fill, FillOpacity, Blur, TScrollInspectVisible, MShowAllLabels, MActiveIconColor, MInactiveIconColor, MBottomNavStaticLabelSize,
								MBottomNavHeight, MBottomNavLeftRightBorder;
				// Fill, FillOpacity, Blur - for background
				// Can expand and hide with TScrollInspectVisible
				MShowAllLabels(); // true by default for actions <= 3
				MBottomNavStaticLabelSize();
				MBottomNavHeight(height : double); // 56.0 by default
				MBottomNavLeftRightBorder(border : double); // 12.0 by default

		//
		// Chips
		//
		// [Material Guidelines | Chips](https://material.io/design/components/chips.html)
		MChip(title : string, style : [MChipStyle]);
			MChipStyle ::= MCloseButton, MCustomCloseButtonIcon, MCustomCloseButtonIconStyle, MChipSelectable, MChipHoverActive, MButtonState, MChipIcon,
						MThemeColor, FillOpacity, MOnClose, MChipVisible, MWidth, MNewChip, MUnselectedColor, MCustomTextStyle, MChipCorners, MChipBorder,
						MOutlined, MOutlineColor, MOutlineOpacity, MOutlineWidth;
				MChipSelectable(enabled : Transform<bool>, selected : DynamicBehaviour<bool>);
				// MChipHoverActive - translates behaviours to control MChip's appearance
				MChipHoverActive(hover : Transform<int>, active : Transform<bool>);
				MCloseButton();
				MCustomCloseButtonIcon(icon : string);
				MCustomCloseButtonIconStyle(styleFn : (bool, bool) -> [MIconButtonStyle]);
				// Should MChip be hidden after press on close button
				MOnClose(close : () -> bool);
				// Is MChip visible
				MChipVisible(visible : DynamicBehaviour<bool>);
				MChipBorder(border : double); // 8. by default

				MChipIcon ::= MAvatar, MLetterIcon, MIcon;

				MNewChip(); // updated chip style.
				MUnselectedColor(color : MThemeColor); // MGrey(300) by default
				MChipCorners(leftTop : MaterialShapeCorner, rightTop : MaterialShapeCorner, rightBottom : MaterialShapeCorner, leftBottom : MaterialShapeCorner);

		//
		// Low-level, Tropic-like
		//
		// Draws a white or dark background for the content with a margin, with a shadow according to the depth
		MBackground(depth : int, m : Material);

		// 1dp separator
		// [Material Guidelines | Dividers](https://material.io/design/components/dividers.html)
		MSeparator(horizontal : bool);
		MSeparatorSize(horizontal : bool, minSize : double);

		//
		// A wizard-like stepper
		//

		// [Material Guidelines | Steppers](https://material.io/archive/guidelines/components/steppers.html)
		MStepper(steps : [MStep], selectedId : DynamicBehaviour<int>, type : MStepperType, style : [MStepperStyle]);

			MStep(title : Transform<string>, content : () -> Material, type : [MStepType], state : [MStepState]);

			MStepperType ::= HorizontalStepper, VerticalStepper, MobileStepper;
				HorizontalStepper(type : [MStepsType]);
				VerticalStepper(type : [MStepsType]);
					MStepsType ::= LinearStepper, AlternativeLabel, StepEditableOnComplete;
						//if false Non-linear steppers. used by default
						LinearStepper(linear : bool);
						AlternativeLabel();
						StepEditableOnComplete();

				MobileStepper(type : MobileStepperType, mobileStepperStyle : [MSBottomBarStyle]);
					MobileStepperType ::= MobileStepText, MobileStepDots, MobileStepProgressBar;
						MobileStepText();
						//not implemented yet
						MobileStepDots();
						MobileStepProgressBar(progressBarStyle : [MProgressBarDetermStyle]);
							MSBottomBarStyle::= MSimpleBottomBar, MOnlyContinueButton;
								// [back batton [progresbar/dotbar/nothing] next button]
								MSimpleBottomBar();
								// [progresbar/dotbar/nothing]
								//				[next button]
								MOnlyContinueButton();
								MProgressBarDetermStyle(color : MThemeColor, backgroundColor : MThemeColor, size : WidthHeight);

			MStepType ::= MEditableStep, MClickableStep, MOptionalStep;
				MEditableStep(editable : bool);
				MClickableStep(clickable : Transform<bool>);
				MOptionalStep(text : Transform<string>);

			MStepperStyle ::= MIconSize, MWarningIconColor,
			                  MActiveIconColor, MInactiveIconColor, MEditIconColor, MCheckCircleIconColor, MBackButton, MContinueButton, MCompleteButton,
			                  MCancelButton, MStepperAddScroll, MHideCancelButton, MSetIntervalBetweenTitles, MUpdatingStepsNumLabels,
			                  MHideFirstStepOnStart, MHeaderTextStyles, MHStepperContentBorder, MHStepperFooterBorder, MStepperCustomFooter,
			                  MStepperTestSupport, MHStepperNoHeaderSeparators;

				MWarningIconColor(color : MThemeColor);
				MActiveIconColor(color : MThemeColor);
				MInactiveIconColor(color : MThemeColor);
				MEditIconColor(color : MThemeColor);
				MCheckCircleIconColor(color : MThemeColor);
				MContinueButton(text : string, style : [MTextButtonStyle], state : [MButtonState]);
				MCompleteButton(text : string, style : [MTextButtonStyle], state : [MButtonState]);
				MBackButton(text : string, style : [MTextButtonStyle], state : [MButtonState]);
				MCancelButton(text : string, style : [MTextButtonStyle], state : [MButtonState]);
				MStepperAddScroll();
				MHideCancelButton();
				MSetIntervalBetweenTitles(size : double);
				// updating steps num labels on steps visibility changing
				MUpdatingStepsNumLabels();
				// allows to keep the first step collapsed on start and open it by clicking on title
				MHideFirstStepOnStart();
				// Font styles of title and subtitle (now used only font color and font size)
				// truncateText - truncate the long text (in title and subtitle) and add ellipsis at the end
				// also tooltips for truncated text will be added
				MHeaderTextStyles(titleStyle : [MTextStyle], subtitleStyle : [MTextStyle], truncateText : bool);
				MHStepperContentBorder(left : double, top : double, right : double, bottom : double);
				MHStepperFooterBorder(left : double, top : double, right : double, bottom : double);
				// Allows to change the footer layout for hstepper
				MStepperCustomFooter(layout : (previous : Material, cancel : Material, next : Material, borders : (Material) -> Material) -> Material);
				MStepperTestSupport(support : MWTestSupport, isTestPlaybackMode : () -> bool);
				// allows to remove upper and lower horizontal lines from the header
				MHStepperNoHeaderSeparators();

			MStepState ::= MStepperFeedback, MultilineErrorState, MContinueFn, MCancelFn, MCompleteStatus, MEnabled,
			               MBackButton, MContinueButton, MCompleteButton, MCancelButton, MExpanded, MHideStepCompleteButton;
				MultilineErrorState(text : Transform<string>);
				MContinueFn(fn : () -> bool);
				MCancelFn(fn : () -> void);
				MStepperFeedback(content : () -> Material);
				MCompleteStatus(complete : DynamicBehaviour<bool>);
				MHideStepCompleteButton();

		//
		// Click helpers
		//

		// Sends down events to lower z-order elements.
		MClickable(m : Material, onClick : () -> void);

		MMouseDownAround(
			point : Maybe<DynamicBehaviour<Point>>,
			down : DynamicBehaviour<bool>,
			hover : DynamicBehaviour<bool>,
			onClick : () -> void,
			m : Material
		);

		MComponent(state : [MButtonState], fn : (focus : MFocus) -> Material);
		// Use MComponent instead of MFocusClickable directly
		MFocusClickable(state : [MButtonState], fn : (focus : MFocus) -> Material) -> Material { MComponent(state, fn); };

		MSwipe(content : Material, state : [MSwipeState]);
			MSwipeState ::= MOnSwipeDown, MOnSwipeUp, MOnSwipeLeft, MOnSwipeRight, MOnSwipe,
			                TCurrentInteractive, TPressed, MEnabled, MSwipeGap, MInteractionsOnTop;

				MOnSwipeDown(onSwipe : (point : Point, delta : Point) -> bool);
				MOnSwipeUp(onSwipe : (point : Point, delta : Point) -> bool);
				MOnSwipeLeft(onSwipe : (point : Point, delta : Point) -> bool);
				MOnSwipeRight(onSwipe : (point : Point, delta : Point) -> bool);
				MOnSwipe(fn : (swiping : bool) -> void);
				MSwipeGap(gap : double); // 3px by default

		// Draggable and DropSpot in one
		MDragDrop(id : Transform<int>, content : Material, style : [MDragDropStyle]);
			MDragDropStyle ::= MDraggingEnabled, MHoveringEnabled, MDroppingEnabled, MDragging, MHoveringId, MDroppingId,
			                   MOnDrag, MOnHover, MOnDrop, TPressed, THovering, MMousePosition, MLocalMousePosition, MGrabPosition, MNoGrabAnimation,
			                   MDraggingContent, MDraggingPlaceholder, MContentVisibleOnDrag, MGrabDelay, MDragLowestPriority, MDisablePassingClicks;

				MDraggingEnabled(enabled : Transform<bool>);
				MHoveringEnabled(enabled : Transform<bool>);
				MDroppingEnabled(enabled : Transform<bool>);

				MDragging(dragging : DynamicBehaviour<bool>);
				MHoveringId(hovering : DynamicBehaviour<int>);
				MDroppingId(dropping : DynamicBehaviour<int>);

				MOnDrag(fn : (isDragging : bool) -> void); // Fired once when this MDragDrop is dragged or dropped
				MOnHover(fn : (id : int) -> void); // Fired when another MDragDrop is held over this one
				MOnDrop(fn : (id : int) -> void); // Fired when another MDragDrop is dropped inside this one

				MLocalMousePosition(point : DynamicBehaviour<Point>);
				MGrabPosition(point : DynamicBehaviour<Point>);
				MNoGrabAnimation(); // Do not scale dragging element

				MDraggingContent(content : Material);
				MDraggingPlaceholder(content : Material);
				MContentVisibleOnDrag(visible : Transform<bool>);
				MGrabDelay(delay : int); // 300 ms by default
				// Handle click events in the content primarily.
				MDragLowestPriority();
				MDisablePassingClicks();


		MRealHTML(url : string, wh : Transform<WidthHeight>, style : [FRealHTMLStyle]);

		// Supports YouTube and Vimeo links (creates iframe instead of video)
		MVideoPlayer(filename : string, wh : Transform<WidthHeight>, style : [MVideoPlayerStyle]);
			// Ignores OnVideoLoadingError and FVideoControls
			MVideoPlayerStyle ::= FVideoStyle, MThemeColor, MDynamicColor, MCustomBar, MPlayerDynamicBackground, MPlayerBackgroundOpacity, MEnabled, MPlayerShowPanel, MPlayerPanelAutoHide, MPlayerControls,
			                      MPlayerVisibleRange, MPlayerHighlightedRanges, MAnimatedSubtitles, MExternalSubtitles, MPlayerDisableKeyboardShortcuts, MItemsColor, MSelectedColor, MPlayerChapter, MVideoPoster;

				MVideoPoster(poster : Tropic);
				MPlayerBackground(color : MThemeColor) { MPlayerDynamicBackground(const(color)) };
				MPlayerDynamicBackground(color : Transform<MThemeColor>);
				MPlayerBackgroundOpacity(opacity : Transform<double>);
				MPlayerShowPanel(show : Transform<bool>);
				MPlayerPanelAutoHide(enabled : bool); // Hides panel 1 sec after playing was started, returns it on pause.
				MPlayerDisableKeyboardShortcuts();
				MPlayerControls : (controls : [MPlayerControl]); // [VolumeControl()] by default
					MPlayerControl ::= BasicPlayerControl, SubtitlesControl, SubtitlesSelector, MPlayerCustomControl;
						SubtitlesControl(enabled : Transform<bool>);
						SubtitlesSelector(current : DynamicBehaviour<SubtitleSource>, available : [SubtitleSource]);
							SubtitleSource(label : string, lang : string, src : string);
						MPlayerCustomControl(icon : string, onClickAction : () -> void, style : [MToggleStyle], state : [MToggleState]);
				MPlayerChapter(title : Transform<string>);

				// video range displayed in UI
				MPlayerVisibleRange(start : Transform<double>, end : Transform<double>);
				MPlayerHighlightedRanges(ranges : Transform<[MPlayerHighlightedRange]>);
					MPlayerHighlightedRange(start : DynamicBehaviour<double>, end : DynamicBehaviour<double>, style : [MSliderHighlightedRangeStyle]);

				MAnimatedSubtitles(subtitles : Transform<VideoSubtitle>, style : [MAnimatedSubtitleStyle]);
					MAnimatedSubtitleStyle ::= MDuration, MSubtitlesFrame, FVideoSubtitlesScaleMode, MSubtitlesOriginSize;
						MSubtitlesFrame(radius : double, border : double);
						// FVideoSubtitlesScaleMode will be based on this size instead of real video metrics.
						MSubtitlesOriginSize(size : WidthHeight);

				// JS only. WebVTT and TTML formats are supported
				// https://developer.mozilla.org/en-US/docs/Web/HTML/Element/track
				MExternalSubtitles(src : string, kind : string);

		MVideo(filename : string, wh : DynamicBehaviour<WidthHeight>, style : [FVideoStyle]) -> Material {
			TVideo(filename, wh, style);
		};

		// These more or less work exactly like Tropic, except they accept Material

		MEmpty() -> Material { TEmpty(); };

		// If you want Material, which automatically mirrors content in case of RTL layout, see versions with -A suffix below.
		MLines(m : [Material]);
		MCols(m : [Material]);
		MLines2(m1 : Material, m2 : Material);
		MCols2(m1 : Material, m2 : Material);
		MBaselineLines(m : [Material]);
		MBaselineCols(m : [Material]);
		MBaselineLines2(m1 : Material, m2 : Material);
		MBaselineCols2(m1 : Material, m2 : Material);
		MBorder(left : double, top : double, right : double, bottom : double, m : Material); // See also MBorder* helpers into material_gui.flow
		MPad(x : double, y : double, content : Material) -> Material { MBorder(x, y, 0., 0., content) };
		MGroup(m : [Material]);
		MGroup2(m1 : Material, m2 : Material);
		MGrid(m : [[Material]]);
		MMinimumGroup2(m1 : Material, m2 : Material);
		MSubtractGroup2(m1 : Material, m2 : Material);
		MBaselineOffset(offset : Transform<double>, m : Material);
		MAvailable(box : Material, avail : Material); // See also MAvailable* helpers into material_gui.flow
		MAlpha(alpha : Transform<double>, m : Material);
		MCrop(topleft : Transform<Point>, widthHeight : Transform<WidthHeight>, m : Material);
		MCropSize(s : Material, m : Material);
		// Preserves the size when invisible.
		// Be careful, in JS 'value=false' causes element to be removed from the DOM, while it remains constructed on flow level.
		MVisible(value : Transform<bool>, m : Material);
		// Destroys and reconstructs, and is 0 size when invisible
		MShow(show : Transform<bool>, m : Material);
		// Inspects if Material is rendered
		MRenderable(renerable : DynamicBehaviour<bool>, m : Material);
		MMutable(m : Transform<Material>);
		MIf(condition : Transform<bool>, then : Material, elset : Material);
		// Workaround for MIf to prerender inner stuff, use only in special cases
		MIfPreRender(condition : Transform<bool>, then : Material, elset : Material, sameSize : bool);
		// Be careful, f is called 2 times as a maximum, results of these calls are cached.
		// Check out tests/test_mif_lazy.flow for illustration.
		MIfLazy(condition : Transform<bool>, f : (bool) -> Material);
		MInteractive(interactivity: [TInteractivity], form : Material);
		MCursor(kind : CursorShape2, m : Material);
		MFilter(filters : [Filters], m : Material);

		MGraphics(shape : Transform<GShape>, style : Transform<[TGraphicsStyle]>);
			GShape ::= GRect, GRoundedRect, GEllipse, GCircle, GPath;
				// GRect : (x : double, y : double, width : double, height : double);
				// GRoundedRect : (x : double, y : double, width : double, height : double, radius : double);
				// GEllipse : (x : double, y : double, width : double, height : double);
				// GCircle : (x : double, y : double, radius : double);
				GPath(path : [StaticGraphicOp]);

		// Keyframe-based animation (asynchronous in js).
		// Keyframes are evenly distributed across timeline with first and last on the ends.
		// Modifying keyframes Transform cancels previous animation and immediately starts new one.
		// For example if you want to animate content fading-in use
		// MAnimation(..., const([FAnimationKeyframe([FAlphaValue(0.0)]), FAnimationKeyframe([FAlphaValue(1.0)])]), [])
		MAnimation(m : Material, keyframes : Transform<[FAnimationKeyframe]>, style : [FAnimationStyle]);

		MConstruct(constructors : [() -> () -> void], m : Material);
		MCreate2(current : ref Material, fn : () -> Material);
		MCreate(fn : () -> Material) -> MCreate2 {
			MCreate2(ref TEmpty(), fn);
		}
		MDispose(disposers : [() -> void], m : Material);
		MTranslate(point : Transform<Point>, form : Material);
		MOffset(dx : double, dy : double, content : Material) -> Material { MTranslate(const(Point(dx, dy)), content) };
		MRotate(degree : Transform<double>, mat : Material);
		// Define tranformation origin as Factor of the material size.
		// MScale and MRotate will use this origin as center point of all the transformations applied.
		// For example if you want to rotate material around its center use MOrigin(const(Factor(0.5, 0.5), ...).
		// By default origin is Factor(0.0, 0.0) which is the top left corner of the material.
		MOrigin(origin : Transform<Factor>, mat : Material);
		MShift(m : Material, distance : Material);
		MCenter(m : Material);
		MCenterIn(m : Material, box : Material);
		MCenterX(m : Material);
		MCenterY(m : Material);
		MCenterXIn(m : Material, box : Material);
		MCenterYIn(m : Material, box : Material);
		// Content align left inside the box if LTR, align right if RTL. Intended for temporary use.
		MCenterYInA(m : Material, box : Material);
		// Render content which depends on available area.
		// Not very convenient in this signature, only use if you know what you're doing.
		MCase(sizes : [Material], m: [Material]);
		MScroll(content : Material, box : Material, style : [MScrollStyle]);
			MScrollStyle ::= TScrollStyle, MScrollToFocusEnabled, MComponentGroupState, MEnabled, MScrollSpinner;

				MScrollToFocusEnabled(enabled : Transform<bool>);

				MScrollPosition(position : DynamicBehaviour<Point>) -> TScrollPosition { TScrollPosition(position); };
				MExpandOnHover(expand : bool) -> TExpandOnHover { TExpandOnHover(expand); };
				MReverseMouseWheel() -> TReverseMouseWheel { TReverseMouseWheel(); };
				MScrollCropByContent() -> TScrollCropByContent { TScrollCropByContent(const(true), const(true)); };
				MScrollCropByContentEnabled(xEnabled : Transform<bool>, yEnabled : Transform<bool>) -> TScrollCropByContent {
					TScrollCropByContent(xEnabled, yEnabled);
				};
				// Returns distance by which scroll positon is out of bounds
				// Positive for position below scroll and negative for above. 0 if scroll is in bounds.
				MScrollOutOfBounds(x : DynamicBehaviour<double>, y : DynamicBehaviour<double>) -> TScrollOutOfBounds { TScrollOutOfBounds(x, y); };
				MScrollbars(x : TScrollbarStyle, y : TScrollbarStyle) -> TScrollbars { TScrollbars(x, y); };
				// Tells are scrollbars visible on corresponding axes. On mobile its true even if scrollbars are hidden because of scroll
				// position isn't changing.
				// In other words shows if content is bigger that the box. False when scroll is disabled.
				MScrollbarsVisible(x : DynamicBehaviour<bool>, y : DynamicBehaviour<bool>) -> TScrollbarsVisible { TScrollbarsVisible(x, y); };
				MScrollWidthHeight(content : DynamicBehaviour<WidthHeight>, box : DynamicBehaviour<WidthHeight>) -> TScrollWidthHeight { TScrollWidthHeight(content, box); };
				MScrollDisableOutOfBounds(disable : Transform<bool>) -> TScrollDisableOutOfBounds { TScrollDisableOutOfBounds(disable); };
				MScrollMouseEnabled(enabled : Transform<bool>) -> TScrollMouseEnabled { TScrollMouseEnabled(enabled); };
				MCurrentInteractive(current : DynamicBehaviour<Maybe<bool>>) -> TCurrentInteractive { TCurrentInteractive(current); };
				MScrollBound(x : Transform<bool>, y : Transform<bool>) -> TScrollBound { TScrollBound(x, y); };
				MScrollCropEnabled(enabled : Transform<bool>) -> TScrollCropEnabled {TScrollCropEnabled(enabled)};
				MScrollAxisEnabled(x : Transform<bool>, y : Transform<bool>) -> TScrollAxisEnabled {TScrollAxisEnabled(x, y)};
				// Event which fires when scrolled to bottom.
				// May be useful when loading stuff in chunks.
				MOnScrolledToBottom(event : () -> void) -> TOnScrolledToBottom { TOnScrolledToBottom(event); };
				// Event which fires when scrolled to side
				// (right for LTR, left for RTL)
				MOnScrolledToSide(event : () -> void) -> TOnScrolledToSide { TOnScrolledToSide(event); };
				// Puts vertical scrollbar to the left.
				// May be useful for arabic layout.
				MScrollBarStart() -> TScrollBarStart { TScrollBarStart(); };
				// Puts horizontal scrollbar to the top.
				MScrollBarTop() -> TScrollBarTop { TScrollBarTop(); };
				// Enables keys handling by MScroll. True by default
				MScrollKeysEnabled(enabled : Transform<bool>) -> TScrollKeysEnabled { TScrollKeysEnabled(enabled); };
				MScrollFadeContent(color : int, width : double, start : bool, end : bool) -> TScrollFadeContent { TScrollFadeContent(color, width, start, end); };

				MScrollSpinner(spin : DynamicBehaviour<bool>, style : [MScrollSpinnerStyle]);
					MScrollSpinnerStyle ::=
						Fill, FillOpacity, MCustomSpinner, MScrollSpinnerOffset, MScrollSpinnerSize,
						MScrollSpinnerPushContent, MBezier, MDuration, MIosStyledSpinner;

						MCustomSpinner(spinner : (
								draggingMouseY : DynamicBehaviour<Maybe<double>>,
								iterationPrc : DynamicBehaviour<double>,
								releasePrc : DynamicBehaviour<double>,
								resetPrc : DynamicBehaviour<double>
							) -> Material
						);
						MScrollSpinnerOffset(max : double, normal : double);
						MScrollSpinnerSize(size : double);
						MScrollSpinnerPushContent(offset : double); // Pushes content below when visible
						MIosStyledSpinner();
				// Allows scrollbars to be on the top of the content.
				// True by default.
				// Use "scroll_overlap_debug=1" url-parameter to set MScrollbarOverlapContent(false) by default for all scrolls.
				MScrollbarOverlapContent(overlap : bool) -> TScrollbarOverlapContent { TScrollbarOverlapContent(overlap); };

		MScrollBox(content : Material) -> Material { MScroll(content, TFillXY(), []); };


		MTweak(style : [TTweakStyle], content : Material, size : Material);

		// Draws rectangles : actual size - given color, minimum size - blue, maximum size - green, available space from parent - red, baseline - black line
		// For special cases see MDebug* into material_gui.flow
		MDebug(c : int, box : Material);

		// Inspects metrics of m. See MAttach* helpers into material_gui also.
		MInspect(inspectors : [TInspector], m : Material);

		MAttach(ghost : Material, fn : (TFormMetrics) -> Material);
		// Overrides logical size (doesn't effect display!). Use only in specific cases
		MFixSize(m : Material, size : Material);
		// Deprecated. Use MFixSize instead of MSize.
		MSize(size : Material, m : Material);
		MSizeOf(m : Material);
		MZoom(content : Material, container : Material, keepAspect : bool);
		MZoomToFill(content : Material, container : Material, crop : bool);
		MScale(factor : Transform<Factor>, m : Material);
		MMask(content : Material, mask : Material);
		MFullWindow(fw : DynamicBehaviour<bool>, m : Material);
		MFullScreen(fs : DynamicBehaviour<bool>, m : Material);

		MFrame(margin : double, radius : double, style : [TGraphicsStyle], box : Material);
		// Use MComponent instead of MRawButton
		// MRawButton is left here for backward compatibility
		MRawButton(
			normal : Material, hover : Material, pressed : Material, disabled : Material,
			shortcut : string, style : [TButtonStyle], state : [MRawButtonState]
		);

			MRawButtonState ::= MButtonState, TButtonState;

		// Use MDragDrop instead of MDraggable and MDropSpot
		// MDraggable and MDropSpot are left here for backward compatibility
		MDraggable(id : int, stationary : Material, style : [MDragStyle]);
			MDragStyle ::= MDragShape, TDragStyle;
				MDragShape(shape : Material);
		MDropSpot(onHover : DynamicBehaviour<int>, onDrop : DynamicBehaviour<int>, dropTropic : Material);
		MDropSpot2(onHover : DynamicBehaviour<int>, onDrop : DynamicBehaviour<int>, dropTropic : Material, handle : bool);

		MMovable(target : Material, movableArea : Material, style : [MMovableStyle]);
			MMovableStyle ::= MMovablePosition, MMovableExpandArea, MMovableGrabArea, MMovableOrigin, MEnabled, MInteractionsOnTop,
							MMovableDontPassClicks, MMovableCustomCursor, MMousePosition, MMovableLimits, MGrabDelay;
				MMovablePosition(position : DynamicBehaviour<Point>);
				// The target can be moved partially out of the area
				MMovableExpandArea();
				// Area with which you can grab target, padding is the distance from top-left corner.
				MMovableGrabArea(padding : Material, area : Material);
				// What point to use as an origin on content metrics change.
				MMovableOrigin(origin : Transform<Factor>);
				// Don't pass clicks to elements below
				MMovableDontPassClicks();
				// Use a custom cursor
				MMovableCustomCursor(cursor : CursorShape2);
				MMovableLimits(
					left : Maybe<Transform<double>>,
					top : Maybe<Transform<double>>,
					right : Maybe<Transform<double>>,
					bottom : Maybe<Transform<double>>,
				);

		MPicture(picURL : string, style : [MPictureStyle]);
			MPictureStyle ::= TPictureStyle, MPictureShowLoading, MPictureCustomLoadingExt, MPictureSize, MPictureTileMode;
				MPictureShowLoading(show : bool);
				MPictureCustomLoading(loading : Material) { MPictureCustomLoadingExt(loading, None()) };
				MPictureCustomLoadingExt(loading : Material, backgroundStyle : Maybe<[TGraphicsStyle]>);
				MPictureSize(size : Transform<WidthHeight>); // Scales to available area for WidthHeight(-1., -1.)
				MPictureTileMode(); // Tiles available box by a picture, MPictureSize affects tile size

		MResizable(content : Material, style : [MResizableStyle]);
			MResizableStyle ::= MResizableEnabled, MResizableMinMax, MResizableOnCreate, MResizableControlOnStart, MMultipleHandlesMode;
				MResizableEnabled(x : Transform<bool>, y : Transform<bool>);
				MResizableMinMax(min : Material, max : Material);
				MResizableOnCreate(size : Material);
				MResizableControlOnStart();
				MMultipleHandlesMode(
					handles : Transform<[MResizableHandle]>,
					materialize : (position : MResizableHandle) -> Material,
					leftTop : DynamicBehaviour<Point>,
					mousePosition : Transform<Point>
				);
					MResizableHandle ::= MTopLeft, MTopRight, MCenterLeft, MCenterRight, MBottomRight, MBottomLeft;
						MTopLeft();
						MTopRight();
						MCenterLeft();
						MCenterRight();
						MBottomRight();
						MBottomLeft();

		// Scales available space
		MScaleAvailable(factor : Transform<Factor>, m : Material);

		//Set a specific theme for the target
		MExplicitTheme(target : Material, light : Transform<bool>, state : [MComponentGroupState]);


		// [ Material Guidelines | Backdrop ](https://material.io/design/components/backdrop.html)
		MBackdrop(header : Material, content : Material, style : [MBackdropStyle]);
			MBackdropStyle ::= MBackdropTitle, MBackdropSubtitle, MBackdropOpened, MBackdropItems, MBackdropLeftIcon;
				MBackdropTitle(title : Transform<string>);
				MBackdropSubtitle(subtitle : Transform<string>);
				MBackdropOpened(opened : DynamicBehaviour<bool>);
				MBackdropLeftIcon(opened : string, closed : string);
				MBackdropItems(items : [Material]);

		//
		// Helpers for implementing custom elements
		//

		// Helper to create simple animations. Try MMEasingAnimation for complicated ones.
		MAnimator(m : Material, trigger : Transform<bool>, style : [MAnimatorStyle]);
			MAnimatorStyle ::= MDuration, MAnimatorCropType, MExpanderProgress, MBezier, MAnimatorLazy,
			                   MFadeAnimation, MScaleAnimation, MTranslateAnimation, MRotateAnimation;

				MBezier(bezier : Transform<CubicBezierEasing>);
				MDuration(duration : Transform<double>);
				MFadeAnimation();
				MScaleAnimation(style : [MScaleAnimationStyle]);
					MScaleAnimationStyle ::= MCenterMode, MScaleAnimationCustomFactor;
						MCenterMode();
						MScaleAnimationCustomFactor(factor : Transform<Factor>);

				MRotateAnimation(style : [MRotateAnimationStyle]);
					MRotateAnimationStyle ::= MCenterMode, MRotateAnimationCustomAngle;
						MRotateAnimationCustomAngle(angle : Transform<double>); // in degrees

				MTranslateAnimation(type : MTranslateAnimationType, style : [MTranslateAnimationStyle]);
					MTranslateAnimationType ::= MTop, MBottom, MLeft, MRight, MTranslatePosition;
					MTranslateAnimationStyle ::= MExpandFromStart;

				// Dispose content when progress is 0.
				MAnimatorLazy();

				MAnimatorCropType ::= MNoCrop, MAnimatorCropByContent;
					MAnimatorCrop();
					MAnimatorCropByContent();

		MTransformTAcc(
			fn : (
				tropic2acc : (mat : Material, parentInfo : TParentInfo, sheet : Stylesheet, metricsOnly : bool) -> TAcc,
				parentInfo : TParentInfo,
				sheet : Stylesheet,
				metricsOnly : bool
			) -> TAcc
		);

		MGetManager(fn : (MaterialManager) -> Material);
		MGetFocusGroup(fn : (MFocusGroup) -> Material);
		MGetMaterial2Tropic(fn : ((Material, MFocusGroup) -> Tropic) -> Material);

		MSetFocusGroup(parent : MFocusGroup, m : Material);

		MAccess(prop : [FAccessProperty], m : Material);
		MPositionScale(positionScale : DynamicBehaviour<PositionScale>, m : Material);

		MDynamicGroup2(stackChanges : DynamicBehaviour<[MGroupChange]>, currentStack : ref [Material], combiner : TCombiner);
			MGroupChange ::= MGroupAdd, MGroupDelete, MGroupMove, MGroupReplace;

				MGroupAdd(mat : Material, z : int);
				MGroupDelete(z : int);
				MGroupMove(from : int, to : int);
				MGroupReplace(mat : Material, z : int);

		MDynamicGroup(stackChanges : DynamicBehaviour<[MGroupChange]>) -> MDynamicGroup2 {
			MDynamicGroup2(stackChanges, ref [], TGroupCombiner());
		}

		// Enables or disables components inside or focus interactions
		MComponentGroup(content : Material, state : [MComponentGroupState]);
			MComponentGroupState ::= FAccessProperty, MEnabled, MFocusEnabled, MClickEnabled, MKeysEnabled, IScriptBehaviour, MFocusName, MActive, MChildActive, MFocusId,
			                         MFocused, IScriptId, IScriptRecordingEnabled, MFocusVertical, MFocusHorizontal, MZorder, MHintMarkerEnabled,
			                         MaterialTheme, MLightBackground, MGetParent, MSetParent, UpdateMaterialTheme, SetRTL, MScrollInfo, THovering,
			                         MIsReady, MSetReady, MFocusOnPrevious;

			// Switch focus using up and down arrows
			MFocusVertical(vertical : bool);
			// Switch focus using left and right arrows
			MFocusHorizontal(horizontal : bool);

			MFocusName(name : string);

			MActive(active : DynamicBehaviour<bool>);

			// Is there any child being focused, hovered or pressed (i.e. interacted by user)
			MChildActive(active : DynamicBehaviour<bool>);
			// Change material dark/light theme
			MLightBackground(light : bool);
			MZorder(zorder : Transform<int>);

			MGetParent(parent : DynamicBehaviour<Maybe<MFocusGroup>>);
			MSetParent(parent : Transform<Maybe<MFocusGroup>>);

			// Monitor or rederfine element animation (transition) state
			// Component is ready if all entering transitions are finished
			// On false blocks inner MPopups and hides MVideoPlayer content
			MIsReady(ready : DynamicBehaviour<bool>);
			MSetReady(ready : Transform<bool>);

			// Create new MaterialTheme from the parent's one
			UpdateMaterialTheme(fn : (MaterialTheme) -> MaterialTheme);

			// Shows pulsing circle around some clickable elements. The circle will disappear on hover or after click on the element.
			// False by default.
			MHintMarkerEnabled(enabled : Transform<bool>);

		MComponentGroupMutable(content : Transform<Material>, state : [MComponentGroupState]);

		MActivate(content : Material, state : [MComponentGroupState]) -> Material { MComponentGroup(content, state); }
		MActivateMutable(content : Transform<Material>, state : [MComponentGroupState]) -> Material { MComponentGroupMutable(content, state); }
		MActivateSelect(value : Transform<?>, fn : (?) -> Material, state : [MComponentGroupState]) -> Material {
			MComponentGroupMutable(fselect(value, FLift(fn)), state);
		}

	//
	// To avoid making Material polymorphic, these are not a part of the union
	//

	MSelect(value : Transform<?>, fn : (?) -> Material) -> Material {MMutable(fselect(value, FLift(fn)))};
	MComponentGroupSelect(value : Transform<?>, fn : (?) -> Material, state : [MComponentGroupState]) -> Material
		{ MComponentGroupMutable(fselect(value, FLift(fn)), state); };

	// Defines a named value in the given scope. This can be used with MDisplay and MGhost.
	// Notice MGhost only works if the named thing is displayed.
	MLet(name : string, value : Material, scope : Material);
	MLetMany(items : [Pair<string, Material>], scope : Material);
	MLetAvailable(name : string, scope : Material);
	MGhost(name : string) -> Material {TGhost(name)};
	MDisplay(name : string) -> Material {TDisplay(name)};

	// Creates a Material with width or height of m. Be careful : usually MGhost is the only optimal way to use into this.
	// Also consider using MAttachWidth / MAttachHeight instead.
	MWidthOf(m : Material) -> Material {MScale(const(Factor(1.0, 0.0)), m)};
	MHeightOf(m : Material) -> Material {MScale(const(Factor(0.0, 1.0)), m)};

	// Aligns content to the right if RTL language chosen.
	MLinesA(arr : [Material]) -> Material {MGetFocusGroup(\p -> MGetMaterial2Tropic(\m2t -> TLinesDir(map(arr, \m -> m2t(m, p)), p.rtl)))}
	MLines2A(m1 : Material, m2 : Material) -> Material {MLinesA([m1, m2])}
	MBaselineLinesA(arr : [Material]) -> Material {MGetFocusGroup(\p -> MGetMaterial2Tropic(\m2t -> TBaselineLinesDir(map(arr, \m -> m2t(m, p)), p.rtl)))}
	MBaselineLines2A(m1 : Material, m2 : Material) -> Material {MBaselineLinesA([m1, m2])}

	// Reverses order of the content columns if RTL language chosen.
	MColsA(m : [Material]) -> Material {MGetFocusGroup(\p -> MCols(if (p.rtl) reverseA(m) else m))}
	MCols2A(m1 : Material, m2 : Material) -> Material {MColsA([m1, m2])}
	MBaselineColsA(m : [Material]) -> Material {MGetFocusGroup(\p -> MBaselineCols(if (p.rtl) reverseA(m) else m))}
	MBaselineCols2A(m1 : Material, m2 : Material) -> Material {MBaselineColsA([m1, m2])}

	MGridA(arr : [[Material]]) -> Material {MGetFocusGroup(\p -> MGrid(if (p.rtl) map(arr, reverseA) else arr))}

	// BiDi-aware, puts start and end borders to left and right in order regarding to global text direction.
	MBorderA(start : double, top : double, end : double, bottom : double, m : Material) -> Material {
		MGetFocusGroup(\p -> MGetMaterial2Tropic(\m2t -> TBorderDir(start, top, end, bottom, m2t(m, p), p.rtl)))
	}
	MPadA(x : double, y : double, content : Material) -> Material {MBorderA(x, y, 0., 0., content)}

	extractCommonAlignmentFromMParagraphStyles(styles: [MParagraphStyle]) -> CommonAlignment;

	// ---------------- WARNING: DEPRECATED ELEMENT ----------------
	// Use it only when MLightweightDataTableStyle doesn't contain needed style.
	// A table of information
	// [Material Guidelines | Data Tables](https://material.io/design/components/data-tables.html)
	MDynamicDataTable(columns : [MColumnDynamic], rows : Transform<[[Material]]>, style : [MDataTableStyle]);
	// -------------------------------------------------------------

}

extractCommonAlignmentFromMParagraphStyles(styles: [MParagraphStyle]) -> CommonAlignment {
	fold(styles, StartAlign(), \acc, style ->
		switch (style) {
			EndAlign(): style;
			LeftAlign(): style;
			RightAlign(): style;
			CenterAlign(): style;
			default: acc;
		}
	)
}
