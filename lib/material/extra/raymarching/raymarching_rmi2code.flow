import material/extra/raymarching/raymarching_types;
import string;

export {
	RMIExp2GLSL(exp : RMIExp) -> string;
	RMIExp2GLSLMaterial(exp : RMIExp) -> string;
	RMIExp2JS(exp : RMIExp) -> string;
}

RMIExp2GLSL(exp : RMIExp) -> string {
	switch(exp) {
		RMICall(fn, args): switch(fn) {
			RMIOp(opName): if (length(args) == 1) {
				opName + RMIExp2GLSL(args[0])
			} else if (length(args) == 2) {
				RMIExp2GLSL(args[0]) + " " + opName + " " + RMIExp2GLSL(args[1])
			} else if (length(args) == 3) {
				RMIExp2GLSL(args[0]) + "?" + RMIExp2GLSL(args[1]) + ":" + RMIExp2GLSL(args[2])
			} else "";
			RMIFn(fnName): fnName + "(" + strGlue(map(args, RMIExp2GLSL), ", ") + ")";
		};
		RMIP(): "p";
		RMIDouble(num): d2GLSLfloat(num);
		RMIInt(num): i2s(num);
		RMIBool(num): b2s(num);
		RMIXYZ(x, y, z): formatString("vec3(%1, %2, %3)", [d2GLSLfloat(x), d2GLSLfloat(y), d2GLSLfloat(z)]);
		RMIVar(name): name;
		RMIConcat(exp1, exp2): RMIExp2GLSL(exp1) + RMIExp2GLSL(exp2);
		RMIProperty(exp2, id, property): RMIExp2GLSL(exp2);
		RMITexture(id, texture): formatString("(
			texture2D(
				uSampler[%1],
				vec2(
					mod(p *3. / (textureSizes[%1].x / max(textureSizes[%1].x, textureSizes[%1].y)), 1.).z,
					mod(p *3. / (textureSizes[%1].y / max(textureSizes[%1].x, textureSizes[%1].y)), 1.).x
				)
			) * normal.y +
			texture2D(
				uSampler[%1],
				vec2(
					mod(p2*3. / (textureSizes[%1].x / max(textureSizes[%1].x, textureSizes[%1].y)), 1.).x,
					mod(p2 *3. / (textureSizes[%1].y / max(textureSizes[%1].x, textureSizes[%1].y)), 1.).y
				)
			) * normal.z +
			texture2D(
				uSampler[%1],
				vec2(
					mod(p2 *3. / (textureSizes[%1].x / max(textureSizes[%1].x, textureSizes[%1].y)), 1.).z,
					mod(p2 *3. / (textureSizes[%1].y / max(textureSizes[%1].x, textureSizes[%1].y)), 1.).y
				)
			) * normal.x
		).rgb", [i2s(id)]);
		RMIEmpty(): "";
	}
}

RMIExp2GLSLMaterial(exp : RMIExp) -> string {
	switch(exp) {
		RMICall(fn, args): strGlue(filter(map(filterRMIBlock(args), RMIExp2GLSLMaterial), \s -> s != ""), " else ");
		RMIP(): "p";
		RMIDouble(num): d2GLSLfloat(num);
		RMIInt(num): i2s(num);
		RMIBool(num): b2s(num);
		RMIXYZ(x, y, z): formatString("vec3(%1, %2, %3)", [d2GLSLfloat(x), d2GLSLfloat(y), d2GLSLfloat(z)]);
		RMIVar(name): name;
		RMIConcat(exp1, exp2): RMIExp2GLSLMaterial(exp1) + RMIExp2GLSLMaterial(exp2);
		RMIProperty(exp2, id, property): formatString("if (id == %1) {\n\tmaterialColor = %2;\n}", [i2s(id), RMIExp2GLSL(property)]);
		RMITexture(id, texture): "";
		RMIEmpty(): "";
	}
}

filterRMIBlock(exps : [RMIExp]) -> [RMIExp] {
	filter(exps, \exp -> {
		switch(exp) {
			RMICall(fn, args): true;
			RMIP(): false;
			RMIDouble(num):false;
			RMIInt(num): false;
			RMIBool(num): false;
			RMIXYZ(x, y, z): false;
			RMIVar(name): false;
			RMIConcat(exp1, exp2): true;
			RMIProperty(exp2, id, property): true;
			RMITexture(id, texture): false;
			RMIEmpty(): false;
		}
	})
}

RMIExp2JS(exp : RMIExp) -> string {
	switch(exp) {
		RMICall(fn, args): switch(fn) {
			RMIOp(opName): if (length(args) == 1) {
				opName + RMIExp2JS(args[0])
			} else if (length(args) == 2) {
				RMIExp2JS(args[0]) + " " + opName + " " + RMIExp2JS(args[1])
			} else if (length(args) == 3) {
				RMIExp2JS(args[0]) + "?" + RMIExp2JS(args[1]) + ":" + RMIExp2JS(args[2])
			} else "";
			RMIFn(fnName): fnName + "(" + strGlue(map(args, RMIExp2JS), ", ") + ")";
		};
		RMIP(): "p";
		RMIDouble(num): d2GLSLfloat(num);
		RMIInt(num): i2s(num);
		RMIBool(num): b2s(num);
		RMIXYZ(x, y, z): formatString("glm.vec3(%1, %2, %3)", [d2GLSLfloat(x), d2GLSLfloat(y), d2GLSLfloat(z)]);
		RMIVar(name): name;
		RMIConcat(exp1, exp2): RMIExp2JS(exp1) + RMIExp2JS(exp2);
		RMIProperty(exp2, id, property): "";
		RMITexture(id, texture): "";
		RMIEmpty(): "";
	}
}

d2GLSLfloat(num : double) {
	s = d2s(num);
	if (strContains(s, ".")) s else s + ".";
}