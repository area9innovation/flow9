import material/extra/raymarching/raymarching_types;
import math/math;
import ds/arrayutils;

export {
	RMScene2RMIExp(obj : RMScene, simpleDistance : bool) -> Triple<RMIExp, Tree<int, RMIExp>, Tree<int, RMScene>>;
	RMLights2RMIExp(obj : RMLights) -> RMIExp;
	RMScene2RMIExpJS(obj : RMScene) -> RMIExp;

	hexColor2RMI(color : int) -> RMIXYZ;
}

RMObjectCounter(
	objectId : int,
	textureId : int,
	topLevelObjects : Tree<int, RMScene>,
	topLevelSmoothObjects : Tree<int, RMIExp>
);

RMSceneAccumulators(
	position : RMCoordinate,
	rmiPosition : RMIXYZ,
	materialColor : RMBaseMaterial,
	materialProperties : [RMMaterialProperties],
	rmiMateiral : RMIExp,
);

RMScene2RMIExp(obj : RMScene, simpleDistance : bool) -> Triple<RMIExp, Tree<int, RMIExp>, Tree<int, RMScene>> {
	resultExp = RMScene2RMIExp0(
		obj,
		RMSceneAccumulators(RMXYZ(0., 0., 0.), RMIXYZ(0., 0., 0.), RMColor(initRMInteractive(0)), [], RMIXYZ(1., 1., 1.)),
		RMObjectCounter(0, 0, makeTree(), makeTree()),
		true,
		simpleDistance,
		false
	);
	Triple(resultExp.second, resultExp.first.topLevelSmoothObjects, resultExp.first.topLevelObjects)
}

RMScene2RMIExp0(
	obj : RMScene,
	acc : RMSceneAccumulators,
	id : RMObjectCounter,
	topLevel : bool,
	simpleDistance : bool,
	innerLevel : bool
) -> Pair<RMObjectCounter, RMIExp> {
	switch(obj) {
		RMCompositeObject(object, name, color, materialProperties, position): {
			compositeObject = RMSTranslate(RMMaterial(object, color, materialProperties), position);
			RMScene2RMIExp0(compositeObject, acc, id, topLevel, simpleDistance, innerLevel);
		};
		RMPrimitive(): {
			wrapFn = if (simpleDistance) {
				\e -> Pair(RMObjectCounter(id.objectId + 1, id.textureId, id.topLevelObjects, id.topLevelSmoothObjects), e)
			} else {
				\e -> addColorToRMIExp(e, id, acc.rmiMateiral, innerLevel)
			};
			resultExp = wrapFn(RMPrimitive2RMIExp(obj, acc.rmiPosition));
			compositeObject = RMCompositeObject(obj, i2s(id.objectId), acc.materialColor, acc.materialProperties, acc.position);

			if (topLevel) Pair(
				RMObjectCounter(resultExp.first with topLevelObjects = setTree(resultExp.first.topLevelObjects, id.objectId, compositeObject)),
				resultExp.second
			) else resultExp
		}
		RMSTranslate(object, d): RMScene2RMIExp0(
			object,
			RMSceneAccumulators(
				acc with
				rmiPosition = addRMIXYZ(acc.rmiPosition, RMCoordinate2RMIXYZ(d)),
				position = addRMCoordinate(acc.position, d)
			),
			id,
			topLevel,
			simpleDistance,
			innerLevel
		);
		RMUnion2(object1, object2): {
			exp1 = RMScene2RMIExp0(object1, acc, id, topLevel, simpleDistance, innerLevel);
			exp2 = RMScene2RMIExp0(object2, acc, exp1.first, topLevel, simpleDistance, innerLevel);
			Pair(exp2.first, RMICall(RMIFn(if (simpleDistance) "min" else "minOI"),
				[
					exp1.second,
					exp2.second,
				]
			))
		};
		RMUnion(objects): {
			if (length(objects) > 0 ) {
				exp1 = RMScene2RMIExp0(objects[0], acc, id, topLevel, simpleDistance, innerLevel);
				fold(tail(objects), exp1, \acc2, obj2 -> {
					exp2 = RMScene2RMIExp0(obj2, acc, acc2.first, topLevel, simpleDistance, innerLevel);
					Pair(exp2.first, RMICall(RMIFn(if (simpleDistance) "min" else "minOI"),
						[
							acc2.second,
							exp2.second,
						]
					))
				})
			} else {
				Pair(id, RMIEmpty());
			}
		};
		RMSmoothUnion(objects, k): {
			if (length(objects) > 0 ) {
				makeSmoothExp = \cond -> {
					initExp = RMScene2RMIExp0(objects[0], acc, id, false, simpleDistance, cond);
					fold(tail(objects), initExp, \acc2, obj2 -> {
						exp2 = RMScene2RMIExp0(obj2, acc, acc2.first, false, simpleDistance, cond);
						Pair(exp2.first, RMICall(
							RMIFn(if (simpleDistance) "opSmoothUnion" else if(cond) "minOIS" else "minOISR"),
							concat(
								[acc2.second, exp2.second, RMIDouble(k)],
								if (!simpleDistance && cond) [RMIP(), RMIVar("normal")] else []
							)
						))
					});
				}
				resultExp = makeSmoothExp(false);
				resultExpI = makeSmoothExp(true);
				if (topLevel) Pair(
					RMObjectCounter(
						resultExp.first with
						topLevelSmoothObjects = setTree(resultExp.first.topLevelSmoothObjects, id.objectId, resultExpI.second),
						topLevelObjects = setTree(resultExp.first.topLevelObjects, id.objectId, obj)
					),
					resultExp.second
				) else resultExp
			} else {
				Pair(id, RMIEmpty());
			}
		};
		RMMaterial(object, color, materialProperties): {
			switch(color) {
				RMTexture(texture, parameters): RMScene2RMIExp0(
					object,
					RMSceneAccumulators(
						acc with
						rmiMateiral = RMICall(
							RMIFn("getTextureColor"),
							[
								RMIP(),
								RMIVar("normal"),
								RMIVar(formatString("textureParameters[%1]", [i2s(id.textureId)])),
								RMIVar(formatString("textures[%1]", [i2s(id.textureId)]))
							]
						),
						materialColor = color,
						materialProperties = materialProperties
					),
					id,
					topLevel,
					simpleDistance,
					innerLevel
				);
				RMColor(col): {
					RMScene2RMIExp0(
						object,
						RMSceneAccumulators(
							acc with
							rmiMateiral = hexColor2RMI(getValue(col.behaviour)),
							materialColor = color,
							materialProperties = materialProperties
						),
						id,
						topLevel,
						simpleDistance,
						innerLevel
					);
				}
			}
		}
		RMEmpty(): Pair(id, RMIEmpty());
	}
}

RMPrimitive2RMIExp(obj : RMPrimitive, position : RMIXYZ) -> RMIExp {
	switch(obj) {
		RMSphere(radius): RMICall(RMIOp("-"), [
			RMICall(RMIFn("length"), [
				RMICall(RMIOp("-"), [RMIP(), position]),
			]),
			RMIDouble(radius)
		]);
		RMPlane(normal): RMICall(RMIFn("dot"), [
			RMICall(RMIOp("-"), [RMIP(), position]),
			RMICall(RMIFn("normalize"), [
				RMCoordinate2RMIXYZ(normal)
			])
		]);
		RMBox(box): RMICall(RMIFn("sdBox"), [
			RMICall(RMIOp("-"), [RMIP(), position]),
			RMCoordinate2RMIXYZ(box)
		]);
		RMRoundBox(box, radius): RMICall(RMIFn("sdRoundBox"), [
			RMICall(RMIOp("-"), [RMIP(), position]),
			RMCoordinate2RMIXYZ(box),
			RMIDouble(radius)
		]);
		RMBoxFrame(box, thickness): RMICall(RMIFn("sdBoxFrame"), [
			RMICall(RMIOp("-"), [RMIP(), position]),
			RMCoordinate2RMIXYZ(box),
			RMIDouble(thickness)
		]);
		RMTorus(revolutionRadius, tubeRadius): RMICall(RMIFn("sdTorus"), [
			RMICall(RMIOp("-"), [RMIP(), position]),
			RMICall(RMIFn("vec2"), [RMIDouble(revolutionRadius), RMIDouble(tubeRadius)])
		]);
		RMCappedTorus(revolutionRadius, tubeRadius, percent): RMICall(RMIFn("sdCappedTorus"), [
			RMICall(RMIOp("-"), [RMIP(), position]),
			RMICall(RMIFn("vec2"), [RMIDouble(sin(PI * percent)), RMIDouble(cos(PI * percent))]),
			RMIDouble(revolutionRadius),
			RMIDouble(tubeRadius)
		]);
		RMCylinder(height, radius): RMICall(RMIFn("sdCappedCylinder"), [
			RMICall(RMIOp("-"), [RMIP(), position]),
			RMIDouble(height),
			RMIDouble(radius)
		]);
		RMRoundedCylinder(height, radius, radiusRounded): RMICall(RMIFn("sdRoundedCylinder"), [
			RMICall(RMIOp("-"), [RMIP(), position]),
			RMIDouble(radius / 2.),
			RMIDouble(radiusRounded),
			RMIDouble(height)
		]);
	}
}

RMLights2RMIExp(obj : RMLights) -> RMIExp {
	RMLights2RMIExp0(obj, RMIXYZ(0., 0., 0.), RMIXYZ(1., 1., 1.))
}

RMLights2RMIExp0(obj : RMLights, acc : RMIXYZ, color : RMIExp) -> RMIExp {
	switch(obj) {
		RMCompositeLight(size, name, col, position): {
			compositeObject = RMLTranslate(RMLightMaterial(RMLight(size), col), position);
			RMLights2RMIExp0(compositeObject, acc, color);
		};
		RMLTranslate(object, d): RMLights2RMIExp0(object, addRMIXYZ(acc, RMCoordinate2RMIXYZ(d)), color);
		RMLightMaterial(object, col): {
			RMLights2RMIExp0(
				object,
				acc,
				hexColor2RMI(col),
			);
		}
		RMLight(size): RMICall(RMIOp("*"),
			[
				RMICall(RMIFn("getLight"), [
					RMIP(),
					RMIVar("rayDirection"),
					acc,
					color,
					RMIVar("normal"),
					RMIDouble(size)
				]),
				color
			]
		);
		RMPlus(object1, object2): {
			exp1 = RMLights2RMIExp0(object1, acc, color);
			exp2 = RMLights2RMIExp0(object2, acc, color);
			RMICall(RMIOp("+"),
				[
					exp1,
					exp2,
				]
			)
		};
		RMEmpty(): RMIEmpty();
	}
}

RMScene2RMIExpJS(obj : RMScene) -> RMIExp {
	RMScene2RMIExpJS0(obj, RMIXYZ(0., 0., 0.), 0).second
}

RMScene2RMIExpJS0(obj : RMScene, acc : RMIXYZ, id : int) -> Pair<int, RMIExp> {
	switch(obj) {
		RMCompositeObject(object, name, color, materialProperties, position): {
			compositeObject = RMSTranslate(RMMaterial(object, color, materialProperties), position);
			RMScene2RMIExpJS0(compositeObject, acc, id);
		};
		RMPrimitive(): {
			Pair(id + 1, RMIJSObject(setTree(makeTree1("distance", RMPrimitive2RMIExpJS(obj, acc)), "id", RMIInt(id))));
		}
		RMSTranslate(object, d): RMScene2RMIExpJS0(object, addRMIXYZ(acc, RMCoordinate2RMIXYZ(d)), id);
		RMUnion2(object1, object2): {
			exp1 = RMScene2RMIExpJS0(object1, acc, id);
			exp2 = RMScene2RMIExpJS0(object2, acc, exp1.first);
			Pair(exp2.first, RMICall(RMIFn("minOI"),
				[
					exp1.second,
					exp2.second,
				]
			));
		}
		RMUnion(objects): {
			if (length(objects) > 0 ) {
				exp1 = RMScene2RMIExpJS0(objects[0], acc, id);
				fold(tail(objects), exp1, \acc2, obj2 -> {
					exp2 = RMScene2RMIExpJS0(obj2, acc, acc2.first);
					Pair(exp2.first, RMICall(RMIFn("minOI"),
						[
							acc2.second,
							exp2.second,
						]
					))
				})
			} else {
				Pair(id, RMIEmpty());
			}
		};
		RMSmoothUnion(objects, k): {
			if (length(objects) > 0 ) {
				exp1 = RMScene2RMIExpJS0(objects[0], acc, id);
				fold(tail(objects), exp1, \acc2, obj2 -> {
					exp2 = RMScene2RMIExpJS0(obj2, acc, acc2.first);
					Pair(exp2.first, RMICall(RMIFn("minOIS"),
						[
							acc2.second,
							exp2.second,
							RMIDouble(k)
						]
					))
				})
			} else {
				Pair(id, RMIEmpty());
			}
		};
		RMMaterial(object, color, materialProperties): RMScene2RMIExpJS0(object, acc, id);
		RMEmpty(): Pair(id, RMIEmpty());
	}
}

RMPrimitive2RMIExpJS(obj : RMPrimitive, position : RMIXYZ) -> RMIExp {
	switch(obj) {
		RMSphere(radius): RMICall(RMIOp("-"), [
			RMICall(RMIFn("glm.length"), [
				RMIConcat(RMIP(), RMICall(RMIFn("['-']"), [position]))
			]),
			RMIDouble(radius)
		]);
		RMPlane(normal): RMICall(RMIFn("glm.dot"), [
			RMIConcat(RMIP(), RMICall(RMIFn("['-']"), [position])),
			RMICall(RMIFn("glm.normalize"), [
				RMCoordinate2RMIXYZ(normal)
			])
		]);
		RMBox(box): RMICall(RMIFn("sdBox"), [
			RMIConcat(RMIP(), RMICall(RMIFn("['-']"), [position])),
			RMCoordinate2RMIXYZ(box)
		]);
		RMRoundBox(box, radius): RMICall(RMIFn("sdRoundBox"), [
			RMIConcat(RMIP(), RMICall(RMIFn("['-']"), [position])),
			RMCoordinate2RMIXYZ(box),
			RMIDouble(radius)
		]);
		RMBoxFrame(box, thickness): RMICall(RMIFn("sdBoxFrame"), [
			RMIConcat(RMIP(), RMICall(RMIFn("['-']"), [position])),
			RMCoordinate2RMIXYZ(box),
			RMIDouble(thickness)
		]);
		RMTorus(revolutionRadius, tubeRadius): RMICall(RMIFn("sdTorus"), [
			RMIConcat(RMIP(), RMICall(RMIFn("['-']"), [position])),
			RMICall(RMIFn("glm.vec2"), [RMIDouble(revolutionRadius), RMIDouble(tubeRadius)])
		]);
		RMCappedTorus(revolutionRadius, tubeRadius, percent): RMICall(RMIFn("sdCappedTorus"), [
			RMIConcat(RMIP(), RMICall(RMIFn("['-']"), [position])),
			RMICall(RMIFn("glm.vec2"), [RMIDouble(sin(PI * percent)), RMIDouble(cos(PI * percent))]),
			RMIDouble(revolutionRadius),
			RMIDouble(tubeRadius)
		]);
		RMCylinder(height, radius): RMICall(RMIFn("sdCappedCylinder"), [
			RMIConcat(RMIP(), RMICall(RMIFn("['-']"), [position])),
			RMIDouble(height),
			RMIDouble(radius)
		]);
		RMRoundedCylinder(height, radius, radiusRounded): RMICall(RMIFn("sdRoundedCylinder"), [
			RMIConcat(RMIP(), RMICall(RMIFn("['-']"), [position])),
			RMIDouble(radius / 2.),
			RMIDouble(radiusRounded),
			RMIDouble(height)
		]);
	}
}

RMCoordinate2RMIXYZ(c : RMCoordinate) -> RMIXYZ {
	switch(c) {
		RMXYZ(x, y, z): RMIXYZ(x, y, z);
		RMXY(x, y): RMIXYZ(x, y, 0.);
		RMXZ(x, z): RMIXYZ(x, 0., z);
		RMYZ(y, z): RMIXYZ(0., y, z);
		RMX(x): RMIXYZ(x, 0., 0.);
		RMY(y): RMIXYZ(0., y, 0.);
		RMZ(z): RMIXYZ(0., 0., z);
	}
}

addRMIXYZ(c1 : RMIXYZ, c2 : RMIXYZ) -> RMIXYZ {
	RMIXYZ(c1.x + c2.x, c1.y + c2.y, c1.z + c2.z)
}

addRMCoordinate(c1 : RMCoordinate, c2 : RMCoordinate) -> RMCoordinate {
	convertCoordinate = \c -> switch(c) {
		RMXYZ(x, y, z): RMXYZ(x, y, z);
		RMXY(x, y): RMXYZ(x, y, 0.);
		RMXZ(x, z): RMXYZ(x, 0., z);
		RMYZ(y, z): RMXYZ(0., y, z);
		RMX(x): RMXYZ(x, 0., 0.);
		RMY(y): RMXYZ(0., y, 0.);
		RMZ(z): RMXYZ(0., 0., z);
	}
	c1xyz = convertCoordinate(c1);
	c2xyz = convertCoordinate(c2);
	RMXYZ(c1xyz.x + c2xyz.x, c1xyz.y + c2xyz.y, c1xyz.z + c2xyz.z)
}

addColorToRMIExp(exp : RMIExp, id : RMObjectCounter, color : RMIExp, innerLevel : bool) -> Pair<RMObjectCounter, RMIProperty> {
	plainColor = switch (color) {
		RMIXYZ(x, y, z): Some(color);
		default: None();
	}
	isTexture = switch (color) {
		RMICall(fn, args): switch(fn) {
			RMIOp(__): false;
			RMIFn(fnName): fnName == "getTextureColor";
		};
		default: false;
	}
	Pair(
		RMObjectCounter(
			id.objectId + 1,
			id.textureId + b2i(isTexture),
			id.topLevelObjects,
			id.topLevelSmoothObjects
		),
		RMIProperty(
			RMICall(
				RMIFn("ObjectInfo"),
				[
					exp,
					RMIInt(id.objectId),
					RMIInt(if (isTexture) id.textureId else -1),
					RMIBool(true),
					RMICall(
						RMIFn("Material"),
						[
							eitherMap(
								plainColor, \__->
								RMIVar(formatString("color[%1]", [i2s(id.objectId - id.textureId)])),
								if (!innerLevel) RMIXYZ(0., 0., 0.) else color
							),
							RMIVar(formatString("reflectiveness[%1]", [i2s(id.objectId)]))
						]
					)
				]
			),
			id.objectId,
			eitherMap(plainColor, \__-> RMIEmpty(), color),
		)
	)
}

hexColor2RMI(color : int) -> RMIXYZ {
	RMIXYZ(i2d(color/0x10000)/255., i2d(color/0x100%0x100)/255., (i2d(color%0x100)/255.))
}
