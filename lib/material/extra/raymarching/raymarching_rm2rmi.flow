import material/extra/raymarching/raymarching_types;
import math/math;
import ds/arrayutils;

export {
	RMScene2RMIExp(obj : RMScene, simpleDistance : bool) -> Pair<RMObjectCounter, RMIExp>;
	RMLights2RMIExp(obj : RMLights) -> RMIExp;
	RMScene2RMIExpJS(obj : RMScene) -> RMIExp;

	hexColor2RMI(color : int) -> RMIXYZ;
	expandRMCoordinate(c : RMCoordinate) -> RMXYZ;
	RMCoordinate2RMIXYZ(c : RMCoordinate) -> RMIXYZ;
	addRMCoordinate(c1 : RMCoordinate, c2 : RMCoordinate) -> RMXYZ;
	multiplyRMCoordinate(c1 : RMCoordinate, c2 : RMCoordinate) -> RMXYZ;
	divideRMCoordinate(c1 : RMCoordinate, c2 : RMCoordinate) -> RMXYZ;
}

RMObjectCounter(
	objectId : int,
	textureId : int,
	topLevelObjects : Tree<int, RMScene>,
	topLevelSmoothObjects : Tree<int, RMIExp>,
	smoothObjectsCounter : int,
	repetitionCounter : int,
);

RMSceneAccumulators(
	position : Transform<RMCoordinate>,
	rotation : Transform<RMCoordinate>,
	scale : Transform<RMCoordinate>,
	materialColor : RMBaseMaterial,
	materialProperties : [RMMaterialProperties],
	rmiMateiral : RMIExp,
	trigger : Behaviour<RMTrigger>,
	smoothMaterial : bool,
	repetition : List<Pair<RMXYZ, RMXYZ>>,
);

RMScene2RMIExp(obj : RMScene, simpleDistance : bool) -> Pair<RMObjectCounter, RMIExp> {
	RMScene2RMIExp0(
		obj,
		RMSceneAccumulators(
			const(RMXYZ(0., 0., 0.)),
			const(RMXYZ(0., 0., 0.)),
			const(RMXYZ(0., 0., 0.)),
			RMColor(make(0)),
			[],
			RMIXYZ(1., 1., 1.),
			make(RMMouseDownleft()),
			false,
			makeList(),
		),
		RMObjectCounter(0, 0, makeTree(), makeTree(), 0, 0),
		true,
		simpleDistance,
		false
	)
}

RMScene2RMIExp0(
	obj : RMScene,
	acc : RMSceneAccumulators,
	id : RMObjectCounter,
	topLevel : bool,
	simpleDistance : bool,
	innerLevel : bool
) -> Pair<RMObjectCounter, RMIExp> {
	switch(obj) {
		RMCompositeObject(object, name, color, materialProperties, position, rotation, scale, trigger, shown): {
			compositeObject = RMTranslate(RMRotate(RMScale(RMMaterial(RMInteractive(object, trigger), color, materialProperties), scale), rotation), position);
			RMScene2RMIExp0(compositeObject, acc, id, topLevel, simpleDistance, innerLevel);
		};
		RMPrimitive(): {
			wrapFn = if (simpleDistance) {
				\e : RMIExp -> Pair(RMObjectCounter(id with objectId = id.objectId + 1), e)
			} else {
				\e : RMIExp -> addColorToRMIExp(e, id, acc.rmiMateiral, innerLevel)
			};
			wrapRepetitions = \p -> {
				foldiList(
					acc.repetition,
					p,
					\i, acc2, __ -> {
						RMICall(RMIOp("-"), [
							RMIBrackets(acc2),
							RMICall(RMIOp("*"), [
								RMIArrayIndex("spaces", id.repetitionCounter + i),
								RMICall(RMIFn("clamp"), [
									RMICall(RMIFn("round"), [RMICall(RMIOp("/"), [RMIBrackets(acc2), RMIArrayIndex("spaces", id.repetitionCounter + i)])]),
									RMICall(RMIOp("*"), [RMIDouble(-1.), RMIArrayIndex("repetitions", id.repetitionCounter + i)]),
									RMIArrayIndex("repetitions", id.repetitionCounter + i),
								])
							])
						])
					}
				)
			};
			resultExp = wrapFn(RMIBrackets(RMICall(RMIOp("+"), [RMICall(RMIOp("*"), [RMIArrayIndex("shown", id.objectId), RMIBrackets(RMPrimitive2RMIExp(
				obj,
				wrapRepetitions(RMIStructMember(RMIBrackets(RMICall(RMIOp("*"), [RMIArrayIndex("positions", id.objectId), RMICall(RMIFn("vec4"), [RMIP(), RMIDouble(1.0)])])), "xyz")),
				id.objectId
			))]), RMICall(RMIOp("*"), [RMIBrackets(RMICall(RMIOp("-"), [RMIDouble(1.0), RMIArrayIndex("shown", id.objectId)])), RMIVar("MAX_DIST")])])));
			compositeObject = RMCompositeObject(
				obj,
				i2s(id.objectId),
				acc.materialColor,
				acc.materialProperties,
				make(fgetValue(acc.position)),
				make(fgetValue(acc.rotation)),
				make(fgetValue(acc.scale)),
				acc.trigger,
				const(true)
			);

			if (topLevel) Pair(
				RMObjectCounter(
					resultExp.first with
					topLevelObjects = setTree(resultExp.first.topLevelObjects, id.objectId, compositeObject),
					repetitionCounter = if (!isEmptyList(acc.repetition)) id.repetitionCounter + countList(acc.repetition) else id.repetitionCounter,
				),
				resultExp.second
			) else Pair(
				RMObjectCounter(
					resultExp.first with
					repetitionCounter = if (!isEmptyList(acc.repetition)) id.repetitionCounter + countList(acc.repetition) else id.repetitionCounter,
				),
				resultExp.second
			)
		}
		RMTranslate(object, d): RMScene2RMIExp0(
			object,
			RMSceneAccumulators(
				acc with
				position = fselect2(acc.position, d, FLift2(addRMCoordinate))
			),
			id,
			topLevel,
			simpleDistance,
			innerLevel
		);
		RMRotate(object, r): RMScene2RMIExp0(
			object,
			RMSceneAccumulators(
				acc with
				rotation = fselect2(acc.rotation, r, FLift2(addRMCoordinate))
			),
			id,
			topLevel,
			simpleDistance,
			innerLevel
		);
		RMScale(object, s): RMScene2RMIExp0(
			object,
			RMSceneAccumulators(
				acc with
				scale = fselect2(acc.scale, s, FLift2(addRMCoordinate))
			),
			id,
			topLevel,
			simpleDistance,
			innerLevel
		);
		RMRepetitionLimited(object, space, repetitions): RMScene2RMIExp0(
			object,
			RMSceneAccumulators(acc with repetition = Cons(Pair(getValue(space), getValue(repetitions)), acc.repetition)),
			id,
			topLevel,
			simpleDistance,
			innerLevel
		);
		RMBinaryOperator(): RMBinaryOperator2RMIExp0(obj, acc, id, topLevel, simpleDistance, innerLevel);
		RMMaterial(object, color, materialProperties): {
			switch(color) {
				RMTexture(texture, parameters): RMScene2RMIExp0(
					object,
					RMSceneAccumulators(
						acc with
						rmiMateiral = RMICall(
							RMIFn("getTextureColor"),
							[
								RMIP(),
								RMIVar("normal"),
								RMIArrayIndex("textureParameters", id.textureId),
								RMIArrayIndex("textures", id.textureId)
							]
						),
						materialColor = color,
						materialProperties = materialProperties
					),
					id,
					topLevel,
					simpleDistance,
					innerLevel
				);
				RMColor(col): {
					RMScene2RMIExp0(
						object,
						RMSceneAccumulators(
							acc with
							rmiMateiral = hexColor2RMI(getValue(col)),
							materialColor = color,
							materialProperties = materialProperties
						),
						id,
						topLevel,
						simpleDistance,
						innerLevel
					);
				}
			}
		}
		RMInteractive(object, trigger): RMScene2RMIExp0(
			object,
			RMSceneAccumulators(acc with trigger = trigger),
			id,
			topLevel,
			simpleDistance,
			innerLevel
		);
		RMText(text, position, showDot): Pair(id, RMIEmpty());
		RMEmpty(): Pair(id, RMIEmpty());
	}
}

RMPrimitive2RMIExp(obj : RMPrimitive, distance : RMIExp, id : int) -> RMIExp {
	getObjectParameter = \paramId -> RMIStructMember(RMIArrayIndex("objectParameters", id), paramId);
	switch(obj) {
		RMSphere(radius): RMICall(RMIOp("-"), [
			RMICall(RMIFn("length"), [distance]),
		 	getObjectParameter("x")
		]);
		RMPlane(normal): RMICall(RMIFn("dot"), [
			distance,
			RMICall(RMIFn("normalize"), [
				RMICall(RMIFn("vec3"), [getObjectParameter("x"), getObjectParameter("y"), getObjectParameter("z")])
			])
		]);
		RMBox(box): RMICall(RMIFn("sdBox"), [
			distance,
			RMICall(RMIFn("vec3"), [getObjectParameter("x"), getObjectParameter("y"), getObjectParameter("z")])
		]);
		RMRoundBox(box, radius): RMICall(RMIFn("sdRoundBox"), [
			distance,
			RMICall(RMIFn("vec3"), [getObjectParameter("x"), getObjectParameter("y"), getObjectParameter("z")]),
			getObjectParameter("w")
		]);
		RMBoxFrame(box, thickness): RMICall(RMIFn("sdBoxFrame"), [
			distance,
			RMICall(RMIFn("vec3"), [getObjectParameter("x"), getObjectParameter("y"), getObjectParameter("z")]),
			getObjectParameter("w")
		]);
		RMTorus(revolutionRadius, tubeRadius): RMICall(RMIFn("sdTorus"), [
			distance,
			RMICall(RMIFn("vec2"), [getObjectParameter("x"), getObjectParameter("y")])
		]);
		RMCappedTorus(revolutionRadius, tubeRadius, percent): RMICall(RMIFn("sdCappedTorus"), [
			distance,
			RMICall(RMIFn("vec2"), [getObjectParameter("z"), getObjectParameter("w")]),
			getObjectParameter("x"),
			getObjectParameter("y")
		]);
		RMCylinder(height, radius): RMICall(RMIFn("sdCappedCylinder"), [
			distance,
			getObjectParameter("x"),
			getObjectParameter("y")
		]);
		RMRoundedCylinder(height, radius, radiusRounded): RMICall(RMIFn("sdRoundedCylinder"), [
			distance,
			getObjectParameter("y"),
			getObjectParameter("z"),
			getObjectParameter("x")
		]);
	}
}

RMBinaryOperator2RMIExp0(
	obj : RMBinaryOperator,
	acc : RMSceneAccumulators,
	id : RMObjectCounter,
	topLevel : bool,
	simpleDistance : bool,
	innerLevel : bool
) -> Pair<RMObjectCounter, RMIExp> {
	switch(obj) {
		RMUnion2(object1, object2): {
			exp1 = RMScene2RMIExp0(object1, acc, id, topLevel, simpleDistance, innerLevel);
			exp2 = RMScene2RMIExp0(object2, acc, exp1.first, topLevel, simpleDistance, innerLevel);
			checkRMBinaryOperator(id, exp1, exp2, \ -> Pair(exp2.first, RMICall(RMIFn(if (simpleDistance) "min" else "opUnion"),
				[
					exp1.second,
					exp2.second,
				]
			)))
		};
		RMUnion(objects): {
			if (length(objects) > 0 ) {
				newExp = fold(tail(objects), objects[0], \acc2, obj2 -> RMUnion2(acc2, obj2));
				RMScene2RMIExp0(newExp, acc, id, topLevel, simpleDistance, innerLevel);
			} else {
				Pair(id, RMIEmpty());
			}
		};
		RMIntersection2(object1, object2): {
			exp1 = RMScene2RMIExp0(object1, acc, id, topLevel, simpleDistance, innerLevel);
			exp2 = RMScene2RMIExp0(object2, acc, exp1.first, topLevel, simpleDistance, innerLevel);
			checkRMBinaryOperator(id, exp1, exp2, \ -> Pair(exp2.first, RMICall(RMIFn(if (simpleDistance) "max" else "opIntersection"),
				[
					exp1.second,
					exp2.second,
				]
			)))
		};
		RMIntersection(objects): {
			if (length(objects) > 0 ) {
				newExp = fold(tail(objects), objects[0], \acc2, obj2 -> RMIntersection2(acc2, obj2));
				RMScene2RMIExp0(newExp, acc, id, topLevel, simpleDistance, innerLevel);
			} else {
				Pair(id, RMIEmpty());
			}
		};
		RMSubtraction2(object1, object2): {
			exp1 = RMScene2RMIExp0(object1, acc, id, topLevel, simpleDistance, innerLevel);
			exp2 = RMScene2RMIExp0(object2, acc, exp1.first, topLevel, simpleDistance, innerLevel);
			checkRMBinaryOperator(id, exp1, exp2, \ -> Pair(exp2.first, RMICall(RMIFn(if (simpleDistance) "max" else "opSubtraction"),
				[
					exp1.second,
					if (simpleDistance) RMICall(RMIOp("*"), [RMIDouble(-1.), exp2.second]) else exp2.second,
				]
			)))
		};
		RMSubtraction(objects): {
			if (length(objects) > 0 ) {
				newExp = fold(tail(objects), objects[0], \acc2, obj2 -> RMSubtraction2(acc2, obj2));
				RMScene2RMIExp0(newExp, acc, id, topLevel, simpleDistance, innerLevel);
			} else {
				Pair(id, RMIEmpty());
			}
		};
		RMSmoothUnion2(object1, object2, k): {
			makeSmoothExp = \cond -> {
				newAcc = RMSceneAccumulators(acc with smoothMaterial = cond);
				exp1 = RMScene2RMIExp0(object1, newAcc, id, false, simpleDistance, cond);
				exp2 = RMScene2RMIExp0(object2, newAcc, exp1.first, false, simpleDistance, cond);
				checkRMBinaryOperator(id, exp1, exp2, \ -> Pair(exp2.first, RMICall(
					RMIFn(if (simpleDistance) "opSmoothUnion" else if(newAcc.smoothMaterial) "opSmoothUnionMaterial" else "opSmoothUnionTopLevel"),
					concat(
						[exp1.second, exp2.second, RMIArrayIndex("smoothCoefficients", id.smoothObjectsCounter)],
						if (!simpleDistance && newAcc.smoothMaterial) [RMIP(), RMIVar("normal")] else []
					)
				)))
			}
			resultExp = makeSmoothExp(acc.smoothMaterial);
			resultExpI = makeSmoothExp(true);
			if (topLevel) Pair(
				RMObjectCounter(
					resultExp.first with
					topLevelSmoothObjects = setTree(resultExp.first.topLevelSmoothObjects, id.objectId, resultExpI.second),
					topLevelObjects = setTree(resultExp.first.topLevelObjects, id.objectId, RMInteractive(obj, acc.trigger)),
					smoothObjectsCounter = resultExp.first.smoothObjectsCounter + 1,
				),
				resultExp.second
			) else resultExp
		};
		RMSmoothUnion(objects, k): {
			if (length(objects) > 0 ) {
				newExp = fold(tail(objects), objects[0], \acc2, obj2 -> RMSmoothUnion2(acc2, obj2, k));
				RMScene2RMIExp0(newExp, acc, id, topLevel, simpleDistance, innerLevel);
			} else {
				Pair(id, RMIEmpty());
			}
		};
		RMSmoothIntersection2(object1, object2, k): {
			makeSmoothExp = \cond -> {
				newAcc = RMSceneAccumulators(acc with smoothMaterial = cond);
				exp1 = RMScene2RMIExp0(object1, newAcc, id, false, simpleDistance, cond);
				exp2 = RMScene2RMIExp0(object2, newAcc, exp1.first, false, simpleDistance, cond);
				checkRMBinaryOperator(id, exp1, exp2, \ -> Pair(exp2.first, RMICall(
					RMIFn(if (simpleDistance) "opSmoothIntersection" else if(newAcc.smoothMaterial) "opSmoothIntersectionMaterial" else "opSmoothIntersectionTopLevel"),
					concat(
						[exp1.second, exp2.second, RMIArrayIndex("smoothCoefficients", id.smoothObjectsCounter)],
						if (!simpleDistance && newAcc.smoothMaterial) [RMIP(), RMIVar("normal")] else []
					)
				)))
			}
			resultExp = makeSmoothExp(acc.smoothMaterial);
			resultExpI = makeSmoothExp(true);
			if (topLevel) Pair(
				RMObjectCounter(
					resultExp.first with
					topLevelSmoothObjects = setTree(resultExp.first.topLevelSmoothObjects, id.objectId, resultExpI.second),
					topLevelObjects = setTree(resultExp.first.topLevelObjects, id.objectId, RMInteractive(obj, acc.trigger)),
					smoothObjectsCounter = resultExp.first.smoothObjectsCounter + 1,
				),
				resultExp.second
			) else resultExp
		};
		RMSmoothIntersection(objects, k): {
			if (length(objects) > 0 ) {
				newExp = fold(tail(objects), objects[0], \acc2, obj2 -> RMSmoothIntersection2(acc2, obj2, k));
				RMScene2RMIExp0(newExp, acc, id, topLevel, simpleDistance, innerLevel);
			} else {
				Pair(id, RMIEmpty());
			}
		};
		RMSmoothSubtraction2(object1, object2, k): {
			makeSmoothExp = \cond -> {
				newAcc = RMSceneAccumulators(acc with smoothMaterial = cond);
				exp1 = RMScene2RMIExp0(object1, newAcc, id, false, simpleDistance, cond);
				exp2 = RMScene2RMIExp0(object2, newAcc, exp1.first, false, simpleDistance, cond);
				checkRMBinaryOperator(id, exp1, exp2, \ -> Pair(exp2.first, RMICall(
					RMIFn(if (simpleDistance) "opSmoothSubtraction" else if(newAcc.smoothMaterial) "opSmoothSubtractionMaterial" else "opSmoothSubtractionTopLevel"),
					concat(
						[exp1.second, exp2.second, RMIArrayIndex("smoothCoefficients", id.smoothObjectsCounter)],
						if (!simpleDistance && newAcc.smoothMaterial) [RMIP(), RMIVar("normal")] else []
					)
				)))
			}
			resultExp = makeSmoothExp(acc.smoothMaterial);
			resultExpI = makeSmoothExp(true);
			if (topLevel) Pair(
				RMObjectCounter(
					resultExp.first with
					topLevelSmoothObjects = setTree(resultExp.first.topLevelSmoothObjects, id.objectId, resultExpI.second),
					topLevelObjects = setTree(resultExp.first.topLevelObjects, id.objectId, RMInteractive(obj, acc.trigger)),
					smoothObjectsCounter = resultExp.first.smoothObjectsCounter + 1,
				),
				resultExp.second
			) else resultExp
		};
		RMSmoothSubtraction(objects, k): {
			if (length(objects) > 0 ) {
				newExp = fold(tail(objects), objects[0], \acc2, obj2 -> RMSmoothSubtraction2(acc2, obj2, k));
				RMScene2RMIExp0(newExp, acc, id, topLevel, simpleDistance, innerLevel);
			} else {
				Pair(id, RMIEmpty());
			}
		};
	}
}

RMLights2RMIExp(obj : RMLights) -> RMIExp {
	RMLights2RMIExp0(obj, RMIXYZ(0., 0., 0.), RMIXYZ(1., 1., 1.))
}

RMLights2RMIExp0(obj : RMLights, acc : RMIXYZ, color : RMIExp) -> RMIExp {
	switch(obj) {
		RMCompositeLight(size, name, col, position): {
			compositeObject = RMLightTranslate(RMLightMaterial(RMLight(size), col), position);
			RMLights2RMIExp0(compositeObject, acc, color);
		};
		RMLightTranslate(object, d): RMLights2RMIExp0(object, addRMIXYZ(acc, RMCoordinate2RMIXYZ(d)), color);
		RMLightMaterial(object, col): {
			RMLights2RMIExp0(
				object,
				acc,
				hexColor2RMI(switch(col){
					RMLightColor(c): c;
				}),
			);
		}
		RMLight(size): RMICall(RMIOp("*"),
			[
				RMICall(RMIFn("getLight"), [
					RMIP(),
					RMIVar("rayDirection"),
					acc,
					color,
					RMIVar("normal"),
					RMIDouble(size)
				]),
				color
			]
		);
		RMPlus(object1, object2): {
			exp1 = RMLights2RMIExp0(object1, acc, color);
			exp2 = RMLights2RMIExp0(object2, acc, color);
			RMICall(RMIOp("+"),
				[
					exp1,
					exp2,
				]
			)
		};
		RMEmpty(): RMIEmpty();
	}
}

RMScene2RMIExpJS(obj : RMScene) -> RMIExp {
	RMScene2RMIExpJS0(obj, makeList(), RMObjectCounter(0, 0, makeTree(), makeTree(), 0, 0)).second
}

RMScene2RMIExpJS0(obj : RMScene, repetition : List<Pair<RMXYZ, RMXYZ>>, id : RMObjectCounter) -> Pair<RMObjectCounter, RMIExp> {
	switch(obj) {
		RMCompositeObject(object, name, color, materialProperties, position, rotation, scale, trigger, shown): {
			compositeObject = RMTranslate(RMRotate(RMScale(RMMaterial(object, color, materialProperties), scale), rotation), position);
			RMScene2RMIExpJS0(compositeObject, repetition, id);
		};
		RMPrimitive(): {
			wrapRepetitions = \p -> {
				foldiList(
					repetition,
					p,
					\i, acc2, __ -> {
						RMIConcat(RMIBrackets(acc2), RMICall(RMIFn("['-']"), [
							RMIConcat(RMIArrayIndex("spaces", id.repetitionCounter + i), RMICall(RMIFn("['*']"), [
								RMICall(RMIFn("clampVec3"), [
									RMICall(RMIFn("roundVec3"), [RMICall(RMIFn("divVec3"), [RMIBrackets(acc2), RMIArrayIndex("spaces", id.repetitionCounter + i)])]),
									RMIConcat(RMIArrayIndex("repetitions", id.repetitionCounter + i), RMICall(RMIFn("['*']"), [RMIDouble(-1.)])),
									RMIArrayIndex("repetitions", id.repetitionCounter + i),
								])
							]))
						]))
					}
				);
			};
			Pair(
				RMObjectCounter(id with objectId = id.objectId + 1, repetitionCounter = id.repetitionCounter + countList(repetition)),
				RMIJSObject(
					setTree(makeTree1(
						"distance",
						RMIBrackets(RMICall(RMIOp("+"), [RMICall(RMIOp("*"), [RMIArrayIndex("shown", id.objectId), RMIBrackets(RMPrimitive2RMIExpJS(
							obj,
							wrapRepetitions(RMIStructMember(RMIBrackets(RMIConcat(RMIArrayIndex("positions", id.objectId), RMICall(RMIFn("['*']"), [RMICall(RMIFn("glm.vec4"), [RMIP(), RMIDouble(1.0)])]))), "xyz")),
							id.objectId
						))]), RMICall(RMIOp("*"), [RMIBrackets(RMICall(RMIOp("-"), [RMIDouble(1.0), RMIArrayIndex("shown", id.objectId)])), RMIVar("defaultDistance.distance")])]))
					),
					"id", RMIInt(id.objectId))
				)
			);
		}
		RMTranslate(object, d): RMScene2RMIExpJS0(object, repetition, id);
		RMRotate(object, r): RMScene2RMIExpJS0(object, repetition, id);
		RMScale(object, s): RMScene2RMIExpJS0(object, repetition, id);
		RMRepetitionLimited(object, space, repetitions): RMScene2RMIExpJS0(object, Cons(Pair(getValue(space), getValue(repetitions)), repetition), id);
		RMBinaryOperator(): RMBinaryOperator2RMIExpJS0(obj, repetition, id);
		RMMaterial(object, color, materialProperties): RMScene2RMIExpJS0(object, repetition, id);
		RMInteractive(object, trigger): RMScene2RMIExpJS0(object, repetition, id);
		RMText(text, position, showDot): Pair(id, RMIEmpty());
		RMEmpty(): Pair(id, RMIEmpty());
	}
}


RMPrimitive2RMIExpJS(obj : RMPrimitive, distance : RMIExp, id : int) -> RMIExp {
	getObjectParameter = \paramId -> RMIStructMember(RMIArrayIndex("objectParameters", id), paramId);
	switch(obj) {
		RMSphere(radius): RMICall(RMIOp("-"), [
			RMICall(RMIFn("glm.length"), [distance]),
			getObjectParameter("x")
		]);
		RMPlane(normal): RMICall(RMIFn("glm.dot"), [
			distance,
			RMICall(RMIFn("glm.normalize"), [
				RMICall(RMIFn("glm.vec3"), [getObjectParameter("x"), getObjectParameter("y"), getObjectParameter("z")])
			])
		]);
		RMBox(box): RMICall(RMIFn("sdBox"), [
			distance,
			RMICall(RMIFn("glm.vec3"), [getObjectParameter("x"), getObjectParameter("y"), getObjectParameter("z")])
		]);
		RMRoundBox(box, radius): RMICall(RMIFn("sdRoundBox"), [
			distance,
			RMICall(RMIFn("glm.vec3"), [getObjectParameter("x"), getObjectParameter("y"), getObjectParameter("z")]),
			getObjectParameter("w")
		]);
		RMBoxFrame(box, thickness): RMICall(RMIFn("sdBoxFrame"), [
			distance,
			RMICall(RMIFn("glm.vec3"), [getObjectParameter("x"), getObjectParameter("y"), getObjectParameter("z")]),
			getObjectParameter("w")
		]);
		RMTorus(revolutionRadius, tubeRadius): RMICall(RMIFn("sdTorus"), [
			distance,
			RMICall(RMIFn("glm.vec2"), [getObjectParameter("x"), getObjectParameter("y")])
		]);
		RMCappedTorus(revolutionRadius, tubeRadius, percent): RMICall(RMIFn("sdCappedTorus"), [
			distance,
			RMICall(RMIFn("glm.vec2"), [getObjectParameter("z"), getObjectParameter("w")]),
			getObjectParameter("x"),
			getObjectParameter("y")
		]);
		RMCylinder(height, radius): RMICall(RMIFn("sdCappedCylinder"), [
			distance,
			getObjectParameter("x"),
			getObjectParameter("y")
		]);
		RMRoundedCylinder(height, radius, radiusRounded): RMICall(RMIFn("sdRoundedCylinder"), [
			distance,
			getObjectParameter("y"),
			getObjectParameter("z"),
			getObjectParameter("x")
		]);
	}
}

RMBinaryOperator2RMIExpJS0(obj : RMBinaryOperator, repetition : List<Pair<RMXYZ, RMXYZ>>, id : RMObjectCounter) -> Pair<RMObjectCounter, RMIExp> {
	switch(obj) {
		RMUnion2(object1, object2): {
			exp1 = RMScene2RMIExpJS0(object1, repetition, id);
			exp2 = RMScene2RMIExpJS0(object2, repetition, exp1.first);
			checkRMBinaryOperator(id, exp1, exp2, \ -> Pair(exp2.first, RMICall(RMIFn("opUnion"),
				[
					exp1.second,
					exp2.second,
				]
			)));
		}
		RMUnion(objects): {
			if (length(objects) > 0 ) {
				newExp = fold(tail(objects), objects[0], \acc2, obj2 -> RMUnion2(acc2, obj2));
				RMScene2RMIExpJS0(newExp, repetition, id);
			} else {
				Pair(id, RMIEmpty());
			}
		};
		RMIntersection2(object1, object2): {
			exp1 = RMScene2RMIExpJS0(object1, repetition, id);
			exp2 = RMScene2RMIExpJS0(object2, repetition, exp1.first);
			checkRMBinaryOperator(id, exp1, exp2, \ -> Pair(exp2.first, RMICall(RMIFn("opIntersection"),
				[
					exp1.second,
					exp2.second,
				]
			)));
		};
		RMIntersection(objects): {
			if (length(objects) > 0 ) {
				newExp = fold(tail(objects), objects[0], \acc2, obj2 -> RMIntersection2(acc2, obj2));
				RMScene2RMIExpJS0(newExp, repetition, id);
			} else {
				Pair(id, RMIEmpty());
			}
		};
		RMSubtraction2(object1, object2): {
			exp1 = RMScene2RMIExpJS0(object1, repetition, id);
			exp2 = RMScene2RMIExpJS0(object2, repetition, exp1.first);
			checkRMBinaryOperator(id, exp1, exp2, \ -> Pair(exp2.first, RMICall(RMIFn("opSubtraction"),
				[
					exp1.second,
					exp2.second,
				]
			)));
		};
		RMSubtraction(objects): {
			if (length(objects) > 0 ) {
				newExp = fold(tail(objects), objects[0], \acc2, obj2 -> RMSubtraction2(acc2, obj2));
				RMScene2RMIExpJS0(newExp, repetition, id);
			} else {
				Pair(id, RMIEmpty());
			}
		};
		RMSmoothUnion2(object1, object2, k): {
			exp1 = RMScene2RMIExpJS0(object1, repetition, id);
			exp2 = RMScene2RMIExpJS0(object2, repetition, exp1.first);
			resExp = checkRMBinaryOperator(id, exp1, exp2, \ -> Pair(exp2.first, RMICall(RMIFn("opSmoothUnion"),
				[
					exp1.second,
					exp2.second,
					RMIArrayIndex("smoothCoefficients", id.smoothObjectsCounter)
				]
			)));

			Pair(
				RMObjectCounter(resExp.first with smoothObjectsCounter = id.smoothObjectsCounter + 1),
				resExp.second
			)
		};
		RMSmoothUnion(objects, k): {
			if (length(objects) > 0 ) {
				newExp = fold(tail(objects), objects[0], \acc2, obj2 -> RMSmoothUnion2(acc2, obj2, k));
				RMScene2RMIExpJS0(newExp, repetition, id);
			} else {
				Pair(id, RMIEmpty());
			}
		};
		RMSmoothIntersection2(object1, object2, k): {
			exp1 = RMScene2RMIExpJS0(object1, repetition, id);
			exp2 = RMScene2RMIExpJS0(object2, repetition, exp1.first);
			resExp = checkRMBinaryOperator(id, exp1, exp2, \ -> Pair(exp2.first, RMICall(RMIFn("opSmoothIntersection"),
				[
					exp1.second,
					exp2.second,
					RMIArrayIndex("smoothCoefficients", id.smoothObjectsCounter)
				]
			)));

			Pair(
				RMObjectCounter(resExp.first with smoothObjectsCounter = id.smoothObjectsCounter + 1),
				resExp.second
			)
		};
		RMSmoothIntersection(objects, k): {
			if (length(objects) > 0 ) {
				newExp = fold(tail(objects), objects[0], \acc2, obj2 -> RMSmoothIntersection2(acc2, obj2, k));
				RMScene2RMIExpJS0(newExp, repetition, id);
			} else {
				Pair(id, RMIEmpty());
			}
		};
		RMSmoothSubtraction2(object1, object2, k): {
			exp1 = RMScene2RMIExpJS0(object1, repetition, id);
			exp2 = RMScene2RMIExpJS0(object2, repetition, exp1.first);
			resExp = checkRMBinaryOperator(id, exp1, exp2, \ -> Pair(exp2.first, RMICall(RMIFn("opSmoothSubtraction"),
				[
					exp1.second,
					exp2.second,
					RMIArrayIndex("smoothCoefficients", id.smoothObjectsCounter)
				]
			)));

			Pair(
				RMObjectCounter(resExp.first with smoothObjectsCounter = id.smoothObjectsCounter + 1),
				resExp.second
			)
		};
		RMSmoothSubtraction(objects, k): {
			if (length(objects) > 0 ) {
				newExp = fold(tail(objects), objects[0], \acc2, obj2 -> RMSmoothSubtraction2(acc2, obj2, k));
				RMScene2RMIExpJS0(newExp, repetition, id);
			} else {
				Pair(id, RMIEmpty());
			}
		};
	}
}

expandRMCoordinate(c : RMCoordinate) -> RMXYZ {
	switch(c) {
		RMXYZ(x, y, z): RMXYZ(x, y, z);
		RMXY(x, y): RMXYZ(x, y, 0.);
		RMXZ(x, z): RMXYZ(x, 0., z);
		RMYZ(y, z): RMXYZ(0., y, z);
		RMX(x): RMXYZ(x, 0., 0.);
		RMY(y): RMXYZ(0., y, 0.);
		RMZ(z): RMXYZ(0., 0., z);
	}
}

RMCoordinate2RMIXYZ(c : RMCoordinate) -> RMIXYZ {
	rmxyz = expandRMCoordinate(c);
	RMIXYZ(rmxyz.x, rmxyz.y, rmxyz.z)
}

addRMIXYZ(c1 : RMIXYZ, c2 : RMIXYZ) -> RMIXYZ {
	RMIXYZ(c1.x + c2.x, c1.y + c2.y, c1.z + c2.z)
}

addRMCoordinate(c1 : RMCoordinate, c2 : RMCoordinate) -> RMXYZ {
	c1xyz = expandRMCoordinate(c1);
	c2xyz = expandRMCoordinate(c2);
	RMXYZ(c1xyz.x + c2xyz.x, c1xyz.y + c2xyz.y, c1xyz.z + c2xyz.z)
}

multiplyRMCoordinate(c1 : RMCoordinate, c2 : RMCoordinate) -> RMXYZ {
	c1xyz = expandRMCoordinate(c1);
	c2xyz = expandRMCoordinate(c2);
	RMXYZ(c1xyz.x * c2xyz.x, c1xyz.y * c2xyz.y, c1xyz.z * c2xyz.z)
}

divideRMCoordinate(c1 : RMCoordinate, c2 : RMCoordinate) -> RMXYZ {
	c1xyz = expandRMCoordinate(c1);
	c2xyz = expandRMCoordinate(c2);
	RMXYZ(c1xyz.x / c2xyz.x, c1xyz.y / c2xyz.y, c1xyz.z / c2xyz.z)
}

addColorToRMIExp(exp : RMIExp, id : RMObjectCounter, color : RMIExp, innerLevel : bool) -> Pair<RMObjectCounter, RMIProperty> {
	plainColor = switch (color) {
		RMIXYZ(x, y, z): Some(color);
		default: None();
	}
	isTexture = switch (color) {
		RMICall(fn, args): switch(fn) {
			RMIOp(__): false;
			RMIFn(fnName): fnName == "getTextureColor";
		};
		default: false;
	}
	Pair(
		RMObjectCounter(
			id with
			objectId = id.objectId + 1,
			textureId = id.textureId + b2i(isTexture),
		),
		RMIProperty(
			RMICall(
				RMIFn("ObjectInfo"),
				[
					exp,
					RMIInt(id.objectId),
					RMIInt(if (isTexture) id.textureId else -1),
					RMIBool(true),
					RMICall(
						RMIFn("Material"),
						[
							eitherMap(
								plainColor, \__->
								RMIArrayIndex("color", id.objectId - id.textureId),
								if (!innerLevel) RMIXYZ(0., 0., 0.) else color
							),
							RMIArrayIndex("reflectiveness", id.objectId)
						]
					)
				]
			),
			id.objectId,
			eitherMap(plainColor, \__-> RMIEmpty(), color),
		)
	)
}

hexColor2RMI(color : int) -> RMIXYZ {
	RMIXYZ(i2d(color/0x10000)/255., i2d(color/0x100%0x100)/255., (i2d(color%0x100)/255.))
}

checkRMBinaryOperator(id : RMObjectCounter, exp1 : Pair<RMObjectCounter, RMIExp>, exp2 : Pair<RMObjectCounter, RMIExp>, onOk : () -> Pair<RMObjectCounter, RMIExp>) -> Pair<RMObjectCounter, RMIExp> {
	if (exp1.second == RMIEmpty() && exp2.second == RMIEmpty()) {
		Pair(id, RMIEmpty())
	} else if (exp1.second == RMIEmpty()) {
		exp2
	} else if (exp2.second == RMIEmpty()) {
		exp1
	} else {
		onOk()
	}
};