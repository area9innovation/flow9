import material/extra/raymarching/raymarching_types;
import math/math;
import ds/arrayutils;

export {
	RMScene2RMIExp(obj : RMScene, simpleDistance : bool) -> Pair<RMObjectCounter, RMIExp>;
	RMLights2RMIExp(obj : RMLights) -> RMIExp;
	RMScene2RMIExpJS(obj : RMScene) -> RMIExp;

	hexColor2RMI(color : int) -> RMIXYZ;
	RMCoordinate2RMIXYZ(c : RMCoordinate) -> RMIXYZ;
	addRMCoordinate(c1 : RMCoordinate, c2 : RMCoordinate) -> RMCoordinate;
}

RMObjectCounter(
	objectId : int,
	textureId : int,
	topLevelObjects : Tree<int, RMScene>,
	topLevelSmoothObjects : Tree<int, RMIExp>,
	smoothObjectsCounter : int,
);

RMSceneAccumulators(
	position : Transform<RMCoordinate>,
	rotation : Transform<RMCoordinate>,
	scale : Transform<RMCoordinate>,
	materialColor : RMBaseMaterial,
	materialProperties : [RMMaterialProperties],
	rmiMateiral : RMIExp,
	trigger : Behaviour<RMTrigger>,
	smoothMaterial : bool,
);

RMScene2RMIExp(obj : RMScene, simpleDistance : bool) -> Pair<RMObjectCounter, RMIExp> {
	RMScene2RMIExp0(
		obj,
		RMSceneAccumulators(
			const(RMXYZ(0., 0., 0.)),
			const(RMXYZ(0., 0., 0.)),
			const(RMXYZ(0., 0., 0.)),
			RMColor(make(0)),
			[],
			RMIXYZ(1., 1., 1.),
			make(RMMouseDownleft()),
			false
		),
		RMObjectCounter(0, 0, makeTree(), makeTree(), 0),
		true,
		simpleDistance,
		false
	)
}

RMScene2RMIExp0(
	obj : RMScene,
	acc : RMSceneAccumulators,
	id : RMObjectCounter,
	topLevel : bool,
	simpleDistance : bool,
	innerLevel : bool
) -> Pair<RMObjectCounter, RMIExp> {
	switch(obj) {
		RMCompositeObject(object, name, color, materialProperties, position, rotation, trigger): {
			compositeObject = RMSTranslate(RMRotate(RMMaterial(RMInteractive(object, trigger), color, materialProperties), rotation), position);
			RMScene2RMIExp0(compositeObject, acc, id, topLevel, simpleDistance, innerLevel);
		};
		RMPrimitive(): {
			wrapFn = if (simpleDistance) {
				\e -> Pair(RMObjectCounter(id with objectId = id.objectId + 1), e)
			} else {
				\e -> addColorToRMIExp(e, id, acc.rmiMateiral, innerLevel)
			};
			resultExp = wrapFn(RMPrimitive2RMIExp(
				obj,
				RMIConcat(RMICall(RMIOp("*"), [RMIVar(formatString("(positions[%1]", [i2s(id.objectId)])), RMICall(RMIFn("vec4"), [RMIP(), RMIDouble(1.0)])]), RMIVar(").xyz")),
				id.objectId
			));
			compositeObject = RMCompositeObject(
				obj,
				i2s(id.objectId),
				acc.materialColor,
				acc.materialProperties,
				make(fgetValue(acc.position)),
				make(fgetValue(acc.rotation)),
				acc.trigger
			);

			if (topLevel) Pair(
				RMObjectCounter(
					resultExp.first
					with topLevelObjects = setTree(resultExp.first.topLevelObjects, id.objectId, compositeObject)
				),
				resultExp.second
			) else resultExp
		}
		RMSTranslate(object, d): RMScene2RMIExp0(
			object,
			RMSceneAccumulators(
				acc with
				position = fselect2(acc.position, d, FLift2(addRMCoordinate))
			),
			id,
			topLevel,
			simpleDistance,
			innerLevel
		);
		RMRotate(object, r): RMScene2RMIExp0(
			object,
			RMSceneAccumulators(
				acc with
				rotation = fselect2(acc.rotation, r, FLift2(addRMCoordinate))
			),
			id,
			topLevel,
			simpleDistance,
			innerLevel
		);
		RMBinaryOperator(): RMBinaryOperator2RMIExp0(obj, acc, id, topLevel, simpleDistance, innerLevel);
		RMMaterial(object, color, materialProperties): {
			switch(color) {
				RMTexture(texture, parameters): RMScene2RMIExp0(
					object,
					RMSceneAccumulators(
						acc with
						rmiMateiral = RMICall(
							RMIFn("getTextureColor"),
							[
								RMIP(),
								RMIVar("normal"),
								RMIVar(formatString("textureParameters[%1]", [i2s(id.textureId)])),
								RMIVar(formatString("textures[%1]", [i2s(id.textureId)]))
							]
						),
						materialColor = color,
						materialProperties = materialProperties
					),
					id,
					topLevel,
					simpleDistance,
					innerLevel
				);
				RMColor(col): {
					RMScene2RMIExp0(
						object,
						RMSceneAccumulators(
							acc with
							rmiMateiral = hexColor2RMI(getValue(col)),
							materialColor = color,
							materialProperties = materialProperties
						),
						id,
						topLevel,
						simpleDistance,
						innerLevel
					);
				}
			}
		}
		RMInteractive(object, trigger): RMScene2RMIExp0(
			object,
			RMSceneAccumulators(acc with trigger = trigger),
			id,
			topLevel,
			simpleDistance,
			innerLevel
		);
		RMEmpty(): Pair(id, RMIEmpty());
	}
}

RMPrimitive2RMIExp(obj : RMPrimitive, distance : RMIExp, id : int) -> RMIExp {
	getObjectParameter = \paramId -> RMIVar(formatString("objectParameters[%1].%2", [i2s(id), paramId]));
	switch(obj) {
		RMSphere(radius): RMICall(RMIOp("-"), [
			RMICall(RMIFn("length"), [distance]),
		 	getObjectParameter("x")
		]);
		RMPlane(normal): RMICall(RMIFn("dot"), [
			distance,
			RMICall(RMIFn("normalize"), [
				RMICall(RMIFn("vec3"), [getObjectParameter("x"), getObjectParameter("y"), getObjectParameter("z")])
			])
		]);
		RMBox(box): RMICall(RMIFn("sdBox"), [
			distance,
			RMICall(RMIFn("vec3"), [getObjectParameter("x"), getObjectParameter("y"), getObjectParameter("z")])
		]);
		RMRoundBox(box, radius): RMICall(RMIFn("sdRoundBox"), [
			distance,
			RMICall(RMIFn("vec3"), [getObjectParameter("x"), getObjectParameter("y"), getObjectParameter("z")]),
			getObjectParameter("w")
		]);
		RMBoxFrame(box, thickness): RMICall(RMIFn("sdBoxFrame"), [
			distance,
			RMICall(RMIFn("vec3"), [getObjectParameter("x"), getObjectParameter("y"), getObjectParameter("z")]),
			getObjectParameter("w")
		]);
		RMTorus(revolutionRadius, tubeRadius): RMICall(RMIFn("sdTorus"), [
			distance,
			RMICall(RMIFn("vec2"), [getObjectParameter("x"), getObjectParameter("y")])
		]);
		RMCappedTorus(revolutionRadius, tubeRadius, percent): RMICall(RMIFn("sdCappedTorus"), [
			distance,
			RMICall(RMIFn("vec2"), [getObjectParameter("z"), getObjectParameter("w")]),
			getObjectParameter("x"),
			getObjectParameter("y")
		]);
		RMCylinder(height, radius): RMICall(RMIFn("sdCappedCylinder"), [
			distance,
			getObjectParameter("x"),
			getObjectParameter("y")
		]);
		RMRoundedCylinder(height, radius, radiusRounded): RMICall(RMIFn("sdRoundedCylinder"), [
			distance,
			getObjectParameter("y"),
			getObjectParameter("z"),
			getObjectParameter("x")
		]);
	}
}

RMBinaryOperator2RMIExp0(
	obj : RMBinaryOperator,
	acc : RMSceneAccumulators,
	id : RMObjectCounter,
	topLevel : bool,
	simpleDistance : bool,
	innerLevel : bool
) -> Pair<RMObjectCounter, RMIExp> {
	switch(obj) {
		RMUnion2(object1, object2): {
			exp1 = RMScene2RMIExp0(object1, acc, id, topLevel, simpleDistance, innerLevel);
			exp2 = RMScene2RMIExp0(object2, acc, exp1.first, topLevel, simpleDistance, innerLevel);
			checkRMBinaryOperator(id, exp1, exp2, \ -> Pair(exp2.first, RMICall(RMIFn(if (simpleDistance) "min" else "opUnion"),
				[
					exp1.second,
					exp2.second,
				]
			)))
		};
		RMUnion(objects): {
			if (length(objects) > 0 ) {
				newExp = fold(tail(objects), objects[0], \acc2, obj2 -> RMUnion2(acc2, obj2));
				RMScene2RMIExp0(newExp, acc, id, topLevel, simpleDistance, innerLevel);
			} else {
				Pair(id, RMIEmpty());
			}
		};
		RMIntersection2(object1, object2): {
			exp1 = RMScene2RMIExp0(object1, acc, id, topLevel, simpleDistance, innerLevel);
			exp2 = RMScene2RMIExp0(object2, acc, exp1.first, topLevel, simpleDistance, innerLevel);
			checkRMBinaryOperator(id, exp1, exp2, \ -> Pair(exp2.first, RMICall(RMIFn(if (simpleDistance) "max" else "opIntersection"),
				[
					exp1.second,
					exp2.second,
				]
			)))
		};
		RMIntersection(objects): {
			if (length(objects) > 0 ) {
				newExp = fold(tail(objects), objects[0], \acc2, obj2 -> RMIntersection2(acc2, obj2));
				RMScene2RMIExp0(newExp, acc, id, topLevel, simpleDistance, innerLevel);
			} else {
				Pair(id, RMIEmpty());
			}
		};
		RMSubtraction2(object1, object2): {
			exp1 = RMScene2RMIExp0(object1, acc, id, topLevel, simpleDistance, innerLevel);
			exp2 = RMScene2RMIExp0(object2, acc, exp1.first, topLevel, simpleDistance, innerLevel);
			checkRMBinaryOperator(id, exp1, exp2, \ -> Pair(exp2.first, RMICall(RMIFn(if (simpleDistance) "max" else "opSubtraction"),
				[
					exp1.second,
					if (simpleDistance) RMICall(RMIOp("*"), [RMIDouble(-1.), exp2.second]) else exp2.second,
				]
			)))
		};
		RMSubtraction(objects): {
			if (length(objects) > 0 ) {
				newExp = fold(tail(objects), objects[0], \acc2, obj2 -> RMSubtraction2(acc2, obj2));
				RMScene2RMIExp0(newExp, acc, id, topLevel, simpleDistance, innerLevel);
			} else {
				Pair(id, RMIEmpty());
			}
		};
		RMSmoothUnion2(object1, object2, k): {
			makeSmoothExp = \cond -> {
				newAcc = RMSceneAccumulators(acc with smoothMaterial = cond);
				exp1 = RMScene2RMIExp0(object1, newAcc, id, false, simpleDistance, cond);
				exp2 = RMScene2RMIExp0(object2, newAcc, exp1.first, false, simpleDistance, cond);
				checkRMBinaryOperator(id, exp1, exp2, \ -> Pair(exp2.first, RMICall(
					RMIFn(if (simpleDistance) "opSmoothUnion" else if(newAcc.smoothMaterial) "opSmoothUnionMaterial" else "opSmoothUnionTopLevel"),
					concat(
						[exp1.second, exp2.second, RMIVar(formatString("smoothCoefficients[%1]", [i2s(id.smoothObjectsCounter)]))],
						if (!simpleDistance && newAcc.smoothMaterial) [RMIP(), RMIVar("normal")] else []
					)
				)))
			}
			resultExp = makeSmoothExp(acc.smoothMaterial);
			resultExpI = makeSmoothExp(true);
			if (topLevel) Pair(
				RMObjectCounter(
					resultExp.first with
					topLevelSmoothObjects = setTree(resultExp.first.topLevelSmoothObjects, id.objectId, resultExpI.second),
					topLevelObjects = setTree(resultExp.first.topLevelObjects, id.objectId, RMInteractive(obj, acc.trigger)),
					smoothObjectsCounter = resultExp.first.smoothObjectsCounter + 1,
				),
				resultExp.second
			) else resultExp
		};
		RMSmoothUnion(objects, k): {
			if (length(objects) > 0 ) {
				newExp = fold(tail(objects), objects[0], \acc2, obj2 -> RMSmoothUnion2(acc2, obj2, k));
				RMScene2RMIExp0(newExp, acc, id, topLevel, simpleDistance, innerLevel);
			} else {
				Pair(id, RMIEmpty());
			}
		};
		RMSmoothIntersection2(object1, object2, k): {
			makeSmoothExp = \cond -> {
				newAcc = RMSceneAccumulators(acc with smoothMaterial = cond);
				exp1 = RMScene2RMIExp0(object1, newAcc, id, false, simpleDistance, cond);
				exp2 = RMScene2RMIExp0(object2, newAcc, exp1.first, false, simpleDistance, cond);
				checkRMBinaryOperator(id, exp1, exp2, \ -> Pair(exp2.first, RMICall(
					RMIFn(if (simpleDistance) "opSmoothIntersection" else if(newAcc.smoothMaterial) "opSmoothIntersectionMaterial" else "opSmoothIntersectionTopLevel"),
					concat(
						[exp1.second, exp2.second, RMIVar(formatString("smoothCoefficients[%1]", [i2s(id.smoothObjectsCounter)]))],
						if (!simpleDistance && newAcc.smoothMaterial) [RMIP(), RMIVar("normal")] else []
					)
				)))
			}
			resultExp = makeSmoothExp(acc.smoothMaterial);
			resultExpI = makeSmoothExp(true);
			if (topLevel) Pair(
				RMObjectCounter(
					resultExp.first with
					topLevelSmoothObjects = setTree(resultExp.first.topLevelSmoothObjects, id.objectId, resultExpI.second),
					topLevelObjects = setTree(resultExp.first.topLevelObjects, id.objectId, RMInteractive(obj, acc.trigger)),
					smoothObjectsCounter = resultExp.first.smoothObjectsCounter + 1,
				),
				resultExp.second
			) else resultExp
		};
		RMSmoothIntersection(objects, k): {
			if (length(objects) > 0 ) {
				newExp = fold(tail(objects), objects[0], \acc2, obj2 -> RMSmoothIntersection2(acc2, obj2, k));
				RMScene2RMIExp0(newExp, acc, id, topLevel, simpleDistance, innerLevel);
			} else {
				Pair(id, RMIEmpty());
			}
		};
		RMSmoothSubtraction2(object1, object2, k): {
			makeSmoothExp = \cond -> {
				newAcc = RMSceneAccumulators(acc with smoothMaterial = cond);
				exp1 = RMScene2RMIExp0(object1, newAcc, id, false, simpleDistance, cond);
				exp2 = RMScene2RMIExp0(object2, newAcc, exp1.first, false, simpleDistance, cond);
				checkRMBinaryOperator(id, exp1, exp2, \ -> Pair(exp2.first, RMICall(
					RMIFn(if (simpleDistance) "opSmoothSubtraction" else if(newAcc.smoothMaterial) "opSmoothSubtractionMaterial" else "opSmoothSubtractionTopLevel"),
					concat(
						[exp1.second, exp2.second, RMIVar(formatString("smoothCoefficients[%1]", [i2s(id.smoothObjectsCounter)]))],
						if (!simpleDistance && newAcc.smoothMaterial) [RMIP(), RMIVar("normal")] else []
					)
				)))
			}
			resultExp = makeSmoothExp(acc.smoothMaterial);
			resultExpI = makeSmoothExp(true);
			if (topLevel) Pair(
				RMObjectCounter(
					resultExp.first with
					topLevelSmoothObjects = setTree(resultExp.first.topLevelSmoothObjects, id.objectId, resultExpI.second),
					topLevelObjects = setTree(resultExp.first.topLevelObjects, id.objectId, RMInteractive(obj, acc.trigger)),
					smoothObjectsCounter = resultExp.first.smoothObjectsCounter + 1,
				),
				resultExp.second
			) else resultExp
		};
		RMSmoothSubtraction(objects, k): {
			if (length(objects) > 0 ) {
				newExp = fold(tail(objects), objects[0], \acc2, obj2 -> RMSmoothSubtraction2(acc2, obj2, k));
				RMScene2RMIExp0(newExp, acc, id, topLevel, simpleDistance, innerLevel);
			} else {
				Pair(id, RMIEmpty());
			}
		};
	}
}

RMLights2RMIExp(obj : RMLights) -> RMIExp {
	RMLights2RMIExp0(obj, RMIXYZ(0., 0., 0.), RMIXYZ(1., 1., 1.))
}

RMLights2RMIExp0(obj : RMLights, acc : RMIXYZ, color : RMIExp) -> RMIExp {
	switch(obj) {
		RMCompositeLight(size, name, col, position): {
			compositeObject = RMLTranslate(RMLightMaterial(RMLight(size), col), position);
			RMLights2RMIExp0(compositeObject, acc, color);
		};
		RMLTranslate(object, d): RMLights2RMIExp0(object, addRMIXYZ(acc, RMCoordinate2RMIXYZ(d)), color);
		RMLightMaterial(object, col): {
			RMLights2RMIExp0(
				object,
				acc,
				hexColor2RMI(col),
			);
		}
		RMLight(size): RMICall(RMIOp("*"),
			[
				RMICall(RMIFn("getLight"), [
					RMIP(),
					RMIVar("rayDirection"),
					acc,
					color,
					RMIVar("normal"),
					RMIDouble(size)
				]),
				color
			]
		);
		RMPlus(object1, object2): {
			exp1 = RMLights2RMIExp0(object1, acc, color);
			exp2 = RMLights2RMIExp0(object2, acc, color);
			RMICall(RMIOp("+"),
				[
					exp1,
					exp2,
				]
			)
		};
		RMEmpty(): RMIEmpty();
	}
}

RMScene2RMIExpJS(obj : RMScene) -> RMIExp {
	RMScene2RMIExpJS0(obj, RMObjectCounter(0, 0, makeTree(), makeTree(), 0)).second
}

RMScene2RMIExpJS0(obj : RMScene, id : RMObjectCounter) -> Pair<RMObjectCounter, RMIExp> {
	switch(obj) {
		RMCompositeObject(object, name, color, materialProperties, position, rotation, trigger): {
			compositeObject = RMSTranslate(RMRotate(RMMaterial(object, color, materialProperties), rotation), position);
			RMScene2RMIExpJS0(compositeObject, id);
		};
		RMPrimitive(): {
			Pair(
				RMObjectCounter(id with objectId = id.objectId + 1),
				RMIJSObject(
					setTree(makeTree1(
						"distance",
						RMPrimitive2RMIExpJS(
							obj,
							RMIConcat(RMIConcat(RMIVar(formatString("(positions[%1]", [i2s(id.objectId)])), RMICall(RMIFn("['*']"), [RMICall(RMIFn("glm.vec4"), [RMIP(), RMIDouble(1.0)])])), RMIVar(").xyz")),
							id.objectId
						)
					),
					"id", RMIInt(id.objectId))
				)
			);
		}
		RMSTranslate(object, d): RMScene2RMIExpJS0(object, id);
		RMRotate(object, r): RMScene2RMIExpJS0(object, id);
		RMBinaryOperator(): RMBinaryOperator2RMIExpJS0(obj, id);
		RMMaterial(object, color, materialProperties): RMScene2RMIExpJS0(object, id);
		RMInteractive(object, trigger): RMScene2RMIExpJS0(object, id);
		RMEmpty(): Pair(id, RMIEmpty());
	}
}


RMPrimitive2RMIExpJS(obj : RMPrimitive, distance : RMIExp, id : int) -> RMIExp {
	getObjectParameter = \paramId -> RMIVar(formatString("objectParameters[%1].%2", [i2s(id), paramId]));
	switch(obj) {
		RMSphere(radius): RMICall(RMIOp("-"), [
			RMICall(RMIFn("glm.length"), [distance]),
			getObjectParameter("x")
		]);
		RMPlane(normal): RMICall(RMIFn("glm.dot"), [
			distance,
			RMICall(RMIFn("glm.normalize"), [
				RMICall(RMIFn("glm.vec3"), [getObjectParameter("x"), getObjectParameter("y"), getObjectParameter("z")])
			])
		]);
		RMBox(box): RMICall(RMIFn("sdBox"), [
			distance,
			RMICall(RMIFn("glm.vec3"), [getObjectParameter("x"), getObjectParameter("y"), getObjectParameter("z")])
		]);
		RMRoundBox(box, radius): RMICall(RMIFn("sdRoundBox"), [
			distance,
			RMICall(RMIFn("glm.vec3"), [getObjectParameter("x"), getObjectParameter("y"), getObjectParameter("z")]),
			getObjectParameter("w")
		]);
		RMBoxFrame(box, thickness): RMICall(RMIFn("sdBoxFrame"), [
			distance,
			RMICall(RMIFn("glm.vec3"), [getObjectParameter("x"), getObjectParameter("y"), getObjectParameter("z")]),
			getObjectParameter("w")
		]);
		RMTorus(revolutionRadius, tubeRadius): RMICall(RMIFn("sdTorus"), [
			distance,
			RMICall(RMIFn("glm.vec2"), [getObjectParameter("x"), getObjectParameter("y")])
		]);
		RMCappedTorus(revolutionRadius, tubeRadius, percent): RMICall(RMIFn("sdCappedTorus"), [
			distance,
			RMICall(RMIFn("glm.vec2"), [getObjectParameter("z"), getObjectParameter("w")]),
			getObjectParameter("x"),
			getObjectParameter("y")
		]);
		RMCylinder(height, radius): RMICall(RMIFn("sdCappedCylinder"), [
			distance,
			getObjectParameter("x"),
			getObjectParameter("y")
		]);
		RMRoundedCylinder(height, radius, radiusRounded): RMICall(RMIFn("sdRoundedCylinder"), [
			distance,
			getObjectParameter("y"),
			getObjectParameter("z"),
			getObjectParameter("x")
		]);
	}
}

RMBinaryOperator2RMIExpJS0(obj : RMBinaryOperator, id : RMObjectCounter) -> Pair<RMObjectCounter, RMIExp> {
	switch(obj) {
		RMUnion2(object1, object2): {
			exp1 = RMScene2RMIExpJS0(object1, id);
			exp2 = RMScene2RMIExpJS0(object2, exp1.first);
			checkRMBinaryOperator(id, exp1, exp2, \ -> Pair(exp2.first, RMICall(RMIFn("opUnion"),
				[
					exp1.second,
					exp2.second,
				]
			)));
		}
		RMUnion(objects): {
			if (length(objects) > 0 ) {
				newExp = fold(tail(objects), objects[0], \acc2, obj2 -> RMUnion2(acc2, obj2));
				RMScene2RMIExpJS0(newExp, id);
			} else {
				Pair(id, RMIEmpty());
			}
		};
		RMIntersection2(object1, object2): {
			exp1 = RMScene2RMIExpJS0(object1, id);
			exp2 = RMScene2RMIExpJS0(object2, exp1.first);
			checkRMBinaryOperator(id, exp1, exp2, \ -> Pair(exp2.first, RMICall(RMIFn("opIntersection"),
				[
					exp1.second,
					exp2.second,
				]
			)));
		};
		RMIntersection(objects): {
			if (length(objects) > 0 ) {
				newExp = fold(tail(objects), objects[0], \acc2, obj2 -> RMIntersection2(acc2, obj2));
				RMScene2RMIExpJS0(newExp, id);
			} else {
				Pair(id, RMIEmpty());
			}
		};
		RMSubtraction2(object1, object2): {
			exp1 = RMScene2RMIExpJS0(object1, id);
			exp2 = RMScene2RMIExpJS0(object2, exp1.first);
			checkRMBinaryOperator(id, exp1, exp2, \ -> Pair(exp2.first, RMICall(RMIFn("opSubtraction"),
				[
					exp1.second,
					exp2.second,
				]
			)));
		};
		RMSubtraction(objects): {
			if (length(objects) > 0 ) {
				newExp = fold(tail(objects), objects[0], \acc2, obj2 -> RMSubtraction2(acc2, obj2));
				RMScene2RMIExpJS0(newExp, id);
			} else {
				Pair(id, RMIEmpty());
			}
		};
		RMSmoothUnion2(object1, object2, k): {
			exp1 = RMScene2RMIExpJS0(object1, id);
			exp2 = RMScene2RMIExpJS0(object2, exp1.first);
			resExp = checkRMBinaryOperator(id, exp1, exp2, \ -> Pair(exp2.first, RMICall(RMIFn("opSmoothUnion"),
				[
					exp1.second,
					exp2.second,
					RMIVar(formatString("smoothCoefficients[%1]", [i2s(id.smoothObjectsCounter)]))
				]
			)));

			Pair(
				RMObjectCounter(resExp.first with smoothObjectsCounter = id.smoothObjectsCounter + 1),
				resExp.second
			)
		};
		RMSmoothUnion(objects, k): {
			if (length(objects) > 0 ) {
				newExp = fold(tail(objects), objects[0], \acc2, obj2 -> RMSmoothUnion2(acc2, obj2, k));
				RMScene2RMIExpJS0(newExp, id);
			} else {
				Pair(id, RMIEmpty());
			}
		};
		RMSmoothIntersection2(object1, object2, k): {
			exp1 = RMScene2RMIExpJS0(object1, id);
			exp2 = RMScene2RMIExpJS0(object2, exp1.first);
			resExp = checkRMBinaryOperator(id, exp1, exp2, \ -> Pair(exp2.first, RMICall(RMIFn("opSmoothIntersection"),
				[
					exp1.second,
					exp2.second,
					RMIVar(formatString("smoothCoefficients[%1]", [i2s(id.smoothObjectsCounter)]))
				]
			)));

			Pair(
				RMObjectCounter(resExp.first with smoothObjectsCounter = id.smoothObjectsCounter + 1),
				resExp.second
			)
		};
		RMSmoothIntersection(objects, k): {
			if (length(objects) > 0 ) {
				newExp = fold(tail(objects), objects[0], \acc2, obj2 -> RMSmoothIntersection2(acc2, obj2, k));
				RMScene2RMIExpJS0(newExp, id);
			} else {
				Pair(id, RMIEmpty());
			}
		};
		RMSmoothSubtraction2(object1, object2, k): {
			exp1 = RMScene2RMIExpJS0(object1, id);
			exp2 = RMScene2RMIExpJS0(object2, exp1.first);
			resExp = checkRMBinaryOperator(id, exp1, exp2, \ -> Pair(exp2.first, RMICall(RMIFn("opSmoothSubtraction"),
				[
					exp1.second,
					exp2.second,
					RMIVar(formatString("smoothCoefficients[%1]", [i2s(id.smoothObjectsCounter)]))
				]
			)));

			Pair(
				RMObjectCounter(resExp.first with smoothObjectsCounter = id.smoothObjectsCounter + 1),
				resExp.second
			)
		};
		RMSmoothSubtraction(objects, k): {
			if (length(objects) > 0 ) {
				newExp = fold(tail(objects), objects[0], \acc2, obj2 -> RMSmoothSubtraction2(acc2, obj2, k));
				RMScene2RMIExpJS0(newExp, id);
			} else {
				Pair(id, RMIEmpty());
			}
		};
	}
}

RMCoordinate2RMIXYZ(c : RMCoordinate) -> RMIXYZ {
	switch(c) {
		RMXYZ(x, y, z): RMIXYZ(x, y, z);
		RMXY(x, y): RMIXYZ(x, y, 0.);
		RMXZ(x, z): RMIXYZ(x, 0., z);
		RMYZ(y, z): RMIXYZ(0., y, z);
		RMX(x): RMIXYZ(x, 0., 0.);
		RMY(y): RMIXYZ(0., y, 0.);
		RMZ(z): RMIXYZ(0., 0., z);
	}
}

addRMIXYZ(c1 : RMIXYZ, c2 : RMIXYZ) -> RMIXYZ {
	RMIXYZ(c1.x + c2.x, c1.y + c2.y, c1.z + c2.z)
}

addRMCoordinate(c1 : RMCoordinate, c2 : RMCoordinate) -> RMCoordinate {
	convertCoordinate = \c -> switch(c) {
		RMXYZ(x, y, z): RMXYZ(x, y, z);
		RMXY(x, y): RMXYZ(x, y, 0.);
		RMXZ(x, z): RMXYZ(x, 0., z);
		RMYZ(y, z): RMXYZ(0., y, z);
		RMX(x): RMXYZ(x, 0., 0.);
		RMY(y): RMXYZ(0., y, 0.);
		RMZ(z): RMXYZ(0., 0., z);
	}
	c1xyz = convertCoordinate(c1);
	c2xyz = convertCoordinate(c2);
	RMXYZ(c1xyz.x + c2xyz.x, c1xyz.y + c2xyz.y, c1xyz.z + c2xyz.z)
}

addColorToRMIExp(exp : RMIExp, id : RMObjectCounter, color : RMIExp, innerLevel : bool) -> Pair<RMObjectCounter, RMIProperty> {
	plainColor = switch (color) {
		RMIXYZ(x, y, z): Some(color);
		default: None();
	}
	isTexture = switch (color) {
		RMICall(fn, args): switch(fn) {
			RMIOp(__): false;
			RMIFn(fnName): fnName == "getTextureColor";
		};
		default: false;
	}
	Pair(
		RMObjectCounter(
			id with
			objectId = id.objectId + 1,
			textureId = id.textureId + b2i(isTexture),
		),
		RMIProperty(
			RMICall(
				RMIFn("ObjectInfo"),
				[
					exp,
					RMIInt(id.objectId),
					RMIInt(if (isTexture) id.textureId else -1),
					RMIBool(true),
					RMICall(
						RMIFn("Material"),
						[
							eitherMap(
								plainColor, \__->
								RMIVar(formatString("color[%1]", [i2s(id.objectId - id.textureId)])),
								if (!innerLevel) RMIXYZ(0., 0., 0.) else color
							),
							RMIVar(formatString("reflectiveness[%1]", [i2s(id.objectId)]))
						]
					)
				]
			),
			id.objectId,
			eitherMap(plainColor, \__-> RMIEmpty(), color),
		)
	)
}

hexColor2RMI(color : int) -> RMIXYZ {
	RMIXYZ(i2d(color/0x10000)/255., i2d(color/0x100%0x100)/255., (i2d(color%0x100)/255.))
}

checkRMBinaryOperator(id : RMObjectCounter, exp1 : Pair<RMObjectCounter, RMIExp>, exp2 : Pair<RMObjectCounter, RMIExp>, onOk : () -> Pair<RMObjectCounter, RMIExp>) -> Pair<RMObjectCounter, RMIExp> {
	if (exp1.second == RMIEmpty() && exp2.second == RMIEmpty()) {
		Pair(id, RMIEmpty())
	} else if (exp1.second == RMIEmpty()) {
		exp2
	} else if (exp2.second == RMIEmpty()) {
		exp1
	} else {
		onOk()
	}
};