import fusion;

export {
	RMScene ::= RMCompositeObject, RMPrimitive, RMSTranslate, RMUnion2, RMUnion, RMSmoothUnion, RMMaterial, RMEmpty;
	RMLights ::= RMCompositeLight, RMLTranslate, RMLightMaterial, RMLight, RMPlus, RMEmpty;
	RMObject ::= RMScene, RMLights;
		RMPrimitive ::= RMSphere, RMPlane, RMBox, RMRoundBox, RMBoxFrame, RMTorus, RMCappedTorus, RMCylinder, RMRoundedCylinder;
			RMSphere(radius : double);
			RMPlane(normal : RMXYZ);
			RMBox(box : RMXYZ);
			RMRoundBox(box : RMXYZ, radius : double);
			RMBoxFrame(box : RMXYZ, thickness : double);
			RMTorus(revolutionRadius : double, tubeRadius : double);
			RMCappedTorus(revolutionRadius : double, tubeRadius : double, percent : double);
			RMCylinder(height : double, radius : double);
			RMRoundedCylinder(height : double, radius : double, radiusRounded : double);
		RMCompositeObject(object : RMPrimitive, name : string, color : RMBaseMaterial, materialProperties : [RMMaterialProperties], position : RMCoordinate);
		RMCompositeLight(size : double, name : string, color : RMColor, position : RMCoordinate);
		RMSTranslate(object : RMScene, d : RMCoordinate);
		RMLTranslate(object : RMLights, d : RMCoordinate);
		RMUnion2(object1 : RMScene, object2 : RMScene);
		RMUnion(objects : [RMScene]);
		RMSmoothUnion(objects : [RMScene], k : double);
		RMMaterial(object : RMScene, color : RMBaseMaterial, materialProperties : [RMMaterialProperties]);
		RMLightMaterial(object : RMLights, color : RMColor);
		RMBaseMaterial ::= RMColor, RMTexture;
		RMMaterialProperties ::= RMReflect;
			RMTexture(
				texture : RMInteractive<string>, //URL or base64
				parameters : RMInteractive<RMTextureParameters>
			);
				RMTextureParameters (
					scale : RMTextureTilingParameter,
					translate : RMTextureTilingParameter,
					rotate : RMTextureTilingParameter,
					step : RMTextureTilingParameter
				);
				RMTextureTilingParameter(
					zx_z : double,
					zx_x : double,
					xy_x : double,
					xy_y : double,
					zy_z : double,
					zy_y : double
				);
			RMColor(color : RMInteractive<int>);
			RMReflect(mixCoef : RMInteractive<double>);
		RMLight(size : double);
		RMPlus(object1 : RMLights, object2 : RMLights);
		RMEmpty();

		RMInteractive(trigger : DynamicBehaviour<RMTrigger>, behaviour : DynamicBehaviour<?>);
		RMTrigger ::= RMMouseHover, RMMouseHoverIn, RMMouseHoverOut, RMMouseDownleft;
			RMMouseHover();
			RMMouseHoverIn();
			RMMouseHoverOut();
			RMMouseDownleft();

	RMCamera(position : RMXYZ, lookAt : RMXYZ);

	RMCoordinate ::= RMXYZ, RMX, RMY, RMZ, RMXY, RMXZ, RMYZ;
		RMXYZ(x : double, y : double, z : double);
		RMXY(x : double, y : double);
		RMXZ(x : double, z : double);
		RMYZ(y : double, z : double);
		RMX(x : double);
		RMY(y : double);
		RMZ(z : double);

	RMIExp ::= RMICall, RMIP, RMIDouble, RMIInt, RMIBool, RMIXYZ, RMIVar, RMIConcat, RMIProperty, RMIJSObject, RMIEmpty;
		RMICall(fn : RMC, args : [RMIExp]);
		// A function, either an operator or function call
		RMC ::= RMIOp, RMIFn;
			// Operators are unary (prefix notation), binary operators, or the ? operator for ternary in GLSL syntax
			RMIOp(opName : string);
			// Function call syntax for these functions
			RMIFn(fnName : string);
		// The point to which we have to measure the distance
		RMIP();
		RMIDouble(num : double);
		RMIInt(num : int);
		RMIBool(num : bool);
		RMIXYZ(x : double, y : double, z : double);
		RMIVar(name : string);
		RMIConcat(exp1 : RMIExp, exp2 : RMIExp);
		RMIProperty(exp : RMIExp, id : int, property : RMIExp);
		RMIJSObject(properties : Tree<string, RMIExp>);
		RMIEmpty();

	makeDefaultRMTexture() -> RMTexture;
	makeRMInteractive(behaviour : DynamicBehaviour<?>) -> RMInteractive<?>;
	initRMInteractive(value : ?) -> RMInteractive<?>;
}

makeDefaultRMTexture() -> RMTexture {
	RMTexture(
		RMInteractive(make(RMMouseDownleft()), make("")),
		RMInteractive(make(RMMouseDownleft()), make(RMTextureParameters(
			RMTextureTilingParameter(1., 1., 1., 1., 1., 1.),
			RMTextureTilingParameter(0., 0., 0., 0., 0., 0.),
			RMTextureTilingParameter(0., 0., 0., 0., 0., 0.),
			RMTextureTilingParameter(1., 1., 1., 1., 1., 1.)
		)))
	)
}

makeRMInteractive(behaviour : DynamicBehaviour<?>) -> RMInteractive<?> {
	RMInteractive(make(RMMouseDownleft()), behaviour)
}

initRMInteractive(value : ?) -> RMInteractive<?> {
	RMInteractive(make(RMMouseDownleft()), make(value))
}