import material/material_ui;
import material/extra/raymarching/raymarching_rm2rmi;
import material/extra/raymarching/raymarching_rmi2code;

export {
	MRaymarching(id : int, scene : RMScene, light : RMLights, camera : RMCamera) -> Material;
	MDynamicRaymarching(id : int, sceneB : Transform<RMScene>, lightB : Transform<RMLights>, cameraB : Transform<RMCamera>) -> Material;

	makeRaymarchingMaterialTexture(material : Material, texture : DynamicBehaviour<string>) -> Material;
}

MRaymarching(id : int, scene : RMScene, light : RMLights, camera : RMCamera) -> Material {
	MDynamicRaymarching(id, const(scene), const(light), const(camera))
}

MDynamicRaymarching(id : int, sceneB : Transform<RMScene>, lightB : Transform<RMLights>, cameraB : Transform<RMCamera>) -> Material {
	rmiScene = RMScene2RMIExp(fgetValue(sceneB), false);
	glsl = RMIExp2GLSL(rmiScene.first);
	glslSimple = RMIExp2GLSL(RMScene2RMIExp(fgetValue(sceneB), true).first);
	topLevelDistanceFunctions = rmiTree2GLSL(rmiScene.second);
	baseMaterial = RMIExp2GLSLMaterial(rmiScene.first);
	jsScene = RMIExp2JS(RMScene2RMIExpJS(fgetValue(sceneB)));
	lightGlsl = RMIExp2GLSL(RMLights2RMIExp(fgetValue(lightB)));

	cameraPositionStr = formatString("%1, %2, %3", [
		d2s(fgetValue(cameraB).position.x),
		d2s(fgetValue(cameraB).position.y),
		d2s(fgetValue(cameraB).position.z)
	]);
	cameraLookAtStr = formatString("%1, %2, %3", [
		d2s(fgetValue(cameraB).lookAt.x),
		d2s(fgetValue(cameraB).lookAt.y),
		d2s(fgetValue(cameraB).lookAt.z)
	]);

	materialsB = make(extractMaterialsFromRMScene(fgetValue(sceneB)));

	countMaterials = \materials -> {
		count = fold2(materials, 0, 0, \acc1, acc2, m -> switch(m.color) {
			RMTexture(texture, parameters): Pair(acc1 + 1, acc2);
			RMColor(col): Pair(acc1, acc2 + 1);
		});
		Pair(if (count.first < 1) 1 else count.first, if (count.second < 1) 1 else count.second)
	};
	countedMaterials = countMaterials(getValue(materialsB));

	webglContextLoadedB = make(false);

	MConstruct(
		[
			make2Subscribe2(
				fthrottle(sceneB, 500), fthrottle(lightB, 500),
				\s, l -> {
					newRMIScene = RMScene2RMIExp(s, false);
					newTopLevelDistanceFunctions = rmiTree2GLSL(newRMIScene.second);
					materials = extractMaterialsFromRMScene(s);
					next(materialsB, materials);
					countedMaterialsChanged = countMaterials(materials);
					hostCall("recompileShader", [
						i2s(id),
						blueprint(
							"#include material/extra/raymarching/raymarching.frag",
							[
								"distanceFunction", RMIExp2GLSL(newRMIScene.first),
								"simpleDistance", RMIExp2GLSL(RMScene2RMIExp(s, true).first),
								"light", RMIExp2GLSL(RMLights2RMIExp(l)),
								"baseMaterial", RMIExp2GLSLMaterial(newRMIScene.first),
								"numTextures", i2s(countedMaterialsChanged.first),
								"numColors", i2s(countedMaterialsChanged.second),
								"topLevelDistanceFunction", newTopLevelDistanceFunctions,
							]
						)
					]);
					hostCall(
						"setDistanceFunction",
						[
							i2s(id),
							formatString("(p) => {return %1;}", [RMIExp2JS(RMScene2RMIExpJS(s))])
						]
					) |> ignore;
				}
			),
			makeSubscribe2(
				fthrottle(cameraB, 500),
				\c -> {
					hostCall("setCameraPosition", [
						i2d(id),
						c.position.x,
						c.position.y,
						c.position.z
					]) |> ignore;
					hostCall("setCameraLookAt", [
						i2d(id),
						c.lookAt.x,
						c.lookAt.y,
						c.lookAt.z
					]) |> ignore;
				}
			),
			makeSubscribeTrigger(
				webglContextLoadedB,
				fsubselect(materialsB, FLift(\materials -> fmerge(filtermap(materials, \material -> switch(material.color) {
					RMTexture(texture, parameters): Some(texture.behaviour);
					RMColor(col): None();
				})))),
				\textures -> {
					hostCall("resetTextures", [i2s(id)]) |> ignore;
					mapi(
						textures,
						\i, texture -> {
							hostCall("loadNewTexture", [i2s(id), texture])
						}
					)|> ignore;
				}
			),
			makeSubscribeTrigger(
				webglContextLoadedB,
				fsubselect(materialsB, FLift(\materials -> fmerge(filtermap(materials, \material -> switch(material.color) {
					RMTexture(texture, parameters): Some(parameters.behaviour);
					RMColor(col): None();
				})))),
				\parameters -> {
					textureParameters = mapConcat(
						parameters,
						\parameter -> concatA([
							RMTextureTilingParameter2FloatArray(parameter.scale), [0., 0.], //allignment bits
							RMTextureTilingParameter2FloatArray(parameter.translate), [0., 0.],
							RMTextureTilingParameter2FloatArray(parameter.rotate), [0., 0.],
							RMTextureTilingParameter2FloatArray(parameter.step), [0., 0.],
						])
					);
					hostCall("loadNewTextureParameters", [flow(i2s(id)), flow(textureParameters)])|> ignore;
				}
			),
			makeSubscribeTrigger(
				webglContextLoadedB,
				fsubselect(materialsB, FLift(\materials -> fmerge(filtermap(materials, \material -> switch(material.color) {
					RMTexture(texture, parameters): None();
					RMColor(color): Some(color.behaviour);
				})))),
				\col -> {
					parameters = mapConcat(
						col,
						\c -> {
							h = hexColor2RMI(c);
							[h.x, h.y, h.z, 0.] //allignment bits
						}
					);
					hostCall("updateMaterialsColorParameters", [flow(i2s(id)), flow(parameters)])|> ignore;
				}
			),
			makeSubscribeTrigger(
				webglContextLoadedB,
				fsubselect(materialsB, FLift(\materials -> fmerge(map(materials, \material -> extractStruct(
					material.materialProperties,
					RMReflect(initRMInteractive(0.0))
				).mixCoef.behaviour)))),
				\reflectivness -> {
					parameters = mapConcat(
						reflectivness,
						\r -> {
							[r, 0., 0., 0.] //allignment bits
						}
					);
					hostCall("updateMaterialsReflectivnessParameters", [flow(i2s(id)), flow(parameters)])|> ignore;
				}
			),
			\ -> addMessageEventListener(\message, origin -> {
				parsedMessage = parseJson(message);
				if (getJsonIntField(parsedMessage, "webglContextLoaded", -1) == id)
					next(webglContextLoadedB, true);

				triggers = [
					Pair(RMMouseHover(), getJsonIntField(parsedMessage, "mouseHoverObjectId", -1)),
					Pair(RMMouseHoverIn(), getJsonIntField(parsedMessage, "mouseHoverInObjectId", -1)),
					Pair(RMMouseHoverOut(), getJsonIntField(parsedMessage, "mouseHoverOutObjectId", -1)),
					Pair(RMMouseDownleft(), getJsonIntField(parsedMessage, "mouseDownLeftObjectId", -1)),
				];
				filteredTriggers = filter(triggers, \t -> t.second != -1);
				if (filteredTriggers != []) {
					topLevelObjects = RMScene2RMIExp(fgetValue(sceneB), false).third;
					iter(
						filteredTriggers,
						\t -> {
							maybeApply(
								lookupTree(topLevelObjects, t.second),
								\obj -> {
									iter(
										extractTriggersFromRMScene(obj),
										\i -> {
											next(i, t.first);
										}
									)
								}
							)
						}
					)
				}
			}),
		],
		displayRaymarchingCanvas(
			id,
			webglContextLoadedB,
			blueprint("#include material/extra/raymarching/raymarching.js", [
				"cameraPosition", cameraPositionStr,
				"cameraLookAt", cameraLookAtStr,
				"distanceFunction", jsScene,
			]),
			"#include material/extra/raymarching/raymarching.vert",
			blueprint("#include material/extra/raymarching/raymarching.frag", [
				"distanceFunction", glsl,
				"simpleDistance", glslSimple,
				"light", lightGlsl,
				"baseMaterial", baseMaterial,
				"numTextures", i2s(countedMaterials.first),
				"numColors", i2s(countedMaterials.second),
				"topLevelDistanceFunction", topLevelDistanceFunctions,
			])
		)
	)
}

sharedScriptInserted : ref Maybe<native> = ref None();
displayRaymarchingCanvas(id : int, webglContextLoadedB : Transform<bool>, scriptContent : string, shaderVertex : string, shaderFragment : string) -> Material {
	whB = make(WidthHeight(0.0, 0.0));
	MInspect([IAvailable(whB)], 
		MHTMLStage(whB, \stage -> {
			canvas = createElement("canvas");
			scriptGLM = createElement("script");
			scriptShaderVertex = createElement("script");
			scriptShaderFragment = createElement("script");
			script = createElement("script");

			setCanvasSize = \wh -> {
				setAttribute(canvas, "width", d2s(wh.width), true);
				setAttribute(canvas, "height", d2s(wh.height), true);
			};

			setAttribute(scriptGLM, "src", "js/glm-js.min.js", true);
			setAttribute(scriptGLM, "onload", "rayMain(" + "\"" + i2s(id) + "\"" + ")", true);
			setAttribute(canvas, "id", "rayCanvas" + i2s(id), true);
			setCanvasSize(fgetValue(whB));
			unsSize = makeSubscribeTrigger(webglContextLoadedB, whB, \wh -> {
				setCanvasSize(wh);
				hostCall("resizeCanvas", [id])|>ignore;
			})();
			setAttribute(scriptShaderVertex, "type", "text/plain", true);
			setAttribute(scriptShaderVertex, "id", "vertex-shader" + i2s(id), true);
			setAttribute(scriptShaderVertex, "innerHTML", shaderVertex, true);
			setAttribute(scriptShaderFragment, "type", "text/plain", true);
			setAttribute(scriptShaderFragment, "id", "fragment-shader"  + i2s(id), true);
			setAttribute(scriptShaderFragment, "innerHTML", shaderFragment, false);
			setAttribute(script, "innerHTML", scriptContent, false);

			setClipStyle(stage, "overflow", "auto");

			// This script contains global storage to dipatch hostCalls between multiple contexts. So it is injected only once.
			sharedScript = onlyOnce(sharedScriptInserted, \ -> {
				shScript = createElement("script");
				setAttribute(shScript, "innerHTML", "#include material/extra/raymarching/raymarching_common.js", true);
				appendChild(stage, shScript);
				shScript;
			});

			appendChild(stage, scriptGLM);
			appendChild(stage, canvas);
			appendChild(stage, scriptShaderVertex);
			appendChild(stage, scriptShaderFragment);
			appendChild(stage, script);
			\ -> {
				unsSize();
				removeElementChild(stage, scriptGLM);
				removeElementChild(stage, canvas);
				removeElementChild(stage, scriptShaderVertex);
				removeElementChild(stage, scriptShaderFragment);
				removeElementChild(stage, script);
				removeElementChild(stage, sharedScript);
			}
		})
	)
}

extractMaterialsFromRMScene(obj : RMScene) -> [RMMaterial] {
	switch(obj) {
		RMCompositeObject(object, name, color, materialProperties, position): [RMMaterial(object, color, materialProperties)];
		RMPrimitive(): [];
		RMSTranslate(object, d): extractMaterialsFromRMScene(object);
		RMUnion2(object1, object2): concat(extractMaterialsFromRMScene(object1), extractMaterialsFromRMScene(object2));
		RMUnion(objects): mapConcat(objects, extractMaterialsFromRMScene);
		RMSmoothUnion(objects, k): mapConcat(objects, extractMaterialsFromRMScene);
		RMMaterial(object, color, materialProperties): [obj];
		RMEmpty(): [];
	}
}

extractTriggersFromRMScene(obj : RMScene) -> [DynamicBehaviour<RMTrigger>] {
	switch(obj) {
		RMCompositeObject(object, name, color, materialProperties, position): switch(color) {
			RMColor(col) : [col.trigger];
			RMTexture(texture, parameters): [texture.trigger, parameters.trigger];
		};
		RMPrimitive(): [];
		RMSTranslate(object, d): extractTriggersFromRMScene(object);
		RMUnion2(object1, object2): concat(extractTriggersFromRMScene(object1), extractTriggersFromRMScene(object2));
		RMUnion(objects): mapConcat(objects, extractTriggersFromRMScene);
		RMSmoothUnion(objects, k): mapConcat(objects, extractTriggersFromRMScene);
		RMMaterial(object, color, materialProperties): concat(
			switch(color) {
				RMColor(col) : [col.trigger];
				RMTexture(texture, parameters): [texture.trigger, parameters.trigger];
			},
			eitherMap(tryExtractStruct(materialProperties, RMReflect(initRMInteractive(0.))), \r -> [r.mixCoef.trigger], [])
		);
		RMEmpty(): [];
	}
}

makeRaymarchingMaterialTexture(material : Material, texture : DynamicBehaviour<string>) -> Material {
	isDisplayed = make(true);
	pngFn = make(None());
	MConstruct(
		[
			makeSubscribe(pngFn, \pfn -> {
				maybeApply(
					pfn,
					\fn -> fn(\v -> {
						timer(100,\ -> next(isDisplayed, false));
						next(texture, v);
					})
				)
			})
		],
		MExtractPNG(
			MIf(
				isDisplayed,
				material,
				MEmpty()
			),
			\fn -> next(pngFn, fn)
		)
	)
}

rmiTree2GLSL(rmiScene : Tree<int, RMIExp>) -> string {
	strGlue(
		convertTreeToArray(
			rmiScene,
			\k, v -> formatString("if (id == %1) {\nresult = %2;\n}", [i2s(k), RMIExp2GLSL(v)])
		),
		" else "
	);
}