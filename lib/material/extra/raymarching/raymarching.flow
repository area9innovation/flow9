import material/material_ui;
import material/extra/raymarching/raymarching_rm2rmi;
import material/extra/raymarching/raymarching_rmi2code;

export {
	MRaymarching(id : int, scene : RMScene, light : RMLights, camera : RMCamera) -> Material;
	MDynamicRaymarching(id : int, sceneB : Transform<RMScene>, lightB : Transform<RMLights>, cameraB : Transform<RMCamera>) -> Material;
}

MRaymarching(id : int, scene : RMScene, light : RMLights, camera : RMCamera) -> Material {
	glsl = RMIExp2GLSL(RMScene2RMIExp(scene, true));
	material1 = RMIExp2GLSLMaterial(RMScene2RMIExp(scene, true));
	material2 = RMIExp2GLSLMaterial(RMScene2RMIExp(scene, false));
	jsScene = RMIExp2JS(RMScene2RMIExpJS(scene, RMIXYZ(0., 0., 0.)));
	lightGlsl = RMIExp2GLSL(RMLights2RMIExp(light));

	cameraPositionStr = formatString("%1, %2, %3", [
		d2s(camera.position.x),
		d2s(camera.position.y),
		d2s(camera.position.z)
	]);
	cameraLookAtStr = formatString("%1, %2, %3", [
		d2s(camera.lookAt.x),
		d2s(camera.lookAt.y),
		d2s(camera.lookAt.z)
	]);

	displayRaymarchingCanvas(
		id,
		blueprint("#include material/extra/raymarching/raymarching.js", [
			"cameraPosition", cameraPositionStr,
			"cameraLookAt", cameraLookAtStr,
			"distanceFunction", jsScene
		]),
		"#include material/extra/raymarching/raymarching.vert",
		blueprint("#include material/extra/raymarching/raymarching.frag", ["distanceFunction", glsl, "light", lightGlsl, "materialFunction1", material1, "materialFunction2", material2])
	)
}

MDynamicRaymarching(id : int, sceneB : Transform<RMScene>, lightB : Transform<RMLights>, cameraB : Transform<RMCamera>) -> Material {
	glsl = RMIExp2GLSL(RMScene2RMIExp(fgetValue(sceneB), true));
	material1 = RMIExp2GLSLMaterial(RMScene2RMIExp(fgetValue(sceneB), true));
	material2 = RMIExp2GLSLMaterial(RMScene2RMIExp(fgetValue(sceneB), false));
	jsScene = RMIExp2JS(RMScene2RMIExpJS(fgetValue(sceneB), RMIXYZ(0., 0., 0.)));
	lightGlsl = RMIExp2GLSL(RMLights2RMIExp(fgetValue(lightB)));

	cameraPositionStr = formatString("%1, %2, %3", [
		d2s(fgetValue(cameraB).position.x),
		d2s(fgetValue(cameraB).position.y),
		d2s(fgetValue(cameraB).position.z)
	]);
	cameraLookAtStr = formatString("%1, %2, %3", [
		d2s(fgetValue(cameraB).lookAt.x),
		d2s(fgetValue(cameraB).lookAt.y),
		d2s(fgetValue(cameraB).lookAt.z)
	]);

	MConstruct(
		[
			make2Subscribe2(
				fthrottle(sceneB, 500), fthrottle(lightB, 500),
				\s, l -> {
					hostCall("recompileShader", [
						i2s(id),
						blueprint(
							"#include material/extra/raymarching/raymarching.frag",
							[
								"distanceFunction", RMIExp2GLSL(RMScene2RMIExp(s, true)),
								"light", RMIExp2GLSL(RMLights2RMIExp(l)),
								"materialFunction1", RMIExp2GLSLMaterial(RMScene2RMIExp(s, true)),
								"materialFunction2", RMIExp2GLSLMaterial(RMScene2RMIExp(s, false))
							]
						)
					]);
					hostCall(
						"setDistanceFunction",
						[
							i2s(id),
							formatString("(p) => {return %1;}", [RMIExp2JS(RMScene2RMIExpJS(s, RMIXYZ(0., 0., 0.)))])
						]
					) |> ignore;
				}
			),
			makeSubscribe2(
				fthrottle(cameraB, 500),
				\c -> {
					hostCall("setCameraPosition", [
						i2d(id),
						c.position.x,
						c.position.y,
						c.position.z
					]) |> ignore;
					hostCall("setCameraLookAt", [
						i2d(id),
						c.lookAt.x,
						c.lookAt.y,
						c.lookAt.z
					]) |> ignore;
				}
			)
		],
		displayRaymarchingCanvas(
			id,
			blueprint("#include material/extra/raymarching/raymarching.js", [
				"cameraPosition", cameraPositionStr,
				"cameraLookAt", cameraLookAtStr,
				"distanceFunction", jsScene
			]),
			"#include material/extra/raymarching/raymarching.vert",
			blueprint("#include material/extra/raymarching/raymarching.frag", ["distanceFunction", glsl, "light", lightGlsl, "materialFunction1", material1, "materialFunction2", material2])
		)
	)
}

sharedScriptInserted : ref Maybe<native> = ref None();
displayRaymarchingCanvas(id : int, scriptContent : string, shaderVertex : string, shaderFragment : string) -> Material {
	whB = make(WidthHeight(0.0, 0.0));
	MInspect([IAvailable(whB)], 
		MHTMLStage(whB, \stage -> {
			canvas = createElement("canvas");
			scriptGLM = createElement("script");
			scriptShaderVertex = createElement("script");
			scriptShaderFragment = createElement("script");
			script = createElement("script");

			setCanvasSize = \wh -> {
				setAttribute(canvas, "width", d2s(wh.width), true);
				setAttribute(canvas, "height", d2s(wh.height), true);
			};

			setAttribute(scriptGLM, "src", "js/glm-js.min.js", true);
			setAttribute(scriptGLM, "onload", "rayMain(" + "\"" + i2s(id) + "\"" + ")", true);
			setAttribute(canvas, "id", "rayCanvas" + i2s(id), true);
			setCanvasSize(fgetValue(whB));
			unsSize = makeSubscribe2(whB, \wh -> {
				setCanvasSize(wh);
				hostCall("resizeCanvas", [id])|>ignore;
			})();
			setAttribute(scriptShaderVertex, "type", "text/plain", true);
			setAttribute(scriptShaderVertex, "id", "vertex-shader" + i2s(id), true);
			setAttribute(scriptShaderVertex, "innerHTML", shaderVertex, true);
			setAttribute(scriptShaderFragment, "type", "text/plain", true);
			setAttribute(scriptShaderFragment, "id", "fragment-shader"  + i2s(id), true);
			setAttribute(scriptShaderFragment, "innerHTML", shaderFragment, false);
			setAttribute(script, "innerHTML", scriptContent, false);

			setClipStyle(stage, "overflow", "auto");

			// This script contains global storage to dipatch hostCalls between multiple contexts. So it is injected only once.
			sharedScript = onlyOnce(sharedScriptInserted, \ -> {
				shScript = createElement("script");
				setAttribute(shScript, "innerHTML", "#include material/extra/raymarching/raymarching_common.js", true);
				appendChild(stage, shScript);
				shScript;
			});

			appendChild(stage, scriptGLM);
			appendChild(stage, canvas);
			appendChild(stage, scriptShaderVertex);
			appendChild(stage, scriptShaderFragment);
			appendChild(stage, script);
			\ -> {
				unsSize();
				removeElementChild(stage, scriptGLM);
				removeElementChild(stage, canvas);
				removeElementChild(stage, scriptShaderVertex);
				removeElementChild(stage, scriptShaderFragment);
				removeElementChild(stage, script);
				removeElementChild(stage, sharedScript);
			}
		})
	)
}
