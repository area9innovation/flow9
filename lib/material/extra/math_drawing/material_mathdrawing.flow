import material/material;
import material/material_gui;
import form/mathdrawingstructs;

export {
	fraction2material(num : Material, denum : Material, colorB : Behaviour<int>, decreaseMargin : bool) -> Material;
	brackets2material(lb : WriteBracketType, rb : WriteBracketType,	body : Material, colorB : Behaviour<int>) -> Material;
}
fraction2material(num : Material, denum : Material, colorB : Behaviour<int>, decreaseMargin : bool) -> Material {
	offsetPoint = \offsetB -> fselect(offsetB, FLift(\offset -> Point(offset, 0.0)));

	numWhB = makeWH();
	numOB = make(0.0);
	numOWB = make(0.0);
	numOffset = offsetPoint(numOB);
	numFOffset = offsetPoint(numOWB);

	numFiller = TSelect2(numWhB, numOB, \nWh, nO -> {
		TFixed(nO, nWh.height)
	});

	denumWhB = makeWH();
	denumOB = make(0.0);
	denumOWB = make(0.0);
	denumOffset = offsetPoint(denumOB);
	denumFOffset = offsetPoint(denumOWB);

	denumFiller = TSelect2(denumWhB, denumOB, \dnWh, dnO -> {
		TFixed(dnO, dnWh.height)
	});

	lineWB = make(0.0);
	heightB = make(0.0);
	baselineB = make(0.0);
	
	MConstruct(
		[make3Subscribe(
			numWhB,
			denumWhB,
			heightB,
			\numWH, denumWH, h -> {
				margin = if (decreaseMargin) 0.0 else 4.0;
				nextDistinct(lineWB, max(numWH.width, denumWH.width) + margin * 2.0);
				numO = max((denumWH.width - numWH.width) * 0.5, 0.0) + margin;
				denumO = max((numWH.width - denumWH.width) * 0.5, 0.0) + margin;
				nextDistinct(numOB, numO);
				nextDistinct(denumOB, denumO);
				nextDistinct(numOWB, numO + numWH.width);
				nextDistinct(denumOWB, denumO + denumWH.width);
				nextDistinct(baselineB, - denumWH.height * 0.82); 
			}
		)],
		MInspect(
			[IHeight(heightB)],
			MBaselineOffset(
				baselineB,
				MLines([
					MGroup([
						numFiller,
						MTranslate(numOffset,
							MInspect([ISize(numWhB)], MBorder(
								0.0, 0.0, 0.0, 1.5,
								num
							))
						),
						MTranslate(numFOffset, numFiller)
					]),
					MGraphics(
						fselect(lineWB, FLift(\lineW ->
							GPath([
								MoveTo(0.0, 0.0),
								LineTo(lineW, 0.0),
								ClosePath()
							])
						)),
						fselect(colorB, FLift(\color ->
							[MStroke(colorInt2MColor(color)), StrokeWidth(1.0)]
						))
					),
					MGroup([
						denumFiller,
						MTranslate(denumOffset,
							MInspect([ISize(denumWhB)], MBorder(
								0.0, 2.0, 0.0, 0.0,
								denum
							)),
						),
						MTranslate(denumFOffset, denumFiller)
					])
				])
			)
		)
	);
}

brackets2material(
	lb : WriteBracketType,
	rb : WriteBracketType,
	body : Material,
	colorB : Behaviour<int>
) -> Material {
	bracketsOffset = 5.0; //???
	baselineB = make(0.0);
	bodyHeightB = make(0.0);
	bodyBaselineB = make(0.0);
	isBracketOrAbsSign = lb == WriteLeftBracket() || lb == WriteAbsSign();
	bodyMaterial = MInspect(
		ifArrayPush([Height(bodyHeightB)], isBracketOrAbsSign, IBaseline(bodyBaselineB)),
		body
	);

	MBaselineOffset(
		baselineB,
		MCols([
			bracket2material(lb, bodyHeightB, colorB),
			bodyMaterial,
			bracket2material(rb, bodyHeightB, colorB),
		])
		
	);
};

bracket2material(
	type : WriteBracketType,
	heightB : Behaviour<double>,
	colorB : Behaviour<int>
) -> Material {
	if (type == WriteNoBracket()) {
		MEmpty()
	} else {
		MSelect2(colorB, heightB, \color, height -> {
			createMaterialBracket(type, height, color)
		})
	}
};


createMaterialBracket(
	type : WriteBracketType,
	bodyHeight : double,
	color : int
) -> Material {
	isSmall = false;

	height = bodyHeight;
	deepness = sqrt(height) + 1.0;

	h = 22.0;
	yScale = height / h;

	border = 2.0;

	println("WriteBracketType -> " + toString(type));

	switch(type : WriteBracketType) {
		WriteAbsSign() : {
			MAttachBox(
				MGraphics(
					const(GPath([
						MoveTo(3.0, 0.0),
						LineTo(3.0, height),
						ClosePath()
					])),
					const([Fill(color), MStroke(colorInt2MColor(color))])
				),
				make(WidthHeight(5.0, height))
			)
		}
		WriteNormSign() : {
			graphics = MGraphics(
				const(GPath([
					MoveTo(3.0, 0.0),
					LineTo(3.0, height),
				])),
				const([MStroke(colorInt2MColor(color))])
			);
			MAttachBox(
				MCols2(graphics, graphics),
				make(WidthHeight(10.0, height))
			)
		}
		WriteLeftBrace() : {
			MAttachBox(
				MGraphics(
					const(GPath([
						MoveTo(deepness, 0.0),
						CubicBezierTo(deepness / 2.0, 4.0 * yScale, deepness / 2.0, 0.0 * yScale),
						LineTo(deepness / 2.0, 7.0 * yScale),
						CubicBezierTo(deepness / 10.0, height * 0.5, deepness / 2.0, 0.5 * height),
						MoveTo(deepness, h * yScale),
						CubicBezierTo(deepness / 2.0, 18.0 * yScale, deepness / 2.0, h * yScale),
						LineTo(deepness / 2.0, 15.0 * yScale),
						CubicBezierTo(deepness / 10.0, height * 0.5, deepness / 2.0, 0.5 * height),
						ClosePath()
					])),
					const([Fill(color), MStroke(colorInt2MColor(color))])
				),
				make(WidthHeight(deepness, height))
			)
		}
		WriteRightBrace() : {
			MAttachBox(
				MGraphics(
					const(GPath([
						MoveTo(0.0, 0.0),
						CubicBezierTo(deepness / 2.0, 4.0 * yScale, deepness / 2.0, 0.0 * yScale),
						LineTo(deepness / 2.0, 7.0 * yScale),
						CubicBezierTo(deepness * 0.9, height * 0.5, deepness / 2.0, 0.5 * height),
						MoveTo(0.0, h * yScale),
						CubicBezierTo(deepness / 2.0, 18.0 * yScale, deepness / 2.0, h * yScale),
						LineTo(deepness / 2.0, 15.0 * yScale),
						CubicBezierTo(deepness * 0.9, height * 0.5, deepness / 2.0, 0.5 * height),
						ClosePath()
					])),
					const([Fill(color), MStroke(colorInt2MColor(color))])
				),
				make(WidthHeight(deepness, height))
			)
		}
		WriteLeftBracket() : {
			MAttachBox(
				MGraphics(
					const(GPath({
						lx1 = - deepness;
						lx2 = lx1 + sqrt(deepness);
						[
							MoveTo(deepness * 0.8 + border, 0.0),
							CubicBezierTo(deepness * 0.8 + border, height, lx2 + border, height / 2.0),
							CubicBezierTo(deepness * 0.8 + border, 0.0, lx1 + border, height / 2.0),
							ClosePath()
						];
					})),
					const([Fill(color), MStroke(colorInt2MColor(color))])
				),
				make(WidthHeight(deepness + border, height))
			)
		}
		WriteRightBracket() : {
			MAttachBox(
				MGraphics(
					const(GPath({
						lx1 = 2.0 * deepness;
						lx2 = lx1 - sqrt(deepness);
						[
							MoveTo(deepness * 0.2, 0.0),
							CubicBezierTo(deepness * 0.2, height, lx1, height / 2.0),
							CubicBezierTo(deepness * 0.2, 0.0, lx2, height / 2.0),
							ClosePath()
						];
					})),
					const([Fill(color), MStroke(colorInt2MColor(color))])
				),
				make(WidthHeight(deepness + border, height))
			)
		}
		WriteLeftSquareBracket() : {
			MAttachBox(
				MGraphics(
					const(GPath([
						MoveTo(7.0, 0.0),
						LineTo(3.0, 0.0),
						LineTo(3.0, height),
						LineTo(7.0, height),
					])),
					const([MStroke(colorInt2MColor(color))])
				),
				make(WidthHeight(8.0, height))
			)
		}
		WriteRightSquareBracket() : {
			MAttachBox(
				MGraphics(
					const(GPath([
						MoveTo(1.0, 0.0),
						LineTo(5.0, 0.0),
						LineTo(5.0, height),
						LineTo(1.0, height),
					])),
					const([MStroke(colorInt2MColor(color))])
				),
				make(WidthHeight(8.0, height))
			)
		}
		WriteLeftFloorBracket() : {
			MAttachBox(
				MGraphics(
					const(GPath([
						MoveTo(3.0, 0.0),
						LineTo(3.0, height),
						LineTo(7.0, height),
					])),
					const([MStroke(colorInt2MColor(color))])
				),
				make(WidthHeight(8.0, height))
			)
		}
		WriteRightFloorBracket() : {
			MAttachBox(
				MGraphics(
					const(GPath([
						MoveTo(5.0, 0.0),
						LineTo(5.0, height),
						LineTo(1.0, height),
					])),
					const([MStroke(colorInt2MColor(color))])
				),
				make(WidthHeight(8.0, height))
			)
		}
		WriteLeftCeilBracket() : {
			MAttachBox(
				MGraphics(
					const(GPath([
						MoveTo(7.0, 0.0),
						LineTo(3.0, 0.0),
						LineTo(3.0, height),
					])),
					const([MStroke(colorInt2MColor(color))])
				),
				make(WidthHeight(8.0, height))
			)
		}
		WriteRightCeilBracket() : {
			MAttachBox(
				MGraphics(
					const(GPath([
						MoveTo(1.0, 0.0),
						LineTo(5.0, 0.0),
						LineTo(5.0, height),
					])),
					const([MStroke(colorInt2MColor(color))])
				),
				make(WidthHeight(8.0, height))
			)
		}
		WriteLeftDoubleSquareBracket() : {
			MAttachBox(
				MGraphics(
					const(GPath([
						MoveTo(10.0, 0.0),
						LineTo(3.0, 0.0),
						LineTo(3.0, height),
						LineTo(10.0, height),
						MoveTo(6.0, 0.0),
						LineTo(6.0, height),
					])),
					const([MStroke(colorInt2MColor(color))])
				),
				make(WidthHeight(11.0, height))
			)
		}
		WriteRightDoubleSquareBracket() : {
			MAttachBox(
				MGraphics(
					const(GPath([
						MoveTo(1.0, 0.0),
						LineTo(8.0, 0.0),
						LineTo(8.0, height),
						LineTo(1.0, height),
						MoveTo(5.0, 0.0),
						LineTo(5.0, height),
					])),
					const([MStroke(colorInt2MColor(color))])
				),
				make(WidthHeight(11.0, height))
			)
		}
		WriteNoBracket() : {
			MEmpty()
		}
	};
}

// brackets2formSelectedAndWrap(
// 	lb : WriteBracketType,
// 	rb : WriteBracketType,
// 	body : Form,
// 	backColor : Maybe<int>,
// 	wrappersLeft : MathFormWrappers,
// 	wrappersRight : MathFormWrappers,
// 	fontSize : double
// ) -> Form {
// 	// with this constant brackets together with outer content looks more pretty. I could not find general solution.
// 	bracketsOffset = 5.0;
// 	isBracketOrAbsSign = lb == WriteLeftBracket() || lb == WriteAbsSign();

// 	unpair(getDynamicFormSize(body), \bodyForm : Form, bodySizeB : Behaviour<FormMetrics> -> {
// 		heightB = make(0.0);
// 		baselineB = make(0.0);
// 		bodyFormMetrics = make(FormMetrics(0.0, 0.0, 0.0, 0.0));

// 		fixBaselineB(
// 			baselineB,
// 			Cols([
// 				bracket2formSelectedAndWrap(lb, backColor, heightB, wrappersLeft, fontSize),
// 				if (isBracketOrAbsSign) Inspect([IMetrics(bodyFormMetrics)], bodyForm)
// 				else bodyForm,
// 				bracket2formSelectedAndWrap(rb, backColor, heightB, wrappersRight, fontSize)
// 			])
// 		)
// 		|> (\f -> Constructor(f, makeSubscribe(bodySizeB, \bodySize-> {
// 				nextDistinct(heightB, bodySize.height);
// 				if (!isBracketOrAbsSign) nextDistinct(baselineB, bodySize.height / 2.0 + bracketsOffset);
// 			})))
// 		|> (\f ->
// 			if (isBracketOrAbsSign) Constructor(f, makeSubscribe(bodyFormMetrics, \met-> nextDistinct(baselineB, met.baseline)))
// 			else f
// 		)
// 	})
// }