import material/material;
import material/material_gui;
import form/mathdrawingstructs;

export {
	fraction2material(num : Material, denum : Material, colorB : Behaviour<int>, decreaseMargin : bool) -> Material;
	brackets2material(lb : WriteBracketType, rb : WriteBracketType,	body : Material, colorB : Behaviour<int>) -> Material;
	longDivision2material(body : Material,	colorB : Behaviour<int>) -> Material;
}
fraction2material(num : Material, denum : Material, colorB : Behaviour<int>, decreaseMargin : bool) -> Material {
	offsetPoint = \offsetB -> fselect(offsetB, FLift(\offset -> Point(offset, 0.0)));

	numWhB = makeWH();
	numBaselinB = make(0.0);
	numOB = make(0.0);
	numOWB = make(0.0);
	numOffset = offsetPoint(numOB);
	numFOffset = offsetPoint(numOWB);

	numFiller = MSelect2(numWhB, numOB, \nWh, nO -> {
		MFixed(nO, nWh.height)
	});

	denumWhB = makeWH();
	denumBaselinB = make(0.0);
	denumOB = make(0.0);
	denumOWB = make(0.0);
	denumOffset = offsetPoint(denumOB);
	denumFOffset = offsetPoint(denumOWB);

	denumFiller = MSelect2(denumWhB, denumOB, \dnWh, dnO -> {
		MFixed(dnO, dnWh.height)
	});

	lineWB = make(0.0);
	heightB = make(0.0);
	baselineB = make(0.0);
	
	MConstruct(
		[make4Subscribe(
			numWhB,
			denumWhB,
			heightB,
			fselect2(numBaselinB, denumBaselinB, FLift2(min)),
			\numWH, denumWH, h, baseline -> {
				margin = if (decreaseMargin) 0.0 else 4.0;
				nextDistinct(lineWB, max(numWH.width, denumWH.width) + margin * 2.0);
				numO = max((denumWH.width - numWH.width) * 0.5, 0.0) + margin;
				denumO = max((numWH.width - denumWH.width) * 0.5, 0.0) + margin;
				nextDistinct(numOB, numO);
				nextDistinct(denumOB, denumO);
				nextDistinct(numOWB, numO + numWH.width);
				nextDistinct(denumOWB, denumO + denumWH.width);
				nextDistinct(baselineB, numWH.height * 0.87  + baseline / 2.0); 
			}
		)],
		MInspect(
			[IHeight(heightB)],
			MBaseline(
				baselineB,
				MLines([
					MGroup([
						numFiller,
						MTranslate(numOffset,
							MInspect([ISize(numWhB), IBaseline(numBaselinB)], MBorder(
								0.0, 0.0, 0.0, 1.5,
								num
							))
						),
						MTranslate(numFOffset, numFiller)
					]),
					MGraphics(
						fselect(lineWB, FLift(\lineW ->
							GPath([
								MoveTo(0.0, 0.0),
								LineTo(lineW, 0.0),
								ClosePath()
							])
						)),
						fselect(colorB, FLift(\color ->
							[MStroke(colorInt2MColor(color)), StrokeWidth(1.0)]
						))
					),
					MGroup([
						denumFiller,
						MTranslate(denumOffset,
							MInspect([ISize(denumWhB), IBaseline(denumBaselinB)], MBorder(
								0.0, 2.0, 0.0, 0.0,
								denum
							)),
						),
						MTranslate(denumFOffset, denumFiller)
					])
				])
			)
		)
	);
}

brackets2material(
	lb : WriteBracketType,
	rb : WriteBracketType,
	body : Material,
	colorB : Behaviour<int>
) -> Material {
	bracketsOffset = 5.0;
	baselineB = make(0.0);
	bodyHeightB = make(0.0);
	bodyBaselineB = make(0.0);
	isBracketOrAbsSign = lb == WriteLeftBracket() || lb == WriteAbsSign();
	bodyMaterial = MInspect(
		ifArrayPush([Height(bodyHeightB)], isBracketOrAbsSign, IBaseline(bodyBaselineB)),
		body
	);

	MConstruct(
		[
			\ -> connectSelect2Distinctu(
				bodyHeightB,
				bodyBaselineB,
				baselineB,
				\bodyHeight, bodyBaseline -> {
					if (isBracketOrAbsSign) {
						bodyBaseline
					} else {
						bodyHeight / 2.0 + bracketsOffset
					}
				}
			)
		],
		MBaseline(
			baselineB,
			MCols([
				bracket2material(lb, bodyHeightB, colorB),
				bodyMaterial,
				bracket2material(rb, bodyHeightB, colorB),
			])
			
		)
	)
};

bracket2material(
	type : WriteBracketType,
	heightB : Behaviour<double>,
	colorB : Behaviour<int>
) -> Material {
	if (type == WriteNoBracket()) {
		MEmpty()
	} else {
		MSelect2(colorB, heightB, \color, height -> {
			createMaterialBracket(type, height, color)
		})
	}
};


createMaterialBracket(
	type : WriteBracketType,
	bodyHeight : double,
	color : int
) -> Material {
	isSmall = false;

	height = bodyHeight;
	deepness = sqrt(height) + 1.0;

	h = 22.0;
	yScale = height / h;

	border = 2.0;

	switch(type : WriteBracketType) {
		WriteAbsSign() : {
			MFixSize(
				MGraphics(
					const(GPath([
						MoveTo(3.0, 0.0),
						LineTo(3.0, height),
					])),
					const([MStroke(colorInt2MColor(color))])
				),
				MFixed(5.0, height)
			)
		}
		WriteNormSign() : {
			graphics = MGraphics(
				const(GPath([
					MoveTo(3.0, 0.0),
					LineTo(3.0, height),
				])),
				const([MStroke(colorInt2MColor(color))])
			);
			MFixSize(
				MCols2(graphics, graphics),
				MFixed(10.0, height)
			)
		}
		WriteLeftBrace() : {
			MFixSize(
				MGraphics(
					const(GPath([
						MoveTo(deepness, 0.0),
						CubicBezierTo(deepness / 2.0, 4.0 * yScale, deepness / 2.0, 0.0 * yScale),
						LineTo(deepness / 2.0, 7.0 * yScale),
						CubicBezierTo(deepness / 10.0, height * 0.5, deepness / 2.0, 0.5 * height),
						MoveTo(deepness, h * yScale),
						CubicBezierTo(deepness / 2.0, 18.0 * yScale, deepness / 2.0, h * yScale),
						LineTo(deepness / 2.0, 15.0 * yScale),
						CubicBezierTo(deepness / 10.0, height * 0.5, deepness / 2.0, 0.5 * height),
					])),
					const([MStroke(colorInt2MColor(color))])
				),
				MFixed(deepness, height)
			)
		}
		WriteRightBrace() : {
			MFixSize(
				MGraphics(
					const(GPath([
						MoveTo(0.0, 0.0),
						CubicBezierTo(deepness / 2.0, 4.0 * yScale, deepness / 2.0, 0.0 * yScale),
						LineTo(deepness / 2.0, 7.0 * yScale),
						CubicBezierTo(deepness * 0.9, height * 0.5, deepness / 2.0, 0.5 * height),
						MoveTo(0.0, h * yScale),
						CubicBezierTo(deepness / 2.0, 18.0 * yScale, deepness / 2.0, h * yScale),
						LineTo(deepness / 2.0, 15.0 * yScale),
						CubicBezierTo(deepness * 0.9, height * 0.5, deepness / 2.0, 0.5 * height),
					])),
					const([MStroke(colorInt2MColor(color))])
				),
				MFixed(deepness, height)
			)
		}
		WriteLeftBracket() : {
			MFixSize(
				MGraphics(
					const(GPath({
						lx1 = - deepness;
						lx2 = lx1 + sqrt(deepness);
						[
							MoveTo(deepness * 0.8 + border, 0.0),
							CubicBezierTo(deepness * 0.8 + border, height, lx2 + border, height / 2.0),
							CubicBezierTo(deepness * 0.8 + border, 0.0, lx1 + border, height / 2.0),
							ClosePath()
						];
					})),
					const([Fill(color)])
				),
				MFixed(deepness + border, height)
			)
		}
		WriteRightBracket() : {
			MFixSize(
				MGraphics(
					const(GPath({
						lx1 = 2.0 * deepness;
						lx2 = lx1 - sqrt(deepness);
						[
							MoveTo(deepness * 0.2, 0.0),
							CubicBezierTo(deepness * 0.2, height, lx1, height / 2.0),
							CubicBezierTo(deepness * 0.2, 0.0, lx2, height / 2.0),
							ClosePath()
						];
					})),
					const([Fill(color)])
				),
				MFixed(deepness + border, height)
			)
		}
		WriteLeftSquareBracket() : {
			MFixSize(
				MGraphics(
					const(GPath([
						MoveTo(7.0, 0.0),
						LineTo(3.0, 0.0),
						LineTo(3.0, height),
						LineTo(7.0, height),
					])),
					const([MStroke(colorInt2MColor(color))])
				),
				MFixed(8.0, height)
			)
		}
		WriteRightSquareBracket() : {
			MFixSize(
				MGraphics(
					const(GPath([
						MoveTo(1.0, 0.0),
						LineTo(5.0, 0.0),
						LineTo(5.0, height),
						LineTo(1.0, height),
					])),
					const([MStroke(colorInt2MColor(color))])
				),
				MFixed(8.0, height)
			)
		}
		WriteLeftFloorBracket() : {
			MFixSize(
				MGraphics(
					const(GPath([
						MoveTo(3.0, 0.0),
						LineTo(3.0, height),
						LineTo(7.0, height),
					])),
					const([MStroke(colorInt2MColor(color))])
				),
				MFixed(8.0, height)
			)
		}
		WriteRightFloorBracket() : {
			MFixSize(
				MGraphics(
					const(GPath([
						MoveTo(5.0, 0.0),
						LineTo(5.0, height),
						LineTo(1.0, height),
					])),
					const([MStroke(colorInt2MColor(color))])
				),
				MFixed(8.0, height)
			)
		}
		WriteLeftCeilBracket() : {
			MFixSize(
				MGraphics(
					const(GPath([
						MoveTo(7.0, 0.0),
						LineTo(3.0, 0.0),
						LineTo(3.0, height),
					])),
					const([MStroke(colorInt2MColor(color))])
				),
				MFixed(8.0, height)
			)
		}
		WriteRightCeilBracket() : {
			MFixSize(
				MGraphics(
					const(GPath([
						MoveTo(1.0, 0.0),
						LineTo(5.0, 0.0),
						LineTo(5.0, height),
					])),
					const([MStroke(colorInt2MColor(color))])
				),
				MFixed(8.0, height)
			)
		}
		WriteLeftDoubleSquareBracket() : {
			MFixSize(
				MGraphics(
					const(GPath([
						MoveTo(10.0, 0.0),
						LineTo(3.0, 0.0),
						LineTo(3.0, height),
						LineTo(10.0, height),
						MoveTo(6.0, 0.0),
						LineTo(6.0, height),
					])),
					const([MStroke(colorInt2MColor(color))])
				),
				MFixed(11.0, height)
			)
		}
		WriteRightDoubleSquareBracket() : {
			MFixSize(
				MGraphics(
					const(GPath([
						MoveTo(1.0, 0.0),
						LineTo(8.0, 0.0),
						LineTo(8.0, height),
						LineTo(1.0, height),
						MoveTo(5.0, 0.0),
						LineTo(5.0, height),
					])),
					const([MStroke(colorInt2MColor(color))])
				),
				MFixed(11.0, height)
			)
		}
		WriteNoBracket() : {
			MEmpty()
		}
	};
}


longDivision2material(
	body : Material,
	colorB : Behaviour<int>
) -> Material {
	radius = 5.0;
	leftOffset = 7.0;
	topOffset = 3.0;
	rightLineLength = 3.0;

	makeLongDivision = \width, height, fc -> {
		path = [
			MoveTo(0.0, height + topOffset),
			CubicBezierTo(0.0, 0.0, 0.0 + radius, (topOffset + height) * 0.5),
			LineTo(width + leftOffset + rightLineLength, 0.0)
		];
		MGraphics(
			const(GPath(path)),
			const([Stroke(fc), StrokeWidth(2.0)])
		)
	};

	addBorder = \m -> MBorder(1.0 + leftOffset, topOffset, rightLineLength + 1.0, 0.0, m);
	
	bodyWHB = makeWH();
	bodyBaselineB = make(0.0);
	baselineB = make(0.0);

	MConstruct(
		[
			\ -> connectSelectDistinctu(bodyBaselineB, baselineB, \bodyBaseline -> bodyBaseline + topOffset)
		],
		MBaseline(
			baselineB,
			MGroup2(
				MSelect2(bodyWHB, colorB, \wh, color -> makeLongDivision(wh.width, wh.height, color)),
				MInspect([ISize(bodyWHB), IBaseline(bodyBaselineB)], body) |> addBorder
			)
		)
	)
	
}