import material/material_ui;

export {
	MInputChips(items : Transform<[string]>, style : [MInputChipsStyle]) -> Material;

	// MWidth is for MAutoComplete
	MInputChipsStyle ::= MWidth, MInputChipsMaxWidth, MSelectedInputChips, MInputChipsLeftCaption, MCustomChipStyle, MInputChipsMultiline;
		MSelectedInputChips(items : DynamicBehaviour<[string]>);
		MInputChipsLeftCaption(caption : Material);
		MInputChipsMaxWidth(width : Transform<double>);
		MCustomChipStyle(style : [MChipStyle]);
		MInputChipsMultiline();
}

MInputChips(items : Transform<[string]>, style : [MInputChipsStyle]) -> Material {
	selectedItems = extractStruct(style, MSelectedInputChips(make([]))).items;
	caption = extractStruct(style, MInputChipsLeftCaption(TEmpty())).caption;
	width = extractStruct(style, MWidth(-1.));
	maxWidth = tryExtractStruct(style, MInputChipsMaxWidth(const(-1.)));
	chipStyle = extractStruct(style, MCustomChipStyle([])).style;
	multiline = contains(style, MInputChipsMultiline());

	text = make("");
	focused = make(false);
	position = make(0);
	leftWidth = make(0.);
	avWidth = make(0.);

	materialize = \elem -> MChip(elem, concat([
		MNewChip(),
		MCloseButton(),
		MOnClose(\ -> {nextDistinct(selectedItems, removeAll(fgetValue(selectedItems), elem)); true})
	], chipStyle));

	chipsGrid =
		if (multiline) {
			gridAvailW = make(0.);
			MFlexibleGrid(
				fmap(selectedItems, materialize),
				[MLockWidth(false), TFillersSupport(), TAvailableMinMax(zero, gridAvailW)]
			)
			|> (\m -> MAttachAvailableWidth(m, gridAvailW))
		} else {
			MReorderCols(selectedItems, materialize, [MNoScroll()])
			|> (\m -> MShow(fneq(selectedItems, []), m))
		}

	chips =
		MScroll(chipsGrid, TFillXY(), [
			MScrollCropByContent(),
			MScrollFadeContent(white, 40.),
			MScrollbars(
				invisibleScrollBar,
				invisibleScrollBar
			),
			TScrollDisableOutOfBounds(const(true))
		]);

	MGetManager(\manager -> {
		defFn = defaultCompletionFn(manager, manager.focus, []).fn;
		MSelect(items, \itms ->
			MAutoComplete(text, itms, [
				width,
				MTextInputOutOfPopup(),
				MCompletionFn(\match, selected, setWord -> defFn(match, selected, \word -> {
					setWord(word);
					if (!contains(getValue(selectedItems), word.sentence)) dynArrayPush(selectedItems, word.sentence);
					deferUntilNextFrameRendered(\ -> {
						next(text, "");
						next(position, 0);
						next(focused, true);
					})
				})),
				MPopupCustomOffset(fnegate(leftWidth)),
				MSentenceMatcher(buildSentenceMatcher, \matcher, input, maxHits, prefix, exhaustive, pos -> {
					filteredMatcher = SentenceMatcher(matcher with sentences = filter(matcher.sentences, \sentence -> !contains(getValue(selectedItems), sentence)));
					simpleSentenceMatcher(filteredMatcher, input, maxHits, prefix, exhaustive, pos);
				})
			], [MFocused(focused), TTextInputPosition(position)]
		))
	})
	|> (\m -> MAvailable(m, TFillWYT(fsubtract(avWidth, leftWidth))))
	|> MSetMinWidth2(const(96.))
	|> (\m -> MBaselineCols2(MAttachWidth(MBaselineCols2(caption, chips), leftWidth), m))
	|> (\m -> MAttachAvailableWidth(m, avWidth))
	|> (\m -> eitherMap(maxWidth, \mw -> MAvailable(m, TFillWYT(mw.width)), m))
	|> (\m -> MFrame(0., 0., [MFill(MWhite())], m))
	|> (\m -> MConstruct([makeSubscribe2(items, \itms ->
			nextDistinct(selectedItems, filter(getValue(selectedItems), \it -> contains(itms, it)))
		)], m))
}