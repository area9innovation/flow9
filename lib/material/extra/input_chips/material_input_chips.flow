import material/material_ui;

export {
	MInputChips(items : Transform<[string]>, style : [MInputChipsStyle]) -> Material;

	MInputChipsStyle ::= MInputChipsMaxWidth, MSelectedInputChips, MInputChipsLeftCaption, MCustomAutoCompleteStyle, MCustomChipStyle, MInputChipsMultiline;
		MSelectedInputChips(items : DynamicBehaviour<[string]>);
		MInputChipsLeftCaption(caption : Material);
		MInputChipsMaxWidth(width : Transform<double>);
		MCustomChipStyle(style : [MChipStyle]);
		MCustomAutoCompleteStyle(style : [MAutoCompleteStyle]);
		MInputChipsMultiline();
}

MInputChips(items : Transform<[string]>, style : [MInputChipsStyle]) -> Material {
	selectedItems = extractStruct(style, MSelectedInputChips(make([]))).items;
	caption = extractStruct(style, MInputChipsLeftCaption(TEmpty())).caption;
	maxWidth = tryExtractStruct(style, MInputChipsMaxWidth(const(-1.)));
	chipStyle = extractStruct(style, MCustomChipStyle([])).style;
	acStyle = extractStruct(style, MCustomAutoCompleteStyle([])).style;
	multiline = contains(style, MInputChipsMultiline());

	text = make("");
	focused = make(false);
	position = make(0);
	leftWidth = make(0.);
	avWidth = make(0.);

	fullWidth = make(0.);
	acPosScale = make(zeroPositionScale);
	icPosScale = make(zeroPositionScale);

	autoComplete =
		MGetManager(\manager -> {
			defFn = defaultCompletionFn(manager, manager.focus, []).fn;
			MSelect(items, \itms ->
				MAutoComplete(text, itms, concatA([
					[
						MTextInputOutOfPopup(),
						MCompletionFn(\match, selected, setWord -> defFn(match, selected, \word -> {
							setWord(word);
							if (!contains(getValue(selectedItems), word.sentence)) dynArrayPush(selectedItems, word.sentence);
							deferUntilNextFrameRendered(\ -> {
								next(text, "");
								next(position, 0);
								next(focused, true);
							})
						})),
						MSentenceMatcher(buildSentenceMatcher, \matcher, input, maxHits, prefix, exhaustive, pos -> {
							filteredMatcher = SentenceMatcher(matcher with sentences = filter(matcher.sentences, \sentence -> !contains(getValue(selectedItems), sentence)));
							simpleSentenceMatcher(filteredMatcher, input, maxHits, prefix, exhaustive, pos);
						}),
					], 
					if (multiline) [
						MPopupCustomOffset(fselect2(icPosScale, acPosScale, FLift2(\icps, acps -> icps.pos.x / icps.scale.x - acps.pos.x / acps.scale.x))),
						MPopupCustomWidth(fullWidth)
					]
					else [MPopupCustomOffset(fnegate(leftWidth))],
					acStyle
				]),
				[MFocused(focused), TTextInputPosition(position)]
			))
		})
		|> (\m ->
			if (multiline) MPositionScale(acPosScale, m)
			else MAvailable(m, TFillWYT(fsubtract(avWidth, leftWidth)))
		)
		|> MSetMinWidth2(const(96.));

	materialize = \elem -> MChip(elem, concat([
		MNewChip(),
		MCloseButton(),
		MOnClose(\ -> {nextDistinct(selectedItems, removeAll(fgetValue(selectedItems), elem)); true})
	], chipStyle));

	chipsGrid =
		if (multiline) {
			MFlexibleGrid(
				farrayPush(fmap(selectedItems, materialize), const(autoComplete)),
				[TFillersSupport()]
			)
		} else {
			MReorderCols(selectedItems, materialize, [MNoScroll()])
			|> (\m -> MShow(fneq(selectedItems, []), m))
		}

	chips =
		MScroll(chipsGrid, TFillXY(), [
			MScrollCropByContent(),
			MScrollFadeContent(white, 40.),
			MScrollbars(
				invisibleScrollBar,
				invisibleScrollBar
			),
			TScrollDisableOutOfBounds(const(true))
		]);
	
	MBaselineCols2(caption, chips)
	|> (\m -> MAttachWidth(m, leftWidth))
	|> (\m -> if (multiline) MAttachWidth(m, fullWidth) else MBaselineCols2(m, autoComplete))
	|> (\m -> MAttachAvailableWidth(m, avWidth))
	|> (\m -> eitherMap(maxWidth, \mw -> MAvailable(m, TFillWYT(mw.width)), m))
	|> (\m -> MFrame(0., 0., [MFill(MWhite())], m))
	|> (\m -> MConstruct([makeSubscribe2(items, \itms ->
			nextDistinct(selectedItems, filter(getValue(selectedItems), \it -> contains(itms, it)))
		)], m))
	|> (\m -> if (multiline) MPositionScale(icPosScale, m) else m)
}