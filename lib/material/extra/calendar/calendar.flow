import material/material_dialog;
import material/material_ui;
import excel_datetime;
import text/translation;
import pebbles/pebble_parameters;

export {
	CalendarForEvents(
		allEvents : DynamicBehaviour<[CalendarEvent]>,
		currentEventTypes : DynamicBehaviour<[CalendarEventDecription]>,
		manager : MaterialManager,
		dateMin : Date,
		dateMax : Date,
		monthNumber : int,
		displayedEventsInOneDay : int,
		onlyOneSameTypeEventsByDay : bool,
		colorizeDayHeaders : bool,
		styles : [CalendarForEventsStyle]) -> Material;

	CalendarEventDecription(
		name : string,
		mainColor : MColor,
		backColor : MColor,
		icon : string,
		editAction : (id : int) -> void,
		addAction : (fullDate : Time) -> void,
		deleteAction : (id : int) -> void,
		additionalActions : [CalendarAdditionalAction]
	);

	CalendarEvent(
		startDate : Time,
		endDate : Time,
		id : int,
		eventType : string,
		title : string,
		description : string,
		additionalFields : Tree<string, string>
	);

	CalendarAdditionalAction(
		icon : string,
		name : string,
		action : (id : int) -> void
	);

	CalendarDefaultDisplayedEventsInOneDay = 3;

	CalendarForEventsStyle ::= ShowMonthViewSwitchMenu, DefaultMonthView, TabOrder, DefaultTab, TabColors, HideAddEventButton,
		CloseDayPopupAfterAdditionalAction, EventListSettings, PlannedTableDateFormat, BlackAndWhiteTextColor, HideTimeInfo, HiddenEventTypes,
		ShowWeekViewDaysNames, CalendarHeaderStyle, CalendarHeaderText, CalendarHideEventTypesLegend, CalendarCurrentDate, CalendarShowTodayButton,
		CalendarHeaderTightWidth, CalendarHeaderAddEventButton, CalendarReadOnly, CalendarCustomEventView, CalendarPrintable, CalendarTabsDropdown,
		CalendarMonthAdditionalEventsView, CalendarWeekDayView, CalendarDayNumberView, CalendarMonthFillEmpty, CalendarEventsPopup,
		CalendarYearHideEventsCount, CalendarCustomEventTitle, CalendarEventsOpacities, CalendarCustomHeader, CalendarHideContentFrame,
		CalendarScrolls, CalendarPlannedHideDeleteButton, CalendarReadOnlyEvent, CalendarPebbles, CalendarHideTabs, CalendarHideWeekends,
		CalendarHideTimeInDayView, CalendarHideTimelineInDayView, CalendarReadOnlyEventDialog, CalendarCombinedEventsView,
		CalendarWeekAdaptiveWidth, CalendarDisableHorizontalBorder;

		ShowMonthViewSwitchMenu();
		DefaultMonthView(byWeek : bool);
		TabOrder(tabs : [CalendarTab]);
		DefaultTab(tab : CalendarTab);
		TabColors(activeTabColor : MColor, nonActiveTabColor : MColor);
		HideAddEventButton();
		// It is possible to assign task for date only.
		HideTimeInfo();
		CloseDayPopupAfterAdditionalAction();
		// settings for dayEventsPopup, cols can be for text - "event type", "event description", "event title",
		// and for date and time - "start", "end"
		EventListSettings(cols : [string], showDate : bool, showTime : bool);
		//"%D" to date.day, "%M" to date.month, "%YYYY" to date.year, "%YY" to last two number of date.year
		//(like date2formatString)
		PlannedTableDateFormat(tableDateFormat : string);
		//autochoose text color - between black and white
		BlackAndWhiteTextColor();
		// Hide event types by default
		HiddenEventTypes(types : [string]);
		// Show days names in week view
		ShowWeekViewDaysNames();
		CalendarHeaderStyle(text : [MTextStyle], icon : [MIconStyle], background : [TGraphicsStyle], button : [MTextButtonStyle]);
		CalendarHeaderText(getText : (date : Date, tab : CalendarTab) -> Maybe<string>);
		CalendarHideEventTypesLegend();
		// Allows to get or set current date
		CalendarCurrentDate(currentDateB : DynamicBehaviour<Date>);
		CalendarShowTodayButton();
		CalendarHeaderTightWidth();
		CalendarHeaderAddEventButton(style : [MIconButtonStyle]);
		CalendarReadOnly(isReadOnlyB : Transform<bool>);
		// Show custom event view instead of default. If None - default view is displayed.
		// getView parameters:
		// CalendarTab - tab in which material is displayed
		// CalendarEvent - current event
		// CalendarEventDecription - current event type
		// Date - date of first event cell displayed
		// int - number of cells (dates) in which event is displayed
		// fn - get default view
		CalendarCustomEventView(getView : (CalendarTab, CalendarEvent, CalendarEventDecription, Date, int, (CalendarEvent) -> Material) -> Material);
		CalendarPrintable(style : [MIconButtonStyle]);
		// Show dropdown with views instead of tabs
		CalendarTabsDropdown();
		// Custom additional events view in month view
		// getView parameters:
		// int - number of additional events
		CalendarMonthAdditionalEventsView(getView : (int) -> Material);
		// Custom week days header in month, range and week views
		// getView parameters:
		// string - text to display
		// CalendarTab - tab in which material is displayed
		CalendarWeekDayView(getView : (string, CalendarTab) -> Material);
		// Custom day number header in month, range and week views
		// getView parameters:
		// string - text to display
		// bool - is today
		// bool - is weekend
		// CalendarTab - tab in which material is displayed
		CalendarDayNumberView(getView : (string, bool, bool, CalendarTab) -> Material);
		// Display previous and next month days in empty cells in month view
		// getTitleView parameters:
		// string - text to display
		// bool - is today
		// bool - is weekend
		CalendarMonthFillEmpty(getTitleView : (string, bool, bool) -> Material);
		// Custom events popup
		// open parameters:
		// int - range type: 0 - day, 1 - week, 2 - month
		// bool - is popup opened by clicking on a group of events (year day or "more events" in month tab)
		// Time - day for which popup is opened
		// [CalendarEvent] - day events
		CalendarEventsPopup(open : (int, bool, Time, [CalendarEvent]) -> void);
		// Hide number of events in year view
		CalendarYearHideEventsCount();
		CalendarCustomEventTitle(getTitle : (CalendarEvent, CalendarEventDecription) -> Material);
		CalendarEventsOpacities(past : Maybe<double>, current : Maybe<double>, future : Maybe<double>);
		CalendarCustomHeader(
			getView : (tab : CalendarTab, currentDateT : Transform<Date>, buttons : CalendarActionButtons) -> Maybe<Material>
		);
		CalendarHideContentFrame();
		CalendarScrolls(enable : bool);
		CalendarPlannedHideDeleteButton();
		// Check if event is read only
		CalendarReadOnlyEvent(isReadOnly : (CalendarEvent) -> Transform<bool>);
		// Enable pebble for views and print dialog
		CalendarPebbles(controller : PebbleController);
		// hide tabs/views dropdown
		CalendarHideTabs();
		// hide weekends in month, week & range (days) tabs
		CalendarHideWeekends();
		CalendarHideTimeInDayView();
		CalendarHideTimelineInDayView();
		// style for week adaptive width & scroll
		// minAvailableWidth - minimal available width to show scroll (default is 800.)
		// visibleWeekdays - visible weekday columns count (default is 5.4)
		CalendarWeekAdaptiveWidth(minAvailableWidth : double, visibleWeekdays : double);
		CalendarDisableHorizontalBorder();

		CalendarReadOnlyEventDialog(open : (int) -> void);
		CalendarCombinedEventsView(getCombinedEvents : (CalendarTab, [CalendarEvent]) -> [CalendarEvent], getView : (CalendarTab, [CalendarEvent], ([CalendarEvent]) -> void) -> Material);

	CalendarTab ::= YearTab, MonthTab, PlannedTab, RangeTab, WeekTab, DayTab;
		YearTab(); MonthTab(); PlannedTab(); RangeTab(); WeekTab(); DayTab();

	getCalendarTabId(tab : CalendarTab) -> string;
	getCalendarTabName(tab : CalendarTab) -> string;
	getCalendarTabById(tabId : string) -> Maybe<CalendarTab>;

	CalendarActionButtons : (
		addButton : Material,
		printButton : Material,
		tabsDropdown : Material,
		groupedByMenu : Material,
		todayButton : Material,
		prevPeriodButtons : Pair<Material, Material>,
		nextPeriodButtons : Pair<Material, Material>
	);
}

CalendarTabView(
	main : Material,
	getPrintPages : (availableSize : WidthHeight) -> [Material],
	overlay : Material
);

emptyEvent = CalendarEvent(Time(2050, 1, 1, 1, 1, 1), Time(2050, 1, 1, 1, 1, 1), 999, "_EMPTY_", "", "", makeTree());

calendarDateCellW = 32.0;
calendarDateCellH = 30.0;
calendarDateNavSize = 40.0;

calendarPickerWidthCells = calendarDateCellW * 7.0;
calendarPickerMarginCells = 12.0;
calendarMpickerWidth = calendarPickerWidthCells + calendarPickerMarginCells * 2.0;
isOnlyOneSameTypeEventsByDay = ref true;
isColorizeDayHeaders = ref true;
defaultCalendarHeaderStyle = CalendarHeaderStyle(
	[MWhite(), MCustomFont(20.0, "RobotoMedium", primarySmallTextOpacity)],
	[MIconSize(30.0), MCustomColor(0xFDB22B)],
	[Fill(black)],
	[MCustomColor(0xFDB22B)]
);

isDateEnable(
	thisDate : Date,
	dateMin : Date,
	dateMax : Date) -> bool {

	compareDates(thisDate, dateMin) != DateBefore()
	&& compareDates(thisDate, dateMax) != DateAfter()
}

timeYearCheck(start : int, end : int, year : int) -> bool {
	(start <= year && year <= end)
}

timeMonthCheck(start : Time, end : Time, current : Date) -> bool {
	if (start.year == end.year)
		(start.month <= current.month && current.month <= end.month)
	else if (current.year < end.year)
		if (current.year == start.year)
			(current.month >= start.month)
		else
			true
	else
		(current.month <= end.month)
}

timeDayCheck(start : Time, end : Time, current : Date, dayNumber : int) -> bool {
	if (start.month == end.month && start.year == end.year) //event in one month
		(start.day <= dayNumber && dayNumber <= end.day)
	else if (current.year < end.year) {     //event in two or more years
		if (current.year > start.year)      //in each year between start and end we need ALL days
			true
		else if (current.month > start.month) //in first year we need ALL days after first month
			true
		else                                //in first month we need ONLY days after start
			(dayNumber >= start.day)
	} else if (start.year != end.year) {    //in last year
		if (current.month < end.month)      //we need ALL days before end month
			true
		else
			(dayNumber <= end.day)          //in last month we need ALL days before last day
	} else if (current.month < end.month) {
		if (current.month == start.month)   //in start month we need ONLY days after start
		   (dayNumber >= start.day)
		else                                //in other we need ALL days
			true
	} else {                                //in last month we need ONLY days before end
		(dayNumber <= end.day)
	}
}

getMultiDayEvents(events : [CalendarEvent]) -> [CalendarEvent] {
	filter(events, \event -> time2date(event.startDate) != time2date(event.endDate))
}

sortEvents(events : [CalendarEvent]) -> [CalendarEvent] {
	timeSort = \event : CalendarEvent -> event.startDate;
	//Multi-day events should be earlier than usual, even if they go later.
	//Otherwise, the union between days will not work
	concat(
		sortCustom(getMultiDayEvents(events), timeSort, true),
		sortCustom(filter(events, \event -> time2date(event.startDate) == time2date(event.endDate)), timeSort, true)
	)
}

makeCalendarEventDescription() -> CalendarEventDecription {
	CalendarEventDecription("", MBlack(), MWhite(), "", nop1, nop1, nop1, [])
}

getEventTitleDefault(event : CalendarEvent) -> string {
	if (event.title != "") event.title else if (event.description != "") event.description else event.eventType
}

isTooltipEnabled(event : CalendarEvent) -> bool {
	event.description != "" && event.title != ""
}

getCalendarEventOpacity(event : CalendarEvent, opacities : CalendarEventsOpacities) -> double {
	type = getCalendarEventTimeType(event);
	if (isPastEventTimeType(type)) {
		either(opacities.past, 1.0);
	} else if (isFutureEventTimeType(type)) {
		either(opacities.future, 1.0);
	} else {
		either(opacities.current, 1.0);
	}
}

//like in DatePicker
CalendarCells(
	manager : MaterialManager,
	color : MThemeColor,
	month : Date,
	currentDate : DynamicBehaviour<Date>,
	dateMin : Date,
	dateMax : Date,
	isPrintingB : DynamicBehaviour<bool>,
	monthEvents : [CalendarEvent],
	monthNumber : DynamicBehaviour<int>,
	openPopupForDay : (date : Date, dayEvents : [CalendarEvent]) -> void,
	currentEventTypes : DynamicBehaviour<[CalendarEventDecription]>,
	hideEventsCount : bool,
	opacities : CalendarEventsOpacities,
	isReadOnlyB : Transform<bool>
) -> Material {
	firstDayInWeekOffset = 8 - ((1 + dayOfWeek(month)) % 7);
	dayOfWeekNames = map(enumFromTo(0, 6), \i -> {
		strLeft(dayOfWeekString(addDaysToDate(month, firstDayInWeekOffset + i), true), 1);
	});

	maxDayInMonth = 31;
	filteredByDay = generate(1, maxDayInMonth + 1, \dayNumber -> {
		allEvents = filter(monthEvents, \item -> timeDayCheck(item.startDate, item.endDate, month, dayNumber));
		sortEvents(allEvents)
	});

	startOffset = dayOfWeek(month) % 7;
	daysNum = getNumberOfDaysPerMonthInTheYear(month.year)[month.month];
	invisible = Point(0.0, calendarDateCellH * 6.0);
	offsets = generate(0, maxDayInMonth, \i -> {
		linearOffset = startOffset + i;
		if (i >= daysNum) invisible
		else Point(calendarDateCellW * i2d(linearOffset % 7), calendarDateCellH * i2d(linearOffset / 7))
	});

	todayDate = getCurrentDate();
	MLinesA([
		MCenterIn(
			MText(monthString(month, true), []),
			MFixed(calendarDateCellW * 7.0, calendarDateNavSize)
		),
		MColsA(map(dayOfWeekNames, \wday -> {
			MCenterIn(
				MText(wday, [MCaption()]),
				MFixed(calendarDateCellW, calendarDateCellH)
			)
		})),
		MGroup(mapi(offsets, \i, offset -> {
			MTranslate(
				const(offset),
				CalendarCell(manager, color, month, i + 1, currentDate, dateMin,
					dateMax, todayDate, isPrintingB, filteredByDay[i], monthNumber,
					openPopupForDay, currentEventTypes, hideEventsCount, opacities, isReadOnlyB
				)
			)
		}))
	]);
}

//like in DatePicker
CalendarCell(
	manager : MaterialManager,
	color : MThemeColor,
	thisMonth : Date,
	day : int,
	currentDate : DynamicBehaviour<Date>,
	dateMin : Date,
	dateMax : Date,
	todayDate : Date,
	isPrintingB : DynamicBehaviour<bool>,
	dayEvents : [CalendarEvent],
	monthNumber : DynamicBehaviour<int>,
	openPopupForDay : (date : Date, dayEvents : [CalendarEvent]) -> void,
	eventTypes : DynamicBehaviour<[CalendarEventDecription]>,
	hideEventsCount : bool,
	opacities : CalendarEventsOpacities,
	isReadOnlyB : Transform<bool>
) -> Material {
	thisDate = Date(getValue(currentDate).year, thisMonth.month, day);
	isEnabled = isDateEnable(thisDate, dateMin, dateMax);
	isHoverB = make(false);

	textColorB = if (isEnabled) {
		fselect2(isHoverB, isPrintingB, FLift2(\isHover, isPrinting -> {
			if (isHover || (thisDate == todayDate && dayEvents == [] && !isPrinting)) MWhite() else MBlack();
		}));
	} else {
		const(MGrey(500));
	}

	diam = 30.0;
	radius = diam / 2.0;
	bhoriz = if (day < 10) 11.0 else 7.5;
	text = MBorderA(bhoriz + 0.5, 7.8, bhoriz - 0.5, 7.8,
		MGroup2(
			MGetFocusGroup(\parent -> TSelectConstantMetrics(textColorB, \col ->
				MText2T(parent, i2s(day), [MCaptionSolid(), col])
			)),
			MFixed(if (day < 10) 8.0 else 15.0, 14.4)
		)
	);

	multiStart = \style -> {
		TGroup([
			TColsA([
				TFixed(radius, 0.),
				TRectangle(style, TFixed(radius + 2.0, diam)),
			]),
			LongSegment(radius, radius, radius, 180., 360., style) |> TForm
		])
	}

	multiStartWithStart = \mainStyle, secondStyle -> {
		TGroup([
			TColsA([
				TFixed(radius, 0.),
				TRectangle(mainStyle, TFixed(radius + 2.0, diam)),
			]),
			TGroup([
				Sector2(radius, radius, radius, 180., 360., secondStyle) |> TForm,
				Sector2(radius, radius, radius - 2., 180., 360., mainStyle) |> TForm
			])
		])
	}

	multiMiddle = \style -> {
		TRectangle(style, TFixed(diam + 2., diam))
	}

	multiMiddleWithStart = \mainStyle, secondStyle -> {
		TGroup([
			TRectangle(mainStyle, TFixed(diam + 2., diam)),
			TGroup2(
				Sector2(radius, radius, radius, 180., 360., secondStyle) |> TForm,
				Sector2(radius, radius, radius - 2., 180., 360., mainStyle) |> TForm
			)
		])
	}

	multiMiddleWithEnd = \mainStyle, secondStyle -> {
		TGroup([
			TRectangle(mainStyle, TFixed(diam + 2., diam)),
			TGroup2(
				Sector2(radius, radius, radius, 0., 180., secondStyle) |> TForm,
				Sector2(radius, radius, radius - 2., 0., 180., mainStyle) |> TForm
			)
		])
	}

	multiMiddleWithStartAndEnd = \mainStyle, startStyle, endStyle -> {
		TGroup([
			TRectangle(mainStyle, TFixed(diam + 2., diam)),
			TGroup2(
				Sector2(radius, radius, radius, 180., 360., startStyle) |> TForm,
				Sector2(radius, radius, radius - 2., 180., 360., mainStyle) |> TForm
			),
			TGroup2(
				Sector2(radius, radius, radius, 0., 180., endStyle) |> TForm,
				Sector2(radius, radius, radius - 2., 0., 180., mainStyle) |> TForm
			)
		])
	}

	multiEnd = \style -> {
		TGroup([
			TRectangle(style, TFixed(radius, diam)),
			LongSegment(radius, radius, radius, 0., 180., style) |> TForm
		])
	}

	multiEndWithEnd = \mainStyle, secondStyle -> {
		TGroup([
			TRectangle(mainStyle, TFixed(radius, diam)),
			TGroup([
				Sector2(radius, radius, radius, 0., 180., secondStyle) |> TForm,
				Sector2(radius, radius, radius - 2., 0., 180., mainStyle) |> TForm
			])
		])
	}

	multiEndWithStart = \mainStyle, secondStyle -> {
		TGroup([
			TColsA([
				TFixed(radius, 0.),
				TRectangle(secondStyle, TFixed(radius + 2.0, diam)),
			]),
			TRectangle(mainStyle, TFixed(radius, diam)),
			TGroup([
				Sector2(radius, radius, radius, 0., 180., mainStyle) |> TForm,
				Sector2(radius, radius, radius, 180., 360., secondStyle) |> TForm,
				Sector2(radius, radius, radius - 2., 180., 360., mainStyle) |> TForm
			])
		])
	}

	multiEndWithStartAndEnd = \mainStyle, startStyle, endStyle -> {
		TGroup([
			TColsA([
				TFixed(radius, 0.),
				TRectangle(startStyle, TFixed(radius + 2.0, diam)),
			]),
			TRectangle(mainStyle, TFixed(radius, diam)),
			TGroup([
				Sector2(radius, radius, radius, 0., 180., endStyle) |> TForm,
				Sector2(radius, radius, radius - 2., 0., 180., mainStyle) |> TForm,
				Sector2(radius, radius, radius, 180., 360., startStyle) |> TForm,
				Sector2(radius, radius, radius - 2., 180., 360., mainStyle) |> TForm
			])
		])
	}

	multiEndWithMiddleAndEnd = \mainStyle, middleStyle, endStyle -> {
		TGroup([
			TColsA([
				TFixed(radius, 0.),
				TRectangle(middleStyle, TFixed(radius + 2.0, diam)),
			]),
			TRectangle(mainStyle, TFixed(radius, diam)),
			TGroup([
				Sector2(radius, radius, radius, 0., 180., endStyle) |> TForm,
				Sector2(radius, radius, radius - 2., 0., 180., mainStyle) |> TForm
			])
		])
	}

	multiEndWithMiddleAndStart = \mainStyle, middleStyle, startStyle -> {
		TGroup([
			TColsA([
				TFixed(radius, 0.),
				TRectangle(middleStyle, TFixed(radius + 2.0, diam)),
			]),
			TRectangle(mainStyle, TFixed(radius, diam)),
			TGroup([
				Sector2(radius, radius, radius, 0., 180., mainStyle) |> TForm,
				Sector2(radius, radius, radius, 180., 360., startStyle) |> TForm,
				Sector2(radius, radius, radius - 2., 180., 360., mainStyle) |> TForm
			])
		])
	}

	multiEndWithMiddle = \mainStyle, secondStyle -> {
		TGroup([
			TColsA([
				TFixed(radius, 0.),
				TRectangle(secondStyle, TFixed(radius + 2.0, diam)),
			]),
			TRectangle(mainStyle, TFixed(radius, diam)),
			LongSegment(radius, radius, radius, 0., 180., mainStyle) |> TForm
		])
	}

	plusEventsBar = \number -> {
		if (!hideEventsCount) {
			MGroup([
				MColsA([
					MFixed(radius + 1.5, 0.),
					MGroup([
						Sector2(1.0, diam / 8.0 + 2., diam / 8.0 + 1.5, 0., 360., [Fill(black)]) |> TForm,
						MColsA([
							MFixed(diam / 16.0, 0.),
							TRectangle([Fill(black), FillOpacity(1.0)], TFixed(diam / 4.0, diam / 4.0 + 3.2)),
						]),
						MColsA([
							MFixed(diam / 16.0 + diam / 4.0, 0.),
							Sector2(0.0, diam / 8.0 + 2., diam / 8.0 + 1.5, 0., 360., [Fill(black)]) |> TForm,
						]),
						MCenterIn(
							MText("+" + i2s(number), [MWhite(), MCustomFont(9., "Roboto", primarySmallTextOpacity)]),
							MFixed(radius - 5., 0.0)
						)
					])
				]),
			]);
		} else {
			MEmpty();
		}
	}

	eventsCheck = \currentEventTypes -> {
		multiDayEvents = getMultiDayEvents(dayEvents);
		getEventTypeStyle = \event -> {
			fillColor = eitherMap(
				find(currentEventTypes, \type -> type.name == event.eventType),
				\type -> type.backColor,
				MGrey(300)
			);
			opacity = getCalendarEventOpacity(event, opacities);
			[MFill(fillColor), FillOpacity(opacity)]
		}

		if (length(multiDayEvents) > 0) {
			//events that started on this day
			startEvents : [CalendarEvent] = filter(multiDayEvents, \item -> time2date(item.startDate) == thisDate);

			//events that goes on this day
			middleEvents : [CalendarEvent] = filter(multiDayEvents, \item -> time2date(item.startDate) < thisDate && thisDate < time2date(item.endDate));

			//events that ended on this day
			endEvents : [CalendarEvent] = filter(multiDayEvents, \item -> time2date(item.endDate) == thisDate);

			firstEvent = multiDayEvents[0];
			//Depending on what event happens before we have 11 possible situations to display.
			//From simple "beginning", "middle", "end", then more complex combinations
			if (contains(startEvents, firstEvent)) {
				if (length(startEvents) >= 2) {
					firstStyle = getEventTypeStyle(firstEvent);
					secondStyle = getEventTypeStyle(startEvents[1]);

					MGroup2(
						multiStartWithStart(firstStyle, secondStyle),
						if (length(dayEvents) > 2) plusEventsBar(length(dayEvents) - 2) else TEmpty()
					);
				} else {
					firstStyle = getEventTypeStyle(firstEvent);

					MGroup2(
						multiStart(firstStyle),
						if (length(dayEvents) > 1) plusEventsBar(length(dayEvents) - 1) else TEmpty()
					);
				}
			} else if (contains(middleEvents, firstEvent)) {
				firstStyle = getEventTypeStyle(firstEvent);

				if (length(dayEvents) >= 3) {
					secondStyle = getEventTypeStyle(dayEvents[1]);
					thirdStyle = getEventTypeStyle(dayEvents[2]);

					if (contains(endEvents, dayEvents[1]) && contains(startEvents, dayEvents[2])) {
						MGroup2(
							multiMiddleWithStartAndEnd(firstStyle, thirdStyle, secondStyle),
							if (length(dayEvents) > 3) plusEventsBar(length(dayEvents) - 3) else TEmpty()
						)

					} else if (contains(startEvents, dayEvents[1])) {
						MGroup2(
							multiMiddleWithStart(firstStyle, secondStyle),
							if (length(dayEvents) > 2) plusEventsBar(length(dayEvents) - 2) else TEmpty()
						)

					} else if (contains(endEvents, dayEvents[1])) {
						MGroup2(
							multiMiddleWithEnd(firstStyle, secondStyle),
							if (length(dayEvents) > 2) plusEventsBar(length(dayEvents) - 2) else TEmpty()
						)

					} else {
						MGroup2(
							multiMiddle(firstStyle),
							if (length(dayEvents) > 1) plusEventsBar(length(dayEvents) - 1) else TEmpty()
						)
					}

				} else if (length(dayEvents) >= 2) {
					secondStyle = getEventTypeStyle(dayEvents[1]);
					if (contains(startEvents, dayEvents[1])) {
						MGroup2(
							multiMiddleWithStart(firstStyle, secondStyle),
							if (length(dayEvents) > 2) plusEventsBar(length(dayEvents) - 2) else TEmpty()
						)

					} else if (contains(endEvents, dayEvents[1])) {
						MGroup2(
							multiMiddleWithEnd(firstStyle, secondStyle),
							if (length(dayEvents) > 2) plusEventsBar(length(dayEvents) - 2) else TEmpty()
						)

					} else {
						MGroup2(
							multiMiddle(firstStyle),
							if (length(dayEvents) > 1) plusEventsBar(length(dayEvents) - 1) else TEmpty()
						)
					}

				} else {
					MGroup2(
						multiMiddle(firstStyle),
						if (length(dayEvents) > 1) plusEventsBar(length(dayEvents) - 1) else TEmpty()
					)
				}
			} else {
				firstStyle = getEventTypeStyle(firstEvent);

				if (length(dayEvents) >= 3) {
					secondStyle = getEventTypeStyle(dayEvents[1]);
					thirdStyle = getEventTypeStyle(dayEvents[2]);

					if (contains(endEvents, dayEvents[1]) && contains(startEvents, dayEvents[2])) {
						MGroup2(
							multiEndWithStartAndEnd(firstStyle, thirdStyle, secondStyle),
							if (length(dayEvents) > 3) plusEventsBar(length(dayEvents) - 3) else TEmpty()
						)

					} else if (contains(middleEvents, dayEvents[1]) && contains(endEvents, dayEvents[2])) {
						MGroup2(
							multiEndWithMiddleAndEnd(firstStyle, secondStyle, thirdStyle),
							if (length(dayEvents) > 3) plusEventsBar(length(dayEvents) - 3) else TEmpty()
						)

					} else if (contains(middleEvents, dayEvents[2]) && contains(endEvents, dayEvents[1])) {
						MGroup2(
							multiEndWithMiddleAndEnd(firstStyle, thirdStyle, secondStyle),
							if (length(dayEvents) > 3) plusEventsBar(length(dayEvents) - 3) else TEmpty()
						)

					} else if (length(middleEvents) > 0 && contains(endEvents, dayEvents[1])) {
						fourthStyle = getEventTypeStyle(middleEvents[0]);
						MGroup2(
							multiEndWithMiddleAndEnd(firstStyle, fourthStyle, secondStyle),
							if (length(dayEvents) > 3) plusEventsBar(length(dayEvents) - 3) else TEmpty()
						)

					} else if (contains(middleEvents, dayEvents[1]) && contains(startEvents, dayEvents[2])) {
						MGroup2(
							multiEndWithMiddleAndStart(firstStyle, secondStyle, thirdStyle),
							if (length(dayEvents) > 3) plusEventsBar(length(dayEvents) - 3) else TEmpty()
						)

					} else if (contains(startEvents, dayEvents[1])) {
						MGroup2(
							multiEndWithStart(firstStyle, secondStyle),
							if (length(dayEvents) > 2) plusEventsBar(length(dayEvents) - 2) else TEmpty()
						)

					} else if (contains(endEvents, dayEvents[1])) {
						MGroup2(
							multiEndWithEnd(firstStyle, secondStyle),
							if (length(dayEvents) > 2) plusEventsBar(length(dayEvents) - 2) else TEmpty()
						)

					} else if (contains(middleEvents, dayEvents[1])) {
						MGroup2(
							multiEndWithMiddle(firstStyle, secondStyle),
							if (length(dayEvents) > 2) plusEventsBar(length(dayEvents) - 2) else TEmpty()
						)
					} else if (length(middleEvents) > 0) {
						fourthStyle = getEventTypeStyle(middleEvents[0]);
						MGroup2(
							multiEndWithMiddle(firstStyle, fourthStyle),
							if (length(dayEvents) > 2) plusEventsBar(length(dayEvents) - 2) else TEmpty()
						)
					} else {
						MGroup2(
							multiEnd(firstStyle),
							if (length(dayEvents) > 1) plusEventsBar(length(dayEvents) - 1) else TEmpty()
						)
					}

				} else if (length(dayEvents) >= 2) {
					secondStyle = getEventTypeStyle(dayEvents[1]);

					if (contains(startEvents, dayEvents[1])) {
						MGroup2(
							multiEndWithStart(firstStyle, secondStyle),
							if (length(dayEvents) > 3) plusEventsBar(length(dayEvents) - 3) else TEmpty()
						)
					} else if (contains(endEvents, dayEvents[1])) {
						MGroup2(
							multiEndWithEnd(firstStyle, secondStyle),
							if (length(dayEvents) > 2) plusEventsBar(length(dayEvents) - 2) else TEmpty()
						)
					} else if (contains(middleEvents, dayEvents[1])) {
						MGroup2(
							multiEndWithMiddle(firstStyle, secondStyle),
							if (length(dayEvents) > 2) plusEventsBar(length(dayEvents) - 2) else TEmpty()
						)
					} else {
						MGroup2(
							multiEnd(firstStyle),
							if (length(dayEvents) > 1) plusEventsBar(length(dayEvents) - 1) else TEmpty()
						)
					}

				} else {
					MGroup2(
						multiEnd(firstStyle),
						if (length(dayEvents) > 1) plusEventsBar(length(dayEvents) - 1) else TEmpty()
					)
				}
			}
		} else {
			style = getEventTypeStyle(dayEvents[0]);
			MGroup2(
				TCircle(radius, style),
				if (length(dayEvents) > 1) plusEventsBar(length(dayEvents) - 1) else TEmpty()
			)
		}
	}

	bubble = MGroup2(
		if (length(dayEvents) > 0) {
			MSelect(eventTypes, \types -> eventsCheck(types));
		} else if (todayDate != thisDate) {
			MEmpty()
		} else {
			MShow(fnot(isPrintingB), MCircle(radius, [MThemeFill(manager, color)]))
		},
		text
	);

	bubbleAnimated = if (manager.theme.enableAnimations) {
		MCopySize(
			bubble,
			\m -> MGetFocusGroup(\parent -> MRipple2T(manager, parent, m, isHoverB, [MRippleColor(const(color)), MRippleType(const(MRippleCenter()))])),
			false
		);
	} else {
		MGroup2(
			MVisible(isHoverB, MCircle(radius, [MThemeFill(manager, color), FillOpacity(0.5)])),
			bubble
		);
	}

	click2 = \-> if (isEnabled) {
		nextDistinct(monthNumber, thisMonth.month);
		nextDistinct(currentDate, thisDate);
		openPopupForDay(thisDate, dayEvents);
	} else {
		println("this day not available!");
	}

	bubbleClickable = MGroup2(
		MComponent(
			[MOnClick(click2), THovering(isHoverB)],
			\__ -> MFrame(0.0, 0.0, [Fill(green), FillOpacity(0.0)], bubbleAnimated)
		),
		TCursor(FingerCursor(), TRectangle([Fill(white), FillOpacity(0.0)], TFixed(calendarDateCellW, calendarDateCellH)))
	);

	MSize(
		MFixed(calendarDateCellW, calendarDateCellH),
		if (isEnabled) bubbleClickable else text
	);
}

//Small popup to confirm deletion
eventDeletePopup(
	cancelAction : () -> void,
	okAction : () -> void
	) -> Material {

	//fontsSizes
	littleFontSize = MBody();
	mediumFontSize = MSubheading();
	bigBoldFontSize = MCustomFont(20., "RobotoMedium", primaryTextOpacity);
	buttonFontSize = bigBoldFontSize;
	//colors
	veryLightGrey = MGrey(50);
	lightGrey = MGrey(200);
	mediumGrey = MGrey(600);
	notSoDarkGrey = MGrey(700);
	darkGrey = MGrey(800);

	title = MColsA([
		TFixed(25., 0.),
		MCenterIn(
			MText(_("Are you sure?"), [bigBoldFontSize]),
			TFixed(330., 80.)
		),
		TFixed(25., 0.),
	]);

	footer = MColsA([
		TFixed(25., 0.),
		MCenterYIn(
			MColsA([
				MCard(
					[
						MRichMediaBlock(
							MCenter(
								MText(_("CANCEL"), [buttonFontSize, MWhite()])
							),
						[])
					],
					[MCardHeight(50.), MCardWidth(150.0), MContentBorders(false), mediumGrey],
					[MOnClick(cancelAction)]
				),
				TFixed(20., 0.),
				MCard(
					[
						MRichMediaBlock(
							MCenter(
								MText(_("DELETE"), [buttonFontSize])
							),
						[])
					],
					[MCardHeight(50.), MCardWidth(150.0), MContentBorders(false), MCustomColor(0xFDB22B)],
					[MOnClick(okAction)]
				),
			]),
			TFixed(0., 80.)
		),
		TFixed(25., 0.)
	]);

	MGroup([
		TRectangle([Fill(white), FillOpacity(1.0)], TFixed(380., 160.)),
		MLinesA([
			title,
			footer
		])
	])
}

dayEventsPopup(
	curDate : Date,
	dayEventsStatic : [CalendarEvent],
	eventTypesB : DynamicBehaviour<[CalendarEventDecription]>,
	manager : MaterialManager,
	choosedFilters : [string],
	rangeType : int, // 0 - day, 1 - week, 2 - month
	isGroupOfEvents : bool,
	styles : [CalendarForEventsStyle]
	) -> void {

	listSettings = extractStruct(styles, EventListSettings(["event any text", "start", "end"], false, true));
	colsToShow = listSettings.cols;
	showDate = listSettings.showDate;
	showTime = listSettings.showTime;
	showStart = contains(colsToShow, "start");
	showEnd = contains(colsToShow, "end");
	closePopupAfterAdditionalAction = containsStruct(styles, CloseDayPopupAfterAdditionalAction());
	isReadOnly = fgetValue(extractStruct(styles, CalendarReadOnly(const(false))).isReadOnlyB);
	customPopupM = tryExtractStruct(styles, CalendarEventsPopup(nop4));
	isReadOnlyEvent = extractStruct(styles, CalendarReadOnlyEvent(\__ -> const(false))).isReadOnly;

	close = make(false);
	dayEvents = make(dayEventsStatic);

	curTime = stamp2time(timestamp());
	dayNumber = curDate.day;
	monthNumber = curDate.month;

	roundTime = \time -> {
		roundInterval = 30;
		roundedMinutes = (time.min / roundInterval + 1) * roundInterval;
		flooredTime = Time(time with min = 0, sec = 0);
		stamp2time(time2stamp(flooredTime) + min2ms(roundedMinutes));
	}
	dateForAdd = roundTime(Time(curDate.year, curDate.month, curDate.day, curTime.hour, curTime.min, curTime.sec));

	textCols = ["event type", "event description", "event title"];
	dateCols = ["start", "end"];
	additionalCols = subtractA(colsToShow, concat(textCols, dateCols));

	dateExpandingFactor = 1.65;

	getDateWidth = \-> {
		if ((showDate && showTime) && (showStart && showEnd)) dateExpandingFactor
		else b2d((showDate || showTime) && (showStart || showEnd))
	}

	getTextWidth = \-> {
		if (length(colsToShow) == 0 || contains(colsToShow, "event any text")) 1.
		else i2d(length(intersection(colsToShow, textCols)))
	}

	additionalColsWidth = i2d(length(additionalCols)) * 166.;

	lineWidth = 264. + getTextWidth() * 276. + getDateWidth() * 156. + additionalColsWidth;
	popupWidth = lineWidth + 85.;
	titleHeight = 60.;
	lineHeight = 88.;
	buttonHeight = 70.;

	leftOffset = TFixed(40., 0.);
	iconBox = TFixed(100., lineHeight);
	nameBox = TFixed(260., lineHeight);
	additionalColBox = TFixed(150., lineHeight);
	editButtonBox = TFixed(44., lineHeight);
	deleteButtonBox = TFixed(70., lineHeight);
	timeBox = TFixed(getDateWidth() * 156., lineHeight);

	mediumFont = MCustomFont(18., "RobotoMedium", primaryTextOpacity);
	normalFont = MCustomFont(18., "Roboto", primaryTextOpacity);
	littleFont = MBody();

	centeredTitleText = \text -> MCenterIn(MText(text, [mediumFont, MGrey(800)]), TFillXH(titleHeight));

	titleText = if (rangeType == 0) {
		MColsA([
			MCenterYIn(
				MText(i2s(dayNumber) + " " + monthString(curDate, true), [mediumFont, MGrey(800)]),
				TFixed(100., titleHeight)
			),
			TFillX(),
			MCenterYIn(
				MParagraph(dayOfWeekString(curDate, true), [littleFont, MGrey(800), RightAlign(), MWidth(80.)]),
				TFixed(80., titleHeight)
			),
		])
	}   else if (rangeType == 1) centeredTitleText(i2s(getWeekOfYear(curDate, 0, true)))
		else centeredTitleText(monthString(curDate, true));

	addLeftOffset = \m : Material -> MCols2A(leftOffset, m);

	title = MGroup([
		TRectangle([MFill(MGrey(200))], TFixed(popupWidth, titleHeight)),
		MFixSize(
			addLeftOffset(MCols2A(
				titleText,
				MCenterYIn(
					MIconButton("close",
						\ -> next(close, true),
						[MBlack(), MIconSize(20.)],
						[MShortcut("esc")]
					),
					TFixed(20., 55.)
				)
			)),
			TFixed(popupWidth, titleHeight)
		)
	]);

	separatorLine = TRectangle([Fill(grey), FillOpacity(0.7)], TFixed(lineWidth, 0.5));

	//line with "empty" icon and text
	emptyLine = MLines2A(
		MCols2A(
			MBorderA(0., 0., 8., 0., MCenterYIn(TCircle(28., [Fill(grey)]), TFixed(70., lineHeight))),
			MCenterYIn(MText(_("No added events"), [normalFont]), TFixed(100., lineHeight))
		),
		separatorLine
	);

	makeTextCol = \text : string, boxSize : Material -> {
		MBorderA(8., 0., 8., 0.,
			MFixSize(MCenterY(MEllipsisText(text, [mediumFont, MShowTooltip(const(true)), MMaxLines(2)])), boxSize)
		);
	}

	getEventTitle = extractStruct(styles, CalendarCustomEventTitle(\event : CalendarEvent, __ -> {
		makeNameTextCol = \text : string -> makeTextCol(text, nameBox);
		MColsA([
			if (contains(colsToShow, "event any text")) makeNameTextCol(getEventTitleDefault(event)) else MEmpty(),
			if (contains(colsToShow, "event type") || (length(colsToShow) == 0 && event.title == "")) makeNameTextCol(event.eventType) else MEmpty(),
			if (contains(colsToShow, "event title") || (length(colsToShow) == 0 && event.title != "")) makeNameTextCol(event.title) else MEmpty(),
			if (contains(colsToShow, "event description")) makeNameTextCol(event.description) else MEmpty()
		])
	})).getTitle;

	makeTextCols = \event : CalendarEvent -> {
		eventTypeB = fselect(eventTypesB, FLift(\eventTypes -> findDef(eventTypes, \p -> p.name == event.eventType, makeCalendarEventDescription())));
		MSelect(eventTypeB, \eventType -> getEventTitle(event, eventType));
	}

	makeAdditionalCols = \event : CalendarEvent -> {
		MColsA(map(additionalCols, \col -> makeTextCol(lookupTreeDef(event.additionalFields, col, ""), additionalColBox)))
	}

	makeDateCol = \event : CalendarEvent -> {
		getDateText = \dt : Time -> {
			timeString = lpad(getTimeOnlyString(dt, false, false), "0", 5);
			dateString = date2formatString(time2date(dt), "%DD.%MM.%YY");
			if (showDate && showTime) dateString + " " + timeString
			else if (showDate) dateString
			else if (showTime) timeString
			else ""
		}
		text = if (showStart && showEnd) getDateText(event.startDate) + " - " + getDateText(event.endDate)
			else if (showStart) getDateText(event.startDate)
			else if (showEnd) getDateText(event.endDate)
			else "";
		if (text != "" && text != " - ") MFixSize(MCenterY(MEllipsisText(text, [normalFont, MShowTooltip(const(true))])), timeBox)
		else MEmpty()
	}

	makeAddButtonsMenu = \event, eventType -> {
		mainButton = MIconButton("more_horiz",
			nop,
			[MIconSize(22.), MGrey(700)],
			[]
		);

		items = map(eventType.additionalActions, \act -> {
			MMenuCustomLine(
				MColsA([
					MCenterYIn(
						MIcon(act.icon, [MIconSize(22.)]),
						TFixed(50., 44.)
					),
					MCenterYIn(
						MText(act.name, [normalFont]),
						TFixed(0., 44.)
					)
				]),
			[])
		});

		MCenterYIn(
			MMenu(
				mainButton,
				items,
				[MOnListClick(const(true), \index -> eventType.additionalActions[index].action(event.id))]
			),
			editButtonBox
		)
	}

	makeAddButtonsCol = \event : CalendarEvent, eventType : CalendarEventDecription -> {
		if (length(eventType.additionalActions) > 0) {
			if (length(eventType.additionalActions) == 1) {
				MCenterYIn(
					MIconButton(eventType.additionalActions[0].icon,
						\-> {
							eventType.additionalActions[0].action(event.id);
							if (closePopupAfterAdditionalAction) next(close, true);
						},
						[MIconSize(22.), MGrey(700)],
						[]
					),
					editButtonBox
				)
			} else makeAddButtonsMenu(event, eventType)
		} else editButtonBox
	}

	makeEditButton = \event : CalendarEvent, eventType : CalendarEventDecription -> {
		MIf(fOr(const(isReadOnly), isReadOnlyEvent(event)),
			MEmpty(),
			MCenterYIn(
				MIconButton("mode_edit",
					\-> {
						eventType.editAction(event.id);
						next(close, true);
					},
					[MGrey(700), MIconSize(22.)],
					[]
				),
				editButtonBox
			)
		);
	}

	makeDeleteButton = \event : CalendarEvent, eventType : CalendarEventDecription -> {
		MIf(fOr(const(isReadOnly), isReadOnlyEvent(event)),
			MEmpty(),
			MCenterYIn(
				MIconButton("delete",
					\-> {
						popupClose = make(false);
						ShowMDialog(manager, popupClose, [],
							eventDeletePopup(
								\-> next(popupClose, true),
								\-> {
									next(popupClose, true);
									evIndexInDay = either(findi(getValue(dayEvents), \p -> p.id == event.id), -1);
									if (evIndexInDay != -1) next(dayEvents, removeIndex(getValue(dayEvents), evIndexInDay));
									eventType.deleteAction(event.id);
								}
							)
						);
					},
					[MGrey(700), MIconSize(22.)],
					[]
				),
				deleteButtonBox
			)
		);
	}

	makeAvatar = \eventType : CalendarEventDecription -> {
		MCenterYIn(
			MAvatar(eventType.icon, [MIconSize(56.0)]),
			iconBox
		)
	}

	//line with icon, event name, event time and buttons for edit and delete
	eventLine = \event : CalendarEvent, eventType : CalendarEventDecription -> {
		MLines2A(
			MColsA([
				makeAvatar(eventType),
				makeTextCols(event),
				makeAdditionalCols(event),
				makeDateCol(event),
				editButtonBox,
				makeAddButtonsCol(event, eventType),
				makeEditButton(event, eventType),
				makeDeleteButton(event, eventType)
			]),
			separatorLine
		);
	}

	eventAddButton = \evType ->  {
		MLines2A(
			MClickable(
				MGroup([
					MCenterYIn(
						MShadow(const(4.0),
							MFrame(2., 2., [MFill(MGrey(200))], TFixed(lineWidth, buttonHeight))
						),
						TFixed(0., buttonHeight)
					),
					MCenterIn(
						MFrame(2., 2., [MFill(evType.backColor)], TFixed(lineWidth - 2., buttonHeight - 2.)),
						TFixed(lineWidth, buttonHeight)
					),
					MCenterIn(
						MText(_("ADD") + " " + toUpperCase(evType.name), [mediumFont, evType.mainColor]),
						TFixed(lineWidth, buttonHeight)
					)
				]),
				\ -> {
					evType.addAction(dateForAdd);
					next(close, true)
				}
			),
			TFixed(popupWidth - 40., 20.)
		)
	};

	popup = MLines2A(
		MShadow(const(4.0), title),
		MSelect2(dayEvents, eventTypesB, \events, eventTypes -> {
			notAddedEvents = if (^isOnlyOneSameTypeEventsByDay)
					filter(eventTypes, \ev -> {
						evIndexInDay = findiDef(getValue(dayEvents), \p -> p.eventType == ev.name, -1);
						evIndexInDay == -1 && !contains(choosedFilters, ev.name)
					})
				else
					eventTypes;

			eventsList : Material = if (length(events) == 0)
					emptyLine
				else MLinesA(
					filtermap(events, \dayEvent -> {
						eventTypeIndex = findiDef(eventTypes, \p -> p.name == dayEvent.eventType, -1);
						if (eventTypeIndex != -1) Some(eventLine(dayEvent, eventTypes[eventTypeIndex])) else None()
					})
				);

			content = MLet(
				"m",
				MLinesA([
					eventsList,
					TRectangle([Fill(white)], TFixed(popupWidth - 40., 40.)),
					MLinesA(map(notAddedEvents,
						\notAddedEvent ->
							if (notAddedEvent.addAction == nop1 || isReadOnly) MEmpty()
							else eventAddButton(notAddedEvent)
						)
					)
				]),
				MAttach(MGhost("m"), \formMetrics -> MGroup2(
					TSizedHeight(popupWidth, formMetrics.height)
					|> addTBackground(MWhite()),
					addLeftOffset(MDisplay("m"))
				))
			);

			MScroll(
				content,
				TFillWY(popupWidth),
				[TScrollbars(invisibleScrollBar, standardScrollBar), MScrollCropByContent(), MScrollDisableOutOfBounds(const(true))]
			)
		}),
	);

	eitherFn(customPopupM, \customPopup -> {
		customPopup.open(rangeType, isGroupOfEvents, dateForAdd, dayEventsStatic);
	}, \ -> {
		ShowMDialog(
			manager,
			close,
			[MDialogClickOutToClose(), MDialogScroll()],
			MShadow(const(20.0), popup)
		);
	});
}

makeLineOfDaysBlockForMonthView(
	startIndex : int,
	getOtherMonthDay : (int) -> Material,
	daysBlock : [Material],
	hideWeekends : bool,
	result : [Material],
) -> [Material] {

	blocksLength = length(daysBlock);

	if (startIndex >= blocksLength) {
		result
	} else {
		newLine = MColsA(
			generate(startIndex, startIndex + if (hideWeekends) 5 else 7, \blockIndex -> {
				i = blockIndex - blocksLength;
				if (i < 0) {
					daysBlock[blockIndex];
				} else {
					getOtherMonthDay(i + 1);
				}
			})
		);
		makeLineOfDaysBlockForMonthView(startIndex + 7, getOtherMonthDay, daysBlock, hideWeekends, arrayPush(result, newLine))
	}
}

//create cards with events for each day in current month
MonthTable(
	currentEvents : DynamicBehaviour<[CalendarEvent]>,
	eventTypesB : DynamicBehaviour<[CalendarEventDecription]>,
	currentDateB : DynamicBehaviour<Date>,
	dateMin : Date,
	dateMax : Date,
	manager : MaterialManager,
	maxDisplayedEventsInOneDay : int,
	choosedFilters : DynamicBehaviour<[string]>,
	isMobileViewB : Transform<bool>,
	isPrintingB : DynamicBehaviour<bool>,
	styles : [CalendarForEventsStyle]
) -> CalendarTabView {
	minHeight = 26.0;
	maxHeight = minHeight * 3.0;

	lineBox =                                  TFillXYXY(50., minHeight, 141.5 * 5., maxHeight);
	lineBoxForBlockWithEvent =                 TFillXYXY(50., minHeight, 138.5 * 5., maxHeight);
	lineBoxForBlockWithFirstMultiDayEvent =    TFillXYXY(50., minHeight, 140.0 * 5., maxHeight);
	lineBoxForBlockWithNotFirstMultiDayEvent = TFillXYXY(50., minHeight, 141.5 * 5., maxHeight);
	lineBoxForBlockWithFirstMultiDayEvent2 =   TFillXYXY(50., minHeight, 140.0 * 5., maxHeight);
	blankDaySize =                             TFillXYXY(50., minHeight, 141.5 * 5., minHeight);

	showMonthSwitchView = contains(styles, ShowMonthViewSwitchMenu());
	isUseMTextMColor = contains(styles, BlackAndWhiteTextColor());
	byWeekViewB = make(extractStruct(styles, DefaultMonthView(true)).byWeek);
	hideTimeInfo = contains(styles, HideTimeInfo());
	calendarHeaderStyle = extractStruct(styles, defaultCalendarHeaderStyle);
	isReadOnlyB = extractStruct(styles, CalendarReadOnly(const(false))).isReadOnlyB;
	isReadOnlyEvent = extractStruct(styles, CalendarReadOnlyEvent(\__ -> const(false))).isReadOnly;
	getEventView = extractStruct(styles, CalendarCustomEventView(\__, e, __, __, __, getDefaultView -> getDefaultView(e))).getView;
	getWeekDay = extractStruct(styles, CalendarWeekDayView(\dayName, __ -> MCenterIn(MText(dayName, []), MFillXH(58.0)))).getView;
	otherMonthViewM = tryExtractStruct(styles, CalendarMonthFillEmpty(\__, __, __ -> MEmpty()));
	opacities = extractStruct(styles, CalendarEventsOpacities(None(), None(), None()));
	isDynamicNumberOfEvents = maxDisplayedEventsInOneDay == -1;
	enableScrolls = extractStruct(styles, CalendarScrolls(true)).enable;
	hideWeekends = contains(styles, CalendarHideWeekends());
	openReadOnlyDialog = extractStruct(styles, CalendarReadOnlyEventDialog(nop1)).open;
	// TODO: display combined events
	combinedEventsView = extractStruct(styles, CalendarCombinedEventsView(\__, __ -> [], \__, __, __ -> MEmpty()));

	weekDayHeightB = make(0.0);
	dayTitleHeightB = make(0.0);
	eventRowHeightB = make(0.0);
	availableHeightB = make(0.0);
	maxDisplayedEventsInOneDayB = make(if (maxDisplayedEventsInOneDay <= 0) CalendarDefaultDisplayedEventsInOneDay else maxDisplayedEventsInOneDay);
	multiDayEventsPosition = make([]);

	defaultAdditionalEventsView = \count -> {
		MGroup2(
			MFrame(0.0, 0.0, [MFill(MGrey(400)), FillOpacity(1.0)], lineBox),
			MCenterIn(MText(i2s(count) + _("+ events"), [MWhite()]), lineBox)
		);
	}
	getAdditionalEventsView = extractStruct(styles, CalendarMonthAdditionalEventsView(defaultAdditionalEventsView)).getView;
	isMultiDay = \e -> (time2date(e.startDate) != time2date(e.endDate));

	calendarDayTouch = \item : CalendarEvent, dayDate : Date -> {
		eventTypeB = fselect(eventTypesB, FLift(\eventTypes -> findDef(eventTypes, \p -> p.name == item.eventType, makeCalendarEventDescription())));
		getEventTitle = extractStruct(styles, CalendarCustomEventTitle(\e, t -> {
			eventTime = if (hideTimeInfo) "" else i2s(e.startDate.hour) + ":" + substring(time2string(time2stamp2(e.startDate)), 14, 2) + "   ";
			eventText = if (!isMultiDay(e)) {
				eventTime + getEventTitleDefault(e)
			} else if (dayDate == time2date(e.startDate) || dayOfWeek(dayDate) == 0) {
				getEventTitleDefault(e)
			} else {
				" ";
			}
			textColor = if (isUseMTextMColor) MTextMColor(t.mainColor) else t.mainColor;
			MEllipsisText(eventText, [textColor, MFullWidth()]);
		})).getTitle;

		MShowLazy(fselect(eventTypeB, FLift(\eventType -> eventType.name != "")), \ -> {
			getDefaultView = \e : CalendarEvent -> {
				backColorB = fselect(eventTypeB, FLift(\eventType -> eventType.backColor));
				eventsOpacity = getCalendarEventOpacity(e, opacities);
				MGroup([
					if (!isMultiDay(e)) {
						MGroup2(
							TRectangle([Fill(white), FillOpacity(eventsOpacity)], lineBox),
							MCenterIn(
								MSelect(backColorB, \backColor -> TRectangle([MFill(backColor), FillOpacity(eventsOpacity)], lineBoxForBlockWithEvent)),
								lineBox
							)
						)
					} else {
						if (dayDate == time2date(e.startDate)) {
							MGroup2(
								TRectangle([Fill(white), FillOpacity(eventsOpacity)], lineBox),
								MColsA([
									TFixed(1.5, 0.),
									MCenterYIn(
										MSelect(backColorB, \backColor -> TRectangle([MFill(backColor), FillOpacity(eventsOpacity)], lineBoxForBlockWithFirstMultiDayEvent)),
										lineBoxForBlockWithFirstMultiDayEvent2
									)
								])
							)
						} else if (dayDate == time2date(e.endDate)) {
							MGroup2(
								TRectangle([Fill(white), FillOpacity(eventsOpacity)], lineBox),
								MColsA([
									MCenterYIn(
										MSelect(backColorB, \backColor -> TRectangle([MFill(backColor), FillOpacity(eventsOpacity)], lineBoxForBlockWithFirstMultiDayEvent)),
										lineBoxForBlockWithFirstMultiDayEvent2
									),
									TFixed(1.5, 0.),
								])
							)
						} else {
							MGroup2(
								TRectangle([Fill(white), FillOpacity(eventsOpacity)], lineBox),
								MCenterYIn(
									MSelect(backColorB, \backColor -> TRectangle([MFill(backColor), FillOpacity(eventsOpacity)], lineBoxForBlockWithNotFirstMultiDayEvent)),
									lineBox
								),
							)
						}
					},
					MTooltip(
						MCenterIn(
							MSelect(eventTypeB, \eventType -> getEventTitle(e, eventType)) |> MBorderLeftRight(2.0),
							lineBox
						),
						MText(e.description, []),
						[MEnabled(const(isTooltipEnabled(e)))]
					),
				]);
			}

			isEditAllowedT = fand(fnot(isReadOnlyEvent(item)), fand(fnot(isReadOnlyB), fselect(eventTypeB, FLift(\et -> et.editAction != nop1))));
			onClick = \ -> {
				if (fgetValue(isEditAllowedT)) {
					fgetValue(eventTypeB).editAction(item.id);
				} else {
					openReadOnlyDialog(item.id);
				}
			}
			MComponent(
				[MOnClick(onClick), MEnabled(fOr(const(openReadOnlyDialog != nop1), isEditAllowedT))],
				\__ -> {
					MSelect(eventTypeB, \eventType -> {
						getEventView(MonthTab(), item, eventType, dayDate, 1, getDefaultView) |> MFixWidth(getDefaultView(item))
					});
				}
			);
		});
	}

	openDayEventsPopup = \date, isEnable, events : [CalendarEvent], isGroupOfEvents -> {
		if (isEnable) dayEventsPopup(date, events, eventTypesB, manager, getValue(choosedFilters), 0, isGroupOfEvents, styles);
	}

	ifAttachHeight = \material, cond, heightB -> if (cond) MAttachHeight(material, heightB) else material;

	makeTitle = \eventColor, date, isEnable, events : [CalendarEvent] -> MComponent(
		[MOnClick(\-> openDayEventsPopup(date, isEnable, events, false)), MEnabled(fnot(isReadOnlyB))],
		\__ -> {
			getView = extractStruct(styles, CalendarDayNumberView(\dayNumber, __, __, __ -> {
				MGroup2(
					TRectangle([MFill(eventColor)], lineBox),
					MCenterIn(MText(dayNumber, [MWhite()]), lineBox)
				);
			})).getView;

			dayNumber = i2s(date.day);
			isWeekend = dayOfWeek(date) > 5;
			currentDate = getValue(currentDateB);
			isCurrentMonth = date.year == currentDate.year && date.month == currentDate.month;

			isTodayB = fand(const(compareDates(date, getCurrentDate()) == DateEqual()), fnot(isPrintingB));
			ifAttachHeight(
				MSelect(isTodayB, \isToday -> {
					if (isCurrentMonth) {
						getView(dayNumber, isToday, isWeekend, MonthTab());
					} else {
						eitherMap(otherMonthViewM, \otherMonthView -> {
							otherMonthView.getTitleView(dayNumber, isToday, isWeekend);
						}, getView(dayNumber, isToday, isWeekend, MonthTab()));
					}
				}) |> MSetAddFillers(const(false)),
				currentDate == date,
				dayTitleHeightB
			);
		}
	);

	makeEmptyBlock = \date, isEnable, events : [CalendarEvent] -> MComponent(
		[MOnClick(\-> openDayEventsPopup(date, isEnable, events, false)), MEnabled(fnot(isReadOnlyB))],
		\__ -> MSizeOf(getEventView(MonthTab(), emptyEvent, makeCalendarEventDescription(), date, 1, \__ -> lineBox))
	);

	makeAdditionalEventsBlock = \additionalEventsCount, date, isEnable, events : [CalendarEvent] -> MComponent(
		[MOnClick(\-> openDayEventsPopup(date, isEnable, events, true))],
		\__ -> getAdditionalEventsView(additionalEventsCount) |> MSetAddFillers(const(false))
	);

	getDayMaxEvents = \date, rowsEventsCount -> {
		countM = find(rowsEventsCount, \count -> {
			date >= count.first && date <= count.second;
		});
		eitherMap(countM, thirdOfTriple, 1);
	}

	// "Empty" day consists of a header with the number of the day and maxDisplayedEventsInOneDay empty units.
	// By clicking on the card - opens a window with a choice of added events
	makeEmptyCalendarDay = \dayDate, isEnable, rowsEventsCount -> {
		MLines2A(
			makeTitle(MGrey(600), dayDate, isEnable, []),
			MSelect2(maxDisplayedEventsInOneDayB, isPrintingB, \maxDisplayedEvents, isPrinting -> {
				maxEvents = if (isPrinting) getDayMaxEvents(dayDate, rowsEventsCount) else maxDisplayedEvents;
				MLinesA(generate(0, maxEvents, \i -> {
					ifAttachHeight(
						makeEmptyBlock(dayDate, isEnable, []),
						i == 0 && dayDate == getValue(currentDateB),
						eventRowHeightB
					);
				}));
			})
		);
	}

	// "NotEmpty" day consists of a header with a background color number of the day of the first (in time) of the event,
	// as well as maxDisplayedEventsInOneDay blocks of the events.
	// If the event is less than maxDisplayedEventsInOneDay  - fill the "empty" blocks
	makeNotEmptyCalendarDay = \dayDate, events : [CalendarEvent], isEnable, rowsEventsCount -> {
		eventTypes = getValue(eventTypesB);
		MSelect2(maxDisplayedEventsInOneDayB, isPrintingB, \maxDisplayedEvents, isPrinting -> {
			maxEvents = if (isPrinting) getDayMaxEvents(dayDate, rowsEventsCount) else maxDisplayedEvents;
			fullDayEvents = if (length(events) < maxEvents) {
				concat(events, generate(0, maxEvents - length(events), \__ -> emptyEvent))
			} else {
				events
			};

			getAdditionalNonEmptyEvents = \newEvents -> {
				foldi(newEvents, 0, \i, res, e -> {
					if (i >= maxEvents - 1 && e.eventType != "_EMPTY_") res + 1 else res
				});
			}

			newEvents = checkOneDayEventsPosition(fullDayEvents, maxEvents, multiDayEventsPosition);
			notEmptyEventIndex = either(findi(newEvents, \p -> p.eventType != "_EMPTY_"), -1);
			eventIndex = if (notEmptyEventIndex != -1) {
				either(findi(eventTypes, \p -> p.name == newEvents[notEmptyEventIndex].eventType), -1);
			} else {
				-1;
			}

			eventColor = if (!^isColorizeDayHeaders) {
				MGrey(600);
			} else if (eventIndex != -1) {
				eventTypes[eventIndex].mainColor;
			} else {
				MWhite();
			}

			eventsCount = length(newEvents);
			MLines2A(
				makeTitle(eventColor, dayDate, isEnable, events),
				MLinesA(mapi(take(newEvents, maxEvents), \i, e -> {
					ifAttachHeight(
						if (i == maxEvents - 1 && eventsCount > maxEvents) {
							makeAdditionalEventsBlock(getAdditionalNonEmptyEvents(newEvents), dayDate, isEnable, events)
						} else if (e.eventType != "_EMPTY_") {
							calendarDayTouch(e, dayDate)
						} else {
							makeEmptyBlock(dayDate, isEnable, events)
						},
						dayDate == getValue(currentDateB) && i == 0 && isDynamicNumberOfEvents,
						eventRowHeightB
					);
				}))
			);
		});
	}

	//if day consists 0 events or this day is not available - show emptyDay
	makeCalendarDay = \dayDate, events : [CalendarEvent], isEnable, rowsEventsCount -> {
		calendarDayM = if (length(events) > 0 && isEnable) {
			makeNotEmptyCalendarDay(dayDate, events, isEnable, rowsEventsCount)
		} else {
			makeEmptyCalendarDay(dayDate, isEnable, rowsEventsCount)
		}
		separatorM = MSeparator(false) |> MFixHeight(calendarDayM);
		MGroup2(
			MFillX(),
			MColsA([
				if (dayOfWeek(dayDate) == 0) separatorM else MEmpty(),
				calendarDayM,
				separatorM
			])
		);
	}

	// First, we keep out all events except the events for the current month. Then create a list of events for each day
	calendarFiltering = \items : [CalendarEvent], rowsEventsCount -> {
		currentDate = getValue(currentDateB);
		filteredByMonth = filter(items, \item -> {
			startDate = item.startDate;
			endDate = item.endDate;
			timeYearCheck(startDate.year, endDate.year, currentDate.year) &&
				timeMonthCheck(startDate, endDate, currentDate)
		});

		daysCount = getNumberOfDaysPerMonthInTheYear(currentDate.year)[currentDate.month];
		generate(1, daysCount + 1, \dayNumber -> {
			date = Date(currentDate with day = dayNumber);
			isEnable = isDateEnable(date, dateMin, dateMax);
			allEvents = filter(filteredByMonth, \item -> timeDayCheck(item.startDate, item.endDate, currentDate, dayNumber));
			makeCalendarDay(date, sortEvents(allEvents), isEnable, rowsEventsCount);
		});
	}

	getOtherMonthDayFn = \items, rowsEventsCount -> \i -> {
		if (isSome(otherMonthViewM)) {
			monthStart = Date(getValue(currentDateB) with day = 1);
			date = if (i > 0) {
				addDaysToDate(addMonthsToDate(monthStart, 1), i - 1);
			} else {
				addDaysToDate(monthStart, i);
			}
			events = filter(items, \item -> {
				startDate = item.startDate;
				endDate = item.endDate;
				timeYearCheck(startDate.year, endDate.year, date.year) &&
					timeMonthCheck(startDate, endDate, date) &&
					timeDayCheck(startDate, endDate, date, date.day)
			});
			makeCalendarDay(date, events, isDateEnable(date, dateMin, dateMax), rowsEventsCount);
		} else {
			blankDaySize;
		}
	}

	weekDayNames = [strsubsmart(_("Monday"), 0, 3), strsubsmart(_("Tuesday"), 0, 3), strsubsmart(_("Wednesday"), 0, 3),
		strsubsmart(_("Thursday"), 0, 3), strsubsmart(_("Friday"), 0, 3), strsubsmart(_("Saturday"), 0, 3), strsubsmart(_("Sunday"), 0, 3)];
	makeWeekDayNameCell = \i : int, name : string -> {
		weekDayM = getWeekDay(name, MonthTab());
		separatorM = MSeparator(false) |> MFixHeight(weekDayM);
		ifAttachHeight(
			MColsYCenterA([
				if (i == 0) separatorM else MEmpty(),
				weekDayM,
				separatorM
			]) |> MSetAddFillers(const(false)),
			i == 0,
			weekDayHeightB
		);
	};

	MonthViewByWeek = \curD : Date, items : [CalendarEvent] -> {
		headerM = MLines2A(MSeparator(true), MColsA(mapi(if (hideWeekends) take(weekDayNames, 5) else weekDayNames, makeWeekDayNameCell)));
		weekDay = dayOfWeek(curD);
		rowsCount = ceil(i2d(getNumberOfDaysPerMonthInTheYear(curD.year)[curD.month] + weekDay) / 7.0);
		minEventsCount = 1;
		rowsEventsCount = generate(0, rowsCount, \i -> {
			startDate = addDaysToDate(curD, -weekDay + i * 7);
			endDate = addDaysToDate(startDate, 6);

			rowEventsCount = maxA(generate(0, 7, \d -> {
				date = addDaysToDate(startDate, d);
				countA(items, \item -> {
					date >= time2date(item.startDate) && date <= time2date(item.endDate)
				});
			}));
			Triple(startDate, endDate, max(either(rowEventsCount, 0), minEventsCount));
		});

		separateRows = \rows -> arrayPush(interleave(rows, MSeparator(true)), MSeparator(true));
		getOtherMonthDay = getOtherMonthDayFn(items, rowsEventsCount);

		days = concat(
			generate(-weekDay, 0, getOtherMonthDay),
			calendarFiltering(items, rowsEventsCount)
		);
		rows = makeLineOfDaysBlockForMonthView(0, getOtherMonthDay, days, hideWeekends, []);

		updateDisplayedEvents = \avaliableHeight, weekDayHeight, dayTitleHeight, eventRowHeight -> {
			availableDayHeight = (avaliableHeight - weekDayHeight) / i2d(rowsCount) - dayTitleHeight;
			maxEvents = max(CalendarDefaultDisplayedEventsInOneDay, floor(availableDayHeight / eventRowHeight));
			nextDistinct(maxDisplayedEventsInOneDayB, maxEvents);
		}

		CalendarTabView(
			MConstruct(
				if (isDynamicNumberOfEvents) {
					[make4Subscribe(availableHeightB, weekDayHeightB, dayTitleHeightB, eventRowHeightB, updateDisplayedEvents)]
				} else {
					[];
				},
				MAttachAvailableHeight(
					MLines2A(headerM, MLinesA(separateRows(rows)) |> (\c-> if (enableScrolls) MScroll(c, MFillXY(), []) else c)),
					availableHeightB
				)
			),
			\availableSize -> {
				eventRowHeight = getValue(eventRowHeightB);
				dayTitleHeight = getValue(dayTitleHeightB);
				rowsHeights = map(rowsEventsCount, \count -> i2d(count.third) * eventRowHeight + dayTitleHeight);

				weekDayHeight = getValue(weekDayHeightB);
				availableHeight = availableSize.height - weekDayHeight;

				pagesRows = foldi(rowsHeights, [], \i, acc, h -> {
					if (acc == []) {
						[[i]];
					} else {
						last = lastElement(acc, []);
						lastHeight = dsum(map(last, \j -> rowsHeights[j]));
						if (lastHeight + h > availableHeight) {
							arrayPush(acc, [i]);
						} else {
							replace(acc, length(acc) - 1, arrayPush(last, i));
						}
					}
				});

				map(pagesRows, \pageRows -> {
					MLines2A(headerM, MLinesA(separateRows(map(pageRows, \i -> rows[i]))));
				});
			},
			TEmpty()
		);
	}

	MonthViewByDay = \curD : Date, items : [CalendarEvent] -> {
		lastMonthDayDate = Date(curD.year, curD.month, getNumberOfDaysPerMonthInTheYear(curD.year)[curD.month]);
		RangeView(
			manager,
			items,
			eventTypesB,
			Date(curD.year, curD.month, 1),
			lastMonthDayDate,
			\date, events, isGroupOfEvents, rangeType -> {
				dayEventsPopup(date, events, eventTypesB, manager, getValue(choosedFilters), rangeType, isGroupOfEvents, styles)
			},
			dateMin,
			dateMax,
			0,
			false,
			isMobileViewB,
			isPrintingB,
			RangeTab(),
			styles
		)
	}

	MonthViewSwitchMenu = \ -> {
		style = concat(
			calendarHeaderStyle.icon,
			[MIconButtonBorder(8.), MToggleFalseIcon("view_column", arrayPush(calendarHeaderStyle.icon, MGrey(600)))]
		);
		MIconToggle("view_module", style, [MToggleValue(byWeekViewB)]) |> (\m -> MCols2A(MFillX(), m))
	}

	eventsT = fselect(currentEvents, FLift(\events -> {
		combinedEvents = combinedEventsView.getCombinedEvents(MonthTab(), events);
		if (combinedEvents == []) events else filter(events, \event -> !exists(combinedEvents, \e -> e.id == event.id));
	}));

	monthViewB = fselect3(byWeekViewB, currentDateB, eventsT, \byWeekView, currentDate, items -> {
		if (byWeekView) {
			MonthViewByWeek(currentDate, items);
		} else {
			MonthViewByDay(currentDate, items);
		}
	});

	CalendarTabView(
		MConstruct([
				make2Subscribe(eventsT, maxDisplayedEventsInOneDayB, \events, maxEvents -> {
					next(multiDayEventsPosition, []);
					checkMultiDayEventsPosition(dateMin, dateMax, events, maxEvents, multiDayEventsPosition);
				})
			],
			MGroup2(
				TRectangle([Fill(white), FillOpacity(1.0)], TFillXY()),
				MLines2A(
					if (showMonthSwitchView) MFrame(0.0, 0.0, calendarHeaderStyle.background, MonthViewSwitchMenu()) else MEmpty(),
					MSelect(monthViewB, \monthView -> monthView.main),
				)
			)
		),
		\availableSize -> fgetValue(monthViewB).getPrintPages(availableSize),
		TEmpty()
	);
}

// week utils
getWeeksBetweenDates(date1 : Date, date2 : Date, acc : int) -> int {
	start = min(date1, date2);
	end = max(date1, date2);
	res = if (start.year == end.year) acc + getWeekOfYear(end, 0, true) - getWeekOfYear(start, 0, true)
		else getWeeksBetweenDates(start, Date(end.year - 1, 12, 31), getWeekOfYear(end, 0, true) + acc);
	if (date1 <= date2) res else -res
}

getWeekStartDate(weekNum : int, year : int) -> Date {
	if (weekNum == 1) Date(year, 1, 1)
	else {
		lastYearDay = Date(year, 12, 31);
		lastWeekNum = getWeekOfYear(lastYearDay, 0, true);
		weekDate = addDaysToDate(lastYearDay, 7 * (weekNum - lastWeekNum));
		addDaysToDate(weekDate, -dayOfWeek(weekDate))
	}
}

getWeekEndDate(start : Date) -> Date {
	end = addDaysToDate(start, 6 - dayOfWeek(start));
	if (end.year == start.year) end else Date(start.year, 12, 31)
}

getNextWeekStartDate(weekNum : int, year : int, weeksToAdd : int) -> Date {
	lastWeekNum = getWeekOfYear(Date(year, 12, 31), 0, true);
	weeksToAddThisYear = lastWeekNum - weekNum;
	if (weeksToAddThisYear < weeksToAdd) getNextWeekStartDate(0, year + 1, weeksToAdd - weeksToAddThisYear)
	else getWeekStartDate(weekNum + weeksToAdd, year)
}

getMonthsBetweenDates(date1 : Date, date2 : Date, acc : int) -> int {
	start = min(date1, date2);
	end = max(date1, date2);
	res = if (start.year == end.year) acc + end.month - start.month else getMonthsBetweenDates(start, Date(end.year - 1, 12, 31), acc + end.month);
	if (date1 <= date2) res else -res
}

RangeView(
	manager : MaterialManager,
	events : [CalendarEvent],
	eventTypes : DynamicBehaviour<[CalendarEventDecription]>,
	startDate : Date,
	endDate : Date,
	showDayEventsPopup : (date : Date, events : [CalendarEvent], isGroupOfEvents : bool, rangeType : int) -> void,
	dateMin : Date,
	dateMax : Date,
	rangeType : int,
	showMonthRow : bool,
	isMobileViewB : Transform<bool>,
	isPrintingB : DynamicBehaviour<bool>,
	tab : CalendarTab,
	styles : [CalendarForEventsStyle]
) -> CalendarTabView {
	gridWidth = 1.0;
	isReadOnlyB = extractStruct(styles, CalendarReadOnly(const(false))).isReadOnlyB;
	isReadOnlyEvent = extractStruct(styles, CalendarReadOnlyEvent(\__ -> const(false))).isReadOnly;
	opacities = extractStruct(styles, CalendarEventsOpacities(None(), None(), None()));
	enableScrolls = extractStruct(styles, CalendarScrolls(true)).enable;
	hideWeekends = contains(styles, CalendarHideWeekends());
	openReadOnlyDialog = extractStruct(styles, CalendarReadOnlyEventDialog(nop1)).open;

	getWeekDay = extractStruct(styles, CalendarWeekDayView(\dayName, __ -> {
		MCenterX(MText(dayName, [MCaptionColumn(), MGrey(500)])) |> MBorderTopBottom(6.0)
	})).getView;
	getDayNumber = extractStruct(styles, CalendarDayNumberView(\dayNumber, isToday, isWeekend, __ -> {
		circleDiam = 24.0;
		circleSize = MFixed(circleDiam, circleDiam);
		todayBackgroundColor = getPrimaryColor(manager);
		textColor = if (isToday) {
			MContrastingTextColor(todayBackgroundColor);
		} else if (isWeekend) {
			MRed(600);
		} else {
			MBlack();
		}
		dayNumberM = MCenterIn(MText(dayNumber, [MBodyBold(), textColor]), circleSize);
		MCenterX(if (isToday) {
			MGroup2(
				MFrame(0.0, circleDiam / 2.0, [MFill(todayBackgroundColor)], circleSize),
				dayNumberM
			);
		} else {
			dayNumberM;
		});
	})).getView;
	getEventView = extractStruct(styles, CalendarCustomEventView(\__, e, __, __, __, getDefaultView -> getDefaultView(e))).getView;
	showDaysNames = containsStruct(styles, ShowWeekViewDaysNames());
	getEventTitle = extractStruct(styles, CalendarCustomEventTitle(\event, type -> {
		MEllipsisText(getEventTitleDefault(event), [type.mainColor, MShowTooltip(make(true))]);
	})).getTitle;
	combinedEventsView = extractStruct(styles, CalendarCombinedEventsView(\__, __ -> [], \__, __, __ -> MEmpty()));

	byDayCellHeight = if (showDaysNames) 58.0 else 48.0;
	byDayCellSize : Tropic = TFillXH(byDayCellHeight);

	getDaysWithoutWeekends = \start : Date, end : Date -> {
		filtermap(enumFromTo(0, getDaysBetweenDates(start, end)), \dateNum -> {
			date = addDaysToDate(start, dateNum);
			if (dayOfWeek(date) >= 5) None() else Some(date)
		})
	}

	getRangeColumnsCount = \start : Date, end : Date -> {
		if (rangeType == 0) {
			if (hideWeekends) {
				length(getDaysWithoutWeekends(start, end)) - 1
			} else {
				getDaysBetweenDates(start, end)
			}
		}
		else if (rangeType == 1) getWeeksBetweenDates(start, end, 0)
		else end.month - start.month + 12 * (end.year - start.year)
	}

	getNextDate = \oldDate : Date, dateNum : int -> {
		newDate = if (rangeType == 0) {
			if (hideWeekends) {
				elementAt(getDaysWithoutWeekends(startDate, endDate), dateNum, oldDate)
			} else {
				addDaysToDate(oldDate, dateNum)
			}
		} else if (rangeType == 1) {
			getNextWeekStartDate(getWeekOfYear(oldDate, 0, true), oldDate.year, dateNum)
		} else {
			addMonthsToDate(oldDate, 1 * dateNum)
		}
		min(max(newDate, startDate), endDate)
	}

	columnsCountInRange = getRangeColumnsCount(startDate, endDate) + 1;

	allRangeEvents = filtermap(events, \event -> {
		if (time2date(event.startDate) <= endDate && startDate <= time2date(event.endDate)) {
			if (rangeType == 0 && hideWeekends) {
				eventStart = time2date(event.startDate);
				eventEnd = time2date(event.endDate);

				eventStartDay = dayOfWeek(eventStart);
				eventEndDay = dayOfWeek(eventEnd);

				newEvent = CalendarEvent(event with
					startDate = if (eventStartDay >= 5) date2time(addDaysToDate(eventStart, 7 - eventStartDay)) else event.startDate,
					endDate = if (eventEndDay >= 5) date2time(addDaysToDate(eventEnd, 4 - eventEndDay)) else event.endDate
				);
				if (time2stamp(newEvent.startDate) <= time2stamp(newEvent.endDate)) Some(newEvent) else None()
			} else {
				Some(event)
			}
		} else {
			None()
		}
	});

	combinedEvents = combinedEventsView.getCombinedEvents(tab, allRangeEvents);
	rangeEvents = if (combinedEvents == []) allRangeEvents else filter(allRangeEvents, \event -> !exists(combinedEvents, \e -> e.id == event.id));

	cellBorder = \colour : int, height : double -> TRectangle([Fill(colour)], TFillMax(2., height));

	eventsByRow : [[CalendarEvent]] = fold(sortCustom(rangeEvents, \event -> event.endDate, true), [], \res, event : CalendarEvent -> {
		eitherFn(
			findi(res, \x -> getRangeColumnsCount(time2date(lastElement(x, emptyEvent).endDate), time2date(event.startDate)) > 0),
			\idx -> replace(res, idx, arrayPush(res[idx], event)),
			\ -> arrayPush(res, [event])
		)
	});

	titleRowHeightB = make(0.0);
	titleRow = MAttachHeight(MColsA(generate(0, columnsCountInRange, \dateNum -> {
		date = getNextDate(startDate, dateNum);
		isTodayB = fand(const(compareDates(date, getCurrentDate()) == DateEqual()), fnot(isPrintingB));

		text = i2s(if (rangeType == 0) date.day else if (rangeType == 1) getWeekOfYear(date, 0, true) else date.month);
		isWeekend = dayOfWeek(date) >= 5 && rangeType == 0;
		dayNumberM = MIfLazy(isTodayB, \isToday -> getDayNumber(text, isToday, isWeekend, tab));

		if (rangeType == 0 && showDaysNames) {
			MLines2A(getWeekDay(toUpperCase(dayOfWeekString(date, false)), tab), dayNumberM) |> MBorderBottom(8.0);
		} else {
			MCenterIn(dayNumberM, byDayCellSize);
		}
	})), titleRowHeightB);

	dayClickGrid = MColsA(generate(0, columnsCountInRange, \dateNum -> {
		date = getNextDate(startDate, dateNum);
		eventsToShow = {
			sectionStart = if (rangeType <= 1) date else Date(date.year, date.month, 1);
			sectionEnd = if (rangeType == 0) date
					else if (rangeType == 1) getWeekEndDate(sectionStart)
					else Date(date.year, date.month, getNumberOfDaysPerMonthInTheYear(date.year)[date.month]);
			filter(
				rangeEvents,
				\event -> max(sectionStart, startDate) <= time2date(event.endDate) && time2date(event.startDate) <= min(sectionEnd, endDate)
			)
		}
		onClick = \ -> {
			if (isDateBetween(date, dateMin, dateMax)) showDayEventsPopup(date, eventsToShow, false, rangeType);
		}
		MComponent([MOnClick(onClick), MEnabled(fnot(isReadOnlyB))], \__ -> MFillXY());
	}));

	getDefaultEventView = \event, eventCells, eventType -> {
		text = MCenterYIn(MBorderA(8., 0., 8., 0., getEventTitle(event, eventType)), eventCells);
		MGroup2(eventCells, MTooltip(text, MText(event.description, []), [MEnabled(const(isTooltipEnabled(event)))]));
	}
	EventCells = \len : int, event : CalendarEvent -> {
		eventTypeB = fselect(eventTypes, FLift(\types -> {
			findDef(types, \et -> et.name == event.eventType, makeCalendarEventDescription())
		}));
		date = max(time2date(event.startDate), startDate);
		opacity = getCalendarEventOpacity(event, opacities);
		getEventCells = \eventType -> MColsA(generate(0, len, \cellNum : int -> {
			leftCorner = b2d(cellNum == 0) * 4.;
			rightCorner = b2d(cellNum == len - 1) * 4.;
			backColourInt = MColor2int(eventType.backColor);
			MCols2A(
				TRounded(leftCorner, rightCorner, rightCorner, leftCorner, [Fill(backColourInt), FillOpacity(opacity)], byDayCellSize),
				cellBorder(if (cellNum == len - 1) white else backColourInt, byDayCellHeight)
			);
		}));

		isEditAllowedT = fand(fnot(isReadOnlyEvent(event)), fand(fnot(isReadOnlyB), fselect(eventTypeB, FLift(\et -> et.editAction != nop1))));
		onClick = \ -> {
			if (fgetValue(isEditAllowedT)) {
				fgetValue(eventTypeB).editAction(event.id);
			} else {
				openReadOnlyDialog(event.id);
			}
		}

		MComponent(
			[MOnClick(onClick), MEnabled(fOr(const(openReadOnlyDialog != nop1), isEditAllowedT))],
			\__ -> {
				MSelect(eventTypeB, \eventType -> {
					eventCells = getEventCells(eventType);
					getEventView(tab, event, eventType, date, len, \e -> getDefaultEventView(e, eventCells, eventType)) |> MFixWidth(eventCells)
				})
			}
		) |> disableMInteractivesBelow |> MBorderStart(gridWidth);
	};
	EmptyCells = \len : int -> MColsA(generate(0, len, \__ -> MCols2A(MFillXH(0.0), cellBorder(white, 0.0))));

	rowsHeightsB = generate(0, length(eventsByRow), \__ -> make(0.0));
	getEventRows = \ -> mapi(eventsByRow, \i, evs : [CalendarEvent] -> {
		MAttachHeight(
			mapi(evs, \j, event -> {
				eventLength = getRangeColumnsCount(max(time2date(event.startDate), startDate), min(time2date(event.endDate), endDate)) + 1;
				blankLength = if (j == 0) {
					getRangeColumnsCount(startDate, time2date(event.startDate));
				} else {
					getRangeColumnsCount(time2date(evs[j - 1].endDate), time2date(event.startDate)) - 1;
				}
				res = [EventCells(eventLength, event)]
					// insert empty cells before event, if any
					|> (\r -> if (blankLength > 0) insertArray(r, 0, EmptyCells(blankLength)) else r)
					// insert empty cells after event, if it's the last
					|> (\r -> {
						c = getRangeColumnsCount(time2date(event.endDate), endDate);
						if (j == length(evs) - 1 && c > 0) arrayPush(r, EmptyCells(c)) else r
					});
				res
			}) |> concatA |> MCols,
			rowsHeightsB[i]
		);
	});

	gridLinesStyle = [MFill(MGrey(400)), FillOpacity(0.4)];

	monthCount = getMonthsBetweenDates(startDate, endDate, 1);

	monthNamesRowHeightB = make(0.0);
	monthNamesRow = if (rangeType == 0 && showMonthRow) {
		MAttachHeight(MColsA(generate(0, monthCount, \idx -> {
			date = addMonthsToDate(startDate, idx);
			len = getRangeColumnsCount(
				if (idx == 0) startDate else Date(date.year, date.month, 1),
				if (idx == monthCount - 1) endDate else Date(date.year, date.month, getNumberOfDaysPerMonthInTheYear(date.year)[date.month])
			) + 1;
			MCols2A(
				TRectangle(if (idx == 0) [Fill(white)] else gridLinesStyle, TFixed(gridWidth, 24.)),
				MOnTop(
					MColsA(generate(0, len, \__ -> TFillXH(24.))),
					MCenter(MEllipsisText(monthString(date, true), [MBodyBold(), MShowTooltip(const(true))]))
				)
			)
		})), monthNamesRowHeightB)
	} else {
		MEmpty();
	}

	gridLine = TRectangle(gridLinesStyle, TFillWY(gridWidth));
	verticalGrid = MColsA(arrayPush(concatA(generate(0, columnsCountInRange, \__ -> [gridLine, TFillX()])), gridLine));

	horizontalLine = TRectangle(gridLinesStyle, TFillXH(gridWidth));

	addTitleAndGrid = \m -> {
		MLinesA([
			monthNamesRow,
			horizontalLine,
			MOnTop(
				dayClickGrid,
				MOnTop(MLinesA([titleRow, horizontalLine, m]), verticalGrid)
			)
		]);
	}

	getEventRowsMobile = \ -> mapConcat(generate(0, columnsCountInRange, \i -> addDaysToDate(startDate, i)), \date -> {
		dayEvents = filter(rangeEvents, \event -> date >= time2date(event.startDate) && date <= time2date(event.endDate));
		concat3(
			[getWeekDay(toUpperCase(date2formatString(date, "%DDD, %MMM %D")), tab)],
			map(dayEvents, \event -> EventCells(1, event)),
			[MFixedY(2.0), horizontalLine]
		);
	});

	openDayEventsPopup = \eventsToShow -> showDayEventsPopup(startDate, eventsToShow, true, 1);

	combinedEventsViewHeightB = make(0.0);

	CalendarTabView(
		MIfLazy(isMobileViewB, \isMobileView -> {
			addScroll = \m -> if (enableScrolls) MScroll(m, TFillXY(), []) else m;
			addGrid = \m -> if (isMobileView) MFrame(2.0, 0.0, [MStroke(MGrey(400))], m) else addTitleAndGrid(m);
			rows = if (isMobileView) getEventRowsMobile() else getEventRows();

			MGroup2(
				addScroll(MLinesA(rows)) |> {\m -> MBorderT(zero, combinedEventsViewHeightB, zero, zero, m)} |> addGrid,
				MLinesA([
					TSizedHeight(0.0, fsum([combinedEventsViewHeightB, titleRowHeightB, monthNamesRowHeightB, const(2.0 * gridWidth)])),
					MShowLazy(fneq(combinedEventsViewHeightB, 0.0), \ -> horizontalLine)
				])
			)
		}),
		\availableSize -> {
			titleHeight = getValue(monthNamesRowHeightB) + getValue(titleRowHeightB) + 2.0 * gridWidth;
			availableHeight = availableSize.height - titleHeight;
			pagesRows = foldi(getEventRows(), Pair([], 0.0), \i, acc, row -> {
				rowHeight = getValue(rowsHeightsB[i]);
				if (acc.first == []) {
					Pair([[row]], rowHeight);
				} else if (acc.second + rowHeight < availableHeight) {
					lastIndex = length(acc.first) - 1;
					newRows = replace(acc.first, lastIndex, arrayPush(acc.first[lastIndex], row));
					Pair(newRows, acc.second + rowHeight);
				} else {
					Pair(arrayPush(acc.first, [row]), rowHeight);
				}
			}).first;

			if (pagesRows == []) {
				[addTitleAndGrid(MFillXY())];
			} else {
				map(pagesRows, \rows -> addTitleAndGrid(MLinesA(rows)));
			}
		},
		MLines2A(
			TSizedHeight(0.0, fsum([titleRowHeightB, monthNamesRowHeightB, const(2.0 * gridWidth)])),
			MAttachHeight(combinedEventsView.getView(tab, combinedEvents, openDayEventsPopup), combinedEventsViewHeightB) |> MBorderLeftRight(2.0),
		)
	);
}

//Shows ONLY the upcoming events
PlannedEventsTable(
	currentEvents : DynamicBehaviour<[CalendarEvent]>,
	eventTypesB : DynamicBehaviour<[CalendarEventDecription]>,
	manager : MaterialManager,
	tabsDropdownM : Material,
	styles : [CalendarForEventsStyle]
) -> Material {
	tableDateFormat = extractStruct(styles, PlannedTableDateFormat("%YYYY/%MM/%DD")).tableDateFormat;
	hideTimeInfo = contains(styles, HideTimeInfo());
	hideDeleteButton = contains(styles, CalendarPlannedHideDeleteButton());
	littleFont = MBody();
	calendarHeaderStyle = extractStruct(styles, defaultCalendarHeaderStyle);
	isReadOnlyB = extractStruct(styles, CalendarReadOnly(const(false))).isReadOnlyB;
	isReadOnlyEvent = extractStruct(styles, CalendarReadOnlyEvent(\__ -> const(false))).isReadOnly;
	printButtonStyleM = maybeMap(tryExtractStruct(styles, CalendarPrintable([])), \p -> p.style);
	getCustomHeader = extractStruct(styles, CalendarCustomHeader(\__, __, __ -> None())).getView;
	getEventTitle = extractStruct(styles, CalendarCustomEventTitle(\event, __ -> {
		eventName = if (event.title != "") event.title else event.eventType;
		MEllipsisText(eventName, [littleFont]);
	})).getTitle;

	timeSort = \item : CalendarEvent -> item.startDate;

	getLastEvents = \events -> {
		today = stamp2time2(timestamp());
		eventsAfterToday = filter(events, \event -> event.startDate >= today);
		sortCustom(eventsAfterToday, timeSort, true);
	}

	getLastEventsWithDescription = \events -> {
		today = stamp2time2(timestamp());
		filter(events, \event -> event.startDate >= today && event.description != "")
	}

	currentLine = make(-1);

	lineHeight = 60.;
	lineSeparatorHeight = 1.0;

	titleTextM = MCenterYIn(
		MSelect(currentEvents, \events -> MText(i2s(length(getLastEvents(events))) + " " + _("planned events"), calendarHeaderStyle.text)),
		TFillXH(60.0)
	) |> MBorderStart(20.0);

	createTimeColumn = \_columnHeader -> {
		if (hideTimeInfo) TEmpty()
		else
			MCenterYIn(
				MText(_columnHeader, [littleFont, MGrey(800)]),
				TFixed(150., lineHeight)
			)
	}

	columnNames = MGroup([
		MLines2A(
			TRectangle([MFill(MGrey(200)), FillOpacity(1.0)], TFillXH(lineHeight)),
			TRectangle([MFill(MGrey(500)), FillOpacity(0.3)], TFillXH(2.))
		),
		MColsA([
			TFixed(25., 0.),
			MCenterYIn(
				MText(_("Date"), [littleFont, MGrey(800)]),
				TFixed(80., lineHeight)
			),
			TFixed(100., 0.),
			MCenterYIn(
				MText(_("Event name"), [littleFont, MGrey(800)]),
				TFixed(200., lineHeight)
			),
			TFixed(5., 0.),
			MIf(
				fselect(currentEvents, FLift(\events -> length(getLastEventsWithDescription(events)) > 0)),
				MCenterYIn(
					MText(_("Description"), [littleFont, MGrey(800)]),
					TFillXH(lineHeight)
				),
				TFillXH(lineHeight)
			),
			TFixed(5., 0.),
			createTimeColumn(_("Start time")),
			createTimeColumn(_("End time"))
		])
	]);

	makeAddButtonsMenu = \ev, evType -> {
		mainButton = MIconButton("more_horiz",
			nop,
			[MIconSize(22.), FillOpacity(1.0)],
			[]
		);

		items = map(evType.additionalActions, \act -> {
			MMenuCustomLine(
				MColsA([
					MCenterYIn(
						MIcon(act.icon, [MIconSize(22.), FillOpacity(1.0)]),
						TFixed(50., 44.)
					),
					MCenterYIn(
						MText(act.name, [littleFont]),
						TFixed(0., 44.)
					)
				]),
			[])
		});

		MCenterYIn(
			MMenu(
				mainButton,
				items,
				[MOnListClick(const(true), \index -> evType.additionalActions[index].action(ev.id))]
			),
			TFixed(50., lineHeight)
		)
	}

	isPrintingB = make(false);

	eventLine = \number, event, eventType -> {
		eventTitle = getEventTitle(event, eventType);
		eventDate = date2formatString(time2date(event.startDate), tableDateFormat);

		isStartDayOrEndDayTime = \time -> {
			time.hour == 0 && time.min == 0 || time.hour == 23 && time.min == 59;
		}
		createTimeLabel = \time -> {
			if (hideTimeInfo) TEmpty()
			else
				MCenterYIn(
					MText(if (time != "") lpad(time, "0", 5) else "", [littleFont]),
					TFixed(150., lineHeight)
				)
		}
		times = if (isStartDayOrEndDayTime(event.startDate) && isStartDayOrEndDayTime(event.endDate)) {
			Pair("", "");
		} else if (event.startDate.hour == event.endDate.hour && event.startDate.min == event.endDate.min) {
			Pair(getTimeOnlyString(event.startDate, false, false), "");
		} else {
			Pair(
				getTimeOnlyString(event.startDate, false, false),
				getTimeOnlyString(event.endDate, false, false)
			);
		}
		startTimeM = createTimeLabel(times.first);
		endTimeM = createTimeLabel(times.second);

		isSelectedB = fand(feq(currentLine, number), fnot(isPrintingB));
		enabledB = if (eventType.editAction == nop1) const(false) else fand(fnot(isReadOnlyEvent(event)), fnot(isReadOnlyB));
		MComponent(
			[MOnClick(\ -> nextDistinct(currentLine, number)), MEnabled(enabledB)],
			\__ -> MGroup([
				MGroup2(
					MSelect(isSelectedB, \isSelected ->
						TRectangle([MFill(if (isSelected) MCustomColor(0xFFECB3) else MWhite()), FillOpacity(1.0)], TFillXH(lineHeight + lineSeparatorHeight))),
					TRectangle([Fill(grey), FillOpacity(0.6)], TFillXH(lineSeparatorHeight))
					|> (\m -> MBorderA(25., lineHeight, 25., 0., m))
				),
				MColsYCenterA([
					TFixed(25., 0.),
					MText(eventDate, [littleFont]) |> MFixWidth(MFixedX(80.0)),
					if (eventType.icon != "") MAvatar(eventType.icon, [MIconSize(40.0)]) |> MBorderLeftRight(30.0) else MFixedX(100.0),
					eventTitle |> MFixWidth(MFixedX(200.0)),
					TFixed(5., 0.),
					MEllipsisText(event.description, [littleFont, MFullWidth()]),
					TFixed(5., 0.),
					startTimeM,
					MIf(isSelectedB,
						MColsA([
							if (length(eventType.additionalActions) > 0) {
								if (length(eventType.additionalActions) == 1) {
									MCenterYIn(
										MIconButton(eventType.additionalActions[0].icon,
											\-> {eventType.additionalActions[0].action(event.id)},
											[MIconSize(22.), FillOpacity(1.0)],
											[]
										),
										TFixed(50., lineHeight)
									)
								} else {
									makeAddButtonsMenu(event, eventType)
								}
							} else {
								TFixed(0., 0.)
							},
							MCenterYIn(
								MIconButton("mode_edit",
									\-> {
										eventType.editAction(event.id)
									},
									[MIconSize(22.), FillOpacity(0.8)],
									[]
								),
								TFixed(50., lineHeight)
							),
							MVisible(const(!hideDeleteButton),
								MCenterYIn(
									MIconButton("close",
										\-> {
											close = make(false);
											ShowMDialog(manager, close, [],
												eventDeletePopup(
													\-> next(close, true),
													\-> {
														eventType.deleteAction(event.id);
														next(close, true);
													}
												)
											);
										},
										[MIconSize(22.), FillOpacity(0.8)],
										[]
									),
									TFixed(50., lineHeight)
								)
							),
							if (length(eventType.additionalActions) == 0)
								TFixed(50., 0.)
							else
								TFixed(0., 0.)
						]),
						endTimeM
					)
				])
			])
		)
	};

	getEventView = extractStruct(styles, CalendarCustomEventView(\__, e, __, __, __, getDefaultView -> getDefaultView(e))).getView;

	rowsB = fselect(currentEvents, FLift(\eventUnsort -> {
		eventSorted = getLastEvents(eventUnsort);
		nextDistinct(currentLine, -1);
		eventTypes = getValue(eventTypesB);
		mapi(eventSorted, \i, event -> {
			eventType = findDef(eventTypes, \p -> p.name == event.eventType, makeCalendarEventDescription());
			getEventView(PlannedTab(), event, eventType, event.startDate, 1, \e -> eventLine(i, e, eventType));
		});
	}));

	contentM = MGroup2(
		TRectangle([Fill(white), FillOpacity(1.0)], TFillXY()),
		MSelect(rowsB, MLinesA)
	);

	addBackground = \m -> MFrame(0.0, 0.0, calendarHeaderStyle.background, m);

	printHeaderM = MLines2A(addBackground(titleTextM), columnNames);
	getPrintPages = \availableSize -> {
		rows = fgetValue(rowsB);
		rowHeight = lineHeight + lineSeparatorHeight;
		rowsPerPage = floor(availableSize.height / rowHeight);
		pagesCount = ceil(i2d(length(rows)) / i2d(rowsPerPage));
		generate(0, pagesCount, \i -> MLinesA(subrange(rows, i * rowsPerPage, rowsPerPage)));
	}
	printCalendarButtonM = getPrintCalendarIconButton(manager, printHeaderM, MEmpty(), getPrintPages, isPrintingB, styles);

	buttons = CalendarActionButtons(MEmpty(), printCalendarButtonM, tabsDropdownM, MEmpty(), MEmpty(), Pair(MEmpty(), MEmpty()), Pair(MEmpty(), MEmpty()));
	headerM = eitherFn(getCustomHeader(PlannedTab(), const(getCurrentDate()), buttons), idfn, \ -> addBackground(MColsYCenterA([titleTextM, buttons.tabsDropdown, buttons.printButton])));

	MLinesA([headerM, columnNames, MScroll(contentM, TFillXY(), [])]);
}

reshuffleEvents(
	events : [CalendarEvent],
	startPos : int,
	endPos : int,
	eventToChange : CalendarEvent
	) -> [CalendarEvent] {

	if (startPos < endPos) {
		newPos = startPos + 1;
		newEvents = if (newPos < length(events)) {
			swapIndexes(events, startPos, newPos);
		} else {
		//if we need to place an event outside the array - just insert an empty event into its place
			newEvents = replace(events, startPos, emptyEvent);
			arrayPush(newEvents, eventToChange);
		}
		reshuffleEvents(newEvents, newPos, endPos, eventToChange);
	} else {
		swapIndexes(events, startPos, endPos);
	}
}

checkOneDayEventsPosition(
	events : [CalendarEvent],
	maxEvents : int,
	multiDayEventsPosition : DynamicBehaviour<[Pair<CalendarEvent, int>]>
) -> [CalendarEvent] {
	printEvents = \evt -> println(foldi(evt, "", \index, res, it -> res + " #" + i2s(index) + " " + it.eventType));

	//To avoid an endless loop with an attempt to take one "seat" by two events
	eventsInWrongPositionWithoutCorrection = foldi(events, [], \i, res, item -> {
		index = either(findi(multiDayEventsPosition |> getValue, \p2 -> p2.first == item), -1);
		if (index != -1) {
			currentPosition = i;
			rigthPosition = getValue(multiDayEventsPosition)[index].second;
			arrayPush(res, Pair(currentPosition, rigthPosition))
		} else {
			res
		}
	});

	eventsInWrongPosition = foldi(events, [], \i, res, item -> {
		index = either(findi(multiDayEventsPosition |> getValue, \p2 -> p2.first == item), -1);
		if (index != -1) {
			currentPosition = i;
			rigthPosition = getValue(multiDayEventsPosition)[index].second;
			corrRightPosition = if (rigthPosition >= length(events)) {
				//if we already have a non-empty event in this position, we don't occupy it
				index2 = either(findi(eventsInWrongPositionWithoutCorrection, \p2 ->
					(p2.first != currentPosition && (p2.second == maxEvents - 1 || p2.second >= maxEvents ))), -1);
				if (index2 == -1) maxEvents - 1 else rigthPosition;
			} else {
				rigthPosition;
			}
			//println("c - " + i2s(currentPosition) + " r - " + i2s(rigthPosition) + " cr - " + i2s(corrRightPosition));
			if (currentPosition != corrRightPosition) {
				arrayPush(res, Pair(currentPosition, corrRightPosition))
			} else
				res
		} else {
			res
		}
	});

	if (length(eventsInWrongPosition) > 0) {
		//printEvents(events);
		newEvents = reshuffleEvents(events, eventsInWrongPosition[0].first, eventsInWrongPosition[0].second, events[eventsInWrongPosition[0].first]);
		//printEvents(newEvents);
		if (events != newEvents) checkOneDayEventsPosition(newEvents, maxEvents, multiDayEventsPosition) else events;
	} else {
		events
	}

}

//Multi-day events must go in one position through all the days.
//Therefore, before displaying, you need to know the positions of ALL events
checkMultiDayEventsPosition(
	dateMin : Date,
	dateMax : Date,
	allEvents : [CalendarEvent],
	maxEvents : int,
	multiDayEventsPosition : DynamicBehaviour<[Pair<CalendarEvent, int>]>
	) -> void {
	minYear = dateMin.year;
	maxYear = dateMax.year;
	years = enumFromTo(minYear, maxYear);
	months = enumFromTo(1, 12);

	iter(years, \year -> {
		filteredByYear = filter(allEvents, \item -> timeYearCheck(item.startDate.year, item.endDate.year, year));

		iter(months, \month -> {
			filteredByMonth = filter(filteredByYear, \item -> timeMonthCheck(item.startDate, item.endDate, Date(year, month, 1)));

			daysNum = getNumberOfDaysPerMonthInTheYear(year)[month];
			days = enumFromTo(1, daysNum);

			iter(days, \day -> {
				timeSort = \item : CalendarEvent -> item.startDate;

				currentDate = Date(year, month, day);

				dayEvents = filter(filteredByMonth, \item -> timeDayCheck(item.startDate, item.endDate, currentDate, day));

				events = sortEvents(dayEvents)
					|> \evs -> concat(evs, generate(0, maxEvents - length(evs), \__ -> emptyEvent));

				newEvents = checkOneDayEventsPosition(events, maxEvents, multiDayEventsPosition);
				iteri(newEvents, \i, item -> {
					isMultiDay = (time2date(item.startDate) != time2date(item.endDate));
					if (isMultiDay) {
						if (currentDate == time2date(item.startDate)) {
							index = either(findi(multiDayEventsPosition |> getValue, \p -> p.first == item), -1);
							if (index == -1)
								next(multiDayEventsPosition, arrayPush(getValue(multiDayEventsPosition), Pair(item, i)));
						}
					}
				});
			});
		});
	});
}

showDatePickerDialog(
	date : Date,
	manager : MaterialManager,
	onOk : (Date) -> void,
	dateMin : Date,
	dateMax : Date,
	markDays : (Date) -> bool
) -> void {
	value = make(date);
	close = make(false);
	ShowMDialog(manager, close, [MDialogClickOutToClose()],
		MDatePicker(
			value,
			[
				MDialogButtons([
					MButtonOk("enter", \ -> { next(close, true); onOk(getValue(value)) }),
					MButtonCancel("esc", \ -> next(close, true))
				]),
				MMarkDays(markDays), MDateMin(dateMin), MDateMax(dateMax)
			]
		)
	)
}

CalendarDayEvent(index : int, event : CalendarEvent, type : CalendarEventDecription, heightB : DynamicBehaviour<double>);

CalendarEventTimeType ::= CalendarAllDayEvent, CalendarPastEvent, CalendarCurrentEvent, CalendarFutureEvent;
	CalendarAllDayEvent(type : CalendarEventTimeType);
	CalendarPastEvent();
	CalendarCurrentEvent();
	CalendarFutureEvent();

isPastEventTimeType(type : CalendarEventTimeType) -> bool {
	switch (type) {
		CalendarAllDayEvent(t): isPastEventTimeType(t);
		CalendarPastEvent(): true;
		default: false;
	}
}

isCurrentEventTimeType(type : CalendarEventTimeType) -> bool {
	switch (type) {
		CalendarAllDayEvent(t): isCurrentEventTimeType(t);
		CalendarCurrentEvent(): true;
		default: false;
	}
}

isFutureEventTimeType(type : CalendarEventTimeType) -> bool {
	switch (type) {
		CalendarAllDayEvent(t): isFutureEventTimeType(t);
		CalendarFutureEvent(): true;
		default: false;
	}
}

getCalendarEventTimeType(event : CalendarEvent) -> CalendarEventTimeType {
	currentTime = getCurrentTime();
	currentDate = getCurrentDate();
	type = if (event.endDate < currentTime) {
		CalendarPastEvent();
	} else if (event.startDate > currentTime) {
		CalendarFutureEvent();
	} else {
		CalendarCurrentEvent();
	}
	if (time2date(event.startDate) != time2date(event.endDate) || (event.startDate <= date2time(currentDate) && event.endDate >= date2timeEOD(currentDate))) {
		CalendarAllDayEvent(type);
	} else {
		type;
	}
}

getCalendarDayEventTimeline(
	dayEvent : CalendarDayEvent,
	timeType : CalendarEventTimeType,
	currentTimeB : Transform<Time>,
	firstEventIdB : Transform<int>,
	lastEventIdB : Transform<int>,
	isCircleVisible : bool,
	pastColor : MColor,
	futureColor : MColor
) -> Material {
	event = dayEvent.event;
	eventHeightB = dayEvent.heightB;
	circleRadius = if (isCircleVisible) 4.0 else 0.0;
	circleDiam = 2.0 * circleRadius;
	lineWidth = 2.0;
	timelineWidth = 24.0;

	circleM = MFrame(0.0, circleRadius, [MFill(futureColor)], MFixed(circleDiam, circleDiam));

	getLine = \color, addMargin, heightB -> {
		margin = if (addMargin) circleRadius - lineWidth * 0.5 else 0.0;
		MFrame(0.0, 0.0, [MFill(color)], MSizedHeight(lineWidth, heightB)) |> MBorderStart(margin);
	}

	timelineM = switch (timeType : CalendarEventTimeType) {
		CalendarAllDayEvent(__): MEmpty();
		CalendarPastEvent(): getLine(pastColor, false, eventHeightB);
		CalendarFutureEvent(): {
			futureHeightB = fsubtract(eventHeightB, const(circleDiam));
			MLinesXCenter([circleM, getLine(futureColor, false, futureHeightB)]);
		}
		CalendarCurrentEvent(): {
			pastHeightB = if (isCircleVisible) {
				fselect2(currentTimeB, eventHeightB, FLift2(\time, height -> {
					roundTime = \t -> dfloor(time2stamp(t) / 100000.0);
					start = roundTime(event.startDate);
					end = roundTime(event.endDate);
					min(height - circleDiam, max(0.0, dround(height * (roundTime(time) - start) / (end - start)) - circleRadius));
				}));
			} else {
				const(0.0);
			}
			futureHeightB = fselect2(pastHeightB, eventHeightB, FLift2(\pastHeight, height -> height - pastHeight - circleDiam));
			MLinesA([
				getLine(pastColor, isCircleVisible, pastHeightB),
				circleM,
				getLine(futureColor, isCircleVisible, futureHeightB)
			]);
		}
	}

	getTimelineBorder = \isStart -> {
		colorM = switch (timeType : CalendarEventTimeType) {
			CalendarAllDayEvent(__): None();
			CalendarPastEvent(): Some(pastColor);
			CalendarFutureEvent(): Some(futureColor);
			CalendarCurrentEvent(): Some(if (isStart) pastColor else futureColor);
		}
		eitherMap(colorM, \color -> MFrame(0.0, 0.0, [MFill(color)], MFixed(timelineWidth * 0.5, lineWidth)), MEmpty());
	}
	timelineStartM = MShow(feq(firstEventIdB, dayEvent.index), getTimelineBorder(true));
	timelineEndM = MShow(feq(lastEventIdB, dayEvent.index), getTimelineBorder(false));
	timelineBordersM = MAvailableHeight(MLinesA([timelineStartM, MFillY(), timelineEndM]), eventHeightB);

	centerTimeline = \m -> MCenterXIn(m, MFillWY(timelineWidth));
	isHoveringB = make(false);
	MComponent([
			THovering(isHoveringB),
			MTooltipAlignment(MRight()),
			MEnabled(const(!isSameStructType(timeType, CalendarAllDayEvent(CalendarPastEvent())))),
			MTooltipText(fselect(isHoveringB, FLift(\__ -> getTimeOnlyString(stamp2time2(timestamp()), false, false))))
		],
		\__ -> MGroup2(centerTimeline(timelineM), centerTimeline(timelineBordersM))
	);
}

getCalendarDayEventDefaultView(event : CalendarEvent, type : CalendarEventDecription, timeType : CalendarEventTimeType, styles : [CalendarForEventsStyle]) -> Material {
	opacities = extractStruct(styles, CalendarEventsOpacities(None(), None(), None()));

	// background and stroke colors
	getColors = \opacity -> {
		if (opacity == 0.0) {
			Pair(MWhite(), MGrey(400));
		} else {
			color = MCustomColor(mixColors(MColor2int(type.backColor), white, opacity, 1.0 - opacity));
			Pair(color, color);
		}
	}
	pastColors = getColors(either(opacities.past, 0.2));
	currentColors = getColors(either(opacities.current, 1.0));
	futureColors = getColors(either(opacities.future, 0.2));

	hideTime = containsStruct(styles, CalendarHideTimeInDayView());

	getEventView = \timeString, colors, isPastEvent -> {
		textColor = MTextMColor(colors.first);
		getEventTitle = extractStruct(styles, CalendarCustomEventTitle(\e, __ -> {
			MEllipsisText(getEventTitleDefault(e), ifArrayPush([textColor, MFullWidth()], !isPastEvent, MBodyBold()));
		})).getTitle;
		MFrame(if (hideTime) 0.0 else 16.0, 4.0, [MFill(colors.first), StrokeWidth(1.0), MStroke(colors.second)],
			MColsYCenterA([
				if (hideTime) MFixedY(48.0) else MEmpty(),
				MLinesA([
					if (hideTime) {
						MEmpty()
					} else {
						MColsYCenterA([
							MIcon("schedule", [textColor]) |> MBorderEnd(8.0),
							MText(timeString, [textColor, MBodyBold()])
						]) |> MBorderBottom(4.0)
					},
					getEventTitle(event, type) |> MBorderStart(2.0)
				]),
				MFillX(),
				if (isPastEvent) {
					MTooltip(MFrame(0.0, 5.0, [MFill(pastColors.first)], MFixed(10.0, 10.0)), MText(type.name, []), []);
				} else {
					MEmpty();
				}
			]) |> MBorderLeftRight(if (hideTime) 8.0 else 0.0)
		);
	}
	geEventTimeString = \ -> {
		startTime = getTimeOnlyString(event.startDate, false, false);
		endTime = if (event.startDate != event.endDate) "-" + getTimeOnlyString(event.endDate, false, false) else "";
		startTime + endTime;
	}

	switch (timeType : CalendarEventTimeType) {
		CalendarAllDayEvent(allDayTimeType): {
			switch (allDayTimeType) {
				CalendarCurrentEvent(): getEventView(_("All Day"), currentColors, false);
				CalendarFutureEvent(): getEventView(_("All Day"), futureColors, false);
				default: getEventView(_("All Day"), getColors(0.0), true);
			}
		}
		CalendarCurrentEvent(): getEventView(geEventTimeString(), currentColors, false);
		CalendarFutureEvent(): getEventView(geEventTimeString(), futureColors, false);
		CalendarPastEvent(): getEventView(geEventTimeString(), getColors(0.0), true);
	}
}

getCalendarDayView(
	manager : MaterialManager,
	date : Date,
	dayEvents : [CalendarEvent],
	dayEventTypes : [CalendarEventDecription],
	addEvent : () -> void,
	isPrintingB : Transform<bool>,
	styles : [CalendarForEventsStyle]
) -> CalendarTabView {
	getEventView = extractStruct(styles, CalendarCustomEventView(\__, e, __, __, __, getDefaultView -> getDefaultView(e))).getView;
	isReadOnlyB = extractStruct(styles, CalendarReadOnly(const(false))).isReadOnlyB;
	isReadOnlyEvent = extractStruct(styles, CalendarReadOnlyEvent(\__ -> const(false))).isReadOnly;
	hideContentViewFrame = containsStruct(styles, CalendarHideContentFrame());
	enableScrolls = extractStruct(styles, CalendarScrolls(true)).enable;
	hideTimeline = containsStruct(styles, CalendarHideTimelineInDayView());
	openReadOnlyDialog = extractStruct(styles, CalendarReadOnlyEventDialog(nop1)).open;
	combinedEventsView = extractStruct(styles, CalendarCombinedEventsView(\__, __ -> [], \__, __, __ -> MEmpty()));

	getTime = \ -> stamp2time2(timestamp());
	isToday = getCurrentDate() == date;
	isPastDay = date < getCurrentDate();
	currentTimeB = make(getTime());
	timer = repeatable2(5 * 60 * 1000, false);
	pastColor = MGrey(400);
	futureColor = if (isToday) getPrimaryColor(manager) else pastColor;
	firstEventIdB = make(0);
	lastEventIdB = make(0);

	getDayEventView = \timeType, dayEvent, isTimelineCircleVisible -> {
		getDefaultView = \event -> {
			bottomMargin = MFixedY(4.0);
			MLines2A(
				getCalendarDayEventDefaultView(event, dayEvent.type, timeType, styles),
				switch (timeType) {
					CalendarAllDayEvent(__): bottomMargin;
					default: MShow(fneq(lastEventIdB, dayEvent.index), bottomMargin);
				}
			);
		}

		isEditAllowedT = fand(const(dayEvent.type.editAction != nop1), fand(fnot(isReadOnlyEvent(dayEvent.event)), fnot(isReadOnlyB)));
		onClick = \ -> {
			if (fgetValue(isEditAllowedT)) {
				dayEvent.type.editAction(dayEvent.event.id);
			} else {
				openReadOnlyDialog(dayEvent.event.id);
			}
		}

		eventViewM = MComponent(
			[MOnClick(onClick), MEnabled(fOr(const(openReadOnlyDialog != nop1), isEditAllowedT))],
			\__ -> getEventView(DayTab(), dayEvent.event, dayEvent.type, date, 1, getDefaultView)
		);
		border = if (hideContentViewFrame) 0.0 else 12.0;
		if (hideTimeline) {
			eventViewM |> MBorderLeftRight(border);
		} else {
			timelineM = getCalendarDayEventTimeline(dayEvent, timeType, currentTimeB, firstEventIdB, lastEventIdB, isTimelineCircleVisible, pastColor, futureColor);
			MColsSameHeight([timelineM |> MBorderEnd(4.0), eventViewM |> MBorderEnd(border)]);
		}
	}

	combinedEvents = combinedEventsView.getCombinedEvents(DayTab(), dayEvents);
	getDayEvent = \i, event -> {
		if (exists(combinedEvents, \e -> e.id == event.id)) {
			None();
		} else {
			maybeMap(find(dayEventTypes, \type -> type.name == event.eventType), \type -> CalendarDayEvent(i, event, type, make(0.0)));
		}
	}

	sortDayEvents = \events -> sortCustom(events, \e -> time2stamp(e.event.startDate) + time2stamp(e.event.endDate) * 0.001, true);
	isAllDayEvent = \dayEvent -> {
		time2date(dayEvent.event.startDate) != time2date(dayEvent.event.endDate) ||
			(dayEvent.event.startDate <= date2time(date) && dayEvent.event.endDate >= date2timeEOD(date));
	}
	splittedEvents = unzip(filtermapi(dayEvents, getDayEvent), isAllDayEvent);

	allDayEvents = splittedEvents.first;
	nonAllDayEvents = sortDayEvents(splittedEvents.second);
	pastEventsB = make([]);
	currentEventsB = make([]);
	futureEventsB = make([]);

	addFrame = \m -> if (hideContentViewFrame) {
		MGroup2(MFillXY(), m);
	} else {
		MFrame(4.0, 0.0, [MStroke(MGrey(300)), StrokeWidth(1.0)], MGroup2(MFillXY(), m));
	}

	getAllDayEvent = \event -> {
		currentTime = getValue(currentTimeB);
		type = if (currentTime > event.event.endDate) {
			CalendarPastEvent();
		} else if (currentTime > event.event.startDate) {
			CalendarCurrentEvent();
		} else {
			CalendarFutureEvent();
		}
		getDayEventView(CalendarAllDayEvent(type), event, false);
	}
	getPastEvent = \event -> getDayEventView(CalendarPastEvent(), event, false);
	getCurrentEvent = \event, isFirst -> getDayEventView(CalendarCurrentEvent(), event, isFirst);
	getFutureEvent = \event, isFirst -> MSelect(currentEventsB, \currentEvents -> {
		getDayEventView(CalendarFutureEvent(), event, isFirst && currentEvents == [] && isToday);
	});

	scrollPositionB = make(Point(0.0, 0.0));
	if (isToday) {
		deferUntilRender(\ -> {
			h = dsum(map(getValue(pastEventsB), \e -> getValue(e.heightB)));
			nextDistinct(scrollPositionB, Point(0.0, h));
		});
	}

	updateFirstLastEvents = \events -> {
		size = length(events);
		if (size > 0) {
			nextDistinct(firstEventIdB, events[0].index);
			nextDistinct(lastEventIdB, events[size - 1].index);
		}
	}

	updateEvents = \events, currentTime -> {
		currentDate = time2date(currentTime);
		if (currentDate > date) {
			nextDistinct(pastEventsB, events);
			updateFirstLastEvents(events);
		} else if (currentDate < date) {
			nextDistinct(futureEventsB, events);
			updateFirstLastEvents(events);
		} else {
			unpair(unzip(events, \e -> currentTime > e.event.startDate), \nonFutureEvents, newFutureEvents -> {
				unpair(unzip(concat(nonFutureEvents, getValue(currentEventsB)), \e -> currentTime > e.event.endDate), \newPastEvents, newCurrentEvents -> {
					newSortedPastEvents = sortDayEvents(concat(getValue(pastEventsB), newPastEvents));
					newSortedCurrentEvents = sortDayEvents(newCurrentEvents);
					nextDistinct(pastEventsB, newSortedPastEvents);
					nextDistinct(currentEventsB, newSortedCurrentEvents);
					nextDistinct(futureEventsB, newFutureEvents);
					updateFirstLastEvents(concatA([newSortedPastEvents, newSortedCurrentEvents, newFutureEvents]));
				});
			});
		}
	}

	updateEvents(nonAllDayEvents, getValue(currentTimeB));

	getNoEventsView = \ -> {
		MCenter(
			MLinesXCenter([
				MIcon("event", [MIconSize(168.0), MCustomColor(0xF6F7F9)]) |> MBorderBottom(4.0),
				MText(if (isPastDay) _("No Events") else _("No Events Yet"), [MTitle(), MGrey(600)]) |> MBorderBottom(16.0),
				MVisible(
					fand(const(!isPastDay), fnot(fOr(isReadOnlyB, isPrintingB))),
					MTextButton(_("ADD EVENT"), addEvent, [MButtonRaised(), MButtonPaddings(32.0, 12.0, 32.0, 12.0)], [])
				)
			])
		);
	}

	openDayEventsPopup = \events -> dayEventsPopup(date, events, make(dayEventTypes), manager, [], 0, true, styles);

	getEventsView = \ -> {
		MLinesA([
			combinedEventsView.getView(DayTab(), combinedEvents, openDayEventsPopup),
			MLinesA(map(allDayEvents, \event -> MAttachHeight(getAllDayEvent(event), event.heightB))),
			MLinesA([
				SelectMLinesA(pastEventsB, \__, i, event -> MAttachHeight(getPastEvent(event), event.heightB)),
				SelectMLinesA(currentEventsB, \__, i, event -> MAttachHeight(getCurrentEvent(event, i == 0), event.heightB)),
				SelectMLinesA(futureEventsB, \__, i, event -> MAttachHeight(getFutureEvent(event, i == 0), event.heightB)),
			]) |> (\c ->
				if (enableScrolls) MScroll(c, MFillXY(), [TScrollSetPosition(scrollPositionB)])
				else c
			)
		]);
	}

	CalendarTabView(
		MConstruct([
				\ -> if (isToday) {
					timer.start();
					\ -> timer.stop();
				} else nop,
				makeSubscribe2(timer.value, \__ -> nextDistinct(currentTimeB, getTime())),
				makeSubscribe2(currentTimeB, \time -> updateEvents(getValue(futureEventsB), time))
			],
			addFrame(if (allDayEvents == [] && nonAllDayEvents == [] && combinedEvents == []) getNoEventsView() else getEventsView())
		),
		\availableSize -> {
			rows = concatA([
				map(allDayEvents, \e -> Pair(getAllDayEvent(e), getValue(e.heightB))),
				map(getValue(pastEventsB), \e -> Pair(getPastEvent(e), getValue(e.heightB))),
				mapi(getValue(currentEventsB), \i, e -> Pair(getCurrentEvent(e, i == 0), getValue(e.heightB))),
				mapi(getValue(futureEventsB), \i, e -> Pair(getFutureEvent(e, i == 0), getValue(e.heightB)))
			]);
			pagesRows = foldi(rows, Pair([], 0.0), \i, acc, row -> {
				rowHeight = row.second;
				if (acc.first == []) {
					Pair([[row.first]], rowHeight);
				} else if (acc.second + rowHeight < availableSize.height) {
					lastIndex = length(acc.first) - 1;
					newRows = replace(acc.first, lastIndex, arrayPush(acc.first[lastIndex], row.first));
					Pair(newRows, acc.second + rowHeight);
				} else {
					Pair(arrayPush(acc.first, [row.first]), rowHeight);
				}
			}).first;

			if (pagesRows == []) {
				[addFrame(getNoEventsView())];
			} else {
				map(pagesRows, \pageRows -> addFrame(MLinesA(pageRows)));
			}
		},
		TEmpty()
	);
}

getCalendarTabById(tabId : string) -> Maybe<CalendarTab> {
	if (tabId == "year") {
		Some(YearTab());
	} else if (tabId == "month") {
		Some(MonthTab());
	} else if (tabId == "planned") {
		Some(PlannedTab());
	} else if (tabId == "range") {
		Some(RangeTab());
	} else if (tabId == "week") {
		Some(WeekTab());
	} else if (tabId == "day") {
		Some(DayTab());
	} else {
		None();
	}
}

getCalendarTabId(tab : CalendarTab) -> string {
	switch (tab) {
		YearTab(): "year";
		MonthTab(): "month";
		PlannedTab(): "planned";
		RangeTab(): "range";
		WeekTab(): "week";
		DayTab(): "day";
	}
}

getCalendarTabName(tab : CalendarTab) -> string {
	switch (tab) {
		YearTab(): _("Year");
		MonthTab(): _("Month");
		PlannedTab(): _("Planned");
		RangeTab(): _("Range");
		WeekTab(): _("Week");
		DayTab(): _("Day");
	}
}

CalendarForEvents(
	allEvents : DynamicBehaviour<[CalendarEvent]>,
	currentEventTypes : DynamicBehaviour<[CalendarEventDecription]>,
	manager : MaterialManager,
	dateMin : Date,
	dateMax : Date,
	defaultMonthNumber : int,
	displayedEventsInOneDay : int,
	onlyOneSameTypeEventsByDay : bool,
	colorizeDayHeaders : bool,
	styles : [CalendarForEventsStyle]) -> Material {

	isOnlyOneSameTypeEventsByDay := onlyOneSameTypeEventsByDay;
	isColorizeDayHeaders := colorizeDayHeaders;
	hideAddEventButton = contains(styles, HideAddEventButton());
	calendarHeaderStyle = extractStruct(styles, defaultCalendarHeaderStyle);
	hideLegend = containsStruct(styles, CalendarHideEventTypesLegend());
	externalDateM = tryExtractStruct(styles, CalendarCurrentDate(make(nullDate)));
	showTodayButton = containsStruct(styles, CalendarShowTodayButton());
	headerTightWidth = containsStruct(styles, CalendarHeaderTightWidth());
	menuAddEventButtonM = tryExtractStruct(styles, CalendarHeaderAddEventButton([]));
	isReadOnlyB = extractStruct(styles, CalendarReadOnly(const(false))).isReadOnlyB;
	printButtonStyleM = maybeMap(tryExtractStruct(styles, CalendarPrintable([])), \p -> p.style);
	isTabsDropdown = containsStruct(styles, CalendarTabsDropdown());
	hideEventsCount = containsStruct(styles, CalendarYearHideEventsCount());
	getCustomHeader = extractStruct(styles, CalendarCustomHeader(\__, __, __ -> None())).getView;
	enableScrolls = extractStruct(styles, CalendarScrolls(true)).enable;
	pebbleControllerM = maybeMap(tryExtractStruct(styles, CalendarPebbles(makeDummyPebbleController())), \pebble -> pebble.controller);

	filteredEvents = make(getValue(allEvents));
	hiddenEventTypes = extractStruct(styles, HiddenEventTypes([])).types;
	choosedFilters = make(hiddenEventTypes);

	isMobileViewB = if (isMobilePhone()) const(true) else fless(fwidth(manager.stageWH), const(1000.0));

	tabOrder : [CalendarTab] = extractStruct(styles, TabOrder([YearTab(), MonthTab(), PlannedTab()])).tabs;
	defaultTabFromStyle = extractStruct(styles, DefaultTab(YearTab())).tab;
	defaultTab = if (!contains(tabOrder, defaultTabFromStyle)) firstElement(tabOrder, YearTab()) else defaultTabFromStyle;
	selectedTabB = make(defaultTab);
	scrollPositionB = make(Point(0.0, 0.0));

	tabColors = extractStruct(styles, TabColors(MWhite(), MGrey(300)));
	activeTabColor = tabColors.activeTabColor;
	nonActiveTabColor = tabColors.nonActiveTabColor;
	hideTabs = length(tabOrder) < 2 || containsStruct(styles, CalendarHideTabs());

	maxYear = dateMax.year;
	minYear = dateMin.year;

	choosedTabsColor = MCustomColor(0xFDB22B);

	monthValue = \year, month -> Date(year, month, 1);
	currentMonthNumber = make(defaultMonthNumber);
	currentMonthDate = monthValue(stamp2date(timestamp()).year, defaultMonthNumber);
	currentDate = make(eitherMap(
		externalDateM,
		\externalDate -> {
			date = getValue(externalDate.currentDateB);
			if (date == nullDate) currentMonthDate else date;
		},
		currentMonthDate
	));

	width = calendarDateCellW * 7.0;
	height = calendarDateCellH * 7.0 + calendarDateNavSize;

	isPrintingB = make(false);
	yearB = fselect(currentDate, FLift(\date -> date.year));
	eventsOpacities = extractStruct(styles, CalendarEventsOpacities(None(), None(), None()));
	//It creates an image for one month (as in DatePicker)
	monthView = \monthNumber : int -> {
		openPopupForDay = \date : Date, dayEvents : [CalendarEvent] -> {
			dayEventsPopup(date, dayEvents, currentEventTypes, manager, getValue(choosedFilters), 0, dayEvents != [], styles);
		}
		// TODO: display combined events
		combinedEventsView = extractStruct(styles, CalendarCombinedEventsView(\__, __ -> [], \__, __, __ -> MEmpty()));

		MColsA([
			TFixed(calendarPickerMarginCells, 0.0),
			MSelect(yearB, \year -> {
				month = monthValue(year, monthNumber);
				filteredEventsByMonthB = fselect(filteredEvents, FLift(\events -> {
					combinedEvents = combinedEventsView.getCombinedEvents(YearTab(), events);
					filter(events, \event -> {
						timeYearCheck(event.startDate.year, event.endDate.year, year)
							&& timeMonthCheck(event.startDate, event.endDate, month)
							&& !exists(combinedEvents, \e -> e.id == event.id)
					});
				}));
				MSelect(filteredEventsByMonthB, \events -> {
					MClickable(
						MCrop(
							const(zeroPoint),
							const(WidthHeight(width, height)),
							CalendarCells(
								manager, MPrimaryColor(), month, currentDate, dateMin, dateMax, isPrintingB, events,
								currentMonthNumber, openPopupForDay, currentEventTypes, hideEventsCount, eventsOpacities, isReadOnlyB
							)
						),
						\-> {
							nextDistinct(currentMonthNumber, monthNumber);
							nextDistinct(currentDate, Date(getValue(currentDate).year, monthNumber, 1));
							if (contains(tabOrder, MonthTab())) nextDistinct(selectedTabB, MonthTab());
						}
					);
				})
			}),
			TFixed(calendarPickerMarginCells, 0.0)
		]);
	};

	monthWidth = width + 2.0 * calendarPickerMarginCells;
	yearAvailableWidthB = make(0.0);
	getMonthsPerRow = \availableWidth -> {
		monthsPerRow = floor(availableWidth / monthWidth);
		if (monthsPerRow == 5) 4 else min(6, monthsPerRow);
	}
	yearWidthB = fselect(yearAvailableWidthB, FLift(\availableWidth -> {
		monthWidth * i2d(getMonthsPerRow(availableWidth));
	}));
	
	monthViewsM = generate(1, 13, monthView);
	annualView = CalendarTabView(
		MAttachAvailableWidth(
			MIfLazy(fless(yearAvailableWidthB, const(monthWidth * 2.0)), \isOneColumn -> {
				if (isOneColumn) {
					month = getCurrentDate().month;
					scaleB = fdivide(yearAvailableWidthB, const(monthWidth));
					if (month > 1) {
						monthHeight = 250.0;
						scrollPositionY = 16.0 + monthHeight * i2d(month - 1);
						nextDistinct(scrollPositionB, Point(0.0, 0.0));
						deferUntilRender(\ -> nextDistinct(scrollPositionB, Point(0.0, scrollPositionY * fgetValue(scaleB))));
					}
					MScale(ffactor2(scaleB), MLinesA(monthViewsM));
				} else {
					MAvailableWidth(
						MFlexibleGrid(const(monthViewsM), [CenterAlign()]),
						yearWidthB
					);
				}
			}),
			yearAvailableWidthB
		),
		\availableSize -> {
			monthsPerRow = getMonthsPerRow(availableSize.width);
			rowsPerPage = floor(availableSize.height / height);
			monthsPerPage = monthsPerRow * rowsPerPage;
			pagesCount = ceil(12.0 / i2d(monthsPerPage));
			generate(0, pagesCount, \i -> {
				MAvailable(
					MLines2A(
						MFlexibleGrid(const(subrange(monthViewsM, i * monthsPerPage, monthsPerPage)), [CenterAlign()]),
						MFillY()
					),
					TFillMaxWY(i2d(monthsPerRow) * monthWidth)
				);
			});
		},
		TEmpty()
	);

	makeTabTitle = \tab : CalendarTab -> {
		minWidth = 120.;
		maxWidth = 210.;
		tabHeight = 62.0;
		MClickable(
			MGroup2(
				MSelect(selectedTabB, \selectedTab ->
					TRectangle(
						[MFill(choosedTabsColor),
						FillOpacity(if (selectedTab == tab) 1.0 else 0.0)],
						TFillXYXY(minWidth, 5., maxWidth, 5.)
					)
				),
				MCenterIn(
					MSelect(selectedTabB, \selectedTab ->
						MParagraph(
							toUpperCase(getCalendarTabName(tab)),
							[
								if (selectedTab == tab) activeTabColor else nonActiveTabColor,
								if (selectedTab == tab) MCustomFont(20., "RobotoMedium", primaryTextOpacity) else MTitle(),
								CenterAlign(), MWidth(maxWidth)
							]
						)
					),
					TFillXYXY(minWidth, tabHeight, maxWidth, tabHeight)
				)
			),
			\ -> nextDistinct(selectedTabB, tab)
		)
	}

	subMenuButtonStyle = calendarHeaderStyle.button;
	subMenuDropdownStyle = concat([MRightIcon("arrow_drop_down", []), MButtonPaddings(14.0, 2.0, 10.0, 2.0)], subMenuButtonStyle);
	tabTitles = MCenterXIn(MColsA(map(tabOrder, makeTabTitle)), TFillX());
	tabsDropdownButtonM = MSelect(selectedTabB, \tab -> {
		name = getCalendarTabName(tab);
		MTextButton(name, nop, subMenuDropdownStyle, []);
	});
	tabsDropdownM = if (!hideTabs && isTabsDropdown) {
		selectedTabIdB = make(elemIndex(tabOrder, getValue(selectedTabB), 0));
		MConstruct([
				\ -> fBidirectionalLink(selectedTabB, selectedTabIdB,
					\selectedTab -> nextDistinct(selectedTabIdB, elemIndex(tabOrder, selectedTab, 0)),
					\selectedTabId -> if (existsIndex(tabOrder, selectedTabId)) {
						nextDistinct(selectedTabB, tabOrder[selectedTabId]);
					}
				)
			],
			MDropDown(selectedTabIdB, "", map(tabOrder, getCalendarTabName), [MCustomButton(tabsDropdownButtonM), MOutlined()])
		)|> MBorderEnd(14.0);
	} else {
		MEmpty();
	}

	makeLegend = \eventDescription -> {
		focused = make(false);
		eventIndex = either(findi(choosedFilters |> getValue, \p -> p == eventDescription.name), -1);
		clicked = make((eventIndex != -1));

		MBorder2(0., 10.,
			MColsA([
				MMouseDownAround(None(), make(false), focused, nop,
					MGroup2(
						TCircle(10., [MFill(eventDescription.backColor)]),
						MSelect(clicked, \f-> if (f)
								MIconButton("visibility_off", \-> {
										index = either(findi(choosedFilters |> getValue, \p -> p == eventDescription.name), -1);
										if (index != -1) next(choosedFilters, removeIndex(getValue(choosedFilters), index));
										next(clicked, false);
									}, [MIconSize(10.)], []
								)
							else
								MSelect(focused, \f2-> if (f2)
									MIconButton("visibility", \-> {
											next(choosedFilters, arrayPush(getValue(choosedFilters), eventDescription.name));
											next(clicked, true);
										}, [MIconSize(10.)], []
									) else TEmpty()
								)
						)
					)
				),
				MFixedX(16.0),
				MCenterYIn(
					MText(eventDescription.name, [MCaption()]),
					MFixedY(20.0)
				),
				MFixedX(30.0)
			])
		);
	}

	subMenuIconStyle = arrayPush(calendarHeaderStyle.icon, MIconButtonBorder(4.0));

	monthTable = MonthTable(filteredEvents, currentEventTypes, currentDate, dateMin, dateMax, manager, displayedEventsInOneDay, choosedFilters, isMobileViewB, isPrintingB, styles);
	plannedTable = PlannedEventsTable(filteredEvents, currentEventTypes, manager, tabsDropdownM, styles);

	eventTypesForPrintingB = make([]);

	getLegend = \isPrint -> {
		// for printing show only types of visible events
		filteredTypesB = if (isPrint) {
			eventTypesForPrintingB;
		} else {
			currentEventTypes;
		}
		MFrame(0.0, 0.0, [MFill(MGrey(100))],
			MFlexibleGrid(fselect(filteredTypesB, FLift(\types -> map(types, makeLegend))), [CenterAlign()])
		);
	}

	legendM = getLegend(false);
	printLegendM = getLegend(true);

	addHeaderBackground = \m -> MFrame(0.0, 0.0, calendarHeaderStyle.background, m);
	addHeaderBorder = \m -> MCenterX(m |> MBorderTopBottom(16.0));
	addLeftRightBorder = \m, b -> {
		borderT = fselect(isMobileViewB, FLift(\isMobile -> if (isMobile) 4.0 else b));
		MBorderTA(borderT, const(0.0), borderT, const(0.0), m);
	}

	showFloatingButtonInDayTabB = make(true);

	TabContent = \tab : CalendarTab -> {
		updateCurrentDate = \newDate : Date -> {
			if (newDate == nullDate) {
				nextDistinct(currentDate, getCurrentDate());
			} else if (isDateBetween(newDate, dateMin, dateMax)) {
				nextDistinct(currentDate, newDate);
			}
		}
		customFontStyle = calendarHeaderStyle.text;
		subMenuSize = TFillX();

		isSwipePaused = make(false);
		pauseSwipe = \ -> {
			next(isSwipePaused, true);
			timer(1000, \ -> next(isSwipePaused, false))
		}

		drawCalendarHeaderText = \date, defaultText -> {
			text = either(extractStruct(styles, CalendarHeaderText(\__, __ -> None())).getText(date, tab), defaultText);
			textM = MText(text, customFontStyle);
			if (headerTightWidth) addLeftRightBorder(textM, 32.0) else MCenterX(textM);
		}

		getTodayButton = \currentStartDate -> {
			if (showTodayButton) {
				isNotCurrentYearB = fselect(currentDate, FLift(\date -> date.year != currentStartDate.year));
				MVisible(if (tab != YearTab()) fneq(currentDate, currentStartDate) else isNotCurrentYearB,
					MIf(isMobileViewB,
						MGroup2(
							MIconButton(
								"calendar_today",
								\ -> updateCurrentDate(currentStartDate),
								[MIconButtonBorder(4.0)],
								[]
							),
							MCenterXIn(
								MText(i2s(getCurrentDate().day), [MCaptionColumn()]) |> MBorderTop(11.0),
								MFixedX(32.0)
							)
						),
						MTextButton(
							_("Today"),
							\ -> updateCurrentDate(currentStartDate),
							concat([MButtonPaddings(28.0, 6.0, 28.0, 6.0)], subMenuButtonStyle),
							[]
						)
					)
				);
			} else {
				MEmpty();
			}
		}

		getAddEventButton = \currentStartDate -> {
			eitherMap(menuAddEventButtonM, \addEventButton -> {
				style = if (addEventButton.style == []) subMenuIconStyle else addEventButton.style;
				MShow(fnot(isReadOnlyB), MIconButton("add_circle", \ -> {
					curDate = getValue(currentDate);
					date = if (curDate == currentStartDate) getCurrentDate() else curDate;
					dateEvents = filter(getValue(filteredEvents), \item -> time2date(item.startDate) == date);
					dayEventsPopup(date, dateEvents, currentEventTypes, manager, getValue(choosedFilters), 0, false, styles);
				}, style, [MTooltipText(const(_("Add Event")))]));
			}, MEmpty());
		}

		getPrintButton = \headerM, getPrintPages -> {
			getPrintCalendarIconButton(manager, addHeaderBackground(headerM), printLegendM, getPrintPages, isPrintingB, styles);
		}

		buildActionButtons = \currentStartDate, printButtonM, prevPeriodButtons, nextPeriodButtons -> {
			CalendarActionButtons(
				getAddEventButton(currentStartDate),
				printButtonM,
				tabsDropdownM,
				MEmpty(),
				getTodayButton(currentStartDate),
				prevPeriodButtons,
				nextPeriodButtons
			)
		}

		getAdditionalButtons = \buttons : CalendarActionButtons -> {
			todayButton = addLeftRightBorder(buttons.todayButton, 16.0);
			leftButtons = [
				MGroup2(
					MWidthOf(MColsA([buttons.addButton, buttons.printButton, buttons.groupedByMenu, buttons.tabsDropdown])),
					todayButton
				),
				if (headerTightWidth) MFillX() else MEmpty()
			];
			rightButtons = [
				if (headerTightWidth) MFillX() else MEmpty(),
				MGroup2(
					MWidthOf(todayButton),
					MColsYCenterA([buttons.tabsDropdown, buttons.groupedByMenu, buttons.printButton, buttons.addButton])
				)
			];
			Pair(leftButtons, rightButtons);
		}

		TabHeader = \headerTextM : Material, buttons : CalendarActionButtons -> {
			eitherFn(getCustomHeader(tab, currentDate, buttons), idfn, \ -> {
				items = unpair(getAdditionalButtons(buttons), \leftButtons, rightButtons -> concatA([
					if (headerTightWidth) leftButtons else [],
					[buttons.prevPeriodButtons.first, buttons.prevPeriodButtons.second],
					if (!headerTightWidth) leftButtons else [],
					[headerTextM],
					if (!headerTightWidth) rightButtons else [],
					[buttons.nextPeriodButtons.first, buttons.nextPeriodButtons.second],
					if (headerTightWidth) rightButtons else []
				]));
				centeredItemsM = MCenterX(MColsYCenterA(items));
				addHeaderBackground(centeredItemsM);
			});
		}
		isHorizontalScrollbarVisibleB = make(false);
		TabBody = \body : Material, overlay : Material -> MGroup([
			TRectangle([Fill(white)], TFillXY()),
			MLines2A(
				if (enableScrolls) MScroll(body, TFillXY(), [
					TScrollSetPosition(scrollPositionB),
					TScrollbarsVisible(isHorizontalScrollbarVisibleB, make(false)),
					TScrollPersistent(make(true))
				]) else body,
				if (hideLegend) MEmpty() else legendM
			),
			overlay
		]);

		getYearHeader = \getPrintPages -> {
			headerTextM = MSelect(currentDate, \date -> {
				defaultText = i2s(date.year);
				drawCalendarHeaderText(date, defaultText);
			});
			buttons = buildActionButtons(
				getCurrentDate(),
				getPrintButton(addHeaderBorder(headerTextM), getPrintPages),
				Pair(
					MEmpty(),
					MIconButton(
						"keyboard_arrow_left",
						\ -> updateCurrentDate(addYearsToDate(getValue(currentDate), -1)),
						subMenuIconStyle,
						[]
					),
				),
				Pair(
					MIconButton(
						"keyboard_arrow_right",
						\ -> updateCurrentDate(addYearsToDate(getValue(currentDate), 1)),
						subMenuIconStyle,
						[]
					),
					MEmpty()
				)
			);
			TabHeader(headerTextM, buttons)
		}

		tabContent = switch(tab) {
			YearTab(): {
				MConstruct([
						make3Subscribe(yearB, currentEventTypes, filteredEvents, \year, types, events -> {
							filteredTypes = filter(types, \type -> {
								exists(events, \e -> (year >= e.startDate.year && year <= e.endDate.year) && e.eventType == type.name);
							});
							nextDistinct(eventTypesForPrintingB, filteredTypes);
						}),
						\ -> eitherMap(externalDateM, \externalDate -> {
							externalDateB = externalDate.currentDateB;
							fBidirectionalLink(currentDate, externalDateB,
								\curDate -> nextDistinct(externalDateB, curDate),
								\extDate -> updateCurrentDate(extDate),
							);
						}, nop)
					],
					MLines2A(getYearHeader(annualView.getPrintPages), TabBody(MLines2A(MFixedY(20.), annualView.main), annualView.overlay))
				);
			}

			MonthTab(): {
				getStartOfMonth = \d -> Date(d.year, d.month, 1);
				startOfCurrentMonth = getStartOfMonth(getCurrentDate());
				updateCurrentDate(getStartOfMonth(getValue(currentDate)));
				
				getMonthHeader = \ -> {
					headerTextM = MSelect(currentDate, \date -> {
						defaultText = i2s(date.year) + " " + toUpperCase(monthString(date, true));
						drawCalendarHeaderText(date, defaultText);
					});

					buttons = buildActionButtons(
						startOfCurrentMonth,
						getPrintButton(addHeaderBorder(headerTextM), monthTable.getPrintPages),
						Pair(
							MShow(fnot(isMobileViewB), MIconButton(
								"first_page",
								\ -> updateCurrentDate(addYearsToDate(getValue(currentDate), -1)),
								subMenuIconStyle,
								[]
							)),
							MIconButton(
								"keyboard_arrow_left",
								\ -> updateCurrentDate(addMonthsToDate(getValue(currentDate), -1)),
								subMenuIconStyle,
								[]
							)
						),
						Pair(
							MIconButton(
								"keyboard_arrow_right",
								\ -> updateCurrentDate(addMonthsToDate(getValue(currentDate), 1)),
								subMenuIconStyle,
								[]
							),
							MShow(fnot(isMobileViewB), MIconButton(
								"last_page",
								\ -> updateCurrentDate(addYearsToDate(getValue(currentDate), 1)),
								subMenuIconStyle,
								[]
							))
						)
					);
					TabHeader(headerTextM, buttons);
				}

				MConstruct([
						make3Subscribe(currentDate, currentEventTypes, filteredEvents, \date, types, events -> {
							filteredTypes = filter(types, \type -> {
								exists(events, \e -> (
									(date.year == e.startDate.year && date.month == e.startDate.month) ||
									isDateBetween(date, time2date(e.startDate), time2date(e.endDate))
								) && e.eventType == type.name);
							});
							nextDistinct(eventTypesForPrintingB, filteredTypes);
						}),
						\ -> eitherMap(externalDateM, \externalDate -> {
							externalDateB = externalDate.currentDateB;
							fBidirectionalLink(currentDate, externalDateB,
								\curDate -> nextDistinct(externalDateB, curDate),
								\extDate -> updateCurrentDate(getStartOfMonth(extDate))
							);
						}, nop)
					],
					MIfLazy(isMobileViewB, \isMobile -> {
						if (isMobile) {
							MLines2A(getYearHeader(monthTable.getPrintPages), TabBody(annualView.main, annualView.overlay));
						} else {
							MLines2A(getMonthHeader(), TabBody(monthTable.main, monthTable.overlay));
						}
					})
				);
			}

			PlannedTab(): plannedTable;

			RangeTab(): {
				startDate = make(getCurrentDate());
				endDate = make(addDaysToDate(getValue(startDate), 7));
				// 0 - day, 1 - week, 2 - month
				rangeTypeB = make(0);

				dateButton = \dateB : DynamicBehaviour<Date>, pickMinDate : Date, pickMaxDate : Date -> MTextClickable(
						date2formatString(getValue(dateB), "%DD.%MM.%YYYY"),
						\ -> showDatePickerDialog(
							getValue(dateB),
							manager,
							\newDate -> nextDistinct(dateB, newDate),
							pickMinDate, pickMaxDate,
							\d -> isDateBetween(d, getValue(startDate), getValue(endDate))
						),
						customFontStyle,
						[MHighlightOnHover(const(true))]
				);

				types = [_("Grouped by days"), _("Grouped by weeks"), _("Grouped by months")];
				groupedByView = MSelect(rangeTypeB, \rangeType -> MTextButton(types[rangeType], nop, subMenuDropdownStyle, []));
				groupedByMenu = MDropDown(rangeTypeB, "", types, [MCustomButton(groupedByView), MOutlined()]);

				tabMenuContentM = MCenterX(
					MSelect2(startDate, endDate, \start, end ->
						MColsA([
							dateButton(startDate, dateMin, addDaysToDate(end, -1)),
							MBorder4(4., MText(" — ", customFontStyle)),
							dateButton(endDate, addDaysToDate(start, 1), dateMax),
						]),
					)
				);

				showDayEventsPopup = \date, dayEvents, isGroupOfEvents, rangeType -> {
					dayEventsPopup(date, dayEvents, currentEventTypes, manager, getValue(choosedFilters), rangeType, isGroupOfEvents, styles);
				}

				contentB = fselect4(startDate, endDate, rangeTypeB, filteredEvents, \start, end, rangeType, events -> {
					RangeView(
						manager, events, currentEventTypes, start, end, showDayEventsPopup,
						dateMin, dateMax, rangeType, true, isMobileViewB, isPrintingB, tab, styles
					);
				});

				getPrintPages = \availableSize -> fgetValue(contentB).getPrintPages(availableSize);
				printButtonM = getPrintButton(tabMenuContentM, getPrintPages);

				buttons = CalendarActionButtons(
					MEmpty(), // addButton
					printButtonM,
					tabsDropdownM,
					groupedByMenu,
					MEmpty(), // todayButton
					Pair(MEmpty(), MEmpty()), // prevPeriodButtons : Pair<Material, Material>,
					Pair(MEmpty(), MEmpty()) // nextPeriodButtons : Pair<Material, Material>
				);

				MConstruct([
						make4Subscribe(startDate, endDate, currentEventTypes, filteredEvents, \start, end, eventTypes, events -> {
							filteredTypes = filter(eventTypes, \type -> {
								exists(events, \e -> (
									isDateBetween(time2date(e.startDate), start, end) ||
									isDateBetween(start, time2date(e.startDate), time2date(e.endDate))
								) && e.eventType == type.name);
							});
							nextDistinct(eventTypesForPrintingB, filteredTypes);
						}),
						\ -> eitherMap(externalDateM, \externalDate -> {
							externalDateB = externalDate.currentDateB;
							fBidirectionalLink(startDate, externalDateB,
								\date -> nextDistinct(externalDateB, date),
								\date -> {
									if (getValue(startDate) > date) {
										nextDistinct(startDate, date);
									} else if (getValue(endDate) < date) {
										nextDistinct(endDate, date);
									}
								}
							);
						}, nop)
					],
					MLines2A(TabHeader(tabMenuContentM, buttons), TabBody(MSelect(contentB, \content -> content.main), MSelect(contentB, \content -> content.overlay)))
				);
			}

			WeekTab(): {
				// set current date as start of current week
				getStartOfWeek = \d -> addDaysToDate(d, -dayOfWeek(d));
				startOfCurrentWeek = getStartOfWeek(getCurrentDate());
				updateCurrentDate(startOfCurrentWeek);

				contentB = fselect2(currentDate, filteredEvents, FLift2(\start, events -> {
					RangeView(
						manager, events, currentEventTypes, start, addDaysToDate(start, 6),
						\date, dayEvents, isGroupOfEvents, rangeType -> {
							dayEventsPopup(date, dayEvents, currentEventTypes, manager, getValue(choosedFilters), rangeType, isGroupOfEvents, styles)
						},
						dateMin, dateMax, 0, false, isMobileViewB, isPrintingB, tab, styles
					)
				}));

				headerTextM = MSelect(currentDate, \date -> {
					defaultText = formatString("WEEK %1 OF %2", [i2s(getWeekOfYear(date, 0, true)), i2s(date.year)]);
					drawCalendarHeaderText(date, defaultText);
				});

				getPrintPages = \availableSize -> fgetValue(contentB).getPrintPages(availableSize);

				buttons = buildActionButtons(
					startOfCurrentWeek,
					getPrintButton(addHeaderBorder(headerTextM), getPrintPages),
					Pair(
						MShow(fnot(isMobileViewB), MIconButton(
							"first_page",
							\ -> updateCurrentDate(addDaysToDate(getValue(currentDate), -28)),
							subMenuIconStyle,
							[]
						)),
						MIconButton(
							"keyboard_arrow_left",
							\ -> updateCurrentDate(addDaysToDate(getValue(currentDate), -7)),
							subMenuIconStyle,
							[]
						)
					),
					Pair(
						MIconButton(
							"keyboard_arrow_right",
							\ -> updateCurrentDate(addDaysToDate(getValue(currentDate), 7)),
							subMenuIconStyle,
							[]
						),
						MShow(fnot(isMobileViewB), MIconButton(
							"last_page",
							\ -> updateCurrentDate(addDaysToDate(getValue(currentDate), 28)),
							subMenuIconStyle,
							[]
						))
					)
				);

				availableWidthB = make(0.0);
				hideWeekends = contains(styles, CalendarHideWeekends());
				weekAddaptiveWdith = extractStruct(styles, CalendarWeekAdaptiveWidth(800.0, 5.4));
				minWidthT = fselect3(isMobileViewB, currentDate, availableWidthB, \isMobileView, start, availableWidth -> {
					if (!isMobileView && !hideWeekends && availableWidth < weekAddaptiveWdith.minAvailableWidth) {
						daysBetweenStartAndToday = i2d(getDaysBetweenDates(start, getCurrentDate()));
						factor = max(7.0 / weekAddaptiveWdith.visibleWeekdays, 1.0);
						if (daysBetweenStartAndToday > 2.0 && daysBetweenStartAndToday < 7.0) {
							deferUntilRender(\ -> nextDistinct(scrollPositionB, Point(availableWidth * (factor - 1.0), 0.0)));
						}
						availableWidth * factor;
					} else {
						0.0;
					}
				});

				MConstruct([
						make3Subscribe(currentDate, currentEventTypes, filteredEvents, \date, types, events -> {
							filteredTypes = filter(types, \type -> {
								exists(events, \e -> (
									isDateBetween(time2date(e.startDate), date, addDaysToDate(date, 6)) ||
									isDateBetween(date, time2date(e.startDate), time2date(e.endDate))
								) && e.eventType == type.name);
							});
							nextDistinct(eventTypesForPrintingB, filteredTypes);
						}),
						\ -> eitherMap(externalDateM, \externalDate -> {
							externalDateB = externalDate.currentDateB;
							fBidirectionalLink(currentDate, externalDateB,
								\curDate -> nextDistinct(externalDateB, curDate),
								\extDate -> updateCurrentDate(getStartOfWeek(extDate))
							);
						}, nop)
					],
					MLines2A(
						TabHeader(headerTextM, buttons),
						MAttachAvailableWidth(
							TabBody(MAvailableWidth(MSelect(contentB, \content -> content.main), fmax(minWidthT, availableWidthB)), MSelect(contentB, \content -> content.overlay)),
							availableWidthB
						)
					)
				);
			}

			DayTab(): {
				updateCurrentDate(getCurrentDate());
				headerTextM = MSelect(currentDate, \date -> {
					defaultText = date2formatString(date, "%MMMM %DD, %YYYY");
					drawCalendarHeaderText(date, defaultText);
				});

				contentB = fselect3(currentDate, filteredEvents, currentEventTypes, \date, events, types -> {
					dayEvents = filter(events, \event -> date >= time2date(event.startDate) && date <= time2date(event.endDate));
					dayEventTypes = filter(types, \type -> exists(dayEvents, \event -> event.eventType == type.name));
					addEvent = \ -> dayEventsPopup(date, dayEvents, currentEventTypes, manager, getValue(choosedFilters), 0, false, styles);
					nextDistinct(eventTypesForPrintingB, dayEventTypes);
					nextDistinct(showFloatingButtonInDayTabB, date < getCurrentDate() || dayEvents != []);
					getCalendarDayView(manager, date, dayEvents, dayEventTypes, addEvent, isPrintingB, styles);
				});

				getPrintPages = \availableSize -> fgetValue(contentB).getPrintPages(availableSize);

				buttons = buildActionButtons(
					getCurrentDate(),
					getPrintButton(addHeaderBorder(headerTextM), getPrintPages),
					Pair(
						MEmpty(),
						MIconButton(
							"keyboard_arrow_left",
							\ -> updateCurrentDate(addDaysToDate(getValue(currentDate), -1)),
							subMenuIconStyle,
							[]
						)
					),
					Pair(
						MIconButton(
							"keyboard_arrow_right",
							\ -> updateCurrentDate(addDaysToDate(getValue(currentDate), 1)),
							subMenuIconStyle,
							[]
						),
						MEmpty()
					)
				);

				MConstruct([
						\ -> eitherMap(externalDateM, \externalDate -> {
							externalDateB = externalDate.currentDateB;
							fBidirectionalLink(currentDate, externalDateB,
								\curDate -> nextDistinct(externalDateB, curDate),
								\extDate -> updateCurrentDate(extDate)
							);
						}, nop)
					],
					MLines2A(TabHeader(headerTextM, buttons), TabBody(MSelect(contentB, \content -> content.main), MSelect(contentB, \content -> content.overlay)))
				);
			}
		}

		MIfLazy(isHorizontalScrollbarVisibleB, \isVisible -> {
			if (isVisible) {
				tabContent;
			} else {
				MSwipe(
					tabContent,
					[
						MOnSwipeLeft(\point, delta -> {
							selectedTabId = elemIndex(tabOrder, getValue(selectedTabB), 0);
							if (!getValue(isSwipePaused) && delta.x < -20. && selectedTabId > 0) {
								nextDistinct(selectedTabB, tabOrder[selectedTabId - 1]);
								pauseSwipe();
							}
							true;
						}),
						MOnSwipeRight(\point, delta -> {
							tabsCount = length(tabOrder);
							selectedTabId = elemIndex(tabOrder, getValue(selectedTabB), tabsCount);
							if (!getValue(isSwipePaused) && delta.x > 20. && selectedTabId < tabsCount - 1) {
								nextDistinct(selectedTabB, tabOrder[selectedTabId + 1]);
								pauseSwipe();
							}
							true;
						})
					]
				)
			}
		});
	}
	tabContent = MSelect(selectedTabB, \tab -> TabContent(tab));

	viewM = MConstruct(
		[
			makeSubscribe(allEvents, \events -> {
				filters = getValue(choosedFilters);
				nextDistinct(filteredEvents, filter(events, \item -> !contains(filters, item.eventType)));
			}),
			makeSubscribe2(choosedFilters, \cf -> {
				nextDistinct(filteredEvents, filter(getValue(allEvents), \item -> !contains(cf, item.eventType)));
			})
		],
		MGroup([
			MLinesA([
				if (hideTabs || isTabsDropdown) MEmpty() else tabTitles,
				if (containsStruct(styles, CalendarDisableHorizontalBorder())) {
					tabContent
				} else {
					addLeftRightBorder(tabContent, 16.0)
				}
			]),
			if (hideAddEventButton) MEmpty()
			else MShow(fand(fnot(isReadOnlyB), fOr(fneq(selectedTabB, DayTab()), showFloatingButtonInDayTabB)),
				MFloatingButton(
					"add",
					[MBottom(), MEnd(), getPrimaryColor(manager)],
					[MOnClick(\-> {
						today = stamp2date(timestamp());
						todayEvents = filter(getValue(filteredEvents), \item -> time2date(item.startDate) == today);
						dayEventsPopup(today, todayEvents, currentEventTypes, manager, getValue(choosedFilters), 0, false, styles);
					})]
				)
			)
		])
	);
	eitherMap(pebbleControllerM, \pebbleController -> {
		selectedTabIdB = make("");
		getTab = \tabId -> {
			tab = either(getCalendarTabById(tabId), defaultTab);
			if (contains(tabOrder, tab)) tab else defaultTab;
		}
		onTabIdChange = \tabId -> {
			if (eitherMap(getCalendarTabById(tabId), \tab -> !contains(tabOrder, tab), true)) {
				setViewFromPebble(pebbleController, extendCurrentPebbleWithParameter(pebbleController, "calendarTab", getCalendarTabId(defaultTab)));
			} else {
				nextDistinct(selectedTabB, getTab(tabId));
			}
		}
		MConstruct(
			[makeSubscribe(selectedTabB, \selectedTab -> nextDistinct(selectedTabIdB, getCalendarTabId(selectedTab)))],
			MLinkPebbleParameters(pebbleController, [PebbleStringLink("calendarTab", selectedTabIdB, onTabIdChange, RecordURLChange())], viewM)
		);
	}, viewM);
}

getPrintCalendarIconButton(
	manager : MaterialManager,
	headerM : Material,
	footerM : Material,
	getPrintPages : (WidthHeight) -> [Material],
	isPrintingB : DynamicBehaviour<bool>,
	styles : [CalendarForEventsStyle]
) -> Material {
	showDialog = \isRunningB : Transform<bool>, disposer : () -> void -> {
		closeB = make(false);
		pageSizeB = make(4);
		pageOrientationB = make(1);
		widthS = make("21.0");
		heightS = make("29.7");

		pagesB = make([]);

		headerHeightB = make(0.0);
		footerHeightB = make(0.0);

		printAvailableWidthB = fselect(TPrintPageSize, FLift(\s -> either(s, WidthHeight(0.0, 0.0)).width));

		onPrint = \ -> {
			maybeApply(getValue(TPrintPageSize), \size -> {
				headerHeight = getValue(headerHeightB);
				footerHeight = getValue(footerHeightB);
				availableSize = WidthHeight(size.width, size.height - headerHeight - footerHeight);
				pages = mapi(getPrintPages(availableSize), \i, p -> {
					MIfPrint(MLinesA([headerM, p, footerM]), MEmpty());
				});
				nextDistinct(pagesB, pages);
				showPrintDialog();
			});
		}

		isCustomSize = \s -> s >= length(MPrintPaperSizes) - 1 || s < 0;
		isCustomSizeB = fselect(pageSizeB, FLift(isCustomSize));

		dialogViewM = MConstruct([
				\ -> addEventListener(getStage(), "beforeprint", \ -> nextDistinct(isPrintingB, true)),
				\ -> addEventListener(getStage(), "afterprint", \ -> nextDistinct(isPrintingB, false)),
				make2SubscribeUns(pageSizeB, pageOrientationB, \s, o -> {
					if (isCustomSize(s)) {
						[
							makeSubscribe(fwh(fselect(widthS, FLift(\w -> cm2pixels(s2d(w)))), fselect(heightS, FLift(\h -> cm2pixels(s2d(h))))), \v -> {
								nextDistinct(TPrintPageSize, Some(v))
							})()
						]
					} else {
						size = MPrintPaperSizes[s].second;
						nextDistinct(TPrintPageSize, Some(if (o == 0) size else WidthHeight(size.height, size.width)));
						[];
					}
				}),
				\ -> \ -> nextDistinct(TPrintPageSize, None())
			],
			MAvailableWidth(MGroup2(
				MFixSize(
					MVisible(make(false),
						MAvailableWidth(
							MGroup2(MAttachHeight(headerM, headerHeightB), MAttachHeight(footerM, footerHeightB)),
							printAvailableWidthB
						)
					),
					MEmpty()
				),
				MLinesA([
					MDropDown(pageSizeB, "", map(MPrintPaperSizes, firstOfPair), [MLabel(_("Page Size:")), MWidth(-1.0)]) |> MBorderBottom(12.0),
					MShowAnimationHeight(
						isCustomSizeB,
						MCenterX(MBaselineColsA([
							MTextInput(widthS, [MWidth(64.0)], []),
							MText(_("cm"), []),
							MIcon("close", []) |> (\f -> MBorder4(12.0, f)),
							MTextInput(heightS, [MWidth(64.0)], []),
							MText(_("cm"), [])
						])),
						[MAutoStart()]
					),
					MShowAnimationHeight(
						fnot(isCustomSizeB),
						MDropDown(pageOrientationB, "", [_("Portrait"), _("Landscape")], [MLabel(_("Orientation:")), MWidth(-1.0)]),
						[MAutoStart()]
					),
					MFixSize(MPrintPages(pagesB), MEmpty())
				])
			), const(240.0))
		);

		dialogStyle = [
			MDialogUseFrame(),
			MDialogClickOutToClose(),
			MDialogTitle(_("Print Dialog")),
			MDialogActions([
				MTextButton(_("CLOSE"), disposer, [], []),
				MTextButton(_("PREVIEW"), onPrint, [], []),
			])
		];

		ShowMDialog(manager, fnot(isRunningB), dialogStyle, dialogViewM);
	}

	getButton = \fn -> {
		eitherMap(tryExtractStruct(styles, CalendarPrintable([])), \p -> {
			calendarHeaderStyle = extractStruct(styles, defaultCalendarHeaderStyle);
			style = if (p.style == []) calendarHeaderStyle.icon else p.style;
			MIconButton("print", fn, style, [MTooltipText(const(_("Print")))]);
			
		}, MEmpty());
	}
	eitherMap(maybeMap(tryExtractStruct(styles, CalendarPebbles(makeDummyPebbleController())), \pebble -> pebble.controller),
		\pebbleController -> {
			printCalendarB = make(false);
			buttonM = getButton(\ -> nextDistinct(printCalendarB, true));
			MLinkPebbleParameters(pebbleController, [makePebbleBoolTrigger("calendarPrint", printCalendarB, showDialog, RecordURLChange())], buttonM);
		},
		getButton(\ -> {
			isRunningB = make(true);
			disposer = \ -> next(isRunningB, false);
			showDialog(isRunningB, disposer);
		})
	);
}
