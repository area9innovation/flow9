import material/material_dialog;
import material/material_ui;
import excel_datetime;
import text/translation;

export {
	CalendarForEvents(
		allEvents : DynamicBehaviour<[CalendarEvent]>,
		currentEventTypes : DynamicBehaviour<[CalendarEventDecription]>,
		manager : MaterialManager,
		dateMin : Date,
		dateMax : Date,
		monthNumber : int,
		displayedEventsInOneDay : int,
		onlyOneSameTypeEventsByDay : bool,
		colorizeDayHeaders : bool,
		styles : [CalendarForEventsStyle]) -> Material;

	CalendarEventDecription(
		name : string,
		mainColor : MColor,
		backColor : MColor,
		icon : string,
		editAction : (id : int) -> void,
		addAction : (fullDate : Time) -> void,
		deleteAction : (id : int) -> void,
		additionalActions : [CalendarAdditionalAction]
	);

	CalendarEvent(
		startDate : Time,
		endDate : Time,
		id : int,
		eventType : string,
		title : string,
		description : string,
		additionalFields : Tree<string, string>
	);

	CalendarAdditionalAction(
		icon : string,
		name : string,
		action : (id : int) -> void
	);

	CalendarDefaultDisplayedEventsInOneDay = 3;

	CalendarForEventsStyle ::= ShowMonthViewSwitchMenu, DefaultMonthView, TabOrder, DefaultTab, TabColors, HideAddEventButton,
		CloseDayPopupAfterAdditionalAction, EventListSettings, PlannedTableDateFormat, BlackAndWhiteTextColor, HideTimeInfo, HiddenEventTypes,
		ShowWeekViewDaysNames, CalendarTabMenuStyle, CalendarTabMenuText, CalendarHideEventTypesLegend, CalendarCurrentDate, CalendarShowTodayButton,
		CalendarMenuTightWidth, CalendarMenuAddEventButton, CalendarReadOnly, CalendarCustomEventView, CalendarPrintable, CalendarTabsDropdown,
		CalendarMonthAdditionalEventsView, CalendarWeekDayView, CalendarDayNumberView, CalendarMonthFillEmpty, CalendarEventsPopup,
		CalendarYearHideEventsCount, CalendarCustomEventTitle, CalendarEventsOpacity, CalendarDayCustomTab,
		CalendarScrolls;

		ShowMonthViewSwitchMenu();
		DefaultMonthView(byWeek : bool);
		TabOrder(tabs : [CalendarTab]);
		DefaultTab(tab : CalendarTab);
		TabColors(activeTabColor : MColor, nonActiveTabColor : MColor);
		HideAddEventButton();
		// It is possible to assign task for date only.
		HideTimeInfo();
		CloseDayPopupAfterAdditionalAction();
		// settings for dayEventsPopup, cols can be for text - "event type", "event description", "event title",
		// and for date and time - "start", "end"
		EventListSettings(cols : [string], showDate : bool, showTime : bool);
		//"%D" to date.day, "%M" to date.month, "%YYYY" to date.year, "%YY" to last two number of date.year
		//(like date2formatString)
		PlannedTableDateFormat(tableDateFormat : string);
		//autochoose text color - between black and white
		BlackAndWhiteTextColor();
		// Hide event types by default
		HiddenEventTypes(types : [string]);
		// Show days names in week view
		ShowWeekViewDaysNames();
		CalendarTabMenuStyle(text : [MTextStyle], icon : [MIconStyle], background : [TGraphicsStyle], button : [MTextButtonStyle]);
		CalendarTabMenuText(getText : (date : Date, tab : CalendarTab) -> Maybe<string>);
		CalendarHideEventTypesLegend();
		// Allows to get or set current date
		CalendarCurrentDate(currentDateB : DynamicBehaviour<Date>);
		CalendarShowTodayButton();
		CalendarMenuTightWidth();
		CalendarMenuAddEventButton(style : [MIconButtonStyle]);
		CalendarReadOnly(isReadOnlyB : Transform<bool>);
		// Show custom event view instead of default. If None - default view is displayed.
		// getView parameters:
		// CalendarTab - tab in which material is displayed
		// CalendarEvent - current event
		// CalendarEventDecription - current event type
		// Date - date of first event cell displayed
		// int - number of cells (dates) in which event is displayed
		CalendarCustomEventView(getView : (CalendarTab, CalendarEvent, CalendarEventDecription, Date, int) -> Maybe<Material>);
		CalendarPrintable(style : [MIconButtonStyle]);
		// Show dropdown with views instead of tabs
		CalendarTabsDropdown();
		// Custom additional events view in month view
		// getView parameters:
		// int - number of additional events
		CalendarMonthAdditionalEventsView(getView : (int) -> Material);
		// Custom week days header in month, range and week views
		// getView parameters:
		// string - text to display
		// CalendarTab - tab in which material is displayed
		CalendarWeekDayView(getView : (string, CalendarTab) -> Material);
		// Custom day number header in month, range and week views
		// getView parameters:
		// string - text to display
		// bool - is today
		// bool - is weekend
		// CalendarTab - tab in which material is displayed
		CalendarDayNumberView(getView : (string, bool, bool, CalendarTab) -> Material);
		// Display previous and next month days in empty cells in month view
		// getTitleView parameters:
		// string - text to display
		// bool - is today
		// bool - is weekend
		CalendarMonthFillEmpty(getTitleView : (string, bool, bool) -> Material);
		// Custom events popup
		// open parameters:
		// bool - is popup opened by clicking on a group of events (year day or "more events" in month tab)
		// Time - day for which popup is opened
		// [CalendarEvent] - day events
		CalendarEventsPopup(open : (bool, Time, [CalendarEvent]) -> void);
		// Hide number of events in year view
		CalendarYearHideEventsCount();
		CalendarCustomEventTitle(getTitle : (CalendarEvent) -> string);
		CalendarEventsOpacity(opacity : double);
		CalendarDayCustomTab(
			getMenuView : (currentDateT : Transform<Date>, buttons : CalendarActionButtons) -> Material,
			needContentViewFrame : bool
		);
		CalendarScrolls(enable : bool);

	CalendarTab ::= YearTab, MonthTab, PlannedTab, RangeTab, WeekTab, DayTab;
		YearTab(); MonthTab(); PlannedTab(); RangeTab(); WeekTab(); DayTab();

	CalendarActionButtons : (
		addButton : Material,
		printButton : Material,
		tabsDropdown : Material,
		todayButton : Material,
		prevPeriodButtons : Pair<Material, Material>,
		nextPeriodButtons : Pair<Material, Material>
	);
}

CalendarTabView(
	main : Material,
	getPrintPages : (availableSize : WidthHeight) -> [Material]
);

emptyEvent = CalendarEvent(Time(2050, 1, 1, 1, 1, 1), Time(2050, 1, 1, 1, 1, 1), 999, "_EMPTY_", "", "", makeTree());

calendarDateCellW = 32.0;
calendarDateCellH = 30.0;
calendarDateNavSize = 40.0;

calendarPickerWidthCells = calendarDateCellW * 7.0;
calendarPickerMarginCells = 12.0;
calendarMpickerWidth = calendarPickerWidthCells + calendarPickerMarginCells * 2.0;
isOnlyOneSameTypeEventsByDay = ref true;
isColorizeDayHeaders = ref true;
defaultCalendarTabMenuStyle = CalendarTabMenuStyle(
	[MWhite(), MCustomFont(20.0, "RobotoMedium", primarySmallTextOpacity)],
	[MIconSize(30.0), MCustomColor(0xFDB22B)],
	[Fill(black)],
	[MCustomColor(0xFDB22B)]
);

isDateEnable(
	thisDate : Date,
	dateMin : Date,
	dateMax : Date) -> bool {

	compareDates(thisDate, dateMin) != DateBefore()
	&& compareDates(thisDate, dateMax) != DateAfter()
}

timeYearCheck(start : int, end : int, year : int) -> bool {
	(start <= year && year <= end)
}

timeMonthCheck(start : Time, end : Time, current : Date) -> bool {
	if (start.year == end.year)
		(start.month <= current.month && current.month <= end.month)
	else if (current.year < end.year)
		if (current.year == start.year)
			(current.month >= start.month)
		else
			true
	else
		(current.month <= end.month)
}

timeDayCheck(start : Time, end : Time, current : Date, dayNumber : int) -> bool {
	if (start.month == end.month && start.year == end.year) //event in one month
		(start.day <= dayNumber && dayNumber <= end.day)
	else if (current.year < end.year) {     //event in two or more years
		if (current.year > start.year)      //in each year between start and end we need ALL days
			true
		else if (current.month > start.month) //in first year we need ALL days after first month
			true
		else                                //in first month we need ONLY days after start
			(dayNumber >= start.day)
	} else if (start.year != end.year) {    //in last year
		if (current.month < end.month)      //we need ALL days before end month
			true
		else
			(dayNumber <= end.day)          //in last month we need ALL days before last day
	} else if (current.month < end.month) {
		if (current.month == start.month)   //in start month we need ONLY days after start
		   (dayNumber >= start.day)
		else                                //in other we need ALL days
			true
	} else {                                //in last month we need ONLY days before end
		(dayNumber <= end.day)
	}
}

getMultiDayEvents(events : [CalendarEvent]) -> [CalendarEvent] {
	filter(events, \event -> time2date(event.startDate) != time2date(event.endDate))
}

sortEvents(events : [CalendarEvent]) -> [CalendarEvent] {
	timeSort = \event : CalendarEvent -> event.startDate;
	//Multi-day events should be earlier than usual, even if they go later.
	//Otherwise, the union between days will not work
	concat(
		sortCustom(getMultiDayEvents(events), timeSort, true),
		sortCustom(filter(events, \event -> time2date(event.startDate) == time2date(event.endDate)), timeSort, true)
	)
}

makeCalendarEventDescription() -> CalendarEventDecription {
	CalendarEventDecription("", MBlack(), MWhite(), "", nop1, nop1, nop1, [])
}

getEventTitleDefault(event : CalendarEvent) -> string {
	if (event.title != "") event.title else if (event.description != "") event.description else event.eventType
}

isTooltipEnabled(event : CalendarEvent) -> bool {
	event.description != "" && event.title != ""
}

//like in DatePicker
CalendarCells(
	manager : MaterialManager,
	color : MThemeColor,
	month : Date,
	currentDate : DynamicBehaviour<Date>,
	dateMin : Date,
	dateMax : Date,
	isPrintingB : DynamicBehaviour<bool>,
	monthEvents : [CalendarEvent],
	monthNumber : DynamicBehaviour<int>,
	openPopupForDay : (date : Date, dayEvents : [CalendarEvent]) -> void,
	currentEventTypes : DynamicBehaviour<[CalendarEventDecription]>,
	hideEventsCount : bool,
	opacity : double,
	isReadOnlyB : Transform<bool>
) -> Material {
	firstDayInWeekOffset = 8 - ((1 + dayOfWeek(month)) % 7);
	dayOfWeekNames = map(enumFromTo(0, 6), \i -> {
		strLeft(dayOfWeekString(addDaysToDate(month, firstDayInWeekOffset + i), true), 1);
	});

	maxDayInMonth = 31;
	filteredByDay = generate(1, maxDayInMonth + 1, \dayNumber -> {
		allEvents = filter(monthEvents, \item -> timeDayCheck(item.startDate, item.endDate, month, dayNumber));
		sortEvents(allEvents)
	});

	startOffset = dayOfWeek(month) % 7;
	daysNum = getNumberOfDaysPerMonthInTheYear(month.year)[month.month];
	invisible = Point(0.0, calendarDateCellH * 6.0);
	offsets = generate(0, maxDayInMonth, \i -> {
		linearOffset = startOffset + i;
		if (i >= daysNum) invisible
		else Point(calendarDateCellW * i2d(linearOffset % 7), calendarDateCellH * i2d(linearOffset / 7))
	});

	todayDate = getCurrentDate();
	MLinesA([
		MCenterIn(
			MText(monthString(month, true), []),
			MFixed(calendarDateCellW * 7.0, calendarDateNavSize)
		),
		MColsA(map(dayOfWeekNames, \wday -> {
			MCenterIn(
				MText(wday, [MCaption()]),
				MFixed(calendarDateCellW, calendarDateCellH)
			)
		})),
		MGroup(mapi(offsets, \i, offset -> {
			MTranslate(
				const(offset),
				CalendarCell(manager, color, month, i + 1, currentDate, dateMin,
					dateMax, todayDate, isPrintingB, filteredByDay[i], monthNumber,
					openPopupForDay, currentEventTypes, hideEventsCount, opacity, isReadOnlyB
				)
			)
		}))
	]);
}

//like in DatePicker
CalendarCell(
	manager : MaterialManager,
	color : MThemeColor,
	thisMonth : Date,
	day : int,
	currentDate : DynamicBehaviour<Date>,
	dateMin : Date,
	dateMax : Date,
	todayDate : Date,
	isPrintingB : DynamicBehaviour<bool>,
	dayEvents : [CalendarEvent],
	monthNumber : DynamicBehaviour<int>,
	openPopupForDay : (date : Date, dayEvents : [CalendarEvent]) -> void,
	eventTypes : DynamicBehaviour<[CalendarEventDecription]>,
	hideEventsCount : bool,
	opacity : double,
	isReadOnlyB : Transform<bool>
) -> Material {
	thisDate = Date(getValue(currentDate).year, thisMonth.month, day);
	isEnabled = isDateEnable(thisDate, dateMin, dateMax);
	isHoverB = make(false);

	textColorB = if (isEnabled) {
		fselect2(isHoverB, isPrintingB, FLift2(\isHover, isPrinting -> {
			if (isHover || (thisDate == todayDate && dayEvents == [] && !isPrinting)) MWhite() else MBlack();
		}));
	} else {
		const(MGrey(500));
	}

	diam = 30.0;
	radius = diam / 2.0;
	bhoriz = if (day < 10) 11.0 else 7.5;
	text = MBorder(bhoriz + 0.5, 7.8, bhoriz - 0.5, 7.8,
		MGroup2(
			MGetFocusGroup(\parent -> TSelectConstantMetrics(textColorB, \col ->
				MText2T(parent, i2s(day), [MCaptionSolid(), col])
			)),
			MFixed(if (day < 10) 8.0 else 15.0, 14.4)
		)
	);

	multiStart = \fillColor -> {
		TGroup([
			TColsA([
				TFixed(radius, 0.),
				TRectangle([MFill(fillColor), FillOpacity(opacity)], TFixed(radius + 2.0, diam)),
			]),
			LongSegment(radius, radius, radius, 180., 360., [MFill(fillColor), FillOpacity(opacity)]) |> TForm
		])
	}

	multiStartWithStart = \mainColor, secondColor -> {
		TGroup([
			TColsA([
				TFixed(radius, 0.),
				TRectangle([MFill(mainColor), FillOpacity(opacity)], TFixed(radius + 2.0, diam)),
			]),
			TGroup([
				Sector2(radius, radius, radius, 180., 360., [MFill(secondColor), FillOpacity(opacity)]) |> TForm,
				Sector2(radius, radius, radius - 2., 180., 360., [MFill(mainColor), FillOpacity(opacity)]) |> TForm
			])
		])
	}

	multiMiddle = \fillColor -> {
		TRectangle([MFill(fillColor), FillOpacity(opacity)], TFixed(diam + 2., diam))
	}

	multiMiddleWithStart = \mainColor, secondColor -> {
		TGroup([
			TRectangle([MFill(mainColor), FillOpacity(opacity)], TFixed(diam + 2., diam)),
			TGroup2(
				Sector2(radius, radius, radius, 180., 360., [MFill(secondColor), FillOpacity(opacity)]) |> TForm,
				Sector2(radius, radius, radius - 2., 180., 360., [MFill(mainColor), FillOpacity(opacity)]) |> TForm
			)
		])
	}

	multiMiddleWithEnd = \mainColor, secondColor -> {
		TGroup([
			TRectangle([MFill(mainColor), FillOpacity(opacity)], TFixed(diam + 2., diam)),
			TGroup2(
				Sector2(radius, radius, radius, 0., 180., [MFill(secondColor), FillOpacity(opacity)]) |> TForm,
				Sector2(radius, radius, radius - 2., 0., 180., [MFill(mainColor), FillOpacity(opacity)]) |> TForm
			)
		])
	}

	multiMiddleWithStartAndEnd = \mainColor, startColor, endColor -> {
		TGroup([
			TRectangle([MFill(mainColor), FillOpacity(opacity)], TFixed(diam + 2., diam)),
			TGroup2(
				Sector2(radius, radius, radius, 180., 360., [MFill(startColor), FillOpacity(opacity)]) |> TForm,
				Sector2(radius, radius, radius - 2., 180., 360., [MFill(mainColor), FillOpacity(opacity)]) |> TForm
			),
			TGroup2(
				Sector2(radius, radius, radius, 0., 180., [MFill(endColor), FillOpacity(opacity)]) |> TForm,
				Sector2(radius, radius, radius - 2., 0., 180., [MFill(mainColor), FillOpacity(opacity)]) |> TForm
			)
		])
	}

	multiEnd = \fillColor -> {
		TGroup([
			TRectangle([MFill(fillColor), FillOpacity(opacity)], TFixed(radius, diam)),
			LongSegment(radius, radius, radius, 0., 180., [MFill(fillColor), FillOpacity(opacity)]) |> TForm
		])
	}

	multiEndWithEnd = \mainColor, secondColor -> {
		TGroup([
			TRectangle([MFill(mainColor), FillOpacity(opacity)], TFixed(radius, diam)),
			TGroup([
				Sector2(radius, radius, radius, 0., 180., [MFill(secondColor), FillOpacity(opacity)]) |> TForm,
				Sector2(radius, radius, radius - 2., 0., 180., [MFill(mainColor), FillOpacity(opacity)]) |> TForm
			])
		])
	}

	multiEndWithStart = \mainColor, secondColor -> {
		TGroup([
			TColsA([
				TFixed(radius, 0.),
				TRectangle([MFill(secondColor), FillOpacity(opacity)], TFixed(radius + 2.0, diam)),
			]),
			TRectangle([MFill(mainColor), FillOpacity(opacity)], TFixed(radius, diam)),
			TGroup([
				Sector2(radius, radius, radius, 0., 180., [MFill(mainColor), FillOpacity(opacity)]) |> TForm,
				Sector2(radius, radius, radius, 180., 360., [MFill(secondColor), FillOpacity(opacity)]) |> TForm,
				Sector2(radius, radius, radius - 2., 180., 360., [MFill(mainColor), FillOpacity(opacity)]) |> TForm
			])
		])
	}

	multiEndWithStartAndEnd = \mainColor, startColor, endColor -> {
		TGroup([
			TCols([
				TFixed(radius, 0.),
				TRectangle([MFill(startColor), FillOpacity(opacity)], TFixed(radius + 2.0, diam)),
			]),
			TRectangle([MFill(mainColor), FillOpacity(opacity)], TFixed(radius, diam)),
			TGroup([
				Sector2(radius, radius, radius, 0., 180., [MFill(endColor), FillOpacity(opacity)]) |> TForm,
				Sector2(radius, radius, radius - 2., 0., 180., [MFill(mainColor), FillOpacity(opacity)]) |> TForm,
				Sector2(radius, radius, radius, 180., 360., [MFill(startColor), FillOpacity(opacity)]) |> TForm,
				Sector2(radius, radius, radius - 2., 180., 360., [MFill(mainColor), FillOpacity(opacity)]) |> TForm
			])
		])
	}

	multiEndWithMiddleAndEnd = \mainColor, middleColor, endColor -> {
		TGroup([
			TColsA([
				TFixed(radius, 0.),
				TRectangle([MFill(middleColor), FillOpacity(opacity)], TFixed(radius + 2.0, diam)),
			]),
			TRectangle([MFill(mainColor), FillOpacity(opacity)], TFixed(radius, diam)),
			TGroup([
				Sector2(radius, radius, radius, 0., 180., [MFill(endColor), FillOpacity(opacity)]) |> TForm,
				Sector2(radius, radius, radius - 2., 0., 180., [MFill(mainColor), FillOpacity(opacity)]) |> TForm
			])
		])
	}

	multiEndWithMiddleAndStart = \mainColor, middleColor, startColor -> {
		TGroup([
			TColsA([
				TFixed(radius, 0.),
				TRectangle([MFill(middleColor), FillOpacity(opacity)], TFixed(radius + 2.0, diam)),
			]),
			TRectangle([MFill(mainColor), FillOpacity(opacity)], TFixed(radius, diam)),
			TGroup([
				Sector2(radius, radius, radius, 0., 180., [MFill(mainColor), FillOpacity(opacity)]) |> TForm,
				Sector2(radius, radius, radius, 180., 360., [MFill(startColor), FillOpacity(opacity)]) |> TForm,
				Sector2(radius, radius, radius - 2., 180., 360., [MFill(mainColor), FillOpacity(opacity)]) |> TForm
			])
		])
	}

	multiEndWithMiddle = \mainColor, secondColor -> {
		TGroup([
			TColsA([
				TFixed(radius, 0.),
				TRectangle([MFill(secondColor), FillOpacity(opacity)], TFixed(radius + 2.0, diam)),
			]),
			TRectangle([MFill(mainColor), FillOpacity(opacity)], TFixed(radius, diam)),
			LongSegment(radius, radius, radius, 0., 180., [MFill(mainColor), FillOpacity(opacity)]) |> TForm
		])
	}

	plusEventsBar = \number -> {
		if (!hideEventsCount) {
			MGroup([
				MColsA([
					MFixed(radius + 1.5, 0.),
					MGroup([
						Sector2(1.0, diam / 8.0 + 2., diam / 8.0 + 1.5, 0., 360., [Fill(black)]) |> TForm,
						MColsA([
							MFixed(diam / 16.0, 0.),
							TRectangle([Fill(black), FillOpacity(1.0)], TFixed(diam / 4.0, diam / 4.0 + 3.2)),
						]),
						MColsA([
							MFixed(diam / 16.0 + diam / 4.0, 0.),
							Sector2(0.0, diam / 8.0 + 2., diam / 8.0 + 1.5, 0., 360., [Fill(black)]) |> TForm,
						]),
						MCenterIn(
							MText("+" + i2s(number), [MWhite(), MCustomFont(9., "Roboto", primarySmallTextOpacity)]),
							MFixed(radius - 5., 0.0)
						)
					])
				]),
			]);
		} else {
			MEmpty();
		}
	}

	eventsCheck = \currentEventTypes -> {
		multiDayEvents = getMultiDayEvents(dayEvents);
		getEventTypeBackColor = \event -> {
			eitherMap(
				find(currentEventTypes, \type -> type.name == event.eventType),
				\type -> type.backColor,
				MGrey(300)
			);
		}

		if (length(multiDayEvents) > 0) {
			//events that started on this day
			startEvents : [CalendarEvent] = filter(multiDayEvents, \item -> time2date(item.startDate) == thisDate);

			//events that goes on this day
			middleEvents : [CalendarEvent] = filter(multiDayEvents, \item -> time2date(item.startDate) < thisDate && thisDate < time2date(item.endDate));

			//events that ended on this day
			endEvents : [CalendarEvent] = filter(multiDayEvents, \item -> time2date(item.endDate) == thisDate);

			firstEvent = multiDayEvents[0];
			//Depending on what event happens before we have 11 possible situations to display.
			//From simple "beginning", "middle", "end", then more complex combinations
			if (contains(startEvents, firstEvent)) {
				if (length(startEvents) >= 2) {
					firstColor = getEventTypeBackColor(firstEvent);
					secondColor = getEventTypeBackColor(startEvents[1]);

					MGroup2(
						multiStartWithStart(firstColor, secondColor),
						if (length(dayEvents) > 2) plusEventsBar(length(dayEvents) - 2) else TEmpty()
					);
				} else {
					firstColor = getEventTypeBackColor(firstEvent);
					MGroup2(
						multiStart(firstColor),
						if (length(dayEvents) > 1) plusEventsBar(length(dayEvents) - 1) else TEmpty()
					);
				}
			} else if (contains(middleEvents, firstEvent)) {
				firstColor = getEventTypeBackColor(firstEvent);

				if (length(dayEvents) >= 3) {
					secondColor = getEventTypeBackColor(dayEvents[1]);
					thirdColor = getEventTypeBackColor(dayEvents[2]);

					if (contains(endEvents, dayEvents[1]) && contains(startEvents, dayEvents[2])) {
						MGroup2(
							multiMiddleWithStartAndEnd(firstColor, thirdColor, secondColor),
							if (length(dayEvents) > 3) plusEventsBar(length(dayEvents) - 3) else TEmpty()
						)

					} else if (contains(startEvents, dayEvents[1])) {
						MGroup2(
							multiMiddleWithStart(firstColor, secondColor),
							if (length(dayEvents) > 2) plusEventsBar(length(dayEvents) - 2) else TEmpty()
						)

					} else if (contains(endEvents, dayEvents[1])) {
						MGroup2(
							multiMiddleWithEnd(firstColor, secondColor),
							if (length(dayEvents) > 2) plusEventsBar(length(dayEvents) - 2) else TEmpty()
						)

					} else {
						MGroup2(
							multiMiddle(firstColor),
							if (length(dayEvents) > 1) plusEventsBar(length(dayEvents) - 1) else TEmpty()
						)
					}

				} else if (length(dayEvents) >= 2) {
					secondColor = getEventTypeBackColor(dayEvents[1]);
					if (contains(startEvents, dayEvents[1])) {
						MGroup2(
							multiMiddleWithStart(firstColor, secondColor),
							if (length(dayEvents) > 2) plusEventsBar(length(dayEvents) - 2) else TEmpty()
						)

					} else if (contains(endEvents, dayEvents[1])) {
						MGroup2(
							multiMiddleWithEnd(firstColor, secondColor),
							if (length(dayEvents) > 2) plusEventsBar(length(dayEvents) - 2) else TEmpty()
						)

					} else {
						MGroup2(
							multiMiddle(firstColor),
							if (length(dayEvents) > 1) plusEventsBar(length(dayEvents) - 1) else TEmpty()
						)
					}

				} else {
					MGroup2(
						multiMiddle(firstColor),
						if (length(dayEvents) > 1) plusEventsBar(length(dayEvents) - 1) else TEmpty()
					)
				}
			} else {
				firstColor = getEventTypeBackColor(firstEvent);

				if (length(dayEvents) >= 3) {
					secondColor = getEventTypeBackColor(dayEvents[1]);
					thirdColor = getEventTypeBackColor(dayEvents[2]);

					if (contains(endEvents, dayEvents[1]) && contains(startEvents, dayEvents[2])) {
						MGroup2(
							multiEndWithStartAndEnd(firstColor, thirdColor, secondColor),
							if (length(dayEvents) > 3) plusEventsBar(length(dayEvents) - 3) else TEmpty()
						)

					} else if (contains(middleEvents, dayEvents[1]) && contains(endEvents, dayEvents[2])) {
						MGroup2(
							multiEndWithMiddleAndEnd(firstColor, secondColor, thirdColor),
							if (length(dayEvents) > 3) plusEventsBar(length(dayEvents) - 3) else TEmpty()
						)

					} else if (contains(middleEvents, dayEvents[2]) && contains(endEvents, dayEvents[1])) {
						MGroup2(
							multiEndWithMiddleAndEnd(firstColor, thirdColor, secondColor),
							if (length(dayEvents) > 3) plusEventsBar(length(dayEvents) - 3) else TEmpty()
						)

					} else if (length(middleEvents) > 0 && contains(endEvents, dayEvents[1])) {
						fourthColor = getEventTypeBackColor(middleEvents[0]);
						MGroup2(
							multiEndWithMiddleAndEnd(firstColor, fourthColor, secondColor),
							if (length(dayEvents) > 3) plusEventsBar(length(dayEvents) - 3) else TEmpty()
						)

					} else if (contains(middleEvents, dayEvents[1]) && contains(startEvents, dayEvents[2])) {
						MGroup2(
							multiEndWithMiddleAndStart(firstColor, secondColor, thirdColor),
							if (length(dayEvents) > 3) plusEventsBar(length(dayEvents) - 3) else TEmpty()
						)

					} else if (contains(startEvents, dayEvents[1])) {
						MGroup2(
							multiEndWithStart(firstColor, secondColor),
							if (length(dayEvents) > 2) plusEventsBar(length(dayEvents) - 2) else TEmpty()
						)

					} else if (contains(endEvents, dayEvents[1])) {
						MGroup2(
							multiEndWithEnd(firstColor, secondColor),
							if (length(dayEvents) > 2) plusEventsBar(length(dayEvents) - 2) else TEmpty()
						)

					} else if (contains(middleEvents, dayEvents[1])) {
						MGroup2(
							multiEndWithMiddle(firstColor, secondColor),
							if (length(dayEvents) > 2) plusEventsBar(length(dayEvents) - 2) else TEmpty()
						)
					} else if (length(middleEvents) > 0) {
						fourthColor = getEventTypeBackColor(middleEvents[0]);
						MGroup2(
							multiEndWithMiddle(firstColor, fourthColor),
							if (length(dayEvents) > 2) plusEventsBar(length(dayEvents) - 2) else TEmpty()
						)
					} else {
						MGroup2(
							multiEnd(firstColor),
							if (length(dayEvents) > 1) plusEventsBar(length(dayEvents) - 1) else TEmpty()
						)
					}

				} else if (length(dayEvents) >= 2) {
					secondColor = getEventTypeBackColor(dayEvents[1]);

					if (contains(startEvents, dayEvents[1])) {
						MGroup2(
							multiEndWithStart(firstColor, secondColor),
							if (length(dayEvents) > 3) plusEventsBar(length(dayEvents) - 3) else TEmpty()
						)
					} else if (contains(endEvents, dayEvents[1])) {
						MGroup2(
							multiEndWithEnd(firstColor, secondColor),
							if (length(dayEvents) > 2) plusEventsBar(length(dayEvents) - 2) else TEmpty()
						)
					} else if (contains(middleEvents, dayEvents[1])) {
						MGroup2(
							multiEndWithMiddle(firstColor, secondColor),
							if (length(dayEvents) > 2) plusEventsBar(length(dayEvents) - 2) else TEmpty()
						)
					} else {
						MGroup2(
							multiEnd(firstColor),
							if (length(dayEvents) > 1) plusEventsBar(length(dayEvents) - 1) else TEmpty()
						)
					}

				} else {
					MGroup2(
						multiEnd(firstColor),
						if (length(dayEvents) > 1) plusEventsBar(length(dayEvents) - 1) else TEmpty()
					)
				}
			}
		} else {
			backColor = getEventTypeBackColor(dayEvents[0]);
			MGroup2(
				TCircle(radius, [MFill(backColor), FillOpacity(opacity)]),
				if (length(dayEvents) > 1) plusEventsBar(length(dayEvents) - 1) else TEmpty()
			)
		}
	}

	bubble = MGroup2(
		if (length(dayEvents) > 0) {
			MSelect(eventTypes, \types -> eventsCheck(types));
		} else if (todayDate != thisDate) {
			MEmpty()
		} else {
			MShow(fnot(isPrintingB), MCircle(radius, [MThemeFill(manager, color)]))
		},
		text
	);

	bubbleAnimated = if (manager.theme.enableAnimations) {
		MCopySize(
			bubble,
			\m -> MGetFocusGroup(\parent -> MRipple2T(manager, parent, m, isHoverB, [MRippleColor(const(color)), MRippleType(const(MRippleCenter()))])),
			false
		);
	} else {
		MGroup2(
			MVisible(isHoverB, MCircle(radius, [MThemeFill(manager, color), FillOpacity(0.5)])),
			bubble
		);
	}

	click2 = \-> if (isEnabled) {
		nextDistinct(monthNumber, thisMonth.month);
		nextDistinct(currentDate, thisDate);
		openPopupForDay(thisDate, dayEvents);
	} else {
		println("this day not available!");
	}

	bubbleClickable = MGroup2(
		MComponent(
			[MOnClick(click2), MEnabled(fnot(isReadOnlyB)), THovering(isHoverB)],
			\__ -> MFrame(0.0, 0.0, [Fill(green), FillOpacity(0.0)], bubbleAnimated)
		),
		TCursor(FingerCursor(), TRectangle([Fill(white), FillOpacity(0.0)], TFixed(calendarDateCellW, calendarDateCellH)))
	);

	MSize(
		MFixed(calendarDateCellW, calendarDateCellH),
		if (isEnabled) bubbleClickable else text
	);
}

//Small popup to confirm deletion
eventDeletePopup(
	cancelAction : () -> void,
	okAction : () -> void
	) -> Material {

	//fontsSizes
	littleFontSize = MBody();
	mediumFontSize = MSubheading();
	bigBoldFontSize = MCustomFont(20., "RobotoMedium", primaryTextOpacity);
	buttonFontSize = bigBoldFontSize;
	//colors
	veryLightGrey = MGrey(50);
	lightGrey = MGrey(200);
	mediumGrey = MGrey(600);
	notSoDarkGrey = MGrey(700);
	darkGrey = MGrey(800);

	title = MCols([
		TFixed(25., 0.),
		MCenterIn(
			MText(_("Are you sure?"), [bigBoldFontSize]),
			TFixed(330., 80.)
		),
		TFixed(25., 0.),
	]);

	footer = MCols([
		TFixed(25., 0.),
		MCenterYIn(
			MColsA([
				MCard(
					[
						MRichMediaBlock(
							MCenter(
								MText(_("CANCEL"), [buttonFontSize, MWhite()])
							),
						[])
					],
					[MCardHeight(50.), MCardWidth(150.0), MContentBorders(false), mediumGrey],
					[MOnClick(cancelAction)]
				),
				TFixed(20., 0.),
				MCard(
					[
						MRichMediaBlock(
							MCenter(
								MText(_("DELETE"), [buttonFontSize])
							),
						[])
					],
					[MCardHeight(50.), MCardWidth(150.0), MContentBorders(false), MCustomColor(0xFDB22B)],
					[MOnClick(okAction)]
				),
			]),
			TFixed(0., 80.)
		),
		TFixed(25., 0.)
	]);

	MGroup([
		TRectangle([Fill(white), FillOpacity(1.0)], TFixed(380., 160.)),
		MLinesA([
			title,
			footer
		])
	])
}

dayEventsPopup(
	curDate : Date,
	dayEventsStatic : [CalendarEvent],
	eventTypesB : DynamicBehaviour<[CalendarEventDecription]>,
	manager : MaterialManager,
	choosedFilters : [string],
	rangeType : int, // 0 - day, 1 - week, 2 - month
	isGroupOfEvents : bool,
	styles : [CalendarForEventsStyle]
	) -> void {

	listSettings = extractStruct(styles, EventListSettings(["event any text", "start", "end"], false, true));
	colsToShow = listSettings.cols;
	showDate = listSettings.showDate;
	showTime = listSettings.showTime;
	showStart = contains(colsToShow, "start");
	showEnd = contains(colsToShow, "end");
	closePopupAfterAdditionalAction = containsStruct(styles, CloseDayPopupAfterAdditionalAction());
	isReadOnly = fgetValue(extractStruct(styles, CalendarReadOnly(const(false))).isReadOnlyB);
	customPopupM = tryExtractStruct(styles, CalendarEventsPopup(nop3));
	getEventTitle = extractStruct(styles, CalendarCustomEventTitle(getEventTitleDefault)).getTitle;

	close = make(false);
	dayEvents = make(dayEventsStatic);

	curTime = stamp2time(timestamp());
	dayNumber = curDate.day;
	monthNumber = curDate.month;

	roundTime = \time -> {
		roundInterval = 30;
		roundedMinutes = (time.min / roundInterval + 1) * roundInterval;
		flooredTime = Time(time with min = 0, sec = 0);
		stamp2time(time2stamp(flooredTime) + min2ms(roundedMinutes));
	}
	dateForAdd = roundTime(Time(curDate.year, curDate.month, curDate.day, curTime.hour, curTime.min, curTime.sec));

	textCols = ["event type", "event description", "event title"];
	dateCols = ["start", "end"];
	additionalCols = subtractA(colsToShow, concat(textCols, dateCols));

	dateExpandingFactor = 1.65;

	getDateWidth = \-> {
		if ((showDate && showTime) && (showStart && showEnd)) dateExpandingFactor
		else b2d((showDate || showTime) && (showStart || showEnd))
	}

	getTextWidth = \-> {
		if (length(colsToShow) == 0 || contains(colsToShow, "event any text")) 1.
		else i2d(length(intersection(colsToShow, textCols)))
	}

	additionalColsWidth = i2d(length(additionalCols)) * 166.;

	lineWidth = 264. + getTextWidth() * 276. + getDateWidth() * 156. + additionalColsWidth;
	popupWidth = lineWidth + 85.;
	titleHeight = 60.;
	lineHeight = 88.;
	buttonHeight = 70.;

	leftOffset = TFixed(40., 0.);
	iconBox = TFixed(100., lineHeight);
	nameBox = TFixed(260., lineHeight);
	additionalColBox = TFixed(150., lineHeight);
	editButtonBox = TFixed(44., lineHeight);
	deleteButtonBox = TFixed(70., lineHeight);
	timeBox = TFixed(getDateWidth() * 156., lineHeight);

	mediumFont = MCustomFont(18., "RobotoMedium", primaryTextOpacity);
	normalFont = MCustomFont(18., "Roboto", primaryTextOpacity);
	littleFont = MBody();

	centeredTitleText = \text -> MCenterIn(MText(text, [mediumFont, MGrey(800)]), TFillXH(titleHeight));

	titleText = if (rangeType == 0) {
		MColsA([
			MCenterYIn(
				MText(i2s(dayNumber) + " " + monthString(curDate, true), [mediumFont, MGrey(800)]),
				TFixed(100., titleHeight)
			),
			TFillX(),
			MCenterYIn(
				MParagraph(dayOfWeekString(curDate, true), [littleFont, MGrey(800), RightAlign(), MWidth(80.)]),
				TFixed(80., titleHeight)
			),
		])
	}   else if (rangeType == 1) centeredTitleText(i2s(getWeekOfYear(curDate, 0, true)))
		else centeredTitleText(_(monthString(curDate, true)));

	addLeftOffset = \m : Material -> MCols2(leftOffset, m);

	title = MGroup([
		TRectangle([MFill(MGrey(200))], TFixed(popupWidth, titleHeight)),
		MFixSize(
			addLeftOffset(MCols2A(
				titleText,
				MCenterYIn(
					MIconButton("close",
						\ -> next(close, true),
						[MBlack(), MIconSize(20.)],
						[MShortcut("esc")]
					),
					TFixed(20., 55.)
				)
			)),
			TFixed(popupWidth, titleHeight)
		)
	]);

	separatorLine = TRectangle([Fill(grey), FillOpacity(0.7)], TFixed(lineWidth, 0.5));

	//line with "empty" icon and text
	emptyLine = MLines2A(
		MCols2A(
			MBorderA(0., 0., 8., 0., MCenterYIn(TCircle(28., [Fill(grey)]), TFixed(70., lineHeight))),
			MCenterYIn(MText(_("No added events"), [normalFont]), TFixed(100., lineHeight))
		),
		separatorLine
	);

	makeTextCol = \text : string, boxSize : Material -> {
		MBorderA(8., 0., 8., 0.,
			MFixSize(MCenterY(MEllipsisText(text, [mediumFont, MShowTooltip(const(true)), MMaxLines(2)])), boxSize)
		);
	}

	makeTextCols = \event : CalendarEvent -> {
		makeNameTextCol = \text : string -> makeTextCol(text, nameBox);
		MColsA([
			if (contains(colsToShow, "event any text")) makeNameTextCol(getEventTitle(event)) else MEmpty(),
			if (contains(colsToShow, "event type") || (length(colsToShow) == 0 && event.title == "")) makeNameTextCol(event.eventType) else MEmpty(),
			if (contains(colsToShow, "event title") || (length(colsToShow) == 0 && event.title != "")) makeNameTextCol(event.title) else MEmpty(),
			if (contains(colsToShow, "event description")) makeNameTextCol(event.description) else MEmpty()
		])
	}

	makeAdditionalCols = \event : CalendarEvent -> {
		MCols(map(additionalCols, \col -> makeTextCol(lookupTreeDef(event.additionalFields, col, ""), additionalColBox)))
	}

	makeDateCol = \event : CalendarEvent -> {
		getDateText = \dt : Time -> {
			timeString = lpad(getTimeOnlyString(dt, false, false), "0", 5);
			dateString = date2formatString(time2date(dt), "%DD.%MM.%YY");
			if (showDate && showTime) dateString + " " + timeString
			else if (showDate) dateString
			else if (showTime) timeString
			else ""
		}
		text = if (showStart && showEnd) getDateText(event.startDate) + " - " + getDateText(event.endDate)
			else if (showStart) getDateText(event.startDate)
			else if (showEnd) getDateText(event.endDate)
			else "";
		if (text != "" && text != " - ") MFixSize(MCenterY(MEllipsisText(text, [normalFont, MShowTooltip(const(true))])), timeBox)
		else MEmpty()
	}

	makeAddButtonsMenu = \event, eventType -> {
		mainButton = MIconButton("more_horiz",
			nop,
			[MIconSize(22.), MGrey(700)],
			[]
		);

		items = map(eventType.additionalActions, \act -> {
			MMenuCustomLine(
				MColsA([
					MCenterYIn(
						MIcon(act.icon, [MIconSize(22.)]),
						TFixed(50., 44.)
					),
					MCenterYIn(
						MText(act.name, [normalFont]),
						TFixed(0., 44.)
					)
				]),
			[])
		});

		MCenterYIn(
			MMenu(
				mainButton,
				items,
				[MOnListClick(const(true), \index -> eventType.additionalActions[index].action(event.id))]
			),
			editButtonBox
		)
	}

	makeAddButtonsCol = \event : CalendarEvent, eventType : CalendarEventDecription -> {
		if (length(eventType.additionalActions) > 0) {
			if (length(eventType.additionalActions) == 1) {
				MCenterYIn(
					MIconButton(eventType.additionalActions[0].icon,
						\-> {
							eventType.additionalActions[0].action(event.id);
							if (closePopupAfterAdditionalAction) next(close, true);
						},
						[MIconSize(22.), MGrey(700)],
						[]
					),
					editButtonBox
				)
			} else makeAddButtonsMenu(event, eventType)
		} else editButtonBox
	}

	makeEditButton = \event : CalendarEvent, eventType : CalendarEventDecription -> {
		MCenterYIn(
			MIconButton("mode_edit",
				\-> {
					eventType.editAction(event.id);
					next(close, true);
				},
				[MGrey(700), MIconSize(22.)],
				[]
			),
			editButtonBox
		)
	}

	makeDeleteButton = \event : CalendarEvent, eventType : CalendarEventDecription -> {
		MCenterYIn(
			MIconButton("delete",
				\-> {
					popupClose = make(false);
					ShowMDialog(manager, popupClose, [],
						eventDeletePopup(
							\-> next(popupClose, true),
							\-> {
								next(popupClose, true);
								evIndexInDay = either(findi(getValue(dayEvents), \p -> p.id == event.id), -1);
								if (evIndexInDay != -1) next(dayEvents, removeIndex(getValue(dayEvents), evIndexInDay));
								eventType.deleteAction(event.id);
							}
						)
					);
				},
				[MGrey(700), MIconSize(22.)],
				[]
			),
			deleteButtonBox
		)
	}

	makeAvatar = \eventType : CalendarEventDecription -> {
		MCenterYIn(
			MAvatar(eventType.icon, [MIconSize(56.0)]),
			iconBox
		)
	}

	//line with icon, event name, event time and buttons for edit and delete
	eventLine = \event : CalendarEvent, eventType : CalendarEventDecription -> {
		MLines2A(
			MColsA([
				makeAvatar(eventType),
				makeTextCols(event),
				makeAdditionalCols(event),
				makeDateCol(event),
				editButtonBox,
				makeAddButtonsCol(event, eventType),
				makeEditButton(event, eventType),
				makeDeleteButton(event, eventType)
			]),
			separatorLine
		);
	}

	eventAddButton = \evType ->  {
		MLines2A(
			MClickable(
				MGroup([
					MCenterYIn(
						MShadow(const(4.0),
							MFrame(2., 2., [MFill(MGrey(200))], TFixed(lineWidth, buttonHeight))
						),
						TFixed(0., buttonHeight)
					),
					MCenterIn(
						MFrame(2., 2., [MFill(evType.backColor)], TFixed(lineWidth - 2., buttonHeight - 2.)),
						TFixed(lineWidth, buttonHeight)
					),
					MCenterIn(
						MText(_("ADD") + " " + toUpperCase(evType.name), [mediumFont, evType.mainColor]),
						TFixed(lineWidth, buttonHeight)
					)
				]),
				\ -> {
					evType.addAction(dateForAdd);
					next(close, true)
				}
			),
			TFixed(popupWidth - 40., 20.)
		)
	};

	popup = MLines2(
		MShadow(const(4.0), title),
		MSelect2(dayEvents, eventTypesB, \events, eventTypes -> {
			notAddedEvents = if (^isOnlyOneSameTypeEventsByDay)
					filter(eventTypes, \ev -> {
						evIndexInDay = findiDef(getValue(dayEvents), \p -> p.eventType == ev.name, -1);
						evIndexInDay == -1 && !contains(choosedFilters, ev.name)
					})
				else
					eventTypes;

			eventsList : Material = if (length(events) == 0)
					emptyLine
				else MLinesA(
					filtermap(events, \dayEvent -> {
						eventTypeIndex = findiDef(eventTypes, \p -> p.name == dayEvent.eventType, -1);
						if (eventTypeIndex != -1) Some(eventLine(dayEvent, eventTypes[eventTypeIndex])) else None()
					})
				);

			content = MLet(
				"m",
				MLinesA([
					eventsList,
					TRectangle([Fill(white)], TFixed(popupWidth - 40., 40.)),
					MLinesA(map(notAddedEvents,
						\notAddedEvent ->
							if (notAddedEvent.addAction == nop1 || isReadOnly) MEmpty()
							else eventAddButton(notAddedEvent)
						)
					)
				]),
				MAttach(MGhost("m"), \formMetrics -> MGroup2(
					TSizedHeight(popupWidth, formMetrics.height)
					|> addTBackground(MWhite()),
					addLeftOffset(MDisplay("m"))
				))
			);

			MScroll(
				content,
				TFillWY(popupWidth),
				[TScrollbars(invisibleScrollBar, standardScrollBar), MScrollCropByContent(), MScrollDisableOutOfBounds(const(true))]
			)
		}),
	);

	eitherFn(customPopupM, \customPopup -> {
		customPopup.open(isGroupOfEvents, dateForAdd, dayEventsStatic);
	}, \ -> {
		if (!isReadOnly || dayEventsStatic != []) {
			ShowMDialog(
				manager,
				close,
				[MDialogClickOutToClose(), MDialogScroll()],
				MShadow(const(20.0), popup)
			);
		}
	});
}

makeLineOfDaysBlockForMonthView(
	startIndex : int,
	getOtherMonthDay : (int) -> Material,
	daysBlock : [Material],
	result : [Material]) -> [Material] {

	blocksLength = length(daysBlock);

	if (startIndex >= blocksLength) {
		result
	} else {
		newLine = MCols(
			generate(startIndex, startIndex + 7, \blockIndex -> {
				i = blockIndex - blocksLength;
				if (i < 0) {
					daysBlock[blockIndex];
				} else {
					getOtherMonthDay(i + 1);
				}
			})
		);
		makeLineOfDaysBlockForMonthView(startIndex + 7, getOtherMonthDay, daysBlock, arrayPush(result, newLine))
	}
}

//create cards with events for each day in current month
MonthTable(
	currentEvents : DynamicBehaviour<[CalendarEvent]>,
	eventTypesB : DynamicBehaviour<[CalendarEventDecription]>,
	currentDateB : DynamicBehaviour<Date>,
	dateMin : Date,
	dateMax : Date,
	manager : MaterialManager,
	maxDisplayedEventsInOneDay : int,
	choosedFilters : DynamicBehaviour<[string]>,
	isPrintingB : DynamicBehaviour<bool>,
	styles : [CalendarForEventsStyle]
) -> CalendarTabView {
	minHeight = 26.0;
	maxHeight = minHeight * 3.0;

	lineBox =                                  TFillXYXY(50., minHeight, 141.5 * 5., maxHeight);
	lineBoxForBlockWithEvent =                 TFillXYXY(50., minHeight, 138.5 * 5., maxHeight);
	lineBoxForBlockWithFirstMultiDayEvent =    TFillXYXY(50., minHeight, 140.0 * 5., maxHeight);
	lineBoxForBlockWithNotFirstMultiDayEvent = TFillXYXY(50., minHeight, 141.5 * 5., maxHeight);
	lineBoxForBlockWithFirstMultiDayEvent2 =   TFillXYXY(50., minHeight, 140.0 * 5., maxHeight);
	blankDaySize =                             TFillXYXY(50., minHeight, 141.5 * 5., minHeight);

	showMonthSwitchView = contains(styles, ShowMonthViewSwitchMenu());
	isUseMTextMColor = contains(styles, BlackAndWhiteTextColor());
	byWeekViewB = make(extractStruct(styles, DefaultMonthView(true)).byWeek);
	hideTimeInfo = contains(styles, HideTimeInfo());
	calendarTabMenuStyle = extractStruct(styles, defaultCalendarTabMenuStyle);
	isReadOnlyB = extractStruct(styles, CalendarReadOnly(const(false))).isReadOnlyB;
	getEventView = extractStruct(styles, CalendarCustomEventView(\__, __, __, __, __ -> None())).getView;
	getWeekDay = extractStruct(styles, CalendarWeekDayView(\dayName, __ -> MCenterIn(MText(dayName, []), MFillXH(58.0)))).getView;
	otherMonthViewM = tryExtractStruct(styles, CalendarMonthFillEmpty(\__, __, __ -> MEmpty()));
	getEventTitle = extractStruct(styles, CalendarCustomEventTitle(getEventTitleDefault)).getTitle;
	eventsOpacity = extractStruct(styles, CalendarEventsOpacity(1.0)).opacity;
	isDynamicNumberOfEvents = maxDisplayedEventsInOneDay == -1;
	enableScrolls = extractStruct(styles, CalendarScrolls(true)).enable;

	weekDayHeightB = make(0.0);
	dayTitleHeightB = make(0.0);
	eventRowHeightB = make(0.0);
	availableHeightB = make(0.0);
	maxDisplayedEventsInOneDayB = make(if (maxDisplayedEventsInOneDay <= 0) CalendarDefaultDisplayedEventsInOneDay else maxDisplayedEventsInOneDay);
	multiDayEventsPosition = make([]);

	defaultAdditionalEventsView = \count -> {
		MGroup2(
			MFrame(0.0, 0.0, [MFill(MGrey(400)), FillOpacity(1.0)], lineBox),
			MCenterIn(MText(i2s(count) + _("+ events"), [MWhite()]), lineBox)
		);
	}
	getAdditionalEventsView = extractStruct(styles, CalendarMonthAdditionalEventsView(defaultAdditionalEventsView)).getView;

	calendarDayTouch = \item : CalendarEvent, dayDate : Date -> {
		isMultiDay = (time2date(item.startDate) != time2date(item.endDate));
		eventTime = if (hideTimeInfo) ""
			else i2s(item.startDate.hour) + ":" + substring(item.startDate |> time2stamp2 |> time2string, 14, 2) + "   ";

		eventTypeB = fselect(eventTypesB, FLift(\eventTypes -> findDef(eventTypes, \p -> p.name == item.eventType, makeCalendarEventDescription())));
		eventText = if (!isMultiDay)
				eventTime + getEventTitle(item)
			else if (dayDate == time2date(item.startDate) || dayOfWeek(dayDate) == 0)
				getEventTitle(item)
			else
				" ";

		MShowLazy(fselect(eventTypeB, FLift(\eventType -> eventType.name != "")), \ -> {
			backColorB = fselect(eventTypeB, FLift(\eventType -> eventType.backColor));
			eventTextM = MSelect(eventTypeB, \eventType -> {
				mainColor = eventType.mainColor;
				eventTextColor = if (isUseMTextMColor) MTextMColor(mainColor) else mainColor;
				MEllipsisText(eventText, [eventTextColor])
			});
			defaultViewM = MGroup([
				if (!isMultiDay) {
					MGroup2(
						TRectangle([Fill(white), FillOpacity(eventsOpacity)], lineBox),
						MCenterIn(
							MSelect(backColorB, \backColor -> TRectangle([MFill(backColor), FillOpacity(eventsOpacity)], lineBoxForBlockWithEvent)),
							lineBox
						)
					)
				} else {
					if (dayDate == time2date(item.startDate)) {
						MGroup2(
							TRectangle([Fill(white), FillOpacity(eventsOpacity)], lineBox),
							MColsA([
								TFixed(1.5, 0.),
								MCenterYIn(
									MSelect(backColorB, \backColor -> TRectangle([MFill(backColor), FillOpacity(eventsOpacity)], lineBoxForBlockWithFirstMultiDayEvent)),
									lineBoxForBlockWithFirstMultiDayEvent2
								)
							])
						)
					} else if (dayDate == time2date(item.endDate)) {
						MGroup2(
							TRectangle([Fill(white), FillOpacity(eventsOpacity)], lineBox),
							MColsA([
								MCenterYIn(
									MSelect(backColorB, \backColor -> TRectangle([MFill(backColor), FillOpacity(eventsOpacity)], lineBoxForBlockWithFirstMultiDayEvent)),
									lineBoxForBlockWithFirstMultiDayEvent2
								),
								TFixed(1.5, 0.),
							])
						)
					} else {
						MGroup2(
							TRectangle([Fill(white), FillOpacity(eventsOpacity)], lineBox),
							MCenterYIn(
								MSelect(backColorB, \backColor -> TRectangle([MFill(backColor), FillOpacity(eventsOpacity)], lineBoxForBlockWithNotFirstMultiDayEvent)),
								lineBox
							),
						)
					}
				},
				MTooltip(
					MCenterIn(
						MBorderA(2., 0., 2., 0., eventTextM),
						lineBox
					),
					MText(item.description, []),
					[MEnabled(const(isTooltipEnabled(item)))]
				),
			]);

			isEditActionNotEmptyB = fselect(eventTypeB, FLift(\et -> et.editAction != nop1));
			MComponent(
				[MOnClick(\-> fgetValue(eventTypeB).editAction(item.id)), MEnabled(fand(fnot(isReadOnlyB), isEditActionNotEmptyB))],
				\__ -> {
					MSelect(eventTypeB, \eventType -> {
						eitherMap(getEventView(MonthTab(), item, eventType, dayDate, 1), MFixWidth(defaultViewM), defaultViewM)
					});
				}
			);
		});
	}

	openDayEventsPopup = \date, isEnable, events : [CalendarEvent], isGroupOfEvents -> {
		if (isEnable) dayEventsPopup(date, events, eventTypesB, manager, getValue(choosedFilters), 0, isGroupOfEvents, styles);
	}

	ifAttachHeight = \material, cond, heightB -> if (cond) MAttachHeight(material, heightB) else material;

	makeTitle = \eventColor, date, isEnable, events : [CalendarEvent] -> MComponent(
		[MOnClick(\-> openDayEventsPopup(date, isEnable, events, false)), MEnabled(fnot(isReadOnlyB))],
		\__ -> {
			getView = extractStruct(styles, CalendarDayNumberView(\dayNumber, __, __, __ -> {
				MGroup2(
					TRectangle([MFill(eventColor), FillOpacity(eventsOpacity)], lineBox),
					MCenterIn(MText(dayNumber, [MWhite()]), lineBox)
				);
			})).getView;

			dayNumber = i2s(date.day);
			isWeekend = dayOfWeek(date) > 5;
			currentDate = getValue(currentDateB);
			isCurrentMonth = date.year == currentDate.year && date.month == currentDate.month;

			isTodayB = fand(const(compareDates(date, getCurrentDate()) == DateEqual()), fnot(isPrintingB));
			ifAttachHeight(
				MSelect(isTodayB, \isToday -> {
					if (isCurrentMonth) {
						getView(dayNumber, isToday, isWeekend, MonthTab());
					} else {
						eitherMap(otherMonthViewM, \otherMonthView -> {
							otherMonthView.getTitleView(dayNumber, isToday, isWeekend);
						}, getView(dayNumber, isToday, isWeekend, MonthTab()));
					}
				}) |> MSetAddFillers(const(false)),
				currentDate == date,
				dayTitleHeightB
			);
		}
	);

	makeEmptyBlock = \date, isEnable, events : [CalendarEvent] -> MComponent(
		[MOnClick(\-> openDayEventsPopup(date, isEnable, events, false)), MEnabled(fnot(isReadOnlyB))],
		\__ -> MSizeOf(either(getEventView(MonthTab(), emptyEvent, makeCalendarEventDescription(), date, 1), lineBox))
	);

	makeAdditionalEventsBlock = \additionalEventsCount, date, isEnable, events : [CalendarEvent] -> MComponent(
		[MOnClick(\-> openDayEventsPopup(date, isEnable, events, true)), MEnabled(fnot(isReadOnlyB))],
		\__ -> getAdditionalEventsView(additionalEventsCount) |> MSetAddFillers(const(false))
	);

	getDayMaxEvents = \date, rowsEventsCount -> {
		countM = find(rowsEventsCount, \count -> {
			date >= count.first && date <= count.second;
		});
		eitherMap(countM, thirdOfTriple, 1);
	}

	// "Empty" day consists of a header with the number of the day and maxDisplayedEventsInOneDay empty units.
	// By clicking on the card - opens a window with a choice of added events
	makeEmptyCalendarDay = \dayDate, isEnable, rowsEventsCount -> {
		MLines2(
			makeTitle(MGrey(600), dayDate, isEnable, []),
			MSelect2(maxDisplayedEventsInOneDayB, isPrintingB, \maxDisplayedEvents, isPrinting -> {
				maxEvents = if (isPrinting) getDayMaxEvents(dayDate, rowsEventsCount) else maxDisplayedEvents;
				MLines(generate(0, maxEvents, \i -> {
					ifAttachHeight(
						makeEmptyBlock(dayDate, isEnable, []),
						i == 0 && dayDate == getValue(currentDateB),
						eventRowHeightB
					);
				}));
			})
		);
	}

	// "NotEmpty" day consists of a header with a background color number of the day of the first (in time) of the event,
	// as well as maxDisplayedEventsInOneDay blocks of the events.
	// If the event is less than maxDisplayedEventsInOneDay  - fill the "empty" blocks
	makeNotEmptyCalendarDay = \dayDate, events : [CalendarEvent], isEnable, rowsEventsCount -> {
		eventTypes = getValue(eventTypesB);
		MSelect2(maxDisplayedEventsInOneDayB, isPrintingB, \maxDisplayedEvents, isPrinting -> {
			maxEvents = if (isPrinting) getDayMaxEvents(dayDate, rowsEventsCount) else maxDisplayedEvents;
			fullDayEvents = if (length(events) < maxEvents) {
				concat(events, generate(0, maxEvents - length(events), \__ -> emptyEvent))
			} else {
				events
			};

			getAdditionalNonEmptyEvents = \newEvents -> {
				foldi(newEvents, 0, \i, res, e -> {
					if (i >= maxEvents - 1 && e.eventType != "_EMPTY_") res + 1 else res
				});
			}

			newEvents = checkOneDayEventsPosition(fullDayEvents, maxEvents, multiDayEventsPosition);
			notEmptyEventIndex = either(findi(newEvents, \p -> p.eventType != "_EMPTY_"), -1);
			eventIndex = if (notEmptyEventIndex != -1) {
				either(findi(eventTypes, \p -> p.name == newEvents[notEmptyEventIndex].eventType), -1);
			} else {
				-1;
			}

			eventColor = if (!^isColorizeDayHeaders) {
				MGrey(600);
			} else if (eventIndex != -1) {
				eventTypes[eventIndex].mainColor;
			} else {
				MWhite();
			}

			eventsCount = length(newEvents);
			MLines2(
				makeTitle(eventColor, dayDate, isEnable, events),
				MLines(mapi(take(newEvents, maxEvents), \i, e -> {
					ifAttachHeight(
						if (i == maxEvents - 1 && eventsCount > maxEvents) {
							makeAdditionalEventsBlock(getAdditionalNonEmptyEvents(newEvents), dayDate, isEnable, events)
						} else if (e.eventType != "_EMPTY_") {
							calendarDayTouch(e, dayDate)
						} else {
							makeEmptyBlock(dayDate, isEnable, events)
						},
						dayDate == getValue(currentDateB) && i == 0 && isDynamicNumberOfEvents,
						eventRowHeightB
					);
				}))
			);
		});
	}

	//if day consists 0 events or this day is not available - show emptyDay
	makeCalendarDay = \dayDate, events : [CalendarEvent], isEnable, rowsEventsCount -> {
		calendarDayM = if (length(events) > 0 && isEnable) {
			makeNotEmptyCalendarDay(dayDate, events, isEnable, rowsEventsCount)
		} else {
			makeEmptyCalendarDay(dayDate, isEnable, rowsEventsCount)
		}
		separatorM = MSeparator(false) |> MFixHeight(calendarDayM);
		MCols([
			if (dayOfWeek(dayDate) == 0) separatorM else MEmpty(),
			calendarDayM,
			separatorM
		]);
	}

	// First, we keep out all events except the events for the current month. Then create a list of events for each day
	calendarFiltering = \items : [CalendarEvent], rowsEventsCount -> {
		currentDate = getValue(currentDateB);
		filteredByMonth = filter(items, \item -> {
			startDate = item.startDate;
			endDate = item.endDate;
			timeYearCheck(startDate.year, endDate.year, currentDate.year) &&
				timeMonthCheck(startDate, endDate, currentDate)
		});

		daysCount = getNumberOfDaysPerMonthInTheYear(currentDate.year)[currentDate.month];
		generate(1, daysCount + 1, \dayNumber -> {
			date = Date(currentDate with day = dayNumber);
			isEnable = isDateEnable(date, dateMin, dateMax);
			allEvents = filter(filteredByMonth, \item -> timeDayCheck(item.startDate, item.endDate, currentDate, dayNumber));
			makeCalendarDay(date, sortEvents(allEvents), isEnable, rowsEventsCount);
		});
	}

	getOtherMonthDayFn = \items, rowsEventsCount -> \i -> {
		if (isSome(otherMonthViewM)) {
			monthStart = Date(getValue(currentDateB) with day = 1);
			date = if (i > 0) {
				addDaysToDate(addMonthsToDate(monthStart, 1), i - 1);
			} else {
				addDaysToDate(monthStart, i);
			}
			events = filter(items, \item -> {
				startDate = item.startDate;
				endDate = item.endDate;
				timeYearCheck(startDate.year, endDate.year, date.year) &&
					timeMonthCheck(startDate, endDate, date) &&
					timeDayCheck(startDate, endDate, date, date.day)
			});
			makeCalendarDay(date, events, isDateEnable(date, dateMin, dateMax), rowsEventsCount);
		} else {
			blankDaySize;
		}
	}

	weekDayNames = [strsubsmart(_("Monday"), 0, 3), strsubsmart(_("Tuesday"), 0, 3), strsubsmart(_("Wednesday"), 0, 3),
		strsubsmart(_("Thursday"), 0, 3), strsubsmart(_("Friday"), 0, 3), strsubsmart(_("Saturday"), 0, 3), strsubsmart(_("Sunday"), 0, 3)];
	makeWeekDayNameCell = \i : int, name : string -> {
		weekDayM = getWeekDay(name, MonthTab());
		separatorM = MSeparator(false) |> MFixHeight(weekDayM);
		ifAttachHeight(
			MColsYCenterA([
				if (i == 0) separatorM else MEmpty(),
				weekDayM,
				separatorM
			]) |> MSetAddFillers(const(false)),
			i == 0,
			weekDayHeightB
		);
	};

	MonthViewByWeek = \curD : Date, items : [CalendarEvent] -> {
		headerM = MLines2(MSeparator(true), MColsA(mapi(weekDayNames, makeWeekDayNameCell)));
		weekDay = dayOfWeek(curD);
		rowsCount = ceil(i2d(getNumberOfDaysPerMonthInTheYear(curD.year)[curD.month] + weekDay) / 7.0);
		minEventsCount = 1;
		rowsEventsCount = generate(0, rowsCount, \i -> {
			startDate = addDaysToDate(curD, -weekDay + i * 7);
			endDate = addDaysToDate(startDate, 6);

			rowEventsCount = maxA(generate(0, 7, \d -> {
				date = addDaysToDate(startDate, d);
				countA(items, \item -> {
					date >= time2date(item.startDate) && date <= time2date(item.endDate)
				});
			}));
			Triple(startDate, endDate, max(either(rowEventsCount, 0), minEventsCount));
		});

		separateRows = \rows -> arrayPush(interleave(rows, MSeparator(true)), MSeparator(true));
		getOtherMonthDay = getOtherMonthDayFn(items, rowsEventsCount);

		days = concat(
			generate(-weekDay, 0, getOtherMonthDay),
			calendarFiltering(items, rowsEventsCount)
		);
		rows = makeLineOfDaysBlockForMonthView(0, getOtherMonthDay, days, []);

		updateDisplayedEvents = \avaliableHeight, weekDayHeight, dayTitleHeight, eventRowHeight -> {
			availableDayHeight = (avaliableHeight - weekDayHeight) / i2d(rowsCount) - dayTitleHeight;
			maxEvents = max(CalendarDefaultDisplayedEventsInOneDay, floor(availableDayHeight / eventRowHeight));
			nextDistinct(maxDisplayedEventsInOneDayB, maxEvents);
		}

		CalendarTabView(
			MConstruct(
				if (isDynamicNumberOfEvents) {
					[make4Subscribe(availableHeightB, weekDayHeightB, dayTitleHeightB, eventRowHeightB, updateDisplayedEvents)]
				} else {
					[];
				},
				MAttachAvailableHeight(
					MLines2A(headerM, MLines(separateRows(rows)) |> (\c-> if (enableScrolls) MScroll(c, MFillXY(), []) else c)),
					availableHeightB
				)
			),
			\availableSize -> {
				eventRowHeight = getValue(eventRowHeightB);
				dayTitleHeight = getValue(dayTitleHeightB);
				rowsHeights = map(rowsEventsCount, \count -> i2d(count.third) * eventRowHeight + dayTitleHeight);

				weekDayHeight = getValue(weekDayHeightB);
				availableHeight = availableSize.height - weekDayHeight;

				pagesRows = foldi(rowsHeights, [], \i, acc, h -> {
					if (acc == []) {
						[[i]];
					} else {
						last = lastElement(acc, []);
						lastHeight = dsum(map(last, \j -> rowsHeights[j]));
						if (lastHeight + h > availableHeight) {
							arrayPush(acc, [i]);
						} else {
							replace(acc, length(acc) - 1, arrayPush(last, i));
						}
					}
				});

				map(pagesRows, \pageRows -> {
					MLines2A(headerM, MLines(separateRows(map(pageRows, \i -> rows[i]))));
				});
			}
		);
	}

	MonthViewByDay = \curD : Date, items : [CalendarEvent] -> {
		lastMonthDayDate = Date(curD.year, curD.month, getNumberOfDaysPerMonthInTheYear(curD.year)[curD.month]);
		RangeView(
			manager,
			items,
			eventTypesB,
			Date(curD.year, curD.month, 1),
			lastMonthDayDate,
			\date, events -> dayEventsPopup(date, events, eventTypesB, manager, getValue(choosedFilters), 0, false, styles),
			dateMin,
			dateMax,
			0,
			false,
			isPrintingB,
			RangeTab(),
			styles
		)
	}

	MonthViewSwitchMenu = \ -> {
		style = concat(
			calendarTabMenuStyle.icon,
			[MIconButtonBorder(8.), MToggleFalseIcon("view_column", arrayPush(calendarTabMenuStyle.icon, MGrey(600)))]
		);
		MIconToggle("view_module", style, [MToggleValue(byWeekViewB)]) |> (\m -> MCols2(MFillX(), m))
	}

	monthViewB = fselect3(byWeekViewB, currentDateB, currentEvents, \byWeekView, currentDate, items -> {
		if (byWeekView) {
			MonthViewByWeek(currentDate, items);
		} else {
			MonthViewByDay(currentDate, items);
		}
	});

	CalendarTabView(
		MConstruct([
				make2Subscribe(currentEvents, maxDisplayedEventsInOneDayB, \events, maxEvents -> {
					next(multiDayEventsPosition, []);
					checkMultiDayEventsPosition(dateMin, dateMax, events, maxEvents, multiDayEventsPosition);
				})
			],
			MGroup2(
				TRectangle([Fill(white), FillOpacity(1.0)], TFillXY()),
				MLines2A(
					if (showMonthSwitchView) MFrame(0.0, 0.0, calendarTabMenuStyle.background, MonthViewSwitchMenu()) else MEmpty(),
					MSelect(monthViewB, \monthView -> monthView.main),
				)
			)
		),
		\availableSize -> fgetValue(monthViewB).getPrintPages(availableSize)
	);
}

// week utils
getWeeksBetweenDates(date1 : Date, date2 : Date, acc : int) -> int {
	start = min(date1, date2);
	end = max(date1, date2);
	res = if (start.year == end.year) acc + getWeekOfYear(end, 0, true) - getWeekOfYear(start, 0, true)
		else getWeeksBetweenDates(start, Date(end.year - 1, 12, 31), getWeekOfYear(end, 0, true) + acc);
	if (date1 <= date2) res else -res
}

getWeekStartDate(weekNum : int, year : int) -> Date {
	if (weekNum == 1) Date(year, 1, 1)
	else {
		lastYearDay = Date(year, 12, 31);
		lastWeekNum = getWeekOfYear(lastYearDay, 0, true);
		weekDate = addDaysToDate(lastYearDay, 7 * (weekNum - lastWeekNum));
		addDaysToDate(weekDate, -dayOfWeek(weekDate))
	}
}

getWeekEndDate(start : Date) -> Date {
	end = addDaysToDate(start, 6 - dayOfWeek(start));
	if (end.year == start.year) end else Date(start.year, 12, 31)
}

getNextWeekStartDate(weekNum : int, year : int, weeksToAdd : int) -> Date {
	lastWeekNum = getWeekOfYear(Date(year, 12, 31), 0, true);
	weeksToAddThisYear = lastWeekNum - weekNum;
	if (weeksToAddThisYear < weeksToAdd) getNextWeekStartDate(0, year + 1, weeksToAdd - weeksToAddThisYear)
	else getWeekStartDate(weekNum + weeksToAdd, year)
}

getMonthsBetweenDates(date1 : Date, date2 : Date, acc : int) -> int {
	start = min(date1, date2);
	end = max(date1, date2);
	res = if (start.year == end.year) acc + end.month - start.month else getMonthsBetweenDates(start, Date(end.year - 1, 12, 31), acc + end.month);
	if (date1 <= date2) res else -res
}

RangeView(
	manager : MaterialManager,
	events : [CalendarEvent],
	eventTypes : DynamicBehaviour<[CalendarEventDecription]>,
	startDate : Date,
	endDate : Date,
	showDayEventsPopup : (date : Date, events : [CalendarEvent]) -> void,
	dateMin : Date,
	dateMax : Date,
	rangeType : int,
	showMonthRow : bool,
	isPrintingB : DynamicBehaviour<bool>,
	tab : CalendarTab,
	styles : [CalendarForEventsStyle]
) -> CalendarTabView {
	gridWidth = 1.0;
	isReadOnlyB = extractStruct(styles, CalendarReadOnly(const(false))).isReadOnlyB;
	eventsOpacity = extractStruct(styles, CalendarEventsOpacity(1.0)).opacity;
	enableScrolls = extractStruct(styles, CalendarScrolls(true)).enable;

	getWeekDay = extractStruct(styles, CalendarWeekDayView(\dayName, __ -> {
		MCenterX(MText(dayName, [MCaptionColumn(), MGrey(500)])) |> MBorderTopBottom(6.0)
	})).getView;
	getDayNumber = extractStruct(styles, CalendarDayNumberView(\dayNumber, isToday, isWeekend, __ -> {
		circleDiam = 24.0;
		circleSize = MFixed(circleDiam, circleDiam);
		todayBackgroundColor = getPrimaryColor(manager);
		textColor = if (isToday) {
			MContrastingTextColor(todayBackgroundColor);
		} else if (isWeekend) {
			MRed(600);
		} else {
			MBlack();
		}
		dayNumberM = MCenterIn(MText(dayNumber, [MBodyBold(), textColor]), circleSize);
		MCenterX(if (isToday) {
			MGroup2(
				MFrame(0.0, circleDiam / 2.0, [MFill(todayBackgroundColor)], circleSize),
				dayNumberM
			);
		} else {
			dayNumberM;
		});
	})).getView;
	getEventView = extractStruct(styles, CalendarCustomEventView(\__, __, __, __, __ -> None())).getView;
	showDaysNames = containsStruct(styles, ShowWeekViewDaysNames());
	getEventTitle = extractStruct(styles, CalendarCustomEventTitle(getEventTitleDefault)).getTitle;

	byDayCellHeight = if (showDaysNames) 58.0 else 48.0;
	byDayCellSize : Tropic = TFillXH(byDayCellHeight);

	getRangeColumnsCount = \start : Date, end : Date -> {
		if (rangeType == 0) getDaysBetweenDates(start, end)
		else if (rangeType == 1) getWeeksBetweenDates(start, end, 0)
		else end.month - start.month + 12 * (end.year - start.year)
	}

	getNextDate = \oldDate : Date, dateNum : int -> {
		newDate = if (rangeType == 0) addDaysToDate(oldDate, 1 * dateNum)
			else if (rangeType == 1) getNextWeekStartDate(getWeekOfYear(oldDate, 0, true), oldDate.year, dateNum)
			else addMonthsToDate(oldDate, 1 * dateNum);
		min(max(newDate, startDate), endDate)
	}

	columnsCountInRange = getRangeColumnsCount(startDate, endDate) + 1;
	rangeEvents = filter(events, \event -> time2date(event.startDate) <= endDate && startDate <= time2date(event.endDate));

	cellBorder = \colour : int, height : double -> TRectangle([Fill(colour)], TFillMax(2., height));

	eventsByRow : [[CalendarEvent]] = fold(sortCustom(rangeEvents, \event -> event.endDate, true), [], \res, event : CalendarEvent -> {
		eitherFn(
			findi(res, \x -> getRangeColumnsCount(time2date(lastElement(x, emptyEvent).endDate), time2date(event.startDate)) > 0),
			\idx -> replace(res, idx, arrayPush(res[idx], event)),
			\ -> arrayPush(res, [event])
		)
	});

	titleRowHeightB = make(0.0);
	titleRow = MAttachHeight(MColsA(generate(0, columnsCountInRange, \dateNum -> {
		date = getNextDate(startDate, dateNum);
		isTodayB = fand(const(compareDates(date, getCurrentDate()) == DateEqual()), fnot(isPrintingB));

		text = i2s(if (rangeType == 0) date.day else if (rangeType == 1) getWeekOfYear(date, 0, true) else date.month);
		isWeekend = dayOfWeek(date) >= 5 && rangeType == 0;
		dayNumberM = MIfLazy(isTodayB, \isToday -> getDayNumber(text, isToday, isWeekend, tab));

		if (rangeType == 0 && showDaysNames) {
			MLines2A(getWeekDay(toUpperCase(dayOfWeekString(date, false)), tab), dayNumberM) |> MBorderBottom(8.0);
		} else {
			MCenterIn(dayNumberM, byDayCellSize);
		}
	})), titleRowHeightB);

	dayClickGrid = MColsA(generate(0, columnsCountInRange, \dateNum -> {
		date = getNextDate(startDate, dateNum);
		eventsToShow = {
			sectionStart = if (rangeType <= 1) date else Date(date.year, date.month, 1);
			sectionEnd = if (rangeType == 0) date
					else if (rangeType == 1) getWeekEndDate(sectionStart)
					else Date(date.year, date.month, getNumberOfDaysPerMonthInTheYear(date.year)[date.month]);
			filter(
				rangeEvents,
				\event -> max(sectionStart, startDate) <= time2date(event.endDate) && time2date(event.startDate) <= min(sectionEnd, endDate)
			)
		}
		onClick = \ -> {
			if (isDateBetween(date, dateMin, dateMax)) showDayEventsPopup(date, eventsToShow);
		}
		MComponent([MOnClick(onClick), MEnabled(fnot(isReadOnlyB))], \__ -> MFillXY());
	}));

	EventCells = \len : int, event : CalendarEvent -> {
		eventTypeB = fselect(eventTypes, FLift(\types -> {
			findDef(types, \et -> et.name == event.eventType, makeCalendarEventDescription())
		}));
		date = max(time2date(event.startDate), startDate);
		getEventCells = \eventType -> MCols(generate(0, len, \cellNum : int -> {
			leftCorner = b2d(cellNum == 0) * 4.;
			rightCorner = b2d(cellNum == len - 1) * 4.;
			backColourInt = MColor2int(eventType.backColor);
			MCols2A(
				TRounded(leftCorner, rightCorner, rightCorner, leftCorner, [Fill(backColourInt), FillOpacity(eventsOpacity)], byDayCellSize),
				cellBorder(if (cellNum == len - 1) white else backColourInt, byDayCellHeight)
			);
		}));
		getDefaultView = \eventCells, eventType -> {
			text = MCenterYIn(MBorder(8., 0., 8., 0.,
				MEllipsisText(getEventTitle(event), [eventType.mainColor, MShowTooltip(make(true))])
			), eventCells);
			MGroup2(eventCells, MTooltip(text, MText(event.description, []), [MEnabled(const(isTooltipEnabled(event)))]));
		}

		isEditActionNotEmptyB = fselect(eventTypeB, FLift(\et -> et.editAction != nop1));
		MComponent(
			[MOnClick(\ -> fgetValue(eventTypeB).editAction(event.id)), MEnabled(fand(fnot(isReadOnlyB), isEditActionNotEmptyB))],
			\__ -> {
				MSelect(eventTypeB, \eventType -> {
					eventCells = getEventCells(eventType);
					eitherMap(getEventView(tab, event, eventType, date, len), MFixWidth(eventCells), getDefaultView(eventCells, eventType))
				})
			}
		) |> disableMInteractivesBelow |> MBorderLeft(gridWidth);
	};
	EmptyCells = \len : int -> MCols(generate(0, len, \__ -> MCols2(MFillXH(0.0), cellBorder(white, 0.0))));

	rowsHeightsB = generate(0, length(eventsByRow), \__ -> make(0.0));
	eventRows = mapi(eventsByRow, \i, evs : [CalendarEvent] -> {
		MAttachHeight(
			mapi(evs, \j, event -> {
				eventLength = getRangeColumnsCount(max(time2date(event.startDate), startDate), min(time2date(event.endDate), endDate)) + 1;
				blankLength = if (j == 0) {
					getRangeColumnsCount(startDate, time2date(event.startDate));
				} else {
					getRangeColumnsCount(time2date(evs[j - 1].endDate), time2date(event.startDate)) - 1;
				}
				res = [EventCells(eventLength, event)]
					// insert empty cells before event, if any
					|> (\r -> if (blankLength > 0) insertArray(r, 0, EmptyCells(blankLength)) else r)
					// insert empty cells after event, if it's the last
					|> (\r -> {
						c = getRangeColumnsCount(time2date(event.endDate), endDate);
						if (j == length(evs) - 1 && c > 0) arrayPush(r, EmptyCells(c)) else r
					});
				res
			}) |> concatA |> MCols,
			rowsHeightsB[i]
		);
	});

	gridLinesStyle = [MFill(MGrey(400)), FillOpacity(0.4)];

	monthCount = getMonthsBetweenDates(startDate, endDate, 1);

	monthNamesRowHeightB = make(0.0);
	monthNamesRow = MAttachHeight(MCols(generate(0, monthCount, \idx -> {
		date = addMonthsToDate(startDate, idx);
		len = getDaysBetweenDates(
			if (idx == 0) startDate else Date(date.year, date.month, 1),
			if (idx == monthCount - 1) endDate else Date(date.year, date.month, getNumberOfDaysPerMonthInTheYear(date.year)[date.month])
		) + 1;
		MCols2A(
			TRectangle(if (idx == 0) [Fill(white)] else gridLinesStyle, TFixed(gridWidth, 24.)),
			MOnTop(
				MCols(generate(0, len, \__ -> TFillXH(24.))),
				MCenter(MEllipsisText(monthString(date, true), [MBodyBold(), MShowTooltip(const(true))]))
			)
		)
	})), monthNamesRowHeightB);

	gridLine = TRectangle(gridLinesStyle, TFillWY(gridWidth));
	verticalGrid = MCols(concatA(generate(0, columnsCountInRange, \__ -> [gridLine, TFillX()])));

	horizontalLine = TRectangle(gridLinesStyle, TFillXH(gridWidth));

	addTitleAndGrid = \m -> {
		MLinesA([
			if (rangeType == 0 && showMonthRow) monthNamesRow else MEmpty(),
			horizontalLine,
			MOnTop(
				dayClickGrid,
				MOnTop(MLinesA([titleRow, horizontalLine, m]), verticalGrid)
			)
		]);
	}

	CalendarTabView(
		addTitleAndGrid(MLinesA(eventRows) |> (\c -> if (enableScrolls) MScroll(c, TFillXY(), []) else c)),
		\availableSize -> {
			titleHeight = getValue(monthNamesRowHeightB) + getValue(titleRowHeightB) + 2.0 * gridWidth;
			availableHeight = availableSize.height - titleHeight;
			pagesRows = foldi(eventRows, Pair([], 0.0), \i, acc, row -> {
				rowHeight = getValue(rowsHeightsB[i]);
				if (acc.first == []) {
					Pair([[row]], rowHeight);
				} else if (acc.second + rowHeight < availableHeight) {
					lastIndex = length(acc.first) - 1;
					newRows = replace(acc.first, lastIndex, arrayPush(acc.first[lastIndex], row));
					Pair(newRows, acc.second + rowHeight);
				} else {
					Pair(arrayPush(acc.first, [row]), rowHeight);
				}
			}).first;

			if (pagesRows == []) {
				[addTitleAndGrid(MFillXY())];
			} else {
				map(pagesRows, \rows -> addTitleAndGrid(MLines(rows)));
			}
		}
	);
}

//Shows ONLY the upcoming events
PlannedEventsTable(
	currentEvents : DynamicBehaviour<[CalendarEvent]>,
	eventTypesB : DynamicBehaviour<[CalendarEventDecription]>,
	manager : MaterialManager,
	tabsDropdownM : Material,
	styles : [CalendarForEventsStyle]
) -> Material {
	tableDateFormat = extractStruct(styles, PlannedTableDateFormat("%YYYY/%MM/%DD")).tableDateFormat;
	hideTimeInfo = contains(styles, HideTimeInfo());
	littleFont = MBody();
	calendarTabMenuStyle = extractStruct(styles, defaultCalendarTabMenuStyle);
	isReadOnlyB = extractStruct(styles, CalendarReadOnly(const(false))).isReadOnlyB;
	printButtonStyleM = maybeMap(tryExtractStruct(styles, CalendarPrintable([])), \p -> p.style);
	getEventTitle = extractStruct(styles, CalendarCustomEventTitle(\event -> {
		if (event.title != "") event.title else event.eventType;
	})).getTitle;

	timeSort = \item : CalendarEvent -> item.startDate;

	getLastEvents = \events -> {
		today = stamp2time2(timestamp());
		eventsAfterToday = filter(events, \event -> event.startDate >= today);
		sortCustom(eventsAfterToday, timeSort, true);
	}

	getLastEventsWithDescription = \events -> {
		today = stamp2time2(timestamp());
		filter(events, \event -> event.startDate >= today && event.description != "")
	}

	currentLine = make(-1);

	lineHeight = 60.;
	lineSeparatorHeight = 1.0;

	titleTextM = MCenterYIn(
		MSelect(currentEvents, \events -> MText(i2s(length(getLastEvents(events))) + " " + _("planned events"), calendarTabMenuStyle.text)),
		TFillXH(60.0)
	) |> MBorderStart(20.0);

	createTimeColumn = \_columnHeader -> {
		if (hideTimeInfo) TEmpty()
		else
			MCenterYIn(
				MText(_columnHeader, [littleFont, MGrey(800)]),
				TFixed(150., lineHeight)
			)
	}

	columnNames = MGroup([
		MLines2A(
			TRectangle([MFill(MGrey(200)), FillOpacity(1.0)], TFillXH(lineHeight)),
			TRectangle([MFill(MGrey(500)), FillOpacity(0.3)], TFillXH(2.))
		),
		MColsA([
			TFixed(25., 0.),
			MCenterYIn(
				MText(_("Date"), [littleFont, MGrey(800)]),
				TFixed(80., lineHeight)
			),
			TFixed(100., 0.),
			MCenterYIn(
				MText(_("Event name"), [littleFont, MGrey(800)]),
				TFixed(200., lineHeight)
			),
			TFixed(5., 0.),
			MIf(
				fselect(currentEvents, FLift(\events -> length(getLastEventsWithDescription(events)) > 0)),
				MCenterYIn(
					MText(_("Description"), [littleFont, MGrey(800)]),
					TFillXH(lineHeight)
				),
				TFillXH(lineHeight)
			),
			TFixed(5., 0.),
			createTimeColumn(_("Start time")),
			createTimeColumn(_("End time"))
		])
	]);

	makeAddButtonsMenu = \ev, evType -> {
		mainButton = MIconButton("more_horiz",
			nop,
			[MIconSize(22.), FillOpacity(1.0)],
			[]
		);

		items = map(evType.additionalActions, \act -> {
			MMenuCustomLine(
				MColsA([
					MCenterYIn(
						MIcon(act.icon, [MIconSize(22.), FillOpacity(1.0)]),
						TFixed(50., 44.)
					),
					MCenterYIn(
						MText(act.name, [littleFont]),
						TFixed(0., 44.)
					)
				]),
			[])
		});

		MCenterYIn(
			MMenu(
				mainButton,
				items,
				[MOnListClick(const(true), \index -> evType.additionalActions[index].action(ev.id))]
			),
			TFixed(50., lineHeight)
		)
	}

	isPrintingB = make(false);

	eventLine = \number, event -> {
		eventTypes = getValue(eventTypesB);
		eventType = findDef(eventTypes, \p -> p.name == event.eventType, makeCalendarEventDescription());
		eventName = getEventTitle(event);
		eventDate = date2formatString(time2date(event.startDate), tableDateFormat);

		isStartDayOrEndDayTime = \time -> {
			time.hour == 0 && time.min == 0 || time.hour == 23 && time.min == 59;
		}
		createTimeLabel = \time -> {
			if (hideTimeInfo) TEmpty()
			else
				MCenterYIn(
					MText(if (time != "") lpad(time, "0", 5) else "", [littleFont]),
					TFixed(150., lineHeight)
				)
		}
		times = if (isStartDayOrEndDayTime(event.startDate) && isStartDayOrEndDayTime(event.endDate)) {
			Pair("", "");
		} else if (event.startDate.hour == event.endDate.hour && event.startDate.min == event.endDate.min) {
			Pair(getTimeOnlyString(event.startDate, false, false), "");
		} else {
			Pair(
				getTimeOnlyString(event.startDate, false, false),
				getTimeOnlyString(event.endDate, false, false)
			);
		}
		startTimeM = createTimeLabel(times.first);
		endTimeM = createTimeLabel(times.second);

		isEditActionNotEmpty = eventType.editAction != nop1;
		isSelectedB = fand(feq(currentLine, number), fnot(isPrintingB));
		MComponent(
			[MOnClick(\ -> nextDistinct(currentLine, number)), MEnabled(fand(fnot(isReadOnlyB), const(isEditActionNotEmpty)))],
			\__ -> MGroup([
				MGroup2(
					MSelect(isSelectedB, \isSelected ->
						TRectangle([MFill(if (isSelected) MCustomColor(0xFFECB3) else MWhite()), FillOpacity(1.0)], TFillXH(lineHeight + lineSeparatorHeight))),
					TRectangle([Fill(grey), FillOpacity(0.6)], TFillXH(lineSeparatorHeight))
					|> (\m -> MBorder(25., lineHeight, 25., 0., m))
				),
				MColsA([
					TFixed(25., 0.),
					MCenterYIn(
						MText(eventDate, [littleFont]),
						TFixed(80., lineHeight)
					),
					MCenterIn(
						MAvatar(eventType.icon, [MIconSize(40.0)]),
						TFixed(100., lineHeight)
					),
					MCenterYIn(
						MEllipsisText(eventName, [littleFont]),
						TFixed(200., lineHeight)
					),
					TFixed(5., 0.),
					MCenterYIn(
						MEllipsisText(event.description, [littleFont]),
						TFillXH(lineHeight)
					),
					TFixed(5., 0.),
					startTimeM,
					MIf(isSelectedB,
						MColsA([
							if (length(eventType.additionalActions) > 0) {
								if (length(eventType.additionalActions) == 1) {
									MCenterYIn(
										MIconButton(eventType.additionalActions[0].icon,
											\-> {eventType.additionalActions[0].action(event.id)},
											[MIconSize(22.), FillOpacity(1.0)],
											[]
										),
										TFixed(50., lineHeight)
									)
								} else {
									makeAddButtonsMenu(event, eventType)
								}
							} else {
								TFixed(0., 0.)
							},
							MCenterYIn(
								MIconButton("mode_edit",
									\-> {
										eventType.editAction(event.id)
									},
									[MIconSize(22.), FillOpacity(0.8)],
									[]
								),
								TFixed(50., lineHeight)
							),
							MCenterYIn(
								MIconButton("close",
									\-> {
										close = make(false);
										ShowMDialog(manager, close, [],
											eventDeletePopup(
												\-> next(close, true),
												\-> {
													eventType.deleteAction(event.id);
													next(close, true);
												}
											)
										);
									},
									[MIconSize(22.), FillOpacity(0.8)],
									[]
								),
								TFixed(50., lineHeight)
							),
							if (length(eventType.additionalActions) == 0)
								TFixed(50., 0.)
							else
								TFixed(0., 0.)
						]),
						endTimeM
					)
				])
			])
		)
	};

	rowsB = fselect(currentEvents, FLift(\eventUnsort -> {
		eventSorted = getLastEvents(eventUnsort);
		mapi(eventSorted, eventLine);
	}));

	contentM = MGroup2(
		TRectangle([Fill(white), FillOpacity(1.0)], TFillXY()),
		MSelect(rowsB, MLinesA)
	);

	addBackground = \m -> MFrame(0.0, 0.0, calendarTabMenuStyle.background, m);

	printCalendarButtonM = eitherMap(printButtonStyleM, \printButtonStyle -> {
		headerM = MLines2A(addBackground(titleTextM), columnNames);
		getPrintPages = \availableSize -> {
			rows = fgetValue(rowsB);
			rowHeight = lineHeight + lineSeparatorHeight;
			rowsPerPage = floor(availableSize.height / rowHeight);
			pagesCount = ceil(i2d(length(rows)) / i2d(rowsPerPage));
			generate(0, pagesCount, \i -> MLinesA(subrange(rows, i * rowsPerPage, rowsPerPage)));
		}
		style = if (printButtonStyle == []) calendarTabMenuStyle.icon else printButtonStyle;
		getPrintCalendarIconButton(manager, headerM, MEmpty(), getPrintPages, isPrintingB, style);
	}, MEmpty());

	headerM = addBackground(MColsYCenterA([titleTextM, tabsDropdownM, printCalendarButtonM]));

	MLinesA([headerM, columnNames, MScroll(contentM, TFillXY(), [])]);
}

reshuffleEvents(
	events : [CalendarEvent],
	startPos : int,
	endPos : int,
	eventToChange : CalendarEvent
	) -> [CalendarEvent] {

	if (startPos < endPos) {
		newPos = startPos + 1;
		newEvents = if (newPos < length(events)) {
			swapIndexes(events, startPos, newPos);
		} else {
		//if we need to place an event outside the array - just insert an empty event into its place
			newEvents = replace(events, startPos, emptyEvent);
			arrayPush(newEvents, eventToChange);
		}
		reshuffleEvents(newEvents, newPos, endPos, eventToChange);
	} else {
		swapIndexes(events, startPos, endPos);
	}
}

checkOneDayEventsPosition(
	events : [CalendarEvent],
	maxEvents : int,
	multiDayEventsPosition : DynamicBehaviour<[Pair<CalendarEvent, int>]>
) -> [CalendarEvent] {
	printEvents = \evt -> println(foldi(evt, "", \index, res, it -> res + " #" + i2s(index) + " " + it.eventType));

	//To avoid an endless loop with an attempt to take one "seat" by two events
	eventsInWrongPositionWithoutCorrection = foldi(events, [], \i, res, item -> {
		index = either(findi(multiDayEventsPosition |> getValue, \p2 -> p2.first == item), -1);
		if (index != -1) {
			currentPosition = i;
			rigthPosition = getValue(multiDayEventsPosition)[index].second;
			arrayPush(res, Pair(currentPosition, rigthPosition))
		} else {
			res
		}
	});

	eventsInWrongPosition = foldi(events, [], \i, res, item -> {
		index = either(findi(multiDayEventsPosition |> getValue, \p2 -> p2.first == item), -1);
		if (index != -1) {
			currentPosition = i;
			rigthPosition = getValue(multiDayEventsPosition)[index].second;
			corrRightPosition = if (rigthPosition >= length(events)) {
				//if we already have a non-empty event in this position, we don't occupy it
				index2 = either(findi(eventsInWrongPositionWithoutCorrection, \p2 ->
					(p2.first != currentPosition && (p2.second == maxEvents - 1 || p2.second >= maxEvents ))), -1);
				if (index2 == -1) maxEvents - 1 else rigthPosition;
			} else {
				rigthPosition;
			}
			//println("c - " + i2s(currentPosition) + " r - " + i2s(rigthPosition) + " cr - " + i2s(corrRightPosition));
			if (currentPosition != corrRightPosition) {
				arrayPush(res, Pair(currentPosition, corrRightPosition))
			} else
				res
		} else {
			res
		}
	});

	if (length(eventsInWrongPosition) > 0) {
		//printEvents(events);
		newEvents = reshuffleEvents(events, eventsInWrongPosition[0].first, eventsInWrongPosition[0].second, events[eventsInWrongPosition[0].first]);
		//printEvents(newEvents);
		if (events != newEvents) checkOneDayEventsPosition(newEvents, maxEvents, multiDayEventsPosition) else events;
	} else {
		events
	}

}

//Multi-day events must go in one position through all the days.
//Therefore, before displaying, you need to know the positions of ALL events
checkMultiDayEventsPosition(
	dateMin : Date,
	dateMax : Date,
	allEvents : [CalendarEvent],
	maxEvents : int,
	multiDayEventsPosition : DynamicBehaviour<[Pair<CalendarEvent, int>]>
	) -> void {
	minYear = dateMin.year;
	maxYear = dateMax.year;
	years = enumFromTo(minYear, maxYear);
	months = enumFromTo(1, 12);

	iter(years, \year -> {
		filteredByYear = filter(allEvents, \item -> timeYearCheck(item.startDate.year, item.endDate.year, year));

		iter(months, \month -> {
			filteredByMonth = filter(filteredByYear, \item -> timeMonthCheck(item.startDate, item.endDate, Date(year, month, 1)));

			daysNum = getNumberOfDaysPerMonthInTheYear(year)[month];
			days = enumFromTo(1, daysNum);

			iter(days, \day -> {
				timeSort = \item : CalendarEvent -> item.startDate;

				currentDate = Date(year, month, day);

				dayEvents = filter(filteredByMonth, \item -> timeDayCheck(item.startDate, item.endDate, currentDate, day));

				events = sortEvents(dayEvents)
					|> \evs -> concat(evs, generate(0, maxEvents - length(evs), \__ -> emptyEvent));

				newEvents = checkOneDayEventsPosition(events, maxEvents, multiDayEventsPosition);
				iteri(newEvents, \i, item -> {
					isMultiDay = (time2date(item.startDate) != time2date(item.endDate));
					if (isMultiDay) {
						if (currentDate == time2date(item.startDate)) {
							index = either(findi(multiDayEventsPosition |> getValue, \p -> p.first == item), -1);
							if (index == -1)
								next(multiDayEventsPosition, arrayPush(getValue(multiDayEventsPosition), Pair(item, i)));
						}
					}
				});
			});
		});
	});
}

showDatePickerDialog(
	date : Date,
	manager : MaterialManager,
	onOk : (Date) -> void,
	dateMin : Date,
	dateMax : Date,
	markDays : (Date) -> bool
) -> void {
	value = make(date);
	close = make(false);
	ShowMDialog(manager, close, [MDialogClickOutToClose()],
		MDatePicker(
			value,
			[
				MDialogButtons([
					MButtonOk("enter", \ -> { next(close, true); onOk(getValue(value)) }),
					MButtonCancel("esc", \ -> next(close, true))
				]),
				MMarkDays(markDays), MDateMin(dateMin), MDateMax(dateMax)
			]
		)
	)
}

CalendarDayEvent(event : CalendarEvent, type : CalendarEventDecription, heightB : DynamicBehaviour<double>);

CalendarDayEventTimeType ::= CalendarDayAllDayEvent, CalendarDayPastEvent, CalendarDayCurrentEvent, CalendarDayFutureEvent;
	CalendarDayAllDayEvent(isPastEvent : bool);
	CalendarDayPastEvent();
	CalendarDayCurrentEvent();
	CalendarDayFutureEvent();

getCalendarDayEventTimeline(
	dayEvent : CalendarDayEvent,
	timeType : CalendarDayEventTimeType,
	currentTimeB : Transform<Time>,
	firstEventIdB : Transform<int>,
	lastEventIdB : Transform<int>,
	isCircleVisible : bool,
	pastColor : MColor,
	futureColor : MColor
) -> Material {
	event = dayEvent.event;
	eventHeightB = dayEvent.heightB;
	circleRadius = if (isCircleVisible) 4.0 else 0.0;
	circleDiam = 2.0 * circleRadius;
	lineWidth = 2.0;
	timelineWidth = 24.0;

	circleM = MFrame(0.0, circleRadius, [MFill(futureColor)], MFixed(circleDiam, circleDiam));

	getLine = \color, addMargin, heightB -> {
		margin = if (addMargin) circleRadius - lineWidth * 0.5 else 0.0;
		MFrame(0.0, 0.0, [MFill(color)], MSizedHeight(lineWidth, heightB)) |> MBorderLeft(margin);
	}

	timelineM = switch (timeType : CalendarDayEventTimeType) {
		CalendarDayAllDayEvent(__): MEmpty();
		CalendarDayPastEvent(): getLine(pastColor, false, eventHeightB);
		CalendarDayFutureEvent(): {
			futureHeightB = fsubtract(eventHeightB, const(circleDiam));
			MLinesXCenter([circleM, getLine(futureColor, false, futureHeightB)]);
		}
		CalendarDayCurrentEvent(): {
			pastHeightB = if (isCircleVisible) {
				fselect2(currentTimeB, eventHeightB, FLift2(\time, height -> {
					roundTime = \t -> dfloor(time2stamp(t) / 100000.0);
					start = roundTime(event.startDate);
					end = roundTime(event.endDate);
					min(height - circleDiam, max(0.0, dround(height * (roundTime(time) - start) / (end - start)) - circleRadius));
				}));
			} else {
				const(0.0);
			}
			futureHeightB = fselect2(pastHeightB, eventHeightB, FLift2(\pastHeight, height -> height - pastHeight - circleDiam));
			MLinesA([
				getLine(pastColor, isCircleVisible, pastHeightB),
				circleM,
				getLine(futureColor, isCircleVisible, futureHeightB)
			]);
		}
	}

	getTimelineBorder = \isStart -> {
		colorM = switch (timeType : CalendarDayEventTimeType) {
			CalendarDayAllDayEvent(__): None();
			CalendarDayPastEvent(): Some(pastColor);
			CalendarDayFutureEvent(): Some(futureColor);
			CalendarDayCurrentEvent(): Some(if (isStart) pastColor else futureColor);
		}
		eitherMap(colorM, \color -> MFrame(0.0, 0.0, [MFill(color)], MFixed(timelineWidth * 0.5, lineWidth)), MEmpty());
	}
	timelineStartM = MShow(feq(firstEventIdB, event.id), getTimelineBorder(true));
	timelineEndM = MShow(feq(lastEventIdB, event.id), getTimelineBorder(false));
	timelineBordersM = MAvailableHeight(MLinesA([timelineStartM, MFillY(), timelineEndM]), eventHeightB);

	centerTimeline = \m -> MCenterXIn(m, MFillWY(timelineWidth));
	isHoveringB = make(false);
	MComponent([
			THovering(isHoveringB),
			MTooltipAlignment(MRight()),
			MEnabled(const(!isSameStructType(timeType, CalendarDayAllDayEvent(false)))),
			MTooltipText(fselect(isHoveringB, FLift(\__ -> getTimeOnlyString(stamp2time2(timestamp()), false, false))))
		],
		\__ -> MGroup2(centerTimeline(timelineM), centerTimeline(timelineBordersM))
	);
}

getCalendarDayEventDefaultView(event : CalendarEvent, type : CalendarEventDecription, timeType : CalendarDayEventTimeType, styles : [CalendarForEventsStyle]) -> Material {
	getEventTitle = extractStruct(styles, CalendarCustomEventTitle(getEventTitleDefault)).getTitle;
	eventsOpacity = extractStruct(styles, CalendarEventsOpacity(0.2)).opacity;

	getEventView = \timeString, backColor, strokeColor, circleColor -> {
		textColor = MTextMColor(backColor);
		MFrame(16.0, 4.0, [MFill(backColor), StrokeWidth(1.0), MStroke(strokeColor)],
			MColsYCenterA([
				MLines2A(
					MColsYCenterA([
						MIcon("schedule", [textColor]) |> MBorderEnd(8.0),
						MText(timeString, [textColor, MBodyBold()])
					]) |> MBorderBottom(4.0),
					MEllipsisText(getEventTitle(event), [textColor, MFullWidth()]) |> MBorderStart(2.0)
				),
				MFillX(),
				MFrame(0.0, 5.0, [MFill(circleColor)], MFixed(10.0, 10.0))
			])
		) |> MBorderEnd(12.0);
	}
	geEventTimeString = \ -> {
		startTime = getTimeOnlyString(event.startDate, false, false);
		endTime = if (event.startDate != event.endDate) "-" + getTimeOnlyString(event.endDate, false, false) else "";
		startTime + endTime;
	}

	transparentBackColor = MCustomColor(mixColors(MColor2int(type.backColor), white, eventsOpacity, 1.0 - eventsOpacity));
	switch (timeType : CalendarDayEventTimeType) {
		CalendarDayAllDayEvent(isPastEvent): {
			if (isPastEvent) {
				getEventView(_("All Day"), MWhite(), MGrey(400), transparentBackColor);
			} else {
				getEventView(_("All Day"), transparentBackColor, transparentBackColor, transparentBackColor);
			}
		}
		CalendarDayCurrentEvent(): getEventView(geEventTimeString(), type.backColor, type.backColor, type.backColor);
		CalendarDayFutureEvent(): getEventView(geEventTimeString(), transparentBackColor, transparentBackColor, transparentBackColor);
		CalendarDayPastEvent(): getEventView(geEventTimeString(), MWhite(), MGrey(400), transparentBackColor);
	}
}

getCalendarDayView(
	date : Date,
	dayEvents : [CalendarEvent],
	dayEventTypes : [CalendarEventDecription],
	primaryColor : MColor,
	addEvent : () -> void,
	isPrintingB : Transform<bool>,
	styles : [CalendarForEventsStyle]
) -> CalendarTabView {
	getEventView = extractStruct(styles, CalendarCustomEventView(\__, __, __, __, __ -> None())).getView;
	isReadOnlyB = extractStruct(styles, CalendarReadOnly(const(false))).isReadOnlyB;
	needContentViewFrame = extractStruct(
		styles, CalendarDayCustomTab(\__, __ -> MEmpty(), true)
	).needContentViewFrame;
	enableScrolls = extractStruct(styles, CalendarScrolls(true)).enable;

	getTime = \ -> stamp2time2(timestamp());
	isToday = getCurrentDate() == date;
	isPastDay = date < getCurrentDate();
	currentTimeB = make(getTime());
	timer = repeatable2(5 * 60 * 1000, false);
	pastColor = MGrey(400);
	futureColor = if (isToday) primaryColor else pastColor;
	firstEventIdB = make(0);
	lastEventIdB = make(0);

	getDayEventView = \timeType, dayEvent, isTimelineCircleVisible -> {
		timelineM = getCalendarDayEventTimeline(dayEvent, timeType, currentTimeB, firstEventIdB, lastEventIdB, isTimelineCircleVisible, pastColor, futureColor);
		getDefaultView = \ -> {
			MLines2A(
				getCalendarDayEventDefaultView(dayEvent.event, dayEvent.type, timeType, styles),
				MShow(fneq(lastEventIdB, dayEvent.event.id), MFixedY(4.0))
			);
		}

		isEditActionNotEmpty = dayEvent.type.editAction != nop1;
		eventViewM = MComponent(
			[MOnClick(\ -> dayEvent.type.editAction(dayEvent.event.id)), MEnabled(fand(fnot(isReadOnlyB), const(isEditActionNotEmpty)))],
			\__ -> either(getEventView(DayTab(), dayEvent.event, dayEvent.type, date, 1), getDefaultView())
		);

		MColsSameHeight([timelineM |> MBorderRight(4.0), eventViewM]);
	}

	getDayEvent = \event -> maybeMap(find(dayEventTypes, \type -> type.name == event.eventType), \type -> CalendarDayEvent(event, type, make(0.0)));

	sortEvents = \events -> sortCustom(events, \e -> time2stamp(e.event.startDate) + time2stamp(e.event.endDate) * 0.001, true);
	isAllDayEvent = \dayEvent -> {
		time2date(dayEvent.event.startDate) != time2date(dayEvent.event.endDate) ||
			(dayEvent.event.startDate <= date2time(date) && dayEvent.event.endDate >= date2timeEOD(date));
	}
	splittedEvents = unzip(filtermap(dayEvents, getDayEvent), isAllDayEvent);

	allDayEvents = splittedEvents.first;
	nonAllDayEvents = sortEvents(splittedEvents.second);
	pastEventsB = make([]);
	currentEventsB = make([]);
	futureEventsB = make([]);

	addFrame = \m -> if (needContentViewFrame) {
		MFrame(4.0, 0.0, [MStroke(MGrey(300)), StrokeWidth(1.0)], MGroup2(MFillXY(), m))
	} else {
		MGroup2(MFillXY(), m)
	}

	getAllDayEvent = \event -> getDayEventView(CalendarDayAllDayEvent(isPastDay), event, false);
	getPastEvent = \event -> getDayEventView(CalendarDayPastEvent(), event, false);
	getCurrentEvent = \event, isFirst -> getDayEventView(CalendarDayCurrentEvent(), event, isFirst);
	getFutureEvent = \event, isFirst -> MSelect(currentEventsB, \currentEvents -> {
		getDayEventView(CalendarDayFutureEvent(), event, isFirst && currentEvents == [] && isToday);
	});

	scrollPositionB = make(Point(0.0, 0.0));
	if (isToday) {
		deferUntilRender(\ -> {
			h = dsum(map(getValue(pastEventsB), \e -> getValue(e.heightB)));
			nextDistinct(scrollPositionB, Point(0.0, h));
		});
	}

	updateFirstLastEvents = \events -> {
		size = length(events);
		if (size > 0) {
			nextDistinct(firstEventIdB, events[0].event.id);
			nextDistinct(lastEventIdB, events[size - 1].event.id);
		}
	}

	updateEvents = \events, currentTime -> {
		currentDate = time2date(currentTime);
		if (currentDate > date) {
			nextDistinct(pastEventsB, events);
			updateFirstLastEvents(events);
		} else if (currentDate < date) {
			nextDistinct(futureEventsB, events);
			updateFirstLastEvents(events);
		} else {
			unpair(unzip(events, \e -> currentTime > e.event.startDate), \nonFutureEvents, newFutureEvents -> {
				unpair(unzip(concat(nonFutureEvents, getValue(currentEventsB)), \e -> currentTime > e.event.endDate), \newPastEvents, newCurrentEvents -> {
					newSortedPastEvents = sortEvents(concat(getValue(pastEventsB), newPastEvents));
					newSortedCurrentEvents = sortEvents(newCurrentEvents);
					nextDistinct(pastEventsB, newSortedPastEvents);
					nextDistinct(currentEventsB, newSortedCurrentEvents);
					nextDistinct(futureEventsB, newFutureEvents);
					updateFirstLastEvents(concatA([newSortedPastEvents, newSortedCurrentEvents, newFutureEvents]));
				});
			});
		}
	}

	updateEvents(nonAllDayEvents, getValue(currentTimeB));

	getNoEventsView = \ -> {
		MCenter(
			MLinesXCenter([
				MIcon("event", [MIconSize(168.0), MCustomColor(0xF6F7F9)]) |> MBorderBottom(4.0),
				MText(if (isPastDay) _("No Events") else _("No Events Yet"), [MTitle(), MGrey(600)]) |> MBorderBottom(16.0),
				MVisible(
					fand(const(!isPastDay), fnot(fOr(isReadOnlyB, isPrintingB))),
					MTextButton(_("ADD EVENT"), addEvent, [MButtonRaised(), MButtonPaddings(32.0, 12.0, 32.0, 12.0)], [])
				)
			])
		);
	}

	getEventsView = \ -> {
		MLines2A(
			MLinesA(map(allDayEvents, \event -> MAttachHeight(getAllDayEvent(event), event.heightB))),
			MLinesA([
				SelectMLinesA(pastEventsB, \__, i, event -> MAttachHeight(getPastEvent(event), event.heightB)),
				SelectMLinesA(currentEventsB, \__, i, event -> MAttachHeight(getCurrentEvent(event, i == 0), event.heightB)),
				SelectMLinesA(futureEventsB, \__, i, event -> MAttachHeight(getFutureEvent(event, i == 0), event.heightB)),
			]) |> (\c ->
				if (enableScrolls) MScroll(c, MFillXY(), [TScrollSetPosition(scrollPositionB)])
				else c
			)
		);
	}

	CalendarTabView(
		MConstruct([
				\ -> if (isToday) {
					timer.start();
					\ -> timer.stop();
				} else nop,
				makeSubscribe2(timer.value, \__ -> nextDistinct(currentTimeB, getTime())),
				makeSubscribe2(currentTimeB, \time -> updateEvents(getValue(futureEventsB), time))
			],
			addFrame(if (allDayEvents == [] && nonAllDayEvents == []) getNoEventsView() else getEventsView())
		),
		\availableSize -> {
			rows = concatA([
				map(allDayEvents, \e -> Pair(getAllDayEvent(e), getValue(e.heightB))),
				map(getValue(pastEventsB), \e -> Pair(getPastEvent(e), getValue(e.heightB))),
				mapi(getValue(currentEventsB), \i, e -> Pair(getCurrentEvent(e, i == 0), getValue(e.heightB))),
				mapi(getValue(futureEventsB), \i, e -> Pair(getFutureEvent(e, i == 0), getValue(e.heightB)))
			]);
			pagesRows = foldi(rows, Pair([], 0.0), \i, acc, row -> {
				rowHeight = row.second;
				if (acc.first == []) {
					Pair([[row.first]], rowHeight);
				} else if (acc.second + rowHeight < availableSize.height) {
					lastIndex = length(acc.first) - 1;
					newRows = replace(acc.first, lastIndex, arrayPush(acc.first[lastIndex], row.first));
					Pair(newRows, acc.second + rowHeight);
				} else {
					Pair(arrayPush(acc.first, [row.first]), rowHeight);
				}
			}).first;

			if (pagesRows == []) {
				[addFrame(getNoEventsView())];
			} else {
				map(pagesRows, \pageRows -> addFrame(MLinesA(pageRows)));
			}
		}
	);
}

CalendarForEvents(
	allEvents : DynamicBehaviour<[CalendarEvent]>,
	currentEventTypes : DynamicBehaviour<[CalendarEventDecription]>,
	manager : MaterialManager,
	dateMin : Date,
	dateMax : Date,
	defaultMonthNumber : int,
	displayedEventsInOneDay : int,
	onlyOneSameTypeEventsByDay : bool,
	colorizeDayHeaders : bool,
	styles : [CalendarForEventsStyle]) -> Material {

	isOnlyOneSameTypeEventsByDay := onlyOneSameTypeEventsByDay;
	isColorizeDayHeaders := colorizeDayHeaders;
	hideAddEventButton = contains(styles, HideAddEventButton());
	calendarTabMenuStyle = extractStruct(styles, defaultCalendarTabMenuStyle);
	hideLegend = containsStruct(styles, CalendarHideEventTypesLegend());
	externalDateM = tryExtractStruct(styles, CalendarCurrentDate(make(nullDate)));
	showTodayButton = containsStruct(styles, CalendarShowTodayButton());
	menuTightWidth = containsStruct(styles, CalendarMenuTightWidth());
	menuAddEventButtonM = tryExtractStruct(styles, CalendarMenuAddEventButton([]));
	isReadOnlyB = extractStruct(styles, CalendarReadOnly(const(false))).isReadOnlyB;
	printButtonStyleM = maybeMap(tryExtractStruct(styles, CalendarPrintable([])), \p -> p.style);
	isTabsDropdown = containsStruct(styles, CalendarTabsDropdown());
	hideEventsCount = containsStruct(styles, CalendarYearHideEventsCount());
	dayCustomTabM = tryExtractStruct(styles, CalendarDayCustomTab(\__, __ -> MEmpty(), true));
	enableScrolls = extractStruct(styles, CalendarScrolls(true)).enable;

	filteredEvents = make(getValue(allEvents));
	hiddenEventTypes = extractStruct(styles, HiddenEventTypes([])).types;
	choosedFilters = make(hiddenEventTypes);

	tabOrder : [CalendarTab] = extractStruct(styles, TabOrder([YearTab(), MonthTab(), PlannedTab()])).tabs;
	//0 - year, 1 - month, 2 - planned - by default
	choosedTab = make(
		findiDef(
			tabOrder,
			eq(extractStruct(styles, DefaultTab(YearTab())).tab),
			0
	));
	tabColors = extractStruct(styles, TabColors(MWhite(), MGrey(300)));
	activeTabColor = tabColors.activeTabColor;
	nonActiveTabColor = tabColors.nonActiveTabColor;
	hideTabs = length(tabOrder) < 2;

	maxYear = dateMax.year;
	minYear = dateMin.year;

	choosedTabsColor = MCustomColor(0xFDB22B);

	monthValue = \year, month -> Date(year, month, 1);
	currentMonthNumber = make(defaultMonthNumber);
	currentMonthDate = monthValue(stamp2date(timestamp()).year, defaultMonthNumber);
	currentDate = make(eitherMap(
		externalDateM,
		\externalDate -> {
			date = getValue(externalDate.currentDateB);
			if (date == nullDate) currentMonthDate else date;
		},
		currentMonthDate
	));

	width = calendarDateCellW * 7.0;
	height = calendarDateCellH * 7.0 + calendarDateNavSize;

	isPrintingB = make(false);
	yearB = fselect(currentDate, FLift(\date -> date.year));
	eventsOpacity = extractStruct(styles, CalendarEventsOpacity(1.0)).opacity;
	//It creates an image for one month (as in DatePicker)
	monthView = \monthNumber : int -> {
		openPopupForDay = \date : Date, dayEvents : [CalendarEvent] -> {
			dayEventsPopup(date, dayEvents, currentEventTypes, manager, getValue(choosedFilters), 0, dayEvents != [], styles);
		}

		MColsA([
			TFixed(calendarPickerMarginCells, 0.0),
			MSelect(yearB, \year -> {
				month = monthValue(year, monthNumber);
				filteredEventsByMonthB = ffilter(filteredEvents, \item -> {
					timeYearCheck(item.startDate.year, item.endDate.year, year)
						&& timeMonthCheck(item.startDate, item.endDate, month)
				});
				MSelect(filteredEventsByMonthB, \events -> {
					MClickable(
						MCrop(
							const(zeroPoint),
							const(WidthHeight(width, height)),
							CalendarCells(
								manager, MPrimaryColor(), month, currentDate, dateMin, dateMax, isPrintingB, events,
								currentMonthNumber, openPopupForDay, currentEventTypes, hideEventsCount, eventsOpacity, isReadOnlyB
							)
						),
						\-> {
							nextDistinct(currentMonthNumber, monthNumber);
							nextDistinct(currentDate, Date(getValue(currentDate).year, monthNumber, 1));
							nextDistinct(choosedTab, findiDef(tabOrder, eq(MonthTab()), 0));
						}
					);
				})
			}),
			TFixed(calendarPickerMarginCells, 0.0)
		]);
	};

	monthWidth = width + 2.0 * calendarPickerMarginCells;
	yearAvailableWidthB = make(0.0);
	getMonthsPerRow = \availableWidth -> {
		monthsPerRow = floor(availableWidth / monthWidth);
		if (monthsPerRow == 5) 4 else min(6, monthsPerRow);
	}
	yearWidthB = fselect(yearAvailableWidthB, FLift(\availableWidth -> {
		monthWidth * i2d(getMonthsPerRow(availableWidth));
	}));
	
	monthViewsM = generate(1, 13, monthView);
	annualView = CalendarTabView(
		MAttachAvailableWidth(
			MAvailableWidth(
				MFlexibleGrid(const(monthViewsM), [CenterAlign()]),
				yearWidthB
			),
			yearAvailableWidthB
		),
		\availableSize -> {
			monthsPerRow = getMonthsPerRow(availableSize.width);
			rowsPerPage = floor(availableSize.height / height);
			monthsPerPage = monthsPerRow * rowsPerPage;
			pagesCount = ceil(12.0 / i2d(monthsPerPage));
			generate(0, pagesCount, \i -> {
				MAvailable(
					MLines2(
						MFlexibleGrid(const(subrange(monthViewsM, i * monthsPerPage, monthsPerPage)), [CenterAlign()]),
						MFillY()
					),
					TFillMaxWY(i2d(monthsPerRow) * monthWidth)
				);
			});
		}
	);

	getTabName = \tab : CalendarTab -> {
		switch(tab) {
			YearTab(): _("Year");
			MonthTab(): _("Month");
			PlannedTab(): _("Planned");
			RangeTab(): _("Range");
			WeekTab(): _("Week");
			DayTab(): _("Day");
		}
	}

	makeTabTitle = \tabNumber : int, tabType : CalendarTab -> {
		minWidth = 120.;
		maxWidth = 210.;
		tabHeight = 62.0;
		MClickable(
			MGroup2(
				MSelect(choosedTab, \tab ->
					TRectangle(
						[MFill(choosedTabsColor),
						FillOpacity(if (tab == tabNumber) 1.0 else 0.0)],
						TFillXYXY(minWidth, 5., maxWidth, 5.)
					)
				),
				MCenterIn(
					MSelect(choosedTab, \tab ->
						MParagraph(
							toUpperCase(getTabName(tabType)),
							[
								if (tab == tabNumber) activeTabColor else nonActiveTabColor,
								if (tab == tabNumber) MCustomFont(20., "RobotoMedium", primaryTextOpacity) else MTitle(),
								CenterAlign(), MWidth(maxWidth)
							]
						)
					),
					TFillXYXY(minWidth, tabHeight, maxWidth, tabHeight)
				)
			),
			\ -> nextDistinct(choosedTab, tabNumber)
		)
	}

	subMenuButtonStyle = calendarTabMenuStyle.button;
	subMenuDropdownStyle = concat([MRightIcon("arrow_drop_down", []), MButtonPaddings(14.0, 2.0, 10.0, 2.0)], subMenuButtonStyle);
	tabTitles = MCenterXIn(MCols(mapi(tabOrder, makeTabTitle)), TFillX());
	tabsDropdownButtonM = MSelect(choosedTab, \tab -> {
		name = getTabName(tabOrder[tab]);
		MTextButton(name, nop, subMenuDropdownStyle, []);
	});
	tabsDropdownM = if (!hideTabs && isTabsDropdown) {
		MDropDown(choosedTab, "", map(tabOrder, getTabName), [MCustomButton(tabsDropdownButtonM), MOutlined()]) |> MBorderEnd(14.0);
	} else {
		MEmpty();
	}

	makeLegend = \eventDescription -> {
		focused = make(false);
		eventIndex = either(findi(choosedFilters |> getValue, \p -> p == eventDescription.name), -1);
		clicked = make((eventIndex != -1));

		MBorder(0., 10., 0., 10.,
			MColsA([
				MMouseDownAround(None(), make(false), focused, nop,
					MGroup2(
						TCircle(10., [MFill(eventDescription.backColor)]),
						MSelect(clicked, \f-> if (f)
								MIconButton("visibility_off", \-> {
										index = either(findi(choosedFilters |> getValue, \p -> p == eventDescription.name), -1);
										if (index != -1) next(choosedFilters, removeIndex(getValue(choosedFilters), index));
										next(clicked, false);
									}, [MIconSize(10.)], []
								)
							else
								MSelect(focused, \f2-> if (f2)
									MIconButton("visibility", \-> {
											next(choosedFilters, arrayPush(getValue(choosedFilters), eventDescription.name));
											next(clicked, true);
										}, [MIconSize(10.)], []
									) else TEmpty()
								)
						)
					)
				),
				TFixed(16., 0.),
				MCenterYIn(
					MText(eventDescription.name, [MCaption()]),
					TFixed(0., 20.)
				),
				TFixed(30., 0.),
			])
		);
	}

	subMenuIconStyle = calendarTabMenuStyle.icon;

	monthTable = MonthTable(filteredEvents, currentEventTypes, currentDate, dateMin, dateMax, manager, displayedEventsInOneDay, choosedFilters, isPrintingB, styles);
	plannedTable = PlannedEventsTable(filteredEvents, currentEventTypes, manager, tabsDropdownM, styles);

	eventTypesForPrintingB = make([]);

	getLegend = \isPrint -> {
		// for printing show only types of visible events
		filteredTypesB = if (isPrint) {
			eventTypesForPrintingB;
		} else {
			currentEventTypes;
		}
		MFrame(0.0, 0.0, [MFill(MGrey(100))],
			MFlexibleGrid(fselect(filteredTypesB, FLift(\types -> map(types, makeLegend))), [CenterAlign()])
		);
	}

	legendM = getLegend(false);
	printLegendM = getLegend(true);

	addHeaderBackground = \m -> MFrame(0.0, 0.0, calendarTabMenuStyle.background, m);
	addHeaderBorder = \m -> MCenterX(m |> MBorderTopBottom(16.0));

	TabContent = \tab : CalendarTab -> {
		updateCurrentDate = \newDate : Date -> {
			if (newDate == nullDate) {
				nextDistinct(currentDate, getCurrentDate());
			} else if (isDateBetween(newDate, dateMin, dateMax)) {
				nextDistinct(currentDate, newDate);
			}
		}
		customFontStyle = calendarTabMenuStyle.text;
		subMenuSize = TFillX();

		isSwipePaused = make(false);
		pauseSwipe = \ -> {
			next(isSwipePaused, true);
			timer(1000, \ -> next(isSwipePaused, false))
		}

		TabMenu = \items : [Material] -> {
			centeredItemsM = MCenterX(MColsYCenterA(items));
			addHeaderBackground(centeredItemsM);
		}
		TabBody = \body : Material -> MGroup2(
			TRectangle([Fill(white)], TFillXY()),
			MLines2(
				if (enableScrolls) MScroll(body, TFillXY(), []) else body,
				if (hideLegend) MEmpty() else legendM
			)
		);

		drawCalendarTabMenuText = \date, defaultText -> {
			text = either(extractStruct(styles, CalendarTabMenuText(\__, __ -> None())).getText(date, tab), defaultText);
			textM = MText(text, customFontStyle);
			if (menuTightWidth) textM |> MBorderLeftRight(32.0) else MCenterX(textM);
		}

		getTodayButton = \currentStartDate -> {
			if (showTodayButton) {
				isNotCurrentYearB = fselect(currentDate, FLift(\date -> date.year != currentStartDate.year));
				MVisible(if (tab != YearTab()) fneq(currentDate, currentStartDate) else isNotCurrentYearB,
					MTextButton(
						_("Today"),
						\ -> updateCurrentDate(currentStartDate),
						concat([MButtonPaddings(28.0, 6.0, 28.0, 6.0)], subMenuButtonStyle),
						[]
					)
				);
			} else {
				MEmpty();
			}
		}

		getAddEventButton = \currentStartDate -> {
			eitherMap(menuAddEventButtonM, \addEventButton -> {
				style = if (addEventButton.style == []) subMenuIconStyle else addEventButton.style;
				MShow(fnot(isReadOnlyB), MIconButton("add_circle", \ -> {
					curDate = getValue(currentDate);
					date = if (curDate == currentStartDate) getCurrentDate() else curDate;
					dateEvents = filter(getValue(filteredEvents), \item -> time2date(item.startDate) == date);
					dayEventsPopup(date, dateEvents, currentEventTypes, manager, getValue(choosedFilters), 0, false, styles);
				}, style, [MTooltipText(const(_("Add Event")))]));
			}, MEmpty());
		}

		getPrintButton = \headerM, getPrintPages -> {
			eitherMap(printButtonStyleM, \printButtonStyle -> {
				style = if (printButtonStyle == []) subMenuIconStyle else printButtonStyle;
				getPrintCalendarIconButton(manager, addHeaderBackground(headerM), printLegendM, getPrintPages, isPrintingB, style);
			}, MEmpty());
		}

		buildActionButtons = \currentStartDate, printButtonM, prevPeriodButtons, nextPeriodButtons -> {
			CalendarActionButtons(
				getAddEventButton(currentStartDate),
				printButtonM,
				tabsDropdownM,
				getTodayButton(currentStartDate),
				prevPeriodButtons,
				nextPeriodButtons
			)
		}

		getAdditionalButtons = \buttons : CalendarActionButtons -> {
			todayButton = buttons.todayButton |> MBorderLeftRight(16.0);
			leftButtons = [
				MGroup2(
					MWidthOf(MCols([buttons.addButton, buttons.printButton, buttons.tabsDropdown])),
					todayButton
				),
				if (menuTightWidth) MFillX() else MEmpty()
			];
			rightButtons = [
				if (menuTightWidth) MFillX() else MEmpty(),
				MGroup2(
					MWidthOf(todayButton),
					MColsYCenterA([buttons.tabsDropdown, buttons.printButton, buttons.addButton])
				)
			];
			Pair(leftButtons, rightButtons);
		}

		tabContent = switch(tab) {
			YearTab(): {
				tabMenuTextM = MSelect(currentDate, \date -> {
					defaultText = i2s(date.year);
					drawCalendarTabMenuText(date, defaultText);
				});
				buttons = buildActionButtons(
					getCurrentDate(),
					getPrintButton(addHeaderBorder(tabMenuTextM), annualView.getPrintPages),
					Pair(
						MIconButton(
							"keyboard_arrow_left",
							\ -> updateCurrentDate(addYearsToDate(getValue(currentDate), -1)),
							subMenuIconStyle,
							[]
						),
						MEmpty()
					),
					Pair(
						MIconButton(
							"keyboard_arrow_right",
							\ -> updateCurrentDate(addYearsToDate(getValue(currentDate), 1)),
							subMenuIconStyle,
							[]
						),
						MEmpty()
					)
				);

				menuItems = unpair(getAdditionalButtons(buttons), \leftButtons, rightButtons -> concatA([
					if (menuTightWidth) leftButtons else [],
					[buttons.prevPeriodButtons.first],
					if (!menuTightWidth) leftButtons else [],
					[tabMenuTextM],
					if (!menuTightWidth) rightButtons else [],
					[buttons.nextPeriodButtons.first],
					if (menuTightWidth) rightButtons else []
				]));

				MConstruct([
						make3Subscribe(yearB, currentEventTypes, filteredEvents, \year, types, events -> {
							filteredTypes = filter(types, \type -> {
								exists(events, \e -> (year >= e.startDate.year && year <= e.endDate.year) && e.eventType == type.name);
							});
							nextDistinct(eventTypesForPrintingB, filteredTypes);
						}),
						\ -> eitherMap(externalDateM, \externalDate -> {
							externalDateB = externalDate.currentDateB;
							fBidirectionalLink(currentDate, externalDateB,
								\curDate -> nextDistinct(externalDateB, curDate),
								\extDate -> updateCurrentDate(extDate),
							);
						}, nop)
					],
					MLines2(TabMenu(menuItems), TabBody(MLines2(MFixedY(20.), annualView.main)))
				);
			}

			MonthTab(): {
				getStartOfMonth = \d -> Date(d.year, d.month, 1);
				startOfCurrentMonth = getStartOfMonth(getCurrentDate());
				updateCurrentDate(getStartOfMonth(getValue(currentDate)));

				tabMenuTextM = MSelect(currentDate, \date -> {
					defaultText = i2s(date.year) + " " + toUpperCase(monthString(date, true));
					drawCalendarTabMenuText(date, defaultText);
				});

				buttons = buildActionButtons(
					startOfCurrentMonth,
					getPrintButton(addHeaderBorder(tabMenuTextM), monthTable.getPrintPages),
					Pair(
						MIconButton(
							"first_page",
							\ -> updateCurrentDate(addYearsToDate(getValue(currentDate), -1)),
							subMenuIconStyle,
							[]
						),
						MIconButton(
							"keyboard_arrow_left",
							\ -> updateCurrentDate(addMonthsToDate(getValue(currentDate), -1)),
							subMenuIconStyle,
							[]
						)
					),
					Pair(
						MIconButton(
							"keyboard_arrow_right",
							\ -> updateCurrentDate(addMonthsToDate(getValue(currentDate), 1)),
							subMenuIconStyle,
							[]
						),
						MIconButton(
							"last_page",
							\ -> updateCurrentDate(addYearsToDate(getValue(currentDate), 1)),
							subMenuIconStyle,
							[]
						)
					)
				);
				menuItems = unpair(getAdditionalButtons(buttons), \leftButtons, rightButtons -> concatA([
					if (menuTightWidth) leftButtons else [],
					[buttons.prevPeriodButtons.first, buttons.prevPeriodButtons.second],
					if (!menuTightWidth) leftButtons else [],
					[tabMenuTextM],
					if (!menuTightWidth) rightButtons else [],
					[buttons.nextPeriodButtons.first, buttons.nextPeriodButtons.second],
					if (menuTightWidth) rightButtons else []
				]));
				MConstruct([
						make3Subscribe(currentDate, currentEventTypes, filteredEvents, \date, types, events -> {
							filteredTypes = filter(types, \type -> {
								exists(events, \e -> (
									(date.year == e.startDate.year && date.month == e.startDate.month) ||
									isDateBetween(date, time2date(e.startDate), time2date(e.endDate))
								) && e.eventType == type.name);
							});
							nextDistinct(eventTypesForPrintingB, filteredTypes);
						}),
						\ -> eitherMap(externalDateM, \externalDate -> {
							externalDateB = externalDate.currentDateB;
							fBidirectionalLink(currentDate, externalDateB,
								\curDate -> nextDistinct(externalDateB, curDate),
								\extDate -> updateCurrentDate(getStartOfMonth(extDate))
							);
						}, nop)
					],
					MLines([TabMenu(menuItems), TabBody(monthTable.main)])
				);
			}

			PlannedTab(): plannedTable;

			RangeTab(): {
				startDate = make(getCurrentDate());
				endDate = make(addDaysToDate(getValue(startDate), 7));
				// 0 - day, 1 - week, 2 - month
				rangeTypeB = make(0);

				dateButton = \dateB : DynamicBehaviour<Date>, pickMinDate : Date, pickMaxDate : Date -> MTextClickable(
						date2formatString(getValue(dateB), "%DD.%MM.%YYYY"),
						\ -> showDatePickerDialog(
							getValue(dateB),
							manager,
							\newDate -> nextDistinct(dateB, newDate),
							pickMinDate, pickMaxDate,
							\d -> isDateBetween(d, getValue(startDate), getValue(endDate))
						),
						customFontStyle,
						[MHighlightOnHover(const(true))]
				);

				types = [_("Grouped by days"), _("Grouped by weeks"), _("Grouped by months")];
				groupedByView = MSelect(rangeTypeB, \rangeType -> MTextButton(types[rangeType], nop, subMenuDropdownStyle, []));
				groupedByMenu = MDropDown(rangeTypeB, "", types, [MCustomButton(groupedByView), MOutlined()]);

				tabMenuContentM = MCenterX(
					MSelect2(startDate, endDate, \start, end ->
						MColsA([
							dateButton(startDate, dateMin, addDaysToDate(end, -1)),
							MBorder(4., 4., 4., 4., MText("  ", customFontStyle)),
							dateButton(endDate, addDaysToDate(start, 1), dateMax),
						]),
					)
				);

				contentB = fselect4(startDate, endDate, rangeTypeB, filteredEvents, \start, end, rangeType, events -> {
					RangeView(
						manager, events, currentEventTypes, start, end,
						\date, dayEvents -> dayEventsPopup(date, dayEvents, currentEventTypes, manager, getValue(choosedFilters), rangeType, false, styles),
						dateMin, dateMax, rangeType, true, isPrintingB, tab, styles
					);
				});

				getPrintPages = \availableSize -> fgetValue(contentB).getPrintPages(availableSize);
				printButtonM = getPrintButton(tabMenuContentM, getPrintPages);

				menuItems = [
					MSizeOf(printButtonM),
					MSizeOf(groupedByMenu),
					MSizeOf(tabsDropdownM),
					tabMenuContentM,
					tabsDropdownM,
					groupedByMenu,
					printButtonM
				];

				MConstruct([
						make4Subscribe(startDate, endDate, currentEventTypes, filteredEvents, \start, end, eventTypes, events -> {
							filteredTypes = filter(eventTypes, \type -> {
								exists(events, \e -> (
									isDateBetween(time2date(e.startDate), start, end) ||
									isDateBetween(start, time2date(e.startDate), time2date(e.endDate))
								) && e.eventType == type.name);
							});
							nextDistinct(eventTypesForPrintingB, filteredTypes);
						}),
						\ -> eitherMap(externalDateM, \externalDate -> {
							externalDateB = externalDate.currentDateB;
							fBidirectionalLink(startDate, externalDateB,
								\date -> nextDistinct(externalDateB, date),
								\date -> {
									if (getValue(startDate) > date) {
										nextDistinct(startDate, date);
									} else if (getValue(endDate) < date) {
										nextDistinct(endDate, date);
									}
								}
							);
						}, nop)
					],
					MLines2A(TabMenu(menuItems), TabBody(MSelect(contentB, \content -> content.main)))
				);
			}

			WeekTab(): {
				// set current date as start of current week
				getStartOfWeek = \d -> addDaysToDate(d, -dayOfWeek(d));
				startOfCurrentWeek = getStartOfWeek(getCurrentDate());
				updateCurrentDate(startOfCurrentWeek);

				contentB = fselect2(currentDate, filteredEvents, FLift2(\start, events -> {
					RangeView(
						manager, events, currentEventTypes, start, addDaysToDate(start, 6),
						\date, dayEvents -> dayEventsPopup(date, dayEvents, currentEventTypes, manager, getValue(choosedFilters), 0, false, styles),
						dateMin, dateMax, 0, false, isPrintingB, tab, styles
					)
				}));

				tabMenuTextM = MSelect(currentDate, \date -> {
					defaultText = formatString("WEEK %1 OF %2", [i2s(getWeekOfYear(date, 0, true)), i2s(date.year)]);
					drawCalendarTabMenuText(date, defaultText);
				});

				getPrintPages = \availableSize -> fgetValue(contentB).getPrintPages(availableSize);

				buttons = buildActionButtons(
					startOfCurrentWeek,
					getPrintButton(addHeaderBorder(tabMenuTextM), getPrintPages),
					Pair(
						MIconButton(
							"first_page",
							\ -> updateCurrentDate(addDaysToDate(getValue(currentDate), -28)),
							subMenuIconStyle,
							[]
						),
						MIconButton(
							"keyboard_arrow_left",
							\ -> updateCurrentDate(addDaysToDate(getValue(currentDate), -7)),
							subMenuIconStyle,
							[]
						)
					),
					Pair(
						MIconButton(
							"keyboard_arrow_right",
							\ -> updateCurrentDate(addDaysToDate(getValue(currentDate), 7)),
							subMenuIconStyle,
							[]
						),
						MIconButton(
							"last_page",
							\ -> updateCurrentDate(addDaysToDate(getValue(currentDate), 28)),
							subMenuIconStyle,
							[]
						)
					)
				);
				menuItems = unpair(getAdditionalButtons(buttons), \leftButtons, rightButtons -> {
					concatA([
						if (menuTightWidth) leftButtons else [],
						[buttons.prevPeriodButtons.first, buttons.prevPeriodButtons.second],
						if (!menuTightWidth) leftButtons else [],
						[tabMenuTextM],
						if (!menuTightWidth) rightButtons else [],
						[buttons.nextPeriodButtons.first, buttons.nextPeriodButtons.second],
						if (menuTightWidth) rightButtons else []
					])
				});

				MConstruct([
						make3Subscribe(currentDate, currentEventTypes, filteredEvents, \date, types, events -> {
							filteredTypes = filter(types, \type -> {
								exists(events, \e -> (
									isDateBetween(time2date(e.startDate), date, addDaysToDate(date, 6)) ||
									isDateBetween(date, time2date(e.startDate), time2date(e.endDate))
								) && e.eventType == type.name);
							});
							nextDistinct(eventTypesForPrintingB, filteredTypes);
						}),
						\ -> eitherMap(externalDateM, \externalDate -> {
							externalDateB = externalDate.currentDateB;
							fBidirectionalLink(currentDate, externalDateB,
								\curDate -> nextDistinct(externalDateB, curDate),
								\extDate -> updateCurrentDate(getStartOfWeek(extDate))
							);
						}, nop)
					],
					MLines2A(TabMenu(menuItems), TabBody(MSelect(contentB, \content -> content.main)))
				);
			}

			DayTab(): {
				updateCurrentDate(getCurrentDate());
				tabMenuTextM = MSelect(currentDate, \date -> {
					defaultText = date2formatString(date, "%MMMM %DD, %YYYY");
					drawCalendarTabMenuText(date, defaultText);
				});

				contentB = fselect3(currentDate, filteredEvents, currentEventTypes, \date, events, types -> {
					dayEvents = filter(events, \event -> date >= time2date(event.startDate) && date <= time2date(event.endDate));
					dayEventTypes = filter(types, \type -> exists(dayEvents, \event -> event.eventType == type.name));
					addEvent = \ -> dayEventsPopup(date, dayEvents, currentEventTypes, manager, getValue(choosedFilters), 0, false, styles);
					nextDistinct(eventTypesForPrintingB, dayEventTypes);
					getCalendarDayView(date, dayEvents, dayEventTypes, getPrimaryColor(manager), addEvent, isPrintingB, styles);
				});

				getPrintPages = \availableSize -> fgetValue(contentB).getPrintPages(availableSize);

				buttons = buildActionButtons(
					getCurrentDate(),
					getPrintButton(addHeaderBorder(tabMenuTextM), getPrintPages),
					Pair(
						MIconButton(
							"keyboard_arrow_left",
							\ -> updateCurrentDate(addDaysToDate(getValue(currentDate), -1)),
							subMenuIconStyle,
							[]
						),
						MEmpty()
					),
					Pair(
						MIconButton(
							"keyboard_arrow_right",
							\ -> updateCurrentDate(addDaysToDate(getValue(currentDate), 1)),
							subMenuIconStyle,
							[]
						),
						MEmpty()
					)
				);

				menuItems = eitherFn(
					dayCustomTabM,
					\dayCustomTab -> dayCustomTab.getMenuView(currentDate, buttons),
					\-> unpair(getAdditionalButtons(buttons), \leftButtons, rightButtons ->
						TabMenu(concatA([
							if (menuTightWidth) leftButtons else [],
							[buttons.prevPeriodButtons.first,],
							if (!menuTightWidth) leftButtons else [],
							[tabMenuTextM],
							if (!menuTightWidth) rightButtons else [],
							[buttons.nextPeriodButtons.first,],
							if (menuTightWidth) rightButtons else []
						]))
					)
				);

				MConstruct([
						\ -> eitherMap(externalDateM, \externalDate -> {
							externalDateB = externalDate.currentDateB;
							fBidirectionalLink(currentDate, externalDateB,
								\curDate -> nextDistinct(externalDateB, curDate),
								\extDate -> updateCurrentDate(extDate)
							);
						}, nop)
					],
					MLines2A(menuItems, TabBody(MSelect(contentB, \content -> content.main)))
				);
			}
		}

		MSwipe(
			tabContent,
			[
				MOnSwipeLeft(\point, delta -> {
					if (!getValue(isSwipePaused) && delta.x < -20. && getValue(choosedTab) != 0) {
						next(choosedTab, getValue(choosedTab) - 1);
						pauseSwipe();
					}
					true;
				}),
				MOnSwipeRight(\point, delta -> {
					if (!getValue(isSwipePaused) && delta.x > 20. && getValue(choosedTab) != length(tabOrder) - 1) {
						next(choosedTab, getValue(choosedTab) + 1);
						pauseSwipe();
					}
					true;
				})
			]
		)
	}

	MConstruct(
		[
			makeSubscribe(allEvents, \events -> {
				filters = getValue(choosedFilters);
				nextDistinct(filteredEvents, filter(events, \item -> !contains(filters, item.eventType)));
			}),
			makeSubscribe2(choosedFilters, \cf -> {
				nextDistinct(filteredEvents, filter(getValue(allEvents), \item -> !contains(cf, item.eventType)));
			})
		],
		MGroup([
			MLinesA([
				if (hideTabs || isTabsDropdown) MEmpty() else tabTitles,
				MBorderA(16., 0., 16., 0.,
					MSelect(choosedTab, \tabNumber -> TabContent(elementAt(tabOrder, tabNumber, YearTab())))
				)
			]),
			if (hideAddEventButton) MEmpty()
			else MShow(fnot(isReadOnlyB), MLines2A(
				TFillY(),
				MCols2A(
					TFillX(),
					MFloatingButton("add",
						[MBlack()],
						[MOnClick(\-> {
							today = stamp2date(timestamp());
							todayEvents = filter(getValue(filteredEvents), \item -> time2date(item.startDate) == today);
							dayEventsPopup(today, todayEvents, currentEventTypes, manager, getValue(choosedFilters), 0, false, styles);
						})]
					)
				)
			))
		])
	)
}

getPrintCalendarIconButton(
	manager : MaterialManager,
	headerM : Material,
	footerM : Material,
	getPrintPages : (WidthHeight) -> [Material],
	isPrintingB : DynamicBehaviour<bool>,
	style : [MIconButtonStyle]
) -> Material {
	showDialog = \ -> {
		closeB = make(false);
		pageSizeB = make(4);
		pageOrientationB = make(1);
		widthS = make("21.0");
		heightS = make("29.7");

		pagesB = make([]);

		headerHeightB = make(0.0);
		footerHeightB = make(0.0);

		printAvailableWidthB = fselect(TPrintPageSize, FLift(\s -> either(s, WidthHeight(0.0, 0.0)).width));

		onPrint = \ -> {
			maybeApply(getValue(TPrintPageSize), \size -> {
				headerHeight = getValue(headerHeightB);
				footerHeight = getValue(footerHeightB);
				availableSize = WidthHeight(size.width, size.height - headerHeight - footerHeight);
				pages = mapi(getPrintPages(availableSize), \i, p -> {
					MIfPrint(MLinesA([headerM, p, footerM]), MEmpty());
				});
				nextDistinct(pagesB, pages);
				showPrintDialog();
			});
		}

		isCustomSize = \s -> s >= length(MPrintPaperSizes) - 1 || s < 0;
		isCustomSizeB = fselect(pageSizeB, FLift(isCustomSize));

		dialogViewM = MConstruct([
				\ -> addEventListener(getStage(), "beforeprint", \ -> nextDistinct(isPrintingB, true)),
				\ -> addEventListener(getStage(), "afterprint", \ -> nextDistinct(isPrintingB, false)),
				make2SubscribeUns(pageSizeB, pageOrientationB, \s, o -> {
					if (isCustomSize(s)) {
						[
							makeSubscribe(fwh(fselect(widthS, FLift(\w -> cm2pixels(s2d(w)))), fselect(heightS, FLift(\h -> cm2pixels(s2d(h))))), \v -> {
								nextDistinct(TPrintPageSize, Some(v))
							})()
						]
					} else {
						size = MPrintPaperSizes[s].second;
						nextDistinct(TPrintPageSize, Some(if (o == 0) size else WidthHeight(size.height, size.width)));
						[];
					}
				}),
				\ -> \ -> nextDistinct(TPrintPageSize, None())
			],
			MAvailableWidth(MGroup2(
				MFixSize(
					MVisible(make(false),
						MAvailableWidth(
							MGroup2(MAttachHeight(headerM, headerHeightB), MAttachHeight(footerM, footerHeightB)),
							printAvailableWidthB
						)
					),
					MEmpty()
				),
				MLines([
					MDropDown(pageSizeB, "", map(MPrintPaperSizes, firstOfPair), [MLabel(_("Page Size:")), MWidth(-1.0)]) |> MBorderBottom(12.0),
					MShowAnimationHeight(
						isCustomSizeB,
						MCenterX(MBaselineCols([
							MTextInput(widthS, [MWidth(64.0)], []),
							MText(_("cm"), []),
							MIcon("close", []) |> (\f -> MBorder4(12.0, f)),
							MTextInput(heightS, [MWidth(64.0)], []),
							MText(_("cm"), [])
						])),
						[MAutoStart()]
					),
					MShowAnimationHeight(
						fnot(isCustomSizeB),
						MDropDown(pageOrientationB, "", [_("Portrait"), _("Landscape")], [MLabel(_("Orientation:")), MWidth(-1.0)]),
						[MAutoStart()]
					),
					MFixSize(MPrintPages(pagesB), MEmpty())
				])
			), const(260.0))
		);

		dialogStyle = [
			MDialogUseFrame(),
			MDialogClickOutToClose(),
			MDialogTitle(_("Print Dialog")),
			MDialogActions([
				MTextButton(_("CLOSE"), \ -> next(closeB, true), [], []),
				MTextButton(_("PREVIEW"), onPrint, [], []),
			])
		];

		ShowMDialog(manager, closeB, dialogStyle, dialogViewM);
	}
	
	MIconButton("print", showDialog, style, [MTooltipText(const(_("Print")))]);
}
