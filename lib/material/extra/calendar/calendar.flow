import material/material_dialog;
import material/material_ui;
import excel_datetime;
import text/translation;

export {
	CalendarForEvents(
		allEvents : DynamicBehaviour<[CalendarEvent]>,
		currentEventTypes : DynamicBehaviour<[CalendarEventDecription]>,
		manager : MaterialManager,
		dateMin : Date,
		dateMax : Date,
		monthNumber : int,
		displayedEventsInOneDay : int,
		onlyOneSameTypeEventsByDay : bool,
		colorizeDayHeaders : bool,
		styles : [CalendarForEventsStyle]) -> Material;

	CalendarEventDecription(
		name : string,
		mainColor : MColor,
		backColor : MColor,
		icon : string,
		editAction : (id : int) -> void,
		addAction : (fullDate : Time) -> void,
		deleteAction : (id : int) -> void,
		additionalActions : [CalendarAdditionalAction]
	);

	CalendarEvent(
		startDate : Time,
		endDate : Time,
		id : int,
		eventType : string,
		title : string,
		description : string,
		additionalFields : Tree<string, string>
	);

	CalendarAdditionalAction(
		icon : string,
		name : string,
		action : (id : int) -> void
	);

	CalendarDefaultDisplayedEventsInOneDay = 3;

	CalendarForEventsStyle ::= ShowMonthViewSwitchMenu, DefaultMonthView, TabOrder, DefaultTab, TabColors, HideAddEventButton,
		CloseDayPopupAfterAdditionalAction, EventListSettings, PlannedTableDateFormat, BlackAndWhiteTextColor, HideTimeInfo, HiddenEventTypes,
		ShowWeekViewDaysNames, CalendarTabMenuStyle, CalendarTabMenuText, CalendarTodayColors, CalendarWeekendsColor, CalendarDefaultEventToAdd,
		CalendarHideEventTypesLegend, CalendarCurrentDate, CalendarShowTodayButton, CalendarMenuTightWidth, CalendarMenuAddEventButton,
		CalendarReadOnly, CalendarCustomEventView, CalendarPrintable, CalendarTabsDropdown;

		ShowMonthViewSwitchMenu();
		DefaultMonthView(byWeek : bool);
		TabOrder(tabs : [CalendarTab]);
		DefaultTab(tab : CalendarTab);
		TabColors(activeTabColor : MColor, nonActiveTabColor : MColor);
		HideAddEventButton();
		// It is possible to assign task for date only.
		HideTimeInfo();
		CloseDayPopupAfterAdditionalAction();
		// settings for dayEventsPopup, cols can be for text - "event type", "event description", "event title",
		// and for date and time - "start", "end"
		EventListSettings(cols : [string], showDate : bool, showTime : bool);
		//"%D" to date.day, "%M" to date.month, "%YYYY" to date.year, "%YY" to last two number of date.year
		//(like date2formatString)
		PlannedTableDateFormat(tableDateFormat : string);
		//autochoose text color - between black and white
		BlackAndWhiteTextColor();
		// Hide event types by default
		HiddenEventTypes(types : [string]);
		// Show days names in week view
		ShowWeekViewDaysNames();
		CalendarTabMenuStyle(text : [MTextStyle], icon : [MIconStyle], background : [TGraphicsStyle]);
		CalendarTabMenuText(getText : (date : Date, tab : CalendarTab) -> Maybe<string>);
		CalendarTodayColors(text : MColor, background : MColor);
		CalendarWeekendsColor(color : MColor);
		// Instead of dayEventsPopup show add event dialog for event type
		CalendarDefaultEventToAdd(getEventType : () -> string);
		CalendarHideEventTypesLegend();
		// Allows to get or set current date
		CalendarCurrentDate(currentDateB : DynamicBehaviour<Date>);
		CalendarShowTodayButton();
		CalendarMenuTightWidth();
		CalendarMenuAddEventButton(style : [MIconButtonStyle]);
		CalendarReadOnly(isReadOnlyB : Transform<bool>);
		// Show custom event view instead of default. If None - default view is displayed.
		// getView parameters:
		// CalendarTab - tab in which material is displayed
		// CalendarEvent - current event
		// CalendarEventDecription - current event type
		// Date - date of first event cell displayed
		// int - number of cells (dates) in which event is displayed
		CalendarCustomEventView(getView : (CalendarTab, CalendarEvent, CalendarEventDecription, Date, int) -> Maybe<Material>);
		CalendarPrintable(style : [MIconButtonStyle]);
		// Show dropdown with views instead of tabs
		CalendarTabsDropdown();

	CalendarTab ::= YearTab, MonthTab, PlannedTab, RangeTab, WeekTab;
		YearTab(); MonthTab(); PlannedTab(); RangeTab(); WeekTab();
}

CalendarTabView(
	main : Material,
	getPrintPages : (availableSize : WidthHeight) -> [Material]
);

emptyEvent = CalendarEvent(Time(2050, 1, 1, 1, 1, 1), Time(2050, 1, 1, 1, 1, 1), 999, "_EMPTY_", "", "", makeTree());

calendarDateCellW = 32.0;
calendarDateCellH = 30.0;
calendarDateNavSize = 40.0;

calendarPickerWidthCells = calendarDateCellW * 7.0;
calendarPickerMarginCells = 12.0;
calendarMpickerWidth = calendarPickerWidthCells + calendarPickerMarginCells * 2.0;
maxDisplayedEventsInOneDay = ref 3;
isOnlyOneSameTypeEventsByDay = ref true;
isColorizeDayHeaders = ref true;
defaultCalendarTabMenuStyle = CalendarTabMenuStyle([MWhite(), MCustomFont(20.0, "RobotoMedium", primarySmallTextOpacity)], [MIconSize(30.0), MCustomColor(0xFDB22B)], [Fill(black)]);

isDateEnable(
	thisDate : Date,
	dateMin : Date,
	dateMax : Date) -> bool {

	compareDates(thisDate, dateMin) != DateBefore()
	&& compareDates(thisDate, dateMax) != DateAfter()
}

timeYearCheck(start : int, end : int, year : int) -> bool {
	(start <= year && year <= end)
}

timeMonthCheck(start : Time, end : Time, current : Date) -> bool {
	if (start.year == end.year)
		(start.month <= current.month && current.month <= end.month)
	else if (current.year < end.year)
		if (current.year == start.year)
			(current.month >= start.month)
		else
			true
	else
		(current.month <= end.month)
}

timeDayCheck(start : Time, end : Time, current : Date, dayNumber : int) -> bool {
	if (start.month == end.month && start.year == end.year) //event in one month
		(start.day <= dayNumber && dayNumber <= end.day)
	else if (current.year < end.year) {     //event in two or more years
		if (current.year > start.year)      //in each year between start and end we need ALL days
			true
		else if (current.month > start.month) //in first year we need ALL days after first month
			true
		else                                //in first month we need ONLY days after start
			(dayNumber >= start.day)
	} else if (start.year != end.year) {    //in last year
		if (current.month < end.month)      //we need ALL days before end month
			true
		else
			(dayNumber <= end.day)          //in last month we need ALL days before last day
	} else if (current.month < end.month) {
		if (current.month == start.month)   //in start month we need ONLY days after start
		   (dayNumber >= start.day)
		else                                //in other we need ALL days
			true
	} else {                                //in last month we need ONLY days before end
		(dayNumber <= end.day)
	}
}

getMultiDayEvents(events : [CalendarEvent]) -> [CalendarEvent] {
	filter(events, \event -> time2date(event.startDate) != time2date(event.endDate))
}

sortEvents(events : [CalendarEvent]) -> [CalendarEvent] {
	timeSort = \event : CalendarEvent -> event.startDate;
	//Multi-day events should be earlier than usual, even if they go later.
	//Otherwise, the union between days will not work
	concat(
		sortCustom(getMultiDayEvents(events), timeSort, true),
		sortCustom(filter(events, \event -> time2date(event.startDate) == time2date(event.endDate)), timeSort, true)
	)
}

makeCalendarEventDescription() -> CalendarEventDecription {
	CalendarEventDecription("", MBlack(), MWhite(), "", nop1, nop1, nop1, [])
}

getEventTitle(event : CalendarEvent) -> string {
	if (event.title != "") event.title else if (event.description != "") event.description else event.eventType
}

isTooltipEnabled(event : CalendarEvent) -> bool {
	event.description != "" && event.title != ""
}

//like in DatePicker
CalendarCells(
	manager : MaterialManager,
	color : MThemeColor,
	month : Date,
	currentDate : DynamicBehaviour<Date>,
	dateMin : Date,
	dateMax : Date,
	isPrintingB : DynamicBehaviour<bool>,
	monthEvents : [CalendarEvent],
	monthNumber : DynamicBehaviour<int>,
	openPopupForDay : (date : Date, dayEvents : [CalendarEvent]) -> void,
	currentEventTypes : DynamicBehaviour<[CalendarEventDecription]>,
	isReadOnlyB : Transform<bool>
) -> Material {
	firstDayInWeekOffset = 8 - ((1 + dayOfWeek(month)) % 7);
	dayOfWeekNames = map(enumFromTo(0, 6), \i -> {
		strLeft(dayOfWeekString(addDaysToDate(month, firstDayInWeekOffset + i), true), 1);
	});

	maxDayInMonth = 31;
	filteredByDay = generate(1, maxDayInMonth + 1, \dayNumber -> {
		allEvents = filter(monthEvents, \item -> timeDayCheck(item.startDate, item.endDate, month, dayNumber));
		sortEvents(allEvents)
	});

	startOffset = dayOfWeek(month) % 7;
	daysNum = getNumberOfDaysPerMonthInTheYear(month.year)[month.month];
	invisible = Point(0.0, calendarDateCellH * 6.0);
	offsets = generate(0, maxDayInMonth, \i -> {
		linearOffset = startOffset + i;
		if (i >= daysNum) invisible
		else Point(calendarDateCellW * i2d(linearOffset % 7), calendarDateCellH * i2d(linearOffset / 7))
	});

	todayDate = getCurrentDate();
	MLinesA([
		MCenterIn(
			MText(monthString(month, true), []),
			MFixed(calendarDateCellW * 7.0, calendarDateNavSize)
		),
		MColsA(map(dayOfWeekNames, \wday -> {
			MCenterIn(
				MText(wday, [MCaption()]),
				MFixed(calendarDateCellW, calendarDateCellH)
			)
		})),
		MGroup(mapi(offsets, \i, offset -> {
			MTranslate(
				const(offset),
				CalendarCell(manager, color, month, i + 1, currentDate, dateMin,
					dateMax, todayDate, isPrintingB, filteredByDay[i], monthNumber,
					openPopupForDay, currentEventTypes, isReadOnlyB
				)
			)
		}))
	]);
}

//like in DatePicker
CalendarCell(
	manager : MaterialManager,
	color : MThemeColor,
	thisMonth : Date,
	day : int,
	currentDate : DynamicBehaviour<Date>,
	dateMin : Date,
	dateMax : Date,
	todayDate : Date,
	isPrintingB : DynamicBehaviour<bool>,
	dayEvents : [CalendarEvent],
	monthNumber : DynamicBehaviour<int>,
	openPopupForDay : (date : Date, dayEvents : [CalendarEvent]) -> void,
	eventTypes : DynamicBehaviour<[CalendarEventDecription]>,
	isReadOnlyB : Transform<bool>
) -> Material {
	thisDate = Date(getValue(currentDate).year, thisMonth.month, day);
	isEnabled = isDateEnable(thisDate, dateMin, dateMax);
	isHoverB = make(false);

	textColorB = if (isEnabled) {
		fselect2(isHoverB, isPrintingB, FLift2(\isHover, isPrinting -> {
			if (isHover || (thisDate == todayDate && !isPrinting)) MWhite() else MBlack();
		}));
	} else {
		const(MGrey(500));
	}

	diam = 30.0;
	radius = diam / 2.0;
	bhoriz = if (day < 10) 11.0 else 7.5;
	text = MBorder(bhoriz + 0.5, 7.8, bhoriz - 0.5, 7.8,
		MGroup2(
			MGetFocusGroup(\parent -> TSelectConstantMetrics(textColorB, \col ->
				MText2T(parent, i2s(day), [MCaptionSolid(), col])
			)),
			MFixed(if (day < 10) 8.0 else 15.0, 14.4)
		)
	);

	multiStart = \fillColor -> {
		TGroup([
			TColsA([
				TFixed(radius, 0.),
				TRectangle([MFill(fillColor), FillOpacity(1.0)], TFixed(radius + 2.0, diam)),
			]),
			LongSegment(radius, radius, radius, 180., 360., [MFill(fillColor)]) |> TForm
		])
	}

	multiStartWithStart = \mainColor, secondColor -> {
		TGroup([
			TColsA([
				TFixed(radius, 0.),
				TRectangle([MFill(mainColor), FillOpacity(1.0)], TFixed(radius + 2.0, diam)),
			]),
			TGroup([
				Sector2(radius, radius, radius, 180., 360., [MFill(secondColor)]) |> TForm,
				Sector2(radius, radius, radius - 2., 180., 360., [MFill(mainColor)]) |> TForm
			])
		])
	}

	multiMiddle = \fillColor -> {
		TRectangle([MFill(fillColor), FillOpacity(1.0)], TFixed(diam + 2., diam))
	}

	multiMiddleWithStart = \mainColor, secondColor -> {
		TGroup([
			TRectangle([MFill(mainColor), FillOpacity(1.0)], TFixed(diam + 2., diam)),
			TGroup2(
				Sector2(radius, radius, radius, 180., 360., [MFill(secondColor)]) |> TForm,
				Sector2(radius, radius, radius - 2., 180., 360., [MFill(mainColor)]) |> TForm
			)
		])
	}

	multiMiddleWithEnd = \mainColor, secondColor -> {
		TGroup([
			TRectangle([MFill(mainColor), FillOpacity(1.0)], TFixed(diam + 2., diam)),
			TGroup2(
				Sector2(radius, radius, radius, 0., 180., [MFill(secondColor)]) |> TForm,
				Sector2(radius, radius, radius - 2., 0., 180., [MFill(mainColor)]) |> TForm
			)
		])
	}

	multiMiddleWithStartAndEnd = \mainColor, startColor, endColor -> {
		TGroup([
			TRectangle([MFill(mainColor), FillOpacity(1.0)], TFixed(diam + 2., diam)),
			TGroup2(
				Sector2(radius, radius, radius, 180., 360., [MFill(startColor)]) |> TForm,
				Sector2(radius, radius, radius - 2., 180., 360., [MFill(mainColor)]) |> TForm
			),
			TGroup2(
				Sector2(radius, radius, radius, 0., 180., [MFill(endColor)]) |> TForm,
				Sector2(radius, radius, radius - 2., 0., 180., [MFill(mainColor)]) |> TForm
			)
		])
	}

	multiEnd = \fillColor -> {
		TGroup([
			TRectangle([MFill(fillColor), FillOpacity(1.0)], TFixed(radius, diam)),
			LongSegment(radius, radius, radius, 0., 180., [MFill(fillColor)]) |> TForm
		])
	}

	multiEndWithEnd = \mainColor, secondColor -> {
		TGroup([
			TRectangle([MFill(mainColor), FillOpacity(1.0)], TFixed(radius, diam)),
			TGroup([
				Sector2(radius, radius, radius, 0., 180., [MFill(secondColor)]) |> TForm,
				Sector2(radius, radius, radius - 2., 0., 180., [MFill(mainColor)]) |> TForm
			])
		])
	}

	multiEndWithStart = \mainColor, secondColor -> {
		TGroup([
			TColsA([
				TFixed(radius, 0.),
				TRectangle([MFill(secondColor), FillOpacity(1.0)], TFixed(radius + 2.0, diam)),
			]),
			TRectangle([MFill(mainColor), FillOpacity(1.0)], TFixed(radius, diam)),
			TGroup([
				Sector2(radius, radius, radius, 0., 180., [MFill(mainColor)]) |> TForm,
				Sector2(radius, radius, radius, 180., 360., [MFill(secondColor)]) |> TForm,
				Sector2(radius, radius, radius - 2., 180., 360., [MFill(mainColor)]) |> TForm
			])
		])
	}

	multiEndWithStartAndEnd = \mainColor, startColor, endColor -> {
		TGroup([
			TCols([
				TFixed(radius, 0.),
				TRectangle([MFill(startColor), FillOpacity(1.0)], TFixed(radius + 2.0, diam)),
			]),
			TRectangle([MFill(mainColor), FillOpacity(1.0)], TFixed(radius, diam)),
			TGroup([
				Sector2(radius, radius, radius, 0., 180., [MFill(endColor)]) |> TForm,
				Sector2(radius, radius, radius - 2., 0., 180., [MFill(mainColor)]) |> TForm,
				Sector2(radius, radius, radius, 180., 360., [MFill(startColor)]) |> TForm,
				Sector2(radius, radius, radius - 2., 180., 360., [MFill(mainColor)]) |> TForm
			])
		])
	}

	multiEndWithMiddleAndEnd = \mainColor, middleColor, endColor -> {
		TGroup([
			TColsA([
				TFixed(radius, 0.),
				TRectangle([MFill(middleColor), FillOpacity(1.0)], TFixed(radius + 2.0, diam)),
			]),
			TRectangle([MFill(mainColor), FillOpacity(1.0)], TFixed(radius, diam)),
			TGroup([
				Sector2(radius, radius, radius, 0., 180., [MFill(endColor)]) |> TForm,
				Sector2(radius, radius, radius - 2., 0., 180., [MFill(mainColor)]) |> TForm
			])
		])
	}

	multiEndWithMiddleAndStart = \mainColor, middleColor, startColor -> {
		TGroup([
			TColsA([
				TFixed(radius, 0.),
				TRectangle([MFill(middleColor), FillOpacity(1.0)], TFixed(radius + 2.0, diam)),
			]),
			TRectangle([MFill(mainColor), FillOpacity(1.0)], TFixed(radius, diam)),
			TGroup([
				Sector2(radius, radius, radius, 0., 180., [MFill(mainColor)]) |> TForm,
				Sector2(radius, radius, radius, 180., 360., [MFill(startColor)]) |> TForm,
				Sector2(radius, radius, radius - 2., 180., 360., [MFill(mainColor)]) |> TForm
			])
		])
	}

	multiEndWithMiddle = \mainColor, secondColor -> {
		TGroup([
			TColsA([
				TFixed(radius, 0.),
				TRectangle([MFill(secondColor), FillOpacity(1.0)], TFixed(radius + 2.0, diam)),
			]),
			TRectangle([MFill(mainColor), FillOpacity(1.0)], TFixed(radius, diam)),
			LongSegment(radius, radius, radius, 0., 180., [MFill(mainColor)]) |> TForm
		])
	}

	plusEventsBar = \number -> {
		MGroup([
			MColsA([
				MFixed(radius + 1.5, 0.),
				MGroup([
					Sector2(1.0, diam / 8.0 + 2., diam / 8.0 + 1.5, 0., 360., [Fill(black)]) |> TForm,
					MColsA([
						MFixed(diam / 16.0, 0.),
						TRectangle([Fill(black), FillOpacity(1.0)], TFixed(diam / 4.0, diam / 4.0 + 3.2)),
					]),
					MColsA([
						MFixed(diam / 16.0 + diam / 4.0, 0.),
						Sector2(0.0, diam / 8.0 + 2., diam / 8.0 + 1.5, 0., 360., [Fill(black)]) |> TForm,
					]),
					MCenterIn(
						MText("+" + i2s(number), [MWhite(), MCustomFont(9., "Roboto", primarySmallTextOpacity)]),
						MFixed(radius - 5., 0.0)
					)
				])
			]),
		])
	}

	eventsCheck = \currentEventTypes -> {
		multiDayEvents = getMultiDayEvents(dayEvents);
		getEventTypeBackColor = \event -> {
			eitherMap(
				find(currentEventTypes, \type -> type.name == event.eventType),
				\type -> type.backColor,
				MGrey(300)
			);
		}

		if (length(multiDayEvents) > 0) {
			//events that started on this day
			startEvents : [CalendarEvent] = filter(multiDayEvents, \item -> time2date(item.startDate) == thisDate);

			//events that goes on this day
			middleEvents : [CalendarEvent] = filter(multiDayEvents, \item -> time2date(item.startDate) < thisDate && thisDate < time2date(item.endDate));

			//events that ended on this day
			endEvents : [CalendarEvent] = filter(multiDayEvents, \item -> time2date(item.endDate) == thisDate);

			firstEvent = multiDayEvents[0];
			//Depending on what event happens before we have 11 possible situations to display.
			//From simple "beginning", "middle", "end", then more complex combinations
			if (contains(startEvents, firstEvent)) {
				if (length(startEvents) >= 2) {
					firstColor = getEventTypeBackColor(firstEvent);
					secondColor = getEventTypeBackColor(startEvents[1]);

					MGroup2(
						multiStartWithStart(firstColor, secondColor),
						if (length(dayEvents) > 2) plusEventsBar(length(dayEvents) - 2) else TEmpty()
					);
				} else {
					firstColor = getEventTypeBackColor(firstEvent);
					MGroup2(
						multiStart(firstColor),
						if (length(dayEvents) > 1) plusEventsBar(length(dayEvents) - 1) else TEmpty()
					);
				}
			} else if (contains(middleEvents, firstEvent)) {
				firstColor = getEventTypeBackColor(firstEvent);

				if (length(dayEvents) >= 3) {
					secondColor = getEventTypeBackColor(dayEvents[1]);
					thirdColor = getEventTypeBackColor(dayEvents[2]);

					if (contains(endEvents, dayEvents[1]) && contains(startEvents, dayEvents[2])) {
						MGroup2(
							multiMiddleWithStartAndEnd(firstColor, thirdColor, secondColor),
							if (length(dayEvents) > 3) plusEventsBar(length(dayEvents) - 3) else TEmpty()
						)

					} else if (contains(startEvents, dayEvents[1])) {
						MGroup2(
							multiMiddleWithStart(firstColor, secondColor),
							if (length(dayEvents) > 2) plusEventsBar(length(dayEvents) - 2) else TEmpty()
						)

					} else if (contains(endEvents, dayEvents[1])) {
						MGroup2(
							multiMiddleWithEnd(firstColor, secondColor),
							if (length(dayEvents) > 2) plusEventsBar(length(dayEvents) - 2) else TEmpty()
						)

					} else {
						MGroup2(
							multiMiddle(firstColor),
							if (length(dayEvents) > 1) plusEventsBar(length(dayEvents) - 1) else TEmpty()
						)
					}

				} else if (length(dayEvents) >= 2) {
					secondColor = getEventTypeBackColor(dayEvents[1]);
					if (contains(startEvents, dayEvents[1])) {
						MGroup2(
							multiMiddleWithStart(firstColor, secondColor),
							if (length(dayEvents) > 2) plusEventsBar(length(dayEvents) - 2) else TEmpty()
						)

					} else if (contains(endEvents, dayEvents[1])) {
						MGroup2(
							multiMiddleWithEnd(firstColor, secondColor),
							if (length(dayEvents) > 2) plusEventsBar(length(dayEvents) - 2) else TEmpty()
						)

					} else {
						MGroup2(
							multiMiddle(firstColor),
							if (length(dayEvents) > 1) plusEventsBar(length(dayEvents) - 1) else TEmpty()
						)
					}

				} else {
					MGroup2(
						multiMiddle(firstColor),
						if (length(dayEvents) > 1) plusEventsBar(length(dayEvents) - 1) else TEmpty()
					)
				}
			} else {
				firstColor = getEventTypeBackColor(firstEvent);

				if (length(dayEvents) >= 3) {
					secondColor = getEventTypeBackColor(dayEvents[1]);
					thirdColor = getEventTypeBackColor(dayEvents[2]);

					if (contains(endEvents, dayEvents[1]) && contains(startEvents, dayEvents[2])) {
						MGroup2(
							multiEndWithStartAndEnd(firstColor, thirdColor, secondColor),
							if (length(dayEvents) > 3) plusEventsBar(length(dayEvents) - 3) else TEmpty()
						)

					} else if (contains(middleEvents, dayEvents[1]) && contains(endEvents, dayEvents[2])) {
						MGroup2(
							multiEndWithMiddleAndEnd(firstColor, secondColor, thirdColor),
							if (length(dayEvents) > 3) plusEventsBar(length(dayEvents) - 3) else TEmpty()
						)

					} else if (contains(middleEvents, dayEvents[2]) && contains(endEvents, dayEvents[1])) {
						MGroup2(
							multiEndWithMiddleAndEnd(firstColor, thirdColor, secondColor),
							if (length(dayEvents) > 3) plusEventsBar(length(dayEvents) - 3) else TEmpty()
						)

					} else if (length(middleEvents) > 0 && contains(endEvents, dayEvents[1])) {
						fourthColor = getEventTypeBackColor(middleEvents[0]);
						MGroup2(
							multiEndWithMiddleAndEnd(firstColor, fourthColor, secondColor),
							if (length(dayEvents) > 3) plusEventsBar(length(dayEvents) - 3) else TEmpty()
						)

					} else if (contains(middleEvents, dayEvents[1]) && contains(startEvents, dayEvents[2])) {
						MGroup2(
							multiEndWithMiddleAndStart(firstColor, secondColor, thirdColor),
							if (length(dayEvents) > 3) plusEventsBar(length(dayEvents) - 3) else TEmpty()
						)

					} else if (contains(startEvents, dayEvents[1])) {
						MGroup2(
							multiEndWithStart(firstColor, secondColor),
							if (length(dayEvents) > 2) plusEventsBar(length(dayEvents) - 2) else TEmpty()
						)

					} else if (contains(endEvents, dayEvents[1])) {
						MGroup2(
							multiEndWithEnd(firstColor, secondColor),
							if (length(dayEvents) > 2) plusEventsBar(length(dayEvents) - 2) else TEmpty()
						)

					} else if (contains(middleEvents, dayEvents[1])) {
						MGroup2(
							multiEndWithMiddle(firstColor, secondColor),
							if (length(dayEvents) > 2) plusEventsBar(length(dayEvents) - 2) else TEmpty()
						)
					} else if (length(middleEvents) > 0) {
						fourthColor = getEventTypeBackColor(middleEvents[0]);
						MGroup2(
							multiEndWithMiddle(firstColor, fourthColor),
							if (length(dayEvents) > 2) plusEventsBar(length(dayEvents) - 2) else TEmpty()
						)
					} else {
						MGroup2(
							multiEnd(firstColor),
							if (length(dayEvents) > 1) plusEventsBar(length(dayEvents) - 1) else TEmpty()
						)
					}

				} else if (length(dayEvents) >= 2) {
					secondColor = getEventTypeBackColor(dayEvents[1]);

					if (contains(startEvents, dayEvents[1])) {
						MGroup2(
							multiEndWithStart(firstColor, secondColor),
							if (length(dayEvents) > 3) plusEventsBar(length(dayEvents) - 3) else TEmpty()
						)
					} else if (contains(endEvents, dayEvents[1])) {
						MGroup2(
							multiEndWithEnd(firstColor, secondColor),
							if (length(dayEvents) > 2) plusEventsBar(length(dayEvents) - 2) else TEmpty()
						)
					} else if (contains(middleEvents, dayEvents[1])) {
						MGroup2(
							multiEndWithMiddle(firstColor, secondColor),
							if (length(dayEvents) > 2) plusEventsBar(length(dayEvents) - 2) else TEmpty()
						)
					} else {
						MGroup2(
							multiEnd(firstColor),
							if (length(dayEvents) > 1) plusEventsBar(length(dayEvents) - 1) else TEmpty()
						)
					}

				} else {
					MGroup2(
						multiEnd(firstColor),
						if (length(dayEvents) > 1) plusEventsBar(length(dayEvents) - 1) else TEmpty()
					)
				}
			}
		} else {
			backColor = getEventTypeBackColor(dayEvents[0]);
			MGroup2(
				TCircle(radius, [MFill(backColor)]),
				if (length(dayEvents) > 1) plusEventsBar(length(dayEvents) - 1) else TEmpty()
			)
		}
	}

	bubble = MGroup2(
		if (length(dayEvents) > 0) {
			MSelect(eventTypes, \types -> eventsCheck(types));
		} else if (todayDate != thisDate) {
			MEmpty()
		} else {
			MShow(fnot(isPrintingB), MCircle(radius, [MThemeFill(manager, color)]))
		},
		text
	);

	bubbleAnimated = if (manager.theme.enableAnimations) {
		MCopySize(
			bubble,
			\m -> MGetFocusGroup(\parent -> MRipple2T(manager, parent, m, isHoverB, [MRippleColor(const(color)), MRippleType(const(MRippleCenter()))])),
			false
		);
	} else {
		MGroup2(
			MVisible(isHoverB, MCircle(radius, [MThemeFill(manager, color), FillOpacity(0.5)])),
			bubble
		);
	}

	click2 = \-> if (isEnabled) {
		nextDistinct(monthNumber, thisMonth.month);
		nextDistinct(currentDate, thisDate);
		openPopupForDay(thisDate, dayEvents);
	} else {
		println("this day not available!");
	}

	bubbleClickable = MGroup2(
		MComponent(
			[MOnClick(click2), MEnabled(fnot(isReadOnlyB)), THovering(isHoverB)],
			\__ -> MFrame(0.0, 0.0, [Fill(green), FillOpacity(0.0)], bubbleAnimated)
		),
		TCursor(FingerCursor(), TRectangle([Fill(white), FillOpacity(0.0)], TFixed(calendarDateCellW, calendarDateCellH)))
	);

	MSize(
		MFixed(calendarDateCellW, calendarDateCellH),
		if (isEnabled) bubbleClickable else text
	);
}

//Small popup to confirm deletion
eventDeletePopup(
	cancelAction : () -> void,
	okAction : () -> void
	) -> Material {

	//fontsSizes
	littleFontSize = MBody();
	mediumFontSize = MSubheading();
	bigBoldFontSize = MCustomFont(20., "RobotoMedium", primaryTextOpacity);
	buttonFontSize = bigBoldFontSize;
	//colors
	veryLightGrey = MGrey(50);
	lightGrey = MGrey(200);
	mediumGrey = MGrey(600);
	notSoDarkGrey = MGrey(700);
	darkGrey = MGrey(800);

	title = MCols([
		TFixed(25., 0.),
		MCenterIn(
			MText(_("Are you sure?"), [bigBoldFontSize]),
			TFixed(330., 80.)
		),
		TFixed(25., 0.),
	]);

	footer = MCols([
		TFixed(25., 0.),
		MCenterYIn(
			MColsA([
				MCard(
					[
						MRichMediaBlock(
							MCenter(
								MText(_("CANCEL"), [buttonFontSize, MWhite()])
							),
						[])
					],
					[MCardHeight(50.), MCardWidth(150.0), MContentBorders(false), mediumGrey],
					[MOnClick(cancelAction)]
				),
				TFixed(20., 0.),
				MCard(
					[
						MRichMediaBlock(
							MCenter(
								MText(_("DELETE"), [buttonFontSize])
							),
						[])
					],
					[MCardHeight(50.), MCardWidth(150.0), MContentBorders(false), MCustomColor(0xFDB22B)],
					[MOnClick(okAction)]
				),
			]),
			TFixed(0., 80.)
		),
		TFixed(25., 0.)
	]);

	MGroup([
		TRectangle([Fill(white), FillOpacity(1.0)], TFixed(380., 160.)),
		MLinesA([
			title,
			footer
		])
	])
}

dayEventsPopup(
	curDate : Date,
	dayEventsStatic : [CalendarEvent],
	eventTypesB : DynamicBehaviour<[CalendarEventDecription]>,
	manager : MaterialManager,
	choosedFilters : [string],
	rangeType : int, // 0 - day, 1 - week, 2 - month
	styles : [CalendarForEventsStyle]
	) -> void {

	listSettings = extractStruct(styles, EventListSettings(["event any text", "start", "end"], false, true));
	colsToShow = listSettings.cols;
	showDate = listSettings.showDate;
	showTime = listSettings.showTime;
	showStart = contains(colsToShow, "start");
	showEnd = contains(colsToShow, "end");
	closePopupAfterAdditionalAction = containsStruct(styles, CloseDayPopupAfterAdditionalAction());
	defaultEventToAdd = extractStruct(styles, CalendarDefaultEventToAdd(\ -> "")).getEventType();
	isReadOnly = fgetValue(extractStruct(styles, CalendarReadOnly(const(false))).isReadOnlyB);

	close = make(false);
	dayEvents = make(dayEventsStatic);

	curTime = stamp2time(timestamp());
	dayNumber = curDate.day;
	monthNumber = curDate.month;

	roundTime = \time -> {
		roundInterval = 30;
		roundedMinutes = (time.min / roundInterval + 1) * roundInterval;
		flooredTime = Time(time with min = 0, sec = 0);
		stamp2time(time2stamp(flooredTime) + min2ms(roundedMinutes));
	}
	dateForAdd = roundTime(Time(curDate.year, curDate.month, curDate.day, curTime.hour, curTime.min, curTime.sec));

	textCols = ["event type", "event description", "event title"];
	dateCols = ["start", "end"];
	additionalCols = subtractA(colsToShow, concat(textCols, dateCols));

	dateExpandingFactor = 1.65;

	getDateWidth = \-> {
		if ((showDate && showTime) && (showStart && showEnd)) dateExpandingFactor
		else b2d((showDate || showTime) && (showStart || showEnd))
	}

	getTextWidth = \-> {
		if (length(colsToShow) == 0 || contains(colsToShow, "event any text")) 1.
		else i2d(length(intersection(colsToShow, textCols)))
	}

	additionalColsWidth = i2d(length(additionalCols)) * 166.;

	lineWidth = 264. + getTextWidth() * 276. + getDateWidth() * 156. + additionalColsWidth;
	popupWidth = lineWidth + 85.;
	titleHeight = 60.;
	lineHeight = 88.;
	buttonHeight = 70.;

	leftOffset = TFixed(40., 0.);
	iconBox = TFixed(100., lineHeight);
	nameBox = TFixed(260., lineHeight);
	additionalColBox = TFixed(150., lineHeight);
	editButtonBox = TFixed(44., lineHeight);
	deleteButtonBox = TFixed(70., lineHeight);
	timeBox = TFixed(getDateWidth() * 156., lineHeight);

	mediumFont = MCustomFont(18., "RobotoMedium", primaryTextOpacity);
	normalFont = MCustomFont(18., "Roboto", primaryTextOpacity);
	littleFont = MBody();

	centeredTitleText = \text -> MCenterIn(MText(text, [mediumFont, MGrey(800)]), TFillXH(titleHeight));

	titleText = if (rangeType == 0) {
		MColsA([
			MCenterYIn(
				MText(i2s(dayNumber) + " " + monthString(curDate, true), [mediumFont, MGrey(800)]),
				TFixed(100., titleHeight)
			),
			TFillX(),
			MCenterYIn(
				MParagraph(dayOfWeekString(curDate, true), [littleFont, MGrey(800), RightAlign(), MWidth(80.)]),
				TFixed(80., titleHeight)
			),
		])
	}   else if (rangeType == 1) centeredTitleText(i2s(getWeekOfYear(curDate, 0, true)))
		else centeredTitleText(_(monthString(curDate, true)));

	addLeftOffset = \m : Material -> MCols2(leftOffset, m);

	title = MGroup([
		TRectangle([MFill(MGrey(200))], TFixed(popupWidth, titleHeight)),
		MFixSize(
			addLeftOffset(MCols2A(
				titleText,
				MCenterYIn(
					MIconButton("close",
						\ -> next(close, true),
						[MBlack(), MIconSize(20.)],
						[MShortcut("esc")]
					),
					TFixed(20., 55.)
				)
			)),
			TFixed(popupWidth, titleHeight)
		)
	]);

	separatorLine = TRectangle([Fill(grey), FillOpacity(0.7)], TFixed(lineWidth, 0.5));

	//line with "empty" icon and text
	emptyLine = MLines2A(
		MCols2A(
			MBorderA(0., 0., 8., 0., MCenterYIn(TCircle(28., [Fill(grey)]), TFixed(70., lineHeight))),
			MCenterYIn(MText(_("No added events"), [normalFont]), TFixed(100., lineHeight))
		),
		separatorLine
	);

	makeTextCol = \text : string, boxSize : Material -> {
		MBorderA(8., 0., 8., 0.,
			MFixSize(MCenterY(MEllipsisText(text, [mediumFont, MShowTooltip(const(true)), MMaxLines(2)])), boxSize)
		);
	}

	makeTextCols = \event : CalendarEvent -> {
		makeNameTextCol = \text : string -> makeTextCol(text, nameBox);
		MColsA([
			if (contains(colsToShow, "event any text")) makeNameTextCol(getEventTitle(event)) else MEmpty(),
			if (contains(colsToShow, "event type") || (length(colsToShow) == 0 && event.title == "")) makeNameTextCol(event.eventType) else MEmpty(),
			if (contains(colsToShow, "event title") || (length(colsToShow) == 0 && event.title != "")) makeNameTextCol(event.title) else MEmpty(),
			if (contains(colsToShow, "event description")) makeNameTextCol(event.description) else MEmpty()
		])
	}

	makeAdditionalCols = \event : CalendarEvent -> {
		MCols(map(additionalCols, \col -> makeTextCol(lookupTreeDef(event.additionalFields, col, ""), additionalColBox)))
	}

	makeDateCol = \event : CalendarEvent -> {
		getDateText = \dt : Time -> {
			timeString = lpad(getTimeOnlyString(dt, false, false), "0", 5);
			dateString = date2formatString(time2date(dt), "%DD.%MM.%YY");
			if (showDate && showTime) dateString + " " + timeString
			else if (showDate) dateString
			else if (showTime) timeString
			else ""
		}
		text = if (showStart && showEnd) getDateText(event.startDate) + " - " + getDateText(event.endDate)
			else if (showStart) getDateText(event.startDate)
			else if (showEnd) getDateText(event.endDate)
			else "";
		if (text != "" && text != " - ") MFixSize(MCenterY(MEllipsisText(text, [normalFont, MShowTooltip(const(true))])), timeBox)
		else MEmpty()
	}

	makeAddButtonsMenu = \event, eventType -> {
		mainButton = MIconButton("more_horiz",
			nop,
			[MIconSize(22.), MGrey(700)],
			[]
		);

		items = map(eventType.additionalActions, \act -> {
			MMenuCustomLine(
				MColsA([
					MCenterYIn(
						MIcon(act.icon, [MIconSize(22.)]),
						TFixed(50., 44.)
					),
					MCenterYIn(
						MText(act.name, [normalFont]),
						TFixed(0., 44.)
					)
				]),
			[])
		});

		MCenterYIn(
			MMenu(
				mainButton,
				items,
				[MOnListClick(const(true), \index -> eventType.additionalActions[index].action(event.id))]
			),
			editButtonBox
		)
	}

	makeAddButtonsCol = \event : CalendarEvent, eventType : CalendarEventDecription -> {
		if (length(eventType.additionalActions) > 0) {
			if (length(eventType.additionalActions) == 1) {
				MCenterYIn(
					MIconButton(eventType.additionalActions[0].icon,
						\-> {
							eventType.additionalActions[0].action(event.id);
							if (closePopupAfterAdditionalAction) next(close, true);
						},
						[MIconSize(22.), MGrey(700)],
						[]
					),
					editButtonBox
				)
			} else makeAddButtonsMenu(event, eventType)
		} else editButtonBox
	}

	makeEditButton = \event : CalendarEvent, eventType : CalendarEventDecription -> {
		MCenterYIn(
			MIconButton("mode_edit",
				\-> {
					eventType.editAction(event.id);
					next(close, true);
				},
				[MGrey(700), MIconSize(22.)],
				[]
			),
			editButtonBox
		)
	}

	makeDeleteButton = \event : CalendarEvent, eventType : CalendarEventDecription -> {
		MCenterYIn(
			MIconButton("delete",
				\-> {
					popupClose = make(false);
					ShowMDialog(manager, popupClose, [],
						eventDeletePopup(
							\-> next(popupClose, true),
							\-> {
								next(popupClose, true);
								evIndexInDay = either(findi(getValue(dayEvents), \p -> p.id == event.id), -1);
								if (evIndexInDay != -1) next(dayEvents, removeIndex(getValue(dayEvents), evIndexInDay));
								eventType.deleteAction(event.id);
							}
						)
					);
				},
				[MGrey(700), MIconSize(22.)],
				[]
			),
			deleteButtonBox
		)
	}

	makeAvatar = \eventType : CalendarEventDecription -> {
		MCenterYIn(
			MAvatar(eventType.icon, [MIconSize(56.0)]),
			iconBox
		)
	}

	//line with icon, event name, event time and buttons for edit and delete
	eventLine = \event : CalendarEvent, eventType : CalendarEventDecription -> {
		MLines2A(
			MColsA([
				makeAvatar(eventType),
				makeTextCols(event),
				makeAdditionalCols(event),
				makeDateCol(event),
				editButtonBox,
				makeAddButtonsCol(event, eventType),
				makeEditButton(event, eventType),
				makeDeleteButton(event, eventType)
			]),
			separatorLine
		);
	}

	eventAddButton = \evType ->  {
		MLines2A(
			MClickable(
				MGroup([
					MCenterYIn(
						MShadow(const(4.0),
							MFrame(2., 2., [MFill(MGrey(200))], TFixed(lineWidth, buttonHeight))
						),
						TFixed(0., buttonHeight)
					),
					MCenterIn(
						MFrame(2., 2., [MFill(evType.backColor)], TFixed(lineWidth - 2., buttonHeight - 2.)),
						TFixed(lineWidth, buttonHeight)
					),
					MCenterIn(
						MText(_("ADD") + " " + toUpperCase(evType.name), [mediumFont, evType.mainColor]),
						TFixed(lineWidth, buttonHeight)
					)
				]),
				\ -> {
					evType.addAction(dateForAdd);
					next(close, true)
				}
			),
			TFixed(popupWidth - 40., 20.)
		)
	};

	popup = MLines2(
		MShadow(const(4.0), title),
		MSelect2(dayEvents, eventTypesB, \events, eventTypes -> {
			notAddedEvents = if (^isOnlyOneSameTypeEventsByDay)
					filter(eventTypes, \ev -> {
						evIndexInDay = findiDef(getValue(dayEvents), \p -> p.eventType == ev.name, -1);
						evIndexInDay == -1 && !contains(choosedFilters, ev.name)
					})
				else
					eventTypes;

			eventsList : Material = if (length(events) == 0)
					emptyLine
				else MLinesA(
					filtermap(events, \dayEvent -> {
						eventTypeIndex = findiDef(eventTypes, \p -> p.name == dayEvent.eventType, -1);
						if (eventTypeIndex != -1) Some(eventLine(dayEvent, eventTypes[eventTypeIndex])) else None()
					})
				);

			content = MLet(
				"m",
				MLinesA([
					eventsList,
					TRectangle([Fill(white)], TFixed(popupWidth - 40., 40.)),
					MLinesA(map(notAddedEvents,
						\notAddedEvent ->
							if (notAddedEvent.addAction == nop1) MEmpty()
							else eventAddButton(notAddedEvent)
						)
					)
				]),
				MAttach(MGhost("m"), \formMetrics -> MGroup2(
					TSizedHeight(popupWidth, formMetrics.height)
					|> addTBackground(MWhite()),
					addLeftOffset(MDisplay("m"))
				))
			);

			MScroll(
				content,
				TFillWY(popupWidth),
				[TScrollbars(invisibleScrollBar, standardScrollBar), MScrollCropByContent(), MScrollDisableOutOfBounds(const(true))]
			)
		}),
	);

	if (!isReadOnly) {
		eventTypeM = find(getValue(eventTypesB), \type -> type.name == defaultEventToAdd);
		eitherFn(eventTypeM, \eventType -> {
			eventType.addAction(dateForAdd);
		}, \ -> {
			ShowMDialog(
				manager,
				close,
				[MDialogClickOutToClose(), MDialogScroll()],
				MShadow(const(20.0), popup)
			);
		});
	}
}

makeLineOfDaysBlockForMonthView(
	startIndex : int,
	blankDaySize : Material,
	daysBlock : [Material],
	result : [Material]) -> [Material] {

	blocksLength = length(daysBlock);

	if (startIndex >= blocksLength) {
		result
	} else {
		newLine = MCols(
			generate(startIndex, startIndex + 7, \blockIndex -> {
				if (blockIndex < blocksLength)
					daysBlock[blockIndex]
				else
					blankDaySize
			})
		);
		makeLineOfDaysBlockForMonthView(startIndex + 7, blankDaySize, daysBlock, arrayPush(result, newLine))
	}
}

//create cards with events for each day in current month
MonthTable(
	currentEvents : DynamicBehaviour<[CalendarEvent]>,
	eventTypesB : DynamicBehaviour<[CalendarEventDecription]>,
	currentDate : DynamicBehaviour<Date>,
	dateMin : Date,
	dateMax : Date,
	manager : MaterialManager,
	multiDayEventsPosition : DynamicBehaviour<[Pair<CalendarEvent, int>]>,
	choosedFilters : DynamicBehaviour<[string]>,
	styles : [CalendarForEventsStyle]
) -> CalendarTabView {
	weekDayHeight = 55.0;

	lineBox =                                  TFillXYXY(50., 30., 141.5 * 5., 30. * 3.);
	lineBoxForBlockWithEvent =                 TFillXYXY(50., 28., 138.5 * 5., 28. * 3.);
	lineBoxForBlockWithFirstMultiDayEvent =    TFillXYXY(50., 28., 140.0 * 5., 28. * 3.);
	lineBoxForBlockWithNotFirstMultiDayEvent = TFillXYXY(50., 28., 141.5 * 5., 28. * 3.);
	lineBoxForBlockWithFirstMultiDayEvent2 =   TFillXYXY(50., 30., 140.0 * 5., 30. * 3.);
	weekDaySize =                              TFillXYXY(50., weekDayHeight, 141.5 * 5., weekDayHeight);
	blankDaySize =                             TFillXYXY(50., 120., 141.5 * 5., 120. * 3.);
	borderLineBox =                            TFillWY(1.0);

	showMonthSwitchView = contains(styles, ShowMonthViewSwitchMenu());
	isUseMTextMColor = contains(styles, BlackAndWhiteTextColor());
	byWeekViewB = make(extractStruct(styles, DefaultMonthView(true)).byWeek);
	hideTimeInfo = contains(styles, HideTimeInfo());
	calendarTabMenuStyle = extractStruct(styles, defaultCalendarTabMenuStyle);
	isReadOnlyB = extractStruct(styles, CalendarReadOnly(const(false))).isReadOnlyB;
	getEventView = extractStruct(styles, CalendarCustomEventView(\__, __, __, __, __ -> None())).getView;

	calendarDayTouch = \item : CalendarEvent, dayDate : Date -> {
		isMultiDay = (time2date(item.startDate) != time2date(item.endDate));
		eventTime = if (hideTimeInfo) ""
			else i2s(item.startDate.hour) + ":" + substring(item.startDate |> time2stamp2 |> time2string, 14, 2) + "   ";

		eventTypeB = fselect(eventTypesB, FLift(\eventTypes -> findDef(eventTypes, \p -> p.name == item.eventType, makeCalendarEventDescription())));
		eventText = if (!isMultiDay)
				eventTime + getEventTitle(item)
			else if (dayDate == time2date(item.startDate))
				getEventTitle(item)
			else
				" ";

		MShowLazy(fselect(eventTypeB, FLift(\eventType -> eventType.name != "")), \ -> {
			backColorB = fselect(eventTypeB, FLift(\eventType -> eventType.backColor));
			eventTextM = MSelect(eventTypeB, \eventType -> {
				mainColor = eventType.mainColor;
				eventTextColor = if (isUseMTextMColor) MTextMColor(mainColor) else mainColor;
				MEllipsisText(eventText, [eventTextColor])
			});
			defaultViewM = MGroup([
				if (!isMultiDay) {
					MGroup2(
						TRectangle([Fill(white), FillOpacity(1.0)], lineBox),
						MCenterIn(
							MSelect(backColorB, \backColor -> TRectangle([MFill(backColor), FillOpacity(1.0)], lineBoxForBlockWithEvent)),
							lineBox
						)
					)
				} else {
					if (dayDate == time2date(item.startDate)) {
						MGroup2(
							TRectangle([Fill(white), FillOpacity(1.0)], lineBox),
							MColsA([
								TFixed(1.5, 0.),
								MCenterYIn(
									MSelect(backColorB, \backColor -> TRectangle([MFill(backColor), FillOpacity(1.0)], lineBoxForBlockWithFirstMultiDayEvent)),
									lineBoxForBlockWithFirstMultiDayEvent2
								)
							])
						)
					} else if (dayDate == time2date(item.endDate)) {
						MGroup2(
							TRectangle([Fill(white), FillOpacity(1.0)], lineBox),
							MColsA([
								MCenterYIn(
									MSelect(backColorB, \backColor -> TRectangle([MFill(backColor), FillOpacity(1.0)], lineBoxForBlockWithFirstMultiDayEvent)),
									lineBoxForBlockWithFirstMultiDayEvent2
								),
								TFixed(1.5, 0.),
							])
						)
					} else {
						MGroup2(
							TRectangle([Fill(white), FillOpacity(1.0)], lineBox),
							MCenterYIn(
								MSelect(backColorB, \backColor -> TRectangle([MFill(backColor), FillOpacity(1.0)], lineBoxForBlockWithNotFirstMultiDayEvent)),
								lineBox
							),
						)
					}
				},
				MTooltip(
					MCenterIn(
						MBorderA(2., 0., 2., 0., eventTextM),
						lineBox
					),
					MText(item.description, []),
					[MEnabled(const(isTooltipEnabled(item)))]
				),
			]);

			isEditActionNotEmptyB = fselect(eventTypeB, FLift(\et -> et.editAction != nop1));
			MComponent(
				[MOnClick(\-> fgetValue(eventTypeB).editAction(item.id)), MEnabled(fand(fnot(isReadOnlyB), isEditActionNotEmptyB))],
				\__ -> {
					MSelect(eventTypeB, \eventType -> {
						eitherMap(getEventView(MonthTab(), item, eventType, dayDate, 1), \m -> MFixSize(m, defaultViewM), defaultViewM)
					});
				}
			);
		});
	}

	openDayEventsPopup = \dayNumber, isEnable, events : [CalendarEvent] -> {
		curD = getValue(currentDate);
		dayDate = Date(curD.year, curD.month, dayNumber);
		if (isEnable) dayEventsPopup(dayDate, events, eventTypesB, manager, getValue(choosedFilters), 0, styles);
	}

	makeTitle = \eventColor, dayNumber, isEnable, events : [CalendarEvent] -> MComponent(
		[MOnClick(\-> openDayEventsPopup(dayNumber, isEnable, events)), MEnabled(fnot(isReadOnlyB))],
		\__ -> {
			MGroup2(
				TRectangle([MFill(eventColor), FillOpacity(1.0)], lineBox),
				MCenterIn(
					MText(i2s(dayNumber), [MWhite()]),
					lineBox
				)
			);
		}
	);

	makeEmptyBlock = \dayNumber, isEnable, events : [CalendarEvent] -> MComponent(
		[MOnClick(\-> openDayEventsPopup(dayNumber, isEnable, events)), MEnabled(fnot(isReadOnlyB))],
		\__ -> {
			MGroup2(
				TRectangle([Fill(white), FillOpacity(1.0)], lineBox),
				MCenterIn(
					MText("  ", [MWhite()]),
					lineBox
				)
			);
		}
	);

	makeAdditionalEventsBlock = \addDaysCount, dayNumber, isEnable, events : [CalendarEvent] -> MComponent(
		[MOnClick(\-> openDayEventsPopup(dayNumber, isEnable, events)), MEnabled(fnot(isReadOnlyB))],
		\__ -> {
			MGroup2(
				TRectangle([MFill(MGrey(400)), FillOpacity(1.0)], lineBox),
				MCenterIn(
					MText(i2s(addDaysCount) + _("+ events"), [MWhite()]),
					lineBox
				)
			);
		}
	);

	// "Empty" day consists of a header with the number of the day and maxDisplayedEventsInOneDay empty units.
	// By clicking on the card - opens a window with a choice of added events
	makeEmptyCalendarDay = \dayDate, isEnable -> {
		dayNumber = dayDate.day;
		maxEvents = ^maxDisplayedEventsInOneDay;

		title = makeTitle(MGrey(600), dayNumber, isEnable, []);

		blocks = concat([title],
			generate(0, maxEvents, \empty -> makeEmptyBlock(dayNumber, isEnable, []))
		);

		MLines(blocks);
	}

	// "NotEmpty" day consists of a header with a background color number of the day of the first (in time) of the event,
	// as well as maxDisplayedEventsInOneDay blocks of the events.
	// If the event is less than maxDisplayedEventsInOneDay  - fill the "empty" blocks
	makeNotEmptyCalendarDay = \dayDate, events : [CalendarEvent], isEnable -> {
		eventTypes = getValue(eventTypesB);
		dayNumber = dayDate.day;
		eventName = events[0].eventType;
		maxEvents = ^maxDisplayedEventsInOneDay;

		fullDayEvents = if (length(events) < maxEvents) {
			concat(events, generate(0, maxEvents - length(events),
				\__ -> emptyEvent)
			)
		} else {
			events
		};
		newEvents = checkOneDayEventsPosition(fullDayEvents, multiDayEventsPosition);

		notEmptyEventIndex = either(findi(newEvents, \p -> p.eventType != "_EMPTY_"), -1);
		eventIndex = if (notEmptyEventIndex != -1) either(findi(eventTypes, \p -> p.name == newEvents[notEmptyEventIndex].eventType), -1) else -1;

		eventColor = if (!^isColorizeDayHeaders) {
			MGrey(600)
		} else if (eventIndex != -1) {
			eventTypes[eventIndex].mainColor
		} else {
			MWhite()
		};

		title = makeTitle(eventColor, dayNumber, isEnable, events);
		getAdditionalNonEmptyEvents = \-> foldi(newEvents, 0, \index, res, e -> if (index >= maxEvents - 1 && e.eventType != "_EMPTY_") res + 1 else res);

		eventsCount = length(newEvents);
		MLines(concat(
			[title],
			mapi(take(newEvents, maxEvents), \i, e ->
				if ( (i == maxEvents - 1) && (eventsCount > maxEvents) )
					makeAdditionalEventsBlock(getAdditionalNonEmptyEvents(), dayNumber, isEnable, events)
				else if (e.eventType != "_EMPTY_")
					calendarDayTouch(e, dayDate)
				else
					makeEmptyBlock(dayNumber, isEnable, events)
			)
		));
	}

	gridLineM = TRectangle([MFill(MGrey(600)), FillOpacity(1.0)], borderLineBox);
	//if day consists 0 events or this day is not available - show emptyDay
	makeCalendarDay = \dayDate, events : [CalendarEvent], isEnable -> {
		MCols([
			if (dayDate.day == 1 || dayOfWeek(dayDate) == 0) gridLineM else MEmpty(),
			if (length(events) > 0 && isEnable) {
				makeNotEmptyCalendarDay(dayDate, events, isEnable)
			} else {
				makeEmptyCalendarDay(dayDate, isEnable)
			},
			gridLineM
		]);
	}

	rowHeightB = make(0.0);
	// First, we keep out all events except the events for the current month. Then create a list of events for each day
	calendarFiltering = \items : [CalendarEvent] -> {
		filteredByMonth = filter(
			items,
			\item -> timeYearCheck(item.startDate.year, item.endDate.year, getValue(currentDate).year)
					&& timeMonthCheck(item.startDate, item.endDate, getValue(currentDate))
		);

		daysCount = getNumberOfDaysPerMonthInTheYear(getValue(currentDate).year)[getValue(currentDate).month];
		timeSort = \item : CalendarEvent -> item.startDate;
		filteredByDay = generate(1, daysCount + 1, \dayNumber -> {
			isEnable = isDateEnable(Date(getValue(currentDate).year, getValue(currentDate).month, dayNumber), dateMin, dateMax);
			allEvents = filter(filteredByMonth, \item -> timeDayCheck(item.startDate, item.endDate, getValue(currentDate), dayNumber));

			m = makeCalendarDay(
				Date(getValue(currentDate).year, getValue(currentDate).month, dayNumber),
				sortEvents(allEvents),
				isEnable
			);
			if (dayNumber == 1) MAttachHeight(m, rowHeightB) else m;
		});
		filteredByDay
	}

	calendarOffset = \firstWeekOffset : int -> {
		generate(0, firstWeekOffset, \__ -> blankDaySize);
	};

	weekDayNames = [strsubsmart(_("Monday"), 0, 3), strsubsmart(_("Tuesday"), 0, 3), strsubsmart(_("Wednesday"), 0, 3),
		strsubsmart(_("Thursday"), 0, 3), strsubsmart(_("Friday"), 0, 3), strsubsmart(_("Saturday"), 0, 3), strsubsmart(_("Sunday"), 0, 3)];
	makeWeekDayNameCell = \name : string -> {
		MCenterIn(MText(name, []), weekDaySize)
	};

	MonthViewByWeek = \curD : Date, items : [CalendarEvent] -> {
		headerM = MColsA(map(weekDayNames, makeWeekDayNameCell));
		rows = makeLineOfDaysBlockForMonthView(0, blankDaySize,
			concat(calendarOffset(dayOfWeek(curD) % 7), calendarFiltering(items)),
			[]
		);
		CalendarTabView(
			MLines2A(
				headerM,
				MScroll(MLines(rows), TFillXY(), [])
			),
			\availableSize -> {
				rowHeight = getValue(rowHeightB);
				rowsPerPage = floor((availableSize.height - weekDayHeight) / rowHeight);
				pagesCount = ceil(i2d(length(rows)) / i2d(rowsPerPage));
				generate(0, pagesCount, \i -> {
					MLines2A(
						headerM,
						MLines(subrange(rows, i * rowsPerPage, rowsPerPage))
					)
				});
			}
		);
	}

	MonthViewByDay = \curD : Date, items : [CalendarEvent] -> {
		lastMonthDayDate = Date(curD.year, curD.month, getNumberOfDaysPerMonthInTheYear(curD.year)[curD.month]);
		RangeView(
			manager,
			items,
			eventTypesB,
			Date(curD.year, curD.month, 1),
			lastMonthDayDate,
			\date, events -> dayEventsPopup(date, events, eventTypesB, manager, getValue(choosedFilters), 0, styles),
			dateMin,
			dateMax,
			0,
			false,
			make(false),
			RangeTab(),
			styles
		)
	}

	MonthViewSwitchMenu = \ -> {
		style = concat(
			calendarTabMenuStyle.icon,
			[MIconButtonBorder(8.), MToggleFalseIcon("view_column", arrayPush(calendarTabMenuStyle.icon, MGrey(600)))]
		);
		MIconToggle("view_module", style, [MToggleValue(byWeekViewB)]) |> (\m -> MCols2(MFillX(), m))
	}

	monthViewB = fselect3(byWeekViewB, currentDate, currentEvents, \byWeekView, curD, items -> {
		if (byWeekView) {
			MonthViewByWeek(curD, items);
		} else {
			MonthViewByDay(curD, items);
		}
	});

	CalendarTabView(
		MGroup2(
			TRectangle([Fill(white), FillOpacity(1.0)], TFillXY()),
			MLines2A(
				if (showMonthSwitchView) MFrame(0.0, 0.0, calendarTabMenuStyle.background, MonthViewSwitchMenu()) else MEmpty(),
				MSelect(monthViewB, \monthView -> monthView.main),
			)
		),
		\availableSize -> fgetValue(monthViewB).getPrintPages(availableSize)
	);
}

// week utils
getWeeksBetweenDates(date1 : Date, date2 : Date, acc : int) -> int {
	start = min(date1, date2);
	end = max(date1, date2);
	res = if (start.year == end.year) acc + getWeekOfYear(end, 0, true) - getWeekOfYear(start, 0, true)
		else getWeeksBetweenDates(start, Date(end.year - 1, 12, 31), getWeekOfYear(end, 0, true) + acc);
	if (date1 <= date2) res else -res
}

getWeekStartDate(weekNum : int, year : int) -> Date {
	if (weekNum == 1) Date(year, 1, 1)
	else {
		lastYearDay = Date(year, 12, 31);
		lastWeekNum = getWeekOfYear(lastYearDay, 0, true);
		weekDate = addDaysToDate(lastYearDay, 7 * (weekNum - lastWeekNum));
		addDaysToDate(weekDate, -dayOfWeek(weekDate))
	}
}

getWeekEndDate(start : Date) -> Date {
	end = addDaysToDate(start, 6 - dayOfWeek(start));
	if (end.year == start.year) end else Date(start.year, 12, 31)
}

getNextWeekStartDate(weekNum : int, year : int, weeksToAdd : int) -> Date {
	lastWeekNum = getWeekOfYear(Date(year, 12, 31), 0, true);
	weeksToAddThisYear = lastWeekNum - weekNum;
	if (weeksToAddThisYear < weeksToAdd) getNextWeekStartDate(0, year + 1, weeksToAdd - weeksToAddThisYear)
	else getWeekStartDate(weekNum + weeksToAdd, year)
}

getMonthsBetweenDates(date1 : Date, date2 : Date, acc : int) -> int {
	start = min(date1, date2);
	end = max(date1, date2);
	res = if (start.year == end.year) acc + end.month - start.month else getMonthsBetweenDates(start, Date(end.year - 1, 12, 31), acc + end.month);
	if (date1 <= date2) res else -res
}

RangeView(
	manager : MaterialManager,
	events : [CalendarEvent],
	eventTypes : DynamicBehaviour<[CalendarEventDecription]>,
	startDate : Date,
	endDate : Date,
	showDayEventsPopup : (date : Date, events : [CalendarEvent]) -> void,
	dateMin : Date,
	dateMax : Date,
	rangeType : int,
	showMonthRow : bool,
	isPrintingB : DynamicBehaviour<bool>,
	tab : CalendarTab,
	styles : [CalendarForEventsStyle]
) -> CalendarTabView {
	isReadOnlyB = extractStruct(styles, CalendarReadOnly(const(false))).isReadOnlyB;
	weekendsColor = extractStruct(styles, CalendarWeekendsColor(MRed(600))).color;
	getEventView = extractStruct(styles, CalendarCustomEventView(\__, __, __, __, __ -> None())).getView;
	showDaysNames = containsStruct(styles, ShowWeekViewDaysNames());

	byDayCellHeight = if (showDaysNames) 58.0 else 48.0;
	byDayCellSize : Tropic = TFillXH(byDayCellHeight);

	getRangeColumnsCount = \start : Date, end : Date -> {
		if (rangeType == 0) getDaysBetweenDates(start, end)
		else if (rangeType == 1) getWeeksBetweenDates(start, end, 0)
		else end.month - start.month + 12 * (end.year - start.year)
	}

	getNextDate = \oldDate : Date, dateNum : int -> {
		newDate = if (rangeType == 0) addDaysToDate(oldDate, 1 * dateNum)
			else if (rangeType == 1) getNextWeekStartDate(getWeekOfYear(oldDate, 0, true), oldDate.year, dateNum)
			else addMonthsToDate(oldDate, 1 * dateNum);
		min(max(newDate, startDate), endDate)
	}

	columnsCountInRange = getRangeColumnsCount(startDate, endDate) + 1;
	rangeEvents = filter(events, \event -> time2date(event.startDate) <= endDate && startDate <= time2date(event.endDate));

	cellBorder = \colour : int, height : double -> TRectangle([Fill(colour)], TFillMax(2., height));

	eventsByRow : [[CalendarEvent]] = fold(sortCustom(rangeEvents, \event -> event.endDate, true), [], \res, event : CalendarEvent -> {
		eitherFn(
			findi(res, \x -> getRangeColumnsCount(time2date(lastElement(x, emptyEvent).endDate), time2date(event.startDate)) > 0),
			\idx -> replace(res, idx, arrayPush(res[idx], event)),
			\ -> arrayPush(res, [event])
		)
	});

	titleRowHeightB = make(0.0);
	titleRow = MAttachHeight(MColsA(generate(0, columnsCountInRange, \dateNum -> {
		todayCircleDiam = 24.0;
		date = getNextDate(startDate, dateNum);
		isTodayB = fand(const(compareDates(date, getCurrentDate()) == DateEqual()), fnot(isPrintingB));
		todayBackgroundColor = getPrimaryColor(manager);

		text = if (rangeType == 0) date.day else if (rangeType == 1) getWeekOfYear(date, 0, true) else date.month;
		dayNumberText = \color -> MCenterIn(MText(i2s(text), [color, MBodyBold()]), MFixed(todayCircleDiam, todayCircleDiam));

		dayNumberM = MIfLazy(isTodayB, \isToday -> {
			if (isToday) {
				MFrame(0.0, todayCircleDiam / 2.0, [MFill(todayBackgroundColor)],
					dayNumberText(MContrastingTextColor(todayBackgroundColor))
				);
			} else {
				color = if (dayOfWeek(date) >= 5 && rangeType == 0) {
					weekendsColor;
				} else {
					MBlack();
				}
				dayNumberText(color);
			}
		});

		if (rangeType == 0 && showDaysNames) {
			dayName = toUpperCase(dayOfWeekString(date, false));
			MLines2A(
				MCenterX(MText(dayName, [MCaptionColumn(), MGrey(500)])) |> MBorderTopBottom(6.0),
				MCenterX(dayNumberM)
			) |> MBorderBottom(8.0);
		} else {
			MCenterIn(dayNumberM, byDayCellSize);
		}
	})), titleRowHeightB);

	dayClickGrid = MColsA(generate(0, columnsCountInRange, \dateNum -> {
		date = getNextDate(startDate, dateNum);
		eventsToShow = {
			sectionStart = if (rangeType <= 1) date else Date(date.year, date.month, 1);
			sectionEnd = if (rangeType == 0) date
					else if (rangeType == 1) getWeekEndDate(sectionStart)
					else Date(date.year, date.month, getNumberOfDaysPerMonthInTheYear(date.year)[date.month]);
			filter(
				rangeEvents,
				\event -> max(sectionStart, startDate) <= time2date(event.endDate) && time2date(event.startDate) <= min(sectionEnd, endDate)
			)
		}
		onClick = \ -> {
			if (isDateBetween(date, dateMin, dateMax)) showDayEventsPopup(date, eventsToShow);
		}
		MComponent([MOnClick(onClick), MEnabled(fnot(isReadOnlyB))], \__ -> MFillXY());
	}));

	EventCells = \len : int, event : CalendarEvent -> {
		eventTypeB = fselect(eventTypes, FLift(\types -> {
			findDef(types, \et -> et.name == event.eventType, makeCalendarEventDescription())
		}));
		date = max(time2date(event.startDate), startDate);
		getEventCells = \eventType -> MCols(generate(0, len, \cellNum : int -> {
			leftCorner = b2d(cellNum == 0) * 4.;
			rightCorner = b2d(cellNum == len - 1) * 4.;
			backColourInt = MColor2int(eventType.backColor);
			MCols2A(
				TRounded(leftCorner, rightCorner, rightCorner, leftCorner, [Fill(backColourInt)], byDayCellSize),
				cellBorder(if (cellNum == len - 1) white else backColourInt, byDayCellHeight)
			);
		}));
		getDefaultView = \eventCells, eventType -> {
			text = MCenterYIn(MBorder(8., 0., 8., 0.,
				MEllipsisText(getEventTitle(event), [eventType.mainColor, MShowTooltip(make(true))])
			), eventCells);
			MGroup2(eventCells, MTooltip(text, MText(event.description, []), [MEnabled(const(isTooltipEnabled(event)))]));
		}

		isEditActionNotEmptyB = fselect(eventTypeB, FLift(\et -> et.editAction != nop1));
		MComponent(
			[MOnClick(\ -> fgetValue(eventTypeB).editAction(event.id)), MEnabled(fand(fnot(isReadOnlyB), isEditActionNotEmptyB))],
			\__ -> {
				MSelect(eventTypeB, \eventType -> {
					eventCells = getEventCells(eventType);
					eitherMap(getEventView(tab, event, eventType, date, len), MFixWidth(eventCells), getDefaultView(eventCells, eventType))
				})
			}
		) |> disableMInteractivesBelow;
	};
	EmptyCells = \len : int -> MCols(generate(0, len, \__ -> MCols2(MFillXH(0.0), cellBorder(white, 0.0))));

	rowsHeightsB = generate(0, length(eventsByRow), \__ -> make(0.0));
	eventRows = mapi(eventsByRow, \i, evs : [CalendarEvent] -> {
		MAttachHeight(
			mapi(evs, \j, event -> {
				eventLength = getRangeColumnsCount(max(time2date(event.startDate), startDate), min(time2date(event.endDate), endDate)) + 1;
				blankLength = if (j == 0) {
					getRangeColumnsCount(startDate, time2date(event.startDate));
				} else {
					getRangeColumnsCount(time2date(evs[j - 1].endDate), time2date(event.startDate)) - 1;
				}
				res = [EventCells(eventLength, event)]
					// insert empty cells before event, if any
					|> (\r -> if (blankLength > 0) insertArray(r, 0, EmptyCells(blankLength)) else r)
					// insert empty cells after event, if it's the last
					|> (\r -> {
						c = getRangeColumnsCount(time2date(event.endDate), endDate);
						if (j == length(evs) - 1 && c > 0) arrayPush(r, EmptyCells(c)) else r
					});
				res
			}) |> concatA |> MCols,
			rowsHeightsB[i]
		);
	});

	gridLinesStyle = [MFill(MGrey(400)), FillOpacity(0.4)];

	monthCount = getMonthsBetweenDates(startDate, endDate, 1);

	monthNamesRowHeightB = make(0.0);
	monthNamesRow = MAttachHeight(MCols(generate(0, monthCount, \idx -> {
		date = addMonthsToDate(startDate, idx);
		len = getDaysBetweenDates(
			if (idx == 0) startDate else Date(date.year, date.month, 1),
			if (idx == monthCount - 1) endDate else Date(date.year, date.month, getNumberOfDaysPerMonthInTheYear(date.year)[date.month])
		) + 1;
		MCols2A(
			TRectangle(if (idx == 0) [Fill(white)] else gridLinesStyle, TFixed(1., 24.)),
			MOnTop(
				MCols(generate(0, len, \__ -> TFillXH(24.))),
				MCenter(MEllipsisText(monthString(date, true), [MBodyBold(), MShowTooltip(const(true))]))
			)
		)
	})), monthNamesRowHeightB);

	gridLine = TRectangle(gridLinesStyle, TFillWY(1.));
	verticalGrid = MCols(concatA(generate(0, columnsCountInRange, \__ -> [gridLine, TFillX()])));

	horizontalLineHeight = 1.0;
	horizontalLine = TRectangle(gridLinesStyle, TFillXH(horizontalLineHeight));

	addTitleAndGrid = \m -> {
		MLinesA([
			if (rangeType == 0 && showMonthRow) monthNamesRow else MEmpty(),
			horizontalLine,
			MOnTop(
				dayClickGrid,
				MOnTop(MLinesA([titleRow, horizontalLine, m]), verticalGrid)
			)
		]);
	}

	CalendarTabView(
		addTitleAndGrid(MScroll(MLinesA(eventRows), TFillXY(), [])),
		\availableSize -> {
			titleHeight = getValue(monthNamesRowHeightB) + getValue(titleRowHeightB) + 2.0 * horizontalLineHeight;
			availableHeight = availableSize.height - titleHeight;
			pagesRows = foldi(eventRows, Pair([], 0.0), \i, acc, row -> {
				rowHeight = getValue(rowsHeightsB[i]);
				if (acc.first == []) {
					Pair([[row]], rowHeight);
				} else if (acc.second + rowHeight < availableHeight) {
					lastIndex = length(acc.first) - 1;
					newRows = replace(acc.first, lastIndex, arrayPush(acc.first[lastIndex], row));
					Pair(newRows, acc.second + rowHeight);
				} else {
					Pair(arrayPush(acc.first, [row]), rowHeight);
				}
			});

			if (pagesRows.first == []) {
				[addTitleAndGrid(MFillXY())];
			} else {
				map(pagesRows.first, \rows -> addTitleAndGrid(MLines(rows)));
			}
		}
	);
}

//Shows ONLY the upcoming events
PlannedEventsTable(
	currentEvents : DynamicBehaviour<[CalendarEvent]>,
	eventTypesB : DynamicBehaviour<[CalendarEventDecription]>,
	manager : MaterialManager,
	tabsDropdownM : Material,
	styles : [CalendarForEventsStyle]
) -> Material {


	tableDateFormat = extractStruct(styles, PlannedTableDateFormat("%YYYY/%MM/%DD")).tableDateFormat;
	hideTimeInfo = contains(styles, HideTimeInfo());
	littleFont = MBody();
	calendarTabMenuStyle = extractStruct(styles, defaultCalendarTabMenuStyle);
	isReadOnlyB = extractStruct(styles, CalendarReadOnly(const(false))).isReadOnlyB;
	printButtonStyleM = maybeMap(tryExtractStruct(styles, CalendarPrintable([])), \p -> p.style);

	timeSort = \item : CalendarEvent -> item.startDate;

	getLastEvents = \events -> {
		today = stamp2time2(timestamp());
		eventsAfterToday = filter(events, \event -> event.startDate >= today);
		sortCustom(eventsAfterToday, timeSort, true);
	}

	getLastEventsWithDescription = \events -> {
		today = stamp2time2(timestamp());
		filter(events, \event -> event.startDate >= today && event.description != "")
	}

	currentLine = make(-1);

	lineHeight = 60.;
	lineSeparatorHeight = 1.0;

	titleTextM = MCenterYIn(
		MSelect(currentEvents, \events -> MText(i2s(length(getLastEvents(events))) + " " + _("planned events"), calendarTabMenuStyle.text)),
		TFillXH(60.0)
	) |> MBorderStart(20.0);

	createTimeColumn = \_columnHeader -> {
		if (hideTimeInfo) TEmpty()
		else
			MCenterYIn(
				MText(_columnHeader, [littleFont, MGrey(800)]),
				TFixed(150., lineHeight)
			)
	}

	columnNames = MGroup([
		MLines2A(
			TRectangle([MFill(MGrey(200)), FillOpacity(1.0)], TFillXH(lineHeight)),
			TRectangle([MFill(MGrey(500)), FillOpacity(0.3)], TFillXH(2.))
		),
		MColsA([
			TFixed(25., 0.),
			MCenterYIn(
				MText(_("Date"), [littleFont, MGrey(800)]),
				TFixed(80., lineHeight)
			),
			TFixed(100., 0.),
			MCenterYIn(
				MText(_("Event name"), [littleFont, MGrey(800)]),
				TFixed(200., lineHeight)
			),
			TFixed(5., 0.),
			MIf(
				fselect(currentEvents, FLift(\events -> length(getLastEventsWithDescription(events)) > 0)),
				MCenterYIn(
					MText(_("Description"), [littleFont, MGrey(800)]),
					TFillXH(lineHeight)
				),
				TFillXH(lineHeight)
			),
			TFixed(5., 0.),
			createTimeColumn(_("Start time")),
			createTimeColumn(_("End time"))
		])
	]);

	makeAddButtonsMenu = \ev, evType -> {
		mainButton = MIconButton("more_horiz",
			nop,
			[MIconSize(22.), FillOpacity(1.0)],
			[]
		);

		items = map(evType.additionalActions, \act -> {
			MMenuCustomLine(
				MColsA([
					MCenterYIn(
						MIcon(act.icon, [MIconSize(22.), FillOpacity(1.0)]),
						TFixed(50., 44.)
					),
					MCenterYIn(
						MText(act.name, [littleFont]),
						TFixed(0., 44.)
					)
				]),
			[])
		});

		MCenterYIn(
			MMenu(
				mainButton,
				items,
				[MOnListClick(const(true), \index -> evType.additionalActions[index].action(ev.id))]
			),
			TFixed(50., lineHeight)
		)
	}

	isPrintingB = make(false);

	eventLine = \number, event -> {
		eventTypes = getValue(eventTypesB);
		eventType = findDef(eventTypes, \p -> p.name == event.eventType, makeCalendarEventDescription());
		eventName = if (event.title != "") event.title else event.eventType;
		eventDate = date2formatString(time2date(event.startDate), tableDateFormat);

		isStartDayOrEndDayTime = \time -> {
			time.hour == 0 && time.min == 0 || time.hour == 23 && time.min == 59;
		}
		createTimeLabel = \time -> {
			if (hideTimeInfo) TEmpty()
			else
				MCenterYIn(
					MText(if (time != "") lpad(time, "0", 5) else "", [littleFont]),
					TFixed(150., lineHeight)
				)
		}
		times = if (isStartDayOrEndDayTime(event.startDate) && isStartDayOrEndDayTime(event.endDate)) {
			Pair("", "");
		} else if (event.startDate.hour == event.endDate.hour && event.startDate.min == event.endDate.min) {
			Pair(getTimeOnlyString(event.startDate, false, false), "");
		} else {
			Pair(
				getTimeOnlyString(event.startDate, false, false),
				getTimeOnlyString(event.endDate, false, false)
			);
		}
		startTimeM = createTimeLabel(times.first);
		endTimeM = createTimeLabel(times.second);

		isEditActionNotEmpty = eventType.editAction != nop1;
		isSelectedB = fand(feq(currentLine, number), fnot(isPrintingB));
		MComponent(
			[MOnClick(\ -> nextDistinct(currentLine, number)), MEnabled(fand(fnot(isReadOnlyB), const(isEditActionNotEmpty)))],
			\__ -> MGroup([
				MGroup2(
					MSelect(isSelectedB, \isSelected ->
						TRectangle([MFill(if (isSelected) MCustomColor(0xFFECB3) else MWhite()), FillOpacity(1.0)], TFillXH(lineHeight + lineSeparatorHeight))),
					TRectangle([Fill(grey), FillOpacity(0.6)], TFillXH(lineSeparatorHeight))
					|> (\m -> MBorder(25., lineHeight, 25., 0., m))
				),
				MColsA([
					TFixed(25., 0.),
					MCenterYIn(
						MText(eventDate, [littleFont]),
						TFixed(80., lineHeight)
					),
					MCenterIn(
						MAvatar(eventType.icon, [MIconSize(40.0)]),
						TFixed(100., lineHeight)
					),
					MCenterYIn(
						MEllipsisText(eventName, [littleFont]),
						TFixed(200., lineHeight)
					),
					TFixed(5., 0.),
					MCenterYIn(
						MEllipsisText(event.description, [littleFont]),
						TFillXH(lineHeight)
					),
					TFixed(5., 0.),
					startTimeM,
					MIf(isSelectedB,
						MColsA([
							if (length(eventType.additionalActions) > 0) {
								if (length(eventType.additionalActions) == 1) {
									MCenterYIn(
										MIconButton(eventType.additionalActions[0].icon,
											\-> {eventType.additionalActions[0].action(event.id)},
											[MIconSize(22.), FillOpacity(1.0)],
											[]
										),
										TFixed(50., lineHeight)
									)
								} else {
									makeAddButtonsMenu(event, eventType)
								}
							} else {
								TFixed(0., 0.)
							},
							MCenterYIn(
								MIconButton("mode_edit",
									\-> {
										eventType.editAction(event.id)
									},
									[MIconSize(22.), FillOpacity(0.8)],
									[]
								),
								TFixed(50., lineHeight)
							),
							MCenterYIn(
								MIconButton("close",
									\-> {
										close = make(false);
										ShowMDialog(manager, close, [],
											eventDeletePopup(
												\-> next(close, true),
												\-> {
													eventType.deleteAction(event.id);
													next(close, true);
												}
											)
										);
									},
									[MIconSize(22.), FillOpacity(0.8)],
									[]
								),
								TFixed(50., lineHeight)
							),
							if (length(eventType.additionalActions) == 0)
								TFixed(50., 0.)
							else
								TFixed(0., 0.)
						]),
						endTimeM
					)
				])
			])
		)
	};

	rowsB = fselect(currentEvents, FLift(\eventUnsort -> {
		eventSorted = getLastEvents(eventUnsort);
		mapi(eventSorted, eventLine);
	}));

	contentM = MGroup2(
		TRectangle([Fill(white), FillOpacity(1.0)], TFillXY()),
		MSelect(rowsB, MLinesA)
	);

	addBackground = \m -> MFrame(0.0, 0.0, calendarTabMenuStyle.background, m);

	printCalendarButtonM = eitherMap(printButtonStyleM, \printButtonStyle -> {
		headerM = MLines2A(addBackground(titleTextM), columnNames);
		getPrintPages = \availableSize -> {
			rows = fgetValue(rowsB);
			rowHeight = lineHeight + lineSeparatorHeight;
			rowsPerPage = floor(availableSize.height / rowHeight);
			pagesCount = ceil(i2d(length(rows)) / i2d(rowsPerPage));
			generate(0, pagesCount, \i -> MLinesA(subrange(rows, i * rowsPerPage, rowsPerPage)));
		}
		style = if (printButtonStyle == []) calendarTabMenuStyle.icon else printButtonStyle;
		getPrintCalendarIconButton(manager, headerM, MEmpty(), getPrintPages, isPrintingB, style);
	}, MEmpty());

	headerM = addBackground(MColsYCenterA([titleTextM, tabsDropdownM, printCalendarButtonM]));

	MLinesA([headerM, columnNames, MScroll(contentM, TFillXY(), [])]);
}

reshuffleEvents(
	events : [CalendarEvent],
	startPos : int,
	endPos : int,
	eventToChange : CalendarEvent
	) -> [CalendarEvent] {

	if (startPos < endPos) {
		newPos = startPos + 1;
		newEvents = if (newPos < length(events)) {
			replace(events, startPos, events[newPos]);
		} else {
		//if we need to place an event outside the array - just insert an empty event into its place
			newEvents = replace(events, startPos, emptyEvent);
			arrayPush(newEvents, eventToChange);
		}
		reshuffleEvents(newEvents, newPos, endPos, eventToChange);
	} else {
		newEvents = replace(events, endPos, eventToChange);
		newEvents
	}
}

checkOneDayEventsPosition(
	events : [CalendarEvent],
	multiDayEventsPosition : DynamicBehaviour<[Pair<CalendarEvent, int>]>
	) -> [CalendarEvent] {

	printEvents = \evt -> println(foldi(evt, "", \index, res, it -> res + " #" + i2s(index) + " " + it.eventType));

	//To avoid an endless loop with an attempt to take one "seat" by two events
	eventsInWrongPositionWithoutCorrection = foldi(events, [], \i, res, item -> {
		index = either(findi(multiDayEventsPosition |> getValue, \p2 -> p2.first == item), -1);
		if (index != -1) {
			currentPosition = i;
			rigthPosition = getValue(multiDayEventsPosition)[index].second;
			arrayPush(res, Pair(currentPosition, rigthPosition))
		} else {
			res
		}
	});

	eventsInWrongPosition = foldi(events, [], \i, res, item -> {
		index = either(findi(multiDayEventsPosition |> getValue, \p2 -> p2.first == item), -1);
		if (index != -1) {
			currentPosition = i;
			rigthPosition = getValue(multiDayEventsPosition)[index].second;
			corrRightPosition = if (rigthPosition >= length(events)) {
				//if we already have a non-empty event in this position, we don't occupy it
				index2 = either(findi(eventsInWrongPositionWithoutCorrection, \p2 ->
					(p2.first != currentPosition && (p2.second == ^maxDisplayedEventsInOneDay - 1 || p2.second >= ^maxDisplayedEventsInOneDay ))), -1);
				if (index2 == -1) ^maxDisplayedEventsInOneDay - 1 else rigthPosition;
			} else {
				rigthPosition;
			}
			//println("c - " + i2s(currentPosition) + " r - " + i2s(rigthPosition) + " cr - " + i2s(corrRightPosition));
			if (currentPosition != corrRightPosition) {
				arrayPush(res, Pair(currentPosition, corrRightPosition))
			} else
				res
		} else {
			res
		}
	});

	if (length(eventsInWrongPosition) > 0) {
		//printEvents(events);
		newEvents = reshuffleEvents(events, eventsInWrongPosition[0].first, eventsInWrongPosition[0].second, events[eventsInWrongPosition[0].first]);
		//printEvents(newEvents);
		checkOneDayEventsPosition(newEvents, multiDayEventsPosition);
	} else {
		events
	}

}

//Multi-day events must go in one position through all the days.
//Therefore, before displaying, you need to know the positions of ALL events
checkMultiDayEventsPosition(
	dateMin : Date,
	dateMax : Date,
	allEvents : DynamicBehaviour<[CalendarEvent]>,
	multiDayEventsPosition : DynamicBehaviour<[Pair<CalendarEvent, int>]>
	) -> void {

	items = getValue(allEvents);
	minYear = dateMin.year;
	maxYear = dateMax.year;
	years = enumFromTo(minYear, maxYear);
	months = enumFromTo(1, 12);

	iter(years, \year -> {
		filteredByYear = filter(items, \item -> timeYearCheck(item.startDate.year, item.endDate.year, year));

		iter(months, \month -> {
			filteredByMonth = filter(filteredByYear, \item -> timeMonthCheck(item.startDate, item.endDate, Date(year, month, 1)));

			daysNum = getNumberOfDaysPerMonthInTheYear(year)[month];
			days = enumFromTo(1, daysNum);

			iter(days, \day -> {
				timeSort = \item : CalendarEvent -> item.startDate;

				currentDate = Date(year, month, day);

				dayEvents = filter(filteredByMonth, \item -> timeDayCheck(item.startDate, item.endDate, currentDate, day));

				events = sortEvents(dayEvents)
					|> \evs -> concat(evs, generate(0, ^maxDisplayedEventsInOneDay - length(evs), \__ -> emptyEvent));

				newEvents = checkOneDayEventsPosition(events, multiDayEventsPosition);
				iteri(newEvents, \i, item -> {
					isMultiDay = (time2date(item.startDate) != time2date(item.endDate));
					if (isMultiDay) {
						if (currentDate == time2date(item.startDate)) {
							index = either(findi(multiDayEventsPosition |> getValue, \p -> p.first == item), -1);
							if (index == -1)
								next(multiDayEventsPosition, arrayPush(getValue(multiDayEventsPosition), Pair(item, i)));
						}
					}
				});
			});
		});
	});
}

showDatePickerDialog(
	date : Date,
	manager : MaterialManager,
	onOk : (Date) -> void,
	dateMin : Date,
	dateMax : Date,
	markDays : (Date) -> bool
) -> void {
	value = make(date);
	close = make(false);
	ShowMDialog(manager, close, [MDialogClickOutToClose()],
		MDatePicker(
			value,
			[
				MDialogButtons([
					MButtonOk("enter", \ -> { next(close, true); onOk(getValue(value)) }),
					MButtonCancel("esc", \ -> next(close, true))
				]),
				MMarkDays(markDays), MDateMin(dateMin), MDateMax(dateMax)
			]
		)
	)
}

CalendarForEvents(
	allEvents : DynamicBehaviour<[CalendarEvent]>,
	currentEventTypes : DynamicBehaviour<[CalendarEventDecription]>,
	manager : MaterialManager,
	dateMin : Date,
	dateMax : Date,
	defaultMonthNumber : int,
	displayedEventsInOneDay : int,
	onlyOneSameTypeEventsByDay : bool,
	colorizeDayHeaders : bool,
	styles : [CalendarForEventsStyle]) -> Material {

	maxDisplayedEventsInOneDay := if (displayedEventsInOneDay <= 0) CalendarDefaultDisplayedEventsInOneDay else displayedEventsInOneDay;
	isOnlyOneSameTypeEventsByDay := onlyOneSameTypeEventsByDay;
	isColorizeDayHeaders := colorizeDayHeaders;
	hideAddEventButton = contains(styles, HideAddEventButton());
	calendarTabMenuStyle = extractStruct(styles, defaultCalendarTabMenuStyle);
	hideLegend = containsStruct(styles, CalendarHideEventTypesLegend());
	externalDateM = tryExtractStruct(styles, CalendarCurrentDate(make(nullDate)));
	showTodayButton = containsStruct(styles, CalendarShowTodayButton());
	menuTightWidth = containsStruct(styles, CalendarMenuTightWidth());
	menuAddEventButtonM = tryExtractStruct(styles, CalendarMenuAddEventButton([]));
	isReadOnlyB = extractStruct(styles, CalendarReadOnly(const(false))).isReadOnlyB;
	printButtonStyleM = maybeMap(tryExtractStruct(styles, CalendarPrintable([])), \p -> p.style);
	isTabsDropdown = containsStruct(styles, CalendarTabsDropdown());

	filteredEvents = make(getValue(allEvents));
	hiddenEventTypes = extractStruct(styles, HiddenEventTypes([])).types;
	choosedFilters = make(hiddenEventTypes);
	multiDayEventsPosition = make([]);

	tabOrder : [CalendarTab] = extractStruct(styles, TabOrder([YearTab(), MonthTab(), PlannedTab()])).tabs;
	//0 - year, 1 - month, 2 - planned - by default
	choosedTab = make(
		findiDef(
			tabOrder,
			eq(extractStruct(styles, DefaultTab(YearTab())).tab),
			0
	));
	tabColors = extractStruct(styles, TabColors(MWhite(), MGrey(300)));
	activeTabColor = tabColors.activeTabColor;
	nonActiveTabColor = tabColors.nonActiveTabColor;
	hideTabs = length(tabOrder) < 2;

	maxYear = dateMax.year;
	minYear = dateMin.year;

	choosedTabsColor = MCustomColor(0xFDB22B);

	monthValue = \year, month -> Date(year, month, 1);
	currentMonthNumber = make(defaultMonthNumber);
	currentDate = make(monthValue(stamp2date(timestamp()).year, defaultMonthNumber));

	width = calendarDateCellW * 7.0;
	height = calendarDateCellH * 7.0 + calendarDateNavSize;

	openPopupForDay = \date : Date, dayEvents : [CalendarEvent] -> {
		dayEventsPopup(date, dayEvents, currentEventTypes, manager, getValue(choosedFilters), 0, styles)
	}

	isPrintingB = make(false);
	yearB = fselect(currentDate, FLift(\date -> date.year));
	//It creates an image for one month (as in DatePicker)
	monthView = \monthNumber : int -> {
		datesSection = MColsA([
			TFixed(calendarPickerMarginCells, 0.0),
			MSelect(yearB, \year -> {
				month = monthValue(year, monthNumber);
				filteredEventsByMonthB = ffilter(filteredEvents, \item -> {
					timeYearCheck(item.startDate.year, item.endDate.year, year)
						&& timeMonthCheck(item.startDate, item.endDate, month)
				});
				MSelect(filteredEventsByMonthB, \events -> {
					MClickable(
						MCrop(
							const(zeroPoint),
							const(WidthHeight(width, height)),
							CalendarCells(
								manager, MPrimaryColor(), month, currentDate, dateMin, dateMax, isPrintingB,
								events, currentMonthNumber, openPopupForDay, currentEventTypes, isReadOnlyB
							)
						),
						\-> {
							nextDistinct(currentMonthNumber, monthNumber);
							nextDistinct(currentDate, Date(getValue(currentDate).year, monthNumber, 1));
							nextDistinct(choosedTab, findiDef(tabOrder, eq(MonthTab()), 0));
						}
					);
				})
			}),
			TFixed(calendarPickerMarginCells, 0.0)
		]);
		datesSection
	};

	monthViewsM = generate(1, 13, monthView);
	annualView = CalendarTabView(
		MFlexibleGrid(const(monthViewsM), [CenterAlign()]),
		\availableSize -> {
			monthsPerRow = floor(availableSize.width / (width + 2.0 * calendarPickerMarginCells));
			rowsPerPage = floor(availableSize.height / height);
			monthsPerPage = monthsPerRow * rowsPerPage;
			pagesCount = ceil(12.0 / i2d(monthsPerPage));
			generate(0, pagesCount, \i -> {
				MLines2(MFlexibleGrid(const(subrange(monthViewsM, i * monthsPerPage, monthsPerPage)), [CenterAlign()]), MFillY());
			});
		}
	);

	getTabName = \tab : CalendarTab -> {
		switch(tab) {
			YearTab(): _("Year");
			MonthTab(): _("Month");
			PlannedTab(): _("Planned");
			RangeTab(): _("Range");
			WeekTab(): _("Week");
		}
	}

	makeTabTitle = \tabNumber : int, tabType : CalendarTab -> {
		minWidth = 120.;
		maxWidth = 210.;
		tabHeight = 62.0;
		MClickable(
			MGroup2(
				MSelect(choosedTab, \tab ->
					TRectangle(
						[MFill(choosedTabsColor),
						FillOpacity(if (tab == tabNumber) 1.0 else 0.0)],
						TFillXYXY(minWidth, 5., maxWidth, 5.)
					)
				),
				MCenterIn(
					MSelect(choosedTab, \tab ->
						MParagraph(
							toUpperCase(getTabName(tabType)),
							[
								if (tab == tabNumber) activeTabColor else nonActiveTabColor,
								if (tab == tabNumber) MCustomFont(20., "RobotoMedium", primaryTextOpacity) else MTitle(),
								CenterAlign(), MWidth(maxWidth)
							]
						)
					),
					TFillXYXY(minWidth, tabHeight, maxWidth, tabHeight)
				)
			),
			\ -> nextDistinct(choosedTab, tabNumber)
		)
	}

	tabTitles = MCenterXIn(MCols(mapi(tabOrder, makeTabTitle)), TFillX());
	tabsDropdownButtonM = MSelect(choosedTab, \tab -> {
		name = getTabName(tabOrder[tab]);
		MTextButton(name, nop, [MGrey(200), MButtonRaised(), MButtonPaddings(14.0, 2.0, 10.0, 2.0), MRightIcon("arrow_drop_down", [])], []);
	});
	tabsDropdownM = if (!hideTabs && isTabsDropdown) {
		MDropDown(choosedTab, "", map(tabOrder, getTabName), [MCustomButton(tabsDropdownButtonM)]) |> MBorderEnd(14.0);
	} else {
		MEmpty();
	}

	makeLegend = \eventDescription -> {
		focused = make(false);
		eventIndex = either(findi(choosedFilters |> getValue, \p -> p == eventDescription.name), -1);
		clicked = make((eventIndex != -1));

		MBorder(0., 10., 0., 10.,
			MColsA([
				MMouseDownAround(None(), make(false), focused, nop,
					MGroup2(
						TCircle(10., [MFill(eventDescription.backColor)]),
						MSelect(clicked, \f-> if (f)
								MIconButton("visibility_off", \-> {
										index = either(findi(choosedFilters |> getValue, \p -> p == eventDescription.name), -1);
										if (index != -1) next(choosedFilters, removeIndex(getValue(choosedFilters), index));
										next(clicked, false);
									}, [MIconSize(10.)], []
								)
							else
								MSelect(focused, \f2-> if (f2)
									MIconButton("visibility", \-> {
											next(choosedFilters, arrayPush(getValue(choosedFilters), eventDescription.name));
											next(clicked, true);
										}, [MIconSize(10.)], []
									) else TEmpty()
								)
						)
					)
				),
				TFixed(16., 0.),
				MCenterYIn(
					MText(eventDescription.name, [MCaption()]),
					TFixed(0., 20.)
				),
				TFixed(30., 0.),
			])
		);
	}

	subMenuIconStyle = calendarTabMenuStyle.icon;

	monthTable = MonthTable(filteredEvents, currentEventTypes, currentDate, dateMin, dateMax, manager, multiDayEventsPosition, choosedFilters, styles);
	plannedTable = PlannedEventsTable(filteredEvents, currentEventTypes, manager, tabsDropdownM, styles);

	eventTypesForPrintingB = make([]);

	getLegend = \isPrint -> {
		// for printing show only types of visible events
		filteredTypesB = if (isPrint) {
			eventTypesForPrintingB;
		} else {
			currentEventTypes;
		}
		MFrame(0.0, 0.0, [MFill(MGrey(100))],
			MFlexibleGrid(fselect(filteredTypesB, FLift(\types -> map(types, makeLegend))), [CenterAlign()])
		);
	}

	legendM = getLegend(false);
	printLegendM = getLegend(true);

	addHeaderBackground = \m -> MFrame(0.0, 0.0, calendarTabMenuStyle.background, m);
	addHeaderBorder = \m -> MCenterX(m |> MBorderTopBottom(16.0));

	TabContent = \tab : CalendarTab -> {
		updateCurrentDate = \newDate : Date -> if (isDateBetween(newDate, dateMin, dateMax)) next(currentDate, newDate);
		customFontStyle = calendarTabMenuStyle.text;
		subMenuSize = TFillX();

		isSwipePaused = make(false);
		pauseSwipe = \ -> {
			next(isSwipePaused, true);
			timer(1000, \ -> next(isSwipePaused, false))
		}

		TabMenu = \items : [Material] -> {
			centeredItemsM = MCenterX(MColsYCenterA(items));
			addHeaderBackground(centeredItemsM);
		}
		TabBody = \body : Material -> MGroup2(
			TRectangle([Fill(white)], TFillXY()),
			MLines2(
				MScroll(body, TFillXY(), []),
				if (hideLegend) MEmpty() else legendM
			)
		);

		drawCalendarTabMenuText = \date, defaultText -> {
			text = either(extractStruct(styles, CalendarTabMenuText(\__, __ -> None())).getText(date, tab), defaultText);
			textM = MText(text, customFontStyle);
			if (menuTightWidth) textM |> MBorderLeftRight(32.0) else MCenterX(textM);
		}

		getTodayButton = \currentStartDate -> {
			if (showTodayButton) {
				isNotCurrentYearB = fselect(currentDate, FLift(\date -> date.year != currentStartDate.year));
				MShow(if (tab != YearTab()) fneq(currentDate, currentStartDate) else isNotCurrentYearB,
					MTextButton(
						_("Today"),
						\ -> updateCurrentDate(currentStartDate),
						[MGrey(200), MButtonRaised(), MButtonPaddings(28.0, 6.0, 28.0, 6.0)],
						[]
					) |> MBorderLeftRight(16.0)
				);
			} else {
				MEmpty();
			}
		}

		getAddEventButton = \currentStartDate -> {
			eitherMap(menuAddEventButtonM, \addEventButton -> {
				style = if (addEventButton.style == []) subMenuIconStyle else addEventButton.style;
				MShow(fnot(isReadOnlyB), MIconButton("add_circle", \ -> {
					curDate = getValue(currentDate);
					date = if (curDate == currentStartDate) getCurrentDate() else curDate;
					dateEvents = filter(getValue(filteredEvents), \item -> time2date(item.startDate) == date);
					dayEventsPopup(date, dateEvents, currentEventTypes, manager, getValue(choosedFilters), 0, styles);
				}, style, [MTooltipText(const(_("Add Event")))]));
			}, MEmpty());
		}

		getPrintButton = \headerM, getPrintPages -> {
			eitherMap(printButtonStyleM, \printButtonStyle -> {
				style = if (printButtonStyle == []) subMenuIconStyle else printButtonStyle;
				getPrintCalendarIconButton(manager, addHeaderBackground(headerM), printLegendM, getPrintPages, isPrintingB, style);
			}, MEmpty());
		}

		getAdditionalButtons = \currentStartDate, printButtonM -> {
			todayButtonM = getTodayButton(currentStartDate);
			addButtonM = getAddEventButton(currentStartDate);
			leftButtons = [
				todayButtonM,
				MSizeOf(tabsDropdownM),
				MSizeOf(addButtonM),
				MSizeOf(printButtonM),
				if (menuTightWidth) MFillX() else MEmpty()
			];
			rightButtons = [
				if (menuTightWidth) MFillX() else MEmpty(),
				MSizeOf(todayButtonM),
				tabsDropdownM,
				addButtonM,
				printButtonM
			];
			Pair(leftButtons, rightButtons);
		}

		tabContent = switch(tab) {
			YearTab(): {
				tabMenuTextM = MSelect(currentDate, \date -> {
					defaultText = i2s(date.year);
					drawCalendarTabMenuText(date, defaultText);
				});

				printButtonM = getPrintButton(addHeaderBorder(tabMenuTextM), annualView.getPrintPages);

				menuItems = unpair(getAdditionalButtons(getCurrentDate(), printButtonM), \leftButtons, rightButtons -> concatA([
					if (menuTightWidth) leftButtons else [],
					[MIconButton(
						"keyboard_arrow_left",
						\ -> updateCurrentDate(addYearsToDate(getValue(currentDate), -1)),
						subMenuIconStyle,
						[]
					)],
					if (!menuTightWidth) leftButtons else [],
					[tabMenuTextM],
					if (!menuTightWidth) rightButtons else [],
					[MIconButton(
						"keyboard_arrow_right",
						\ -> updateCurrentDate(addYearsToDate(getValue(currentDate), 1)),
						subMenuIconStyle,
						[]
					)],
					if (menuTightWidth) rightButtons else []
				]));

				MConstruct([
						make3Subscribe(yearB, currentEventTypes, filteredEvents, \year, types, events -> {
							filteredTypes = filter(types, \type -> {
								exists(events, \e -> (year >= e.startDate.year && year <= e.endDate.year) && e.eventType == type.name);
							});
							nextDistinct(eventTypesForPrintingB, filteredTypes);
						}),
						\ -> eitherMap(externalDateM, \externalDate -> {
							externalDateB = externalDate.currentDateB;
							fBidirectionalLink(currentDate, externalDateB,
								\curDate -> nextDistinct(externalDateB, curDate),
								\extDate -> updateCurrentDate(extDate),
							);
						}, nop)
					],
					MLines2(TabMenu(menuItems), TabBody(MLines2(MFixedY(20.), annualView.main)))
				);
			}

			MonthTab(): {
				getStartOfMonth = \d -> Date(d.year, d.month, 1);
				startOfCurrentMonth = getStartOfMonth(getCurrentDate());
				updateCurrentDate(getStartOfMonth(getValue(currentDate)));

				tabMenuTextM = MSelect(currentDate, \date -> {
					defaultText = i2s(date.year) + " " + toUpperCase(monthString(date, true));
					drawCalendarTabMenuText(date, defaultText);
				});

				printButtonM = getPrintButton(addHeaderBorder(tabMenuTextM), monthTable.getPrintPages);

				menuItems = unpair(getAdditionalButtons(startOfCurrentMonth, printButtonM), \leftButtons, rightButtons -> concatA([
					if (menuTightWidth) leftButtons else [],
					[
						MIconButton(
							"first_page",
							\ -> updateCurrentDate(addYearsToDate(getValue(currentDate), -1)),
							subMenuIconStyle,
							[]
						),
						MIconButton(
							"keyboard_arrow_left",
							\ -> updateCurrentDate(addMonthsToDate(getValue(currentDate), -1)),
							subMenuIconStyle,
							[]
						)
					],
					if (!menuTightWidth) leftButtons else [],
					[tabMenuTextM],
					if (!menuTightWidth) rightButtons else [],
					[
						MIconButton(
							"keyboard_arrow_right",
							\ -> updateCurrentDate(addMonthsToDate(getValue(currentDate), 1)),
							subMenuIconStyle,
							[]
						),
						MIconButton(
							"last_page",
							\ -> updateCurrentDate(addYearsToDate(getValue(currentDate), 1)),
							subMenuIconStyle,
							[]
						)
					],
					if (menuTightWidth) rightButtons else []
				]));
				MConstruct([
						make3Subscribe(currentDate, currentEventTypes, filteredEvents, \date, types, events -> {
							filteredTypes = filter(types, \type -> {
								exists(events, \e -> (
									(date.year == e.startDate.year && date.month == e.startDate.month) ||
									isDateBetween(date, time2date(e.startDate), time2date(e.endDate))
								) && e.eventType == type.name);
							});
							nextDistinct(eventTypesForPrintingB, filteredTypes);
						}),
						\ -> eitherMap(externalDateM, \externalDate -> {
							externalDateB = externalDate.currentDateB;
							fBidirectionalLink(currentDate, externalDateB,
								\curDate -> nextDistinct(externalDateB, curDate),
								\extDate -> updateCurrentDate(getStartOfMonth(extDate))
							);
						}, nop)
					],
					MLines([TabMenu(menuItems), TabBody(monthTable.main)])
				);
			}

			PlannedTab(): plannedTable;

			RangeTab(): {
				startDate = make(getCurrentDate());
				endDate = make(addDaysToDate(getValue(startDate), 7));
				// 0 - day, 1 - week, 2 - month
				rangeTypeB = make(0);

				dateButton = \dateB : DynamicBehaviour<Date>, pickMinDate : Date, pickMaxDate : Date -> MTextClickable(
						date2formatString(getValue(dateB), "%DD.%MM.%YYYY"),
						\ -> showDatePickerDialog(
							getValue(dateB),
							manager,
							\newDate -> nextDistinct(dateB, newDate),
							pickMinDate, pickMaxDate,
							\d -> isDateBetween(d, getValue(startDate), getValue(endDate))
						),
						customFontStyle,
						[MHighlightOnHover(const(true))]
				);

				types = map(["days", "weeks", "months"], \s -> "grouped by " + s);
				groupedByMenu = MDropDown(
					rangeTypeB, "", types,
					[MCustomButton(
						MSelect(rangeTypeB, \rangeType -> MTextButton(types[rangeType], nop, [MRightIcon("arrow_drop_down", []), MOrange(600)], []))
					)]
				);

				tabMenuContentM = MCenterX(
					MSelect2(startDate, endDate, \start, end ->
						MColsA([
							dateButton(startDate, dateMin, addDaysToDate(end, -1)),
							MBorder(4., 4., 4., 4., MText(" — ", customFontStyle)),
							dateButton(endDate, addDaysToDate(start, 1), dateMax),
						]),
					)
				);

				contentB = fselect4(startDate, endDate, rangeTypeB, filteredEvents, \start, end, rangeType, events -> {
					RangeView(
						manager, events, currentEventTypes, start, end,
						\date, dayEvents -> dayEventsPopup(date, dayEvents, currentEventTypes, manager, getValue(choosedFilters), rangeType, styles),
						dateMin, dateMax, rangeType, true, isPrintingB, tab, styles
					);
				});

				getPrintPages = \availableSize -> fgetValue(contentB).getPrintPages(availableSize);
				printButtonM = getPrintButton(tabMenuContentM, getPrintPages);

				menuItems = [
					MSizeOf(printButtonM),
					MSizeOf(groupedByMenu),
					MSizeOf(tabsDropdownM),
					tabMenuContentM,
					tabsDropdownM,
					groupedByMenu,
					printButtonM
				];

				MConstruct([
						make4Subscribe(startDate, endDate, currentEventTypes, filteredEvents, \start, end, eventTypes, events -> {
							filteredTypes = filter(eventTypes, \type -> {
								exists(events, \e -> (
									isDateBetween(time2date(e.startDate), start, end) ||
									isDateBetween(start, time2date(e.startDate), time2date(e.endDate))
								) && e.eventType == type.name);
							});
							nextDistinct(eventTypesForPrintingB, filteredTypes);
						}),
						\ -> eitherMap(externalDateM, \externalDate -> {
							externalDateB = externalDate.currentDateB;
							fBidirectionalLink(startDate, externalDateB,
								\date -> nextDistinct(externalDateB, date),
								\date -> {
									if (getValue(startDate) > date) {
										nextDistinct(startDate, date);
									} else if (getValue(endDate) < date) {
										nextDistinct(endDate, date);
									}
								}
							);
						}, nop)
					],
					MLines2A(TabMenu(menuItems), TabBody(MSelect(contentB, \content -> content.main)))
				);
			}

			WeekTab(): {
				// set current date as start of current week
				getStartOfWeek = \d -> addDaysToDate(d, -dayOfWeek(d));
				startOfCurrentWeek = getStartOfWeek(getCurrentDate());
				updateCurrentDate(startOfCurrentWeek);

				contentB = fselect2(currentDate, filteredEvents, FLift2(\start, events -> {
					RangeView(
						manager, events, currentEventTypes, start, addDaysToDate(start, 6),
						\date, dayEvents -> dayEventsPopup(date, dayEvents, currentEventTypes, manager, getValue(choosedFilters), 0, styles),
						dateMin, dateMax, 0, false, isPrintingB, tab, styles
					)
				}));

				tabMenuTextM = MSelect(currentDate, \date -> {
					defaultText = formatString("WEEK %1 OF %2", [i2s(getWeekOfYear(date, 0, true)), i2s(date.year)]);
					drawCalendarTabMenuText(date, defaultText);
				});

				getPrintPages = \availableSize -> fgetValue(contentB).getPrintPages(availableSize);
				printButtonM = getPrintButton(addHeaderBorder(tabMenuTextM), getPrintPages);

				menuItems = unpair(getAdditionalButtons(startOfCurrentWeek, printButtonM), \leftButtons, rightButtons -> {
					concatA([
						if (menuTightWidth) leftButtons else [],
						[
							MIconButton(
								"first_page",
								\ -> updateCurrentDate(addDaysToDate(getValue(currentDate), -28)),
								subMenuIconStyle,
								[]
							),
							MIconButton(
								"keyboard_arrow_left",
								\ -> updateCurrentDate(addDaysToDate(getValue(currentDate), -7)),
								subMenuIconStyle,
								[]
							)
						],
						if (!menuTightWidth) leftButtons else [],
						[tabMenuTextM],
						if (!menuTightWidth) rightButtons else [],
						[
							MIconButton(
								"keyboard_arrow_right",
								\ -> updateCurrentDate(addDaysToDate(getValue(currentDate), 7)),
								subMenuIconStyle,
								[]
							),
							MIconButton(
								"last_page",
								\ -> updateCurrentDate(addDaysToDate(getValue(currentDate), 28)),
								subMenuIconStyle,
								[]
							)
						],
						if (menuTightWidth) rightButtons else []
					])
				});

				MConstruct([
						make3Subscribe(currentDate, currentEventTypes, filteredEvents, \date, types, events -> {
							filteredTypes = filter(types, \type -> {
								exists(events, \e -> (
									isDateBetween(time2date(e.startDate), date, addDaysToDate(date, 6)) ||
									isDateBetween(date, time2date(e.startDate), time2date(e.endDate))
								) && e.eventType == type.name);
							});
							nextDistinct(eventTypesForPrintingB, filteredTypes);
						}),
						\ -> eitherMap(externalDateM, \externalDate -> {
							externalDateB = externalDate.currentDateB;
							fBidirectionalLink(currentDate, externalDateB,
								\curDate -> nextDistinct(externalDateB, curDate),
								\extDate -> updateCurrentDate(getStartOfWeek(extDate))
							);
						}, nop)
					],
					MLines2A(TabMenu(menuItems), TabBody(MSelect(contentB, \content -> content.main)))
				);
			}
		}

		MSwipe(
			tabContent,
			[
				MOnSwipeLeft(\point, delta -> {
					if (!getValue(isSwipePaused) && delta.x < -20. && getValue(choosedTab) != 0) {
						next(choosedTab, getValue(choosedTab) - 1);
						pauseSwipe();
					}
					true;
				}),
				MOnSwipeRight(\point, delta -> {
					if (!getValue(isSwipePaused) && delta.x > 20. && getValue(choosedTab) != length(tabOrder) - 1) {
						next(choosedTab, getValue(choosedTab) + 1);
						pauseSwipe();
					}
					true;
				})
			]
		)
	}

	MConstruct(
		[
			makeSubscribe(allEvents, \events -> {
				filters = getValue(choosedFilters);
				nextDistinct(filteredEvents, filter(events, \item -> !contains(filters, item.eventType)));
			}),
			makeSubscribe2(choosedFilters, \cf -> {
				nextDistinct(filteredEvents, filter(getValue(allEvents), \item -> !contains(cf, item.eventType)));
			}),
			makeSubscribe(filteredEvents, \__ -> {
				next(multiDayEventsPosition, []);
				checkMultiDayEventsPosition(dateMin, dateMax, filteredEvents, multiDayEventsPosition);
			})
		],
		MGroup([
			MLinesA([
				if (hideTabs || isTabsDropdown) MEmpty() else tabTitles,
				MBorderA(16., 0., 16., 0.,
					MSelect(choosedTab, \tabNumber -> TabContent(elementAt(tabOrder, tabNumber, YearTab())))
				)
			]),
			if (hideAddEventButton) MEmpty()
			else MShow(fnot(isReadOnlyB), MLines2A(
				TFillY(),
				MCols2A(
					TFillX(),
					MFloatingButton("add",
						[MBlack()],
						[MOnClick(\-> {
							today = stamp2date(timestamp());
							todayEvents = filter(getValue(filteredEvents), \item -> time2date(item.startDate) == today);
							dayEventsPopup(today, todayEvents, currentEventTypes, manager, getValue(choosedFilters), 0, styles)
						})]
					)
				)
			))
		])
	)
}

getPrintCalendarIconButton(
	manager : MaterialManager,
	headerM : Material,
	footerM : Material,
	getPrintPages : (WidthHeight) -> [Material],
	isPrintingB : DynamicBehaviour<bool>,
	style : [MIconButtonStyle]
) -> Material {
	showDialog = \ -> {
		closeB = make(false);
		pageSizeB = make(4);
		pageOrientationB = make(1);
		widthS = make("21.0");
		heightS = make("29.7");

		pagesB = make([]);

		headerHeightB = make(0.0);
		footerHeightB = make(0.0);

		printAvailableWidthB = fselect(TPrintPageSize, FLift(\s -> either(s, WidthHeight(0.0, 0.0)).width));

		onPrint = \ -> {
			maybeApply(getValue(TPrintPageSize), \size -> {
				headerHeight = getValue(headerHeightB);
				footerHeight = getValue(footerHeightB);
				availableSize = WidthHeight(size.width, size.height - headerHeight - footerHeight);
				pages = mapi(getPrintPages(availableSize), \i, p -> {
					MIfPrint(MLinesA([headerM, p, footerM]), MEmpty());
				});
				nextDistinct(pagesB, pages);
				showPrintDialog();
			});
		}

		isCustomSize = \s -> s >= length(MPrintPaperSizes) - 1 || s < 0;
		isCustomSizeB = fselect(pageSizeB, FLift(isCustomSize));

		dialogViewM = MConstruct([
				\ -> addEventListener(getStage(), "beforeprint", \ -> nextDistinct(isPrintingB, true)),
				\ -> addEventListener(getStage(), "afterprint", \ -> nextDistinct(isPrintingB, false)),
				make2SubscribeUns(pageSizeB, pageOrientationB, \s, o -> {
					if (isCustomSize(s)) {
						[
							makeSubscribe(fwh(fselect(widthS, FLift(\w -> cm2pixels(s2d(w)))), fselect(heightS, FLift(\h -> cm2pixels(s2d(h))))), \v -> {
								nextDistinct(TPrintPageSize, Some(v))
							})()
						]
					} else {
						size = MPrintPaperSizes[s].second;
						nextDistinct(TPrintPageSize, Some(if (o == 0) size else WidthHeight(size.height, size.width)));
						[];
					}
				}),
				\ -> \ -> nextDistinct(TPrintPageSize, None())
			],
			MAvailableWidth(MGroup2(
				MFixSize(
					MVisible(make(false),
						MAvailableWidth(
							MGroup2(MAttachHeight(headerM, headerHeightB), MAttachHeight(footerM, footerHeightB)),
							printAvailableWidthB
						)
					),
					MEmpty()
				),
				MLines([
					MDropDown(pageSizeB, "", map(MPrintPaperSizes, firstOfPair), [MLabel(_("Page Size:")), MWidth(-1.0)]) |> MBorderBottom(12.0),
					MShowAnimationHeight(
						isCustomSizeB,
						MCenterX(MBaselineCols([
							MTextInput(widthS, [MWidth(64.0)], []),
							MText(_("cm"), []),
							MIcon("close", []) |> (\f -> MBorder4(12.0, f)),
							MTextInput(heightS, [MWidth(64.0)], []),
							MText(_("cm"), [])
						])),
						[MAutoStart()]
					),
					MShowAnimationHeight(
						fnot(isCustomSizeB),
						MDropDown(pageOrientationB, "", [_("Portrait"), _("Landscape")], [MLabel(_("Orientation:")), MWidth(-1.0)]),
						[MAutoStart()]
					),
					MFixSize(MPrintPages(pagesB), MEmpty())
				])
			), const(260.0))
		);

		dialogStyle = [
			MDialogUseFrame(),
			MDialogClickOutToClose(),
			MDialogTitle(_("Print Dialog")),
			MDialogActions([
				MTextButton(_("CLOSE"), \ -> next(closeB, true), [], []),
				MTextButton(_("PREVIEW"), onPrint, [], []),
			])
		];

		ShowMDialog(manager, closeB, dialogStyle, dialogViewM);
	}
	
	MIconButton("print", showDialog, style, [MTooltipText(const(_("Print")))]);
}
