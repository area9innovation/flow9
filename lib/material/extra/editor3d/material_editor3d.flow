import material/material_ui;
import material/extra/filebrowser/material_filebrowser;

export {
	makeM3DEditor(manager : MaterialManager, style : [M3DEditorStyle]) -> M3DEditor;

		M3DEditorStyle ::= M3DEditorCamera, M3DEditorCameraPosition, M3DEditorStageSize, M3DEditorScene, M3DEditorTree, M3DEditorTreeOrder, M3DEditorSelected,
			M3DEditorAxesVisible, M3DEditorGridVisible, M3DEditorBoxesVisible, M3DEditorInteractive, M3DEditorPerspectiveCamera,
			M3DEditorLoadFn, M3DEditorSaveFn, M3DEditorExportFn, M3DEditorObjectPropertiesFn, M3DEditorGeometryPropertiesFn, M3DEditorMaterialPropertiesFn, M3DEditorParseFn, F3DStageStyle;

			M3DEditorCamera(camera : F3DObject); // Editor initial camera
			M3DEditorCameraPosition(position : DynamicBehaviour<Point3D>); // Get or set camera position
			M3DEditorCameraDistance(minDistance : double, maxDistance : double) -> F3DStageStyle { F3DCameraDistance(minDistance, maxDistance); }; // Bounds camera zoom
			M3DEditorStageSize(wh : DynamicBehaviour<WidthHeight>); // Inspect stage size
			M3DEditorScene(scene : DynamicBehaviour<Maybe<F3DObject>>); // Inspect or update currently loaded scene
			M3DEditorTree(tree : DynamicBehaviour<Transform<[MTreeNode<string>]>>); // Inspect MTree created for currently loaded scene
			M3DEditorTreeOrder(treeOrder : DynamicBehaviour<[MTreeOrderNode<string>]>); // Inspect MTree order created for currently loaded scene
			M3DEditorSelected(selected : DynamicBehaviour<Maybe<native>>); // Inspect or update currently selected 3d object

			M3DEditorAxesVisible(visible : DynamicBehaviour<bool>); // Inspect or update guide axes visibility
			M3DEditorGridVisible(visible : DynamicBehaviour<bool>); // Inspect or update guide grid visibility
			M3DEditorBoxesVisible(visible : DynamicBehaviour<bool>); // Inspect or update guide bounding boxes visibility
			M3DEditorPerspectiveCamera(perspective : DynamicBehaviour<bool>); // Switch between perspective and orthographic camera
			M3DEditorInteractive(interactive : DynamicBehaviour<bool>); // Enable or disable orbit controls

			M3DEditorLoadFn(fn : ((sceneJson : string) -> void) -> void); // Fn called in "Open Scene" menu item, default is openFileDialog
			M3DEditorSaveFn(fn : (sceneJson : string) -> void); // Fn called in "Save Scene" menu item, default is saveFileClient
			M3DEditorExportFn(fn : ref Maybe<(includeCamera : bool) -> string>); // Fn to obtain current scene Json
			M3DEditorObjectPropertiesFn(fn : ref Maybe<(object3d : native) -> [Pair<string, Material>]>); // Fn to obtain properties for any 3d object
			M3DEditorGeometryPropertiesFn(fn : ref Maybe<(object3d : native) -> [Pair<string, Material>]>); // Fn to obtain geometry properties for any 3d object
			M3DEditorMaterialPropertiesFn(fn : ref Maybe<(object3d : native) -> Transform<[Pair<string, Material>]>>); // Fn to obtain material properties for any 3d object
			M3DEditorParseFn(fn : (scene : F3DNative) -> void); // Fn called after parsing currently loaded scene

	M3DEditor(
		menu : MMenuPanel,
		stage : Material,
		tree : MTree,
		objectProperties : Material,
		geometryProperties : Material,
		materialProperties : Material
	);

	M3DEditorProperties2MTabs(editor : M3DEditor) -> Material;
}

M3DEditorProperties2MTabs(editor : M3DEditor) -> Material {
	MTabs(
		[
			MTab(
				editor.objectProperties
				|> (\f -> MBorder(24.0, 8.0, 24.0, 8.0, f)),
				const("OBJECT"),
				[]
			),
			MTab(
				editor.geometryProperties
				|> (\f -> MBorder(24.0, 8.0, 24.0, 8.0, f)),
				const("GEOMETRY"),
				[]
			),
			MTab(
				editor.materialProperties
				|> (\f -> MBorder(24.0, 8.0, 24.0, 8.0, f)),
				const("MATERIAL"),
				[]
			)
		],
		make(0),
		[MGrey(950)]
	)
}

M3DEditorState(
	manager : MaterialManager,
	wh : DynamicBehaviour<WidthHeight>,
	mutable stage : native,
	scene : DynamicBehaviour<Maybe<F3DObject>>,
	loading : DynamicBehaviour<bool>,
	tree : DynamicBehaviour<Transform<[MTreeNode<string>]>>,
	treeOrder : DynamicBehaviour<[MTreeOrderNode<string>]>,
	selected : DynamicBehaviour<Maybe<native>>,
	undoStack : DynamicBehaviour<[string]>,
	redoStack : DynamicBehaviour<[string]>,
	axes : DynamicBehaviour<bool>,
	grid : DynamicBehaviour<bool>,
	boxes : DynamicBehaviour<bool>,
	perspectiveCamera : DynamicBehaviour<bool>,
	orbitControls : DynamicBehaviour<bool>,
	loadFn : ((sceneJson : string) -> void) -> void,
	saveFn : (sceneJson : string) -> void,
	exportFn : ref Maybe<(includeCamera : bool) -> string>,
	objectPropertiesFn : ref Maybe<(object3d : native) -> [Pair<string, Material>]>,
	geometryPropertiesFn : ref Maybe<(object3d : native) -> [Pair<string, Material>]>,
	materialPropertiesFn : ref Maybe<(object3d : native) -> Transform<[Pair<string, Material>]>>,
	parseFn : (F3DNative) -> void,
	mutable ignoreUndo : bool
);

makeM3DEditorState(manager : MaterialManager, style : [M3DEditorStyle]) -> M3DEditorState {
	wh = extractStruct(style, M3DEditorStageSize(makeWH())).wh;
	stage = makeClip();
	scene = extractStruct(style, M3DEditorScene(make(None()))).scene;
	loading = extractStruct(style, F3DLoading(make(true))).loading;
	tree = extractStruct(style, M3DEditorTree(make(const([])))).tree;
	treeOrder = extractStruct(style, M3DEditorTreeOrder(make([]))).treeOrder;
	selected = extractStruct(style, M3DEditorSelected(make(None()))).selected;

	loadFn =
		extractStruct(
			style,
			M3DEditorLoadFn(
				\cb ->
					openFileDialog(1, ["*.txt", "*.json"], \ff ->
						iter(ff, \f ->
							readFileClient(
								f,
								"text",
								\s -> cb(s),
								println
							)
						)
					)
			)
		).fn;

	saveFn =
		extractStruct(
			style,
			M3DEditorSaveFn(
				\obj ->
					saveFileClient("scene.json", obj, "text")
			)
		).fn;

	exportFn =
		extractStruct(
			style,
			M3DEditorExportFn(ref None())
		).fn;

	objectPropertiesFn =
		extractStruct(
			style,
			M3DEditorObjectPropertiesFn(ref None())
		).fn;

	geometryPropertiesFn =
		extractStruct(
			style,
			M3DEditorGeometryPropertiesFn(ref None())
		).fn;

	materialPropertiesFn =
		extractStruct(
			style,
			M3DEditorMaterialPropertiesFn(ref None())
		).fn;

	parseFn =
		extractStruct(
			style,
			M3DEditorParseFn(nop1)
		).fn;

	axesVisible = extractStruct(style, M3DEditorAxesVisible(make(false))).visible;
	gridVisible = extractStruct(style, M3DEditorGridVisible(make(false))).visible;
	boxesVisible = extractStruct(style, M3DEditorBoxesVisible(make(false))).visible;
	perspectiveCamera = extractStruct(style, M3DEditorPerspectiveCamera(make(true))).perspective;
	orbitControls = extractStruct(style, M3DEditorInteractive(make(true))).interactive;

	M3DEditorState(
		manager,
		wh,
		stage,
		scene,
		loading,
		tree,
		treeOrder,
		selected,
		make([]),
		make([]),
		axesVisible,
		gridVisible,
		boxesVisible,
		perspectiveCamera,
		orbitControls,
		loadFn,
		saveFn,
		exportFn,
		objectPropertiesFn,
		geometryPropertiesFn,
		materialPropertiesFn,
		parseFn,
		false
	)
}

M3DEditorStyle2F3DStageStyle(style : [M3DEditorStyle]) -> [F3DStageStyle] {
	filtermap(style, \s -> {
		switch (s : M3DEditorStyle) {
			F3DStageStyle() : Some(s);
			default : None();
		}
	})
}

makeM3DEditor(manager : MaterialManager, style : [M3DEditorStyle]) -> M3DEditor {
	state = makeM3DEditorState(manager, style);
	state.objectPropertiesFn := Some(\obj -> F3DObjectProperties(state, obj));
	state.geometryPropertiesFn := Some(\obj -> F3DGeometryProperties(state, obj));
	state.materialPropertiesFn := Some(\obj -> F3DMaterialProperties(state, obj));
	cameraDistance = extractStruct(style, F3DCameraDistance(0.0, 1000.0));

	scene =
		F3DName(
			F3DChildren(
				F3DScene(
					feitherMap(
						state.scene,
						\c -> [
							F3DObject2Json(
								F3DMutable(
									fif(
										fOr(
											feq(flength(state.treeOrder), 0),
											fsubselect(felementAt(state.treeOrder, const(0), const(MTreeOrderNode("", make([])))), FLift(\to ->
												feq(flength(to.children), 0)
											)),
										),
										const(c),
										fsubselect(felementAt(state.treeOrder, const(0), const(MTreeOrderNode("", make([])))), FLift(\to ->
											fselect(felementAt(to.children, const(0), const(MTreeOrderNode("", make([])))), FLift(\sc ->
												makeF3DScene(state, sc)
											))
										)),
									)
								),
								state.exportFn
							)
						],
						const([])
					)
				),
				\c -> {
					if (getValue(state.loading)) {
						uns = ref nop;
						uns := makeSubscribe2(state.loading, \l -> {
							if (!l) {
								next(state.tree, farray(makeF3DTree(state, c, const(true))));
								^uns();
							}
						})();
					} else {
						next(state.tree, farray(makeF3DTree(state, c, const(true))));
					}

					state.parseFn(c)
				}
			),
			const("Scene")
		);

	cameraPosition =
		extractStruct(
			style,
			M3DEditorCameraPosition(make(Point3D(0.0, 0.0, (cameraDistance.max - cameraDistance.min) / 2.0)))
		).position;
	camera =
		F3DLocalPosition(
			F3DInspectLocalPosition(
				extractStruct(
					style,
					M3DEditorCamera(
						F3DIf(
							state.perspectiveCamera,
							F3DPerspectiveCamera(
								const(50.0),
								fdivide(fwidth(state.wh), fheight(state.wh)),
								const(0.01),
								const(cameraDistance.max * 2.0)
							),
							F3DOrthographicCamera(
								fmultiply(const(cameraDistance.max / 2.0), fdivide(fwidth(state.wh), fheight(state.wh))),
								const(cameraDistance.max / 2.0),
								const(0.01),
								const(cameraDistance.max * 2.0),
								const(1.0)
							)
						)
					)
				).camera,
				cameraPosition,
				const(true)
			),
			cameraPosition
		);

	menu =
		MMenuPanel(
			[
				MMenu(
					MTextButton("File", nop, [], []),
					[
						MMenuSingleLine(
							"Open Scene",
							[
								MPrimaryAction(MIcon("folder_open", [])),
								MOnClick(\ ->
									state.loadFn(\s -> {
										next(state.scene, None());

										clear3DStageObjectCache(state.stage);

										next(state.undoStack, []);
										next(state.redoStack, []);

										next(state.scene, Some(F3DJsonObject(s)));
									})
								)
							]
						),
						MMenuSingleLine(
							"Save Scene",
							[
								MPrimaryAction(MIcon("save", [])),
								MOnClick(\ -> maybeApply(^(state.exportFn), \fn -> state.saveFn(fn(true))))
							]
						)
					],
					[
						MMenuIndent()
					]
				),
				MMenu(
					MTextButton("Edit", nop, [], []),
					[
						MMenuSingleLine(
							"Undo",
							[
								MOnClick(\ -> applyF3DUndo(state)),
								MAdditionalText("Ctrl+Z"),
								MShortcut("Ctrl+Z"),
								MEnabled(fneq(flength(state.undoStack), 0))
							]
						),
						MMenuSingleLine(
							"Redo",
							[
								MOnClick(\ -> applyF3DRedo(state)),
								MAdditionalText("Ctrl+Shift+Z"),
								MShortcut("Ctrl+Shift+Z"),
								MEnabled(fneq(flength(state.redoStack), 0))
							]
						)
					],
					[]
				),
				MMenu(
					MTextButton("View", nop, [], []),
					[
						MMenuSingleLine(
							"Axes",
							[
								MPrimaryAction(MIf(state.axes, MIcon("check_box", []), MIcon("check_box_outline_blank", []))),
								MOnClick(\ -> reverseBehaviour(state.axes)),
								MAdditionalText("A"),
								MShortcut("A")
							]
						),
						MMenuSingleLine(
							"Grid",
							[
								MPrimaryAction(MIf(state.grid, MIcon("grid_on", []), MIcon("grid_off", []))),
								MOnClick(\ -> reverseBehaviour(state.grid)),
								MAdditionalText("G"),
								MShortcut("G")
							]
						),
						MMenuSingleLine(
							"Boxes",
							[
								MPrimaryAction(MIf(state.boxes, MIcon("check_box", []), MIcon("check_box_outline_blank", []))),
								MOnClick(\ -> reverseBehaviour(state.boxes)),
								MAdditionalText("B"),
								MShortcut("B")
							]
						),
						MMenuCustomLine(
							MDynamicText(fif(state.perspectiveCamera, const("Perspective Camera"), const("Orthographic Camera")), [MSubheading()])
							|> MBorderTop(8.0),
							[
								MPrimaryAction(MIf(state.perspectiveCamera, MIcon("visibility", []), MIcon("videocam", []))),
								MOnClick(\ -> reverseBehaviour(state.perspectiveCamera)),
								MHeight(32.0)
							]
						),
						MMenuSingleLine(
							"Interactive",
							[
								MPrimaryAction(MIf(state.orbitControls, MIcon("check_box", []), MIcon("check_box_outline_blank", []))),
								MOnClick(\ -> reverseBehaviour(state.orbitControls))
							]
						)
					],
					[
						MMenuIndent()
					]
				),
				MMenu(
					MTextButton("Add", nop, [], []),
					[
						MMenuSingleLine(
							"Group",
							[
								MOnClick(\ -> addF3DNativeObject(state, make3DScene(), "Group"))
							]
						),
						MSeparatorLine(),
						MMenuSingleLine(
							"Plane",
							[
								MOnClick(\ ->
									addF3DNativeObject(
										state,
										make3DMesh(
											make3DPlaneGeometry(1.0, 1.0, 1, 1),
											[make3DMeshStandardMaterial(white, [])],
											[]
										),
										"Plane"
									)
								)
							]
						),
						MMenuSingleLine(
							"Box",
							[
								MOnClick(\ ->
									addF3DNativeObject(
										state,
										make3DMesh(
											make3DBoxGeometry(1.0, 1.0, 1.0, 1, 1, 1),
											[make3DMeshStandardMaterial(white, [])],
											[]
										),
										"Box"
									)
								)
							]
						),
						MMenuSingleLine(
							"Circle",
							[
								MOnClick(\ ->
									addF3DNativeObject(
										state,
										make3DMesh(
											make3DCircleGeometry(1.0, 32, 0.0, 2.0 * PI),
											[make3DMeshStandardMaterial(white, [])],
											[]
										),
										"Circle"
									)
								)
							]
						),
						MMenuSingleLine(
							"Ring",
							[
								MOnClick(\ ->
									addF3DNativeObject(
										state,
										make3DMesh(
											make3DRingGeometry(0.5, 1.0, 32, 0.0, 2.0 * PI),
											[make3DMeshStandardMaterial(white, [])],
											[]
										),
										"Ring"
									)
								)
							]
						),
						MMenuSingleLine(
							"Cylinder",
							[
								MOnClick(\ ->
									addF3DNativeObject(
										state,
										make3DMesh(
											make3DCylinderGeometry(1.0, 1.0, 1.0, 32, 1, false, 0.0, 2.0 * PI),
											[make3DMeshStandardMaterial(white, [])],
											[]
										),
										"Cylinder"
									)
								)
							]
						),
						MMenuSingleLine(
							"Sphere",
							[
								MOnClick(\ ->
									addF3DNativeObject(
										state,
										make3DMesh(
											make3DSphereGeometry(1.0, 32, 32, 0.0, 2.0 * PI, 0.0, PI),
											[make3DMeshStandardMaterial(white, [])],
											[]
										),
										"Sphere"
									)
								)
							]
						),
						MSeparatorLine(),
						MMenuSingleLine(
							"Ambient Light",
							[
								MOnClick(\ ->
									addF3DNativeObject(
										state,
										make3DAmbientLight(white, 1.0),
										"Ambient Light"
									)
								)
							]
						),
						MMenuSingleLine(
							"Point Light",
							[
								MOnClick(\ ->
									addF3DNativeObject(
										state,
										make3DPointLight(white, 1.0, 0.0, 1.0),
										"Point Light"
									)
								)
							]
						),
						MMenuSingleLine(
							"Spot Light",
							[
								MOnClick(\ ->
									addF3DNativeObject(
										state,
										make3DSpotLight(white, 1.0, 0.0, 0.314, 0.0, 1.0),
										"Spot Light"
									)
								)
							]
						),
						MSeparatorLine(),
						MMenuSingleLine(
							"External Object",
							[
								MOnClick(\ ->
									openFileDialog(1, ["*.obj"], \ff ->
										iter(ff, \f ->
											readFileClient(
												f,
												"text",
												\s -> {
													openFileDialog(1, ["*.mtl"], \ff2 ->
														iter(ff2, \f2 ->
															readFileClient(
																f2,
																"text",
																\s2 -> {
																	addF3DNativeObject(
																		state,
																		make3DObjectFromObj(state.stage, s, s2),
																		"Object"
																	);
																},
																println
															)
														)
													);
												},
												println
											)
										)
									)
								)
							]
						)
					],
					[]
				)
			],
			[]
		);

	stage =
		T3DStage(
			F3DScene(const([
				F3DInteractive(F3DVisible(F3DAxesHelper(cameraDistance.max), state.axes), [], const(false)),
				F3DInteractive(F3DVisible(F3DGridHelper(cameraDistance.max * 2.0, 50, 0xaaaaaa, 0xffffff), state.grid), [], const(false)),
				F3DVisible(scene, fnot(state.loading))
			])),
			camera,
			TFillXY(),
			M3DEditorStyle2F3DStageStyle(
				replaceStructMany(
					style,
					[
						extractStruct(style, F3DTransformControlsEnabled(const(true))),
						F3DLoading(state.loading),
						F3DOrbitControlsEnabled(state.orbitControls)
					]
				)
			)
		)
		|> (\f -> MInspect([ISize(state.wh)], f))
		|> (\f ->
			MCopySize(
				f,
				\sz -> MGetFocusGroup(\parent -> MFrame(0.0, 0.0, [MThemeFill(parent, MThemedColor(MGrey(200), MGrey(800)))], sz)),
				false
			)
		)
		|> (\f ->
			MCopySize(
				f,
				\sz -> MCenterIn(MShow(state.loading, MProgressCircle([])), sz),
				true
			)
		)
		|> (\f ->
			MInteractive(
				[
					KeyDown(\ke -> {
						if (ke.keycode == KEY_Q) {
							set3DTransformControlsSpace(state.stage, !is3DTransformControlsSpaceLocal(state.stage));
						} else if (ke.keycode == KEY_CTRL) {
							set3DTransformControlsTranslationSnap(state.stage, 100.0);
							set3DTransformControlsRotationSnap(state.stage, 15.0);
						} else if (ke.keycode == KEY_W) {
							set3DTransformControlsMode(state.stage, "translate");
						} else if (ke.keycode == KEY_E) {
							set3DTransformControlsMode(state.stage, "rotate");
						} else if (ke.keycode == KEY_R) {
							set3DTransformControlsMode(state.stage, "scale");
						} else if (ke.keycode == KEY_NUMPAD_ADD) {
							set3DTransformControlsSize(state.stage, get3DTransformControlsSize(state.stage) + 0.1);
						} else if (ke.keycode == KEY_NUMPAD_SUBTRACT) {
							set3DTransformControlsSize(state.stage, max(get3DTransformControlsSize(state.stage) - 0.1, 0.1));
						} else if (ke.keycode == KEY_X) {
							set3DTransformControlsShowX(state.stage, !get3DTransformControlsShowX(state.stage));
						} else if (ke.keycode == KEY_Y) {
							set3DTransformControlsShowY(state.stage, !get3DTransformControlsShowY(state.stage));
						} else if (ke.keycode == KEY_Z && !ke.ctrl && !ke.shift) {
							set3DTransformControlsShowZ(state.stage, !get3DTransformControlsShowZ(state.stage));
						} else if (ke.keycode == KEY_SPACE) {
							set3DTransformControlsEnabled(state.stage, !get3DTransformControlsEnabled(state.stage));
						}
					}),
					KeyUp(\ke -> {
						if (ke.keycode == KEY_CTRL) {
							set3DTransformControlsTranslationSnap(state.stage, 0.0);
							set3DTransformControlsRotationSnap(state.stage, 0.0);
						}
					}),
				],
				f
			)
		);

	tree =
		MTree(
			fsubselect(state.tree, idfn |> FLift),
			[
				MTreeHideSeparators(),
				MTreeOrder(state.treeOrder),
				MTreeOnOrderChange(\t -> {
					if (length(t) > 0 && length(getValue(t[0].children)) > 0) {
						appendF3DUndo(state);
					}
				})
			]
		);

	objectProperties =
		MSelect(state.selected, \o ->
			eitherMap(
				o,
				\c ->
					eitherMap(
						^(state.objectPropertiesFn),
						\fn ->
							map(fn(c), \p ->
								MProportionBaselineCols([
									Pair(const(0.25), MGroup2(TFillX(), MText(p.first + ": ", []))),
									Pair(const(0.75), p.second)
								])
							)
							|> MLines,
						TEmpty()
					),
				TEmpty()
			)
		);

	geometryProperties =
		MSelect(state.selected, \o ->
			eitherMap(
				o,
				\c ->
					eitherMap(
						^(state.geometryPropertiesFn),
						\fn ->
							map(fn(c), \p ->
								MProportionBaselineCols([
									Pair(const(0.25), MGroup2(TFillX(), MText(p.first + ": ", []))),
									Pair(const(0.75), p.second)
								])
							)
							|> MLines,
						TEmpty()
					),
				TEmpty()
			)
		);

	materialProperties =
		MSelect(state.selected, \o ->
			eitherMap(
				o,
				\c ->
					eitherMap(
						^(state.materialPropertiesFn),
						\fn ->
							SelectMLines(fn(c), \__, __, p ->
								MProportionBaselineCols([
									Pair(const(0.25), MGroup2(TFillX(), MText(p.first + ": ", []))),
									Pair(const(0.75), p.second)
								])
							),
						TEmpty()
					),
				TEmpty()
			)
		);

	M3DEditor(
		menu,
		stage,
		tree,
		objectProperties,
		geometryProperties,
		materialProperties
	);
}

printF3DChildren(id : string, object : F3DNative) -> F3DNative {
	switch (object : F3DNative) {
		F3DNativeScene(clip, items): {
			println(id + (if (strlen(id) > 0) " " else "") + get3DObjectType(clip) + " " + get3DObjectName(clip));

			F3DNativeScene(clip, fmapi(items, \i, it -> printF3DChildren(id + (if (strlen(id) > 0) " " else "") + i2s(i), it)));
		}
		F3DNativeObject(clip): {
			println(id + (if (strlen(id) > 0) " " else "") + get3DObjectType(clip) + " " + get3DObjectName(clip));

			object;
		}
		F3DNativeMutable(innerObject): {
			F3DNativeMutable(fselect(innerObject, FLift(\it -> printF3DChildren(id, it))));
		}
		default: {
			object;
		}
	}
}

makeF3DTreeNode(
	state : M3DEditorState,
	clip : native,
	children : (isVisible : Transform<bool>)  -> Transform<[MTreeNode<string>]>,
	visibleEnabled : Transform<bool>,
) -> MTreeNode<string> {
	sel = make(is3DTransformControlsAttached(state.stage, clip));
	name = make(get3DObjectName(clip));
	isVisible = make(get3DObjectVisible(clip));
	matrixLock = ref true;
	matrixUns = ref nop;

	MTreeNode(
		get3DObjectId(clip),
		\__ ->
			MBaselineCols([
				MConstruct(
					[
						\ -> {
							nextDistinct(sel, is3DTransformControlsAttached(state.stage, clip));
							nextDistinct(name, get3DObjectName(clip));
							nextDistinct(isVisible, get3DObjectVisible(clip));

							\ -> ^matrixUns();
						},
						\ -> add3DEventListener(clip, "matrix", \ -> {
							^matrixUns();

							if (getValue(sel) && ^matrixLock) {
								matrixLock := false;
								appendF3DUndo(state);
							}

							matrixUns := interruptibleTimer(300, \ -> matrixLock := true);
						}),
						\ -> add3DEventListener(clip, "change", \ -> {
							deferred(\ -> {
								nextDistinct(name, get3DObjectName(clip));
								nextDistinct(isVisible, get3DObjectVisible(clip));
							});
						}),
						\ -> add3DEventListener(clip, "attached", \ -> nextDistinct(sel, true)),
						\ -> add3DEventListener(clip, "detached", \ -> nextDistinct(sel, false)),
						make2Subscribe(sel, state.boxes, \sl, boxes -> {
							^matrixUns();
							matrixUns := nop;
							matrixLock := true;

							if (sl) {
								appendF3DUndo(state);
								attach3DTransformControls(state.stage, clip);
								next(state.selected, Some(clip));
							} else {
								if (getValue(state.selected) == Some(clip)) {
									next(state.selected, None());
								}
							}

							if (sl && boxes) {
								attach3DBoxHelper(state.stage, clip);
							} else {
								detach3DBoxHelper(state.stage, clip);
							}
						})
					],
					MCheckBox(
						TEmpty(),
						isVisible,
						[
							MIconButtonBorder(6.0),
							MIconSize(16.0),
							MOnNewValue(\v -> {
								if (v != get3DObjectVisible(clip)) {
									appendF3DUndo(state);
								}

								set3DObjectVisible(clip, v);
							}),
							MEnabled(visibleEnabled)
						]
					)
				),
				MIf(
					sel,
					MTextInput(
						name,
						[
							MCondensed(true),
							MCustomTextStyle([MCaptionSolid()]),
							MInputBorders(0., 0., 0., 4.)
						],
						[
							MInputFilter(\c, f -> {
								if (!f) {
									appendF3DUndo(state);
									set3DObjectName(clip, c);
									get3DObjectName(clip);
								} else {
									c;
								}
							})
						]
					),
					MGroup2(TFillX(), MDynamicParagraph(name, [MCaptionSolid()]))
				),
				MFixedX(8.0),
				MText(get3DObjectType(clip), [MCaption1()]),
				MFixedX(4.0),
				MVisible(
					sel,
					MIconButton(
						"delete",
						\ -> {
							removeF3DSceneId(state.treeOrder, get3DObjectId(clip));
						},
						[
							MIconButtonBorder(6.0),
							MIconSize(16.0)
						],
						[
							MEnabled(sel)
						]
					)
				)
			]),
		children(fand(visibleEnabled, isVisible)),
		[
			MExpanded(make(true)),
			MTreeNodeCustomHighlighter(\wh -> MSelect(state.manager.white, \w -> TFrame(0., 4., [MFill(if (w) MGrey(300) else MGrey(700))], TSized(wh)))),
			MSelected(sel)
		]
	)
}

makeF3DTree(
	state : M3DEditorState,
	object : F3DNative,
	visibleEnabled : Transform<bool>
) -> Transform<MTreeNode<string>> {
	switch (object : F3DNative) {
		F3DNativeScene(clip, items): {
			map(get3DObjectStage(clip), \s -> {
				state.stage ::= s;
				enable3DStageObjectCache(state.stage);
			});

			const(makeF3DTreeNode(state, clip, \isVisible -> fsubmap(items, \it -> makeF3DTree(state, it, isVisible)), visibleEnabled));
		}
		F3DNativeObject(clip): {
			map(get3DObjectStage(clip), \s -> {
				state.stage ::= s;
				enable3DStageObjectCache(state.stage);
			});

			const(makeF3DTreeNode(state, clip, \isVisible -> const([]), visibleEnabled));
		}
		F3DNativeMutable(innerObject): {
			fsubselect(innerObject, FLift(\it -> makeF3DTree(state, it, visibleEnabled)));
		}
		F3DNativeOnLoad(innerObject, onLoad): {
			makeF3DTree(state, innerObject, visibleEnabled)
		}
		F3DEmpty(): {
			const(MTreeNode("", \__ -> TEmpty(), const([]), []))
		}
	}
}

makeF3DScene(state : M3DEditorState, node : MTreeOrderNode<string>) -> F3DNative {
	if (node.content == "") {
		F3DEmpty()
	} else {
		clips = get3DObjectById(state.stage, node.content);

		if (length(clips) > 0)
			F3DNativeScene(clips[0], fmap(node.children, \c -> makeF3DScene(state, c)))
		else
			F3DEmpty();
	}
}

addF3DNativeObject(state : M3DEditorState, clip : native, name : string) -> void {
	t = getValue(state.treeOrder);

	if (length(t) > 0 && length(getValue(t[0].children)) > 0) {
		set3DObjectName(clip, name);

		node = getValue(t[0].children)[0];
		scene = get3DObjectById(state.stage, node.content)[0];

		add3DChild(scene, clip);

		attach3DTransformControls(state.stage, clip);

		if (fgetValue(state.boxes)) {
			attach3DBoxHelper(state.stage, clip);
		}
	}
}

removeF3DSceneId(nodes : DynamicBehaviour<[MTreeOrderNode<string>]>, id : string) -> void {
	nextDistinct(
		nodes,
		filter(getValue(nodes), \n -> {
			removeF3DSceneId(n.children, id);
			n.content != id;
		})
	);
}

make3DPropertyTextInput(state : M3DEditorState, object : native, material : native, getValueFn : (native) -> string, setValueFn : (native, string) -> void) -> Material {
	value = make(getValueFn(object));

	MConstruct(
		[
			\ -> add3DEventListener(object, "change", \ -> {
				nextDistinct(value, getValueFn(object));
			})
		],
		MTextInput(
			value,
			[MCondensed(true)],
			[
				MInputFilter(\c, f -> {
					if (!f && c != getValueFn(object)) {
						appendF3DUndo(state);
						setValueFn(object, c);
						getValueFn(object);
					} else {
						c;
					}
				})
			]
		)
	)
}

make3DPropertyTextInputDouble(state : M3DEditorState, object : native, material : native, getValueFn : (native) -> double, setValueFn : (native, double) -> void) -> Material {
	value = make(d2s(getValueFn(material)));

	MConstruct(
		[
			\ -> add3DEventListener(object, "change", \ -> {
				nextDistinct(value, d2s(getValueFn(material)));
			})
		],
		MTextInput(
			value,
			[MCondensed(true)],
			[
				MInputFilter(\c, f -> {
					if (!f && s2d(c) != getValueFn(material)) {
						appendF3DUndo(state);
						setValueFn(material, s2d(c));
						d2s(getValueFn(material));
					} else {
						c;
					}
				})
			]
		)
	)
}

make3DPropertyParameterInputDouble(state : M3DEditorState, object : native, material : native, name : string) -> Material {
	make3DPropertyTextInput(
		state,
		object,
		material,
		\o -> get3DObjectParameter(material, name, "0"),
		\o, c -> set3DObjectParameter(material, name, d2s(s2d(c)))
	);
}

make3DPropertyParameterInputInteger(state : M3DEditorState, object : native, material : native, name : string) -> Material {
	make3DPropertyTextInput(
		state,
		object,
		material,
		\o -> get3DObjectParameter(material, name, "0"),
		\o, c -> set3DObjectParameter(material, name, d2s(s2d(c)))
	);
}

make3DPropertyColorPicker(state : M3DEditorState, object : native, material : native, getValueFn : (native) -> int, setValueFn : (native, int) -> void) -> Material {
	color = make(MCustomColor(getValueFn(material)));

	MConstruct(
		[
			\ -> add3DEventListener(object, "change", \ -> {
				next(color, MCustomColor(getValueFn(material)));
			})
		],
		MGroup2(
			TFillX(),
			MSelect(color, \c ->
				MTextButton(
					"PICK",
					\ -> {
						close = make(false);

						ShowMDialog(
							state.manager,
							close,
							[MDialogClickOutToCancel(color)],
							MColorPicker(
								color,
								[
									MaterialColorPicker(),
									MDialogButtons([
										MTextButton(
											_("APPLY"),
											\ -> setValueFn(material, MColor2int(getValue(color))),
											[],
											[MShortcut("enter")]
										),
										MTextButton(_("CLOSE"), \ -> next(close, true), [], [MShortcut("esc")]),
									])
								]
							)
						)
					},
					[
						c,
						MButtonPaddings(8.0, 4.0, 8.0, 4.0),
						MButtonRaised()
					],
					[]
				)
			)
		)
	);
}

set3DObjectParameter(object : native, name : string, value : string) -> void {
	set3DObjectParameters(object, [[name, value]]) |> ignore;
}

make3DPropertyVectorInput(
	state : M3DEditorState,
	object : native,
	getXValueFn : (native) -> double,
	getYValueFn : (native) -> double,
	getZValueFn : (native) -> double,
	setXValueFn : (native, double) -> void,
	setYValueFn : (native, double) -> void,
	setZValueFn : (native, double) -> void,
	add3DObjectListenerFn : (native, (double, double, double) -> void) -> () -> void
) -> Material {
	x = make(d2s(getXValueFn(object)));
	y = make(d2s(getYValueFn(object)));
	z = make(d2s(getZValueFn(object)));

	MConstruct(
		[
			\ -> add3DObjectListenerFn(object, \nx, ny, nz -> {
				nextDistinct(x, nx |> d2s);
				nextDistinct(y, ny |> d2s);
				nextDistinct(z, nz |> d2s);
			})
		],
		MBaselineCols([
			MTextInput(
				x,
				[MCondensed(true)],
				[
					MInputFilter(\c, f -> {
						if (!f && s2d(c) != getXValueFn(object)) {
							appendF3DUndo(state);
							setXValueFn(object, s2d(c));
							getXValueFn(object) |> d2s;
						} else {
							c;
						}
					})
				]
			),
			MFixedX(16.0),
			MTextInput(
				y,
				[MCondensed(true)],
				[
					MInputFilter(\c, f -> {
						if (!f && s2d(c) != getYValueFn(object)) {
							appendF3DUndo(state);
							setYValueFn(object, s2d(c));
							getYValueFn(object) |> d2s;
						} else {
							c;
						}
					})
				]
			),
			MFixedX(16.0),
			MTextInput(
				z,
				[MCondensed(true)],
				[
					MInputFilter(\c, f -> {
						if (!f && s2d(c) != getZValueFn(object)) {
							appendF3DUndo(state);
							setZValueFn(object, s2d(c));
							getZValueFn(object) |> d2s;
						} else {
							c;
						}
					})
				]
			),
		])
	);
}

make3DPropertyCheckBox(state : M3DEditorState, object : native, getValueFn : (native) -> bool, setValueFn : (native, bool) -> void) -> Material {
	value = make(getValueFn(object));

	MGroup2(
		MConstruct(
			[
				\ -> add3DEventListener(object, "change", \ -> {
					nextDistinct(value, getValueFn(object));
				})
			],
			MCheckBox(
				TEmpty(),
				value,
				[
					MOnNewValue(\v -> {
						if (v != getValueFn(object)) {
							appendF3DUndo(state);
							setValueFn(object, v);
						}
					})
				]
			)
			|> MBorderLeft(-8.0)
		),
		TFillX()
	)
}

make3DPropertyParameterCheckBox(state : M3DEditorState, object : native, material : native, name : string) -> Material {
	make3DPropertyCheckBox(
		state,
		object,
		\o -> s2b(get3DObjectParameter(material, name, "false")),
		\o, c -> set3DObjectParameter(material, name, b2s(c))
	)
}

F3DObjectProperties(state : M3DEditorState, object : native) -> [Pair<string, Material>] {
	type = get3DObjectType(object);

	[
		Pair(
			"Type",
			MTextInput(make(type), [MCondensed(true), ReadOnly(true)], [])
		),
		Pair(
			"UUID",
			MTextInput(make(get3DObjectId(object)), [MCondensed(true), ReadOnly(true)], [])
		),
		Pair(
			"Name",
			make3DPropertyTextInput(state, object, object, get3DObjectName, set3DObjectName)
		),
		Pair(
			"Position",
			make3DPropertyVectorInput(
				state,
				object,
				get3DObjectLocalPositionX,
				get3DObjectLocalPositionY,
				get3DObjectLocalPositionZ,
				set3DObjectLocalPositionX,
				set3DObjectLocalPositionY,
				set3DObjectLocalPositionZ,
				add3DObjectLocalPositionListener
			)
		),
		Pair(
			"Rotation",
			make3DPropertyVectorInput(
				state,
				object,
				get3DObjectLocalRotationX,
				get3DObjectLocalRotationY,
				get3DObjectLocalRotationZ,
				set3DObjectLocalRotationX,
				set3DObjectLocalRotationY,
				set3DObjectLocalRotationZ,
				add3DObjectLocalRotationListener
			)
		),
		Pair(
			"Scale",
			make3DPropertyVectorInput(
				state,
				object,
				get3DObjectLocalScaleX,
				get3DObjectLocalScaleY,
				get3DObjectLocalScaleZ,
				set3DObjectLocalScaleX,
				set3DObjectLocalScaleY,
				set3DObjectLocalScaleZ,
				add3DObjectLocalScaleListener
			)
		),
		Pair(
			"Cast Shadow",
			make3DPropertyCheckBox(state, object, get3DObjectCastShadow, set3DObjectCastShadow)
		),
		Pair(
			"Recieve Shadow",
			make3DPropertyCheckBox(state, object, get3DObjectReceiveShadow, set3DObjectReceiveShadow)
		),
		Pair(
			"Visible",
			make3DPropertyCheckBox(state, object, get3DObjectVisible, set3DObjectVisible)
		),
		Pair(
			"Frustum Cull",
			make3DPropertyCheckBox(state, object, get3DObjectFrustumCulled, set3DObjectFrustumCulled)
		),
		Pair(
			"Render Order",
			make3DPropertyParameterInputInteger(state, object, object, "renderOrder")
		)
	]
	|> (\a ->
		if (type == "AmbientLight" || type == "PointLight" || type == "SpotLight")
			concat(
				a,
				[
					Pair(
						"Color",
						make3DPropertyColorPicker(state, object, object, get3DObjectColor, set3DObjectColor)
					),
					Pair(
						"Intensity",
						make3DPropertyTextInputDouble(state, object, object, get3DLightIntensity, set3DLightIntensity)
					)
				]
			)
		else
			a
	)
	|> (\a ->
		if (type == "PointLight")
			concat(
				a,
				[
					Pair(
						"Distance",
						make3DPropertyTextInputDouble(state, object, object, get3DLightDistance, set3DLightDistance)
					),
					Pair(
						"Decay",
						make3DPropertyTextInputDouble(state, object, object, get3DLightDecay, set3DLightDecay)
					)
				]
			)
		else if (type == "SpotLight")
			concat(
				a,
				[
					Pair(
						"Distance",
						make3DPropertyTextInputDouble(state, object, object, get3DLightDistance, set3DLightDistance)
					),
					Pair(
						"Angle",
						make3DPropertyTextInputDouble(state, object, object, get3DLightAngle, set3DLightAngle)
					),
					Pair(
						"Penumbra",
						make3DPropertyTextInputDouble(state, object, object, get3DLightPenumbra, set3DLightPenumbra)
					),
					Pair(
						"Decay",
						make3DPropertyTextInputDouble(state, object, object, get3DLightDecay, set3DLightDecay)
					)
				]
			)
		else
			a
	)
}

F3DGeometryProperties(state : M3DEditorState, object : native) -> [Pair<string, Material>] {
	geometries = get3DObjectGeometries(object);

	if (length(geometries) > 0) {
		geometry = geometries[0];
		type = get3DObjectType(geometry);

		[
			Pair(
				"Type",
				MTextInput(make(type), [MCondensed(true), ReadOnly(true)], [])
			),
			Pair(
				"UUID",
				MTextInput(make(get3DObjectId(geometry)), [MCondensed(true), ReadOnly(true)], [])
			),
			Pair(
				"Name",
				make3DPropertyTextInput(state, object, geometry, get3DObjectName, set3DObjectName)
			),
		]
		|> (\a ->
			if (type == "BoxGeometry" && false)
				concat(
					a,
					[
						Pair(
							"Width",
							make3DPropertyTextInput(
								state,
								object,
								geometry,
								\o -> get3DGeometryParameter(geometry, "width", "0"),
								\o, c -> {}
							)
						),
						Pair(
							"Height",
							make3DPropertyTextInput(
								state,
								object,
								geometry,
								\o -> get3DGeometryParameter(geometry, "height", "0"),
								\o, c -> {}
							)
						),
						Pair(
							"Depth",
							make3DPropertyTextInput(
								state,
								object,
								geometry,
								\o -> get3DGeometryParameter(geometry, "depth", "0"),
								\o, c -> {}
							)
						),
						Pair(
							"Width Segments",
							make3DPropertyTextInput(
								state,
								object,
								geometry,
								\o -> get3DGeometryParameter(geometry, "widthSegments", "0"),
								\o, c -> {}
							)
						),
						Pair(
							"Height Segments",
							make3DPropertyTextInput(
								state,
								object,
								geometry,
								\o -> get3DGeometryParameter(geometry, "heightSegments", "0"),
								\o, c -> {}
							)
						),
						Pair(
							"Depth Segments",
							make3DPropertyTextInput(
								state,
								object,
								geometry,
								\o -> get3DGeometryParameter(geometry, "depthSegments", "0"),
								\o, c -> {}
							)
						),
					]
				)
			else
				a
		)
	} else {
		[];
	}
}

F3DMaterialProperties(state : M3DEditorState, object : native) -> Transform<[Pair<string, Material>]> {
	initMaterials = get3DObjectMaterials(object);

	if (length(initMaterials) > 0) {
		initMaterial = initMaterials[0];
		currentType = make(get3DObjectType(initMaterial));

		fselect(currentType, FLift(\type -> {
			materials = get3DObjectMaterials(object);
			if (length(materials) > 0) {
				material = materials[0];

				availableTypes =
					concat(
						[type],
						[
							"MeshBasicMaterial",
							"MeshStandardMaterial"
						]
					)
					|> uniq;
				selectedType = make(0);

				[
					Pair(
						"Type",
						MConstruct(
							[
								makeSubscribe2(selectedType, \st -> if (st >= 0) {
									if (availableTypes[st] == "MeshBasicMaterial") {
										set3DObjectMaterials(object, [make3DMeshBasicMaterial(get3DObjectColor(material), [])]);
										next(currentType, availableTypes[st]);
									} else if (availableTypes[st] == "MeshStandardMaterial") {
										set3DObjectMaterials(object, [make3DMeshStandardMaterial(get3DObjectColor(material), [])]);
										next(currentType, availableTypes[st]);
									}
								})
							],
							MDropDown(
								selectedType,
								"Select Material Type",
								availableTypes,
								[MWidth(-1.0)]
							)
						)
					),
					Pair(
						"UUID",
						MTextInput(make(get3DObjectId(material)), [MCondensed(true), ReadOnly(true)], [])
					),
					Pair(
						"Name",
						make3DPropertyTextInput(state, object, material, get3DObjectName, set3DObjectName)
					),
				]
				|> (\a ->
					if (type == "MeshBasicMaterial" || type == "MeshStandardMaterial")
						concat(
							a,
							[
								Pair(
									"Color",
									make3DPropertyColorPicker(state, object, material, get3DObjectColor, set3DObjectColor)
								)
							]
						)
					else
						a
				)
				|> (\a ->
					if (type == "MeshStandardMaterial")
						concat(
							a,
							[
								Pair(
									"Roughness",
									make3DPropertyParameterInputDouble(state, object, material, "roughness")
								),
								Pair(
									"Metalness",
									make3DPropertyParameterInputDouble(state, object, material, "metalness")
								),
								Pair(
									"Emissive",
									make3DPropertyColorPicker(state, object, material, get3DObjectEmissive, set3DObjectEmissive)
								)
							]
						)
					else
						a
				)
				|> (\a ->
					concat(
						a,
						[
							Pair(
								"Vertex Colors",
								make3DPropertyParameterCheckBox(state, object, material, "vertexColors")
							),
							Pair(
								"Vertex Tangents",
								make3DPropertyParameterCheckBox(state, object, material, "vertexTangents")
							),
							Pair(
								"Skinning",
								make3DPropertyParameterCheckBox(state, object, material, "skinning")
							),
							Pair(
								"Flat Shaded",
								make3DPropertyParameterCheckBox(state, object, material, "flatShaded")
							),
							Pair(
								"Opacity",
								make3DPropertyParameterInputDouble(state, object, material, "opacity")
							),
							Pair(
								"Transparent",
								make3DPropertyParameterCheckBox(state, object, material, "transparent")
							),
							Pair(
								"Alpha Test",
								make3DPropertyParameterInputDouble(state, object, material, "alphaTest")
							),
							Pair(
								"Depth Test",
								make3DPropertyParameterCheckBox(state, object, material, "depthTest")
							),
							Pair(
								"Depth Write",
								make3DPropertyParameterCheckBox(state, object, material, "depthWrite")
							),
							Pair(
								"Wireframe",
								make3DPropertyParameterCheckBox(state, object, material, "wireframe")
							),
						]
					)
				)
			} else {
				[]
			}
		}))
	} else {
		const([])
	}
}

cachedF3DUndo = ref "";

appendF3DUndo(state : M3DEditorState) -> void {
	if (!state.ignoreUndo) {
		state.ignoreUndo ::= true;

		iter(get3DStageScene(state.stage), \scene -> {
			undo = ^cachedF3DUndo;
			cachedF3DUndo := get3DObjectState(scene);

			if (undo != "" && undo != ^cachedF3DUndo) {
				stack = getValue(state.undoStack);

				if (length(stack) == 0 || undo != stack[length(stack) - 1]) {
					next(state.undoStack, arrayPush(stack, undo));
					next(state.redoStack, []);
				}
			}
		});

		timer(300, \ -> state.ignoreUndo ::= false);
	}
}

applyF3DUndo(state : M3DEditorState) -> void {
	if (!state.ignoreUndo) {
		state.ignoreUndo ::= true;

		iter(get3DStageScene(state.stage), \scene -> {
			undoStack = getValue(state.undoStack);
			redoStack = getValue(state.redoStack);

			if (length(undoStack) > 0) {
				undo = undoStack[length(undoStack) - 1];
				redo = get3DObjectState(scene);

				next(state.redoStack, arrayPush(redoStack, redo));
				next(state.undoStack, subrange(undoStack, 0, length(undoStack) - 1));

				apply3DObjectState(scene, undo);
			}
		});

		timer(300, \ -> state.ignoreUndo ::= false);
	}
}

applyF3DRedo(state : M3DEditorState) -> void {
	if (!state.ignoreUndo) {
		state.ignoreUndo ::= true;

		iter(get3DStageScene(state.stage), \scene -> {
			undoStack = getValue(state.undoStack);
			redoStack = getValue(state.redoStack);

			if (length(redoStack) > 0) {
				undo = get3DObjectState(scene);
				redo = redoStack[length(redoStack) - 1];

				next(state.undoStack, arrayPush(undoStack, undo));
				next(state.redoStack, subrange(redoStack, 0, length(redoStack) - 1));

				apply3DObjectState(scene, redo);
			}
		});

		timer(300, \ -> state.ignoreUndo ::= false);
	}
}
