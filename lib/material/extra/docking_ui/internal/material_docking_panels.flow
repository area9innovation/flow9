import material/material2tropic;
import material/extra/docking_ui/internal/material_docking_utils;
import material/extra/docking_ui/internal/material_docking_drop;

export {
	// NOTE: example in flow9/lib/material/tests/test_docking_ui.flow

	// Each panel can be movable or docked, and it's defined by:
	MDockingPanel(
		// note: if content is [MDockingPanelToolbarItem] is not used
		title : string,
		// creates easily different standard panels as array of MDockingPanelItems
		content : MDockingPanelContent,
		// store the position where the panel is docked
		panelDock : MDock,
		// starting panel size
		size : WidthHeight,
		// panel's style
		style : [MDockingPanelStyle]
	);
						
	makeMovablePanel(state : MDockingState, panelId : int, cursorPositionA : DynamicBehaviour<[Point]>) -> Material;
	makeDockedPanel(isColumn : bool, state : MDockingState, panelId : int, style : [MDockingStyle]) -> Material;
}


makeDockingPanelContent(state : MDockingState, panelId : int, mobilePanel : bool, isForcedHorizontal : bool, resizePressed : DynamicBehaviour<bool>, isHovering : DynamicBehaviour<bool>, style : [MDockingStyle]) -> Material {
	manager = state.manager;
	pstyle = getValue(state.panelStyle)[panelId];
	panelContent = getValue(state.content)[panelId];
	dontShowSep = contains(style, MDPanelHideToolbarSeparators());
	dontResize  = contains(style, MDPanelDontResize());
	isToolbar = isSameStructType(getValue(state.content)[panelId], MDPanelToolbar([]));
	// Theme
	darkTheme = contains(pstyle, MDPanelForceDarkTheme());
	lightTheme = contains(pstyle, MDPanelForceLightTheme());
	theme = if (darkTheme) const(false) else if (lightTheme) const(true) else manager.white;

	resizeHandleMobile = MInteractive(
		[
			TMouseDown(resizePressed), 
			TMouseInside(isHovering, false)
		],
		makeMDockingResizeHandleMobile(state, resizePressed, style)
			|> MBorderEnd(dockingRadius / 2.0)
			|> MBorderBottom(dockingRadius / 2.0)
	);

	content =
		switch (panelContent : MDockingPanelContent) {
			MDPanelToolbar(buttonsA): {
				mapi(buttonsA, \i, btn : MDPanelToolbarItem -> {
					click  = extractStruct(btn.style, MOnClick(nop)).click;
					pad = 10.0;
					minWidth = dockingItemHeight;
					sep = if (dontShowSep) TEmpty() else MSeparator(!isForcedHorizontal);
					buttonSep = if (i == length(buttonsA) - 1) TEmpty() else {if (dontShowSep) TEmpty() else sep}

					ic = MCursor(FingerCursor(), MIcon(btn.icon, [MIconSize(dockingToolbarIconSize), FillOpacity(dockingToolbarIconOpacity)]));
					button = MRawButton(ic, ic, ic, ic, "", [], [TOnClicked(click)]);

					b = if (isForcedHorizontal) MCols2A(MCenterIn(button, TFillWY(minWidth)), buttonSep)
							else MLines2(MCenterIn(button, TFillXH(minWidth)), buttonSep);

					if (!isForcedHorizontal) MBorder(pad, 0.0, pad, 0.0, b) else MBorder(0.0, pad, 0.0, pad, b);


				}) |> (\m -> if (isForcedHorizontal) MColsA(m) else MLines(m))
			}
			MDPanelContent(mat) : mat;
		};

	MGroup([
		content,
		if (mobilePanel) {
			if (dontResize || isToolbar) TEmpty() else resizeHandleMobile;
		} else TEmpty()
	])
	|> (\f -> (MExplicitTheme(f, theme, [])));
}

makePanelTopBar(docked : bool, panelId: int, state : MDockingState, isColumn: bool, pTheme : bool) -> Material {
	manager = state.manager;
	pstyle = getValue(state.panelStyle)[panelId];
	enabled = getValue(state.enabled)[panelId];
	expanded = getValue(state.expanded)[panelId];
	sideExpanded = getValue(state.sideExpanded)[panelId];
	position = getValue(state.positions)[panelId];
	title = getValue(state.title)[panelId];
	minTitleEllipsisWidth = extractStruct(pstyle, MDPanelTitleEllipsis(120.0)).width;
	isToolbar = isSameStructType(getValue(state.content)[panelId], MDPanelToolbar([]));
	// Size
	size = if (docked) getValue(state.dockedSize)[panelId] else getValue(state.mobileSize)[panelId];
	width = size.width;
	height = size.height;
	isForcedHorizontal = contains(pstyle, MDPanelForceHorizontalWhenMobile());
	topBarSize = makeHSize(if (isToolbar) dockingBarHeightToolbar else dockingBarHeightPanel, isColumn || !isToolbar);
	// Prop
	disableButton = contains(pstyle, MDPanelShowCloseBtn());
	disableExpander = contains(pstyle, MDPanelHideExpanderBtn());
	// Colors
	barColorFn : MColor = topBarColorFn(pTheme, pstyle);
	panelColorFn : MColor = panelBgColorFn(pTheme, pstyle);
	titleColorFn : MColor = titleColorFn(pTheme, pstyle);
	sepColorFn = separatorColorFn(pTheme, state.style);

	addTooltip = \label : string, m : Material -> MTooltip(m , MText(label, [MTooltipDesktop()]), []);
	getPanelIcon = \st : [MIconStyle] ->  {
		icon = extractStruct(pstyle, MDPanelIcon("web_asset")).icon;
		MIcon(icon, concat([titleColorFn], st));
	}

	makeIconToggleButton = \boolB : DynamicBehaviour<bool>,
		iconOn : string, iconOff : string,
		tooltipOn : string, tooltipOff :string,
		iconSize: double, clickFn : () -> void,
		iconColor : MColor, fill : double -> {
			MSelect(boolB,\b -> if (b) MIconButton(iconOn, clickFn, [MIconSize(iconSize), iconColor, FillOpacity(fill), MIconButtonBorder(1.0)], []) |> (\f -> addTooltip(tooltipOn, f))
				else MIconButton(iconOff, clickFn, [MIconSize(iconSize), iconColor, FillOpacity(fill), MIconButtonBorder(1.0)], []) |> (\f -> addTooltip(tooltipOff, f))
			) |> MCenterY
	}

	// Panel's buttons
	customButtonsA = extractStruct(pstyle, MDPanelCustomButtons([])).buttons;
	customButtons = customButtonsA != [];
	panelButtonsA = map(customButtonsA, \btn -> {
		clickedB = make(false);
		switch (btn) {
			MDPanelCustomButton(ic, tt, clkFn, st) : {
				btnColor = extractStruct(st, titleColorFn);
				makeIconToggleButton(clickedB, ic, ic, tt, tt, dockingTopBarIconSize, clkFn, btnColor, 0.5);
			}
			default: MEmpty();
		} |> MCenterY

	});

	// Handles
	linedHandle = makeMDockingLinedHandle(isColumn, sepColorFn);

	// TopBar Content
	panelTopBarButtons = {
		MBaselineColsA([
			getPanelIcon([MIconSize(dockingTopBarIconSize), FillOpacity(dockingTitleOpacity)])
				|> MBorderLeft(10.0)
				|> MCenterY,
			MEllipsisText(title, [titleColorFn, dockingTitleFont, MMinWidth(minTitleEllipsisWidth)]) 
			|> MBorderLeft(10.0) 
			|> MCenterY,
			TFillX(),
			if (customButtons)
				MBaselineColsA(panelButtonsA) |> MCenterY
			else TEmpty(),
			if (disableButton)
				MCols2A(
					TFixed(6.0, 0.0),
					MIconButton("close", \ -> next(enabled, false), [MIconSize(dockingTopBarIconSize - 4.0), titleColorFn, MIconButtonBorder(1.0), FillOpacity(0.5)], [])
						|> (\f -> addTooltip("hide panel", f)) |> MCenterY
				)
			else TEmpty(),
			TFixed(4.0, 0.0),

			if (disableExpander)
				TEmpty()
			else
				makeIconToggleButton(
					expanded,
					"keyboard_arrow_up",
					"keyboard_arrow_down",
					"collapse panel",
					"expand panel",
					dockingTopBarIconSize,
					\ -> {
						reverseBehaviour(expanded);
						// next(state.dock, getValue(state.dock)); //force redraw (should be used for mobile)
					},
					titleColorFn,
					0.5
				) |> showIf(isColumn),


			TFixed(8.0, 0.0)
		])
	}

	dockedTopBar = \isSideExpanded : bool  -> {
		MAvailable(
			MGroup([
				// Topbar background
				if (isToolbar) {
					TRounded(dockingRadius, 0.0, 0.0, dockingRadius, [MFill(panelColorFn)], makeHSize(dockingBarHeightToolbar, isColumn))
				} else {

					if (isColumn) {
						if (isSideExpanded) {
							MIfLazy(expanded,\e -> 
								if (e) TRounded(dockingRadius, dockingRadius, 0.0, 0.0, [MFill(barColorFn), FillOpacity(1.0)], TFillXH(dockingBarHeightPanel))
									else TRounded(dockingRadius, dockingRadius, dockingRadius, dockingRadius, [MFill(barColorFn)], TFillXH(dockingBarHeightPanel))
							) //|> showIf(!contains(pstyle, MDPanelDontShowTopbar()));
						} else {
							TRounded(dockingRadius, dockingRadius, dockingRadius, dockingRadius, [MFill(barColorFn)], TFillXH(dockingBarHeightPanel))
								|> (\f -> addTooltip(title + " panel", f))
						}

					} else {				
						TRectangle([MFill(barColorFn), /*FillOpacity(0.0)*/], TFillXH(dockingBarHeightPanel))
					}
				},
				// Topbar content
				if (isToolbar) {
					MCenterIn(
						linedHandle |> (\m -> if (isColumn) MOffset(0.0, 4.0, m) else MOffset(4.0, 0.0, m)), // tweak handle position for toolbar content
						topBarSize
					)
					// |>(\m -> MGroup2(TRectangle([MFill(panelBgColorFn(pTheme, pstyle))], topBarSize) ,m))

				} else {
						if (isSideExpanded) panelTopBarButtons else {			
							getPanelIcon([MIconSize(sideExpanderButtonSize), FillOpacity(0.3)]) |> MCenter
						}
				}
			]), topBarSize
		);
	};

	mobileTopBar =
		if (isToolbar) {
			linedHandle 
				|> (\f -> if (!isColumn) MCols2A(TFillX(), MCenterY(f)) else MLines2(TFillY(), MCenterX(f)))
				|> (\m -> if (isColumn) MOffset(0.0, 4.0, m) else MOffset(4.0, 0.0, m)) // tweak handle position for toolbar content

		} else {
			MAvailable(
				MGroup([
					MSelect(expanded,\e -> if (e) TRounded(dockingRadius, dockingRadius, 0.0, 0.0, [MFill(barColorFn)], TFillXY())
						else TRounded(dockingRadius, dockingRadius, dockingRadius, dockingRadius, [MFill(barColorFn)], TFillXY())	
					),
					if (isSameStructType(getValue(state.content)[panelId], MDPanelToolbar([])))
						MCenterIn(linedHandle, TFillXH(dockingBarHeightPanel))
					else panelTopBarButtons			
				]),
				TFillXH(dockingBarHeightPanel)
			);
		}

	MSelect(getValue(state.sideExpanded)[panelId], \se -> {
		if (se) {
			if (docked) dockedTopBar(se) else mobileTopBar;
		} else {
			dockedTopBar(se);
		}
	});
}

makeMovablePanel(state : MDockingState, panelId : int, cursorPositionA : DynamicBehaviour<[Point]>) -> Material {
	manager = state.manager;
	itemId = makeTropicTag(manager);
	dockA = state.dock;
	groupA = state.group;
	enabled = getValue(state.enabled)[panelId];
	expanded = getValue(state.expanded)[panelId];
	position = getValue(state.positions)[panelId];
	pstyle = getValue(state.panelStyle)[panelId];
	isForcedHorizontal = contains(pstyle, MDPanelForceHorizontalWhenMobile());
	cacheEnabled = extractStruct(state.style, MDockingEnableLoadAndStoreCache("", false)).cacheEnabled;
	// Theme
	darkTheme = contains(pstyle, MDPanelForceDarkTheme());
	lightTheme = contains(pstyle, MDPanelForceLightTheme());
	mobileTheme = if (darkTheme) const(false) else if (lightTheme) const(true) else manager.white;

	resizePressed = make(false);
	isResizing = make(false);
	isHovering = make(false);
	dContent = makeDockingPanelContent(state, panelId, true, isForcedHorizontal, resizePressed, isHovering, pstyle);

	isToolbar = isSameStructType(getValue(state.content)[panelId], MDPanelToolbar([]));
	topBarH = if (isToolbar) dockingBarHeightToolbar else dockingBarHeightPanel;

	// Size
	size = getValue(state.size)[panelId];
	minWidth = size.width;
	minHeight = size.height + topBarH;

	msize = getValue(state.mobileSize)[panelId];
	width = msize.width;
	height = msize.height + topBarH;

	disableButton = contains(pstyle, MDPanelShowCloseBtn());

	mouseXyLocal = make(zeroPoint);
	dragPressed = make(false);
	tempWH = make(WidthHeight(width, height));
	r = dockingRadius;

	draggingShape = TSelect(state.mobileSize, \ms ->
		if (getValue(getValue(state.expanded)[panelId])) {
			TRounded(r, r, r, r, [MFill(dockingPrimaryColor /*panelBgColorFn(fgetValue(mobileTheme), pstyle)*/), FillOpacity(dockingMobileOpacity)], TFixed(ms[panelId].width, ms[panelId].height))
		} else TRounded(r, r, r, r, [MFill(dockingPrimaryColor), FillOpacity(dockingMobileOpacity)], TFixed(ms[panelId].width, dockingBarHeightPanel))
	) |> (\m -> if (isForcedHorizontal) TRotate90(m) else m);

	makeResizablePanel = \c : Material, lg : bool -> {	
		MConstruct([
				makeSubscribe(isResizing, \rs -> {
					if (!rs) {
					// update mobile size
					next(state.mobileSize, replace(getValue(state.mobileSize), panelId , getValue(tempWH))); //
				}
			})
		],
		MInteractive([TMouseXY(mouseXyLocal)],
			// TODO: Toolbar item options

			if(isToolbar) {
				toolbarSize = TFixed(width, size.height + topBarH) |> (\m -> if (!isForcedHorizontal) m else TRotate90(m));
				MAvailable(
					[
						makePanelTopBar(false, panelId, state, !isForcedHorizontal, lg),
						MCenterIn(c, TFillXY())
					]
					|> (\f -> if (isForcedHorizontal) MCols(f) else MLines(f))
					|> (\f -> 
						MShadowShape(const(4.0), f, 
							TropicShape(
								TRounded4(dockingRadius, [MFill(panelBgColorFn(lg, pstyle))], TFillXY()),
								
							)
						)
					),
					toolbarSize
				)
			} else {
				MSelect(expanded,\e -> {
					MAvailable(
						MLines2(
							makePanelTopBar(false, panelId, state, !isForcedHorizontal, lg),
							if (e) c else TEmpty() 
						) 
						|> (\f -> 
							MShadowShape(const(4.0), f, 
								TropicShape(TRounded4(dockingRadius, [MFill(panelBgColorFn(lg, pstyle))], TFillXY()))
							)
						),
						if (e) TSized(tempWH) else TSelect(tempWH, \wh ->  TFixed(wh.width, dockingBarHeightPanel)),
					)
				})	
			}
		))
	}

	makeMovablePanel = \lg -> 
		MDraggable(panelId,
			MSelect(manager.manager.dragging, \h -> {
				d = MConstruct([
					makeSubscribe(dragPressed, \p -> {
						if (p) next(cursorPositionA, replace(getValue(cursorPositionA), panelId, getValue(mouseXyLocal)));
					})],
					makeResizablePanel(dContent, lg)
				);
				if (h == panelId) draggingShape else d;

			})|> (\f-> MInteractive([TMouseDownGhost(dragPressed)],f)),
			[]
		);

	MConstruct([
		makeSubscribe2(isResizing, \rs -> { 
			if (!rs) {
				// Update mobile size
				updateH(state.mobileSize, panelId,  getValue(tempWH).height - topBarH);
				updateW(state.mobileSize, panelId,  getValue(tempWH).width);
				// Update docked size
				updateH(state.dockedSize, panelId,  getValue(tempWH).height - topBarH);
				updateW(state.dockedSize, panelId,  getValue(tempWH).width);

				// Update cache
				if (cacheEnabled) setMDockingStateKeyValue(state) |> ignore;
			}
		}),
		makeSubscribe(resizePressed, \p -> {
			if (p) {
				addMInteractionItemId(manager, itemId);
				next(isResizing, true);
			} else {
				if (getValue(isResizing)) next(isResizing, false);
			}
		}),
		makeSubscribe(mouseXyLocal, \mxy -> {
			if (isCurrentMInteractionItemId(manager, itemId) && getValue(isResizing)) {
				blockOtherMInteractionItemIds(manager, itemId);
				nextDistinct(tempWH, WidthHeight(getValue(tempWH).width, max(minHeight, mxy.y)));
				nextDistinct(tempWH, WidthHeight(max(minWidth, mxy.x), getValue(tempWH).height));
			}
		})
	],	
	MSelect2(dockA, mobileTheme, \d, lg -> {
		if (d[panelId].areaId < 0) {
			next(getValue(state.sideExpanded)[panelId], true);
			MSelect(enabled, \e -> if (e) 
				MTranslate(
					const(getValue(position)), 
					makeMovablePanel(lg)
				) else TEmpty()
			);
		} else MEmpty();	
	}))
}

makeDockedPanel(isColumn : bool, state : MDockingState, panelId : int, style : [MDockingStyle]) -> Material {
	manager = state.manager;
	pstyle = getValue(state.panelStyle)[panelId];
	isToolbar = isSameStructType(getValue(state.content)[panelId], MDPanelToolbar([]));

	// Scroll
	dontScroll  = contains(pstyle, MDPanelDontScroll());
	hasScrollPos = \dockingstyle -> {
		!exists([MDPanelScrollPosition(make(zeroPoint))], \dsp -> isSameStructType(dsp, dockingstyle))
	};
	scrollPos = extractStruct(style, MDPanelScrollPosition(make(zeroPoint))).scrollPos;
	hasScrollInspectVisible = \dockingstyle -> {
		!exists([MDPanelScrollInspectVisible(make(zeroPoint), makeWH())], \dsiv -> isSameStructType(dsiv, dockingstyle))
	};
	scrollTopLeft = extractStruct(style, MDPanelScrollInspectVisible(make(zeroPoint), makeWH())).scrollTopLeft;
	scrollWidthHeight = extractStruct(style, MDPanelScrollInspectVisible(make(zeroPoint), makeWH())).scrollWidthHeight;

	// Expanded
	expanded = getValue(state.expanded)[panelId];
	sideExpanded = getValue(state.sideExpanded)[panelId];
	enabled = getValue(state.enabled)[panelId];
	
	// Theme
	darkTheme = contains(pstyle, MDPanelForceDarkTheme());
	lightTheme = contains(pstyle, MDPanelForceLightTheme());
	dockedTheme = if (darkTheme) const(false) else if (lightTheme) const(true) else manager.white;


	// println("  -   -   -   -   -   -   -   -   - > DockedPanel " + i2s(panelId));


	// Panel's content
	dContent = makeDockingPanelContent(state, panelId, false, !isColumn, make(false), make(false), pstyle);
	dPanel = \lg : bool -> {
		if (isToolbar) {
			dContent 
			|> (\f -> MGroup2(TFillXY(), f))
			|> (\f -> MGroup2(TRounded(0.0, 0.0, dockingRadius, dockingRadius, [MFill(panelBgColorFn(lg, pstyle))], TFillXY()), f))  
		} else {
			
			MSelect(expanded, \e -> {	
				pContent = if (dontScroll) {
					MCropSize(TFillXY(), dContent)
				} else {
					MScroll(
						dContent, TFillXY(),
						if (hasScrollPos(style) && hasScrollInspectVisible(style))
							[MScrollPosition(scrollPos), TScrollInspectVisible(scrollTopLeft, scrollWidthHeight)]
						else if (hasScrollPos(style))
							[MScrollPosition(scrollPos)]
						else []
					)
				}
				if (isColumn) {
					if (e) pContent else TFillXH(dockingCollapsedSeparatorH);
				} else	pContent;

			}) 
			|> (\f -> MGroup2(TRounded(0.0, 0.0, dockingRadius, dockingRadius, [MFill(panelBgColorFn(lg, pstyle))], TFillXY()), f))  
			|> (\m -> if (!isColumn) m else MShowLazy(sideExpanded, \ -> m))
		} 
	}

	MSelect(dockedTheme, \lg -> {
		addRowTopBars = \f : Material -> [addDockedTopbar(isColumn, state, panelId, lg, style), f]
			|> (\r -> if (isColumn) MLines(r) else {if (isToolbar) MCols(r) else MLines(r)});
		dPanel(lg) 
			|> addRowTopBars
	})
}


addDockedTopbar(isColumn : bool, state : MDockingState, panelId : int, pTheme : bool, style : [MDockingStyle]) -> Material {
	manager = state.manager;
	pstyle = getValue(state.panelStyle)[panelId];
	dontMove  = contains(pstyle, MDPanelDontMove());
	isToolbar = isSameStructType(getValue(state.content)[panelId], MDPanelToolbar([]));
	panelDockedSize = getValue(state.dockedSize)[panelId];
	r = dockingRadius;
	enabled = getValue(state.enabled)[panelId];


	dheight = if (isColumn) panelDockedSize.height else panelDockedSize.width;
	// dheight = if (isColumn) panelDockedSize.height else {
	// 	if (isToolbar) panelDockedSize.height else panelDockedSize.width
	// };
	posCorrection = Point(0.0, 0.0);
		// if (isColumn) Point(0.0, 0.0) else {
		// 	dx = 4.0; 
		// 	dy = (dheight / 2.0) - 12.0; 
		// 	Point(dx, -dy);
		// }

	// Mobile size for dragging shape
	mHeight = getValue(state.mobileSize)[panelId].height;
	mWidth = getValue(state.mobileSize)[panelId].width;
	panelSize = TFixed(mWidth, mHeight);

	draggingShape = 
		TRounded(dockingRadius, dockingRadius, dockingRadius, dockingRadius, [MFill(dockingPrimaryColor), FillOpacity(dockingMobileOpacity)], panelSize) 
			|> (\m -> 
				if (isToolbar) {
					if (isColumn) m else TRotate90(m)
				} else m
			);

	cursor = fif(fselect(manager.manager.dragging, FLift(\dr -> dr >= 0)), const(GrabbingCursor()), const(GrabCursor()));
	// MSelect(theme, \lg -> {
		// Test for removing top bar
		// MTooltip(
		// 	// MBorder4(12.0, MIcon("trip_origin", [MIconSize(dockingTopBarIconSize - 8.0), FillOpacity(0.9), titleColorFn(lg, [])])),
		// 	MBorder4(12.0, MIcon("trip_origin", [MIconSize(dockingTopBarIconSize - 8.0), FillOpacity(0.9), MYellow(500)])),
		// 	MText("Undock Panel", []),
		// 	[]
		// ) 	
		makePanelTopBar(true, panelId, state, isColumn, pTheme) 
			|> (\f -> if (dontMove) f else
				MDraggable(panelId, f, [
					TDragShape(TTranslate(const(posCorrection), draggingShape)),
					TCursorShape(DynamicCursor(cursor))
				])
			)
	// })
}
