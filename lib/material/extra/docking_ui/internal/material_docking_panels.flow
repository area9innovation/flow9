import material/material;
import material/material_ui;
import material/material2tropic;
import material/extra/docking_ui/internal/material_docking_ui_utils;

export {

	// Each panel can be movable or docked, and it's defined by:
	MDockingPanel(
		// note: if content is [MDockingPanelToolbarItem] is not used
		title : string,
		// note: if content is [MDockingPanelToolbarItem] is not used
		panelIcon : string,
		// creates easily different standard panels as array of MDockingPanelItems
		content : [MDockingPanelItem],
		// set on which MDockingArea the panel is docked by default (a negative number means the panel is floating undocked)
		dockingAreaId : int,
		// it means "column's order" or "row's order" depending on where the panel is docked
		order : int,
		// panels can be moved and docked on different allowed groups of MDockingAreas, group name's are defined inside each MDockingArea by "groupName"
		allowedGroups : [string],
		// panel's style
		style : [MDockingStyle]
	);

	updateMDockingState(state : MDockingState, panelsA : [MDockingPanel], style : [MDockingStyle]) -> void;
	makeDockingPanel(docked : bool, state : MDockingState,id : int, groupName : string, isColumn : bool, fillPanel : bool, style : [MDockingStyle],
		barHeight: double, cursorPositionA : DynamicBehaviour<[Point]>, sizeCollapsed : DynamicBehaviour<bool>, zorder : int) -> Material;
	makeMovablePanel(state : MDockingState, id : int, cursorPositionA : DynamicBehaviour<[Point]>) -> Material;
}

makeDockingPanel(docked : bool, state : MDockingState, id : int, groupName : string, isColumn : bool, fillPanel : bool, style : [MDockingStyle], barHeight: double,
	cursorPositionA : DynamicBehaviour<[Point]>/*,enabled = DynamicBehaviour<bool>*/, sizeCollapsed : DynamicBehaviour<bool>, zorder : int) -> Material {

	if (docked) makeDockedPanel(state, id, groupName, isColumn, fillPanel, style, barHeight, sizeCollapsed, zorder) 
		else makeMovablePanel(state, id, cursorPositionA);
}


updateMDockingState(state : MDockingState, panelsA : [MDockingPanel], style : [MDockingStyle]) -> void {

println(" |--> update docking state");

	titleA = state.title;
	panelIconA = state.panelIcon;
	contentA = state.content;
	dockA = state.dock;
	groupA = state.group;
	mPositiosA = state.positions;
	enabledA = state.enabled;
	expandedA = state.expanded;
	panelsStyleA = state.style;

	// Update UI layout
	if (getValue(dockA) == [[]]) {
		iteri(panelsA, \panelId, p -> {
			next(dockA, replace(getValue(dockA), panelId , [p.dockingAreaId, p.order, panelId]));
		});
	};
	
	// Expanded
	if (getValue(state.expanded) == []) iteri(panelsA, \i, p -> {	
		expandedB = extractStruct(p.style, MDPanelExpanded(make(true))).expanded;
		next(state.expanded, replace(getValue(state.expanded), i ,expandedB))
	});
	if (getValue(state.sideExpanded) == []) iteri(panelsA, \i, p -> {
		next(state.sideExpanded, replace(getValue(state.sideExpanded), i , make(true)))
	});

	// Positions
	offsetP = extractStruct(style, MDockingMobileOffset(Point(72.0, 72.0))).offsetPosition;
	println(style);
	println(offsetP);
	if (getValue(state.positions) == []) iteri(panelsA, \i, p -> {
		zeroPosition = Point(
			offsetP.x + 36.0 * i2d(i),
			offsetP.y + dockingItemHeight * i2d(i)
		);
		positionB = extractStruct(p.style, MDPanelPosition(make(zeroPosition))).position;
		next(state.positions, replace(getValue(state.positions), i , positionB));
	});

	// Enabled
	if (getValue(state.enabled) == []) iteri(panelsA, \i, p -> {
		enabledB = extractStruct(p.style, MDPanelEnabled(make(true))).enabled;
		if (contains(p.style, MDockingDisabled())) next(enabledB, false);
		next(state.enabled, replace(getValue(state.enabled), i , enabledB));
	});

	if (getValue(titleA) == []) {
		iteri(panelsA, \i, p -> {
			next(titleA, replace(getValue(titleA), i , p.title));
			next(panelIconA, replace(getValue(panelIconA), i , p.panelIcon));
			next(contentA, replace(getValue(contentA), i , p.content));
			next(groupA, replace(getValue(groupA), i , p.allowedGroups));
			next(panelsStyleA, replace(getValue(panelsStyleA), i , p.style));

			content = getValue(state.content)[i];

			iteri(getValue(contentA)[i], \j, itemA -> {

				switch (itemA : MDockingPanelItem) {
					// Toolbar
					MDockingPanelToolbarItem(ic, st): {
						minWidth = dockingItemHeight;
						dontShowSep = contains(p.style, MDockingDontShowSeparators());
						panelHeight = if (dontShowSep) (minWidth * i2d(length(content))) else (minWidth * i2d(length(content))) + (i2d(length(content)) - 1.0);
						size = TFixed(minWidth, panelHeight);
						next(state.size, replace(getValue(state.size), i , size));
						next(state.dockedSize, replace(getValue(state.dockedSize), i , size));
						next(state.mobileSize, replace(getValue(state.mobileSize), i , size));
					}
					// Panel of Buttons
					MDockingPanelButtonsItem(ic, lb, st): {
						minWidth = dockingItemHeight;
						width = extractStruct(p.style, MDockingPanelWidth(minWidth * 5.0)).width;
						dontShowSep = contains(p.style, MDockingDontShowSeparators());
						fillHeight = contains(p.style, MDockingFillSpace());

						panelHeight = if (dontShowSep) (minWidth * i2d(length(content))) else (minWidth * i2d(length(content))) + (i2d(length(content)) - 1.0);
						size = TFixed(width, panelHeight);
						dockedSize = if (fillHeight) TFillWY(width) else TFixed(width, panelHeight + dockingBarHeight + dockingDragSize);

						next(state.size, replace(getValue(state.size), i , size));
						next(state.dockedSize, replace(getValue(state.dockedSize), i , dockedSize));
						next(state.mobileSize, replace(getValue(state.mobileSize), i , size));
					}
					// Custom panels
					MDockingPanelCustomItem(mat, msize, st): {
						next(state.size, replace(getValue(state.size), i , TFixed(msize.width, msize.height)));
						next(state.dockedSize, replace(getValue(state.dockedSize), i , TFixed(msize.width, msize.height)));
						next(state.mobileSize, replace(getValue(state.mobileSize), i , TFixed(msize.width, msize.height)));
					}
				};
			});
		});
	}
}

makeDockingPanelContent(state : MDockingState, id : int, mobilePanel : bool, isHorizontal : bool, resizePressed : DynamicBehaviour<bool>, isHovering : DynamicBehaviour<bool>, theme : Transform<bool>, style : [MDockingStyle]) -> Material {
	contentA = getValue(state.content)[id];
	width = getTropicMetrics(getValue(state.size)[id]).width;
	dontShowSep = contains(style, MDockingDontShowSeparators());
	dontResize  = contains(style, MDockingDontResize());
	resizeHandleColor = if (fgetValue(theme)) textColorLight else textColorDark;
	isToolbarItem = isSameStructType(getValue(state.content)[id][0], MDockingPanelToolbarItem("", []));

	resizeHandleMobile = MInteractive(
		[
			TMouseDown(resizePressed), 
			TMouseInside(isHovering, false)
		],
		makeMDockingResizeHandleMobile(state, style)
	);

	buttonsA = mapi(contentA, \i, c -> {

		switch (c : MDockingPanelItem) {
			MDockingPanelToolbarItem(picon, itemStyle): {
				click  = extractStruct(itemStyle, MOnClick(nop)).click;
				pad = 10.0;
				minWidth = 48.0;
				sep = if (dontShowSep) TEmpty() else MSeparator(!isHorizontal);
				buttonSep = if (i == length(contentA) - 1) TEmpty() else {if (dontShowSep) TEmpty() else sep}

				ic = MCursor(FingerCursor(), MIcon(picon, [MIconSize(dockingToolbarIconSize)]));
				button = MRawButton(ic, ic, ic, ic, "", [], [TOnClicked(click)]);

				b = if (isHorizontal) MCols2A(MCenterIn(button, TFillWY(minWidth)), buttonSep)
						else MLines2(MCenterIn(button, TFillXH(minWidth)), buttonSep);

				if (!isHorizontal) MBorder(pad, 0.0, pad, 0.0, b) else MBorder(0.0, pad, 0.0, pad, b);
			}
			MDockingPanelButtonsItem(picon, label, itemStyle): {
				onClick  = extractStruct(itemStyle, MOnClick(nop)).click;
				pad = 16.0;
				minWidth = 48.0;
				sep = if (dontShowSep) TEmpty() else {MSeparator(if (isHorizontal) false else true);};

				p = if (isHorizontal) {
					MCols2A(
						MAvailable(
							MColsA([
								MIconButton(picon, onClick, [MIconSize(dockingToolbarIconSize)], []) |>(\f -> MCenter(f)),
								TFillXY(),
							])|>(\f -> MCenterIn(f,TFixed(minWidth, minWidth) )),
							TFillXH(width)
						),
						if (i == length(contentA) - 1) TEmpty() else sep
					);
				} else {
					MLines2(
						MAvailable(
							MColsA([
								if (width <= 100.0)
								MIcon(picon, [MIconSize(dockingToolbarIconSize)]) |> (\f -> MCenterIn(f,TFillXH(minWidth)))
								else
								MIcon(picon, [MIconSize(dockingToolbarIconSize)]) |> (\f -> MCenterY(f)),
								if (width <= 100.0) TEmpty() else TFillXY(),
								if (width <= 100.0) TEmpty() else
								MText(label, [MListBody()])|>(\f -> MCenterY(f))
							]),
							TFillXH(minWidth)
						),
						if (i == length(contentA) - 1) TEmpty() else {if (dontShowSep) TEmpty() else sep}
					);
				}

				MBorder(pad, 0.0, pad, 0.0, p);
			}
			MDockingPanelCustomItem(mat, msize, st): mat;
		};
	});

	MGroup([
		if (isHorizontal) MColsA(buttonsA) else MLines(buttonsA),
		if (mobilePanel) {if (dontResize || isToolbarItem) TEmpty() else resizeHandleMobile;} else TEmpty()
	]);
}

makePanelTopBar(docked : bool, id: int, state : MDockingState, isColumn: bool, light : bool) -> Material {
	manager = state.manager;
	style = getValue(state.style)[id];
	enabled = getValue(state.enabled)[id];
	expanded = getValue(state.expanded)[id];
	sideExpanded = getValue(state.sideExpanded)[id];
	position = getValue(state.positions)[id];
	title = getValue(state.title)[id];
	minTitleEllipsisWidth = extractStruct(style, MDockingMinTitleEllipsisWidth(120.0)).width;
	panelIcon = if (getValue(state.panelIcon)[id] == "") "web_asset" else getValue(state.panelIcon)[id];
	// Size
	size = if (docked) getValue(state.dockedSize)[id] else getValue(state.mobileSize)[id];
	width = getTropicMetrics(size).width;
	height = getTropicMetrics(size).height;
	isHorizontal = contains(style, MDockingMobileHorizontal());
	handleWidth = 24.0;
	handleHeight = 24.0;
	topBarSize = if (isColumn) TFillXH(dockingBarHeight) else TFillWY(dockingBarHeight / 2.0);
	// Prop
	ifMobile = extractStruct(style, MDockingMobileWatcher(make(false))).mobile;
	disableButton = contains(style, MDockingDisableButton());
	isToolbarItem = isSameStructType(getValue(state.content)[id][0], MDockingPanelToolbarItem("", []));
	disableExpander = contains(style, MDockingDisablePanelExpander());
	// Theme
	darkTheme = contains(style, MDockingForceDarkTheme());
	lightTheme = contains(style, MDockingForceLightTheme());
	theme = if (darkTheme) const(false) else if (lightTheme) const(true) else manager.white;
	// Colors
	color = extractStruct(style, if (fgetValue(theme)) textColorLight else textColorDark);
	bgHandleColor = extractStruct(style, if (fgetValue(theme)) bgHandleColorLight else bgHandleColorDark);

	dockedBarColorToolbar = extractStruct(style, if (fgetValue(theme)) panelBgColorLight else areaBgColorDark);
	barColor : MColor = if (fgetValue(theme)) barColorLight else barColorDark;
	titleColor : MColor = if (fgetValue(theme)) textColorLight else textColorDark;

	addTooltip = \label : string, m : Material -> MTooltip(m , MText(label, [MTooltipDesktop()]), []);

	makeIconToggleButton = \boolB : DynamicBehaviour<bool>,
		iconOn : string, iconOff : string,
		tooltipOn : string, tooltipOff :string,
		iconSize: double, clickFn : () -> void,
		iconColor : MColor, fill : double -> {
			MSelect(boolB,\b -> if (b) MIconButton(iconOn, clickFn, [MIconSize(iconSize), iconColor, FillOpacity(fill), MIconButtonBorder(1.0)], []) |> (\f -> addTooltip(tooltipOn, f))
				else MIconButton(iconOff, clickFn, [MIconSize(iconSize), iconColor, FillOpacity(fill), MIconButtonBorder(1.0)], []) |> (\f -> addTooltip(tooltipOff, f))
			) |> MCenterY
	}

	// Panel's buttons
	customButtonsA = extractStruct(style, MDockingCustomButtons([])).buttons;
	customButtons = customButtonsA != [];
	panelButtonsA = map(customButtonsA, \btn -> {
		clickedB = make(false);
		switch (btn) {
			MDockingCustomButton(ic, tt, clkFn, st) : {
				btnColor = extractStruct(st, titleColor);
				makeIconToggleButton(clickedB, ic, ic, tt, tt, dockingTopBarIconSize, clkFn, btnColor, 0.5);
			}
			default: MEmpty();
		} |> MCenterY

	});

	// Handles
	linedHandle = makeMDockingLinedHandle(isHorizontal, titleColor);
	dottedHandle =  makeMDockingDottedHandle(isColumn, color);

	// TopBar Content
	panelTopBarButtons = {
		MBaselineColsA([
			MIcon(panelIcon, [MIconSize(dockingTopBarIconSize), titleColor]) 
				|> MBorderLeftRight(8.0)
				|> MCenterY,
			MEllipsisText(title + " - " + d2s(width) + "x"+ d2s(height), [titleColor, MCaptionSolid(), MMinWidth(minTitleEllipsisWidth)])	|> MCenterY,
			TFillX(),
			if (customButtons)
				MBaselineColsA(panelButtonsA) |> MCenterY
			else TEmpty(),
			if (disableButton)
				MCols2A(
					TFixed(6.0, 0.0),
					MIconButton("visibility_off", \ -> next(enabled, false), [MIconSize(dockingTopBarIconSize), titleColor, MIconButtonBorder(1.0), FillOpacity(0.5)], [])
					|> (\f -> addTooltip("hide panel", f)) |> MCenterY
				)
			else TEmpty(),
			TFixed(4.0, 0.0),
			if (disableExpander)
				TEmpty()
			else
				makeIconToggleButton(
					expanded,
					"keyboard_arrow_up",
					"keyboard_arrow_down",
					"collapse panel",
					"expand panel",
					dockingTopBarIconSize,
					\ -> {
						reverseBehaviour(expanded);
						// next(state.dock, getValue(state.dock)); //force redraw (should be used for mobile)
					},
					titleColor,
					0.5
				),
			TFixed(8.0, 0.0)
		])
	}

	dockedTopBar = \isSideExpanded : bool  -> {
		MAvailable(
			MGroup([
				// Toplbar background
				if (isColumn) {
					if (isSideExpanded) {
						MIfLazy(expanded,\e -> 
							if (e) TRounded(dockingRadius, dockingRadius, 0.0, 0.0, [MFill(barColor), FillOpacity(1.0)], TFillXH(dockingBarHeight))
								else TRounded(dockingRadius, dockingRadius, dockingRadius, dockingRadius, [MFill(barColor)], TFillXH(dockingBarHeight))
						);

					} else {
						TRounded(dockingRadius, dockingRadius, dockingRadius, dockingRadius, [MFill(barColor)], TFillXH(dockingBarHeight));
					}

				} else {
					TRectangle([MFill(barColor)], TFillWY(dockingBarHeight / 2.0))
				},

				// Toplbar content
				if (isToolbarItem) {
					MGroup2(
						TRectangle([MFill(dockedBarColorToolbar)], topBarSize),
						MCenterIn(dottedHandle, topBarSize)
					)
				} else {
					if (isColumn)
						if (isSideExpanded) panelTopBarButtons else {
							MIcon(panelIcon, [MIconSize(dockingTopBarIconSize), titleColor, FillOpacity(0.3)]) |> MCenter
								|> (\f -> addTooltip(title + " panel", f))
						}
					else MCenterIn(dottedHandle, TFillWY(dockingBarHeight / 2.0));
				}
			]), topBarSize
		);
	};

	mobileTopBar =
		if (isHorizontal) {
			MSelect(expanded,\e ->
				MAvailable(
					MGroup([
						if (e) TRounded(dockingRadius, 0.0, 0.0, dockingRadius, [MFill(barColor)], TFillXY())
						else TRounded(dockingRadius, dockingRadius, dockingRadius, dockingRadius, [MFill(barColor)], TFillXY()),
						MCenterIn(linedHandle, TFixed(dockingBarHeight, width)),
					]),
					TFixed(dockingBarHeight, width)
				)
			);
		} else {
			MAvailable(
				MGroup([
					MSelect(expanded,\e -> if (e) TRounded(dockingRadius, dockingRadius, 0.0, 0.0, [MFill(barColor)], TFillXY())
						else TRounded(dockingRadius, dockingRadius, dockingRadius, dockingRadius, [MFill(barColor)], TFillXY())	
					),
					if (isSameStructType(getValue(state.content)[id][0], MDockingPanelToolbarItem("", [])))
						MCenterIn(linedHandle, TFillXH(dockingBarHeight))
					else panelTopBarButtons			
				]),
				TFillXH(dockingBarHeight)
			);
		}

	MSelect(getValue(state.sideExpanded)[id], \se -> {
		if (se) {
			if (docked) dockedTopBar(se) else mobileTopBar;
		} else {
			dockedTopBar(se);
		}
	});
}

makeMovablePanel(state : MDockingState, id : int, cursorPositionA : DynamicBehaviour<[Point]>) -> Material {
	manager = state.manager;
	itemId = makeTropicTag(manager);
	dockA = state.dock;
	groupA = state.group;
	enabled = getValue(state.enabled)[id];
	expanded = getValue(state.expanded)[id];
	position = getValue(state.positions)[id];
	style = getValue(state.style)[id];
	isHorizontal = contains(style, MDockingMobileHorizontal());

	darkTheme = contains(style, MDockingForceDarkTheme());
	lightTheme = contains(style, MDockingForceLightTheme());
	theme = if (darkTheme) const(false) else if (lightTheme) const(true) else manager.white;

	resizePressed = make(false);
	isResizing = make(false);
	isHovering = make(false);
	content = makeDockingPanelContent(state, id, true, isHorizontal, resizePressed, isHovering, theme, style);

	color = extractStruct(style, if (fgetValue(theme)) textColorLight else textColorDark);
	pad = 36.0;

	// Mobile size
	size = getValue(state.mobileSize)[id];
	width = getTropicMetrics(size).width;
	height = getTropicMetrics(size).height + dockingBarHeight;

	ifMobile = extractStruct(style, MDockingMobileWatcher(make(false))).mobile;
	disableButton = contains(style, MDockingDisableButton());
	dontShowSep  = contains(style, MDockingDontShowSeparators());

	mouseXyLocal = make(zeroPoint);
	dragPressed = make(false);
	WH = makeWH();
	nextDistinct(WH, WidthHeight(width, height));


	draggingShape = TSelect(state.mobileSize, \ms ->
		if (getValue(getValue(state.expanded)[id])) TAlpha(const(dockingMobileOpacity), TRounded(dockingRadius, dockingRadius, dockingRadius, dockingRadius, [MFill(dockingPrimaryColor)], ms[id]))
		else TAlpha(const(dockingMobileOpacity), TRounded(dockingRadius, dockingRadius, dockingRadius, dockingRadius, [MFill(dockingPrimaryColor)], TFixed(getTropicMetrics(ms[id]).width, dockingBarHeight)))
	);

	makeResizablePanel = \c : Material -> {
		MSelect(manager.white, \lg ->
			MConstruct([
					makeSubscribe(isResizing, \rs -> {
						if (!rs) {
						// update mobile size
						next(state.mobileSize, replace(getValue(state.mobileSize), id , TSized(WH)));
					}
				})
			],
			MInteractive([TMouseXY(mouseXyLocal)],
				if (isHorizontal) {
					MShadow(const(4.0),
					MColsA([
						makePanelTopBar(false, id, state, !isHorizontal, lg),
						MSelect(expanded,\e ->
							if (e)
								MAvailable(
									MGroup([
										TRectangle([MFill(areaBgColorFn(lg, style))], size |> TRotate90 ),
										MCenterIn(c, size |> TRotate90),
									]),
									size |> TRotate90
								)
							else TEmpty()
						)
					]));
				} else {

					MShadow(const(4.0),
						MSelect(expanded,\e -> {
							MAvailable(
								MLines([
									makePanelTopBar(false, id, state, !isHorizontal, lg),
									 if (e) MGroup([TRectangle([MFill(panelBgColorFn(lg, style))], TFillXY()), c]) else TEmpty()
								]),
								if (e) TSized(WH) else TSelect(WH, \wh ->  TFixed(wh.width, dockingBarHeight)),
							)
						}),
					);
				}
			))
		);
	}

	movablePanel = MDraggable(id,
		MSelect(manager.manager.dragging, \h -> {
			d = MConstruct([
				makeSubscribe(dragPressed, \p -> {
					if (p) next(cursorPositionA, replace(getValue(cursorPositionA), id, getValue(mouseXyLocal)));
				})],
				makeResizablePanel(content)
			);

			if (h == id) draggingShape else d;
		})|> (\f-> MInteractive([TMouseDownGhost(dragPressed)],f)),
		[]
	);

	MConstruct([
		makeSubscribe(resizePressed, \p -> {
			if (p) {
				addMInteractionItemId(manager, itemId);
				next(isResizing, true);
			} else {
				if (getValue(isResizing)) next(isResizing, false);
			}
		}),
		makeSubscribe(mouseXyLocal, \mxy -> {
			if (isCurrentMInteractionItemId(manager, itemId) && getValue(isResizing)) {
				blockOtherMInteractionItemIds(manager, itemId);
				if (mxy.y >= height) nextDistinct(WH, WidthHeight(getValue(WH).width, mxy.y)) else nextDistinct(WH, WidthHeight(getValue(WH).width, height));
			}
		}),
		makeSubscribe(mouseXyLocal, \mxy -> {
			if (isCurrentMInteractionItemId(manager, itemId) && getValue(isResizing)) {
				blockOtherMInteractionItemIds(manager, itemId);
				if (mxy.x >= width) nextDistinct(WH, WidthHeight(mxy.x, getValue(WH).height)) else nextDistinct(WH, WidthHeight(width, getValue(WH).height));
			}
		})],
		MSelect(dockA, \d -> if (d[id][0] < 0) {
				next(getValue(state.sideExpanded)[id], true);
				next(ifMobile, true);
				MSelect(enabled, \e -> if (e) MTranslate(const(getValue(position)), movablePanel) else TEmpty());
			} else {
				next(ifMobile, false);
				TEmpty();
		})
	) |> (\f -> (MExplicitTheme(f, theme, [])));
}


makeDockedPanel(state : MDockingState, id : int, groupName : string, isColumn : bool, fillPanel : bool, style : [MDockingStyle], barHeight: double, sideCollapsed : DynamicBehaviour<bool>, zorder : int) -> Material {
	manager = state.manager;
	itemId = makeTropicTag(manager);
	title = getValue(state.title)[id];
	pstyle = getValue(state.style)[id];
	panelIcon = if (getValue(state.panelIcon)[id] == "") "web_asset" else getValue(state.panelIcon)[id];
	groupA = state.group;
	dockedSize = getValue(state.dockedSize)[id];
	dropSize = dockingDragSize;
	dragSize = dockingDragSize;
	sideCollapsedSize = dockingSideCollapsedSize;
	isHorizontal = contains(pstyle, MDockingMobileHorizontal());
	resizePressed = make(false);
	dragPressed = make(false);
	isResizing = make(false);
	isHovering = make(false);
	mouseXyLocal = make(zeroPoint);

	hasScrollPos = \dockingstyle -> {
		!exists([MDockingScrollPosition(make(zeroPoint))], \dsp -> isSameStructType(dsp, dockingstyle))
	};

	scrollPos = extractStruct(style, MDockingScrollPosition(make(zeroPoint))).scrollPos;

	hasScrollInspectVisible = \dockingstyle -> {
		!exists([MDockingScrollInspectVisible(make(zeroPoint), makeWH())], \dsiv -> isSameStructType(dsiv, dockingstyle))
	};

	scrollTopLeft = extractStruct(style, MDockingScrollInspectVisible(make(zeroPoint), makeWH())).scrollTopLeft;
	scrollWidthHeight = extractStruct(style, MDockingScrollInspectVisible(make(zeroPoint), makeWH())).scrollWidthHeight;


	WH = if (isColumn) make(WidthHeight(getTropicMetrics(dockedSize).width, getTropicMetrics(dockedSize).height))
		else make(WidthHeight(getTropicMetrics(dockedSize).height, getTropicMetrics(dockedSize).width));

	expanded = getValue(state.expanded)[id];
	sideExpanded = getValue(state.sideExpanded)[id];
	enabled = getValue(state.enabled)[id];

	darkTheme = contains(style, MDockingForceDarkTheme());
	lightTheme = contains(style, MDockingForceLightTheme());
	theme = if (darkTheme) const(false) else if (lightTheme) const(true) else manager.white;

	fillHeightArea = contains(style, MDockingFillSpace());
	fillHeight = fillHeightArea || contains(pstyle, MDockingFillSpace());

	collapsedSepColor = MGrey(400);

	isToolbarItem = isSameStructType(getValue(state.content)[id][0], MDockingPanelToolbarItem("", []));
	dontResize  = contains(pstyle, MDockingDontResize());
	dontMove  = contains(pstyle, MDockingDontMove());
	dontScroll  = contains(pstyle, MDockingDontScroll());

	mHeight = if (isColumn) getTropicMetrics(getValue(state.mobileSize)[id]).height else getTropicMetrics(getValue(state.mobileSize)[id]).width;
	mWidth = if (isColumn) getTropicMetrics(getValue(state.mobileSize)[id]).width else getTropicMetrics(getValue(state.mobileSize)[id]).height;


	height = if (isColumn) getTropicMetrics(getValue(state.dockedSize)[id]).height else getTropicMetrics(getValue(state.dockedSize)[id]).width;
	width = if (isColumn) getTropicMetrics(getValue(state.dockedSize)[id]).width else getTropicMetrics(getValue(state.dockedSize)[id]).height;
	size = if (fillPanel || fillHeight) TFillXY() else TFixed(width, height);


	// Panel's content
	content = makeDockingPanelContent(state, id, false, !isColumn, make(false), make(false), theme, pstyle);

	pad = 10.0;
	dragHandleSize = if (isColumn) TFillXH(dragSize) else TFillWY(dragSize);

	posCorrection =
	if (isColumn) {dx = 0.0; dy = 0.0; Point(-dx, dy);}
		else {dx = 4.0; dy = (height / 2.0) - 12.0; Point(dx, -dy);};

	panelSize = if (isColumn) TFixed(mWidth, mHeight + dockingBarHeight) else TFixed(mWidth + dockingBarHeight, mHeight);

	draggingShape = TRounded(dockingRadius, dockingRadius, dockingRadius, dockingRadius, [MFill(dockingPrimaryColor)], panelSize);

	topDragHandle = MSelect(manager.white, \lg ->
		if (dontMove) makePanelTopBar(true, id, state, isColumn, lg) else
		MDraggable(id, makePanelTopBar(true, id, state, isColumn, lg),
			[TDragShape(TTranslate(const(posCorrection), TAlpha(const(dockingMobileOpacity), draggingShape)))]
		)
	);

	topBar = MInteractive([TMouseDown(dragPressed)], 
		if (isColumn) MCenterIn(topDragHandle, TFillXH(dockingBarHeight)) else MCenterXIn(topDragHandle, TFillWY(dockingBarHeight / 2.0)));

	panelWithTopBar = if (isColumn) {
		MLines([
			topBar,


			// MShowLazy(sideExpanded, \ -> 
			MSelect(sideExpanded, \se -> if (se)
				// MIfLazy(expanded, \e -> if (e) {
				MSelect(expanded, \e -> if (e) {
						if (dontScroll) {
							MCropSize(TFillXY(), content)
						} else {
							MScroll(
								content, TFillXY(),
								if (hasScrollPos(style) && hasScrollInspectVisible(style))
									[MScrollPosition(scrollPos), TScrollInspectVisible(scrollTopLeft, scrollWidthHeight)]
								else if (hasScrollPos(style))
									[MScrollPosition(scrollPos)]
								else []
							)
						}


					} else TFillXH(dockingCollapsedSeparatorH)
				)    // scroll for single inner panel

				else TEmpty()
			)

		]);
	} else {
		if (dontMove) content else MCols([topBar,  content]);
	}

	draggingHandleInactive = \lg : bool -> TRectangle([MFill(separatorColorFn(lg, style)), FillOpacity(0.05)], dragHandleSize);

	draggingHandle = \lg : bool -> {
		smallHandle = TRectangle([MFill(resizeHandleColorFn(lg, style))], if (isColumn) TFixed(dockingHandleH, dockingHandleW) else TFixed(dockingHandleW, dockingHandleH));
		MSelect(manager.manager.dragging, \dr ->
			if ((dr >= 0) && (dr < length(getValue(state.title))) && zorder >= getValue(manager.manager.zorder) && (dr < length(getValue(groupA))) && (contains(getValue(groupA)[dr], groupName))) {
				MGroup2(TRectangle([MFill(separatorColorFn(lg, style))], dragHandleSize), MCenterIn(smallHandle, dragHandleSize))
			} else {
				MSelect(expanded, \e -> if (e) {
					if (fillHeight || !getValue(getValue(state.sideExpanded)[id])) TEmpty() else
					MCursor(MoveCursor(),
						MInteractive([TMouseDown(resizePressed), TMouseInside(isHovering, false)],
							MGroup2(
								MSelect(isHovering,\h -> if (h) TRectangle([MFill(dockingPrimaryColor)], dragHandleSize) else TRectangle([MFill(separatorColorFn(lg, style))], dragHandleSize)),
								MCenterIn(smallHandle, dragHandleSize)
							)
						)
					)} else TRectangle([MFill(collapsedSepColor), FillOpacity(0.4)], TFillXH(dockingCollapsedSeparatorH))
				)
			}
		)
	}

	MSelect(manager.white, \lg ->
		MConstruct([
			makeSubscribe(resizePressed, \p -> {
				if (p) {
					addMInteractionItemId(manager, itemId);
					next(isResizing, true);
				} else {
					if (getValue(isResizing)) {
						next(isResizing, false);
					}
				}
			}),
			makeSubscribe(mouseXyLocal, \mxy -> {
				if (isCurrentMInteractionItemId(manager, itemId) && getValue(isResizing)) {
					blockOtherMInteractionItemIds(manager, itemId);
					if (isColumn) nextDistinct(WH, WidthHeight(getValue(WH).width, mxy.y))
						else nextDistinct(WH, WidthHeight(mxy.x, getValue(WH).height));

					// UPDATE DOCKED SIZE
					nextDistinct(state.dockedSize, replace(getValue(state.dockedSize), id, TFixed(getValue(WH).width, getValue(WH).height)));
				};
			})],
			MInteractive([TMouseXY(mouseXyLocal)],
				MSelect(sideExpanded, \se -> {
					MSelect(expanded, \e -> {
// println(id);
// println("fillHeight");
// println(fillHeight);
// println("fillPanel");
// println(fillPanel);
						dockedSpace = {
							if (isColumn) {
								if (fillHeight || fillPanel) {
									println("Panel " + title + " - fillHeight: " + b2s(fillHeight) + " fillPanel: " + b2s(fillPanel));
									if (e || se) TGroup2(TFillXY(), TSelect(WH, \wh -> {
										
																					
											
											println(" -------->");
										println(wh.height);
										println(" -------->");
										
										TFillXH(wh.height)})) else TFillXH(dockingBarHeight + dockingCollapsedSeparatorH);
								} else {
									if (se) {
										

										if (e) TSelect(WH, \wh -> TFillXH(wh.height)) else TFillXH(dockingBarHeight);
									} else {TFixed(sideCollapsedSize, dockingBarHeight);}
								}


								// if (fillHeight || fillPanel) {
								// 	// if (e || se) TGroup2(TFillXY(), TSelect(WH, \wh -> TFillXH(wh.height))) else TFillXH(dockingBarHeight + dockingCollapsedSeparatorH);
								// 	if (e || se) TSelect(WH, \wh -> TFillXH(wh.height)) else TFillXH(dockingBarHeight + dockingCollapsedSeparatorH);
								// } else {
								// 	if (se) {
								// 		if (e) TSelect(WH, \wh -> TFillXH(wh.height)) else TFillXH(dockingBarHeight);
								// 	} else TFixed(sideCollapsedSize, dockingBarHeight);
								// }




							} else {
								if (fillHeight || fillPanel) TGroup2(TFillXY(), TSelect(WH, \wh -> TFillWY(wh.width + dockingBarHeight))) else TSelect(WH, \wh -> TFillWY(wh.width + dockingBarHeight));
							}
						}

						MAvailable(
							if (isColumn) {
								MLines([

									MGroup2(
										// Panel background

										// if (se) {
										// 	r = dockingRadius;
										// 	if (e) TRounded(r,r,r,r, [MFill(panelBgColorFn(lg, style))/*, Stroke(0x000000)*/], TFillXY()) else TFillXH(dockingBarHeight);
										// } else {
										// 	TFixed(sideCollapsedSize, dockingBarHeight)
										// },

										MEmpty(),
										panelWithTopBar
									),
									// if (fillPanel || isToolbarItem) TEmpty() else draggingHandle(lg), 
									// TRectangle([MFill(MBrown(500)), FillOpacity(1.0)], TFillXH(dockingCollapsedSeparatorH))
									//  if (fillPanel || isToolbarItem) draggingHandleInactive(lg) else draggingHandle(lg)


								])

// |> (\f -> MGroup2(f, TRectangle([MFill(MBlue(500)), FillOpacity(0.9)], TFillXY()) |> MBorderBottom(0.0)))
							} else {
								MColsA([
									MGroup2(
										TRectangle([MFill(panelBgColorFn (lg, style))], TFillXY()),
										panelWithTopBar
									),
									if (fillPanel || isToolbarItem) TEmpty() else draggingHandle(lg)
									//  if (fillPanel || isToolbarItem) draggingHandleInactive(lg) else draggingHandle(lg)
								])
							},
							dockedSpace
						) 

						// |> (\f -> MGroup2(MFrame(0.0, 0.0, [MFill(MBlue(500)), FillOpacity(0.7)], dockedSpace), f))




					})
				})
			)
		)
	)
	|> (\f -> (MExplicitTheme(f, theme, [])))
	|> (\f -> (MConstruct([makeSubscribe(enabled, \e -> {
		if (!e) next(state.dock, mapi(getValue(state.dock), \j, item -> if (j == id) [-1, item[1], item[2]] else item)); //undock
	})], f)));
}