import material/material2tropic;
import material/extra/docking_ui/internal/material_docking_utils;
import material/extra/docking_ui/internal/material_docking_drop;

export {
	// NOTE: example in flow9/lib/material/tests/test_docking_ui.flow

	// Each panel can be movable or docked, and it's defined by:
	MDockingPanel(
		// note: if content is [MDockingPanelToolbarItem] is not used
		title : string,
		// creates easily different standard panels as array of MDockingPanelItems
		content : [MDockingPanelItem],
		// store the position where the panel is docked
		panelDock : MDock,
		// panels can be moved and docked on different allowed groups of MDockingAreas, group name's are defined inside each MDockingArea by "groupName", if [] you can dock the panel everywhere
		allowedGroups : [string],
		// panel's style
		style : [MDockingStyle]
	);
						
	makeMovablePanel(state : MDockingState, panelId : int, cursorPositionA : DynamicBehaviour<[Point]>) -> Material;
	makeDockedPanel(state : MDockingState, panelId : int, gridPosition : Pair<int/*col*/, int /*row*/>, colA : [int], dropInfo : MDockingDropInfo, isColumn : bool, fillPanel : bool, style : [MDockingStyle], barHeight: double, sideCollapsed : DynamicBehaviour<bool>, zorder : int) -> Material;
}


makeDockingPanelContent(state : MDockingState, panelId : int, mobilePanel : bool, isHorizontal : bool, resizePressed : DynamicBehaviour<bool>, isHovering : DynamicBehaviour<bool>, theme : Transform<bool>, style : [MDockingStyle]) -> Material {
	contentA = getValue(state.content)[panelId];
	width = getValue(state.size)[panelId].width;
	dontShowSep = contains(style, MDockingDontShowSeparators());
	dontResize  = contains(style, MDockingDontResize());
	resizeHandleColor = if (fgetValue(theme)) textColorLight else textColorDark;
	isToolbarItem = isSameStructType(getValue(state.content)[panelId][0], MDockingPanelToolbarItem("", []));

	resizeHandleMobile = MInteractive(
		[
			TMouseDown(resizePressed), 
			TMouseInside(isHovering, false)
		],
		makeMDockingResizeHandleMobile(state, style)
	);

	buttonsA = mapi(contentA, \i, c -> {

		switch (c : MDockingPanelItem) {
			MDockingPanelToolbarItem(picon, itemStyle): {
				click  = extractStruct(itemStyle, MOnClick(nop)).click;
				pad = 10.0;
				minWidth = 48.0;
				sep = if (dontShowSep) TEmpty() else MSeparator(!isHorizontal);
				buttonSep = if (i == length(contentA) - 1) TEmpty() else {if (dontShowSep) TEmpty() else sep}

				ic = MCursor(FingerCursor(), MIcon(picon, [MIconSize(dockingToolbarIconSize)]));
				button = MRawButton(ic, ic, ic, ic, "", [], [TOnClicked(click)]);

				b = if (isHorizontal) MCols2A(MCenterIn(button, TFillWY(minWidth)), buttonSep)
						else MLines2(MCenterIn(button, TFillXH(minWidth)), buttonSep);

				if (!isHorizontal) MBorder(pad, 0.0, pad, 0.0, b) else MBorder(0.0, pad, 0.0, pad, b);
			}
			MDockingPanelCustomItem(mat, msize, st): mat;
		};
	});

	MGroup([
		if (isHorizontal) MColsA(buttonsA) else MLines(buttonsA),
		if (mobilePanel) {if (dontResize || isToolbarItem) TEmpty() else resizeHandleMobile;} else TEmpty()
	]);
}

makePanelTopBar(docked : bool, panelId: int, state : MDockingState, isColumn: bool, light : bool) -> Material {
	manager = state.manager;
	pstyle = getValue(state.panelStyle)[panelId];
	enabled = getValue(state.enabled)[panelId];
	expanded = getValue(state.expanded)[panelId];
	sideExpanded = getValue(state.sideExpanded)[panelId];
	position = getValue(state.positions)[panelId];
	title = getValue(state.title)[panelId];
	minTitleEllipsisWidth = extractStruct(pstyle, MDockingMinTitleEllipsisWidth(120.0)).width;
	// Size
	size = if (docked) getValue(state.dockedSize)[panelId] else getValue(state.mobileSize)[panelId];
	width = size.width;
	height = size.height;
	isHorizontal = contains(pstyle, MDockingMobileHorizontal());
	topBarSize = TFillXH(dockingBarHeight);
	// Prop
	ifMobile = extractStruct(pstyle, MDockingMobileWatcher(make(false))).mobile;
	disableButton = contains(pstyle, MDockingDisableButton());
	isToolbarItem = isSameStructType(getValue(state.content)[panelId][0], MDockingPanelToolbarItem("", []));
	disableExpander = contains(pstyle, MDockingDisablePanelExpander());
	// Theme
	darkTheme = contains(pstyle, MDockingForceDarkTheme());
	lightTheme = contains(pstyle, MDockingForceLightTheme());
	theme = if (darkTheme) const(false) else if (lightTheme) const(true) else manager.white;
	// Colors
	color = extractStruct(pstyle, if (fgetValue(theme)) textColorLight else textColorDark);
	bgHandleColor = extractStruct(pstyle, if (fgetValue(theme)) bgHandleColorLight else bgHandleColorDark);

	dockedBarColorToolbar = extractStruct(pstyle, if (fgetValue(theme)) panelBgColorLight else areaBgColorDark);
	barColor : MColor = if (fgetValue(theme)) barColorLight else barColorDark;
	// barColor : MColor = if (fgetValue(theme)) areaBgColorLight else areaBgColorDark;
	titleColor : MColor = if (fgetValue(theme)) textColorLight else textColorDark;

	addTooltip = \label : string, m : Material -> MTooltip(m , MText(label, [MTooltipDesktop()]), []);
	getPanelIcon = \st : [MIconStyle] ->  {
		// eitherFn(tryExtractStruct(pstyle, MDPanelIcon("web_asset")),
		// 	\m -> MIcon(m.icon, concat([titleColor], st)),
		// 	\ -> MEmpty()
		// );
		icon = extractStruct(pstyle, MDPanelIcon("web_asset")).icon;
		MIcon(icon, concat([titleColor], st));
	}

	makeIconToggleButton = \boolB : DynamicBehaviour<bool>,
		iconOn : string, iconOff : string,
		tooltipOn : string, tooltipOff :string,
		iconSize: double, clickFn : () -> void,
		iconColor : MColor, fill : double -> {
			MSelect(boolB,\b -> if (b) MIconButton(iconOn, clickFn, [MIconSize(iconSize), iconColor, FillOpacity(fill), MIconButtonBorder(1.0)], []) |> (\f -> addTooltip(tooltipOn, f))
				else MIconButton(iconOff, clickFn, [MIconSize(iconSize), iconColor, FillOpacity(fill), MIconButtonBorder(1.0)], []) |> (\f -> addTooltip(tooltipOff, f))
			) |> MCenterY
	}

	// Panel's buttons
	customButtonsA = extractStruct(pstyle, MDockingCustomButtons([])).buttons;
	customButtons = customButtonsA != [];
	panelButtonsA = map(customButtonsA, \btn -> {
		clickedB = make(false);
		switch (btn) {
			MDockingCustomButton(ic, tt, clkFn, st) : {
				btnColor = extractStruct(st, titleColor);
				makeIconToggleButton(clickedB, ic, ic, tt, tt, dockingTopBarIconSize, clkFn, btnColor, 0.5);
			}
			default: MEmpty();
		} |> MCenterY

	});

	// Handles
	linedHandle = makeMDockingLinedHandle(isHorizontal, titleColor);
	dottedHandle =  makeMDockingDottedHandle(isColumn, color);

	// TopBar Content
	panelTopBarButtons = {
		MBaselineColsA([
			getPanelIcon([MIconSize(dockingTopBarIconSize), FillOpacity(dockingTitleOpacity)])
				|> MBorderLeft(10.0)
				|> MCenterY,
			MEllipsisText(title, [titleColor, dockingTitleFont, MMinWidth(minTitleEllipsisWidth)]) 
			|> MBorderLeft(10.0) 
			|> MCenterY,
			TFillX(),
			if (customButtons)
				MBaselineColsA(panelButtonsA) |> MCenterY
			else TEmpty(),
			if (disableButton)
				MCols2A(
					TFixed(6.0, 0.0),
					MIconButton("close", \ -> next(enabled, false), [MIconSize(dockingTopBarIconSize - 4.0), titleColor, MIconButtonBorder(1.0), FillOpacity(0.5)], [])
					|> (\f -> addTooltip("hide panel", f)) |> MCenterY
				)
			else TEmpty(),
			TFixed(4.0, 0.0),

			if (disableExpander)
				TEmpty()
			else
				makeIconToggleButton(
					expanded,
					"keyboard_arrow_up",
					"keyboard_arrow_down",
					"collapse panel",
					"expand panel",
					dockingTopBarIconSize,
					\ -> {
						reverseBehaviour(expanded);
						// next(state.dock, getValue(state.dock)); //force redraw (should be used for mobile)
					},
					titleColor,
					0.5
				) |> showIf(isColumn),


			TFixed(8.0, 0.0)
		])
	}

	dockedTopBar = \isSideExpanded : bool  -> {
		MAvailable(
			MGroup([
				// Topbar background
				if (isColumn) {
					if (isSideExpanded) {
						MIfLazy(expanded,\e -> 
							if (e) TRounded(dockingRadius, dockingRadius, 0.0, 0.0, [MFill(barColor), FillOpacity(1.0)], TFillXH(dockingBarHeight))
								else TRounded(dockingRadius, dockingRadius, dockingRadius, dockingRadius, [MFill(barColor)], TFillXH(dockingBarHeight))
						) |> showIf(!contains(pstyle, MDPDontShowDockedTopBar()));
					} else {
						TRounded(dockingRadius, dockingRadius, dockingRadius, dockingRadius, [MFill(barColor)], TFillXH(dockingBarHeight))
							|> (\f -> addTooltip(title + " panel", f))
					}

				} else {
					TRectangle([MFill(barColor), FillOpacity(0.0)], TFillXH(dockingBarHeight))
				// Toolbar item options
				// 	// TRounded(dockingRadius, 0.0, 0.0, dockingRadius, [MFill(areaBgColorFn(fgetValue(theme), pstyle))], TFillWY(dockingBarHeight / 2.0))
				// 	TRounded(dockingRadius, 0.0, 0.0, dockingRadius, [MFill(barColor)], TFillWY(dockingBarHeight / 2.0))
				// 	// TRectangle([MFill(areaBgColorFn(fgetValue(theme), pstyle))], TFillWY(dockingBarHeight / 2.0))
				},

				// Topbar content
				if (isToolbarItem) {
					MGroup2(
						TRectangle([MFill(areaBgColorFn(fgetValue(theme), pstyle))], topBarSize),
						MCenterIn(dottedHandle, topBarSize)
					)
				} else {
					// if (isColumn)
						if (isSideExpanded) panelTopBarButtons else {			
							getPanelIcon([MIconSize(sideExpanderButtonSize), FillOpacity(0.3)])
								|> MCenter
						}
					// else MCenterIn(dottedHandle, TFillWY(dockingBarHeight / 2.0));
				}
			]), topBarSize
		);
	};

	mobileTopBar =
		if (isHorizontal) {
			MSelect(expanded,\e ->
				MAvailable(
					MGroup([
						if (e) TRounded(dockingRadius, 0.0, 0.0, dockingRadius, [MFill(barColor)], TFillXY())
						else TRounded(dockingRadius, dockingRadius, dockingRadius, dockingRadius, [MFill(barColor)], TFillXY()),
						MCenterIn(linedHandle, TFixed(dockingBarHeight, width)),
					]),
					TFixed(dockingBarHeight, width)
				)
			);
		} else {
			MAvailable(
				MGroup([
					MSelect(expanded,\e -> if (e) TRounded(dockingRadius, dockingRadius, 0.0, 0.0, [MFill(barColor)], TFillXY())
						else TRounded(dockingRadius, dockingRadius, dockingRadius, dockingRadius, [MFill(barColor)], TFillXY())	
					),
					if (isSameStructType(getValue(state.content)[panelId][0], MDockingPanelToolbarItem("", [])))
						MCenterIn(linedHandle, TFillXH(dockingBarHeight))
					else panelTopBarButtons			
				]),
				TFillXH(dockingBarHeight)
			);
		}

	MSelect(getValue(state.sideExpanded)[panelId], \se -> {
		if (se) {
			if (docked) dockedTopBar(se) else mobileTopBar;
		} else {
			dockedTopBar(se);
		}
	});
}

makeMovablePanel(state : MDockingState, panelId : int, cursorPositionA : DynamicBehaviour<[Point]>) -> Material {
	manager = state.manager;
	itemId = makeTropicTag(manager);
	dockA = state.dock;
	groupA = state.group;
	enabled = getValue(state.enabled)[panelId];
	expanded = getValue(state.expanded)[panelId];
	position = getValue(state.positions)[panelId];
	style = getValue(state.panelStyle)[panelId];
	isHorizontal = contains(style, MDockingMobileHorizontal());
	cacheEnabled = extractStruct(state.style, MDockingEnableLoadAndStoreCache(false)).cacheEnabled;

	darkTheme = contains(style, MDockingForceDarkTheme());
	lightTheme = contains(style, MDockingForceLightTheme());
	theme = if (darkTheme) const(false) else if (lightTheme) const(true) else manager.white;

	resizePressed = make(false);
	isResizing = make(false);
	isHovering = make(false);
	content = makeDockingPanelContent(state, panelId, true, isHorizontal, resizePressed, isHovering, theme, style);

	color = extractStruct(style, if (fgetValue(theme)) textColorLight else textColorDark);
	pad = 36.0;

	// println(" > DRAW - MovablePanel -m- " + i2s(panelId) /*+ "      - " + toString(colA)*/);

	// Mobile size
	size = getValue(state.mobileSize)[panelId];
	width = size.width;
	// height = size.height + dockingBarHeight;
	height = size.height;

	ifMobile = extractStruct(style, MDockingMobileWatcher(make(false))).mobile;
	disableButton = contains(style, MDockingDisableButton());
	dontShowSep  = contains(style, MDockingDontShowSeparators());

	mouseXyLocal = make(zeroPoint);
	dragPressed = make(false);
	WH = makeWH();
	nextDistinct(WH, WidthHeight(width, height));
	r = dockingRadius;

	draggingShape = TSelect(state.mobileSize, \ms ->
		if (getValue(getValue(state.expanded)[panelId])) {
			TRounded(r, r, r, r, [MFill(dockingPrimaryColor /*panelBgColorFn(fgetValue(theme), style)*/), FillOpacity(dockingMobileOpacity)], TFixed(ms[panelId].width, ms[panelId].height))
		} else TRounded(r, r, r, r, [MFill(dockingPrimaryColor), FillOpacity(dockingMobileOpacity)], TFixed(ms[panelId].width, dockingBarHeight))
	);

	makeResizablePanel = \c : Material -> {
		MSelect(manager.white, \lg ->
			MConstruct([
					makeSubscribe(isResizing, \rs -> {
						if (!rs) {
						// update mobile size
						next(state.mobileSize, replace(getValue(state.mobileSize), panelId , getValue(WH))); //
					}
				})
			],
			MInteractive([TMouseXY(mouseXyLocal)],
				// TODO: Toolbar item options
				// if (isHorizontal) {
				// 	MShadow(const(4.0),
				// 	MColsA([
				// 		makePanelTopBar(false, panelId, state, !isHorizontal, lg),
				// 		MSelect(expanded,\e ->
				// 			if (e)
				// 				MAvailable(
				// 					MGroup([
				// 						// TRectangle([MFill(areaBgColorFn(lg, style))], size |> TRotate90 ),
				// 						MCenterIn(c, size), // |> TRotate90),
				// 					]),
				// 					size //|> TRotate90
				// 				)
				// 			else TEmpty()
				// 		)
				// 	]));
				// } else {
					MShadow(const(4.0),
						MSelect(expanded,\e -> {
							MAvailable(
								MLines2(
									makePanelTopBar(false, panelId, state, !isHorizontal, lg),
									if (e) c else TEmpty() 
								) |> (\f -> MFrame(0.0, r, [MFill(panelBgColorFn(lg, style))], f)),
								if (e) TSized(WH) else TSelect(WH, \wh ->  TFixed(wh.width, dockingBarHeight)),
							)
						}),
					)
				// }
			))
		);
	}

	movablePanel = MDraggable(panelId,
		MSelect(manager.manager.dragging, \h -> {
			d = MConstruct([
				makeSubscribe(dragPressed, \p -> {
					if (p) next(cursorPositionA, replace(getValue(cursorPositionA), panelId, getValue(mouseXyLocal)));
				})],
				makeResizablePanel(content)
			);
			if (h == panelId) draggingShape else d;
			// d
		})|> (\f-> MInteractive([TMouseDownGhost(dragPressed)],f)),
		[]
	);

	MConstruct([
		makeSubscribe2(isResizing, \rs -> { 
				if (!rs) {
					// Update mobile size
					updateH(state.mobileSize, panelId,  getValue(WH).height);
					updateW(state.mobileSize, panelId,  getValue(WH).width);
					// Update docked size
					updateH(state.dockedSize, panelId,  getValue(WH).height);
					updateW(state.dockedSize, panelId,  getValue(WH).width);

					// Update cache
					if (cacheEnabled) setMDockingStateKeyValue(state) |> ignore;
				}
			}),
		makeSubscribe(resizePressed, \p -> {
			if (p) {
				addMInteractionItemId(manager, itemId);
				next(isResizing, true);
			} else {
				if (getValue(isResizing)) next(isResizing, false);
			}
		}),
		makeSubscribe(mouseXyLocal, \mxy -> {
			if (isCurrentMInteractionItemId(manager, itemId) && getValue(isResizing)) {
				blockOtherMInteractionItemIds(manager, itemId);
				// if (mxy.y >= height) nextDistinct(WH, WidthHeight(getValue(WH).width, mxy.y)) else nextDistinct(WH, WidthHeight(getValue(WH).width, height));
				if (mxy.y >= dockingBarHeight) nextDistinct(WH, WidthHeight(getValue(WH).width, mxy.y)) else nextDistinct(WH, WidthHeight(getValue(WH).width, height));

				// if (mxy.x >= width) nextDistinct(WH, WidthHeight(mxy.x, getValue(WH).height)) else nextDistinct(WH, WidthHeight(width, getValue(WH).height));
				if (mxy.x >= dockingBarHeight) nextDistinct(WH, WidthHeight(mxy.x, getValue(WH).height)) else nextDistinct(WH, WidthHeight(width, getValue(WH).height));
			}
		})],	
		MSelect(dockA, \d -> 
		if (d[panelId].areaId < 0) {
				next(getValue(state.sideExpanded)[panelId], true);
				next(ifMobile, true);
				MSelect(enabled, \e -> if (e) 
					MTranslate(
						const(getValue(position)), 
						movablePanel
					) else TEmpty()
				);
			} else {
				next(ifMobile, false);
				TEmpty();
		})
	) |> (\f -> (MExplicitTheme(f, theme, [])));
}

makeDockedPanel(state : MDockingState, panelId : int, gridPosition : Pair<int/*col*/, int /*row*/>, colA : [int], dropInfo : MDockingDropInfo, isColumn : bool, fillPanel : bool, style : [MDockingStyle], barHeight: double, sideCollapsed : DynamicBehaviour<bool>, zorder : int) -> Material {
	manager = state.manager;
	pstyle = getValue(state.panelStyle)[panelId];
	panelDockedSize = getValue(state.dockedSize)[panelId];
	rowId = gridPosition.second;

	// Scroll
	hasScrollPos = \dockingstyle -> {
		!exists([MDockingScrollPosition(make(zeroPoint))], \dsp -> isSameStructType(dsp, dockingstyle))
	};
	scrollPos = extractStruct(style, MDockingScrollPosition(make(zeroPoint))).scrollPos;
	hasScrollInspectVisible = \dockingstyle -> {
		!exists([MDockingScrollInspectVisible(make(zeroPoint), makeWH())], \dsiv -> isSameStructType(dsiv, dockingstyle))
	};
	scrollTopLeft = extractStruct(style, MDockingScrollInspectVisible(make(zeroPoint), makeWH())).scrollTopLeft;
	scrollWidthHeight = extractStruct(style, MDockingScrollInspectVisible(make(zeroPoint), makeWH())).scrollWidthHeight;

	// Expanded
	expanded = getValue(state.expanded)[panelId];
	sideExpanded = getValue(state.sideExpanded)[panelId];
	enabled = getValue(state.enabled)[panelId];
	
	// Theme
	darkTheme = contains(pstyle, MDockingForceDarkTheme());
	lightTheme = contains(pstyle, MDockingForceLightTheme());
	theme = if (darkTheme) const(false) else if (lightTheme) const(true) else manager.white;

	dontMove  = contains(pstyle, MDockingDontMove());
	dontScroll  = contains(pstyle, MDockingDontScroll());
	sideCollapsedSize = dockingSideCollapsedSize;
	r = dockingRadius;

	xheight = make(0.0);
	xwidth = make(0.0);
	// println(" > DRAW - DockedPanel - " + i2s(panelId) /*+ "      - " + toString(colA)*/);

	// Panel's content
	content = makeDockingPanelContent(state, panelId, false, !isColumn, make(false), make(false), theme, pstyle);

	dheight = if (isColumn) panelDockedSize.height else panelDockedSize.width;
	posCorrection = 
		if (isColumn) Point(0.0, 0.0) else {
			dx = 4.0; 
			dy = (dheight / 2.0) - 12.0; 
			Point(dx, -dy);
		}

	// Mobile size for dragging shape
	mHeight = getValue(state.mobileSize)[panelId].height;
	mWidth = getValue(state.mobileSize)[panelId].width;

	panelSize = TFixed(mWidth, mHeight);

	draggingShape = 
		TRounded(dockingRadius, dockingRadius, dockingRadius, dockingRadius, [
			// MFill(panelBgColorFn(fgetValue(theme), style)), 
			MFill(dockingPrimaryColor), 
			FillOpacity(dockingMobileOpacity), 
		], panelSize);

	cursor = fif(fselect(manager.manager.dragging, FLift(\dr -> dr >= 0)), const(GrabbingCursor()), const(GrabCursor()));
	topDragHandle = 
		MSelect(manager.white, \lg -> {
			// Test for removing top bar
			// MTooltip(
			// 	// MBorder4(12.0, MIcon("trip_origin", [MIconSize(dockingTopBarIconSize - 8.0), FillOpacity(0.9), dockedTitleColorFn(lg, [])])),
			// 	MBorder4(12.0, MIcon("trip_origin", [MIconSize(dockingTopBarIconSize - 8.0), FillOpacity(0.9), MYellow(500)])),
			// 	MText("Undock Panel", []),
			// 	[]
			// ) 	
			makePanelTopBar(true, panelId, state, isColumn, lg) 
				|> (\f -> if (dontMove) f else
					MDraggable(panelId, f, [
						TDragShape(TTranslate(const(posCorrection), draggingShape)),
						TCursorShape(DynamicCursor(cursor))
					])
				)
		});

	dPanel = \lg : bool ->
		// if (isColumn) {
			MLines([
				topDragHandle |> showIf(!contains(pstyle, MDPDontShowDockedTopBar())),
				MShowLazy(sideExpanded, \ ->
					MSelect(expanded, \e -> {		
							if (e) {
								if (dontScroll) {
									MCropSize(TFillXY(), content)
								} else {
									MScroll(
										content, TFillXY(),
										if (hasScrollPos(style) && hasScrollInspectVisible(style))
											[MScrollPosition(scrollPos), TScrollInspectVisible(scrollTopLeft, scrollWidthHeight)]
										else if (hasScrollPos(style))
											[MScrollPosition(scrollPos)]
										else []
									)
								}
							} else TFillXH(dockingCollapsedSeparatorH);			
					})
				)					
			]) |> (\f -> MFrame(0.0, r, [MFill(panelBgColorFn(lg, style))], f))

		// } else {
		// Toolbar item options 
		// 	dockedToolbar = if (dontMove) content else MCols([topDragHandle, content]);
		// 	dockedToolbar |> (\f -> MFrame(0.0, r, [MFill(panelBgColorFn(lg, style))], f))
		// }

	MExplicitTheme(
		dPanel(fgetValue(theme)),
		theme, []
	)	
}
