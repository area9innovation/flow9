import material/material2tropic;
import material/extra/docking_ui/internal/material_docking_utils;
import material/extra/docking_ui/internal/material_docking_drop;

export {
	// NOTE: example in flow9/lib/material/tests/test_docking_ui.flow

	// Each panel can be movable or docked, and it's defined by:
	MDockingPanel(
		// note: if content is [MDockingPanelToolbarItem] is not used
		title : string,
		// note: if content is [MDockingPanelToolbarItem] is not used
		panelIcon : string,
		// creates easily different standard panels as array of MDockingPanelItems
		content : [MDockingPanelItem],
		// set on which MDockingArea the panel is docked by default (a negative number means the panel is floating undocked)
		dockingAreaId : int,
		// it means "column's order" or "row's order" depending on where the panel is docked
		order : int,
		// panels can be moved and docked on different allowed groups of MDockingAreas, group name's are defined inside each MDockingArea by "groupName"
		allowedGroups : [string],
		// panel's style
		style : [MDockingStyle]
	);
		
	makeMovablePanel(state : MDockingState, panelId : int, cursorPositionA : DynamicBehaviour<[Point]>) -> Material;
	makeDockedPanel(state : MDockingState, panelId : int, gridPosition : Pair<int/*col*/, int /*row*/>, colA : [int], colHeightB : DynamicBehaviour<double>, dropInfo : MDockingDropInfo, isColumn : bool, fillPanel : bool, style : [MDockingStyle], barHeight: double, sideCollapsed : DynamicBehaviour<bool>, zorder : int) -> Material;
}


makeDockingPanelContent(state : MDockingState, panelId : int, mobilePanel : bool, isHorizontal : bool, resizePressed : DynamicBehaviour<bool>, isHovering : DynamicBehaviour<bool>, theme : Transform<bool>, style : [MDockingStyle]) -> Material {
	contentA = getValue(state.content)[panelId];
	width = getTropicMetrics(getValue(state.size)[panelId]).width;
	dontShowSep = contains(style, MDockingDontShowSeparators());
	dontResize  = contains(style, MDockingDontResize());
	resizeHandleColor = if (fgetValue(theme)) textColorLight else textColorDark;
	isToolbarItem = isSameStructType(getValue(state.content)[panelId][0], MDockingPanelToolbarItem("", []));

	resizeHandleMobile = MInteractive(
		[
			TMouseDown(resizePressed), 
			TMouseInside(isHovering, false)
		],
		makeMDockingResizeHandleMobile(state, style)
	);

	buttonsA = mapi(contentA, \i, c -> {

		switch (c : MDockingPanelItem) {
			MDockingPanelToolbarItem(picon, itemStyle): {
				click  = extractStruct(itemStyle, MOnClick(nop)).click;
				pad = 10.0;
				minWidth = 48.0;
				sep = if (dontShowSep) TEmpty() else MSeparator(!isHorizontal);
				buttonSep = if (i == length(contentA) - 1) TEmpty() else {if (dontShowSep) TEmpty() else sep}

				ic = MCursor(FingerCursor(), MIcon(picon, [MIconSize(dockingToolbarIconSize)]));
				button = MRawButton(ic, ic, ic, ic, "", [], [TOnClicked(click)]);

				b = if (isHorizontal) MCols2A(MCenterIn(button, TFillWY(minWidth)), buttonSep)
						else MLines2(MCenterIn(button, TFillXH(minWidth)), buttonSep);

				if (!isHorizontal) MBorder(pad, 0.0, pad, 0.0, b) else MBorder(0.0, pad, 0.0, pad, b);
			}
			MDockingPanelButtonsItem(picon, label, itemStyle): {
				onClick  = extractStruct(itemStyle, MOnClick(nop)).click;
				pad = 16.0;
				minWidth = 48.0;
				sep = if (dontShowSep) TEmpty() else {MSeparator(if (isHorizontal) false else true);};

				p = if (isHorizontal) {
					MCols2A(
						MAvailable(
							MColsA([
								MIconButton(picon, onClick, [MIconSize(dockingToolbarIconSize)], []) |>(\f -> MCenter(f)),
								TFillXY(),
							])|>(\f -> MCenterIn(f,TFixed(minWidth, minWidth) )),
							TFillXH(width)
						),
						if (i == length(contentA) - 1) TEmpty() else sep
					);
				} else {
					MLines2(
						MAvailable(
							MColsA([
								if (width <= 100.0)
								MIcon(picon, [MIconSize(dockingToolbarIconSize)]) |> (\f -> MCenterIn(f,TFillXH(minWidth)))
								else
								MIcon(picon, [MIconSize(dockingToolbarIconSize)]) |> (\f -> MCenterY(f)),
								if (width <= 100.0) TEmpty() else TFillXY(),
								if (width <= 100.0) TEmpty() else
								MText(label, [MListBody()])|>(\f -> MCenterY(f))
							]),
							TFillXH(minWidth)
						),
						if (i == length(contentA) - 1) TEmpty() else {if (dontShowSep) TEmpty() else sep}
					);
				}

				MBorder(pad, 0.0, pad, 0.0, p);
			}
			MDockingPanelCustomItem(mat, msize, st): mat;
		};
	});

	MGroup([
		if (isHorizontal) MColsA(buttonsA) else MLines(buttonsA),
		if (mobilePanel) {if (dontResize || isToolbarItem) TEmpty() else resizeHandleMobile;} else TEmpty()
	]);
}

makePanelTopBar(docked : bool, panelId: int, state : MDockingState, isColumn: bool, light : bool) -> Material {
	manager = state.manager;
	style = getValue(state.style)[panelId];
	enabled = getValue(state.enabled)[panelId];
	expanded = getValue(state.expanded)[panelId];
	sideExpanded = getValue(state.sideExpanded)[panelId];
	position = getValue(state.positions)[panelId];
	title = getValue(state.title)[panelId];
	minTitleEllipsisWidth = extractStruct(style, MDockingMinTitleEllipsisWidth(120.0)).width;
	panelIcon = if (getValue(state.panelIcon)[panelId] == "") "web_asset" else getValue(state.panelIcon)[panelId];
	// Size
	size = if (docked) getValue(state.dockedSize)[panelId] else getValue(state.mobileSize)[panelId];
	width = getTropicMetrics(size).width;
	height = getTropicMetrics(size).height;
	isHorizontal = contains(style, MDockingMobileHorizontal());
	// handleWidth = 24.0;
	// handleHeight = 24.0;
	topBarSize = if (isColumn) TFillXH(dockingBarHeight) else TFillWY(dockingBarHeight / 2.0);
	// Prop
	ifMobile = extractStruct(style, MDockingMobileWatcher(make(false))).mobile;
	disableButton = contains(style, MDockingDisableButton());
	isToolbarItem = isSameStructType(getValue(state.content)[panelId][0], MDockingPanelToolbarItem("", []));
	disableExpander = contains(style, MDockingDisablePanelExpander());
	// Theme
	darkTheme = contains(style, MDockingForceDarkTheme());
	lightTheme = contains(style, MDockingForceLightTheme());
	theme = if (darkTheme) const(false) else if (lightTheme) const(true) else manager.white;
	// Colors
	color = extractStruct(style, if (fgetValue(theme)) textColorLight else textColorDark);
	bgHandleColor = extractStruct(style, if (fgetValue(theme)) bgHandleColorLight else bgHandleColorDark);

	dockedBarColorToolbar = extractStruct(style, if (fgetValue(theme)) panelBgColorLight else areaBgColorDark);
	barColor : MColor = if (fgetValue(theme)) barColorLight else barColorDark;
	// barColor : MColor = if (fgetValue(theme)) areaBgColorLight else areaBgColorDark;
	titleColor : MColor = if (fgetValue(theme)) textColorLight else textColorDark;

	addTooltip = \label : string, m : Material -> MTooltip(m , MText(label, [MTooltipDesktop()]), []);

	makeIconToggleButton = \boolB : DynamicBehaviour<bool>,
		iconOn : string, iconOff : string,
		tooltipOn : string, tooltipOff :string,
		iconSize: double, clickFn : () -> void,
		iconColor : MColor, fill : double -> {
			MSelect(boolB,\b -> if (b) MIconButton(iconOn, clickFn, [MIconSize(iconSize), iconColor, FillOpacity(fill), MIconButtonBorder(1.0)], []) |> (\f -> addTooltip(tooltipOn, f))
				else MIconButton(iconOff, clickFn, [MIconSize(iconSize), iconColor, FillOpacity(fill), MIconButtonBorder(1.0)], []) |> (\f -> addTooltip(tooltipOff, f))
			) |> MCenterY
	}

	// Panel's buttons
	customButtonsA = extractStruct(style, MDockingCustomButtons([])).buttons;
	customButtons = customButtonsA != [];
	panelButtonsA = map(customButtonsA, \btn -> {
		clickedB = make(false);
		switch (btn) {
			MDockingCustomButton(ic, tt, clkFn, st) : {
				btnColor = extractStruct(st, titleColor);
				makeIconToggleButton(clickedB, ic, ic, tt, tt, dockingTopBarIconSize, clkFn, btnColor, 0.5);
			}
			default: MEmpty();
		} |> MCenterY

	});

	// Handles
	linedHandle = makeMDockingLinedHandle(isHorizontal, titleColor);
	dottedHandle =  makeMDockingDottedHandle(isColumn, color);

	// TopBar Content
	panelTopBarButtons = {
		MBaselineColsA([
			MIcon(panelIcon, [MIconSize(dockingTopBarIconSize), titleColor, FillOpacity(dockingTitleOpacity)]) 
				|> MBorderLeftRight(10.0)
				|> MCenterY,
			MEllipsisText(title, [titleColor, dockingTitleFont, MMinWidth(minTitleEllipsisWidth)]) |> MCenterY,
			TFillX(),
			if (customButtons)
				MBaselineColsA(panelButtonsA) |> MCenterY
			else TEmpty(),
			if (disableButton)
				MCols2A(
					TFixed(6.0, 0.0),
					MIconButton("close", \ -> next(enabled, false), [MIconSize(dockingTopBarIconSize - 4.0), titleColor, MIconButtonBorder(1.0), FillOpacity(0.5)], [])
					|> (\f -> addTooltip("hide panel", f)) |> MCenterY
				)
			else TEmpty(),
			TFixed(4.0, 0.0),
			if (disableExpander)
				TEmpty()
			else
				makeIconToggleButton(
					expanded,
					"keyboard_arrow_up",
					"keyboard_arrow_down",
					"collapse panel",
					"expand panel",
					dockingTopBarIconSize,
					\ -> {
						reverseBehaviour(expanded);
						// next(state.dock, getValue(state.dock)); //force redraw (should be used for mobile)
					},
					titleColor,
					0.5
				),
			TFixed(8.0, 0.0)
		])
	}

	dockedTopBar = \isSideExpanded : bool  -> {
		MAvailable(
			MGroup([
				// Topbar background
				if (isColumn) {
					if (isSideExpanded) {
						MIfLazy(expanded,\e -> 
							if (e) TRounded(dockingRadius, dockingRadius, 0.0, 0.0, [MFill(barColor), FillOpacity(1.0)], TFillXH(dockingBarHeight))
								else TRounded(dockingRadius, dockingRadius, dockingRadius, dockingRadius, [MFill(barColor)], TFillXH(dockingBarHeight))
						);

					} else {
						TRounded(dockingRadius, dockingRadius, dockingRadius, dockingRadius, [MFill(barColor)], TFillXH(dockingBarHeight));
					}

				} else {
					// TRounded(dockingRadius, 0.0, 0.0, dockingRadius, [MFill(areaBgColorFn(fgetValue(theme), style))], TFillWY(dockingBarHeight / 2.0))
					TRounded(dockingRadius, 0.0, 0.0, dockingRadius, [MFill(barColor)], TFillWY(dockingBarHeight / 2.0))
					// TRectangle([MFill(areaBgColorFn(fgetValue(theme), style))], TFillWY(dockingBarHeight / 2.0))
				},

				// Topbar content
				if (isToolbarItem) {
					MGroup2(
						TRectangle([MFill(areaBgColorFn(fgetValue(theme), style))], topBarSize),
						MCenterIn(dottedHandle, topBarSize)
					)
				} else {

					if (isColumn)
						if (isSideExpanded) panelTopBarButtons else {
							MIcon(panelIcon, [MIconSize(dockingTopBarIconSize), titleColor, FillOpacity(0.3)]) |> MCenter
								|> (\f -> addTooltip(title + " panel", f))
						}
					else MCenterIn(dottedHandle, TFillWY(dockingBarHeight / 2.0));
				}
			]), topBarSize
		);
	};

	mobileTopBar =
		if (isHorizontal) {
			MSelect(expanded,\e ->
				MAvailable(
					MGroup([
						if (e) TRounded(dockingRadius, 0.0, 0.0, dockingRadius, [MFill(barColor)], TFillXY())
						else TRounded(dockingRadius, dockingRadius, dockingRadius, dockingRadius, [MFill(barColor)], TFillXY()),
						MCenterIn(linedHandle, TFixed(dockingBarHeight, width)),
					]),
					TFixed(dockingBarHeight, width)
				)
			);
		} else {
			MAvailable(
				MGroup([
					MSelect(expanded,\e -> if (e) TRounded(dockingRadius, dockingRadius, 0.0, 0.0, [MFill(barColor)], TFillXY())
						else TRounded(dockingRadius, dockingRadius, dockingRadius, dockingRadius, [MFill(barColor)], TFillXY())	
					),
					if (isSameStructType(getValue(state.content)[panelId][0], MDockingPanelToolbarItem("", [])))
						MCenterIn(linedHandle, TFillXH(dockingBarHeight))
					else panelTopBarButtons			
				]),
				TFillXH(dockingBarHeight)
			);
		}

	MSelect(getValue(state.sideExpanded)[panelId], \se -> {
		if (se) {
			if (docked) dockedTopBar(se) else mobileTopBar;
		} else {
			dockedTopBar(se);
		}
	});
}

makeMovablePanel(state : MDockingState, panelId : int, cursorPositionA : DynamicBehaviour<[Point]>) -> Material {
	manager = state.manager;
	itemId = makeTropicTag(manager);
	dockA = state.dock;
	groupA = state.group;
	enabled = getValue(state.enabled)[panelId];
	expanded = getValue(state.expanded)[panelId];
	position = getValue(state.positions)[panelId];
	style = getValue(state.style)[panelId];
	isHorizontal = contains(style, MDockingMobileHorizontal());

	darkTheme = contains(style, MDockingForceDarkTheme());
	lightTheme = contains(style, MDockingForceLightTheme());
	theme = if (darkTheme) const(false) else if (lightTheme) const(true) else manager.white;

	resizePressed = make(false);
	isResizing = make(false);
	isHovering = make(false);
	content = makeDockingPanelContent(state, panelId, true, isHorizontal, resizePressed, isHovering, theme, style);

	color = extractStruct(style, if (fgetValue(theme)) textColorLight else textColorDark);
	pad = 36.0;

	// println(" > DRAW - MovablePanel -m- " + i2s(panelId) /*+ "      - " + toString(colA)*/);

	// Mobile size
	size = getValue(state.mobileSize)[panelId];
	width = getTropicMetrics(size).width;
	height = getTropicMetrics(size).height + dockingBarHeight;

	ifMobile = extractStruct(style, MDockingMobileWatcher(make(false))).mobile;
	disableButton = contains(style, MDockingDisableButton());
	dontShowSep  = contains(style, MDockingDontShowSeparators());

	mouseXyLocal = make(zeroPoint);
	dragPressed = make(false);
	WH = makeWH();
	nextDistinct(WH, WidthHeight(width, height));
	r = dockingRadius;

	draggingShape = TSelect(state.mobileSize, \ms ->
	// draggingShape = TSelect(state.size, \ms ->
		if (getValue(getValue(state.expanded)[panelId])) 
		// TAlpha(const(dockingMobileOpacity), 
			TRounded(r, r, r, r, [MFill(panelBgColorFn(fgetValue(theme), style)), FillOpacity(dockingMobileOpacity)], ms[panelId])
		// )
		// else TAlpha(const(dockingMobileOpacity), 
		else TRounded(r, r, r, r, [MFill(dockingPrimaryColor), FillOpacity(dockingMobileOpacity)], TFixed(getTropicMetrics(ms[panelId]).width, dockingBarHeight))
		// )
	);

	makeResizablePanel = \c : Material -> {
		MSelect(manager.white, \lg ->
			MConstruct([
					makeSubscribe(isResizing, \rs -> {
						if (!rs) {
						// update mobile size
						next(state.mobileSize, replace(getValue(state.mobileSize), panelId , TSized(WH))); //
						// next(state.size, replace(getValue(state.size), panelId , TSized(WH)));
					}
				})
			],
			MInteractive([TMouseXY(mouseXyLocal)],
				if (isHorizontal) {
					MShadow(const(4.0),
					MColsA([
						makePanelTopBar(false, panelId, state, !isHorizontal, lg),
						MSelect(expanded,\e ->
							if (e)
								MAvailable(
									MGroup([
										// TRectangle([MFill(areaBgColorFn(lg, style))], size |> TRotate90 ),
										MCenterIn(c, size), // |> TRotate90),
									]),
									size //|> TRotate90
								)
							else TEmpty()
						)
					]));
				} else {

					MShadow(const(4.0),
						MSelect(expanded,\e -> {
							MAvailable(
								MLines([
									makePanelTopBar(false, panelId, state, !isHorizontal, lg),
									//  if (e) MGroup([TRectangle([MFill(panelBgColorFn(lg, style))], TFillXY()), c]) else TEmpty()
									 if (e) c else TEmpty()
									 
								]) |> (\f -> MFrame(0.0, r, [MFill(panelBgColorFn(lg, style))], f)),
								if (e) TSized(WH) else TSelect(WH, \wh ->  TFixed(wh.width, dockingBarHeight)),
							)
						}),
					);
				}
			))
		);
	}

	movablePanel = MDraggable(panelId,
		MSelect(manager.manager.dragging, \h -> {
			d = MConstruct([
				makeSubscribe(dragPressed, \p -> {
					if (p) next(cursorPositionA, replace(getValue(cursorPositionA), panelId, getValue(mouseXyLocal)));
				})],
				makeResizablePanel(content)
			);
			if (h == panelId) draggingShape else d;
			// d
		})|> (\f-> MInteractive([TMouseDownGhost(dragPressed)],f)),
		[]
	);

	MConstruct([
		makeSubscribe2(isResizing, \rs -> { 
				if (!rs) {
					// Update mobile size
					updateTH(state.mobileSize, panelId,  getValue(WH).height);
					updateTW(state.mobileSize, panelId,  getValue(WH).width);
					// Update docked size
					updateTH(state.dockedSize, panelId,  getValue(WH).height);
					updateTW(state.dockedSize, panelId,  getValue(WH).width);
				}
			}),
		makeSubscribe(resizePressed, \p -> {
			if (p) {
				addMInteractionItemId(manager, itemId);
				next(isResizing, true);
			} else {
				if (getValue(isResizing)) next(isResizing, false);
			}
		}),
		makeSubscribe(mouseXyLocal, \mxy -> {
			if (isCurrentMInteractionItemId(manager, itemId) && getValue(isResizing)) {
				blockOtherMInteractionItemIds(manager, itemId);
				// if (mxy.y >= height) nextDistinct(WH, WidthHeight(getValue(WH).width, mxy.y)) else nextDistinct(WH, WidthHeight(getValue(WH).width, height));
				if (mxy.y >= dockingBarHeight) nextDistinct(WH, WidthHeight(getValue(WH).width, mxy.y)) else nextDistinct(WH, WidthHeight(getValue(WH).width, height));

				// if (mxy.x >= width) nextDistinct(WH, WidthHeight(mxy.x, getValue(WH).height)) else nextDistinct(WH, WidthHeight(width, getValue(WH).height));
				if (mxy.x >= dockingBarHeight) nextDistinct(WH, WidthHeight(mxy.x, getValue(WH).height)) else nextDistinct(WH, WidthHeight(width, getValue(WH).height));
			}
		})],	
		MSelect(dockA, \d -> 
		if (d[panelId][0] < 0) {
				next(getValue(state.sideExpanded)[panelId], true);
				next(ifMobile, true);
				MSelect(enabled, \e -> if (e) 
					MTranslate(
						const(getValue(position)), 
						movablePanel
					) else TEmpty()
				);
			} else {
				next(ifMobile, false);
				TEmpty();
		})
	) |> (\f -> (MExplicitTheme(f, theme, [])));
}

makeDockedPanel(state : MDockingState, panelId : int, gridPosition : Pair<int/*col*/, int /*row*/>, colA : [int], colHeightB : DynamicBehaviour<double>, dropInfo : MDockingDropInfo, isColumn : bool, fillPanel : bool, style : [MDockingStyle], barHeight: double, sideCollapsed : DynamicBehaviour<bool>, zorder : int) -> Material {
	manager = state.manager;
	pstyle = getValue(state.style)[panelId];
	panelDockedSize = getValue(state.dockedSize)[panelId];
	rowId = gridPosition.second;

	// Scroll
	hasScrollPos = \dockingstyle -> {
		!exists([MDockingScrollPosition(make(zeroPoint))], \dsp -> isSameStructType(dsp, dockingstyle))
	};
	scrollPos = extractStruct(style, MDockingScrollPosition(make(zeroPoint))).scrollPos;
	hasScrollInspectVisible = \dockingstyle -> {
		!exists([MDockingScrollInspectVisible(make(zeroPoint), makeWH())], \dsiv -> isSameStructType(dsiv, dockingstyle))
	};
	scrollTopLeft = extractStruct(style, MDockingScrollInspectVisible(make(zeroPoint), makeWH())).scrollTopLeft;
	scrollWidthHeight = extractStruct(style, MDockingScrollInspectVisible(make(zeroPoint), makeWH())).scrollWidthHeight;

	// Expanded
	expanded = getValue(state.expanded)[panelId];
	sideExpanded = getValue(state.sideExpanded)[panelId];
	enabled = getValue(state.enabled)[panelId];
	
	// Theme
	darkTheme = contains(pstyle, MDockingForceDarkTheme());
	lightTheme = contains(pstyle, MDockingForceLightTheme());
	theme = if (darkTheme) const(false) else if (lightTheme) const(true) else manager.white;


	dontMove  = contains(pstyle, MDockingDontMove());
	dontScroll  = contains(pstyle, MDockingDontScroll());
	sideCollapsedSize = dockingSideCollapsedSize;

	dragPressed = make(false);
	r = dockingRadius;

	xheight = make(0.0);
	xwidth = make(0.0);
	// println(" > DRAW - DockedPanel - " + i2s(panelId) /*+ "      - " + toString(colA)*/);

	// Panel's content
	content = makeDockingPanelContent(state, panelId, false, !isColumn, make(false), make(false), theme, pstyle);

	dheight = if (isColumn) getTropicMetrics(panelDockedSize).height else getTropicMetrics(panelDockedSize).width;
	posCorrection =
	if (isColumn) {dx = 0.0; dy = 0.0; Point(-dx, dy);}
		else {dx = 4.0; dy = (dheight / 2.0) - 12.0; Point(dx, -dy);};

	// Mobile size for dragging shape
	// mHeight = if (isColumn) getTropicMetrics(getValue(state.mobileSize)[panelId]).height else getTropicMetrics(getValue(state.mobileSize)[panelId]).width;
	// mWidth = if (isColumn) getTropicMetrics(getValue(state.mobileSize)[panelId]).width else getTropicMetrics(getValue(state.mobileSize)[panelId]).height;
	mHeight = getTropicMetrics(getValue(state.mobileSize)[panelId]).height;
	mWidth = getTropicMetrics(getValue(state.mobileSize)[panelId]).width;
	// panelSize = if (isColumn) TFixed(mWidth, mHeight + dockingBarHeight) else TFixed(mWidth + dockingBarHeight, mHeight);
	panelSize = TFixed(mWidth, mHeight + dockingBarHeight);

	draggingShape = TRounded(dockingRadius, dockingRadius, dockingRadius, dockingRadius, [
		MFill(panelBgColorFn(fgetValue(theme), style)), 
		FillOpacity(dockingMobileOpacity), 
	], panelSize);

	topDragHandle = MSelect(manager.white, \lg -> {
		// Test for removing top bar
		// MTooltip(
		// 	MBorder4(12.0, MIcon("trip_origin", [MIconSize(dockingTopBarIconSize - 8.0), FillOpacity(0.9), dockedTitleColorFn(lg, [])])),
		// 	MText("Undock Panel", []),
		// 	[]
		// )

		makePanelTopBar(true, panelId, state, isColumn, lg) 
			|> (\f -> if (dontMove) f else
				MDraggable(panelId, f, [TDragShape(TTranslate(const(posCorrection), draggingShape))]
					// [TDragShape(TTranslate(const(posCorrection), TAlpha(const(dockingMobileOpacity), draggingShape)))]
				)
			)
	});

	topBar = MInteractive(
		[
			TMouseDown(dragPressed)
		], 
		topDragHandle
	);
		// if (isColumn) MCenterIn(topDragHandle, TFillXH(dockingBarHeight)) else MCenterXIn(topDragHandle, TFillWY(dockingBarHeight / 2.0)));

	dPanel = \lg : bool ->
		if (isColumn) {
			MLines([
				topBar,
				MShowLazy(sideExpanded, \ ->
					MSelect(expanded, \e -> {		
							if (e) {
								if (dontScroll) {
									MCropSize(TFillXY(), content)
								} else {
									MScroll(
										content, TFillXY(),
										if (hasScrollPos(style) && hasScrollInspectVisible(style))
											[MScrollPosition(scrollPos), TScrollInspectVisible(scrollTopLeft, scrollWidthHeight)]
										else if (hasScrollPos(style))
											[MScrollPosition(scrollPos)]
										else []
									)
								}
							} else TFillXH(dockingCollapsedSeparatorH);			
					})
				)					
			]) |> (\f -> MFrame(0.0, r, [MFill(panelBgColorFn(lg, style))], f))

		} else {
			dockedToolbar = if (dontMove) content else MCols([topBar, content]);
			dockedToolbar |> (\f -> MFrame(0.0, r, [MFill(panelBgColorFn(lg, style))], f))
		}

	MExplicitTheme(
		dPanel(fgetValue(theme)),
		theme, []
	)	
}
