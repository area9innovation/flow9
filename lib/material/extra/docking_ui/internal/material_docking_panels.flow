import material/material2tropic;
import material/extra/docking_ui/internal/material_docking_utils;
import material/extra/docking_ui/internal/material_docking_drop;

export {
	// NOTE: example in flow9/lib/material/tests/test_docking_ui.flow

	// Each panel can be movable or docked, and it's defined by:
	MDockingPanel(
		// note: if content is [MDockingPanelToolbarItem] is not used
		title : string,
		// note: if content is [MDockingPanelToolbarItem] is not used
		panelIcon : string,
		// creates easily different standard panels as array of MDockingPanelItems
		content : [MDockingPanelItem],
		// set on which MDockingArea the panel is docked by default (a negative number means the panel is floating undocked)
		dockingAreaId : int,
		// it means "column's order" or "row's order" depending on where the panel is docked
		order : int,
		// panels can be moved and docked on different allowed groups of MDockingAreas, group name's are defined inside each MDockingArea by "groupName"
		allowedGroups : [string],
		// panel's style
		style : [MDockingStyle]
	);
		
	makeMovablePanel(state : MDockingState, panelId : int, cursorPositionA : DynamicBehaviour<[Point]>) -> Material;
	makeDockedPanel(state : MDockingState, panelId : int, gridPosition : Pair<int/*col*/, int /*row*/>, colA : [int], colHeightB : DynamicBehaviour<double>, dropInfo : MDockingDropInfo, isColumn : bool, fillPanel : bool, style : [MDockingStyle], barHeight: double, sideCollapsed : DynamicBehaviour<bool>, zorder : int) -> Material;
}


makeDockingPanelContent(state : MDockingState, panelId : int, mobilePanel : bool, isHorizontal : bool, resizePressed : DynamicBehaviour<bool>, isHovering : DynamicBehaviour<bool>, theme : Transform<bool>, style : [MDockingStyle]) -> Material {
	contentA = getValue(state.content)[panelId];
	width = getTropicMetrics(getValue(state.size)[panelId]).width;
	dontShowSep = contains(style, MDockingDontShowSeparators());
	dontResize  = contains(style, MDockingDontResize());
	resizeHandleColor = if (fgetValue(theme)) textColorLight else textColorDark;
	isToolbarItem = isSameStructType(getValue(state.content)[panelId][0], MDockingPanelToolbarItem("", []));

	resizeHandleMobile = MInteractive(
		[
			TMouseDown(resizePressed), 
			TMouseInside(isHovering, false)
		],
		makeMDockingResizeHandleMobile(state, style)
	);

	buttonsA = mapi(contentA, \i, c -> {

		switch (c : MDockingPanelItem) {
			MDockingPanelToolbarItem(picon, itemStyle): {
				click  = extractStruct(itemStyle, MOnClick(nop)).click;
				pad = 10.0;
				minWidth = 48.0;
				sep = if (dontShowSep) TEmpty() else MSeparator(!isHorizontal);
				buttonSep = if (i == length(contentA) - 1) TEmpty() else {if (dontShowSep) TEmpty() else sep}

				ic = MCursor(FingerCursor(), MIcon(picon, [MIconSize(dockingToolbarIconSize)]));
				button = MRawButton(ic, ic, ic, ic, "", [], [TOnClicked(click)]);

				b = if (isHorizontal) MCols2A(MCenterIn(button, TFillWY(minWidth)), buttonSep)
						else MLines2(MCenterIn(button, TFillXH(minWidth)), buttonSep);

				if (!isHorizontal) MBorder(pad, 0.0, pad, 0.0, b) else MBorder(0.0, pad, 0.0, pad, b);
			}
			MDockingPanelButtonsItem(picon, label, itemStyle): {
				onClick  = extractStruct(itemStyle, MOnClick(nop)).click;
				pad = 16.0;
				minWidth = 48.0;
				sep = if (dontShowSep) TEmpty() else {MSeparator(if (isHorizontal) false else true);};

				p = if (isHorizontal) {
					MCols2A(
						MAvailable(
							MColsA([
								MIconButton(picon, onClick, [MIconSize(dockingToolbarIconSize)], []) |>(\f -> MCenter(f)),
								TFillXY(),
							])|>(\f -> MCenterIn(f,TFixed(minWidth, minWidth) )),
							TFillXH(width)
						),
						if (i == length(contentA) - 1) TEmpty() else sep
					);
				} else {
					MLines2(
						MAvailable(
							MColsA([
								if (width <= 100.0)
								MIcon(picon, [MIconSize(dockingToolbarIconSize)]) |> (\f -> MCenterIn(f,TFillXH(minWidth)))
								else
								MIcon(picon, [MIconSize(dockingToolbarIconSize)]) |> (\f -> MCenterY(f)),
								if (width <= 100.0) TEmpty() else TFillXY(),
								if (width <= 100.0) TEmpty() else
								MText(label, [MListBody()])|>(\f -> MCenterY(f))
							]),
							TFillXH(minWidth)
						),
						if (i == length(contentA) - 1) TEmpty() else {if (dontShowSep) TEmpty() else sep}
					);
				}

				MBorder(pad, 0.0, pad, 0.0, p);
			}
			MDockingPanelCustomItem(mat, msize, st): mat;
		};
	});

	MGroup([
		if (isHorizontal) MColsA(buttonsA) else MLines(buttonsA),
		if (mobilePanel) {if (dontResize || isToolbarItem) TEmpty() else resizeHandleMobile;} else TEmpty()
	]);
}

makePanelTopBar(docked : bool, panelId: int, state : MDockingState, isColumn: bool, light : bool) -> Material {
	manager = state.manager;
	style = getValue(state.style)[panelId];
	enabled = getValue(state.enabled)[panelId];
	expanded = getValue(state.expanded)[panelId];
	sideExpanded = getValue(state.sideExpanded)[panelId];
	position = getValue(state.positions)[panelId];
	title = getValue(state.title)[panelId];
	minTitleEllipsisWidth = extractStruct(style, MDockingMinTitleEllipsisWidth(120.0)).width;
	panelIcon = if (getValue(state.panelIcon)[panelId] == "") "web_asset" else getValue(state.panelIcon)[panelId];
	// Size
	size = if (docked) getValue(state.dockedSize)[panelId] else getValue(state.mobileSize)[panelId];
	width = getTropicMetrics(size).width;
	height = getTropicMetrics(size).height;
	isHorizontal = contains(style, MDockingMobileHorizontal());
	handleWidth = 24.0;
	handleHeight = 24.0;
	topBarSize = if (isColumn) TFillXH(dockingBarHeight) else TFillWY(dockingBarHeight / 2.0);
	// Prop
	ifMobile = extractStruct(style, MDockingMobileWatcher(make(false))).mobile;
	disableButton = contains(style, MDockingDisableButton());
	isToolbarItem = isSameStructType(getValue(state.content)[panelId][0], MDockingPanelToolbarItem("", []));
	disableExpander = contains(style, MDockingDisablePanelExpander());
	// Theme
	darkTheme = contains(style, MDockingForceDarkTheme());
	lightTheme = contains(style, MDockingForceLightTheme());
	theme = if (darkTheme) const(false) else if (lightTheme) const(true) else manager.white;
	// Colors
	color = extractStruct(style, if (fgetValue(theme)) textColorLight else textColorDark);
	bgHandleColor = extractStruct(style, if (fgetValue(theme)) bgHandleColorLight else bgHandleColorDark);

	dockedBarColorToolbar = extractStruct(style, if (fgetValue(theme)) panelBgColorLight else areaBgColorDark);
	barColor : MColor = if (fgetValue(theme)) barColorLight else barColorDark;
	titleColor : MColor = if (fgetValue(theme)) textColorLight else textColorDark;

	addTooltip = \label : string, m : Material -> MTooltip(m , MText(label, [MTooltipDesktop()]), []);

	makeIconToggleButton = \boolB : DynamicBehaviour<bool>,
		iconOn : string, iconOff : string,
		tooltipOn : string, tooltipOff :string,
		iconSize: double, clickFn : () -> void,
		iconColor : MColor, fill : double -> {
			MSelect(boolB,\b -> if (b) MIconButton(iconOn, clickFn, [MIconSize(iconSize), iconColor, FillOpacity(fill), MIconButtonBorder(1.0)], []) |> (\f -> addTooltip(tooltipOn, f))
				else MIconButton(iconOff, clickFn, [MIconSize(iconSize), iconColor, FillOpacity(fill), MIconButtonBorder(1.0)], []) |> (\f -> addTooltip(tooltipOff, f))
			) |> MCenterY
	}

	// Panel's buttons
	customButtonsA = extractStruct(style, MDockingCustomButtons([])).buttons;
	customButtons = customButtonsA != [];
	panelButtonsA = map(customButtonsA, \btn -> {
		clickedB = make(false);
		switch (btn) {
			MDockingCustomButton(ic, tt, clkFn, st) : {
				btnColor = extractStruct(st, titleColor);
				makeIconToggleButton(clickedB, ic, ic, tt, tt, dockingTopBarIconSize, clkFn, btnColor, 0.5);
			}
			default: MEmpty();
		} |> MCenterY

	});

	// Handles
	linedHandle = makeMDockingLinedHandle(isHorizontal, titleColor);
	dottedHandle =  makeMDockingDottedHandle(isColumn, color);

	// TopBar Content
	panelTopBarButtons = {
		MBaselineColsA([
			MIcon(panelIcon, [MIconSize(dockingTopBarIconSize), titleColor]) 
				|> MBorderLeftRight(8.0)
				|> MCenterY,
			MEllipsisText(title + "  ("+ i2s(panelId) +  ")  - " + d2s(width) + "x"+ d2s(height), [titleColor, MCaptionSolid(), MMinWidth(minTitleEllipsisWidth)])	|> MCenterY,
			TFillX(),
			if (customButtons)
				MBaselineColsA(panelButtonsA) |> MCenterY
			else TEmpty(),
			if (disableButton)
				MCols2A(
					TFixed(6.0, 0.0),
					MIconButton("visibility_off", \ -> next(enabled, false), [MIconSize(dockingTopBarIconSize), titleColor, MIconButtonBorder(1.0), FillOpacity(0.5)], [])
					|> (\f -> addTooltip("hide panel", f)) |> MCenterY
				)
			else TEmpty(),
			TFixed(4.0, 0.0),
			if (disableExpander)
				TEmpty()
			else
				makeIconToggleButton(
					expanded,
					"keyboard_arrow_up",
					"keyboard_arrow_down",
					"collapse panel",
					"expand panel",
					dockingTopBarIconSize,
					\ -> {
						reverseBehaviour(expanded);
						// next(state.dock, getValue(state.dock)); //force redraw (should be used for mobile)
					},
					titleColor,
					0.5
				),
			TFixed(8.0, 0.0)
		])
	}

	dockedTopBar = \isSideExpanded : bool  -> {
		MAvailable(
			MGroup([
				// Toplbar background
				if (isColumn) {
					if (isSideExpanded) {
						MIfLazy(expanded,\e -> 
							if (e) TRounded(dockingRadius, dockingRadius, 0.0, 0.0, [MFill(barColor), FillOpacity(1.0)], TFillXH(dockingBarHeight))
								else TRounded(dockingRadius, dockingRadius, dockingRadius, dockingRadius, [MFill(barColor)], TFillXH(dockingBarHeight))
						);

					} else {
						TRounded(dockingRadius, dockingRadius, dockingRadius, dockingRadius, [MFill(barColor)], TFillXH(dockingBarHeight));
					}

				} else {
					TRectangle([MFill(barColor)], TFillWY(dockingBarHeight / 2.0))
				},

				// Toplbar content
				if (isToolbarItem) {
					MGroup2(
						TRectangle([MFill(dockedBarColorToolbar)], topBarSize),
						MCenterIn(dottedHandle, topBarSize)
					)
				} else {
					if (isColumn)
						if (isSideExpanded) panelTopBarButtons else {
							MIcon(panelIcon, [MIconSize(dockingTopBarIconSize), titleColor, FillOpacity(0.3)]) |> MCenter
								|> (\f -> addTooltip(title + " panel", f))
						}
					else MCenterIn(dottedHandle, TFillWY(dockingBarHeight / 2.0));
				}
			]), topBarSize
		);
	};

	mobileTopBar =
		if (isHorizontal) {
			MSelect(expanded,\e ->
				MAvailable(
					MGroup([
						if (e) TRounded(dockingRadius, 0.0, 0.0, dockingRadius, [MFill(barColor)], TFillXY())
						else TRounded(dockingRadius, dockingRadius, dockingRadius, dockingRadius, [MFill(barColor)], TFillXY()),
						MCenterIn(linedHandle, TFixed(dockingBarHeight, width)),
					]),
					TFixed(dockingBarHeight, width)
				)
			);
		} else {
			MAvailable(
				MGroup([
					MSelect(expanded,\e -> if (e) TRounded(dockingRadius, dockingRadius, 0.0, 0.0, [MFill(barColor)], TFillXY())
						else TRounded(dockingRadius, dockingRadius, dockingRadius, dockingRadius, [MFill(barColor)], TFillXY())	
					),
					if (isSameStructType(getValue(state.content)[panelId][0], MDockingPanelToolbarItem("", [])))
						MCenterIn(linedHandle, TFillXH(dockingBarHeight))
					else panelTopBarButtons			
				]),
				TFillXH(dockingBarHeight)
			);
		}

	MSelect(getValue(state.sideExpanded)[panelId], \se -> {
		if (se) {
			if (docked) dockedTopBar(se) else mobileTopBar;
		} else {
			dockedTopBar(se);
		}
	});
}

makeMovablePanel(state : MDockingState, panelId : int, cursorPositionA : DynamicBehaviour<[Point]>) -> Material {
	manager = state.manager;
	itemId = makeTropicTag(manager);
	dockA = state.dock;
	groupA = state.group;
	enabled = getValue(state.enabled)[panelId];
	expanded = getValue(state.expanded)[panelId];
	position = getValue(state.positions)[panelId];
	style = getValue(state.style)[panelId];
	isHorizontal = contains(style, MDockingMobileHorizontal());

	darkTheme = contains(style, MDockingForceDarkTheme());
	lightTheme = contains(style, MDockingForceLightTheme());
	theme = if (darkTheme) const(false) else if (lightTheme) const(true) else manager.white;

	resizePressed = make(false);
	isResizing = make(false);
	isHovering = make(false);
	content = makeDockingPanelContent(state, panelId, true, isHorizontal, resizePressed, isHovering, theme, style);

	color = extractStruct(style, if (fgetValue(theme)) textColorLight else textColorDark);
	pad = 36.0;

	println(" > DRAW - MovablePanel -m- " + i2s(panelId) /*+ "      - " + toString(colA)*/);

	// Mobile size
	size = getValue(state.mobileSize)[panelId];
	width = getTropicMetrics(size).width;
	height = getTropicMetrics(size).height + dockingBarHeight;

	ifMobile = extractStruct(style, MDockingMobileWatcher(make(false))).mobile;
	disableButton = contains(style, MDockingDisableButton());
	dontShowSep  = contains(style, MDockingDontShowSeparators());

	mouseXyLocal = make(zeroPoint);
	dragPressed = make(false);
	WH = makeWH();
	nextDistinct(WH, WidthHeight(width, height));


	// draggingShape = TSelect(state.mobileSize, \ms ->
	draggingShape = TSelect(state.size, \ms ->
		if (getValue(getValue(state.expanded)[panelId])) TAlpha(const(dockingMobileOpacity), TRounded(dockingRadius, dockingRadius, dockingRadius, dockingRadius, [MFill(panelBgColorFn(fgetValue(theme), style))], ms[panelId]))
		else TAlpha(const(dockingMobileOpacity), TRounded(dockingRadius, dockingRadius, dockingRadius, dockingRadius, [MFill(dockingPrimaryColor)], TFixed(getTropicMetrics(ms[panelId]).width, dockingBarHeight)))
	);

	makeResizablePanel = \c : Material -> {
		MSelect(manager.white, \lg ->
			MConstruct([
					makeSubscribe(isResizing, \rs -> {
						if (!rs) {
						// update mobile size
						// next(state.mobileSize, replace(getValue(state.mobileSize), panelId , TSized(WH))); //
						next(state.size, replace(getValue(state.size), panelId , TSized(WH)));
					}
				})
			],
			MInteractive([TMouseXY(mouseXyLocal)],
				if (isHorizontal) {
					MShadow(const(4.0),
					MColsA([
						makePanelTopBar(false, panelId, state, !isHorizontal, lg),
						MSelect(expanded,\e ->
							if (e)
								MAvailable(
									MGroup([
										TRectangle([MFill(areaBgColorFn(lg, style))], size |> TRotate90 ),
										MCenterIn(c, size |> TRotate90),
									]),
									size |> TRotate90
								)
							else TEmpty()
						)
					]));
				} else {

					MShadow(const(4.0),
						MSelect(expanded,\e -> {
							MAvailable(
								MLines([
									makePanelTopBar(false, panelId, state, !isHorizontal, lg),
									 if (e) MGroup([TRectangle([MFill(panelBgColorFn(lg, style))], TFillXY()), c]) else TEmpty()
								]),
								if (e) TSized(WH) else TSelect(WH, \wh ->  TFixed(wh.width, dockingBarHeight)),
							)
						}),
					);
				}
			))
		);
	}

	movablePanel = MDraggable(panelId,
		MSelect(manager.manager.dragging, \h -> {
			d = MConstruct([
				makeSubscribe(dragPressed, \p -> {
					if (p) next(cursorPositionA, replace(getValue(cursorPositionA), panelId, getValue(mouseXyLocal)));
				})],
				makeResizablePanel(content)
			);
			// if (h == panelId) draggingShape else d;
			d
		})|> (\f-> MInteractive([TMouseDownGhost(dragPressed)],f)),
		[]
	);

	MConstruct([
		makeSubscribe(resizePressed, \p -> {
			if (p) {
				addMInteractionItemId(manager, itemId);
				next(isResizing, true);
			} else {
				if (getValue(isResizing)) next(isResizing, false);
			}
		}),
		makeSubscribe(mouseXyLocal, \mxy -> {
			if (isCurrentMInteractionItemId(manager, itemId) && getValue(isResizing)) {
				blockOtherMInteractionItemIds(manager, itemId);
				// if (mxy.y >= height) nextDistinct(WH, WidthHeight(getValue(WH).width, mxy.y)) else nextDistinct(WH, WidthHeight(getValue(WH).width, height));
				if (mxy.y >= dockingBarHeight) nextDistinct(WH, WidthHeight(getValue(WH).width, mxy.y)) else nextDistinct(WH, WidthHeight(getValue(WH).width, height));

								// if (mxy.x >= width) nextDistinct(WH, WidthHeight(mxy.x, getValue(WH).height)) else nextDistinct(WH, WidthHeight(width, getValue(WH).height));
				if (mxy.x >= dockingBarHeight) nextDistinct(WH, WidthHeight(mxy.x, getValue(WH).height)) else nextDistinct(WH, WidthHeight(width, getValue(WH).height));
			}
		}),
		// makeSubscribe(mouseXyLocal, \mxy -> {
		// 	if (isCurrentMInteractionItemId(manager, itemId) && getValue(isResizing)) {
		// 		blockOtherMInteractionItemIds(manager, itemId);

		// 	}
		// }),
		// makeSubscribe(position, \p ->
		// println(i2s(panelId) + " - " + toString(p))
		
		
		
		// )
		
		],
		
		MSelect(dockA, \d -> 
		if (d[panelId][0] < 0) {
				next(getValue(state.sideExpanded)[panelId], true);
				next(ifMobile, true);
				MSelect(enabled, \e -> if (e) 
					MTranslate(
						const(getValue(position)), 
						movablePanel
					) else TEmpty()
				);
			} else {
				next(ifMobile, false);
				TEmpty();
		})
	) |> (\f -> (MExplicitTheme(f, theme, [])));
}

makeDockedPanel(state : MDockingState, panelId : int, gridPosition : Pair<int/*col*/, int /*row*/>, colA : [int], colHeightB : DynamicBehaviour<double>, dropInfo : MDockingDropInfo, isColumn : bool, fillPanel : bool, style : [MDockingStyle], barHeight: double, sideCollapsed : DynamicBehaviour<bool>, zorder : int) -> Material {
	manager = state.manager;
	pstyle = getValue(state.style)[panelId];
	panelDockedSize = getValue(state.dockedSize)[panelId];
	rowId = gridPosition.second;

	// Scroll
	hasScrollPos = \dockingstyle -> {
		!exists([MDockingScrollPosition(make(zeroPoint))], \dsp -> isSameStructType(dsp, dockingstyle))
	};
	scrollPos = extractStruct(style, MDockingScrollPosition(make(zeroPoint))).scrollPos;
	hasScrollInspectVisible = \dockingstyle -> {
		!exists([MDockingScrollInspectVisible(make(zeroPoint), makeWH())], \dsiv -> isSameStructType(dsiv, dockingstyle))
	};
	scrollTopLeft = extractStruct(style, MDockingScrollInspectVisible(make(zeroPoint), makeWH())).scrollTopLeft;
	scrollWidthHeight = extractStruct(style, MDockingScrollInspectVisible(make(zeroPoint), makeWH())).scrollWidthHeight;

	// Expanded
	expanded = getValue(state.expanded)[panelId];
	sideExpanded = getValue(state.sideExpanded)[panelId];
	enabled = getValue(state.enabled)[panelId];
	
	// Theme
	darkTheme = contains(pstyle, MDockingForceDarkTheme());
	lightTheme = contains(pstyle, MDockingForceLightTheme());
	theme = if (darkTheme) const(false) else if (lightTheme) const(true) else manager.white;


	dontMove  = contains(pstyle, MDockingDontMove());
	dontScroll  = contains(pstyle, MDockingDontScroll());
	sideCollapsedSize = dockingSideCollapsedSize;

	dragPressed = make(false);

	xheight = make(0.0);
	xwidth = make(0.0);
	println(" > DRAW - DockedPanel - " + i2s(panelId) /*+ "      - " + toString(colA)*/);


	// Panel's content
	content = makeDockingPanelContent(state, panelId, false, !isColumn, make(false), make(false), theme, pstyle);
	// content =	TRounded(0.0, 0.0, dockingRadius, dockingRadius, [MFill(MGreen(500))], TFillXY());


	dheight = if (isColumn) getTropicMetrics(panelDockedSize).height else getTropicMetrics(panelDockedSize).width;
	posCorrection =
	if (isColumn) {dx = 0.0; dy = 0.0; Point(-dx, dy);}
		else {dx = 4.0; dy = (dheight / 2.0) - 12.0; Point(dx, -dy);};

	// Mobile size for dragging shape
	mHeight = if (isColumn) getTropicMetrics(getValue(state.mobileSize)[panelId]).height else getTropicMetrics(getValue(state.mobileSize)[panelId]).width;
	mWidth = if (isColumn) getTropicMetrics(getValue(state.mobileSize)[panelId]).width else getTropicMetrics(getValue(state.mobileSize)[panelId]).height;

	panelSize = if (isColumn) TFixed(mWidth, mHeight + dockingBarHeight) else TFixed(mWidth + dockingBarHeight, mHeight);
	draggingShape = TRounded(dockingRadius, dockingRadius, dockingRadius, dockingRadius, [
		MFill(panelBgColorFn(fgetValue(theme), style)), 
		FillOpacity(dockingMobileOpacity), 
		/*StrokeWidth(1.0), MStroke(panelBgColorFn(fgetValue(theme), style))*/
	], panelSize);

	topDragHandle = MSelect(manager.white, \lg ->
		if (dontMove) makePanelTopBar(true, panelId, state, isColumn, lg) else
		MDraggable(panelId, makePanelTopBar(true, panelId, state, isColumn, lg),
			[TDragShape(TTranslate(const(posCorrection), draggingShape))]
			// [TDragShape(TTranslate(const(posCorrection), TAlpha(const(dockingMobileOpacity), draggingShape)))]
		)
	);

	topBar = MInteractive([TMouseDown(dragPressed)], 
		if (isColumn) MCenterIn(topDragHandle, TFillXH(dockingBarHeight)) else MCenterXIn(topDragHandle, TFillWY(dockingBarHeight / 2.0)));

	dPanel = \lg : bool ->
		if (isColumn) {
			MLines([
				topBar,




				// MShowLazy(sideExpanded, \ -> 
				MSelect(sideExpanded, \se -> if (se)
					// MIfLazy(expanded, \e -> if (e) {
					MSelect(expanded, \e -> if (e) {



					MGroup2(
						// Panel background
						if (se) {
							r = dockingRadius;
							if (e) TRounded(0.0, 0.0, r, r, [MFill(panelBgColorFn(lg, style))/*, Stroke(0x000000)*/], TFillXY()) else TFillXH(dockingBarHeight);
						} else {
							TFixed(sideCollapsedSize, dockingBarHeight)
						},



							if (dontScroll) {
								MCropSize(TFillXY(), content)
							} else {
								MScroll(
									content, TFillXY(),
									if (hasScrollPos(style) && hasScrollInspectVisible(style))
										[MScrollPosition(scrollPos), TScrollInspectVisible(scrollTopLeft, scrollWidthHeight)]
									else if (hasScrollPos(style))
										[MScrollPosition(scrollPos)]
									else []
								)
							}
					)




						} else TFillXH(dockingCollapsedSeparatorH)
					)    // scroll for single inner panel

					else TEmpty()
				)




			]);
		} else {
			if (dontMove) content else MCols([topBar,  content]);
		}


	MExplicitTheme(
		dPanel(fgetValue(theme)),
		// makeAvailableDockedHeight(dPanel, isColumn, dropInfo, state, colHeightB, panelId, colA, rowId, fillPanel, style, barHeight, sideCollapsed, zorder),
		// |> (\f -> MAttachWidthHeight(f, xwidth, xheight)),
		theme, []
	)	
}
