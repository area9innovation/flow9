import material/material2tropic;
import material/extra/docking_ui/internal/material_docking_utils;
import material/extra/docking_ui/internal/material_docking_drop;

export {
	// NOTE: example in flow9/lib/material/tests/test_docking_ui.flow

	// Each panel can be movable or docked, and it's defined by:
	MDockingPanel(
		// note: if content is [MDockingPanelToolbarItem] is not used
		title : string,
		// creates easily different standard panels as array of MDockingPanelItems
		content : MDockingPanelContent,
		// store the position where the panel is docked
		panelDock : MDock,
		// starting panel size
		size : WidthHeight,
		// panel's style
		style : [MDockingPanelStyle]
	);
						
	makeMovablePanel(state : MDockingState, panelId : int, cursorPositionA : DynamicBehaviour<[Point]>, style : [MDockingStyle]) -> Material;
	makeDockedPanel(isColumn : bool, colA : [int], state : MDockingState, areaId : int, colId : int, panelId : int) -> Material;
}


makeDockingPanelContent(state : MDockingState, panelId : int, mobilePanel : bool, isVerticalToolbarMobile : bool, resizePressed : DynamicBehaviour<bool>, isHovering : DynamicBehaviour<bool>, style : [MDockingStyle]) -> Material {
	manager = state.manager;
	panelContent = getValue(state.content)[panelId];
	dontResize  = contains(style, MDPanelDontResize());
	pstyle = getValue(state.panelStyle)[panelId];
	isToolbar = isDockingToolbar(state, panelId);
	isEndAligned = getValue(extractStruct(pstyle, MDToolbarEndAlign(make(false))).endAlign);
	dRadius = getDockingRadius(state.style);

	// Theme
	darkTheme = contains(pstyle, MDPanelForceDarkTheme());
	lightTheme = contains(pstyle, MDPanelForceLightTheme());
	theme = if (darkTheme) const(false) else if (lightTheme) const(true) else manager.white;

	resizeHandleMobile = MInteractive(
		[
			TMouseDown(resizePressed), 
			TMouseInside(isHovering, false)
		],
		makeMDockingResizeHandleMobile(state, resizePressed, style)
			|> MBorderEnd(dRadius / 2.0)
			|> MBorderBottom(dRadius / 2.0)
	);

	content = 
		switch (panelContent : MDockingPanelContent) {
			MDToolbarContent(buttonsA): {			
				buttonsA
				|> (\m -> {
					if (isPanelFullSize(state, panelId)) if (isVerticalToolbarMobile) MColsA(m) else MLinesA(m) else {
						if (isEndAligned) {
							if (isVerticalToolbarMobile) MAlignCenterEndFill(MColsA(m)) else MAlignBottomEndFill(MLines(m))
						} else {
							if (isVerticalToolbarMobile) MAlignCenterStartFill(MColsA(m)) else MAlignTopCenter(MLines(m))
						}
					}
				})
			}
			MDPanelContent(mat) : mat;
		};

	MGroup([
		content,
		if (mobilePanel) {
			if (dontResize || isToolbar) TEmpty() else resizeHandleMobile;
		} else TEmpty()
	])
	|> (\m -> if (isToolbar) m else MCropSize(TFillXY(), m))
	|> (\m -> (MExplicitTheme(m, theme, [])));
}

makePanelTopBar(docked : bool, panelId: int, areaId : int, colId : int, colA : [int], state : MDockingState, isColumn: bool, pTheme : bool) -> Material {
	manager = state.manager;
	pstyle = getValue(state.panelStyle)[panelId];
	areaStyle = lookupTreeDef(getValue(state.areaStyle), areaId, []);
	enabled = getValue(state.enabled)[panelId];
	expanded = getValue(state.expanded)[panelId];
	sideExpanded = getValue(state.sideExpanded)[panelId];
	title = getValue(state.title)[panelId];
	minTitleEllipsisWidth = extractStruct(pstyle, MDPanelTitleEllipsis(120.0)).width;
	dRadius = getDockingRadius(state.style);
	// Order
	isFirstPanel = panelId == firstElement(colA, intMax);
	isLastPanel = panelId == lastElement(colA, intMax);
	// Topbar
	isToolbar = isDockingToolbar(state, panelId);
	toolbarThickness = extractStruct(pstyle, MDToolbarThickness(dockingItemHeight)).thickness;
	isVerticalToolbarMobile = !contains(pstyle, MDToolbarVerticalWhenMobile());
	topBarH = if (isToolbar) dockingBarHeightToolbar else dockingBarHeightPanel;
	topBarSize = makeHSize(topBarH, isColumn || !isToolbar);
	hideTopbar = contains(pstyle, MDPanelHideTopbar());
	containsDockingBarHeightPanel = if (hideTopbar) 0.0 else topBarH;
	// Prop
	disableButton = contains(pstyle, MDPanelShowCloseBtn());
	disableExpander = contains(pstyle, MDPanelHideExpanderBtn());
	// Colors
	barColorFn : MColor = topBarColorFn(pTheme, state.style);
	tColorFn : MColor = titleColorFn(pTheme, pstyle);
	sepColorFn = separatorColorFn(pTheme, state.style);
	toolbarSepColorFn = toolbarHandleColorFn(pTheme, state.style);
	// Accordion menu
	accordionEnable = fsubselect(state.areaAccordion, FLift(\aa -> make(lookupTreeDef(aa, areaId, false))));

	addTooltip = \label : string, m : Material -> MTooltip(m , MText(label, [MTooltipDesktop()]), []);
	getPanelIcon = \st : [MIconStyle] ->  {
		icon = extractStruct(pstyle, MDPanelIcon("web_asset")).icon;
		MIcon(icon, concat([tColorFn], st));
	}

	makeIconToggleButton = \boolB : DynamicBehaviour<bool>,
		iconOn : string, iconOff : string,
		tooltipOn : string, tooltipOff :string,
		iconSize: double, clickFn : () -> void,
		iconColor : MColor, fill : double -> {
			MSelect(boolB,\b -> if (b) MIconButton(iconOn, clickFn, [MIconSize(iconSize), iconColor, FillOpacity(fill), MIconButtonBorder(1.0)], []) |> (\m -> addTooltip(tooltipOn, m))
				else MIconButton(iconOff, clickFn, [MIconSize(iconSize), iconColor, FillOpacity(fill), MIconButtonBorder(1.0)], []) |> (\m -> addTooltip(tooltipOff, m))
			) |> MCenterY
	}

	linedHandle = \enableHover : bool, rotate : bool ->  makeMDockingLinedHandle(rotate, docked, state, toolbarSepColorFn, panelId, colA, enableHover, false, pTheme);

	// Toolbar drag handle (on the top)
	mobileToolbarDragHandle = \rotate : bool -> {
		linedHandle(true, rotate) 
			|> makeDraggableToolbar(state, panelId)
			|> (\m -> if (rotate) MCenterX(m) else MCenterY(m))
			|> showIf(!docked);
	}

	// Panel's buttons
	topbarCustomEndButtonsA = map(extractStruct(pstyle, MDPanelTopbarCustomButtons([])).buttons, \btn -> btn |> MCenterY);
	topbarCustomStartButtonsA = map(extractStruct(pstyle, MDPanelTopbarCustomButtonsStart([])).buttons, \btn -> btn |> MCenterY);
	hasTopbarCustomButtonsStart = topbarCustomStartButtonsA != [];
	hasTopbarCustomButtons = topbarCustomEndButtonsA != [];

	topbarPanelButtonsA = extractStruct(pstyle, MDPanelTopbarButtons([])).buttons;
	hasTopbarPanelButtons = topbarPanelButtonsA != [];
	topbarToggleButtonsA = map(topbarPanelButtonsA, \btn -> {
		clickedB = make(false);
		switch (btn) {
			MDPanelCustomToggleButton(ic, tt, clkFn, st) : {
				btnColor = extractStruct(st, tColorFn);
				makeIconToggleButton(clickedB, ic, ic, tt, tt, dockingTopBarIconSize, clkFn, btnColor, 0.5) |> MBorderLeftRight(4.0);
			}
			default: MEmpty();
		} |> MCenterY

	});

	// TopBar Content
	panelTopBarContent = {
		MSelect(accordionEnable, \isAccEnabled -> {
			MBaselineColsA([
				getPanelIcon([MIconSize(dockingTopBarIconSize), FillOpacity(dockingTitleOpacity)])
					|> MBorderStart(24.0)
					|> MCenterY,
				MEllipsisText(title, [tColorFn, dockingTitleFont, MMinWidth(minTitleEllipsisWidth)]) 
					|> MBorderStart(8.0)
					|> MCenterY,
				MBaselineColsA(concat(topbarCustomStartButtonsA, []))
					|> MCenterY 
					|> showIf(hasTopbarCustomButtonsStart),
				TFillX(),
				MBaselineColsA(concat(topbarCustomEndButtonsA, [])) |> MCenterY |> showIf(hasTopbarCustomButtons),
				MBaselineColsA(topbarToggleButtonsA) |> MCenterY |> showIf(hasTopbarPanelButtons),
				MSeparator(false) |> MBorderTopBottom(8.0) |> MBorderLeftRight(4.0) |> MCenterY 
					|> showIf((hasTopbarCustomButtons || hasTopbarPanelButtons) && ((disableExpander && !docked) || disableButton)),
				if (disableButton)
					MIconButton("close", \ -> next(enabled, false), [MIconSize(dockingTopBarIconSize - 4.0), tColorFn, MIconButtonBorder(1.0), FillOpacity(0.5)], [])
						|> MBorderStart(6.0)
						|> (\m -> addTooltip("hide panel", m))
						|> MCenterY
				else TEmpty(),
				TFixed(4.0, 0.0),

				if (disableExpander && docked)
					MEmpty()
				else
					makeIconToggleButton(
						expanded,
						if (isAccEnabled) "remove" else "keyboard_arrow_up",
						if (isAccEnabled) "add" else "keyboard_arrow_down",
						_("Collapse Panel"),
						_("Expand Panel"),
						if (isAccEnabled) (dockingTopBarIconSize - 4.0) else dockingTopBarIconSize,
						\ -> if (isAccEnabled) accordionExpanPanelFn(colA, state, panelId) else reverseBehaviour(expanded),
						tColorFn,
						0.5
					) |> showIf(isColumn || !docked),
				TFixed(if (isAccEnabled) 14.0 else 10.0, 0.0)
			])
		})
	}

	dockedTopBar = \isSideExpanded : bool  -> {
		MAvailable(
			MGroup([
				// Topbar background
				if (isToolbar) MEmpty() else {
					if (isColumn) {
						if (isSideExpanded) {
							MIfLazy(expanded,\e -> {
								topBarOpen = TRounded(dRadius, dRadius, 0.0, 0.0, [MFill(barColorFn), FillOpacity(1.0)], TFillXH(topBarH));
								topBarClose = TRounded4(dRadius, [MFill(barColorFn)], TFillXH(topBarH));
								if (e) topBarOpen else {
									if (isLastPanel) topBarOpen else topBarClose
								}
							})
						} else {
							isHovering = make(false);
							MInteractive(
								[
									TMouseInside(isHovering, false)
								],
								MClickable(
									MSelect(fselect2(manager.manager.dragging, isHovering, FLift2(\dr, h -> if (dr > 0) false else h)), \b -> {
										TRounded4(dRadius, [MFill(if (b) dockingDropLineHoverColor else barColorFn), FillOpacity(if (b) 0.4 else 1.0)], TFillXH(topBarH))
									}), \ -> iter(colA, \c -> {
										nextDistinct(getValue(state.sideExpanded)[c], true);
									}))
							) |> (\m -> addTooltip(title + " panel", m))
						}

					} else {
						TRectangle([MFill(barColorFn), /*FillOpacity(0.0)*/], TFillXH(topBarH))
					}
				},
				// Topbar content
				if (isToolbar) linedHandle(true, isColumn) else  panelTopBarContent |> showIf(isSideExpanded)
			]), topBarSize
		) |> showIf(!hideTopbar);
	};

	mobileTopBar =
		if (isToolbar) mobileToolbarDragHandle(isColumn) else {
			MAvailable(
				MGroup([
					MSelect(expanded,\e -> if (e) TRounded(dRadius, dRadius, 0.0, 0.0, [MFill(barColorFn)], TFillXY())
						else TRounded(dRadius, dRadius, dRadius, dRadius, [MFill(barColorFn)], TFillXY())	
					),
					if (isSameStructType(getValue(state.content)[panelId], MDToolbarContent([])))
						MCenterIn(linedHandle(false, isColumn), TFillXH(topBarH))
					else panelTopBarContent
				]),
				TFillXH(topBarH)
			);
		}


	MSelect(getValue(state.sideExpanded)[panelId], \se -> {
		if (se) {
			if (docked) dockedTopBar(se) else mobileTopBar;
		} else {
			dockedTopBar(se);
		}
	}) 
	|> (\r -> (MExplicitTheme(r, const(pTheme), [])))
}

makeMovablePanel(state : MDockingState, panelId : int, cursorPositionA : DynamicBehaviour<[Point]>, style : [MDockingStyle]) -> Material {
	manager = state.manager;
	itemId = makeTropicTag(manager);
	dockA = state.dock;
	groupA = state.group;
	enabled = getValue(state.enabled)[panelId];
	expanded = getValue(state.expanded)[panelId];
	position = getValue(state.positions)[panelId];
	pstyle = concat(state.style, getValue(state.panelStyle)[panelId]);
	isVerticalToolbarMobile = !contains(pstyle, MDToolbarVerticalWhenMobile());
	dRadius = getDockingRadius(state.style);

	// Theme
	darkTheme = contains(pstyle, MDPanelForceDarkTheme());
	lightTheme = contains(pstyle, MDPanelForceLightTheme());
	mobileTheme = if (darkTheme) const(false) else if (lightTheme) const(true) else manager.white;

	resizePressed = make(false);
	isResizing = make(false);
	isHovering = make(false);
	activeHover = make(false);
	dContent = makeDockingPanelContent(state, panelId, true, isVerticalToolbarMobile, resizePressed, isHovering, pstyle);

	isToolbar = isDockingToolbar(state, panelId);
	topBarH = if (isToolbar) dockingBarHeightToolbar else dockingBarHeightPanel;

	// Size
	size = getValue(state.size)[panelId];
	minPanelSize = extractStruct(pstyle, MDPanelMimimumSize(size)).size;
	minWidth = minPanelSize.width;
	minHeight = minPanelSize.height;

	msize = getValue(state.mobileSize)[panelId];
	width = msize.width;
	height = msize.height;

	disableButton = contains(pstyle, MDPanelShowCloseBtn());

	mouseXyLocal = make(zeroPoint);
	dragPressed = make(false);
	tempWH = make(WidthHeight(width, height));

	resizablePanel = \c : Material, lg : bool -> {
		addShadow = \m : Material -> {
			MShadowShape(const(4.0), m, 
				TropicShape(
					TRounded4(dRadius, [MFill(panelBgColorFn(lg, pstyle))], TFillXY())
				)
			)
		}
		
		// Mobile Panel Topbar
		panelTopBar = {
			makePanelTopBar(false, panelId, intMin, intMax, [], state, !isVerticalToolbarMobile, lg)
			// NOTE: same drag handle as docked panel
			|> (\m -> 
				MGroup2(
					m,
					// Drag handle for mobile panels
					MSelect2(state.mobileSize, expanded, \ms, e -> {
						draggingShape = 
							TRounded(dRadius, dRadius, dRadius, dRadius, [MFill(dockingPrimaryColor), FillOpacity(dockingMobileOpacity)],
								TFixed(
									ms[panelId].width, 
									if (e) ms[panelId].height else dockingBarHeightPanel
								)
							);
							MDraggable(panelId,
								makeMDockingDottedHandle(state, smallDragHandleColorFn(lg, state.style), !isToolbar)
									|> addMTooltip(_("Drag and Drop into a Dockable Area")),
								[
									TDragShape(draggingShape),
									TCursorShape(GrabCursor())
								]
							)
							|> highlightActiveHoverLayer(activeHover)

					})
				)
			);
		}
		 
		MConstruct([
				makeSubscribe2(isResizing, \rs -> {
					if (!rs) {
					// update mobile size
					nextDistinct(state.mobileSize, replace(getValue(state.mobileSize), panelId , getValue(tempWH)));
				}
			})
		],
		MInteractive([TMouseXY(mouseXyLocal)],
			if (isToolbar) {
				toolbarSize = TFixed(width, size.height + topBarH) |> (\m -> if (!isVerticalToolbarMobile) m else TRotate90(m));
					[
						panelTopBar,
						c
					]
					|> (\m -> if (isVerticalToolbarMobile) MCols(m) else MLines(m))
					|> addShadow
					|> (\m -> MCopySize(m, \sz -> MAvailable(m,	sz), true)) // fix for zero-size fillers
					|> (\m -> MAvailable(m,	toolbarSize))
			} else {
				MSelect(expanded,\e -> {
					MAvailable(
						MLines2(
							panelTopBar,
							if (e) c else TEmpty() 
						)
						|> (\m -> MGroup2(m, MShowLazy(activeHover, \ -> activeHoverLayer(state))))
						|> addShadow,
						if (e) TSized(tempWH) else TSelect(tempWH, \wh ->  TFixed(wh.width, dockingBarHeightPanel)),
					)
				})	
			}
		))
	}

	movablePanel = \lg -> {
		MConstruct([
			makeSubscribe(dragPressed, \p -> {
				if (p) next(cursorPositionA, replace(getValue(cursorPositionA), panelId, getValue(mouseXyLocal)));
			})],
			resizablePanel(dContent, lg)
			|> (\m-> MInteractive([TMouseDownGhost(dragPressed)], m))
			|> (\m-> {
				MMovable(
					m,
					TFillXY(),
					[
						MMovableCustomCursor(MoveCursor()),
						MMovableDontPassClicks(),
						MMovablePosition(position),
						MMovableLimits(Some(const(dockingSafeResizeGap)), Some(const(dockingSafeResizeGap)), Some(const(-dockingSafeResizeGap)),Some(const(-dockingSafeResizeGap)))
					]
				)
			})
		)
	}

	MConstruct([
		makeSubscribe2(isResizing, \rs -> { 
			if (!rs) {
				// Update mobile size only (do not affect dockedSize)
				updateH(state.mobileSize, panelId,  getValue(tempWH).height);
				updateW(state.mobileSize, panelId,  getValue(tempWH).width);
			}
		}),
		makeSubscribe2(resizePressed, \p -> {
			if (p) {
				addMInteractionItemId(manager, itemId);
				next(isResizing, true);
			} else {
				if (getValue(isResizing)) next(isResizing, false);
			}
		}),
		makeSubscribe(mouseXyLocal, \mxy -> {
			if (isCurrentMInteractionItemId(manager, itemId) && getValue(isResizing)) {
				rtlCorrection = if (getDefaultRtl()) 1.0 else 1.0;
				blockOtherMInteractionItemIds(manager, itemId);
				// Update while resizing, but do not exceed the editor size

				nextDistinct(tempWH, 
					WidthHeight(
						min(
							max(minWidth, rtlCorrection * mxy.x),
							getValue(state.editorWH).width - dockingSafeResizeGap
						),
						min(
							max(minHeight, mxy.y),
							getValue(state.editorWH).height - getValue(position).y - dockingSafeResizeGap // do not grow in vertical while resizing
						)
					)
				);
			}
		})
	],	
	MSelect2(dockA, mobileTheme, \d, lg -> {
		if (d[panelId].areaId < 0) {
			next(getValue(state.sideExpanded)[panelId], true);
			MShowLazy(enabled, \ -> movablePanel(lg));
		} else MEmpty();	
	}))
}

makeDockedPanel(isColumn : bool, colA : [int], state : MDockingState, areaId : int, colId : int, panelId : int) -> Material {
	manager = state.manager;
	pstyle = concat(state.style, getValue(state.panelStyle)[panelId]);
	areaStyle = lookupTreeDef(getValue(state.areaStyle), areaId, []);
	dontMove  = contains(pstyle, MDPanelDontMove());
	isToolbar = isDockingToolbar(state, panelId);
	toolbarThickness = extractStruct(pstyle, MDToolbarThickness(dockingItemHeight)).thickness;
	isVerticalToolbarMobile = !contains(pstyle, MDToolbarVerticalWhenMobile());
	isEndAligned = getValue(extractStruct(pstyle, MDToolbarEndAlign(make(false))).endAlign);
	fillSpace = contains(pstyle, MDToolbarFullSizeFixed());
	dRadius = getDockingRadius(state.style);
	activeHover = make(false);

	topBarH = if (isToolbar) dockingBarHeightToolbar else dockingBarHeightPanel;
	hideTopBar = contains(pstyle, MDPanelHideTopbar());
	containsDockingBarHeightPanel = if (hideTopBar) 0.0 else topBarH;
	
	// Order
	isFirstPanel = panelId == firstElement(colA, intMax);
	isLastPanel = panelId == lastElement(colA, intMax);

	// Expanded
	expanded = getValue(state.expanded)[panelId];
	sideExpanded = getValue(state.sideExpanded)[panelId];
	enabled = getValue(state.enabled)[panelId];
	
	// Theme
	darkTheme = contains(pstyle, MDPanelForceDarkTheme());
	lightTheme = contains(pstyle, MDPanelForceLightTheme());
	isAreaDark = contains(areaStyle, MDAreaForceDarkTheme());
	isAreaLight = contains(areaStyle, MDAreaForceLightTheme());
	dockedTheme = if (darkTheme || isAreaDark) const(false) else if (lightTheme || isAreaLight) const(true) else manager.white;
	toolbarSepColorFn = toolbarHandleColorFn(fgetValue(dockedTheme), state.style);

	// Accordion menu
	accordionEnable = fsubselect(state.areaAccordion, FLift(\aa -> make(lookupTreeDef(aa, areaId, false))));
	
	// Panel's content
	dContent = makeDockingPanelContent(state, panelId, false, !isColumn, make(false), make(false), pstyle);
	dPanel = \lg : bool -> {
		if (isToolbar) {
			dContent 
		} else {
			MSelect(expanded, \e -> {
				croppedContent = MCropSize(TFillXY(), dContent);

				if (isColumn) {
					if (e) croppedContent else TFillXH(dockingCollapsedSeparatorH);
				} else	croppedContent;

			}) 
			|> (\m -> if (!isColumn) m else MShowLazy(sideExpanded, \ -> m))
		} 
	}

	// Dragging panel utils
	makeDraggingShape = \dsA : [WidthHeight], e : bool -> 
		TRounded(dRadius, dRadius, dRadius, dRadius, [MFill(dockingPrimaryColor), FillOpacity(dockingMobileOpacity)],
			TFixed(
				dsA[panelId].width, 
				if (e) dsA[panelId].height + containsDockingBarHeightPanel else dockingBarHeightPanel
			)
		);

	rotateDS = \dgs : Tropic -> if (isToolbar && isVerticalToolbarMobile) TRotate90(dgs) else dgs;

	// Draggable handle
	makeDraggableHandle = \handleM : Material ->
		MSelect2(state.dockedSize, expanded, \ds, e -> {
			positionCorrection = 
			if (isEndAligned && isToolbar) {
				if (isColumn) Point(0.0, -(ds[panelId].height)) else Point(-(ds[panelId].height), 0.0)
			} else zeroPoint;
			MDraggable(panelId, handleM, [
				TDragShape(TTranslate(const(positionCorrection), rotateDS(makeDraggingShape(ds, e)))),
				TCursorShape(GrabCursor())
			])
		})

	MSelect2(dockedTheme, accordionEnable, \lg, accEnab -> {
		[
			// Docked Topbar
			makePanelTopBar(true, panelId, areaId, colId, colA, state, isColumn, lg)	
				|> (\tpbar -> 
					if (isToolbar) {
						if (dontMove || fillSpace) {
							tpbar
						} else {
							makeDraggableHandle(tpbar) |> highlightActiveHoverLayer(activeHover);
						}
					} else {
						MGroup2(
							MClickable(tpbar, \ -> {
								if (accEnab) accordionExpanPanelFn(colA, state, panelId) else reverseBehaviour(expanded)
							}),
							MShowLazy(sideExpanded, \ -> 
								makeMDockingDottedHandle(state, smallDragHandleColorFn(lg, state.style), !isToolbar && !dontMove)
									|> (\m -> 
										if (!isToolbar && !dontMove) {
											makeDraggableHandle(m) |> addMTooltip(_("Drag to Undock")) |> highlightActiveHoverLayer(activeHover)
										} else m
									)
							)
							|> showIf(!(dontMove && hideTopBar))
						)
					}
				),
			dPanel(lg),
			makeMDockingLinedHandle(isColumn, true, state, toolbarSepColorFn, panelId, colA, false, true, lg)
				|> showIf(containsDockingToolbarButtons(state, colA) && isPanelFullSize(state, panelId))
		]
		|> (\r -> {
			if (isToolbar) {
				if (isColumn) MLinesA(if (isEndAligned) reverseA(r) else r)
					else MColsA(if (isEndAligned) reverseA(r) else r)
			} else {
				if (hideTopBar) MGroup(r) else	MLines(r)
			}
		})
		// Panel's BG rounded
		|> (\m -> 
			MGroup2(
				TRounded4(dRadius, [MFill(panelBgColorFn(lg, pstyle))], TFillXY()),
				m
			)
		)
		|> (\m -> MGroup2(m, MShowLazy(activeHover, \ -> activeHoverLayer(state))))
	})
}