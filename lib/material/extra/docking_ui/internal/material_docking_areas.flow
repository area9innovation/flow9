import material/material_ui;
import material/extra/docking_ui/internal/material_docking_utils;
import material/extra/docking_ui/internal/material_docking_panels;
// import material/extra/docking_ui/internal/material_docking_drop;


export {
	// NOTE:
	// - MDockingAreas can act as a "dockable MCols" or "MLines" (by "isColumn")
	// - each MDockingArea has unique id
	// - different MDockingAreas can have the same groupName
	// - the groupNames are used by MDockingPanel in the "allowedGroups" field
	// - each panel can have a vertical or horizontal orientation, but its size is defined by default as vertical
	// - when docked on cols a panel will be shown as vertical, when on lines as horizontal
	// - when mobile a panel will be vertical, but you can flip it with MDockingMobileHorizontal() style
	// - example in flow9/lib/material/tests/test_docking_ui.flow

	MDockingArea(isColumn : bool, state : MDockingState, groupName : string, areaId : int, style : [MDockingStyle]) -> Material;
}

// Let's think about dockable/resizable MCols with inside MLines of panels, 
// the logic can be swithched and we get MLines with inside MCols 
MDockingArea(isColumn : bool, state : MDockingState, groupName : string, areaId : int, style : [MDockingStyle]) -> Material {
	MShowLazy(fselect(state.size, FLift(\sz -> sz != [])), 
		\ -> {
			manager = state.manager;
			itemId = makeTropicTag(manager);
			zorder = getValue(manager.manager.zorder);
			contentA = getValue(state.content);
			sizeA = getValue(state.size);

			// Drop
			onDragging = manager.manager.dragging;
			onDrop = make(-1);
			order = make([0, 0]);
			dockedPanelsGrid = make([[]]);
			isDockingCol = make(true);
			isRow = make(false);
			lastDropSize = make(TEmpty());

			// Drop Info
			dropInfo = 
				MDockingDropInfo(
					areaId,
					groupName,
					onDrop, 
					order, 
					dockedPanelsGrid, 
					isDockingCol, 
					isRow,
					lastDropSize
				);

			// Inactive drop bar
			dropSize = extractStruct(style, MDockingDropSize(dockingDropSize)).size;
			colSize = if (isColumn) TFillWY(dropSize) else TFillXH(dropSize);
			inactiveDropLine = TRectangle([MFill(MGrey(300))], colSize);

			areaGridT = fselect(state.dock, FLift(\dockA -> extractAreaGridById(dockA, areaId)));

			MSelect(areaGridT, \areaGrid : [[int]] -> {
				next(dockedPanelsGrid, areaGrid);
				mapi(areaGrid, \colId, colA -> {
					atLeastOneEnabledInCol = fold(colA, false, \acc, a -> acc || getValue(getValue(state.enabled)[a]));
					atLeastOneEnabled = fold(areaGrid, false, \acc, singleColA -> acc || fold(singleColA, false, \acc2, a -> acc2 || getValue(getValue(state.enabled)[a])));
					enabledColT = fmerge(map(colA, \c -> getValue(state.enabled)[c]));
					sideExpandedColT = fmerge(map(colA, \c -> getValue(state.sideExpanded)[c]));
					// Enable a single col					
					MSelect3(
						manager.white, 
						enabledColT,
						sideExpandedColT,
						\w, e, __ -> {
							containsDark = fold(colA, false, \acc, a -> acc || contains(getValue(state.panelStyle)[a], MDockingForceDarkTheme()));
							containsLight = fold(colA, false, \acc, a -> acc || contains(getValue(state.panelStyle)[a], MDockingForceLightTheme()));
							colTheme = if (containsDark) false else if (containsLight) true else w;
							// println(" > DRAW - docked lines of panels - " + i2s(areaId) + "      - " + toString(colA));
				
							if (atLeastOneEnabledInCol) {
								// Single resizable column of docked panels with dragging handles and drop areas
								makeDockedPanelA(
									isColumn,
									dropInfo,
									state,
									areaGrid,
									colA,
									colId,
									colTheme,
									style
								);

							} else if (atLeastOneEnabled) {
								TEmpty();
							} else {
								// NO PANELS ENABLED
								dockingDropLine(isColumn, isColumn, dropInfo, state, [0, 0], false, inactiveDropLine, colSize, colSize, true, style);
							}
						}
					);


				}) |> (\f -> if (isColumn) MColsA(f) else MLines(f))

				// NO PANELS DOCKED
				|> (\f -> if (areaGrid != []) f 
					else dockingDropLine(isColumn, isColumn, dropInfo, state, [0, 0], false, inactiveDropLine, colSize, colSize, true, style));
				
			});

		} 
	);
}



makeDockedPanelA(
	isColumn : bool,
	dropInfo : MDockingDropInfo,
	state : MDockingState, 
	areaGrid : [[int]],
	colA : [int], 
	colId : int,
	light : bool, 
	style : [MDockingStyle]
) -> Material {

	// println("  ------------- > makeResizableColFn " + i2s(areaId));

	manager = state.manager;
	onDragging = manager.manager.dragging;
	zorder = getValue(manager.manager.zorder);
	groupA = state.group;
	contentA = getValue(state.content);

	// Drop info
	areaId = dropInfo.areaId;
	groupName = dropInfo.groupName; 

	dockedSizeA = getValue(state.dockedSize);
	dropSize = extractStruct(style, MDockingDropSize(dockingDropSize)).size;
	dragSize = dockingDragSize;
	handleHeight = dropSize;
	rowSize = if (isColumn) TFillXH(dropSize) else TFillWY(dropSize);
	colSize = if (isColumn) TFillWY(dropSize) else TFillXH(dropSize);
	inactiveDropLine = TRectangle([MFill(MGrey(300))], rowSize);

	fillHeightArea = contains(style, MDockingFillSpace());
	fillLast = contains(style, MDockingColFillLast());
			
	dontResize  = contains(style, MDockingDontResize());
	dontSideExpand = contains(style, MDockingDontCollapseColumn());

	sideExpandedA = map(contentA,\c -> make(false));

	lastPanel = length(colA) - 1;
	lastCol = length(areaGrid) - 1;

	// mouseXyLocalR = make(zeroPoint);
	dontResizeAll = fold(colA, true, \acc, p -> acc && contains(getValue(state.panelStyle)[p], MDockingDontResize()));
	dontSideExpandPanel = fold(colA, false, \acc, p -> acc || contains(getValue(state.panelStyle)[p], MDockingDontCollapsePanel()));

	panelsWidthA = map(colA, \s -> getValue(state.size)[s].width);
	dockedWidthA = map(colA, \s -> getValue(state.dockedSize)[s].width);
	panelsHeightA = map(colA, \s -> getValue(state.size)[s].height);
	dockedHeightA = map(colA, \s -> getValue(state.dockedSize)[s].height);

	maxPanelsWidth = either(maxA(panelsWidthA), -doubleMax);
	maxDockedWidth = either(maxA(dockedWidthA), -doubleMax);
	maxPanelsHeight = either(maxA(panelsHeightA), -doubleMax);
	maxDockedHeight = either(maxA(dockedHeightA), -doubleMax);
		
	colWB = make(if (isColumn) maxDockedWidth else maxDockedHeight);

	WA = map(contentA,\c -> make(0.0));
	HA = map(contentA,\c -> make(0.0));

	if (getValue(WA[colId]) == 0.0) next(WA[colId], maxPanelsWidth);
	if (getValue(HA[colId]) == 0.0) next(HA[colId], maxPanelsHeight);

	colHeightB = make(0.0);

	// Side expander button
	sebtn = makeSideExpanderBtn(isColumn, state, colA, light, style)
		|> showIf(/*isColumn && */!dontSideExpand && !dontSideExpandPanel);

	MFrame(0.0, 0.0, [MFill(areaBgColorFn(light, style))], 
		MGroup2(							
			TFillY() |> (\f -> MAttachHeight(f, colHeightB)),  // Get column height
			// Docked panels			
			mapi(colA, \rowId, panelId -> {
				
				// Panel position
				isFirstPanel = panelId == firstElement(colA, intMax);
				isLastPanel = panelId == lastElement(colA, intMax);
				lastPanelId = length(colA) - 1;

				// Fill panel order
				fillBottom = rowId == lastPanel; 	// fill last panel --default
				fillTop = rowId == 0; 			// fill first panel
				fillPanelOrder = if (fillLast) fillBottom else fillTop;
				fillPanelOrderId = if (fillLast) lastPanel else 0;

				panelStyle = getValue(state.panelStyle)[panelId];
				fillHeight = fillHeightArea || contains(panelStyle, MDockingFillSpace());  // NOTE: should be handled

				// Expanded
				expanded = getValue(state.expanded)[panelId];
				sideExpanded = getValue(state.sideExpanded)[panelId];
				enabled = getValue(state.enabled)[panelId];

				// Panel size
				dockedSize = getValue(state.dockedSize)[panelId];
				pSize = getValue(state.size)[panelId];

				pWidth = dockedSize.width;
				pHeight = if (isLastPanel) pSize.height else dockedSize.height;

				rowHB = make(if (isColumn) pHeight else pWidth);

				otherPanelsH = foldi(colA, 0.0, \k, acc, pId -> {
					if (k < (length(colA) )) {
						if (k != fillPanelOrderId) {
							sz = if (isColumn) {
								getValue(state.dockedSize)[pId].height // + dockingDragSize + dockingBarHeight
							} else {
								getValue(state.dockedSize)[pId].width // + dockingDragSize
							}
							acc + sz
						} else acc
					} else acc;
				});

			MConstruct([
				// makeSubscribe(rowHB, \rh -> println(i2s(panelId) + "- rowHB: " +  toString(rh))), // debug
				makeSubscribe(sideExpanded, \se -> {
					if (isColumn) {
						if (se) {
							nextDistinct(rowHB, pHeight);
							nextDistinct(colWB, pWidth);
							// Also expand panels in col
							iter(colA, \pId -> nextDistinct(getValue(state.expanded)[pId], se));
						} else {
							nextDistinct(rowHB, dockingBarHeight);
							nextDistinct(colWB, dockingSideCollapsedSize);
						}
					} else {
						if (se) {
							nextDistinct(colWB, maxDockedHeight);
							// nextDistinct(rowHB, pWidth);
							// Also expand panels in row and update all heights
							iter(colA, \pId -> nextDistinct(getValue(state.expanded)[pId], se));
							iter(colA, \pId -> updateH(state.dockedSize, pId, maxDockedHeight));
						} else {
							nextDistinct(colWB, dockingBarHeight);
							nextDistinct(rowHB, dockingSideCollapsedSize);
						}
					}
				}),
				makeSubscribe2(expanded, \e -> {
					rH = if (fillPanelOrder) {
						getValue(colHeightB) - sideExpanderButtonSize - foldi(colA, 0.0, \k, acc, pId -> {
							if (k < (length(colA) )) {if (k != fillPanelOrderId) acc + getValue(state.dockedSize)[pId].height + dockingDragSize else acc} else acc;
						}) 
					} else pHeight;
					// println(" panel" + i2s(panelId) + " - h: " + d2s(rH) );
					// if (e) nextDistinct(rowHB, rH) else nextDistinct(rowHB, dockingBarHeight);
					nextDistinct(rowHB, if (e) getValue(state.dockedSize)[panelId].height else dockingBarHeight);
				}),
				// Undock panel
				makeSubscribe(enabled, \e -> if (!e) undockPanel(state, panelId)),
				// Fill correction
				makeSubscribe(
					// Update only the first time
					ftransistor(
						fselect(colHeightB, FLift(\ch -> {
							// Fill if docking state is not cached
							savedString = getKeyValue(state.keyGroupName |> addDockingSuffix, "");
							savedString == ""
						})),
						colHeightB
					), \totColH -> {
						if (isColumn) {
							if (fillPanelOrder) {
								availableColHeight = totColH - sideExpanderButtonSize /*- dockingDragSize*/ - dockingBarHeight - otherPanelsH;
								// Fill height
								if (totColH > otherPanelsH) next(rowHB, availableColHeight);
							}
						}
					}
				)
				],
				makeDockedPanel(
					state, 
					panelId, 
					Pair(colId, rowId), 
					colA, 
					dropInfo, 
					isColumn, 
					fillPanelOrder, 
					style, 
					dropSize, 
					sideExpandedA[colId], 
					zorder
				) 	
			) 				
			|> (\f ->
					// Wrapper with drop area and resize handle for a row
					resizePanelH(f, isColumn, dropInfo, state, rowHB, panelId, colA, colId, rowId, light, style)
				) |> showIf(dockedSizeA != [])

			}) 
			|> (\f -> if (isColumn) MLines(f) else MColsA(f))
			// Bg of a container
			|> (\m -> MIfLazy(fselectLift(fmerge(map(colA, \c -> getValue(state.sideExpanded)[c])), \seA -> contains(seA, true)), \cse -> if (cse) m else
			MFrame(0.0, dockingRadius, [MFill(panelBgColorFn(light, style))], MGroup2(makeVSize(dockingSideCollapsedSize, isColumn), m))
			))

			// |> (\f -> 
			// 	MFrame(0.0, dockingRadius, [MFill(panelBgColorFn(light, style))], MGroup2(makeVSize(dockingSideCollapsedSize, isColumn), f))
			// )
			|> (\f -> if (isColumn) MLines2(sebtn, f) else MCols2A(f, sebtn))
		) 
	) 
	|> (\f ->
		// Wrapper with drop area and resize handle for a col
		resizeAreaW(f, isColumn, dropInfo, state, colWB, areaGrid, colA, colId, light, style)
	)
}


resizePanelH(
	box : Material, 
	isColumn : bool,
	dropInfo : MDockingDropInfo,
	state : MDockingState,
	sizeB : DynamicBehaviour<double>, 
	panelId : int, 
	parentA : [int], 
	colId : int,
	rowId : int,		
	light : bool,
	style : [MDockingStyle], 
) -> Material {
	manager = state.manager;
	itemId = makeTropicTag(manager);
	zorder = getValue(manager.manager.zorder);
	pstyle = getValue(state.panelStyle)[panelId];
	groupA = state.group;

	// Size	
	sideCollapsedSize = dockingSideCollapsedSize;
	panelDockedSize = getValue(state.dockedSize)[panelId];
	pWidth = panelDockedSize.width;
	pHeight = panelDockedSize.height;

	// Container size
	// WH = if (isColumn) make(WidthHeight(pWidth, pHeight)) else make(WidthHeight(pHeight, pWidth));
	WH = make(WidthHeight(pWidth, pHeight));

	// Order
	isFirstPanel = panelId == firstElement(parentA, intMax);
	isLastPanel = panelId == lastElement(parentA, intMax);
	lastPanelId = length(parentA) - 1;

	fillLast = contains(style, MDockingColFillLast());
	fillPanelOrderId = if (fillLast) lastPanelId else 0;

	resizePressed = make(false);
	isResizing = make(false);
	isHovering = make(false);
	mouseXyLocal = make(zeroPoint);
	
	// Expanded
	expanded = getValue(state.expanded)[panelId];
	sideExpanded = getValue(state.sideExpanded)[panelId];
	enabled = getValue(state.enabled)[panelId];

	se = getValue(getValue(state.sideExpanded)[parentA[0]]);
	collapsedSepColor = MGrey(400);

	cacheEnabled = extractStruct(state.style, MDockingEnableLoadAndStoreCache(false)).cacheEnabled;
	isToolbarItem = isSameStructType(getValue(state.content)[panelId][0], MDockingPanelToolbarItem("", []));
	fillHeightArea = contains(style, MDockingFillSpace());
	fillHeight = fillHeightArea || contains(pstyle, MDockingFillSpace());
	isBottomLine = contains(style, MDockingBottomtLines());
	dontScroll  = contains(style, MDockingDontScroll());	
	dontResizeAll = fold(parentA, true, \acc, p -> acc || contains(getValue(state.panelStyle)[p], MDockingDontResize()));
	dontResize = isLastPanel;

	// println(" > DRAW - Container R - " + i2s(panelId) /*+ "      - " + toString(parentA)*/);

	// Rows separator with drop
	dragSize = dockingDragSize;
	dragSizeBig = dockingHelperDragSize;
	dragHandleSizeBig = makeHSize(dragSizeBig, isColumn);
	dragHandleSize = makeHSize(dockingDragSize, isColumn);

	rowFiller = if (isColumn) TFillY() else TFillX();

	makeSeparator = \resizeW : bool, order : [int], resize : bool, endpoint : bool -> {
		resizeHelper = dockingResizeLine(isColumn, resizeW, dontResize, resizePressed, dragHandleSizeBig, style) |> showIf(resize);
		dockingDropLine(isColumn, resizeW, dropInfo, state, order, true, resizeHelper, dragHandleSize, dragHandleSizeBig, endpoint, style)
			|> (\m -> MShowLazy(fmin(expanded, sideExpanded), \ -> m));
	}

	rowsWithHandles = 
		if (isColumn) {
			// Resize H
			MLines( 
				if (rowId == 0 && length(parentA) == 1)
				[
					makeSeparator(false, [colId, rowId], false, true /*endpoint*/), 		// top
					rowFiller,
					makeSeparator(false, [colId, rowId + 1 ], false, false), 				// bottom
				]
				else if (rowId == 0 && length(parentA) != 1)
				[
					makeSeparator(false, [colId, rowId], false, true /*endpoint*/),
					rowFiller,
					makeSeparator(false, [colId, rowId + 1], true /*resize*/, false),
				]
				else if (rowId ==  length(parentA) - 1 && length(parentA) != 1)
				[
					rowFiller,
					makeSeparator(false, [colId, rowId + 1 ], false, false),
				]
				else
				[	
					rowFiller,
					makeSeparator(false, [colId, rowId + 1], true /*resize*/, false),
				]
			)
		} else {
			// Resize W
			MCols(
				//  if (rowId == 0 && length(parentA) == 1)
				// [
				// 	if (isBottomLine) dLine(rowId + 1, false) else dLine(rowId, true),   //top
				// 	rowFiller,
				// 	if (isBottomLine) dLine(rowId, true) else dLine(rowId + 1, false) ,  //bottom
				// ]
				// else if (rowId == 0 && length(parentA) != 1)
				// [
				// 	if (isBottomLine) dLine(rowId + 1, true) else dLine(rowId, true),
				// 	rowFiller,
				// 	if (isBottomLine) TEmpty() else makeHResizeSeparator(rowId + 1),
				// ]
				// else if (rowId ==  length(parentA) - 1 && length(parentA) != 1)
				// [
				// 	if (!isBottomLine) TEmpty() else makeHResizeSeparator(rowId),
				// 	rowFiller,
				// 	if (!isBottomLine) dLine(rowId + 1, false) else dLine(rowId, true),
				// ]
				// else
				[
					makeSeparator(true, [colId, rowId], false, true /*endpoint*/), 
					rowFiller,
					makeSeparator(true, [colId, rowId + 1], true /*resize*/, false),
				]
			)
		}

	scrollBox = if (dontScroll) MCropSize(TFillXY(), box) else MScroll(box, TFillXY(), []);


	addRowSeparators = \f : Material ->
		[
			f,
			if (isLastPanel) TEmpty() else makeSeparatorBar(!isColumn, state, panelId, dontResize, light, style)    // bottom/dx
		] |> (\r -> if (isColumn) MLines(r) else MCols(r));

	addDragAndDropHelperGroup = \ f : Material ->  MGroup2(f, rowsWithHandles);

	MConstruct([
		// makeSubscribe(sizeB, \s -> println(getValue(state.title)[panelId] + ": " + toString(s))),
		makeSubscribe2(isResizing, \rs -> { 
			if (!rs) {
				// println("update H -" + i2s(panelId) + "- "+ toString(getValue(sizeB)));
				if (isColumn) updateH(state.dockedSize, panelId,  getValue(sizeB))
					else updateW(state.dockedSize, panelId,  getValue(sizeB));

				// Update cache
				if (cacheEnabled) setMDockingStateKeyValue(state) |> ignore;
			}
		}),
		makeSubscribe(resizePressed, \p -> {
			if (p) {
				addMInteractionItemId(manager, itemId);
				next(isResizing, true);
			} else {
				if (getValue(isResizing)) next(isResizing, false);
			}
		}),
		makeSubscribe(mouseXyLocal, \mxy -> {
			if (isCurrentMInteractionItemId(manager, itemId) && getValue(isResizing)) {
				blockOtherMInteractionItemIds(manager, itemId);
				// Update container	
				if (isColumn) nextDistinct(sizeB, max(dockingBarHeight, mxy.y)) else nextDistinct(sizeB, max(mxy.x, dockingBarHeight));
				// UPDATE DOCKED SIZE
				nextDistinct(state.dockedSize, replace(getValue(state.dockedSize), panelId, getValue(WH)));
			};
		})
	],
	MInteractive([
		TMouseXY(mouseXyLocal)
		],
		MAvailable(	
			scrollBox,
			if (isColumn) {
				if (isLastPanel /*|| isFirstPanel*/) TGroup2(TFillXY(), TSelect(fselect(sizeB, FLift(\h -> h /*+ dockingDragSize + dockingBarHeight*/)), \hh  -> TFillXH(hh))) 
				else  TSelect(fselect(sizeB, FLift(\h -> h /*+ dockingDragSize + dockingBarHeight*/)), \hh  -> TFillXH(hh))
			} else {
				if (isLastPanel /*|| isFirstPanel*/) TGroup2(TFillXY(), 
				TSelect(fselect(sizeB, FLift(\w -> w + dockingDragSize + dockingBarHeight)), \ww  -> TFillWY(ww)))
					else TSelect(sizeB, \ww  -> TFillWY(ww)) |> (\f -> TGroup2(TFillY(), f))
					// else TSelect(sizeB, \ww  -> TFillXH(ww)) |> (\f -> TGroup2(TFillY(), f))
			}
		)	
		// Keep separator's size out of MAvailable
		|> addRowSeparators
		|> (\t -> 
			MCopySize(t, \sz -> 
				MAvailable(
					TRectangle([MFill(MWhite()), FillOpacity(dockingHelperDragOpacity)], TFillXY()) |> addDragAndDropHelperGroup,
					sz
				), 
			true
			)
		)
	))
}


resizeAreaW(
	box : Material, 
	isColumn : bool,
	dropInfo : MDockingDropInfo,
	state : MDockingState, 
	sizeB : DynamicBehaviour<double>,
	areaGrid : [[int]],
	colA : [int], 
	colId : int,
	light : bool,
	style : [MDockingStyle]
) -> Material {

	manager = state.manager;
	itemId = makeTropicTag(manager);
	zorder = getValue(manager.manager.zorder);

	isBottomLine = contains(style, MDockingBottomtLines());
	isRightCol  = contains(style, MDockingRightCols());
	dontScroll  = contains(style, MDockingDontScroll());
	dontResizeAll = fold(colA, true, \acc, p -> acc && contains(getValue(state.panelStyle)[p], MDockingDontResize()));
	dontResizeCol  = contains(style, MDockingDontResize());
	dontResize = dontResizeCol || dontResizeAll;

	resizePressed = make(false);
	isResizing = make(false);
	mouseXyLocal = make(zeroPoint);
	currXy = make(zeroPoint);
	panelWH = makeWH();
	startingValueB = make(0.0);
	firstPanelId = firstElement(colA, 0);
	cacheEnabled = extractStruct(state.style, MDockingEnableLoadAndStoreCache(false)).cacheEnabled;

	panelsWidthA = map(colA, \s -> getValue(state.size)[s].width);
	maxPanelsWidth = either(maxA(panelsWidthA), -doubleMax);
	se = getValue(getValue(state.sideExpanded)[firstPanelId]);

	numOfCols = length(areaGrid);
	lastCol = numOfCols - 1;

	isReversed = isRightCol || isBottomLine;
	isEdge = colId == numOfCols - 1;
	isEdgeReverse = colId == 0 && isReversed;

	// Cols separator with drop
	dragSizeBig = dockingHelperDragSize;
	dragHandleSizeBig = makeVSize(dragSizeBig, isColumn);
	dragHandleSize = makeVSize(dockingDragSize, isColumn);

	colFiller = if (isColumn) TFillX() else TFillY();
	corrSide = if (isReversed) -1.0 else 1.0;

	makeSeparator = \resizeW : bool, order : [int], resize : bool, endpoint : bool -> {
		resizeHelper = dockingResizeLine(isColumn, resizeW, dontResize, resizePressed, dragHandleSizeBig, style)  
			|> (\m -> MShowLazy(fselectLift(fmerge(map(colA, \c -> getValue(state.sideExpanded)[c])), \seA -> contains(seA, true)), \ -> m))
			|> showIf(resize);
		dockingDropLine(isColumn, resizeW, dropInfo, state, order, false, resizeHelper, dragHandleSize, dragHandleSizeBig, endpoint, style);		
	}
	
	colWithHandles =
	if (isColumn) {
		// Resize W
		MCols(
			if (colId == 0 && numOfCols == 1)
			[
				makeSeparator(true, [colId, 0], isRightCol, !isRightCol), // sx
				colFiller,
				makeSeparator(true, [colId + 1, 0], !isRightCol, isRightCol), // dx
			]
			else if (colId == 0 && numOfCols != 1)
			[
				makeSeparator(true, [colId, 0], isRightCol, !isRightCol),
				colFiller,
				if (isRightCol) TEmpty() else makeSeparator(true, [colId + 1, 0], true, false)
			]
			else if (colId != 0 && colId == numOfCols - 1)
			[
				if (isRightCol) makeSeparator(true, [colId, 0], true, false) else  TEmpty(),
				colFiller,
				makeSeparator(true, [colId + 1, 0], !isRightCol, isRightCol),
			]
			else
			[
				if (isRightCol) makeSeparator(true, [colId, 0], true, false) else  TEmpty(),
				colFiller,
				if (isRightCol) TEmpty() else makeSeparator(true, [colId + 1, 0], true, false)
			]
		)
	} else {
		// Resize H
		MLines(
			if (colId == 0 && numOfCols == 1)
			[
				makeSeparator(false, [colId, 0], isBottomLine, !isBottomLine),
				colFiller,
				makeSeparator(false, [colId + 1, 0], !isBottomLine, isBottomLine),
			]
			else if (colId == 0 && numOfCols != 1)
			[
				makeSeparator(false, [colId, 0], isBottomLine, !isBottomLine),
				colFiller,
				if (isBottomLine) TEmpty() else makeSeparator(false, [colId + 1, 0], true, false)
			]
			else if (colId != 0 && colId == numOfCols - 1)
			[
				if (isBottomLine) makeSeparator(false, [colId, 0], true, false) else  TEmpty(),
				colFiller,
				makeSeparator(false, [colId + 1, 0], !isBottomLine, isBottomLine),
			]
			else
			[
				if (isBottomLine) makeSeparator(false, [colId, 0], true, false) else  TEmpty(),
				colFiller,
				if (isBottomLine) TEmpty() else makeSeparator(false, [colId + 1, 0], true, false)
			]
		)
	}

	scrollBox = if (dontScroll) MCropSize(TFillXY(), box) else MScroll(box, TFillXY(), []);

	// addColSeparators = \ f : Material ->
	// 	[
	// 		if (!isRightCol || dontResize) TEmpty() else makeSeparatorBar(isColumn, state, firstPanelId, dontResize, light, style),	// sx
	// 		f,
	// 		if (isRightCol || dontResize) TEmpty() else makeSeparatorBar(isColumn, state, firstPanelId, dontResize, light, style)  	// dx
	// 	] 
	// 	|> (\c -> if (isColumn) MCols(c) else MLines(c));


	addColSeparators = \ f : Material ->
		if (isColumn) {
			MColsA([
				if (isEdgeReverse && dontResize) TEmpty() else  {
					if (isRightCol) makeSeparatorBar(isColumn, state, firstPanelId, dontResize, light, style) else TEmpty()	// sx
				},
				f,
				if (isEdge && dontResize) TEmpty() else {
					if (isRightCol) TEmpty() else makeSeparatorBar(isColumn, state, firstPanelId, dontResize, light, style)  	// dx
				}
			])
		} else {
			MLines([
				if (isEdgeReverse && dontResize) TEmpty() else  {
					if (isBottomLine)  makeSeparatorBar(isColumn, state, firstPanelId, dontResize, light, style) else TEmpty()  // top
				},	
				f,
				if (isEdge && dontResize) TEmpty() else {
					if (isBottomLine) TEmpty() else makeSeparatorBar(isColumn, state, firstPanelId, dontResize, light, style)  // bottom
				}	
			])
		}

	addDragAndDropHelperGroup = \ f : Material ->  MGroup2(f, colWithHandles);

	MConstruct([
		// makeSubscribe(sizeB, \s -> { 
		// 	println("COL SIDE EXPANDED ");
		// 	println(s);
		// }),
		makeSubscribe2(isResizing, \rs -> { 
			if (!rs) {
				// println("update Ws -" + i2s(colId) + "- "+ toString(getValue(sizeB)));
				// Update all docked panels in a col
				iter(colA, \pId -> {
					if (isColumn) updateW(state.dockedSize, pId,  getValue(sizeB))
						else updateH(state.dockedSize, pId,  getValue(sizeB));
				});

				// Update cache
				if (cacheEnabled) setMDockingStateKeyValue(state) |> ignore;
			}
		}),
		makeSubscribe(resizePressed, \p -> {
			if (p) {
				addMInteractionItemId(manager, itemId);
				next(currXy, getValue(state.mouseXy));
				next(startingValueB, getValue(sizeB));
				next(panelWH, WidthHeight(getValue(sizeB), getValue(sizeB)));
				next(isResizing, true);
			} else {
				if (getValue(isResizing)) next(isResizing, false);
			}
		}),
		makeSubscribe(state.mouseXy, \mxy -> {
			if (isCurrentMInteractionItemId(manager, itemId) && getValue(isResizing)) {
				rtlCorrection = if (getDefaultRtl()) -1.0 else 1.0; // correction the direction of width changing depending of rtl mode
				blockOtherMInteractionItemIds(manager, itemId);
				if (isColumn) {
					if (isRightCol) nextDistinct(sizeB, max(maxPanelsWidth, getValue(startingValueB) + rtlCorrection * (getValue(currXy).x - mxy.x)))
						else nextDistinct(sizeB, max(maxPanelsWidth, getValue(startingValueB) - rtlCorrection * (getValue(currXy).x - mxy.x)));
				} else {
					if (isBottomLine) nextDistinct(sizeB, max(dockingItemHeight, getValue(panelWH).height + (getValue(currXy).y - mxy.y)))
						else nextDistinct(sizeB, max(dockingItemHeight, getValue(panelWH).height - (getValue(currXy).y - mxy.y)));
				}
			};
		}),
		// \ -> \-> println("dispose" + i2s(areaId)),
	],
	MInteractive([
			TMouseXY(mouseXyLocal)
		],
		MAvailable(
			scrollBox,
			if (isColumn) {
				TSelect(sizeB, \w  -> TFillWY(w));
			} else {
				TSelect(sizeB, \h  -> TFillXH(h));
			}
		) 
		// Keep separator's size out of MAvailable
		|> addColSeparators
		|> (\t -> 
			MCopySize(t, \sz -> 
				MAvailable(
					TRectangle([MFill(MBlack()), FillOpacity(dockingHelperDragOpacity)], TFillXY()) |> addDragAndDropHelperGroup,
					sz
				), 
			true
			)
		)

	));
}