import material/material_ui;
import material/extra/docking_ui/internal/material_docking_utils;
import material/extra/docking_ui/internal/material_docking_drop;
import material/extra/docking_ui/internal/material_docking_panels;


export {
	// NOTE:
	// - MDockingAreas can act as a "dockable MCols" or "MLines" (by "isColumn")
	// - each MDockingArea has unique id
	// - different MDockingAreas can have the same groupName
	// - the groupNames are used by MDockingPanel in the "allowedGroups" field
	// - each panel can have a vertical or horizontal orientation, but its size is defined by default as vertical
	// - when docked on cols a panel will be shown as vertical, when on lines as horizontal
	// - when mobile a panel will be vertical, but you can flip it with MDockingMobileHorizontal() style
	// - example in flow9/lib/material/tests/test_docking_ui.flow

	MDockingArea(isColumn : bool, state : MDockingState, groupName : string, areaId : int, style : [MDockingStyle]) -> Material;
}

// Let's think about dockable/resizable MCols with inside MLines of panels, 
// the logic can be swithched and we get MLines with inside MCols 
MDockingArea(isColumn : bool, state : MDockingState, groupName : string, areaId : int, style : [MDockingStyle]) -> Material {

	MShowLazy(fselect(state.size, FLift(\sz -> sz != [])), 
		\ -> {

			manager = state.manager;
			itemId = makeTropicTag(manager);              //
			zorder = getValue(manager.manager.zorder);
			contentA = getValue(state.content);
			sizeA = getValue(state.size);

			// Drop
			onDragging = manager.manager.dragging;
			onDrop = make(-1);
			order = make([0, 0]);
			dockedPanelsGrid = make([[]]);
			isDockingCol = make(true);
			isRow = make(false);
			lastDropSize = make(TEmpty());

			// Drop Info
			dropInfo = 
				MDockingDropInfo(
					areaId,
					groupName,
					onDrop, 
					order, 
					dockedPanelsGrid, 
					isDockingCol, 
					isRow, 
					lastDropSize
				);

			// Inactive drop bar
			dropSize = extractStruct(style, MDockingDropSize(dockingDropSize)).size;
			colSize = if (isColumn) TFillWY(dropSize) else TFillXH(dropSize);
			inactiveDropLine = TRectangle([MFill(MGrey(300))], colSize);


			areaGridT = fselect(state.dock, FLift(\dockA -> extractAreaGridById(dockA, areaId)));

			WA = map(contentA,\c -> make(0.0));
			HA = map(contentA,\c -> make(0.0));

			MSelect(areaGridT, \areaGrid : [[int]] -> {

				areaSizeInfo = 
					MDockingAreaSizeInfo(
						[],
						make(map(areaGrid, \__ -> 0.0)),
						make(map(areaGrid, \c -> map(c, \__ -> 0.0)))
					);



				areaSizeInfoB = 
					MDockingAreaSizeInfoB(
						[],
						make(map(areaGrid, \__ -> make(260.0))),
						make(map(areaGrid, \c -> map(c, \__ -> make(0.0))))
					);

				// println("areaSize");
				// println(areaSize);

				println(" > DRAW - DockingArea - " + i2s(areaId)+ "    - " + toString(areaGrid));
				// println(" > DRAW - DockingArea - REDRAW or DOCKA:  " +  b2s(r) + "    - " + toString(areaGrid));
				// println("areaGrid");
				// println(extractAreaGridById(getValue(state.dock), areaId));
				// Get Panel
				// areaGrid = extractAreaGridById(d, areaId);

				next(dockedPanelsGrid, areaGrid);

				mapi(areaGrid, \colId, colA -> {

					atLeastOneEnabledInCol = fold(colA, false, \acc, a -> acc || getValue(getValue(state.enabled)[a]));
					atLeastOneEnabled = fold(areaGrid, false, \acc, singleColA -> acc || fold(singleColA, false, \acc2, a -> acc2 || getValue(getValue(state.enabled)[a])));
					enabledColT = fmerge(map(colA, \c -> getValue(state.enabled)[c]));
					sideExpandedColT = fmerge(map(colA, \c -> getValue(state.sideExpanded)[c]));

					// Col size

					// areaSizeInfo.colSizeA
					updateColSize(areaSizeInfo,  colId, 240.0);
		
					// Enable a single col					
					MSelect3(
						manager.white, 
						enabledColT,
						sideExpandedColT, 
						\w, e, __ -> {

							containsDark = fold(colA, false, \acc, a -> acc || contains(getValue(state.style)[a], MDockingForceDarkTheme()));
							containsLight = fold(colA, false, \acc, a -> acc || contains(getValue(state.style)[a], MDockingForceLightTheme()));
							colTheme = if (containsDark) false else if (containsLight) true else w;

							println(" > DRAW - docked lines of panels - " + i2s(areaId) + "      - " + toString(colA));

							
							if (atLeastOneEnabledInCol) {
								// Single resizable column of docked panels with dragging handles and drop areas
								makeDockedPanelA(
									isColumn,
									dropInfo,
									areaSizeInfo,
									areaSizeInfoB,
									state,
									WA,
									HA,
									areaGrid,
									colA,
									colId,
									colTheme,
									style
								);

							} else if (atLeastOneEnabled) {
								TEmpty();
							} else {
								// NO PANELS ENABLED
								dockingDropLine(isColumn, 0, dropInfo, state, [0, 0],  inactiveDropLine,  true, style);
							}
						}
					);


				}) |> (\f -> if (isColumn) MColsA(f) else MLines(f))

				// NO PANELS DOCKED
				|> (\f -> if (areaGrid != []) f 
					else dockingDropLine(isColumn, 0, dropInfo, state, [0, 0], inactiveDropLine,  true, style));
				
			});

		} 
	);
}


makeDockedPanelA(
	isColumn : bool,
	dropInfo : MDockingDropInfo,
	areaSizeInfo : MDockingAreaSizeInfo,
	areaSizeInfoB : MDockingAreaSizeInfoB,
	state : MDockingState,

	WA : [DynamicBehaviour<double>], 
	HA : [DynamicBehaviour<double>], 

	areaGrid : [[int]],
	colA : [int], 
	colId : int,

	light : bool, 
	style : [MDockingStyle]
) -> Material {

	// println("  ------------- > makeResizableColFn " + i2s(areaId));

	manager = state.manager;
	onDragging = manager.manager.dragging;
	zorder = getValue(manager.manager.zorder);
	groupA = state.group;
	contentA = getValue(state.content);

	// Drop info
	areaId = dropInfo.areaId;
	groupName = dropInfo.groupName; 

	// Area size info
	colSizeA = getValue(areaSizeInfo.colSizeA);
	colW = colSizeA[colId];
	colWB = make(colW);

	colSizeA2 = getValue(areaSizeInfoB.colSizeA);
	colWB2 = colSizeA2[colId];

					// println("colW");
					// println(colW);





	dockedSizeA = getValue(state.dockedSize);
	dropSize = extractStruct(style, MDockingDropSize(dockingDropSize)).size;
	dragSize = dockingDragSize;
	handleHeight = dropSize;
	rowSize = if (isColumn) TFillXH(dropSize) else TFillWY(dropSize);
	colSize = if (isColumn) TFillWY(dropSize) else TFillXH(dropSize);
	inactiveDropLine = TRectangle([MFill(MGrey(300))], rowSize);

	fillHeightArea = contains(style, MDockingFillSpace());
	stickBottomPanels = contains(style, MDockingColStickBottom());
			
	dontResize  = contains(style, MDockingDontResize());
	dontSideExpand = contains(style, MDockingDontCollapseColumn());

	sideExpandedA = map(contentA,\c -> make(false));

	lastPanel = length(colA) - 1;
	lastCol = length(areaGrid) - 1;

	// mouseXyLocalR = make(zeroPoint);
	maxPanelSize = TSizeOf(TGroup(map(colA, \s -> if (dockedSizeA != []) dockedSizeA[s] else TEmpty())));
	dontResizeAll = fold(colA, true, \acc, p -> acc && contains(getValue(state.style)[p], MDockingDontResize()));
	dontSideExpandPanel = fold(colA, false, \acc, p -> acc || contains(getValue(state.style)[p], MDockingDontCollapsePanel()));

	panelsWidthA = map(colA, \s -> getTropicMetrics(getValue(state.size)[s]).width);
	dockedWidthA = map(colA, \s -> getTropicMetrics(getValue(state.dockedSize)[s]).width);
	mobileWidthA = map(colA, \s -> getTropicMetrics(getValue(state.mobileSize)[s]).width);

	maxPanelsWidth = either(maxA(panelsWidthA), -doubleMax);
	maxDockedWidth = either(maxA(dockedWidthA), -doubleMax);
	maxMobileWidth = either(maxA(mobileWidthA), -doubleMax);
	// se = getValue(getValue(state.sideExpanded)[colA[0]]);

	if (getValue(WA[colId]) == 0.0) next(WA[colId], maxPanelsWidth);
	if (getValue(HA[colId]) == 0.0) next(HA[colId], maxPanelsWidth);

	colHeightB = make(0.0);

	MFrame(0.0, 0.0, [MFill(areaBgColorFn(light, style))], 
		MGroup2(							
			TFillY() |> (\f -> MAttachHeight(f, colHeightB)),  // Get column height
			MLines2(	
				if ((isColumn && !dontSideExpand && !dontSideExpandPanel))  makeSideExpanderBtn(state, colA, light, style) else TEmpty(),  // Side expander button
							
				// Docked panels			
				mapi(colA, \rowId, panelId -> {

					panelStyle = getValue(state.style)[panelId];
					fillHeight = fillHeightArea || contains(panelStyle, MDockingFillSpace());  // NOTE: should be handled

					// Expanded
					expanded = getValue(state.expanded)[panelId];
					sideExpanded = getValue(state.sideExpanded)[panelId];
					enabled = getValue(state.enabled)[panelId];


										// Panel size
					panelSize = getValue(state.size)[panelId];
					pWidth = getTropicMetrics(panelSize).width;
					pHeight = getTropicMetrics(panelSize).height;

// println("BEFORE UPDATE");
// 					println(getValue(areaSizeInfo.colSizeA));
// println(getValue(areaSizeInfo.rowSizeA));

					updateRowSize(areaSizeInfo, colId, rowId, pHeight);


					// Area size info
					rowSizeA = getValue(areaSizeInfo.rowSizeA);
					rowHA = rowSizeA[colId];
					rowH = rowHA[rowId];
					rowHB = make(rowH);



					rowSizeA2 = getValue(areaSizeInfoB.rowSizeA);
					rowHA2 = rowSizeA2[colId];
					rowHB2 = rowHA2[rowId];

					nextDistinct(rowHB2, pHeight);




// 					println("pHeight");
// 					println(pHeight);
// println("AFTER UPDATE");



	// panelDockedSize = getValue(state.dockedSize)[panelId];
	// 	pWidth = getTropicMetrics(panelDockedSize).width;
	// 	pHeight = getTropicMetrics(panelDockedSize).height;

		// Container size
		WH = if (isColumn) make(WidthHeight(pWidth, pHeight)) else make(WidthHeight(pHeight, pWidth));



					// println("rowH");
					// println(rowH);

					// Fill panel order
					fillBottomTop = rowId == lastPanel; 	// fill last panel --default
					fillTopBottom = rowId == 0; 			// fill first panel
					fillPanelOrder = if (stickBottomPanels) fillTopBottom else fillBottomTop;

println("getTropicMetrics(getValue(state.size)[panelId]).height");
println(getTropicMetrics(getValue(state.size)[panelId]).height);
println("getValue(rowHB2)");
println(getValue(rowHB2));
println("getValue(WH).height");
println(getValue(WH).height);
println("grid area: " + i2s(areaId));
println(getValue(areaSizeInfo.colSizeA));
println(getValue(areaSizeInfo.rowSizeA));
println(getValue(areaSizeInfoB.colSizeA));
println(getValue(areaSizeInfoB.rowSizeA));

					isFirstPanel = panelId == firstElement(colA, intMax);
					isLastPanel = panelId == lastElement(colA, intMax);
					lastPanelId = length(colA) - 1;






				MConstruct([
						makeSubscribe(enabled, \e -> {
							if (!e) next(state.dock, mapi(getValue(state.dock), \j, item -> if (j == panelId) [-1, item[1], item[2]] else item)); //undock
						}),		
						// Fill correction
						makeSubscribe(
							// Update only the first time
							ftransistor(
								fselect(colHeightB, FLift(\ch -> {
									getTropicMetrics(getValue(state.size)[panelId]).height == getValue(rowHB2)
									// getTropicMetrics(getValue(state.dockedSize)[panelId]).height == getValue(WH).height
								})),
								colHeightB
							), \colH -> {

							// colHeightB, \colH -> {
									// if (isFirstPanel) {
							if (isFirstPanel) {
								availableColHeight = colH - sideExpanderButtonSize - foldi(colA, 0.0, \k, acc, pId -> {
									// println(i2s(k) + " - - - " + i2s(length(colA) - 1) + "     " + d2s(getTropicMetrics(getValue(state.dockedSize)[pId]).height));
									if (k < (length(colA) )) {
										if (k != 0) acc + getTropicMetrics(getValue(state.size)[pId]).height else acc
										// if (k != 0) acc + getTropicMetrics(getValue(state.dockedSize)[pId]).height else acc
									} else acc;
								});
								// Fill height
								// next(WH, WidthHeight(getValue(WH).width, availableColHeight));
								next(rowHB, availableColHeight);
								next(rowHB2, availableColHeight);
							}// A single docked panel	
						})
					],

						makeDockedPanel(
							state, 
							panelId, 
							Pair(colId, rowId), 
							colA, 
							colHeightB, 
							dropInfo, 
							isColumn, 
							fillPanelOrder, 
							style, 
							dropSize, 
							sideExpandedA[colId], 
							zorder
						)
					
			)
					 |> (\f ->
						// Wrapper with drop area and resize handle for a row
						makeAvailableDockedHeight(f, isColumn, dropInfo, state, rowHB2, colHeightB, panelId, colA, rowId, fillPanelOrder, light, style, /*dropSize, sideExpandedA[colId]*/)	
					) |> showIf(dockedSizeA != [])

				}) |> (\f -> if (isColumn) MLines(f) else MColsA(f))		
			)
		) 
	) |> (\f ->
		// Wrapper with drop area and resize handle for a col
		makeAvailableDockedWidth(f, isColumn, dropInfo, state, colWB2, WA, HA, areaGrid, colA, colId, light, style)
	)

}


	makeAvailableDockedHeight(
		box : Material, 
		isColumn : bool,
		dropInfo : MDockingDropInfo, 
		state : MDockingState,
		sizeB : DynamicBehaviour<double>, 
		colHeightB : DynamicBehaviour<double>, 

		panelId : int, 
		parentA : [int], 
		rowId : int,
		
		fillPanel : bool,
		light : bool,
		style : [MDockingStyle], 
		// barHeight: double, 
		// sideCollapsed : DynamicBehaviour<bool>, 

	) -> Material {

		manager = state.manager;
		itemId = makeTropicTag(manager);
		zorder = getValue(manager.manager.zorder);
		pstyle = getValue(state.style)[panelId];
		groupA = state.group;

		// Size	
		sideCollapsedSize = dockingSideCollapsedSize;
		panelDockedSize = getValue(state.dockedSize)[panelId];
		pWidth = getTropicMetrics(panelDockedSize).width;
		pHeight = getTropicMetrics(panelDockedSize).height;

		// Container size
		WH = if (isColumn) make(WidthHeight(pWidth, pHeight)) else make(WidthHeight(pHeight, pWidth));

		// Order
		isFirstPanel = panelId == firstElement(parentA, intMax);
		isLastPanel = panelId == lastElement(parentA, intMax);
		lastPanelId = length(parentA) - 1;

		resizeRow = false;
		resizePressed = make(false);
		isResizing = make(false);
		isHovering = make(false);
		mouseXyLocal = make(zeroPoint);
		
		// Expanded
		expanded = getValue(state.expanded)[panelId];
		sideExpanded = getValue(state.sideExpanded)[panelId];
		enabled = getValue(state.enabled)[panelId];

		collapsedSepColor = MGrey(400);

		isToolbarItem = isSameStructType(getValue(state.content)[panelId][0], MDockingPanelToolbarItem("", []));
		fillHeightArea = contains(style, MDockingFillSpace());
		fillHeight = fillHeightArea || contains(pstyle, MDockingFillSpace());
		isBottomLine = contains(style, MDockingBottomtLines());
		dontScroll  = contains(style, MDockingDontScroll());	

		xheight = make(0.0);
		xwidth = make(0.0);

		// Drop info
		// areaId = dropInfo.areaId;
		groupName = dropInfo.groupName; 
		// onDrop = dropInfo.onDrop;
		// panelsOrder = dropInfo.order;
		// panelsArray = dropInfo.dockedPanelsGrid;

		// isDockingCol = dropInfo.isDockingCol;
		// isRow = dropInfo.isRow; 
		// lastDropSize = dropInfo.lastDropSize;


		// println(" > DRAW - Container R - " + i2s(panelId) /*+ "      - " + toString(parentA)*/);




	makeColResizeSeparator = makeMDockingSeparatorDrop(isColumn, resizeRow, rowId, parentA, length(parentA), dropInfo, resizePressed, state, style);

	MConstruct([
			makeSubscribe(resizePressed, \p -> {
				if (p) {
					addMInteractionItemId(manager, itemId);
					next(isResizing, true);
				} else {
					if (getValue(isResizing)) {
						next(isResizing, false);
					}
				}
			}),
			makeSubscribe(mouseXyLocal, \mxy -> {
				if (isCurrentMInteractionItemId(manager, itemId) && getValue(isResizing)) {
					blockOtherMInteractionItemIds(manager, itemId);	

					if (isColumn) nextDistinct(WH, WidthHeight(getValue(WH).width, min( getTropicMetrics(TFillY()).height - dockingBarHeight, max(dockingBarHeight, mxy.y))))
						else nextDistinct(WH, WidthHeight(mxy.x, getValue(WH).height));

					if (isColumn) nextDistinct(sizeB, max(dockingBarHeight, mxy.y))
						else nextDistinct(WH, WidthHeight(mxy.x, getValue(WH).height));


					// UPDATE DOCKED SIZE
					nextDistinct(state.dockedSize, replace(getValue(state.dockedSize), panelId, TFixed(getValue(WH).width, getValue(WH).height)));
					// nextDistinct(state.size, replace(getValue(state.dockedSize), panelId, TFixed(getValue(WH).width, getValue(WH).height)));
				};
			})
		],
		MInteractive([
			TMouseXY(mouseXyLocal)
			],

			MSelect2(sideExpanded, expanded, \se, e -> {


					// dockedSpace = {
					// 	if (isColumn) {

					// 		if (se) {
					// 			if (e) TSelect(WH, \wh ->
					// 				TFillXH(wh.height) |> (\f -> if (isLastPanel) TGroup2(TFillXY(), f) else f)					
					// 			) else TFillXH(dockingBarHeight);
					// 		} else TFixed(sideCollapsedSize, dockingBarHeight);

					// 	} else {
					// 		if (fillHeight || fillPanel) TGroup2(TFillXY(), TSelect(WH, \wh -> TFillWY(wh.width + dockingBarHeight))) else TSelect(WH, \wh -> TFillWY(wh.width + dockingBarHeight));
					// 	}
					// }


					// Drop enpoint
					dragHandleSize = makeColSize(dockingDragSize, isColumn);
					draggingBarInactive = \lg : bool -> TRectangle([MFill(separatorColorFn(lg, style))], dragHandleSize);
					dLine = dockingDropLine(isColumn, rowId,  dropInfo, state, [if (isBottomLine) lastPanelId + 1 else 0, 0], draggingBarInactive(light), true, style);



		rowFiller = if (isColumn) TFillY() else TFillX();
		rowsWithHandles = {
		[
			if (!isBottomLine) TEmpty() else makeColResizeSeparator,
			rowFiller,
			if (isBottomLine) TEmpty() else makeColResizeSeparator,
		]



} |> (\f -> if (isColumn) MLines(f) else MCols(f))


	scrollBox = if (dontScroll) MCropSize(TFillXY(), box) else MScroll(box, TFillXY(), []);
	resizableScrollBox = MGroup2(scrollBox, rowsWithHandles);


					MAvailable(
						// if (isColumn) {
						// 	MGroup2(
						// 		box,
						// 		MLines2(
						// 			TFillY(),
						// 			// draggingHandle(light) |> showIf(!isLastPanel)
						// 			// if (fillPanel || isToolbarItem) TEmpty() else draggingHandle(light), // ORIGINAL
						// 			// TRectangle([MFill(MBrown(500)), FillOpacity(1.0)], TFillXH(dockingDragSize))
						// 			//  if (fillPanel || isToolbarItem) draggingHandleInactive(light) else draggingHandle(light)


						// 			// if (isLastPanel || isToolbarItem) draggingHandleInactive(light) else draggingHandle(light)
						// 			// if (isLastPanel || isToolbarItem) TEmpty() else makeColResizeSeparator
						// 			if (isToolbarItem) TEmpty() else makeColResizeSeparator
						// 		)
						// 	)

						// } else {
						// 	MGroup2(
						// 		// MGroup2(
						// 		// 	TRectangle([MFill(panelBgColorFn(light, style))], TFillXY()),
						// 		// 	box
						// 		// ),
						// 		box
						// 		MColsA([
						// 			TFillX(),
						// 			if (fillPanel || isToolbarItem) TEmpty() else makeColResizeSeparator
						// 			// if (fillPanel || isToolbarItem) TEmpty() else draggingHandle(light)
						// 			//  if (fillPanel || isToolbarItem) draggingHandleInactive(light) else draggingHandle(light)
						// 		])
						// 	)
						// },
resizableScrollBox,
						if (isColumn) {
							if (se) {
								if (e) TSelect(sizeB, \h ->
									TFillXH(h) |> (\f -> if (isLastPanel) TGroup2(TFillXY(), f) else f)					
								) else TFillXH(dockingBarHeight);
							} else TFixed(sideCollapsedSize, dockingBarHeight);

						} else {
							if (fillHeight || fillPanel) TGroup2(TFillXY(), TSelect(sizeB, \w -> TFillWY(w + dockingBarHeight))) else TSelect(sizeB, \w -> TFillWY(w + dockingBarHeight));
						}

						// dockedSpace
						// if (isColumn) {
						// 	if (se) TSelect(sizeB, \h  -> TFillXH(h)) else TFillXH(dockingSideCollapsedSize);
						// } else {
						// 	if (se) TSelect(sizeB, \h -> TFillWY(h + dockingBarHeight)) else TFillWY(dockingSideCollapsedSize);
						// }
					) 
					
			})
		)
	)
}






makeAvailableDockedWidth(
	box : Material, 
	isColumn : bool,
	dropInfo : MDockingDropInfo,
	state : MDockingState, 
	sizeB : DynamicBehaviour<double>,
	WA : [DynamicBehaviour<double>], 
	HA : [DynamicBehaviour<double>], 
	areaGrid : [[int]],
	colA : [int], 
	colId : int,
	light : bool,
	style : [MDockingStyle]
) -> Material {

	manager = state.manager;
	itemId = makeTropicTag(manager);
	zorder = getValue(manager.manager.zorder);

	isBottomLine = contains(style, MDockingBottomtLines());
	isRightCol  = contains(style, MDockingRightCols());
	dontScroll  = contains(style, MDockingDontScroll());	

	resizeCol = true;
	resizePressed = make(false);
	isResizing = make(false);
	mouseXyLocal = make(zeroPoint);
	currXy = make(zeroPoint);
	panelWH = makeWH();

	panelsWidthA = map(colA, \s -> getTropicMetrics(getValue(state.size)[s]).width);
	maxPanelsWidth = either(maxA(panelsWidthA), -doubleMax);
	se = getValue(getValue(state.sideExpanded)[colA[0]]);

	numOfCols = length(areaGrid);
	lastCol = numOfCols - 1;

	// Cols separator with drop
	makeColResizeSeparator = makeMDockingSeparatorDrop(isColumn, resizeCol, colId, colA,  numOfCols, dropInfo, resizePressed, state, style);

	// Drop enpoint
	dragHandleSize = makeColSize(dockingDragSize, isColumn);
	draggingBarInactive = \lg : bool -> TRectangle([MFill(separatorColorFn(lg, style))], dragHandleSize);
	dLine = dockingDropLine(isColumn, colId,  dropInfo, state, [if (isRightCol) lastCol + 1 else 0, 0], draggingBarInactive(light), true, style);

	colFiller = if (isColumn) TFillX() else TFillY();

	colWithHandles = {
		if (colId == 0 && numOfCols == 1)
		[
			if (isRightCol || isBottomLine) makeColResizeSeparator else dLine,
			colFiller,
			if (isRightCol || isBottomLine) dLine else makeColResizeSeparator,
		]
		else if (colId == 0 && numOfCols != 1)
		[
			if (isRightCol || isBottomLine) makeColResizeSeparator else dLine,
			colFiller,
			if (isRightCol || isBottomLine) TEmpty() else makeColResizeSeparator,
		]
		else if (colId != 0 && colId == numOfCols - 1)
		[
			if (!isRightCol && !isBottomLine) TEmpty() else makeColResizeSeparator,
			colFiller,
			if (isRightCol || isBottomLine) dLine else makeColResizeSeparator,
		]
		else
		[
			if (!isRightCol && !isBottomLine) TEmpty() else makeColResizeSeparator,
			colFiller,
			if (isRightCol || isBottomLine) TEmpty() else makeColResizeSeparator,
		]

		// [
		// 	makeMDockingSeparatorDrop(resizeCol, colA, colId, numOfCols, dropInfo, resizePressed, state, style),
		// 	colFiller,
		// 	makeMDockingSeparatorDrop(resizeCol, colA, colId + 1, numOfCols, dropInfo, resizePressed, state, style),
		// ]

	} |> (\f -> if (isColumn) MCols(f) else MLines(f))





	scrollBox =  //box;
	 if (dontScroll) MCropSize(TFillXY(), box) else MScroll(box, TFillXY(), [
		 ]);

	// 	TScrollbarsVisible(make(true),make(true)),

	// 	TScrollAxisEnabled(make(true), make(true))

	// ]);



	resizableScrollBox = MGroup2(scrollBox, colWithHandles);

	MConstruct([
		makeSubscribe(resizePressed, \p -> {
			if (p) {
				addMInteractionItemId(manager, itemId);
				next(currXy, getValue(state.mouseXy));
				next(panelWH, WidthHeight(getValue(sizeB), getValue(HA[colId])));
				next(isResizing, true);
			} else {
				if (getValue(isResizing)) next(isResizing, false);
			}
		}),
		makeSubscribe(state.mouseXy, \mxy -> {
			if (isCurrentMInteractionItemId(manager, itemId) && getValue(isResizing)) {
				rtlCorrection =1.0; // if (getDefaultRtl()) -1.0 else 1.0; // correction the direction of width changing depending of rtl mode
				blockOtherMInteractionItemIds(manager, itemId);
				if (isColumn) {
					if (isRightCol) nextDistinct(sizeB, max(maxPanelsWidth, getValue(panelWH).width + rtlCorrection*(getValue(currXy).x - mxy.x)))
						else nextDistinct(sizeB, max(maxPanelsWidth, getValue(panelWH).width - rtlCorrection*(getValue(currXy).x - mxy.x)));
					} else {
					if (isBottomLine) nextDistinct(HA[colId], max(maxPanelsWidth, getValue(panelWH).height + (getValue(currXy).y - mxy.y)))
						else nextDistinct(HA[colId], max(maxPanelsWidth, getValue(panelWH).height - (getValue(currXy).y - mxy.y)));
					}
			};
		}),
		// \ -> \-> println("dispose" + i2s(areaId)),
	],
	MInteractive([
			TMouseXY(mouseXyLocal)
		],
		MAvailable(
			resizableScrollBox, 
			if (isColumn) {
				if (se) TSelect(sizeB, \w  -> TFillWY(w)) else TFillWY(dockingSideCollapsedSize);
			} else {
				if (se) TSelect(HA[colId], \h  -> TFillXH(h)) else TFillXH(dockingSideCollapsedSize);
			}
		)
	));
}
