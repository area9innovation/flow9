import material/material_ui;
import material/extra/docking_ui/internal/material_docking_state;
import material/extra/docking_ui/internal/material_docking_ui_utils;
import material/extra/docking_ui/internal/material_docking_panels;


export {
	// Make a single resizable column (or row) with docked panels inside
	makeSingleResizableColFn(
		isColumn : bool, 
		state : MDockingState, 
		groupName : string, 
		id : int,
		redraw : DynamicBehaviour<bool>, 
		WA : [DynamicBehaviour<double>], 
		HA : [DynamicBehaviour<double>], 
		dockedPanelsGrid : DynamicBehaviour<[[int]]>,
		singleColA : [int], 
		colId : int, 
		resizePressedH : DynamicBehaviour<bool>, 
		resizePressedV : DynamicBehaviour<bool>, 
		style : [MDockingStyle]
	) -> (int, int) -> [Material];


makeColResizeSeparatorFn(isColumn : bool, state : MDockingState, style : [MDockingStyle]) -> 
	(int, int, int, [int], DynamicBehaviour<bool>) -> Material;

makeSingleDockedAreaFn(
	isColumn : bool, 
	redraw : DynamicBehaviour<bool>, 
	state : MDockingState, 
	groupName : string, 
	id : int, 
	WA : [DynamicBehaviour<double>], 
	HA : [DynamicBehaviour<double>], 
	style : [MDockingStyle]
) -> (i : int, dockedPanelsGrid : DynamicBehaviour<[[int]]>, singleColA : [int], resizePressedV : DynamicBehaviour<bool>, resizePressedH : DynamicBehaviour<bool>) -> Material;
}



makeSingleResizableColFn(
	isColumn : bool, 
	state : MDockingState, 
	groupName : string, 
	id : int,
	redraw : DynamicBehaviour<bool>,
	WA : [DynamicBehaviour<double>], 
	HA : [DynamicBehaviour<double>], 
	dockedPanelsGrid : DynamicBehaviour<[[int]]>,
	singleColA : [int], 
	colId : int, 
	resizePressedH : DynamicBehaviour<bool>, 
	resizePressedV : DynamicBehaviour<bool>, 
	style : [MDockingStyle]
) -> (int, int) -> [Material] {

	// Array of docked panels in a single resizable column/row
	makeSingleDockedArea = makeSingleDockedAreaFn(isColumn, redraw, state, groupName, id, WA, HA, style);
	// Cols separator
	makeColResizeSeparator = makeColResizeSeparatorFn(isColumn, state, style);

	isRightCol  = contains(style, MDockingRightCols());
	isBottomLine = contains(style, MDockingBottomtLines());

	\idx : int, len : int -> {
		if (idx == 0 && len == 1)
		[
			makeColResizeSeparator(idx, 0, len, singleColA, resizePressedH),
			makeSingleDockedArea(idx, dockedPanelsGrid, singleColA, resizePressedV, resizePressedH),
			makeColResizeSeparator(idx + 1, 0, len, singleColA, resizePressedH),
		]
		else if (idx == 0 && len != 1)
		[
			makeColResizeSeparator(idx, 0, len, singleColA, resizePressedH),
			makeSingleDockedArea(idx, dockedPanelsGrid, singleColA, resizePressedV, resizePressedH),
			if (isRightCol || isBottomLine) TEmpty() else makeColResizeSeparator(idx + 1, 0, len, singleColA, resizePressedH),
		]
		else if (idx != 0 && colId == len - 1)
		[
			if (!isRightCol && !isBottomLine) TEmpty() else makeColResizeSeparator(idx, 0, len, singleColA, resizePressedH),
			makeSingleDockedArea(idx, dockedPanelsGrid, singleColA, resizePressedV, resizePressedH),
			makeColResizeSeparator(idx + 1, 0, len, singleColA, resizePressedH),
		]
		else
		[
			if (!isRightCol && !isBottomLine) TEmpty() else makeColResizeSeparator(idx, 0, len, singleColA, resizePressedH),
			makeSingleDockedArea(idx, dockedPanelsGrid, singleColA, resizePressedV, resizePressedH),
			if (isRightCol || isBottomLine) TEmpty() else makeColResizeSeparator(idx + 1, 0, len, singleColA, resizePressedH),
		]
	}
}

// Make a resizable col (or row) of docked panels
makeSingleDockedAreaFn(
	isColumn : bool, 
	redraw : DynamicBehaviour<bool>, 
	state : MDockingState, 
	groupName : string, 
	id : int, 
	WA : [DynamicBehaviour<double>], 
	HA : [DynamicBehaviour<double>], 
	style : [MDockingStyle]
) -> (i : int, dockedPanelsGrid : DynamicBehaviour<[[int]]>, singleColA : [int], resizePressedV : DynamicBehaviour<bool>, resizePressedH : DynamicBehaviour<bool>) -> Material { 

	manager = state.manager;
	itemId = makeTropicTag(manager);
	onDragging = manager.manager.dragging;
	zorder = getValue(manager.manager.zorder);
	groupA = state.group;
	contentA = getValue(state.content);

	dockedSizeA = getValue(state.dockedSize);
	dropSize = extractStruct(style, MDockingDropSize(dockingDropSize)).size;
	dragSize = dockingDragSize;
	handleHeight = dropSize;
	rowSize = if (isColumn) TFillXH(dropSize) else TFillWY(dropSize);
	colSize = if (isColumn) TFillWY(dropSize) else TFillXH(dropSize);

	isRightCol  = contains(style, MDockingRightCols());
	isBottomLine = contains(style, MDockingBottomtLines());
	fillHeightArea = contains(style, MDockingFillSpace());

	onDrop = make(-1);
	order = make([0, 0]);
	isRow = make(false);
	isDockingCol = make(true);
	lastDropSize = make(TEmpty());
	stickBottomPanels = contains(style, MDockingColStickBottom());

			
	dontResize  = contains(style, MDockingDontResize());
	dontScroll  = contains(style, MDockingDontScroll());
	dontSideExpand = contains(style, MDockingDontCollapseColumn());

	// redraw = make(false);
	sideExpandedA = map(contentA,\c -> make(false));

	color = extractStruct(style, MBlue(600));

	\i : int, dockedPanelsGrid : DynamicBehaviour<[[int]]>, singleColA : [int], resizePressedV : DynamicBehaviour<bool>, resizePressedH : DynamicBehaviour<bool> -> {

		dockedPanelsCols = getValue(dockedPanelsGrid);
		lastPanel = length(singleColA) - 1;
		lastCol = length(dockedPanelsCols) - 1;
		isResizing = make(false);
		mouseXyLocal = make(zeroPoint);
		mouseXyLocalR = make(zeroPoint);
		maxPanelSize = TSizeOf(TGroup(map(singleColA, \s -> if (dockedSizeA != []) dockedSizeA[s] else TEmpty())));
		dontResizeAll = fold(singleColA, true, \acc, p -> acc && contains(getValue(state.style)[p], MDockingDontResize()));
		dontSideExpandPanel = fold(singleColA, false, \acc, p -> acc || contains(getValue(state.style)[p], MDockingDontCollapsePanel()));

		panelsWidthA = map(singleColA, \s -> getTropicMetrics(getValue(state.size)[s]).width);
		dockedWidthA = map(singleColA, \s -> getTropicMetrics(getValue(state.dockedSize)[s]).width);
		mobileWidthA = map(singleColA, \s -> getTropicMetrics(getValue(state.mobileSize)[s]).width);

		maxPanelsWidth = either(maxA(panelsWidthA), -doubleMax);
		maxDockedWidth = either(maxA(dockedWidthA), -doubleMax);
		maxMobileWidth = either(maxA(mobileWidthA), -doubleMax);
		se = getValue(getValue(state.sideExpanded)[singleColA[0]]);

		currXy = make(zeroPoint);
		panelWH = makeWH();
		if (getValue(WA[i]) == 0.0) next(WA[i], maxPanelsWidth);
		if (getValue(HA[i]) == 0.0) next(HA[i], maxPanelsWidth);


		// Dropping line for rows
		makeInnerDroppingLine = \a : int, b : int, c : MColor, s : int -> {
			dragCorrection = if  ((dontResize || dontResizeAll) && length(dockedPanelsCols) == 1) 0.0 else dragSize;
			separatorSize = if (isColumn) {
				if (isRightCol) {
					if (a != lastCol) TSubtractGroup2(rowSize, TFixed(dropSize - dragSize, 0.0)) else TSubtractGroup2(rowSize, TFixed(dropSize + dropSize - dragCorrection, 0.0));
				} else {
					if (a != 0) TSubtractGroup2(rowSize, TFixed(dropSize - dragSize, 0.0)) else TSubtractGroup2(rowSize, TFixed(dropSize + dropSize - dragCorrection, 0.0));
				}
			} else {
				TFillWY(dropSize);
			}

			MSelect(onDragging, \dr -> {
				if ((dr >= 0) && (dr < length(getValue(groupA))) && (contains(getValue(groupA)[dr], groupName))) {
					if (isColumn) {
						if (isSameStructType(getValue(state.content)[dr][0], MDockingPanelToolbarItem("", []))) {
								dockingDropLine(state, onDrop, dockedPanelsGrid, [a, b], id, groupName, color, order, separatorSize, true, isRow, lastDropSize, true, isDockingCol, zorder)
						} else {
							if (isRightCol) {
								MOffset(dropSize - dragSize, 0.0, dockingDropLine(state, onDrop, dockedPanelsGrid, [a, b], id, groupName, c, order, separatorSize, true, isRow, lastDropSize, true, isDockingCol, zorder));
							} else {
								if (a == 0)
								MOffset(dropSize, 0.0, dockingDropLine(state, onDrop, dockedPanelsGrid, [a, b], id, groupName, c, order, separatorSize, true, isRow, lastDropSize, true, isDockingCol, zorder))
								else
								dockingDropLine(state, onDrop, dockedPanelsGrid, [a, b], id, groupName, c, order, separatorSize, true, isRow, lastDropSize, true, isDockingCol, zorder);
							}
						}

					} else {
						dockingDropLine(state, onDrop, dockedPanelsGrid, [a, b], id, groupName, color, order, separatorSize, true, isRow, lastDropSize, true, isDockingCol, zorder);
					}
				} else TEmpty()
			});
		};

		// Make single area (col or row) docked panels
		makeAreaContents = \areaScrollingSize : Tropic, lg : bool -> {

println("singleColA");
println(singleColA);


			cntA = mapi(singleColA, \colId, panelId -> {
				panelStyle = getValue(state.style)[panelId];
				enabled = getValue(state.enabled)[panelId];
				fillHeight = fillHeightArea || contains(panelStyle, MDockingFillSpace());
				
				// Fill panel order
				fillBottomTop = colId == lastPanel; 	// fill last panel - default
				fillTopBottom = colId == 0; 			// fill first panel
				fillPanelOrder = if (stickBottomPanels) fillTopBottom else fillBottomTop;

				// Dropping area overlay
				dropAreaOverlay = 
					if (isColumn) {
						MLines([
							makeInnerDroppingLine(i, colId, dockingPrimaryColor, panelId),
							if (se) {
								// if (colId == lastPanel || fillHeight) MShow(getValue(state.expanded)[panelId], TFillY()) else TEmpty(); //--ORIGINAL

								println("panelId");
println(panelId);
								if (fillPanelOrder || fillHeight) MShow(getValue(state.expanded)[panelId], TFillY()) else TEmpty();
							} else TEmpty(),
							// if (colId == lastPanel) makeInnerDroppingLine(i, colId + 1, dockingPrimaryColor, lg, panelId) else TEmpty()
							makeInnerDroppingLine(i, colId + 1, dockingPrimaryColor, panelId) 
						]) 


					} else {
						MColsA([
							makeInnerDroppingLine(i, colId, dockingPrimaryColor, panelId),
							if (se) {
								if (colId == lastPanel) MShow(getValue(state.expanded)[panelId], TFillX()) else TEmpty();
							} else TEmpty(),
							makeInnerDroppingLine(i, colId + 1, dockingPrimaryColor, panelId) |> showIf(colId == lastPanel)
						])
					}

				// ENABLED
				MShowLazy(enabled, \ ->
					MGroup2(	
						// makeDockingPanel(true, state, panelId, groupName, isColumn, colId == lastPanel, panelStyle, dropSize, make([]), sideExpandedA[i], zorder)  	// Docked panel		 
						makeDockingPanel(true, state, panelId, groupName, isColumn, fillPanelOrder, panelStyle, dropSize, make([]), sideExpandedA[i], zorder)  	// Docked panel - fill the first	 
							|> showIf(dockedSizeA != []),	
						dropAreaOverlay 																													// Drop layer
					)
				);
			});

			singleAreaWithContents = if (isColumn) MLines(cntA) else MColsA(cntA);
			if (dontScroll)  MCropSize(areaScrollingSize, singleAreaWithContents) else MScroll(singleAreaWithContents, areaScrollingSize, []);
		}

		// Side expander button
		sideExpFn = \ -> {
			iter(singleColA, \c -> reverseBehaviour(getValue(state.sideExpanded)[c]));
			reverseBehaviour(redraw);
		}

		sideExpBtnLabel = if (isRightCol) {
			if (se) "skip_next" else "skip_previous";
		} else {
			if (!se) "skip_next" else "skip_previous";
		}

		sideExpBtnItem = \lg : bool -> MGroup2(
			TRectangle([MFill(sideExpanderBgColorFn(lg, style))], TFillXH(sideExpanderButtonSize)),
			if (isRightCol) MColsA([TFillX(), MIcon(sideExpBtnLabel, [MIconSize(sideExpanderButtonSize - 2.0), dockedTitleColorFn(lg, style)]), TFixed(2.0, 2.0)])
			else MColsA([TFixed(2.0, 2.0), MIcon(sideExpBtnLabel, [MIconSize(sideExpanderButtonSize - 2.0), dockedTitleColorFn(lg, style)]), TFillX()]),
		);

		sideExpBtnItemHover = \lg : bool -> MGroup2(
			TRectangle([MFill(sideExpanderHoverColorFn(lg, style))], TFillXH(sideExpanderButtonSize)),
			if (isRightCol) MColsA([TFillX(), MIcon(sideExpBtnLabel, [MIconSize(sideExpanderButtonSize - 2.0), dockedTitleColorFn(lg, style)]), TFixed(2.0, 2.0),])
			else MColsA([TFixed(2.0, 2.0), MIcon(sideExpBtnLabel, [MIconSize(sideExpanderButtonSize - 2.0), dockedTitleColorFn(lg, style)])]),
		) ;

		sideExpanderBtn = \lg : bool -> MRawButton(sideExpBtnItem(lg), sideExpBtnItemHover(lg), sideExpBtnItem(lg), sideExpBtnItem(lg),
			"", [], [TOnClicked(sideExpFn)]);


		// Area background with content
		makeBgAndContentCol = \lg : bool, colWidthB : Transform<double> -> {
			singleColSize = if (se) TSelect(colWidthB, \w  -> TFillWY(w)) else TFillWY(dockingSideCollapsedSize);
			// MGroup2(
			// 	TRectangle([MFill(areaBgColorFn(lg, style))], singleColSize),
			// 	makeAreaContents(singleColSize, lg),
			// );

			MFrame(0.0, 0.0, [MFill(areaBgColorFn(lg, style))], makeAreaContents(singleColSize, lg))
		}

		makeBgAndContentRow = \lg : bool, rowHeightB : Transform<double> -> {
			singleRowSize = if (se) TSelect(rowHeightB, \h  -> TFillXH(h)) else TFillXH(dockingSideCollapsedSize);
			MGroup2(
				TRectangle([MFill(areaBgColorFn(lg, style))], singleRowSize),
				makeAreaContents(singleRowSize, lg)
			);
		}

		// A resizable column or row of panels
		MSelect(getValue(state.enabled)[i], \e -> {
			MConstruct([
				makeSubscribe(resizePressedH, \p -> {
					if (p) {
						addMInteractionItemId(manager, itemId);
						next(currXy, getValue(state.mouseXy));
						next(panelWH, WidthHeight(getValue(WA[i]),getValue(HA[i])));
						next(isResizing, true);
					} else {
						if (getValue(isResizing)) next(isResizing, false);
					}
				}),
				makeSubscribe(state.mouseXy, \mxy -> {
					if (isCurrentMInteractionItemId(manager, itemId) && getValue(isResizing)) {
						rtlCorrection = if (getDefaultRtl()) -1.0 else 1.0; // correction the direction of width changing depending of rtl mode
						blockOtherMInteractionItemIds(manager, itemId);
						if (isColumn) {
							if (isRightCol) nextDistinct(WA[i], max(maxPanelsWidth, getValue(panelWH).width + rtlCorrection*(getValue(currXy).x - mxy.x)))
								else nextDistinct(WA[i], max(maxPanelsWidth, getValue(panelWH).width - rtlCorrection*(getValue(currXy).x - mxy.x)));
							} else {
							if (isBottomLine) nextDistinct(HA[i], max(maxPanelsWidth, getValue(panelWH).height + (getValue(currXy).y - mxy.y)))
								else nextDistinct(HA[i], max(maxPanelsWidth, getValue(panelWH).height - (getValue(currXy).y - mxy.y)));
							}
					};
				}),
				// \ -> \-> println("dispose" + i2s(id)),
			],
			MInteractive([TMouseXY(mouseXyLocal)],
				MSelect(manager.white, \ww -> {
					containsDark = fold(singleColA, false, \acc, a -> acc || contains(getValue(state.style)[a], MDockingForceDarkTheme()));
					containsLight = fold(singleColA, false, \acc, a -> acc || contains(getValue(state.style)[a], MDockingForceLightTheme()));
					light = if (containsDark) false else if (containsLight) true else ww;

					MLines2(
						if ((isColumn && !dontSideExpand && !dontSideExpandPanel))  sideExpanderBtn(light) else TEmpty(),
						if (isColumn) makeBgAndContentCol(light, WA[i]) else makeBgAndContentRow(light, HA[i])
					)
				})
			));
		});
	}
}



// Col separator with resize handle
makeColResizeSeparatorFn(isColumn : bool, state : MDockingState, style : [MDockingStyle]) -> (int, int, int, [int], DynamicBehaviour<bool>) -> Material {


	\a : int, b : int, maxLenght : int, singleColA : [int], resizePressedH : DynamicBehaviour<bool> -> {
		manager = state.manager;	
		isHovering = make(false);
		isRightCol  = contains(style, MDockingRightCols());
		isBottomLine = contains(style, MDockingBottomtLines());
		dontResize  = contains(style, MDockingDontResize());
		dontResizeAll = fold(singleColA, true, \acc, p -> acc && contains(getValue(state.style)[p], MDockingDontResize()));

		// Sizes
		dropSize = extractStruct(style, MDockingDropSize(dockingDropSize)).size;
		dragSize = dockingDragSize;
		rowSize = if (isColumn) TFillXH(dropSize) else TFillWY(dropSize);
		colSize = if (isColumn) TFillWY(dropSize) else TFillXH(dropSize);
		colSizeDrag = if (isColumn) TFillWY(dragSize) else TFillXH(dragSize);
		invisibleBar = TRectangle([MFill(MGreen(700)), FillOpacity(0.0)], colSizeDrag);

		// Dragging bar 
		smallHandle = \lg : bool -> TRectangle([MFill(resizeHandleColorFn(lg, style))], if (isColumn) TFixed(dockingHandleW, dockingHandleH) else TFixed(dockingHandleH, dockingHandleW));		
		draggingBarInactive = \lg : bool -> TRectangle([MFill(separatorColorFn(lg, style))], colSizeDrag);
		draggingBarActive = \lg : bool -> {
			MCursor(
				if (isColumn) EWResizeCursor() else NSResizeCursor(),
				MInteractive([TMouseDown(resizePressedH), TMouseInside(isHovering, false)],
					MGroup2(
						MSelect(isHovering, \h -> TRectangle([MFill(if (h) dockingPrimaryColor else separatorColorFn(lg, style)), FillOpacity(dockingDragHandleOpacity)], colSizeDrag)),
						MCenterIn(smallHandle(lg), colSizeDrag)
					)
				)
			);
		}

		draggingBarSideExpanded =  \lg : bool -> if (getValue(getValue(state.sideExpanded)[singleColA[0]])) draggingBarActive(lg) else draggingBarInactive(lg);

		draggingBar = 
			MSelect(manager.white, \ww -> {
				containsDark = fold(singleColA, false, \acc, p -> acc || contains(getValue(state.style)[p], MDockingForceDarkTheme()));
				containsLight = fold(singleColA, false, \acc, p -> acc || contains(getValue(state.style)[p], MDockingForceLightTheme()));
				light = if (containsDark) false else if (containsLight) true else ww;

				if (maxLenght == 1) {
					if (dontResizeAll || dontResize) TEmpty() else draggingBarSideExpanded(light);
				} else {
					if (dontResizeAll || dontResize) draggingBarInactive(light) else {
						if (getValue(getValue(state.sideExpanded)[singleColA[0]])) draggingBarActive(light) else invisibleBar			
					}
				}
			});

		if (isRightCol || isBottomLine) {
			if (a != maxLenght) draggingBar else TEmpty();
		} else {
			if (a != 0) draggingBar else TEmpty();
		}
	}
};