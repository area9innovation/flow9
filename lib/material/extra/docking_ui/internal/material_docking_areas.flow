import material/material_ui;
import material/extra/docking_ui/internal/material_docking_utils;
import material/extra/docking_ui/internal/material_docking_drop;
import material/extra/docking_ui/internal/material_docking_panels;


export {
	// NOTE:
	// - MDockingAreas can act as a "dockable MCols" or "MLines" (by "isColumn")
	// - each MDockingArea has unique id
	// - different MDockingAreas can have the same groupName
	// - the groupNames are used by MDockingPanel in the "allowedGroups" field
	// - each panel can have a vertical or horizontal orientation, but its size is defined by default as vertical
	// - when docked on cols a panel will be shown as vertical, when on lines as horizontal
	// - when mobile a panel will be vertical, but you can flip it with MDockingMobileHorizontal() style
	// - example in flow9/lib/material/tests/test_docking_ui.flow

	MDockingArea(isColumn : bool, state : MDockingState, groupName : string, areaId : int, style : [MDockingStyle]) -> Material;
}

// Let's think about dockable/resizable MCols with inside MLines of panels, 
// the logic can be swithched and we get MLines with inside MCols 
MDockingArea(isColumn : bool, state : MDockingState, groupName : string, areaId : int, style : [MDockingStyle]) -> Material {

	MShowLazy(fselect(state.size, FLift(\sz -> sz != [])), 
		\ -> {

			manager = state.manager;
			itemId = makeTropicTag(manager);              //
			zorder = getValue(manager.manager.zorder);
			contentA = getValue(state.content);
			sizeA = getValue(state.size);

			// Drop
			onDragging = manager.manager.dragging;
			onDrop = make(-1);
			order = make([0, 0]);
			dockedPanelsGrid = make([[]]);
			isDockingCol = make(true);
			isRow = make(false);
			lastDropSize = make(TEmpty());

			// Drop Info
			dropInfo = 
				MDockingDropInfo(
					areaId,
					groupName,
					onDrop, 
					order, 
					dockedPanelsGrid, 
					isDockingCol, 
					isRow, 
					lastDropSize
				);

			// Inactive drop bar
			dropSize = extractStruct(style, MDockingDropSize(dockingDropSize)).size;
			colSize = if (isColumn) TFillWY(dropSize) else TFillXH(dropSize);
			inactiveDropLine = TRectangle([MFill(MGrey(300))], colSize);


			areaGridT = fselect(state.dock, FLift(\dockA -> {
				// println(dockA);
				extractAreaGridById(dockA, areaId)
			}));

			WA = map(contentA,\c -> make(0.0));
			HA = map(contentA,\c -> make(0.0));

			MSelect(areaGridT, \areaGrid : [[int]] -> {

				areaSizeInfo = 
					MDockingAreaSizeInfo(
						[],
						make(map(areaGrid, \__ -> 0.0)),
						make(map(areaGrid, \c -> map(c, \__ -> 0.0)))
					);

				// println("areaSize");
				// println(areaSize);

				println(" > DRAW - DockingArea - " + i2s(areaId)+ "    - " + toString(areaGrid));
				// println(" > DRAW - DockingArea - REDRAW or DOCKA:  " +  b2s(r) + "    - " + toString(areaGrid));
				// println("areaGrid");
				// println(extractAreaGridById(getValue(state.dock), areaId));
				// Get Panel
				// areaGrid = extractAreaGridById(d, areaId);

				next(dockedPanelsGrid, areaGrid);

				mapi(areaGrid, \colId, colA -> {

					atLeastOneEnabledInCol = fold(colA, false, \acc, a -> acc || getValue(getValue(state.enabled)[a]));
					atLeastOneEnabled = fold(areaGrid, false, \acc, singleColA -> acc || fold(singleColA, false, \acc2, a -> acc2 || getValue(getValue(state.enabled)[a])));
					enabledColT = fmerge(map(colA, \c -> getValue(state.enabled)[c]));
					sideExpandedColT = fmerge(map(colA, \c -> getValue(state.sideExpanded)[c]));

					// Col size

					// areaSizeInfo.colSizeA
					updateColSize(areaSizeInfo,  colId, 300.0);
		
					// Enable a single col					
					MSelect3(
						manager.white, 
						enabledColT,
						sideExpandedColT, 
						\w, e, __ -> {

							containsDark = fold(colA, false, \acc, a -> acc || contains(getValue(state.style)[a], MDockingForceDarkTheme()));
							containsLight = fold(colA, false, \acc, a -> acc || contains(getValue(state.style)[a], MDockingForceLightTheme()));
							colTheme = if (containsDark) false else if (containsLight) true else w;

							println(" > DRAW - docked lines of panels - " + i2s(areaId) + "      - " + toString(colA));

							
							if (atLeastOneEnabledInCol) {
								// Single resizable column of docked panels with dragging handles and drop areas
								makeDockedPanelA(
									isColumn,
									dropInfo,
									areaSizeInfo,
									state,
									WA,
									HA,
									areaGrid,
									colA,
									colId,
									colTheme,
									style
								);

							} else if (atLeastOneEnabled) {
								TEmpty();
							} else {
								// NO PANELS ENABLED
								dockingDropLine(isColumn, 0, dropInfo, state, [0, 0],  inactiveDropLine,  true, zorder, style);
							}
						}
					);


				}) |> (\f -> if (isColumn) MColsA(f) else MLines(f))

				// NO PANELS DOCKED
				|> (\f -> if (areaGrid != []) f 
					else dockingDropLine(isColumn, 0, dropInfo, state, [0, 0], inactiveDropLine,  true, zorder, style));
				
			});

		} 
	);
}


makeDockedPanelA(
	isColumn : bool,
	dropInfo : MDockingDropInfo,
	areaSizeInfo : MDockingAreaSizeInfo,
	state : MDockingState,

	WA : [DynamicBehaviour<double>], 
	HA : [DynamicBehaviour<double>], 

	areaGrid : [[int]],
	colA : [int], 
	colId : int,

	light : bool, 
	style : [MDockingStyle]
) -> Material {

	// println("  ------------- > makeResizableColFn " + i2s(areaId));

	manager = state.manager;
	onDragging = manager.manager.dragging;
	zorder = getValue(manager.manager.zorder);
	groupA = state.group;
	contentA = getValue(state.content);

	// Drop info
	areaId = dropInfo.areaId;
	groupName = dropInfo.groupName; 

	dockedSizeA = getValue(state.dockedSize);
	dropSize = extractStruct(style, MDockingDropSize(dockingDropSize)).size;
	dragSize = dockingDragSize;
	handleHeight = dropSize;
	rowSize = if (isColumn) TFillXH(dropSize) else TFillWY(dropSize);
	colSize = if (isColumn) TFillWY(dropSize) else TFillXH(dropSize);
	inactiveDropLine = TRectangle([MFill(MGrey(300))], rowSize);

	fillHeightArea = contains(style, MDockingFillSpace());
	stickBottomPanels = contains(style, MDockingColStickBottom());
			
	dontResize  = contains(style, MDockingDontResize());
	dontSideExpand = contains(style, MDockingDontCollapseColumn());

	sideExpandedA = map(contentA,\c -> make(false));

	lastPanel = length(colA) - 1;
	lastCol = length(areaGrid) - 1;

	// mouseXyLocalR = make(zeroPoint);
	maxPanelSize = TSizeOf(TGroup(map(colA, \s -> if (dockedSizeA != []) dockedSizeA[s] else TEmpty())));
	dontResizeAll = fold(colA, true, \acc, p -> acc && contains(getValue(state.style)[p], MDockingDontResize()));
	dontSideExpandPanel = fold(colA, false, \acc, p -> acc || contains(getValue(state.style)[p], MDockingDontCollapsePanel()));

	panelsWidthA = map(colA, \s -> getTropicMetrics(getValue(state.size)[s]).width);
	dockedWidthA = map(colA, \s -> getTropicMetrics(getValue(state.dockedSize)[s]).width);
	mobileWidthA = map(colA, \s -> getTropicMetrics(getValue(state.mobileSize)[s]).width);

	maxPanelsWidth = either(maxA(panelsWidthA), -doubleMax);
	maxDockedWidth = either(maxA(dockedWidthA), -doubleMax);
	maxMobileWidth = either(maxA(mobileWidthA), -doubleMax);
	// se = getValue(getValue(state.sideExpanded)[colA[0]]);

	if (getValue(WA[colId]) == 0.0) next(WA[colId], maxPanelsWidth);
	if (getValue(HA[colId]) == 0.0) next(HA[colId], maxPanelsWidth);

	colHeightB = make(0.0);

	MFrame(0.0, 0.0, [MFill(areaBgColorFn(light, style))], 
		MGroup2(							
			TFillY() |> (\f -> MAttachHeight(f, colHeightB)),  // Get column height
			MLines2(	
				if ((isColumn && !dontSideExpand && !dontSideExpandPanel))  makeSideExpanderBtn(state, colA, light, style) else TEmpty(),  // Side expander button
							
				// Docked panels			
				mapi(colA, \rowId, panelId -> {
					panelStyle = getValue(state.style)[panelId];
					fillHeight = fillHeightArea || contains(panelStyle, MDockingFillSpace());  // NOTE: should be handled
					
					// Fill panel order
					fillBottomTop = rowId == lastPanel; 	// fill last panel --default
					fillTopBottom = rowId == 0; 			// fill first panel
					fillPanelOrder = if (stickBottomPanels) fillTopBottom else fillBottomTop;

updateRowSize(areaSizeInfo, colId, rowId, 120.0);
println(getValue(areaSizeInfo.colSizeA));
println(getValue(areaSizeInfo.rowSizeA));


					// A single docked panel	
					makeDockedPanel(
						state, 
						panelId, 
						Pair(colId, rowId), 
						colA, 
						colHeightB, 
						dropInfo, 
						isColumn, 
						fillPanelOrder, 
						style, 
						dropSize, 
						sideExpandedA[colId], 
						zorder
					) |> (\f ->
						// Wrapper with drop area and resize handle for a row
						makeAvailableDockedHeight(f, isColumn, dropInfo, state, colHeightB, panelId, colA, rowId, fillPanelOrder, style, dropSize, sideExpandedA[colId], zorder)	
					) |> showIf(dockedSizeA != [])

				}) |> (\f -> if (isColumn) MLines(f) else MColsA(f))		
			)
		) 
	) |> (\f ->
		// Wrapper with drop area and resize handle for a col
		makeAvailableDockedWidth(f, isColumn, dropInfo, state,  WA, HA, areaGrid, colA, colId, light, style)
	)

}


// makeAvailableDockedHeight(
// 		box : Material, 
// 		isColumn : bool,
// 		dropInfo : MDockingDropInfo, 
// 		state : MDockingState,
// 		colHeightB : DynamicBehaviour<double>, 

// 		panelId : int, 
// 		singleColA : [int], 
// 		rowId : int,
		
// 		fillPanel : bool, 
// 		style : [MDockingStyle], 
// 		barHeight: double, 
// 		sideCollapsed : DynamicBehaviour<bool>, 
// 		zorder : int 






makeAvailableDockedWidth(
	box : Material, 
	isColumn : bool,
	dropInfo : MDockingDropInfo,
	state : MDockingState, 
	WA : [DynamicBehaviour<double>], 
	HA : [DynamicBehaviour<double>], 
	areaGrid : [[int]],
	colA : [int], 
	colId : int,
	light : bool,
	style : [MDockingStyle]
) -> Material {

	manager = state.manager;
	itemId = makeTropicTag(manager);
	zorder = getValue(manager.manager.zorder);

	isBottomLine = contains(style, MDockingBottomtLines());
	isRightCol  = contains(style, MDockingRightCols());
	dontScroll  = contains(style, MDockingDontScroll());	

	resizeCol = true;
	resizePressed = make(false);
	isResizing = make(false);
	mouseXyLocal = make(zeroPoint);
	currXy = make(zeroPoint);
	panelWH = makeWH();

	panelsWidthA = map(colA, \s -> getTropicMetrics(getValue(state.size)[s]).width);
	maxPanelsWidth = either(maxA(panelsWidthA), -doubleMax);
	se = getValue(getValue(state.sideExpanded)[colA[0]]);

	numOfCols = length(areaGrid);
	lastCol = numOfCols - 1;

	// Cols separator with drop
	makeColResizeSeparator = makeMDockingSeparatorDrop(isColumn, resizeCol, colId, colA,  numOfCols, dropInfo, resizePressed, state, style);

	// Drop enpoint
	dragHandleSize = makeColSize(dockingDragSize, isColumn);
	draggingBarInactive = \lg : bool -> TRectangle([MFill(separatorColorFn(lg, style))], dragHandleSize);
	dLine = dockingDropLine(isColumn, colId,  dropInfo, state, [if (isRightCol) lastCol + 1 else 0, 0], draggingBarInactive(light), true, zorder, style);

	colFiller = if (isColumn) TFillX() else TFillY();

	colWithHandles = {
		if (colId == 0 && numOfCols == 1)
		[
			if (isRightCol || isBottomLine) makeColResizeSeparator else dLine,
			colFiller,
			if (isRightCol || isBottomLine) dLine else makeColResizeSeparator,
		]
		else if (colId == 0 && numOfCols != 1)
		[
			if (isRightCol || isBottomLine) makeColResizeSeparator else dLine,
			colFiller,
			if (isRightCol || isBottomLine) TEmpty() else makeColResizeSeparator,
		]
		else if (colId != 0 && colId == numOfCols - 1)
		[
			if (!isRightCol && !isBottomLine) TEmpty() else makeColResizeSeparator,
			colFiller,
			if (isRightCol || isBottomLine) dLine else makeColResizeSeparator,
		]
		else
		[
			if (!isRightCol && !isBottomLine) TEmpty() else makeColResizeSeparator,
			colFiller,
			if (isRightCol || isBottomLine) TEmpty() else makeColResizeSeparator,
		]

		// [
		// 	makeMDockingSeparatorDrop(resizeCol, colA, colId, numOfCols, dropInfo, resizePressed, state, style),
		// 	colFiller,
		// 	makeMDockingSeparatorDrop(resizeCol, colA, colId + 1, numOfCols, dropInfo, resizePressed, state, style),
		// ]

	} |> (\f -> if (isColumn) MCols(f) else MLines(f))


	scrollBox = if (dontScroll) MCropSize(TFillXY(), box) else MScroll(box, TFillXY(), []);
	resizableScrollBox = MGroup2(scrollBox, colWithHandles);

	MConstruct([
		makeSubscribe(resizePressed, \p -> {
			if (p) {
				addMInteractionItemId(manager, itemId);
				next(currXy, getValue(state.mouseXy));
				next(panelWH, WidthHeight(getValue(WA[colId]), getValue(HA[colId])));
				next(isResizing, true);
			} else {
				if (getValue(isResizing)) next(isResizing, false);
			}
		}),
		makeSubscribe(state.mouseXy, \mxy -> {
			if (isCurrentMInteractionItemId(manager, itemId) && getValue(isResizing)) {
				rtlCorrection =1.0; // if (getDefaultRtl()) -1.0 else 1.0; // correction the direction of width changing depending of rtl mode
				blockOtherMInteractionItemIds(manager, itemId);
				if (isColumn) {
					if (isRightCol) nextDistinct(WA[colId], max(maxPanelsWidth, getValue(panelWH).width + rtlCorrection*(getValue(currXy).x - mxy.x)))
						else nextDistinct(WA[colId], max(maxPanelsWidth, getValue(panelWH).width - rtlCorrection*(getValue(currXy).x - mxy.x)));
					} else {
					if (isBottomLine) nextDistinct(HA[colId], max(maxPanelsWidth, getValue(panelWH).height + (getValue(currXy).y - mxy.y)))
						else nextDistinct(HA[colId], max(maxPanelsWidth, getValue(panelWH).height - (getValue(currXy).y - mxy.y)));
					}
			};
		}),
		// \ -> \-> println("dispose" + i2s(areaId)),
	],
	MInteractive([
			TMouseXY(mouseXyLocal)
		],
		MAvailable(
			resizableScrollBox, 
			if (isColumn) {
				if (se) TSelect(WA[colId], \w  -> TFillWY(w)) else TFillWY(dockingSideCollapsedSize);
			} else {
				if (se) TSelect(HA[colId], \h  -> TFillXH(h)) else TFillXH(dockingSideCollapsedSize);
			}
		)
	));
}
