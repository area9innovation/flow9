import material/material_ui;
import material/extra/docking_ui/internal/material_docking_utils;
import material/extra/docking_ui/internal/material_docking_panels;
// import material/extra/docking_ui/internal/material_docking_drop;


export {
	// NOTE:
	// - MDockingAreas can act as a "dockable MCols" or "MLines" (by "isColumn")
	// - each MDockingArea has unique id
	// - different MDockingAreas can have the same groupName
	// - the groupNames are used by MDockingPanel in the "allowedGroups" field
	// - each panel can have a vertical or horizontal orientation, but its size is defined by default as vertical
	// - when docked on cols a panel will be shown as vertical, when on lines as horizontal
	// - when mobile a panel will be vertical, but you can flip it with MDockingMobileHorizontal() style
	// - example in flow9/lib/material/tests/test_docking_ui.flow

	MDockingArea(isColumn : bool, state : MDockingState, groupName : string, areaId : int, style : [MDockingStyle]) -> Material;
}

// Let's think about dockable/resizable MCols with inside MLines of panels, 
// the logic can be swithched and we get MLines with inside MCols 
MDockingArea(isColumn : bool, state : MDockingState, groupName : string, areaId : int, style : [MDockingStyle]) -> Material {

	MShowLazy(fselect(state.size, FLift(\sz -> sz != [])), 
		\ -> {

			manager = state.manager;
			itemId = makeTropicTag(manager);              //
			zorder = getValue(manager.manager.zorder);
			contentA = getValue(state.content);
			sizeA = getValue(state.size);

			// Drop
			onDragging = manager.manager.dragging;
			onDrop = make(-1);
			order = make([0, 0]);
			dockedPanelsGrid = make([[]]);
			isDockingCol = make(true);
			isRow = make(false);
			lastDropSize = make(TEmpty());

			// Drop Info
			dropInfo = 
				MDockingDropInfo(
					areaId,
					groupName,
					onDrop, 
					order, 
					dockedPanelsGrid, 
					isDockingCol, 
					isRow, 
					lastDropSize
				);

			// Inactive drop bar
			dropSize = extractStruct(style, MDockingDropSize(dockingDropSize)).size;
			colSize = if (isColumn) TFillWY(dropSize) else TFillXH(dropSize);
			inactiveDropLine = TRectangle([MFill(MGrey(300))], colSize);



			// areaSizeInfo = {
			// 	aGrid = extractAreaGridById(getValue(state.dock), areaId);
			// 		MDockingAreaSizeInfo(
			// 			[],
			// 			make(map(aGrid, \__ -> 220.0)),
			// 			make(map(aGrid, \c -> map(c, \__ -> 0.0)))
			// 		);
			// }



			areaGridT = fselect(state.dock, FLift(\dockA -> extractAreaGridById(dockA, areaId)));

			WA = map(contentA,\c -> make(0.0));
			HA = map(contentA,\c -> make(0.0));

			

			MSelect(areaGridT, \areaGrid : [[int]] -> {


				// println(" > DRAW - DockingArea - " + i2s(areaId)+ "    - " + toString(areaGrid));
				// println(" > DRAW - DockingArea - REDRAW or DOCKA:  " +  b2s(r) + "    - " + toString(areaGrid));
				// println("areaGrid");
				// println(extractAreaGridById(getValue(state.dock), areaId));
				// Get Panel
				// areaGrid = extractAreaGridById(d, areaId);

				next(dockedPanelsGrid, areaGrid);

				mapi(areaGrid, \colId, colA -> {

					atLeastOneEnabledInCol = fold(colA, false, \acc, a -> acc || getValue(getValue(state.enabled)[a]));
					atLeastOneEnabled = fold(areaGrid, false, \acc, singleColA -> acc || fold(singleColA, false, \acc2, a -> acc2 || getValue(getValue(state.enabled)[a])));
					enabledColT = fmerge(map(colA, \c -> getValue(state.enabled)[c]));
					sideExpandedColT = fmerge(map(colA, \c -> getValue(state.sideExpanded)[c]));

					// Col size

		
		
					// Enable a single col					
					MSelect3(
						manager.white, 
						enabledColT,
						sideExpandedColT, 
						\w, e, __ -> {

							containsDark = fold(colA, false, \acc, a -> acc || contains(getValue(state.style)[a], MDockingForceDarkTheme()));
							containsLight = fold(colA, false, \acc, a -> acc || contains(getValue(state.style)[a], MDockingForceLightTheme()));
							colTheme = if (containsDark) false else if (containsLight) true else w;

							// println(" > DRAW - docked lines of panels - " + i2s(areaId) + "      - " + toString(colA));

							
							if (atLeastOneEnabledInCol) {
								// Single resizable column of docked panels with dragging handles and drop areas
								makeDockedPanelA(
									isColumn,
									dropInfo,
									state,
									WA,
									HA,
									areaGrid,
									colA,
									colId,
									colTheme,
									style
								);

							} else if (atLeastOneEnabled) {
								TEmpty();
							} else {
								// NO PANELS ENABLED
								dockingDropLine(isColumn, 0, dropInfo, state, [0, 0],  inactiveDropLine,  true, style);
							}
						}
					);


				}) |> (\f -> if (isColumn) MColsA(f) else MLines(f))

				// NO PANELS DOCKED
				|> (\f -> if (areaGrid != []) f 
					else dockingDropLine(isColumn, 0, dropInfo, state, [0, 0], inactiveDropLine,  true, style));
				
			});

		} 
	);
}


makeDockedPanelA(
	isColumn : bool,
	dropInfo : MDockingDropInfo,
	state : MDockingState,

	WA : [DynamicBehaviour<double>], 
	HA : [DynamicBehaviour<double>], 

	areaGrid : [[int]],
	colA : [int], 
	colId : int,

	light : bool, 
	style : [MDockingStyle]
) -> Material {

	// println("  ------------- > makeResizableColFn " + i2s(areaId));

	manager = state.manager;
	onDragging = manager.manager.dragging;
	zorder = getValue(manager.manager.zorder);
	groupA = state.group;
	contentA = getValue(state.content);

	// Drop info
	areaId = dropInfo.areaId;
	groupName = dropInfo.groupName; 


					// println("colW");
					// println(colW);





	dockedSizeA = getValue(state.dockedSize);
	dropSize = extractStruct(style, MDockingDropSize(dockingDropSize)).size;
	dragSize = dockingDragSize;
	handleHeight = dropSize;
	rowSize = if (isColumn) TFillXH(dropSize) else TFillWY(dropSize);
	colSize = if (isColumn) TFillWY(dropSize) else TFillXH(dropSize);
	inactiveDropLine = TRectangle([MFill(MGrey(300))], rowSize);

	fillHeightArea = contains(style, MDockingFillSpace());
	stickBottomPanels = contains(style, MDockingColStickBottom());
			
	dontResize  = contains(style, MDockingDontResize());
	dontSideExpand = contains(style, MDockingDontCollapseColumn());

	sideExpandedA = map(contentA,\c -> make(false));

	lastPanel = length(colA) - 1;
	lastCol = length(areaGrid) - 1;

	// mouseXyLocalR = make(zeroPoint);
	maxPanelSize = TSizeOf(TGroup(map(colA, \s -> if (dockedSizeA != []) dockedSizeA[s] else TEmpty())));
	dontResizeAll = fold(colA, true, \acc, p -> acc && contains(getValue(state.style)[p], MDockingDontResize()));
	dontSideExpandPanel = fold(colA, false, \acc, p -> acc || contains(getValue(state.style)[p], MDockingDontCollapsePanel()));

	panelsWidthA = map(colA, \s -> getTropicMetrics(getValue(state.size)[s]).width);
	dockedWidthA = map(colA, \s ->{
		println("READING DOCKED SIZEs " + i2s(areaId) + "    - " + i2s(colId));
		println("- - - - - - - - - - - - - - - - - - - - - - - - - - - -");

		println(s);
		println(getTropicMetrics(getValue(state.dockedSize)[s]).width);
		println("-");
		
		
		
		 getTropicMetrics(getValue(state.dockedSize)[s]).width});
	// mobileWidthA = map(colA, \s -> getTropicMetrics(getValue(state.mobileSize)[s]).width);

	maxPanelsWidth = either(maxA(panelsWidthA), -doubleMax);
	maxDockedWidth = either(maxA(dockedWidthA), -doubleMax);
	// maxMobileWidth = either(maxA(mobileWidthA), -doubleMax);
	// se = getValue(getValue(state.sideExpanded)[colA[0]]);

	println("**************");
	println("area: " + i2s(areaId) + " - col: " + i2s(colId));
	println(maxDockedWidth);
	println("**************");
	// Area size info
					
	colWB = make(maxDockedWidth);

	if (getValue(WA[colId]) == 0.0) next(WA[colId], maxPanelsWidth);
	if (getValue(HA[colId]) == 0.0) next(HA[colId], maxPanelsWidth);

	colHeightB = make(0.0);

	MFrame(0.0, 0.0, [MFill(areaBgColorFn(light, style))], 
		MGroup2(							
			TFillY() |> (\f -> MAttachHeight(f, colHeightB)),  // Get column height
			MLines2(	
				if ((isColumn && !dontSideExpand && !dontSideExpandPanel))  makeSideExpanderBtn(state, colA, light, style) else TEmpty(),  // Side expander button
							
				// Docked panels			
				mapi(colA, \rowId, panelId -> {
					
					// Panel position
					isFirstPanel = panelId == firstElement(colA, intMax);
					isLastPanel = panelId == lastElement(colA, intMax);
					lastPanelId = length(colA) - 1;

					// Fill panel order
					fillBottom = rowId == lastPanel; 	// fill last panel --default
					fillTop = rowId == 0; 			// fill first panel
					fillPanelOrder = if (stickBottomPanels) fillTop else fillBottom;
					fillPanelOrderId = if (stickBottomPanels) 0 else lastPanel;

					panelStyle = getValue(state.style)[panelId];
					fillHeight = fillHeightArea || contains(panelStyle, MDockingFillSpace());  // NOTE: should be handled

					// Expanded
					expanded = getValue(state.expanded)[panelId];
					sideExpanded = getValue(state.sideExpanded)[panelId];
					enabled = getValue(state.enabled)[panelId];


										// Panel size
					dockedSize = getValue(state.dockedSize)[panelId];
					pSize = getValue(state.size)[panelId];

					pWidth = getTropicMetrics(dockedSize).width;
					pHeight = if (isLastPanel) getTropicMetrics(pSize).height else getTropicMetrics(dockedSize).height;

					// rowHB = make(pHeight + dockingBarHeight);
					rowHB = make(pHeight);


					println("READING DOCKED H " + i2s(colId) + "    - " + i2s(panelId));
					println("- - - - - - - - - - - - - - - - - - - - - - - - - - - -");
					println(getValue(rowHB));
					println("-");

					pHB = make(0.0);

						// Container size
						WH = if (isColumn) make(WidthHeight(pWidth, pHeight)) else make(WidthHeight(pHeight, pWidth));


	

				MConstruct([
					// makeSubscribe(rowHB, \rh -> {
					// 	println(i2s(panelId) + "- rowHB: " +  toString(rh));

					// }),
					makeSubscribe2(sideExpanded, \se -> {
						if (se) {
							nextDistinct(rowHB, pHeight);
							nextDistinct(colWB, pWidth);
						} else {
							nextDistinct(rowHB, dockingBarHeight);
							nextDistinct(colWB, dockingSideCollapsedSize);
						}
					}),
					makeSubscribe2(expanded, \e -> {
						rH = if (fillPanelOrder) {
							getValue(colHeightB) - sideExpanderButtonSize - foldi(colA, 0.0, \k, acc, pId -> {
								if (k < (length(colA) )) {if (k != fillPanelOrderId) acc + getTropicMetrics(getValue(state.size)[pId]).height else acc} else acc;
							}) 
						} else pHeight;
						// println(" panel" + i2s(panelId) + " - h: " + d2s(rH) );
						if (e) nextDistinct(rowHB, rH) else nextDistinct(rowHB, dockingBarHeight);
					}),
					makeSubscribe(enabled, \e -> {
						if (!e) next(state.dock, mapi(getValue(state.dock), \j, item -> if (j == panelId) [-1, item[1], item[2]] else item)); //undock
					}),


								// Fill correction
								makeSubscribe(
									// Update only the first time
									ftransistor(
										fselect(colHeightB, FLift(\ch -> {
											// getTropicMetrics(getValue(state.size)[panelId]).height == getValue(rowHB)




											// println(" --------------------------------------------->");
											// println(fillPanelOrderId);
											// println(getTropicMetrics(getValue(state.dockedSize)[panelId]).height);
											// println(getValue(rowHB));
											// println(getTropicMetrics(getValue(state.dockedSize)[panelId]).height == getValue(rowHB));
											// println(" --------------------------------------------->");
											getTropicMetrics(getValue(state.dockedSize)[panelId]).height == getValue(rowHB)
											// getTropicMetrics(getValue(state.dockedSize)[panelId]).height == getValue(WH).height
										})),
										colHeightB
									), \colH -> {

									// colHeightB, \colH -> {
											// if (isFirstPanel) {

									if (fillPanelOrder) {
									// if (isFirstPanel) {
										availableColHeight = colH - sideExpanderButtonSize - foldi(colA, 0.0, \k, acc, pId -> {
											if (k < (length(colA) )) {
												if (k != fillPanelOrderId) acc + getTropicMetrics(getValue(state.dockedSize)[pId]).height else acc
											} else acc;
										});
										// Fill height
										// next(WH, WidthHeight(getValue(WH).width, availableColHeight));
										next(rowHB, availableColHeight);
									}// A single docked panel	
								}),






									// makeSubscribe(colHeightB, \colH -> {
									// 	if (isLastPanel) {
									// 			availableColHeight = colH - sideExpanderButtonSize - foldi(colA, 0.0, \k, acc, pId -> {
									// 				if (k < (length(colA) )) {
									// 					if (k != lastPanelId) acc + getTropicMetrics(getValue(state.dockedSize)[pId]).height else acc
									// 				} else acc;
									// 			});

									// 		println(" --------------------------------------------->");
									// 		println(lastPanelId);
									// 		println(colH);
									// 		println(availableColHeight);
									// 		// println(getTropicMetrics(getValue(state.dockedSize)[panelId]).height == getValue(rowHB));
									// 		println(" --------------------------------------------->");

									// 		next(rowHB, availableColHeight);
									// 	}

									// })


				],

					makeDockedPanel(
						state, 
						panelId, 
						Pair(colId, rowId), 
						colA, 
						colHeightB, 
						dropInfo, 
						isColumn, 
						fillPanelOrder, 
						style, 
						dropSize, 
						sideExpandedA[colId], 
						zorder
					) 
					// |> (\f -> MBorder4(dockingDragSize, f))


					
				) |> (\f ->
						// Wrapper with drop area and resize handle for a row
						makeAvailableDockedHeight(f, isColumn, dropInfo, state, rowHB, panelId, colA, colId, rowId, light, style)
					) |> showIf(dockedSizeA != [])

				}) |> (\f -> if (isColumn) MLines(f) else MColsA(f))		
			)
		) 
	) |> (\f ->
		// Wrapper with drop area and resize handle for a col
		makeAvailableDockedWidth(f, isColumn, dropInfo, state, colWB, areaGrid, colA, colId, light, style)
	)

}


	makeAvailableDockedHeight(
		box : Material, 
		isColumn : bool,
		dropInfo : MDockingDropInfo,
		state : MDockingState,
		sizeB : DynamicBehaviour<double>, 

		panelId : int, 
		parentA : [int], 
		colId : int,
		rowId : int,
		
		light : bool,
		style : [MDockingStyle], 

	) -> Material {

		manager = state.manager;
		itemId = makeTropicTag(manager);
		zorder = getValue(manager.manager.zorder);
		pstyle = getValue(state.style)[panelId];
		groupA = state.group;

		// Size	
		sideCollapsedSize = dockingSideCollapsedSize;
		panelDockedSize = getValue(state.dockedSize)[panelId];
		pWidth = getTropicMetrics(panelDockedSize).width;
		pHeight = getTropicMetrics(panelDockedSize).height;

		// Container size
		WH = if (isColumn) make(WidthHeight(pWidth, pHeight)) else make(WidthHeight(pHeight, pWidth));

		// Order
		isFirstPanel = panelId == firstElement(parentA, intMax);
		isLastPanel = panelId == lastElement(parentA, intMax);
		lastPanelId = length(parentA) - 1;

		resizeRow = false;
		resizePressed = make(false);
		isResizing = make(false);
		isHovering = make(false);
		mouseXyLocal = make(zeroPoint);
		
		// Expanded
		expanded = getValue(state.expanded)[panelId];
		sideExpanded = getValue(state.sideExpanded)[panelId];
		enabled = getValue(state.enabled)[panelId];

		se = getValue(getValue(state.sideExpanded)[parentA[0]]);


		collapsedSepColor = MGrey(400);

		isToolbarItem = isSameStructType(getValue(state.content)[panelId][0], MDockingPanelToolbarItem("", []));
		fillHeightArea = contains(style, MDockingFillSpace());
		fillHeight = fillHeightArea || contains(pstyle, MDockingFillSpace());
		isBottomLine = contains(style, MDockingBottomtLines());
		dontScroll  = contains(style, MDockingDontScroll());	

		xheight = make(0.0);
		xwidth = make(0.0);

		// Drop info
		// areaId = dropInfo.areaId;
		groupName = dropInfo.groupName; 
		// onDrop = dropInfo.onDrop;
		// panelsOrder = dropInfo.order;
		// panelsArray = dropInfo.dockedPanelsGrid;

		// isDockingCol = dropInfo.isDockingCol;
		// isRow = dropInfo.isRow; 
		// lastDropSize = dropInfo.lastDropSize;


		// println(" > DRAW - Container R - " + i2s(panelId) /*+ "      - " + toString(parentA)*/);

		// Rows separator with drop
		// makeRowResizeSeparator = \idx -> makeMDockingSeparatorDrop(isColumn, resizeRow, colId, idx, parentA, length(parentA), dropInfo, resizePressed, state, style);
		makeRowResizeSeparator = \idx -> dockingResizeAndDropLine(isColumn, resizeRow, [colId, idx], dropInfo, resizePressed, state, style);
		

		// Drop enpoint
		dragHandleSize = makeRowSize(dockingDragSize, isColumn);
		// draggingBarInactive = \lg : bool -> TRectangle([MFill(separatorColorFn(lg, style))], dragHandleSize);
		draggingBarInactive = \lg : bool -> TRectangle([MFill(MIndigoA(500))], dragHandleSize);
		// dLine = \idx -> dockingDropLine(resizeRow && isColumn, idx,  dropInfo, state, [if (isBottomLine) lastPanelId + 1 else 0, 0], MEmpty(), true, style);
		dLine = \idx : int , e : bool -> dockingDropLine(resizeRow && isColumn, rowId,  dropInfo, state, [0, idx], MEmpty(), e, style);

		rowFiller = if (isColumn) TFillY() else TFillX();

		rowsWithHandles = {
			if (rowId == 0 && length(parentA) == 1)
			[
				if (isBottomLine) dLine(rowId + 1, false) else dLine(rowId, true),
				rowFiller,
				if (isBottomLine) dLine(rowId, true) else dLine(rowId + 1, false) ,
			]
			else if (rowId == 0 && length(parentA) != 1)
			[
				if (isBottomLine) dLine(rowId + 1, true) else dLine(rowId, true),
				rowFiller,
				if (isBottomLine) TEmpty() else makeRowResizeSeparator(rowId + 1),
			]
			else if (rowId ==  length(parentA) - 1 && length(parentA) != 1)
			[
				if (!isBottomLine) TEmpty() else makeRowResizeSeparator(rowId),
				rowFiller,
				if (!isBottomLine) dLine(rowId + 1, false) else dLine(rowId, true),
			]
			else
			[
				if (!isBottomLine) TEmpty() else makeRowResizeSeparator(rowId),
				rowFiller,
				if (isBottomLine) TEmpty() else   makeRowResizeSeparator(rowId + 1),
			]
		} |> (\f -> if (isColumn) MLines(f) else MCols(f));

		scrollBox = if (dontScroll) MCropSize(TFillXY(), box) else MScroll(box, TFillXY(), []);
		// resizableScrollBox = MGroup2(scrollBox, rowsWithHandles);


		addRowSeparator = \ f : Material -> MLinesA(
			[
				if (!isBottomLine) TEmpty() else draggingBarInactive(light),  //top
				f,
				if (isBottomLine) TEmpty() else draggingBarInactive(light) //botttom
			]
		);

		addDragAndDropHelper = \ f : Material ->  MGroup2(f, rowsWithHandles);




		MConstruct([
				makeSubscribe2(isResizing, \rs -> { 
					if (!rs) {
						println("update H -" + i2s(panelId) + "- "+ toString(getValue(sizeB)));
						updateTH(state.dockedSize, panelId,  getValue(sizeB));
					}
				}),
			makeSubscribe(resizePressed, \p -> {
				if (p) {
					addMInteractionItemId(manager, itemId);
					next(isResizing, true);
				} else {
					if (getValue(isResizing)) next(isResizing, false);
				}
			}),
			makeSubscribe(mouseXyLocal, \mxy -> {
				if (isCurrentMInteractionItemId(manager, itemId) && getValue(isResizing)) {
					blockOtherMInteractionItemIds(manager, itemId);	

					// if (isColumn) nextDistinct(WH, WidthHeight(getValue(WH).width, max(dockingBarHeight, mxy.y)))
					// 	else nextDistinct(WH, WidthHeight(mxy.x, getValue(WH).height));

					if (isColumn) nextDistinct(sizeB, max(dockingBarHeight, mxy.y))
						else nextDistinct(sizeB, max(mxy.x, dockingBarHeight));


						// updateRowSize(areaSizeInfo, colId, rowId, if (isColumn) max(dockingBarHeight, mxy.y) else max(mxy.x, dockingBarHeight));

					// UPDATE DOCKED SIZE
					nextDistinct(state.dockedSize, replace(getValue(state.dockedSize), panelId, TFixed(getValue(WH).width, getValue(WH).height)));
					// nextDistinct(state.size, replace(getValue(state.dockedSize), panelId, TFixed(getValue(WH).width, getValue(WH).height)));
				};
			})
		],
		MInteractive([
			TMouseXY(mouseXyLocal)
			],



					MAvailable(
						// if (isColumn) {
						// 	MGroup2(
						// 		box,
						// 		MLines2(
						// 			TFillY(),
						// 			// draggingHandle(light) |> showIf(!isLastPanel)
						// 			// if (fillPanel || isToolbarItem) TEmpty() else draggingHandle(light), // ORIGINAL
						// 			// TRectangle([MFill(MBrown(500)), FillOpacity(1.0)], TFillXH(dockingDragSize))
						// 			//  if (fillPanel || isToolbarItem) draggingHandleInactive(light) else draggingHandle(light)


						// 			// if (isLastPanel || isToolbarItem) draggingHandleInactive(light) else draggingHandle(light)
						// 			// if (isLastPanel || isToolbarItem) TEmpty() else makeColResizeSeparator
						// 			if (isToolbarItem) TEmpty() else makeColResizeSeparator
						// 		)
						// 	)

						// } else {
						// 	MGroup2(
						// 		// MGroup2(
						// 		// 	TRectangle([MFill(panelBgColorFn(light, style))], TFillXY()),
						// 		// 	box
						// 		// ),
						// 		box
						// 		MColsA([
						// 			TFillX(),
						// 			if (fillPanel || isToolbarItem) TEmpty() else makeColResizeSeparator
						// 			// if (fillPanel || isToolbarItem) TEmpty() else draggingHandle(light)
						// 			//  if (fillPanel || isToolbarItem) draggingHandleInactive(light) else draggingHandle(light)
						// 		])
						// 	)
						// },
						scrollBox 
							|> addRowSeparator
							|> addDragAndDropHelper,

						if (isColumn) {
							// if (/*isLastPanel ||*/ isFirstPanel) TGroup2(TFillXY(), TSelect(sizeB, \h -> TFillXH(h))) else TSelect(sizeB, \h -> TFillXH(h));
							if (isLastPanel /*|| isFirstPanel*/) TGroup2(TFillXY(), TSelect(sizeB, \h -> TFillXH(h))) else  TSelect(fselect(sizeB,FLift(\h -> h + dockingDragSize)), \hh  -> TFillXH(hh));
						} else {
							TSelect(fselect(sizeB,FLift(\w -> w + dockingDragSize)), \ww  -> TFillWY(ww));
						}

						// if (isColumn) {
						// 	// if (se) {

						// 		// MSelect(enabled, \e ->{
						// 		// 	if (e) 
						// 			TSelect(sizeB, \h ->
						// 				TFillXH(h)
						// 				//  |> (\f -> if (isLastPanel) TGroup2(TFillXY(), f) else f)					
						// 			) 
						// 			// else TFillXH(dockingBarHeight);
						// 		// })


						// 	// } else TFillXH(dockingBarHeight);

						// } else {
						// 	if (fillHeight || fillPanel) TGroup2(TFillXY(), TSelect(sizeB, \w -> TFillWY(w + dockingBarHeight))) else TSelect(sizeB, \w -> TFillWY(w + dockingBarHeight));
						// }







						// dockedSpace
						// if (isColumn) {
						// 	if (se) TSelect(sizeB, \h  -> TFillXH(h)) else TFillXH(dockingSideCollapsedSize);
						// } else {
						// 	if (se) TSelect(sizeB, \h -> TFillWY(h + dockingBarHeight)) else TFillWY(dockingSideCollapsedSize);
						// }





					// dockedSpace = {
					// 	if (isColumn) {

					// 		if (se) {
					// 			if (e) TSelect(WH, \wh ->
					// 				TFillXH(wh.height) |> (\f -> if (isLastPanel) TGroup2(TFillXY(), f) else f)					
					// 			) else TFillXH(dockingBarHeight);
					// 		} else TFixed(sideCollapsedSize, dockingBarHeight);

					// 	} else {
					// 		if (fillHeight || fillPanel) TGroup2(TFillXY(), TSelect(WH, \wh -> TFillWY(wh.width + dockingBarHeight))) else TSelect(WH, \wh -> TFillWY(wh.width + dockingBarHeight));
					// 	}
					// }


					) 
					
		)
	)
}






makeAvailableDockedWidth(
	box : Material, 
	isColumn : bool,
	dropInfo : MDockingDropInfo,
	state : MDockingState, 
	sizeB : DynamicBehaviour<double>,

	areaGrid : [[int]],
	colA : [int], 
	colId : int,
	light : bool,
	style : [MDockingStyle]
) -> Material {

	manager = state.manager;
	itemId = makeTropicTag(manager);
	zorder = getValue(manager.manager.zorder);

	isBottomLine = contains(style, MDockingBottomtLines());
	isRightCol  = contains(style, MDockingRightCols());
	dontScroll  = contains(style, MDockingDontScroll());	

	resizeCol = true;
	resizePressed = make(false);
	isResizing = make(false);
	mouseXyLocal = make(zeroPoint);
	currXy = make(zeroPoint);
	panelWH = makeWH();
	startingValueB = make(0.0);

	panelsWidthA = map(colA, \s -> getTropicMetrics(getValue(state.size)[s]).width);
	maxPanelsWidth = either(maxA(panelsWidthA), -doubleMax);
	se = getValue(getValue(state.sideExpanded)[colA[0]]);

	numOfCols = length(areaGrid);
	lastCol = numOfCols - 1;

	// Cols separator with drop
	// makeColResizeSeparator = \idx -> makeMDockingSeparatorDrop(isColumn, resizeCol, idx, 0 /*new row*/, colA,  numOfCols, dropInfo, resizePressed, state, style);
	makeColResizeSeparator = \idx -> dockingResizeAndDropLine(isColumn, resizeCol, [idx, 0], dropInfo, resizePressed, state, style);

	// Drop enpoint
	dragHandleSize = makeColSize(dockingDragSize, isColumn);
	draggingBarInactive = \lg : bool -> TRectangle([MFill(MIndigoA(500))], dragHandleSize);
	// draggingBarInactive = \lg : bool -> TRectangle([MFill(separatorColorFn(lg, style))], dragHandleSize);
	// dLine = dockingDropLine(isColumn, colId,  dropInfo, state, [if (isRightCol) lastCol + 1 else 0, 0], draggingBarInactive(light), true, style);
	dLine = dockingDropLine(isColumn, colId,  dropInfo, state, [if (isRightCol) lastCol + 1 else 0, 0], MEmpty(), true, style);



	colFiller = if (isColumn) TFillX() else TFillY();

	colWithHandles = {
		if (colId == 0 && numOfCols == 1)
		[
			if (isRightCol || isBottomLine) makeColResizeSeparator(colId) else dLine,
			colFiller,
			if (isRightCol || isBottomLine) dLine else makeColResizeSeparator(colId + 1),
			// if (!isRightCol && !isBottomLine) dLine else makeColResizeSeparator,
			// makeColResizeSeparator

		]
		else if (colId == 0 && numOfCols != 1)
		[
			if (isRightCol || isBottomLine) makeColResizeSeparator(colId) else dLine,
			colFiller,
			if (isRightCol || isBottomLine) TEmpty() else makeColResizeSeparator(colId + 1),
		]
		else if (colId != 0 && colId == numOfCols - 1)
		[
			if (!isRightCol && !isBottomLine) TEmpty() else makeColResizeSeparator(colId),
			colFiller,
			if (isRightCol || isBottomLine) dLine else makeColResizeSeparator(colId + 1),
		]
		else
		[
			if (!isRightCol && !isBottomLine) TEmpty() else makeColResizeSeparator(colId),
			colFiller,
			if (isRightCol || isBottomLine) TEmpty() else makeColResizeSeparator(colId + 1),
		]

// [ 									
// 			makeMDockingSeparatorDrop(isColumn, resizeCol, colId, colA,  numOfCols, dropInfo, resizePressed, state, style),
// 			colFiller,
// 			makeMDockingSeparatorDrop(isColumn, resizeCol, colId + 1, colA,  numOfCols, dropInfo, resizePressed, state, style),
// 		]

	} |> (\f -> if (isColumn) MCols(f) else MLines(f))

	scrollBox = if (dontScroll) MCropSize(TFillXY(), box) else MScroll(box, TFillXY(), []);

	// resizableScrollBox = scrollBox |> (\f ->MGroup2(f, colWithHandles));
	// resizableScrollBox = scrollBox;




	addColSeparator = \ f : Material -> MColsA(
		[
			if (!isRightCol) TEmpty() else draggingBarInactive(light),  //sx
			f,
			if (isRightCol) TEmpty() else draggingBarInactive(light) //dx
		]
	);

	addDragAndDropHelper = \ f : Material ->  MGroup2(f, colWithHandles);

	MConstruct([
					// makeSubscribe(sizeB, \e -> {
					// 	println("sizeB");
					// 	println(e);

					// }),
				makeSubscribe2(isResizing, \rs -> { 
					if (!rs) {
						println("update Ws -" + i2s(colId) + "- "+ toString(getValue(sizeB)));
						// Update docked panels in col for storage
						iter(colA, \pId -> updateTW(state.dockedSize, pId,  getValue(sizeB)));
					}
				}),

		makeSubscribe(resizePressed, \p -> {
			if (p) {
				addMInteractionItemId(manager, itemId);
				next(currXy, getValue(state.mouseXy));
				next(startingValueB, getValue(sizeB));

				next(panelWH, WidthHeight(getValue(sizeB), getValue(sizeB)));
				next(isResizing, true);
			} else {
				if (getValue(isResizing)) next(isResizing, false);
			}
		}),
		makeSubscribe(state.mouseXy, \mxy -> {
			if (isCurrentMInteractionItemId(manager, itemId) && getValue(isResizing)) {
				rtlCorrection =1.0; // if (getDefaultRtl()) -1.0 else 1.0; // correction the direction of width changing depending of rtl mode
				blockOtherMInteractionItemIds(manager, itemId);
				if (isColumn) {

					// newW = if (isRightCol) max(dockingSideCollapsedSize, getValue(panelWH).width + rtlCorrection*(getValue(currXy).x - mxy.x))
					// else max(dockingSideCollapsedSize, getValue(panelWH).width - rtlCorrection*(getValue(currXy).x - mxy.x));

				if (isRightCol) nextDistinct(sizeB, max(dockingSideCollapsedSize, getValue(startingValueB) + rtlCorrection*(getValue(currXy).x - mxy.x)))
					else nextDistinct(sizeB, max(dockingSideCollapsedSize, getValue(startingValueB) - rtlCorrection*(getValue(currXy).x - mxy.x)));

if (isRightCol)

println(
	toString(getValue(startingValueB)) +    " - "  +   
	toString(rtlCorrection*(getValue(currXy).x - mxy.x)) + " : " + 
	toString(getValue(startingValueB) + rtlCorrection*(getValue(currXy).x - mxy.x)) 
)
else 
println(
	toString(getValue(startingValueB)) +    " - "  +   
	toString(rtlCorrection*(getValue(currXy).x - mxy.x)) + " : " + 
	toString(getValue(startingValueB) - rtlCorrection*(getValue(currXy).x - mxy.x)) 
);
						
											


					} else {
					if (isBottomLine) nextDistinct(sizeB, max(maxPanelsWidth, getValue(panelWH).height + (getValue(currXy).y - mxy.y)))
						else nextDistinct(sizeB, max(maxPanelsWidth, getValue(panelWH).height - (getValue(currXy).y - mxy.y)));
					}
			};
		}),
		// \ -> \-> println("dispose" + i2s(areaId)),
	],
	MInteractive([
			TMouseXY(mouseXyLocal)
		],
		MAvailable(
			scrollBox
				|> addColSeparator
				|> addDragAndDropHelper,

			if (isColumn) {
				// if (se) TSelect(sizeB, \w  -> TFillWY(w)) else TFillWY(dockingSideCollapsedSize);
				// TSelect(sizeB, \w  -> TFillWY(w));
				TSelect(fselect(sizeB,FLift(\w -> w + dockingDragSize)), \ww  -> TFillWY(ww));
			} else {
				TSelect(fselect(sizeB,FLift(\h -> h + dockingDragSize)), \hh  -> TFillXH(hh));
				// if (se) TSelect(HA[colId], \h  -> TFillXH(h)) else TFillXH(dockingSideCollapsedSize);
			}
		) 
	));
}
