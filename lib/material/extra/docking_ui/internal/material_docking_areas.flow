import material/material_ui;
import material/extra/docking_ui/internal/material_docking_utils;
import material/extra/docking_ui/internal/material_docking_panels;
// import material/extra/docking_ui/internal/material_docking_drop;


export {
	// NOTE:
	// - MDockingAreas can act as a "dockable MCols" or "MLines" (by "isColumn")
	// - each MDockingArea has unique id
	// - different MDockingAreas can have the same groupName
	// - the groupNames are used by MDockingPanel in the "allowedGroups" field
	// - each panel can have a vertical or horizontal orientation, but its size is defined by default as vertical
	// - when docked on cols a panel will be shown as vertical, when on lines as horizontal
	// - when mobile a panel will be vertical, but you can flip it with MDockingMobileHorizontal() style
	// - example in flow9/lib/material/tests/test_docking_ui.flow

	MDockingArea(isColumn : bool, state : MDockingState, groupName : string, areaId : int, style : [MDockingStyle]) -> Material;
}

// Let's think about dockable/resizable MCols with inside MLines of panels, 
// the logic can be swithched and we get MLines with inside MCols 
MDockingArea(isColumn : bool, state : MDockingState, groupName : string, areaId : int, style : [MDockingStyle]) -> Material {

	MShowLazy(fselect(state.size, FLift(\sz -> sz != [])), 
		\ -> {

			manager = state.manager;
			itemId = makeTropicTag(manager);              //
			zorder = getValue(manager.manager.zorder);
			contentA = getValue(state.content);
			sizeA = getValue(state.size);

			// Drop
			onDragging = manager.manager.dragging;
			onDrop = make(-1);
			order = make([0, 0]);
			dockedPanelsGrid = make([[]]);
			isDockingCol = make(true);
			isRow = make(false);
			lastDropSize = make(TEmpty());

			// Drop Info
			dropInfo = 
				MDockingDropInfo(
					areaId,
					groupName,
					onDrop, 
					order, 
					dockedPanelsGrid, 
					isDockingCol, 
					isRow, 
					lastDropSize
				);

			// Inactive drop bar
			dropSize = extractStruct(style, MDockingDropSize(dockingDropSize)).size;
			colSize = if (isColumn) TFillWY(dropSize) else TFillXH(dropSize);
			inactiveDropLine = TRectangle([MFill(MGrey(300))], colSize);

			enableCache = extractStruct(style, MDockingEnableLoadFromBrowserCache(make(false))).enable;


			// areaSizeInfo = {
			// 	aGrid = extractAreaGridById(getValue(state.dock), areaId);
			// 		MDockingAreaSizeInfo(
			// 			[],
			// 			make(map(aGrid, \__ -> 220.0)),
			// 			make(map(aGrid, \c -> map(c, \__ -> 0.0)))
			// 		);
			// }



			areaGridT = fselect(state.dock, FLift(\dockA -> extractAreaGridById(dockA, areaId)));

			WA = map(contentA,\c -> make(0.0));
			HA = map(contentA,\c -> make(0.0));

			

			MSelect(areaGridT, \areaGrid : [[int]] -> {


				// println(" > DRAW - DockingArea - " + i2s(areaId)+ "    - " + toString(areaGrid));
				// println(" > DRAW - DockingArea - REDRAW or DOCKA:  " +  b2s(r) + "    - " + toString(areaGrid));
				// println("areaGrid");
				// println(extractAreaGridById(getValue(state.dock), areaId));
				// Get Panel
				// areaGrid = extractAreaGridById(d, areaId);

				next(dockedPanelsGrid, areaGrid);

				mapi(areaGrid, \colId, colA -> {

					atLeastOneEnabledInCol = fold(colA, false, \acc, a -> acc || getValue(getValue(state.enabled)[a]));
					atLeastOneEnabled = fold(areaGrid, false, \acc, singleColA -> acc || fold(singleColA, false, \acc2, a -> acc2 || getValue(getValue(state.enabled)[a])));
					enabledColT = fmerge(map(colA, \c -> getValue(state.enabled)[c]));
					sideExpandedColT = fmerge(map(colA, \c -> getValue(state.sideExpanded)[c]));

					// Col size

		
		
					// Enable a single col					
					MSelect3(
						manager.white, 
						enabledColT,
						sideExpandedColT, 
						\w, e, __ -> {

							containsDark = fold(colA, false, \acc, a -> acc || contains(getValue(state.style)[a], MDockingForceDarkTheme()));
							containsLight = fold(colA, false, \acc, a -> acc || contains(getValue(state.style)[a], MDockingForceLightTheme()));
							colTheme = if (containsDark) false else if (containsLight) true else w;

							// println(" > DRAW - docked lines of panels - " + i2s(areaId) + "      - " + toString(colA));

							
							if (atLeastOneEnabledInCol) {
								// Single resizable column of docked panels with dragging handles and drop areas
								makeDockedPanelA(
									isColumn,
									dropInfo,
									state,
									WA,
									HA,
									areaGrid,
									colA,
									colId,
									colTheme,
									style
								);

							} else if (atLeastOneEnabled) {
								TEmpty();
							} else {
								// NO PANELS ENABLED
								dockingDropLine(isColumn, isColumn, dropInfo, state, [0, 0], false, inactiveDropLine, colSize, colSize, true, style);
							}
						}
					);


				}) |> (\f -> if (isColumn) MColsA(f) else MLines(f))

				// NO PANELS DOCKED
				|> (\f -> if (areaGrid != []) f 
					else dockingDropLine(isColumn, isColumn, dropInfo, state, [0, 0], false, inactiveDropLine, colSize, colSize, true, style));
				
			});

		} 
	);
}


makeDockedPanelA(
	isColumn : bool,
	dropInfo : MDockingDropInfo,
	state : MDockingState,

	WA : [DynamicBehaviour<double>], 
	HA : [DynamicBehaviour<double>], 

	areaGrid : [[int]],
	colA : [int], 
	colId : int,

	light : bool, 
	style : [MDockingStyle]
) -> Material {

	// println("  ------------- > makeResizableColFn " + i2s(areaId));

	manager = state.manager;
	onDragging = manager.manager.dragging;
	zorder = getValue(manager.manager.zorder);
	groupA = state.group;
	contentA = getValue(state.content);

	// Drop info
	areaId = dropInfo.areaId;
	groupName = dropInfo.groupName; 

	dockedSizeA = getValue(state.dockedSize);
	dropSize = extractStruct(style, MDockingDropSize(dockingDropSize)).size;
	dragSize = dockingDragSize;
	handleHeight = dropSize;
	rowSize = if (isColumn) TFillXH(dropSize) else TFillWY(dropSize);
	colSize = if (isColumn) TFillWY(dropSize) else TFillXH(dropSize);
	inactiveDropLine = TRectangle([MFill(MGrey(300))], rowSize);

	fillHeightArea = contains(style, MDockingFillSpace());
	fillLast = contains(style, MDockingColFillLast());
			
	dontResize  = contains(style, MDockingDontResize());
	dontSideExpand = contains(style, MDockingDontCollapseColumn());

	sideExpandedA = map(contentA,\c -> make(false));

	lastPanel = length(colA) - 1;
	lastCol = length(areaGrid) - 1;

	// mouseXyLocalR = make(zeroPoint);
	maxPanelSize = TSizeOf(TGroup(map(colA, \s -> if (dockedSizeA != []) dockedSizeA[s] else TEmpty())));
	dontResizeAll = fold(colA, true, \acc, p -> acc && contains(getValue(state.style)[p], MDockingDontResize()));
	dontSideExpandPanel = fold(colA, false, \acc, p -> acc || contains(getValue(state.style)[p], MDockingDontCollapsePanel()));

	panelsWidthA = map(colA, \s -> getTropicMetrics(getValue(state.size)[s]).width);
	dockedWidthA = map(colA, \s ->{
		// println("READING DOCKED SIZEs " + i2s(areaId) + "    - " + i2s(colId));
		// println("- - - - - - - - - - - - - - - - - - - - - - - - - - - -");

		// println(s);
		// println(getTropicMetrics(getValue(state.dockedSize)[s]).width);
		// println("-");
		
		
		
		 getTropicMetrics(getValue(state.dockedSize)[s]).width});
	// mobileWidthA = map(colA, \s -> getTropicMetrics(getValue(state.mobileSize)[s]).width);

	maxPanelsWidth = either(maxA(panelsWidthA), -doubleMax);
	maxDockedWidth = either(maxA(dockedWidthA), -doubleMax);
	// maxMobileWidth = either(maxA(mobileWidthA), -doubleMax);
	// se = getValue(getValue(state.sideExpanded)[colA[0]]);

	// println("**************");
	// println("area: " + i2s(areaId) + " - col: " + i2s(colId));
	// println(maxDockedWidth);
	// println("**************");
	// Area size info
					
	colWB = make(maxDockedWidth);

	if (getValue(WA[colId]) == 0.0) next(WA[colId], maxPanelsWidth);
	if (getValue(HA[colId]) == 0.0) next(HA[colId], maxPanelsWidth);

	colHeightB = make(0.0);

	MFrame(0.0, 0.0, [MFill(areaBgColorFn(light, style))], 
		MGroup2(							
			TFillY() |> (\f -> MAttachHeight(f, colHeightB)),  // Get column height
			MLines2(	
				if ((isColumn && !dontSideExpand && !dontSideExpandPanel))  makeSideExpanderBtn(state, colA, light, style) else TEmpty(),  // Side expander button
							// MText(i2s(colId), [MBlue(500)]),
				// Docked panels			
				mapi(colA, \rowId, panelId -> {
					
					// Panel position
					isFirstPanel = panelId == firstElement(colA, intMax);
					isLastPanel = panelId == lastElement(colA, intMax);
					lastPanelId = length(colA) - 1;

					// Fill panel order
					fillBottom = rowId == lastPanel; 	// fill last panel --default
					fillTop = rowId == 0; 			// fill first panel
					fillPanelOrder = if (fillLast) fillBottom else fillTop;
					fillPanelOrderId = if (fillLast) lastPanel else 0;



					// println(areaId);
					// println(rowId);
					// println(" - - - - - - - -");
					// println("fillBottom");
					// println(fillBottom);
					// println("fillTop");
					// println(fillTop);
					// println("fillPanelOrder");
					// println(fillPanelOrder);
					// println("fillPanelOrderId");
					// println(fillPanelOrderId);
					// println("fillLast");
					// println(fillLast);
					// println("");

					panelStyle = getValue(state.style)[panelId];
					fillHeight = fillHeightArea || contains(panelStyle, MDockingFillSpace());  // NOTE: should be handled

					// Expanded
					expanded = getValue(state.expanded)[panelId];
					sideExpanded = getValue(state.sideExpanded)[panelId];
					enabled = getValue(state.enabled)[panelId];


										// Panel size
					dockedSize = getValue(state.dockedSize)[panelId];
					pSize = getValue(state.size)[panelId];

					pWidth = getTropicMetrics(dockedSize).width;
					pHeight = if (isLastPanel) getTropicMetrics(pSize).height else getTropicMetrics(dockedSize).height;

					// rowHB = make(pHeight + dockingBarHeight);
					rowHB = make(pHeight);


					println("READING DOCKED H:    area: " + i2s(areaId) + " col: " + i2s(colId) + "    panel: " + i2s(panelId) + " HEIGHT: " + d2s(getValue(rowHB)));
					println("-");

					pHB = make(0.0);

						// Container size
						WH = if (isColumn) make(WidthHeight(pWidth, pHeight)) else make(WidthHeight(pHeight, pWidth));


					otherPanelsH = foldi(colA, 0.0, \k, acc, pId -> {
						if (k < (length(colA) )) {
							if (k != fillPanelOrderId) {
								if (isColumn) {
									acc + getTropicMetrics(getValue(state.dockedSize)[pId]).height// + dockingDragSize + dockingBarHeight
								} else {
									acc + getTropicMetrics(getValue(state.dockedSize)[pId]).width// + dockingDragSize
								}
							} else acc
						} else acc;
					});

				MConstruct([
					// makeSubscribe(rowHB, \rh -> {
					// 	println(i2s(panelId) + "- rowHB: " +  toString(rh));

					// }),
					makeSubscribe2(sideExpanded, \se -> {
						if (se) {
							nextDistinct(rowHB, pHeight);
							nextDistinct(colWB, pWidth);
						} else {
							nextDistinct(rowHB, dockingBarHeight);
							nextDistinct(colWB, dockingSideCollapsedSize);
						}
					}),
					makeSubscribe2(expanded, \e -> {


						rH = if (fillPanelOrder) {
							getValue(colHeightB) - sideExpanderButtonSize - foldi(colA, 0.0, \k, acc, pId -> {
								if (k < (length(colA) )) {if (k != fillPanelOrderId) acc + getTropicMetrics(getValue(state.size)[pId]).height else acc} else acc;
							}) 
						} else pHeight;


						// println(" panel" + i2s(panelId) + " - h: " + d2s(rH) );
						if (e) nextDistinct(rowHB, rH) else nextDistinct(rowHB, dockingBarHeight);
					}),
					makeSubscribe(enabled, \e -> {
						if (!e) next(state.dock, mapi(getValue(state.dock), \j, item -> if (j == panelId) [-1, item[1], item[2]] else item)); //undock
					}),


								// Fill correction
								makeSubscribe(
									// Update only the first time
									ftransistor(
										fselect(colHeightB, FLift(\ch -> {
											// getTropicMetrics(getValue(state.size)[panelId]).height == getValue(rowHB)



								if (panelId == fillPanelOrderId) {
											// println(" A|--------------------------------------------->");
											// println(i2s(areaId) + " - "+ i2s(areaId)+ " - "+ i2s(areaId)+ " - "+ i2s(areaId)+ " - "+ i2s(areaId)+ " - "+ i2s(areaId));
											// println(fillPanelOrderId);
											// println(panelId);
											// println(getTropicMetrics(getValue(state.size)[panelId]).height);
											// println(getTropicMetrics(getValue(state.mobileSize)[panelId]).height);
											// println(getTropicMetrics(getValue(state.dockedSize)[panelId]).height);
											// println(getValue(rowHB));
											// println(getTropicMetrics(getValue(state.dockedSize)[panelId]).height == getValue(rowHB));
											// println(" A|--------------------------------------------->");
} 
											getTropicMetrics(getValue(state.dockedSize)[panelId]).height == getValue(rowHB)
											// getTropicMetrics(getValue(state.dockedSize)[panelId]).height == getValue(WH).height
								
										})),
										colHeightB
									), \totColH -> {

									// colHeightB, \colH -> {
											// if (isFirstPanel) {

									if (fillPanelOrder) {
									// if (isFirstPanel) {
										availableColHeight = totColH - sideExpanderButtonSize /*- dockingDragSize*/ - dockingBarHeight - otherPanelsH;
										// Fill height
										// next(WH, WidthHeight(getValue(WH).width, availableColHeight));

if (totColH > otherPanelsH) {
											// println(" - FILL CORRECTION - FILL CORRECTION - FILL CORRECTION - FILL CORRECTION - FILL CORRECTION - FILL CORRECTION- FILL CORRECTION - " + i2s(areaId));

											 next(rowHB, availableColHeight);
} else {
											// println(" - not FILL CORRECTION - not FILL CORRECTION - " + i2s(areaId));

}




											// println(" B|--------------------------------------------->");
											// println(i2s(areaId) + " - "+ i2s(areaId)+ " - "+ i2s(areaId)+ " - "+ i2s(areaId)+ " - "+ i2s(areaId)+ " - "+ i2s(areaId));

											// println(fillPanelOrderId);
											// println(panelId);
											// println(getTropicMetrics(getValue(state.size)[panelId]).height);
											// println(getTropicMetrics(getValue(state.mobileSize)[panelId]).height);
											// println(getTropicMetrics(getValue(state.dockedSize)[panelId]).height);
											// println(getValue(rowHB));
											// println(getTropicMetrics(getValue(state.dockedSize)[panelId]).height == getValue(rowHB));
											// println(" B|--------------------------------------------->");


									}// A single docked panel	
								}),






									// makeSubscribe(colHeightB, \colH -> {
									// 	if (isLastPanel) {
									// 			availableColHeight = colH - sideExpanderButtonSize - foldi(colA, 0.0, \k, acc, pId -> {
									// 				if (k < (length(colA) )) {
									// 					if (k != lastPanelId) acc + getTropicMetrics(getValue(state.dockedSize)[pId]).height else acc
									// 				} else acc;
									// 			});

									// 		println(" --------------------------------------------->");
									// 		println(lastPanelId);
									// 		println(colH);
									// 		println(availableColHeight);
									// 		// println(getTropicMetrics(getValue(state.dockedSize)[panelId]).height == getValue(rowHB));
									// 		println(" --------------------------------------------->");

									// 		next(rowHB, availableColHeight);
									// 	}

									// })


				],

					makeDockedPanel(
						state, 
						panelId, 
						Pair(colId, rowId), 
						colA, 
						colHeightB, 
						dropInfo, 
						isColumn, 
						fillPanelOrder, 
						style, 
						dropSize, 
						sideExpandedA[colId], 
						zorder
					) 
					// |> (\f -> MBorder4(dockingDragSize, f))


					
				) 
				
				
				|> (\f ->
						// Wrapper with drop area and resize handle for a row
						// makeAvailableDockedHeight(f, isColumn, dropInfo, state, rowHB, panelId, colA, colId, rowId, light, style)

						resizePanelH(f, isColumn, dropInfo, state, rowHB, panelId, colA, colId, rowId, light, style)
						
						// f
					) |> showIf(dockedSizeA != [])

				}) |> (\f -> if (isColumn) MLines(f) else MColsA(f))		
			)
		) 
	) 
	
	|> (\f ->
		// Wrapper with drop area and resize handle for a col
		// makeAvailableDockedWidth(f, isColumn, dropInfo, state, colWB, areaGrid, colA, colId, light, style)
		resizeAreaW(f, isColumn, dropInfo, state, colWB, areaGrid, colA, colId, light, style)
		// f
	)

}


	resizePanelH(
		box : Material, 
		isColumn : bool,
		dropInfo : MDockingDropInfo,
		state : MDockingState,
		sizeB : DynamicBehaviour<double>, 

		panelId : int, 
		parentA : [int], 
		colId : int,
		rowId : int,
		
		light : bool,
		style : [MDockingStyle], 

	) -> Material {
		manager = state.manager;
		itemId = makeTropicTag(manager);
		zorder = getValue(manager.manager.zorder);
		pstyle = getValue(state.style)[panelId];
		groupA = state.group;

		// Size	
		sideCollapsedSize = dockingSideCollapsedSize;
		panelDockedSize = getValue(state.dockedSize)[panelId];
		pWidth = getTropicMetrics(panelDockedSize).width;
		pHeight = getTropicMetrics(panelDockedSize).height;

		// Container size
		WH = if (isColumn) make(WidthHeight(pWidth, pHeight)) else make(WidthHeight(pHeight, pWidth));

		// Order
		isFirstPanel = panelId == firstElement(parentA, intMax);
		isLastPanel = panelId == lastElement(parentA, intMax);
		lastPanelId = length(parentA) - 1;

		fillLast = contains(style, MDockingColFillLast());
		fillPanelOrderId = if (fillLast) lastPanelId else 0;

		resizePressed = make(false);
		isResizing = make(false);
		isHovering = make(false);
		mouseXyLocal = make(zeroPoint);
		
		// Expanded
		expanded = getValue(state.expanded)[panelId];
		sideExpanded = getValue(state.sideExpanded)[panelId];
		enabled = getValue(state.enabled)[panelId];

		se = getValue(getValue(state.sideExpanded)[parentA[0]]);


		collapsedSepColor = MGrey(400);

		isToolbarItem = isSameStructType(getValue(state.content)[panelId][0], MDockingPanelToolbarItem("", []));
		fillHeightArea = contains(style, MDockingFillSpace());
		fillHeight = fillHeightArea || contains(pstyle, MDockingFillSpace());
		isBottomLine = contains(style, MDockingBottomtLines());
		dontScroll  = contains(style, MDockingDontScroll());	
		dontResizeAll = fold(parentA, true, \acc, p -> acc && contains(getValue(state.style)[p], MDockingDontResize()));
		dontResize = isLastPanel;

		println(" > DRAW - Container R - " + i2s(panelId) /*+ "      - " + toString(parentA)*/);

		// Rows separator with drop
		dragSize = dockingDragSize;
		dragSizeBig = dockingHelperDragSize;
		dragHandleSizeBig = makeHSize(dragSizeBig, isColumn);
		dragHandleSize = makeHSize(dockingDragSize, isColumn);

		rowFiller = if (isColumn) TFillY() else TFillX();

		makeSeparator = \resizeW : bool, order : [int], resize : bool, endpoint : bool -> {
			resizeHelper = if (resize) dockingResizeLine(isColumn, resizeW, dontResize, resizePressed, dragHandleSizeBig, style) else MEmpty();
			dockingDropLine(isColumn, resizeW, dropInfo, state, order, true, resizeHelper, dragHandleSize, dragHandleSizeBig, endpoint, style)
			
		}
		//  |> (\f -> MOffset(
		// 		 	if (isColumn) 0.0 else dragSizeBig / 2.0,
		// 			if (!isColumn) 0.0 else dragSizeBig / 2.0,
		// 			// 0.0,
		// 			// dragSizeBig,
		// 		 f));

				//  |> (\f -> MOffset(
				//  	if (endpoint) 0.0 else { if (isColumn) 0.0 else dragSizeBig / 2.0 },
				// 	if (endpoint) 0.0 else { if (!isColumn) 0.0 else dragSizeBig / 2.0},
				// 	// 0.0,
				// 	// dragSizeBig,
				//  f));

		rowsWithHandles = 
			 if (isColumn) {
				 // Resize H
				 MLines( 
					if (rowId == 0 && length(parentA) == 1)
					[
						makeSeparator(false, [colId, rowId], false, true /*endpoint*/), 		// top
						rowFiller,
						makeSeparator(false, [colId, rowId + 1 ], false, false), 				// bottom
					]
					else if (rowId == 0 && length(parentA) != 1)
					[
						makeSeparator(false, [colId, rowId], false, true /*endpoint*/),
						rowFiller,
						makeSeparator(false, [colId, rowId + 1], true /*resize*/, false),
					]
					else if (rowId ==  length(parentA) - 1 && length(parentA) != 1)
					[
						rowFiller,
						makeSeparator(false, [colId, rowId + 1 ], false, false),
					]
					else
					[	
						rowFiller,
						makeSeparator(false, [colId, rowId + 1], true /*resize*/, false),
					]
				)
			 } else {
				// Resize W
				 MCols(
					//  if (rowId == 0 && length(parentA) == 1)
					// [
					// 	if (isBottomLine) dLine(rowId + 1, false) else dLine(rowId, true),   //top
					// 	rowFiller,
					// 	if (isBottomLine) dLine(rowId, true) else dLine(rowId + 1, false) ,  //bottom
					// ]
					// else if (rowId == 0 && length(parentA) != 1)
					// [
					// 	if (isBottomLine) dLine(rowId + 1, true) else dLine(rowId, true),
					// 	rowFiller,
					// 	if (isBottomLine) TEmpty() else makeHResizeSeparator(rowId + 1),
					// ]
					// else if (rowId ==  length(parentA) - 1 && length(parentA) != 1)
					// [
					// 	if (!isBottomLine) TEmpty() else makeHResizeSeparator(rowId),
					// 	rowFiller,
					// 	if (!isBottomLine) dLine(rowId + 1, false) else dLine(rowId, true),
					// ]
					// else
					[
						makeSeparator(true, [colId, rowId], false, true /*endpoint*/), 
						rowFiller,
						// makeHResizeSeparator([colId, rowId + 1]),
						makeSeparator(true, [colId, rowId + 1], true /*resize*/, false),
					]
				 )
			 }




		scrollBox = if (dontScroll) MCropSize(TFillXY(), box) else MScroll(box, TFillXY(), []);
		// resizableScrollBox = MGroup2(scrollBox, rowsWithHandles);


		addRowSeparators = \f : Material ->
			[
				f,
				if (isLastPanel) TEmpty() else makeSeparatorBar(!isColumn, dontResize, se, light, style)    // bottom/dx
			] |> (\r -> if (isColumn) MLines(r) else MCols(r));



		// addRowSeparators = \ f : Material ->
		// if (isColumn) {
		// 	MLines([
		// 		// TEmpty(),
		// 		f,
		// 		// if (isBottomLine) TEmpty() else 
		// 		if (isLastPanel) TEmpty() else makeSeparatorBar(!isColumn, dontResize, se, light, style)    // bottom/dx
		// 	])
		// } else {
 		// 	MCols([
		// 		// if (!isBottomLine) TEmpty() else makeSeparatorBar(!isColumn, dontResize, se, !light, style),  // top/sx
		// 		f,
		// 		// if (isBottomLine) TEmpty() else
		// 		if (isLastPanel) TEmpty() else makeSeparatorBar(!isColumn, dontResize, se, light, style)    // bottom/dx
		// 	])
		// }	


		

		addDragAndDropHelperGroup = \ f : Material ->  MGroup2(f, rowsWithHandles);

		
		println("isColumn" + b2s(isColumn));


		MConstruct([
					// makeSubscribe(sizeB, \e -> {
					// 	println("sizeB - h");
					// 	println(e);

					// }),
				makeSubscribe2(isResizing, \rs -> { 
					if (!rs) {
						// println("update H -" + i2s(panelId) + "- "+ toString(getValue(sizeB)));
						if (isColumn) updateTH(state.dockedSize, panelId,  getValue(sizeB))
							else updateTW(state.dockedSize, panelId,  getValue(sizeB));
					}
				}),
			makeSubscribe(resizePressed, \p -> {
				if (p) {
					addMInteractionItemId(manager, itemId);
					next(isResizing, true);
				} else {
					if (getValue(isResizing)) next(isResizing, false);
				}
			}),
			makeSubscribe(mouseXyLocal, \mxy -> {
				if (isCurrentMInteractionItemId(manager, itemId) && getValue(isResizing)) {
					blockOtherMInteractionItemIds(manager, itemId);	

					// if (isColumn) nextDistinct(WH, WidthHeight(getValue(WH).width, max(dockingBarHeight, mxy.y)))
					// 	else nextDistinct(WH, WidthHeight(mxy.x, getValue(WH).height));
					if (isColumn) nextDistinct(sizeB, max(dockingBarHeight, mxy.y))
						else nextDistinct(sizeB, max(mxy.x, dockingBarHeight));

					// UPDATE DOCKED SIZE
					nextDistinct(state.dockedSize, replace(getValue(state.dockedSize), panelId, TFixed(getValue(WH).width, getValue(WH).height)));



					
					// nextDistinct(state.dockedSize, replace(getValue(state.dockedSize), panelId, TFixed(getValue(WH).width, getValue(sizeB))));
					// nextDistinct(state.size, replace(getValue(state.dockedSize), panelId, TFixed(getValue(WH).width, getValue(WH).height)));
				};
			})
		],
		MInteractive([
			TMouseXY(mouseXyLocal)
			],
			MAvailable(	
				scrollBox,
				// scrollBox
					// |> addRowSeparators 
					// |> addDragAndDropHelperGroup,


				if (isColumn) {
					// if (panelId == fillPanelOrderId || isLastPanel) TGroup2(TFillXY(), TSelect(fselect(sizeB,FLift(\h -> h + dockingDragSize)), \hh  -> TFillXH(hh))) 

					// if (isLastPanel /*|| isFirstPanel*/) TGroup2(TFillXY(), TSelect(fselect(sizeB,FLift(\h -> h + dockingDragSize + dockingBarHeight)), \hh  -> TFillXH(hh))) 
					// 	else  TSelect(fselect(sizeB,FLift(\h -> h + dockingDragSize + dockingBarHeight)), \hh  -> TFillXH(hh))

						if (isLastPanel /*|| isFirstPanel*/) TGroup2(TFillXY(), TSelect(fselect(sizeB,FLift(\h -> h /*+ dockingDragSize + dockingBarHeight*/)), \hh  -> TFillXH(hh))) 
						else  TSelect(fselect(sizeB,FLift(\h -> h /*+ dockingDragSize + dockingBarHeight*/)), \hh  -> TFillXH(hh))


				} else {
					if (isLastPanel /*|| isFirstPanel*/) TGroup2(TFillXY(), TSelect(fselect(sizeB, FLift(\w -> w + dockingDragSize + dockingBarHeight)), \ww  -> TFillWY(ww)))
						else TSelect(fselect(sizeB,FLift(\w -> w /*+ dockingDragSize + dockingBarHeight*/)), \ww  -> TFillWY(ww))

				}
			)	
			|> addRowSeparators 
			|> (\t -> 
				MCopySize(t, \sz -> 
					MAvailable(
						TRectangle([MFill(MWhite()), FillOpacity(dockingHelperDragOpacity)], TFillXY()) |> addDragAndDropHelperGroup,
						sz
					), 
				true
				)
			)
		)
	)
}








resizeAreaW(
	box : Material, 
	isColumn : bool,
	dropInfo : MDockingDropInfo,
	state : MDockingState, 
	sizeB : DynamicBehaviour<double>,

	areaGrid : [[int]],
	colA : [int], 
	colId : int,
	light : bool,
	style : [MDockingStyle]
) -> Material {

	manager = state.manager;
	itemId = makeTropicTag(manager);
	zorder = getValue(manager.manager.zorder);

	isBottomLine = contains(style, MDockingBottomtLines());
	isRightCol  = contains(style, MDockingRightCols());
	dontScroll  = contains(style, MDockingDontScroll());
	dontResizeAll = fold(colA, true, \acc, p -> acc && contains(getValue(state.style)[p], MDockingDontResize()));
	dontResizeCol  = contains(style, MDockingDontResize());
	dontResize = dontResizeCol || dontResizeAll;

	resizePressed = make(false);
	isResizing = make(false);
	mouseXyLocal = make(zeroPoint);
	currXy = make(zeroPoint);
	panelWH = makeWH();
	startingValueB = make(0.0);

	panelsWidthA = map(colA, \s -> getTropicMetrics(getValue(state.size)[s]).width);
	maxPanelsWidth = either(maxA(panelsWidthA), -doubleMax);
	se = getValue(getValue(state.sideExpanded)[colA[0]]);

	numOfCols = length(areaGrid);
	lastCol = numOfCols - 1;

	isReverseSide = isRightCol || isBottomLine;

	isEdgeTop = colId == numOfCols - 1;
	isEdgeBottom = colId == 0 && isBottomLine;

	// Cols separator with drop
	dragSizeBig = dockingHelperDragSize;
	dragHandleSizeBig = makeVSize(dragSizeBig, isColumn);
	dragHandleSize = makeVSize(dockingDragSize, isColumn);

	colFiller = if (isColumn) TFillX() else TFillY();
	corrSide = if (isReverseSide) -1.0 else 1.0;

	makeSeparator = \resizeW : bool, order : [int], resize : bool, endpoint : bool -> {
		resizeHelper = if (resize) dockingResizeLine(isColumn, resizeW, dontResize, resizePressed, dragHandleSizeBig, style) else MEmpty();
		dockingDropLine(isColumn, resizeW, dropInfo, state, order, false, resizeHelper, dragHandleSize, dragHandleSizeBig, endpoint, style);
	} 
	// |> (\f -> MOffset(
	// 			 	if (endpoint) 0.0 else { if (isColumn) corrSide * dragSizeBig / 1.0 else 0.0},
	// 				if (endpoint) 0.0 else { if (!isColumn) corrSide *dragSizeBig / 1.0 else 0.0},
	// 				// 0.0,
	// 				// dragSizeBig,
	// 			 f));


	colWithHandles =
	if (isColumn) {
		// Resize W
		MCols(
			if (colId == 0 && numOfCols == 1)
			[
				makeSeparator(true, [colId, 0], isRightCol, !isRightCol), // sx
				colFiller,
				makeSeparator(true, [colId + 1, 0], !isRightCol, isRightCol), // dx

			]
			else if (colId == 0 && numOfCols != 1)
			[
				makeSeparator(true, [colId, 0], isRightCol, !isRightCol),
				colFiller,
				if (isRightCol) TEmpty() else makeSeparator(true, [colId + 1, 0], true, false)
			]
			else if (colId != 0 && colId == numOfCols - 1)
			[
				if (isRightCol) makeSeparator(true, [colId, 0], true, false) else  TEmpty(),
				colFiller,
				makeSeparator(true, [colId + 1, 0], !isRightCol, isRightCol),
			]
			else
			[
				if (isRightCol) makeSeparator(true, [colId, 0], true, false) else  TEmpty(),
				colFiller,
				if (isRightCol) TEmpty() else makeSeparator(true, [colId + 1, 0], true, false)
			]
		)
	} else {
		// Resize H
		MLines(
			if (colId == 0 && numOfCols == 1)
			[
				makeSeparator(false, [colId, 0], isBottomLine, !isBottomLine),
				colFiller,
				makeSeparator(false, [colId + 1, 0], !isBottomLine, isBottomLine),
			]
			else if (colId == 0 && numOfCols != 1)
			[
				makeSeparator(false, [colId, 0], isBottomLine, !isBottomLine),
				colFiller,
				if (isBottomLine) TEmpty() else makeSeparator(false, [colId + 1, 0], true, false)
			]
			else if (colId != 0 && colId == numOfCols - 1)
			[
				if (isBottomLine) makeSeparator(false, [colId, 0], true, false) else  TEmpty(),
				colFiller,
				makeSeparator(false, [colId + 1, 0], !isBottomLine, isBottomLine),
			]
			else
			[
				if (isBottomLine) makeSeparator(false, [colId, 0], true, false) else  TEmpty(),
				colFiller,
				if (isBottomLine) TEmpty() else makeSeparator(false, [colId + 1, 0], true, false)
			]
		)
	}

	scrollBox = if (dontScroll) MCropSize(TFillXY(), box) else MScroll(box, TFillXY(), []);

	// addColSeparators = \ f : Material ->
	// 	[
	// 		if (!isRightCol) TEmpty() else makeSeparatorBar(isColumn, dontResize, se, !light, style),	// sx
	// 		f,
	// 		if (isRightCol) TEmpty() else makeSeparatorBar(isColumn, dontResize, se, !light, style)  	// dx
	// 	] 
	// 	|> (\c -> if (isColumn) MCols(c) else MLines(c));


		addColSeparators = \ f : Material ->
			if (isColumn) {
				MColsA([
					if (!isRightCol) TEmpty() else makeSeparatorBar(isColumn, dontResize, se, light, style),	// sx
					f,
					if (isRightCol) TEmpty() else makeSeparatorBar(isColumn, dontResize, se, light, style)  	// dx
				])
			} else {
				MLines([
					if (isEdgeBottom) TEmpty() else  {
						if (isBottomLine)  makeSeparatorBar(isColumn, dontResize, se, light, style) else TEmpty()  // top
					},	
					f,
					if (isEdgeTop) TEmpty() else {
						if (isBottomLine) TEmpty() else makeSeparatorBar(isColumn, dontResize, se, light, style)  // bottom
					}	
				])
			}

		addDragAndDropHelperGroup = \ f : Material ->  MGroup2(f, colWithHandles);

	MConstruct([
					// makeSubscribe(sizeB, \e -> {
					// 	println("sizeB");
					// 	println(e);

					// }),
		makeSubscribe2(isResizing, \rs -> { 
			if (!rs) {
				println("update Ws -" + i2s(colId) + "- "+ toString(getValue(sizeB)));
				// Update all docked panels in a col
				iter(colA, \pId -> {
					if (isColumn) updateTW(state.dockedSize, pId,  getValue(sizeB))
						else updateTH(state.dockedSize, pId,  getValue(sizeB));
				});

				// Update cache
				setMDockingStateKeyValue(state) |> ignore;
			}
		}),
		makeSubscribe(resizePressed, \p -> {
			if (p) {
				addMInteractionItemId(manager, itemId);
				next(currXy, getValue(state.mouseXy));
				next(startingValueB, getValue(sizeB));

				next(panelWH, WidthHeight(getValue(sizeB), getValue(sizeB)));
				next(isResizing, true);
			} else {
				if (getValue(isResizing)) next(isResizing, false);
			}
		}),
		makeSubscribe(state.mouseXy, \mxy -> {
			if (isCurrentMInteractionItemId(manager, itemId) && getValue(isResizing)) {
				rtlCorrection = if (getDefaultRtl()) -1.0 else 1.0; // correction the direction of width changing depending of rtl mode
				blockOtherMInteractionItemIds(manager, itemId);
				if (isColumn) {

					// newW = if (isRightCol) max(dockingSideCollapsedSize, getValue(panelWH).width + rtlCorrection*(getValue(currXy).x - mxy.x))
					// else max(dockingSideCollapsedSize, getValue(panelWH).width - rtlCorrection*(getValue(currXy).x - mxy.x));

					if (isRightCol) nextDistinct(sizeB, max(dockingSideCollapsedSize, getValue(startingValueB) + rtlCorrection * (getValue(currXy).x - mxy.x)))
						else nextDistinct(sizeB, max(dockingSideCollapsedSize, getValue(startingValueB) - rtlCorrection * (getValue(currXy).x - mxy.x)));

										// if (isRightCol)

										// println(
										// 	toString(getValue(startingValueB)) +    " - "  +   
										// 	toString(rtlCorrection*(getValue(currXy).x - mxy.x)) + " : " + 
										// 	toString(getValue(startingValueB) + rtlCorrection*(getValue(currXy).x - mxy.x)) 
										// )
										// else 
										// println(
										// 	toString(getValue(startingValueB)) +    " - "  +   
										// 	toString(rtlCorrection*(getValue(currXy).x - mxy.x)) + " : " + 
										// 	toString(getValue(startingValueB) - rtlCorrection*(getValue(currXy).x - mxy.x)) 
										// );
						
					} else {
						if (isBottomLine) nextDistinct(sizeB, max(dockingItemHeight, getValue(panelWH).height + (getValue(currXy).y - mxy.y)))
							else nextDistinct(sizeB, max(dockingItemHeight, getValue(panelWH).height - (getValue(currXy).y - mxy.y)));

							// if (isBottomLine) nextDistinct(sizeB, max(maxPanelsWidth, getValue(panelWH).height + (getValue(currXy).y - mxy.y)))
							// else nextDistinct(sizeB, max(maxPanelsWidth, getValue(panelWH).height - (getValue(currXy).y - mxy.y)));
					}
			};
		}),
		// \ -> \-> println("dispose" + i2s(areaId)),
	],
	MInteractive([
			TMouseXY(mouseXyLocal)
		],
		MAvailable(
			scrollBox,
			// |> addColSeparators
			// |> addDragAndDropHelperGroup,

			// |> (\f -> MGroup2(
			// 	f,
			// 	MText(i2s(colId), [])
			// )),

			if (isColumn) {
				// if (se) TSelect(sizeB, \w  -> TFillWY(w)) else TFillWY(dockingSideCollapsedSize);
				// TSelect(sizeB, \w  -> TFillWY(w));
				// TSelect(fselect(sizeB,FLift(\w -> w + dockingDragSize)), \ww  -> TFillWY(ww));
				TSelect(fselect(sizeB,FLift(\w -> w)), \ww  -> TFillWY(ww));
			} else {
				TSelect(fselect(sizeB,FLift(\h -> h)), \hh  -> TFillXH(hh));
				// TSelect(fselect(sizeB,FLift(\h -> h + dockingDragSize)), \hh  -> TFillXH(hh));
				// if (se) TSelect(HA[colId], \h  -> TFillXH(h)) else TFillXH(dockingSideCollapsedSize);
			}
		) 
		|> addColSeparators
		|> (\t -> 
			MCopySize(t, \sz -> 
				MAvailable(
					TRectangle([MFill(MBlack()), FillOpacity(dockingHelperDragOpacity)], TFillXY()) |> addDragAndDropHelperGroup,
					sz
				), 
			true
			)
		)

	));
}




























































// makeAvailableDockedWidth(
// 	box : Material, 
// 	isColumn : bool,
// 	dropInfo : MDockingDropInfo,
// 	state : MDockingState, 
// 	sizeB : DynamicBehaviour<double>,

// 	areaGrid : [[int]],
// 	colA : [int], 
// 	colId : int,
// 	light : bool,
// 	style : [MDockingStyle]
// ) -> Material {

// 	manager = state.manager;
// 	itemId = makeTropicTag(manager);
// 	zorder = getValue(manager.manager.zorder);

// 	isBottomLine = contains(style, MDockingBottomtLines());
// 	isRightCol  = contains(style, MDockingRightCols());
// 	dontScroll  = contains(style, MDockingDontScroll());
// 	dontResizeAll = fold(colA, true, \acc, p -> acc && contains(getValue(state.style)[p], MDockingDontResize()));
// 	dontResizeCol  = contains(style, MDockingDontResize());
// 	dontResize = dontResizeCol || dontResizeAll;

// 	resizePressed = make(false);
// 	isResizing = make(false);
// 	mouseXyLocal = make(zeroPoint);
// 	currXy = make(zeroPoint);
// 	panelWH = makeWH();
// 	startingValueB = make(0.0);

// 	panelsWidthA = map(colA, \s -> getTropicMetrics(getValue(state.size)[s]).width);
// 	maxPanelsWidth = either(maxA(panelsWidthA), -doubleMax);
// 	se = getValue(getValue(state.sideExpanded)[colA[0]]);

// 	numOfCols = length(areaGrid);
// 	lastCol = numOfCols - 1;

// 	// Cols separator with drop
// 	dragSize = dockingDragSize;
// 	dragSizeBig = dockingHelperDragSize;
// 	dragHandleSizeBig = makeVSize(dragSizeBig, isColumn);
// 	dragHandleSize = makeVSize(dockingDragSize, isColumn);
// 	makeVResizeSeparator = \cid ->
// 		dockingDropLine(isColumn, true, dropInfo, state, [cid, 0], false,
// 			dockingResizeLine(isColumn, true, dontResize, resizePressed, dragHandleSizeBig, style), 
// 		dragHandleSize, dragHandleSizeBig, false, style);

// 	dLine = dockingDropLine(isColumn, true, dropInfo, state, [if (isRightCol) lastCol + 1 else 0, 0], false, MEmpty(), dragHandleSize, dragHandleSizeBig, true, style);
// 	// dLine = \cid -> dockingDropLine(isColumn, true, colId,  dropInfo, state, [if (isRightCol) lastCol + 1 else 0, 0], MEmpty(), dragHandleSize, dragHandleSizeBig, true, style);



// 	colFiller = if (isColumn) TFillX() else TFillY();

// // 	colWithHandles = {
// // 		if (colId == 0 && numOfCols == 1)
// // 		[
// // 			if (isRightCol || isBottomLine) makeVResizeSeparator(colId) else dLine,
// // 			colFiller,
// // 			if (isRightCol || isBottomLine) dLine else makeVResizeSeparator(colId + 1),
// // 		]
// // 		else if (colId == 0 && numOfCols != 1)
// // 		[
// // 			if (isRightCol || isBottomLine) makeVResizeSeparator(colId) else dLine,
// // 			colFiller,
// // 			if (isRightCol || isBottomLine) TEmpty() else makeVResizeSeparator(colId + 1),
// // 		]
// // 		else if (colId != 0 && colId == numOfCols - 1)
// // 		[
// // 			if (!isRightCol && !isBottomLine) TEmpty() else makeVResizeSeparator(colId),
// // 			colFiller,
// // 			if (isRightCol || isBottomLine) dLine else makeVResizeSeparator(colId + 1),
// // 		]
// // 		else
// // 		[
// // 			if (!isRightCol && !isBottomLine) TEmpty() else makeVResizeSeparator(colId),
// // 			colFiller,
// // 			if (isRightCol || isBottomLine) TEmpty() else makeVResizeSeparator(colId + 1),
// // 		]

// // // [ 									
// // // 			makeMDockingSeparatorDrop(isColumn, resizeCol, colId, colA,  numOfCols, dropInfo, resizePressed, state, style),
// // // 			colFiller,
// // // 			makeMDockingSeparatorDrop(isColumn, resizeCol, colId + 1, colA,  numOfCols, dropInfo, resizePressed, state, style),
// // // 		]

// // 	} |> (\f -> if (isColumn) MCols(f) else MLines(f))




// 	colWithHandles =
// 	if (isColumn) {
// 		MCols(
// 			if (colId == 0 && numOfCols == 1)
// 			[
// 				if (isRightCol) makeVResizeSeparator(colId) else dLine,   		// sx
// 				colFiller,
// 				if (isRightCol) dLine else makeVResizeSeparator(colId + 1),		// dx
// 			]
// 			else if (colId == 0 && numOfCols != 1)
// 			[
// 				if (isRightCol) makeVResizeSeparator(colId) else dLine,
// 				colFiller,
// 				if (isRightCol) TEmpty() else makeVResizeSeparator(colId + 1),
// 			]
// 			else if (colId != 0 && colId == numOfCols - 1)
// 			[
// 				if (isRightCol) makeVResizeSeparator(colId) else  TEmpty(),
// 				colFiller,
// 				if (isRightCol) dLine else makeVResizeSeparator(colId + 1),
// 			]
// 			else
// 			[
// 				if (isRightCol) makeVResizeSeparator(colId) else  TEmpty(),
// 				colFiller,
// 				if (isRightCol) TEmpty() else makeVResizeSeparator(colId + 1),
// 			]
// 		)
// 	} else {
// 		MLines(
// 			if (colId == 0 && numOfCols == 1)
// 			[
// 				if (isRightCol || isBottomLine) makeVResizeSeparator(colId) else dLine,
// 				colFiller,
// 				if (isRightCol || isBottomLine) dLine else makeVResizeSeparator(colId + 1),
// 			]
// 			else if (colId == 0 && numOfCols != 1)
// 			[
// 				if (isRightCol || isBottomLine) makeVResizeSeparator(colId) else dLine,
// 				colFiller,
// 				if (isRightCol || isBottomLine) TEmpty() else makeVResizeSeparator(colId + 1),
// 			]
// 			else if (colId != 0 && colId == numOfCols - 1)
// 			[
// 				if (!isRightCol && !isBottomLine) TEmpty() else makeVResizeSeparator(colId),
// 				colFiller,
// 				if (isRightCol || isBottomLine) dLine else makeVResizeSeparator(colId + 1),
// 			]
// 			else
// 			[
// 				if (!isRightCol && !isBottomLine) TEmpty() else makeVResizeSeparator(colId),
// 				colFiller,
// 				if (isRightCol || isBottomLine) TEmpty() else makeVResizeSeparator(colId + 1),
// 			]
// 		)
// 	}

// // [ 									
// // 			makeMDockingSeparatorDrop(isColumn, resizeCol, colId, colA,  numOfCols, dropInfo, resizePressed, state, style),
// // 			colFiller,
// // 			makeMDockingSeparatorDrop(isColumn, resizeCol, colId + 1, colA,  numOfCols, dropInfo, resizePressed, state, style),
// // 		]





// 	scrollBox = if (dontScroll) MCropSize(TFillXY(), box) else MScroll(box, TFillXY(), []);

// 	// resizableScrollBox = scrollBox |> (\f ->MGroup2(f, colWithHandles));
// 	// resizableScrollBox = scrollBox;

// 		// addColSeparators = \ f : Material ->
// 		// 	[
// 		// 		if (!isRightCol) TEmpty() else makeSeparatorBar(isColumn, dontResize, se, !light, style),	// sx
// 		// 		f,
// 		// 		if (isRightCol) TEmpty() else makeSeparatorBar(isColumn, dontResize, se, !light, style)  	// dx
// 		// 	] 
// 		// 	|> (\c -> if (isColumn) MCols(c) else MLines(c));


// 		addColSeparators = \ f : Material ->
// 			if (isColumn) {
// 				MColsA([
// 					if (!isRightCol) TEmpty() else makeSeparatorBar(isColumn, dontResize, se, light, style),	// sx
// 					f,
// 					if (isRightCol) TEmpty() else makeSeparatorBar(isColumn, dontResize, se, light, style)  	// dx
// 				])
// 			} else {
// 				MLines([
// 					if (isBottomLine)  makeSeparatorBar(isColumn, dontResize, se, light, style) else TEmpty(),	// top
// 					f,
// 					if (isBottomLine) TEmpty() else makeSeparatorBar(isColumn, dontResize, se, light, style)	// bottom
// 				])
// 			}
	

// 		addDragAndDropHelper = \ f : Material ->  MGroup2(f, colWithHandles);

// 	resizableBox = 
// 		scrollBox
// 			|> addColSeparators
// 			|> addDragAndDropHelper;

// 	MConstruct([
// 					// makeSubscribe(sizeB, \e -> {
// 					// 	println("sizeB");
// 					// 	println(e);

// 					// }),
// 		makeSubscribe2(isResizing, \rs -> { 
// 			if (!rs) {
// 				println("update Ws -" + i2s(colId) + "- "+ toString(getValue(sizeB)));
// 				// Update all docked panels in a col
// 				iter(colA, \pId -> updateTW(state.dockedSize, pId,  getValue(sizeB)));
// 				// Update cache
// 				setMDockingStateKeyValue(state) |> ignore;
// 			}
// 		}),
// 		makeSubscribe(resizePressed, \p -> {
// 			if (p) {
// 				addMInteractionItemId(manager, itemId);
// 				next(currXy, getValue(state.mouseXy));
// 				next(startingValueB, getValue(sizeB));

// 				next(panelWH, WidthHeight(getValue(sizeB), getValue(sizeB)));
// 				next(isResizing, true);
// 			} else {
// 				if (getValue(isResizing)) next(isResizing, false);
// 			}
// 		}),
// 		makeSubscribe(state.mouseXy, \mxy -> {
// 			if (isCurrentMInteractionItemId(manager, itemId) && getValue(isResizing)) {
// 				rtlCorrection = if (getDefaultRtl()) -1.0 else 1.0; // correction the direction of width changing depending of rtl mode
// 				blockOtherMInteractionItemIds(manager, itemId);
// 				if (isColumn) {

// 					// newW = if (isRightCol) max(dockingSideCollapsedSize, getValue(panelWH).width + rtlCorrection*(getValue(currXy).x - mxy.x))
// 					// else max(dockingSideCollapsedSize, getValue(panelWH).width - rtlCorrection*(getValue(currXy).x - mxy.x));

// 				if (isRightCol) nextDistinct(sizeB, max(dockingSideCollapsedSize, getValue(startingValueB) + rtlCorrection*(getValue(currXy).x - mxy.x)))
// 					else nextDistinct(sizeB, max(dockingSideCollapsedSize, getValue(startingValueB) - rtlCorrection*(getValue(currXy).x - mxy.x)));

// 										// if (isRightCol)

// 										// println(
// 										// 	toString(getValue(startingValueB)) +    " - "  +   
// 										// 	toString(rtlCorrection*(getValue(currXy).x - mxy.x)) + " : " + 
// 										// 	toString(getValue(startingValueB) + rtlCorrection*(getValue(currXy).x - mxy.x)) 
// 										// )
// 										// else 
// 										// println(
// 										// 	toString(getValue(startingValueB)) +    " - "  +   
// 										// 	toString(rtlCorrection*(getValue(currXy).x - mxy.x)) + " : " + 
// 										// 	toString(getValue(startingValueB) - rtlCorrection*(getValue(currXy).x - mxy.x)) 
// 										// );
						
// 					} else {
// 						if (isBottomLine) nextDistinct(sizeB, max(maxPanelsWidth, getValue(panelWH).height + (getValue(currXy).y - mxy.y)))
// 							else nextDistinct(sizeB, max(maxPanelsWidth, getValue(panelWH).height - (getValue(currXy).y - mxy.y)));
// 					}
// 			};
// 		}),
// 		// \ -> \-> println("dispose" + i2s(areaId)),
// 	],
// 	MInteractive([
// 			TMouseXY(mouseXyLocal)
// 		],
// 		MAvailable(
// 			resizableBox,

// 			if (isColumn) {
// 				// if (se) TSelect(sizeB, \w  -> TFillWY(w)) else TFillWY(dockingSideCollapsedSize);
// 				// TSelect(sizeB, \w  -> TFillWY(w));
// 				TSelect(fselect(sizeB,FLift(\w -> w + dockingDragSize)), \ww  -> TFillWY(ww));
// 			} else {
// 				TSelect(fselect(sizeB,FLift(\h -> h + dockingDragSize)), \hh  -> TFillXH(hh));
// 				// if (se) TSelect(HA[colId], \h  -> TFillXH(h)) else TFillXH(dockingSideCollapsedSize);
// 			}
// 		) 
// 	));
// }






// 	makeAvailableDockedHeight(
// 		box : Material, 
// 		isColumn : bool,
// 		dropInfo : MDockingDropInfo,
// 		state : MDockingState,
// 		sizeB : DynamicBehaviour<double>, 

// 		panelId : int, 
// 		parentA : [int], 
// 		colId : int,
// 		rowId : int,
		
// 		light : bool,
// 		style : [MDockingStyle], 

// 	) -> Material {

// 		manager = state.manager;
// 		itemId = makeTropicTag(manager);
// 		zorder = getValue(manager.manager.zorder);
// 		pstyle = getValue(state.style)[panelId];
// 		groupA = state.group;

// 		// Size	
// 		sideCollapsedSize = dockingSideCollapsedSize;
// 		panelDockedSize = getValue(state.dockedSize)[panelId];
// 		pWidth = getTropicMetrics(panelDockedSize).width;
// 		pHeight = getTropicMetrics(panelDockedSize).height;

// 		// Container size
// 		WH = if (isColumn) make(WidthHeight(pWidth, pHeight)) else make(WidthHeight(pHeight, pWidth));

// 		// Order
// 		isFirstPanel = panelId == firstElement(parentA, intMax);
// 		isLastPanel = panelId == lastElement(parentA, intMax);
// 		lastPanelId = length(parentA) - 1;

// 		fillLast = contains(style, MDockingColFillLast());
// 		fillPanelOrderId = if (fillLast) lastPanelId else 0;

// 		resizePressed = make(false);
// 		isResizing = make(false);
// 		isHovering = make(false);
// 		mouseXyLocal = make(zeroPoint);
		
// 		// Expanded
// 		expanded = getValue(state.expanded)[panelId];
// 		sideExpanded = getValue(state.sideExpanded)[panelId];
// 		enabled = getValue(state.enabled)[panelId];

// 		se = getValue(getValue(state.sideExpanded)[parentA[0]]);


// 		collapsedSepColor = MGrey(400);

// 		isToolbarItem = isSameStructType(getValue(state.content)[panelId][0], MDockingPanelToolbarItem("", []));
// 		fillHeightArea = contains(style, MDockingFillSpace());
// 		fillHeight = fillHeightArea || contains(pstyle, MDockingFillSpace());
// 		isBottomLine = contains(style, MDockingBottomtLines());
// 		dontScroll  = contains(style, MDockingDontScroll());	
// 		dontResizeAll = fold(parentA, true, \acc, p -> acc && contains(getValue(state.style)[p], MDockingDontResize()));
// 		// dontResize = dontResizeAll || isLastPanel;
// 		dontResize = isLastPanel;

// 		println(" > DRAW - Container R - " + i2s(panelId) /*+ "      - " + toString(parentA)*/);
// 		// println("isColumn" + b2s(isColumn));

// 		// Rows separator with drop
// 		dragSize = dockingDragSize;
// 		dragSizeBig = dockingHelperDragSize;
// 		dragHandleSizeBig = makeHSize(dragSizeBig, isColumn);
// 		dragHandleSize = makeHSize(dockingDragSize, isColumn);

// 		// makeHResizeSeparator = \idx -> makeMDockingSeparatorDrop(isColumn, resizeRow, colId, idx, parentA, length(parentA), dropInfo, resizePressed, state, style);
// 		makeHResizeSeparator = \order : [int] -> {
// 			// dockingDropLine(isColumn, !isColumn, rid, dropInfo, state, [colId, rid], 
// 			// 	dockingResizeLine(isColumn, false, dontResize, [colId, rid], dropInfo, resizePressed, dragHandleSizeBig, state, style),
// 			// 	// dockingResizeLine(isColumn, false, false, [colId, rid], dropInfo, resizePressed, dragHandleSizeBig, state, style),
// 			// dragHandleSize, dragHandleSizeBig, !isColumn, style);
		
// println("order");
// println(order);
// println("rowId");
// println(rowId);
// println("colId");
// println(colId);
// 			dockingDropLine(isColumn, false, dropInfo, state, order, true,
// 					dockingResizeLine(isColumn, false, dontResize, resizePressed, dragHandleSizeBig, style),
// 					// dockingResizeLine(isColumn, false, false, [colId, rid], dropInfo, resizePressed, dragHandleSizeBig, state, style),
// 				dragHandleSize, dragHandleSizeBig, false, style);
// 		}
	
// 		dLine = \rid : int , e : bool -> dockingDropLine(isColumn, false, dropInfo, state, [colId, rid], true, MEmpty(), dragHandleSize, dragHandleSizeBig, e, style);

// 		rowFiller = if (isColumn) TFillY() else TFillX();

// 		// rowsWithHandles = {
// 		// 	if (rowId == 0 && length(parentA) == 1)
// 		// 	[
// 		// 		if (isBottomLine) dLine(rowId + 1, false) else dLine(rowId, true),
// 		// 		rowFiller,
// 		// 		if (isBottomLine) dLine(rowId, true) else dLine(rowId + 1, false) ,
// 		// 	]
// 		// 	else if (rowId == 0 && length(parentA) != 1)
// 		// 	[
// 		// 		if (isBottomLine) dLine(rowId + 1, true) else dLine(rowId, true),
// 		// 		rowFiller,
// 		// 		if (isBottomLine) TEmpty() else makeHResizeSeparator(rowId + 1),
// 		// 	]
// 		// 	else if (rowId ==  length(parentA) - 1 && length(parentA) != 1)
// 		// 	[
// 		// 		if (!isBottomLine) TEmpty() else makeHResizeSeparator(rowId),
// 		// 		rowFiller,
// 		// 		if (!isBottomLine) dLine(rowId + 1, false) else dLine(rowId, true),
// 		// 	]
// 		// 	else
// 		// 	[
// 		// 		if (!isBottomLine) TEmpty() else makeHResizeSeparator(rowId),
// 		// 		rowFiller,
// 		// 		if (isBottomLine) TEmpty() else   makeHResizeSeparator(rowId + 1),
// 		// 	]
// 		// } |> (\f -> if (isColumn) MLines(f) else MCols(f));


// 		rowsWithHandles = 
// 			 if (isColumn) {
// 				 MLines( 
// 					// if (rowId == 0 && length(parentA) == 1)
// 					// [
// 					// 	if (isBottomLine) dLine(rowId + 1, false) else dLine(rowId, true),   //top
// 					// 	rowFiller,
// 					// 	if (isBottomLine) dLine(rowId, true) else dLine(rowId + 1, false) ,  //bottom
// 					// ]
// 					// else if (rowId == 0 && length(parentA) != 1)
// 					// [
// 					// 	if (isBottomLine) dLine(rowId + 1, true) else dLine(rowId, true),
// 					// 	rowFiller,
// 					// 	if (isBottomLine) TEmpty() else makeHResizeSeparator(rowId + 1),
// 					// ]
// 					// else if (rowId ==  length(parentA) - 1 && length(parentA) != 1)
// 					// [
// 					// 	if (!isBottomLine) TEmpty() else makeHResizeSeparator(rowId),
// 					// 	rowFiller,
// 					// 	if (!isBottomLine) dLine(rowId + 1, false) else dLine(rowId, true),
// 					// ]
// 					// else
// 					// [
// 					// 	if (!isBottomLine) TEmpty() else makeHResizeSeparator(rowId),
// 					// 	rowFiller,
// 					// 	if (isBottomLine) TEmpty() else   makeHResizeSeparator(rowId + 1),
// 					// ]
// 					[
// 						// if (!isBottomLine) TEmpty() else makeHResizeSeparator(rowId),
// 						rowFiller,
// 						makeHResizeSeparator([colId, rowId + 1]),
// 						// makeHResizeSeparator([colId, rowId]),
// 						// makeHResizeSeparator([rowId, colId]),
// 						// makeHResizeSeparator([rowId + 1, colId]),
// 					]
// 				)
// 			 } else {
// 				 MEmpty()
// 				//  MCols(
// 				// 	//  if (rowId == 0 && length(parentA) == 1)
// 				// 	// [
// 				// 	// 	if (isBottomLine) dLine(rowId + 1, false) else dLine(rowId, true),   //top
// 				// 	// 	rowFiller,
// 				// 	// 	if (isBottomLine) dLine(rowId, true) else dLine(rowId + 1, false) ,  //bottom
// 				// 	// ]
// 				// 	// else if (rowId == 0 && length(parentA) != 1)
// 				// 	// [
// 				// 	// 	if (isBottomLine) dLine(rowId + 1, true) else dLine(rowId, true),
// 				// 	// 	rowFiller,
// 				// 	// 	if (isBottomLine) TEmpty() else makeHResizeSeparator(rowId + 1),
// 				// 	// ]
// 				// 	// else if (rowId ==  length(parentA) - 1 && length(parentA) != 1)
// 				// 	// [
// 				// 	// 	if (!isBottomLine) TEmpty() else makeHResizeSeparator(rowId),
// 				// 	// 	rowFiller,
// 				// 	// 	if (!isBottomLine) dLine(rowId + 1, false) else dLine(rowId, true),
// 				// 	// ]
// 				// 	// else
// 				// 	[
// 				// 		TEmpty(),
// 				// 		rowFiller,
// 				// 		makeHResizeSeparator([colId, rowId + 1]),
// 				// 		// makeHResizeSeparator(rowId + 1),
// 				// 	]
// 				//  )
// 			 }




// 		scrollBox = if (dontScroll) MCropSize(TFillXY(), box) else MScroll(box, TFillXY(), []);
// 		// resizableScrollBox = MGroup2(scrollBox, rowsWithHandles);


// 		// addRowSeparators = \ f : Material ->
// 		// 	[
// 		// 		if (!isBottomLine) TEmpty() else makeSeparatorBar(!isColumn, dontResize, se, !light, style),  // top/sx
// 		// 		f,
// 		// 		if (isBottomLine) TEmpty() else makeSeparatorBar(!isColumn, dontResize, se, !light, style)    // bottom/dx
// 		// 	] |> (\r -> if (isColumn) MLines(r) else MCols(r));



// 		addRowSeparators = \ f : Material ->
// 		if (isColumn) {
// 			MLines([
// 				// TEmpty(),
// 				f,
// 				// if (isBottomLine) TEmpty() else 
// 				if (isLastPanel) TEmpty() else makeSeparatorBar(!isColumn, dontResize, se, light, style)    // bottom/dx
// 			])
// 		} else {
//  			MCols([
// 				// if (!isBottomLine) TEmpty() else makeSeparatorBar(!isColumn, dontResize, se, !light, style),  // top/sx
// 				f,
// 				// if (isBottomLine) TEmpty() else
// 				if (isLastPanel) TEmpty() else makeSeparatorBar(!isColumn, dontResize, se, light, style)    // bottom/dx
// 			])
// 		}	


		

// 		addDragAndDropHelper = \ f : Material ->  MGroup2(f, rowsWithHandles);

// 		resizableBox = scrollBox |> addRowSeparators |> addDragAndDropHelper;


// 		println("isColumn" + b2s(isColumn));


// 		MConstruct([
// 					// makeSubscribe(sizeB, \e -> {
// 					// 	println("sizeB - h");
// 					// 	println(e);

// 					// }),
// 				makeSubscribe2(isResizing, \rs -> { 
// 					if (!rs) {
// 						println("update H -" + i2s(panelId) + "- "+ toString(getValue(sizeB)));
// 						updateTH(state.dockedSize, panelId,  getValue(sizeB));
// 					}
// 				}),
// 			makeSubscribe(resizePressed, \p -> {
// 				if (p) {
// 					addMInteractionItemId(manager, itemId);
// 					next(isResizing, true);
// 				} else {
// 					if (getValue(isResizing)) next(isResizing, false);
// 				}
// 			}),
// 			makeSubscribe(mouseXyLocal, \mxy -> {
// 				if (isCurrentMInteractionItemId(manager, itemId) && getValue(isResizing)) {
// 					blockOtherMInteractionItemIds(manager, itemId);	

// 					// if (isColumn) nextDistinct(WH, WidthHeight(getValue(WH).width, max(dockingBarHeight, mxy.y)))
// 					// 	else nextDistinct(WH, WidthHeight(mxy.x, getValue(WH).height));
// 					if (isColumn) nextDistinct(sizeB, max(dockingBarHeight, mxy.y))
// 						else nextDistinct(sizeB, max(mxy.x, dockingBarHeight));

// 					// UPDATE DOCKED SIZE
// 					nextDistinct(state.dockedSize, replace(getValue(state.dockedSize), panelId, TFixed(getValue(WH).width, getValue(WH).height)));
// 					// nextDistinct(state.size, replace(getValue(state.dockedSize), panelId, TFixed(getValue(WH).width, getValue(WH).height)));
// 				};
// 			})
// 		],
// 		MInteractive([
// 			TMouseXY(mouseXyLocal)
// 			],
// 			MAvailable(	
// 				resizableBox, 
// 				if (isColumn) {
// 					// if (panelId == fillPanelOrderId || isLastPanel) TGroup2(TFillXY(), TSelect(fselect(sizeB,FLift(\h -> h + dockingDragSize)), \hh  -> TFillXH(hh))) 

// 					if (isLastPanel /*|| isFirstPanel*/) TGroup2(TFillXY(), TSelect(fselect(sizeB,FLift(\h -> h + dockingDragSize + dockingBarHeight)), \hh  -> TFillXH(hh))) 
// 						else  TSelect(fselect(sizeB,FLift(\h -> h + dockingDragSize + dockingBarHeight)), \hh  -> TFillXH(hh))

// 					// TSelect(fselect(sizeB,FLift(\h -> h + dockingDragSize + dockingBarHeight)), \hh  -> TFillXH(hh))

// 				} else {
// 					if (isLastPanel /*|| isFirstPanel*/) TGroup2(TFillXY(), TSelect(fselect(sizeB, FLift(\w -> w + dockingDragSize + dockingBarHeight)), \ww  -> TFillWY(ww)))
// 						else TSelect(fselect(sizeB,FLift(\w -> w + dockingDragSize + dockingBarHeight)), \ww  -> TFillWY(ww))

// 						// TSelect(fselect(sizeB, FLift(\w -> {
						
// 						// println("width: " + toString(w));
// 						// w + dockingDragSize})), \ww  -> TFillWY(ww));
// 				}
// 			)		
// 		)
// 	)
// }