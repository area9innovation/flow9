import material/material_ui;
import material/extra/docking_ui/internal/material_docking_utils;
import material/extra/docking_ui/internal/material_docking_drop;
import material/extra/docking_ui/internal/material_docking_panels;


export {
	// Make a single resizable column (or row) with docked panels inside
	makeResizableColFn(
		isColumn : bool, 
		dropInfo : MDockingDropInfo,
		state : MDockingState, 
		groupName : string, 
		id : int,
		redraw : DynamicBehaviour<bool>, 
		WA : [DynamicBehaviour<double>], 
		HA : [DynamicBehaviour<double>], 
		dockedPanelsGrid : DynamicBehaviour<[[int]]>,
		singleColA : [int], 
		colId : int, 
		style : [MDockingStyle]
	) -> (int, int) -> [Material];
}



makeResizableColFn(
	isColumn : bool,
	dropInfo : MDockingDropInfo,
	state : MDockingState, 
	groupName : string, 
	id : int,
	redraw : DynamicBehaviour<bool>,
	WA : [DynamicBehaviour<double>], 
	HA : [DynamicBehaviour<double>], 
	dockedPanelsGrid : DynamicBehaviour<[[int]]>,
	singleColA : [int], 
	colId : int, 
	style : [MDockingStyle]
) -> (int, int) -> [Material] {

	// Array of docked panels in a single resizable column/row
	makeSingleDockedArea = makeDockedAreaLines(isColumn, dropInfo, redraw, state, groupName, id, WA, HA, style);
	// Cols separator
	makeColResizeSeparator = makeColSeparator(isColumn, state, style);

	isRightCol  = contains(style, MDockingRightCols());
	isBottomLine = contains(style, MDockingBottomtLines());

	resizePressedH = make(false);
	resizePressedV = make(false);

	dockedPanelsCols = getValue(dockedPanelsGrid);
	numOfCols = length(dockedPanelsCols);

	\idx : int, len : int -> {
		if (colId == 0 && numOfCols == 1)
		[
			makeColResizeSeparator(colId, 0, numOfCols, singleColA, resizePressedH),
			makeSingleDockedArea(colId, dockedPanelsGrid, singleColA, resizePressedV, resizePressedH),
			makeColResizeSeparator(colId + 1, 0, numOfCols, singleColA, resizePressedH),
		]
		else if (colId == 0 && numOfCols != 1)
		[
			makeColResizeSeparator(colId, 0, numOfCols, singleColA, resizePressedH),
			makeSingleDockedArea(colId, dockedPanelsGrid, singleColA, resizePressedV, resizePressedH),
			if (isRightCol || isBottomLine) TEmpty() else makeColResizeSeparator(colId + 1, 0, numOfCols, singleColA, resizePressedH),
		]
		else if (colId != 0 && colId == numOfCols - 1)
		[
			if (!isRightCol && !isBottomLine) TEmpty() else makeColResizeSeparator(colId, 0, numOfCols, singleColA, resizePressedH),
			makeSingleDockedArea(colId, dockedPanelsGrid, singleColA, resizePressedV, resizePressedH),
			makeColResizeSeparator(colId + 1, 0, numOfCols, singleColA, resizePressedH),
		]
		else
		[
			if (!isRightCol && !isBottomLine) TEmpty() else makeColResizeSeparator(colId, 0, numOfCols, singleColA, resizePressedH),
			makeSingleDockedArea(colId, dockedPanelsGrid, singleColA, resizePressedV, resizePressedH),
			if (isRightCol || isBottomLine) TEmpty() else makeColResizeSeparator(colId + 1, 0, numOfCols, singleColA, resizePressedH),
		]
	}
}


// Col separator with resize handle
makeColSeparator(isColumn : bool, state : MDockingState, style : [MDockingStyle]) -> (int, int, int, [int], DynamicBehaviour<bool>) -> Material {


	\a : int, b : int, maxLenght : int, singleColA : [int], resizePressedH : DynamicBehaviour<bool> -> {
		manager = state.manager;	
		isHovering = make(false);
		isRightCol  = contains(style, MDockingRightCols());
		isBottomLine = contains(style, MDockingBottomtLines());
		dontResize  = contains(style, MDockingDontResize());
		dontResizeAll = fold(singleColA, true, \acc, p -> acc && contains(getValue(state.style)[p], MDockingDontResize()));

		// Sizes
		dropSize = extractStruct(style, MDockingDropSize(dockingDropSize)).size;
		dragSize = dockingDragSize;
		rowSize = if (isColumn) TFillXH(dropSize) else TFillWY(dropSize);
		colSize = if (isColumn) TFillWY(dropSize) else TFillXH(dropSize);
		colSizeDrag = if (isColumn) TFillWY(dragSize) else TFillXH(dragSize);
		invisibleBar = TRectangle([MFill(MGreen(700)), FillOpacity(0.0)], colSizeDrag);

		// Dragging bar 
		smallHandle = \lg : bool -> TRectangle([MFill(smallHandleColorFn(lg, style))], if (isColumn) TFixed(dockingHandleW, dockingHandleH) else TFixed(dockingHandleH, dockingHandleW));		
		draggingBarInactive = \lg : bool -> TRectangle([MFill(separatorColorFn(lg, style))], colSizeDrag);
		draggingBarActive = \lg : bool -> {
			MCursor(
				if (isColumn) EWResizeCursor() else NSResizeCursor(),
				MInteractive([TMouseDown(resizePressedH), TMouseInside(isHovering, false)],
					MGroup2(
						MSelect(isHovering, \h -> TRectangle([MFill(if (h) dockingPrimaryColor else separatorColorFn(lg, style)), FillOpacity(dockingDragHandleOpacity)], colSizeDrag)),
						MCenterIn(smallHandle(lg), colSizeDrag)
					)
				)
			);
		}

		draggingBarSideExpanded =  \lg : bool -> if (getValue(getValue(state.sideExpanded)[singleColA[0]])) draggingBarActive(lg) else draggingBarInactive(lg);

		draggingBar = 
			MSelect(manager.white, \ww -> {
				containsDark = fold(singleColA, false, \acc, p -> acc || contains(getValue(state.style)[p], MDockingForceDarkTheme()));
				containsLight = fold(singleColA, false, \acc, p -> acc || contains(getValue(state.style)[p], MDockingForceLightTheme()));
				light = if (containsDark) false else if (containsLight) true else ww;

				if (maxLenght == 1) {
					if (dontResizeAll || dontResize) TEmpty() else draggingBarSideExpanded(light);
				} else {
					if (dontResizeAll || dontResize) draggingBarInactive(light) else {
						if (getValue(getValue(state.sideExpanded)[singleColA[0]])) draggingBarActive(light) else invisibleBar			
					}
				}
			});

		if (isRightCol || isBottomLine) {
			if (a != maxLenght) draggingBar else TEmpty();
		} else {
			if (a != 0) draggingBar else TEmpty();
		}
	}
};



// Arrange panels into resizable lines (or cols when isColumn is false)
makeDockedAreaLines(
	isColumn : bool, 				// parent is column
	dropInfo : MDockingDropInfo,
	redraw : DynamicBehaviour<bool>,
	state : MDockingState, 
	groupName : string, 
	areaId : int,   					// col id
	WA : [DynamicBehaviour<double>], 
	HA : [DynamicBehaviour<double>], 
	style : [MDockingStyle]
) -> (colId : int, dockedPanelsGrid : DynamicBehaviour<[[int]]>, singleColA : [int], resizePressedV : DynamicBehaviour<bool>, resizePressedH : DynamicBehaviour<bool>) -> Material { 

	manager = state.manager;
	itemId = makeTropicTag(manager);
	onDragging = manager.manager.dragging;
	zorder = getValue(manager.manager.zorder);
	groupA = state.group;
	contentA = getValue(state.content);

	dockedSizeA = getValue(state.dockedSize);
	dropSize = extractStruct(style, MDockingDropSize(dockingDropSize)).size;
	dragSize = dockingDragSize;
	handleHeight = dropSize;
	rowSize = if (isColumn) TFillXH(dropSize) else TFillWY(dropSize);
	colSize = if (isColumn) TFillWY(dropSize) else TFillXH(dropSize);

	isRightCol  = contains(style, MDockingRightCols());
	isBottomLine = contains(style, MDockingBottomtLines());
	fillHeightArea = contains(style, MDockingFillSpace());
	stickBottomPanels = contains(style, MDockingColStickBottom());
			
	dontResize  = contains(style, MDockingDontResize());
	dontScroll  = contains(style, MDockingDontScroll());
	dontSideExpand = contains(style, MDockingDontCollapseColumn());

	// redraw = make(false);
	sideExpandedA = map(contentA,\c -> make(false));

	color = extractStruct(style, MBlue(600));




	\colId : int, dockedPanelsGrid : DynamicBehaviour<[[int]]>, singleColA : [int], resizePressedV : DynamicBehaviour<bool>, resizePressedH : DynamicBehaviour<bool> -> {


		println(" > DRAW - docked lines of panels - " + i2s(areaId) + "      - " + toString(singleColA));

		dockedPanelsCols = getValue(dockedPanelsGrid);
		lastPanel = length(singleColA) - 1;
		lastCol = length(dockedPanelsCols) - 1;
		isResizing = make(false);
		mouseXyLocal = make(zeroPoint);
		mouseXyLocalR = make(zeroPoint);
		maxPanelSize = TSizeOf(TGroup(map(singleColA, \s -> if (dockedSizeA != []) dockedSizeA[s] else TEmpty())));
		dontResizeAll = fold(singleColA, true, \acc, p -> acc && contains(getValue(state.style)[p], MDockingDontResize()));
		dontSideExpandPanel = fold(singleColA, false, \acc, p -> acc || contains(getValue(state.style)[p], MDockingDontCollapsePanel()));

		panelsWidthA = map(singleColA, \s -> getTropicMetrics(getValue(state.size)[s]).width);
		dockedWidthA = map(singleColA, \s -> getTropicMetrics(getValue(state.dockedSize)[s]).width);
		mobileWidthA = map(singleColA, \s -> getTropicMetrics(getValue(state.mobileSize)[s]).width);

		maxPanelsWidth = either(maxA(panelsWidthA), -doubleMax);
		maxDockedWidth = either(maxA(dockedWidthA), -doubleMax);
		maxMobileWidth = either(maxA(mobileWidthA), -doubleMax);
		se = getValue(getValue(state.sideExpanded)[singleColA[0]]);

		currXy = make(zeroPoint);
		panelWH = makeWH();
		if (getValue(WA[colId]) == 0.0) next(WA[colId], maxPanelsWidth);
		if (getValue(HA[colId]) == 0.0) next(HA[colId], maxPanelsWidth);

		colHeightB = make(0.0);
		
// xheight = make(0.0);
// xwidth = make(0.0);


		// Dropping line for rows
		makeInnerDroppingLine = \rId : int, c : MColor, s : int -> {
			dragCorrection = if  ((dontResize || dontResizeAll) && length(dockedPanelsCols) == 1) 0.0 else dragSize;
			// separatorSize = if (isColumn) {
			// 	if (isRightCol) {
			// 		if (colId != lastCol) TSubtractGroup2(rowSize, TFixed(dropSize - dragSize, 0.0)) else TSubtractGroup2(rowSize, TFixed(dropSize + dropSize - dragCorrection, 0.0));
			// 	} else {
			// 		if (colId != 0) TSubtractGroup2(rowSize, TFixed(dropSize - dragSize, 0.0)) else TSubtractGroup2(rowSize, TFixed(dropSize + dropSize - dragCorrection, 0.0));
			// 	}
			// } else {
			// 	TFillWY(dropSize);
			// }

			separatorSize = if (isColumn) {
				TFillXH(dropSize);
			} else {
				TFillWY(dropSize);
			}

			defRow = true;
			defDockingCol = true;

			// MSelect(onDragging, \dr -> {
			// 	if ((dr >= 0) && (dr < length(getValue(groupA))) && (contains(getValue(groupA)[dr], groupName))) {

			// 		if (isColumn) {
			// 			if (isSameStructType(getValue(state.content)[dr][0], MDockingPanelToolbarItem("", []))) {
			// 					dockingDropLine(dropInfo, state, [colId, rId], areaId, groupName, c, separatorSize, defRow, defDockingCol, zorder)
			// 			} else {
			// 				if (isRightCol) {
			// 					MOffset(dropSize - dragSize, 0.0, dockingDropLine(dropInfo, state, [colId, rId], areaId, groupName, c, separatorSize, defRow, defDockingCol, zorder));
			// 				} else {

			// 					dockingDropLine(dropInfo, state, [colId, rId], areaId, groupName, c, separatorSize, defRow, defDockingCol, zorder)
			// 						|> (\m -> MOffset(if (colId == 0) dropSize else 0.0, 0.0, m));
			// 					// if (colId == 0)
			// 					// 	MOffset(dropSize, 0.0, dockingDropLine(dropInfo, state, [colId, rId], areaId, groupName, c, separatorSize, defRow, defDockingCol, zorder))
			// 					// else
			// 					// 	dockingDropLine(dropInfo, state, [colId, rId], areaId, groupName, c, separatorSize, defRow, defDockingCol, zorder);
			// 				}
			// 			}

			// 		} else {
			// 			dockingDropLine(dropInfo, state, [colId, rId], areaId, groupName, color, separatorSize, defRow, defDockingCol, zorder);
			// 		}

			// 	} else TEmpty()
			// });
			dockingDropLine(dropInfo, state, [colId, rId], areaId, groupName, color, separatorSize, defRow, defDockingCol, zorder);
		};

		// Make single area (col or row) docked panels
		makeAreaContents = \areaScrollingSize : Tropic, lg : bool -> {

			cntA = 
				mapi(singleColA, \rowId, panelId -> {
					panelStyle = getValue(state.style)[panelId];
					enabled = getValue(state.enabled)[panelId];
					fillHeight = fillHeightArea || contains(panelStyle, MDockingFillSpace());
					
					// Fill panel order
					fillBottomTop = rowId == lastPanel; 	// fill last panel - default
					fillTopBottom = rowId == 0; 			// fill first panel
					fillPanelOrder = if (stickBottomPanels) fillTopBottom else fillBottomTop;

					// Dropping area overlay
					dropAreaOverlay = 
						if (isColumn) {
							MLines([
								makeInnerDroppingLine(rowId, MGreen(200), panelId),
								// makeInnerDroppingLine(rowId, dockingPrimaryColor, panelId),
								if (se) {
									// if (rowId == lastPanel || fillHeight) MShow(getValue(state.expanded)[panelId], TFillY()) else TEmpty(); //--ORIGINAL
									if (fillPanelOrder || fillHeight) MShow(getValue(state.expanded)[panelId], TFillY()) else TEmpty();
								} else TEmpty(),
								// if (rowId == lastPanel) makeInnerDroppingLine(rowId + 1, dockingPrimaryColor, lg, panelId) else TEmpty() //--ORIGINAL
								if (rowId == lastPanel) makeInnerDroppingLine(rowId + 1, MRed(200), panelId) else TEmpty()
							]) 


						} else {
							MColsA([
								makeInnerDroppingLine(rowId, dockingPrimaryColor, panelId),
								if (se) {
									if (rowId == lastPanel) MShow(getValue(state.expanded)[panelId], TFillX()) else TEmpty();
								} else TEmpty(),
								makeInnerDroppingLine(rowId + 1, dockingPrimaryColor, panelId) |> showIf(rowId == lastPanel)
							])
						}

					// ENABLED
					MShowLazy(enabled, \ ->
						MGroup2(	
							// makeDockingPanel(true, state, panelId, groupName, isColumn, rowId == lastPanel, panelStyle, dropSize, make([]), sideExpandedA[colId], zorder)  	// Docked panel	
							makeDockedPanel(state, panelId, singleColA, colHeightB, groupName, isColumn, fillPanelOrder, panelStyle, dropSize, sideExpandedA[colId], zorder) 
							// makeDockingPanel(true, state, panelId, groupName, isColumn, fillPanelOrder, panelStyle, dropSize, make([]), sideExpandedA[colId], zorder)  	// Docked panel - fill the first	 
								|> showIf(dockedSizeA != []),

								MEmpty()	
							// dropAreaOverlay 																													// Drop layer
						)
					);
				});

			singleAreaWithContents = if (isColumn) MLines(cntA) else MColsA(cntA);
			
			// Add Bg
MGroup2(
	TFillY() |> (\f -> MAttachHeight(f, colHeightB)),
				MFrame(0.0, 0.0, [MFill(areaBgColorFn(lg, style))], 
					if (dontScroll) MCropSize(areaScrollingSize, singleAreaWithContents) 
						else MScroll(singleAreaWithContents, areaScrollingSize, [])
				)
)
				
		}

		// Arrange area contents
		makeContentCols = \lg : bool, colWidthB : Transform<double> -> {
			singleColSize = if (se) TSelect(colWidthB, \w  -> TFillWY(w)) else TFillWY(dockingSideCollapsedSize);
			makeAreaContents(singleColSize, lg)
		}
		makeContentRows = \lg : bool, rowHeightB : Transform<double> -> {
			singleRowSize = if (se) TSelect(rowHeightB, \h  -> TFillXH(h)) else TFillXH(dockingSideCollapsedSize);
			makeAreaContents(singleRowSize, lg)
		}















					// Side expander button
					sideExpFn = \ -> {
						iter(singleColA, \c -> reverseBehaviour(getValue(state.sideExpanded)[c]));
						reverseBehaviour(redraw);
					}

					sideExpBtnLabel = if (isRightCol) {
						if (se) "skip_next" else "skip_previous";
					} else {
						if (!se) "skip_next" else "skip_previous";
					}

					sideExpBtnItem = \lg : bool -> MGroup2(
						TRectangle([MFill(sideExpanderBgColorFn(lg, style))], TFillXH(sideExpanderButtonSize)),
						if (isRightCol) MColsA([TFillX(), MIcon(sideExpBtnLabel, [MIconSize(sideExpanderButtonSize - 2.0), dockedTitleColorFn(lg, style)]), TFixed(2.0, 2.0)])
						else MColsA([TFixed(2.0, 2.0), MIcon(sideExpBtnLabel, [MIconSize(sideExpanderButtonSize - 2.0), dockedTitleColorFn(lg, style)]), TFillX()]),
					);

					sideExpBtnItemHover = \lg : bool -> MGroup2(
						TRectangle([MFill(sideExpanderHoverColorFn(lg, style))], TFillXH(sideExpanderButtonSize)),
						if (isRightCol) MColsA([TFillX(), MIcon(sideExpBtnLabel, [MIconSize(sideExpanderButtonSize - 2.0), dockedTitleColorFn(lg, style)]), TFixed(2.0, 2.0),])
						else MColsA([TFixed(2.0, 2.0), MIcon(sideExpBtnLabel, [MIconSize(sideExpanderButtonSize - 2.0), dockedTitleColorFn(lg, style)])]),
					) ;

					sideExpanderBtn = \lg : bool -> MRawButton(sideExpBtnItem(lg), sideExpBtnItemHover(lg), sideExpBtnItem(lg), sideExpBtnItem(lg),
						"", [], [TOnClicked(sideExpFn)]);





		// A resizable column or row of panels
		MSelect(getValue(state.enabled)[colId], \e -> {    // enable ??

			MConstruct([
				// makeSubscribe(colHeightB, \h -> {
						// println("   >>>  COl h: " + i2s(areaId) + "  - " + d2s(h));
				// }),

				// make2Subscribe(xwidth, xheight, \w, h -> {
				// 		println("   >>>  AVAILABLE: " + i2s(areaId) + "  - " + d2s(w) + " x "+ d2s(h));
				// }),
				makeSubscribe(resizePressedH, \p -> {
					if (p) {
						addMInteractionItemId(manager, itemId);
						next(currXy, getValue(state.mouseXy));
						next(panelWH, WidthHeight(getValue(WA[colId]),getValue(HA[colId])));
						next(isResizing, true);
					} else {
						if (getValue(isResizing)) next(isResizing, false);
					}
				}),
				makeSubscribe(state.mouseXy, \mxy -> {
					if (isCurrentMInteractionItemId(manager, itemId) && getValue(isResizing)) {
						rtlCorrection = if (getDefaultRtl()) -1.0 else 1.0; // correction the direction of width changing depending of rtl mode
						blockOtherMInteractionItemIds(manager, itemId);
						if (isColumn) {
							if (isRightCol) nextDistinct(WA[colId], max(maxPanelsWidth, getValue(panelWH).width + rtlCorrection*(getValue(currXy).x - mxy.x)))
								else nextDistinct(WA[colId], max(maxPanelsWidth, getValue(panelWH).width - rtlCorrection*(getValue(currXy).x - mxy.x)));
							} else {
							if (isBottomLine) nextDistinct(HA[colId], max(maxPanelsWidth, getValue(panelWH).height + (getValue(currXy).y - mxy.y)))
								else nextDistinct(HA[colId], max(maxPanelsWidth, getValue(panelWH).height - (getValue(currXy).y - mxy.y)));
							}
					};
				}),
				// \ -> \-> println("dispose" + i2s(id)),
			],
			MInteractive([TMouseXY(mouseXyLocal)],
				MSelect(manager.white, \ww -> {
					containsDark = fold(singleColA, false, \acc, a -> acc || contains(getValue(state.style)[a], MDockingForceDarkTheme()));
					containsLight = fold(singleColA, false, \acc, a -> acc || contains(getValue(state.style)[a], MDockingForceLightTheme()));
					light = if (containsDark) false else if (containsLight) true else ww;

					MLines2(
						if ((isColumn && !dontSideExpand && !dontSideExpandPanel))  sideExpanderBtn(light) else TEmpty(),
						if (isColumn) {

							makeContentCols(light, WA[colId])
								
								// |> (\f -> MAttachWidthHeight(f, xwidth, xheight))
							
							
							
							} else makeContentRows(light, HA[colId])

						
					)
				})
			));


		});
	}
}