import material/material_ui;
import material/extra/docking_ui/internal/material_docking_utils;
import material/extra/docking_ui/internal/material_docking_panels;
// import material/extra/docking_ui/internal/material_docking_drop;


export {
	// NOTE:
	// - MDockingAreas can act as a "dockable MCols" or "MLines" (by "isColumn")
	// - each MDockingArea has unique id
	// - different MDockingAreas can have the same groupName
	// - the groupNames are used by MDockingPanel in the "allowedGroups" field
	// - each panel can have a vertical or horizontal orientation, but its size is defined by default as vertical
	// - when docked on cols a panel will be shown as vertical, when on lines as horizontal
	// - when mobile a panel will be vertical, but you can flip it with MDockingMobileHorizontal() style
	// - example in flow9/lib/material/tests/test_docking_ui.flow

	MDockingArea(isColumn : bool, state : MDockingState, groupName : string, areaId : int, style : [MDockingStyle]) -> Material;
}

// Let's think about dockable/resizable MCols with inside MLines of panels, 
// the logic can be swithched and we get MLines with inside MCols 
MDockingArea(isColumn : bool, state : MDockingState, groupName : string, areaId : int, style : [MDockingStyle]) -> Material {
	MShowLazy(fselect(state.size, FLift(\sz -> sz != [])), 
		\ -> {
			manager = state.manager;
			itemId = makeTropicTag(manager);
			zorder = getValue(manager.manager.zorder);
			contentA = getValue(state.content);
			sizeA = getValue(state.size);

			// Drop
			onDragging = manager.manager.dragging;
			onDrop = make(-1);
			order = make([0, 0]);
			dockedPanelsGrid = make([[]]);
			isDockingCol = make(true);
			isRow = make(false);
			lastDropSize = make(TEmpty());

			// Drop Info
			dropInfo = 
				MDockingDropInfo(
					areaId,
					groupName,
					onDrop, 
					order, 
					dockedPanelsGrid, 
					isDockingCol, 
					isRow, 
					lastDropSize
				);

			// Inactive drop bar
			dropSize = extractStruct(style, MDockingDropSize(dockingDropSize)).size;
			colSize = if (isColumn) TFillWY(dropSize) else TFillXH(dropSize);
			inactiveDropLine = TRectangle([MFill(MGrey(300))], colSize);

			areaGridT = fselect(state.dock, FLift(\dockA -> extractAreaGridById(dockA, areaId)));
			WA = map(contentA,\c -> make(0.0));
			HA = map(contentA,\c -> make(0.0));

			MSelect(areaGridT, \areaGrid : [[int]] -> {
				next(dockedPanelsGrid, areaGrid);
				mapi(areaGrid, \colId, colA -> {
					atLeastOneEnabledInCol = fold(colA, false, \acc, a -> acc || getValue(getValue(state.enabled)[a]));
					atLeastOneEnabled = fold(areaGrid, false, \acc, singleColA -> acc || fold(singleColA, false, \acc2, a -> acc2 || getValue(getValue(state.enabled)[a])));
					enabledColT = fmerge(map(colA, \c -> getValue(state.enabled)[c]));
					sideExpandedColT = fmerge(map(colA, \c -> getValue(state.sideExpanded)[c]));
		
					// Enable a single col					
					MSelect3(
						manager.white, 
						enabledColT,
						sideExpandedColT, 
						\w, e, __ -> {
							containsDark = fold(colA, false, \acc, a -> acc || contains(getValue(state.style)[a], MDockingForceDarkTheme()));
							containsLight = fold(colA, false, \acc, a -> acc || contains(getValue(state.style)[a], MDockingForceLightTheme()));
							colTheme = if (containsDark) false else if (containsLight) true else w;
							// println(" > DRAW - docked lines of panels - " + i2s(areaId) + "      - " + toString(colA));
				
							if (atLeastOneEnabledInCol) {
								// Single resizable column of docked panels with dragging handles and drop areas
								makeDockedPanelA(
									isColumn,
									dropInfo,
									state,
									WA,
									HA,
									areaGrid,
									colA,
									colId,
									colTheme,
									style
								);

							} else if (atLeastOneEnabled) {
								TEmpty();
							} else {
								// NO PANELS ENABLED
								dockingDropLine(isColumn, isColumn, dropInfo, state, [0, 0], false, inactiveDropLine, colSize, colSize, true, style);
							}
						}
					);


				}) |> (\f -> if (isColumn) MColsA(f) else MLines(f))

				// NO PANELS DOCKED
				|> (\f -> if (areaGrid != []) f 
					else dockingDropLine(isColumn, isColumn, dropInfo, state, [0, 0], false, inactiveDropLine, colSize, colSize, true, style));
				
			});

		} 
	);
}



makeDockedPanelA(
	isColumn : bool,
	dropInfo : MDockingDropInfo,
	state : MDockingState,
	WA : [DynamicBehaviour<double>], 
	HA : [DynamicBehaviour<double>], 
	areaGrid : [[int]],
	colA : [int], 
	colId : int,
	light : bool, 
	style : [MDockingStyle]
) -> Material {

	// println("  ------------- > makeResizableColFn " + i2s(areaId));

	manager = state.manager;
	onDragging = manager.manager.dragging;
	zorder = getValue(manager.manager.zorder);
	groupA = state.group;
	contentA = getValue(state.content);

	// Drop info
	areaId = dropInfo.areaId;
	groupName = dropInfo.groupName; 

	dockedSizeA = getValue(state.dockedSize);
	dropSize = extractStruct(style, MDockingDropSize(dockingDropSize)).size;
	dragSize = dockingDragSize;
	handleHeight = dropSize;
	rowSize = if (isColumn) TFillXH(dropSize) else TFillWY(dropSize);
	colSize = if (isColumn) TFillWY(dropSize) else TFillXH(dropSize);
	inactiveDropLine = TRectangle([MFill(MGrey(300))], rowSize);

	fillHeightArea = contains(style, MDockingFillSpace());
	fillLast = contains(style, MDockingColFillLast());
			
	dontResize  = contains(style, MDockingDontResize());
	dontSideExpand = contains(style, MDockingDontCollapseColumn());

	sideExpandedA = map(contentA,\c -> make(false));

	lastPanel = length(colA) - 1;
	lastCol = length(areaGrid) - 1;

	// mouseXyLocalR = make(zeroPoint);
	maxPanelSize = TSizeOf(TGroup(map(colA, \s -> if (dockedSizeA != []) dockedSizeA[s] else TEmpty())));
	dontResizeAll = fold(colA, true, \acc, p -> acc && contains(getValue(state.style)[p], MDockingDontResize()));
	dontSideExpandPanel = fold(colA, false, \acc, p -> acc || contains(getValue(state.style)[p], MDockingDontCollapsePanel()));

	panelsWidthA = map(colA, \s -> getTropicMetrics(getValue(state.size)[s]).width);
	dockedWidthA = map(colA, \s ->getTropicMetrics(getValue(state.dockedSize)[s]).width);
	// mobileWidthA = map(colA, \s -> getTropicMetrics(getValue(state.mobileSize)[s]).width);

	maxPanelsWidth = either(maxA(panelsWidthA), -doubleMax);
	maxDockedWidth = either(maxA(dockedWidthA), -doubleMax);
	// se = getValue(getValue(state.sideExpanded)[colA[0]]);
		
	colWB = make(maxDockedWidth);

	if (getValue(WA[colId]) == 0.0) next(WA[colId], maxPanelsWidth);
	if (getValue(HA[colId]) == 0.0) next(HA[colId], maxPanelsWidth);

	colHeightB = make(0.0);

	MFrame(0.0, 0.0, [MFill(areaBgColorFn(light, style))], 
		MGroup2(							
			TFillY() |> (\f -> MAttachHeight(f, colHeightB)),  // Get column height
			MLines2(	
				if ((isColumn && !dontSideExpand && !dontSideExpandPanel))  makeSideExpanderBtn(state, colA, light, style) else TEmpty(),  // Side expander button
				// Docked panels			
				mapi(colA, \rowId, panelId -> {
					
					// Panel position
					isFirstPanel = panelId == firstElement(colA, intMax);
					isLastPanel = panelId == lastElement(colA, intMax);
					lastPanelId = length(colA) - 1;

					// Fill panel order
					fillBottom = rowId == lastPanel; 	// fill last panel --default
					fillTop = rowId == 0; 			// fill first panel
					fillPanelOrder = if (fillLast) fillBottom else fillTop;
					fillPanelOrderId = if (fillLast) lastPanel else 0;

					panelStyle = getValue(state.style)[panelId];
					fillHeight = fillHeightArea || contains(panelStyle, MDockingFillSpace());  // NOTE: should be handled

					// Expanded
					expanded = getValue(state.expanded)[panelId];
					sideExpanded = getValue(state.sideExpanded)[panelId];
					enabled = getValue(state.enabled)[panelId];

					// Panel size
					dockedSize = getValue(state.dockedSize)[panelId];
					pSize = getValue(state.size)[panelId];

					pWidth = getTropicMetrics(dockedSize).width;
					pHeight = if (isLastPanel) getTropicMetrics(pSize).height else getTropicMetrics(dockedSize).height;

					// rowHB = make(pHeight + dockingBarHeight);
					rowHB = make(pHeight);
					pHB = make(0.0);

					// Container size
					WH = if (isColumn) make(WidthHeight(pWidth, pHeight)) else make(WidthHeight(pHeight, pWidth));

					otherPanelsH = foldi(colA, 0.0, \k, acc, pId -> {
						if (k < (length(colA) )) {
							if (k != fillPanelOrderId) {
								sz = if (isColumn) {
									getTropicMetrics(getValue(state.dockedSize)[pId]).height // + dockingDragSize + dockingBarHeight
								} else {
									getTropicMetrics(getValue(state.dockedSize)[pId]).width // + dockingDragSize
								}
								acc + sz
								// if (getValue(expanded)) /*dockingBarHeight + */ dockingDragSize else if (getValue(enabled)) 0.0 else  sz;
							} else acc
						} else acc;
					});

				MConstruct([
					// makeSubscribe(rowHB, \rh -> {
					// 		println(i2s(panelId) + "- rowHB: " +  toString(rh));
					// }),
					makeSubscribe(sideExpanded, \se -> {
						if (se) {
							nextDistinct(rowHB, pHeight);
							nextDistinct(colWB, pWidth);
							// Also expand panels in col
							iter(colA, \pId -> nextDistinct(getValue(state.expanded)[pId], se));
						} else {
							nextDistinct(rowHB, dockingBarHeight);
							nextDistinct(colWB, dockingSideCollapsedSize);
						}
					}),
					makeSubscribe2(expanded, \e -> {

						rH = if (fillPanelOrder) {
							getValue(colHeightB) - sideExpanderButtonSize - foldi(colA, 0.0, \k, acc, pId -> {
								if (k < (length(colA) )) {if (k != fillPanelOrderId) acc + getTropicMetrics(getValue(state.size)[pId]).height + dockingDragSize else acc} else acc;
							}) 
						} else pHeight;

						// println(" panel" + i2s(panelId) + " - h: " + d2s(rH) );
						// if (e) nextDistinct(rowHB, rH) else nextDistinct(rowHB, dockingBarHeight);
						nextDistinct(rowHB, if (e) getTropicMetrics(getValue(state.size)[panelId]).height else dockingBarHeight);
					}),
					makeSubscribe(enabled, \e -> {
						if (!e) next(state.dock, mapi(getValue(state.dock), \j, item -> if (j == panelId) [-1, item[1], item[2]] else item)); //undock
					}),
					// Fill correction
					makeSubscribe(
						// Update only the first time
						ftransistor(
							fselect(colHeightB, FLift(\ch -> {
								// getTropicMetrics(getValue(state.dockedSize)[panelId]).height == getValue(rowHB)			
								// Fill if docking state is not cached
								savedString = getKeyValue(state.keyGroupName |> addDockingSuffix, "");
								savedString == ""
							})),
							colHeightB
						), \totColH -> {
							if (fillPanelOrder) {
								availableColHeight = totColH - sideExpanderButtonSize /*- dockingDragSize*/ - dockingBarHeight - otherPanelsH;
								// Fill height
								if (totColH > otherPanelsH) next(rowHB, availableColHeight);
							} 
						}
					)
					],
					makeDockedPanel(
						state, 
						panelId, 
						Pair(colId, rowId), 
						colA, 
						colHeightB, 
						dropInfo, 
						isColumn, 
						fillPanelOrder, 
						style, 
						dropSize, 
						sideExpandedA[colId], 
						zorder
					) 	
				) 				
				|> (\f ->
						// Wrapper with drop area and resize handle for a row
						resizePanelH(f, isColumn, dropInfo, state, rowHB, panelId, colA, colId, rowId, light, style)
					) |> showIf(dockedSizeA != [])

				}) |> (\f -> if (isColumn) MLines(f) else MColsA(f))		
			)
		) 
	) 	
	|> (\f ->
		// Wrapper with drop area and resize handle for a col
		resizeAreaW(f, isColumn, dropInfo, state, colWB, areaGrid, colA, colId, light, style)
	)
}


resizePanelH(
	box : Material, 
	isColumn : bool,
	dropInfo : MDockingDropInfo,
	state : MDockingState,
	sizeB : DynamicBehaviour<double>, 
	panelId : int, 
	parentA : [int], 
	colId : int,
	rowId : int,		
	light : bool,
	style : [MDockingStyle], 
) -> Material {
	manager = state.manager;
	itemId = makeTropicTag(manager);
	zorder = getValue(manager.manager.zorder);
	pstyle = getValue(state.style)[panelId];
	groupA = state.group;

	// Size	
	sideCollapsedSize = dockingSideCollapsedSize;
	panelDockedSize = getValue(state.dockedSize)[panelId];
	pWidth = getTropicMetrics(panelDockedSize).width;
	pHeight = getTropicMetrics(panelDockedSize).height;

	// Container size
	WH = if (isColumn) make(WidthHeight(pWidth, pHeight)) else make(WidthHeight(pHeight, pWidth));

	// Order
	isFirstPanel = panelId == firstElement(parentA, intMax);
	isLastPanel = panelId == lastElement(parentA, intMax);
	lastPanelId = length(parentA) - 1;

	fillLast = contains(style, MDockingColFillLast());
	fillPanelOrderId = if (fillLast) lastPanelId else 0;

	resizePressed = make(false);
	isResizing = make(false);
	isHovering = make(false);
	mouseXyLocal = make(zeroPoint);
	
	// Expanded
	expanded = getValue(state.expanded)[panelId];
	sideExpanded = getValue(state.sideExpanded)[panelId];
	enabled = getValue(state.enabled)[panelId];

	se = getValue(getValue(state.sideExpanded)[parentA[0]]);
	collapsedSepColor = MGrey(400);

	isToolbarItem = isSameStructType(getValue(state.content)[panelId][0], MDockingPanelToolbarItem("", []));
	fillHeightArea = contains(style, MDockingFillSpace());
	fillHeight = fillHeightArea || contains(pstyle, MDockingFillSpace());
	isBottomLine = contains(style, MDockingBottomtLines());
	dontScroll  = contains(style, MDockingDontScroll());	
	dontResizeAll = fold(parentA, true, \acc, p -> acc || contains(getValue(state.style)[p], MDockingDontResize()));
	dontResize = isLastPanel;

	// println(" > DRAW - Container R - " + i2s(panelId) /*+ "      - " + toString(parentA)*/);

	// Rows separator with drop
	dragSize = dockingDragSize;
	dragSizeBig = dockingHelperDragSize;
	dragHandleSizeBig = makeHSize(dragSizeBig, isColumn);
	dragHandleSize = makeHSize(dockingDragSize, isColumn);

	rowFiller = if (isColumn) TFillY() else TFillX();

	makeSeparator = \resizeW : bool, order : [int], resize : bool, endpoint : bool -> {
		resizeHelper = MShowLazy(fmin(expanded, sideExpanded), \ -> dockingResizeLine(isColumn, resizeW, dontResize, resizePressed, dragHandleSizeBig, style)) |> showIf(resize);
		dockingDropLine(isColumn, resizeW, dropInfo, state, order, true, resizeHelper, dragHandleSize, dragHandleSizeBig, endpoint, style);
	}

	rowsWithHandles = 
		if (isColumn) {
			// Resize H
			MLines( 
				if (rowId == 0 && length(parentA) == 1)
				[
					makeSeparator(false, [colId, rowId], false, true /*endpoint*/), 		// top
					rowFiller,
					makeSeparator(false, [colId, rowId + 1 ], false, false), 				// bottom
				]
				else if (rowId == 0 && length(parentA) != 1)
				[
					makeSeparator(false, [colId, rowId], false, true /*endpoint*/),
					rowFiller,
					makeSeparator(false, [colId, rowId + 1], true /*resize*/, false),
				]
				else if (rowId ==  length(parentA) - 1 && length(parentA) != 1)
				[
					rowFiller,
					makeSeparator(false, [colId, rowId + 1 ], false, false),
				]
				else
				[	
					rowFiller,
					makeSeparator(false, [colId, rowId + 1], true /*resize*/, false),
				]
			)
		} else {
			// Resize W
			MCols(
				//  if (rowId == 0 && length(parentA) == 1)
				// [
				// 	if (isBottomLine) dLine(rowId + 1, false) else dLine(rowId, true),   //top
				// 	rowFiller,
				// 	if (isBottomLine) dLine(rowId, true) else dLine(rowId + 1, false) ,  //bottom
				// ]
				// else if (rowId == 0 && length(parentA) != 1)
				// [
				// 	if (isBottomLine) dLine(rowId + 1, true) else dLine(rowId, true),
				// 	rowFiller,
				// 	if (isBottomLine) TEmpty() else makeHResizeSeparator(rowId + 1),
				// ]
				// else if (rowId ==  length(parentA) - 1 && length(parentA) != 1)
				// [
				// 	if (!isBottomLine) TEmpty() else makeHResizeSeparator(rowId),
				// 	rowFiller,
				// 	if (!isBottomLine) dLine(rowId + 1, false) else dLine(rowId, true),
				// ]
				// else
				[
					makeSeparator(true, [colId, rowId], false, true /*endpoint*/), 
					rowFiller,
					makeSeparator(true, [colId, rowId + 1], true /*resize*/, false),
				]
			)
		}

	scrollBox = if (dontScroll) MCropSize(TFillXY(), box) else MScroll(box, TFillXY(), []);


	addRowSeparators = \f : Material ->
		[
			f,
			if (isLastPanel) TEmpty() else makeSeparatorBar(!isColumn, state, panelId, dontResize, light, style)    // bottom/dx
		] |> (\r -> if (isColumn) MLines(r) else MCols(r));

	addDragAndDropHelperGroup = \ f : Material ->  MGroup2(f, rowsWithHandles);

	MConstruct([
		makeSubscribe2(isResizing, \rs -> { 
			if (!rs) {
				// println("update H -" + i2s(panelId) + "- "+ toString(getValue(sizeB)));
				if (isColumn) updateTH(state.dockedSize, panelId,  getValue(sizeB))
					else updateTW(state.dockedSize, panelId,  getValue(sizeB));
			}
		}),
		makeSubscribe(resizePressed, \p -> {
			if (p) {
				addMInteractionItemId(manager, itemId);
				next(isResizing, true);
			} else {
				if (getValue(isResizing)) next(isResizing, false);
			}
		}),
		makeSubscribe(mouseXyLocal, \mxy -> {
			if (isCurrentMInteractionItemId(manager, itemId) && getValue(isResizing)) {
				blockOtherMInteractionItemIds(manager, itemId);	

				if (isColumn) nextDistinct(sizeB, max(dockingBarHeight, mxy.y))
					else nextDistinct(sizeB, max(mxy.x, dockingBarHeight));
				// UPDATE DOCKED SIZE
				nextDistinct(state.dockedSize, replace(getValue(state.dockedSize), panelId, TFixed(getValue(WH).width, getValue(WH).height)));
			};
		})
	],
	MInteractive([
		TMouseXY(mouseXyLocal)
		],
		MAvailable(	
			scrollBox,
			if (isColumn) {
				if (isLastPanel /*|| isFirstPanel*/) TGroup2(TFillXY(), TSelect(fselect(sizeB,FLift(\h -> h /*+ dockingDragSize + dockingBarHeight*/)), \hh  -> TFillXH(hh))) 
				else  TSelect(fselect(sizeB,FLift(\h -> h /*+ dockingDragSize + dockingBarHeight*/)), \hh  -> TFillXH(hh))
			} else {
				if (isLastPanel /*|| isFirstPanel*/) TGroup2(TFillXY(), TSelect(fselect(sizeB, FLift(\w -> w + dockingDragSize + dockingBarHeight)), \ww  -> TFillWY(ww)))
					else TSelect(fselect(sizeB,FLift(\w -> w /*+ dockingDragSize + dockingBarHeight*/)), \ww  -> TFillWY(ww))
			}
		)	
		// Keep separator's size out of MAvailable
		|> addRowSeparators
		|> (\t -> 
			MCopySize(t, \sz -> 
				MAvailable(
					TRectangle([MFill(MWhite()), FillOpacity(dockingHelperDragOpacity)], TFillXY()) |> addDragAndDropHelperGroup,
					sz
				), 
			true
			)
		)
	))
}


resizeAreaW(
	box : Material, 
	isColumn : bool,
	dropInfo : MDockingDropInfo,
	state : MDockingState, 
	sizeB : DynamicBehaviour<double>,
	areaGrid : [[int]],
	colA : [int], 
	colId : int,
	light : bool,
	style : [MDockingStyle]
) -> Material {

	manager = state.manager;
	itemId = makeTropicTag(manager);
	zorder = getValue(manager.manager.zorder);

	isBottomLine = contains(style, MDockingBottomtLines());
	isRightCol  = contains(style, MDockingRightCols());
	dontScroll  = contains(style, MDockingDontScroll());
	dontResizeAll = fold(colA, true, \acc, p -> acc && contains(getValue(state.style)[p], MDockingDontResize()));
	dontResizeCol  = contains(style, MDockingDontResize());
	dontResize = dontResizeCol || dontResizeAll;

	resizePressed = make(false);
	isResizing = make(false);
	mouseXyLocal = make(zeroPoint);
	currXy = make(zeroPoint);
	panelWH = makeWH();
	startingValueB = make(0.0);
	firstPanelId = firstElement(colA, 0);

	panelsWidthA = map(colA, \s -> getTropicMetrics(getValue(state.size)[s]).width);
	maxPanelsWidth = either(maxA(panelsWidthA), -doubleMax);
	se = getValue(getValue(state.sideExpanded)[firstPanelId]);

	numOfCols = length(areaGrid);
	lastCol = numOfCols - 1;

	isReversed = isRightCol || isBottomLine;
	isEdge = colId == numOfCols - 1;
	isEdgeReverse = colId == 0 && isReversed;

	// Cols separator with drop
	dragSizeBig = dockingHelperDragSize;
	dragHandleSizeBig = makeVSize(dragSizeBig, isColumn);
	dragHandleSize = makeVSize(dockingDragSize, isColumn);

	colFiller = if (isColumn) TFillX() else TFillY();
	corrSide = if (isReversed) -1.0 else 1.0;

	makeSeparator = \resizeW : bool, order : [int], resize : bool, endpoint : bool -> {
		resizeHelper = dockingResizeLine(isColumn, resizeW, dontResize, resizePressed, dragHandleSizeBig, style)  |> showIf(resize);
		dockingDropLine(isColumn, resizeW, dropInfo, state, order, false, resizeHelper, dragHandleSize, dragHandleSizeBig, endpoint, style);
	} 
	
	colWithHandles =
	if (isColumn) {
		// Resize W
		MCols(
			if (colId == 0 && numOfCols == 1)
			[
				makeSeparator(true, [colId, 0], isRightCol, !isRightCol), // sx
				colFiller,
				makeSeparator(true, [colId + 1, 0], !isRightCol, isRightCol), // dx
			]
			else if (colId == 0 && numOfCols != 1)
			[
				makeSeparator(true, [colId, 0], isRightCol, !isRightCol),
				colFiller,
				if (isRightCol) TEmpty() else makeSeparator(true, [colId + 1, 0], true, false)
			]
			else if (colId != 0 && colId == numOfCols - 1)
			[
				if (isRightCol) makeSeparator(true, [colId, 0], true, false) else  TEmpty(),
				colFiller,
				makeSeparator(true, [colId + 1, 0], !isRightCol, isRightCol),
			]
			else
			[
				if (isRightCol) makeSeparator(true, [colId, 0], true, false) else  TEmpty(),
				colFiller,
				if (isRightCol) TEmpty() else makeSeparator(true, [colId + 1, 0], true, false)
			]
		)
	} else {
		// Resize H
		MLines(
			if (colId == 0 && numOfCols == 1)
			[
				makeSeparator(false, [colId, 0], isBottomLine, !isBottomLine),
				colFiller,
				makeSeparator(false, [colId + 1, 0], !isBottomLine, isBottomLine),
			]
			else if (colId == 0 && numOfCols != 1)
			[
				makeSeparator(false, [colId, 0], isBottomLine, !isBottomLine),
				colFiller,
				if (isBottomLine) TEmpty() else makeSeparator(false, [colId + 1, 0], true, false)
			]
			else if (colId != 0 && colId == numOfCols - 1)
			[
				if (isBottomLine) makeSeparator(false, [colId, 0], true, false) else  TEmpty(),
				colFiller,
				makeSeparator(false, [colId + 1, 0], !isBottomLine, isBottomLine),
			]
			else
			[
				if (isBottomLine) makeSeparator(false, [colId, 0], true, false) else  TEmpty(),
				colFiller,
				if (isBottomLine) TEmpty() else makeSeparator(false, [colId + 1, 0], true, false)
			]
		)
	}

	scrollBox = if (dontScroll) MCropSize(TFillXY(), box) else MScroll(box, TFillXY(), []);

	// addColSeparators = \ f : Material ->
	// 	[
	// 		if (!isRightCol || dontResize) TEmpty() else makeSeparatorBar(isColumn, state, firstPanelId, dontResize, light, style),	// sx
	// 		f,
	// 		if (isRightCol || dontResize) TEmpty() else makeSeparatorBar(isColumn, state, firstPanelId, dontResize, light, style)  	// dx
	// 	] 
	// 	|> (\c -> if (isColumn) MCols(c) else MLines(c));


	addColSeparators = \ f : Material ->
		if (isColumn) {
			MColsA([
				if (isEdgeReverse && dontResize) TEmpty() else  {
					if (isRightCol) makeSeparatorBar(isColumn, state, firstPanelId, dontResize, light, style) else TEmpty()	// sx
				},
				f,
				if (isEdge && dontResize) TEmpty() else {
					if (isRightCol) TEmpty() else makeSeparatorBar(isColumn, state, firstPanelId, dontResize, light, style)  	// dx
				}
			])
		} else {
			MLines([
				if (isEdgeReverse && dontResize) TEmpty() else  {
					if (isBottomLine)  makeSeparatorBar(isColumn, state, firstPanelId, dontResize, light, style) else TEmpty()  // top
				},	
				f,
				if (isEdge && dontResize) TEmpty() else {
					if (isBottomLine) TEmpty() else makeSeparatorBar(isColumn, state, firstPanelId, dontResize, light, style)  // bottom
				}	
			])
		}

	addDragAndDropHelperGroup = \ f : Material ->  MGroup2(f, colWithHandles);

	MConstruct([
		// makeSubscribe(sizeB, \s -> { 
		// 	println("COL SIDE EXPANDED : ");
		// 	println(s);
		// }),
		makeSubscribe2(isResizing, \rs -> { 
			if (!rs) {
				// println("update Ws -" + i2s(colId) + "- "+ toString(getValue(sizeB)));
				// Update all docked panels in a col
				iter(colA, \pId -> {
					if (isColumn) updateTW(state.dockedSize, pId,  getValue(sizeB))
						else updateTH(state.dockedSize, pId,  getValue(sizeB));
				});
			}
		}),
		makeSubscribe(resizePressed, \p -> {
			if (p) {
				addMInteractionItemId(manager, itemId);
				next(currXy, getValue(state.mouseXy));
				next(startingValueB, getValue(sizeB));
				next(panelWH, WidthHeight(getValue(sizeB), getValue(sizeB)));
				next(isResizing, true);
			} else {
				if (getValue(isResizing)) next(isResizing, false);
			}
		}),
		makeSubscribe(state.mouseXy, \mxy -> {
			if (isCurrentMInteractionItemId(manager, itemId) && getValue(isResizing)) {
				rtlCorrection = if (getDefaultRtl()) -1.0 else 1.0; // correction the direction of width changing depending of rtl mode
				blockOtherMInteractionItemIds(manager, itemId);
				if (isColumn) {
					if (isRightCol) nextDistinct(sizeB, max(maxPanelsWidth, getValue(startingValueB) + rtlCorrection * (getValue(currXy).x - mxy.x)))
						else nextDistinct(sizeB, max(maxPanelsWidth, getValue(startingValueB) - rtlCorrection * (getValue(currXy).x - mxy.x)));
				} else {
					if (isBottomLine) nextDistinct(sizeB, max(dockingItemHeight, getValue(panelWH).height + (getValue(currXy).y - mxy.y)))
						else nextDistinct(sizeB, max(dockingItemHeight, getValue(panelWH).height - (getValue(currXy).y - mxy.y)));
				}
			};
		}),
		// \ -> \-> println("dispose" + i2s(areaId)),
	],
	MInteractive([
			TMouseXY(mouseXyLocal)
		],
		MAvailable(
			scrollBox,
			if (isColumn) {
				TSelect(sizeB, \w  -> TFillWY(w));
			} else {
				TSelect(sizeB, \h  -> TFillXH(h));
			}
		) 
		// Keep separator's size out of MAvailable
		|> addColSeparators
		|> (\t -> 
			MCopySize(t, \sz -> 
				MAvailable(
					TRectangle([MFill(MBlack()), FillOpacity(dockingHelperDragOpacity)], TFillXY()) |> addDragAndDropHelperGroup,
					sz
				), 
			true
			)
		)

	));
}