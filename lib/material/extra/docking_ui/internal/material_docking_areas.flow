import material/material_ui;
import material/extra/docking_ui/internal/material_docking_utils;
import material/extra/docking_ui/internal/material_docking_drop;
import material/extra/docking_ui/internal/material_docking_panels;


export {
	// NOTE:
	// - MDockingAreas can act as a "dockable MCols" or "MLines" (by "isColumn")
	// - each MDockingArea has unique id
	// - different MDockingAreas can have the same groupName
	// - the groupNames are used by MDockingPanel in the "allowedGroups" field
	// - each panel can have a vertical or horizontal orientation, but its size is defined by default as vertical
	// - when docked on cols a panel will be shown as vertical, when on lines as horizontal
	// - when mobile a panel will be vertical, but you can flip it with MDockingMobileHorizontal() style
	// - example in flow9/lib/material/tests/test_docking_ui.flow

	MDockingArea(isColumn : bool, state : MDockingState, groupName : string, areaId : int, style : [MDockingStyle]) -> Material;
}

// Let's think about dockable/resizable MCols with inside MLines of panels, 
// the logic can be swithched and we get MLines with inside MCols 
MDockingArea(isColumn : bool, state : MDockingState, groupName : string, areaId : int, style : [MDockingStyle]) -> Material {

	MShowLazy(fselect(state.size, FLift(\sz -> sz != [])), 
		\ -> {

			manager = state.manager;
			itemId = makeTropicTag(manager);              //
			zorder = getValue(manager.manager.zorder);
			contentA = getValue(state.content);
			sizeA = getValue(state.size);

			// Drop
			onDragging = manager.manager.dragging;
			onDrop = make(-1);
			order = make([0, 0]);
			dockedPanelsGrid = make([[]]);
			isDockingCol = make(true);
			isRow = make(false);
			lastDropSize = make(TEmpty());

			// Drop Info
			dropInfo = 
				MDockingDropInfo(
					areaId,
					groupName,
					onDrop, 
					order, 
					dockedPanelsGrid, 
					isDockingCol, 
					isRow, 
					lastDropSize
				);

			// Inactive drop bar
			dropSize = extractStruct(style, MDockingDropSize(dockingDropSize)).size;
			colSize = if (isColumn) TFillWY(dropSize) else TFillXH(dropSize);
			inactiveDropLine = TRectangle([MFill(MGrey(300))], colSize);

			redraw = make(false);
			WA = map(contentA,\c -> make(0.0));
			HA = map(contentA,\c -> make(0.0));

			MSelect2(
				redraw,   // check if needed
				fselect(state.dock, FLift(\dockA -> {
					// println(dockA);
					extractDockedPanelsId(dockA, areaId)
				})), \r, areaGrid : [[int]] -> {


				// areaSize = MDockingAreaSize(
				// 	[],
				// 	make(map(areaGrid, \__ -> 0.0)),
				// 	make(map(areaGrid, \c -> map(c, \p -> 0.0)))
				// );
				// println("areaSize");
				// println(areaSize);

				println(" > DRAW - DockingArea - " + i2s(areaId)+ "    - " + toString(areaGrid));
				// println(" > DRAW - DockingArea - REDRAW or DOCKA:  " +  b2s(r) + "    - " + toString(areaGrid));
				// println("areaGrid");
				// println(extractDockedPanelsId(getValue(state.dock), areaId));
				// Get Panel
				// areaGrid = extractDockedPanelsId(d, areaId);

				next(dockedPanelsGrid, areaGrid);

				mapi(areaGrid, \colId, colA -> {

					atLeastOneEnabledInCol = fold(colA, false, \acc, a -> acc || getValue(getValue(state.enabled)[a]));
					atLeastOneEnabled = fold(areaGrid, false, \acc, singleColA -> acc || fold(singleColA, false, \acc2, a -> acc2 || getValue(getValue(state.enabled)[a])));
					enabledCol = fmerge(map(colA, \sca -> getValue(state.enabled)[sca]));
		
					// Enable a single col					
					MSelect(enabledCol, \e -> {							
						
						if (atLeastOneEnabledInCol) {

							// Single resizable column of docked panels with dragging handles and drop areas
							makeDockedPanelA(isColumn, dropInfo, state, groupName, areaId, redraw, WA, HA, areaGrid, colA, colId, style);

						} else if (atLeastOneEnabled) {
							TEmpty();
						} else {
							// NO PANELS ENABLED
							dockingDropLine(isColumn, 0, dropInfo, state, [0, 0],  inactiveDropLine,  true, zorder, style);
						}
					});

				}) |> (\f -> if (isColumn) MColsA(f) else MLines(f))

				// NO PANELS DOCKED
				|> (\f -> if (areaGrid != []) f 
					else dockingDropLine(isColumn, 0, dropInfo, state, [0, 0], inactiveDropLine,  true, zorder, style));
				
			});

		} 
	);
}


makeDockedPanelA(
	isColumn : bool,
	dropInfo : MDockingDropInfo,
	state : MDockingState, 
	groupName : string, 
	areaId : int,
	redraw : DynamicBehaviour<bool>,
	WA : [DynamicBehaviour<double>], 
	HA : [DynamicBehaviour<double>], 
	areaGrid : [[int]],
	colA : [int], 
	colId : int, 
	style : [MDockingStyle]
) -> Material {

	println("  ------------- > makeResizableColFn " + i2s(areaId));

					manager = state.manager;
					itemId = makeTropicTag(manager);

	onDragging = manager.manager.dragging;
	zorder = getValue(manager.manager.zorder);
	groupA = state.group;

	contentA = getValue(state.content);

	dockedSizeA = getValue(state.dockedSize);
	dropSize = extractStruct(style, MDockingDropSize(dockingDropSize)).size;
	dragSize = dockingDragSize;
	handleHeight = dropSize;
	rowSize = if (isColumn) TFillXH(dropSize) else TFillWY(dropSize);
	colSize = if (isColumn) TFillWY(dropSize) else TFillXH(dropSize);
	inactiveDropLine = TRectangle([MFill(MGrey(300))], rowSize);

	fillHeightArea = contains(style, MDockingFillSpace());
	stickBottomPanels = contains(style, MDockingColStickBottom());
			
	dontResize  = contains(style, MDockingDontResize());
	dontSideExpand = contains(style, MDockingDontCollapseColumn());

	sideExpandedA = map(contentA,\c -> make(false));


		println(" > DRAW - docked lines of panels - " + i2s(areaId) + "      - " + toString(colA));

		lastPanel = length(colA) - 1;
		lastCol = length(areaGrid) - 1;

		mouseXyLocalR = make(zeroPoint);
		maxPanelSize = TSizeOf(TGroup(map(colA, \s -> if (dockedSizeA != []) dockedSizeA[s] else TEmpty())));
		dontResizeAll = fold(colA, true, \acc, p -> acc && contains(getValue(state.style)[p], MDockingDontResize()));
		dontSideExpandPanel = fold(colA, false, \acc, p -> acc || contains(getValue(state.style)[p], MDockingDontCollapsePanel()));

		panelsWidthA = map(colA, \s -> getTropicMetrics(getValue(state.size)[s]).width);
		dockedWidthA = map(colA, \s -> getTropicMetrics(getValue(state.dockedSize)[s]).width);
		mobileWidthA = map(colA, \s -> getTropicMetrics(getValue(state.mobileSize)[s]).width);

		maxPanelsWidth = either(maxA(panelsWidthA), -doubleMax);
		maxDockedWidth = either(maxA(dockedWidthA), -doubleMax);
		maxMobileWidth = either(maxA(mobileWidthA), -doubleMax);
		se = getValue(getValue(state.sideExpanded)[colA[0]]);

		if (getValue(WA[colId]) == 0.0) next(WA[colId], maxPanelsWidth);
		if (getValue(HA[colId]) == 0.0) next(HA[colId], maxPanelsWidth);

		colHeightB = make(0.0);



		// Dropping line for rows
		makeInnerDroppingLine = \rId : int, c : MColor, s : int -> {
			dragCorrection = if  ((dontResize || dontResizeAll) && length(areaGrid) == 1) 0.0 else dragSize;
			// separatorSize = if (isColumn) {
			// 	if (isRightCol) {
			// 		if (colId != lastCol) TSubtractGroup2(rowSize, TFixed(dropSize - dragSize, 0.0)) else TSubtractGroup2(rowSize, TFixed(dropSize + dropSize - dragCorrection, 0.0));
			// 	} else {
			// 		if (colId != 0) TSubtractGroup2(rowSize, TFixed(dropSize - dragSize, 0.0)) else TSubtractGroup2(rowSize, TFixed(dropSize + dropSize - dragCorrection, 0.0));
			// 	}
			// } else {
			// 	TFillWY(dropSize);
			// }

			separatorSize = if (isColumn) {
				TFillXH(dropSize);
			} else {
				TFillWY(dropSize);
			}

			defRow = true;
			defDockingCol = true;

			// MSelect(onDragging, \dr -> {
			// 	if ((dr >= 0) && (dr < length(getValue(groupA))) && (contains(getValue(groupA)[dr], groupName))) {

			// 		if (isColumn) {
			// 			if (isSameStructType(getValue(state.content)[dr][0], MDockingPanelToolbarItem("", []))) {
			// 					dockingDropLine(dropInfo, state, [colId, rId], areaId, groupName, c, separatorSize, defRow, defDockingCol, zorder)
			// 			} else {
			// 				if (isRightCol) {
			// 					MOffset(dropSize - dragSize, 0.0, dockingDropLine(dropInfo, state, [colId, rId], areaId, groupName, c, separatorSize, defRow, defDockingCol, zorder));
			// 				} else {

			// 					dockingDropLine(dropInfo, state, [colId, rId], areaId, groupName, c, separatorSize, defRow, defDockingCol, zorder)
			// 						|> (\m -> MOffset(if (colId == 0) dropSize else 0.0, 0.0, m));
			// 					// if (colId == 0)
			// 					// 	MOffset(dropSize, 0.0, dockingDropLine(dropInfo, state, [colId, rId], areaId, groupName, c, separatorSize, defRow, defDockingCol, zorder))
			// 					// else
			// 					// 	dockingDropLine(dropInfo, state, [colId, rId], areaId, groupName, c, separatorSize, defRow, defDockingCol, zorder);
			// 				}
			// 			}

			// 		} else {
			// 			dockingDropLine(dropInfo, state, [colId, rId], areaId, groupName, color, separatorSize, defRow, defDockingCol, zorder);
			// 		}

			// 	} else TEmpty()
			// });
			dockingDropLine(isColumn, colId, dropInfo, state, [colId, rId], inactiveDropLine, false, zorder, style);
		};

	// Make single area (col or row) docked panels

		
							
	MSelect(manager.white, \ww -> {
		containsDark = fold(colA, false, \acc, a -> acc || contains(getValue(state.style)[a], MDockingForceDarkTheme()));
		containsLight = fold(colA, false, \acc, a -> acc || contains(getValue(state.style)[a], MDockingForceLightTheme()));
		light = if (containsDark) false else if (containsLight) true else ww;

		MFrame(0.0, 0.0, [MFill(areaBgColorFn(light, style))], 
			MGroup2(					
				// Get column height     --- (HANDLE FOR LINES)
				TFillY() |> (\f -> MAttachHeight(f, colHeightB)),
				MLines2(
					// Side expander button
					if ((isColumn && !dontSideExpand && !dontSideExpandPanel))  makeSideExpanderBtn(state, redraw, colA, light, style) else TEmpty(),
								
					// Docked panels			
					mapi(colA, \rowId, panelId -> {
						panelStyle = getValue(state.style)[panelId];
						// enabled = getValue(state.enabled)[panelId];
						fillHeight = fillHeightArea || contains(panelStyle, MDockingFillSpace());
						
						// Fill panel order
						fillBottomTop = rowId == lastPanel; 	// fill last panel - default
						fillTopBottom = rowId == 0; 			// fill first panel
						fillPanelOrder = if (stickBottomPanels) fillTopBottom else fillBottomTop;

						// Dropping area overlay
						dropAreaOverlay = 
							if (isColumn) {
								MLines([
									makeInnerDroppingLine(rowId, MGreen(200), panelId),
									// makeInnerDroppingLine(rowId, dockingPrimaryColor, panelId),
									if (se) {
										// if (rowId == lastPanel || fillHeight) MShow(getValue(state.expanded)[panelId], TFillY()) else TEmpty(); //--ORIGINAL
										if (fillPanelOrder || fillHeight) MShow(getValue(state.expanded)[panelId], TFillY()) else TEmpty();
									} else TEmpty(),
									// if (rowId == lastPanel) makeInnerDroppingLine(rowId + 1, dockingPrimaryColor, lg, panelId) else TEmpty() //--ORIGINAL
									if (rowId == lastPanel) makeInnerDroppingLine(rowId + 1, MRed(200), panelId) else TEmpty()
								]) 

							} else {
								MColsA([
									makeInnerDroppingLine(rowId, dockingPrimaryColor, panelId),
									if (se) {
										if (rowId == lastPanel) MShow(getValue(state.expanded)[panelId], TFillX()) else TEmpty();
									} else TEmpty(),
									makeInnerDroppingLine(rowId + 1, dockingPrimaryColor, panelId) |> showIf(rowId == lastPanel)
								])
							}

							// Make docked panel
							MGroup2(	
								makeDockedPanel(state, panelId, Pair(colId, rowId), colA, colHeightB, dropInfo, isColumn, fillPanelOrder, style, dropSize, sideExpandedA[colId], zorder) 
									|> showIf(dockedSizeA != []),
								MEmpty()	
								// dropAreaOverlay 	
							)
	
					}) |> (\f -> if (isColumn) MLines(f) else MColsA(f))		
				)
			) 
		) |> (\f -> makeAvailableDockedWidth(f, isColumn, dropInfo, state,  WA, HA, areaGrid, colA, colId, light, style))

	})
	// |> (\f -> MSelect(getValue(state.enabled)[colId], \e -> f));   // enable col
}



makeAvailableDockedWidth(
	box : Material, 
	isColumn : bool,
	dropInfo : MDockingDropInfo,
	state : MDockingState, 
	WA : [DynamicBehaviour<double>], 
	HA : [DynamicBehaviour<double>], 
	areaGrid : [[int]],
	colA : [int], 
	colId : int,
	light : bool,
	style : [MDockingStyle]
) -> Material {

	manager = state.manager;
zorder = getValue(manager.manager.zorder);

	itemId = makeTropicTag(manager);
	isBottomLine = contains(style, MDockingBottomtLines());
	isRightCol  = contains(style, MDockingRightCols());
	dontScroll  = contains(style, MDockingDontScroll());
	
	dontResize  = contains(style, MDockingDontResize());
	dontResizeAll = fold(colA, true, \acc, p -> acc && contains(getValue(state.style)[p], MDockingDontResize()));

	resizePressed = make(false);
	
	resizeCol = true;
	isResizing = make(false);
	isHovering = make(false);
	mouseXyLocal = make(zeroPoint);
	currXy = make(zeroPoint);
	panelWH = makeWH();

	panelsWidthA = map(colA, \s -> getTropicMetrics(getValue(state.size)[s]).width);
	maxPanelsWidth = either(maxA(panelsWidthA), -doubleMax);
	se = getValue(getValue(state.sideExpanded)[colA[0]]);

	// areaGrid = getValue(dockedPanelsGrid);
	numOfCols = length(areaGrid);
	lastCol = numOfCols - 1;

	dragSize = dockingDragSize;
	dragSizeBig = dockingHelperDragSize;
	colSizeDrag = if (isColumn) TFillWY(dragSize) else TFillXH(dragSize);
	colSizeDragBig = if (isColumn) TFillWY(dragSizeBig) else TFillXH(dragSizeBig);
	colSizeDragInactive = dockingDragSizeInactive |> (\f -> if (isColumn) TFillWY(f) else TFillXH(f));


	// scrollBox = if (dontScroll) MCropSize(areaScrollingSize, box) else MScroll(box, areaScrollingSize, []);
	scrollBox = if (dontScroll) MCropSize(TFillXY(), box) else MScroll(box, TFillXY(), []);

	// Cols separator
	// makeColResizeSeparator = makeMDockingSeparator(resizeCol, colA, colId, numOfCols, resizePressed, state, style);
	makeColResizeSeparator = makeMDockingSeparatorDrop(isColumn, resizeCol, colId, colA,  numOfCols, dropInfo, resizePressed, state, style);




	draggingBarInactive = \lg : bool -> TRectangle([MFill(separatorColorFn(lg, style))], colSizeDrag);
	dLine = dockingDropLine(isColumn, colId,  dropInfo, state, [if (isRightCol) lastCol + 1 else 0, 0], draggingBarInactive(light), true, zorder, style);






	colFiller = if (isColumn) TFillX() else TFillY();

		 colHandleA = {		
			if (colId == 0 && numOfCols == 1)
			[
				if (isRightCol || isBottomLine) makeColResizeSeparator else dLine,
				colFiller,
				if (isRightCol || isBottomLine) dLine else makeColResizeSeparator,
			]
			else if (colId == 0 && numOfCols != 1)
			[
				if (isRightCol || isBottomLine) makeColResizeSeparator else dLine,
				colFiller,
				if (isRightCol || isBottomLine) TEmpty() else makeColResizeSeparator,
			]
			else if (colId != 0 && colId == numOfCols - 1)
			[
				if (!isRightCol && !isBottomLine) TEmpty() else makeColResizeSeparator,
				colFiller,
				if (isRightCol || isBottomLine) dLine else makeColResizeSeparator,
			]
			else
			[
				if (!isRightCol && !isBottomLine) TEmpty() else makeColResizeSeparator,
				colFiller,
				if (isRightCol || isBottomLine) TEmpty() else makeColResizeSeparator,
			]

			// [
			// 	makeMDockingSeparatorDrop(resizeCol, colA, colId, numOfCols, dropInfo, resizePressed, state, style),
			// 	colFiller,
			// 	makeMDockingSeparatorDrop(resizeCol, colA, colId + 1, numOfCols, dropInfo, resizePressed, state, style),
			// ]
	
		} |> (\f -> if (isColumn) MColsA(f) else MLines(f))



		resizeBoxCol = MGroup2(scrollBox, colHandleA);


		MConstruct([
			makeSubscribe(resizePressed, \p -> {
				if (p) {
					addMInteractionItemId(manager, itemId);
					next(currXy, getValue(state.mouseXy));
					next(panelWH, WidthHeight(getValue(WA[colId]), getValue(HA[colId])));
					next(isResizing, true);
				} else {
					if (getValue(isResizing)) next(isResizing, false);
				}
			}),
			makeSubscribe(state.mouseXy, \mxy -> {
				if (isCurrentMInteractionItemId(manager, itemId) && getValue(isResizing)) {
					rtlCorrection = if (getDefaultRtl()) -1.0 else 1.0; // correction the direction of width changing depending of rtl mode
					blockOtherMInteractionItemIds(manager, itemId);
					if (isColumn) {
						if (isRightCol) nextDistinct(WA[colId], max(maxPanelsWidth, getValue(panelWH).width + rtlCorrection*(getValue(currXy).x - mxy.x)))
							else nextDistinct(WA[colId], max(maxPanelsWidth, getValue(panelWH).width - rtlCorrection*(getValue(currXy).x - mxy.x)));
						} else {
						if (isBottomLine) nextDistinct(HA[colId], max(maxPanelsWidth, getValue(panelWH).height + (getValue(currXy).y - mxy.y)))
							else nextDistinct(HA[colId], max(maxPanelsWidth, getValue(panelWH).height - (getValue(currXy).y - mxy.y)));
						}
				};
			}),
			// \ -> \-> println("dispose" + i2s(areaId)),
		],
		MInteractive([
			TMouseXY(mouseXyLocal)
		],
		MAvailable(
			resizeBoxCol, 
			if (isColumn) {
				if (se) TSelect(WA[colId], \w  -> TFillWY(w)) else TFillWY(dockingSideCollapsedSize);
			} else {
				if (se) TSelect(HA[colId], \h  -> TFillXH(h)) else TFillXH(dockingSideCollapsedSize);
			}
		)
	));
}




// Col separator with resize handle
makeColSeparator(isColumn : bool, state : MDockingState, style : [MDockingStyle]) -> (int, int, int, [int], DynamicBehaviour<bool>) -> Material {


	\a : int, b : int, maxLenght : int, colA : [int], resizePressedH : DynamicBehaviour<bool> -> {
		manager = state.manager;	
		isHovering = make(false);
		isRightCol  = contains(style, MDockingRightCols());
		isBottomLine = contains(style, MDockingBottomtLines());
		dontResize  = contains(style, MDockingDontResize());
		dontResizeAll = fold(colA, true, \acc, p -> acc && contains(getValue(state.style)[p], MDockingDontResize()));

		// Sizes
		dropSize = extractStruct(style, MDockingDropSize(dockingDropSize)).size;
		dragSize = dockingDragSize;
		rowSize = if (isColumn) TFillXH(dropSize) else TFillWY(dropSize);
		colSize = if (isColumn) TFillWY(dropSize) else TFillXH(dropSize);
		colSizeDrag = if (isColumn) TFillWY(dragSize) else TFillXH(dragSize);
		invisibleBar = TRectangle([MFill(MGreen(700)), FillOpacity(0.0)], colSizeDrag);

		// Dragging bar 
		smallHandle = \lg : bool -> TRectangle([MFill(smallHandleColorFn(lg, style))], if (isColumn) TFixed(dockingHandleW, dockingHandleH) else TFixed(dockingHandleH, dockingHandleW));		
		draggingBarInactive = \lg : bool -> TRectangle([MFill(separatorColorFn(lg, style))], colSizeDrag);
		draggingBarActive = \lg : bool -> {
			MCursor(
				if (isColumn) EWResizeCursor() else NSResizeCursor(),
				MInteractive([TMouseDown(resizePressedH), TMouseInside(isHovering, false)],
					MGroup2(
						MSelect(isHovering, \h -> TRectangle([MFill(if (h) dockingPrimaryColor else separatorColorFn(lg, style)), FillOpacity(dockingDragHandleOpacity)], colSizeDrag)),
						MCenterIn(smallHandle(lg), colSizeDrag)
					)
				)
			);
		}

		draggingBarSideExpanded =  \lg : bool -> if (getValue(getValue(state.sideExpanded)[colA[0]])) draggingBarActive(lg) else draggingBarInactive(lg);

		draggingBar = 
			MSelect(manager.white, \ww -> {
				containsDark = fold(colA, false, \acc, p -> acc || contains(getValue(state.style)[p], MDockingForceDarkTheme()));
				containsLight = fold(colA, false, \acc, p -> acc || contains(getValue(state.style)[p], MDockingForceLightTheme()));
				light = if (containsDark) false else if (containsLight) true else ww;

				if (maxLenght == 1) {
					if (dontResizeAll || dontResize) TEmpty() else draggingBarSideExpanded(light);
				} else {
					if (dontResizeAll || dontResize) draggingBarInactive(light) else {
						if (getValue(getValue(state.sideExpanded)[colA[0]])) draggingBarActive(light) else invisibleBar			
					}
				}
			});

		if (isRightCol || isBottomLine) {
			if (a != maxLenght) draggingBar else TEmpty();
		} else {
			if (a != 0) draggingBar else TEmpty();
		}
	}
};








