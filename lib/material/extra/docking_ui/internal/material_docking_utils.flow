import material/material_ui;
import material/extra/docking_ui/internal/material_docking_styles;
import material/extra/docking_ui/internal/material_docking_theme;
import material/extra/docking_ui/internal/material_docking_state;
import material/extra/docking_ui/internal/material_docking_drop;



export {
	// Get docked panels IDs into an area of given areaId 
	extractAreaGridById(dockA: [[int]], areaId : int) -> [[int]];

	// Handles & buttons
	// makeMDockingSeparator(
	// 	isColumn : bool,
	// 	colA : [int], 
	// 	colId : int,
	// 	numOfCols : int, 
	// 	resizePressed : DynamicBehaviour<bool>,
	// 	state : MDockingState, 
	// 	style : [MDockingStyle]
	// ) -> Material;

	makeMDockingSeparatorDrop(
		isColumn : bool,
		resizeCol : bool,  // resize cols (W) or panels (H)
		colId : int,
		colA : [int], 	
		numOfCols : int,
		dropInfo : MDockingDropInfo, 
		resizePressed : DynamicBehaviour<bool>,
		state : MDockingState, 
		style : [MDockingStyle]
	) -> Material;

	makeMDockingResizeHandleMobile(state : MDockingState, style : [MDockingStyle]) -> Material;
	makeMDockingLinedHandle(isHorizontal : bool, titleColor : MColor) -> Material;
	makeMDockingDottedHandle(isColumn : bool, color : MColor) -> Material;
	makeSideExpanderBtn(state : MDockingState, colA : [int], light : bool, style : [MDockingStyle]) -> Material;

	// Utils
	showIf(cond : bool) -> (Material) -> Material;
	makeColSize(s : double, rotate: bool) -> Tropic;
	makeRowSize(s : double, rotate: bool) -> Tropic;
	
	// Debug prints
	makeMDockingDebugPrints(state : MDockingState) -> Material;
	
}




extractAreaGridById(dockA: [[int]], areaId : int) -> [[int]] {
	areaIdSorted = sortCustom(filter(mapi(dockA, \i : int, v : [int] -> if (v[0] == areaId) [v[1], v[2], i] else []), \item -> item != []), \v -> v, true);
	colsIdSorted = map(areaIdSorted, \item -> item[2]);
	// We don't need to have an order for mobile panels
	if (areaId < 0) [colsIdSorted] else {
		colGroups = sortCustom(filter(uniq(map(dockA, \v -> if (v[0] == areaId) v[1] else -intMax)), \v -> v >= 0), \v -> v, true);
		filter(map(colGroups, \item -> filter(map(colsIdSorted, \c -> if (dockA[c][1] == item ) c else -intMax), \itm -> itm != -intMax)), \item -> item != []);
	}
}






// Col separator with resize handle and drop area
makeMDockingSeparatorDrop(
	isColumn : bool,
	resizeCol : bool,  // resize cols (W) or panels (H)
	id : int,		   // it could be colId or rowId
	colA : [int], 	
	numOfCols : int,
	dropInfo : MDockingDropInfo, 
	resizePressed : DynamicBehaviour<bool>,
	state : MDockingState, 
	style : [MDockingStyle]
) -> Material {

		manager = state.manager;	
		isHovering = make(false);
		isRightCol  = contains(style, MDockingRightCols());
		isBottomLine = contains(style, MDockingBottomtLines());
		dontResize  = contains(style, MDockingDontResize());
		dontResizeAll = fold(colA, true, \acc, p -> acc && contains(getValue(state.style)[p], MDockingDontResize()));

		// Sizes
		dropSize = extractStruct(style, MDockingDropSize(dockingDropSize)).size;

		dragSize = dockingDragSize;
		dragSizeBig = dockingHelperDragSize;
		dragHandleSize = makeColSize(dockingDragSize, resizeCol);
		dragHandleSizeBig = makeColSize(dragSizeBig, resizeCol);
		dragHandleSizeInactive = makeColSize(dockingDragSizeInactive, resizeCol);
		draggingHandleInactive = \lg : bool -> TRectangle([MFill(separatorColorFn(lg, style))], dragHandleSizeInactive);

		invisibleBar = TRectangle([MFill(MGreen(700)), FillOpacity(0.0)], dragHandleSize);
		se = getValue(getValue(state.sideExpanded)[colA[0]]);

		smallHandle = \lg : bool -> TRectangle([MFill(smallHandleColorFn(lg, style))], if (resizeCol) TFixed(dockingHandleW, dockingHandleH) else TFixed(dockingHandleH, dockingHandleW));		
		draggingBarInactive = \lg : bool -> TRectangle([MFill(separatorColorInactiveFn(lg, style))], dragHandleSizeInactive);

		offSetBar = \f : Material -> MOffset(
			if (resizeCol) (dragSizeBig - dragSize) * (if (isRightCol) 0.0 else 1.0) else 0.0,
			if (resizeCol) 0.0 else (dragSizeBig - dragSize) * (if (isBottomLine) 0.0 else 1.0), 
			f
		);

		offSetHelper = \f : Material -> MBorder(
			if (isRightCol) {if (resizeCol) 0.0 else dragSizeBig} else 0.0, 0.0,
			if (!isRightCol) {if (resizeCol) 0.0 else dragSizeBig} else 0.0, 0.0, 
			f
		);

		draggingBarActive = \lg : bool -> {
			MCursor(
				if (resizeCol) EWResizeCursor() else NSResizeCursor(),
				MInteractive([
						TMouseDown(resizePressed), 
						// TMouseInside(isHovering, false)
					],
					MGroup2(
						
						MGroup2(
							MSelect(isHovering, \h -> TRectangle([MFill(if (h) dockingPrimaryColor else separatorColorFn(lg, style)), FillOpacity(dockingDragHandleOpacity)], dragHandleSize)),
							MCenterIn(smallHandle(lg), dragHandleSize),
							// MEmpty()
						) |> offSetBar,
						
						

						// if (isRightCol)
						// Helper for a better dragging area
						// MOffset((dragSizeBig / 2.0) * (if (isRightCol) - 1.0 else 1.0), 0.0,
							TRectangle([MFill(MRed(500)), FillOpacity(dockingHelperDragOpacity)], dragHandleSizeBig) |> offSetHelper
							// |> MBorderLeft(if (isColumn) 0.0 else if (isRightCol) dragSizeBig else 0.0
							// |> MBorderRight(if (isColumn) 0.0 else dragSizeBig)
							
						// ) 
						// else MEmpty()
					)

					
				)
			);
		}

		draggingBarSideExpanded =  \lg : bool -> if (se) draggingBarActive(lg) else draggingBarInactive(lg);
		draggingBar=
			MSelect(manager.white, \ww -> {
				containsDark = fold(colA, false, \acc, p -> acc || contains(getValue(state.style)[p], MDockingForceDarkTheme()));
				containsLight = fold(colA, false, \acc, p -> acc || contains(getValue(state.style)[p], MDockingForceLightTheme()));
				light = if (containsDark) false else if (containsLight) true else ww;

					// if (numOfCols == 1) {
					// 	if (dontResizeAll || dontResize) TEmpty() else draggingBarSideExpanded(light);
					// } else {
						if (dontResizeAll || dontResize) draggingBarInactive(light) else {
							if (se) draggingBarActive(light) else TRectangle([MFill(MGreen(700)), FillOpacity(0.0)], dragHandleSize)			
		
						} 
					// }

// b |> (\f -> MGroup2(f, MCenterIn(MText(i2s(id), [MOverline(), if (light) MBlack() else MWhite()]), dragHandleSize)))
			});

		// if (isRightCol || isBottomLine) {
		// 	if (id != numOfCols) draggingBar else TEmpty();
		// } else {
		// 	if (id != 0) draggingBar else TEmpty();
		// }





	// Drop info
	onDrop = dropInfo.onDrop;
	panelsOrder = dropInfo.order;
	panelsArray = dropInfo.dockedPanelsGrid;
	isDockingCol = dropInfo.isDockingCol;
	isRow = dropInfo.isRow; 
	lastDropSize = dropInfo.lastDropSize;


	// manager = state.manager;
					// itemId = makeTropicTag(manager);
					
	onDragging = manager.manager.dragging;
	zorder = getValue(manager.manager.zorder);

	newId = if (resizeCol) {
		if (isRightCol) id else id + 1;
	} else {
		 id + 1;
	}
colRowOrderA = if (resizeCol) [newId, 0] else [0, newId];
	dockingDropLine(resizeCol, id, dropInfo, state, colRowOrderA, draggingBar, false, zorder, style)

};








// // Col separator with resize handle
// makeMDockingSeparator(
// 	isColumn : bool,   // resize width
// 	colA : [int], 
// 	colId : int,
// 	numOfCols : int, 
// 	resizePressed : DynamicBehaviour<bool>,
// 	state : MDockingState, 
// 	style : [MDockingStyle]
// ) -> Material {

// 		manager = state.manager;	
// 		isHovering = make(false);
// 		isRightCol  = contains(style, MDockingRightCols());
// 		isBottomLine = contains(style, MDockingBottomtLines());
// 		dontResize  = contains(style, MDockingDontResize());
// 		dontResizeAll = fold(colA, true, \acc, p -> acc && contains(getValue(state.style)[p], MDockingDontResize()));

// 		// Sizes
// 		dropSize = extractStruct(style, MDockingDropSize(dockingDropSize)).size;

// 		dragSize = dockingDragSize;
// 		dragSizeBig = dockingHelperDragSize;
// 		dragHandleSize = if (isColumn) TFillWY(dragSize) else TFillXH(dragSize);
// 		dragHandleSizeBig = if (isColumn) TFillWY(dragSizeBig) else TFillXH(dragSizeBig);
// 		dragHandleSizeInactive = dockingDragSizeInactive |> (\f -> if (isColumn) TFillWY(f) else TFillXH(f));


	
// 	dragHandleSize = if (isColumn) TFillXH(dragSize) else TFillWY(dragSize);
// 	dragHandleSizeBig = if (isColumn) TFillXH(dragSizeBig) else TFillWY(dragSizeBig);
// 	dragHandleSizeInactive = dockingDragSizeInactive |> (\f -> if (isColumn) TFillXH(f) else TFillWY(f));
// 	draggingHandleInactive = \lg : bool -> TRectangle([MFill(separatorColorFn(lg, style)), FillOpacity(1.0)], dragHandleSizeInactive);





// 		rowSize = if (isColumn) TFillXH(dropSize) else TFillWY(dropSize);
// 		colSize = if (isColumn) TFillWY(dropSize) else TFillXH(dropSize);
// 		// dragHandleSize = if (isColumn) TFillWY(dragSize) else TFillXH(dragSize);
// 		invisibleBar = TRectangle([MFill(MGreen(700)), FillOpacity(0.0)], dragHandleSize);
// 		se = getValue(getValue(state.sideExpanded)[colA[0]]);



// if (!isColumn) println("isRightCol: " +  b2s(isRightCol));

// println("isColumn: " +  b2s(isColumn) + " " + i2s(colId));
	
// 		smallHandle = \lg : bool -> TRectangle([MFill(smallHandleColorFn(lg, style))], if (isColumn) TFixed(dockingHandleW, dockingHandleH) else TFixed(dockingHandleH, dockingHandleW));		
// 		draggingBarInactive = \lg : bool -> TRectangle([MFill(separatorColorInactiveFn(lg, style))], dragHandleSizeInactive);

// 		draggingBarActive = \lg : bool -> {
// 			MCursor(
// 				if (isColumn) EWResizeCursor() else NSResizeCursor(),
// 				MInteractive([
// 						TMouseDown(resizePressed), 
// 						TMouseInside(isHovering, false)
// 					],
// 					MGroup2(
						


// 							MGroup2(
// 								MSelect(isHovering, \h -> TRectangle([MFill(if (h) dockingPrimaryColor else separatorColorFn(lg, style)), FillOpacity(dockingDragHandleOpacity)], dragHandleSize)),
// 								MCenterIn(smallHandle(lg), dragHandleSize)
// 								// MEmpty()
// 							) |> (\f -> MOffset(
// 									if (isColumn) (dragSizeBig - dragSize) * (if (isRightCol) 0.0 else 1.0) else 0.0,
// 									if (isColumn) 0.0 else (dragSizeBig - dragSize) * (if (isBottomLine) 0.0 else 1.0),
// 									f
// 								)),




// 						// if (isRightCol)
// 						// Helper for a better dragging area
// 						// MOffset((dragSizeBig / 2.0) * (if (isRightCol) - 1.0 else 1.0), 0.0,
// 							TRectangle([MFill(MRed(500)), FillOpacity(dockingHelperDragOpacity)], dragHandleSizeBig)
// 							// |> MBorderLeft(if (isColumn) 0.0 else if (isRightCol) dragSizeBig else 0.0
// 							// |> MBorderRight(if (isColumn) 0.0 else dragSizeBig)

// 							|> (\f -> MBorder(
// 								if (isRightCol) {if (isColumn) 0.0 else dragSizeBig} else 0.0,

// 								0.0,
// 								if (!isRightCol) {if (isColumn) 0.0 else dragSizeBig} else 0.0,

// 								// if (isRightCol) 0.0 else {if (isColumn) 0.0 else dragSizeBig}, 
// 								0.0, 
// 								f
// 							))
// 						// ) 
// 						// else MEmpty()
// 					)

					
// 				)
// 			);
// 		}
// 		draggingBarSideExpanded =  \lg : bool -> if (se) draggingBarActive(lg) else draggingBarInactive(lg);
// 		draggingBar=
// 			MSelect(manager.white, \ww -> {
// 				containsDark = fold(colA, false, \acc, p -> acc || contains(getValue(state.style)[p], MDockingForceDarkTheme()));
// 				containsLight = fold(colA, false, \acc, p -> acc || contains(getValue(state.style)[p], MDockingForceLightTheme()));
// 				light = if (containsDark) false else if (containsLight) true else ww;

// 					// if (numOfCols == 1) {
// 					// 	if (dontResizeAll || dontResize) TEmpty() else draggingBarSideExpanded(light);
// 					// } else {
// 						if (dontResizeAll || dontResize) draggingBarInactive(light) else {
// 							if (se) draggingBarActive(light) else TRectangle([MFill(MGreen(700)), FillOpacity(0.0)], dragHandleSize)			
// 						}
// 					// }


// 			});

// 		// if (isRightCol || isBottomLine) {
// 		// 	if (colId != numOfCols) draggingBar else TEmpty();
// 		// } else {
// 		// 	if (colId != 0) draggingBar else TEmpty();
// 		// }
// 		draggingBar

// };

makeSideExpanderBtn(state : MDockingState, colA : [int], light : bool, style : [MDockingStyle]) -> Material {	
	isRightCol  = contains(style, MDockingRightCols());
	se = getValue(getValue(state.sideExpanded)[colA[0]]);
	sideExpFn = \ -> {
		iter(colA, \c -> reverseBehaviour(getValue(state.sideExpanded)[c]));
	}
	 
	sideExpBtnLabel = if (if (getDefaultRtl()) !isRightCol else isRightCol) {
		if (se) "skip_next" else "skip_previous";
	} else {
		if (!se) "skip_next" else "skip_previous";
	}
	sideExpBtnItem = \lg : bool -> MGroup2(
		TRectangle([MFill(sideExpanderBgColorFn(lg, style))], TFillXH(sideExpanderButtonSize)),
		if (isRightCol) MColsA([TFillX(), MIcon(sideExpBtnLabel, [MIconSize(sideExpanderButtonSize - 2.0), dockedTitleColorFn(lg, style)]), TFixed(2.0, 2.0)])
		else MColsA([TFixed(2.0, 2.0), MIcon(sideExpBtnLabel, [MIconSize(sideExpanderButtonSize - 2.0), dockedTitleColorFn(lg, style)]), TFillX()]),
	);
	sideExpBtnItemHover = \lg : bool -> MGroup2(
		TRectangle([MFill(sideExpanderHoverColorFn(lg, style))], TFillXH(sideExpanderButtonSize)),
		if (isRightCol) MColsA([TFillX(), MIcon(sideExpBtnLabel, [MIconSize(sideExpanderButtonSize - 2.0), dockedTitleColorFn(lg, style)]), TFixed(2.0, 2.0),])
		else MColsA([TFixed(2.0, 2.0), MIcon(sideExpBtnLabel, [MIconSize(sideExpanderButtonSize - 2.0), dockedTitleColorFn(lg, style)])]),
	) ;
	MRawButton(sideExpBtnItem(light), sideExpBtnItemHover(light), sideExpBtnItem(light), sideExpBtnItem(light), "", [], [TOnClicked(sideExpFn)]);
}

makeMDockingResizeHandleMobile(state : MDockingState, style : [MDockingStyle]) -> Material {
	dot = TRounded(1.0, 1.0, 1.0, 1.0, [MThemeFill(state.manager, MThemedColor(mobileHandleColorFn(true, style), mobileHandleColorFn(false, style)))], TFixed(1.0, 1.0));
	gapW = TFixed(2.0, 0.0);
	gapH = TFixed(0.0, 2.0);
	cornerSpace = TFixed(24.0, 18.0);

	MLines([
		TFillY(),
		MColsA([
			TFillX(),
			MCursor(
				MoveCursor(),
				MGroup2(
					TRectangle(interactiveRectangleStyle, cornerSpace),
					MAvailable(
						MLines([
							TFillY(),
							MColsA([
								TFillX(),
								MLines([
									MColsA([TFixed(6.0, 0.0), dot]),
									gapH,
									MColsA([TFixed(3.0, 0.0), dot, gapW, dot]),
									gapH,
									MColsA([dot, gapW, dot, gapW, dot])
								]),
								TFixed(3.0, 0.0)
							]),
							TFixed(0.0, 3.0)
						]),
						cornerSpace
					)
				)
			)
		])
	]);
};

makeMDockingLinedHandle(isHorizontal : bool, titleColor : MColor) -> Material {
	handleWidth = 24.0;
	if (isHorizontal) {
		MCenterIn(
			MColsA([
				TRounded(1.0, 1.0, 1.0, 1.0, [MFill(titleColor)], TFixed(1.0, 18.0)),
				TFixed(2.0, 0.0),
				TRounded(1.0, 1.0, 1.0, 1.0, [MFill(titleColor)], TFixed(1.0, 18.0))
			]),
			TFixed(dockingBarHeight, handleWidth)
		);
	} else {
		MCenterIn(
			MLines([
				TRounded(1.0, 1.0, 1.0, 1.0, [MFill(titleColor)], TFixed(18.0, 1.0)),
				TFixed(0.0, 2.0),
				TRounded(1.0, 1.0, 1.0, 1.0, [MFill(titleColor)], TFixed(18.0, 1.0))
			]),
			TFixed(handleWidth, dockingBarHeight)
		);
	};
};

makeMDockingDottedHandle(isColumn : bool, color : MColor) -> Material {
		r = 2.0;
		t = 1.0;
		handleWidth = 24.0;
		if (isColumn) {
			TGroup2(
				TRectangle(interactiveRectangleStyle, TFixed(handleWidth, dockingBarHeight)),
				TCenterIn(
					TCols([
						TLines([TRounded(r, r, r, r, [MFill(color)], TFixed(t, t)), TFixed(0.0, 2.0), TRounded(r, r, r, r, [MFill(color)], TFixed(t, t))]),
						TFixed(2.0, 0.0),
						TLines([TRounded(r, r, r, r, [MFill(color)], TFixed(t, t)), TFixed(0.0, 2.0), TRounded(r, r, r, r, [MFill(color)], TFixed(t, t))]),
						TFixed(2.0, 0.0),
						TLines([TRounded(r, r, r, r, [MFill(color)], TFixed(t, t)), TFixed(0.0, 2.0), TRounded(r, r, r, r, [MFill(color)], TFixed(t, t))]),
						TFixed(2.0, 0.0),
						TLines([TRounded(r, r, r, r, [MFill(color)], TFixed(t, t)), TFixed(0.0, 2.0), TRounded(r, r, r, r, [MFill(color)], TFixed(t, t))]),
					]),
					TFixed(handleWidth, dockingBarHeight / 2.0)
				)
			);
		} else {
			TGroup2(
				TRectangle(interactiveRectangleStyle, TFixed(dockingBarHeight / 2.0, handleWidth)),
				TCenterIn(
					TLines([
						TCols([TRounded(r, r, r, r, [MFill(color)], TFixed(t, t)), TFixed(2.0, 0.0), TRounded(r, r, r, r, [MFill(color)], TFixed(t, t))]),
						TFixed(0.0, 2.0),
						TCols([TRounded(r, r, r, r, [MFill(color)], TFixed(t, t)), TFixed(2.0, 0.0), TRounded(r, r, r, r, [MFill(color)], TFixed(t, t))]),
						TFixed(0.0, 2.0),
						TCols([TRounded(r, r, r, r, [MFill(color)], TFixed(t, t)), TFixed(2.0, 0.0), TRounded(r, r, r, r, [MFill(color)], TFixed(t, t))]),
						TFixed(0.0, 2.0),
						TCols([TRounded(r, r, r, r, [MFill(color)], TFixed(t, t)), TFixed(2.0, 0.0), TRounded(r, r, r, r, [MFill(color)], TFixed(t, t))]),
					]),
					TFixed(dockingBarHeight / 2.0, handleWidth)
				)
			);
		};
	};

	
showIf(cond : bool) -> (Material) -> Material {\m -> if (cond) m else TEmpty()}
makeColSize(s : double, rotate: bool) -> Tropic { if (rotate) TFillWY(s) else TFillXH(s)}
makeRowSize(s : double, rotate: bool) -> Tropic { if (rotate) TFillXH(s) else TFillWY(s)}

makeMDockingDebugPrints(state : MDockingState) -> Material {
	MConstruct([
			makeSubscribe(state.dock, \dockA -> {
			// make2Subscribe(state.dock, state.mobileSize, \dockA, msize -> {

				// println("- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ");
				// println("State.dock :  DynamicBehaviour<[[int]]> -  stores UI layout");
				// println("- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ");
				// println(dockA);
				// println("");

				iter(dockA,\panelDockInfoA -> {
					lf = \j : int, s : string -> lpad(s, " ", j);
					GAP = " ";

					areaId = panelDockInfoA[0];
					colID = panelDockInfoA[1];
					panelId = panelDockInfoA[2];
					enabled = if (getValue(getValue(state.enabled)[panelId])) "e   " else "    ";
					expanded = if (getValue(getValue(state.expanded)[panelId])) "+   " else "-   ";
					sideExpanded = if (getValue(getValue(state.sideExpanded)[panelId])) "se   " else "--   ";
					
					size = getTropicMetrics(getValue(state.size)[panelId]);
					panelSize = lf(4, d2s(size.width)) + "  x " + lf(4, d2s(size.height));
					// mobileSize = getTropicMetrics(msize[panelId]);
					mobileSize = getTropicMetrics(getValue(state.mobileSize)[panelId]);
					mobilePanelSize = lf(4, d2s(mobileSize.width)) + "  x " + lf(4, d2s(mobileSize.height));
					dockedSize = getTropicMetrics(getValue(state.dockedSize)[panelId]);
					dockedPanelSize = lf(4, d2s(dockedSize.width)) + "  x " + lf(4, d2s(dockedSize.height));
					dockString = "[areaID: " + lf(2, i2s(areaId)) + ",   colID: " + lf(2, i2s(colID)) + ",   panelID: " + lf(2, i2s(panelId)) + "]   ";
					positionString = toString(getValue(getValue(state.positions)[panelId]));

					println(
						dockString + 
						GAP + enabled + 
						GAP + expanded + 
						GAP + sideExpanded + 
						rpad(getValue(state.title)[panelId], " ", 16) + 
						"s: " + panelSize + 
						"       m: " + mobilePanelSize + 
						"       d: " + dockedPanelSize + 
						"       " + positionString
					);
				});
				println("");

				// Print area's docked panels
				areaIDs = uniq(fold(dockA, [], \acc, p ->if (p != []) arrayPush(acc, p[0]) else acc));
				iter(areaIDs,\areaId -> if (areaId > 0) println("Area " + i2s(areaId) + " contains: " + toString(extractAreaGridById(dockA, areaId))));
				println("Floating: " + toString(extractAreaGridById(dockA, -1)));
				println("");
			}),

			// makeSubscribe(state.positions, \positionA -> {
			// 	println("State.positions :  DynamicBehaviour<[DynamicBehaviour<Point>]>");
			// 	println("");
			// 	iteri(positionA,\i,p -> println(i2s(i) + " - " + toString(p)));
			// 	println("");
			// }),
		],
		TRectangle(interactiveRectangleStyle, TFillXY())
	)
}