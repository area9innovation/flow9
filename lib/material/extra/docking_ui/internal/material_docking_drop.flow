import material/material_ui;
import material/extra/docking_ui/internal/material_docking_state;
import material/extra/docking_ui/internal/material_docking_theme;
import material/extra/docking_ui/internal/material_docking_utils;


export {
	// Resizing cols and rows, and drop panels
	dockingResizeLine(
		isColumn : bool,
		resizeW : bool,  	// resize cols (W) or panels (H)
		dontResize : bool,
		resizePressed : DynamicBehaviour<bool>,
		size : Tropic,
		style : [MDockingStyle]
	) -> Material;

	// The place where we can drop panels
	dockingDropLine(
		isColumn : bool,
		resizeW : bool,
		dropInfo : MDockingDropInfo,
		state : MDockingState,   
		defPanelsOrderA : [int], // colId, rowId
		updateRow : bool, // Update row or col
		resizeBar : Material,
		hoverSize : Tropic,
		dropSize : Tropic,
		isEndpoint : bool,
		style : [MDockingStyle]
	) -> Material;


	dockingDropLineH(
		isColumn : bool,
		resizeW : bool,
		dropInfo : MDockingDropInfo,
		state : MDockingState,   
		defPanelsOrderA : [int], // colId, rowId
		updateRow : bool, // Update row or col
		resizeBar : Material,
		hoverSize : Tropic,
		dropSize : Tropic,
		isEndpoint : bool,
		style : [MDockingStyle]
	) -> Material;



	// Drop info
	MDockingDropInfo(
		areaId : int, 
		groupName : string, 
		onDrop : DynamicBehaviour<int>,
		order : DynamicBehaviour<[int]>,
		dockedPanelsGrid : DynamicBehaviour<[[int]]>,
		isDockingCol : DynamicBehaviour<bool>,
		isRow : DynamicBehaviour<bool>,
		lastDropSize : DynamicBehaviour<Tropic>
	);
}


// makeResizeAndDropSeparator(resizeW : bool, order : [int], resize : bool, endpoint : bool) -> (
// 	(
// 		isColumn : bool,
// 		resizeW : bool,
// 		dropInfo : MDockingDropInfo,
// 		state : MDockingState,   
// 		defPanelsOrderA : [int], // colId, rowId
// 		updateRow : bool, // Update row or col
// 		resizeBar : Material,
// 		hoverSize : Tropic,
// 		dropSize : Tropic,
// 		isEndpoint : bool,
// 		style : [MDockingStyle]
// 	)
// ) -> Material{
// 			resizeHelper = if (resize) dockingResizeLine(isColumn, true, dontResize, resizePressed, dragHandleSizeBig, style) else MEmpty();
// 			dockingDropLineH(isColumn, true, dropInfo, state, order, true, resizeHelper, dragHandleSize, dragHandleSizeBig, endpoint, style);
// 		}


dockingResizeLine(
	isColumn : bool,
	resizeW : bool,  	// resize cols (W) or panels (H)
	dontResize : bool,
	resizePressed : DynamicBehaviour<bool>,
	size : Tropic,
	style : [MDockingStyle]
) -> Material {
	// isHovering = make(false);
	dragHelper = 
		MCursor(
			if (resizeW) EWResizeCursor() else NSResizeCursor(),
			// if (isColumn) EWResizeCursor() else NSResizeCursor(),
			MInteractive([
					TMouseDown(resizePressed), 
					// TMouseInside(isHovering, false)
				],
				// TRectangle([MFill(if (resizeW) MRed(500) else MPurple(500)), FillOpacity(dockingHelperDragOpacity)], size)	
				TRectangle([MFill(MRed(500)), FillOpacity(dockingHelperDragOpacity)], size)	
					// |> (\f -> MGroup2(f, MCenterIn(
					// 	MLines2(
					// 		MText(i2s(id), [MOverline(), MBlack()]), MEmpty()
					// 		// MText(toString(dropInfo.areaId), [MOverline(), MBlack()]),
					// 	), size)))
			)
		);
	if (dontResize) TEmpty() else dragHelper;
};


	dockingDropLineH(
		isColumn : bool,
		resizeW : bool,
		dropInfo : MDockingDropInfo,
		state : MDockingState,   
		defPanelsOrderA : [int], // colId, rowId
		updateRow : bool, // Update row or col
		resizeBar : Material,
		hoverSize : Tropic,
		dropSize : Tropic,
		isEndpoint : bool,
		style : [MDockingStyle]
	) -> Material {

	dockingDropLine(
			isColumn,
			resizeW,
			dropInfo,
			state,
			defPanelsOrderA,
			updateRow,
			resizeBar,
			hoverSize,
			dropSize,
			isEndpoint,
			style
		)
	}



dockingDropLine(
	isColumn : bool,
	resizeW : bool,
	dropInfo : MDockingDropInfo,
	state : MDockingState,
	order : [int], // colId, rowId
	updateRow : bool, // Update row or col
	resizeBar : Material,
	hoverSize : Tropic,
	dropSize : Tropic,
	isEndpoint : bool,
	style : [MDockingStyle]
) -> Material {

	manager = state.manager;
	zorder = getValue(manager.manager.zorder);
	dockA = state.dock;
	groupA = state.group;
	onHover = make(-1);
	hovering = make(false);

	isRightCol  = contains(style, MDockingRightCols());
	isBottomLine = contains(style, MDockingBottomtLines());

	// Drop info
	areaId = dropInfo.areaId;
	groupName = dropInfo.groupName; 
	onDrop = dropInfo.onDrop;
	panelsOrderB = dropInfo.order;
	panelsArray = dropInfo.dockedPanelsGrid;

	isDockingCol = dropInfo.isDockingCol;
	isRow = dropInfo.isRow; 
	lastDropSizeB = dropInfo.lastDropSize;

	offSetHover =  \f : Material -> {
		MAvailable(
			if (resizeW) {
				if ((isRightCol && isEndpoint) || (!isRightCol && !isEndpoint)) MCols2(TFillX(), f) else f
			} else {
				if ((isBottomLine && isEndpoint) || (!isBottomLine && !isEndpoint)) MLines2(TFillY(), f) else f
			},
			dropSize
		)
	}

	MIfLazy(
		fselect(manager.manager.dragging, 
		FLift(\dr -> 
			(dr >= 0) &&
			(dr < length(getValue(state.title))) &&
			zorder >= getValue(manager.manager.zorder) &&
			(dr < length(getValue(groupA))) &&
			(contains(getValue(groupA)[dr], groupName))
		)
	),	\e -> if (e) {

			MGroup([
				MDropSpot2(onHover, onDrop, 		
					// MGroup([
						// TRectangle([MFill(if (resizeW) {if (isEndpoint) MYellowA(500) else MBlue(500) } else {if (isEndpoint) MYellowA(500) else MGreen(500) }), FillOpacity(0.6)], dropSize),
						// TRectangle([MFill(if (isEndpoint) MYellowA(500) else MBlue(500)), FillOpacity(0.6)], dropSize),
						TRectangle([MFill(dockingPrimaryColor), FillOpacity(dockingHelperDropOpacity)], dropSize),  //|> offSetHelper // Hightlight allowed droppimg areas

							// |> (\f -> MGroup2(f, MCenterIn(
							// // 	MLines2(
							// // 		MText(i2s(id), [MOverline(), MBlack()]),
							// 		MText(toString(order), [MOverline(), MBlack()])
							// 	, dropSize))),



						// MText(i2s(id), [if (isLastCol) MBlue(600) else MOrange(600), MCaptionSolid() ])  // debug
						// |>(\f -> if (isColumn) f |> MBorderLeft(16.0)|>MBorderTop(512.0) else  f |>MBorderLeft(128.0))
						// hoveringBar |> offSetHover
					// ]), 
					false
				),
				// hoveringBar |> offSetHover
				MConstruct([
					makeSubscribe(onHover, \h -> if (h >= 0) {
							next(isDockingCol, isColumn);
							next(panelsOrderB, order);
							next(lastDropSizeB, dropSize);
							next(isRow, updateRow);
							
							// dockedLength = if (getValue(isDockingCol)) getTropicMetri cs(getValue(lastDropSizeB)).width else getTropicMetrics(getValue(lastDropSizeB)).height;
							if (/*(*/getValue(isRow) /*&& (dockedLength == getTropicMetrics(m2t(getValue(state.dropSize)[h])).width))*/) next(hovering, true)
								else if (!getValue(isRow)) next(hovering, true)
									else next(hovering, false);
						} else next(hovering, false)
					),
					// On drop function
					makeSubscribe(onDrop, \d -> if (d >= 0) {
						updateDockingPositions(d, areaId, dockA, panelsArray, panelsOrderB, isRow);
					})],
					MShowLazy(hovering, \ -> TRectangle([MFill(dockingDropLineHoverColor), FillOpacity(dockingDropLineHoverOpacity)], hoverSize)) |> offSetHover
					// MShowLazy(hovering, \ -> MFrame(4.0, 4.0, [MFill(dockingDropLineHoverColor), FillOpacity(dockingDropLineHoverOpacity)], hoverSize))// |> offSetHover
				) |> offSetHover
			])
		// } else MEmpty()
		} else resizeBar
	);
}






















// dockingDropLine(
// 	isColumn : bool,
// 	resizeW : bool,
// 	dropInfo : MDockingDropInfo,
// 	state : MDockingState,
// 	order : [int], // colId, rowId
// 	updateRow : bool, // Update row or col
// 	resizeBar : Material,
// 	hoverSize : Tropic,
// 	dropSize : Tropic,
// 	isEndpoint : bool,
// 	style : [MDockingStyle]
// ) -> Material {

// 	manager = state.manager;
// 	zorder = getValue(manager.manager.zorder);
// 	dockA = state.dock;
// 	groupA = state.group;
// 	onHover = make(-1);
// 	hovering = make(false);

// 	isRightCol  = contains(style, MDockingRightCols());
// 	isBottomLine = contains(style, MDockingBottomtLines());

// 	// Drop info
// 	areaId = dropInfo.areaId;
// 	groupName = dropInfo.groupName; 
// 	onDrop = dropInfo.onDrop;
// 	panelsOrderB = dropInfo.order;
// 	panelsArray = dropInfo.dockedPanelsGrid;

// 	isDockingCol = dropInfo.isDockingCol;
// 	isRow = dropInfo.isRow; 
// 	lastDropSizeB = dropInfo.lastDropSize;

// 	offSetHover =  \f : Material -> {
// 		MAvailable(
// 			if (isColumn && resizeW) {

// 				println("IS RESIZE COL " + i2s(areaId));
// 				if ((isRightCol && isEndpoint) || (!isRightCol && !isEndpoint)) MCols2(TFillX(), f) else f

// 			} else {
				
// 				println("IS  -not-  RESIZE COL " + i2s(areaId));

// 				// MLines2(TFillY(), f)
// 				// f
// 				if ((isBottomLine && isEndpoint) || (!isBottomLine && !isEndpoint)) MLines2(TFillY(), f) else f
// 			},
// 			dropSize
// 		)
// 	}

// 	MIfLazy(
// 		fselect(manager.manager.dragging, 
// 		FLift(\dr -> 
// 			(dr >= 0) &&
// 			(dr < length(getValue(state.title))) &&
// 			zorder >= getValue(manager.manager.zorder) &&
// 			(dr < length(getValue(groupA))) &&
// 			(contains(getValue(groupA)[dr], groupName))
// 		)
// 	),	\e -> if (e) {

// 			MGroup([
// 				MDropSpot2(onHover, onDrop, 		
// 					// MGroup([
// 						// resizeBar , //|> offSetBar, !!!!!!!!!!!!	
// 						TRectangle([MFill(if (resizeW) {if (isEndpoint) MYellowA(500) else MBlue(500) } else {if (isEndpoint) MYellowA(500) else MGreen(500) }), FillOpacity(0.6)], dropSize)
// 						// TRectangle([MFill(dockingPrimaryColor), FillOpacity(dockingHelperDropOpacity)], colSizeDropBig)  //|> offSetHelper // Hightlight allowed droppimg areas

// 							|> (\f -> MGroup2(f, MCenterIn(
// 							// 	MLines2(
// 							// 		MText(i2s(id), [MOverline(), MBlack()]),
// 									MText(toString(order), [MOverline(), MBlack()])
// 								, dropSize))),

// 						// MText(i2s(id), [if (isLastCol) MBlue(600) else MOrange(600), MCaptionSolid() ])  // debug
// 						// |>(\f -> if (isColumn) f |> MBorderLeft(16.0)|>MBorderTop(512.0) else  f |>MBorderLeft(128.0))
// 						// hoveringBar |> offSetHover
// 					// ]), 
// 					false
// 				),
// 				// hoveringBar |> offSetHover
// 				MConstruct([
// 					makeSubscribe(onHover, \h -> if (h >= 0) {
// 							next(isDockingCol, isColumn);
// 							next(panelsOrderB, order);
// 							next(lastDropSizeB, dropSize);
// 							next(isRow, updateRow);
// 							// next(isRow, !(isColumn && resizeW));
							
// 							// dockedLength = if (getValue(isDockingCol)) getTropicMetri cs(getValue(lastDropSizeB)).width else getTropicMetrics(getValue(lastDropSizeB)).height;
// 							if (/*(*/getValue(isRow) /*&& (dockedLength == getTropicMetrics(m2t(getValue(state.dropSize)[h])).width))*/) next(hovering, true)
// 								else if (!getValue(isRow)) next(hovering, true)
// 									else next(hovering, false);
// 						} else next(hovering, false)
// 					),
// 					makeSubscribe(panelsOrderB, \o -> {
// 						println(" -> panelsOrderB: " + toString(o));
// 					}),
// 					// On drop function
// 					makeSubscribe(onDrop, \d -> if (d >= 0) {
// 						updateDockingPositions(d, areaId, dockA, panelsArray, panelsOrderB, isRow);
// 						// println(" > " + toString(order));
// 					})],
// 					MShowLazy(hovering, \ -> TRectangle([MFill(dockingDropLineHoverColor), FillOpacity(dockingDropLineHoverOpacity)], hoverSize))
// 					// MShowLazy(hovering, \ -> MFrame(4.0, 4.0, [MFill(dockingDropLineHoverColor), FillOpacity(dockingDropLineHoverOpacity)], hoverSize))// |> offSetHover
// 				) |> offSetHover
// 			])
// 		// } else MEmpty()
// 		} else resizeBar
// 	);
// }


updateDockingPositions(droppedId: int, areaId : int, dockA : DynamicBehaviour<[[int]]>, panelsArray : DynamicBehaviour<[[int]]>, panelsOrder : DynamicBehaviour<[int]>, isRow : DynamicBehaviour<bool>) -> void {
	tempA = make([]);
	// colId = getValue(panelsOrder)[0];
	// rowId = getValue(panelsOrder)[1];
	colId = firstElement(getValue(panelsOrder), 0);
	rowId = lastElement(getValue(panelsOrder), 0);


	println(" +++ (" + i2s(areaId) + ") updateDockingPositions - dropped: " + i2s(droppedId) + "    - " + toString(getValue(panelsOrder)));

	if (!fold(getValue(panelsArray), false, \acc, a -> acc || contains(a, droppedId))) {
		if (getValue(panelsArray) != [[]]) {


println("getValue(isRow)");
println(getValue(isRow));
println(" AAA - panelsArraypanelsArraypanelsArraypanelsArraypanelsArraypanelsArraypanelsArraypanelsArraypanelsArraypanelsArray");
		println(getValue(panelsArray));
		println("droppedId; " + i2s(droppedId));
		println(getValue(panelsOrder));


			if (getValue(isRow)) next(panelsArray, replace(getValue(panelsArray), colId, insertArray(getValue(panelsArray)[colId], rowId, droppedId)))
				else next(panelsArray, insertArray(getValue(panelsArray), colId, [droppedId]));

println("BBB - panelsArraypanelsArraypanelsArraypanelsArraypanelsArraypanelsArraypanelsArraypanelsArraypanelsArraypanelsArray");
		println(getValue(panelsArray));



		} else {
			println("error: empty panels array");
		}


	} else {
		colIndex = if (colId < length(getValue(panelsArray))) colId else (length(getValue(panelsArray)) - 1);
		prevPos = if (getValue(isRow)) elemIndex(getValue(panelsArray)[colIndex], droppedId, -intMax) else elemIndex(getValue(panelsArray), [droppedId], -intMax);

		println("prevPosprevPosprevPosprevPosprevPosprevPosprevPosprevPosprevPos");
		println(prevPos);



		if (prevPos == -intMax) {

			replaced = if (getValue(isRow)) {
				index = if (colId < length(getValue(panelsArray))) colId else (length(getValue(panelsArray)) - 1);
				replace(getValue(panelsArray), index, insertArray(getValue(panelsArray)[index], rowId, droppedId));
			} else {
				insertArray(getValue(panelsArray), colId, [droppedId]);
			}
			next(panelsArray, mapi(replaced, \i, item -> if (i == colId) item else removeFirst(item, droppedId)));

		} else {
			if (getValue(isRow)) {
				updated = if (prevPos <= rowId) {
					inserted = insertArray(getValue(panelsArray)[colIndex], rowId, droppedId);
					removeIndex(inserted, prevPos);
				} else {
					uniq(insertArray(getValue(panelsArray)[colId], rowId, droppedId));
				};
				next(panelsArray, replace(getValue(panelsArray), colId, updated));
			} else {
				updated = if (prevPos <= colId) {
					inserted = insertArray(getValue(panelsArray), colId, [droppedId]);
					removed = mapi(inserted, \i, item -> if (i == colId) item else removeFirst(item, droppedId));
					removeIndex(removed, prevPos);
				} else {
					uniq(insertArray(getValue(panelsArray), colId, [droppedId]));
				};
				next(panelsArray, updated);
			}
		}
	};
	//Update state
	println(" AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA");
	println(getValue(dockA));

	next(tempA, getValue(dockA));
	iteri(getValue(panelsArray), \i, item -> {
		index = if (i < length(getValue(panelsArray))) i else length(getValue(panelsArray)) - 1;
		iteri(item, \j, itm -> next(tempA, replace(getValue(tempA), itm, [areaId, index, j])));
	});
	println(" BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB");

	println(getValue(tempA));
	next(dockA, getValue(tempA));
}