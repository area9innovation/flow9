import material/material_ui;
import material/extra/docking_ui/internal/material_docking_state;
import material/extra/docking_ui/internal/material_docking_theme;

export {
	// The place where we can drop panels
	dockingDropLine(
		dropInfo : MDockingDropInfo,
		state : MDockingState,   
		defPanelsOrder : [int],  // colId, rowId
		color : MColor,  
		size : Tropic,
		inactiveBar : Material,
		defRow : bool,  
		defDockingCol : bool,  
		zorder : int,
		style : [MDockingStyle]
	) -> Material;

	// Drop info
	MDockingDropInfo(
		areaId : int, 
		groupName : string, 
		onDragging : DynamicBehaviour<int>,
		onDrop : DynamicBehaviour<int>,
		order : DynamicBehaviour<[int]>,
		dockedPanelsGrid : DynamicBehaviour<[[int]]>,
		isDockingCol : DynamicBehaviour<bool>,
		isRow : DynamicBehaviour<bool>,
		lastDropSize : DynamicBehaviour<Tropic>
	);
}



dockingDropLine(
	dropInfo : MDockingDropInfo,
	state : MDockingState,   
	defPanelsOrderA : [int], // colId, rowId
	color : MColor,  //note necessary
	size : Tropic,
	inactiveBar : Material,
	defRow : bool,  
	defDockingCol : bool,  
	zorder : int,  //maybe not necssary
	style : [MDockingStyle]
) -> Material {

	manager = state.manager;
	dockA = state.dock;
	groupA = state.group;
	onHover = make(-1);
	hoverColor = dockingDropLineHoverColor;
	dropLineOpacity = dockingDropLineOpacity;
	dropLineOpacityHover = 1.0;
	hovering = make(false);

isColumn = defDockingCol;
colSizeDropBig = if (isColumn) TFillWY(dockingHelperDropSize) else TFillXH(dockingHelperDropSize);

	dropSize = dockingDragSize;
	dropSizeBig = dockingHelperDropSize;
	dragSizeBig = dockingHelperDragSize;


	isRightCol  = contains(style, MDockingRightCols());
	isBottomLine = contains(style, MDockingBottomtLines());


	offSetBar =  \f : Material -> MOffset(
								if (isColumn) (dropSizeBig - dropSize) * (if (isRightCol) 0.0 else 1.0) else 0.0,
								if (isColumn) 0.0 else (dropSizeBig - dropSize) * (if (isBottomLine) 0.0 else 1.0), 
								f
							);


	offSetBar2 =  \f : Material -> MOffset(
								if (isColumn) abs(dropSizeBig - dragSizeBig) * (if (isRightCol) 0.0 else 1.0) else 0.0,
								if (isColumn) 0.0 else abs(dropSizeBig - dragSizeBig) * (if (isBottomLine) 0.0 else 1.0), 
								f
							);




	// Drop info
	areaId = dropInfo.areaId;
	groupName = dropInfo.groupName; 
	isDragging = dropInfo.onDragging;
	onDrop = dropInfo.onDrop;
	panelsOrder = dropInfo.order;
	panelsArray = dropInfo.dockedPanelsGrid;
	isDockingCol = dropInfo.isDockingCol;
	isRow = dropInfo.isRow; 
	lastDropSize = dropInfo.lastDropSize;

	// MSelect(manager.manager.dragging, \dr -> {
		// if ((dr >= 0) && (dr < length(getValue(state.title))) && zorder >= getValue(manager.manager.zorder) && (dr < length(getValue(groupA))) && (contains(getValue(groupA)[dr], groupName))) {
			
		MIfLazy(fselect(manager.manager.dragging, FLift(\dr -> 
			(dr >= 0) &&
			(dr < length(getValue(state.title))) &&
			zorder >= getValue(manager.manager.zorder) &&
			(dr < length(getValue(groupA))) &&
			(contains(getValue(groupA)[dr], groupName))
		)),	\e -> if (e) {
			MGroup([
				// MDropSpot2(onHover, onDrop, TRectangle([MFill(MTeal(500)), FillOpacity(dropLineOpacity)], size), false),
				// MDropSpot2(onHover, onDrop, TRectangle([MFill(color), FillOpacity(dropLineOpacity)], size), false),
				MDropSpot2(onHover, onDrop, 
					
					MGroup([
						inactiveBar |> offSetBar2,
						// TRectangle([MFill(color), FillOpacity(dropLineOpacity)], size) // Hightlight allowed droppimg areas
						// TRectangle([MFill(MYellow(600)), FillOpacity(1.0)], size) |> offSetBar // Hightlight allowed droppimg areas

						// |> (\f -> MOffset(
						// 		if (isColumn) (dropSizeBig - dropSize) * (if (isRightCol) 0.0 else 1.0) else 0.0,
						// 		if (isColumn) 0.0 else (dropSizeBig - dropSize) * (if (isBottomLine) 0.0 else 1.0), 
						// 		f
						// 	)),

						TRectangle([MFill(MBlue(500)), FillOpacity(0.05)], colSizeDropBig)
						// TRectangle([MFill(MBlue(500)), FillOpacity(dockingHelperDropOpacity)], colSizeDropBig)
							|> (\f -> MBorder(
								if (isRightCol) {if (isColumn) 0.0 else dockingDropSize} else 0.0, 0.0,
								if (!isRightCol) {if (isColumn) 0.0 else dockingDropSize} else 0.0, 0.0, 
								f
							))



					]), false),
			
				MConstruct([
					makeSubscribe(onHover, \h -> if (h >= 0) {
							next(isDockingCol, defDockingCol);
							next(panelsOrder, defPanelsOrderA);
							next(lastDropSize, size);
							next(isRow, defRow);
							// dockedLength = if (getValue(isDockingCol)) getTropicMetri cs(getValue(lastDropSize)).width else getTropicMetrics(getValue(lastDropSize)).height;
							if (/*(*/getValue(isRow) /*&& (dockedLength == getTropicMetrics(m2t(getValue(state.size)[h])).width))*/) next(hovering, true)
								else if (!getValue(isRow)) next(hovering, true)
									else next(hovering, false);
						} else next(hovering, false)
					),
					makeSubscribe(onDrop, \d -> if (d >= 0) {
						updateDockingPositions(d, areaId, dockA, panelsArray, panelsOrder, isRow);
					})],
					MShowLazy(hovering, \ -> TRectangle([MFill(hoverColor), FillOpacity(dropLineOpacityHover)], size))
						|> offSetBar
					// MSelect(hovering, \h -> if (h) 
					// 	TRectangle([MFill(hoverColor), FillOpacity(dropLineOpacityHover)], size) 
					// 	else TEmpty()
					// )
				),



				// MSelect(onDrop,\dd -> MText(i2s(dd) + ", " + i2s(areaId) + "    " + toString(defPanelsOrderA), []))  //debug

			])

		} else inactiveBar
		// } else TRectangle([MFill(MGreen(500))], size)
		// } else TRectangle([MFill(MGrey(300))], size)
	);
}


dockingDropLineOLD(
	dropInfo : MDockingDropInfo,
	state : MDockingState,   
	defPanelsOrderA : [int], // colId, rowId
	color : MColor,  //note necessary
	size : Tropic, 
	defRow : bool,  
	defDockingCol : bool,  
	zorder : int  //maybe not necssary
) -> Material {

	manager = state.manager;
	dockA = state.dock;
	groupA = state.group;
	onHover = make(-1);
	hoverColor = dockingDropLineHoverColor;
	dropLineOpacity = dockingDropLineOpacity;
	dropLineOpacityHover = 1.0;
	hovering = make(false);

	// Drop info
	areaId = dropInfo.areaId;
	groupName = dropInfo.groupName; 
	isDragging = dropInfo.onDragging;
	onDrop = dropInfo.onDrop;
	panelsOrder = dropInfo.order;
	panelsArray = dropInfo.dockedPanelsGrid;
	isDockingCol = dropInfo.isDockingCol;
	isRow = dropInfo.isRow; 
	lastDropSize = dropInfo.lastDropSize;

	// MSelect(manager.manager.dragging, \dr -> {
		// if ((dr >= 0) && (dr < length(getValue(state.title))) && zorder >= getValue(manager.manager.zorder) && (dr < length(getValue(groupA))) && (contains(getValue(groupA)[dr], groupName))) {
			
		MIfLazy(fselect(manager.manager.dragging, FLift(\dr -> 
			(dr >= 0) &&
			(dr < length(getValue(state.title))) &&
			zorder >= getValue(manager.manager.zorder) &&
			(dr < length(getValue(groupA))) &&
			(contains(getValue(groupA)[dr], groupName))
		)),	\e -> if (e) {
			MGroup([
				MDropSpot2(onHover, onDrop, TRectangle([MFill(MTeal(500)), FillOpacity(dropLineOpacity)], size), false),
				// MDropSpot2(onHover, onDrop, TRectangle([MFill(color), FillOpacity(dropLineOpacity)], size), false),
				MConstruct([
					makeSubscribe(onHover, \h -> if (h >= 0) {
							next(isDockingCol, defDockingCol);
							next(panelsOrder, defPanelsOrderA);
							next(lastDropSize, size);
							next(isRow, defRow);
							// dockedLength = if (getValue(isDockingCol)) getTropicMetri cs(getValue(lastDropSize)).width else getTropicMetrics(getValue(lastDropSize)).height;
							if (/*(*/getValue(isRow) /*&& (dockedLength == getTropicMetrics(m2t(getValue(state.size)[h])).width))*/) next(hovering, true)
								else if (!getValue(isRow)) next(hovering, true)
									else next(hovering, false);
						} else next(hovering, false)
					),
					makeSubscribe(onDrop, \d -> if (d >= 0) {
						updateDockingPositions(d, areaId, dockA, panelsArray, panelsOrder, isRow);
					})],
					MShowLazy(hovering, \ -> TRectangle([MFill(hoverColor), FillOpacity(dropLineOpacityHover)], size))

					// MSelect(hovering, \h -> if (h) 
					// 	TRectangle([MFill(hoverColor), FillOpacity(dropLineOpacityHover)], size) 
					// 	else TEmpty()
					// )
				),



				MSelect(onDrop,\dd -> MText(i2s(dd) + ", " + i2s(areaId) + "    " + toString(defPanelsOrderA), []))  //debug


			])
		} else TRectangle([MFill(MGrey(300))], size)
	);
}



updateDockingPositions(droppedId: int, areaId : int, dockA : DynamicBehaviour<[[int]]>, panelsArray : DynamicBehaviour<[[int]]>, panelsOrder : DynamicBehaviour<[int]>, isRow : DynamicBehaviour<bool>) -> void {
	tempA = make([]);
	colId = getValue(panelsOrder)[0];
	rowId = getValue(panelsOrder)[1];

	println(" +++ updateDockingPositions - dropped: " + i2s(droppedId));

	if (!fold(getValue(panelsArray), false, \acc, a -> acc || contains(a, droppedId))) {
		if (getValue(panelsArray) != [[]]) {
			if (getValue(isRow)) next(panelsArray, replace(getValue(panelsArray), colId, insertArray(getValue(panelsArray)[colId], rowId, droppedId)))
				else next(panelsArray, insertArray(getValue(panelsArray), colId, [droppedId]));
		} else {
			println("error: empty panels array");
		}
	} else {
		colIndex = if (colId < length(getValue(panelsArray))) colId else (length(getValue(panelsArray)) - 1);
		prevPos = if (getValue(isRow)) elemIndex(getValue(panelsArray)[colIndex], droppedId, -intMax) else elemIndex(getValue(panelsArray), [droppedId], -intMax);
		if (prevPos == -intMax) {

			replaced = if (getValue(isRow)) {
				index = if (colId < length(getValue(panelsArray))) colId else (length(getValue(panelsArray)) - 1);
				replace(getValue(panelsArray), index, insertArray(getValue(panelsArray)[index], rowId, droppedId));
			} else {
				insertArray(getValue(panelsArray), colId, [droppedId]);
			}
			next(panelsArray, mapi(replaced, \i, item -> if (i == colId) item else removeFirst(item, droppedId)));

		} else {
			if (getValue(isRow)) {
				updated = if (prevPos <= rowId) {
					inserted = insertArray(getValue(panelsArray)[colIndex], rowId, droppedId);
					removeIndex(inserted, prevPos);
				} else {
					uniq(insertArray(getValue(panelsArray)[colId], rowId, droppedId));
				};
				next(panelsArray, replace(getValue(panelsArray), colId, updated));
			} else {
				updated = if (prevPos <= colId) {
					inserted = insertArray(getValue(panelsArray), colId, [droppedId]);
					removed = mapi(inserted, \i, item -> if (i == colId) item else removeFirst(item, droppedId));
					removeIndex(removed, prevPos);
				} else {
					uniq(insertArray(getValue(panelsArray), colId, [droppedId]));
				};
				next(panelsArray, updated);
			}
		}
	};
	//Update state
	next(tempA, getValue(dockA));
	iteri(getValue(panelsArray), \i, item -> {
		index = if (i < length(getValue(panelsArray))) i else length(getValue(panelsArray)) - 1;
		iteri(item, \j, itm -> next(tempA, replace(getValue(tempA), itm, [areaId, index, j])));
	});
	next(dockA, getValue(tempA));
}