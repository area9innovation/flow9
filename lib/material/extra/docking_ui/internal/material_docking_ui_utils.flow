import material/extra/docking_ui/internal/material_docking_styles;
import material/extra/docking_ui/internal/material_docking_theme;
import material/extra/docking_ui/internal/material_docking_state;



export {
	// The place where we can drop panels
	dockingDropLine(
		state : MDockingState, 
		onDrop : DynamicBehaviour<int>, 
		panelsArray : DynamicBehaviour<[[int]]>, 
		defPanelsOrder : [int],
		id : int, 
		groupName : string, 
		color : MColor, 
		panelsOrder : DynamicBehaviour<[int]>, 
		size : Tropic, 
		defRow : bool, 
		isRow : DynamicBehaviour<bool>,
		lastDropSize : DynamicBehaviour<Tropic>, 
		defDockingCol : bool, 
		isDockingCol : DynamicBehaviour<bool>, 
		zorder : int
	) -> Material;

	// Get docked panels IDs into an area of given areaId 
	extractDockedPanelsId(dockA: [[int]], areaId : int) -> [[int]];

	// makeMDockingSideExpanderBtn(light : bool, sideExpanded : bool, isRightCol : bool, redraw : DynamicBehaviour<bool>, singleColA : [int], style : [MDockingStyle]) -> Material;

	// Handles
	makeMDockingResizeHandleMobile(state : MDockingState, style : [MDockingStyle]) -> Material;
	makeMDockingLinedHandle(isHorizontal : bool, titleColor : MColor) -> Material;
	makeMDockingDottedHandle(isColumn : bool, color : MColor) -> Material;

	// Utils
	showIf(cond : bool) -> (Material) -> Material;
	
	// Debug prints
	makeMDockingDebugPrints(state : MDockingState) -> Material;
}










// makeMDockingSideExpanderBtn(light : bool, sideExpanded : bool, isRightCol : bool, redraw : DynamicBehaviour<bool>, singleColA : [int], style : [MDockingStyle]) -> Material {
// 	sideExpFn = \ -> {
// 		iter(singleColA, \c -> reverseBehaviour(getValue(state.sideExpanded)[c]));
// 		reverseBehaviour(redraw);
// 	}

// 	sideExpBtnLabel = if (isRightCol) {
// 		if (sideExpanded) "skip_next" else "skip_previous";
// 	} else {
// 		if (!sideExpanded) "skip_next" else "skip_previous";
// 	}

// 	sideExpBtnItem = \lg : bool -> MGroup2(
// 		TRectangle([MFill(sideExpanderBgColorFn(lg, style))], TFillXH(sideExpanderButtonSize)),
// 		if (isRightCol) MColsA([TFillX(), MIcon(sideExpBtnLabel, [MIconSize(sideExpanderButtonSize - 2.0), dockedTitleColorFn(lg, style)]), TFixed(2.0, 2.0)])
// 		else MColsA([TFixed(2.0, 2.0), MIcon(sideExpBtnLabel, [MIconSize(sideExpanderButtonSize - 2.0), dockedTitleColorFn(lg, style)]), TFillX()]),
// 	);

// 	sideExpBtnItemHover = \lg : bool -> MGroup2(
// 		TRectangle([MFill(sideExpanderHoverColorFn(lg, style))], TFillXH(sideExpanderButtonSize)),
// 		if (isRightCol) MColsA([TFillX(), MIcon(sideExpBtnLabel, [MIconSize(sideExpanderButtonSize - 2.0), dockedTitleColorFn(lg, style)]), TFixed(2.0, 2.0),])
// 		else MColsA([TFixed(2.0, 2.0), MIcon(sideExpBtnLabel, [MIconSize(sideExpanderButtonSize - 2.0), dockedTitleColorFn(lg, style)])]),
// 	) ;

// 	MRawButton(sideExpBtnItem(light), sideExpBtnItemHover(light), sideExpBtnItem(light), sideExpBtnItem(light),	"", [], [TOnClicked(sideExpFn)]);
// }







dockingDropLine(state : MDockingState, onDrop : DynamicBehaviour<int>, panelsArray : DynamicBehaviour<[[int]]>, defPanelsOrder : [int],
	id : int, groupName : string, color : MColor, panelsOrder : DynamicBehaviour<[int]>, size : Tropic, defRow : bool, isRow : DynamicBehaviour<bool>,
	lastDropSize : DynamicBehaviour<Tropic>, defDockingCol : bool, isDockingCol : DynamicBehaviour<bool>, zorder : int) -> Material {

	manager = state.manager;
	dockA = state.dock;
	groupA = state.group;
	onHover = make(-1);
	hoverColor = dockingDropLineHoverColor;
	dropLineOpacity = dockingDropLineOpacity;
	dropLineOpacityHover = 1.0;
	hovering = make(false);

	MSelect(manager.manager.dragging, \dr ->
		if ((dr >= 0) && (dr < length(getValue(state.title))) && zorder >= getValue(manager.manager.zorder) && (dr < length(getValue(groupA))) && (contains(getValue(groupA)[dr], groupName))) {
			MGroup([
				MDropSpot2(onHover, onDrop, TRectangle([MFill(color), FillOpacity(dropLineOpacity)], size), false),
				MConstruct([
					makeSubscribe(onHover, \h -> if (h >= 0) {
							next(isDockingCol, defDockingCol);
							next(panelsOrder, [defPanelsOrder[0], defPanelsOrder[1]]);
							next(lastDropSize, size);
							next(isRow, defRow);
							// dockedLength = if (getValue(isDockingCol)) getTropicMetri cs(getValue(lastDropSize)).width else getTropicMetrics(getValue(lastDropSize)).height;
							if (/*(*/getValue(isRow) /*&& (dockedLength == getTropicMetrics(m2t(getValue(state.size)[h])).width))*/) next(hovering, true)
								else if (!getValue(isRow)) next(hovering, true)
									else next(hovering, false);
						} else next(hovering, false)
					),
					makeSubscribe(onDrop, \d -> if (d >= 0) {
						updateDockingPositions(d, id, dockA, panelsArray, panelsOrder, isRow);
					})],
					MSelect(hovering, \h -> if (h) TRectangle([MFill(hoverColor), FillOpacity(dropLineOpacityHover)], size) else TEmpty())
				)
			]);
		} else
		TRectangle([MFill(MGrey(300))], size)
	);
}

updateDockingPositions(d: int, id : int, dockA : DynamicBehaviour<[[int]]>, panelsArray : DynamicBehaviour<[[int]]>, panelsOrder : DynamicBehaviour<[int]>, isRow : DynamicBehaviour<bool>) -> void {
	tempA = make([]);
	colId = getValue(panelsOrder)[0];
	rowId = getValue(panelsOrder)[1];

	if (!fold(getValue(panelsArray), false, \acc, a -> acc || contains(a, d))) {
		if (getValue(panelsArray) != [[]]) {
			if (getValue(isRow)) next(panelsArray, replace(getValue(panelsArray), colId, insertArray(getValue(panelsArray)[colId], rowId, d)))
				else next(panelsArray, insertArray(getValue(panelsArray), colId, [d]));
		} else {
			println("error: empty panels array");
		}
	} else {
		colIndex = if (colId < length(getValue(panelsArray))) colId else (length(getValue(panelsArray)) - 1);
		prevPos = if (getValue(isRow)) elemIndex(getValue(panelsArray)[colIndex], d, -intMax) else elemIndex(getValue(panelsArray), [d], -intMax);
		if (prevPos == -intMax) {

			replaced = if (getValue(isRow)) {
				index = if (colId < length(getValue(panelsArray))) colId else (length(getValue(panelsArray)) - 1);
				replace(getValue(panelsArray), index, insertArray(getValue(panelsArray)[index], rowId, d));
			} else {
				insertArray(getValue(panelsArray), colId, [d]);
			}
			next(panelsArray, mapi(replaced, \i, item -> if (i == colId) item else removeFirst(item, d)));

		} else {
			if (getValue(isRow)) {
				updated = if (prevPos <= rowId) {
					inserted = insertArray(getValue(panelsArray)[colIndex], rowId, d);
					removeIndex(inserted, prevPos);
				} else {
					uniq(insertArray(getValue(panelsArray)[colId], rowId, d));
				};
				next(panelsArray, replace(getValue(panelsArray), colId, updated));
			} else {
				updated = if (prevPos <= colId) {
					inserted = insertArray(getValue(panelsArray), colId, [d]);
					removed = mapi(inserted, \i, item -> if (i == colId) item else removeFirst(item, d));
					removeIndex(removed, prevPos);
				} else {
					uniq(insertArray(getValue(panelsArray), colId, [d]));
				};
				next(panelsArray, updated);
			}
		}
	};
	//Update state
	next(tempA, getValue(dockA));
	iteri(getValue(panelsArray), \i, item -> {
		index = if (i < length(getValue(panelsArray))) i else length(getValue(panelsArray)) - 1;
		iteri(item, \j, itm -> next(tempA, replace(getValue(tempA), itm, [id, index, j])));
	});
	next(dockA, getValue(tempA));
}

extractDockedPanelsId(dockA: [[int]], areaId : int) -> [[int]] {
	// println(" - dockA");
	// println(dockA);
	// println(" - areaID: " + i2s(areaId));

	areaIdSorted = sortCustom(filter(mapi(dockA, \i : int, v : [int] -> if (v[0] == areaId) [v[1], v[2], i] else []), \item -> item != []), \v -> v, true);
	// println(" - dockIdSorted");
	// println(areaIdSorted);

	colsIdSorted = map(areaIdSorted, \item -> item[2]);
	// println(" - colsIdSorted");
	// println(colsIdSorted);

	colGroups = sortCustom(filter(uniq(map(dockA, \v -> if (v[0] == areaId) v[1] else -intMax)), \v -> v >= 0), \v -> v, true);
	// println(" - colGroups");
	// println(colGroups);

	out = 
	filter(map(colGroups, \item -> filter(map(colsIdSorted, \c -> if (dockA[c][1] == item ) c else -intMax), \itm -> itm != -intMax)), \item -> item != []);
	// println(" - out");
	// println(out);
	// println("");
out;
}



makeMDockingResizeHandleMobile(state : MDockingState, style : [MDockingStyle]) -> Material {
	dot = TRounded(1.0, 1.0, 1.0, 1.0, [MThemeFill(state.manager, MThemedColor(mobileHandleColorFn(true, style), mobileHandleColorFn(false, style)))], TFixed(1.0, 1.0));
	gapW = TFixed(2.0, 0.0);
	gapH = TFixed(0.0, 2.0);
	cornerSpace = TFixed(24.0, 18.0);

	MLines([
		TFillY(),
		MColsA([
			TFillX(),
			MCursor(
				MoveCursor(),
				MGroup2(
					TRectangle(interactiveRectangleStyle, cornerSpace),
					MAvailable(
						MLines([
							TFillY(),
							MColsA([
								TFillX(),
								MLines([
									MColsA([TFixed(6.0, 0.0), dot]),
									gapH,
									MColsA([TFixed(3.0, 0.0), dot, gapW, dot]),
									gapH,
									MColsA([dot, gapW, dot, gapW, dot])
								]),
								TFixed(3.0, 0.0)
							]),
							TFixed(0.0, 3.0)
						]),
						cornerSpace
					)
				)
			)
		])
	]);
};

makeMDockingLinedHandle(isHorizontal : bool, titleColor : MColor) -> Material {
	handleWidth = 24.0;
	if (isHorizontal) {
		MCenterIn(
			MColsA([
				TRounded(1.0, 1.0, 1.0, 1.0, [MFill(titleColor)], TFixed(1.0, 18.0)),
				TFixed(2.0, 0.0),
				TRounded(1.0, 1.0, 1.0, 1.0, [MFill(titleColor)], TFixed(1.0, 18.0))
			]),
			TFixed(dockingBarHeight, handleWidth)
		);
	} else {
		MCenterIn(
			MLines([
				TRounded(1.0, 1.0, 1.0, 1.0, [MFill(titleColor)], TFixed(18.0, 1.0)),
				TFixed(0.0, 2.0),
				TRounded(1.0, 1.0, 1.0, 1.0, [MFill(titleColor)], TFixed(18.0, 1.0))
			]),
			TFixed(handleWidth, dockingBarHeight)
		);
	};
};

makeMDockingDottedHandle(isColumn : bool, color : MColor) -> Material {
		r = 2.0;
		t = 1.0;
		handleWidth = 24.0;
		if (isColumn) {
			TGroup2(
				TRectangle(interactiveRectangleStyle, TFixed(handleWidth, dockingBarHeight)),
				TCenterIn(
					TCols([
						TLines([TRounded(r, r, r, r, [MFill(color)], TFixed(t, t)), TFixed(0.0, 2.0), TRounded(r, r, r, r, [MFill(color)], TFixed(t, t))]),
						TFixed(2.0, 0.0),
						TLines([TRounded(r, r, r, r, [MFill(color)], TFixed(t, t)), TFixed(0.0, 2.0), TRounded(r, r, r, r, [MFill(color)], TFixed(t, t))]),
						TFixed(2.0, 0.0),
						TLines([TRounded(r, r, r, r, [MFill(color)], TFixed(t, t)), TFixed(0.0, 2.0), TRounded(r, r, r, r, [MFill(color)], TFixed(t, t))]),
						TFixed(2.0, 0.0),
						TLines([TRounded(r, r, r, r, [MFill(color)], TFixed(t, t)), TFixed(0.0, 2.0), TRounded(r, r, r, r, [MFill(color)], TFixed(t, t))]),
					]),
					TFixed(handleWidth, dockingBarHeight / 2.0)
				)
			);
		} else {
			TGroup2(
				TRectangle(interactiveRectangleStyle, TFixed(dockingBarHeight / 2.0, handleWidth)),
				TCenterIn(
					TLines([
						TCols([TRounded(r, r, r, r, [MFill(color)], TFixed(t, t)), TFixed(2.0, 0.0), TRounded(r, r, r, r, [MFill(color)], TFixed(t, t))]),
						TFixed(0.0, 2.0),
						TCols([TRounded(r, r, r, r, [MFill(color)], TFixed(t, t)), TFixed(2.0, 0.0), TRounded(r, r, r, r, [MFill(color)], TFixed(t, t))]),
						TFixed(0.0, 2.0),
						TCols([TRounded(r, r, r, r, [MFill(color)], TFixed(t, t)), TFixed(2.0, 0.0), TRounded(r, r, r, r, [MFill(color)], TFixed(t, t))]),
						TFixed(0.0, 2.0),
						TCols([TRounded(r, r, r, r, [MFill(color)], TFixed(t, t)), TFixed(2.0, 0.0), TRounded(r, r, r, r, [MFill(color)], TFixed(t, t))]),
					]),
					TFixed(dockingBarHeight / 2.0, handleWidth)
				)
			);
		};
	};

	
showIf(cond : bool) -> (Material) -> Material {
	\m -> if (cond) m else TEmpty()
}

makeMDockingDebugPrints(state : MDockingState) -> Material {
	MConstruct([
			makeSubscribe(state.dock, \dockA -> {
				println("- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ");
				println("State.dock :  DynamicBehaviour<[[int]]> -  stores UI layout");
				println("- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ");
				println(dockA);
				iter(dockA,\panelDockInfoA -> {
					areaId = panelDockInfoA[0];
					colID = panelDockInfoA[1];
					panelId = panelDockInfoA[2];
					printSpace = if (panelId<10) " "  else "";
					// println("Panel " + printSpace +  i2s(i) + " - " + toString(panelDockInfoA));
					println("[areaID: " + i2s(areaId) + ",   colID: " + i2s(colID) + ",   panelID: " + printSpace + i2s(panelId) + "]    " + getValue(state.title)[panelId]);
				});
				println("");

				// Print area's docked panels
				areaIDs = uniq(fold(dockA, [], \acc, p ->if (p != []) arrayPush(acc, p[0]) else acc));
				iter(areaIDs,\areaId -> if (areaId > 0) println("Area " + i2s(areaId) + " contains: " + toString(extractDockedPanelsId(dockA, areaId))));
				println("Mobile: " + toString(extractDockedPanelsId(dockA, -1)));
				println("");
			}),
			// makeSubscribe(state.size, \sizeA -> {
			// 	println("State.size :  DynamicBehaviour<[Tropic]>");
			// 	println("");
			// 	iteri(sizeA,\i,s -> println(i2s(i) + " - " + toString(s)));
			// 	println("");
			// }),
			// makeSubscribe(state.mobileSize, \sizeA -> {
			// 	println("State.mobileSize :  DynamicBehaviour<[Tropic]>");
			// 	println("");
			// 	iteri(sizeA,\i,s -> println(i2s(i) + " - " + toString(s)));
			// 	println("");
			// }),
			// makeSubscribe(state.dockedSize, \sizeA -> {
			// 	println("State.dockedSize :  DynamicBehaviour<[Tropic]>");
			// 	println("");
			// 	iteri(sizeA,\i,s -> println(i2s(i) + " - " + toString(s)));
			// 	println("");
			// }),
			makeSubscribe(state.positions, \positionA -> {
				println("State.positions :  DynamicBehaviour<[DynamicBehaviour<Point>]>");
				println("");
				iteri(positionA,\i,p -> println(i2s(i) + " - " + toString(p)));
				println("");
			}),
		],
		TRectangle(interactiveRectangleStyle, TFillXY())
	)
}