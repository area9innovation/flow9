import material/material;
import material/internal/types;
import material/internal/material_util;

import material/extra/docking_ui/internal/material_docking_state;
import material/extra/docking_ui/internal/material_docking_state_store;
import material/extra/docking_ui/internal/material_docking_styles;
import material/extra/docking_ui/internal/material_docking_theme;
import material/extra/docking_ui/internal/material_docking_areas;

export {

	// USAGE:
	// - Set up a dockable UI defining two main elements, "panels" and "layout", and stores layout changes into a "state".
	// - Define your panels as of array of MDockingPanels, each one differs for the content type (MDockingPanelItem)
	// - Inizialize the MDockingState with panel's information using "makeMDockingState" function
	// - Design your layout using MDockingAreas as dockable areas.

	// NOTE:
	// - MDockingAreas can act as a "dockable MCols" or "MLines" (by "isColumn")
	// - each MDockingArea has unique id
	// - different MDockingAreas can have the same groupName
	// - the groupNames are used by MDockingPanel in the "allowedGroups" field
	// - each panel can have a vertical or horizontal orientation, but its size is defined by default as vertical
	// - when docked on cols a panel will be shown as vertical, when on lines as horizontal
	// - when mobile a panel will be vertical, but you can flip it with MDockingMobileHorizontal() style
	// - example in flow9/lib/material/tests/test_docking_ui.flow

	MDockingUI(state : MDockingState, panels : [MDockingPanel], layout : Material, style : [MDockingStyle]) -> Material;
	MDockingArea(isColumn : bool, state : MDockingState, groupName : string, id : int, style : [MDockingStyle]) -> Material;
}



MDockingArea(isColumn : bool, state : MDockingState, groupName : string, id : int, style : [MDockingStyle]) -> Material {
	// println("area" + i2s(id));
	MSelect(state.size, \szs ->
		if (szs != []) {
			manager = state.manager;
			itemId = makeTropicTag(manager);
			dockA = state.dock;
			groupA = state.group;
			contentA = getValue(state.content);
			sizeA = getValue(state.size);
			dockedSizeA = getValue(state.dockedSize);
			mobileSizeA = getValue(state.mobileSize);

			onDragging = manager.manager.dragging;
			dockedPanelsGrid = make([[]]);
			onDrop = make(-1);
			order = make([0, 0]);
			isRow = make(false);
			isDockingCol = make(true);
			lastDropSize = make(TEmpty());

			highlightDrop = make(true);
			zorder = getValue(manager.manager.zorder);

			dontResize  = contains(style, MDockingDontResize());
			dontScroll  = contains(style, MDockingDontScroll());
			dontSideExpand = contains(style, MDockingDontCollapseColumn());

			isRightCol  = contains(style, MDockingRightCols());
			isBottomLine = contains(style, MDockingBottomtLines());
			dontShowSep  = contains(style, MDockingDontShowSeparators());
			fillHeightArea = contains(style, MDockingFillSpace());

			darkTheme = contains(style, MDockingForceDarkTheme());
			theme = if (darkTheme) const(false) else manager.white;
			color = extractStruct(style, MBlue(600));
			vertical = !isColumn;

			overlayColor = MOrange(500);
			overlayOpacity = 0.6;
			dropSize = extractStruct(style, MDockingDropSize(dockingDropSize)).size;
			dragSize = dockingDragSize;
			handleHeight = dropSize;
			rowSize = if (isColumn) TFillXH(dropSize) else TFillWY(dropSize);
			colSize = if (isColumn) TFillWY(dropSize) else TFillXH(dropSize);
			colSizeDrag = if (isColumn) TFillWY(dragSize) else TFillXH(dragSize);

			pad = 10.0;
			redraw = make(false);
			sideExpandedA = map(contentA,\c -> make(false));


			WA = map(contentA,\c -> make(0.0));
			WRA = map(contentA,\c -> make(0.0));
			HA = map(contentA,\c -> make(0.0));
			HRA = map(contentA,\c -> make(0.0));

			panelSizeA = make([TEmpty()]);

			// Update panelSizeA with TopBar height
			iteri(sizeA, \i, s -> next(panelSizeA, replace(getValue(panelSizeA), i , TLines2(s, TFillXH(dockingBarHeight)))));



		
			MSelect2(redraw, dockA, \r, d -> {

				dockedPanelsCols = extractDockedPanelsId(d, id);
				next(dockedPanelsGrid, dockedPanelsCols);

				if (dockedPanelsCols != []) {

				droppingArea=
					mapi(dockedPanelsCols, \colId, singleColA -> {
						lastPanel = length(singleColA) - 1;
						resizePressedV = make(false);
						resizePressedH = make(false);
						isResizing = make(false);
						mouseXyLocal = make(zeroPoint);
						mouseXyLocalR = make(zeroPoint);
						numOfCols = length(dockedPanelsCols);

						containsDark = fold(singleColA, false, \acc, a -> acc || contains(getValue(state.style)[a], MDockingForceDarkTheme()));
						containsLight = fold(singleColA, false, \acc, a -> acc || contains(getValue(state.style)[a], MDockingForceLightTheme()));

						maxPanelSize = TSizeOf(TGroup(map(singleColA, \s -> if (dockedSizeA != []) dockedSizeA[s] else TEmpty())));

						panelsWidthA = map(singleColA, \s -> getTropicMetrics(getValue(state.size)[s]).width);
						dockedWidthA = map(singleColA, \s -> getTropicMetrics(getValue(state.dockedSize)[s]).width);
						mobileWidthA = map(singleColA, \s -> getTropicMetrics(getValue(state.mobileSize)[s]).width);

						panelsHeightA = map(singleColA, \s -> getTropicMetrics(getValue(state.size)[s]).height);
						dockedHeightA = map(singleColA, \s -> getTropicMetrics(getValue(state.dockedSize)[s]).height);
						mobileHeightA = map(singleColA, \s -> getTropicMetrics(getValue(state.mobileSize)[s]).height);

						maxPanelsWidth = either(maxA(panelsWidthA), -doubleMax);
						maxDockedWidth = either(maxA(dockedWidthA), -doubleMax);
						maxMobileWidth = either(maxA(mobileWidthA), -doubleMax);

						dontResizeAll = fold(singleColA, true, \acc, p -> acc && contains(getValue(state.style)[p], MDockingDontResize()));
						isToolbarItem = isSameStructType(getValue(state.content)[singleColA[0]][0], MDockingPanelToolbarItem("", []));

						// Side expanded state of panels
						se = getValue(getValue(state.sideExpanded)[singleColA[0]]);
						iter(singleColA, \c -> nextDistinct(getValue(state.sideExpanded)[c], se));

						colSpace = \k : double, idx : int -> {
							psize = TCols2(maxPanelSize, TFillWY(dragSize * k));
							if (isColumn) {
								if (se) TSelect(WA[colId], \w -> TFillWY(w  + (dragSize * k)))
									else TFillWY(dockingSideCollapsedSize + (dragSize * k));
							} else {
								if (se) TSelect(HA[colId], \h -> TFillXH(h  + (dragSize * k)))
									else TFillXH(dockingSideCollapsedSize  + (dragSize * k));
							}
						}

						droppingAreaSpace = \idx : int, len : int -> {
							if (idx == 0 && len == 1) {if (dontResizeAll || dontResize || isToolbarItem) colSpace(0.0, idx) else colSpace(1.0, idx)}
							else if (idx == 0 && len != 1) {if (isRightCol) colSpace(0.0, idx) else colSpace(1.0, idx)}
							else if (idx != 0 && colId == len - 1) colSpace(1.0, idx)
							else colSpace(1.0, idx)
						}

						// Single resizable column of docked panels with dragging handles
						singleColComplete = makeSingleResizableColFn(isColumn, state, groupName, id, redraw, WA, HA, dockedPanelsGrid, singleColA, colId, resizePressedH, resizePressedV, style);

						// Dropping line for cols
						makeOuterDroppingLine = \a : int, b : int -> {
							MSelect(onDragging, \dr -> {
								if ((dr >= 0) && (dr < length(getValue(groupA))) && (contains(getValue(groupA)[dr], groupName)))
									dockingDropLine(state, onDrop, dockedPanelsGrid, [a, b], id, groupName, color, order, colSize, false, isRow, lastDropSize, true, isDockingCol, zorder)
								else TEmpty();	
							});
						};

						// Dropping areas over docked panels
						overlayDroppingHandles = \ idx : int, len : int, lg : bool -> {
							if (idx == 0 && len == 1)
							[
								makeOuterDroppingLine(idx, 0),
								if (isColumn) TFillX() else TFillY(),
								makeOuterDroppingLine(idx + 1, 0),
							]
							else if (idx == 0 && len != 1)
							[
								makeOuterDroppingLine(idx, 0),
								if (isColumn) TFillX() else TFillY(),
								if (isRightCol) TEmpty() else makeOuterDroppingLine(idx + 1, 0),
							]
							else if (idx != 0 && colId == len - 1)
							[
								if (!isRightCol) TEmpty() else makeOuterDroppingLine(idx, 0),
								if (isColumn) TFillX() else TFillY(),
								makeOuterDroppingLine(idx + 1, 0),
							]
							else
							[
								if (!isRightCol) TEmpty() else makeOuterDroppingLine(idx, 0),
								if (isColumn) TFillX() else TFillY(),
								if (isRightCol) TEmpty() else makeOuterDroppingLine(idx + 1, 0),
							]
						}


						enabled = fmerge(map(singleColA, \sca -> getValue(state.enabled)[sca]));

						// Add dropping layer
						MSelect(enabled, \e -> {
							atLeastOneEnabledInCol = fold(singleColA, false, \acc, a -> acc || getValue(getValue(state.enabled)[a]));
							atLeastOneEnabled = fold(dockedPanelsCols, false, \acc, singleColA2 -> acc ||
								fold(singleColA2, false, \acc2, a -> acc2 || getValue(getValue(state.enabled)[a])));
							dontSideExpandPanel = fold(singleColA, false, \acc, p -> acc || contains(getValue(state.style)[p], MDockingDontCollapsePanel()));

							if (atLeastOneEnabledInCol) {
								MSelect(manager.white, \ww -> {
									light = if (containsDark) false else if (containsLight) true else ww;
									MAvailable(
										if (isColumn)
										MGroup([
											MColsA(singleColComplete(colId, numOfCols, light)),
											MLines2(
												if (dontSideExpand || dontSideExpandPanel) TEmpty() else TFillXH(sideExpanderButtonSize),
												MColsA(overlayDroppingHandles(colId, numOfCols, light))
											)
										]) else
										MGroup([
											MLines(singleColComplete(colId, numOfCols, light)),
											MLines(overlayDroppingHandles(colId, numOfCols, light)),
										]),
										droppingAreaSpace(colId, numOfCols)
									)
								});

							} else if (atLeastOneEnabled) {
								TEmpty();
							} else {
								// NO PANELS ENABLED
								dockingDropLine(state, onDrop, dockedPanelsGrid, [0, 0], id, groupName, color, order, colSize, false, isRow, lastDropSize, isColumn, isDockingCol, zorder);
							}
						});
					});



					// Docking area
					if (isColumn) MColsA(droppingArea) else MLines(droppingArea);

				} else {
					// NO PANELS DOCKED
					dockingDropLine(state, onDrop, dockedPanelsGrid, [0, 0], id, groupName, color, order, colSize, false, isRow, lastDropSize, isColumn, isDockingCol, zorder);
				}


			});

		} else TEmpty()

	);
	//|> (\f -> (MShadow(const(16.0), f)))
}

MDockingUI(state : MDockingState, panelsA : [MDockingPanel], layout : Material, style : [MDockingStyle]) -> Material {
	updateMDockingState(state, panelsA, style);
	manager = state.manager;
	titleA = state.title;
	panelIconA = state.panelIcon;
	contentA = state.content;
	dockA = state.dock;
	groupA = state.group;
	sizeA = state.size;
	mPositiosA = state.positions;
	expandedA = state.expanded;
	panelsStyleA = state.style;

	onDrop = make(-1);
	localPositionA = make([]);
	minimizedA = make([]);
	visibleA = make([]);
	defSizeA = make([]);
	start = make(false);
	positionScale = make(zeroPositionScale);
	zorder = getValue(manager.manager.zorder);
	isDragging = manager.manager.dragging;

	iteri(panelsA, \i, p -> {
		next(localPositionA, replace(getValue(localPositionA), i , zeroPoint));
		next(panelsStyleA, replace(getValue(panelsStyleA), i , p.style));
	});

	//overlay layout
	mainDropArea = 
		MConstruct([
			makeSubscribe(onDrop, \d -> {
				if (d >= 0) {
					pstyle = panelsA[d].style;
					width = getTropicMetrics(getValue(sizeA)[d]).width;
					height = getTropicMetrics(getValue(sizeA)[d]).height;
					posCorrection =
					if (getValue(dockA)[d][0] >= 0) {
							dx = if (d >= 0)  (width / 2.0) else 0.0; dy = 4.0; Point(dx, dy);
					} else {
						getValue(localPositionA)[d];
					}
					next(getValue(state.positions)[d], Point(
						manager.manager.xy().x  - posCorrection.x - getValue(positionScale).pos.x,
						manager.manager.xy().y - posCorrection.y - getValue(positionScale).pos.y
					));
					next(getValue(state.enabled)[d], true);
					if (getValue(dockA)[d][0] >= 0) next(dockA, mapi(getValue(dockA), \j, item -> if (j == d) [-1, item[1], item[2]] else item)); //undock panel
					next(localPositionA, replace(getValue(localPositionA), d, zeroPoint));

	println("| dropped panel " + i2s(d) +" |");
	println(getValue(state.positions)[d]);



				}
			})
		],
		// MSelect(manager.manager.dragging, \dr -> {
		// 	if ((dr >= 0) && (dr < length(panelsA)) && zorder >= getValue(manager.manager.zorder)) MDropSpot2(make(-1), onDrop, TRectangle(interactiveRectangleStyle, TFillXY()), false) else TEmpty()
		// }));

		MShow(fselect(isDragging, FLift(\dr -> (dr >= 0) && (dr < length(panelsA)) && zorder >= getValue(manager.manager.zorder))),
			// MDropSpot2(make(-1), onDrop, TRectangle(interactiveRectangleStyle, TFillXY()), false)
			MDropSpot2(make(-1), onDrop, TRectangle([MFill(MRed(500)), FillOpacity(0.05)], TFillXY()), false)  // REMOVE AFTER DEBUG
		));

	// movablePanels = mapi(panelsA, \i, p -> makeDockingPanel(false, state, i, "", false, false, [], 0.0, localPositionA, make(true), zorder));
	movablePanels = mapi(panelsA, \i, p -> makeMovablePanel(state, i, localPositionA));

	MInteractive([TMouseXY(state.mouseXy)],
		MGroup(concatA([
			// [makeMDockingDebugPrints(state)],        // Uncomment for debug prints
			[TPositionScale(positionScale, TRectangle([MFill(MGrey(100))], TFillXY()))],
			[MScroll(layout, TFillXY(), [])],
			movablePanels,
			[mainDropArea]
		]))
	);
}