import material/material;
import material/internal/types;
import material/internal/material_util;

import material/extra/docking_ui/internal/material_docking_state;
import material/extra/docking_ui/internal/material_docking_state_store;
import material/extra/docking_ui/internal/material_docking_styles;
import material/extra/docking_ui/internal/material_docking_theme;
import material/extra/docking_ui/internal/material_docking_areas;

export {

	// USAGE:
	// - Set up a dockable UI defining two main elements, "panels" and "layout", and stores layout changes into a "state".
	// - Define your panels as of array of MDockingPanels, each one differs for the content type (MDockingPanelItem)
	// - Inizialize the MDockingState with panel's information using "makeMDockingState" function
	// - Design your layout using MDockingAreas as dockable areas.

	// NOTE: example in flow9/lib/material/tests/test_docking_ui.flow

	MDockingUI(state : MDockingState, panels : [MDockingPanel], layout : Material, style : [MDockingStyle]) -> Material;
}


MDockingUI(state : MDockingState, panelsA : [MDockingPanel], layout : Material, style : [MDockingStyle]) -> Material {
	updateMDockingState(state, panelsA, style);
	manager = state.manager;
	titleA = state.title;
	panelIconA = state.panelIcon;
	contentA = state.content;
	dockA = state.dock;
	groupA = state.group;
	sizeA = state.size;
	mPositiosA = state.positions;
	expandedA = state.expanded;
	panelsStyleA = state.style;

	onDrop = make(-1);
	localPositionA = make([]);
	minimizedA = make([]);
	visibleA = make([]);
	defSizeA = make([]);
	start = make(false);
	positionScale = make(zeroPositionScale);
	zorder = getValue(manager.manager.zorder);
	isDragging = manager.manager.dragging;
	isDraggingT = fselect(isDragging, FLift(\dr -> (dr >= 0) && (dr < length(panelsA)) && zorder >= getValue(manager.manager.zorder)));

	iteri(panelsA, \i, p -> {
		next(localPositionA, replace(getValue(localPositionA), i , zeroPoint));
		next(panelsStyleA, replace(getValue(panelsStyleA), i , p.style));
	});

	//overlay layout
	movableDropArea = 
		MConstruct([
			makeSubscribe(onDrop, \d -> {
				if (d >= 0) {
					pstyle = panelsA[d].style;
					width = getTropicMetrics(getValue(sizeA)[d]).width;
					height = getTropicMetrics(getValue(sizeA)[d]).height;

					posCorrection =
						if (getValue(dockA)[d][0] >= 0) {
								dx = if (d >= 0)  (width / 2.0) else 0.0; dy = 4.0; Point(dx, dy);
						} else {
							getValue(localPositionA)[d];
						}

					next(getValue(state.positions)[d], Point(
						manager.manager.xy().x  - posCorrection.x - getValue(positionScale).pos.x,
						manager.manager.xy().y - posCorrection.y - getValue(positionScale).pos.y
					));

					next(getValue(state.enabled)[d], true);
					if (getValue(dockA)[d][0] >= 0) next(dockA, mapi(getValue(dockA), \j, item -> if (j == d) [-1, item[1], item[2]] else item)); //undock panel
					next(localPositionA, replace(getValue(localPositionA), d, zeroPoint));
				}
			})
		],
		MShow(isDraggingT,
			MDropSpot2(make(-1), onDrop, TRectangle(interactiveRectangleStyle, TFillXY()), false)
		));

// println(" > DRAW - MDocking UI ");

	movablePanelsLayer = mapi(panelsA, \i, p -> makeMovablePanel(state, i, localPositionA));
	// movablePanelsLayer = MSelect(fselect(state.dock,FLift(\d -> concatA(extractAreaGridById(getValue(dockA), -1)))), \m ->
	// MGroup(map(m, \p -> makeMovablePanel(state, p, localPositionA))));

	MInteractive([TMouseXY(state.mouseXy)],
		MGroup(concatA([
			// [makeMDockingDebugPrints(state)],        // Uncomment for debug prints
			[TPositionScale(positionScale, TRectangle([MFill(MGrey(100))], TFillXY()))],
			[MScroll(layout, TFillXY(), [])],
			movablePanelsLayer,
			[movableDropArea]
		])) 
	)
}



// Update MDockingState collecting data from panels and areas
updateMDockingState(state : MDockingState, panelsA : [MDockingPanel], style : [MDockingStyle]) -> void {
	titleA = state.title;
	panelIconA = state.panelIcon;
	contentA = state.content;
	dockA = state.dock;
	groupA = state.group;
	mPositiosA = state.positions;
	enabledA = state.enabled;
	expandedA = state.expanded;
	panelsStyleA = state.style;

	enableLoad = make(true);
	cacheEnabled = getValue(enableLoad);

	savedString = getKeyValue(state.keyGroupName |> addDockingSuffix, "");
	cachedPanelsA = if (cacheEnabled && savedString != "") {
		savedJson = parseJson(savedString);
		getJsonObjectValue(savedJson, []);	
	} else [];

	cachedPanelA = mapi(panelsA, \panelId, __ -> 
		getJsonFieldValue(parseJson(savedString), i2s(panelId), JsonNull())
	);

	// Update UI layout
	if (getValue(dockA) == [[]]) {
		iteri(panelsA, \panelId, p -> {
			cachedPanel = cachedPanelA[panelId];
			cAreaId = getJsonIntValue(getJsonFieldValue(cachedPanel, "areaId", JsonNull()), intMax);
			cColId = getJsonIntValue(getJsonFieldValue(cachedPanel, "colId", JsonNull()), intMax);
			aId = if (cacheEnabled && cAreaId != intMax) cAreaId else p.dockingAreaId;
			cId = if (cacheEnabled && cColId != intMax) cColId else p.order;
			next(dockA, replace(getValue(dockA), panelId , [aId, cId, panelId]));
		});
	};
	
	// Expanded
	if (getValue(state.expanded) == []) iteri(panelsA, \i, p -> {
		expandedB = extractStruct(p.style, MDPanelExpanded(make(true))).expanded;
		cExpanded = getJsonBoolValue(getJsonFieldValue(cachedPanelA[i], "expanded", JsonNull()), getValue(expandedB));
		expB = if (cacheEnabled) make(cExpanded) else expandedB;
		next(state.expanded, replace(getValue(state.expanded), i , expB))
	});

	// Side Expanded
	if (getValue(state.sideExpanded) == []) iteri(panelsA, \i, p -> {
		sideExpandedB = extractStruct(p.style, MDPanelSideExpanded(make(true))).sideExpanded;
		csideExpanded = getJsonBoolValue(getJsonFieldValue(cachedPanelA[i], "sideExpanded", JsonNull()), getValue(sideExpandedB));
		sExpB = if (cacheEnabled) make(csideExpanded) else sideExpandedB;
		next(state.sideExpanded, replace(getValue(state.sideExpanded), i , sExpB))
	});

	// Positions
	offsetP = extractStruct(style, MDockingMobileOffset(Point(72.0, 72.0))).offsetPosition;
	if (getValue(state.positions) == []) iteri(panelsA, \i, p -> {
		zeroPosition = Point(
			offsetP.x + 36.0 * i2d(i),
			offsetP.y + dockingItemHeight * i2d(i)
		);
		positionB = extractStruct(p.style, MDPanelPosition(make(zeroPosition))).position;
		cPosX = getJsonDoubleValue(getJsonFieldValue(cachedPanelA[i], "x", JsonNull()), getValue(positionB).x);
		cPosY = getJsonDoubleValue(getJsonFieldValue(cachedPanelA[i], "y", JsonNull()), getValue(positionB).y);
		posB = if (cacheEnabled) make(Point(cPosX, cPosY)) else positionB;
		next(state.positions, replace(getValue(state.positions), i , posB));
	});

	// Enabled
	if (getValue(state.enabled) == []) iteri(panelsA, \i, p -> {
		enabledB = extractStruct(p.style, MDPanelEnabled(make(true))).enabled;
		cEnabled = getJsonBoolValue(getJsonFieldValue(cachedPanelA[i], "enabled", JsonNull()), getValue(enabledB));
		enB = if (cacheEnabled) make(cEnabled) else enabledB;
		if (contains(p.style, MDockingDisabled())) next(enB, false);
		next(state.enabled, replace(getValue(state.enabled), i , enB));
	});

	if (getValue(titleA) == []) {
		iteri(panelsA, \i, p -> {
			next(titleA, replace(getValue(titleA), i , p.title));
			next(panelIconA, replace(getValue(panelIconA), i , p.panelIcon));
			next(contentA, replace(getValue(contentA), i , p.content));
			next(groupA, replace(getValue(groupA), i , p.allowedGroups));
			next(panelsStyleA, replace(getValue(panelsStyleA), i , p.style));

			content = getValue(state.content)[i];

			iter(getValue(contentA)[i], \itemA -> {

				switch (itemA : MDockingPanelItem) {
					// Toolbar
					MDockingPanelToolbarItem(ic, st): {
						minWidth = dockingItemHeight;
						dontShowSep = contains(p.style, MDockingDontShowSeparators());
						panelHeight = if (dontShowSep) (minWidth * i2d(length(content))) else (minWidth * i2d(length(content))) + (i2d(length(content)) - 1.0);
						size = TFixed(minWidth, panelHeight);
						next(state.size, replace(getValue(state.size), i , size));
						next(state.dockedSize, replace(getValue(state.dockedSize), i , size));
						next(state.mobileSize, replace(getValue(state.mobileSize), i , size));
					}
					// Panel of Buttons
					MDockingPanelButtonsItem(ic, lb, st): {
						minWidth = dockingItemHeight;
						width = extractStruct(p.style, MDockingPanelWidth(minWidth * 5.0)).width;
						dontShowSep = contains(p.style, MDockingDontShowSeparators());
						fillHeight = contains(p.style, MDockingFillSpace());

						panelHeight = if (dontShowSep) (minWidth * i2d(length(content))) else (minWidth * i2d(length(content))) + (i2d(length(content)) - 1.0);
						size = TFixed(width, panelHeight);
						dockedSize = if (fillHeight) TFillWY(width) else TFixed(width, panelHeight + dockingBarHeight + dockingDragSize);

						next(state.size, replace(getValue(state.size), i , size));
						next(state.dockedSize, replace(getValue(state.dockedSize), i , dockedSize));
						next(state.mobileSize, replace(getValue(state.mobileSize), i , size));
					}
					// Custom panels
					MDockingPanelCustomItem(mat, msize, st): {
						cWidth = getJsonDoubleValue(getJsonFieldValue(cachedPanelA[i], "w", JsonNull()), doubleMax);
						cHeight = getJsonDoubleValue(getJsonFieldValue(cachedPanelA[i], "h", JsonNull()), doubleMax);
						pWidth = if (cacheEnabled && (cWidth != doubleMax)) cWidth else msize.width;
						pHeight = if (cacheEnabled && (cHeight != doubleMax)) cHeight else msize.height;

						cDockedWidth = getJsonDoubleValue(getJsonFieldValue(cachedPanelA[i], "dockedW", JsonNull()), doubleMax);
						cDockedHeight = getJsonDoubleValue(getJsonFieldValue(cachedPanelA[i], "dockedH", JsonNull()), doubleMax);
						dockedWidth = if (cacheEnabled && (cDockedWidth != doubleMax)) cDockedWidth else msize.width;
						dockedHeight = if (cacheEnabled && (cDockedHeight != doubleMax)) cDockedHeight else msize.height;

						cMobileWidth = getJsonDoubleValue(getJsonFieldValue(cachedPanelA[i], "mobileW", JsonNull()), doubleMax);
						cMobileHeight = getJsonDoubleValue(getJsonFieldValue(cachedPanelA[i], "mobileH", JsonNull()), doubleMax);
						mobileWidth = if (cacheEnabled && (cMobileWidth != doubleMax)) cMobileWidth else msize.width;
						mobileHeight = if (cacheEnabled && (cMobileHeight != doubleMax)) cMobileHeight else msize.height;

						next(state.size, replace(getValue(state.size), i , TFixed(pWidth, pHeight)));
						next(state.mobileSize, replace(getValue(state.mobileSize), i , TFixed(mobileWidth, mobileHeight)));
						next(state.dockedSize, replace(getValue(state.dockedSize), i , TFixed(dockedWidth, dockedHeight)));
					}
				};
			});
		});
	}
}