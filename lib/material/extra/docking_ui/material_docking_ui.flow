import material/material;
import material/internal/types;
import material/internal/material_util;

import material/extra/docking_ui/internal/material_docking_state;
import material/extra/docking_ui/internal/material_docking_state_store;
import material/extra/docking_ui/internal/material_docking_styles;
import material/extra/docking_ui/internal/material_docking_theme;
import material/extra/docking_ui/internal/material_docking_areas;

export {

	// USAGE:
	// - Set up a dockable UI defining two main elements, "panels" and "layout", and stores layout changes into a "state".
	// - Define your panels as of array of MDockingPanels, each one differs for the content type (MDockingPanelItem)
	// - Inizialize the MDockingState with panel's information using "makeMDockingState" function
	// - Design your layout using MDockingAreas as dockable areas.

	// NOTE: example in flow9/lib/material/tests/test_docking_ui.flow

	MDockingUI(state : MDockingState, panels : [MDockingPanel], layout : Material, style : [MDockingStyle]) -> Material;
}


MDockingUI(state : MDockingState, panelsA : [MDockingPanel], layout : Material, style : [MDockingStyle]) -> Material {
	updateMDockingState(state, panelsA, style);
	manager = state.manager;
	titleA = state.title;
	panelIconA = state.panelIcon;
	contentA = state.content;
	dockA = state.dock;
	groupA = state.group;
	sizeA = state.size;
	mPositiosA = state.positions;
	expandedA = state.expanded;
	panelsStyleA = state.style;

	onDrop = make(-1);
	localPositionA = make([]);
	minimizedA = make([]);
	visibleA = make([]);
	defSizeA = make([]);
	start = make(false);
	positionScale = make(zeroPositionScale);
	zorder = getValue(manager.manager.zorder);
	isDragging = manager.manager.dragging;
	isDraggingT = fselect(isDragging, FLift(\dr -> (dr >= 0) && (dr < length(panelsA)) && zorder >= getValue(manager.manager.zorder)));

	iteri(panelsA, \i, p -> {
		next(localPositionA, replace(getValue(localPositionA), i , zeroPoint));
		next(panelsStyleA, replace(getValue(panelsStyleA), i , p.style));
	});

	//overlay layout
	movableDropArea = 
		MConstruct([
			makeSubscribe(localPositionA,\lp -> {
				// println("local: " + toString(lp[3]));
			}),
			makeSubscribe(onDrop, \d -> {
				if (d >= 0) {
					pstyle = panelsA[d].style;
					width = getTropicMetrics(getValue(sizeA)[d]).width;
					height = getTropicMetrics(getValue(sizeA)[d]).height;

					posCorrection =
						if (getValue(dockA)[d][0] >= 0) {
							// println("-NO");
								dx = if (d >= 0)  (width / 2.0) else 0.0; dy = 4.0; Point(dx, dy);
						} else {
							// println("-getLocal");
							getValue(localPositionA)[d];
						}


// println("onDROP:                        " + i2s(d));
// println("manager.manager.xy().x:        " + toString(manager.manager.xy().x));
// println("posCorrection.x:               " + toString(posCorrection.x));
// println("getValue(positionScale).pos.x: " + toString(getValue(positionScale).pos.x));
// println("tot:                           " + toString(manager.manager.xy().x - posCorrection.x - getValue(positionScale).pos.x));





					next(getValue(state.positions)[d], Point(
						manager.manager.xy().x  - posCorrection.x - getValue(positionScale).pos.x,
						manager.manager.xy().y - posCorrection.y - getValue(positionScale).pos.y
					));

					next(getValue(state.enabled)[d], true);
					if (getValue(dockA)[d][0] >= 0) next(dockA, mapi(getValue(dockA), \j, item -> if (j == d) [-1, item[1], item[2]] else item)); //undock panel
					next(localPositionA, replace(getValue(localPositionA), d, zeroPoint));
				}
			})
		],
		MShow(isDraggingT,
			MDropSpot2(make(-1), onDrop, TRectangle(interactiveRectangleStyle, TFillXY()), false)
		));

println(" > DRAW - MDocking UI ");

	// movablePanelsLayer = mapi(panelsA, \i, p -> makeDockingPanel(false, state, i, "", false, false, [], 0.0, localPositionA, make(true), zorder));
	movablePanelsLayer = mapi(panelsA, \i, p -> makeMovablePanel(state, i, localPositionA));
	// movablePanelsLayer = map(concatA(extractDockedPanelsId(getValue(dockA), -1)), \p -> makeMovablePanel(state, p, localPositionA));
	// movablePanelsLayer = map(concatA(extractDockedPanelsId(getValue(dockA), -1)), \p -> makeMovablePanel(state, p, localPositionA));

	// movablePanelsLayer = MSelect(fselect(state.dock,FLift(\d -> concatA(extractDockedPanelsId(getValue(dockA), -1)))), \m ->
	// MGroup(map(m, \p -> makeMovablePanel(state, p, localPositionA))));


	MConstruct([
		// makeSubscribe(
		// 	fselect(state.dock, FLift(\dockA_ -> {
		// 		println(dockA_);
		// 		concatA(extractDockedPanelsId(dockA_, -1))
		// 	})), \mobileA -> {
				
		// 		println(mobileA);
		// 		println(".");
		// 		println(".");
		// })
	],


		MInteractive([TMouseXY(state.mouseXy)],
			MGroup(concatA([
				// [makeMDockingDebugPrints(state)],        // Uncomment for debug prints
				[TPositionScale(positionScale, TRectangle([MFill(MGrey(100))], TFillXY()))],
				[MScroll(layout, TFillXY(), [])],
				movablePanelsLayer,
				[movableDropArea]
			]))
		)
	);



}



// Update MDockingState collecting data from panels and areas
updateMDockingState(state : MDockingState, panelsA : [MDockingPanel], style : [MDockingStyle]) -> void {
	titleA = state.title;
	panelIconA = state.panelIcon;
	contentA = state.content;
	dockA = state.dock;
	groupA = state.group;
	mPositiosA = state.positions;
	enabledA = state.enabled;
	expandedA = state.expanded;
	panelsStyleA = state.style;

	// Update UI layout
	if (getValue(dockA) == [[]]) {
		iteri(panelsA, \panelId, p -> {
			next(dockA, replace(getValue(dockA), panelId , [p.dockingAreaId, p.order, panelId]));
		});
	};
	
	// Expanded
	if (getValue(state.expanded) == []) iteri(panelsA, \i, p -> {	
		expandedB = extractStruct(p.style, MDPanelExpanded(make(true))).expanded;
		next(state.expanded, replace(getValue(state.expanded), i ,expandedB))
	});
	if (getValue(state.sideExpanded) == []) iteri(panelsA, \i, p -> {
		next(state.sideExpanded, replace(getValue(state.sideExpanded), i , make(true)))
	});

	// Positions
	offsetP = extractStruct(style, MDockingMobileOffset(Point(72.0, 72.0))).offsetPosition;
	if (getValue(state.positions) == []) iteri(panelsA, \i, p -> {
		zeroPosition = Point(
			offsetP.x + 36.0 * i2d(i),
			offsetP.y + dockingItemHeight * i2d(i)
		);
		positionB = extractStruct(p.style, MDPanelPosition(make(zeroPosition))).position;
		next(state.positions, replace(getValue(state.positions), i , positionB));
	});

	// Enabled
	if (getValue(state.enabled) == []) iteri(panelsA, \i, p -> {
		enabledB = extractStruct(p.style, MDPanelEnabled(make(true))).enabled;
		if (contains(p.style, MDockingDisabled())) next(enabledB, false);
		next(state.enabled, replace(getValue(state.enabled), i , enabledB));
	});

	if (getValue(titleA) == []) {
		iteri(panelsA, \i, p -> {
			next(titleA, replace(getValue(titleA), i , p.title));
			next(panelIconA, replace(getValue(panelIconA), i , p.panelIcon));
			next(contentA, replace(getValue(contentA), i , p.content));
			next(groupA, replace(getValue(groupA), i , p.allowedGroups));
			next(panelsStyleA, replace(getValue(panelsStyleA), i , p.style));

			content = getValue(state.content)[i];

			iter(getValue(contentA)[i], \itemA -> {

				switch (itemA : MDockingPanelItem) {
					// Toolbar
					MDockingPanelToolbarItem(ic, st): {
						minWidth = dockingItemHeight;
						dontShowSep = contains(p.style, MDockingDontShowSeparators());
						panelHeight = if (dontShowSep) (minWidth * i2d(length(content))) else (minWidth * i2d(length(content))) + (i2d(length(content)) - 1.0);
						size = TFixed(minWidth, panelHeight);
						next(state.size, replace(getValue(state.size), i , size));
						next(state.dockedSize, replace(getValue(state.dockedSize), i , size));
						next(state.mobileSize, replace(getValue(state.mobileSize), i , size));
					}
					// Panel of Buttons
					MDockingPanelButtonsItem(ic, lb, st): {
						minWidth = dockingItemHeight;
						width = extractStruct(p.style, MDockingPanelWidth(minWidth * 5.0)).width;
						dontShowSep = contains(p.style, MDockingDontShowSeparators());
						fillHeight = contains(p.style, MDockingFillSpace());

						panelHeight = if (dontShowSep) (minWidth * i2d(length(content))) else (minWidth * i2d(length(content))) + (i2d(length(content)) - 1.0);
						size = TFixed(width, panelHeight);
						dockedSize = if (fillHeight) TFillWY(width) else TFixed(width, panelHeight + dockingBarHeight + dockingDragSize);

						next(state.size, replace(getValue(state.size), i , size));
						next(state.dockedSize, replace(getValue(state.dockedSize), i , dockedSize));
						next(state.mobileSize, replace(getValue(state.mobileSize), i , size));
					}
					// Custom panels
					MDockingPanelCustomItem(mat, msize, st): {
						next(state.size, replace(getValue(state.size), i , TFixed(msize.width, msize.height)));
						next(state.dockedSize, replace(getValue(state.dockedSize), i , TFixed(msize.width, msize.height)));
						next(state.mobileSize, replace(getValue(state.mobileSize), i , TFixed(msize.width, msize.height)));
					}
				};
			});
		});
	}
}