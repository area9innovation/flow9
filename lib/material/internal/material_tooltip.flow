import material/internal/material_popup;
import material/internal/material_typography;

export {
	MTooltip2T(manager : MaterialManager, parent : MFocusGroup, m : MTooltip, m2t : (Material, MFocusGroup) -> Tropic) -> Tropic;
}

MTooltip2T(manager : MaterialManager, parent : MFocusGroup, m : MTooltip, m2t : (Material, MFocusGroup) -> Tropic) -> Tropic {
	zorder = getValue(manager.manager.zorder);
	virtualScreen = tryExtractStruct(m.style, MVirtualScreen(makeWH(), make(zeroPositionScale)));
	disableOnDragging = contains(m.style, MDisableOnDragging());
	blockHover = contains(m.style, MBlockHover());

	tooltipGap = 8.;
	overlapGap = 4.;
	hover = make(false);
	popupHover = make(false);
	externalFocused = extractStruct(m.style, MTooltipExternalFocused(const(false))).focused;
	enabled =
		extractStruct(m.style, MEnabled(const(true))).enabled
		|> (\en -> if (disableOnDragging) fand(en, feq(manager.manager.dragging, -1)) else en);

	openMenu = extractStruct(m.style, MOpenMenu(make(false)));

	lightBackground = extractStruct(m.style, MLightBackground(getLightBackground(parent))).light;
	bgStyle = extractStruct(m.style, MBackgroundStyle([MFill(MGrey(if (lightBackground) 600 else 200))]));

	tooltipAlign = extractStruct(m.style, MTooltipAlignmentDynamic(const(MBottom()))).type;
	translatePosition = extractStruct(m.style, MTranslatePosition(const(zeroPoint))).point;

	customId = tryExtractStruct(m.style, MTooltipCustomId(-1));
	popupId = eitherFn(customId, \cid -> cid.id, \ -> makeTropicTag(manager));
	tooltipId = "tooltip" + i2s(popupId);

	MComponentGroup2T(
		manager,
		parent,
		"MTooltip",
		[
			FAccessAttribute("aria-describedby", fif(openMenu.opened, const(eitherMap(customId, \__ -> "", tooltipId)), const(""))),
			FAccessVisible(enabled)
		],
		\p -> {
			positionScale = fselect(p.transformMatrix, getTransformPositionScale |> FLift);
			buttonWH = p.widthHeight;
			tooltipWH = makeWH();

			offsetAndBordersT =
				fsubselect3(tooltipWH, buttonWH, tooltipAlign, \twh, bwh, align -> {
					top = const(Pair(WidthHeight((bwh.width - twh.width) / 2., -twh.height - tooltipGap), Quadruple(0., 0., 0., tooltipGap + overlapGap) ));
					bottom = const(Pair(WidthHeight((bwh.width - twh.width) / 2., bwh.height + tooltipGap), Quadruple(0., tooltipGap + overlapGap, 0., 0.)));
					left = const(Pair(WidthHeight(-twh.width - tooltipGap, (bwh.height - twh.height) / 2.), Quadruple(0., 0., tooltipGap + overlapGap, 0.)));
					right = const(Pair(WidthHeight(bwh.width + tooltipGap, (bwh.height - twh.height) / 2.), Quadruple(tooltipGap + overlapGap, 0., 0., 0.)));

					switch (align) {
						MStart() : if (p.rtl) right else left;
						MEnd() : if (p.rtl) left else right;
						MTop() : top;
						MBottom() : bottom;
						MLeft() : left;
						MRight() : right;
						MTryTopFirst() :
							fif(
								fselect(positionScale, FLift(\ps : PositionScale -> ps.pos.y > twh.height + tooltipGap)),
								top,
								bottom
							);
						MTryBottomFirst() : {
							stageWH =
								eitherMap(virtualScreen, \vs : MVirtualScreen ->
									fselect2(vs.size, vs.position, FLift2(\vss, vsp ->
										WidthHeight(vss.width * vsp.scale.x + vsp.pos.x, vss.height * vsp.scale.y + vsp.pos.y)
									)),
									manager.stageWH
								);

							fif(
								fselect2(positionScale, stageWH, FLift2(\ps : PositionScale, sWH ->
									ps.pos.y + (bwh.height + twh.height) * ps.scale.y > sWH.height - tooltipGap
								)),
								top,
								bottom
							);
						}
						MNoAlignment() : const(Pair(WidthHeight(0., 0.), Quadruple(0., 0., 0., 0.)));
					}
				});

			offsetT = fFirstOfPair(offsetAndBordersT);
			bordersT = fSecondOfPair(offsetAndBordersT);

			interactives = [
				KeyDown2(\h, ke -> {
					if (fgetValue(p.keysEnabled) && ke.keycode == KEY_ESCAPE) {
						next(openMenu.opened, false);

						true;
					} else {
						h;
					}
				}),
				TMouseInside(popupHover, blockHover)
			];

			TConstruct(
				[
					makeSubscribe2Uns(fand(enabled, openMenu.opened), \op -> {
						if (op && !isEmptyMaterial(m.tooltip)) {
							[
								interruptibleDeferUntilNextFrameRendered(\ -> {
									MComponentGroup(
										m.tooltip
										|> MBorderLeftRight(8.)
										|> MBorderTopBottom(4.)
										|> (\f ->
											if (mobile)
												f
											else (
												if (blockHover)
													MFrame(0., 0.,
														interactiveRectangleStyle,
														MBorderT(  // This is absolute because bordersT are absolute calculated regarding alignment chosen, which could be absolute/relative.
															fselectLift(bordersT, \b -> b.first),
															fselectLift(bordersT, \b -> b.second),
															fselectLift(bordersT, \b -> b.third),
															fselectLift(bordersT, \b -> b.fourth),
															f
														)
													)
													|> (\t -> MInteractive(interactives, t))
													|> (\t -> MBorderT(  // Is not -A because bordersT are absolute calculated regarding alignment chosen, which could be absolute/relative.
														fselectLift(bordersT, \b -> -b.first),
														fselectLift(bordersT, \b -> -b.second),
														fselectLift(bordersT, \b -> -b.third),
														fselectLift(bordersT, \b -> -b.fourth),
														t
													))
												else
													MCopySize(
														f,
														\sz ->
															TRectangle(
																interactiveRectangleStyle,
																TBorderT(  // Is not -A because bordersT are absolute calculated regarding alignment chosen, which could be absolute/relative.
																	fselectLift(bordersT, \b -> b.first),
																	fselectLift(bordersT, \b -> b.second),
																	fselectLift(bordersT, \b -> b.third),
																	fselectLift(bordersT, \b -> b.fourth),
																	sz
																)
															)
															|> (\t -> TInteractive(interactives, t))
															|> (\t -> TTranslate(
																fpoint(
																	fselectLift(bordersT, \b -> -b.first),
																	fselectLift(bordersT, \b -> -b.second)
																),
																t
															)),
														true
													)
											)
											|> (\t -> MDispose([\ -> next(popupHover, false)], t))
										),
										concat(
											extractMComponentGroupState(m.style),
											[
												MFocusName("MTooltipPopup"),
												UpdateMaterialTheme(\t ->
													MLightTheme(
														MaterialTheme(t with type = MaterialFontManager(t.type with body1 = MTooltipDesktop(), body2 = MTooltipDesktop())),
														!lightBackground
													)
												),
												AccessRole("tooltip"),
												FAccessAttribute("id", const(tooltipId))
											]
										)
									)
									|> (\f -> {
										popupStyle : [MPopupStyle] = [
											RMOutterBorder(tooltipGap),
											RMAlphaAnimation(),
											openMenu,
											MSameZorder(true),
											RMBorders(0.),
											bgStyle,
											RMDontHandle(),
											RMNoSnapSize(),
											MElevation(zero),
											RMOffset(fpair(offsetT, const(0.))),
											MRippleShape("MTooltipPopup"),
											MFocusOnPrevious(false)
										];
										RenderMPopup(
											manager,
											p,
											MPopup(
												[[MAttachBox(f, tooltipWH)]],
												fselect2(positionScale, translatePosition, FLift2(\ps : PositionScale, tr : Point ->
													PositionScale(Point(ps.pos.x + tr.x, ps.pos.y + tr.y), ps.scale))
												),
												eitherMap(virtualScreen, \vs -> arrayPush(popupStyle, vs), popupStyle)
											),
											m2t
										)
									})
								})
							]
						} else {
							[]
						}
					}),
					makeSubscribeUns(fand(enabled, fand(fOr(fOr(fOr(hover, popupHover), p.focused), externalFocused), fselect(manager.manager.zorder, FLift(\cz -> cz <= zorder)))), \h -> {
						if (h) {
							addMPopupItemId(manager, popupId);
							blockOtherMPopupItemIds(manager, popupId);

							[
								fconnect(fcontains(manager.manager.currentPopupItemID, const(popupId)), openMenu.opened)
							]
						} else {
							nextDistinct(openMenu.opened, false);

							[]
						}
					}),
					\ -> \ -> next(openMenu.opened, false)
				],
				if (!mobile)
					TInteractive(
						[TMouseInside(hover, blockHover)],
						m2t(m.box, p)
					)
				else
					TCopySize(
						m2t(m.box, p),
						\tr ->
							TInteractive([TMouseDownGhost(hover)], tr),
						true
					)
			)
		}
	)
}

isEmptyMaterial(m : Material) -> bool {
	m == TEmpty() || m == TMutable(ConstBehaviour(TEmpty())) || m == MMutable(ConstBehaviour(TEmpty()))
}
