import material/internal/material_popup;
import material/internal/material_typography;

export {
	MTooltip2T(manager : MaterialManager, parent : MFocusGroup, m : MTooltip, m2t : (Material, MFocusGroup) -> Tropic) -> Tropic;
}

MTooltip2T(manager : MaterialManager, parent : MFocusGroup, m : MTooltip, m2t : (Material, MFocusGroup) -> Tropic) -> Tropic {
	zorder = getValue(manager.manager.zorder);
	disableOnDragging = contains(m.style, MDisableOnDragging());

	tooltipGap = 8.;
	hover = make(false);
	enabled =
		extractStruct(m.style, MEnabled(const(true))).enabled
		|> (\en -> if (disableOnDragging) fand(en, feq(manager.manager.dragging, -1)) else en);

	openMenu = extractStruct(m.style, MOpenMenu(make(false)));

	positionScale = make(zeroPositionScale);

	buttonWH = makeWH();
	lightBackground = extractStruct(m.style, MLightBackground(getLightBackground(parent))).light;
	bgStyle = extractStruct(m.style, MBackgroundStyle([MFill(MGrey(if (lightBackground) 600 else 200))]));

	tooltipAlign = extractStruct(m.style, MTooltipAlignment(MBottom())).type;
	translatePosition = extractStruct(m.style, MTranslatePosition(const(zeroPoint))).point;

	TConstruct(
		[
			makeSubscribe2Uns(fand(enabled, openMenu.opened), \op -> {
				if (op && !isEmptyMaterial(m.tooltip)) {
					[
						interruptibleDeferUntilNextFrameRendered(\ -> {
							MComponentGroup(
								m.tooltip
								|> MBorderLeftRight(8.)
								|> MBorderTopBottom(4.),
								[
									MFocusName("MTooltip"),
									UpdateMaterialTheme(\t ->
										MLightTheme(
											MaterialTheme(t with type = MaterialTypeManager(t.type with body1 = MTooltipDesktop(), body2 = MTooltipDesktop())),
											!lightBackground
										)
									)
								]
							)
							|> (\f -> {
								tooltipWH = makeWH();

								RenderMPopup(
									manager,
									parent,
									MPopup(
										[[MAttachBox(f, tooltipWH)]],
										fselect2(positionScale, translatePosition, FLift2(\ps : PositionScale, tr : Point ->
											PositionScale(Point(ps.pos.x + tr.x, ps.pos.y + tr.y), ps.scale))
										),
										[
											RMOutterBorder(tooltipGap),
											RMAlphaAnimation(),
											openMenu,
											MSameZorder(true),
											RMBorders(0.),
											bgStyle,
											RMDontHandle(),
											RMNoSnapSize(),
											MElevation(zero),
											RMOffset(
												fsubselect2(tooltipWH, buttonWH, \twh, bwh -> {
													top = const(WidthHeight((bwh.width - twh.width) / 2., -twh.height - tooltipGap));
													bottom = const(WidthHeight((bwh.width - twh.width) / 2., bwh.height + tooltipGap));
													left = const(WidthHeight(-twh.width - tooltipGap, (bwh.height - twh.height) / 2.));
													right = const(WidthHeight(bwh.width + tooltipGap, (bwh.height - twh.height) / 2.));
													switch (tooltipAlign) {
														MTop() : top;
														MBottom() : bottom;
														MLeft() : left;
														MRight() : right;
														MTryTopFirst() :
															fif(
																fselect(positionScale, FLift(\ps : PositionScale -> ps.pos.y > twh.height + tooltipGap)),
																top,
																bottom
															);
														MTryBottomFirst() :
															fif(
																fselect2(positionScale, manager.stageWH, FLift2(\ps : PositionScale, sWH ->
																	ps.pos.y + bwh.height > sWH.height - twh.height - tooltipGap)
																), 
																top,
																bottom
															)
													}
												})
												|> (\offset -> fpair(offset, const(0.)))
											),
											MRippleShape("MTooltip")
										]
									),
									m2t
								)
							})
						})
					]
				} else {
					[]
				}
			}),
			\ -> fconnect(
				fand(enabled, fand(hover, fselect(manager.manager.zorder, FLift(\cz -> cz <= zorder)))),
				openMenu.opened
			),
			\ -> \ -> next(openMenu.opened, false)
		],
		(if (!mobile)
			TInteractive([TMouseInside(hover, contains(m.style, MBlockHover()))], m2t(m.box, parent))
		else
			TCopySize(
				m2t(m.box, parent),
				\tr ->
					TInteractive([TMouseDownGhost(hover)], tr),
				true
			))
		|> (\f -> MPositionScaleAttachBox(positionScale, buttonWH, f, fand(enabled, openMenu.opened)))
	)
}

isEmptyMaterial(m : Material) -> bool {
	m == TEmpty() || m == TMutable(ConstBehaviour(TEmpty())) || m == MMutable(ConstBehaviour(TEmpty()))
}