import material/internal/material_textinput;
import material/internal/material_dropdown;
import material/internal/material_list;
import material/internal/material_dialog_internal;

export {
	MDynamicDataTable2T(manager : MaterialManager, parent : MFocusGroup, m : MDynamicDataTable, m2t : (Material, MFocusGroup) -> Tropic) -> Tropic;
	MLightweightDataTable2T(manager : MaterialManager, parent : MFocusGroup, m : MLightweightDataTable<?>, m2t : (Material, MFocusGroup) -> Tropic) -> Tropic;
	MSpannableDataTable2T(manager : MaterialManager, parent : MFocusGroup, m : MSpannableDataTable<?>, m2t : (Material, MFocusGroup) -> Tropic) -> Tropic;
}

MDynamicDataTable2T(manager : MaterialManager, parent : MFocusGroup, m : MDynamicDataTable, m2t : (Material, MFocusGroup) -> Tropic) -> Tropic {
	MDynamicDataTable2TInner(manager, parent, m.columns, m.rows, \row -> map(row, \cell -> MCell(cell, 1, 1)), m.style, false, m2t)
}

MLightweightDataTable2T(manager : MaterialManager, parent : MFocusGroup, m : MLightweightDataTable<?>, m2t : (Material, MFocusGroup) -> Tropic) -> Tropic {
	MDynamicDataTable2TInner(manager, parent, m.columns, m.data, \v -> map(m.rowsFn(v), \cell -> MCell(cell, 1, 1)), m.style, true, m2t)
}

MSpannableDataTable2T(manager : MaterialManager, parent : MFocusGroup, m : MSpannableDataTable<?>, m2t : (Material, MFocusGroup) -> Tropic) -> Tropic {
	MDynamicDataTable2TInner(manager, parent, m.columns, m.data, m.rowsFn, m.style, true, m2t)
}

MDynamicDataTable2TInner(
	manager : MaterialManager,
	parent : MFocusGroup,
	columns : [MColumnDynamic],
	data : Transform<[?]>,
	rowsFn : (?) -> [MCell],
	style : [MDataTableStyle],
	lightweight : bool,
	m2t : (Material, MFocusGroup) -> Tropic
) -> Tropic {
	useMaxSizeFix = !isUrlParameterFalse("table_max_size_enabled");
	rowsCountB = flength(data);

	reorderList = if (lightweight) None() else tryExtractStruct(style, MListReorder(make([]), const(false)));
	isReorderEnabled = eitherMap(reorderList, \rl : MListReorder -> fgetValue(rl.enabled), false);
	reorderShowIcon = !contains(style, MListReorderHideIcon());
	// Reserved space for column with drag&drop reorder icon. Icon added at function MListLine2T
	reorderIconSpace = if (isReorderEnabled && reorderShowIcon) 40. else 0.;
	reorderOnDragEnd = contains(style, MReorderOnDragEnd());

	sorting = makeMSortingState(data, rowsFn, style, isSome(reorderList), lightweight, manager, m2t);
	paginationState = makeMPaginationState(style, isSome(reorderList));
	page = paginationState.page;

	state = makeMDataTableState(columns, style, manager, parent, m2t, rowsCountB, paginationState, sorting);

	expandRowEnabled = extractStruct(style, MExpandRow(const(false))).enabled;
	isDefExpandRow = isFConst(expandRowEnabled) && !fgetValue(expandRowEnabled);

	defaultHS = MHeaderStyle([], [], []);
	headerStyle = tryExtractStruct(style, defaultHS);
	rowBackgroundStyle = tryExtractStruct(style, MRowBackgroundStyle(\__ -> []));
	selectedBgStyle : Maybe<MSelectedBackgroundStyle> = tryExtractStruct(style, MSelectedBackgroundStyle([]));

	showFixedRow = eitherMap(state.fixedRow, \fr -> fr.show, const(false));
	lifted = eitherMap(tryExtractStruct(style, MDataTableInnerScroll(MStandardMode(), [])), \is -> is.mode == MLiftedFirstColumnMode(), false);
	isAnyWidthByContent = state.widthByContent || any(map(state.columns, isWidthByContent));

	screenW = make(0.);
	rowsBoxH = make(0.);

	splitWithoutHead : ([flow], int) -> [flow] = \arr : [flow], er : int -> {
		concat(map(colsHead(state, arr), v2a), splitByNumber(colsTail(state, arr), er));
	}
	mapSplitWithoutHead = \arr : [flow], er, fn -> map(splitWithoutHead(arr, er), fn);

	tableWidth : (Transform<int>) -> Transform<double> = \expRow ->
		if (length(state.columns) == 0)
			const(0.)
		else
			fselect2(fmerge(state.columnWidths), expRow, FLift2(\colWs : [double], er : int ->
				dsum(mapSplitWithoutHead(if (lifted) colsTail(state, colWs) else colWs, er, \ws -> either(maxA(ws), 0.))) + 2. * state.externalBorder
			));

	minWidthsSum = if (isAnyWidthByContent) tableWidth(const(1)) else fsum(state.minWidths);

	innerScrollHotfix = contains(manager.style, MDataTableDefaultInnerScrollHotfix());
	innerScrollState = makeMInnerScrollState(state.fullWidth, screenW, minWidthsSum, state.externalBorder, style, innerScrollHotfix);
	isInnerScroll = isSome(innerScrollState);
	glued = eitherMap(innerScrollState, \is -> either(is.glued, false), false);

	expandRow = initExpandRow(expandRowEnabled, screenW, minWidthsSum, state.externalBorder);

	// Height handling

	separatorsHeight = extractStruct(style, MRowSpacing(b2d(state.separators))).spacing;

	noFooter = contains(style, MNoFooter()) && !paginationState.anyType;
	footerHeight = if (noFooter) 0. else 56.;
	footerMinWidth = make(0.);
	tableHeight = make(0.);
	tableMaxWidth = make(0.);
	tableMaxHeight = make(0.);
	headerActionsHeight = make(0.);

	countRowHeight0 = \er : int, isHeader : bool ->
		state.lineHeight(isHeader) * (i2d(er) + b2d(lifted && !isHeader)) + separatorsHeight;
	countRowHeight = \er -> countRowHeight0(er, false);
	countHeaderRowHeight = \er -> countRowHeight0(er, true);

	minimumRowsDef = 3;
	rowHeight = countRowHeight(1);
	minTableHeightDef = i2d(minimumRowsDef) * rowHeight + b2d(!state.replaceHeader) * countHeaderRowHeight(1) + footerHeight;
	minTableHeight =
		extractStruct(style, MMinTableHeight(minTableHeightDef)).height
		|> (\h -> max(h, state.rowHeight + footerHeight));
	fullMinTableHeight = faddition(fmin(const(minTableHeight), tableHeight), headerActionsHeight);

	minimumRows = \er -> min(
		ceil((minTableHeight - b2d(!state.replaceHeader) * countHeaderRowHeight(1) - footerHeight) / countRowHeight(er)),
		fgetValue(rowsCountB)
	);

	rowsAvailableHeight =
		fselect4(paginationState.rowsPerPage, rowsCountB, showFixedRow, expandRow, \rpp, rc, fr, er ->
			i2d(min(rpp, rc) + b2i(fr)) * countRowHeight(er)
		);

	currentVisibleRowsCount =
		fselect2(rowsCountB, page, FLift2(\rc, p -> min(p.second, rc - p.first)));

	visibleRowsHeight =
		fselect3(currentVisibleRowsCount, showFixedRow, expandRow, \vrc, fr, er ->
			i2d(vrc + b2i(fr)) * countRowHeight(er)
		);

	// Helpers
	expandContent = \cells : [Tropic], er : int -> map(splitWithoutHead(cells, er), \l -> TLinesDir(l, parent.rtl));

	wrapItemsForFirstColumnMode = \p -> \items ->
		eitherMap(innerScrollState, \is ->
			if (is.lifted) colsTail(state,items)
			else eitherMap(is.glued, \gl ->
				if (gl) concat([TShow(fnot(is.visible), TColsDir(colsHead(state, items), p.rtl))], colsTail(state, items))
				else concat(colsBeforeLastColumns(state, items), [TShow(fnot(is.visible), TColsDir(colsLastColumns(state, items), p.rtl))]),
				items
			),
			items
		);

	wrapIntoBorders = \p -> \t -> eitherMap(innerScrollState, \is ->
		eitherMap(is.glued, \gl ->
			if (gl) TBorderTDir(fif(is.visible, zero, const(state.externalBorder)), zero, const(state.externalBorder), zero, t, p.rtl)
			else TBorderTDir(const(state.externalBorder), zero, fif(is.visible, zero, const(state.externalBorder)), zero, t, p.rtl),
			t |> TBorderLeftRight(state.externalBorder)
		),
		t |> TBorderLeftRight(state.externalBorder)
	);

	yTranslation = fselectLift(page, \pg -> max(0., i2d(pg.first)) * rowHeight);
	totalRowsHeight = fselect2(rowsCountB, showFixedRow, FLift2(\rc, fr -> (i2d(rc) + b2d(fr)) * rowHeight));

	// Header
	tableHeader = \headers, p ->
		TSelect(expandRow, \er ->
			expandContent(headers, er)
			|> wrapItemsForFirstColumnMode(p)
			|> (\t -> TColsDir(t, p.rtl))
		)
		|> wrapIntoBorders(p)
		|> (\t -> TBorderDir(0., 0., reorderIconSpace, 0., t, p.rtl))
		|> (\t ->
			eitherMap(
				headerStyle,
				\hs ->
					TCopySize(
						t,
						\tr ->
							TRounded(2., 2., 0., 0., hs.background, tr),
						false
					),
				t
			)
		)
		|> (\t -> TAccess([TagName("tr"), AccessRole("row")], t));

	addHeaderActions = \p -> \t : Tropic ->
		if (state.headerActions.actions != TEmpty())
			TLines2Dir(
				m2t(state.headerActions.actions, p)
				|> (\t2 -> TAvailableHeight(t2, const(state.rowHeight)))
				|> (\t2 -> TAttachHeight(t2, headerActionsHeight)),
				t,
				p.rtl
			)
		else t;

	scrollStep =
		if (contains(style, MDataTableScrollByPage())) [TScrollStep(visibleRowsHeight)]
		else if (contains(style, MDataTableScrollByRow())) [TScrollStep(const(rowHeight))]
		else [];

	(\p -> {
		headers =
			MDTTitles(state, p, sorting, defaultHS, headerStyle, isSome(reorderList), rowsCountB, page);
		footer =
			MDTFooter(manager, p, paginationState, rowsCountB, state.scrollEnabled, noFooter, footerHeight, footerMinWidth, m2t);

		// Data rows
		content =
			if (lightweight) {
				rowsBoxMaxWidth = make(0.);
				rows : Transform<[Pair<Maybe<?>, int>]> =
					fselect3(sorting.result, data, page, \sortRes, dat, pg ->
						map(subrange(sortRes, pg.first, pg.second + 1), \i -> Pair(elementAtM(dat, i), i))
					);

				renderedRowspans : [DynamicBehaviour<[Pair<Transform<int>, int>]>] = generate(0, length(state.columnWidths), \__ -> make([]));

				SelectTLinesA(rows, \idx, id, value -> {
					row = eitherMap(value.first, rowsFn, []);
					j = value.second;

					disp = initUnsM();
					iteri(row, \i, cell -> if (cell.rowspan > 1) {
						column = elementAt(renderedRowspans, i, make([]));
						val = Pair(idx, cell.rowspan);
						dynArrayPush(column, val);
						setUnsM(disp, \ -> nextDistinct(column, removeFirst(getValue(column), val)))
					});

					TSelect(state.makeCells(p, j, row, false, Some(MTableRowspanInfo(renderedRowspans, idx))),
						\cells -> TColsDir(cells |> wrapItemsForFirstColumnMode(p), p.rtl)
					)
					|> wrapIntoBorders(p)
					|> (if (lifted) TBorderTop(state.rowHeight) else idfn)
					|> (\t -> {
						lineSelectionEnabled =
							fand(
								state.selection.enabled,
								fsubselect(state.selectionEnabled.enabled, FLift(\selEnabled -> elementAt(selEnabled, j, const(true))))
							);
						isInteractive = fand(
							state.hoverEnabled.enabled,
							fOr(lineSelectionEnabled, state.onClick.enabled)
						);
						MComponent2T(manager, p, "MDataTableLine" + i2s(j), [
							MHighlightOnHover(const(true)),
							MHighlightOnFocus(const(true)),
							MOnClick(\ -> MListOnClickHandler(state.selection, state.selectionEnabled, state.onClick)(j)),
							MRippleType(fif(isInteractive, const(MRippleFill()), const(MNoRipple()))),
							MCursorShape(fif(isInteractive, const(FingerCursor()), const(DefaultCursor()))),
							MButtonTitle(const("MDataTableLine" + i2s(j))),
							MEnabled(fOr(lineSelectionEnabled, state.onClick.enabled))
						], \__ -> t, m2t)
					})
					|> (\t -> eitherMap(rowBackgroundStyle, \rb -> if (j == -1) t else
							TIfLazy2(
								fcontains(state.selection.selected, const(j)),
								\v -> if (v && isSome(selectedBgStyle)) t else TFrame(0., 0., rb.fn(j), t),
								false
							), t
						))
					|> (\t ->
						TIfLazy2(
							fcontains(state.selection.selected, const(j)),
							\v -> {
								if (v)
									TFrame(0., 0.,
										eitherMap(
											selectedBgStyle,
											\sbs -> sbs.style,
											[Fill(contrastingColor(p)), FillOpacity(if (getLightBackground(p)) 0.08 else 0.16)]
										),
										t
									)
								else t
							},
							false
						)
					)
					|> (\t -> if (state.separators) addSeparator(manager, p, t, false) else t)
					|> (\t -> TAccess([TagName("tr"), AccessRole("row")], t))
					|> (\t -> TDispose([\ -> dispUnsM(disp)], t));
				})
				|> (\t -> TInspect([IMaxWidth(rowsBoxMaxWidth)], t))
				|> (\t -> {
					scrollBox = if (useMaxSizeFix) TFillWYT(rowsBoxMaxWidth) else TFillXY();
					TGroup2(
						TCropSize(
							scrollBox,
							TTranslate(fselect2Lift(yTranslation, state.rowsBoxScrollPosition.position, \yTr, pos -> Point(pos.x, yTr - pos.y)), t)
						),
						MScroll2T(
							manager,
							p,
							MScroll(
								TSizedHeight(1., totalRowsHeight),
								scrollBox,
								concat3([
										state.rowsBoxScrollPosition,
										TScrollEnabled(state.scrollEnabled),
										TScrollAxisEnabled(const(false), state.scrollEnabled),
										MScrollBound(const(true), fselect(page, FLift(\pg -> pg.first <= 0)))
									],
									state.verticalScroll,
									scrollStep
								)
							),
							m2t
						)
					)
				})
			} else {
				rows = fmap(data, rowsFn);
				MSelect2T(manager, p, "MDynamicDataTableLines", [], expandRow, \er, p2 ->
					eitherMap(
						state.fixedRow,
						\fr -> fconcat(const([map(fr.cols, unitaryCell)]), rows),
						rows
					)
					|> (\rc -> fmapi(rc, \j0, row -> {

							j = j0 - b2i(isSome(state.fixedRow));

							makeLineContent = \p3 : MFocusGroup ->
								TSelect(state.makeCells(p3, j, row, false, None()),
									\cells -> TColsDir(expandContent(cells, er) |> wrapItemsForFirstColumnMode(p), p.rtl)
								)
								|> TAlignStart
								|> wrapIntoBorders(p2)
								|> (if (lifted) TBorderTop(state.rowHeight) else idfn)
								|> (\t -> TFixSize(t, TFillXH(countRowHeight(er) - separatorsHeight)))
								|> (\t -> eitherMap(rowBackgroundStyle, \rb -> if (j == -1) t else
											TIfLazy2(
												fcontains(state.selection.selected, const(j)),
												\v -> if (v && isSome(selectedBgStyle)) t else TFrame(0., 0., rb.fn(j), t),
												false
											), t
										))
								|> (\t -> if (state.separators) addSeparator(state.manager, p3, t, false) else t);

							MCustomLine(
								MGetFocusGroup(makeLineContent),
								[state.clickEnabled, MHeight(countRowHeight(er)), TagName("tr"), AccessRole("row")]
							);
						})
					)
					|> (\rws0 : Transform<[MCustomLine]> ->
						(
							if (isSome(state.fixedRow))
								fselect(rws0, tail |> FLift)
							else
								rws0
						)
						|> (\rws : Transform<[MCustomLine]> ->
							eitherFn(
								reorderList,
								\rl ->
									MSelect2T(
										manager,
										p2,
										"MDataTableContent",
										[],
										rws,
										\f4, p3 ->
											MList2T(
												manager,
												p3,
												MList(
													f4,
													concat(
														[MSideBorders(const(0.)), MAddScroll(None())],
														eitherMap(selectedBgStyle, v2a, [])
													),
													[state.selection, state.onClick, rl, state.hoverEnabled]
													|> (\st : [MListState] -> ifArrayPush(st, !reorderShowIcon, MListReorderHideIcon()))
													|> (\st -> ifArrayPush(st, reorderOnDragEnd, MReorderOnDragEnd()))
												),
												m2t
											)
									),
								\ -> {
									listSort = make([]);

									TConstruct(
										[\ -> fconnect(sorting.result, listSort)],
										MDynamicList2T(
											manager,
											p2,
											MDynamicList(
												cast(rws : Transform<[MCustomLine]> -> Transform<[MListLine]>),
												concat(
													[MSideBorders(const(0.))],
													eitherMap(selectedBgStyle, v2a, [])
												),
												concat3([
														state.selection, state.selectionEnabled, state.onClick, MListReorder(listSort, const(false)),
														state.rowsBoxScrollPosition, TScrollEnabled(state.scrollEnabled),
														MScrollbars(
															TScrollbarStyle(getMaterialScrollBar().x with visible = state.scrollEnabled),
															TScrollbarStyle(getMaterialScrollBar().y with visible = state.scrollEnabled)
														), state.hoverEnabled, MScrollBound(state.scrollEnabled, state.scrollEnabled)
													],
													state.verticalScroll,
													scrollStep
												)
											),
											m2t
										)
									)
								}
							)
						)
						|> (\f : Tropic ->
							eitherMap(
								state.fixedRow,
								\fr -> {
									bStyle = filtermap(fr.style, \st -> switch (st) {
										TGraphicsStyle() : {a : Maybe<TGraphicsStyle> = Some(st); a};
										default : None()
									});

									onFixedRowClick = tryExtractStruct(fr.style, MOnClick(nop));

									TCopySize(
										MSelect2T(manager, p2, "MDataTableFixedRow", [], rws0, \fr2, p3 ->
											firstElement(fr2, MCustomLine(TEmpty(), [])).content
											|> (\f4 -> eitherMap(
												onFixedRowClick,
												\onclk ->
													MComponent([
														MOnClick(onclk.click),
														MRippleType(const(MRippleFill())),
														state.clickEnabled
													], \__ -> f4),
												f4
											))
											|> (\f4 -> m2t(f4, p3))
										),
										\tr -> TRounded(2., 2., 0., 0., bStyle, tr),
										false
									)
									|> (\t -> TShow(fr.show, t))
									|> (\t -> TLines2Dir(t, f, p.rtl))
								},
								f
							)
						)
					)
				)
			};

		content
		|> (\f -> TAvailableHeightPreventFillers(f, if (paginationState.cropPageHeight) visibleRowsHeight else rowsAvailableHeight))
		|> (\f -> TConstruct(
				concat(
					if (paginationState.isEmpty) [
						makeSubscribeUns(
						fOr(const(paginationState.auto), state.scrollEnabled),
						\v ->
							if (v)
								[make4Subscribe(
									rowsBoxH,
									expandRow,
									showFixedRow,
									rowsCountB,
									\height, er, fr, rowsCount -> {
										newRowsCount =
											forceRange(
												floor(height / countRowHeight(er)),
												minimumRows(er),
												rowsCount + b2i(fr)
											) - b2i(fr);

										pg = getValue(page);
										if (pg.second != newRowsCount)
											next(page,
												Pair(
													forceRange(
														pg.first * newRowsCount / max(pg.second, 1),
														0,
														max(rowsCount - 1, 0)
													),
													newRowsCount
												)
											);
								})()]
							else
								[makeSubscribe(rowsCountB, paginationState.updateRowsPerPage)()]
					)] else
						[],

					if (state.fullWidth && !state.widthByContent && length(state.columnWidths) > 0) [
						make4Subscribe(screenW, expandRow, fmerge(state.columnWidths), fmerge(state.minWidths), \width, er, colWs, minWs -> {
							cutFirstColumn = \arr : [flow] -> if (lifted || glued) colsTail(state, arr) else arr;

							miw =
								mapi(state.columns, \i, c -> {
									if (isWidthByContent(c))
										colWs[i]
									else
										minWs[i]
								})
								|> (\arr ->
									mapSplitWithoutHead(arr, er,
										\r -> either(maxA(r), -1.)
									)
								)
								|> cutFirstColumn;

							maw =
								mapi(state.columns, \i, c -> {
									if (isWidthByContent(c))
										colWs[i]
									else {
										w = extractStruct(c.style, MMaxWidth(-1)).width;

										if (w == -1)
											-1.
										else
											max(i2d(w) + state.cellBorder, minWs[i])
									}
								})
								|> (\arr ->
									mapSplitWithoutHead(arr, er,
										\r -> if (contains(r, -1.)) -1. else either(maxA(r), -1.)
									)
								)
								|> cutFirstColumn;

							newSizes =
								distributeSizesEvenly(
									miw,
									maw,
									max(width - state.externalBorder * 2. - reorderIconSpace, getValue(footerMinWidth))
									- if (glued) dsum(colsHead(state, colWs)) else 0.
								);

							iteri(
								splitWithoutHead(state.columnCalculatedWidths, er) |> cutFirstColumn,
								\i, r -> iter(r, \cellWidth -> nextDistinct(cellWidth, newSizes[i]))
							)
						})] else []
					),
					f
				)
		)
		|> (\t -> if (paginationState.isEmpty) TAttachAvailableHeight(t, rowsBoxH) |> TSetMaxHeight2(totalRowsHeight) else t)
		|> (if (!paginationState.anyType && isFConst(data) && isFConst(showFixedRow) && !fgetValue(state.scrollEnabled) && isFConst(expandRow))
				makeTropicConstantHeight(Some((i2d(fgetValue(rowsCountB)) + b2d(fgetValue(showFixedRow))) * countRowHeight(fgetValue(expandRow))))
			else idfn)
		|> (\t -> if (state.separators) addSeparator(manager, p, t, true) else t)
		// Header
		|> (\f -> TLines2Dir(tableHeader(headers, p), f, p.rtl))
		|> (\t : Tropic -> eitherMap(innerScrollState, \is -> {
				defaultScrollBarStyle : TScrollbars = extractStruct(is.style, getMaterialScrollBar());

				scrollStyle = concat(is.style, [
					TScrollInspectShowScrolling(is.visibilityInspector),
					MScrollPosition(is.position),
					MScrollDisableOutOfBounds(const(true)),
					TScrollEnabled(is.enabled),
					MScrollbars(
						TScrollbarStyle(defaultScrollBarStyle.x with visible = is.enabled),
						TScrollbarStyle(defaultScrollBarStyle.y with visible = is.enabled)
					)
				]);

				isYFiller = paginationState.auto || (!paginationState.anyType && fgetValue(state.scrollEnabled));
				innerMaxWidth = make(0.);
				innerMaxHeight = make(0.);

				scroll =
					if (isYFiller)
						MScroll(MInspect([IMaxWidth(innerMaxWidth), IMaxHeight(innerMaxHeight)], t), TFillMin(0., minTableHeight - footerHeight), arrayPush(scrollStyle, MScrollCropByContent()))
					else {
						contentHeight = make(0.);
						MScroll(MInspect([IMaxWidth(innerMaxWidth), Height(contentHeight)], t), TFillXHT(contentHeight), scrollStyle)
					}

				MScroll2T(manager, p, scroll, m2t)
				|> (\t2 ->
					if (useMaxSizeFix) t2 |> TSetMaxWidth2(innerMaxWidth) |> (if (isYFiller) TSetMaxHeight2(innerMaxHeight) else idfn)
					else t2
				)
			}, t))
		|> MDTSideColumns(state, p, headers, data, rowsFn, sorting, innerScrollState, expandRow, yTranslation,
				rowBackgroundStyle, selectedBgStyle, totalRowsHeight, visibleRowsHeight, rowsAvailableHeight, page, lightweight)
		|> (\t -> TAccess([TagName("tbody")], t))
		|> (\t -> TAccess([TagName("table"), AccessRole("table")], t))
		|> addHeaderActions(p)
		// Bottom bar
		|> (\f : Tropic -> TLines2Dir(f, footer, p.rtl))
		// Card
		|> (\f ->
			if (contains(style, MInCard())) {
				MShapeFrame(p, [MThemeFill(p, MSurfaceColor())], f, "MDynamicDataTable")
				|> (\f2 -> TShadowShape(p, const(2.0), f2, RectangleShape("MDynamicDataTable")))
			} else
				f)
		|> (\f ->
			TConstruct(
				concat(
					[\ -> fBidirectionalLink(
						fpair(page, expandRow),
						fpair(state.rowsBoxScrollPosition.position, expandRow),
						\pair -> if (paginationState.anyType || fgetValue(state.scrollEnabled))
							nextDistinct(state.rowsBoxScrollPosition.position, Point(0., i2d(pair.first.first) * countRowHeight(pair.second))),
						\pair ->
							paginationState.updatePageNumber(max(0, floor(pair.first.y) / floor(countRowHeight(pair.second))))
					)],
					state.subs
				),
				f
			)
		)
		|> (\t -> {
			tWidth = tableWidth(expandRow);
			TAvailableWidth(t, if (isInnerScroll) fmin(screenW, tWidth) else tWidth)
			|> (if (useMaxSizeFix) TSetMaxWidth2(tWidth) else idfn)
		})
		|> (\t -> if (state.fullWidthAdvanced) TTweak([TSnapSize(8., -1., false)], t, TEmpty()) else t)
		|> (if (!paginationState.anyType && isFConst(data) && isFConst(showFixedRow) && !fgetValue(state.scrollEnabled)) makeTropicConstantHeight(None()) else idfn)
		|> (if (state.fullWidth || isAnyWidthByContent || isInnerScroll || !isDefExpandRow) idfn else makeTropicConstantWidth(None()))
		|> (\t -> TAttachHeight(t, tableHeight))
		|> (\t -> TInspect([IMaxWidth(tableMaxWidth), IMaxHeight(tableMaxHeight)], t))
		|> (\t ->
			if (state.fullWidth) {
				box =
					if (paginationState.auto || fgetValue(state.scrollEnabled)) MGroup2(TFillXY(), TSizedHeight(0., fullMinTableHeight))
					else TFillXHT(tableHeight);
				MScroll2T(manager, p, MScroll(t, box, [MScrollCropByContent()]), m2t)
			} else t)
		|> TSetMinHeight2(fullMinTableHeight)
		|> (\t ->
			if (useMaxSizeFix) t |> TSetMaxWidth2(tableMaxWidth) |> TSetMaxHeight2(tableMaxHeight)
			else t
		)		
	})
	|> (\f ->
		MComponentGroup2T(
			manager,
			parent,
			"MDynamicDataTable",
			[
				MEnabled(state.enabled),
				IScriptBehaviour("current_page", paginationState.pageNumber, ISInputValue([], "int", true)),
				IScriptBehaviour("sort_by", sorting.sortColumnNumber, ISInputValue(map(state.columns, \c -> fgetValue(c.header)), "index", true))
			],
			f
		)
	)
	|> (\t ->
		if (isInnerScroll || !isDefExpandRow) {
			if (useMaxSizeFix) {
				fullTableMaxWidth = make(0.);
				TAttachAvailableWidth(TInspect([IMaxWidth(fullTableMaxWidth)], t), screenW)
				|> TSetMaxWidth2(fullTableMaxWidth)
			} else TAttachAvailableWidth(t, screenW)
		} else if (state.fullWidth) TAttachWidth2(TFillX(), screenW, t)
		else t
	)
}

MDTState(
	manager : MaterialManager,
	columns : [MColumnDynamic],
	cellWs : Transform<[[DynamicBehaviour<double>]]>,
	minWidths : [Transform<double>],
	columnWidths : [Transform<double>],
	columnCalculatedWidths : [DynamicBehaviour<double>],
	rowHeight: double,
	lineHeight : (bool) -> double,
	headerActions : MHeaderActions,
	replaceHeader : bool,
	separators : bool,
	selection : MListSelection,
	selectionEnabled : MListSelectionEnabled,
	onClick : MOnListClick,
	clickEnabled : MClickEnabled,
	fixedRow : Maybe<MFixedRow>,
	fullWidthAdvanced : bool,
	fullWidth : bool,
	cellBorder : double,
	externalBorder : double,
	showRowNumbers : bool,
	widthByContent : bool,
	headCount : int,
	specialColumnsCount : int,
	isCheckboxColumn : (int) -> bool,
	checkboxSelectAllPages : Transform<bool>,
	makeChkbox : (MFocusGroup, DynamicBehaviour<bool>, Transform<bool>, () -> void, Maybe<[MIconStyle]>, Maybe<Transform<string>>) -> Tropic,
	makeCells : (MFocusGroup, int, [MCell], bool, Maybe<MTableRowspanInfo>) -> Transform<[Tropic]>,
	cellBox : (int, bool, int, int) -> Tropic,
	enabled : Transform<bool>,
	hoverEnabled : MHoverEnabled,
	rowsBoxScrollPosition : TScrollPosition,
	scrollEnabled : Transform<bool>,
	verticalScroll : [MScrollStyle],
	subs : [() -> () -> void],
	m2t : (Material, MFocusGroup) -> Tropic
);

makeMDataTableState(
	columns0 : [MColumnDynamic],
	style : [MDataTableStyle],
	manager : MaterialManager,
	parent : MFocusGroup,
	m2t : (Material, MFocusGroup) -> Tropic,
	rowsCountB : Transform<int>,
	paginationState : MPaginationState,
	sorting : MSortingState
) -> MDTState {
	cellBorder = 16.;
	externalBorder = 16.;

	enabled = extractStruct(style, MEnabled(const(true))).enabled;
	hoverEnabled : MHoverEnabled = extractStruct(style, MHoverEnabled(const(true)));

	rowsBoxScrollPosition : TScrollPosition = extractStruct(style, MScrollPosition(make(zeroPoint)));
	scrollEnabled = extractStruct(style, TScrollEnabled(const(false))).enabled;
	verticalScroll = extractStruct(style, MDataTableScrollStyle([])).style;

	rowHeight = extractStruct(style, MRowHeight(if (extractStruct(style, MCondensed(false)).condensed) 32. else 48.)).height;
	headerActions = extractStruct(style, MHeaderActions(TEmpty(), []));
	replaceHeader = contains(headerActions.style, MReplaceHeader());
	headerRowHeight = if (replaceHeader) 0. else extractStruct(style, MHeaderRowHeight(rowHeight)).height;
	lineHeight = \isHeader -> if (!isHeader) rowHeight else headerRowHeight;

	separators = !contains(style, MNoSeparators());
	onClick : MOnListClick = extractStruct(style, MOnListClick(const(false), nop1));
	clickEnabled : MClickEnabled = extractStruct(style, MClickEnabled(const(true)));

	singleSelection = tryExtractStruct(style, MSingleSelection(make(-1)));
	multiSelection = tryExtractStruct(style, MMultiSelection(make(makeSet())));
	selection : MListSelection =
		extractStruct(style, MListSelection(
			const(isSome(singleSelection) || isSome(multiSelection)),
			isSome(multiSelection),
			false,
			make([])
		));
	selectionEnabled : MListSelectionEnabled = extractStruct(style, MListSelectionEnabled(const([])));

	crop = !contains(style, MNoCrop());
	fixedRow = tryExtractStruct(style, MFixedRow(const(false), [], []));

	fullWidthAdvanced = contains(style, MFullWidthAdvanced());
	fullWidth = contains(style, MFullWidth()) || fullWidthAdvanced;

	checkboxSelection = tryExtractStruct(style, MCheckBoxSelection([]));
	isCheckboxColumn = \i -> isSome(checkboxSelection) && i == 0;
	checkboxColor = eitherMap(checkboxSelection, \cs -> extractMColor(parent, cs.style, MPrimaryColor()), MPrimaryColor());
	checkboxBorder = \rh -> forceRange((rh - 24.) / 2., 0., 12.);
	checkboxIconSize = extractStruct(eitherMap(checkboxSelection, \cs -> cs.style, []), MIconSize(standardIconSize)).size;
	checkboxColumnWidth = checkboxBorder(rowHeight) * 3. / 2. + checkboxIconSize - cellBorder;
	checkboxSelectAllPages = extractStruct(eitherMap(checkboxSelection, \cs -> cs.style, []), MCheckboxSelectAllPages(const(false))).enabled;

	makeChkbox = \p, trigger, en, onClk, hStyle, tooltipText -> {
		lh = lineHeight(isSome(hStyle));
		chStyle =
			concatA([
				[MIconButtonBorder(checkboxBorder(lh)), checkboxColor, MEnabled(en), MOnClick(onClk)],
				eitherMap(hStyle, \hs : [MIconStyle] -> concat(hs, [MUncheckedIconStyle(arrayPush(hs, MIconSize(checkboxIconSize)))]), []),
				[MIconSize(checkboxIconSize)],
				eitherMap(tooltipText, \tt -> [MTooltipText(tt)], [])
			]);

		MCheckBox2T(manager, p, MCheckBox(TEmpty(), trigger, chStyle), m2t)
		|> (\t -> TBorderDir(-checkboxBorder(lh) / 2. - cellBorder / 2., 0., 0., 0., t, p.rtl))
		|> (\t -> TCenterYIn(t, TFixed(0., lh)))
	}

	showRowNumbers = contains(style, MShowRowNumbers());

	widthByContent = contains(style, MWidthByContent());
	
	specialColumnsCount = b2i(showRowNumbers) + b2i(isSome(checkboxSelection));
	headCount =
		eitherMap(
			tryExtractStruct(style, MDataTableInnerScroll(MStandardMode(), [])),
			\is -> switch (is.mode) {
				MGluedFirstColumnMode(gluedStyle) : extractStruct(gluedStyle, MGluedColumns(1)).columns + specialColumnsCount;
				MGluedLastColumnMode(gluedStyle) : extractStruct(gluedStyle, MGluedColumns(1)).columns;
				default : 1 + specialColumnsCount
			},
			1 + specialColumnsCount
		);

	columns = columns0
		|> (\arr -> map(arr, \col ->
			if (widthByContent || contains(col.style, MWidthByContent()))
				MColumnDynamic(col with style = arrayPush(col.style, MWidthByContentLimited(const(-1.), const(-1.))))
			else col
		))
		|> (\arr -> if (showRowNumbers) concat([MColumn("#", "Row number", 80, [MWidthByContentLimited(const(-1.), const(-1.))])], arr) else arr)
		|> (\arr -> if (isSome(checkboxSelection)) concat([MColumn("", "", floor(checkboxColumnWidth), [MMaxWidth(floor(checkboxColumnWidth))])], arr) else arr);

	columnsCount = length(columns);

	cellWs : Transform<[[DynamicBehaviour<double>]]> =
		fselect(rowsCountB, FLift(\rc ->
			generate(0, rc + b2i(isSome(fixedRow)), \__ ->
				generate(0, columnsCount, \i ->
					if (isCheckboxColumn(i)) make(checkboxColumnWidth)
					else make(0.0)
				)
			)
		));

	minWidths = map(columns, \c -> {
		colEnabled = extractStruct(c.style, MEnabled(const(true))).enabled;
		fif(colEnabled, fselect(c.width, FLift(\w -> i2d(w) + cellBorder)), zero)
	});
	columnCalculatedWidths = mapi(columns, \i, col -> make(fgetValue(minWidths[i])));
	columnWidths : [Transform<double>] =
		mapi(columns, \i, col -> {
			colEnabled = extractStruct(col.style, MEnabled(const(true))).enabled;
			eitherMap(
				tryExtractStruct(col.style, MWidthByContentLimited(const(-1.), const(-1.))), \mwc ->
				fsubselect(cellWs, FLift(\cWs ->
					fsubselect(paginationState.page, FLift(\pg ->
						fsubselect(sorting.result, FLift(\srt -> {
							currentRows =
								eitherMap(
									fixedRow,
									\__ -> concat([firstElement(cWs, [])],
										map(subrange(srt, pg.first, pg.second), \idx -> elementAt(tail(cWs), idx, []))
									),
									map(subrange(srt, pg.first, pg.second), \idx -> elementAt(cWs, idx, []))
								);

							(
								if (length(currentRows) != 0)
									fmaxA(map(currentRows, \row -> elementAt(row, i, make(0.))), 0.)
								else
									fi2d(col.width)
							)
							|> (\colW -> fselect3(colW, mwc.minWidth, mwc.maxWidth, \cw, minW, maxW ->
									if (maxW == -1.) max(cw, minW)
									else forceRange(cw, minW, maxW)
								))
							|> (\colW -> faddition(colW, const(cellBorder)))
						}))
					))
				)),
			if (fullWidth)
				columnCalculatedWidths[i]
			else
				minWidths[i]
			)
			|> (\w -> fif(colEnabled, w, zero))
		});

	cellBox = \i, h, colspan, rowspan -> TSizedWidth(
		if (colspan == 1) elementAt(columnWidths, i, zero) else fsum(subrange(columnWidths, i, colspan)),
		lineHeight(h) * i2d(rowspan)
	);

	makeCells = \p, j, row : [MCell], firstColumn : bool, rowspanInfo : Maybe<MTableRowspanInfo> -> {
		checkbox = eitherMap(checkboxSelection, \__ ->
			if (j >= 0) {
				selRow = make(contains(getValue(selection.selected), j));
				makeChkbox(p, selRow,
					fsubselect(selectionEnabled.enabled, FLift(\en ->
						fand(selection.enabled, elementAt(en, j, const(true))),
					)),
					\ -> {
						sel = getValue(selection.selected);

						if (selection.multiple) {
							if (!getValue(selRow))
								nextDistinct(selection.selected, removeAll(sel, j))
							else if (!contains(sel, j))
								nextDistinct(selection.selected, arrayPush(sel, j))
						} else {
							if (getValue(selRow))
								nextDistinct(selection.selected, [j])
							else
								nextDistinct(selection.selected, [])
						}
					},
					None(),
					None()
				)
				|> (\t -> TConstruct(
					[\ -> fconnectSelect(selection.selected, selRow, \s -> contains(s, j))], t
				))
				|> unitaryCell
				|> v2a
			}
			else [TFixed(checkboxColumnWidth, 0.) |> unitaryCell],
			[]
		);

		fullRow : Transform<[MCell]> = [
			const(checkbox),
			const(if (showRowNumbers) [MText(i2s(j + 1), []) |> unitaryCell] else []),
			mapi(row, \i, cell -> fconcat(
				eitherMap(rowspanInfo, \rsi ->
					fif(
						fsubselect(elementAt(rsi.renderedRowspans, i, const([])), FLift(\column ->
							fOrs(
								map(column, \pair : Pair<Transform<int>, int> ->
									fselect2(pair.first, rsi.currentIndex, FLift2(\rsIdx, curIdx ->
										curIdx - rsIdx > 0 && curIdx - rsIdx < pair.second
									))
								),
								false
							)
						)),
						const([
							MCell(TSizedWidth(elementAt(columnWidths, i, zero), 0.), 1, 1),
							cell
						]),
						const([cell])
					),
					const([cell])
				),
				const(if (firstColumn) [] else generate(0, cell.colspan - 1, \__ -> MCell(TEmpty(), 0, 1)))
			))
			|> fmerge
			|> fconcatA
		]
		|> fmerge
		|> fconcatA;

		fselect(fullRow, FLift(\fr ->
			mapi(fr, \i, cell : MCell -> {
				if (i >= columnsCount)
					TEmpty()
				else {
					colStyle = columns[i].style;
					colEnabled = extractStruct(colStyle, MEnabled(const(true))).enabled;
					box = cellBox(i, false, if (firstColumn) 1 else cell.colspan, cell.rowspan);
					cellContent = cell.content;
					content =
						eitherMap(
							tryExtractStruct(colStyle, MWidthByContentLimited(const(-1.), const(-1.))), \wbcl ->
							MSelect(fstall(cellWs, 0), \cws -> {
								widthInspector = elementAt(elementAt(cws, j + b2i(isSome(fixedRow)), []), i, make(0.0));
								if (fgetValue(wbcl.maxWidth) == -1.)
									MAttachWidth(cellContent, widthInspector)
								else
									MInspect([IMaxWidth(widthInspector)], cellContent)
							}),
							cellContent
						);

					MCellContent2T(manager, p, content, rowHeight, box, crop && !isCheckboxColumn(i), m2t)
					|> alignCellContent(p, cellBorder, colStyle, box)
					|> TFixHeight(TFixed(0., lineHeight(false)))
					|> (\t -> TAccess(concatA([
							[TagName("td"), AccessRole("cell")],
							if (cell.colspan > 1) [FAccessAttribute("colspan", const(i2s(cell.colspan)))] else [],
							if (cell.rowspan > 1) [FAccessAttribute("rowspan", const(i2s(cell.rowspan)))] else [],
						]), t))
					|> (\t -> TShow(colEnabled, t))
				}
			})
		))
	};

	subs = concatA([
			sorting.subs(columns),
			paginationState.subs(rowsCountB, sorting.result),
			eitherMap(singleSelection,
				\ss -> [
					\ -> bidirectionalLink(
						ss.selected,
						selection.selected,
						\ar -> if (ar >= 0) [ar] else [],
						\ar -> lastElement(ar, -1)
					)
				], []
			),
			eitherMap(multiSelection,
				\ms -> [
					\ -> bidirectionalLink(
						ms.selected,
						selection.selected,
						set2array,
						buildSet
					)
				], []
			)
		]);

	MDTState(
		manager,
		columns,
		cellWs,
		minWidths,
		columnWidths,
		columnCalculatedWidths,
		rowHeight,
		lineHeight,
		headerActions,
		replaceHeader,
		separators,
		selection,
		selectionEnabled,
		onClick,
		clickEnabled,
		fixedRow,
		fullWidthAdvanced,
		fullWidth,
		cellBorder,
		externalBorder,
		showRowNumbers,
		widthByContent,
		headCount,
		specialColumnsCount,
		isCheckboxColumn,
		checkboxSelectAllPages,
		makeChkbox,
		makeCells,
		cellBox,
		enabled,
		hoverEnabled,
		rowsBoxScrollPosition,
		scrollEnabled,
		verticalScroll,
		subs,
		m2t
	)
}

MPaginationState(
	pagination : MPagination,
	page : DynamicBehaviour<Pair<int, int>>,
	pageNumber : DynamicBehaviour<int>,
	rowsPerPage : Transform<int>,
	updatePageNumber : (int) -> void,
	updateRowsPerPage : (int) -> void,
	anyType : bool,
	auto : bool,
	isEmpty : bool,
	hideAutoPaginationFooter : bool,
	cropPageHeight : bool,
	subs : (Transform<int>, Transform<[int]>) -> [() -> () -> void]
);

makeMPaginationState(style : [MDataTableStyle], isReorder : bool) -> MPaginationState {
	currentPage = tryExtractStruct(style, MCurrentPage(make(0)));
	mRowsPerPage = tryExtractStruct(style, MRowsPerPage(make(0)));
	goToIndex = tryExtractStruct(style, MGoToIndex(make(-1)));
	cropPageHeight = contains(style, MCropPageByVisibleLines());
	paginationDef = MPagination(make(0), []);
	pagination = if (isReorder) paginationDef else extractStruct(style, paginationDef);
	isEmpty = pagination.rowsPerPage == [];
	auto = !isReorder && isEmpty && contains(style, MPaginationAutoScaling());
	anyType = !isEmpty || auto;

	hideAutoPaginationFooter = contains(style, MHideAutoPaginationFooter());

	page = make(Pair(0, 0));

	updatePageNumber = \newPageNumber ->
		nextDistinct(page, Pair(newPageNumber, getValue(page).second));

	updateRowsPerPage = \newRowsPerPage ->
		nextDistinct(page, Pair(getValue(page).first, newRowsPerPage));

	pageNumber = make(0);
	rowsPerPage = fSecondOfPair(page);

	maxPageNumber = \rowsCountB -> fselect2Lift(rowsCountB, rowsPerPage, \rc, rpp -> max(0, ceil(i2d(rc) / i2d(max(rpp, 1))) - 1));

	subs = \rowsCountB, sortingResult -> [
		\ -> fBidirectionalLink(page, pageNumber,
			\pair -> nextDistinct(pageNumber, pair.first / max(pair.second, 1)),
			\num -> {
				rpp = fgetValue(rowsPerPage);
				rowsCount = fgetValue(rowsCountB);
				updatePageNumber(forceRange(num * rpp, 0, rowsCount - 1))
			}),
			makeSubscribe2(maxPageNumber(rowsCountB), \maxPage -> nextDistinct(pageNumber, min(maxPage, getValue(pageNumber))))
		]
		|> (\sbs ->
			eitherMap(
				currentPage,
				\cp ->
					concat(
						[
							make2Subscribe(cp.page, rowsCountB, \pg, rowsCount -> {
								rpp = fgetValue(rowsPerPage);
								updatePageNumber(max(0, min(pg * rpp, rowsCount -1)))
							}),
							\ -> fconnectSelect(page, cp.page, \pg -> pg.first / max(pg.second, 1))
						],
						sbs
					),
				sbs
			)
		)
		|> (\sbs ->
			eitherMap(
				goToIndex,
				\gti ->
					concat(
						[
							make2Subscribe(gti.index, rowsCountB, \ind, rowsCount ->
								fromArrayIndex([ind],  Pair(0, rowsCount), rowsCount, fgetValue(sortingResult))
								|> (\f3 -> if (length(f3) > 0) {
										rpp = fgetValue(rowsPerPage);
										updatePageNumber(if (rpp == 0) 0 else f3[0] / rpp * rpp)
									})
							)
						],
						sbs
					),
				sbs
			)
		)
		|> (\sbs ->
			eitherMap(
				mRowsPerPage,
				\mrpp ->
					concat(
						[\ -> fconnect(rowsPerPage, mrpp.rowsPerPage)],
						sbs
					),
				sbs
			)
		);

	MPaginationState(
		pagination,
		page,
		pageNumber,
		rowsPerPage,
		updatePageNumber,
		updateRowsPerPage,
		anyType,
		auto,
		isEmpty,
		hideAutoPaginationFooter,
		cropPageHeight,
		subs
	)
}

MSortingState(
	result : Transform<[int]>,
	sortedBy : DynamicBehaviour<MDataTableSorting>,
	sortColumnNumber : DynamicBehaviour<int>,
	hasExtOrderBy : bool,
	onColumnClick : (int, Maybe<MSort>, Maybe<MSortByValue>, bool, bool, bool) -> void,
	subs : ([MColumnDynamic]) -> [() -> () -> void]
);

MDataTableSorting(
	column : int,
	ascending : bool,
	sortInfo : Maybe<MSort>,
	sortByValue : Maybe<MSortByValue>,
	autoSortByRowData : bool,
	caseInsensitive : bool
);
dataTableSortingDef = MDataTableSorting(-1, true, None(), None(), false, false);

skipSortingThreshold = 10000.; // ms

makeMSortingState(data : Transform<[?]>, rowsFn : (?) -> [MCell], style : [MDataTableStyle], isReorder : bool, lightweight : bool,
	manager : MaterialManager, m2t : (Material, MFocusGroup) -> Tropic) -> MSortingState {

	defaultParam : DynamicBehaviour<MSortingParam> = extractStruct(style, MSortingDefault(make(MSortingParam(0, true)))).sorting;
	listSortedCallback = extractStruct(style, MListSorted(nop1)).newOrderCallback;
	sortedBy : DynamicBehaviour<MDataTableSorting> = make(dataTableSortingDef);
	sortColumnNumber = make(-1);
	sortUpdating = tryExtractStruct(style, MUpdateSorting(0));
	hasExtOrderBy = contains(style, MExternalSort());
	isFirstClick = ref true;

	updatingTrigger = make(true);
	maybeApply(sortUpdating, \su -> updateTrigger(updatingTrigger, su.delay));
	showWarningSnackbar = \ -> renderMSnackbar(manager, "Warning! Sorting lasted for too long and was skipped.", [], m2t, \t -> trender(t, manager.manager.renderStyle));

	result = fsubselect(data, FLift(\dat : [?] ->
		fselect2(sortedBy, updatingTrigger, FLift2(\sb : MDataTableSorting, __ -> {
			sorted =
				if (sb.column >= 0 && !hasExtOrderBy)
					eitherFn(
						sb.sortInfo,
						\sInfo ->
							mergeSort(
								enumFromTo(0, length(dat) - 1),
								\a, b ->
									if (sb.ascending) sInfo.colCompares(a, b)
									else sInfo.colCompares(b, a)
							),
						\ -> eitherFn(
							sb.sortByValue,
							\sInfo ->
								map(
									sortCustom(
										mapi(dat, \j, r -> Pair(sInfo.getValueFn(r), j)),
										firstOfPair,
										sb.ascending
									),
									secondOfPair
								),
							\ ->
							// We have to duplicate code below because of type issues
							if (lightweight && sb.autoSortByRowData) {
								if (sb.caseInsensitive)
									map(
										sortCustom(
											mapi(dat, \j, r -> Pair(toLowerCase(toString(r)), j)),
											firstOfPair,
											sb.ascending
										),
										secondOfPair
									)
								else
									map(
										sortCustom(
											mapi(dat, \j, r -> Pair(r, j)),
											firstOfPair,
											sb.ascending
										),
										secondOfPair
									)
							} else {
								if (lightweight && length(dat) >= 100) {
									st = if (sb.caseInsensitive) "MAutoSortCaseInsensitive()" else "MAutoSort()";
									println("WARNING! You are going to sort on column with " + st + " style inside potentially big MLightweightDataTable. It can lead to noticeable freeze. Consider using MAutoSortByRowData() or MSortByValue() instead.");
								}
								skipSorting = ref false;
								startSort = timestamp();
								if (sb.caseInsensitive)
									map(
										sortCustom(
											mapi(dat, \j, r -> {
												value =
													if (^skipSorting) ""
													else if (timestamp() - startSort > skipSortingThreshold) {
														println("WARNING! Sorting was skipped " + d2s(skipSortingThreshold) + " ms after start. "
															+ i2s(j) + " items out of " + i2s(length(dat)) + " were processed.");
														skipSorting := true;
														deferred(showWarningSnackbar);
														""
													} else {
														cellM = elementAt(map(rowsFn(r), \cell -> cell.content), sb.column, TEmpty());
														toLowerCase(toString(switch (cellM) {
															MMutable(mutContent): fgetValue(mutContent);
															TMutable(mutContent): fgetValue(mutContent);
															default: cellM
														}))
													}
												Pair(value, j)
											}),
											firstOfPair,
											sb.ascending
										),
										secondOfPair
									)
								else
									map(
										sortCustom(
											mapi(dat, \j, r -> {
												value =
													if (^skipSorting) TEmpty()
													else if (timestamp() - startSort > skipSortingThreshold) {
														println("WARNING! Sorting was skipped " + d2s(skipSortingThreshold) + " ms after start. "
															+ i2s(j) + " items out of " + i2s(length(dat)) + " were processed.");
														skipSorting := true;
														deferred(showWarningSnackbar);
														TEmpty()
													} else {
														cellM = elementAt(map(rowsFn(r), \cell -> cell.content), sb.column, TEmpty());
														switch (cellM) {
															MMutable(mutContent): fgetValue(mutContent);
															TMutable(mutContent): fgetValue(mutContent);
															default: cellM
														}
													}
												Pair(value, j)
											}),
											firstOfPair,
											sb.ascending
										),
										secondOfPair
									)
							}
						)
					)
				else enumFromTo(0, length(dat) - 1);
			listSortedCallback(sorted);
			sorted
		})
	)));

	onColumnClick = \i, columnSortStyle, columnSortByValueStyle, autoSortByRowData, caseInsensitive, initialClick -> {
		if (!initialClick || (^isFirstClick && getValue(defaultParam).colIndex == i)) {
			sb = fgetValue(sortedBy);

			if (sb.column == i && !sb.ascending) {
				nextDistinct(defaultParam, MSortingParam(-1, true));
				next(sortedBy, MDataTableSorting(dataTableSortingDef with ascending = false))
			} else {
				asc =
					if (sb.column == -1)
						getValue(defaultParam).isAsc
					else
						sb.column != i;
				nextDistinct(defaultParam, MSortingParam(i, asc));
				next(sortedBy, MDataTableSorting(i, asc, columnSortStyle, columnSortByValueStyle, autoSortByRowData, caseInsensitive))
			}
			isFirstClick := false
		}
	}

	subs = \columns -> [
		\ -> fBidirectionalLink(sortedBy, sortColumnNumber,
			\sb -> nextDistinct(sortColumnNumber, sb.column),
			\num -> {
				columnStyle = if (num >= 0 && !isReorder) columns[num].style else [];
				sortInfo = tryExtractStruct(columnStyle, MSort(\__, __ -> 0));
				sortByValue = tryExtractStruct(columnStyle, MSortByValue(\__ -> 0));
				autoSortByRowData = contains(columnStyle, MAutoSortByRowData());
				caseInsensitive = contains(columnStyle, MAutoSortCaseInsensitive());

				nextDistinct(sortedBy, MDataTableSorting(num, !getValue(defaultParam).isAsc, sortInfo, sortByValue, autoSortByRowData, caseInsensitive));
			})
	];

	MSortingState(
		result,
		sortedBy,
		sortColumnNumber,
		hasExtOrderBy,
		onColumnClick,
		subs
	)
}

MInnerScrollState(
	lifted : bool,
	glued : Maybe<bool>,
	gluedStyle : Maybe<[MGluedColumnModeStyle]>,
	enabled : Transform<bool>,
	visibilityInspector : DynamicBehaviour<bool>,
	visible : Transform<bool>,
	position : DynamicBehaviour<Point>,
	style : [MScrollStyle]
);

makeMInnerScrollState(
	fullWidth : bool,
	screenW : Transform<double>,
	minWidthsSum : Transform<double>,
	externalBorder : double,
	style : [MDataTableStyle],
	innerScrollHotfix : bool) -> Maybe<MInnerScrollState> {

	innerScroll =
		if (!isUrlParameterFalse("table_inner_scroll_enabled") && !innerScrollHotfix) {
			is = extractStruct(style, MDataTableInnerScroll(MStandardMode(), []));
			if (is.mode == MNoScroll()) None() else Some(is);
		} else {
			is = extractStruct(style, MDataTableInnerScroll(MNoScroll(), []));
			if (is.mode == MNoScroll()) None() else Some(is);
		}

	maybeMap(innerScroll, \is -> {
		lifted = is.mode == MLiftedFirstColumnMode();
		gluedStyle = switch (is.mode) {
			MGluedFirstColumnMode(gstyle) : Some(gstyle);
			MGluedLastColumnMode(gstyle) : Some(gstyle);
			default : None()
		};
		glued = switch (is.mode) {
			MGluedFirstColumnMode(__) : Some(true);
			MGluedLastColumnMode(__) : Some(false);
			default : None()
		};
		enabled = if (fullWidth) fless(screenW, faddition(minWidthsSum, const(2. * externalBorder))) else const(true);
		visibilityInspector = make(false);
		visible = fstall(fand(enabled, visibilityInspector), 0);
		position = extractStruct(is.style, MScrollPosition(makePoint())).position;
		uiEnabled = fand(enabled, extractStruct(style, MEnabled(const(true))).enabled);
		MInnerScrollState(lifted, glued, gluedStyle, uiEnabled, visibilityInspector, visible, position, is.style)
	});
}

MDTTitles(
	state : MDTState,
	p : MFocusGroup,
	sorting : MSortingState,
	defaultHS : MHeaderStyle,
	headerStyle : Maybe<MHeaderStyle>,
	isReorder : bool,
	rowsCountB : Transform<int>,
	page : DynamicBehaviour<Pair<int, int>>,
) -> [Tropic] {
	mapi(state.columns, \i0, c : MColumnDynamic -> if (state.replaceHeader) state.cellBox(i0, true, 1, 1) else {
		colHeaderStyle = tryExtractStruct(concat(c.style, eitherMap(headerStyle, \e -> [e], [])), defaultHS);
		arrowStyle = eitherMap(colHeaderStyle, \chs -> style2MIconStyle(chs.textStyle), []);
		rightAlign = isSameStructType(commonAlignment2abs(extractCommonAlignment(c.style), p.rtl), RightAlign());
		sortStyle = if (isReorder) None() else tryExtractStruct(c.style, MSort(\__, __ -> 0));
		sortByValueStyle = if (isReorder) None() else tryExtractStruct(c.style, MSortByValue(\__ -> 0));
		autoSortByRowData = contains(c.style, MAutoSortByRowData());
		caseInsensitive = contains(c.style, MAutoSortCaseInsensitive());
		arrowIconSize = 16.;
		sortable = !isReorder && (
			isSome(sortStyle)
			|| isSome(sortByValueStyle)
			|| sorting.hasExtOrderBy
			|| contains(c.style, MAutoSort())
			|| autoSortByRowData
			|| caseInsensitive
		);
		columnWidthInspector = tryExtractStruct(c.style, MColumnWidthInspector(make(0.)));
		colEnabled = extractStruct(c.style, MEnabled(const(true))).enabled;
		i = i0 - state.specialColumnsCount;

		defHeaderTitle = \isSelected : bool -> {
			defFont = if (isSelected) MCaptionColumnSelected() else MCaptionColumn();
			TSelect(c.header, \header ->
				MEllipsisText2T(
					state.manager,
					p,
					MEllipsisText(
						header,
						eitherMap(colHeaderStyle, \hs -> concat([defFont], hs.textStyle), [defFont])
					),
					state.m2t
				)
			)};

		makeHeaderTitle =
			eitherMap(
				tryExtractStruct(c.style, MColumnCustomTitle(\__ -> TEmpty())),
				\customTitle -> \isSelected -> state.m2t(customTitle.fn(isSelected), p),
				defHeaderTitle
			)
			|> (\h -> \isSelected -> TCenterYIn(h(isSelected), TFixed(0., arrowIconSize)));

		ascendingAttribute =
			if (sortable) fselectLift(sorting.sortedBy, \sb -> {
				if (sb.column == i) {
					if (sb.ascending) "ascending" else "descending"
				} else "none"
			}) else const("");

		(if (sortable) {
			hover = make(false);
			clickColumn = \initialClick -> sorting.onColumnClick(i, sortStyle, sortByValueStyle, autoSortByRowData, caseInsensitive, initialClick);
			isAscending = fselectLift(sorting.sortedBy, \sb -> sb.ascending);

				TIfLazy2(
					fselect(sorting.sortedBy, FLift(\sb : MDataTableSorting -> sb.column == i)),
					\isSorting ->
						TSelect(
							fand(state.enabled, hover),
							\h ->
								TColsDir(
									[
										makeHeaderTitle(h) |> TBorderEnd(4., p.rtl),
										if (isSorting)
											TIfLazy2(isAscending, \isAsc ->
												MIcon2T(p, if (isAsc) "arrow_upward" else "arrow_downward", concat([MIconSize(arrowIconSize)], arrowStyle)),
												true
											)
										else if (h)
											MIcon2T(p, "arrow_upward", concat([MIconSize(arrowIconSize), FillOpacity(0.24)], arrowStyle))
										else
											TFixed(arrowIconSize, 0.)
									]
										|> (\f2 -> if (rightAlign) reverseA(f2) else f2),
									p.rtl
								)
						),
					false
				)
				|> (\t -> MComponent2T(state.manager, p, "MColumnTitle", [
					THovering(hover),
					MOnClick(\ -> clickColumn(false)),
					MEnabled(state.enabled),
					MButtonTitle(fselectLift(c.header, \hd -> hd + " column sort")),
					MHighlightOnFocus(const(true))
				], \__ -> t, state.m2t))
				|> (\t -> TConstruct([\ -> {clickColumn(true); nop}], t))
		} else
			makeHeaderTitle(false)
		)
		|> (\f2 : Tropic ->
			if (c.tooltip == const(""))
				f2
			else
				MTooltip2T(state.manager, p,
					MTooltip(f2, MSelect(c.tooltip, \t -> MText(t, [MTooltipDesktop(), sameLightMColor(p)])), [MBlockHover()]),
					state.m2t
				)
		)
		|> (\t -> if (state.isCheckboxColumn(i0)) {
				allSelected = make(false);
				shouldSelectAll = fOr(state.scrollEnabled, state.checkboxSelectAllPages);

				selPage =
					fselect3(
						fif(shouldSelectAll, fselect(rowsCountB, FLift(\rc -> Pair(0, rc))), page),
						sorting.result,
						fsubselect(state.selectionEnabled.enabled, FLift(fmerge)),
						\pg, sr, en ->
							fold(
								subrange(sr, pg.first, min(pg.second, length(sr))),
								[], \acc, j ->
									ifArrayPush(
										acc,
										elementAt(en, j, true),
										j
									)
							)
					);

				state.makeChkbox(p, allSelected,
					if (state.selection.multiple)
						fand(state.selection.enabled, fselect(selPage, FLift(\pg -> length(pg) > 0)))
					else
						const(false),
					\ -> nextDistinct(state.selection.selected,
						if (getValue(allSelected))
							concat(getValue(state.selection.selected), fgetValue(selPage)) |> uniq
						else {
							sPage = fgetValue(selPage);
							subtractA(getValue(state.selection.selected), sPage)
						}
					),
					Some(arrowStyle),
					Some(fselect2Lift(allSelected, shouldSelectAll, \selected, selectAll -> {
						if (selectAll) {
							if (selected) _("Unselect all pages") else _("Select all pages")
						} else {
							if (selected) _("Unselect current page") else _("Select current page")
						}
					}))
				)
				|> (\t2 ->
					if (state.selection.multiple)
						TConstruct(
							[
								make2Subscribe(state.selection.selected, selPage, \sel, pg ->
									nextDistinct(
										allSelected,
										length(pg) != 0 && length(sel) >= length(pg)
											&& forall(pg, \j -> contains(sel, j))
									)
								)
							],
							t2
						)
					else
						t2
				)
			} else t
		)
		|> alignCellContent(p, state.cellBorder, c.style, state.cellBox(i0, true, 1, 1))
		|> (\t -> eitherMap(columnWidthInspector, \inspector ->
				if (existsIndex(state.columnWidths, i0))
					TConstruct(
						[makeSubscribe(state.columnWidths[i0], \w -> nextDistinct(inspector.width, w - state.cellBorder))],
						t
					)
				else t,
				t
			))
		|> (\t -> TAccess([TagName("th"), AccessRole("columnheader"), FAccessAttribute("scope", const("col")), FAccessAttribute("aria-sort", ascendingAttribute)], t))
		|> (\t -> TShow(colEnabled, t))
	});
}

MDTSideColumns(
	state : MDTState,
	parent : MFocusGroup,
	headers : [Tropic],
	data : Transform<[?]>,
	rowsFn : (?) -> [MCell],
	sorting : MSortingState,
	innerScrollState : Maybe<MInnerScrollState>,
	expandRow : Transform<int>,
	yTranslation : Transform<double>,
	rowBackgroundStyle : Maybe<MRowBackgroundStyle>,
	selectedBgStyle : Maybe<MSelectedBackgroundStyle>,
	totalRowsHeight : Transform<double>,
	visibleRowsHeight : Transform<double>,
	rowsAvailableHeight : Transform<double>,
	page : DynamicBehaviour<Pair<int, int>>,
	lightweight : bool
) -> (Tropic) -> Tropic {
	\table ->
		eitherMap(innerScrollState, \is -> if (isSome(is.glued) || is.lifted) {
			isGlued = isSome(is.glued);
			isStart = either(is.glued, false) || is.lifted;

			getSideFn = \arr : [flow] -> if (isStart) colsHead(state, arr) else colsLastColumns(state, arr);

			implementExpandRow = \isHeader ->
				\t -> TBorderT(zero, zero, zero, fselect(expandRow, FLift(\er -> state.lineHeight(isHeader) * (i2d(er - 1)))), t);

			wrapLineInBorder = \t -> TBorderDir(state.externalBorder, 0., 0., 0., t, parent.rtl == isStart);

			columnsWidth = arrayPush(getSideFn(state.columnWidths), const(state.externalBorder)) |> fsum;

			columnsHeader =
				(
					if (is.lifted) TFixed(0., state.lineHeight(true))
					else getSideFn(headers)
						|> (\t -> TColsDir(t, parent.rtl))
						|> wrapLineInBorder
				)
				|> implementExpandRow(true);

			materializeRow = \row, j -> {
				TSelect(state.makeCells(parent, j, row, true, None()),
					\cells -> TColsDir(getSideFn(cells), parent.rtl)
				)
				|> (\t ->
					if (is.lifted)
						TAlpha(fselect(is.position, FLift(\isp -> max(0.5, 1. - abs(isp.x) / 100.))), t)
						|> TBorderBottom(state.rowHeight)
					else t
				)
				|> implementExpandRow(false)
				|> wrapLineInBorder
				|> (\t -> if (isGlued) {
						if (j == -1) t
						else
							TIfLazy2(
								fcontains(state.selection.selected, const(j)),
								\v -> if (v)
										TFrame(0., 0., eitherMap(selectedBgStyle, \sbs -> sbs.style, getDefLineSelectedBackground(parent)), t)
									else
										eitherMap(rowBackgroundStyle, \rb -> TFrame(0., 0., rb.fn(j), t), t),
								false
							)
					} else t
				)
				|> (\t -> if (state.separators && isGlued) addSeparator(state.manager, parent, t, false) else t)
				|> (\t -> if (isGlued)
					MComponent2T(state.manager, parent, "MDataTableLine" + i2s(j), [
						MOnClick(\ -> MListOnClickHandler(state.selection, state.selectionEnabled, state.onClick)(j)),
						MRippleType(const(MRippleFill())),
						state.clickEnabled,
						MHighlightOnHover(state.hoverEnabled.enabled),
						TagName("tr"),
						AccessRole("row")
					], \__ -> t, state.m2t) else t
				)
			}

			wrapIntoScroll = \t ->
				MScroll2T(state.manager, parent, MScroll(t, TFillXY(), [
					state.rowsBoxScrollPosition,
					TScrollEnabled(const(false)),
					MScrollCropByContent(),
					MScrollbars(
						TScrollbarStyle(getMaterialScrollBar().x with visible = const(false)),
						TScrollbarStyle(getMaterialScrollBar().y with visible = const(false))
					),
					MScrollBound(const(true), const(false)),
				]), state.m2t);

			rows =
				if (lightweight) {
					values : Transform<[Pair<Maybe<?>, int>]> =
						fselect3(sorting.result, data, page, \sortRes, dat, pg ->
							map(subrange(sortRes, pg.first, pg.second + 1), \i -> Pair(elementAtM(dat, i), i))
						);
					SelectTLinesA(values, \idx, id, value -> {
						row = eitherMap(value.first, rowsFn, []);
						materializeRow(row, value.second)
					})
					|> (\t -> TGroup2(
							TSizedHeight(0., totalRowsHeight),
							TTranslate(fpoint(zero, yTranslation), t)
						)
					)
					|> wrapIntoScroll
				} else {
					cells =
						fselect2(sorting.result, data, FLift2(\sortRes, dat ->
							map(sortRes, \i -> elementAtMap(dat, i, rowsFn, []))
							|> (\arr -> eitherMap(state.fixedRow, \fr -> concat([map(fr.cols, unitaryCell)], arr), arr))
							|> (\arr -> mapi(arr, \i, row -> {
								j = sortRes[i - b2i(isSome(state.fixedRow))];
								materializeRow(row, j)
							}))
						));

					TSelect(eitherMap(state.fixedRow, \__ -> fselect(cells, FLift(tail)), cells), \l -> TLinesDir(l, parent.rtl))
					|> wrapIntoScroll
					|> (\t -> eitherMap(state.fixedRow, \fr -> {
							bStyle =
								filtermap(fr.style, \st -> switch (st) {
									TGraphicsStyle() : {a : Maybe<TGraphicsStyle> = Some(st); a};
									default : None()
								});

							TSelect(cells, \cells0 -> firstElement(cells0, TEmpty()))
							|> (\t2 -> TCopySize(t2, \tr -> TRounded(2., 2., 0., 0., bStyle, tr), false))
							|> (\t2 -> TShow(fr.show, t2))
							|> (\t2 -> TLines2Dir(t2, t, parent.rtl))
						}, t));
				}

			sideColumns =
				rows
				|> (\t -> TAlpha(fif(parent.enabled, const(1.), const(if (getLightBackground(parent)) 0.26 else 0.3)), t))
				|> (\t -> TAvailableHeightPreventFillers(t, rowsAvailableHeight))
				|> (\t -> if (state.separators && isGlued) addSeparator(state.manager, parent, t, true) else t)
				|> (\t -> TAvailableWidth(t, columnsWidth))
				|> (\t -> TLines2Dir(columnsHeader, t, parent.rtl))
				|> (\t ->
						eitherMap(is.gluedStyle, \gStyle ->
							TGroup2(
								TShow(is.visible, t),
								TShow(
									extractStruct(gStyle, MSeparatorVisible(is.visible)).visible,
									TAvailableHeightPreventFillers(
										MSeparator2T(state.manager, parent, false),
										faddition(visibleRowsHeight, fselect(expandRow, FLift(\er -> state.lineHeight(true) * i2d(er))))
									)
								)
								|> (\sep -> TBorderTDir(columnsWidth, zero, zero, zero, sep, parent.rtl == isStart))
							),
							t
						)
				)
				|> (\t -> if (isStart) TAlignStartDir(t, parent.rtl) else TAlignEndDir(t, parent.rtl));

			TGroup2(
				if (isGlued) TBorderTDir(fif(is.visible, columnsWidth, zero), zero, zero, zero, table, parent.rtl == isStart)
				else table,
				sideColumns
			)
		} else table, table)
}

MDTFooter(
	manager : MaterialManager,
	parent : MFocusGroup,
	paginationState : MPaginationState,
	rowsCountB : Transform<int>,
	scrollEnabled : Transform<bool>,
	noFooter : bool,
	footerHeight : double,
	footerMinWidth : DynamicBehaviour<double>,
	m2t : (Material, MFocusGroup) -> Tropic
) -> Tropic {

	pagination = paginationState.pagination;
	page = paginationState.page;
	fixPaginationCurrent = \current -> forceRange(current, 0, length(pagination.rowsPerPage) - 1);

	footer =
		if (paginationState.anyType)
			MSelect2T(manager, parent, "MDynamicDataTableFooter", [], rowsCountB, \rowsCount, p2 -> {
				makeFooterButton = \title : string, tooltipText : string, makeUpdatedRow : (Pair<int, int>) -> int, makeEnabled : (Pair<int, int>) -> bool ->
					MIconButton2T(
						manager,
						p2,
						MIconButton(
							title,
							\ -> paginationState.updatePageNumber(makeUpdatedRow(getValue(page))),
							[],
							[MEnabled(fselect(page, FLift(makeEnabled))), MButtonTitle(const(tooltipText)), MTooltipText(const(tooltipText))]
						),
						m2t
					)
					|> TCenterY;

				showFooter =
					eitherMap(minA(pagination.rowsPerPage),
						\rpp -> const(rowsCount >= rpp),
						fOr(const(!paginationState.hideAutoPaginationFooter), fselect(paginationState.rowsPerPage, FLift(\rpp -> rowsCount > rpp)))
					);

				if (!paginationState.isEmpty) {
					selectedRowsPerPage = fixPaginationCurrent(getValue(pagination.current));
					paginationState.updateRowsPerPage(pagination.rowsPerPage[selectedRowsPerPage])
				};


				concatA([
					[TFillX()],
					if (length(pagination.rowsPerPage) > 1)
						[
							MText2T(p2, _("Rows per Page:"), [MCaption()])
							|> TCenterY
							|> (\t -> TBorder(8., 0., 16., 0., t)),
							MDropDown2T(
								manager,
								p2,
								MDropDown(
									pagination.current,
									"",
									map(pagination.rowsPerPage, toString),
									[MDataTableFooter(), MCroppedButton()]
								),
								m2t
							)
							|> (\f2 ->
								TConstruct([
									makeSubscribe2(pagination.current, \c ->
										paginationState.updateRowsPerPage(pagination.rowsPerPage[c])
									)
								], f2)
							)
							|> TCenterY
							|> TBorderRight(16.)
						]
					else
						[],

					[
						TSelect(page, \pg -> {
							text =  formatString(
								_("%3-%2 of %1"),
								[i2s(rowsCount), i2s(max(min(pg.first + pg.second, rowsCount), 0)), i2s(min(pg.first + 1, rowsCount))]
							);

							MText2T(p2, text, [MCaption()])
						})
							|> TCenterY
							|> TBorderEnd(16., parent.rtl),
						makeFooterButton(
							"first_page",
							_("First page"),
							\__ -> 0,
							\pg -> pg.first > 0
						)
							|> hideIfLittlePages(rowsCount, paginationState.rowsPerPage),
						makeFooterButton(
							"navigate_before",
							_("Previous page"),
							\pg -> max(pg.first - pg.second, 0),
							\pg -> pg.first > 0
						),
						makeFooterButton(
							"navigate_next",
							_("Next page"),
							\pg -> min(pg.first + pg.second, rowsCount - if (fgetValue(scrollEnabled)) pg.second else 0),
							\pg -> (rowsCount > 0) && (pg.first + pg.second < rowsCount)
						),
						makeFooterButton(
							"last_page",
							_("Last page"),
							\pg -> min((rowsCount - 1) / pg.second * pg.second, rowsCount - if (fgetValue(scrollEnabled)) pg.second else 0),
							\pg -> pg.first + pg.second < rowsCount
						)
							|> hideIfLittlePages(rowsCount, paginationState.rowsPerPage)
					]
				])
				|> (\t -> TColsDir(t, parent.rtl))
				|> (\t -> TAvailableHeight(t, const(footerHeight)))
				|> makeTropicConstantHeight(footerHeight |> Some)
				|> (\t -> TShowLazy(showFooter, \ -> t))
			})
		else if (noFooter)
			TEmpty()
		else
			TFixed(0., footerHeight);

	footer
	|> (\t -> TAttachMinWidth(t, footerMinWidth));
}

MCellContent2T(manager : MaterialManager, parent : MFocusGroup, c : Material, rowHeight : double, box : Tropic, crop : bool, m2t : (Material, MFocusGroup) -> Tropic) -> Tropic {
	wrapCellContent = \m -> MCellContent2T(manager, parent, m, rowHeight, box, crop, m2t);
	wrapCellContentDef = \m -> MCellContentDefault2T(parent, m, box, crop, m2t);

	switch (c) {
		MSmallEditDialog(__, __, __): {
			MSmallEditDialog2T(manager, parent, c, m2t)
		}
		MSwitchControl(__, __): {
			TBorder(-4.0, -8., -4.0, -8., MSwitchControl2T(manager, parent, c, m2t))
		}
		MDropDown(__, __, __, __): {
			TBorder(-24., 0., -24., 0., MDropDown2T(manager, parent, c, m2t))
		}
		MDropDownMenu(__, __, __): {
			TBorder(-24., 0., -24., 0., MDropDownMenu2T(manager, parent, c, m2t))
		}
		MText(text, style): {
			MEllipsisText2T(manager, parent, MEllipsisText(text, replaceStructMany(style, [MShowTooltip(const(true))])), m2t)
		}
		MIconButton(name, onClick, style, state): {
			MIconButton2T(manager, parent, MCellIconButton(name, onClick, style, state, rowHeight), m2t)
		}
		MTooltip(cont, tooltip, st): {
			MTooltip2T(manager, parent, MTooltip(wrapCellContent(cont), tooltip, st), m2t)
		}
		MConstruct(cons, content): {
			TConstruct(cons, wrapCellContent(content));
		}
		MShow(show, content): {
			TShow(show, wrapCellContent(content));
		}
		MVisible(visible, content): {
			TVisible(visible, wrapCellContent(content));
		}
		MMutable(contentT): {
			TMutable(fselect(contentT, FLift(wrapCellContent)))
		}
		MIf(cond, contentA, contentB): {
			TIf(cond, wrapCellContent(contentA), wrapCellContent(contentB))
		}
		MGroup(elements): {
			TGroup(map(elements, wrapCellContent))
		}
		MGroup2(m1, m2): {
			TGroup2(wrapCellContent(m1), wrapCellContent(m2))
		}
		MLines(elements): {
			TLinesDir(map(elements, wrapCellContent), parent.rtl)
		}
		MLines2(m1, m2): {
			TLines2Dir(wrapCellContent(m1), wrapCellContent(m2), parent.rtl)
		}
		MCols(elements): {
			TColsDir(map(elements, wrapCellContent), parent.rtl)
		}
		MCols2(m1, m2): {
			TCols2Dir(wrapCellContent(m1), wrapCellContent(m2), parent.rtl)
		}
		MCenter(m): {
			TCenter(wrapCellContent(m))
		}
		MCenterX(m): {
			TCenterX(wrapCellContent(m))
		}
		MCenterY(m): {
			TCenterY(wrapCellContent(m))
		}
		MBorder(l, t, r, b, m): {
			TBorder(l, t, r, b, wrapCellContent(m))
		}
		MClickable(m, onClick): {
			clickable(manager, parent, wrapCellContent(m), onClick)
		}
		MInteractive(interactivity, m): {
			TInteractive(interactivity, wrapCellContent(m))
		}
		MInspect(inspectors, m): {
			TInspect(inspectors, wrapCellContent(m))
		}
		MMenu(button, items, style): {
			switch (button) {
				MIconButton(name, onClick, iconStyle, state): {
					wrapCellContentDef(MMenu(MCellIconButton(name, onClick, iconStyle, state, rowHeight), items, style))
				}
				default: wrapCellContentDef(c);
			}
		}
		MGetFocusGroup(fn): {
			wrapCellContent(fn(parent))
		}
		MGetManager(fn): {
			wrapCellContent(fn(manager))
		}
		MGetMaterial2Tropic(fn): {
			wrapCellContent(fn(m2t))
		}
		default: {
			wrapCellContentDef(c)
		}
	}
}

MCellIconButton(name : string, onClick : () -> void, style : [MIconButtonStyle], state : [MButtonState], rowHeight : double) -> MIconButton {
	iconSize : MIconSize = MIconSize(min(extractStruct(style, MIconSize(if (rowHeight > 32.) 24. else 18.)).size, rowHeight));
	circleBackground : MCircleBackground =
		extractStruct(style, MCircleBackground(MRed(500), 0.))
		|> (\f -> MCircleBackground(f.color, min(f.size, rowHeight)));
	border : MIconButtonBorder =
		MIconButtonBorder(
			forceRange(
				extractStruct(style, MIconButtonBorder(iconSize.size / 2.)).border,
				0.,
				(rowHeight - iconSize.size) / 2.
			)
		);

	MIconButton(name, onClick, replaceStructMany(style, [iconSize, circleBackground, border]), state);
}

MCellContentDefault2T(parent : MFocusGroup, c : Material, box : Tropic, crop : bool,  m2t : (Material, MFocusGroup) -> Tropic) -> Tropic {
	m2t(c, parent)
	|> (\f -> if (crop) TCopySize2(f, \tr2, f3 -> TCropSize(TMinimumGroup2(tr2, box), f3)) else f)
}

initExpandRow(enabled : Transform<bool>, screenW : Transform<double>, minWidthsSum : Transform<double>, externalBorder : double) -> Transform<int> {
	prevER = ref 1;

	countExpandRow : (double, double) -> int = \aw, widthsSum ->
		(if (^prevER == 1 && (aw - externalBorder * 2.) < widthsSum * 2. / 3. && aw != 0.)
			2
		else if (^prevER == 2 && (aw - externalBorder * 2.) > widthsSum)
			1
		else
			^prevER) |> (\f -> {prevER := f; f});

	fif(
		enabled,
		fselect2(screenW, minWidthsSum, FLift2(countExpandRow)),
		const(1)
	);
}

alignCellContent(parent : MFocusGroup, cellBorder : double, colstyle : [MColumnStyle], box : Tropic) -> (Tropic) -> Tropic {
	\content : Tropic -> {
		alignment =
			switch (commonAlignment2abs(extractCommonAlignment(colstyle), parent.rtl)) {
				RightAlign() : 1.;
				CenterAlign() : 0.5;
				default : 0.;
			}

		TCopySize(
			box,
			\tr ->
				TTweak(
					[TAlign(const(alignment), const(0.5))],
					TBorderDir(cellBorder / 2., 0., cellBorder / 2., 1.,
						TAvailable(content, TBorderDir(-cellBorder, 0., 0., -1., tr, parent.rtl)),
						parent.rtl
					),
					tr
				),
			false
		)
	}
}

addSeparator(manager : MaterialManager, parent : MFocusGroup, content : Tropic, above : bool) -> Tropic {
	TCopySize2(content, \sz, tr -> {
		separator = TAvailable(MSeparator2T(manager, parent, true), sz);
		if (above) TLines2Dir(separator, tr, parent.rtl)
		else TLines2Dir(tr, separator, parent.rtl)
	})
}

colsHead(state : MDTState, arr : [?]) -> [?] {
	take(arr, state.headCount)
}

colsTail(state : MDTState, arr : [?]) -> [?] {
	tailFrom(arr, state.headCount)
}

colsLastColumns(state : MDTState, arr : [?]) -> [?] {
	tailFrom(arr, length(arr) - state.headCount)
}

colsBeforeLastColumns(state : MDTState, arr : [?]) -> [?] {
	take(arr, length(arr) - state.headCount)
}

isWidthByContent(col : MColumnDynamic) -> bool {
	containsStruct(col.style, MWidthByContentLimited(const(-1.), const(-1.)))
}

toArrayIndex(arr : [int], pageNumber : int, rowsCount : int, sortedBy : [int]) -> [int] {
	filtermap(arr, \a -> {
		idx = pageNumber + a;
		if (idx >= 0 && idx < rowsCount)
			Some(if (sortedBy != []) sortedBy[idx] else idx)
		else
			None()
	})
}

fromArrayIndex(ar : [int], pg : Pair<int, int>, rowsCount : int, sortedBy : [int]) -> [int] {
	fold(ar, [], \acc, arInd -> {
		if (arInd < rowsCount) {
			a = (if (sortedBy != []) elemIndex(sortedBy, arInd, 0) else arInd) - pg.first;
			if (a >= 0 && a < pg.second)
				arrayPush(acc, a)
			else
				acc
		} else {
			acc
		}
	})
}

hideIfLittlePages(rowsCount : int, rowsPerPage : Transform<int>) -> (Tropic) -> Tropic {
	\t -> TShow(fselect(rowsPerPage, FLift(\rpp -> divCeil(rowsCount, rpp) > 2)), t)
}

divCeil(a : int, b : int) -> int {
	ceil(i2d(a) / i2d(b))
}

unitaryCell(content : Material) -> MCell {
	MCell(content, 1, 1);
}

updateTrigger(trigger : DynamicBehaviour<bool>, delay : int) -> void {
	timer(delay, \ -> {
		reverseBehaviour(trigger);
		updateTrigger(trigger, delay)
	})
}

MTableRowspanInfo(
	renderedRowspans : [DynamicBehaviour<[Pair<Transform<int>, int>]>],
	currentIndex : Transform<int>
);
