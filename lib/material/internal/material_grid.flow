import material/internal/material_dragdrop;
import material/internal/selectmarray;

export {
	MFlexibleGrid2T(manager : MaterialManager, parent : MFocusGroup, m : MFlexibleGrid, m2t : (Material, MFocusGroup) -> Tropic) -> Tropic;
	MReorderGrids2T(manager : MaterialManager, parent : MFocusGroup, m : MReorderGrids, m2t : (Material, MFocusGroup) -> Tropic) -> Tropic;
	MReorderGrid2T(manager : MaterialManager, parent : MFocusGroup, items0 : [MReorderItem],
		order : DynamicBehaviour<[int]>, style : [MReorderGridStyle], m2t : (Material, MFocusGroup) -> Tropic) -> Tropic;
	MDynamicGrid2T(manager : MaterialManager, parent : MFocusGroup, m : MDynamicGrid, m2t : (Material, MFocusGroup) -> Tropic) -> Tropic;
	MRecyclerGrid2T(manager : MaterialManager, parent : MFocusGroup, m : MRecyclerGrid, m2t : (Material, MFocusGroup) -> Tropic) -> Tropic;
}

FlexibleGridItem(m : Material, tr : DynamicBehaviour<Point>, wh : DynamicBehaviour<Maybe<WidthHeight>>);

MFlexibleGrid2T(manager : MaterialManager, parent : MFocusGroup, m : MFlexibleGrid, m2t : (Material, MFocusGroup) -> Tropic) -> Tropic {
	en = extractStruct(m.style, MEnabled(const(true))).enabled;
	enableAnimation = extractStruct(m.style, MAnimationEnabled(false)).enabled;
	cropView = extractStruct(m.style, MCropView(true)).crop;
	keepOrder = contains(m.style, MKeepOrder());
	verticalGrid = contains(m.style, MVertical());
	wrapNewRow = contains(m.style, MWrapNewRow());
	wrapNewColumn = contains(m.style, MWrapNewColumn());
	maxRows = extractStruct(m.style, MMaxRows(-1)).rows;
	lockWidth = extractStruct(m.style, MLockWidth(!verticalGrid)).lock;

	(\par -> TFlexibleGrid(
		fmap(m.items, \it -> m2t(it, par)),
		concatA([
			extractStructMany(m.style, CenterAlign()),
			extractStructMany(m.style, EndAlign()),
			if (enableAnimation) [TAnimation(manager.manager.deltaTimer)] else [],
			if (keepOrder) [TOrder(fmapi(m.items, \i, __ -> i))] else [],
			if (verticalGrid) [TVertical()] else [],
			if (wrapNewRow) [TWrapNewRow()] else [],
			if (wrapNewColumn) [TWrapNewColumn()] else [],
			if (maxRows > 0) [TMaxRows(maxRows)] else [],
			[
				TEnabled(en),
				TLockWidth(lockWidth),
				TCropView(cropView),
				TSetRTL(par.rtl)
			]
		])
	))
	|> (\f ->
		MComponentGroup2T(
			manager,
			parent,
			"MFlexibleGrid",
			[],
			f
		)
	)
}

MReorderGrid2T(manager : MaterialManager, parent : MFocusGroup, items : [MReorderItem],
	order : DynamicBehaviour<[int]>, style : [MReorderGridStyle], m2t : (Material, MFocusGroup) -> Tropic) -> Tropic {
	en = extractStruct(style, MEnabled(const(true))).enabled;
	enableAnimation = extractStruct(style, MAnimationEnabled(true)).enabled;
	cropView = extractStruct(style, MCropView(true)).crop;
	verticalGrid = contains(style, MVertical());
	wrapNewRow = contains(style, MWrapNewRow());
	wrapNewColumn = contains(style, MWrapNewColumn());
	maxRows = extractStruct(style, MMaxRows(-1)).rows;
	lockWidth = extractStruct(style, MLockWidth(!verticalGrid)).lock;
	borders = extractStruct(style, MBorders(0.)).borders;
	grabDelay = extractStructMany(style, MGrabDelay(0));
	customDraggingOrder = contains(style, MReorderCustomDraggingOrder());
	itemsLength = length(items) + if (customDraggingOrder) 2 else 1;
	draggingPlaceholder = map(extractStructMany(style, MReorderDropSpot(TEmpty())), \c -> MDraggingPlaceholder(c.spot));

	uniqueIds = ref makeTree();
	getUniqueIdByIndex = \index -> lookupTreeSet(uniqueIds, index, \__ -> makeTropicTag(manager));
	getIndexByUniqueId = \uniqueId -> either(findInOrder(^uniqueIds, \k, v -> if (v == uniqueId) Some(k) else None()), -1);
	onHover = generate(0, itemsLength, \__ -> make(-1));

	draggingItem = extractStruct(style, MDraggingItem(make(-1))).item;
	hoveringItem = extractStruct(style, MHoveringItem(make(-1))).item;

	orderIn = make(concat([itemsLength - 1], generate(0, itemsLength - 1, \i -> if (length(getValue(order)) > i) getValue(order)[i] else i)));
	edgeVisible = if (length(items) > 1) const(false) else if (length(items) > 0) fselect(onHover[0], FLift(\oh -> oh != -1)) else const(true);

	(\par -> TFlexibleGrid(
		mapi(
			items,
			\i, it -> {
				extractStruct(it.style, MReorderItemId(ref -1)).id := getUniqueIdByIndex(i);
				itEn = extractStruct(it.style, MEnabled(const(true))).enabled;
				isDragging : MDragging = extractStruct(it.style, MDragging(make(false)));

				MDragDrop2T(
					manager,
					par,
					MDragDrop(
						const(getUniqueIdByIndex(i)),
						it.content,
						concat3([MHoveringId(onHover[i]), MDraggingEnabled(fand(en, itEn)), isDragging], grabDelay, draggingPlaceholder)
					),
					m2t
				)
				|> (\f -> TBorder4(borders, f))
				|> (\f ->
					TConstruct(
						[
							makeSubscribe2(onHover[i], \hov0 -> {
								hov = getIndexByUniqueId(hov0);

								if (hov != -1 && hov != i && hov >= 0 && hov < itemsLength) {
									order0 = getValue(orderIn);
									newOrder = removeIndex(order0, elemIndex(order0, hov, 0));

									nextDistinct(
										orderIn,
										insertArray(
											newOrder,
											if (i == itemsLength - 1)
												1
											else
												elemIndex(if (customDraggingOrder) newOrder else order0, i, 0),
											hov
										)
									);
								}
							})
						],
						f
					)
				)
			}
		)
		|> (\f ->
			if (customDraggingOrder)
				arrayPush(
					f,
					TRectangle(interactiveRectangleStyle, TFillXH(1.))
					|> (\f2 ->
						MDragDrop2T(
							manager,
							par,
							MDragDrop(
								const(getUniqueIdByIndex(itemsLength - 2)),
								f2,
								concat([MHoveringId(onHover[itemsLength - 2]), MDraggingEnabled(const(false))], grabDelay)
							),
							m2t
						)
					)
					|> (\f2 -> TShow(fnot(edgeVisible), f2))
				)
			else
				f
		)
		|> (\f ->
			arrayPush(
				f,
				TRectangle(interactiveRectangleStyle, TFillXH(48.))
				|> (\f2 ->
					MDragDrop2T(
						manager,
						par,
						MDragDrop(
							const(getUniqueIdByIndex(itemsLength - 1)),
							f2,
							concat([MHoveringId(onHover[itemsLength - 1]), MDraggingEnabled(const(false))], grabDelay)
						),
						m2t
					)
				)
				|> (\f2 -> TShow(edgeVisible, f2))
			)
		)
		|> const,
		concat(extractStructMany(style, CenterAlign()), extractStructMany(style, EndAlign()))
		|> (\st -> if (enableAnimation) arrayPush(st, TAnimation(manager.manager.deltaTimer)) else st)
		|> (\st -> if (verticalGrid) arrayPush(st, TVertical()) else st)
		|> (\st -> if (wrapNewRow) arrayPush(st, TWrapNewRow()) else st)
		|> (\st -> if (wrapNewColumn) arrayPush(st, TWrapNewColumn()) else st)
		|> (\st -> if (maxRows > 0) arrayPush(st, TMaxRows(maxRows)) else st)
		|> (\st -> arrayPush(st, TOrder(orderIn)))
		|> (\st -> arrayPush(st, TEnabled(en)))
		|> (\st -> arrayPush(st, TLockWidth(lockWidth)))
		|> (\st -> arrayPush(st, TCropView(cropView)))
	)
	|> (\f ->
		TConstruct(
			[
				makeSubscribe(manager.manager.dragging, \dr0 -> {
					dr = getIndexByUniqueId(dr0);
					nextDistinct(
						draggingItem,
						if (dr >= 0 && dr < itemsLength - 1)
							dr
						else
							-1
					);
				}),
				makeSubscribe(manager.manager.hovering, \hov0 -> {

					hov = getIndexByUniqueId(hov0);
					nextDistinct(
						hoveringItem,
						if (hov >= 0 && hov < itemsLength && getValue(manager.manager.dragging) != -1)
							hov
						else
							-1
					);
				}),
				\ -> fBidirectionalLink(
					orderIn,
					order,
					\o ->
						nextDistinct(
							order,
							tail(o)
						),
					\o ->
						nextDistinct(
							orderIn,
							concat([itemsLength - 1], generate(0, itemsLength - 1, \i -> if (length(o) > i) o[i] else i))
						)
				)
			],
			f
		)
	))
	|> (\f ->
		MComponentGroup2T(
			manager,
			parent,
			"MReorderGrid",
			[IScriptBehaviour("order", order, ISInputValue([], "[int]", true))],
			f
		)
	)
}

MReorderGrids2T(manager : MaterialManager, parent : MFocusGroup, m : MReorderGrids, m2t : (Material, MFocusGroup) -> Tropic) -> Tropic {
	itemsLength : [int] = map(m.items, length);

	itemVisible : [[MReorderItemVisible]] =
		generate(0, length(m.items), \i -> {
			start = sum(subrange(itemsLength, 0, i));
			end = start + itemsLength[i];

			generate(0, sum(itemsLength), \j -> MReorderItemVisible(make(j >= start && j < end)))
		});

	reorderId : [[MReorderItemId]]=
		generate(0, length(m.items), \__ ->
			generate(0, sum(itemsLength), \__ -> MReorderItemId(ref -1))
		);

	items =
		mapi(m.items, \i, it -> {
			start = sum(subrange(itemsLength, 0, i));
			end = start + itemsLength[i];

			mapi(concatA(m.items), \j, it0 -> MReorderItem(it0.content, replaceStructMany(it0.style, [itemVisible[i][j], reorderId[i][j]])))
		});

	order = generate(0, length(m.items), \i -> make(
			if (length(getValue(m.order)) > i)
				getValue(m.order)[i]
			else {
				start = sum(subrange(itemsLength, 0, i));
				end = start + itemsLength[i];

				fold(generate(0, sum(itemsLength), \k -> k), Pair([], []), \acc, j ->
					if (j >= start && j < end)
						Pair(arrayPush(acc.first, j), acc.second)
					else
						Pair(acc.first, arrayPush(acc.second, j))
				)
				|> (\f -> concat(f.first, f.second))
			}
		));

	style = generate(0, length(m.items), \i -> if (length(m.style) > i) m.style[i] else []);

	dragging0 = generate(0, length(m.items), \i -> extractStruct(style[i], MDraggingItem(make(-1))).item);
	hovering0 = generate(0, length(m.items), \i -> extractStruct(style[i], MHoveringItem(make(-1))).item);

	draggingB = fmerge(dragging0);
	hoveringB = fmerge(hovering0);
	orderB = fmerge(order);

	mapi(items, \i, it ->
		MReorderGrid2T(
			manager,
			parent,
			it,
			order[i],
			replaceStruct(replaceStruct(style[i], MDraggingItem(dragging0[i])), MHoveringItem(hovering0[i])),
			m2t
		)
	)
	|> m.fn
	|> (\f -> m2t(f, parent))
	|> (\f ->
		TConstruct([
			make2Subscribe2(draggingB, hoveringB, \dr, hv -> {
				drId = foldi(dr, -1, \i, acc, dr0 -> if (dr0 != -1) i else acc);
				hvId = foldi(hv, -1, \i, acc, hv0 -> if (hv0 != -1 && i != drId) i else acc);

				if (drId != -1 && hvId != -1 && dr[drId] != -1 && hv[hvId] != -1) {
					next(manager.manager.dragging, ^(reorderId[hvId][dr[drId]].id));

					nextDistinct(itemVisible[drId][dr[drId]].visible, false);
					nextDistinct(itemVisible[hvId][dr[drId]].visible, true);

					newOrder = removeFirst(getValue(order[hvId]), dr[drId]);
					nextDistinct(order[hvId], insertArray(newOrder, elemIndex(newOrder, hv[hvId], 0), dr[drId]));
				}
			}),
			makeSubscribe(orderB, \or ->
				nextDistinct(m.order, mapi(or, \i, or0 -> foldi(or0, [], \j, acc, or1 ->
					if (i < length(itemsLength) && or1 < itemsLength[i] && getValue(itemVisible[i][or1].visible)) arrayPush(acc, or1) else acc)))
			),
			makeSubscribe2(m.order, \or ->
				iteri(or, \i, or0 -> {
					start = sum(subrange(itemsLength, 0, i));
					end = start + itemsLength[i];

					fold(generate(0, sum(itemsLength), \k -> k), [], \acc, j ->
						if (contains(or[i], j)) {
							nextDistinct(itemVisible[i][j].visible, true);
							acc
						} else {
							nextDistinct(itemVisible[i][j].visible, false);
							arrayPush(acc, j)
						}
					)
					|> (\f2 -> nextDistinct(order[i], concat(or0, f2)))
				})
			),
		], f)
	)
}

MDynamicGridContainer(id : DynamicBehaviour<int>, tr : DynamicBehaviour<Point>);

MDynamicGrid2T(manager : MaterialManager, parent : MFocusGroup, m : MDynamicGrid, m2t : (Material, MFocusGroup) -> Tropic) -> Tropic {
	items = ffuseinit(m.items, make([]));
	itemsLength = fselect(items.first, length |> FLift);

	boxSize = extractStruct(m.style, MBoxSize(make(zeroWH))).wh;
	contentSize = make(zeroWH);
	position = make(zeroPoint);
	containers = make([]);
	itemSize = extractStruct(m.style, MItemSize(fselect(contentSize, FLift(\cs -> WidthHeight(cs.width / 5., cs.width / 5.))))).wh;

	SelectMGroup2T(manager, parent, containers, \__, __, c, p -> {
		TransformTAcc2(\t2a -> {
				b1 =
					TTranslate(
						c.tr,
						TAvailable(
							TCenter(TMutable(fselect2(c.id, items.first, FLift2(\i, it -> m2t(if (existsIndex(it, i)) it[i] else TEmpty(), p))))),
							TSized(itemSize)
						)
					)
					|> t2a;

				TAcc(
					b1.form,
					TFormMetrics(
						zero,
						zero,
						zero
					),
					zero,
					zero,
					zero,
					zero,
					zero,
					zero,
					const(false),
					false,
					false,
					b1.disposers
				)
			}
		)
	})
	|> (\f -> TFixSize(f, TSized(contentSize)))
	|> (\f ->
		MScroll2T(
			manager,
			parent,
			MScroll(
				f,
				TFillXY(),
				[MScrollPosition(position), MScrollWidthHeight(make(zeroWH), boxSize)]
			),
			m2t
		)
	)
	|> (\f ->
		TConstruct(
			[
				items.second,
				make4Subscribe(boxSize, itemSize, position, itemsLength, \wh, sz, p, il -> {
					// items count in the row
					rowCount = max(floor(wh.width / sz.width), 1);
					// how much items on the screen
					itemCount = min((ceil(wh.height / sz.height) + 1) * rowCount, il);
					// max avaliable value of the first index
					topItemMax = (ceil(i2d(il - itemCount) / i2d(rowCount)) * rowCount) + if ((il - itemCount) % rowCount > 0) rowCount else 0;
					// index of the first shown item
					topItem = min(max(floor(p.y / sz.height) * rowCount, 0), topItemMax);

					if (itemCount > 0) {
						if (length(getValue(containers)) > itemCount) {
							nextDistinct(
								containers,
								subrange(getValue(containers), 0, itemCount)
							);
						} else if (length(getValue(containers)) < itemCount) {
							nextDistinct(
								containers,
								concat(
									getValue(containers),
									generate(length(getValue(containers)), itemCount, \i -> MDynamicGridContainer(make(-1), make(zeroPoint)))
								)
							);
						}

						topId = max(getValue(getValue(containers)[0].id), 0);

						iteri(getValue(containers), \i, c -> {
							idMod = (topId + i - topItem) % itemCount;
							id = (if (idMod >= 0) idMod else itemCount + idMod) + topItem;

							nextDistinct(c.id, id);
							nextDistinct(c.tr, Point(i2d(id % rowCount) * sz.width, i2d(id / rowCount) * sz.height));
						});
					} else {
						nextDistinct(containers, []);
					}

					nextDistinct(contentSize, WidthHeight(i2d(rowCount) * sz.width, dceil(i2d(il) / i2d(rowCount)) * sz.height));
				})
			],
			f
		)
	)
}

MRecyclerGridContainer(id : int, row : int, column : int, material : Material, size : DynamicBehaviour<WidthHeight>, position : DynamicBehaviour<Point>, mutable cached : Maybe<Tropic>);

boundsOverlap(bounds1 : Bounds, bounds2 : Bounds) -> bool {
	max(bounds1.minX, bounds1.maxX) >= min(bounds2.minX, bounds2.maxX) &&
		min(bounds1.minX, bounds1.maxX) <= max(bounds2.minX, bounds2.maxX) &&
		max(bounds1.minY, bounds1.maxY) >= min(bounds2.minY, bounds2.maxY) &&
		min(bounds1.minY, bounds1.maxY) <= max(bounds2.minY, bounds2.maxY)
}

pointwh2bounds(point : Point, wh : WidthHeight) -> Bounds {
	Bounds(point.x, point.y, point.x + wh.width, point.y + wh.height);
}

fpointwh2bounds(point : Transform<Point>, wh : Transform<WidthHeight>) -> Transform<Bounds> {
	fselect2(point, wh, pointwh2bounds |> FLift2);
}

bounds2w(bounds : Bounds) -> double {
	bounds.maxX - bounds.minX
}

bounds2h(bounds : Bounds) -> double {
	bounds.maxY - bounds.minY
}

insetBounds(bounds : Bounds, left : double, top : double, right : double, bottom : double) -> Bounds {
	Bounds(bounds.minX + left, bounds.minY + top, bounds.maxX - right, bounds.maxY - bottom);
}

MRecyclerGridId(row : int, column : int);

filterVisibleMRecyclerGridContainers(containers : [[MRecyclerGridContainer]], scrollBounds : Bounds) -> [MRecyclerGridId] {
	position = ref zeroPoint;
	filterDone = ref false;
	chunkSize = 1;

	concatA(
		generate(0, ceil(i2d(length(containers)) / i2d(chunkSize)), \i -> {
			if (^filterDone) {
				[]
			} else {
				containersChunk = subrange(containers, 0, chunkSize * (i + 1));

				r = filterVisibleMRecyclerGridContainers2(^position, containersChunk, chunkSize * i, 0, scrollBounds);

				if (length(r) > 0) {
					if (!exists(r, \rr -> rr.row == chunkSize * (i + 1) - 1)) {
						filterDone := true;
						r;
					} else {
						position := fold(r, zeroPoint, \acc, rr -> {
							c = containersChunk[rr.row][rr.column];
							Point(0.0, max(acc.y, getValue(c.position).y + getValue(c.size).height));
						});
						r;
					}
				} else {
					c = containersChunk[length(containersChunk) - 1][0];
					position := Point(0.0, getValue(c.position).y + getValue(c.size).height);
					r;
				}
			}
		})
	)
}

filterVisibleMRecyclerGridContainers2(position : Point, containers : [[MRecyclerGridContainer]], row : int, column : int, scrollBounds : Bounds) -> [MRecyclerGridId] {
	if (length(containers) > row && length(containers[row]) > column) {
		container = containers[row][column];
		size = getValue(container.size);

		next(container.position, position);
		containerBounds = pointwh2bounds(position, size);

		if (size.width == 0.0 && size.height == 0.0) {
			[MRecyclerGridId(row, column)]
		} else if (boundsOverlap(scrollBounds, containerBounds)) {
			if (column == 0) {
				r = filterVisibleMRecyclerGridContainers2(Point(position.x + size.width, position.y), containers, row, column + 1, scrollBounds);
				newPosition = fold(r, Point(0.0, containerBounds.maxY), \acc, rr -> {
					c = containers[rr.row][rr.column];
					Point(0.0, max(acc.y, getValue(c.position).y + getValue(c.size).height));
				});

				concat3(
					[MRecyclerGridId(row, column)],
					r,
					filterVisibleMRecyclerGridContainers2(newPosition, containers, row + 1, column, scrollBounds)
				);
			} else {
				concat(
					[MRecyclerGridId(row, column)],
					filterVisibleMRecyclerGridContainers2(Point(position.x + size.width, position.y), containers, row, column + 1, scrollBounds)
				);
			}
		} else if (position.x > scrollBounds.maxX || position.y > scrollBounds.maxY) {
			[];
		} else {
			if (column == 0) {
				r = filterVisibleMRecyclerGridContainers2(Point(position.x + size.width, position.y), containers, row, column + 1, scrollBounds);
				newPosition = fold(r, zeroPoint, \acc, rr -> {
					c = containers[rr.row][rr.column];
					Point(0.0, max(acc.y, getValue(c.position).y + getValue(c.size).height));
				});

				concat(
					r,
					filterVisibleMRecyclerGridContainers2(newPosition, containers, row + 1, column, scrollBounds)
				);
			} else {
				filterVisibleMRecyclerGridContainers2(Point(position.x + size.width, position.y), containers, row, column + 1, scrollBounds);
			}
		}
	} else {
		[];
	}
}

getMRecyclerGridContentSize(containers : [[MRecyclerGridContainer]]) -> WidthHeight {
	sz =
		foldWhile(containers, Pair(0, WidthHeight(0.0, 0.0)), \accHeight, cc -> {
			sz =
				foldWhile(cc, Pair(0, WidthHeight(0.0, 0.0)), \accWidth, c -> {
					size = getValue(c.size);

					if (size.width > 0.0 && size.height > 0.0) {
						Some(Pair(accWidth.first + 1, WidthHeight(accWidth.second.width + size.width, max(accWidth.second.height, size.height))));
					} else {
						None();
					}
				});

			size =
				WidthHeight(
					sz.second.width / i2d(max(sz.first, 1)) * i2d(length(cc)),
					sz.second.height
				);

			if (size.width > 0.0 && size.height > 0.0) {
				Some(Pair(accHeight.first + 1, WidthHeight(max(accHeight.second.width, size.width), accHeight.second.height + size.height)));
			} else {
				None();
			}
		});

	WidthHeight(
		sz.second.width,
		sz.second.height / i2d(max(sz.first, 1)) * i2d(length(containers))
	);
}

nextDynamicArray(a : DynamicBehaviour<[DynamicBehaviour<[?]>]>, n : [[?]]) -> void {
	av = getValue(a);

	iteri(n, \i, c -> {
		if (length(av) > i) {
			nextDistinct(av[i], c);
		}
	});

	if (length(av) > length(n)) {
		next(a, subrange(av, 0, length(n)))
	} else if (length(av) < length(n)) {
		next(a, concat(av, map(subrange(n, length(av), length(n)), \c -> make(c))))
	}
}

TCached(t : Tropic) -> Tropic {
	cachedB = ref None();
	uns = ref nop;
	instancesCounter = ref 0;

	TransformTAcc2(\t2a -> {
		instancesCounter := ^instancesCounter + 1;
		^uns();
		uns := nop;
		b = eitherFn(^cachedB, \cb -> cb, \ -> { b = t2a(t); cachedB := Some(b); b; });

		TAcc(b with
			disposers =
				[
					\ -> {
						instancesCounter := ^instancesCounter - 1;

						^uns();
						uns := interruptibleTimer(10000, \ -> // Dispose if clip is detroyed for more than 10s
							if (^instancesCounter == 0) {
								maybeApply(^cachedB, \cb -> {
									applyall(cb.disposers);
									cachedB := None();
								})
							}
						);
					}
				];
		)
	})
}

MRecyclerGrid2T(manager : MaterialManager, parent : MFocusGroup, m : MRecyclerGrid, m2t : (Material, MFocusGroup) -> Tropic) -> Tropic {
	sameSize = if (contains(m.style, MSameSize())) Some(makeWH()) else None();
	items =
		ffuseinit(
			fselect(m.items, FLift(\mi -> {
				itemId = ref -1;
				mapi(mi, \i, ii -> mapi(ii, \j, it -> {
					itemId := ^itemId + 1;
					MRecyclerGridContainer(^itemId, i, j, it, either(sameSize, makeWH()), makePoint(), None());
				}))
			})),
			make([])
		);
	scrollSize = extractStruct(m.style, MScrollWidthHeight(make(zeroWH), make(zeroWH)));
	contentSize = make(zeroWH);
	position = extractStruct(m.style, MScrollPosition(makePoint())).position;
	scrollBounds = fpointwh2bounds(position, scrollSize.box);

	containers : DynamicBehaviour<[MRecyclerGridId]> = make([]);
	availableWH = fselect2(scrollSize.box, m.items, FLift2(\cs, it -> WidthHeight(cs.width / i2d(max(either(maxA(map(it, length)), 0), 1)), cs.height / i2d(max(length(it), 1)))));
	needsUpdate = ref true;
	contentSizeNeedsUpdate = ref true;

	invalidateContentSize = \__ -> {
		needsUpdate := true;
		contentSizeNeedsUpdate := true;
	}

	SelectTGroup(containers, \index, __, id -> {
		c = getValue(items.first)[id.row][id.column];

		TConstruct(
			[
				if (getValue(c.size).width == 0.0 || getValue(c.size).height == 0.0)
					makeSubscribe(c.size, invalidateContentSize)
				else
					makeSubscribe2(c.size, invalidateContentSize)
			],
			TTranslate(
				c.position,
				TFixSize(
					TAvailable(
						eitherFn(
							c.cached,
							\tcached -> tcached,
							\ -> {
								tcached = MComponentGroup2T(manager, parent, "MRecyclerGridItem", [MFocusId(const(c.id))], \p -> m2t(c.material, p));
								c.cached ::= Some(tcached);
								tcached;
							}
						)
						|> (\f ->
							if (isNone(sameSize) || (c.row == 0 && c.column == 0))
								TInspect(
									[ISize(c.size)],
									f
								)
							else
								f
						),
						TSized(availableWH)
					),
					TEmpty()
				)
			)
		)
		|> (\f ->
			TGroup2(
				f,
				TShow(
					feq(index, 0),
					TTranslate(
						fpoint(fselect(scrollBounds, FLift(\sb -> sb.minX)), fselect(scrollBounds, FLift(\sb -> sb.minY))),
						TRectangle([], TSized(fselect(scrollBounds, FLift(\sb -> WidthHeight(bounds2w(sb), bounds2h(sb))))))
					)
				)
			)
		)
	})
	|> (\f ->
		MScroll2T(
			manager,
			parent,
			MScroll(
				TFixSize(f, TSized(contentSize)),
				TFillXY(),
				replaceStructMany(
					extractMScrollStyle(m.style),
					[MScrollPosition(position), scrollSize]
				)
			),
			m2t
		)
	)
	|> (\f ->
		TConstruct(
			[
				items.second,
				\ -> {
					manager.manager.deltaTimer.attach();
					manager.manager.deltaTimer.detach;
				},
				make2Subscribe(items.first, fthrottle(scrollBounds, 33), \__, __ -> needsUpdate := true),
				makeSubscribe(manager.manager.deltaTimer.timer, \__ -> {
					if (^needsUpdate) {
						it = getValue(items.first);
						if (^contentSizeNeedsUpdate) {
							contentSizeNeedsUpdate := false;
							next(contentSize, getMRecyclerGridContentSize(it));
						}
						sb = fgetValue(scrollBounds);

						needsUpdate := false;

						currentContainers = getValue(containers);
						newContainers = filterVisibleMRecyclerGridContainers(it, sb);
						nextDistinct(containers, newContainers);
					}
				})
			],
			f
		)
	)
}