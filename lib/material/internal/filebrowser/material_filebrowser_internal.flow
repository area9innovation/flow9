import material/internal/material_menu;
import material/internal/material_dialog_internal;
import material/internal/material_slider;
import material/internal/material_textinput;
import material/internal/material_splitter;
import material/internal/filebrowser/material_filebrowser_internal_view;
import tropic/tropic_ui;

export {
	// Initialization and start of filebrowser using custom style
	renderCustomMFileBrowser(manager : MaterialManager, parent : MFocusGroup, caption : string, ext : [string], buttons : [FileBrowserButtonsM], styles : [FbMStyle], m2t : (Material, MFocusGroup) -> Tropic) -> void;

	//checks if file name has no conflicts with existing names
	validateFileName(name : string, errorB : DynamicBehaviour<Maybe<Pair<string, bool>>>, existsNames : [string], ignoreName : string) -> void;

	//checks if partition name has no conflicts with existing names
	validatePartitionName(name : string, errorB : DynamicBehaviour<Maybe<Pair<string, bool>>>, existsNames : [string]) -> void;

	//filter (with dialog option) to exclude files with large size
	filterFilesByMaxSizeDialog(manager : MaterialManager, files : [native], maxSize : int, showDialog : bool, m2t : (Material, MFocusGroup) -> Tropic, onDone : ([native]) -> void) -> void;
}

SearchState(
	text : string,
	ext : [string],
	counterB : DynamicBehaviour<int>,
	breakSearchB : DynamicBehaviour<bool>,
	currentPathB : DynamicBehaviour<string>,
	selectedNameB : DynamicBehaviour<[string]>
);

//
makeSearchState(text : string, ext : [string], currentPathB : DynamicBehaviour<string>, selectedNameB : DynamicBehaviour<[string]>) -> SearchState {
	SearchState(
		text,
		ext,
		make(0),
		make(false),
		currentPathB,
		selectedNameB
	)
}

// calls the content loading and view creating for the current path
getLibraryUI(state : FilebrowserState<Pair<string, bool>>, ext : [string], filterFn : (string) -> bool, changesCallback : ([string], [string]) -> void, folderSelection : bool) -> Material {
	currentPath = getValue(state.currentPathB);
	viewB = make(MCenter(MLoading(_("Loading content, please wait..."))));

	getContentAPI(currentPath, ext, filterFn,
		\dirs : [string], files : [string] -> {
			previewsB = make([]);
			state.getPreviews(map(files, \f -> currentPath + f), \pairs -> nextDistinct(previewsB, pairs));
			next(viewB, prepareAndGetContentUI(
				state,
				map(dirs, \d -> Pair(d, true)),
				if (folderSelection) [] else map(files, \d -> Pair(d, false)),
				contains(dirs, ".."),
				previewsB
			));
			checkWhatIsChanged(currentPath, dirs, files, changesCallback)
		},
		\error -> {
			next(viewB, MCenter(MText("Error: " + error, [])));
		}
	);

	MMutable(viewB);
}

FSPathContent(
	basePath : string,
	dirs : [string],
	files : [string]
);

lastCheckResultR : ref Maybe<FSPathContent> = ref None();

checkWhatIsChanged(basePath : string, dirs : [string], files : [string], callback : ([string], [string]) -> void) -> void {
	maybeApply(
		^lastCheckResultR,
		\lcr -> {
			if (basePath == lcr.basePath) {
				added = concat(
					map(subtractA(dirs, lcr.dirs), \p -> basePath + p + "/"),
					map(subtractA(files, lcr.files), \p -> basePath + p)
				);
				removed = concat(
					map(subtractA(lcr.dirs, dirs), \p -> basePath + p + "/"),
					map(subtractA(lcr.files, files), \p -> basePath + p)
				);

				if (added != [] || removed != [])
					callback(added, removed);
			}
		}
	);

	lastCheckResultR := Some(FSPathContent(basePath, dirs, files));
}

// loading content of the selected folder using API
getContentAPI(path : string, ext : [string], filterFn : (string) -> bool, callback : (dirs : [string], files : [string]) -> void, onError : (string) -> void) {
	getFilesystemExtAPI().readDirectory(path, \dirs, files -> {
		nonEmpty = neq("");
		okExt = if (ext == []) \f -> true
			else \f -> exists(ext, \val -> endsWith(toLowerCase(f), val));

		callback(
			filter(dirs, \d -> nonEmpty(d) && filterFn(d)),
			filter(files, \f -> nonEmpty(f) && okExt(f) && filterFn(f))
		);

	}, onError);
}

// start the elements searching (which names contains searchText string) and updating the content view
getSearchResultUI(state : FilebrowserState<Pair<string, bool>>, searchText : string, ext : [string], filterFn : (string) -> bool) -> Material {
	stateSearch = makeSearchState(searchText |> toLowerCase, ext, state.currentPathB, state.selectedElementsB);
	next(stateSearch.counterB, getValue(stateSearch.counterB) + 1);
	currentPath = state.currentPathB |> getValue;

	itemB = make(MLoading(_("Searching, please wait...")));
	resD = ref [];
	resF = ref [];

	resultScreen = \-> {
		dirs = map(^resD, \d -> { r = split2Name_Path(d); FBContentPath(Pair(d, true), true, r.second, r.first); });
		files = map(^resF, \f -> { r = split2Name_Path(f); FBContentPath(Pair(f, false), false, r.second, r.first); });

		if (!getValue(stateSearch.breakSearchB)) {
			l = length(dirs) + length(files);
			next(
				itemB,
				if (l == 0)
					MCenter(MText(_("Files for criteria") + " \"" + searchText + "\" " + _("are not found."), []))
				else
					MLines2(
						MText(_("Elements found") + ": " + i2s(l), []),
						getContentUI(state, dirs, files, None(), make([]))
					)
			)
		}
	};

	// adding new founded elenents to the result array
	addResult = \dirs, files -> {
		if (!getValue(stateSearch.breakSearchB)) {
			resD := concat(^resD, dirs);
			resF := concat(^resF, files);
		}
	};

	// a bit of time to render MLoading()
	deferUntilRender(\-> {
		getContentRecursive(stateSearch, currentPath, filterFn, addResult, \error ->
			next(itemB, MCenter(MText(_("Error") + ": " + error, [])))
		);

		next(stateSearch.counterB, getValue(stateSearch.counterB) - 1);
	});

	MConstruct([
			\-> subscribe(state.searchTextB, \text -> nextDistinct(stateSearch.breakSearchB, text != searchText)),
			\-> subscribe(stateSearch.counterB, \count -> if (count == 0) resultScreen())
		],
		MMutable(itemB)
	);
}

// files and folders searching in the "currentPath", including subfolders
getContentRecursive(state : SearchState, currentPath : string, filterFn : (string) -> bool, onOK : ([string], [string]) -> void, onError : (string) -> void) -> void {
	//start search in the currentPath
	next(state.counterB, getValue(state.counterB) + 1);
	correctedCurPath = addSlash2pathEnd(currentPath);

	getContentAPI(currentPath, state.ext, filterFn, \dirs, files -> {
		if (!getValue(state.breakSearchB)) {
			resD = filter(dirs, \dir -> strContains(dir |> toLowerCase, state.text) && dir != "..");
			resF = filter(files, \file -> strContains(file |> toLowerCase, state.text));

			if (length(resD) + length(resF) > 0)
				onOK(
					map(resD, \d -> correctedCurPath + d + "/"),
					map(resF, \f -> correctedCurPath + f)
				);
		}

		// currentPath processing complete
		next(state.counterB, getValue(state.counterB) - 1);

		// go to in the sub folders
		if (!getValue(state.breakSearchB))
			iter(filter(dirs, \d -> d != ".."), \dir ->
				getContentRecursive(state, correctedCurPath + dir + "/", filterFn, onOK, onError)
			);
	}, onError
	);
}

//
getPathExistsNames(currentPath : string, ext : string, isFolder : bool, filterFn : (string) -> bool, callback : (names : [string]) -> void, onError : (string) -> void) -> void {
	callback2 = \dirs, files -> {
		callback(
			if (isFolder) dirs
			else map(files, \f -> f |> split2name_ext |> firstOfPair)
		)
	};

	getContentAPI(currentPath, [ext], filterFn, callback2, onError);
}

// file browser dialod view
renderCustomMFileBrowser(manager : MaterialManager, parent : MFocusGroup, caption : string, ext : [string], buttons : [FileBrowserButtonsM], styles2: [FbMStyle], m2t : (Material, MFocusGroup) -> Tropic) -> void {
	styles = if (extractStructMany(styles2, FbGetCurrentPathB(make(""))) != []) styles2
		else arrayPush(styles2, FbGetCurrentPathB(make("")));
	closeB = make(false);				// Close filebrowser dialog
	fileNameB = make("");				// "Filename" field value
	selectedElementPathB = make("");	// Path + name of the currently selected file or folder
	inSearchB = make(false);			// Show or hide searching panel
	inPathInputB = make(false);			// Show/hide path text input
	pathInputTextB = make("");			// Show/hide path text input
	showSliderB =  make(false);			// Show or hide view zoom slider
	zoomValueB = make(0.5);				// zoom silder position
	dialogContentB = make(TEmpty());
	closeMe = \-> next(closeB, true);
	normalExts = uniq(map(ext, toLowerCase));

	curPathOutAll = map(extractStructMany(styles, FbGetCurrentPathB(make(""))), \s -> s.path);
	curPathOutArrB = tail(curPathOutAll);
	currentPathInnerB = firstElement(curPathOutAll, make(""));

	doUpdateCallArr =  map(extractStructMany(styles, FbGetContentUpdateFn(\__ -> {})), \s -> s.fn);
	additionalText = extractStruct(styles, FbAdditionalText("")).text;
	pathProcessing = extractStruct(styles, FbPathProcessing(\p -> p)).func;
	folderSelection = contains(styles, FbFolderSelection());
	initSelection = extractStruct(styles, FbInitialSelection("")).sel;
	dropFnM = tryExtractStruct(styles, FbDropFileFn(\__ -> {}));
	onCancelFn = extractStruct(buttons, CancelExtFBB(nop)).func;
	hideBottomPanel = contains(styles, FbHideBottomPanel());
	allowPathInput = contains(styles, FbAllowPathInput());
	fileFilterFn = extractStruct(styles, FbFileFilter(\__ -> true)).fn;
	selectedFilesB = extractStruct(styles, FbSelectedNames(make([]))).filenamesB;
	callbackOnUpdateFns = map(extractStructMany(styles, FbWhatIsChanged(nop3)), \s -> s.fn);
	uploadMaxSizeM = minA(map(extractStructMany(styles, FbUploadMaxFileSize(0)), \s -> s.size));

	// Reset the last cache for the WhatIsChanged to start new `session`
	lastCheckResultR := None();

	//currentPathAccessRight = make(FileAccessRightOwner());
	curDirAccessRightB = make(makePathAccessRight());
	fsAPI : FilesystemExtAPI = getFilesystemExtAPI();

	itemProperties = [
		FBItemProperty(
			"Name",
			\i1, i2 -> genericCompare(i1.first, i2.first),
			firstOfPair
		),
		FBItemProperty(
			"Size",
			\i1, i2 -> {
				f1 = getItemFullname(FBContentPath(i1, i1.second, addSlash2pathEnd(getValue(currentPathInnerB)), i1.first));
				f2 = getItemFullname(FBContentPath(i2, i2.second, addSlash2pathEnd(getValue(currentPathInnerB)), i2.first));
				v1 = eitherMap(fsAPI.getExtraInfo(f1, "filesize"), \v1 -> getJsonIntValue(v1, 0), 0);
				v2 = eitherMap(fsAPI.getExtraInfo(f2, "filesize"), \v2 -> getJsonIntValue(v2, 0), 0);
				genericCompare(v1, v2);
			},
			\item -> eitherMap(
				fsAPI.getExtraInfo(getItemFullname(FBContentPath(item, item.second, addSlash2pathEnd(getValue(currentPathInnerB)), item.first)), "filedate"),
				\v -> getJsonIntValue(v, 0),
				0
			) |> i2s
		),
		FBItemProperty(
			"Created",
			\i1, i2 -> {
				f1 = getItemFullname(FBContentPath(i1, i1.second, addSlash2pathEnd(getValue(currentPathInnerB)), i1.first));
				f2 = getItemFullname(FBContentPath(i2, i2.second, addSlash2pathEnd(getValue(currentPathInnerB)), i2.first));
				v1 = eitherMap(fsAPI.getExtraInfo(f1, "filedate"), \v1 -> getJsonDoubleValue(v1, 0.0), 0.0);
				v2 = eitherMap(fsAPI.getExtraInfo(f2, "filedate"), \v2 -> getJsonDoubleValue(v2, 0.0), 0.0);
				genericCompare(v1, v2);
			},
			\item -> eitherMap(
				fsAPI.getExtraInfo(getItemFullname(FBContentPath(item, item.second, addSlash2pathEnd(getValue(currentPathInnerB)), item.first)), "filedate"),
				\v -> getJsonDoubleValue(v, 0.0),
				0.0
			) |> d2s
		)
	];

	state = makeFilebrowserState(firstOfPair, itemProperties, styles);

	filterFn = \name -> {
		fullName = getValue(state.currentPathB) + (if (name != "." && name != ".." && name != "/." && name != "/..")  name else "");
		fileFilterFn(fullName);
	}

	changesCallbackFn = \added, removed -> iter(callbackOnUpdateFns, \fn -> fn(added, removed, closeMe));

	updateFilesView = \-> next(dialogContentB, getLibraryUI(state, normalExts, filterFn, changesCallbackFn, folderSelection));
	iter(doUpdateCallArr, \fn -> fn(updateFilesView));

	fsAPI.isDirectory(
		state.startDir,
		\doesExists -> {
			if (!doesExists) println("WARNING: Filebrowser start path \"" + state.startDir + "\" does not exists");
			next(state.currentPathB, {
				defPath = if (state.startDir != "" && doesExists) state.startDir
				else strReplace(fsAPI.resolveRelativePath("."), "\\", "/");

				extractStruct(styles, FbCurrentPath(make(addSlash2pathEnd(defPath)))).path |> getValue;
			})
		}
	);

	next(state.onRightClickB, \itemCP, clickPos, onUpdate -> {
		filename = getItemFullname(either(itemCP, FBContentPath(Pair("", false), false, "", "")));
		fileAccessRight = fsAPI.getAccessRight(filename);
		curDirAccessRight = getValue(curDirAccessRightB);

		MDialogMenu(manager, parent, [
			MDialogMenuItem("content_copy", "copy", filename != "", \-> next(state.copiedElementsB, Pair(filename, false))),
			MDialogMenuItem("content_cut", "cut", filename != "" && fileAccessRight.arUpdate && fileAccessRight.arDelete, \-> next(state.copiedElementsB, Pair(filename, true))),
			MDialogMenuItem("create_new_folder", "create folder", isNone(itemCP) && !getValue(inSearchB) && curDirAccessRight.arCreate, \-> {
				closeDialogB = make(false);
				nameB = make(_("new folder"));
				errorText = None() |> make;
				saveEnable = make(true);

				showDialog = \existsNames -> {
					renderMDialog(manager, closeDialogB,
						[
							MDialogTitle(_("Create new folder")),
							MDialogUseFrame(),
							MDialogActions([
								MTextButton(_("CANCEL"), \-> next(closeDialogB, true), [], [MShortcut("esc")]),
								MTextButton(_("CREATE"), \-> {
									fsAPI.createFolder(
										getValue(state.currentPathB) + getValue(nameB) + "/",
										updateFilesView,
										println
									);
									next(closeDialogB, true);
								}, [], [MShortcut("enter"), MEnabled(saveEnable)])
							]),
							MDialogScroll(),
						],
						MConstruct(
							[
								makeSubscribe(nameB, \n -> validatePartitionName(n, errorText, existsNames)),
								makeSubscribe(errorText, \t -> nextDistinct(saveEnable, t |> isNone))
							],
							MCols([
								MFixSize(MText(_("Folder name") + ":", []), TFixed(75.0, 20.0)),
								TFixed(8.0, 0.0),
								MPad(0.0, -14.0,
									MTextInput(
										nameB,
										[MWidth(400.0), MMaxLines(1)],
										[MInputError(errorText, []), MEnabled(const(true))]
									)
								)
							])
						), m2t
					);
				}

				getPathExistsNames(getValue(state.currentPathB), "", true, \__ -> true, showDialog, println);
			}),
			MDialogMenuItem("delete", "delete", filename != "" && fileAccessRight.arDelete, \-> {
				closeDialogB = make(false);
				renderMDialog(manager, closeDialogB,
					[
						MDialogTitle(_("Are you sure?")),
						MDialogUseFrame(),
						MDialogActions([
							MTextButton(_("CANCEL"), \-> next(closeDialogB, true), [], [MShortcut("esc")]),
							MTextButton(_("DELETE"), \-> {
								fsAPI.deleteElement(filename, \-> {
										onUpdate(None());
										maybeApply(^lastCheckResultR,
											\lcr -> {
												if (getValue(state.currentPathB) == lcr.basePath) {
													pair = split2Name_Path(filename);
													if (contains(lcr.files, pair.first)) {
														lastCheckResultR := Some(FSPathContent(lcr.basePath, lcr.dirs, subtractA(lcr.files, [pair.first])));
													} else {
														lastCheckResultR := Some(FSPathContent(lcr.basePath, subtractA(lcr.dirs, [pair.first]), lcr.files));
													}
												}
											}
										);
										changesCallbackFn([], [filename]);
									}, println
								);
								next(closeDialogB, true);
							}, [], [MShortcut("enter")])
						]),
						MDialogScroll(),
					],
					TEmpty(), m2t
				);
			}),
			MDialogMenuItem("create", "rename", filename != "" && fileAccessRight.arUpdate, \-> {
				isFolder = endsWith(filename, "/");
				pair = split2Name_Path(filename);
				name_ext = pair.first |> split2name_ext;
				nameB = make(name_ext.first);
				errorText = None() |> make;
				saveEnable = make(true);
				closeDialogB = make(false);

				showDialog = \existsNames -> {
					renderMDialog(manager, closeDialogB,
						[
							MDialogTitle(_("Renaming")),
							MDialogUseFrame(),
							MDialogActions([
								MTextButton(_("CANCEL"), \-> next(closeDialogB, true), [], [MShortcut("esc")]),
								MTextButton(_("RENAME"), \-> {
									newNameFull = pair.second + getValue(nameB) + (if (name_ext.second != "") "." + name_ext.second else "") + (if (isFolder) "/" else "");
									
									// itemCP
									//fsAPI.renameElement(filename, getValue(nameB), \-> onUpdate(newNameFull), println);
									
									next(closeDialogB, true);
								}, [], [MShortcut("enter"), MEnabled(saveEnable)])
							]),
							MDialogScroll(),
						],
						MConstruct(
							[
								makeSubscribe(nameB, \n -> validateFileName(n, errorText, existsNames, "")),
								makeSubscribe(errorText, \t -> nextDistinct(saveEnable, t |> isNone))
							],
							MCols([
								MFixSize(MText(_("Filename") + ":", []), TFixed(75.0, 20.0)),
								TFixed(8.0, 0.0),
								MPad(0.0, -14.0,
									MTextInput(
										nameB,
										[MWidth(400.0), MMaxLines(1)],
										[MInputError(errorText, []), MEnabled(const(true))]
									)
								),
								if (isFolder) TEmpty()
								else MText("." + name_ext.second, [])
							])
						), m2t
					);
				}

				getPathExistsNames(getValue(state.currentPathB), if (isFolder) "" else "." + name_ext.second, isFolder, \__ -> true, showDialog, println);
			}),
			MDialogMenuItem(
				"content_paste",
				"paste",
				strlen(getValue(state.copiedElementsB).first) > 0 && isNone(itemCP) && !getValue(inSearchB) && curDirAccessRight.arCreate,
				\-> {
					copied = getValue(state.copiedElementsB);
					pair = copied.first |> split2Name_Path;
					copyTo = getValue(state.currentPathB);

					// do nothing if we cut/paste at the same place
					if (pair.second != copyTo || !copied.second) {
						fn = if (copied.second) fsAPI.moveElement
							else fsAPI.copyElement;

						fn(
							copied.first,
							copyTo,
							\-> {
								updateFilesView();
								if (copied.second) next(state.copiedElementsB, Pair("", false));
							},
							println
						);
					}
				}
			)
		], m2t, clickPos)
	});

	if (getValue(state.currentPathB) == "") {
		path = if (strlen(state.startDir) > 0) {
			state.startDir;
		} else {
			p = strReplace(fsAPI.resolveRelativePath("."), "\\", "/");
			p + (if (p != "") "/" else "");
		};

		next(state.currentPathB, path);
	};

	setSelected = nop;

	statusPanel = {
		iconsR = ref [];

		addInfoIcon = \iconName, tooltip -> {
			MIcon(iconName, [MIconSize(24.0)])
			|> (\m -> MTooltip(m, MText(tooltip, [MCaption()]), []))
			|> MCenter
			|> (\m -> MFixSize(m, TFixed(30.0, 30.0)))
			|> (\m -> MCols2(TFixed(8.0, 0.0), m))
			|> (\m -> refArrayPush(iconsR, m));
		};

		if (additionalText != "") addInfoIcon("info", additionalText);

		if (length(normalExts) > 0) addInfoIcon(
				"filter_list",
				_("Supported extensions") + ": \"" + strGlue(normalExts, ", ") + "\""
			);

		if (folderSelection) addInfoIcon("folder_shared", _("Directory selection mode installed"));

		maybeApply(uploadMaxSizeM, \size -> addInfoIcon("attach_file", formatString(_("The maximum file size to upload is %1 Mb"), [i2s(size / 1024 / 1024)])));

		switch (state.maybeMultiselectB) {
			Some(ctrlKeyB): {
				MSelect(ctrlKeyB, \ctrlKey -> MIcon("add_to_photos", [if (ctrlKey) MRed(500) else MBlack(), MIconSize(24.0)]))
					|> (\m -> MTooltip(m, MText(_("Multiselection mode: use \"ctrl\" key to select several elements"), [MCaption()]), []))
					|> MCenter
					|> (\m -> MFixSize(m, TFixed(30.0, 30.0)))
					|> (\m -> MCols2(TFixed(8.0, 0.0), m))
					|> (\m -> refArrayPush(iconsR, m));
			}
			None(): {};
		};

		MSelect(state.copiedElementsB, \copied -> {
			if (copied.first == "") TEmpty()
			else {
				{
					if (copied.second)
						MIcon("content_cut", [MIconSize(24.0)])
						|> (\m -> MTooltip(m, MText(_("Element to cut") + ": " + copied.first, [MCaption()]), []))
					else
						MIcon("content_copy", [MIconSize(24.0)])
						|> (\m -> MTooltip(m, MText(_("Element to copy") + ": " + copied.first, [MCaption()]), []));
				}
				|> MCenter
				|> (\m -> MFixSize(m, TFixed(30.0, 30.0)))
			}
		})
		|> (\m -> MCols2(TFixed(8.0, 0.0), m))
		|> (\m -> refArrayPush(iconsR, m));

		refArrayPush(iconsR, TFixed(8.0, 0.0));

		MSelect(state.copiedElementsB, \copied ->
			if (length(^iconsR) == 2 && copied.first == "") TEmpty()
			else
				MCols(concat([TFixed(8.0, 0.0)], ^iconsR))
		);
	};

	buttonFunc = \updateFilenameFn, fileExistsFn, noFileFn, folderFn -> {

		selectedElementsPath = getValue(state.selectedElementsB);
		currentPath = getValue(state.currentPathB);

		filesFuncRespectExistence = \filesNames -> checkIsFilesAll(fsAPI, filesNames, true, \resultFiles -> {
			if (resultFiles) {
				closeMe();
				fileExistsFn(filesNames);
			} else {
				noFileFn(filesNames)
			}
		});

		if (selectedElementsPath != []) {
			checkIsDirectoryAll(fsAPI, selectedElementsPath, true, \resultDir -> {
				if (resultDir) {
					// in case if single folder selected - we open it
					if (length(selectedElementsPath) == 1) next(state.currentPathB, selectedElementsPath[0]);
					if (folderSelection) folderFn(selectedElementsPath);
				} else if (!folderSelection) {
					filesFuncRespectExistence(map(selectedElementsPath, updateFilenameFn));
				}
			})
		// if nothing selected we return the current path (in folder selection mode)
		} else if (folderSelection) {
			folderFn([currentPath]);
		} else {
			filesFuncRespectExistence([currentPath + updateFilenameFn(getValue(fileNameB))]);
		}
	}

	initClickB = \action -> next(state.onClickB, \itemM -> {
		eitherFn(
			itemM,
			\item -> {
				fullName = getItemFullname(FBContentPath(item, item.second, addSlash2pathEnd(getValue(state.currentPathB)), item.first));
				if (item.second /*isFolder*/) {
					nextDistinct(state.currentPathB, fullName);
				} else if (isNone(state.maybeMultiselectB)) {
					nextDistinct(state.selectedElementsB, [fullName]);
					action();
				}
			},
			\-> {
				correctCurPath = addSlash2pathEnd(getValue(state.currentPathB));
				curPath = if (strlen(correctCurPath) > 0) strLeft(correctCurPath, strlen(correctCurPath) - 1) else correctCurPath;
				lastSlashIdx = strLastIndexOf(curPath, "/");
				prevPath = if (lastSlashIdx > 0) strLeft(curPath, lastSlashIdx) else "";
				name = if (endsWith(prevPath, ":")) prevPath + "/" else prevPath + "/";

				next(state.currentPathB, name);
			}
		)
	});

	dialogActions = map(buttons, \button -> {
		switch(button) {
			OpenExtFBB(func): {
				action = \-> buttonFunc(
					\name -> name,
					\filesNames -> func(map(filesNames, \f -> FbObject(pathProcessing(f), fsAPI.convert2realPath(f)))),
					\filesNames -> println("Files or folders '" + strGlue(filesNames, "', '") + "' doesn't exists."),
					\foldersPaths -> { closeMe(); func(map(foldersPaths, \f -> FbObject(pathProcessing(f), fsAPI.convert2realPath(f)))); }
				);

				initClickB(action);

				enabledB = make(false);
				MConstruct(
					[\-> subscribe(state.selectedElementsB, \sel -> {
						if (folderSelection) {
							checkIsDirectoryAll(fsAPI, sel, true, \resultDir -> nextDistinct(enabledB, (sel == [] || resultDir)));
						} else if (sel == []) {
							nextDistinct(enabledB, false);
						} else {
							checkIsFilesAll(fsAPI, sel, true, \resultFiles -> nextDistinct(enabledB, resultFiles));
						}
					})],
					MTextButton(_("OPEN") + if (folderSelection) (" " + _("FOLDER")) else "", action, [], [MEnabled(enabledB), MShortcut("Enter")])
				)
			};
			SaveExtFBB(func): {
				action = \-> buttonFunc(
					\name -> if (strContains(name, ".")) name
						else if (length(normalExts) > 0) name + normalExts[0]
						else name,
					\filesNames -> {
						withConfirmation2(
							_("File with specified name has already exist.\nDo you want to rewrite it?"),
							\-> func(map(filesNames, \f -> FbObject(pathProcessing(f), fsAPI.convert2realPath(f)))),
							onCancelFn
						)
					},
					\filesNames -> {
						closeMe();
						func(
							if (filesNames == []) [FbObject(pathProcessing(getValue(state.currentPathB) + getValue(fileNameB) + if (folderSelection) "/" else ""), "")]
							else map(filesNames, \f -> FbObject(pathProcessing(f), fsAPI.convert2realPath(f)))
						);
					},
					\foldersPaths -> { closeMe(); func(map(foldersPaths, \f -> FbObject(pathProcessing(f), fsAPI.convert2realPath(f)))); }
				);

				initClickB(action);

				enabledB = make(false);
				MConstruct(
					[\-> subscribe(fileNameB, \fileName -> {
						sel = getValue(state.selectedElementsB);
						if (folderSelection) {
							checkIsDirectoryAll(fsAPI, sel, true, \resultDir -> nextDistinct(enabledB, (sel == [] || resultDir)));
						} else {
							nextDistinct(enabledB, fileName != "");
						}
					})],
					MTextButton(_("SAVE"), action, [], [MEnabled(enabledB), MShortcut("Enter")])
				)
			};
			CancelExtFBB(func): {
				MTextButton(_("CANCEL"), \-> { closeMe(); func(); }, [], [MShortcut("Esc")])
			};
			CustomExtFBB(cap, func): {
				MTextButton(cap |> toUpperCase, \-> func(getValue(state.currentPathB), getValue(state.selectedElementsB)), [], [])
			};
			CustomWithUpdateFBB(cap, func): {
				MTextButton(cap |> toUpperCase, \->
					func(getValue(state.currentPathB), getValue(state.selectedElementsB), updateFilesView),
					[],
					[]
				)
			};
		}
	});

	checkForClicable = \path -> {
		if (state.limitAccess && startsWith(state.startDir, path)) false
		else true;
	}

	makePathView = \curPath -> {
		nextDistinct(state.searchTextB, "");
		nextDistinct(inSearchB, false);
		nextDistinct(inPathInputB, false);
		nextDistinct(pathInputTextB, "");

		pathSplitted = strSplit(curPath, "/");
		MCols2(
			MScroll(
				MCols([
					TFixed(8.0, 0.0),
					MCenterY(MText(_("Files in") + ": ", [])),
					MSelect(inPathInputB, \inPathInput ->
						if (inPathInput) {
							nextDistinct(pathInputTextB, getValue(state.currentPathB));
							MCols([
								TFixed(5.0, 0.0),
								MTextInput(pathInputTextB, [MInputBorders(8., 8., 8., 8.), MCustomTextStyle([MButtonFont()]), MShowUnderline(false)], [MEnabled(const(true)), TTextInputFocus(inPathInputB)])
							])
						} else {
							newPath = strReplace(getValue(pathInputTextB), "\\", "/");
							if (fileExists(newPath)) {
								nextDistinct(state.currentPathB, newPath);
							}
							MCols(
								interleave(
									mapi(pathSplitted, \i, name -> {
										path = strGlue(take(pathSplitted, i + 1), "/") + "/";
										if (name == "") TEmpty()
										else MTextButton(name, \-> { nextDistinct(state.searchTextB, ""); nextDistinct(state.currentPathB, path) }, [MBlack()], [MEnabled(const(checkForClicable(path)))])
									}),
									MCenterY(MText("/", [MCustomFont(20.0, "Roboto", 0.5)]))
								)
							)
						}
					),
					MSelect(state.searchTextB, \searchText ->
						if (strlen(searchText) > 0)
							MCols2(
								MCenterY(MText("  " + _("Search result") + "  ", [MBodyBold()])),
								MCenterY(MText("/", [MCustomFont(20.0, "Roboto", 0.5)]))
							)
						else
							TEmpty()
					),
					TFixed(8.0, 0.0),
					MClickable(TFillXH(36.0), \-> {
						if (!getValue(inPathInputB) && allowPathInput) nextDistinct(inPathInputB, true);
					}),
				]),
				TFillXH(36.0),
				[TScrollbars(minimalScrollBarLight, minimalScrollBarLight), TScrollDontHandle()]
			),
			MSelect(inPathInputB, \inPathInput ->
				if (inPathInput || !allowPathInput)
					TEmpty()
				else
					MIconButton("edit", \-> { nextDistinct(inPathInputB, true); }, [MIconButtonBorder(1.0), MIconSize(34.0)], [])
			)
		)
		|> (\m -> MFrame(1.0, 1.0, [Stroke(gray)], m));
	}

	menuIconB = make(MIcon("view_module", [MIconSize(32.0)]));
	updateViewStyle = \icon -> {
		nextDistinct(menuIconB, MIcon(icon, [MIconSize(32.0)]));
		if (icon == "view_module") {
			nextDistinct(state.contentViewIconsB, true);
		} else if (icon == "format_list_bulleted") {
			nextDistinct(state.contentViewIconsB, false);
		}
	};

	topActions =
		filtermap(styles, \s ->
			switch(s) {
				FbTopPanelCustomItem(getItem, requiredAccessRight): {
					enabled = fselect(curDirAccessRightB, FLift(\curDirAR : PathAccessRight -> {
						{if (requiredAccessRight.arCreate) curDirAR.arCreate else true} &&
						{if (requiredAccessRight.arRead  ) curDirAR.arRead   else true} &&
						{if (requiredAccessRight.arUpdate) curDirAR.arUpdate else true} &&
						{if (requiredAccessRight.arDelete) curDirAR.arDelete else true}
					}));
					Some(getItem(closeMe, enabled));
				}
				default: None()
			}
		)
		|> (\customItems ->
			if (customItems == []) TEmpty()
			else {
				MCols(arrayPush(
					interleave(customItems, TFixed(8.0, 0.0)),
					TFixed(8.0, 0.0)
				))
			}
		);

	addSortMenuItem = \itemProperty -> {
		sortIconB = fselect(state.contentSortTypeB, FLift(\sortState : FBSortPropertyState ->
			if (sortState.itemProperty.name != itemProperty.name) TEmpty()
			else if (sortState.asc) MIcon("arrow_downward", [])
			else MIcon("arrow_upward", [])
		));

		onSortClick = \-> {
			sortState = getValue(state.contentSortTypeB);
			if (sortState.itemProperty.name != itemProperty.name) {
				nextDistinct(state.contentSortTypeB, FBSortPropertyState(itemProperty, true));
			} else {
				nextDistinct(state.contentSortTypeB, FBSortPropertyState(itemProperty, !sortState.asc));
			}
		}

		MMenuSingleLine(
			"Sort by " + itemProperty.name,
			[
				MPrimaryAction(MIcon("sort_by_alpha", [])),
				MSecondaryAction(MMutable(sortIconB)),
				MOnClick(onSortClick)
			]
		)
	}

	topNavPanel = MCols([
		MSelect(state.currentPathB, makePathView),
		TFixed(8.0, 0.0),
		topActions,
		MSelect(inSearchB, \inSearch ->
			if (inSearch) {
				MFixSize(
					MCols([
						TFixed(5.0, 0.0),
						MPad(0.0, -6.0, MTextInput(state.searchTextB, [], [MEnabled(const(true))])),
						MIconButton("close", \-> {nextDistinct(state.searchTextB, ""); nextDistinct(inSearchB, false);}, [MIconButtonBorder(1.0), MIconSize(34.0), MOrange(500)], [])
					]),
					TFixed(200.0, 36.0)
				)
				|> (\m -> MFrame(1.0, 1.0, [Stroke(newOrangeColor)], m))
			} else {
				MIconButton("search", \-> { nextDistinct(inSearchB, true); }, [MIconButtonBorder(1.0), MIconSize(34.0)], [])
			}
		),
		TFixed(8.0, 0.0),
		MShow(state.contentViewIconsB, MSelect(
			showSliderB,
			\showSlider -> MIconButton(
				"linear_scale",
				\-> reverseBehaviour(showSliderB),
				[MIconButtonBorder(1.0), MIconSize(34.0), if (showSlider) MOrange(500) else MBlack()],
				[]
			)
		)),
		TFixed(8.0, 0.0),
		MFixSize(
			MMenu(
				MCenter(MMutable(menuIconB)),
				[
					MMenuSingleLine(_("Icons view"), [MPrimaryAction(MIcon("view_module", [])), MOnClick(\-> updateViewStyle("view_module"))]),
					MMenuSingleLine(_("List view"), [MPrimaryAction(MIcon("format_list_bulleted", [])), MOnClick(\-> updateViewStyle("format_list_bulleted"))])
				],
				[MOpenOnClick(), MBelowButton()]
			),
			TFixed(36.0, 36.0)
		),
		TFixed(8.0, 0.0),
		MFixSize(
			MMenu(
				MCenter(MIcon("sort_by_alpha", [])),
				map(state.itemProperties, addSortMenuItem),
				[MOpenOnClick(), MBelowButton()]
			),
			TFixed(36.0, 36.0)
		)
	]);

	updateZoom = \toDown -> {
		newZoom = getValue(zoomValueB) + 0.1 * (if (toDown) -1.0 else 1.0);
		if (newZoom >= 0.0 && newZoom <= 1.0)
			next(zoomValueB, newZoom);
	};

	zoomSlider = MShow(
		showSliderB,
		MLines2(
			TFixed(0.0, 8.0),
			MCols([
				MIconButton("zoom_out", \-> updateZoom(true), [MIconSize(19.0)], [MEnabled(const(true))]),
				MCenterYIn(MSlider(zoomValueB, [MOrange(500), MSliderRange(0.0, 1.0), MSliderStep(0.1)]), TFillXH(36.0)),
				MIconButton("zoom_in", \-> updateZoom(false), [MIconSize(19.0)], [MEnabled(const(true))]),
			])
		)
	);

	dialogContent = MDispose(concat(
		map(getStateSubscribers(state, fileNameB, selectedFilesB, \cp -> {
				iter(curPathOutArrB, \pB -> nextDistinct(pB, cp));
				// Updating of the access rights for the current path
				nextDistinct(curDirAccessRightB, fsAPI.getAccessRight(cp));
			}),
			\fn -> fn()
		),
		[	
			// Creating file full name (including full path)
			subscribe(fileNameB, \fileName -> {
				sel = getValue(state.selectedElementsB);
				if (isNone(state.maybeMultiselectB) && sel != [] && (sel[0] |> split2Name_Path |> firstOfPair) != fileName || sel == []) {
					if (toUpperCase(strLeft(fileName, 4)) == "DB:/") {
						nextDistinct(state.selectedElementsB, [toUpperCase(strLeft(fileName, 4)) + strRight(fileName, 4)]);
					} else {
						nextDistinct(state.selectedElementsB, [getValue(state.currentPathB) + fileName]);
					}
				}
			}),
			subscribe(zoomValueB, \zoomValue -> nextDistinct(state.iconSizeB, 20.0 + zoomValue * 100.0)),
			// Update content if the current path changed
			subscribe(state.currentPathB, \__ -> updateFilesView()),
			// Update content if the "searchText" changed. Updating starts if the "searchText" has not changed during one sec.
			subscribe2(state.searchTextB, \searchText -> {
				// clear selection on search start
				nextDistinct(state.selectedElementsB, []);

				if (strlen(searchText) == 0) updateFilesView()
				else timer(1000, \-> {
					if (searchText == getValue(state.searchTextB))
						next(dialogContentB, getSearchResultUI(state, searchText, normalExts, filterFn))
				})
			}),
			// If smb wants to change a current folder from out of the MFileBrowser (Not tested)
			/*subscribe(curPathOutArrB, \cp -> {
				next(state.selectedElementsB, []);
				nextDistinct(state.currentPathB, cp);
				// Updating of the access rights for the current path
				next(curDirAccessRightB, fsAPI.getAccessRight(cp));
			}),*/
		]),
		MMutable(dialogContentB)
	)
	|> (\m -> MFrame(1.0, 1.0, [Stroke(gray)], m));

	dialogFileName = MFixSize(
		MCols([
			TFixed(5.0, 0.0),
			MPad(0.0, -5.0, MTextInput(fileNameB, [MLabel(if (folderSelection) _("folder name") else _("Filename")), MCustomTextStyle([MBody()])], [])),
			TFixed(5.0, 0.0)
		]),
		TFillXH(30.0)
	);

	renderMDialog2(
		manager,
		closeB,
		[
			MDialogTitle(caption),
			MDialogActions(dialogActions),
			MDialogUseFrame(),
			MDialogResizable(),
			MFocusOnPrevious(true)
		],
		MLines([
			TFixed(0.0, 1.0),
			topNavPanel,
			zoomSlider,
			TFixed(0.0, 8.0),
			eitherMap(dropFnM,
				\dropFn -> {
					dropFn2 = eitherMap(
						uploadMaxSizeM,
						\size -> {
							\files -> {
								filterFilesByMaxSizeDialog(manager, files, size, true, m2t, \files2 -> {
									if (files2 != []) dropFn.fn(files2);
								});
							};
						},
						dropFn.fn
					);
					// we accept only list of extensions without "*." and "." prefixes
					eRegFilter = if (normalExts == []) "" else strGlue(map(normalExts, \e -> strReplace(strReplace(e, "*.", ""), ".", "")), "|");
					MInteractive([TFileDrop(-1, eRegFilter, dropFn2)], dialogContent);
				},
				dialogContent
			),
			if (!hideBottomPanel) {
				MLines2(TFixed(0.0, 8.0), MCols2(dialogFileName, statusPanel))
			} else {
				MEmpty()
			},
		]),
		m2t,
		\t ->
			trender(
				TAvailable(
					TTranslate(fif(manager.iscript.showPanel, const(Point(0.0, 48.0)), const(zeroPoint)), t),
					TIf(manager.iscript.showPanel, TSized(manager.iscript.available), TFillXY())
				)
				|> (\f ->
					materialLogFn(
						\ ->
							TFixSize(
								TLines2(
									TFixed(36., 36.),
									f
								),
								TFillXY()
							),
						MaterialWarning(),
						\ -> f
					)
				),
				manager.manager.renderStyle
			)
	);

	next(fileNameB, initSelection);
}

//////////
// Utils
//////////

filterFilesByMaxSizeDialog(manager : MaterialManager, files : [native], maxSize : int, showDialog : bool, m2t : (Material, MFocusGroup) -> Tropic, onDone : ([native]) -> void) -> void {
	getTitle = \isMany -> if (isMany) _("Files too large") else _("File too large");
	getText = \isMany -> if (isMany) _("Sorry, your files is too large for the system.")
		else _("Sorry, your file is too large for the system.");

	files2 = filter(files, \file -> fileSizeClient(file) <= i2d(maxSize));
	showErrorDialog = \isMany, title, text -> {
		if (showDialog) {
			closeB = make(false);
			renderMDialog2(
				manager,
				closeB,
				[
					MDialogTitle(title),
					MDialogUseFrame(),
					MDialogActions([MTextButton("OK", \-> { onDone(files2); next(closeB, true); }, [], [MShortcut("enter")])]),
					MDialogScroll()
				],
				MLines(interleave(map([
						getText(isMany),
						formatString(_("Try to compress it or break it up into smaller pieces (max size is %1 Mb)."), [i2s(maxSize / 1024 / 1024)]),
						"",
						text
					],
					\t -> MText(t, [MSubheading()])), TFixed(8.0, 8.0)
				)),
				m2t,
				\t -> {
					trender(
						TAvailable(
							TTranslate(fif(manager.iscript.showPanel, const(Point(0.0, 48.0)), const(zeroPoint)), t),
							TIf(manager.iscript.showPanel, TSized(manager.iscript.available), TFillXY())
						)
						|> (\f ->
							materialLogFn(
								\ ->
									TFixSize(
										TLines2(
											TFixed(36., 36.),
											f
										),
										TFillXY()
									),
								MaterialWarning(),
								\ -> f
							)
						),
						manager.manager.renderStyle
					)
				}
			);
		} else {
			onDone(files2);
		}
	}

	if (files2 == []) {
		isMany = length(files) > 1;
		title = getTitle(isMany);
		text = if (isMany) formatString(_("Nothing were uploaded from %1 files."), [i2s(length(files))])
			else formatString(_("The file was not uploaded."), [i2s(length(files))]);
		showErrorDialog(isMany, title, text);
	} else if (length(files) != length(files2)) {
		countOrig = length(files);
		countFiltered = length(files2);
		countDiff = countOrig - countFiltered;

		title = getTitle(countDiff > 1);
		text = if (countOrig > 1) {
			if (countFiltered > 1) formatString(_("Only %1 of %2 files were uploaded."), [i2s(countFiltered), i2s(countOrig)])
			else formatString(_("Only 1 of %1 files was uploaded."), [i2s(countOrig)]);
		} else {
			// It should be never reached
			_("... and something went wrong. Nothing were uploaded.");
		};
		showErrorDialog(countDiff > 1, title, text);
	} else {
		onDone(files2);
	}
}

checkIsDirectoryAll(api : FilesystemExtAPI, paths : [string], lastResult : bool, callback : (bool) -> void) -> void {
	if (paths == [] || !lastResult) {
		callback(lastResult)
	} else {
		api.isDirectory(paths[0], \resultDir -> checkIsDirectoryAll(api, tail(paths), lastResult && resultDir, callback))
	}
}

checkIsFilesAll(api : FilesystemExtAPI, paths : [string], lastResult : bool, callback : (bool) -> void) -> void {
	if (paths == [] || !lastResult) {
		callback(lastResult)
	} else {
		api.fileExists(paths[0], \resultDir -> checkIsFilesAll(api, tail(paths), lastResult && resultDir, callback))
	}
}

split2name_ext(filename : string) -> Pair<string, string> {
	idx = strLastIndexOf(filename, ".");

	if (idx == -1) Pair(filename, "")
	else Pair(strLeft(filename, idx), strRight(filename, idx + 1));
}

sortPairByFirst(arr : [Pair<?, ?>]) -> [Pair<?, ?>] {
	sortCustom(arr, firstOfPair, true);
}

MDialogMenuItem : (icon : string, tooltip : string, enabled : bool, onClick : () -> void);

mDialogMenuReopenInfoR : ref [() -> void] = ref [];

MDialogMenu(manager : MaterialManager, parent : MFocusGroup, items : [MDialogMenuItem], m2t : (Material, MFocusGroup) -> Tropic, clickPos : Point) -> void {
	applyall(^mDialogMenuReopenInfoR);

	menuSize = 250.;
	itemSize = 70.;
	pressedB = make(false);
	inside1B = make(false);
	insideArrB = generate(1, length(items), \__ -> make(false));

	count = (if (length(items) > 6) 6 else (length(items))) |> i2d;
	if (count > 0.0) {
		step = 360.0 / count;

		easing = makeEasing(0.6, easingStandartCurve, managerTimer(manager), nop);
		closeDialog = \-> applyall(^mDialogMenuReopenInfoR);

		MGroup2(
			MInteractive(
				[TMouseDown(pressedB)],
				TRectangle(interactiveRectangleStyle, TFillXY())
				|> (\m -> MConstruct(
					[make2Subscribe2(pressedB, fOr(inside1B, fmaxA(insideArrB, false)), \p, i -> if (!i && p) closeDialog())],
					m
				))
			),
			MIcon("touch_app", [MIconSize(40.0), MCircleBackground(MGrey(500), menuSize)])
			|> (\m -> MInteractive([TMouseInside(inside1B, true)], m))
			|> (\m -> MGroup(
				concat(
					[m],
					mapi(items, \i, item : MDialogMenuItem -> {
						radius = (menuSize - itemSize) / 2.;
						point = polarDegree2cartesian(radius - 10., i2d(i) * step - 90.0);
						MIconButton(
							item.icon,
							\-> { item.onClick(); closeDialog(); },
							[MIconSize(25.), MCircleBackground(if (item.enabled) MOrange(300) else MGrey(300), itemSize)],
							[MEnabled(const(item.enabled)), THovering(insideArrB[i])]
						)
						|> (\mi -> if (strlen(item.tooltip) > 0) MTooltip(mi, MText(item.tooltip, []), []) else mi)
						|> (\mi -> MPad(point.x + radius, point.y + radius, mi))
					})
				)
			))
			|> (\m -> MScale(ffactor2(easing.percent), m))
			|> (\m -> if (clickPos == zeroPoint) MCenter(m) else MPad(clickPos.x, clickPos.y, m))
		)
		|> MPushZorder
		|> (\m -> m2t(m, parent))
		|> (\t -> mDialogMenuReopenInfoR := [trender(t, manager.manager.renderStyle)]);

		easing.start();
	}
}

polarDegree2cartesian(radius : double, angleDegree : double) -> Point {
	x = radius * cos(angleDegree * PI / 180.);
	y = radius * sin(angleDegree * PI / 180.);

	Point(x, y);
}

validateFileName(name : string, errorB : DynamicBehaviour<Maybe<Pair<string, bool>>>, existsNames : [string], ignoreName : string) -> void {
	nextDistinct(errorB,
		if (contains(map(existsNames, toLowerCase), toLowerCase(name)) && toLowerCase(name) != toLowerCase(ignoreName)) Pair(_("Such name exists"), false) |> Some
		else None()
	)
}

validatePartitionName(name : string, errorB : DynamicBehaviour<Maybe<Pair<string, bool>>>, existsNames : [string]) -> void {
	nextDistinct(errorB,
		if (strlen(name) == 0) Pair(_("Specify the name"), false) |> Some
		else if (contains(map(existsNames, toLowerCase), toLowerCase(name))) Pair(_("Such name exists"), false) |> Some
		else None()
	)
}
