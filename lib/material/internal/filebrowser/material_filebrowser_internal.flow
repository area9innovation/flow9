import material/internal/material_menu;
import material/internal/material_dialog_internal;
import material/internal/material_slider;
import material/internal/material_textinput;
import material/internal/material_splitter;
import material/internal/filebrowser/material_filebrowser_internal_view;
import formats/base64;
import formats/mime/mime_types;
import tropic/tropic_ui;

export {
	// Initialization and start of filebrowser using custom style
	renderCustomMFileBrowser(manager : MaterialManager, parent : MFocusGroup, caption : string, ext : [string], buttons : [FileBrowserButtonsM], styles : [FbMStyle], m2t : (Material, MFocusGroup) -> Tropic) -> void;

	// Checks if file name has no conflicts with existing names
	validateFileName(name : string, errorB : DynamicBehaviour<Maybe<Pair<string, bool>>>, existsNames : [string], ignoreName : string) -> void;

	// Checks if partition name has no conflicts with existing names
	validatePartitionName(name : string, errorB : DynamicBehaviour<Maybe<Pair<string, bool>>>, existsNames : [string]) -> void;

	// Filter (with dialog option) to exclude files with large size (realisation for native files)
	filterUploadedFilesForRestrictionsNative(
		files : [native],
		managerM : Maybe<MaterialManager>,
		m2t : (Material, MFocusGroup) -> Tropic,
		onDone : (/*toUpload*/ [native], /*toReduce*/ [native], /*largeSize*/ [native]) -> void,
		style : [FbFilterUploadDialog]
	) -> void;

	// The same like above but for the string content
	filterUploadedFilesForRestrictionsBase64(
		files : [FbSourceBase64],
		managerM : Maybe<MaterialManager>,
		m2t : (Material, MFocusGroup) -> Tropic,
		onDone : (/*toUpload*/ [FbSourceBase64], /*toReduce*/ [FbSourceBase64], /*largeSize*/ [FbSourceBase64]) -> void,
		style : [FbFilterUploadDialog]
	) -> void;
}

SearchState(
	engine : FilebrowserEngine<?, ??>,
	text : string,
	ext : [string],
	counterB : DynamicBehaviour<int>,
	breakSearchB : DynamicBehaviour<bool>,
	currentPathB : DynamicBehaviour<string>,
	selectedNameB : DynamicBehaviour<[string]>
);

//
makeSearchState(engine : FilebrowserEngine<?, ??>, text : string, ext : [string], currentPathB : DynamicBehaviour<string>, selectedNameB : DynamicBehaviour<[string]>) -> SearchState {
	SearchState(
		engine,
		text,
		ext,
		make(0),
		make(false),
		currentPathB,
		selectedNameB
	)
}

startTimestampR : ref double = ref 0.0;
// calls the content loading and view creating for the current path
getLibraryUI(state : FilebrowserState<Pair<string, bool>, ?>, ext : [string], filterFn : (string) -> bool, changesCallback : ([string], [string], [string]) -> void, folderSelection : bool) -> Material {
	currentPath = getValue(state.currentPathB);
	viewB = make(MCenter(MLoading(_("Loading content, please wait..."))));
	onError = \error -> next(viewB, MCenter(MText("Error: " + error, [])));

	curTimestamp = timestamp();
	startTimestampR := curTimestamp;
	getContentAPI(state.engine, currentPath, ext, filterFn,
		\dirs : [string], files : [string] -> {
			previewsB = make([]);
			previewsLoadingStatusB = make(Some(_("Thumbnails updating, please wait...")));
			next(viewB, prepareAndGetContentUI(
				state,
				map(dirs, \d -> Pair(d, true)),
				if (folderSelection) [] else map(files, \d -> Pair(d, false)),
				contains(dirs, ".."),
				previewsB,
				previewsLoadingStatusB
			));
			timer(100, \-> {
				state.engine.getPathsPreview(
					map(files, \f -> currentPath + f),
					\pairs -> {
						//nextDistinct(previewsLoadingStatusB, None());
						nextDistinct(previewsB, pairs);
					},
					onError
				);
				checkWhatIsChanged(currentPath, dirs, files, state.engine, changesCallback, previewsLoadingStatusB, curTimestamp)
			});
		},
		onError
	);

	MMutable(viewB);
}

FSFileData(
	fileName : string,
	fileVersion : int
);

FSPathContent(
	basePath : string,
	dirs : [string],
	files : [FSFileData]
);

lastCheckResultR : ref Maybe<FSPathContent> = ref None();

checkWhatIsChanged(
	basePath : string,
	dirs : [string],
	files : [string],
	engine : FilebrowserEngine<?, ??>,
	callback : ([string], [string], [string]) -> void,
	previewsLoadingStatusB : DynamicBehaviour<Maybe<string>>,
	curTimestamp : double
) -> void {
	updateLastCheckResult = \files3 -> {
		eitherFn(
			^lastCheckResultR,
			\lcr -> {
				if (basePath == lcr.basePath) {
					files2 = map(lcr.files, \file -> file.fileName);

					added = concat(
						map(subtractA(dirs, lcr.dirs), \p -> basePath + p + "/"),
						map(subtractA(files, files2), \p -> basePath + p)
					);

					removed = concat(
						map(subtractA(lcr.dirs, dirs), \p -> basePath + p + "/"),
						map(subtractA(files2, files), \p -> basePath + p)
					);

					updated = filter(
						files3,
						\f -> 
							eitherMap(
								find(lcr.files, \f2 -> f2.fileName == f.fileName),
								\f2 -> !(f2.fileVersion == f.fileVersion || f2.fileVersion == 0),
								false
							)
					);

					updatedNames = map(updated, \file -> file.fileName);
					lastCheckResultR := Some(FSPathContent(basePath, dirs, files3));
					if (added != [] || removed != []|| updatedNames != []) {
						callback(added, removed, updatedNames);
					}
			}},
			\-> lastCheckResultR := Some(FSPathContent(basePath, dirs, files3))
		);
		nextDistinct(previewsLoadingStatusB, None());
	}

	nextDistinct(previewsLoadingStatusB, Some(_("Cache updating, please wait...")));
	mapAsync(
		files,
		\f, ff, rj -> if (^startTimestampR == curTimestamp) engine.getExtraInfo(
			basePath + f,
			"version",
			\m -> eitherFn(m, \m2 -> ff(FSFileData(f, getJsonIntValue(m2, 0))), \-> rj("can't get version")),
			rj
		) else ff(FSFileData(f, 0)),
		updateLastCheckResult,
		\__ -> {
			updateLastCheckResult(
				eitherMap(
					^lastCheckResultR,
					\lcr -> lcr.files,
					[]
				)
			);
		}
	)
}

// loading content of the selected folder using API
getContentAPI(engine : FilebrowserEngine<?, ??>, path : string, ext : [string], filterFn : (string) -> bool, callback : (dirs : [string], files : [string]) -> void, onError : (string) -> void) {
	// A small delay to show empty filebrowser before content loading
	deferUntilRender(\->
		engine.readDirectory(path, \dirs, files -> {
			nonEmpty = neq("");
			okExt = if (ext == []) \f -> true
				else \f -> exists(ext, \val -> endsWith(toLowerCase(f), val));

			callback(
				filter(dirs, \d -> nonEmpty(d) && filterFn(d)),
				filter(files, \f -> nonEmpty(f) && okExt(f) && filterFn(f))
			);

		}, onError)
	);
}

// start the elements searching (which names contains searchText string) and updating the content view
getSearchResultUI(state : FilebrowserState<Pair<string, bool>, ?>, searchText : string, ext : [string], filterFn : (string) -> bool) -> Material {
	// Special state2 for search case to have tooltips in result view.
	// Without dummy `currentPathB` files in the current folder will be without tooltips.
	state2 = FilebrowserState(state with currentPathB=make("-1"));
	stateSearch = makeSearchState(state.engine, toLowerCase(searchText), ext, state.currentPathB, state.selectedElementsB);
	next(stateSearch.counterB, getValue(stateSearch.counterB) + 1);
	currentPath = getValue(state.currentPathB);

	itemB = make(MLoading(_("Searching, please wait...")));
	resD = ref [];
	resF = ref [];

	resultScreen = \-> {
		dirs = map(^resD, \d -> { r = split2Name_Path(d); FBContentPath(Pair(r.first, true), ref makeTree(), true, r.second, r.first); });
		files = map(^resF, \f -> { r = split2Name_Path(f); FBContentPath(Pair(r.first, false), ref makeTree(), false, r.second, r.first); });

		if (!getValue(stateSearch.breakSearchB)) {
			l = length(dirs) + length(files);
			next(
				itemB,
				if (l == 0)
					MCenter(MText(_("Files for criteria") + " \"" + searchText + "\" " + _("are not found."), []))
				else
					MLines2(
						MText(_("Elements found") + ": " + i2s(l), []),
						getContentUI(state2, dirs, files, None(), make([]), make(None()))
					)
			)
		}
	};

	// adding new founded elenents to the result array
	addResult = \dirs, files -> {
		if (!getValue(stateSearch.breakSearchB)) {
			resD := concat(^resD, dirs);
			resF := concat(^resF, files);
		}
	};

	// a bit of time to render MLoading()
	deferUntilRender(\-> {
		getContentRecursive(stateSearch, currentPath, filterFn, addResult, \error ->
			next(itemB, MCenter(MText(_("Error") + ": " + error, [])))
		);

		next(stateSearch.counterB, getValue(stateSearch.counterB) - 1);
	});

	MConstruct([
			\-> subscribe(state.searchTextB, \text -> nextDistinct(stateSearch.breakSearchB, text != searchText)),
			\-> subscribe(stateSearch.counterB, \count -> if (count == 0) resultScreen())
		],
		MMutable(itemB)
	);
}

// files and folders searching in the "currentPath", including subfolders
getContentRecursive(state : SearchState, currentPath : string, filterFn : (string) -> bool, onOK : ([string], [string]) -> void, onError : (string) -> void) -> void {
	//start search in the currentPath
	next(state.counterB, getValue(state.counterB) + 1);
	correctedCurPath = addSlash2pathEnd(currentPath);

	getContentAPI(state.engine, currentPath, state.ext, filterFn, \dirs, files -> {
		dirs2 = filtermap(dirs, \dir -> {
			r = takeAfterLast(dir, "/", dir);
			if (r != "..") Some(r)
			else None();
		});

		if (!getValue(state.breakSearchB)) {
			resD = filtermap(dirs2, \dir -> {
				r = takeAfterLast(dir, "/", dir);
				if (strContains(toLowerCase(r), state.text)) Some(r)
				else None();
			});
			resF = filtermap(files, \file -> {
				r = takeAfterLast(file, "/", file);
				if (strContains(toLowerCase(r), state.text)) Some(r)
				else None();
			});

			if (length(resD) + length(resF) > 0)
				onOK(
					map(resD, \d -> correctedCurPath + d + "/"),
					map(resF, \f -> correctedCurPath + f)
				);
		}

		// currentPath processing complete
		next(state.counterB, getValue(state.counterB) - 1);

		// go to in the sub folders
		if (!getValue(state.breakSearchB))
			iter(dirs2, \dir -> {
				getContentRecursive(state, correctedCurPath + dir + "/", filterFn, onOK, onError)
			});
	}, onError
	);
}

//
getPathExistsNames(engine : FilebrowserEngine<?, ??>, currentPath : string, ext : string, isFolder : bool, filterFn : (string) -> bool, callback : (names : [string]) -> void, onError : (string) -> void) -> void {
	callback2 = \dirs, files -> {
		callback(
			if (isFolder) dirs
			else map(files, \f -> f |> split2name_ext |> firstOfPair)
		)
	};

	getContentAPI(engine, currentPath, [ext], filterFn, callback2, onError);
}

// file browser dialod view
renderCustomMFileBrowser(manager : MaterialManager, parent : MFocusGroup, caption : string, ext : [string], buttons : [FileBrowserButtonsM], styles2 : [FbMStyle], m2t : (Material, MFocusGroup) -> Tropic) -> void {
	styles = if (extractStructMany(styles2, FbGetCurrentPathB(make(""))) != []) styles2
		else arrayPush(styles2, FbGetCurrentPathB(make("")));
	closeB = make(false);				// Close filebrowser dialog
	fileNameB = make("");				// "Filename" field value
	selectedElementPathB = make("");	// Path + name of the currently selected file or folder
	inSearchB = make(false);			// Show or hide searching panel
	inPathInputB = make(false);			// Show/hide path text input
	pathInputTextB = make("");			// Show/hide path text input
	showSliderB =  make(false);			// Show or hide view zoom slider
	zoomValueB = make(0.5);				// zoom silder position
	dialogContentB = make(TEmpty());
	closeMe = \-> next(closeB, true);
	normalExts = uniq(map(ext, toLowerCase));

	curPathOutAll = map(extractStructMany(styles, FbGetCurrentPathB(make(""))), \s -> s.path);
	curPathOutArrB = tail(curPathOutAll);
	currentPathInnerB = firstElement(curPathOutAll, make(""));
	selectedFilesB = make([]);

	doUpdateCallArr = map(extractStructMany(styles, FbGetContentUpdateFn(\__ -> {})), \s -> s.fn);
	additionalText = extractStruct(styles, FbAdditionalText("")).text;
	pathProcessing = extractStruct(styles, FbPathProcessing(\p -> p)).func;
	folderSelection = contains(styles, FbFolderSelection());
	initSelection = extractStruct(styles, FbInitialSelection("")).sel;
	dropFnM = tryExtractStruct(styles, FbDropFileFn(\__ -> {}));
	onCancelFn = extractStruct(buttons, CancelExtFBB(nop)).func;
	hideBottomPanel = contains(styles, FbHideBottomPanel());
	allowPathInput = contains(styles, FbAllowPathInput());
	fileFilterFn = extractStruct(styles, FbFileFilter(\__ -> true)).fn;
	selectedFilesMany = map(extractStructMany(styles, FbSelectedNames(make([]))), \s -> s.filenamesB);
	callbackOnUpdateFns = map(extractStructMany(styles, FbWhatIsChanged(nop4)), \s -> s.fn);
	uploadMaxSizeM = minA(map(extractStructMany(styles, FbUploadMaxFileSize(0)), \s -> s.size));
	uploadMaxImageResolutionM = minA(map(extractStructMany(styles, FbUploadImageMaxResolution(0)), \s -> s.resolution));
	uploadMaxVideoBitrateM = minA(map(extractStructMany(styles, FbUploadVideoMaxBitrate(0)), \s -> s.bitrate));

	importEngines = mapConcat(extractStructMany(styles, FbImportEngine([])), \s -> s.engines);

	// Reset the last cache for the WhatIsChanged to start new `session`
	lastCheckResultR := None();

	//currentPathAccessRight = make(FileAccessRightOwner());
	curDirAccessRightB = make(makePathAccessRight());
	fbEngine = extractStruct(styles, FbEngine(convertExtApi2engine(
		getFilesystemExtAPI(),
		tryExtractStruct(styles, FbGetFilesPreview(\__, fn -> fn([]))),
		maybeMap(tryExtractStruct(styles, FbDropFileFn(nop1)), \s -> s.fn)
	))).engine;

	itemProperties = [
		FBItemProperty(
			_("Name"),
			\itemCP, onOK2, onError2 -> {
				itemCP.propertiesR := setTree(^(itemCP.propertiesR), "Name", JsonString(itemCP.filename));
				onOK2();
			},
			\itemCP1, itemCP2 -> genericCompare(itemCP1.filename, itemCP2.filename),
			\itemCP -> itemCP.item.first
		),
		FBItemProperty(
			_("Size"),
			\itemCP, onOK2, onError2 -> {
				fbEngine.getExtraInfo(getItemFullname(itemCP), "filesize",
					\jsonM -> {
						itemCP.propertiesR := setTree(^(itemCP.propertiesR), "Size", either(jsonM, JsonDouble(0.0)));
						onOK2();
					},
					onError2
				);
			},
			\itemCP1, itemCP2 -> {
				genericCompare(
					getJsonIntValue(lookupTreeDef(^(itemCP1.propertiesR), "Size", JsonDouble(0.0)), 0),
					getJsonIntValue(lookupTreeDef(^(itemCP2.propertiesR), "Size", JsonDouble(0.0)), 0)
				);
			},
			\itemCP -> {
				getJsonIntValue(lookupTreeDef(^(itemCP.propertiesR), "Size", JsonDouble(0.0)), 0) |> i2s;
			}
		),
		FBItemProperty(
			_("Created"),
			\itemCP, onOK2, onError2 -> {
				fbEngine.getExtraInfo(getItemFullname(itemCP), "filedate",
					\jsonM -> {
						maybeApply(
							jsonM,
							\json -> itemCP.propertiesR := setTree(^(itemCP.propertiesR), "Created", json)
						);
						onOK2();
					},
					onError2
				);
			},
			\itemCP1, itemCP2 -> {
				genericCompare(
					getJsonDoubleValue(lookupTreeDef(^(itemCP1.propertiesR), "Created", JsonDouble(0.0)), 0.0),
					getJsonDoubleValue(lookupTreeDef(^(itemCP2.propertiesR), "Created", JsonDouble(0.0)), 0.0)
				);
			},
			\itemCP -> {
				eitherMap(
					lookupTree(^(itemCP.propertiesR), "Created"),
					\json -> time2string(getJsonDoubleValue(json, 0.0)),
					""
				);
			}
		)
	];

	state = makeFilebrowserState(firstOfPair, itemProperties, styles);

	filterFn = \name -> {
		fullName = getValue(state.currentPathB) + (if (name != "." && name != ".." && name != "/." && name != "/..")  name else "");
		fileFilterFn(fullName);
	}

	changesCallbackFn = \added, removed, updated -> iter(callbackOnUpdateFns, \fn -> fn(added, removed, updated, closeMe));

	lastUpdateTimeMR = ref None();
	updateFilesView = \-> {
		if (eitherMap(^lastUpdateTimeMR, \t -> timestamp() - t, 10.0) > 1.0) {
			nextDistinct(dialogContentB, getLibraryUI(state, normalExts, filterFn, changesCallbackFn, folderSelection));
			lastUpdateTimeMR := Some(timestamp());
		}
	}
	iter(doUpdateCallArr, \fn -> fn(updateFilesView));

	state.engine.isDirectory(
		state.startDir,
		\doesExists -> {
			if (!doesExists) println("WARNING: Filebrowser start path \"" + state.startDir + "\" does not exists");
			next(state.currentPathB, {
				defPath = if (state.startDir != "" && doesExists) state.startDir
				else if (state.limitAccess) state.startDir
				else strReplace(state.engine.resolveRelativePath("./"), "\\", "/");

				extractStruct(styles, FbCurrentPath(make(addSlash2pathEnd(defPath)))).path |> getValue;
			})
		},
		println /* onError */
	);

	openDialogMenu = \itemCP, clickPos, onUpdate, fileAccessRight -> {
		filename = getItemFullname(either(itemCP, FBContentPath(Pair("", false), ref makeTree(), false, "", "")));
		curDirAccessRight = getValue(curDirAccessRightB);

		MDialogMenu(manager, parent, [
			MDialogMenuItem("content_copy", "copy", filename != "", \-> next(state.copiedElementsB, Pair(filename, false))),
			MDialogMenuItem("content_cut", "cut", filename != "" && fileAccessRight.arUpdate && fileAccessRight.arDelete, \-> next(state.copiedElementsB, Pair(filename, true))),
			MDialogMenuItem("create_new_folder", "create folder", isNone(itemCP) && !getValue(inSearchB) && curDirAccessRight.arCreate, \-> {
				closeDialogB = make(false);
				nameB = make(_("new folder"));
				errorText = None() |> make;
				saveEnable = make(true);

				showDialog = \existsNames -> {
					renderMDialog(manager, closeDialogB,
						[
							MDialogTitle(_("Create new folder")),
							MDialogUseFrame(),
							MDialogActions([
								MTextButton(_("CANCEL"), \-> next(closeDialogB, true), [], [MShortcut("esc")]),
								MTextButton(_("CREATE"), \-> {
									state.engine.createDirectory(
										getValue(state.currentPathB) + getValue(nameB) + "/",
										updateFilesView,
										println
									);
									next(closeDialogB, true);
								}, [], [MShortcut("enter"), MEnabled(saveEnable)])
							]),
							MDialogScroll(),
						],
						MConstruct(
							[
								makeSubscribe(nameB, \n -> validatePartitionName(n, errorText, existsNames)),
								makeSubscribe(errorText, \t -> nextDistinct(saveEnable, t |> isNone))
							],
							MBaselineCols2A(
								MText(_("Folder name:"), []),
								MTextInput(
									nameB,
									[MWidth(400.0), MMaxLines(1)],
									[MInputError(errorText, [])]
								) |> MBorderStart(8.0)
							)
						), m2t
					);
				}

				getPathExistsNames(state.engine, getValue(state.currentPathB), "", true, \__ -> true, showDialog, println);
			}),
			MDialogMenuItem("delete", "delete", filename != "" && fileAccessRight.arDelete, \-> {
				closeDialogB = make(false);
				renderMDialog(manager, closeDialogB,
					[
						MDialogTitle(_("Are you sure?")),
						MDialogUseFrame(),
						MDialogActions([
							MTextButton(_("CANCEL"), \-> next(closeDialogB, true), [], [MShortcut("esc")]),
							MTextButton(_("DELETE"), \-> {
								deleteFn = if (endsWith(filename, "/")) state.engine.deleteDirectories else state.engine.deleteFiles;
								deleteFn([filename], \-> {
										onUpdate(None());
										maybeApply(^lastCheckResultR,
											\lcr -> {
												if (getValue(state.currentPathB) == lcr.basePath) {
													pair = split2Name_Path(filename);
													eitherFn(
														findi(lcr.files, \file -> file.fileName == pair.first),
														\i -> lastCheckResultR := Some(FSPathContent(lcr.basePath, lcr.dirs, removeIndex(lcr.files, i))),
														\ -> lastCheckResultR := Some(FSPathContent(lcr.basePath, subtractA(lcr.dirs, [pair.first]), lcr.files))
													)	
												}
											}
										);
										changesCallbackFn([], [filename], []);
									}, println
								);
								next(closeDialogB, true);
							}, [], [MShortcut("enter")])
						]),
						MDialogScroll(),
					],
					TEmpty(), m2t
				);
			}),
			MDialogMenuItem("create", "rename", filename != "" && fileAccessRight.arUpdate, \-> {
				isFolder = endsWith(filename, "/");
				pair = split2Name_Path(filename);
				name_ext = pair.first |> split2name_ext;
				nameB = make(name_ext.first);
				errorText = None() |> make;
				saveEnable = make(true);
				closeDialogB = make(false);

				showDialog = \existsNames -> {
					renderMDialog(manager, closeDialogB,
						[
							MDialogTitle(_("Renaming")),
							MDialogUseFrame(),
							MDialogActions([
								MTextButton(_("CANCEL"), \-> next(closeDialogB, true), [], [MShortcut("esc")]),
								MTextButton(_("RENAME"), \-> {
									newNameFull = pair.second + getValue(nameB) + (if (name_ext.second != "") "." + name_ext.second else "") + (if (isFolder) "/" else "");
									
									// itemCP
									/*state.engine.renamePath(
										filename,
										getValue(nameB),
										\newName -> onUpdate(pair.second + newName + (if (name_ext.second != "") "." + name_ext.second else "") + (if (isFolder) "/" else "")),
										println
									);*/
									
									next(closeDialogB, true);
								}, [], [MShortcut("enter"), MEnabled(saveEnable)])
							]),
							MDialogScroll(),
						],
						MConstruct(
							[
								makeSubscribe(nameB, \n -> validateFileName(n, errorText, existsNames, "")),
								makeSubscribe(errorText, \t -> nextDistinct(saveEnable, t |> isNone))
							],
							MCols([
								MFixSize(MText(_("Filename") + ":", []), TFixed(75.0, 20.0)),
								TFixed(8.0, 0.0),
								MPad(0.0, -14.0,
									MTextInput(
										nameB,
										[MWidth(400.0), MMaxLines(1)],
										[MInputError(errorText, []), MEnabled(const(true))]
									)
								),
								if (isFolder) TEmpty()
								else MText("." + name_ext.second, [])
							])
						), m2t
					);
				}

				getPathExistsNames(state.engine, getValue(state.currentPathB), if (isFolder) "" else "." + name_ext.second, isFolder, \__ -> true, showDialog, println);
			}),
			MDialogMenuItem(
				"content_paste",
				"paste",
				strlen(getValue(state.copiedElementsB).first) > 0 && isNone(itemCP) && !getValue(inSearchB) && curDirAccessRight.arCreate,
				\-> {
					copied = getValue(state.copiedElementsB);
					pair = copied.first |> split2Name_Path;
					copyTo = getValue(state.currentPathB);

					// do nothing if we cut/paste at the same place
					if (pair.second != copyTo || !copied.second) {
						fn = if (copied.second) state.engine.movePaths
							else state.engine.copyPaths;

						fn(
							[copied.first],
							copyTo,
							\-> {
								updateFilesView();
								if (copied.second) next(state.copiedElementsB, Pair("", false));
							},
							println
						);
					}
				}
			)
		], m2t, clickPos)
	}

	next(state.onRightClickB, \itemCP, clickPos, onUpdate -> {
		state.engine.getAccessRight(
			getItemFullname(either(itemCP, FBContentPath(Pair("", false), ref makeTree(), false, "", ""))),
			\fileAccessRight -> openDialogMenu(itemCP, clickPos, onUpdate, fileAccessRight),
			\err -> openDialogMenu(itemCP, clickPos, onUpdate, PathAccessRight(false, false, false, false)),
		);
		
	});

	if (getValue(state.currentPathB) == "") {
		path = if (strlen(state.startDir) > 0) {
			state.startDir;
		} else {
			p = strReplace(state.engine.resolveRelativePath("."), "\\", "/");
			p + (if (p != "") "/" else "");
		};

		next(state.currentPathB, path);
	};

	setSelected = nop;

	statusPanel = {
		iconsR = ref [];

		addInfoIcon = \iconName, tooltip -> {
			MIcon(iconName, [MIconSize(24.0)])
			|> (\m -> MTooltip(m, MText(tooltip, [MCaption()]), []))
			|> MCenter
			|> (\m -> MFixSize(m, TFixed(30.0, 30.0)))
			|> (\m -> MCols2(TFixed(8.0, 0.0), m))
			|> (\m -> refArrayPush(iconsR, m));
		};

		if (additionalText != "") addInfoIcon("info", additionalText);

		if (length(normalExts) > 0) addInfoIcon(
				"filter_list",
				_("Supported extensions") + ": \"" + strGlue(normalExts, ", ") + "\""
			);

		if (folderSelection) addInfoIcon("folder_shared", _("Directory selection mode installed"));

		maybeApply(uploadMaxSizeM, \size -> addInfoIcon("attach_file", formatString(_("The maximum file size to upload is %1 Mb"), [i2s(size / 1024 / 1024)])));

		switch (state.maybeMultiselectB) {
			Some(ctrlKeyB): {
				MSelect(ctrlKeyB, \ctrlKey -> MIcon("add_to_photos", [if (ctrlKey) MRed(500) else MBlack(), MIconSize(24.0)]))
					|> (\m -> MTooltip(m, MText(_("Multiselection mode: use \"ctrl\" key to select several elements"), [MCaption()]), []))
					|> MCenter
					|> (\m -> MFixSize(m, TFixed(30.0, 30.0)))
					|> (\m -> MCols2(TFixed(8.0, 0.0), m))
					|> (\m -> refArrayPush(iconsR, m));
			}
			None(): {};
		}

		if (isDevMode() || isUrlParameterTrue("devtrace"))
			state.engine.whoAmI(\apiName -> addInfoIcon("perm_device_information", "Partition: `" + apiName + "`"), nop1);

		if (state.limitAccess) addInfoIcon("call_missed", formatString(_("Top navigation restricted by the path: \"%1\""), [state.startDir]));

		MSelect(state.copiedElementsB, \copied -> {
			if (copied.first == "") TEmpty()
			else {
				{
					if (copied.second)
						MIcon("content_cut", [MIconSize(24.0)])
						|> (\m -> MTooltip(m, MText(_("Element to cut") + ": " + copied.first, [MCaption()]), []))
					else
						MIcon("content_copy", [MIconSize(24.0)])
						|> (\m -> MTooltip(m, MText(_("Element to copy") + ": " + copied.first, [MCaption()]), []));
				}
				|> MCenter
				|> (\m -> MFixSize(m, TFixed(30.0, 30.0)))
			}
		})
		|> (\m -> MCols2(TFixed(8.0, 0.0), m))
		|> (\m -> refArrayPush(iconsR, m));

		refArrayPush(iconsR, TFixed(8.0, 0.0));

		MSelect(state.copiedElementsB, \copied ->
			if (length(^iconsR) == 2 && copied.first == "") TEmpty()
			else
				MCols(concat([TFixed(8.0, 0.0)], ^iconsR))
		);
	};

	buttonFunc = \updateFilenameFn, onFileExistsFn, onNoFileFn, onFolderFn -> {
		selectedElementsPath = getValue(state.selectedElementsB);
		currentPath = getValue(state.currentPathB);

		filesFuncRespectExistence = \filesNames -> checkIsFilesAll(state.engine, filesNames, true, \resultFiles -> {
			if (resultFiles) {
				closeMe();
				onFileExistsFn(filesNames);
			} else {
				onNoFileFn(filesNames)
			}
		});

		if (selectedElementsPath != []) {
			checkIsDirectoryAll(state.engine, selectedElementsPath, true, \resultDir -> {
				if (resultDir) {
					// in case if single folder selected - we open it
					if (length(selectedElementsPath) == 1) next(state.currentPathB, selectedElementsPath[0]);
					if (folderSelection) onFolderFn(selectedElementsPath);
				} else if (!folderSelection) {
					filesFuncRespectExistence(map(selectedElementsPath, updateFilenameFn));
				}
			})
		// if nothing selected we return the current path (in folder selection mode)
		} else if (folderSelection) {
			onFolderFn([currentPath]);
		} else {
			filesFuncRespectExistence([currentPath + updateFilenameFn(getValue(fileNameB))]);
		}
	}

	initClickLastR = ref 0;
	initClickB = \priorityIdx, action -> if (^initClickLastR < priorityIdx) {
		initClickLastR := priorityIdx;
		next(state.onClickB, \itemM -> {
			eitherFn(
				itemM,
				\item -> {
					fullName = getItemFullname(FBContentPath(item, ref makeTree(), item.second, addSlash2pathEnd(getValue(state.currentPathB)), item.first));
					if (item.second /*isFolder*/) {
						nextDistinct(state.currentPathB, fullName);
					} else if (isNone(state.maybeMultiselectB)) {
						nextDistinct(state.selectedElementsB, [fullName]);
						action();
					}
				},
				\-> {
					correctCurPath = addSlash2pathEnd(getValue(state.currentPathB));
					curPath = if (strlen(correctCurPath) > 0) strLeft(correctCurPath, strlen(correctCurPath) - 1) else correctCurPath;
					lastSlashIdx = strLastIndexOf(curPath, "/");
					prevPath = if (lastSlashIdx > 0) strLeft(curPath, lastSlashIdx) else "";
					name = if (endsWith(prevPath, ":")) prevPath + "/" else prevPath + "/";

					next(state.currentPathB, name);
				}
			)
		});
	};

	dialogActions = map(buttons, \button -> {
		switch(button) {
			OpenExtFBB(func): {
				action = \-> buttonFunc(/*updateFilenameFn, onFileExistsFn, onNoFileFn, onFolderFn*/
					\name -> name,
					\filesNames -> func(map(filesNames, \f -> FbObject(pathProcessing(f), state.engine.path2url(f)))),
					\filesNames -> println("Files or folders '" + strGlue(filesNames, "', '") + "' doesn't exists."),
					\foldersPaths -> { closeMe(); func(map(foldersPaths, \f -> FbObject(pathProcessing(f), state.engine.path2url(f)))); }
				);

				initClickB(10, action);

				enabledB = make(false);
				MConstruct(
					[\-> subscribe(state.selectedElementsB, \sel -> {
						if (sel == []) {
							nextDistinct(enabledB, false);
						} else if (folderSelection) {
							checkIsDirectoryAll(state.engine, sel, true, \resultDir -> nextDistinct(enabledB, (sel == [] || resultDir)));
						} else {
							checkIsFilesAll(state.engine, sel, true, \resultFiles -> nextDistinct(enabledB, resultFiles));
						}
					})],
					MTextButton(_("OPEN") + if (folderSelection) (" " + _("FOLDER")) else "", action, [], [MEnabled(enabledB), MShortcut("Enter")])
				)
			};
			SaveExtFBB(func): {
				action = \-> buttonFunc(/*updateFilenameFn, onFileExistsFn, onNoFileFn, onFolderFn*/
					\name -> if (strContains(name, ".")) name
						else if (length(normalExts) > 0) name + normalExts[0]
						else name,
					\filesNames -> {
						withConfirmation2(
							_("File with specified name has already exist.\nDo you want to rewrite it?"),
							\-> func(map(filesNames, \f -> FbObject(pathProcessing(f), state.engine.path2url(f)))),
							onCancelFn
						)
					},
					\filesNames -> {
						closeMe();
						func(
							if (filesNames == []) [FbObject(pathProcessing(getValue(state.currentPathB) + getValue(fileNameB) + if (folderSelection) "/" else ""), "")]
							else map(filesNames, \f -> FbObject(pathProcessing(f), state.engine.path2url(f)))
						);
					},
					\foldersPaths -> { closeMe(); func(map(foldersPaths, \f -> FbObject(pathProcessing(f), state.engine.path2url(f)))); }
				);

				initClickB(9, action);

				enabledB = make(false);
				MConstruct(
					[\-> subscribe(fileNameB, \fileName -> {
						sel = getValue(state.selectedElementsB);
						if (folderSelection) {
							checkIsDirectoryAll(state.engine, sel, true, \resultDir -> nextDistinct(enabledB, (sel == [] || resultDir)));
						} else {
							nextDistinct(enabledB, fileName != "");
						}
					})],
					MTextButton(_("SAVE"), action, [], [MEnabled(enabledB), MShortcut("Enter")])
				)
			};
			CancelExtFBB(func): {
				MTextButton(_("CANCEL"), \-> { closeMe(); func(); }, [], [MShortcut("Esc")])
			};
			CustomExtFBB(cap, func): {
				action = \-> buttonFunc(/*updateFilenameFn, onFileExistsFn, onNoFileFn, onFolderFn*/
					\name -> name,
					\filesNames -> func(getValue(state.currentPathB), map(getValue(state.selectedElementsB), pathProcessing)),
					\filesNames -> println("Files or folders '" + strGlue(filesNames, "', '") + "' doesn't exists."),
					\foldersPaths -> { closeMe(); func(getValue(state.currentPathB), map(foldersPaths, \f -> pathProcessing(f))); }
				);

				initClickB(4, action);

				enabledB = make(false);
				MConstruct(
					[\-> subscribe(state.selectedElementsB, \sel -> {
						if (sel == []) {
							nextDistinct(enabledB, false);
						} else if (folderSelection) {
							checkIsDirectoryAll(state.engine, sel, true, \resultDir -> nextDistinct(enabledB, (sel == [] || resultDir)));
						} else {
							checkIsFilesAll(state.engine, sel, true, \resultFiles -> nextDistinct(enabledB, resultFiles));
						}
					})],
					MTextButton(toUpperCase(cap), action, [], [MEnabled(enabledB), MShortcut("Enter")])
				)
			};
			CustomWithUpdateFBB(cap, func): {
				initClickB(5, nop);

				MTextButton(cap |> toUpperCase, \->
					func(getValue(state.currentPathB), getValue(state.selectedElementsB), updateFilesView),
					[],
					[]
				)
			};
		}
	});

	checkForClicable = \path -> {
		if (state.limitAccess && startsWith(state.startDir, path)) false
		else true;
	}

	makePathView = \curPath -> {
		nextDistinct(state.searchTextB, "");
		nextDistinct(inSearchB, false);
		nextDistinct(inPathInputB, false);
		nextDistinct(pathInputTextB, "");

		pathSplitted = strSplit(curPath, "/");
		MCols2(
			MScroll(
				MCols([
					TFixed(8.0, 0.0),
					MCenterY(MText(_("Files in") + ": ", [])),
					MSelect(inPathInputB, \inPathInput ->
						if (inPathInput) {
							nextDistinct(pathInputTextB, getValue(state.currentPathB));
							MCols([
								TFixed(5.0, 0.0),
								MTextInput(pathInputTextB, [MInputBorders(8., 8., 8., 8.), MCustomTextStyle([MButtonFont()]), MShowUnderline(false)], [MEnabled(const(true)), TTextInputFocus(inPathInputB)])
							])
						} else {
							newPath = strReplace(getValue(pathInputTextB), "\\", "/");
							if (fileExists(newPath)) {
								nextDistinct(state.currentPathB, newPath);
							}
							MCols(
								interleave(
									mapi(pathSplitted, \i, name -> {
										path = strGlue(take(pathSplitted, i + 1), "/") + "/";
										if (name == "") TEmpty()
										else {
											isClickable = checkForClicable(path);
											MTooltip(
												MTextButton(
													name,
													\-> { nextDistinct(state.searchTextB, ""); nextDistinct(state.currentPathB, path) },
													[MBlack()],
													[MEnabled(const(isClickable))]
												),
												MText(formatString(_("Top navigation restricted by the path: \"%1\""), [state.startDir]), []),
												[MEnabled(const(!isClickable))]
											)
										}
									}),
									MCenterY(MText("/", [MCustomFont(20.0, "Roboto", 0.5)]))
								)
							)
						}
					),
					MSelect(state.searchTextB, \searchText ->
						if (strlen(searchText) > 0)
							MCols2(
								MCenterY(MText("  " + _("Search result") + "  ", [MBodyBold()])),
								MCenterY(MText("/", [MCustomFont(20.0, "Roboto", 0.5)]))
							)
						else
							TEmpty()
					),
					TFixed(8.0, 0.0),
					MClickable(TFillXH(36.0), \-> {
						if (!getValue(inPathInputB) && allowPathInput) nextDistinct(inPathInputB, true);
					}),
				]),
				TFillXH(36.0),
				[TScrollbars(minimalScrollBarLight, minimalScrollBarLight), TScrollDontHandle()]
			),
			MSelect(inPathInputB, \inPathInput ->
				if (inPathInput || !allowPathInput)
					TEmpty()
				else
					MIconButton("edit", \-> { nextDistinct(inPathInputB, true); }, [MIconButtonBorder(1.0), MIconSize(34.0)], [])
			)
		)
		|> (\m -> MFrame(1.0, 4.0, [Stroke(gray)], m));
	}

	menuIconB = make(MIcon("view_module", [MIconSize(32.0)]));
	updateViewStyle = \icon -> {
		nextDistinct(menuIconB, MIcon(icon, [MIconSize(32.0)]));
		if (icon == "view_module") {
			nextDistinct(state.contentViewIconsB, true);
		} else if (icon == "format_list_bulleted") {
			nextDistinct(state.contentViewIconsB, false);
		}
	};

	topActions =
		filtermap(styles, \s ->
			switch(s) {
				FbTopPanelCustomItem(getItem, requiredAccessRight): {
					enabled = fselect(curDirAccessRightB, FLift(\curDirAR : PathAccessRight -> {
						{if (requiredAccessRight.arCreate) curDirAR.arCreate else true} &&
						{if (requiredAccessRight.arRead  ) curDirAR.arRead   else true} &&
						{if (requiredAccessRight.arUpdate) curDirAR.arUpdate else true} &&
						{if (requiredAccessRight.arDelete) curDirAR.arDelete else true}
					}));
					Some(getItem(closeMe, enabled));
				}
				default: None()
			}
		)
		|> (\customItems ->
			if (customItems == []) TEmpty()
			else {
				MCols(arrayPush(
					interleave(customItems, TFixed(8.0, 0.0)),
					TFixed(8.0, 0.0)
				))
			}
		);

	addSortMenuItem = \itemProperty -> {
		sortIconB = fselect(state.contentSortTypeB, FLift(\sortState : FBSortPropertyState ->
			if (sortState.itemProperty.name != itemProperty.name) TEmpty()
			else if (sortState.asc) MIcon("arrow_downward", [])
			else MIcon("arrow_upward", [])
		));

		onSortClick = \-> {
			sortState = getValue(state.contentSortTypeB);
			if (sortState.itemProperty.name != itemProperty.name) {
				nextDistinct(state.contentSortTypeB, FBSortPropertyState(itemProperty, true));
			} else {
				nextDistinct(state.contentSortTypeB, FBSortPropertyState(itemProperty, !sortState.asc));
			}
		}

		MMenuSingleLine(
			_("Sort by") + " " + itemProperty.name,
			[
				MPrimaryAction(MIcon("sort_by_alpha", [])),
				MSecondaryAction(MMutable(sortIconB)),
				MOnClick(onSortClick)
			]
		)
	}

	getSingleEngine = \onEngine -> {
		if (length(importEngines) == 1) onEngine(importEngines[0])
		else {
			mapAsync(
				importEngines,
				\e, ff, rj -> e.whoAmI(\name -> ff([Pair(e, name)]), \err -> ff([])),
				\resArr -> {
					importEngines2 = concatA(resArr);
					if (importEngines2 != []) {
						closeListB = make(false);
						renderMDialog2(
							manager,
							closeListB,
							[
								MDialogTitle(_("Choose a files storage")),
								MDialogActions([MTextButton(_("CANCEL"), \-> next(closeListB, true), [], [MShortcut("esc")])]),
								MDialogUseFrame(),
								MFocusOnPrevious(true)
							],
							MDynamicList(
								const(map(importEngines2, \pair -> MSingleLine(
									pair.second,
									[MOnClick(\-> { onEngine(pair.first); next(closeListB, true); })]
								))),
								[MEmptyMessage(MText(_("No partitions available"), [MListBody()])), MListWidth(240., 360.)],
								[TScrollEnabled(const(true)), TScrollCropByContent()]
							),
							m2t,
							\t -> {
								trender(
									TAvailable(
										TTranslate(fif(manager.iscript.showPanel, const(Point(0.0, 48.0)), const(zeroPoint)), t),
										TIf(manager.iscript.showPanel, TSized(manager.iscript.available), TFillXY())
									)
									|> (\f ->
										materialLogFn(
											\ ->
												TFixSize(
													TLines2(
														TFixed(36., 36.),
														f
													),
													TFillXY()
												),
											MaterialWarning(),
											\ -> f
										)
									),
									manager.manager.renderStyle
								)
							}
						);
					}
				},
				println
			);
		}
	}

	onClickImportFiles = \-> {
		getSingleEngine(\curImportEngine -> {
			renderCustomMFileBrowser(
				manager,
				manager.focus,
				_("Choose files for import"),
				normalExts,
				[
					CancelExtFBB(nop),
					CustomExtFBB(_("IMPORT"), \__, filePaths -> {
						if (filePaths != []) {
							curImportEngine.paths2originals(
								filePaths,
								\origFiles -> state.engine.copySpecial(
									filtermapi(origFiles, \i, fM -> {
										dir = takeBeforeLast(filePaths[i], "/", "") + "/";
										filename = takeAfterLast(filePaths[i], "/", filePaths[i]);
										maybeMap(fM, \f -> FBContentPath(f, ref makeTree(), false, dir, filename));
									}),
									getValue(state.currentPathB),
									\itemCP, onContentDone, onContentError -> {
										curImportEngine.getFileContent(
											itemCP.dirPath + itemCP.filename,
											true,
											\c -> onContentDone(itemCP.filename, c),
											onContentError
										);
									},
									updateFilesView,
									println
								),
								println
							);
						}
					})
				],
				[
					FbEngine(curImportEngine),
					FbLimitAccessToUpperFolder(false),
					FbMultiSelect()
				],
				m2t
			);
		});
	}

	topNavPanel = MColsA([
		MSelect(state.currentPathB, makePathView),
		TFixed(8.0, 0.0),
		topActions,
		if (importEngines == []) MEmpty()
		else {
			MCols2A(
				MIconButton(
					"import_export",
					onClickImportFiles,
					[MIconButtonBorder(1.0), MIconSize(34.0)],
					[
						MEnabled(fselect(curDirAccessRightB, FLift(\ar -> ar.arCreate))),
						MTooltipText(const(_("Show another partition to import files from it.")))
					]
				),
				TFixed(8.0, 0.0)
			)
		},
		MSelect(inSearchB, \inSearch ->
			if (inSearch) {
				MFixSize(
					MColsA([
						TFixed(5.0, 0.0),
						MPadA(0.0, -6.0, MTextInput(state.searchTextB, [MShowUnderline(false)], [MEnabled(const(true))])),
						MIconButton("close", \-> {nextDistinct(state.searchTextB, ""); nextDistinct(inSearchB, false);}, [MIconButtonBorder(1.0), MIconSize(34.0), MOrange(500)], [])
					]),
					TFixed(200.0, 36.0)
				)
				|> (\m -> MFrame(1.0, 4.0, [Stroke(newOrangeColor)], m))
			} else {
				MIconButton("search", \-> { nextDistinct(inSearchB, true); }, [MIconButtonBorder(1.0), MIconSize(34.0)], [MTooltipText(const("Search in filenames here and in sub-folders."))])
			}
		),
		TFixed(8.0, 0.0),
		MShow(state.contentViewIconsB, MSelect(
			showSliderB,
			\showSlider -> MIconButton(
				"linear_scale",
				\-> reverseBehaviour(showSliderB),
				[MIconButtonBorder(1.0), MIconSize(34.0), if (showSlider) MOrange(500) else MBlack()],
				[MTooltipText(const(_("Show/hide view scale slider.")))]
			)
		)),
		TFixed(8.0, 0.0),
		MFixSize(
			MMenu(
				MCenter(MMutable(menuIconB)),
				[
					MMenuSingleLine(_("Icons view"), [MPrimaryAction(MIcon("view_module", [])), MOnClick(\-> updateViewStyle("view_module"))]),
					MMenuSingleLine(_("List view"), [MPrimaryAction(MIcon("format_list_bulleted", [])), MOnClick(\-> updateViewStyle("format_list_bulleted"))])
				],
				[MOpenOnClick(), MBelowButton()]
			),
			TFixed(36.0, 36.0)
		),
		TFixed(8.0, 0.0),
		MFixSize(
			MMenu(
				MCenter(MIcon("sort_by_alpha", [])),
				map(state.itemProperties, addSortMenuItem),
				[MOpenOnClick(), MBelowButton()]
			),
			TFixed(36.0, 36.0)
		)
	]);

	updateZoom = \toDown -> {
		newZoom = getValue(zoomValueB) + 0.1 * (if (toDown) -1.0 else 1.0);
		if (newZoom >= 0.0 && newZoom <= 1.0)
			next(zoomValueB, newZoom);
	};

	zoomSlider = MShow(
		showSliderB,
		MLines2(
			TFixed(0.0, 8.0),
			MCols([
				MIconButton("zoom_out", \-> updateZoom(true), [MIconSize(19.0)], [MEnabled(const(true))]),
				MCenterYIn(MSlider(zoomValueB, [MOrange(500), MSliderRange(0.0, 1.0), MSliderStep(0.1)]), TFillXH(36.0)),
				MIconButton("zoom_in", \-> updateZoom(false), [MIconSize(19.0)], [MEnabled(const(true))]),
			])
		)
	);

	selectedFilesLockedUpdateR = ref false;
	dialogContent = MDispose(concat(
		map(getStateSubscribers(state, fileNameB, selectedFilesB, \cp -> {
				iter(curPathOutArrB, \pB -> nextDistinct(pB, cp));
				// Updating of the access rights for the current path
				state.engine.getAccessRight(cp,
					\ar -> nextDistinct(curDirAccessRightB, ar),
					\err -> nextDistinct(curDirAccessRightB, PathAccessRight(false, false, false, false))
				);
			}),
			\fn -> fn()
		),
		[	
			// Creating file full name (including full path)
			subscribe(fileNameB, \fileName -> {
				sel = getValue(state.selectedElementsB);
				if (isNone(state.maybeMultiselectB) && sel != [] && (sel[0] |> split2Name_Path |> firstOfPair) != fileName || sel == []) {
					if (toUpperCase(strLeft(fileName, 4)) == either(state.engine.myRootName(), "DB") + ":/") {
						nextDistinct(state.selectedElementsB, [toUpperCase(strLeft(fileName, 4)) + strRight(fileName, 4)]);
					} else {
						nextDistinct(state.selectedElementsB, [getValue(state.currentPathB) + fileName]);
					}
				}
			}),
			subscribe(zoomValueB, \zoomValue -> nextDistinct(state.iconSizeB, 20.0 + zoomValue * 100.0)),
			// Update content if the current path changed
			subscribe(state.currentPathB, \__ -> updateFilesView()),
			// Update content if the "searchText" changed. Updating starts if the "searchText" has not changed during one sec.
			subscribe2(state.searchTextB, \searchText -> {
				// clear selection on search start
				nextDistinct(state.selectedElementsB, []);

				if (strlen(searchText) == 0) updateFilesView()
				else timer(1000, \-> {
					if (searchText == getValue(state.searchTextB))
						next(dialogContentB, getSearchResultUI(state, searchText, normalExts, filterFn))
				})
			}),
			state.engine.subscribeOnUpdates(updateFilesView),
			fBidirectionalLink(
				selectedFilesB,
				fmerge(selectedFilesMany),
				\selectedFiles -> {
					if (!^selectedFilesLockedUpdateR) {
						selectedFilesLockedUpdateR := true;
						iter(selectedFilesMany, \fileB -> nextDistinct(fileB, selectedFiles));
						selectedFilesLockedUpdateR := false;
					}
					nextDistinct(
						fileNameB,
						if (selectedFiles == []) ""
						else if (strContains(selectedFiles[0], "/") && endsWith(selectedFiles[0], "/")) takeAfterLast(selectedFiles[0], "/", "")
						else if (!strContains(selectedFiles[0], "/")) selectedFiles[0]
						else ""
					);
				},
				\selectedFilesArr -> {
					if (!^selectedFilesLockedUpdateR) {
						selectedFilesLockedUpdateR := true;
						selectedFilesOld = getValue(selectedFilesB);
						selectedFiles = uniq(concatA(filter(selectedFilesArr, \arr -> arr != selectedFilesOld)));
						iter(selectedFilesMany, \fileB -> nextDistinct(fileB, selectedFiles));
						selectedFilesLockedUpdateR := false;

						nextDistinct(selectedFilesB, selectedFiles);
					}
				}
			),
			// If smb wants to change a current folder from out of the MFileBrowser (Not tested)
			/*subscribe(curPathOutArrB, \cp -> {
				next(state.selectedElementsB, []);
				nextDistinct(state.currentPathB, cp);
				// Updating of the access rights for the current path
				next(curDirAccessRightB, state.engine.getAccessRight(cp));
			}),*/
		]),
		MMutable(dialogContentB)
	)
	|> (\m -> MFrame(1.0, 4.0, [Stroke(gray)], m));

	dialogFileName = MFixSize(
		MCols([
			TFixed(5.0, 0.0),
			MPad(0.0, -5.0, MTextInput(fileNameB, [MLabel(if (folderSelection) _("folder name") else _("Filename")), MCustomTextStyle([MBody()])], [])),
			TFixed(5.0, 0.0)
		]),
		TFillXH(30.0)
	);

	renderMDialog2(
		manager,
		closeB,
		[
			MDialogTitle(caption),
			MDialogActions(dialogActions),
			MDialogUseFrame(),
			MDialogResizable(),
			MFocusOnPrevious(true)
		],
		MLines([
			TFixed(0.0, 1.0),
			topNavPanel,
			zoomSlider,
			TFixed(0.0, 8.0),
			eitherMap(dropFnM,
				\dropFn -> {
					dropFn2 = {
						\files -> {
							filterUploadedFilesForRestrictionsNative(files, Some(manager), m2t, \files2, files3, __ -> {
									dropFn.fn(concat(files2, files3));
								},
								concat3(
									eitherMap(uploadMaxSizeM, \size -> [FbFilterMaxSize(size)], []),
									eitherMap(uploadMaxImageResolutionM, \res -> [FbFilterMaxResolution(res)], []),
									eitherMap(uploadMaxVideoBitrateM, \bitrate -> [FbFilterMaxBitrate(bitrate)], []),
								)
							);
						}
					}
					// we accept only list of extensions without "*." and "." prefixes
					eRegFilter = if (normalExts == []) "" else strGlue(map(normalExts, \e -> strReplace(strReplace(e, "*.", ""), ".", "")), "|");
					MInteractive([TFileDrop(-1, eRegFilter, dropFn2)], dialogContent);
				},
				dialogContent
			),
			if (!hideBottomPanel) {
				MLines2(TFixed(0.0, 8.0), MCols2(dialogFileName, statusPanel))
			} else {
				MEmpty()
			},
		]),
		m2t,
		\t ->
			trender(
				TAvailable(
					TTranslate(fif(manager.iscript.showPanel, const(Point(0.0, 48.0)), const(zeroPoint)), t),
					TIf(manager.iscript.showPanel, TSized(manager.iscript.available), TFillXY())
				)
				|> (\f ->
					materialLogFn(
						\ ->
							TFixSize(
								TLines2(
									TFixed(36., 36.),
									f
								),
								TFillXY()
							),
						MaterialWarning(),
						\ -> f
					)
				),
				manager.manager.renderStyle
			)
	);

	next(fileNameB, initSelection);
}

//////////
// Utils
//////////

FbSourceData(
	index : int,
	name : string,
	extension : string,
	size : double,
	getContentBase64 : (onContent : (string) -> void, onError : (string) -> void) -> void
);

FbResultReduce(data : FbSourceData, reduceFile : bool);

filterUploadedFilesForRestrictionsBase64(
	files : [FbSourceBase64],
	managerM : Maybe<MaterialManager>,
	m2t : (Material, MFocusGroup) -> Tropic,
	onDone : (/*toUpload*/ [FbSourceBase64], /*toReduce*/ [FbSourceBase64], /*largeSize*/ [FbSourceBase64]) -> void,
	style : [FbFilterUploadDialog]
) -> void {
	data = mapi(files, \i, file -> {
		ext1 = toLowerCase(getFileExt(file.filename));
		ext = if (startsWith(ext1, ".")) strRight(ext1, 1) else ext1;

		FbSourceData(
			i,
			rtrim2(file.filename, "." + ext),
			ext,
			// we don't reduce length on amount of '=' in the base64 string
			i2d(strlen(file.contentBase64) * 3 / 4),
			\onContent, __ -> onContent(file.contentBase64)
		)
	});

	filterUploadedFilesForRestrictions(
		data, managerM, m2t,
		\res1, res2, res3 -> {
			idx1 = map(res1, \r -> r.index);
			idx2 = map(res2, \r -> r.index);
			idx3 = map(res3, \r -> r.index);

			onDone(
				filtermapi(files, \i, f -> if (contains(idx1, i)) Some(f) else None()),
				filtermapi(files, \i, f -> if (contains(idx2, i)) Some(f) else None()),
				filtermapi(files, \i, f -> if (contains(idx3, i)) Some(f) else None())
			);
		},
		style
	);
}

filterUploadedFilesForRestrictionsNative(
	files : [native],
	managerM : Maybe<MaterialManager>,
	m2t : (Material, MFocusGroup) -> Tropic,
	onDone : (/*toUpload*/ [native], /*toReduce*/ [native], /*largeSize*/ [native]) -> void,
	style : [FbFilterUploadDialog]
) -> void {
	data = mapi(files, \i, file -> {
		filename = fileNameOnly(fileNameClient(file));
		ext1 = toLowerCase(getFileExt(fileNameClient(file)));
		ext = if (startsWith(ext1, ".")) strRight(ext1, 1) else ext1;

		FbSourceData(
			i,
			rtrim2(filename, "." + ext),
			ext,
			fileSizeClient(file),
			\onContent, onError -> readFileEncClient(
				file,
				"data",
				"Win1252",
				\binaryContent -> onContent(encodeBase64(binaryContent)),
				onError
			)
		)
	});

	filterUploadedFilesForRestrictions(
		data, managerM, m2t,
		\res1, res2, res3 -> {
			idx1 = map(res1, \r -> r.index);
			idx2 = map(res2, \r -> r.index);
			idx3 = map(res3, \r -> r.index);

			onDone(
				filtermapi(files, \i, f -> if (contains(idx1, i)) Some(f) else None()),
				filtermapi(files, \i, f -> if (contains(idx2, i)) Some(f) else None()),
				filtermapi(files, \i, f -> if (contains(idx3, i)) Some(f) else None())
			);
		},
		style
	);
}

filterUploadedFilesForRestrictions(
	data : [FbSourceData],
	managerM : Maybe<MaterialManager>,
	m2t : (Material, MFocusGroup) -> Tropic,
	onDone : (normal : [FbSourceData], large : [FbSourceData], toReduce : [FbSourceData]) -> void,
	style : [FbFilterUploadDialog]
) -> void {
	maxSizeM = maybeMap(tryExtractStruct(style, FbFilterMaxSize(0)), \s -> i2d(s.size));
	maxResolutionM = maybeMap(tryExtractStruct(style, FbFilterMaxResolution(0)), \s -> s.size);
	maxBitrateM = maybeMap(tryExtractStruct(style, FbFilterMaxBitrate(0)), \s -> s.bitrate);

	defaultImageReduce = extractStruct(style, FbDefaultResolutionReduce(true)).reduce;
	defaultVideoReduce = extractStruct(style, FbDefaultBitrateReduce(true)).reduce;

	filesLargeSmall : Pair<[FbSourceData], [FbSourceData]> = eitherFn(
		maxSizeM,
		\maxSize -> partition(data, \d : FbSourceData -> d.size > maxSize),
		\-> Pair([], data)
	);

	getTitle = \isMany -> if (isMany) _("Files too large") else _("File too large");
	getText = \isMany -> if (isMany) _("The files are very large. We recommend you to reduce them.")
		else _("The file is very large. We recommend you to reduce it.");

	showDefaultDialog = \manager, closeB, title, buttons, view -> {
		renderMDialog2(
			manager,
			closeB,
			concat(
				if (title != "") [MDialogTitle(title)] else [],
				[
					MDialogUseFrame(),
					MDialogActions(buttons),
					MDialogScroll(),
					MDialogScrollStyle([TScrollCropByContent(), TExpandOnHover(true)])
				]
			),
			MAvailable(view, TFillWY(418.)),
			m2t,
			\t -> {
				trender(
					TAvailable(
						TTranslate(fif(manager.iscript.showPanel, const(Point(0.0, 48.0)), const(zeroPoint)), t),
						TIf(manager.iscript.showPanel, TSized(manager.iscript.available), TFillXY())
					)
					|> (\f ->
						materialLogFn(
							\ ->
								TFixSize(
									TLines2(
										TFixed(36., 36.),
										f
									),
									TFillXY()
								),
							MaterialWarning(),
							\ -> f
						)
					),
					manager.manager.renderStyle
				)
			}
		);
	}
	
	doStepDialog = \manager, resultNormal, resultLarge, resultImageLarge, resultVideoLarge -> {
		resultImageLargePair : [Triple<FbSourceData, DynamicBehaviour<bool>, WidthHeight>] = map(
			resultImageLarge, \r -> Triple(r.first, make(defaultImageReduce), r.second)
		);
		resultVideoLargePair : [Pair<FbSourceData, DynamicBehaviour<bool>>] = map(
			resultVideoLarge, \r -> Pair(r, make(defaultVideoReduce))
		);

		if ((resultLarge == [] && resultImageLarge == [] && resultVideoLarge == []) || !isSome(managerM)) {
			onDone(resultNormal, [], []);
		} else {
			closeB = make(false);
			isMany = (length(resultNormal) + length(resultLarge) + length(resultImageLarge) + length(resultVideoLarge)) > 1;
			title = getTitle(isMany);

			onCancelFn = \-> {
				onDone([], [], []);
				next(closeB, true);
			}

			onUploadFn = \-> {
				resultImageLarge2 = partition(resultImageLargePair, \r -> getValue(r.second));
				resultVideoLarge2 = partition(resultVideoLargePair, \r -> getValue(r.second));
				onDone(
					concat3(
						resultNormal,
						map(resultImageLarge2.second, firstOfTriple),
						map(resultVideoLarge2.second, firstOfPair)
					),
					concat(
						map(resultImageLarge2.first, firstOfTriple),
						map(resultVideoLarge2.first, firstOfPair)
					),
					resultLarge
				);
				next(closeB, true);
			}

			buttons = [
				MTextButton(_("CANCEL"), onCancelFn, [], [MShortcut("esc")]),
				MTextButton(_("UPLOAD"), onUploadFn, [MButtonRaised()], [
					MShortcut("enter"),
					MEnabled(const(resultNormal != [] || resultImageLarge != [] || resultVideoLarge != []))
				])
			];

			getExpander = \text, viewHeaderAdd, viewBody -> {
				MGroup2(
					MExpander(
						MBaselineCols([
							TFixed(8., 0.),
							MText(text, [getToolbarItemsColor(manager), MSubheading()]),
							TFixed(8., 0.),
							TFillX(),
							viewHeaderAdd
						]),
						\-> MBorder(16., 8., 8., 8., viewBody),
						make(false),
						[MWidth(416.0), getToolbarItemsColor(manager), MExpanderBackgroundStyle([MFill(getPrimaryColor(manager))], [])]
					),
					MEmpty()
				);
			}

			getFileRow = \text, viewLast -> {
				MBaselineCols([
					MGroup2(
						MEllipsisText(text, [MShowTooltip(const(true))]),
						TFillX()
					),
					TFixed(8., 0.),
					viewLast
				]);
			}

			getInfoTextView = \text, value -> [
				MText(formatString(text, [value]), [getPrimaryColor(manager)]),
				TFixed(0., 8.)
			];

			view = MLines(concatA([
				[MText(getText(isMany), [MSubheading()]), MEmpty()],
				if (resultNormal != []) [
					getExpander(
						_("Normal files"), MEmpty(),
						MLines(interleave(
							map(resultNormal, \r -> {
								getFileRow(r.name + "." + r.extension, MText(_("to upload"), [MGrey(400)]));
							}),
							TFixed(0., 8.)
						))
					)
				] else [],
				if (resultLarge != []) [
					getExpander(
						_("Extra large files"), MEmpty(),
						MLines(concat(
							eitherMap(maxSizeM, \size -> getInfoTextView(_("Allowed max file size is %1 bytes;"), d2s(size)), []),
							interleave(
								map(resultLarge, \r -> {
									getFileRow(r.name + "." + r.extension, MText(_("to skip"), [MGrey(400)]));
								}),
								TFixed(0., 8.)
							)
						))
					)
				] else [],
				if (resultImageLargePair != []) [
					getExpander(
						_("High resolution images"),
						{
							mainSwitcherB = make(defaultImageReduce);
							MConstruct(
								[makeSubscribe(mainSwitcherB, \v -> iter(resultImageLargePair, \r -> nextDistinct(r.second, v)))],
								MSwitchControl(mainSwitcherB, [getToolbarItemsColor(manager), MOnOffText(_("Reduce"), _("As is"))])
							)
						},
						MLines(concat(
							eitherMap(maxResolutionM, \res -> getInfoTextView(_("Allowed max resolution for the image is %1 x %1 pixels;"), i2s(res)), []),
							map(resultImageLargePair, \r -> {
								maxRes = max(r.third.width, r.third.height);
								k = maxRes / max(eitherMap(maxResolutionM, i2d, maxRes), 1.);
								text = formatString(_("Current imgae resolution is %1 x %2 pixels."), [i2s(trunc(r.third.width)), i2s(trunc(r.third.height))]) + "\n" +
									formatString(_("On image reducing the resolution will become %1 x %2 pixels."), [i2s(trunc(r.third.width / k)), i2s(trunc(r.third.height / k))]);
								getFileRow(
									r.first.name + "." + r.first.extension,
									MSwitchControl(r.second, [getPrimaryColor(manager), MOnOffText(_("Reduce"), _("As is")), MTooltipText(const(text))])
								)
							})
						))
					)
				] else [],
				if (resultVideoLargePair != []) [
					getExpander(
						_("High resolution videos"),
						{
							mainSwitcherB = make(defaultVideoReduce);
							MConstruct(
								[makeSubscribe(mainSwitcherB, \v -> iter(resultVideoLargePair, \r -> nextDistinct(r.second, v)))],
								MSwitchControl(mainSwitcherB, [getToolbarItemsColor(manager), MOnOffText(_("Reduce"), _("As is"))])
							)
						},
						MLines(concat(
							eitherMap(maxBitrateM, \bitrate -> getInfoTextView(_("Allowed max video bitrate is %1 kbps;"), i2s(bitrate)), []),
							map(resultVideoLargePair, \r -> {
								getFileRow(
									r.first.name + "." + r.first.extension,
									MSwitchControl(r.second, [getPrimaryColor(manager), MOnOffText(_("Reduce"), _("As is"))])
								)
							})
						))
					)
				] else []
			]) |> (\arr -> interleave(arr, TFixed(0., 8.))));

			showDefaultDialog(manager, closeB, title, buttons, view);
		}
	}

	videoExtensions = ["mp4", "webm", "m4v"];
	imageExtensions = ["swf", "png", "jpg", "jpeg", "bmp"];

	dataSplitted = fold(filesLargeSmall.second, Triple([], [], []), \acc, r -> {
		if (contains(imageExtensions, r.extension)) {
			Triple(arrayPush(acc.first, r), acc.second, acc.third);
		} else if (contains(videoExtensions, r.extension)) {
			Triple(acc.first, arrayPush(acc.second, r), acc.third);
		} else {
			Triple(acc.first, acc.second, arrayPush(acc.third, r));
		}
	});
	
	eitherFn(
		managerM,
		\manager -> {
			defaultResultFn = \-> {
				doStepDialog(manager,
					concatA([
						dataSplitted.third,
						if (defaultImageReduce && isSome(maxResolutionM)) [] else dataSplitted.first,
						if (defaultVideoReduce && isSome(maxBitrateM)) [] else dataSplitted.second
					]),
					filesLargeSmall.first,
					if (defaultImageReduce && isSome(maxResolutionM)) map(dataSplitted.first, \v -> Pair(v, WidthHeight(0., 0.))) else [],
					if (defaultVideoReduce && isSome(maxBitrateM)) dataSplitted.second else []
				);
			}

			if ((isSome(maxResolutionM) && dataSplitted.first != []) || (isSome(maxBitrateM) && dataSplitted.second != [])) {
				closeDialogB = make(false);
				imageDataMB = make(None());
				videoDataMB = make(None());
				buttons = [MTextButton(_("CANCEL"), \-> { next(closeDialogB, true); onDone([], [], []); }, [MButtonRaised()], [])];

				view = MLinesA([
					MText(_("Checking of files..."), [MTitle()]),
					TFixed(0.0, 8.0),
					MProgressBar([WidthHeight(240.0, 4.0), MProgressBackgroundColor(MGrey(400))]),
					MSelect(imageDataMB, \imageDataM -> {
						eitherMap(
							imageDataM,
							\imageData -> MPicture(imageData.first, [InspectRealSize(imageData.second), MPictureShowLoading(false), MPictureSize(const(WidthHeight(1., 1.)))]),
							MEmpty()
						)
					}),
					MSelect(videoDataMB, \videoDataM -> {
						eitherMap(
							videoDataM,
							\videoData -> {
								lengthB = make(0.);
								MConstruct(
									[makeSubscribe2(lengthB, videoData.second)],
									MVideo(
										videoData.first,
										make(WidthHeight(1., 1.)),
										[FVideoLength(lengthB), FVideoPlay(make(false)), FVideoVolume(make(0.))]
									)
								);
							},
							MEmpty()
						)
					})
				]);

				showDefaultDialog(manager, closeDialogB, "", buttons, view);

				checkImagesFn = \iData, onChecked -> mapAsync(
					iData,
					\iDataRow, ff, __ -> {
						gotWHR = ref true;
						gotWH = \wh -> {
							if (^gotWHR) {
								gotWHR := false;
								ff(Pair(iDataRow, wh));
							}
						}

						iDataRow.getContentBase64(
							\base64Content -> {
								next(
									imageDataMB, 
									Some(Pair(
										"data:image/" + iDataRow.extension + ";base64," + base64Content,
										gotWH
									))
								);
							},
							\__ -> gotWH(WidthHeight(0., 0.))
						);

						// If can't load image for a long time
						timer(5000, \-> gotWH(WidthHeight(0., 0.)));
					},
					onChecked,
					// Never should happen
					\__ -> onChecked(map(iData, \iDataRow -> Pair(iDataRow, WidthHeight(0., 0.))))
				);

				checkVideosFn = \vData, onChecked -> mapAsync(
					vData,
					\vDataRow, ff, __ -> {
						lengthDoneR = ref false;
						gotLen = \len -> {
							if (!(^lengthDoneR)) {
								lengthDoneR := true;
								len2 = if (len == 0.) 1. else len;
								ff(Pair(vDataRow, trunc(vDataRow.size * 8. / len2 / 1024. * 0.95)));
							}
						}

						vDataRow.getContentBase64(
							\base64Content -> {
								next(
									videoDataMB, 
									Some(Pair(
										"data:" + extension2mimeString("." + vDataRow.extension) + ";base64," + base64Content,
										gotLen
									))
								);
							},
							\__ -> gotLen(1.)
						);

						// If can't load image for a long time
						timer(5000, \-> gotLen(1.));
					},
					onChecked,
					// Never should happen
					\__ -> onChecked(map(vData, \vDataRow -> Pair(vDataRow, 0)))
				);

				mapiAsync(
					[maxResolutionM, maxBitrateM],
					\i, sM, ff, __ -> {
						if (i == 0) {
							eitherFn(
								sM,
								\maxResolution -> {
									checkImagesFn(dataSplitted.first, \result -> {
										normalLarge = partition(result, \r -> max(trunc(r.second.width), trunc(r.second.height)) <= maxResolution);
										ff(Pair(
											map(normalLarge.first, firstOfPair),
											normalLarge.second
										))
									})
								},
								\-> ff(Pair(dataSplitted.first, []))
							);
						} else if (i == 1) {
							eitherFn(
								sM,
								\maxBitrate -> {
									checkVideosFn(dataSplitted.second, \result -> {
										normalLarge = partition(result, \r -> r.second <= maxBitrate);
										ff(Pair(
											map(normalLarge.first, firstOfPair),
											map(normalLarge.second, \v -> Pair(v.first, WidthHeight(0., 0.)))
										))
									})
								},
								\-> ff(Pair(dataSplitted.second, []))
							);
						}
					},
					\resultA /* [Pairs([normal], [large])] */ -> {
						next(closeDialogB, true);
						doStepDialog(manager,
							concat(
								dataSplitted.third,
								mapConcat(resultA, firstOfPair)
							),
							filesLargeSmall.first,
							if (resultA != []) resultA[0].second else [],
							if (length(resultA) > 1) map(resultA[1].second, firstOfPair) else []
						);
					},
					// Never should happen
					\__ -> {
						next(closeDialogB, true);
						defaultResultFn();
					}
				)
			} else {
				defaultResultFn();
			}
		},
		\-> {
			onDone(
				concat3(
					dataSplitted.third,
					if (defaultImageReduce) [] else dataSplitted.first,
					if (defaultVideoReduce) [] else dataSplitted.second
				),
				concat(
					if (defaultImageReduce) dataSplitted.first else [],
					if (defaultVideoReduce) dataSplitted.second else []
				),
				filesLargeSmall.first
			);
		}
	);
}

checkIsDirectoryAll(engine : FilebrowserEngine<?, ??>, paths : [string], lastResult : bool, callback : (bool) -> void) -> void {
	if (paths == [] || !lastResult) {
		callback(lastResult)
	} else {
		engine.isDirectory(paths[0], \resultDir -> checkIsDirectoryAll(engine, tail(paths), lastResult && resultDir, callback), nop1 /* onError */)
	}
}

checkIsFilesAll(engine : FilebrowserEngine<?, ??>, paths : [string], lastResult : bool, callback : (bool) -> void) -> void {
	if (paths == [] || !lastResult) {
		callback(lastResult)
	} else {
		engine.fileExists(paths[0], \resultDir -> checkIsFilesAll(engine, tail(paths), lastResult && resultDir, callback), nop1 /* onError */)
	}
}

split2name_ext(filename : string) -> Pair<string, string> {
	idx = strLastIndexOf(filename, ".");

	if (idx == -1) Pair(filename, "")
	else Pair(strLeft(filename, idx), strRight(filename, idx + 1));
}

sortPairByFirst(arr : [Pair<?, ?>]) -> [Pair<?, ?>] {
	sortCustom(arr, firstOfPair, true);
}

MDialogMenuItem : (icon : string, tooltip : string, enabled : bool, onClick : () -> void);

mDialogMenuReopenInfoR : ref [() -> void] = ref [];

MDialogMenu(manager : MaterialManager, parent : MFocusGroup, items : [MDialogMenuItem], m2t : (Material, MFocusGroup) -> Tropic, clickPos : Point) -> void {
	applyall(^mDialogMenuReopenInfoR);

	menuSize = 250.;
	itemSize = 70.;
	pressedB = make(false);
	inside1B = make(false);
	insideArrB = generate(0, length(items), \__ -> make(false));

	count = (if (length(items) > 6) 6 else (length(items))) |> i2d;
	if (count > 0.0) {
		step = 360.0 / count;

		easing = makeEasing(0.6, easingStandartCurve, managerTimer(manager), nop);
		closeDialog = \-> applyall(^mDialogMenuReopenInfoR);

		MGroup2(
			MInteractive(
				[TMouseDown(pressedB)],
				TRectangle(interactiveRectangleStyle, TFillXY())
				|> (\m -> MConstruct(
					[make2Subscribe2(pressedB, fOr(inside1B, fmaxA(insideArrB, false)), \p, i -> if (!i && p) closeDialog())],
					m
				))
			),
			MIcon("touch_app", [MIconSize(40.0), MCircleBackground(MGrey(500), menuSize)])
			|> (\m -> MInteractive([TMouseInside(inside1B, true)], m))
			|> (\m -> MGroup(
				concat(
					[m],
					mapi(items, \i, item : MDialogMenuItem -> {
						radius = (menuSize - itemSize) / 2.;
						point = polarDegree2cartesian(radius - 10., i2d(i) * step - 90.0);
						MIconButton(
							item.icon,
							\-> { item.onClick(); closeDialog(); },
							[MIconSize(25.), MCircleBackground(if (item.enabled) MOrange(300) else MGrey(300), itemSize)],
							[MEnabled(const(item.enabled)), THovering(insideArrB[i])]
						)
						|> (\mi -> if (strlen(item.tooltip) > 0) MTooltip(mi, MText(item.tooltip, []), []) else mi)
						|> (\mi -> MPad(point.x + radius, point.y + radius, mi))
					})
				)
			))
			|> (\m -> MScale(ffactor2(easing.percent), m))
			|> (\m -> if (clickPos == zeroPoint) MCenter(m) else MPad(clickPos.x, clickPos.y, m))
		)
		|> MPushZorder
		|> (\m -> m2t(m, parent))
		|> (\t -> mDialogMenuReopenInfoR := [trender(t, manager.manager.renderStyle)]);

		easing.start();
	}
}

polarDegree2cartesian(radius : double, angleDegree : double) -> Point {
	x = radius * cos(angleDegree * PI / 180.);
	y = radius * sin(angleDegree * PI / 180.);

	Point(x, y);
}

validateFileName(name : string, errorB : DynamicBehaviour<Maybe<Pair<string, bool>>>, existsNames : [string], ignoreName : string) -> void {
	nextDistinct(errorB,
		if (contains(map(existsNames, toLowerCase), toLowerCase(name)) && toLowerCase(name) != toLowerCase(ignoreName)) Pair(_("Such name exists"), false) |> Some
		else None()
	)
}

validatePartitionName(name : string, errorB : DynamicBehaviour<Maybe<Pair<string, bool>>>, existsNames : [string]) -> void {
	nextDistinct(errorB,
		if (strlen(name) == 0) Pair(_("Specify the name"), false) |> Some
		else if (contains(map(existsNames, toLowerCase), toLowerCase(name))) Pair(_("Such name exists"), false) |> Some
		else None()
	)
}
