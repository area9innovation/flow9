import material/internal/material_textinput_state;
import material/internal/material_list;
import material/internal/material_button;
import material/internal/material_outline;

export {
	MTextInput2T(manager : MaterialManager, parent : MFocusGroup, m : MTextInput, m2t : (Material, MFocusGroup) -> Tropic) -> Tropic;
	MSmallEditDialog2T(manager : MaterialManager, parent : MFocusGroup, m : MSmallEditDialog, m2t : (Material, MFocusGroup) -> Tropic) -> Tropic;
	MAutoComplete2T(manager : MaterialManager, parent : MFocusGroup, m : MAutoComplete, m2t : (Material, MFocusGroup) -> Tropic) -> Tropic;
}

getInputAccessStyles(iScriptBehaviours : MTextEditorIScriptBehaviours, popup : bool) -> [MButtonState] {
	arrayPush(
		if (!iScriptBehaviours.useNativeInput) {
			[AccessRole("button")]
		} else {
			[AccessRole("")]
		},
		FAccessAttribute("aria-label", const(iScriptBehaviours.label))
	)
}

MTextInput2T(manager : MaterialManager, parent : MFocusGroup, m : MTextInput, m2t : (Material, MFocusGroup) -> Tropic) -> Tropic {
	iBehs = makeMTextEditorIScriptBehaviours(m.content, m.style, m.state);
	iBehScr : [MTextInputState] = iBehs.iScriptBehaviours;
	focusState =
		concat(
			concatStyles(m.state, concat([MRippleType(const(MNoRipple())), if (!ios() || !js) MFocusOnDown(ref true) else MKeepFocusOnDown(ref true),
				MAddFocusGroup(true), MCursorShape(const(DefaultCursor())), MFocused(iBehs.focus), MButtonTitle(const(iBehs.label))], getInputAccessStyles(iBehs, false))),
			iBehScr
		);

	MComponent2T(
		manager,
		parent,
		"MTextInput",
		focusState,
		\mfocus ->
			MTextInputField(
				manager,
				m.content,
				mfocus,
				m.style,
				m.state,
				iBehs,
				m2t
			),
		m2t
	)
	|> checkInputStatic(m.style, m.state)
}

MSmallEditDialog2T(manager : MaterialManager, parent : MFocusGroup, m : MSmallEditDialog, m2t : (Material, MFocusGroup) -> Tropic) -> Tropic {
	iBehs = makeMTextEditorIScriptBehaviours(m.content, m.style, m.state);
	iBehScr : [MTextInputState] = iBehs.iScriptBehaviours;
	focusState =
		concat(
			concatStyles(m.state, concat([MRippleType(const(MNoRipple())), MFocusOnDown(ref true), MDisableHover(),
				MAddFocusGroup(true), MCursorShape(const(DefaultCursor())), MFocused(iBehs.focus), MButtonTitle(const(iBehs.label))], getInputAccessStyles(iBehs, true))),
			iBehScr
		);

	MComponent2T(
		manager,
		parent,
		"MSmallEditDialog",
		focusState,
		\mfocus ->
			MTextInputField(
				manager,
				m.content,
				mfocus,
				replaceStructMany(m.style, [extractStruct(m.style, MElevation(const(8.))), extractStruct(m.style, MCondensed(true)), MEditDialog()]),
				m.state,
				iBehs,
				m2t,
			),
		m2t
	)
	|> checkInputStatic(m.style, m.state)
}

MAutoComplete2T(manager : MaterialManager, parent : MFocusGroup, m : MAutoComplete, m2t : (Material, MFocusGroup) -> Tropic) -> Tropic {
	iBehs = makeMTextEditorIScriptBehaviours(m.content, m.style, m.state);
	iBehScr : [MTextInputState] = iBehs.iScriptBehaviours;
	focusState =
		concat(
			concatStyles(m.state, concat([MRippleType(const(MNoRipple())), MFocusOnDown(ref true),
				MAddFocusGroup(true), MCursorShape(const(DefaultCursor())), MFocused(iBehs.focus), MButtonTitle(const(iBehs.label))], getInputAccessStyles(iBehs, true))),
			iBehScr
		);

	MComponent2T(
		manager,
		parent,
		"MAutoComplete",
		focusState,
		\mfocus ->
			MTextInputField(
				manager,
				m.content,
				mfocus,
				replaceStructMany(
					m.style,
					[
						extractStruct(m.style, MDictionary(m.dictionaries)),
						extractStruct(m.style, MElevation(const(8.))),
						extractStruct(m.style, MShowUnderline(true))
					]
				),
				m.state,
				iBehs,
				m2t
			),
		m2t
	)
	|> checkInputStatic(m.style, m.state)
}

checkInputStatic(style : [MAutoCompleteStyle], state : [MTextInputState]) -> (Tropic) -> Tropic {
	wd = extractStruct(style, MWidth(-1.)).width;
	isHgt = !contains(style, MDynamicSize()) && !contains(style, MSuggestionsSameZorderMode()) && extractStruct(style, MMaxLines(1)).lines > 0 &&
		eitherFn(tryExtractStruct(state, MInputError(const(None()), [])), \ie -> extractStruct(ie.style, MMaxLines(1)).lines > 0, \ -> true);

	if (wd != 0.) {
		if (isHgt)
			makeTropicConstant(Some(wd), None())
		else
			makeTropicConstantWidth(Some(wd))
	} else {
		if (isHgt)
			makeTropicConstantHeight(None())
		else
			idfn
	}
}

MTextInputField(manager : MaterialManager, content : DynamicBehaviour<string>, mfocus : MFocus, style : [MAutoCompleteStyle],
	state : [MTextInputState], iScriptBehaviours : MTextEditorIScriptBehaviours, m2t : (Material, MFocusGroup) -> Tropic) -> Tropic {
	inputState = makeMInputState(manager, style, state, mfocus, iScriptBehaviours);
	isRTL = inputState.parent.rtl;

	textError =
		if (isSome(inputState.helperText) || isSome(inputState.error) || isSome(inputState.limitError))
			Some(MTextInputError(inputState, m2t))
		else
			None();
	textLabel = MTextInputLabel(inputState, m2t);
	hasFloatingLabel = isSome(inputState.floatingLabel);

	addErrorText = switch (inputState.skin) {
		MTextInputPlain() : idfn;
		default : \f -> TBaselineLines([f, eitherMap(textError, \te -> TBorder(12.0, 4.0, 12.0, 0.0, te), TEmpty())]);
	}

	addMTextInputBackground = \rotateTrigger, filled -> \t -> {
		shape = (if (filled) "filled" else "outlined") + " text field";
		bs = inputState.backgroundStyle;
		
		if (bs.normal != [] || bs.focused != [])
			TCopySize(
				t,
				\tr ->
					TIfLazy2(inputState.focus, \foc -> MShape(inputState.parent, if (foc) bs.focused else bs.normal, tr, shape), true)
					|> TRotate180(rotateTrigger, tr),
				false
			)
		else
			t
	}

	addIconsAndBorders = \input -> {
		hgt = make(0.);

		TColsDir([
			eitherMap(
				makeLeftIcon(inputState),
				\leftIcon ->
					TCenterYIn(leftIcon |> TBorderEnd(12., isRTL), TSizedHeight(0., hgt)),
				TEmpty()
			),
			TAttachHeight(input |> TBorderBottom(inputState.inputBorders.bottom), hgt),
			eitherMap(
				makeRightIcons(inputState, m2t),
				\rightIcons ->
					TCenterYIn(rightIcons |> TBorderStart(12., isRTL), TSizedHeight(0., hgt)),
				TEmpty()
			)
		], isRTL)
		|> (\f2 -> TBorderDir(inputState.inputBorders.start, 0., inputState.inputBorders.end, 0., f2, isRTL));
	}

	wrapInputField = \input : Tropic ->
		TBorder(if (inputState.noLeftBorder) 8. else 0., inputState.inputBorders.top, 0., 0., input)
		|> (\f -> TGroup2(textLabel, f))
		|> (\f -> switch (inputState.skin) {
			MFilled(): {
				unfocusedColor = contrastingColor(inputState.parent);
				unfocusedOpacity = if (getLightBackground(inputState.parent)) 0.38 else 0.5;

				disabledStroke = 0.0;
				unfocusedStroke = 1.0;
				focusedStroke = 2.0;

				graphicsState =
					eitherFn(
						inputState.error,
						\errorState ->
							fselect4(inputState.mfocus.enabled, inputState.mfocus.focused, errorState.text, errorState.color, \e, fc, t, c ->
								if (!e) {
									if (inputState.width > 0.0) MGraphicsState(disabledStroke, unfocusedColor, 0.0, false)
									else MGraphicsState(disabledStroke, unfocusedColor, 1.0, false);
								} else if (isSome(t)) {
									MGraphicsState(if (fc) focusedStroke else unfocusedStroke, MThemeColor2int(inputState.parent, c), 1.0, false);
								} else if (fc) {
									MGraphicsState(focusedStroke, MColor2int(inputState.color), 1.0, true);
								}  else {
									MGraphicsState(unfocusedStroke, unfocusedColor, unfocusedOpacity, false);
								}
							),
						\ ->
							fselect2(inputState.mfocus.enabled, inputState.mfocus.focused, FLift2(\e, fc ->
								if (!e) {
									if (inputState.width > 0.0) MGraphicsState(disabledStroke, unfocusedColor, 0.0, false)
									else MGraphicsState(disabledStroke, unfocusedColor, 1.0, false);
								} else if (fc) {
									MGraphicsState(focusedStroke, MColor2int(inputState.color), 1.0, true);
								} else {
									MGraphicsState(unfocusedStroke, unfocusedColor, unfocusedOpacity, false);
								}
							))
					);

				addIconsAndBorders(f)
				|> addMFilledUnderline(
					inputState.manager,
					inputState.parent,
					graphicsState,
					eitherMap(inputState.floatingLabel, \fls -> fls.outlinedColor, make(MWhite()))
				)
				|> addMTextInputBackground(const(false), true)
			}
			MOutlined(): {
				unfocusedColor = contrastingColor(inputState.parent);
				unfocusedOpacity = if (getLightBackground(inputState.parent)) 0.38 else 0.5;

				disabledStroke = 1.0;
				unfocusedStroke = 1.0;
				focusedStroke = 2.0;

				graphicsState =
					eitherFn(
						inputState.error,
						\errorState ->
							fselect4(inputState.mfocus.enabled, inputState.mfocus.focused, errorState.text, errorState.color, \e, fc, t, c ->
								if (!e) {
									MGraphicsState(disabledStroke, unfocusedColor, unfocusedOpacity, false);
								} else if (isSome(t)) {
									MGraphicsState(if (fc) focusedStroke else unfocusedStroke, MThemeColor2int(inputState.parent, c), 1.0, false);
								} else if (fc) {
									MGraphicsState(focusedStroke, MColor2int(inputState.color), 1.0, true);
								}  else {
									MGraphicsState(unfocusedStroke, unfocusedColor, unfocusedOpacity, false);
								}
							),
						\ ->
							fselect2(inputState.mfocus.enabled, inputState.mfocus.focused, FLift2(\e, fc ->
								if (!e) {
									MGraphicsState(disabledStroke, unfocusedColor, unfocusedOpacity, false);
								} else if (fc) {
									MGraphicsState(focusedStroke, MColor2int(inputState.color), 1.0, true);
								} else {
									MGraphicsState(unfocusedStroke, unfocusedColor, unfocusedOpacity, false);
								}
							))
					);

				addIconsAndBorders(f)
				|> addMOutline(
					inputState.manager,
					inputState.parent,
					eitherMap(inputState.floatingLabel, \fls -> fls.labelWidth, const(0.0)),
					eitherMap(inputState.floatingLabel, \fls -> fls.progress, const(0.0)),
					graphicsState,
					eitherMap(inputState.floatingLabel, \fls -> fls.outlinedColor, make(MWhite()))
				)
				|> addMTextInputBackground(const(false), false)
			}
			MTextInputPlain(): {
				leftIconUnderlineEnabled = extractStruct(style, MTextInputLeftIconUnderlineEnabled(false)).enabled;
				wrapFooter = \f2 -> TBaselineLines([f2, MTextInputUnderline(inputState), either(textError, TEmpty())]);

					f
					|> (\f2 ->
						if (inputState.dynamicSize)
							eitherMap(
								inputState.floatingLabel,
								\fls ->
									TBorderT(
										const(0.),
										fif(fls.showFloatingLabel, const(inputState.inputBorders.top - inputState.inputBorders.bottom), const(0.)),
										const(0.),
										const(0.),
										f2
									),
								f2
							)
						else
							f2
					)
					|> (\f2 -> eitherMap(
						makeRightIcons(inputState, m2t),
						\rightIcons ->
							TBaselineCols2Dir(f2, rightIcons, isRTL),
						f2
					))
					|> (if (leftIconUnderlineEnabled) idfn else wrapFooter)
					|> (\f2 -> eitherMap(
						makeLeftIcons(inputState, m2t),
						\leftIcons ->
							TBaselineCols2Dir(leftIcons, f2, isRTL),
						f2
					))
					|> (if (leftIconUnderlineEnabled) wrapFooter else idfn)
					|> (\f2 -> TBorderDir(inputState.inputBorders.start, 0., inputState.inputBorders.end, 0., f2, isRTL))
					|> addMTextInputBackground(const(false), false)
			}
		})
		|> (\f2 -> MTextInputHandleKeys(manager, f2, inputState))
		|> (\f2 -> TAlpha(fif(mfocus.enabled, const(1.0),
				extractStruct(style, MCustomDisabledOpacity(const(defaultDisabledItemOpacity(getLightBackground(mfocus.parent))))).opacity
			), f2));

	textInput =
		(if (inputState.useNativeInput)
			makeNativeEditorView(manager, inputState.parent, state, inputState, m2t)
		else
			makeMTextEditorView(manager, inputState, m2t))
		|> addMAutocompleteSuggestionInLine(inputState)
		|> (\t -> TAlignStartDir(t, inputState.parent.rtl))
		|> (\f -> TCursor(DynamicCursor(inputState.cursorShape), f))
		|> wrapInputField;

	eitherFn(
		inputState.popup,
		\ps -> MTextInputWithPopup(inputState, ps, textInput, addMTextInputBackground, addErrorText, m2t),
		\ -> textInput |> addErrorText
	)
	|> (\t -> eitherMap(inputState.autocomplete, \ac -> {
		if (ac.sameZorderMode)
			TLines2Dir(t, MTextInputCompletionBox(inputState, inputState.parent, ac, None(), const(false), m2t), inputState.parent.rtl)
		else t
	}, t))
	|> (\t -> if (inputState.width > 0.) TAvailableWidth(t, const(inputState.width)) else t)
	|> (\f -> TConstruct(inputState.subs, f))
}

makeLeftIcon(inputState : MInputState) -> Maybe<Tropic> {
	iconName = inputState.startIcon.icon;

	if (iconName != "") {
		iconSize = extractStruct(inputState.startIcon.style, MIconSize(if (inputState.condensed) 20. else 24.)).size;

		Some(switch (inputState.skin) {
			MTextInputPlain(): {
				iconStyle =
					eitherFn(
						inputState.error,
						\errorState ->
							fselect4(inputState.mfocus.enabled, inputState.mfocus.focused, errorState.text, errorState.color, \e, fc, t, c ->
								if (!e) {
									[FillOpacity(1.0), MIconSize(iconSize)];
								} else if (isSome(t)) {
									[c, FillOpacity(1.0), MIconSize(iconSize)];
								} else if (fc) {
									[inputState.color, FillOpacity(1.0), MIconSize(iconSize)];
								}  else {
									[MIconSize(iconSize)];
								}
							),
						\ ->
							fselect2(inputState.mfocus.enabled, inputState.mfocus.focused, FLift2(\e, fc ->
								if (!e) {
									[FillOpacity(1.0), MIconSize(iconSize)];
								} else if (fc) {
									[inputState.color, FillOpacity(1.0), MIconSize(iconSize)];
								} else {
									[MIconSize(iconSize)];
								}
							))
					);

				TSelect(iconStyle, \st : [MIconStyle] ->
					MIcon2T(
						inputState.parent,
						if (isMaterialIcon(iconName)) iconName else "subject",
						concat(st, inputState.startIcon.style)
					)
				);
			}
			default:
				MIcon2T(
					inputState.parent,
					if (isMaterialIcon(iconName)) iconName else "subject",
					concat(
						[MIconSize(iconSize)],
						inputState.startIcon.style
					)
				);
		});
	} else {
		None();
	}
}

makeLeftIcons(inputState : MInputState, m2t : (Material, MFocusGroup) -> Tropic) -> Maybe<Tropic> {
	leftIcons = \p0 ->
		concatA([
			eitherMap(
				makeLeftIcon(inputState),
				\leftIcon ->
					[
						leftIcon
						|> (\f2 ->
							TransformTAcc2(\t2a -> {
								acc = f2 |> t2a;

								TAcc(
									FTranslate(const(16.), fnegate(acc.metrics.baseline), acc.form),
									TFormMetrics(
										const(72.),
										zero,
										zero
									),
									const(72.),
									zero,
									const(72.),
									zero,
									zero,
									zero,
									acc.addFillers,
									true,
									true,
									acc.disposers
								)
							})
						)
					]
				,
				[]
			),
			eitherMap(
				inputState.startButton,
				\startButton ->
					[
						(\p -> MIfLazy2T(
							inputState.manager,
							p,
							inputState.mfocus.focused,
							\foc, p2 ->
								if (foc)
									m2t(startButton.open, p2)
								else
									m2t(startButton.closed, p2),
							false
						)
						|> (\f2 -> TBorder4(inputState.iconBorders, f2))
						|> (\f2 -> if (startButton.useOverlay) {
							buttonAlpha = make(1.);

							TCopySize(
								TAlpha(buttonAlpha, f2),
								\tr ->
									MComponent2T(
										inputState.manager,
										p,
										"MTextInputStartButton",
										[
											MRippleType(const(MRippleCenter())),
											MOnClick(
												\ ->
													if (fgetValue(inputState.mfocus.focused))
														inputState.goToPrev()
													else
														nextDistinct(inputState.mfocus.focused, true)
											),
											MPassClicks()
										],
										\foc ->
											TConstruct(
												[
													makeSubscribe(foc.enabled, \en ->
														nextDistinct(
															buttonAlpha,
															if (en) 1. else if (getLightBackground(inputState.parent)) 0.7 else 0.5
														)
													)
												],
												tr
											),
										m2t
									),
								true
							)
						} else f2)
						|> (\f2 ->
							TransformTAcc2(\t2a -> {
								acc = f2 |> t2a;

								dx = make(0.);

								TAcc(
									FConstructor(
										FTranslate(dx, zero, acc.form),
										make2Subscribe(acc.metrics.width, startButton.inputIndent, \wd, ii -> nextDistinct(dx, if (p.rtl) max(0.0, ii - wd) else min(0.0, ii - wd))),
									),
									TFormMetrics(
										startButton.inputIndent,
										zero,
										fselect(acc.metrics.height, FLift(\hgt -> hgt * 0.72 - inputState.iconBorders * 0.375))
									),
									startButton.inputIndent,
									zero,
									startButton.inputIndent,
									zero,
									zero,
									zero,
									acc.addFillers,
									true,
									acc.yConstant,
									acc.disposers
								)
							})
						))
						|> (\f2 ->
							if (startButton.open == TEmpty() || startButton.closed == TEmpty())
								MShowPreRender2T(
									inputState.manager,
									p0,
									fselect(
										inputState.mfocus.focused,
										FLift(\foc -> (foc && startButton.open != TEmpty()) || (!foc && startButton.closed != TEmpty()))
									),
									f2
								)
							else
								f2(p0)
						)
					],
				[]
			)
		]);

	if (inputState.startIcon.icon == "" && isNone(inputState.startButton))
		None()
	else
		Some(MComponentGroup2T(
			inputState.manager,
			inputState.parent,
			"MTextInputLeftIcons",
			[MEnabled(inputState.mfocus.enabled), MFocusEnabled(const(false))],
			\p -> TBaselineColsDir(leftIcons(p), p.rtl)
		));
}

makeRightIcons(inputState : MInputState, m2t : (Material, MFocusGroup) -> Tropic) -> Maybe<Tropic> {
	rightIcons = \p0 ->
		switch (inputState.skin) {
			MTextInputPlain():
				concatA([
					eitherMap(
						inputState.endCustomButton,
						\rightCustomButton ->
							[
								m2t(MTransformTAcc2(\t2a -> {
									b = t2a(rightCustomButton);
									TAcc(b with metrics = TFormMetrics(b.metrics with height = zero))
								}), p0)
							],
						[]
					),
					eitherMap(
						inputState.editIcon,
						\showEditIcon ->
							[
								(\p ->
									MIconButton2T(
										inputState.manager,
										p,
										MIconButton(
											"create",
											\ -> nextDistinct(inputState.mfocus.focused, true),
											[

												MIconSize(inputState.iconSize - 4.),
												MIconButtonBorder(inputState.iconBorders + 2.)
											],
											[]
										),
										m2t
									)
									|> (\f2 ->
										TransformTAcc2(\t2a -> {
											acc = f2 |> t2a;

											wd = inputState.iconSize + inputState.iconBorders;

											TAcc(
												FTranslate(const(-inputState.iconBorders / 2.), fnegate(acc.metrics.baseline), acc.form),
												TFormMetrics(
													const(wd),
													zero,
													zero
												),
												const(wd),
												zero,
												const(wd),
												zero,
												zero,
												zero,
												acc.addFillers,
												true,
												true,
												acc.disposers
											)
										})
									)
								)
								|> (\f2 -> MShow2T(inputState.manager, p0, showEditIcon, f2))
							],
						[]
					),
					eitherMap(
						inputState.endButton,
						\rightButton ->
							[
								MSelect2T(
									inputState.manager,
									p0,
									"MTextInputRightButton",
									[],
									rightButton,
									\ic, p ->
										if (ic == "")
											TEmpty()
										else {
											pressed = make(false);

											onClick =
												\ ->
													if (ic == "clear")
														inputState.clearContent()
													else if (ic == "arrow_drop_down")
														nextDistinct(inputState.mfocus.focused, true)
													else
														nextDistinct(inputState.mfocus.focused, false);

											(if (ic == "clear")
												TBorder4(
													inputState.iconBorders/4.0,
													MIconButton2T(
														inputState.manager,
														p,
														MIconButton(
															ic,
															onClick,
															[
																MIconSize(inputState.iconSize / 2.),
																MIconButtonBorder(0.),
																MCircleBackground(MGrey(400), inputState.iconSize /1.3)
															],
															[TPressed(pressed), MPassClicks()]
														),
														m2t
													)
												)
											else
												MIconButton2T(
													inputState.manager,
													p,
													MIconButton(
														ic,
														onClick,
														[
															MIconSize(inputState.iconSize),
															MIconButtonBorder(inputState.iconBorders)
														],
														[TPressed(pressed), MPassClicks()]
													),
													m2t
												)
											)
											|> (\f2 ->
												TConstruct(
													[
														makeSubscribe2(pressed, \pr -> if (pr) {
															setDownInsideFocus(inputState.manager, inputState.mfocus);
														})
													],
													f2
												)
											)
											|> (\f2 ->
												TransformTAcc2(\t2a -> {
													acc = f2 |> t2a;
													wd = inputState.iconSize + inputState.iconBorders;

													TAcc(
														FTranslate(
															const(if (ic == "clear") inputState.iconBorders / 2. else -inputState.iconBorders / 2.),
															if (ic == "clear") const(-inputState.iconBorders / 4.) else zero,
															acc.form
														),
														TFormMetrics(
															const(wd),
															zero,
															if (ic == "clear") acc.metrics.baseline else fselect(acc.metrics.height, FLift(\hgt -> hgt * 0.72 - inputState.iconBorders * 0.375))
														),
														const(wd),
														zero,
														const(wd),
														zero,
														zero,
														zero,
														acc.addFillers,
														true,
														true,
														acc.disposers
													)
												})
											)
										}
								)
							]
						,
						[]
					),
					eitherMap(
						inputState.password,
						\ps ->
							[
								MSelect2T(
									inputState.manager,
									p0,
									"MTextInputVisibilityButton",
									[],
									ps.style,
									\col : [MIconStyle], p ->
										MIconToggle2T(
											inputState.manager,
											p,
											MIconToggle(
												"visibility",
												[
													MIconButtonBorder(inputState.iconBorders),
													MIconSize(inputState.iconSize),
													MToggleFalseIcon("visibility_off", [MIconSize(inputState.iconSize)] |> (\f -> concat(f, col)))
												]
												|> (\f -> concat(f, col)),
												[
													MPassClicks(),
													MFocusEnabled(const(false)),
													MToggleValue(ps.showPassword)
												]
											),
											m2t
										)
								)
								|> (\f2 ->
									TransformTAcc2(\t2a -> {
										acc = f2 |> t2a;

										wd = inputState.iconSize + inputState.iconBorders;

										TAcc(
											FTranslate(const(-inputState.iconBorders / 2.), fnegate(acc.metrics.baseline), acc.form),
											TFormMetrics(
												const(wd),
												zero,
												zero
											),
											const(wd),
											zero,
											const(wd),
											zero,
											zero,
											zero,
											acc.addFillers,
											true,
											true,
											acc.disposers
										)
									})
								)
							],
						[]
					)
				]);
			default: {
				concatA([
					eitherMap(
						inputState.endButton,
						\rightButton ->
							[
								MSelect2T(
									inputState.manager,
									p0,
									"MTextInputRightButton",
									[],
									rightButton,
									\ic, p ->
										if (ic == "")
											TEmpty()
										else {
											(if (ic == "clear")
												MIconButton2T(
													inputState.manager,
													p,
													MIconButton(
														"cancel",
														\ -> inputState.clearContent(),
														[
															MIconSize(inputState.iconSize),
															MIconButtonBorder(0.)
														],
														[MPassClicks(), MRippleType(const(MNoRipple()))]
													),
													m2t
												)
											else
												MIcon2T(
													p,
													ic,
													[
														MIconSize(inputState.iconSize)
													]
												)
											)
										}
								)
							]
						,
						[]
					),
					eitherMap(
						inputState.password,
						\ps ->
							[
								MSelect2T(
									inputState.manager,
									p0,
									"MTextInputVisibilityButton",
									[],
									ps.style,
									\col : [MIconStyle], p ->
										MIconToggle2T(
											inputState.manager,
											p,
											MIconToggle(
												"visibility",
												[
													MIconButtonBorder(inputState.iconBorders),
													MIconSize(inputState.iconSize),
													MToggleFalseIcon("visibility_off", [MIconSize(inputState.iconSize)] |> (\f -> concat(f, col)))
												]
												|> (\f -> concat(f, col)),
												[
													MPassClicks(),
													MFocusEnabled(const(false)),
													MToggleValue(ps.showPassword)
												]
											),
											m2t
										)
								)
							],
						[]
					)
				]);
			}
		}

	if (isNone(inputState.editIcon) && isNone(inputState.endButton) && isNone(inputState.endCustomButton) && isNone(inputState.password))
		None()
	else
		Some(MComponentGroup2T(
			inputState.manager,
			inputState.parent,
			"MTextInputRightIcons",
			[MEnabled(inputState.mfocus.enabled), MFocusEnabled(const(false))],
			\p -> TBaselineColsDir(rightIcons(p), p.rtl)
		));
}

MTextInputWithPopup(inputState : MInputState, popupState : MInputPopupState, textInput : Tropic,
	addMTextInputBackground : (Transform<bool>, bool) -> (Tropic) -> Tropic, addErrorText : (Tropic) -> Tropic, m2t : (Material, MFocusGroup) -> Tropic) -> Tropic {

	isTextInputInPopup = eitherMap(inputState.autocomplete, \ac -> ac.isTextInputInPopup, true);

	lineHeight =
		eitherMap(inputState.autocomplete, \ac ->
			getTWordMetrics(
				m2t(
					ac.completionFn.fn(
						SentenceHit(
							SentenceMatcher([], makeTrie(), makeTree(), makeTree(), makeTree(),),
							"111",
							0.,
							makeSet()
						),
						false,
						nop1
					),
					inputState.parent
				),
				makeTree()
			).height,
			0.
		);
	inputHgt = make(0.);
	popupMaxSize = makeWH();

	directionChangeLinesThreshold = 2;
	directionChangeThreshold = i2d(directionChangeLinesThreshold) * lineHeight;

	placementType = eitherMap(inputState.autocomplete, \ac -> ac.placementType, MBottom());
	onTop =
		switch (placementType : MSuggestionsPlacementType) {
			MTop() : const(true);
			MBottom() : const(false);
			MTryTopFirst() : fselect(popupState.positionScale, FLift(\ps : PositionScale -> ps.pos.y > directionChangeThreshold));
			MTryBottomFirst() :
				fselect3(popupState.positionScale, fheight(popupState.inputWH), fheight(inputState.manager.stageWH), \ps, iH, sH ->
					sH - iH - ps.pos.y < directionChangeThreshold
				);
		}

	popupItems =
		eitherMap(
			inputState.autocomplete,
			\ac -> if (eitherMap(ac.inLine, \inline -> inline.showPopup, true)) {
				(\p -> {
					maxHeight =
						fselect3(
							if (inputState.maxHeight > 0.) const(inputState.maxHeight) else fheight(inputState.manager.stageWH),
							fheight(popupMaxSize),
							inputHgt,
							\maxH, pH, iH -> {
								a = if (pH - 2. - iH > 0.) pH else maxH;
								a - 2. - iH
							}
						);

					MTextInputCompletionBox(inputState, p, ac, Some(maxHeight), onTop, m2t)
					|> (\f ->
						TConstruct(
							[
								makeSubscribe(ac.selected, \sel -> {
									if (sel >= 0) {
										scrollHeight = max(0., getValue(popupState.contentWH).height - getValue(popupState.boxWH).height);

										if (scrollHeight > 0.) {
											minSelHeight = max(0., lineHeight * i2d(max(sel, 0)));
											maxSelHeight = max(0., minSelHeight + lineHeight - getValue(popupState.boxWH).height);

											if (getValue(popupState.scrollPosition).y < maxSelHeight) {
												next(popupState.scrollPosition, Point(0., maxSelHeight))
											} else if (getValue(popupState.scrollPosition).y > minSelHeight) {
												next(popupState.scrollPosition, Point(0., minSelHeight))
											}
										} else {
											nextDistinct(popupState.scrollPosition, zeroPoint)
										}
									} else {
										nextDistinct(popupState.scrollPosition, zeroPoint)
									}
								})
							],
							f
						)
					)
				})
				|> (\f -> {
					showProgress = eitherMap(ac.autoCompleteAsync, \async -> fgreateri(async.currentRequests, const(0)), const(false));
					[
						\p -> TShowLazy(fneq(ac.sentences, []), \ -> m2t(MSeparator(true), p)),
						\p -> TShow(fnot(showProgress), f(p)),
						\p -> TShow(showProgress, TCenterIn(
							MProgressCircle2T(inputState.manager, p, MProgressCircle([MSecondaryColor()])),
							TFillXH(100.)
						))
					]
				})
				|> (\f -> 
						eitherMap(ac.showMoreResults, \results ->
							arrayPush(f, \p -> {
								onClick = \ -> {prev = getValue(results); nextDistinct(results, Pair(prev.first + ac.maxResults, prev.second))};
								TShow(fselect(results, FLift(\res : Pair -> res.first <= res.second)), 
									MTextButton2T(inputState.manager, p, MTextButton("SHOW MORE", onClick, [MFullWidth(), MButtonRaised()], []), m2t)
								)
							}),
							f
						)
				)
			}
			else [],
			[]
		);

	textInputClip = ref TEmpty();

	content =
		TMoveClip(textInput, None(), \ti -> textInputClip := ti)
		|> (\t -> TAttachHeight(t, inputHgt))
		|> addMTextInputBackground(onTop, false)
		|> addErrorText;

	offsetX =
		either(
			popupState.customMetrics.offsetX,
			if (inputState.smallEdit) const(-24.)
			else if (isTextInputInPopup) const(0.)
			else eitherMap(inputState.startButton, \lb -> lb.inputIndent, const(0.))
		);
	offsetY =
		either(
			popupState.customMetrics.offsetY,
			const(if (inputState.smallEdit) -8. else 0.)
		);

	showPopup = eitherMap(inputState.autocomplete, \ac ->
		if (ac.isTextInputInPopup) const(true)
		else fgreateri(flength(ac.sentences), const(0)),
		const(true)
	);

	TConstruct(
		[
			makeSubscribe2(onTop, \__ ->
				if (fgetValue(popupState.openMenu.opened)) {
					nextDistinct(popupState.openMenu.opened, false);
					nextDistinct(popupState.openMenu.opened, true);
					nextDistinct(inputState.mfocus.focused, true);
			}),
			make2Subscribe(popupState.openMenu.opened, showPopup, \op, show ->
				if (op && show) {
					ontop = fgetValue(onTop);
					RenderMPopup(
						inputState.manager,
						inputState.parent,
						MPopup(
							[
								if (isTextInputInPopup)
									[[
										^textInputClip
										|> (if (inputState.smallEdit) MBorderLeftRight(24.) else idfn)
									]]
								else
									[[TFixed(0., 0.01)]], // workaround for non-visible separator bug
								map(popupItems, \it -> [MGetFocusGroup(it)])
								|> (if (ontop) reverseA else idfn)
							]
							|> (if (ontop) reverseA else idfn)
							|> concatA,
							popupState.positionScale,
							[
								popupState.openMenu,
								RMWidth(
									either(
										popupState.customMetrics.width,
										fselect2(popupState.inputWH, offsetX, FLift2(\bwh, ox -> bwh.width + (if (inputState.smallEdit) 48. else 0.) - ox))
									)
								),
								MSameZorder(true),
								RMBorders(if (inputState.smallEdit) 8. else 0.),
								RMClickOutToClose(),
								RMSameFocus(inputState.mfocus),
								MElevation(popupState.elevation),
								RMOffset(fpair(
									fwh(offsetX, offsetY),
									fif(
										feq(onTop, isTextInputInPopup),
										fheight(popupState.inputWH),
										zero
									)
								)),
								RMHeight(0., inputState.maxHeight),
								MFixPosition(!ontop),
								TScrollWidthHeight(popupState.contentWH, popupState.boxWH),
								MBackgroundStyle(inputState.backgroundStyle.focused),
								MRippleShape("MMenu"),
								MActive(make(true)),
								MFocusOnPrevious(false),
								RMCurrentMaxSize(popupMaxSize)
							]
							|> (\arr ->
								if (popupItems != [])
									concat(arr, [
										if (ontop) RMScrollArea(0, 1) else RMScrollArea(2, 3),
										MScrollPosition(popupState.scrollPosition)
									])
								else arr
							)
							|> (\arr -> eitherMap(popupState.outterBorder, \ob -> arrayPush(arr, ob), arr)),
						),
						m2t
					)
			} else {
				nextDistinct(popupState.openMenu.opened, false)
			}),
			\ -> \ -> next(popupState.openMenu.opened, false)
		],
		content
		|> (\f -> MPositionScaleAttachBox(popupState.positionScale, popupState.inputWH, f, popupState.openMenu.opened))
	)
}

MTextInputError(inputState : MInputState, m2t : (Material, MFocusGroup) -> Tropic) -> Tropic {
	isRTL = inputState.parent.rtl;
	helperText =
		eitherFn(
			inputState.helperText,
			\hs ->
				\ -> TSelect(hs.helper, \ht : Pair<string, [MTextStyle]> -> {
					if (ht.first == "")
						TFillX()
					else
						(if (hs.height <= 0.)
							MDynamicParagraph2T(inputState.parent, const(ht.first), concat(ht.second, [MWidth(-1.)]))
						else
							MEllipsisText2T(
								inputState.manager,
								inputState.parent,
								MEllipsisText(
									ht.first,
									concat(ht.second, [MMaxLines(hs.lines), MShowTooltip(const(true))])
								),
								m2t
							)
						)
						|> (\t -> TAlignStartDir(t, isRTL))
						|> (\f -> if (inputState.dynamicSize || hs.height <= 0.) f else TFixSize(f, TFillXH(hs.height)))
				}),
			\ -> if (isSome(inputState.limitError))
				\ -> TFillX()
			else
				\ -> TEmpty()
		);

	TCols2Dir(
		eitherFn(
			inputState.error,
			\es ->
				TSelect(es.error, \et : Pair<string, [MTextStyle]> -> {
					if (et.first == "")
						helperText()
					else
						(if (es.height(inputState.parent) <= 0.)
							MDynamicParagraph2T(inputState.parent, const(et.first), concat(et.second, [MWidth(-1.)]))
						else
							MEllipsisText2T(
								inputState.manager,
								inputState.parent,
								MEllipsisText(
									et.first,
									concat(et.second, [MMaxLines(es.lines), MShowTooltip(const(true))])
								),
								m2t
							)
						)
						|> (\f -> if (et.first == " ") TGroup2(f, helperText()) else f)
						|> (\t -> TAlignStartDir(t, isRTL))
						|> (\f -> if (inputState.dynamicSize || es.height(inputState.parent) <= 0.) TBorderDir(0., 0., 0., 4., f, isRTL) else TFixSize(f, TFillXH(es.height(inputState.parent))))
				}),
			helperText
		),
		eitherFn(
			inputState.limitError,
			\le ->
				TSelect(le.limit, \let ->
					if (let.first == "")
						TEmpty()
					else
						MText2T(
							inputState.parent,
							let.first,
							let.second
						)
						|> (\f2 ->
							TransformTAcc2(\t2a -> {
								acc = f2 |> t2a;

								TAcc(
									acc.form,
									TFormMetrics(
										acc.metrics.width,
										if (inputState.dynamicSize && le.height > 0.) const(le.height) else acc.metrics.height,
										zero
									),
									acc.metrics.width,
									if (inputState.dynamicSize && le.height > 0.) const(le.height) else acc.metrics.height,
									acc.metrics.width,
									if (inputState.dynamicSize && le.height > 0.) const(le.height) else acc.metrics.height,
									zero,
									zero,
									acc.addFillers,
									true,
									true,
									acc.disposers
								)
							})
						)
				),
			\ -> TEmpty()
		),
		isRTL
	)
	|> (\f2 ->
		TransformTAcc2(\t2a -> {
			acc = f2 |> t2a;

			TAcc(
				acc.form,
				TFormMetrics(
					zero,
					acc.metrics.height,
					acc.metrics.baseline
				),
				zero,
				acc.minHeight,
				zero,
				acc.maxHeight,
				zero,
				if (inputState.dynamicSize && !acc.yConstant)
					const(1.)
				else
					acc.yFillers,
				acc.addFillers,
				true,
				acc.yConstant,
				acc.disposers
			)
		})
	)
}

MTextInputLabel(inputState : MInputState, m2t : (Material, MFocusGroup) -> Tropic) -> Tropic {
	label2T = \labelStyleT ->
		TSelect(labelStyleT, \labelStyle ->
			MEllipsisText2T(
				inputState.manager,
				inputState.parent,
				MEllipsisText(
					eitherMap(
						inputState.error,
						\es -> inputState.label + if (es.requiredField) " *" else "",
						inputState.label
					),
					labelStyle
					|> MCharacterStyle2MTextStyle
				),
				m2t
			)
		);

	eitherFn(
		inputState.floatingLabel,
		\fls : MInputFloatingLabelState -> {
			xOffset =
				if (inputState.startIcon.icon == "" || inputState.skin != MOutlined()) 0.0
				else if (inputState.condensed) -32.0
				else -36.0;

			if (inputState.skin == MOutlined() || inputState.skin == MFilled()) {
				themeColor : Transform<MThemeColor> = fls.outlinedColor;
				makeMFloatingLabel(
					inputState.manager,
					inputState.parent,
					inputState.label,
					MFloatingLabelState(
						fls.progress,
						fls.showFloatingLabel,
						fls.labelSizeFocused,
						fls.labelSize,
						xOffset,
						-xOffset,
						fls.aboveLabel,
						fls.betweenLabels + fls.labelSizeFocused
					),
					inputState.labelStyle,
					Some(MDynamicColor(themeColor)),
					fls.labelWidth,
					m2t
				)
			} else {
				percent = fls.progress;

				styleChanged : Transform<[CharacterStyle]> = fselect2(percent, inputState.labelStyle, FLift2(\prc, labelStyle ->
					replaceStructMany(
						labelStyle,
						[
							FontSize(lerp(fls.labelSizeFocused, fls.labelSize, prc))
						]
					)
				));

				MEasingAnimation(
					inputState.manager,
					inputState.parent,
					const(easingTransitionDuration),
					const(easingStandartCurve),
					fls.showFloatingLabel,
					\showLabel -> {
						perc = getValue(percent);

						if ((showLabel && perc == 0.) || (!showLabel && perc == 1.))
							None()
						else
							Some(showLabel)
					},
					\showLabel, val -> next(percent, if (showLabel) 1. - val else val),
					[MAutoStart()],
					label2T(styleChanged)
					|> (\t -> TBorderT(
						if (xOffset == 0.0) zero else fmultiply(fsubtract(const(1.0), percent), const(xOffset)),
						faddition(fmultiply(percent, const(fls.betweenLabels + fls.labelSizeFocused)), const(fls.aboveLabel)),
						zero,
						zero,
						t
					))
				)
			}
		},
		\ ->
			TShowLazy(
				feq(inputState.content, ""),
				\ -> label2T(inputState.labelStyle)
			)
			|> (\t -> TBorder(0., inputState.inputBorders.top, 0., 0., t))
	)
	|> (\f -> // TODO : TAlignHorizontal
		if (inputState.align == AutoAlignCenter())
			TCenterXIn(f, TFillXY())
		else if ((inputState.align == AutoAlignRight()) != inputState.parent.rtl)
			TTweak([TAlign(const(1.), zero)], f, TFillXY())
		else
			f
	)
	|> (\f -> TFixSize(f, TEmpty()))
}

MTextInputUnderline(inputState : MInputState) -> Tropic {
	area = TFillXH(2.);

	eitherFn(
		inputState.underline,
		\us ->
			TSelect(
				us,
				\pr ->
					if (pr.second == 0.)
						TAttach(area, \wh ->
							TDynamicGraphics(
								fselect(wh.width, FLift(\wd -> 
									generate(0, floor(wd / 4.0), \i ->
										[MoveTo(i2d(i) * 4.0, 0.0), LineTo(i2d(i) * 4.0 + 1.0, 0.0)]
									) |> concatA
								)),
								const(pr.first)
							)
						)
						|> (\f -> TCenterYIn(f, TFillXH(2.)))
					else
						TRectangle(pr.first, TFillXH(pr.second))
						|> (\f -> TBorder(0., 1. - pr.second / 2., 0., 1. - pr.second / 2., f))
			),
		\ -> area
	)
	|> (\f -> TFixSize(f, area))
	|> (\f ->
		TBorder(
			0.,
			forceRange(inputState.inputBorders.bottom - 2., 0., 7.),
			0.,
			max(inputState.inputBorders.bottom - 9., 0.),
			f
		)
	)
}

MTextInputHandleKeys(manager : MaterialManager, textInput : Tropic, inputState : MInputState) -> Tropic {
	focus = eitherMap(inputState.popup, \ps -> ps.openMenu.opened, inputState.mfocus.focused);

	(if (!mobile) {
		handleDownKeys = \handled : bool, k : KeyEvent -> {
			if (fgetValue(inputState.mfocus.focused) && !handled && eitherMap(inputState.processedKeyDown, \pk -> pk.fn(k), true)) {
				if (k.keycode == KEY_UP) { // up
					maybeApply(
						inputState.autocomplete,
						\ac -> {
							sm = getValue(ac.selected);
							ln = length(getValue(ac.sentences));

							nextDistinct(ac.selected, if (ln > 0) {if (sm > 0) sm - 1 else ln + sm - 1} % ln else -1);
						}
					);
				} else if (k.keycode == KEY_DOWN) { // down
					maybeApply(
						inputState.autocomplete,
						\ac -> {
							sm = getValue(ac.selected);
							ln = length(getValue(ac.sentences));

							nextDistinct(ac.selected, if (ln > 0) (sm + 1) % ln else -1);
						}
					);
				} else if (k.keycode == KEY_ESCAPE) { // esc
					inputState.goToPrev();
				} else if ((k.keycode == KEY_TAB || k.keycode == 16777218 /* shift + tab */) && inputState.useNativeInput &&
					fgetValue(inputState.mfocus.focused) && !inputState.multiline &&
					!fgetValue(extractStruct(manager.style, MFocusEnabled(const(true))).enabled) && !js) { // tab
					nextDistinct(inputState.mfocus.focused, false);
				} else if (k.keycode == KEY_ENTER && (!inputState.multiline || k.shift) && eitherMap(inputState.autocomplete, \ac -> getValue(ac.selected) < 0, true)) { // enter
					maybeApply(
						inputState.autocomplete,
						\ac -> {
							maybeApply(ac.inLine, \inline ->
								maybeApply(fgetValue(inline.bestSuggestion), \best ->
									ac.setWord(best.first)
								)
							)
						}
					);

					inputState.filterAction(getValue(inputState.content));

					if (getValue(inputState.mfocus.focused)) {
							next(inputState.mfocus.focused, false);
					}
				};
				inputState.useNativeInput && inputState.eatKeyDown(k);
			} else
				handled
		}
		TCopySize(
			textInput,
			\tr -> {
				uns = ref nop;
				fcFn = \fc -> {
					dispUns(uns);

					if (fc)
						uns := interruptibleTimer(10, \ -> {
							dispUns(uns);
							uns := trender(TInteractive([KeyDown2(handleDownKeys)],
								TRectangle(interactiveRectangleStyle, TGroup2(TFillXY(), tr))), inputState.manager.manager.renderStyle);
						});
				};

				TConstruct(
					[
						makeSubscribe(focus, fcFn),
						\ -> onFullWindow(\fw -> if (fw && getValue(focus)) {
							fcFn(false);
							fcFn(true);
						}),
						\ -> \ -> dispUns(uns)
					],
					tr
				)
			},
			true
		)
	} else {
		textInput
	})
}

MTextInputCompletionBox(
	inputState : MInputState,
	p : MFocusGroup,
	ac : MInputAutocompleteState,
	maxHeight : Maybe<Transform<double>>,
	onTop : Transform<bool>,
	m2t : (Material, MFocusGroup) -> Tropic) -> Tropic {

	items = fselect(ac.sentences, FLift(\compl -> {
		next(ac.selected, -1);

		res = mapi(compl, \i, com ->
			MIfLazy2T(
				inputState.manager,
				p,
				feq(ac.selected, i),
				\sel, p3 ->
					m2t(
						ac.completionFn.fn(
							com,
							sel,
							\w -> {
								ac.setWord(w.sentence);
								inputState.filterAction(getValue(inputState.content));
							}
						),
						p3
					),
				false
			)
		);

		if (ac.autoSelect && length(res) > 0)
			next(ac.selected, 0);

		res
	}));

	lines =
		if (ac.dynListMode) {
			contentWH = makeWH();
			maximumHeight = either(maxHeight,
				if (inputState.maxHeight > 0.) const(inputState.maxHeight) else fheight(inputState.manager.stageWH)
			);

			avHeigth =
				fif(
					feq(flength(items), 0),
					const(0.),
					fselect2(fheight(contentWH), maximumHeight, FLift2(\cH, maxH ->
						if (cH > 0.) min(cH, maxH) else maxH
					))
				);

			MDynamicList2T(
				inputState.manager,
				p,
				MDynamicList(
					fselect(items, FLift(\itms -> map(itms, \it -> MCustomLine(it, [])))),
					[MSideBorders(const(0.))],
					[
						MItemsHeights(\__ -> fselectLift(inputState.tTextMetrics, \tm -> completionLineHeight(tm, inputState.inputBorders))),
						MScrollWidthHeight(contentWH, makeWH()),
						MHoverEnabled(const(false)),
					]
				),
				m2t
			)
			|> (\t -> TAvailableHeightPreventFillers(t, avHeigth))
		} else 
			MSelect2T(inputState.manager, p, "MTextInputCompletionItems", [MFocusEnabled(const(false))], items, \itms, p2 -> TLines(itms));
	
	popupDownFnUns = initUnsM();
	
	TCopySize2(lines, \sz, tr ->
		TGroup([
			MShape(p, ac.fill, sz, "MAutoComplete") |> TRotate180(fnot(onTop), sz),
			tr,
			TInteractive([MouseDown2(\h, mi : MouseDownInfo -> {
				if (mi.inside()) {
					setDownInsideFocusTimer(inputState.manager, inputState.mfocus, popupDownFnUns)
				}

				h
			})], sz)
		])
	)
	|> (\t -> TShow(inputState.focus, t))
}
