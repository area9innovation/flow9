import material/internal/material_textinput;

export {
	MSlider2T(manager : MaterialManager, parent : MFocusGroup, m : MSlider, m2t : (Material, MFocusGroup) -> Tropic) -> Tropic;
}

MSliderThumb(
	percent : DynamicBehaviour<double>,
	active : DynamicBehaviour<bool>,
	restrictPercent : (double) -> double,
	isStart : bool
);

MSlider2T(manager : MaterialManager, parent : MFocusGroup, m : MSlider, m2t : (Material, MFocusGroup) -> Tropic) -> Tropic {
	sliderId = makeTropicTag(manager);
	color : MColor = extractMColor(parent, m.style, MAccentColor());
	itemsColor = tryExtractStruct(m.style, MItemsColor(MWhite()));
	iconLeft = extractStruct(m.style, MSliderIconLeft("")).name;
	iconRight = extractStruct(m.style, MSliderIconRight("")).name;
	sliderRange = extractStruct(m.style, MSliderRange(0., 1.));
	sliderStep = extractStruct(m.style, MSliderStep(-1.)).value;
	sliderSteps = extractStruct(m.style, MSliderSteps([])).steps;
	showValue = extractStruct(m.style, MSliderDisplayValue(false)).display;
	valueEnabled = extractStruct(m.style, MSliderDisplayValueEnabled(const(true))).enabled;
	isDiscrete = contains(m.style, MSliderDiscrete());
	showDiscreteValues = tryExtractStruct(m.style, MSliderShowDiscreteValues(const(false)));
	mWidth = extractStruct(m.style, MWidth(-1.)).width;
	fullWidth = mWidth < 0.;
	enabled = fand(parent.enabled, extractStruct(m.style, MEnabled(const(true))).enabled);
	chooseRange = tryExtractStruct(m.style, MSliderChooseRange(make(0.), make(0.)));
	sliderUndefinedM : Maybe<MSliderUndefined> = tryExtractStruct(m.style, MSliderUndefined(make(true)));
	outlineOnMinimum = extractStruct(m.style, MOutlineOnMinimum(isNone(chooseRange))).outline;
	maximizeOnHover = extractStruct(m.style, MMaximizeOnHover(true)).maximize;
	condensed = extractStruct(m.style, MCondensed(false)).condensed;
	downAnywhere = extractStruct(m.style, MMouseDown(make(false))).down;
	down2 = fand(downAnywhere, enabled);
	sliderTooltip = tryExtractStruct(m.style, MSliderTooltip(\__ -> ""));
	mousePosition : MMousePosition = extractStruct(m.style, MMousePosition(make(zeroPoint)));
	point = mousePosition.point;
	noRipple = !contains(m.style, MSliderRipple());
	enableArrows = contains(m.style, MSliderEnableArrows());

	isRTL = parent.rtl;
	lightBackground = getLightBackground(parent);

	minMax = sliderRange.max - sliderRange.min;
	stepPercent = if (sliderStep >= 0.) sliderStep / minMax else 0.01;

	sliderWidth = make(mWidth);
	percent = make(0.);
	editString = make("");
	drag = ref false;
	tooltipText = make("");
	cursorPercent = fdivide(fpointX(point), sliderWidth) |> (\p -> if (isRTL) fsubtract(const(1.), p) else p);

	percent2value = \p -> sliderRange.min + p * minMax;
	percent2strvalue = \p -> d2st(percent2value(p), 2);
	value2percent = if (minMax != 0.) \v -> (v - sliderRange.min) / minMax else \v -> 0.;

	snapPercent = \p ->
		if (length(sliderSteps) > 0)
			percent2value(p)
			|> (\f ->
				fold(sliderSteps, Pair(-1.0, -1.0), \acc, ss ->
					if (acc.second >= 0.0) {
						if (acc.second > abs(ss - f))
							Pair(ss, abs(ss - f))
						else
							acc
					} else {
						Pair(ss, abs(ss - f))
					}
				).first
			)
			|> value2percent
		else if (sliderStep > 0.)
			roundTo(forceRange(p, 0.0, 1.0) * minMax, sliderStep) + sliderRange.min
			|> (\f -> if (f > sliderRange.max) f - sliderStep else if (f < sliderRange.min) f + sliderStep else f)
			|> value2percent
		else
			forceRange(p, 0.0, 1.0);

	preparePercent = \p ->
		snapPercent(p)
		|> mirrorIfRTL(isRTL);

	setNewPercent = \thumb, prc ->
		nextDistinct(thumb.percent, snapPercent(thumb.restrictPercent(prc)));

	prepareValue = \v ->
		if (length(sliderSteps) > 0)
			fold(sliderSteps, Pair(-1.0, -1.0), \acc, ss ->
				if (acc.second >= 0.0) {
					if (acc.second > abs(ss - v))
						Pair(ss, abs(ss - v))
					else
						acc
				} else {
					Pair(ss, abs(ss - v))
				}
			).first
		else if (sliderStep > 0.)
			(roundTo(max(sliderRange.min, min(sliderRange.max, v)) - sliderRange.min, sliderStep) + sliderRange.min)
			|> (\f -> if (f > sliderRange.max) f - sliderStep else if (f < sliderRange.min) f + sliderStep else f)
		else
			max(sliderRange.min, min(sliderRange.max, v));

	updateValue = \pt : Point -> {
		w = getValue(sliderWidth);

		if (w != 0.0) {
			p = preparePercent((pt.x - 4.0) / w);
			nextDistinct(percent, p);

			if (eitherMap(sliderUndefinedM, \su -> !fgetValue(su.undefined), true))
				nextDistinct(m.value, percent2value(p));
		}
	}

	onValueUpdated = \v, undef -> {
		val = prepareValue(v);
		nextDistinct(editString, if (undef) "" else d2st(val, 2));
		nextDistinct(percent, value2percent(val));
	}

	discreteValues =
		if (length(sliderSteps) > 0)
			map(sliderSteps, \ss -> (ss - sliderRange.min) / minMax)
		else if (sliderStep > 0. && minMax != 0. && minMax / sliderStep < 2000.) {
			mValue = sliderRange.min;
			generate(
				0,
				floor(minMax / sliderStep) |> (\f -> if ((mValue + sliderStep * i2d(f)) <= sliderRange.max) f + 1 else f),
				\i -> (sliderStep * i2d(i)) / minMax
			);
		} else
			[];

	focusState =
		concat(
			concatStyles(
				m.style,
				[
					AccessRole("slider"),
					FAccessAttribute("aria-valuenow", fselect(m.value, d2s |> FLift)),
					FAccessAttribute("aria-valuemin", const(d2s(sliderRange.min))),
					FAccessAttribute("aria-valuemax", const(d2s(sliderRange.max))),
					MRippleType(const(MNoRipple())),
					mousePosition,
					MPassClicks()
				]
			),
			[
				IScriptBehaviour("downAnywhere", downAnywhere, ISInteractionEvent()),
				IScriptBehaviour("value", m.value, ISInputValue([], "double", true)),
				IScriptBehaviour("minValue", make(sliderRange.min), ISInputValue([], "double", true)),
				IScriptBehaviour("maxValue", make(sliderRange.max), ISInputValue([], "double", true))
			]
			|> (\f : [IScriptBehaviour] ->
				eitherMap(
					sliderUndefinedM,
					\su : MSliderUndefined ->
						arrayPush(f, IScriptBehaviour("undefined", su.undefined, ISInputValue([], "bool", false))),
					f
				)
			)
		);

	addIcon = \title, left -> \t ->
		if (title != "") {
			iconStyle = \en -> concatA([
				eitherMap(itemsColor, \ic -> [ic.color], []),
				if (en) [] else [MIconDisabled()]
			]);
			icon = MIfLazy2T(manager, parent, enabled, \en, p -> MIcon2T(p, title, iconStyle(en)), true);
			TBaselineCols2Dir(icon, t, left == isRTL)
		}
		else
			t;

	sliderUndefined = eitherMap(sliderUndefinedM, \su -> su.undefined, const(false));
	switchOffUndefined = \ -> maybeApply(sliderUndefinedM, \su -> nextDistinct(su.undefined, false));

	customThumb : Maybe<MCustomThumb> = tryExtractStruct(m.style, MCustomThumb(\__, __ -> TEmpty()));

	mkCustomThumb : Maybe<(Transform<bool>, Transform<bool>) -> Tropic> =
		maybeMap(customThumb, \thumb -> \down, focused ->
			TLet(
				"thumb",
				m2t(thumb.mkThumb(down, focused), parent),
				TShift(TDisplay("thumb"), TScale(const(Factor(0.5, 1.0)), TGhost("thumb")))
			)
		);

	customBar = tryExtractStruct(m.style, MCustomBar(\__, __, __ -> TEmpty()));

	oldSlider = MComponent2T(
		manager,
		parent,
		"MSlider",
		focusState,
		\focus ->
			makeMSlider(manager, focus, percent, sliderWidth, fand(focus.enabled, downAnywhere), color,
				getLightBackground(parent), discreteValues, fselect(percent, FLift(percent2strvalue)),
				isDiscrete, sliderUndefined, outlineOnMinimum, maximizeOnHover, condensed, mkCustomThumb, showDiscreteValues
			)
			|> (\t -> if (!fullWidth) t else TAttachAvailableWidth(t, sliderWidth))
			|> (\t -> if (condensed) TBorder(0., 7., 0., 7., t) else TBorder(0., 9., 0., 9., t))
			|> (\t ->
				TConstruct(
					[
						makeSubscribe(
							eitherMap(
								sliderUndefinedM,
								\su ->
									fif(su.undefined,
										fOr(
											fselect(focus.down, FLift(\d -> {
												if (d && fgetValue(su.undefined)) {
													next(su.undefined, false);
													updateValue(fgetValue(point));
												}
												d
											})),
											focus.hover
										),
										focus.down
									),
								focus.down
							), \d -> if (d) {
							addMInteractionItemId(manager, sliderId);
							updateValue(fgetValue(point));
							drag := true;
						}),
						make2Subscribe(focus.enabled, point, \en, p -> {
							maybeApply(
								sliderTooltip,
								\tooltip -> {
									if (en) {
										v = preparePercent((p.x - 4.0) / getValue(sliderWidth));
										nextDistinct(tooltipText, tooltip.textFn(percent2value(v)));
									} else {
										nextDistinct(tooltipText, "");
									}
								}
							);
							if (^drag) {
								if (isCurrentMInteractionItemId(manager, sliderId))
									blockOtherMInteractionItemIds(manager, sliderId);
								updateValue(p)
							}
						}),
						makeSubscribe(downAnywhere, \d -> if (!d) drag := false),
						eitherFn(
							sliderUndefinedM,
							\su -> {
								prevVal = ref fgetValue(m.value);

								make2Subscribe(
									fselect(m.value, FLift(\v -> {if (^prevVal != v) nextDistinct(su.undefined, false); prevVal := v; v})),
									su.undefined,
									onValueUpdated
								)
							},
							\ ->
								makeSubscribe(m.value, \v -> onValueUpdated(v, false))
						)
					],
					t
				)
			),
		m2t
	)
	|> (\t -> if (condensed) TBorder(4., 0., 4., 0., t) else TBorder(4., 6., 4., 6., t))
	|> (\t -> TInteractive([if (mobile) TMouseDownGhost(downAnywhere) else TMouseDown(downAnywhere)], t))
	|> (\t -> if (isNone(sliderTooltip)) t else {
			contentW = make(0.);
			posScale = make(zeroPositionScale);

			MTooltip2T(
				manager,
				parent,
				MTooltip(
					TPositionScale(posScale, TAttachWidth(t, contentW)),
					MDynamicParagraph(tooltipText, []),
					[
						MTooltipAlignment(MTop()),
						MLightBackground(!getLightBackground(parent)),
						MTranslatePosition(fselect3(point, contentW, posScale, \p, cw, ps -> Point((p.x - cw / 2.) * ps.scale.x, 0.))),
						MEnabled(fneq(tooltipText, ""))
					]
				),
				m2t
			)
		})
	|> (\t -> if (condensed) TBorder(0., -7., 0., -7., t) else t)
	|> (\t -> TBorder(11.,  if (!condensed) 0. else if (isDiscrete) 28. else 0., 11., 0., t))
	|> (\t -> TBaselineOffset(const(6.), t))
	|> addIcon(iconLeft, true)
	|> (\f ->
		if (showValue) {
			extraTextInputWidth = if (sliderStep > 0.) i2d(strlen(d2s(sliderStep)) - 1) else 2.0;
			width = (i2d(max(strlen(i2s(floor(sliderRange.min))), strlen(i2s(floor(sliderRange.max))))) + extraTextInputWidth) * 12.;

			TBaselineCols2Dir(
				f,
				MTextInput2T(
					manager,
					parent,
					MTextInput(
						editString,
						arrayPushMaybe(
							[TextInputType(NumericType()), color, MWidth(width), MNumericStep(const(sliderStep))],
							maybeMap(itemsColor, \ic -> MCustomTextStyle([ic.color]))
						),
						[MEnabled(fand(valueEnabled, enabled)), MInputFilter(\es, foc -> {
							if (es != "") switchOffUndefined();

							value = s2d(es);
							if (d2s(value) == es)
								nextDistinct(m.value, prepareValue(value));

							if (foc)
								es
							else
								d2s(getValue(m.value));
						})]
					),
					m2t
				),
				isRTL
			)
		} else
			f
	)
	|> addIcon(iconRight, false)
	|> if (fullWidth) idfn else makeTropicConstant(None(), None());

	barHeight0 = make(0.);
	barHeight = eitherMap(customBar, \__ -> barHeight0, const(3.));
	activeItemStyle = \en -> [MFill(if (en) color else MGrey(if (lightBackground) 700 else 300))];
	unactiveItemStyle = mDisabledStyle(lightBackground);
	outlinedStyle = replaceStruct(mDisabledStyle(lightBackground), FillOpacity(defaultDisabledItemOpacity(lightBackground)));

	makeCircleThumb = \focus, radius, foc, st, outlined -> {
		circleStyle = fif(outlined, const(outlinedStyle), fselect(foc.enabled, FLift(st)));

		rippleRadius = fif(foc.down, const(24.), const(16.));
		setRipple = if (noRipple) idfn else \t ->
			MRipple2T(manager, foc.parent, t, fOr(foc.focused, fOr(foc.hover, foc.down)), [
				MRippleType(const(MRippleCenter())),
				MRippleColor(fif(outlined, const(MBlack()), const(color))),
				MRippleOpacity(fif(fOr(foc.focused, foc.down), const(0.2), const(0.1))),
				MRippleWidthHeight(fselect(rippleRadius, FLift(\rr -> WidthHeight(2. * rr, 2. * rr))))
			])
			|> (\t2 -> TBorderT(fsubtract(radius, rippleRadius), fsubtract(radius, rippleRadius), zero, zero, t2));

		setMarker = \t -> t |> MHintMarker(manager, foc, false);

		TCenteredCircle(focus, radius, circleStyle, outlined, setRipple, setMarker)
	}

	makeValueLabel = \par, thumbRadius, thumbPercent, style -> {
		radius = 14.;
		dsqrt2 = 1. / sqrt(2.);

		label =
			TSelect(thumbPercent, \prc ->
				MText2T(parent, percent2strvalue(prc), [MCustomFont(radius, "Roboto", 1.), MWhite()])
			)
			|> (\t -> TCenterIn(t, TFixed(2.0 * radius, 2.0 * radius)));

		TGroupSameMetrics([
			TSelect(style, \st -> TCircle(radius, st)),
			TDynamicGraphics(fselect(thumbRadius, FLift(\smallradius -> [
				MoveTo(radius, radius),
				LineTo((1. + dsqrt2) * radius, (1. + dsqrt2) * radius),
				CubicBezierTo(1.05 * radius, 2.75 * radius, 1.05 * radius, 2.1 * radius),
				CubicBezierTo(radius + dsqrt2 * smallradius, 3. * radius + (1. - dsqrt2) * smallradius, 1.05 * radius, 3. * radius),
				LineTo(radius, 3. * radius + smallradius),
				LineTo(radius - dsqrt2 * smallradius, 3. * radius + (1. - dsqrt2) * smallradius),
				CubicBezierTo(0.95 * radius, 2.75 * radius, 0.95 * radius, 3. * radius),
				CubicBezierTo((1. - dsqrt2) * radius, (1. + dsqrt2) * radius, 0.95 * radius, 2.1 * radius),
				ClosePath()
			])), style),
			label
		])
		|> (\t -> TTranslate(fselect(thumbRadius, FLift(\smallradius -> Point(-radius, -3. * radius - smallradius))), t))
	}

	makeThumb = \thumb, sliderFoc, style -> {
		name = if (thumb.isStart) "startThumb" else "endThumb";
		activeU = if (thumb.isStart) thumb.active else fOr(sliderUndefined, thumb.active);
		thumbPoint = fselect2(thumb.percent, sliderWidth, FLift2(\p, sw -> Point((if (isRTL) 1. - p else p) * sw, 0.)));
		show = fif(sliderUndefined, sliderFoc.hover, const(true));
		focused = if (isSome(chooseRange)) make(false) else sliderFoc.focused;

		MComponent2T(manager, parent, name, concatA([[
					MOnMouseDown(\__, ins -> nextDistinct(thumb.active, ins)),
					MOnMouseUp(\__, __ -> nextDistinct(thumb.active, false)),
					MEnabled(enabled),
					MFocused(focused),
					MAddFocusGroup(true)
				],
				eitherMap(sliderUndefinedM, \__ -> [MPassClicks()], [])
			]), \foc -> {
				onKeyDown = \h, ke ->
					if (!h && fgetValue(foc.focused)) {
						if (ke.utf == "left") { setNewPercent(thumb, getValue(thumb.percent) - stepPercent); true }
						else if (ke.utf == "right") { setNewPercent(thumb, getValue(thumb.percent) + stepPercent); true }
						else false
					} else h;

				eitherMap(mkCustomThumb, \ct -> ct(thumb.active, foc.focused), {
					radius =
						if (condensed) fif(fmax3(sliderFoc.hover, foc.focused, down2), const(6.), const(0.))
						else
							fif(foc.enabled,
								if (maximizeOnHover)
									fif(foc.down, const(if (noRipple) 9. else 7.), fif(fOr(foc.hover, activeU), const(7.), const(6.)))
								else
									const(6.),
								const(4.)
							);
					circle = makeCircleThumb(sliderFoc, radius, foc, style, fand(const(outlineOnMinimum), feq(thumb.percent, 0.)));
					if (isDiscrete)
						TGroup2(
							makeValueLabel(
								foc.parent,
								radius,
								thumb.percent,
								fif(fand(const(outlineOnMinimum), feq(thumb.percent, 0.)), const([MFill(MGrey(500))]), const(style(true)))
							)
							|> (\t -> TShow(fand(foc.enabled, activeU), t)),
							circle
						)
					else circle
				})
				|> (\t -> if (enableArrows) TInteractive([KeyDown2(onKeyDown)], t) else t)
			},
			m2t
		)
		|> (\t -> eitherMap(sliderUndefinedM, \__ -> TCopySize(t, \tr ->
					TInteractive(
						[MouseDown(\mi -> mi.inside() && !fgetValue(sliderUndefined))],
						TRectangle(interactiveRectangleStyle, tr),
					)
					|> (\t2 -> TShift(TScale(ffactor2(const(2.)), t2), tr)),
				false
			), t))
		|> (\t -> TBorderT(zero, fdivide(barHeight, const(2.)), zero, zero, t))
		|> (\t -> TConstruct([
			makeSubscribe2Trigger(activeU, cursorPercent, \p -> setNewPercent(thumb, p)),
			makeSubscribe2(thumb.active, \act -> if (act) deferred( \ -> nextDistinct(focused, true)))
		], t))
		|> (\t -> TTranslate(thumbPoint, t))
		|> (\t -> TVisible(show, t));
	}

	makeValueInput = \thumb -> {
		extraTextInputWidth = if (sliderStep <= 0.) 2 else if (sliderStep < 1.) strlen(d2s(sliderStep)) - 1 else 1;
		width = i2d(max(strlen(i2s(floor(sliderRange.min))), strlen(i2s(floor(sliderRange.max)))) + extraTextInputWidth) * 12.;

		strValue = make("");

		MTextInput2T(
			manager,
			parent,
			MTextInput(
				strValue,
				arrayPushMaybe(
					[TextInputType(NumericType()), color, MWidth(width), MNumericStep(const(sliderStep))],
					maybeMap(itemsColor, \ic -> MCustomTextStyle([ic.color]))
				),
				[
					MEnabled(fand(valueEnabled, enabled)),
					MInputFilter(\es, foc -> {
						if (es != "") switchOffUndefined();
						if (foc) es else if (fgetValue(sliderUndefined)) "" else percent2strvalue(getValue(thumb.percent))
					})
				]
			),
			m2t
		)
		|> (\t -> TConstruct([
				make2Subscribe(thumb.percent, sliderUndefined, \p, su ->
					nextDistinct(strValue, if (su) "" else percent2strvalue(p))
				),
				makeSubscribe2(strValue, \sv -> setNewPercent(thumb, value2percent(s2d(sv))))
			], t))
	}

	makeSliderIcon = \title ->
		if (title == "") TEmpty()
		else {
			iconStyle = \en -> concatA([
				eitherMap(itemsColor, \ic -> [ic.color], []),
				if (en) [] else [MIconDisabled()]
			]);
			MIfLazy2T(manager, parent, enabled, \en, p -> MIcon2T(p, title, iconStyle(en)), true)
		}

	sliderBar = \foc, type, prc ->
		TSelect(foc.enabled, \en -> {
			circleGap = if (en || condensed || isSome(customThumb)) 0. else 6.;
			barLength = fsubtract(fmultiply(prc, sliderWidth), const(if (type == ActiveBar()) 2. * circleGap else circleGap));
			border = faddition(fmin(const(0.), barLength), const(circleGap));
			style = if (type != ActiveBar()) unactiveItemStyle else activeItemStyle(en);

			eitherMap(
				customBar,
				\cb -> TAttachHeight(m2t(cb.makeBar(type, fmax(barLength, const(0.)), style), parent), barHeight0),
				TRectangle(style, TSizedWidthHeight(fmax(barLength, const(0.)), barHeight))
			)
			|> (\t -> TBorderT(if (type == LeftBar()) zero else border, zero, if (type == RightBar()) zero else border, zero, t))
		});

	makeOuterValueLink = \value : DynamicBehaviour<double>, prc ->
		[
			\ -> {if (!fgetValue(sliderUndefined)) nextDistinct(prc, snapPercent(value2percent(getValue(value)))); nop},
			makeSubscribe2(value, \v -> {nextDistinct(prc, snapPercent(value2percent(v))); switchOffUndefined()}),
			makeSubscribe2(fpair(prc, sliderUndefined), \p -> if (!p.second) nextDistinct(value, percent2value(p.first)))
		];

	if (isUrlParameterTrue("newSlider") || isSome(chooseRange) || isSome(customBar)) {
			rangeStartPercent = make(0.);
			rangeEndPercent = make(0.);

			startThumb =
				MSliderThumb(
					rangeStartPercent,
					make(false),
					\p -> min(p, fgetValue(rangeEndPercent) - stepPercent),
					true
				);

			endThumb =
				MSliderThumb(
					rangeEndPercent,
					make(false),
					if (isSome(chooseRange)) \p -> max(p, fgetValue(rangeStartPercent) + stepPercent) else idfn,
					false
				);

			addDiscreteValues = \foc -> \f2 ->
				TGroup2(
					f2,
					(\ ->
						map(discreteValues, \v -> {
							tickColor = fselect2(startThumb.percent, endThumb.percent, FLift2(\st, e -> {
								light = if (v > st && v < e) isLightMColor(color) else lightBackground;
								MDialogMColor(!light)
							}));
							TTranslate(
								fselect2(sliderWidth, barHeight, FLift2(\w, h -> {x = v * w - h / 2.; Point(if (isRTL) w - x else x, 0.)})),
								TSelect(tickColor, \col -> TRectangle([MFill(col)], TSizedWidthHeight(barHeight, barHeight)))
							)
						})
						|> TGroup
					)
					|> (\t -> TShowLazy(fand(
							eitherMap(showDiscreteValues,
								\sdv -> sdv.show,
								fand(
									foc.enabled,
									fif(sliderUndefined, foc.hover, fmax3(down2, startThumb.active, endThumb.active))
								)
							),
							fselect(sliderWidth, FLift(\w -> i2d(length(discreteValues)) < w / 10.))
						), t
					))
				);

			(\foc -> {
				rangeStartPercentU = fif(sliderUndefined, const(0.), rangeStartPercent);
				rangeEndPercentU = fif(fand(sliderUndefined, fnot(foc.hover)), const(0.), rangeEndPercent);

				leftBar =
					sliderBar(foc, LeftBar(), rangeStartPercentU);
				activeBar =
					sliderBar(foc, ActiveBar(), fsubtract(rangeEndPercentU, rangeStartPercentU));
				rightBar =
					sliderBar(foc, RightBar(), fsubtract(const(1.), rangeEndPercentU));

				concat([
						TColsDir([leftBar, activeBar, rightBar], isRTL)
						|> addDiscreteValues(foc),
						makeThumb(endThumb, foc, activeItemStyle)
					],
					eitherMap(chooseRange, \__ -> [makeThumb(startThumb, foc, activeItemStyle)], [])
				)
				|> TGroupSameMetrics
				|> (\t -> if (!fullWidth) t else TAttachAvailableWidth(t, sliderWidth))
				|> (\t -> if (condensed) TBorder(0., 7., 0., 7., t) else TBorder(0., 9., 0., 9., t))
			})
			|> (\makeSlider -> MComponent2T(manager, parent, "MSlider", focusState, makeSlider, m2t))
			|> (\t -> if (condensed) TBorder(4., 0., 4., 0., t) else TBorder(4., 6., 4., 6., t))
			|> (\t -> TInteractive([if (mobile) TMouseDownGhost(downAnywhere) else TMouseDown(downAnywhere), TMouseXY(point)], t))
			|> (\t -> TConstruct(concat([
				makeSubscribe2(down2, \d -> if (d) {
					switchOffUndefined();
					prc = snapPercent(fgetValue(cursorPercent));
					thumb =
						if (isSome(chooseRange) && abs(prc - getValue(rangeStartPercent)) <= abs(prc - getValue(rangeEndPercent)))
							startThumb
						else
							endThumb;

					nextDistinct(thumb.percent, prc);
					nextDistinct(thumb.active, true);
				}),
				makeSubscribeUns(fOr(startThumb.active, endThumb.active), \active -> {
					if (active) {
						addMInteractionItemId(manager, sliderId);

						[
							makeSubscribe2(point, \p -> {
								if (isCurrentMInteractionItemId(manager, sliderId))
									blockOtherMInteractionItemIds(manager, sliderId);
							})()
						]
					} else {
						[]
					}
				})],
				eitherMap(chooseRange, \chR -> concat(
						makeOuterValueLink(chR.end, rangeEndPercent),
						makeOuterValueLink(chR.start, rangeStartPercent)
					),
					makeOuterValueLink(m.value, rangeEndPercent)
				)
			), t))
			|> (\t -> eitherMap(sliderTooltip, \tooltip -> {
					contentW = make(0.);
					posScale = make(zeroPositionScale);

					tooltipText2 = fselect(cursorPercent, FLift(\prc ->
						tooltip.textFn(percent2value(snapPercent(prc)))
					));
					MTooltip2T(
						manager,
						parent,
						MTooltip(
							TPositionScale(posScale, TAttachWidth(t, contentW)),
							MSelect(tooltipText2, \txt -> MText(txt, [])),
							[
								MTooltipAlignment(MTop()),
								MLightBackground(!lightBackground),
								MTranslatePosition(fselect3(point, contentW, posScale, \p, cw, ps -> Point((p.x - cw / 2.) * ps.scale.x, 0.))),
								MEnabled(fneq(tooltipText2, ""))
							]
						),
						m2t
					)
				}, t))
			|> (\t -> if (condensed) TBorder(0., -7., 0., -7., t) else t)
			|> TBorderLeftRight(11.)
			|> (\t -> TBaselineOffset(const(6.), t))
			|> (\t : Tropic -> if (showValue) TBaselineColsDir([if (isSome(chooseRange)) makeValueInput(startThumb) else TEmpty(), t, makeValueInput(endThumb)], isRTL) else t)
			|> (\t -> TBaselineColsDir([makeSliderIcon(iconLeft), t, makeSliderIcon(iconRight)], isRTL))
		}
	else oldSlider
}

IconBasedCircle(parent : MFocusGroup, radius : double, style : [TGraphicsStyle]) -> Tropic {
	color = extractStruct(style, Fill(black)).color;
	opacity = extractStruct(style, FillOpacity(1.0)).opacity;

	stroke = extractStruct(style, Stroke(black)).colour;
	strokeWidth = extractStruct(style, StrokeWidth(0.0)).width;
	strokeOpacity = extractStruct(style, StrokeOpacity(1.0)).opacity;

	makeCircle = \r, col, op ->
		MIcon2T(parent, "lens", [MIconSize(2.4 * r), MCustomColor(col), FillOpacity(op)])
		|> (\t -> TCrop(const(Point(0.21 * r, 0.21 * r)), const(WidthHeight(2. * r, 2. * r)), t));

	if (strokeWidth == 0.0)
		makeCircle(radius, color, opacity)
	else
		TGroup2SameMetrics(
			makeCircle(radius + strokeWidth / 2.0, stroke, strokeOpacity),
			makeCircle(radius - strokeWidth / 2.0, color, opacity) |> (\m -> TTranslate(const(Point(strokeWidth, strokeWidth)), m))
		);
}

makeBlobHandle(parent : MFocusGroup, text : string, radius : double, st : [TGraphicsStyle]) -> Tropic {
	sqrt2 = sqrt(2.0);
	dsqrt2 = 1.0 / sqrt2;

	TGroupSameMetrics([
		IconBasedCircle(parent, radius, st),
		TGraphics(
			[
				MoveTo(radius, 0.0),
				LineTo((1. + sqrt(3.)/2.) * radius, 1.55 * radius),
				LineTo(radius, 3. * radius),
				LineTo((1. - sqrt(3.)/2.) * radius, 1.55 * radius),
				ClosePath()
			],
			st
		),
		MText2T(parent, text, [MCustomFont(radius, "Roboto", 1.), MWhite()])
		|> (\t -> TCenterIn(t, TFixed(2.0 * radius, 2.0 * radius)))
	])
	|> (\t -> TTranslate(const(Point(-radius, -radius * (2. + sqrt2))), t))
}

MSliderState(enabled : bool, strokeCircle : bool, radius : double, left : double, center : double, right : double, circlePosition : double,
	width : double, blob : bool);

makeMSlider(manager : MaterialManager, focus : MFocus, value0 : Transform<double>, width : Transform<double>, down : Transform<bool>, color : MColor, lightBackground: bool,
	discreteValues : [double], editString : Transform<string>, isDiscrete : bool, sliderUndefined : Transform<bool>, outlineOnMinimum : bool, maximizeOnHover : bool,
	condensed : bool, customThumb : Maybe<(Transform<bool>, Transform<bool>) -> Tropic>, showDiscreteValues : Maybe<MSliderShowDiscreteValues>) -> Tropic {

	isRTL = focus.parent.rtl;
	radius =
		if (isSome(customThumb))
			const(0.0)
		else if (condensed)
			fselect(fmax3(focus.hover, focus.focused, down), FLift(\h -> if (!h) 0. else 6.))
		else if (!maximizeOnHover)
			fselect2(focus.hover, sliderUndefined, FLift2(\h, su -> if (su && !h) 0. else 6.))
		else if (isDiscrete)
			fselect3(focus.hover, fOr(down, focus.focused), sliderUndefined, \h, d, su -> if (su || d) 0. else if (h) 7. else 6.)
		else
			fselect3(focus.hover, down, sliderUndefined, \h, d, su -> if (su && !h) 0. else if (d) 9. else if (h) 7. else 6.);

	value = fif(fand(sliderUndefined, fnot(focus.hover)), zero, value0);

	sliderState =
		fselect6(focus.enabled, radius, value, width, sliderUndefined, focus.hover, \en, r0, val, wd, undef, hvr -> {
			strokeCircle = val == 0. && !undef && outlineOnMinimum;
			r = if (strokeCircle) r0 + 1. else r0;

			a = val * wd - r;
			b = (1. - val) * wd - r;
			c = r * 2. + min(a, 0.) + min(b, 0.);

			MSliderState(en, strokeCircle, r0, max(a, 0.), c, max(b, 0.), mirrorIfRTL(isRTL)(val) * wd, wd, r0 == 0. && isDiscrete && (!undef || hvr))
		});

	makeBlob = \r, style, sc, blob ->
		if (blob)
			makeBlobHandle(focus.parent, fgetValue(editString), 14., if (sc) [MFill(MGrey(500))] else style)
		else if (sc)
			TTranslate(
				const(Point(-r - 1., -r - 1.)),
				TGroup2SameMetrics(
					TCircle(r + 1., replaceStruct(mDisabledStyle(lightBackground), FillOpacity(defaultDisabledItemOpacity(lightBackground)))),
					TTranslate(const(Point(2., 2.)), TCircle(r - 1., [MThemeFill(focus, MBackgroundColor())]))
				)
			)
		else
			TTranslate(const(Point(-r, -r)), TCircle(r, style));

	slider = \st ->
		TColsDir([
			TRectangle(if (st.enabled) [MFill(color)] else mDisabledStyle(lightBackground), TFixed(st.left, 3.)),
			TFixed(st.center, 3.),
			TRectangle(mDisabledStyle(lightBackground), TFixed(st.right, 3.))
		], isRTL)
		|> (\f2 ->
			if (i2d(length(discreteValues)) < st.width / 4.)
				TGroup2(
					f2,
					(\ ->
						TGroup(
							map(discreteValues, \v ->
								TTranslate(
									if (isRTL)
										fselect(width, FLift(\w -> Point(w - (v * st.width - 1.5), 0.)))
									else
										const(Point(v * st.width - 1.5, 0.)),
									TRectangle([MFill(MDialogMColor(!lightBackground))], TFixed(3., 3.))
								)
							)
						)
					)
					|> (\f3 -> TShowLazy(eitherMap(showDiscreteValues,
							\sdv -> sdv.show,
							fif(sliderUndefined, focus.hover, down)
						), f3))
				)
			else
				f2
		);

	blob = \st ->
		if (st.radius == 0. && !st.blob)
			TEmpty()
		else if (st.enabled) {
			makeBlob(st.radius, [MFill(color)], st.strokeCircle, st.blob)
			|> (\blob -> if (st.blob) blob else
					TGroup2WithoutMetrics(
						TShowLazy(focus.focused, \ -> makeBlob(
							16.,
							[MFill(if (st.strokeCircle) MGrey(500) else color), FillOpacity(0.2)],
							false,
							false
						)),
						blob
					))
		} else {
			makeBlob(4., mDisabledStyle(lightBackground), st.strokeCircle, false)
		};

	TGroup2SameMetrics(
		TSelect(sliderState, slider),
		eitherFn(
			customThumb,
			\thumb -> thumb(down, focus.focused),
			\ -> TSelect(sliderState, blob)
		)
		|> MHintMarker(manager, focus, false)
		|> (\f2 -> TTranslate(fselect(sliderState, FLift(\st -> Point(st.circlePosition, 1.5))), f2))
	)
}

mirrorIfRTL(isRTL : bool) -> (double) -> double {
	\value -> if (isRTL) 1.0 - value else value
}

TCenteredCircle(
	focus : MFocus,
	radius0 : Transform<double>,
	style : Transform<[TGraphicsStyle]>,
	outlined : Transform<bool>,
	setRipple : (Tropic) -> Tropic,
	setMarker : (Tropic) -> Tropic
) -> Tropic {

	radius = fif(outlined, faddition(radius0, const(1.)), radius0);
	outlinedCircle = TBorder(2., 2., 0., 0., TShowLazy(outlined, \ -> TSelect(radius0, \r -> TCircle(r - 1., [MThemeFill(focus, MBackgroundColor())]))));

	TSelect2(radius, style, \r, st -> TCircle(r, st))
	|> (\t -> TGroup2(t, outlinedCircle))
	|> setRipple
	|> setMarker
	|> (\t -> TBorderT(fnegate(radius), fnegate(radius), zero, zero, t))
}