import material/internal/material_list_util;
import material/internal/material_button;
import material/internal/material_outline;

export {
	MMenu2T(manager : MaterialManager, parent : MFocusGroup, m : MMenu, m2t : (Material, MFocusGroup) -> Tropic) -> Tropic;
	MDynamicMenu2T(manager : MaterialManager, parent : MFocusGroup, m : MDynamicMenu, m2t : (Material, MFocusGroup) -> Tropic) -> Tropic;
	MMenuPanel2T(manager : MaterialManager, parent : MFocusGroup, m : MMenuPanel, m2t : (Material, MFocusGroup) -> Tropic) -> Tropic;
	MDropDownMenu2T(manager : MaterialManager, parent : MFocusGroup, m : MDropDownMenu, m2t : (Material, MFocusGroup) -> Tropic) -> Tropic;
	MMultiSelectDropDown2T(
		manager : MaterialManager,
		parent : MFocusGroup,
		m : MMultiSelectDropDown,
		m2t : (Material, MFocusGroup) -> Tropic
	) -> Tropic;
	MDropDownMenuStyle2MMenuStyle(style : [MDropDownMenuStyle]) -> [MMenuStyle];

	MDropDownIcon(opened : Transform<bool>, style : [MDropDownIconStyle]) -> Material;
		MDropDownIconStyle ::= MIconSize, MIconBorder4;
}

MMenuFocusedItem ::= MMenuFirstItem, MMenuLastItem;
	MMenuFirstItem();
	MMenuLastItem();

MMenu2T(manager : MaterialManager, parent : MFocusGroup, m : MMenu, m2t : (Material, MFocusGroup) -> Tropic) -> Tropic {
	MDynamicMenu2T(manager, parent, MDynamicMenu(m.button, const(m.items), m.style), m2t)
}

MDynamicMenu2T(manager : MaterialManager, parent : MFocusGroup, m : MDynamicMenu, m2t : (Material, MFocusGroup) -> Tropic) -> Tropic {
	MDynamicMenu2TInner(manager, parent, m, m2t, None())
}

MDynamicMenu2TInner(manager : MaterialManager, parent : MFocusGroup, m : MDynamicMenu, m2t : (Material, MFocusGroup) -> Tropic, popupId0 : Maybe<string>) -> Tropic {
	openMenu = extractStruct(m.style, MOpenMenu(make(false)));
	buttonWH = makeWH();
	positionScale = make(zeroPositionScale);
	customPopup = tryExtractStruct(m.style, MMenuCustomPopup(None(), None()));
	popupId = either(popupId0, getPopupId(manager));

	enabled = extractStruct(m.style, MEnabled(const(true))).enabled;
	openOnClick = contains(m.style, MOpenOnClick());
	longTouch = tryExtractStruct(m.style, MLongTouchDelay(0));

	buttonFocused = extractStruct(m.style, MFocused(make(false)));
	buttonState = replaceStruct(extractMButtonState(m.style), buttonFocused);
	focusedItem = make(None());

	(\p ->
		MMenuButton2T(manager, p, m.button, m2t, openMenu, enabled, openOnClick, longTouch, None(), popupId, buttonState)
		|> (\f -> MPositionScaleAttachBox(positionScale, buttonWH, f, openMenu.opened))
		|> (\f -> MAddLabelAndLeftIcon(manager, p, f, m.style, openMenu.opened, 12.))
		|> (\f ->
			TConstruct(
				[
					makeSubscribe2(m.items, \items ->
						if (fgetValue(openMenu.opened)) {
							next(openMenu.opened, false);
							next(openMenu.opened, true)
						}
					),
					makeSubscribe(openMenu.opened, \op -> {
						if (op)
							RenderMPopup(
								manager,
								p,
								MMenuLines2MPopup(
									manager,
									fgetValue(m.items),
									replaceStruct(m.style, openMenu),
									m2t,
									eitherMap(customPopup, \cp -> either(cp.positionScale, positionScale), positionScale),
									eitherMap(customPopup, \cp -> either(cp.buttonWH, buttonWH), buttonWH),
									8.,
									nop,
									popupId,
									getValue(focusedItem)
								),
								m2t
							)
					}),
					\ -> \ -> next(openMenu.opened, false)
				],
				f
			)
		)
	)
	|> (\f ->
		MComponentGroup2T(
			manager,
			parent,
			"MDynamicMenu",
			extractMComponentGroupState(m.style),
			f
		)
	)
	|> MDynamicMenuHandleShortcuts(m.items, openMenu, buttonFocused, focusedItem)
}

MDynamicMenuHandleShortcuts(
	items : Transform<[MMenuLine]>,
	openMenu : MOpenMenu,
	buttonFocused : MFocused,
	focusedItem : DynamicBehaviour<Maybe<MMenuFocusedItem>>) -> (Tropic) -> Tropic {

	\t -> {
		shortcuts = fmap(fgetShortcuts(items), \sh -> parseShortcut(toLowerCase(sh.shortcut)));

		TInteractive(
			[
				KeyDown(\ke -> {
					if (!getValue(openMenu.opened) && exists(fgetValue(shortcuts), \s -> matchShortcutKeyCode(ke, s))) {
						next(openMenu.opened, true);

						emitKeyEvent(getStage(), "keydown", ke.utf, ke.ctrl, ke.shift, ke.alt, ke.meta, ke.keycode);
						emitKeyEvent(getStage(), "keyup", ke.utf, ke.ctrl, ke.shift, ke.alt, ke.meta, ke.keycode);

						deferred(\ -> next(openMenu.opened, false));
					}
				}),
				KeyUp2(\h, ke ->
					if (!h && !getValue(openMenu.opened) && fgetValue(buttonFocused.focused)) {
						onKeyUp = \type -> {
							nextDistinct(focusedItem, Some(type));
							nextDistinct(openMenu.opened, true);
							nextDistinct(focusedItem, None());
						}
						if (ke.utf == "up") {
							onKeyUp(MMenuLastItem());
						} else if (ke.utf == "down") {
							onKeyUp(MMenuFirstItem());
						}
						true
					} else h
				)
			],
			t
		);
	}
}

fgetShortcuts(items : Transform<[MMenuLine]>) -> Transform<[MShortcut]> {
	fsubmap(items, \it ->
		switch (it : MMenuLine) {
			MMenuSingleLine(__, style) : const(extractStructMany(style, MShortcut("shortcut")));
			MMenuCustomLine(__, style) : const(extractStructMany(style, MShortcut("shortcut")));
			MMenuGroupLine(__, style) : const(extractStructMany(style, MShortcut("shortcut")));
			MSubMenu(__, subItems, style) :
				fconcat(
					const(extractStructMany(style, MShortcut("shortcut"))),
					fgetShortcuts(const(subItems))
				);
			MSubMenuDynamic(__, subItems, style) :
				fconcat(
					const(extractStructMany(style, MShortcut("shortcut"))),
					fgetShortcuts(subItems)
				);
			MSeparatorLine() : const([])
		}
	)
	|> fconcatA
}


MMenuButton2T(
	manager : MaterialManager,
	parent : MFocusGroup,
	button : Material,
	m2t : (Material, MFocusGroup) -> Tropic,
	openMenu : MOpenMenu,
	enabled : Transform<bool>,
	openOnClick : bool,
	longTouch : Maybe<MLongTouchDelay>,
	buttonTitleM : Maybe<MButtonTitle>,
	popupId : string,
	buttonState : [MButtonState]
) -> Tropic {

	addAria = \st -> concat(st, arrayPushMaybe([
		FAccessAttribute("aria-haspopup", const("true")),
		FAccessAttribute("aria-expanded", fif(openMenu.opened, const("true"), const(""))),
		FAccessAttribute("aria-owns", fif(openMenu.opened, const(popupId), const("")))
	], buttonTitleM));

	extendState = \state : [MButtonState], open ->
		replaceStruct(state, MEnabled(enabled))
		|> addAria
		|> (\st -> eitherMap(longTouch, \lt -> concat(st, [lt, MOnLongTouch(open)]), st));

	switch (button) {
		MTextButton(text, onClick, style, state): {
			open = \ -> {
				opened = getValue(openMenu.opened);
				onClick();
				nextDistinct(openMenu.opened, !opened);
			}
			MTextButton2T(
				manager,
				parent,
				MTextButton(
					text,
					eitherMap(longTouch, \__-> nop, open),
					style,
					replaceStructMany(
						buttonState,
						extendState(state, open)
					)
				),
				m2t
			)
		}
		MIconButton(name, onClick, style, state): {
			open = \ -> {
				opened = getValue(openMenu.opened);
				onClick();
				nextDistinct(openMenu.opened, !opened);
			}
			MIconButton2T(
				manager,
				parent,
				MIconButton(
					name,
					eitherMap(longTouch, \__-> nop, open),
					style,
					replaceStructMany(
						buttonState,
						extendState(state, open)
					)
				),
				m2t
			)
		}
		MMutable(contentT): {
			TMutable(fselect(contentT, FLift(\content ->
				MMenuButton2T(manager, parent, content, m2t, openMenu, enabled, openOnClick, longTouch, buttonTitleM, popupId, buttonState)
			)))
		}
		default: {
			if (openOnClick || isSome(longTouch)) {
				buttonWH = makeWH();
				isRect = fselect(buttonWH, FLift(\wh -> abs(1. - wh.width / wh.height) > 0.5));
				focusState =
					concat(
						replaceStructMany(
							buttonState,
							[
								MEnabled(enabled),
								MRippleType(fif(isRect, const(MRippleFill()), const(MRippleCenter()))),
								MHighlightOnFocus(const(true)),
								MRippleShape("")
							]
						),
						eitherMap(longTouch, \lt -> [
								lt,
								MOnLongTouch(\ -> reverseBehaviour(openMenu.opened))
							],
							[MOnClick(\ -> reverseBehaviour(openMenu.opened))]
						)
					)
					|> addAria;

				MComponent2T(
					manager,
					parent,
					"MMenuCustomButton",
					focusState,
					\focus ->
						MComponentGroup2T(
							manager,
							parent,
							"MMenuCustomButtonContainer",
							[MFocusEnabled(const(false)), MClickEnabled(const(false))],
							\p -> m2t(button, p)
						)
						|> (\t -> TAttachBox(t, buttonWH)),
					m2t
				)
			} else {
				m2t(button, parent);
			}
		}
	}
}

MMenuPanelIconSize(style : [?], height : double, borders : double) -> MIconSize {
	extractStruct(style, MIconSize((height * 2. - borders * 4.) / 3.));
}

MMenuPanelIconButtonBorders(style : [?], height : double, borders : double, iconSize : MIconSize) -> MIconButtonBorder {
	extractStruct(style, MIconButtonBorder((height - borders - iconSize.size) / 2.));
}

MMenuPanelItem2T(
	manager : MaterialManager,
	parent : MFocusGroup,
	item : Material,
	m2t : (Material, MFocusGroup) -> Tropic,
	enabledHover : Maybe<DynamicBehaviour<bool>>,
	openMenus : ref [MOpenMenu],
	closeMenus : () -> void,
	height : double, borders : double
) -> Tropic {
	switch (item) {
		MDropDownMenu(items, current, style): {
			MDropDownMenu2T(
				manager,
				parent,
				MDropDownMenu(items, current, replaceStructMany(style, [extractStruct(style, MCustomLineHeight(height - 16.)),
					extractStruct(style, MSeparators(false))])),
				m2t
			)
			|> TCenterY
			|> if (contains(style, MCroppedButton())) TBorderLeftRight(8.) else idfn
		}
		MMenu(button, items, style): {
			openMenu = extractStruct(style, MOpenMenu(make(false)));
			refArrayPush(openMenus, openMenu);
			rollOver = make(false);
			(\p ->
				(\par ->
					switch (button) {
						MTextButton(text, onClick, buttonStyle, buttonState): {
							MMenuTextButton2T(manager, par, text, extractStruct(buttonState, MShortcut("")).shortcut, onClick,
								buttonStyle, openMenu, m2t)
						}
						MIconButton(name, onClick, iconStyle, state): {
							iconSize = MMenuPanelIconSize(iconStyle, height, borders);
							iconBorders = MMenuPanelIconButtonBorders(iconStyle, height, borders, iconSize);

							MIconButton2T(
								manager,
								par,
								MIconButton(
									name,
									\ -> {
										onClick();
										reverseBehaviour(openMenu.opened)
									},
									replaceStructMany(iconStyle, [iconSize, iconBorders]),
									replaceStructMany(state, [MFocusEnabled(const(false))])
								),
								m2t
							)
						}
						default: {
							MMenuPanelItem2T(manager, par, button, m2t, enabledHover, openMenus, closeMenus, height, borders)
						}
					}
				)
				|> (\f -> MMenu2T(manager, p, MMenu(MGetFocusGroup(f), items, concat(replaceStruct(style, openMenu), [THovering(rollOver), MBelowButton()])), m2t))
				|> TCenterY
			)
			|> (\f ->
				eitherFn(
					enabledHover,
					\eh -> {
						TConstruct([
								makeSubscribe2(rollOver, \ro -> {
									if (fgetValue(eh) && ro && !fgetValue(openMenu.opened)) {
										closeMenus();
										next(openMenu.opened, true);
									}
								}),
								makeSubscribe2(openMenu.opened, \op -> nextDistinct(eh, op)),
							],
							f(parent)
						)
					},
					\ -> f(parent)
				)
			)
		}
		MDropDown(current, nonSpecified, items, style): {
			m2t(MDropDown(current, nonSpecified, items, replaceStructMany(style, [extractStruct(style, MCustomLineHeight(height - 16.)),
				extractStruct(style, MSeparators(false))])), parent)
			|> TCenterY
			|> if (contains(style, MCroppedButton()))
					TBorderLeftRight(8.)
				else if (isSome(tryExtractStruct(style, MCustomButton(TEmpty()))))
					idfn
				else
					TBorderLeftRight(-8.)
		}
		MTextButton(text, onClick, buttonStyle, buttonState): {
			m2t(item, parent)
			|> TCenterY
		}
		MIconButton(icon, onClick, style, state): {
			iconSize = MMenuPanelIconSize(style, height, borders);
			iconBorders = MMenuPanelIconButtonBorders(style, height, borders, iconSize);

			MIconButton2T(
				manager,
				parent,
				MIconButton(
					icon,
					onClick,
					replaceStructMany(style, [iconSize, iconBorders]),
					state
				),
				m2t
			)
			|> TCenterY
		}
		MIconToggle(icon, style, state): {
			iconSize = MMenuPanelIconSize(style, height, borders);
			iconBorders = MMenuPanelIconButtonBorders(style, height, borders, iconSize);

			MIconToggle2T(
				manager,
				parent,
				MIconToggle(
					icon,
					replaceStructMany(style, [iconSize, iconBorders]),
					state
				),
				m2t
			)
			|> TCenterY
		}
		MBorder(left, top, right, bottom, c): {
			MMenuPanelItem2T(manager, parent, c, m2t, enabledHover, openMenus, closeMenus, height - top - bottom, borders)
			|> (\f -> TBorder(left, top, right, bottom, f))
		}
		MText(__, __): {
			m2t(item, parent)
			|> TCenterY
		}
		MTooltip(box, tip, style): {
			MTooltip2T(
				manager,
				parent,
				MTooltip(MMenuPanelItem2T(manager, parent, box, m2t, enabledHover, openMenus, closeMenus, height, borders), tip, style),
				m2t
			)
		}
		MMutable(cont): {
			MSelect2T(
				manager,
				parent,
				"MSelect",
				[],
				cont,
				\c, p ->
					MMenuPanelItem2T(manager, p, c, m2t, enabledHover, openMenus, closeMenus, height, borders)
			)
		}
		MCols(cont): {
			TColsDir(map(cont, \c -> MMenuPanelItem2T(manager, parent, c, m2t, enabledHover, openMenus, closeMenus, height, borders)), parent.rtl)
		}
		MSeparator(__): {
			m2t(MSeparator(false), parent)
			|> (\f -> TBorder(8., borders + 2., 8., borders + 2., f))
		}
		MConstruct(cons, c): {
			TConstruct(cons, MMenuPanelItem2T(manager, parent, c, m2t, enabledHover, openMenus, closeMenus, height, borders))
		}
		default: {
			m2t(item, parent)
			|> TCenterY
		}
	}
}

MMenuPanel2T(manager : MaterialManager, parent : MFocusGroup, m : MMenuPanel, m2t : (Material, MFocusGroup) -> Tropic) -> Tropic {
	style = m.style;
	items = m.items;

	height = extractStruct(style, MHeight(52.)).height;
	borders = extractStruct(style, MBorders(8.)).borders;
	cropByContent = contains(style, MScrollCropByContent());
	enabledHover = if (extractStruct(style, MExpandOnHover(true)).expand) Some(make(false)) else None();
	bgColor = extractStruct(style, MMenuPanelBackground(MSurfaceColor())).color;
	bgStyle = extractStruct(style, MBackgroundStyle([MThemeFill(parent, bgColor)])).style;
	elevation = extractStruct(style, MElevation(const(4.0))).elevation;
	openMenus = ref [];

	closeMenus = \ -> {
		iter(^openMenus, \om -> nextDistinct(om.opened, false))
	};

	(\p ->
		MGetFocusGroup(\p2 ->
			map(items, \i -> MMenuPanelItem2T(manager, p2, i, m2t, enabledHover, openMenus, closeMenus, height, borders))
			|> (\f ->
				if (cropByContent)
					TColsDir(f, p2.rtl)
				else
					TColsDir(f, p2.rtl)
					|> (\t -> TAlignStartDir(t, p.rtl))
			)
			|> TBorderLeftRight(8.)
		)
		|> (\f ->
			MScroll2T(
				manager,
				p,
				MScroll(
					f,
					TFillXH(height),
					[TScrollbars(invisibleScrollBar, invisibleScrollBar)]
					|> (\f2 -> ifArrayPush(f2, cropByContent, MScrollCropByContent()))
				),
				m2t
			)
		)
		|> (\f -> TFrame(0., 0., bgStyle, f))
		// |> (\f -> TAvailable(f, TFillXH(height)))
		|> (\f -> TShadowShape(p, elevation, f, BottomRectangleShape()))
		// |> (\f3 -> if (^fAccessibilityEnabled) TAccess([AccessRole("menubar")], f3) else f3)
		|> makeTropicConstantHeight(Some(height))
	)
	|> (\f ->
		MComponentGroup2T(manager, parent, "MMenuPanel",
			concat(
				eitherMap(enabledHover, \eh -> [IScriptBehaviour("hover_enabled", eh, ISEnableEvent())], []),
				filtermap(style, \s ->
					switch (s) {
						MComponentGroupState(): {a : Maybe<MComponentGroupState> = Some(s); a};
						default: None();
					}
				)
			),
			f
		)
	)
}

MDropDownMenu2T(
	manager : MaterialManager, parent : MFocusGroup, m : MDropDownMenu, m2t : (Material, MFocusGroup) -> Tropic
) -> Tropic {
	items = m.items;
	current = m.current;
	style = m.style;

	openMenu : MOpenMenu = extractStruct(style, MOpenMenu(make(false)));
	tableRow = contains(style, MDataTableRow());
	tableFooter = contains(style, MDataTableFooter());
	customButton = tryExtractStruct(style, MCustomButton(TEmpty()));
	enabled = extractStruct(style, MEnabled(const(true))).enabled;
	nonSpecified : MNonSpecifiedLine = extractStruct(style, MNonSpecified(MMenuSingleLine(_("Pick"), []))).item;
	croppedButton = contains(style, MCroppedButton());
	lineBorders = extractStruct(style, MMenuLineBorders(if (tableFooter) 16. else 24.)).borders;
	currentInner = cloneBehaviour(current);
	leftIcon = isSome(tryExtractStruct(style, MLeftIcon("", [])));
	addClear = contains(style, MAddClearButton());
	label = switch (nonSpecified) {
		MMenuSingleLine(title, __) : title;
		MMenuCustomLine(__, __) : "";
	};
	buttonTitle : MButtonTitle = extractStruct(style, MButtonTitle(const(label)));

	iconSize = if (tableRow || tableFooter) 16.0 else 20.0;
	iconBorders = extractStruct(style, MDropDownMenuIconBorders(MIconBorder4(0., 0., 0., 0.))).borders;

	icon =
		MDropDownIcon(openMenu.opened, [MIconSize(iconSize), iconBorders])
		|> (\t -> if (addClear) MCols2A(t, MDropDownClearIcon(current, -1, iconSize)) else t)
		|> MCenterY;

	addDropDownIcon = \st -> replaceStruct(st, MSecondaryAction(MCols2A(extractStruct(st, MSecondaryAction(TEmpty())).content, icon)));

	addIcons = \f : MDropDownMenuLine ->
		switch (f) {
			MMenuSingleLine(title, style0):	MMenuSingleLine(title, addDropDownIcon(style0));
			MMenuCustomLine(content, style0): MMenuCustomLine(content, addDropDownIcon(style0));
			MSeparatorLine(): f;
			MMenuGroupLine(__,__): f;
		}
	selected = MSingleSelection(currentInner);
	closed = ref !getValue(openMenu.opened);

	focusState =
		replaceStructMany(
			extractMComponentGroupState(m.style),
			[
				IScriptBehaviour(
					"selected",
					current,
					ISInputValue(map(items, \item -> {
							switch (item) {
								MMenuSingleLine(title, __) : title;
								default : "";
							}
						}),
						"index",
						true
					)
				)
			]
		);

	onClick = \ -> if (^closed) next(openMenu.opened, true);
	mWidth =
		extractStruct(style, MWidth(0.)).width
		|> (\f2 ->
			if (f2 != 0.)
				f2
			else
				MMenuLines2MPopup(
					manager,
					arrayPush(items, nonSpecified)
					|> (\f3 : [MDropDownMenuLine] -> if (isNone(customButton)) map(f3, addIcons) else f3),
					MDropDownMenuStyle2MMenuStyle(style),
					m2t,
					const(zeroPositionScale),
					const(WidthHeight(0., 0.)),
					0.,
					nop,
					"",
					None()
				).items
				|> MGrid
				|> (\f3 -> m2t(f3, parent))
				|> (\f3 -> getTWordMetrics(f3, makeTree()).width) // TODO : Rework without using getTWordMetrics
		);

	popupId = getPopupId(manager);
	buttonFocused = extractStruct(style, MFocused(make(false)));

	menuStyle =
		style
		|> (\st -> replaceStruct(st, MWidth(mWidth)))
		|> (\st -> replaceStruct(st, openMenu))
		|> (\st -> replaceStruct(st, MFocusName("MDropDownMenu")))
		|> (\st -> replaceStruct(st, buttonFocused))
		|> (\st -> addStyleIfAbsent(st, buttonTitle))
		|> MDropDownMenuStyle2MMenuStyle
		|> (\st -> arrayPush(st, selected))
		|> (\st -> ifArrayPush(st, isNone(customButton) && mWidth >= 0.0, MWidthByButton()))
		|> (\st -> if (contains(style, MNonSpecifiedAlwaysOnTop())) arrayPush(st, MMenuNonSpecifiedAlwaysOnTop(nonSpecified)) else st)
		|> (\st -> arrayPush(st, MBelowButton()));

	MGetFocusGroup(\p ->
		eitherFn(
			customButton,
			\cb ->
				MMenuButton2T(manager, p, cb.button, m2t, openMenu, enabled, true, None(), Some(buttonTitle), popupId, extractMButtonState(style))
				|> (\f -> TBaselineOffset(const(-12.), f)),
			\ -> {
				lItems = length(items);

				MDropDownMenuButton2T(
					manager,
					p,
					fselect(currentInner, FLift(\c ->
						(if (c >= 0 && lItems > 0) {
							it = if (c >= lItems) {
								next(currentInner, lItems - 1);

								items[length(items) - 1];
							} else items[c];

							switch (it) {
								MMenuSingleLine(__, __): it;
								MMenuCustomLine(__, __): it;
								default: {
									next(currentInner, -1);
									nonSpecified
								}
							}
						} else
							nonSpecified)
						|> (\f -> {
							newStyle =
								addDropDownIcon(f.style)
								|> (\s -> replaceStruct(s, MEnabled(enabled)));

							switch (f : MNonSpecifiedLine) {
								MMenuSingleLine(__, __): MMenuSingleLine(f.title, newStyle);
								MMenuCustomLine(__, __): MMenuCustomLine(f.content, newStyle);
							}
						})
					)),
					replaceStructMany(style, [MWidth(mWidth), openMenu]),
					onClick,
					getLightBackground(p),
					popupId,
					m2t
				)
			}
		)
	)
	|> (\f -> MDynamicMenu(f, const(items), menuStyle))
	|> (\f -> MDynamicMenu2TInner(manager, parent, f, m2t, Some(popupId)))
	|> (if (croppedButton) TBorderLeftRight(-lineBorders) else idfn)
	|> (\f ->
		TConstruct(
			[
				\ -> makeBidirectionalLink(current, currentInner,
					\c -> foldi(items, -1, \i, acc, it -> {
						if (acc < c && (isSameStructType(it, MMenuSingleLine("", [])) ||
								isSameStructType(it, MMenuCustomLine(TEmpty(), [])))) {
							if (acc == c - 1) i	else acc + 1
						} else acc
					}),
					\ci -> {
						if (ci >= 0) {
							countA(subrange(items, 0, ci), \it -> {
								isSameStructType(it, MMenuSingleLine("", [])) || isSameStructType(it, MMenuCustomLine(TEmpty(), []))
							})
						} else -1
					},
					!contains(style, MForceUpdate())
				),
				makeSubscribe(openMenu.opened, \opn -> if (opn) closed := false else timer(100, \ -> closed := true))
			],
			f
		)
	)
	|> (
		if (isNone(customButton) && mWidth > 0.)
			makeTropicConstantWidth(Some(mWidth + (if (leftIcon) 72. else 0.) - (if (croppedButton) 2. * lineBorders else 0.)))
		else
			idfn
	);
}

MMultiSelectDropDown2T(
	manager : MaterialManager,
	parent : MFocusGroup,
	m : MMultiSelectDropDown,
	m2t : (Material, MFocusGroup) -> Tropic
) -> Tropic {
	items = m.items;
	selected = m.selected;
	style = m.style;

	leftIcon = isSome(tryExtractStruct(style, MLeftIcon("", [])));
	width = extractStruct(style, MWidth(200.)).width |> (\f -> if (leftIcon) f - 72. else f);
	croppedButton = contains(style, MCroppedButton());
	lineBorders = extractStruct(style, MMenuLineBorders(24.)).borders;
	enabled = extractStruct(style, MEnabled(const(true))).enabled;
	nonSpec = extractStruct(style, MNonSpecifiedString(_("Pick"))).item;
	lineHeight = extractStruct(style, MCustomLineHeight(32.)).height;
	maxHeight = extractStruct(style, MMaxHeight(-1.)).height;
	onItemClick = extractStruct(style, MOnItemClick(nop2)).fn;
	addDoneBtn = contains(style, MAddDoneButton());
	textStyle = extractStruct(style, MCustomTextStyle([])).style
				|> (\arr ->  if (arr == []) [MSubheading()] else arr);

	selectedStyle = extractStruct(style, MSelectedItemStyle(MAccentColor(), MWhite()));
	selectedTextColor = selectedStyle.textColor;
	selectedBgColor = selectedStyle.bgColor;

	leftDecorations = extractStruct(style, MLeftDecorations([])).extraItems;
	rightDecorations = extractStruct(style, MRightDecorations([])).extraItems;

	addClear = contains(style, MAddClearButton());
	showTooltip = extractStruct(style, MShowTooltip(const(true)));
	customButton = tryExtractStruct(style, MCustomButton(TEmpty()));
	outlined = contains(style, MOutlined());

	opened = make(false);
	onClick = \ -> nextDistinct(opened, true);

	iconSize = 20.;
	iconBorders = extractStruct(style, MDropDownMenuIconBorders(MIconBorder4(0., 0., 0., 0.))).borders;
	icon =
		MDropDownIcon(opened, [MIconSize(iconSize), iconBorders])
		|> (\t -> if (addClear) MCols2A(t, MDropDownClearIcon(selected, [], iconSize)) else t)
		|> MCenterY;

	iconNearTitle = contains(style, MDropDownIconNearTitle());
	defButtonLineStyle = [MDisableHover(), MEnabled(enabled), MSecondaryAction(icon)];

	popupId = getPopupId(manager);

	defMenuButton =
		MDropDownMenuButton2T(
			manager,
			parent,
			fif(
				fselect(selected, FLift(\s -> length(s) > 0 && length(items) > 0)),
				const(MMenuCustomLine(
					MSelect(selected, \s ->
						MEllipsisText(
							strGlue(
								foldi(items, [], \i, arr, item ->
									ifArrayPush(arr, contains(s, i), item)
								) |> arrayRTL2(parent.rtl),
								", "
							),
							arrayPush(textStyle, showTooltip)
						)
					)
					|> MAlignStart,
					defButtonLineStyle
				)),
				const(MMenuSingleLine(nonSpec, defButtonLineStyle))
			),
			replaceStructMany(
				extractMButtonState(style),
				concatA([
					[MWidth(width + (if (croppedButton) lineBorders * 2. else 0.)), MCustomLineHeight(lineHeight)],
					if (iconNearTitle) [MDropDownIconNearTitle()] else [],
					if (croppedButton) [MCroppedButton()] else [],
					if (outlined) [MOutlined(), MNonSpecified(MMenuSingleLine(nonSpec, [])), MOpenMenu(opened)] else [],
					eitherMap(tryExtractStruct(style, MDropDownMenuDisabledOpacity(const(0.0))), \v -> [v], []),
				])
			),
			onClick,
			getLightBackground(parent),
			popupId,
			m2t
		);

	menuButton =
		eitherMap(
			customButton,
			\cb ->
				MMenuButton2T(
					manager,
					parent,
					cb.button,
					m2t,
					MOpenMenu(opened),
					enabled,
					true,
					None(),
					tryExtractStruct(m.style, MButtonTitle(const(""))),
					popupId,
					extractMButtonState(style)
				)
				|> (\f -> TBaselineOffset(const(-12.), f)),
			defMenuButton
		)
		|> (if (croppedButton) TBorderLeftRight(-lineBorders) else idfn);

	dropDownLines =
		if (length(items) == 0) []
		else
			MList(
				mapi(items, \i, item -> {
					isSelectedB = fselect(selected, FLift(\s -> contains(s, i)));
					MCustomLine(
						MBaselineColsA([
							MVisible(
								isSelectedB,
								MIcon("check", [selectedTextColor])
							),
							MFixedX(4.),
							MSelect(isSelectedB, \isSelected ->
								MEllipsisText(
									item,
									ifArrayPush(textStyle, isSelected, selectedTextColor)
									|> (\arr -> arrayPush(arr, showTooltip))
								)
							)
							|> MAlignStart
						])
							|> (\f -> MGroup2(MFixedY(lineHeight), MCenterY(f)))
							|> (\f -> MGroup2(TFillX(), f))
							|> MBorderLeftRight(lineBorders),
						concat(
							if (existsIndex(leftDecorations, i)) [MPrimaryAction(leftDecorations[i])] else [],
							if (existsIndex(rightDecorations, i)) [MSecondaryAction(rightDecorations[i])] else [],
						)
					)
				}), [
					MAddScroll(Some(TScrollInspectVisible(
						make(zeroPoint),
						make(WidthHeight(
							width,
							if (maxHeight > 0.0) min(maxHeight, lineHeight * i2d(length(items)))
							else lineHeight * i2d(min(6, length(items))))
						)
					))),
					MSelectedBackgroundStyle([MThemeFill(parent, selectedBgColor), FillOpacity(0.2)])
				] , [
					MOnListClick(const(true), \i -> onItemClick(i, contains(getValue(selected), i))),
					MListSelection(make(true), true, true, selected)
				]
			)
			|> MBorderLeftRight(-lineBorders)
			|> (\m2 -> if (addDoneBtn) MLines2(m2,
					MTextButton(
						"DONE",
						\ -> next(opened, false),
						[MButtonRaised()],
						[]
					)
					|> MCenterX
					|> MBorderTop(8.)
				)
				else m2
			)
			|> (\m2 -> MMenuCustomLine(m2, [MDisableHover(), MClickEnabled(const(false)), MEnabled(enabled)]))
			|> v2a;

	MDynamicMenu(
		menuButton,
		const(dropDownLines),
		ifArrayPush([MOpenMenu(opened), MWidthByButton(), MMenuLineBorders(lineBorders)], outlined, MBelowButton())
	)
	|> (\f -> MDynamicMenu2TInner(manager, parent, f, m2t, Some(popupId)))
}

MMenuTitle2T(
	manager : MaterialManager,
	parent : MFocusGroup,
	title : Transform<string>,
	lineHeight : double,
	selectedColor : MColor,
	selected : bool,
	widthByButton : bool,
	width : double,
	showTooltip : Transform<bool>,
	textStyle : [MTextStyle],
	inspectMetrics : Maybe<Pair<DynamicBehaviour<double>, DynamicBehaviour<double>>>,
	m2t : (Material, MFocusGroup) -> Tropic
) -> Tropic {
	TSelect(title, \t ->
		if (t != "")
			(if (width > 0. || widthByButton)
				MEllipsisText2T(
					manager,
					parent,
					MEllipsisText(
						t,
						arrayPush(
							if (selected)
								replaceStruct(textStyle, selectedColor)
							else
								textStyle,
							MShowTooltip(showTooltip)
						)
					),
					m2t
				)
			else
				MText2T(
					parent,
					t,
					if (selected)
						replaceStruct(textStyle, selectedColor)
					else
						textStyle
				))
			|> (\f -> eitherMap(inspectMetrics, \insp -> TInspect([IBaseline(insp.first), Height(insp.second)], f), f))
			|> (\f -> TAlignStartDir(f, parent.rtl))
			|> (\f -> TCenterYIn(f, TFixed(0., lineHeight)))
		else
			TEmpty()
	)
}

MMenuPrimaryAction2T(
	manager : MaterialManager,
	parent : MFocusGroup,
	style : [flow],
	lineHeight : double,
	lineBorders : double,
	color : MColor,
	selectedColor : MColor,
	selected : bool,
	indent : bool,
	m2t : (Material, MFocusGroup) -> Tropic
) -> Tropic {
	eitherMap(
		tryExtractStruct(style, MPrimaryAction(TEmpty())),
		\pa ->
			MListIcon2T(manager, pa.content, color, selectedColor, m2t).first(selected, parent)
			|> (\t -> TCenterYIn(t, TFixed(0., lineHeight)))
			|> TBorderLeft(lineBorders)
			|> (\f -> TFixSize(f, TFixed(40. + lineBorders, lineHeight))),
		TFixed(lineBorders + if (indent) 40. else 0., 0.)
	);
}

MMenuSecondaryAction2T(
	parent : MFocusGroup,
	style : [flow],
	lineHeight : double,
	lineBorders : double,
	addPlayArrow : bool,
	m2t : (Material, MFocusGroup) -> Tropic
) -> Tropic {
	eitherFn(
		tryExtractStruct(style, MSecondaryAction(TEmpty())),
		\sa -> [m2t(sa.content, parent)],
		\ -> []
	)
	|> (\secondaryAction ->
		eitherMap(
			tryExtractStruct(style, MAdditionalText("")),
			\at -> arrayPush(secondaryAction, MText2T(parent, at.text, [MSubheading()])),
			secondaryAction
		)
	)
	|> (\secondaryAction -> ifArrayPush(secondaryAction, addPlayArrow, MIcon2T(parent, "play_arrow", [MIconSize(16.)])))
	|> (\secondaryAction ->
		if (length(secondaryAction) > 0)
			TCenterIn(TBorder(8., 0., lineBorders, 0., TBaselineColsDir(secondaryAction, parent.rtl)), TFixed(0., lineHeight))
		else
			TFixed(lineBorders, 0.)
	);

}

MDropDownMenuButton2T(
	manager : MaterialManager,
	parent : MFocusGroup,
	lineB : Transform<MNonSpecifiedLine>,
	style0 : [MDropDownMenuStyle],
	onClick : () -> void,
	lightBackground : bool,
	popupId : string,
	m2t : (Material, MFocusGroup) -> Tropic
) -> Tropic {
	condensed = extractStruct(style0, MCondensed(true)).condensed;
	tableRow = contains(style0, MDataTableRow());
	tableFooter = contains(style0, MDataTableFooter());
	lineHeight = extractStruct(style0, MCustomLineHeight(32.)).height;
	mWidth = extractStruct(style0, MWidth(-1.)).width;
	croppedButton = contains(style0, MCroppedButton());
	lineBorders0 = extractStruct(style0, MMenuLineBorders(if (tableFooter) 16. else 24.)).borders;
	buttonBorders = extractStruct(style0, MDropDownMenuButtonBorder(lineBorders0)).border;
	lineBorders = if (croppedButton) 0. else buttonBorders;
	color : MColor = extractStruct(style0, if (lightBackground) MBlack() else MWhite());
	selectedColor = MThemeColor2MColor(parent, extractStruct(style0, MSelectedColor(MAccentColor())).color);
	textStyle = [
		if (!condensed) MSubheading() else if (tableFooter) MCaption() else if (tableRow) MDataRow() else MSubheading(),
		color
	];
	outlined = contains(style0, MOutlined());
	nonSpecified : MNonSpecifiedLine = extractStruct(style0, MNonSpecified(MMenuSingleLine(_("Pick"), []))).item;
	label = \line -> switch (line : MDropDownMenuLine) {
		MMenuSingleLine(title, __) : title;
		default : "";
	};
	nonSpecifiedLabel = label(nonSpecified);
	separators = !outlined && extractStruct(style0, MSeparators(true)).separators;
	showTooltip = extractStruct(style0, MShowTooltip(const(false))).show;
	indent = contains(style0, MMenuIndent());
	openMenu = extractStruct(style0, MOpenMenu(make(false))).opened;
	iconNearTitle = contains(style0, MDropDownIconNearTitle());
	
	focusState =
		replaceStructMany(
			extractMButtonState(style0),
			[
				MEnabled(fsubselect(lineB, FLift(\line -> extractStruct(line.style, MEnabled(const(true))).enabled))),
				MOnClick(onClick),
				MRippleType(const(MRippleFill())),
				MHighlightOnFocus(const(true)),
				MHighlightOnHover(const(true)),
				FAccessAttribute("aria-haspopup", const("menu")),
				FAccessAttribute("aria-expanded", fif(openMenu, const("true"), const(""))),
				FAccessAttribute("aria-owns", fif(openMenu, const(popupId), const(""))),
				extractStruct(style0, MButtonTitle(fselect(lineB, label |> FLift)))
			]
		);

	outlineColor = fif(openMenu, const(selectedColor), const(color));
	dynColor = make(color);
	floatingLabelProgress = make(1.);
	labelWidth = make(0.);

	pAc = \st -> MMenuPrimaryAction2T(manager, parent, st, lineHeight, lineBorders, color, color, false, indent, m2t);
	sAc = \st -> MMenuSecondaryAction2T(parent, st, lineHeight, lineBorders, false, m2t);

	addActions = \st -> \t ->
		TColsDir([
			pAc(st),
			t,
			sAc(st)
		], parent.rtl)
		|> (\t2 -> if (iconNearTitle) TGroup2(t2, TFillX()) else t2);

	alpha = \focus ->
		eitherMap(
			tryExtractStruct(style0, MDropDownMenuDisabledOpacity(const(0.))),
			\do -> fif(focus.enabled, const(1.), do.opacity),
			getMenuAlpha(focus, parent)
		);

	setMenuBaseline = \avH, height, baseline ->
		\t -> TBaseline(faddition(baseline, fmax(zero, fdivide(fsubtract(avH, height), const(2.)))), t);

	floatingLabelOffset = \st -> eitherMap(
		tryExtractStruct(st, MPrimaryAction(TEmpty())),
		\__ -> 52.,
		12.
	);

	TSelect(lineB, \line ->  // Display chosen item when not expanded
		switch (line) {
			MMenuSingleLine(title, style): {
				lineTextStyle = extractStruct(style, MCustomTextStyle(textStyle)).style;
				baseline = make(0.);
				height = make(0.);

				MMenuTitle2T(manager, parent, const(title), lineHeight, color, false,
					false, mWidth, showTooltip, lineTextStyle, Some(Pair(baseline, height)), m2t
				)
				|> (\t -> TAlignStartDir(t, parent.rtl))
				|> (\t ->
					if (outlined) {
						isNonSpec = title == nonSpecifiedLabel;
						trigger = if (isNonSpec) fstall(openMenu, 66) else const(true);
						showLabel = if (isNonSpec) fneq(floatingLabelProgress, 1.) else const(true);
						showTitle = if (isNonSpec) feq(floatingLabelProgress, 1.) else const(true);

						characterStyle = MTextStyle2CharacterStyle(parent, lineTextStyle);
						labelSize = extractStruct(characterStyle, FontSize(14.)).size;
						offset = floatingLabelOffset(style);
						TGroup2(
							TVisible(showTitle, t),
							TVisible(
								showLabel,
								makeMFloatingLabel(manager, parent, nonSpecifiedLabel,
									MFloatingLabelState(floatingLabelProgress, trigger, 12., labelSize, -offset, offset, -8., 16.),
									const(characterStyle),
									Some(MDynamicColor(dynColor)),
									labelWidth, m2t
								)
							)
						)
					}
					else t
				)
				|> (\f -> if (iconNearTitle) f else TGroup2(TFillX(), f))
				|> addActions(style)
				|> setMenuBaseline(const(lineHeight), height, baseline)
			}
			MMenuCustomLine(content, style): {
				availableH = make(0.);
				height = make(0.);
				baseline = make(0.);
				offset = floatingLabelOffset(style);

				m2t(MAlignStart(content), parent)
				|> (\t -> TInspect([IAvailableHeight(availableH), Height(height), IBaseline(baseline)], t))
				|> TCenterY
				|> (\t ->
					if (outlined)
						TGroup2(
							t,
							makeMFloatingLabel(manager, parent, nonSpecifiedLabel,
								MFloatingLabelState(floatingLabelProgress, const(true), 12., 14., -offset, offset, -8., 16.),
								const([]),
								Some(MDynamicColor(dynColor)),
								labelWidth, m2t
							)
						)
					else t
				)
				|> (\f -> if (iconNearTitle) f else TGroup2(TFillX(), f))
				|> addActions(style)
				|> setMenuBaseline(availableH, height, baseline)
			}
		}
	)
	|> (\f ->
		MComponent2T(manager, parent, "MDropDownMenuButton", focusState, \focus ->
			TAlpha(alpha(focus), f), m2t
		)
	)
	|> (\f -> if (outlined) {
			addMOutline(
				manager,
				parent,
				labelWidth,
				floatingLabelProgress,
				fselect(outlineColor, FLift(\oc ->
					MGraphicsState(1., MColor2int(oc), 1., true)
				)),
				dynColor
			)(f)
		} else f)
	|> (\f ->
		if (tableFooter || tableRow || !separators)
			f
		else if (croppedButton)
			TBaselineLines2(
				f |> TBorderBottom(-1.),
				m2t(MSeparator(true), parent)
			)
		else
			TLines2(
				m2t(MSeparator(true), parent),
				TBaselineLines2(
					f |> TBorderTopBottom(-1.),
					m2t(MSeparator(true), parent)
				)
			)
	)
	|> (if (croppedButton)
			TBorderLeftRight(buttonBorders)
		else
			idfn)
	|> (\f -> TAvailable(f, if (mWidth < 0.) TFillX() else TFixed(mWidth, 0.)))
	|> makeTropicConstantWidth(Some(mWidth))
}

MMenuTextButton2T(
	manager : MaterialManager,
	parent : MFocusGroup,
	text : string,
	shortcut : string,
	onClick : () -> void,
	style : [MTextButtonStyle],
	openMenu : MOpenMenu,
	m2t : (Material, MFocusGroup) -> Tropic
) -> Tropic {
	raised = contains(style, MButtonRaised());
	color = extractStruct(style, getTextColor(parent));
	buttonTextColor = tryExtractStruct(style, MButtonTextColor(false));
	fullWidth = contains(style, MFullWidth());
	focusState =
		[
			MOnClick(\ -> {
				onClick();
				reverseBehaviour(openMenu.opened)
			}),
			MRippleType(const(MRippleFill())),
			extractStruct(style, MButtonTitle(const(text)))
		];

	disabled = \ ->
		MText2T(
			parent,
			text,
			[MSecondaryButtonStyle(), MTextDisabled(), getTextColor(parent)]
		)
		|> MGridCenterX
		|> TBorderLeftRight(14.)
		|> TBorderTopBottom(6.)
		|> (\f -> if (fullWidth) TCenterX(f) else f)
		|> (\f ->
			TFrame(
				0.0,
				4.0,
				[
					Fill(contrastingColor(parent)),
					FillOpacity(if (raised) 0.12 else 0.0)
				],
				f
			)
		);

	(\ ->
		MText2T(
			parent,
			text,
			[
				MSecondaryButtonStyle(),
				if (raised) {
					eitherFn(
						buttonTextColor,
						\btc -> if (btc.white) MWhite() else MBlack(),
						\ -> MTextMColor(color)
					)
				} else {
					color
				}
			]
		)
		|> MGridCenterX
		|> TBorderLeftRight(14.)
		|> TBorderTopBottom(6.)
		|> (\f -> if (fullWidth) TCenterX(f) else f)
	)
	|> (\f ->
		MComponent2T(
			manager,
			parent,
			"MMenuTextButton",
			focusState,
			\focus -> {
				(\ -> if (raised) {
					z =
						fselect2(
							fOr(fOr(focus.hover, openMenu.opened), focus.focused), focus.down,
							FLift2(\h, d -> if (d) 6. else if (h) {if (getLightBackground(parent)) 2. else 3.} else 0.)
						);

					TFrame(
						0.0,
						4.0,
						[
							MFill(color),
							FillOpacity(1.0)
						],
						f()
					)
					|> (\f2 -> TEasedShadow(manager, parent, z, f2, 0.3))
				} else {
					TCopySize(
						f(),
						\tr ->
							TIfLazy2(
								fOr(fOr(focus.hover, openMenu.opened), focus.focused), \foc ->
								TFrame(
									0.0,
									4.0,
									if (foc) [
										Fill(if (getLightBackground(parent)) 0x999999 else 0xcccccc),
										FillOpacity(if (getLightBackground(parent)) 0.2 else 0.15)
									] else interactiveRectangleStyle,
									tr
								),
								true
							),
						false
					)
				})
				|> (\f2 -> TIfLazy2(focus.enabled, \en -> if (en) f2() else disabled(), false))
			},
			m2t
		)
	)
	|> (\f -> TBaselineOffset(const(-10.0), f))
}

MMenuLines2MPopup(
	manager : MaterialManager,
	items0 : [MMenuLine],
	style0 : [MMenuStyle],
	m2t : (Material, MFocusGroup) -> Tropic,
	posScale : Transform<PositionScale>,
	buttonWH : Behaviour<WidthHeight>,
	elevation : double,
	closeBelow : () -> void,
	popupId : string,
	focusedItem : Maybe<MMenuFocusedItem>
) -> MPopup {
	tableRow = contains(style0, MDataTableRow());
	tableFooter = contains(style0, MDataTableFooter());
	condensed = extractStruct(style0, MCondensed(true)).condensed;
	maxHeight = extractStruct(style0, MMaxHeight(-1.));
	mWidth = extractStruct(style0, MWidth(-1.)).width;
	widthByButton = contains(style0, MWidthByButton());
	singleSelection = tryExtractStruct(style0, MSingleSelection(make(-1)));
	selectedId = eitherMap(singleSelection, \ss -> getValue(ss.selected), -1);
	selectedColor : (MFocusGroup) -> MColor = \parent -> MThemeColor2MColor(parent, extractStruct(style0, MSelectedColor(MAccentColor())).color);
	openMenu = extractStruct(style0, MOpenMenu(make(false)));
	onListClick = extractStruct(style0, MOnListClick(const(true), nop1));
	indent = contains(style0, MMenuIndent());
	belowButton = contains(style0, MBelowButton());
	fixPosition = tryExtractStruct(style0, MFixPosition(true));
	selectedOnTop = tryExtractStruct(style0, MSelectedAlwaysOnTop(MMenuSingleLine("", [])));
	nonspecAlwaysOnTopM = tryExtractStruct(style0, MMenuNonSpecifiedAlwaysOnTop(MSeparatorLine()));
	nonspecAlwaysOnTop = isSome(nonspecAlwaysOnTopM);
	indexShift = nonspecAlwaysOnTop || (isSome(selectedOnTop) && isSome(singleSelection));
	dpiScale = extractStruct(manager.manager.renderStyle, TInspectDpiFactor(make(Factor(1.0, 1.0)))).factor;
	menuShift = extractStruct(style0, MMenuShift(const(zeroPoint))).shift;
	showTooltip = extractStruct(style0, MShowTooltip(const(false))).show;
	customScale = tryExtractStruct(style0, MCustomScale(const(Factor(1., 1.))));
	cols = if (indexShift) 0 else extractStruct(style0, MMenuCols(1)).cols - 1;
	mLabel = tryExtractStruct(style0, MLabel(""));
	sameZorder = extractStruct(style0, MSameZorder(false)).same;
	nextFn = if (contains(style0, MForceUpdate())) next else nextDistinct;
	focusName = extractStruct(style0, MFocusName("MMenu")).name;
	popupRole = extractStruct(style0, AccessRole(if (strContains(toLowerCase(focusName), "drop")) "listbox" else "menu")).role;

	menuScrollStyle = extractStruct(style0, MMenuScrollStyle([])).style;

	checkCols = \acc : Pair<int, [[(MFocusGroup) -> Tropic]]> -> \f : (MFocusGroup) -> Tropic ->
		if (acc.first < cols && length(acc.second) > 0)
			Pair(acc.first + 1, arrayPush(removeIndex(acc.second, length(acc.second) - 1), arrayPush(lastElement(acc.second, []), f)))
		else
			Pair(0, arrayPush(acc.second, [f]));

	items1 : [MMenuLine] =
		(if (indexShift) {
			concat(
				[
					eitherMap(
						nonspecAlwaysOnTopM,
						\nsaot -> nsaot.emptySelection,
						if (selectedId < 0)
							eitherMap(selectedOnTop, \sot -> sot.emptySelection, MSeparatorLine())
						else
							MSeparatorLine()
					),
					MSeparatorLine()
				],
				items0
			)
		} else {
			items0;
		});

	hovered = make(-1);
	activeDescendantId = make("");

	leftAnimation =
		widthByButton ||
		(if (mWidth > 0.)
			fgetValue(posScale).pos.x / getValue(dpiScale).x + mWidth <= getRealStageWidthHeight(manager).width
		else
			fgetValue(posScale).pos.x / getValue(dpiScale).x <= getRealStageWidthHeight(manager).width / 2.);

	lineHeight = extractStruct(style0, MCustomLineHeight(if (!condensed) 48. else 32.)).height;
	textStyle = [if (!condensed) MSubheading() else if (tableFooter) MCaption() else if (tableRow) MDataRow() else MSubheading()];
	borders = if (lineHeight == 32.) 16. else 8.;
	lineBorders = extractStruct(style0, MMenuLineBorders(if (tableFooter) 16. else 24.)).borders;
	iconSize = if (tableRow || tableFooter) 16.0 else 20.0;
	iconBorders = extractStruct(style0, MDropDownMenuIconBorders(MIconBorder4(0., 0., 0., 0.))).borders;

	dropDownIcon =
		MDropDownIcon(openMenu.opened, [MIconSize(iconSize), iconBorders])
		|> (\m -> MCenterYIn(m, TFixed(0., lineHeight)));

	shiftGap = if (indexShift) 2 else 0;
	onItemClick = \i, click -> \ -> {
		nextDistinct(openMenu.opened, false);
		closeBelow();

		if (i >= shiftGap) {
			timer(50, \ ->
				maybeApply(singleSelection, \ss -> nextFn(ss.selected, i - shiftGap))
			);
			if (fgetValue(onListClick.enabled)) onListClick.onClick(i - shiftGap);
			click(); // action is moved outside delayed code - to solve issue with copying something to clipboard in a firefox.
		} else if (nonspecAlwaysOnTop && i == 0) maybeApply(singleSelection, \ss -> nextFn(ss.selected, -1))
	};

	itemOnTop = \i -> {
		indexShift && (
			if (nonspecAlwaysOnTop) i == 0
			else (selectedId >= 0 && i == selectedId + 2) || (selectedId == -1 && i == 0)
		);
	}

	getLineStyle = \style, i ->
		if (itemOnTop(i))
			replaceStruct(style,
				MSecondaryAction(
					MCols2A(
						extractStruct(style, MSecondaryAction(TEmpty())).content,
						dropDownIcon
					)
				)
			)
		else
			style;

	nearTitle = contains(style0, MDropDownIconNearTitle());

	addActions = \parent, style, selected, addPlayArrow -> \t ->
		TColsDir([
			MMenuPrimaryAction2T(manager, parent, style, lineHeight, lineBorders, getTextColor(parent),
				selectedColor(parent), selected, indent, m2t),
			t,
			MMenuSecondaryAction2T(parent, style, lineHeight, lineBorders, addPlayArrow, m2t)
		], parent.rtl)
		|> (\t2 -> if (nearTitle) TGroup2(t2, TFillX()) else t2);

	makeTitle = \parent, lineTextStyle, ttl, selected, onTop ->
		MMenuTitle2T(manager, parent, ttl, lineHeight, selectedColor(parent), selected,
			widthByButton, mWidth, showTooltip, lineTextStyle, None(), m2t
		)
		|> (\t -> TAlignStartDir(t, parent.rtl))
		|> (\f -> if (onTop && nearTitle) f else TGroup2(TFillX(), f));

	addLabel = \t ->
		eitherMap(
			mLabel,
			\lbl ->
				concat(
					[[
						\p ->
							makeTitle(p, [MBodyBold(), MPrimaryColor()], const(lbl.label), false, false)
							|> TBorderLeftRight(lineBorders)
							|> makeTropicConstantHeight(Some(lineHeight))
					]],
					t
				),
			t
		);

	focusOnOpen = \arr -> {
		focused = make(false);
		timer(50, \ -> nextDistinct(focused, true));
		arrayPush(arr, MFocused(focused))
	}

	makeMMenuLine = \i, title : Maybe<string>, content : Maybe<Material>, _style ->
		\parent -> {
			style = getLineStyle(_style, i);
			hgt = extractStruct(style, MHeight(lineHeight)).height;
			onClick = onItemClick(i, extractStruct(style, MOnClick(nop)).click);
			selected = selectedId == i && !indexShift;
			id = popupId + "_menuitem" + i2s(i);
			focusState =
				replaceStructMany(
					style,
					[
						MOnClick(onClick),
						extractStruct(_style, AccessRole(if (popupRole == "menu") "menuitem" else "option")),
						MRippleType(const(MRippleFill())),
						MHighlightOnFocus(const(true)),
						MHighlightOnHover(const(true)),
						MFocusOnDown(ref true),
						FAccessAttribute("id", const(id))
					]
					|> (\arr -> eitherMap(title, \t -> arrayPush(arr, extractStruct(_style, MButtonTitle(const(t)))), arr))
					|> (\arr -> 
						eitherMap(focusedItem,
							\fi ->
								if (
									((i == shiftGap) && fi == MMenuFirstItem())
									|| (i == length(items1) - 1 && fi == MMenuLastItem())
								)
									focusOnOpen(arr)
								else arr,
							if (i == selectedId + shiftGap || (selectedId == -1 && i == 0)) focusOnOpen(arr)
							else arr
						)
					)
				);
			lineTextStyle = extractStruct(style, MCustomTextStyle(arrayPush(textStyle, getTextColor(parent)))).style;

			MComponent2T(manager, parent, "MMenuSingleLine", focusState, \focus ->  // Display chosen item when expanded
				eitherFn(title,
					\t -> makeTitle(parent, lineTextStyle, const(t), selected, itemOnTop(i)),
					\ ->
						m2t(MAlignStart(either(content, TEmpty())), parent)
						|> (\t -> TCenterYIn(t, TFixed(0., hgt)))
						|> (\t -> TGroup2(TFillX(), t))
				)
				|> addActions(parent, style, selected, false)
				|> (\t ->
					TAlpha(
						getMenuAlpha(focus, parent),
						TFrame(0., 0., extractStruct(style0, MBackgroundStyle([])).style, t)
					)
				)
				|> (\f2 ->
					TConstruct(
						[
							makeSubscribe2(fmax(focus.hover, focus.down), \h -> if (h) nextDistinct(hovered, i)),
							makeSubscribe(focus.focused, \foc -> if (foc) nextDistinct(activeDescendantId, id))
						],
						f2
					)
				), m2t
			)
			|> if (isSome(title)) makeTropicConstantHeightDef(hgt) else idfn
		}

	makeMMenuGroupLine = \i, acc : Pair<int, [[(MFocusGroup) -> Tropic]]>, title, style -> {
		if (indexShift && i < length(items0) && selectedId >= 0 && selectedId == i - 1 && isSameStructType(items0[i], MMenuGroupLine("", []))) {
			acc
		} else {
			addLine = \parent, f ->
				if (((i - shiftGap) != 0) && !(indexShift && i > 3 && selectedId == i - 3 &&
						isSameStructType(items0[i - 4], MMenuGroupLine("", []))))
					TLines2(
						TAlpha(const(0.12), TRectangle([Fill(contrastingColor(parent))], TFillXH(1.0)))
						|> (\f2 -> TBorder(0.0, 16.0, 0.0, 8.0, f2)),
						f
					)
				else
					f;

			(\parent -> {
				groupColor = extractMColor(parent, style, MPrimaryColor());
				lineTextStyle = extractStruct(style, MCustomTextStyle([groupColor, MBodyBold()])).style;

				makeTitle(parent, lineTextStyle, const(title), false, false)
				|> addActions(parent, style, false, false)
				|> makeTropicConstantHeight(Some(lineHeight))
				|> (\f -> addLine(parent, f))
			})
			|> (\f -> Pair(cols, arrayPush(acc.second, concat([f], generate(0, cols, \__ -> \parent -> addLine(parent, TFillX()))))))
		}
	}

	makeMSubMenu = \i, title, items, style : [MSubMenuStyle] ->
		\parent -> {
			subOpenMenu : MOpenMenu = extractStruct(style, MOpenMenu(make(false)));
			subButtonWH = makeWH();
			subPosScale = make(zeroPositionScale);
			isOpenOnClick = contains(style, MSubMenuOpenOnClick());
			isCloseParentOnClick = extractStruct(style, MCloseParentOnClick(true)).close;
			subMenuPopupId = getPopupId(manager);

			focusState =
				replaceStructMany(
					style,
					[
						MOnClick(\ -> if (isOpenOnClick) deferred(\-> nextDistinct(subOpenMenu.opened, true))),
						AccessRole("menuitem"),
						FAccessAttribute("aria-haspopup", const("menu")),
						FAccessAttribute("aria-expanded", fif(subOpenMenu.opened, const("true"), const(""))),
						FAccessAttribute("aria-owns", fif(subOpenMenu.opened, const(subMenuPopupId), const(""))),
						MRippleType(const(MRippleFill())),
						extractStruct(style, MButtonTitle(title)),
						MHighlightOnFocus(const(true)),
						MHighlightOnHover(const(true)),
						MFocusOnDown(ref true)
					]
				)
				|> (\focusState -> replaceStruct(focusState, MFocusOnPrevious(false)));
			lineTextStyle = extractStruct(style, MCustomTextStyle(arrayPush(textStyle, getTextColor(parent)))).style;

			MComponent2T(manager, parent, "MSubMenuDynamic", focusState, \focus ->
				makeTitle(parent, lineTextStyle, title, false, false)
				|> addActions(parent, style, false, true)
				|> (\t ->
					TAlpha(
						getMenuAlpha(focus, parent),
						TFrame(0., 0., extractStruct(style0, MBackgroundStyle([])).style, t)
					)
				)
				|> (\f2 ->
					TConstruct(
						[
							makeSubscribe2(fmax(focus.hover, focus.down), \h -> if (h) nextDistinct(hovered, i)),
							makeSubscribe2(hovered, \h ->
								if (h != i)
									nextDistinct(subOpenMenu.opened, false)
								else if (!isOpenOnClick)
									deferred(\ -> nextDistinct(subOpenMenu.opened, true))
							),
							makeSubscribe2(items, \itms ->
								if (fgetValue(subOpenMenu.opened)) {
									next(subOpenMenu.opened, false);
									next(subOpenMenu.opened, true)
								}
							),
							makeSubscribe(subOpenMenu.opened, \op -> {
								itms = fgetValue(items);
								if (op)
									RenderMPopup(
										manager,
										parent,
										MMenuLines2MPopup(
											manager,
											itms,
											MSubMenuStyle2MMenuStyle(
												replaceStructMany(
													style,
													[
														subOpenMenu,
														extractStruct(style, MSameZorder(sameZorder)),
														extractStruct(style, MButtonTitle(title))
													]
													|> (\arr : [MMenuStyle] -> eitherMap(fixPosition, \fp -> arrayPush(arr, fp), arr))
												)
												|> (\subMenuStyle -> replaceStruct(subMenuStyle, MFocusOnPrevious(false)))
											),
											m2t,
											subPosScale,
											subButtonWH,
											elevation + 1.,
											\ -> if (isCloseParentOnClick) {
												next(openMenu.opened, false);
												closeBelow();
											},
											subMenuPopupId,
											None()
										),
										m2t
									)
							}),
							\ -> \ -> next(subOpenMenu.opened, false)
						],
						f2
					)
				), m2t
			)
			|> (\f -> MPositionScaleAttachBox(subPosScale, subButtonWH, f, openMenu.opened))
			|> makeTropicConstantHeight(Some(lineHeight))
		}

	makeSeparatorLine = \acc ->
		(\parent ->
			TRectangle([Fill(contrastingColor(parent)), FillOpacity(0.12)], TFillXH(1.0))
			|> TBorderTopBottom(8.)
		)
		|> (\f -> Pair(cols, arrayPush(acc.second, generate(0, cols + 1, \__ -> f))));


	items : [[(MFocusGroup) -> Tropic]] =
		foldi(items1, Pair(0, []), \i, acc : Pair<int, [[(MFocusGroup) -> Tropic]]>, it : MMenuLine -> {
			switch (it : MMenuLine) {
				MMenuSingleLine(title, style):
					makeMMenuLine(i, Some(title), None(), style)
					|> checkCols(acc);
				MMenuCustomLine(content, style):
					makeMMenuLine(i, None(), Some(content), style)
					|> checkCols(acc);
				MMenuGroupLine(title, style):
					makeMMenuGroupLine(i, acc, title, style);
				MSubMenu(title, items, style):
					makeMSubMenu(i, const(title), const(items), style)
					|> checkCols(acc);
				MSubMenuDynamic(title, items, style):
					makeMSubMenu(i, title, items, style)
					|> checkCols(acc);
				MSeparatorLine():
					makeSeparatorLine(acc)
			}
		}).second;

	newItems =
		(if (indexShift && selectedId >= 0 && !nonspecAlwaysOnTop) {
			if (selectedId > 0 && selectedId < length(items0) - 1 &&
				items0[selectedId - 1].structname == "MMenuGroupLine" && items0[selectedId + 1].structname == "MMenuGroupLine") {
				selIt = items[selectedId + 1];

				concat(
					[selIt],
					removeIndex(removeIndex(items, 0), selectedId)
				);
			} else {
				selIt = items[selectedId + 2];

				concat(
					[selIt],
					removeIndex(removeIndex(items, 0), selectedId + 1)
				);
			}
		} else
			items
		)
		|> addLabel;

	labelIdx = b2i(isSome(mLabel));
	itemsLen = length(newItems);

	popupStyle =
		[
			RMBorders(borders),
			RMOutterBorder(8.0),
			MElevation(const(elevation)),
			RMLeftAnimation(leftAnimation),
			openMenu,
			RMHeight(32. + borders * 2., maxHeight.height),
			MSameZorder(sameZorder),
			RMAlphaAnimation(),
			RMScaleAnimation(),
			MRippleShape("MMenu"),
			MFocusHorizontal(false),
			MFocusVertical(true),
			MActive(make(true)),
			AccessRole(popupRole),
			FAccessAttribute(
				"aria-label",
				extractStruct(style0, MButtonTitle(const(eitherMap(mLabel, \l -> l.label, "")))).title
			),
			FAccessAttribute("aria-activedescendant", activeDescendantId),
			FAccessAttribute("id", const(popupId)),
			extractStruct(style0, MFocusOnPrevious(true))
		]
		|> (\arr : [MPopupStyle] -> maybeArrayPush(arr, tryExtractStruct(menuScrollStyle, TScrollPersistent(const(true)))))
		|> (\arr -> maybeArrayPush(arr, tryExtractStruct(menuScrollStyle, MScrollWidthHeight(makeWH(), makeWH()))))
		|> (\arr -> maybeArrayPush(arr, tryExtractStruct(menuScrollStyle, MScrollPosition(makePoint()))))
		|> (\arr -> eitherMap(fixPosition, \fp : MPopupStyle -> arrayPush(arr, fp), arr))
		|> (\f : [MPopupStyle] ->
			if (indexShift)
				concat(f, [RMSelected(labelIdx), RMScrollArea(2 + labelIdx, itemsLen)])
			else if (isSome(singleSelection))
				concat(f, [RMSelected(labelIdx + selectedId / (cols + 1)), RMScrollArea(labelIdx, itemsLen)])
			else
				arrayPush(f, RMScrollArea(labelIdx, itemsLen))
		)
		|> (\f : [MPopupStyle] ->
			if (widthByButton) {
				if (mWidth > 0.)
					arrayPush(f, RMWidth(fmin(fwidth(buttonWH), const(mWidth))))
				else
					arrayPush(f, RMWidth(fwidth(buttonWH)))
			} else
				ifArrayPush(f, mWidth > 0., RMWidth(const(mWidth)))
		)
		|> (\f -> {
			offset =
				if (belowButton)
					fselect2(buttonWH, menuShift, FLift2(\b : WidthHeight, ms -> Pair(WidthHeight(ms.x + if (!leftAnimation) b.width else 0., b.height), ms.y)))
				else if ((elevation > 8.) == leftAnimation)
					fselect2(buttonWH, menuShift, FLift2(\b : WidthHeight, ms -> Pair(WidthHeight(b.width + ms.x, 0.), ms.y)))
				else
					fselect(menuShift, FLift(\ms -> Pair(WidthHeight(ms.x, 0.), ms.y)));

			arrayPush(f, RMOffset(offset))
		})
		|> (\f -> maybeArrayPush(f, customScale))
		|> (\f ->
				ifArrayPush(f,
					elevation == 8. && getValue(either(singleSelection, MSingleSelection(make(-1))).selected) == -1 && !indexShift,
					RMTranslateAnimation()
				)
		)
		|> (\f -> ifArrayPush(f, elevation == 8., RMClickOutToClose()))
		|> (\f -> concat(f, extractStructMany(style0, MBlockClicks())));

	MPopup(
		map(newItems, \ni -> map(ni, \i -> MGetFocusGroup(i))),
		posScale,
		popupStyle
	)
}

MSubMenuStyle2MMenuStyle(style : [MSubMenuStyle]) -> [MMenuStyle] {
	filtermap(style, \st -> switch (st) {
		MMenuStyle() : {a : Maybe<MMenuStyle> = Some(st); a};
		default : None()
	})
}

MDropDownMenuButtonStyle2MMenuStyle(style : [MDropDownMenuStyle]) -> [MMenuStyle] {
	fold(style, extractStructMany(style, MEnabled(const(true))), \acc, st -> {
		switch (st) {
			MDataTableFooter(): arrayPush(acc, st);
			MDataTableRow(): arrayPush(acc, st);
			MForceUpdate(): arrayPush(acc, st);
			default : acc;
		}
	})
}

MDropDownMenuStyle2MMenuStyle(style : [MDropDownMenuStyle]) -> [MMenuStyle] {
	filtermap(style, \st -> switch (st) {
		MMenuStyle() : {a : Maybe<MMenuStyle> = Some(st); a};
		default : None()
	})
}

MDropDownIcon(opened : Transform<bool>, style : [MDropDownIconStyle]) -> Material {
	iconSize = extractStruct(style, MIconSize(20.)).size;
	borders = extractStruct(style, MIconBorder4(0., 0., 0., 0.));
	MGetFocusGroup(\parent -> TIfLazy2(
		opened,
		\op ->
			MIcon2T(
				parent,
				if (op)
					"arrow_drop_up"
				else
					"arrow_drop_down",
				[MIconSize(iconSize)]
			),
		true
	))
	|> (\m -> MFixSize(m, TFixed(iconSize, iconSize)))
	|> (\m -> MBorder(borders.left, borders.top, borders.right, borders.bottom, m))
}

MDropDownClearIcon(selected : DynamicBehaviour<?>, emptySelection : ?, iconSize : double) -> Material {
	MIconButton("clear", \ -> nextDistinct(selected, emptySelection), [
			MIconSize(iconSize / 1.5),
			MIconButtonBorder(0.),
			MCircleBackground(MGrey(400), iconSize)
		], []
	)
	|> (\m -> MShow(fneq(selected, emptySelection), m))
}

getMenuAlpha(focus : MFocus, parent : MFocusGroup) -> Transform<double> {
	fif(focus.enabled, const(1.), const(defaultDisabledItemOpacity(getLightBackground(parent))))
}

getPopupId(manager : MaterialManager) {
	"menu" + i2s(makeTropicTag(manager))
}