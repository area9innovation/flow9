import material/internal/material_list_util;
import material/internal/material_button;
import material/internal/material_outline;

export {
	MMenu2T(manager : MaterialManager, parent : MFocusGroup, m : MMenu, m2t : (Material, MFocusGroup) -> Tropic) -> Tropic;
	MDynamicMenu2T(manager : MaterialManager, parent : MFocusGroup, m : MDynamicMenu, m2t : (Material, MFocusGroup) -> Tropic) -> Tropic;
	MMenuPanel2T(manager : MaterialManager, parent : MFocusGroup, m : MMenuPanel, m2t : (Material, MFocusGroup) -> Tropic) -> Tropic;
	MDropDownMenu2T(manager : MaterialManager, parent : MFocusGroup, m : MDropDownMenu, m2t : (Material, MFocusGroup) -> Tropic) -> Tropic;
	MMultiSelectDropDown2T(
		manager : MaterialManager,
		parent : MFocusGroup,
		m : MMultiSelectDropDown,
		m2t : (Material, MFocusGroup) -> Tropic
	) -> Tropic;
	MDropDownMenuStyle2MMenuStyle(style : [MDropDownMenuStyle]) -> [MMenuStyle];

	MDropDownIcon(opened : Transform<bool>, style : [MDropDownIconStyle]) -> Material;
		MDropDownIconStyle ::= MIconSize, MIconBorder4, MColor;
}

MMenuFocusedItem ::= MMenuFirstItem, MMenuLastItem;
	MMenuFirstItem();
	MMenuLastItem();

MMenu2T(manager : MaterialManager, parent : MFocusGroup, m : MMenu, m2t : (Material, MFocusGroup) -> Tropic) -> Tropic {
	MDynamicMenu2T(manager, parent, MDynamicMenu(m.button, const(m.items), m.style), m2t)
}

MDynamicMenu2T(manager : MaterialManager, parent : MFocusGroup, m : MDynamicMenu, m2t : (Material, MFocusGroup) -> Tropic) -> Tropic {
	MDynamicMenu2TInner(manager, parent, m, m2t, None())
}

MDynamicMenu2TInner(manager : MaterialManager, parent : MFocusGroup, m : MDynamicMenu, m2t : (Material, MFocusGroup) -> Tropic, popupId0 : Maybe<string>) -> Tropic {
	openMenu = extractStruct(m.style, MOpenMenu(make(false)));
	buttonWH = makeWH();
	positionScale = make(zeroPositionScale);
	customPopup = tryExtractStruct(m.style, MMenuCustomPopup(None(), None()));
	popupId = either(popupId0, getPopupId(manager));

	enabled = extractStruct(m.style, MEnabled(const(true))).enabled;
	openOnClick = contains(m.style, MOpenOnClick());
	longTouch = tryExtractStruct(m.style, MLongTouchDelay(0));

	buttonFocused = extractStruct(m.style, MFocused(make(false)));
	buttonState = replaceStruct(extractMButtonState(m.style), buttonFocused);
	focusedItem = make(None());

	(\p ->
		MMenuButton2T(manager, p, m.button, m2t, openMenu, enabled, openOnClick, longTouch, None(), popupId, buttonState)
		|> (\f -> MPositionScaleAttachBox(positionScale, buttonWH, f, openMenu.opened))
		|> (\f -> MAddLabelAndLeftIcon(manager, p, f, m.style, openMenu.opened, 12.))
		|> (\f ->
			TConstruct(
				[
					makeSubscribe2(m.items, \__ -> reopenMenu(openMenu)),
					makeSubscribe(openMenu.opened, \op -> {
						if (op) {
							if (isNone(getValue(focusedItem)) && fgetValue(buttonFocused.focused)) {
								nextDistinct(focusedItem, Some(MMenuFirstItem()))
							}
							openFn = \ -> RenderMPopup(
								manager,
								p,
								MMenuLines2MPopup(
									manager,
									fgetValue(m.items),
									replaceStruct(m.style, openMenu),
									m2t,
									eitherMap(customPopup, \cp -> either(cp.positionScale, positionScale), positionScale),
									eitherMap(customPopup, \cp -> either(cp.buttonWH, buttonWH), buttonWH),
									8.,
									nop,
									popupId,
									focusedItem
								),
								m2t
							);

							eitherFn(
								tryExtractStruct(m.style, MMenuOpenDelay(0)),
								\delay -> timer(delay.delay, openFn),
								openFn
							);
						}
					}),
					\ -> \ -> next(openMenu.opened, false)
				],
				f
			)
		)
	)
	|> (\f ->
		MComponentGroup2T(
			manager,
			parent,
			"MDynamicMenu",
			extractMComponentGroupState(m.style),
			f
		)
	)
	|> MDynamicMenuHandleShortcuts(m.items, openMenu, buttonFocused, focusedItem)
}

MDynamicMenuHandleShortcuts(
	items : Transform<[MMenuLine]>,
	openMenu : MOpenMenu,
	buttonFocused : MFocused,
	focusedItem : DynamicBehaviour<Maybe<MMenuFocusedItem>>) -> (Tropic) -> Tropic {

	\t -> {
		shortcuts = fmap(fgetShortcuts(items), \sh -> parseShortcut(toLowerCase(sh.shortcut)));

		TInteractive(
			[
				KeyDown2(\h, ke ->
					if (!getValue(openMenu.opened)) {
						if (!h && exists(fgetValue(shortcuts), \s -> matchShortcutKeyCode(ke, s))) {
							next(openMenu.opened, true);

							emitKeyEvent(getStage(), "keydown", ke.utf, ke.ctrl, ke.shift, ke.alt, ke.meta, ke.keycode);
							emitKeyEvent(getStage(), "keyup", ke.utf, ke.ctrl, ke.shift, ke.alt, ke.meta, ke.keycode);

							deferred(\ -> next(openMenu.opened, false));
							true
						} else if (fgetValue(buttonFocused.focused) && (ke.utf == "enter" || ke.utf == " ")) {
							nextDistinct(focusedItem, Some(MMenuFirstItem()));
							true
						} else h
					} else h
				),
				KeyUp2(\h, ke ->
					if (!h && !getValue(openMenu.opened) && fgetValue(buttonFocused.focused)) {
						onKeyUp = \type -> {
							nextDistinct(focusedItem, Some(type));
							nextDistinct(openMenu.opened, true);
						}
						if (ke.utf == "up") {
							onKeyUp(MMenuLastItem());
						} else if (ke.utf == "down") {
							onKeyUp(MMenuFirstItem());
						}
						true
					} else h
				)
			],
			t
		);
	}
}

fgetShortcuts(items : Transform<[MMenuLine]>) -> Transform<[MShortcut]> {
	extractShortcut = \st -> const(extractStructMany(st, MShortcut("shortcut")));
	extractShortcutSub = \st, subItems -> fconcat(const(extractStructMany(st, MShortcut("shortcut"))), fgetShortcuts(subItems));
	fsubmap(items, \it ->
		switch (it : MMenuLine) {
			MMenuSingleLine(__, style) : extractShortcut(style);
			MMenuCustomLine(__, style) : extractShortcut(style);
			MMenuGroupLine(__, style) : extractShortcut(style);
			MSubMenu(__, subItems, style) : extractShortcutSub(style, const(subItems));
			MSubMenuDynamic(__, subItems, style) : extractShortcutSub(style, subItems);
			MSubMenuCustom(__, subItems, style) : extractShortcutSub(style, subItems);
			MSeparatorLine() : const([])
		}
	)
	|> fconcatA
}


MMenuButton2T(
	manager : MaterialManager,
	parent : MFocusGroup,
	button : Material,
	m2t : (Material, MFocusGroup) -> Tropic,
	openMenu : MOpenMenu,
	enabled : Transform<bool>,
	openOnClick : bool,
	longTouch : Maybe<MLongTouchDelay>,
	buttonTitleM : Maybe<MButtonTitle>,
	popupId : string,
	buttonState : [MButtonState]
) -> Tropic {

	addAria = \st -> concat(st, arrayPushMaybe([
		FAccessAttribute("aria-haspopup", const("menu")),
		FAccessAttribute("aria-expanded", fselectLift(openMenu.opened, b2s)),
		FAccessAttribute("aria-owns", fif(openMenu.opened, const(popupId), const("")))
	], buttonTitleM));

	extendState = \state : [MButtonState], open ->
		replaceStruct(state, MEnabled(enabled))
		|> addAria
		|> (\st -> eitherMap(longTouch, \lt -> concat(st, [lt, MOnLongTouch(open)]), st));

	switch (button) {
		MTextButton(text, onClick, style, state): {
			open = \ -> {
				opened = getValue(openMenu.opened);
				onClick();
				nextDistinct(openMenu.opened, !opened);
			}
			MTextButton2T(
				manager,
				parent,
				MTextButton(
					text,
					eitherMap(longTouch, \__-> nop, open),
					style,
					replaceStructMany(
						buttonState,
						extendState(state, open)
					)
				),
				m2t
			)
		}
		MIconButton(name, onClick, style, state): {
			open = \ -> {
				opened = getValue(openMenu.opened);
				onClick();
				nextDistinct(openMenu.opened, !opened);
			}
			MIconButton2T(
				manager,
				parent,
				MIconButton(
					name,
					eitherMap(longTouch, \__-> nop, open),
					style,
					replaceStructMany(
						buttonState,
						extendState(state, open)
					)
				),
				m2t
			)
		}
		MMutable(contentT): {
			TMutable(fselect(contentT, FLift(\content ->
				MMenuButton2T(manager, parent, content, m2t, openMenu, enabled, openOnClick, longTouch, buttonTitleM, popupId, buttonState)
			)))
		}
		default: {
			if (openOnClick || isSome(longTouch)) {
				buttonWH = makeWH();
				isRect = fselect(buttonWH, FLift(\wh -> abs(1. - wh.width / wh.height) > 0.5));
				focusState =
					concat(
						replaceStructMany(
							buttonState,
							[
								MEnabled(enabled),
								MRippleType(fif(isRect, const(MRippleFill()), const(MRippleCenter()))),
								MHighlightOnFocus(const(true)),
								MRippleShape("")
							]
						),
						eitherMap(longTouch, \lt -> [
								lt,
								MOnLongTouch(\ -> reverseBehaviour(openMenu.opened))
							],
							[MOnClick(\ -> reverseBehaviour(openMenu.opened))]
						)
					)
					|> addAria;

				MComponent2T(
					manager,
					parent,
					"MMenuCustomButton",
					focusState,
					\focus ->
						MComponentGroup2T(
							manager,
							parent,
							"MMenuCustomButtonContainer",
							[MFocusEnabled(const(false)), MClickEnabled(const(false))],
							\p -> m2t(button, p)
						)
						|> (\t -> TAttachBox(t, buttonWH)),
					m2t
				)
			} else {
				m2t(button, parent);
			}
		}
	}
}

MMenuPanelIconSize(style : [?], height : double, borders : double) -> MIconSize {
	extractStruct(style, MIconSize((height * 2. - borders * 4.) / 3.));
}

MMenuPanelIconButtonBorders(style : [?], height : double, borders : double, iconSize : MIconSize) -> MIconButtonBorder {
	extractStruct(style, MIconButtonBorder((height - borders - iconSize.size) / 2.));
}

MMenuPanelItem2T(
	manager : MaterialManager,
	parent : MFocusGroup,
	item : Material,
	m2t : (Material, MFocusGroup) -> Tropic,
	enabledHover : Maybe<DynamicBehaviour<bool>>,
	openMenus : ref [MOpenMenu],
	closeMenus : () -> void,
	height : double, borders : double
) -> Tropic {
	switch (item) {
		MDropDownMenu(items, current, style): {
			MDropDownMenu2T(
				manager,
				parent,
				MDropDownMenu(items, current, replaceStructMany(style, [extractStruct(style, MCustomLineHeight(height - 16.)),
					extractStruct(style, MSeparators(false))])),
				m2t
			)
			|> TCenterY
			|> if (contains(style, MCroppedButton())) TBorderLeftRight(8.) else idfn
		}
		MMenu(button, items, style): {
			openMenu = extractStruct(style, MOpenMenu(make(false)));
			refArrayPush(openMenus, openMenu);
			rollOver = make(false);
			focused = extractStruct(style, MFocused(make(false)));
			(\p ->
				(\par ->
					switch (button) {
						MTextButton(text, onClick, buttonStyle, buttonState): {
							MMenuTextButton2T(manager, par, text, extractStruct(buttonState, MShortcut("")).shortcut, onClick,
								buttonStyle, openMenu, focused, m2t)
						}
						MIconButton(name, onClick, iconStyle, state): {
							iconSize = MMenuPanelIconSize(iconStyle, height, borders);
							iconBorders = MMenuPanelIconButtonBorders(iconStyle, height, borders, iconSize);

							MIconButton2T(
								manager,
								par,
								MIconButton(
									name,
									\ -> {
										onClick();
										reverseBehaviour(openMenu.opened)
									},
									replaceStructMany(iconStyle, [iconSize, iconBorders]),
									replaceStructMany(state, [MFocusEnabled(const(false))])
								),
								m2t
							)
						}
						default: {
							MMenuPanelItem2T(manager, par, button, m2t, enabledHover, openMenus, closeMenus, height, borders)
						}
					}
				)
				|> (\f -> MMenu2T(manager, p, MMenu(MGetFocusGroup(f), items, concat(replaceStruct(style, openMenu), [focused, THovering(rollOver), MBelowButton()])), m2t))
				|> TCenterY
			)
			|> (\f ->
				eitherFn(
					enabledHover,
					\eh -> {
						TConstruct([
								makeSubscribe2(rollOver, \ro -> {
									if (fgetValue(eh) && ro && !fgetValue(openMenu.opened)) {
										closeMenus();
										next(openMenu.opened, true);
									}
								}),
								makeSubscribe2(openMenu.opened, \op -> nextDistinct(eh, op)),
							],
							f(parent)
						)
					},
					\ -> f(parent)
				)
			)
		}
		MDropDown(current, nonSpecified, items, style): {
			m2t(MDropDown(current, nonSpecified, items, replaceStructMany(style, [extractStruct(style, MCustomLineHeight(height - 16.)),
				extractStruct(style, MSeparators(false))])), parent)
			|> TCenterY
			|> if (contains(style, MCroppedButton()))
					TBorderLeftRight(8.)
				else if (isSome(tryExtractStruct(style, MCustomButton(TEmpty()))))
					idfn
				else
					TBorderLeftRight(-8.)
		}
		MTextButton(text, onClick, buttonStyle, buttonState): {
			m2t(item, parent)
			|> TCenterY
		}
		MIconButton(icon, onClick, style, state): {
			iconSize = MMenuPanelIconSize(style, height, borders);
			iconBorders = MMenuPanelIconButtonBorders(style, height, borders, iconSize);

			MIconButton2T(
				manager,
				parent,
				MIconButton(
					icon,
					onClick,
					replaceStructMany(style, [iconSize, iconBorders]),
					state
				),
				m2t
			)
			|> TCenterY
		}
		MIconToggle(icon, style, state): {
			iconSize = MMenuPanelIconSize(style, height, borders);
			iconBorders = MMenuPanelIconButtonBorders(style, height, borders, iconSize);

			MIconToggle2T(
				manager,
				parent,
				MIconToggle(
					icon,
					replaceStructMany(style, [iconSize, iconBorders]),
					state
				),
				m2t
			)
			|> TCenterY
		}
		MBorder(left, top, right, bottom, c): {
			MMenuPanelItem2T(manager, parent, c, m2t, enabledHover, openMenus, closeMenus, height - top - bottom, borders)
			|> (\f -> TBorder(left, top, right, bottom, f))
		}
		MText(__, __): {
			m2t(item, parent)
			|> TCenterY
		}
		MTooltip(box, tip, style): {
			MTooltip2T(
				manager,
				parent,
				MTooltip(MMenuPanelItem2T(manager, parent, box, m2t, enabledHover, openMenus, closeMenus, height, borders), tip, style),
				m2t
			)
		}
		MMutable(cont): {
			MSelect2T(
				manager,
				parent,
				"MSelect",
				[],
				cont,
				\c, p ->
					MMenuPanelItem2T(manager, p, c, m2t, enabledHover, openMenus, closeMenus, height, borders)
			)
		}
		MCols(cont): {
			TColsDir(map(cont, \c -> MMenuPanelItem2T(manager, parent, c, m2t, enabledHover, openMenus, closeMenus, height, borders)), parent.rtl)
		}
		MSeparator(__): {
			m2t(MSeparator(false), parent)
			|> (\f -> TBorder(8., borders + 2., 8., borders + 2., f))
		}
		MConstruct(cons, c): {
			TConstruct(cons, MMenuPanelItem2T(manager, parent, c, m2t, enabledHover, openMenus, closeMenus, height, borders))
		}
		default: {
			m2t(item, parent)
			|> TCenterY
		}
	}
}

MMenuPanel2T(manager : MaterialManager, parent : MFocusGroup, m : MMenuPanel, m2t : (Material, MFocusGroup) -> Tropic) -> Tropic {
	style = m.style;
	items = m.items;

	height = extractStruct(style, MHeight(52.)).height;
	borders = extractStruct(style, MBorders(8.)).borders;
	cropByContent = contains(style, MScrollCropByContent());
	enabledHover = if (extractStruct(style, MExpandOnHover(true)).expand) Some(make(false)) else None();
	bgColor = extractStruct(style, MMenuPanelBackground(MSurfaceColor())).color;
	bgStyle = mgraphicsStyle2tgraphicsStyle(parent, extractStruct(style, MBackgroundStyle([MThemeFill(parent, bgColor)])).style);
	elevation = extractStruct(style, MElevation(const(4.0))).elevation;
	openMenus = ref [];

	closeMenus = \ -> {
		iter(^openMenus, \om -> nextDistinct(om.opened, false))
	};

	(\p ->
		MGetFocusGroup(\p2 ->
			map(items, \i -> MMenuPanelItem2T(manager, p2, i, m2t, enabledHover, openMenus, closeMenus, height, borders))
			|> (\f ->
				if (cropByContent)
					TColsDir(f, p2.rtl)
				else
					TColsDir(f, p2.rtl)
					|> (\t -> TAlignStartDir(t, p.rtl))
			)
			|> TBorderLeftRight(8.)
		)
		|> (\f ->
			MScroll2T(
				manager,
				p,
				MScroll(
					f,
					TFillXH(height),
					[TScrollbars(invisibleScrollBar, invisibleScrollBar)]
					|> (\f2 -> ifArrayPush(f2, cropByContent, MScrollCropByContent()))
				),
				m2t
			)
		)
		|> (\f -> TFrame(0., 0., bgStyle, f))
		// |> (\f -> TAvailable(f, TFillXH(height)))
		|> (\f -> TShadowShape(p, elevation, f, BottomRectangleShape()))
		// |> (\f3 -> if (^fAccessibilityEnabled) TAccess([AccessRole("menubar")], f3) else f3)
		|> makeTropicConstantHeight(Some(height))
	)
	|> (\f ->
		MComponentGroup2T(manager, parent, "MMenuPanel",
			concat(
				eitherMap(enabledHover, \eh -> [IScriptBehaviour("hover_enabled", eh, ISEnableEvent())], []),
				filtermap(style, \s ->
					switch (s) {
						MComponentGroupState(): {a : Maybe<MComponentGroupState> = Some(s); a};
						default: None();
					}
				)
			),
			f
		)
	)
}

MDropDownMenu2T(
	manager : MaterialManager, parent : MFocusGroup, m : MDropDownMenu, m2t : (Material, MFocusGroup) -> Tropic
) -> Tropic {
	items : [MDropDownMenuLine] = m.items;
	current = m.current;
	style = m.style;

	openMenu : MOpenMenu = extractStruct(style, MOpenMenu(make(false)));
	tableRow = contains(style, MDataTableRow());
	tableFooter = contains(style, MDataTableFooter());
	customButton = tryExtractStruct(style, MCustomButton(TEmpty()));
	enabled = extractStruct(style, MEnabled(const(true))).enabled;
	nonSpecified : MNonSpecifiedLine = extractStruct(style, MNonSpecified(MMenuSingleLine(_("Pick"), []))).item;
	croppedButton = contains(style, MCroppedButton());
	lineBorders = extractStruct(style, MMenuLineBorders(if (tableFooter) 16. else 24.)).borders;
	currentInner = cloneBehaviour(current);
	leftIcon = isSome(tryExtractStruct(style, MLeftIcon("", [])));
	addClear = contains(style, MAddClearButton());
	outlined = contains(style, MOutlined());
	filled = contains(style, MFilled());
	mLabel = tryExtractStruct(style, MLabel(""));
	label = eitherMap(mLabel, \lbl -> lbl.label, switch (nonSpecified) {
		MMenuSingleLine(title, __) : title;
		MMenuCustomLine(__, __) : "";
	});
	buttonTitle : MButtonTitle = extractStruct(style, MButtonTitle(const(label)));
	croppedTitle = contains(style, MDropDownMenuCropByContent());
	dropDownWarning = tryExtractStruct(style, MDropDownMenuWarning(const(None()), []));

	iconSize = extractStruct(style, MDropDownMenuIconSize(if (tableRow || tableFooter) 16.0 else 20.0)).size;
	iconBorders = extractStruct(style, MDropDownMenuIconBorders(MIconBorder4(0., 0., 0., 0.))).borders;
	iconColorM = maybeMap(tryExtractStruct(style, MDropDownMenuIconColor(MWhite())), \ic -> ic.color);

	icon =
		MDropDownIcon(openMenu.opened, arrayPushMaybe([MIconSize(iconSize), iconBorders], iconColorM))
		|> (\t -> if (addClear) MCols2A(t, MDropDownClearIcon(current, -1, iconSize)) else t);

	addDropDownIcon = \st -> replaceStruct(st, MSecondaryAction(MBaselineCols2A(extractStruct(st, MSecondaryAction(TEmpty())).content, icon)));

	addIcons = \f : MDropDownMenuLine ->
		switch (f) {
			MMenuSingleLine(title, style0):	MMenuSingleLine(title, addDropDownIcon(style0));
			MMenuCustomLine(content, style0): MMenuCustomLine(content, addDropDownIcon(style0));
			MSeparatorLine(): f;
			MMenuGroupLine(__,__): f;
		}
	selected = MSingleSelection(currentInner);
	closed = ref !getValue(openMenu.opened);

	onClick = \ -> if (^closed) next(openMenu.opened, true);
	mWidth =
		extractStruct(style, MWidth(0.)).width
		|> (\f2 ->
			if (f2 != 0.)
				f2
			else {
				mitems : [MMenuLine] =
					arrayPush(
						if (isNone(customButton)) map(items, addIcons) else items,
						addIcons(nonSpecified)
					);
				MMenuLines2MPopup(
					manager,
					mitems,
					MDropDownMenuStyle2MMenuStyle(style),
					m2t,
					const(zeroPositionScale),
					const(WidthHeight(0., 0.)),
					0.,
					nop,
					"",
					make(None())
				).items
				|> MGrid
				|> (\f3 -> m2t(f3, parent))
				|> (\f3 -> getTWordMetrics(f3, makeTree()).width) // TODO : Rework without using getTWordMetrics

			}
		);

	popupId = getPopupId(manager);
	buttonFocused = extractStruct(style, MFocused(make(false)));

	menuStyle =
		style
		|> (\st -> replaceStruct(st, MWidth(mWidth)))
		|> (\st -> replaceStruct(st, openMenu))
		|> (\st -> replaceStruct(st, MFocusName("MDropDownMenu")))
		|> (\st -> replaceStruct(st, buttonFocused))
		|> (\st -> addStyleIfAbsent(st, buttonTitle))
		|> MDropDownMenuStyle2MMenuStyle
		|> (\st -> arrayPush(st, selected))
		|> (\st -> ifArrayPush(st, isNone(customButton) && mWidth >= 0.0 && !croppedTitle, MWidthByButton()))
		|> (\st -> ifArrayPush(st, outlined || filled, MMenuExpandingAnimation()))
		|> (\st -> if (contains(style, MNonSpecifiedAlwaysOnTop())) arrayPush(st, MMenuNonSpecifiedAlwaysOnTop(nonSpecified)) else st)
		|> (\st -> arrayPush(st, MBelowButton()));

	MGetFocusGroup(\p ->
		eitherFn(
			customButton,
			\cb ->
				MMenuButton2T(
					manager,
					p,
					cb.button,
					m2t,
					openMenu,
					enabled,
					!contains(style, MDontOpenOnClick()),
					None(),
					Some(buttonTitle),
					popupId,
					extractMButtonState(style)
				),
			\ -> {
				lItems = length(items);

				MDropDownMenuButton2T(
					manager,
					p,
					fselect(currentInner, FLift(\c ->
						(if (c >= 0 && lItems > 0) {
							it = if (c >= lItems) {
								next(currentInner, lItems - 1);

								items[length(items) - 1];
							} else items[c];

							switch (it) {
								MMenuSingleLine(__, __): it;
								MMenuCustomLine(__, __): it;
								default: {
									next(currentInner, -1);
									nonSpecified
								}
							}
						} else
							nonSpecified)
						|> (\f -> {
							newStyle =
								addDropDownIcon(f.style)
								|> (\s -> replaceStruct(s, MEnabled(enabled)));

							switch (f : MNonSpecifiedLine) {
								MMenuSingleLine(__, __): MMenuSingleLine(f.title, newStyle);
								MMenuCustomLine(__, __): MMenuCustomLine(f.content, newStyle);
							}
						})
					)),
					replaceStructMany(style, [MWidth(mWidth), openMenu, AccessRole("combobox")]),
					onClick,
					getLightBackground(p),
					popupId,
					m2t
				)
			}
		)
	)
	|> addMDropDownMenuWarning(dropDownWarning)
	|> (\f -> MDynamicMenu(f, const(items), menuStyle))
	|> (\f -> MDynamicMenu2TInner(manager, parent, f, m2t, Some(popupId)))
	|> (if (croppedButton) TBorderLeftRight(-lineBorders) else idfn)
	|> (\f ->
		TConstruct(
			[
				\ -> makeBidirectionalLink(current, currentInner,
					\c -> foldi(items, -1, \i, acc, it -> {
						if (acc < c && (isSameStructType(it, MMenuSingleLine("", [])) ||
								isSameStructType(it, MMenuCustomLine(TEmpty(), [])))) {
							if (acc == c - 1) i	else acc + 1
						} else acc
					}),
					\ci -> {
						if (ci >= 0) {
							countA(subrange(items, 0, ci), \it -> {
								isSameStructType(it, MMenuSingleLine("", [])) || isSameStructType(it, MMenuCustomLine(TEmpty(), []))
							})
						} else -1
					},
					!contains(style, MForceUpdate())
				),
				makeSubscribe(openMenu.opened, \opn -> if (opn) closed := false else timer(100, \ -> closed := true))
			],
			f
		)
	)
	|> (
		if (isNone(customButton) && mWidth > 0. && !croppedTitle)
			makeTropicConstantWidth(Some(mWidth + (if (leftIcon) 72. else 0.) - (if (croppedButton) 2. * lineBorders else 0.)))
		else
			idfn
	);
}

MMultiSelectDropDown2T(
	manager : MaterialManager,
	parent : MFocusGroup,
	m : MMultiSelectDropDown,
	m2t : (Material, MFocusGroup) -> Tropic
) -> Tropic {
	items = m.items;
	selected = m.selected;
	style = m.style;

	leftIcon = isSome(tryExtractStruct(style, MLeftIcon("", [])));
	width = extractStruct(style, MWidth(200.)).width |> (\f -> if (leftIcon) f - 72. else f);
	croppedButton = contains(style, MCroppedButton());
	lineBorders = extractStruct(style, MMenuLineBorders(24.)).borders;
	enabled = extractStruct(style, MEnabled(const(true))).enabled;
	nonSpec = extractStruct(style, MNonSpecifiedString(_("Pick"))).item;
	lineHeight = extractStruct(style, MCustomLineHeight(32.)).height;
	maxHeight = extractStruct(style, MMaxHeight(-1.)).height;
	onItemClick = extractStruct(style, MOnItemClick(nop2)).fn;
	addDoneBtn = contains(style, MAddDoneButton());
	additionalButtons = extractStruct(style, MAdditionalButtons([])).buttons;
	tableRow = contains(style, MDataTableRow());
	tableFooter = contains(style, MDataTableFooter());
	textStyle = extractStruct(style, MCustomTextStyle([])).style
				|> (\arr ->  if (arr == []) [if (tableFooter) MCaption() else if (tableRow) MDataRow() else MSubheading()] else arr);

	selectedStyle = extractStruct(style, MSelectedItemStyle(MAccentColor(), MWhite()));
	selectedTextColor = selectedStyle.textColor;
	selectedBgColor = selectedStyle.bgColor;

	leftDecorations = extractStruct(style, MLeftDecorations([])).extraItems;
	rightDecorations = extractStruct(style, MRightDecorations([])).extraItems;

	addClear = contains(style, MAddClearButton());
	showTooltip = extractStruct(style, MShowTooltip(const(true)));
	customButton = tryExtractStruct(style, MCustomButton(TEmpty()));
	outlined = contains(style, MOutlined());
	filled = contains(style, MFilled());
	plain = !outlined && !filled;
	belowButton = !plain || contains(style, MBelowButton());
	showSelectedIcon = extractStruct(style, MShowSelectedIcon(true)).show;

	opened = extractStruct(style, MOpenMenu(make(false))).opened;
	onClick = \ -> nextDistinct(opened, true);

	iconSize = if (tableRow || tableFooter) 16.0 else 20.0;
	iconBorders = extractStruct(style, MDropDownMenuIconBorders(MIconBorder4(0., 0., 0., 0.))).borders;
	icon =
		MDropDownIcon(opened, [MIconSize(iconSize), iconBorders])
		|> (\t -> if (addClear) MCols2A(t, MDropDownClearIcon(selected, [], iconSize)) else t)
		|> MCenterY;

	iconNearTitle = contains(style, MDropDownIconNearTitle());
	defButtonLineStyle = [MDisableHover(), MEnabled(enabled), MSecondaryAction(icon)];
	listSelectionEnabled = tryExtractStruct(style, MListSelectionEnabled(const([])));
	dropDownWarning = tryExtractStruct(style, MDropDownMenuWarning(const(None()), []));

	popupId = getPopupId(manager);

	defMenuButton =
		MDropDownMenuButton2T(
			manager,
			parent,
			fif(
				fselect(selected, FLift(\s -> length(s) > 0 && length(items) > 0)),
				const(MMenuCustomLine(
					MSelect(selected, \s ->
						MEllipsisText(
							strGlue(
								ifArrayReverse(foldi(items, [], \i, arr, item ->
									ifArrayPush(arr, contains(s, i), item)
								), parent.rtl),
								", "
							),
							arrayPush(textStyle, showTooltip)
						)
					)
					|> MAlignStart,
					defButtonLineStyle
				)),
				const(MMenuSingleLine(nonSpec, defButtonLineStyle))
			),
			replaceStructMany(
				extractMButtonState(style),
				concatA([
					[MWidth(width + (if (croppedButton) lineBorders * 2. else 0.))],
					if (iconNearTitle) [MDropDownIconNearTitle()] else [],
					if (croppedButton) [MCroppedButton()] else [],
					if (outlined) [MOutlined()] else [],
					if (filled) [MFilled()] else [],
					if (plain) [] else [MNonSpecified(MMenuSingleLine(nonSpec, [])), MOpenMenu(opened)],
					eitherMap(tryExtractStruct(style, MDropDownMenuDisabledOpacity(const(0.0))), \v -> [v], []),
					eitherMap(tryExtractStruct(style, MCustomLineHeight(-1.)), \v -> [v], []),
					extractStructMany(style, MSeparators(true)),
					extractStructMany(style, MDataTableRow()),
					extractStructMany(style, MDataTableFooter()),
					extractStructMany(style, MDropDownMenuWarning(const(None()), []))
				])
			),
			onClick,
			getLightBackground(parent),
			popupId,
			m2t
		);

	menuButton =
		eitherMap(
			customButton,
			\cb ->
				MMenuButton2T(
					manager,
					parent,
					cb.button,
					m2t,
					MOpenMenu(opened),
					enabled,
					!contains(style, MDontOpenOnClick()),
					None(),
					tryExtractStruct(m.style, MButtonTitle(const(""))),
					popupId,
					extractMButtonState(style)
				),
			defMenuButton
		)
		|> (if (croppedButton) TBorderLeftRight(-lineBorders) else idfn)
		|> addMDropDownMenuWarning(dropDownWarning);

	dropDownLines =
		if (length(items) == 0) []
		else
			MList(
				mapi(items, \i, item -> {
					isSelectedB = fselect(selected, FLift(\s -> contains(s, i)));
					MCustomLine(
						MBaselineColsA([
							if (showSelectedIcon) MVisible(isSelectedB, MIcon("check", [selectedTextColor]))
							else TEmpty(),
							MFixedX(4.),
							MSelect(isSelectedB, \isSelected ->
								MEllipsisText(
									item,
									ifArrayPush(textStyle, isSelected, selectedTextColor)
									|> (\arr -> arrayPush(arr, showTooltip))
								)
							)
							|> MAlignStart
						])
							|> (\f -> MCenterYIn(f, TFixed(0., lineHeight)))
							|> (\f -> MGroup2(TFillX(), f))
							|> MBorderLeftRight(lineBorders),
						concatA([
							if (existsIndex(leftDecorations, i)) [MPrimaryAction(leftDecorations[i])] else [],
							if (existsIndex(rightDecorations, i)) [MSecondaryAction(rightDecorations[i])] else [],
							[extractStruct(style, MRippleOutlineEnabled(const(false)))],
							eitherMap(listSelectionEnabled, \lse -> [
								fsubselect(lse.enabled, FLift(\list -> elementAt(list, i, const(true))))
								|> MEnabled
							], [])
						])
					)
				}), [
					MAddScroll(Some(TScrollInspectVisible(
						make(zeroPoint),
						make(WidthHeight(
							width,
							if (maxHeight > 0.0) min(maxHeight, lineHeight * i2d(length(items)))
							else lineHeight * i2d(min(6, length(items))))
						)
					))),
					MSelectedBackgroundStyle([MThemeFill(parent, selectedBgColor), FillOpacity(0.2)])
				] , [
					MOnListClick(const(true), \i -> onItemClick(i, contains(getValue(selected), i))),
					MListSelection(make(true), true, true, selected)
				]
			)
			|> MBorderLeftRight(-lineBorders)
			|> (\m2 -> if (addDoneBtn) MLines2(m2,
					MTextButton(
						"DONE",
						\ -> next(opened, false),
						[MButtonRaised()],
						[]
					)
					|> MCenterX
					|> MBorderTop(8.)
				)
				else m2
			)
			|> (\m2 -> if (length(additionalButtons) > 0) MLines2(m2,
					additionalButtons
					|> MBaselineColsA
					|> MCenterX
					|> MBorderTop(8.)
				) else m2
			)
			|> (\m2 -> MMenuCustomLine(m2, [MDisableHover(), MClickEnabled(const(false)), MEnabled(enabled)]))
			|> v2a;

	MDynamicMenu(
		menuButton,
		const(dropDownLines),
		concatA([
			[MOpenMenu(opened), MMenuLineBorders(lineBorders)],
			if (belowButton) [MBelowButton()] else [],
			if (isSome(customButton) && isSome(tryExtractStruct(style, MWidth(-1.)))) [] else [MWidthByButton()],
			if (plain) [] else [MMenuExpandingAnimation()],
			extractStructMany(style, MMenuOpenDelay(0))
		])
	)
	|> (\f -> MDynamicMenu2TInner(manager, parent, f, m2t, Some(popupId)))
}

addMDropDownMenuWarning(dropDownWarning : Maybe<MDropDownMenuWarning>) -> (Material) -> Material {
	\m -> eitherMap(dropDownWarning,
		\ddw -> {
			separatorColor = extractStruct(ddw.style, MDropDownMenuWarningColor(const(MErrorColor()))).color;
			warningFont = extractStruct(ddw.style, MDropDownMenuWarningFont(MCaption())).style;
			MLines2A(
				m,
				MSelect2(ddw.text, separatorColor, \txtM, col ->
					eitherMap(txtM, \txt -> MEllipsisText(txt, [warningFont, col]) |> MBorderTop(4.), TEmpty())
				)
			)
		},
		m
	)
}

MMenuTitle2T(
	manager : MaterialManager,
	parent : MFocusGroup,
	title : Transform<string>,
	lineHeight : double,
	selectedColor : MColor,
	selected : bool,
	widthByButton : bool,
	width : double,
	mWidthLimits : Maybe<MMenuWidthLimits>,
	primaryWidth : Maybe<DynamicBehaviour<double>>,
	secondaryWidth : Maybe<DynamicBehaviour<double>>,
	showTooltip : Transform<bool>,
	textStyle : [MTextStyle],
	inspectMetrics : Maybe<Pair<DynamicBehaviour<double>, DynamicBehaviour<double>>>,
	m2t : (Material, MFocusGroup) -> Tropic
) -> Tropic {
	TSelect(title, \t ->
		if (t != "")
			(if (width > 0. || widthByButton || isSome(mWidthLimits))
				MEllipsisText2T(
					manager,
					parent,
					MEllipsisText(
						t,
						arrayPush(
							if (selected)
								replaceStructMany(textStyle, [selectedColor, FillOpacity(1.0)])
							else
								textStyle,
							MShowTooltip(showTooltip)
						)
					),
					m2t
				)
				|> (\t2 -> eitherMap(mWidthLimits, \limits ->
					TAvailableWidth(t2, fsubtract(limits.maxWidth, faddition(either(primaryWidth, zero), either(secondaryWidth, zero)))),
					t2
				))
			else
				MText2T(
					parent,
					t,
					if (selected)
						replaceStructMany(textStyle, [selectedColor, FillOpacity(1.0)])
					else
						textStyle
				)
			)
			|> (\f -> eitherMap(inspectMetrics, \insp -> TInspect([IBaseline(insp.first), Height(insp.second)], f), f))
			|> (\f -> TAlignStartDir(f, parent.rtl))
			|> (\f -> TCenterYIn(f, TFixed(0., lineHeight)))
		else
			TEmpty()
	)
}

MMenuPrimaryAction2T(
	manager : MaterialManager,
	parent : MFocusGroup,
	style : [flow],
	lineHeight : double,
	lineBorders : double,
	color : MColor,
	selectedColor : MColor,
	selected : bool,
	indent : bool,
	m2t : (Material, MFocusGroup) -> Tropic,
	width : DynamicBehaviour<double>
) -> Tropic {
	eitherMap(
		tryExtractStruct(style, MPrimaryAction(TEmpty())),
		\pa ->
			MListIcon2T(manager, pa.content, color, selectedColor, m2t).first(selected, parent)
			|> (\t -> TCenterYIn(t, TFixed(0., lineHeight)))
			|> TBorderLeft(lineBorders)
			|> (\f -> TFixSize(f, TFixed(40. + lineBorders, lineHeight))),
		TFixed(lineBorders + if (indent) 40. else 0., 0.)
	)
	|> (\t -> TAttachWidth(t, width))
}

MMenuSecondaryAction2T(
	parent : MFocusGroup,
	style : [flow],
	lineHeight : double,
	lineBorders : double,
	addPlayArrow : bool,
	m2t : (Material, MFocusGroup) -> Tropic,
	width : DynamicBehaviour<double>
) -> Tropic {
	eitherFn(
		tryExtractStruct(style, MSecondaryAction(TEmpty())),
		\sa -> [m2t(sa.content, parent)],
		\ -> []
	)
	|> (\secondaryAction ->
		eitherMap(
			tryExtractStruct(style, MAdditionalText("")),
			\at -> arrayPush(secondaryAction, MText2T(parent, at.text, [MSubheading()])),
			secondaryAction
		)
	)
	|> (\secondaryAction -> ifArrayPush(secondaryAction, addPlayArrow, MIcon2T(parent, "play_arrow", [MIconSize(16.)])))
	|> (\secondaryAction ->
		if (length(secondaryAction) > 0)
			TCenterIn(TBorder(8., 0., lineBorders, 0., TBaselineColsDir(secondaryAction, parent.rtl)), TFixed(0., lineHeight))
		else
			TFixed(lineBorders, 0.)
	)
	|> (\t -> TAttachWidth(t, width))
}

MDropDownMenuButton2T(
	manager : MaterialManager,
	parent : MFocusGroup,
	lineB : Transform<MNonSpecifiedLine>,
	style0 : [MDropDownMenuStyle],
	onClick : () -> void,
	lightBackground : bool,
	popupId : string,
	m2t : (Material, MFocusGroup) -> Tropic
) -> Tropic {
	condensed = extractStruct(style0, MCondensed(true)).condensed;
	tableRow = contains(style0, MDataTableRow());
	tableFooter = contains(style0, MDataTableFooter());
	mWidth = extractStruct(style0, MWidth(-1.)).width;
	mWidthLimits = tryExtractStruct(style0, MMenuWidthLimits(zero, zero));
	croppedButton = contains(style0, MCroppedButton());
	croppedTitle = contains(style0, MDropDownMenuCropByContent());
	lineBorders0 = extractStruct(style0, MMenuLineBorders(if (tableFooter) 16. else 24.)).borders;
	buttonBorders = extractStruct(style0, MDropDownMenuButtonBorder(lineBorders0)).border;
	lineBorders = if (croppedButton) 0. else buttonBorders;
	color : MColor = extractStruct(style0, if (lightBackground) MBlack() else MWhite());
	separatorsColorM = tryExtractStruct(style0, MSeparatorsColor(MBlack()));
	dropDownMenuWarning = tryExtractStruct(style0, MDropDownMenuWarning(const(None()), []));
	selectedColor = MThemeColor2MColor(parent, extractStruct(style0, MSelectedColor(MAccentColor())).color);
	textStyle = concat(
		extractStruct(
			style0,
			MCustomTextStyle([
				if (!condensed) MSubheading() else if (tableFooter) MCaption() else if (tableRow) MDataRow() else MSubheading(),
			])
		).style,
		[
			color
		]
	);
	outlined = contains(style0, MOutlined());
	filled = contains(style0, MFilled());
	plain = !outlined && !filled;
	lineHeight = extractStruct(style0, MCustomLineHeight(if (filled) 54. else 32.)).height;
	nonSpecified : MNonSpecifiedLine = extractStruct(style0, MNonSpecified(MMenuSingleLine(_("Pick"), []))).item;
	mLabel = tryExtractStruct(style0, MLabel(""));
	label = \line -> eitherMap(mLabel, \lbl -> lbl.label,
		switch (line : MDropDownMenuLine) {
			MMenuSingleLine(title, __) : title;
			default : "";
		}
	);
	nonSpecifiedLabel = label(nonSpecified);
	separators = plain && extractStruct(style0, MSeparators(true)).separators;
	showTooltip = extractStruct(style0, MShowTooltip(const(false))).show;
	indent = contains(style0, MMenuIndent());
	focused = make(false);
	openMenu = extractStruct(style0, MOpenMenu(make(false))).opened;
	iconNearTitle = contains(style0, MDropDownIconNearTitle()) || croppedTitle;

	focusState =
		concat(
			replaceStructMany(
				extractMButtonState(style0),
				[
					MEnabled(fsubselect(lineB, FLift(\line -> extractStruct(line.style, MEnabled(const(true))).enabled))),
					MOnClick(onClick),
					MRippleType(const(MRippleFill())),
					MHighlightOnFocus(const(true)),
					MHighlightOnHover(const(true)),
					MFocused(focused),
					extractStruct(style0, MButtonTitle(fselectLift(lineB, label)))
				]
			),
			[
				FAccessAttribute("aria-haspopup", const("menu")),
				FAccessAttribute("aria-expanded", fselectLift(openMenu, b2s)),
				FAccessAttribute("aria-owns", fif(openMenu, const(popupId), const(""))),
			]
		);

	active = fOr(openMenu, focused);
	outlineColorActive = if (outlined) extractStruct(style0, MOutlineColor(selectedColor)).color else selectedColor;
	outlineColorPassive = if (outlined) extractStruct(style0, MOutlineColor(color)).color else color;
	opacity = if (outlined) extractStruct(style0, MOutlineOpacity(1.)).opacity else 1.;
	widthActive = if (outlined) extractStruct(style0, MOutlineWidth(2.)).width else 2.;
	widthPassive = if (outlined) extractStruct(style0, MOutlineWidth(1.)).width else 1.;
	graphicsState = fif(active,
		const(MGraphicsState(widthActive, MThemeColor2int(manager, outlineColorActive), opacity, true)),
		{
			defPassive = const(MGraphicsState(widthPassive, MThemeColor2int(manager, outlineColorPassive), 0.38 * opacity, false));
			eitherMap(dropDownMenuWarning,
				\ddw -> {
					separatorColor = extractStruct(ddw.style, MDropDownMenuWarningColor(const(MErrorColor()))).color;
					fif(
						fselectLift(ddw.text, \txtM -> eitherMap(txtM, \txt -> txt != "", false)),
						fselectLift(separatorColor, \col -> MGraphicsState(widthPassive, MThemeColor2int(manager, col), 1., false)),
						defPassive
					)
				},
				defPassive
			)
		}
	);

	dynColor = make(eitherMap(dropDownMenuWarning, \ddw ->
		fgetValue(extractStruct(ddw.style, MDropDownMenuWarningColor(const(MErrorColor()))).color),
		color
	));
	floatingLabelProgress = make(1.);
	labelWidth = make(0.);

	primaryWidth = make(0.);
	secondaryWidth = make(0.);
	pAc = \st -> MMenuPrimaryAction2T(manager, parent, st, lineHeight, lineBorders, color, color, false, indent, m2t, primaryWidth);
	sAc = \st -> MMenuSecondaryAction2T(parent, st, lineHeight, lineBorders, false, m2t, secondaryWidth);

	addActions = \st -> \t ->
		TColsDir([
			pAc(st),
			t,
			sAc(st)
		], parent.rtl)
		|> (\t2 -> if (contains(style0, MDropDownIconNearTitle())) TGroup2(t2, TFillX()) else t2);

	alpha = \focus ->
		eitherMap(
			tryExtractStruct(style0, MDropDownMenuDisabledOpacity(const(0.))),
			\do -> fif(focus.enabled, const(1.), do.opacity),
			getMenuAlpha(focus, parent)
		);

	setMenuBaseline = \avH, height, baseline ->
		\t -> TBaseline(faddition(baseline, fmax(zero, fdivide(fsubtract(avH, height), const(2.)))), t);

	makeFloatingLabelState = \style, trigger, labelSize -> {
		xOffset =
			if (filled) 0.
			else eitherMap(
				tryExtractStruct(style, MPrimaryAction(TEmpty())),
				\__ -> 52.,
				12.
			);
		MFloatingLabelState(floatingLabelProgress, trigger, 12., labelSize, -xOffset, xOffset, if (filled) 8. else -8., if (filled) 10. else 16.)
	}

	TSelect(lineB, \line ->  // Display chosen item when not expanded
		switch (line) {
			MMenuSingleLine(title, style): {
				lineTextStyle : [MTextStyle] = extractStruct(style, MCustomTextStyle(textStyle)).style;
				baseline = make(0.);
				height = make(0.);

				MMenuTitle2T(
					manager, parent, const(title), lineHeight, color, false, false, mWidth, mWidthLimits,
					Some(primaryWidth), Some(secondaryWidth), showTooltip, lineTextStyle, Some(Pair(baseline, height)), m2t
				)
				|> (\t -> TAlignStartDir(t, parent.rtl))
				|> (\t ->
					if (plain) t
					else {
						isNonSpec = title == nonSpecifiedLabel;
						trigger = if (isNonSpec) fstall(openMenu, 66) else const(true);
						showLabel = if (isNonSpec) fneq(floatingLabelProgress, 1.) else const(true);
						showTitle = if (isNonSpec) feq(floatingLabelProgress, 1.) else const(true);

						characterStyle = MTextStyle2CharacterStyle(parent, lineTextStyle);
						labelSize = extractStruct(characterStyle, FontSize(14.)).size;
						TGroup2(
							TVisible(showTitle, if (filled && !isNonSpec) TTranslate(const(Point(0., 8.)), t) else t),
							TVisible(
								showLabel,
								makeMFloatingLabel(manager, parent, nonSpecifiedLabel,
									makeFloatingLabelState(style, trigger, labelSize),
									fif(active,
										const(characterStyle),
										const(replaceStruct(characterStyle, FillOpacity(defaultInactiveItemLabelOpacity(MColor2int(color) == black))))
									),
									Some(MDynamicColor(dynColor)),
									labelWidth, m2t
								)
							)
						)
					}
				)
				|> (\f -> if (iconNearTitle) f else TGroup2(TFillX(), f))
				|> addActions(style)
				|> setMenuBaseline(const(lineHeight), height, baseline)
			}
			MMenuCustomLine(content, style): {
				availableH = make(0.);
				height = make(0.);
				baseline = make(0.);

				m2t(MAlignStart(content), parent)
				|> (\t -> TInspect([IAvailableHeight(availableH), Height(height), IBaseline(baseline)], t))
				|> TCenterY
				|> (\t ->
					if (plain) t
					else {
						TGroup2(
							if (filled) TTranslate(const(Point(0., 8.)), t) else t,
							makeMFloatingLabel(manager, parent, nonSpecifiedLabel,
								makeFloatingLabelState(style, const(true), 14.),
								fif(active, const([]), const([FillOpacity(defaultInactiveItemLabelOpacity(MColor2int(color) == black))])),
								Some(MDynamicColor(dynColor)),
								labelWidth, m2t
							)
						)
					}
				)
				|> (\f -> if (iconNearTitle) f else TGroup2(TFillX(), f))
				|> addActions(style)
				|> setMenuBaseline(availableH, height, baseline)
			}
		}
	)
	|> (\f ->
		if (filled || containsStruct(style0, MDropDownMenuButtonBackground(\__ -> []))) {
			backgroundDefaultStyle =
				if (filled) \act -> [Fill(contrastingColor(parent)), FillOpacity(if (act) 0.12 else 0.06)]
				else \__ -> [];
			bgStyle = extractStruct(style0, MDropDownMenuButtonBackground(backgroundDefaultStyle)).fn;
			shape = if (plain) "default" else {
				(if (filled) "filled" else "outlined") + " text field"
			};

			TCopySize(f, \tr ->
				TIfLazy2(active, \act -> MShape(parent, bgStyle(act), tr, shape), true),
				false
			)
		} else f
	)
	|> (\f ->
		MComponent2T(manager, parent, "MDropDownMenuButton", focusState, \focus ->
			TAlpha(alpha(focus), f), m2t
		)
	)
	|> (\f -> if (outlined) {
			addMOutline(
				manager,
				parent,
				labelWidth,
				floatingLabelProgress,
				graphicsState,
				dynColor
			)(f)
		} else if (filled) {
			addMFilledUnderline(
				manager,
				parent,
				graphicsState,
				dynColor
			)(f |> TBorderBottom(-1.))
		} else f)
	|> (\f ->
		if (tableFooter || tableRow || !separators)
			f
		else TCopySize2(f, \sz, tr -> {
			separator = eitherMap(
				separatorsColorM,
				\separatorColor -> TRectangle([MFill(separatorColor.color)], TFillXH(1.)),
				eitherMap(
					dropDownMenuWarning, 
					\ddw -> {
						separatorColor = extractStruct(ddw.style, MDropDownMenuWarningColor(const(MErrorColor()))).color;
						MSelect(ddw.text, \txtM->
							eitherMap(txtM, \txt ->
								if (txt != "") MSelect(separatorColor, \col ->
									TRectangle([MFill(MThemeColor2MColor(parent, col))], TFillXH(1.))
								) else MSeparator(true),
								MSeparator(true)
							)
						)
					},
					MSeparator(true)
				)
			)
			|> (\t -> m2t(t, parent))
			|> (\t -> TAvailable(t, sz));

			if (croppedButton)
				TBaselineLines2(
					tr |> TBorderBottom(-1.),
					separator
				)
			else
				TLines2(
					separator,
					TBaselineLines2(
						tr |> TBorderTopBottom(-1.),
						separator
					)
				)
		})
	)
	|> (if (croppedButton)
			TBorderLeftRight(buttonBorders)
		else
			idfn)
	|> (\f -> TGroup2(f, TFillY()))
	|> (\f -> TAvailable(f, if (mWidth < 0.) TFillX() else TFixed(mWidth, 0.)))
	|> (if (croppedTitle) idfn else makeTropicConstantWidth(Some(mWidth)))
}

MMenuTextButton2T(
	manager : MaterialManager,
	parent : MFocusGroup,
	text : string,
	shortcut : string,
	onClick : () -> void,
	style : [MTextButtonStyle],
	openMenu : MOpenMenu,
	focused : MFocused,
	m2t : (Material, MFocusGroup) -> Tropic
) -> Tropic {
	raised = contains(style, MButtonRaised());
	color = extractStruct(style, getTextColor(parent));
	buttonTextColor = tryExtractStruct(style, MButtonTextColor(false));
	fullWidth = contains(style, MFullWidth());
	focusState =
		[
			MOnClick(\ -> {
				onClick();
				reverseBehaviour(openMenu.opened)
			}),
			MRippleType(const(MRippleFill())),
			extractStruct(style, MButtonTitle(const(text))),
			focused
		];

	disabled = \ ->
		MText2T(
			parent,
			text,
			[MSecondaryButtonStyle(), MTextDisabled(), getTextColor(parent)]
		)
		|> MGridCenterX
		|> TBorderLeftRight(14.)
		|> TBorderTopBottom(6.)
		|> (\f -> if (fullWidth) TCenterX(f) else f)
		|> (\f ->
			TFrame(
				0.0,
				4.0,
				[
					Fill(contrastingColor(parent)),
					FillOpacity(if (raised) 0.12 else 0.0)
				],
				f
			)
		);

	(\ ->
		MText2T(
			parent,
			text,
			[
				MSecondaryButtonStyle(),
				if (raised) {
					eitherFn(
						buttonTextColor,
						\btc -> if (btc.white) MWhite() else MBlack(),
						\ -> MTextMColor(color)
					)
				} else {
					color
				}
			]
		)
		|> MGridCenterX
		|> TBorderLeftRight(14.)
		|> TBorderTopBottom(6.)
		|> (\f -> if (fullWidth) TCenterX(f) else f)
	)
	|> (\f ->
		MComponent2T(
			manager,
			parent,
			"MMenuTextButton",
			focusState,
			\focus -> {
				(\ -> if (raised) {
					z =
						fselect2(
							fOr(fOr(focus.hover, openMenu.opened), focus.focused), focus.down,
							FLift2(\h, d -> if (d) 6. else if (h) {if (getLightBackground(parent)) 2. else 3.} else 0.)
						);

					TFrame(
						0.0,
						4.0,
						[
							MFill(color),
							FillOpacity(1.0)
						],
						f()
					)
					|> (\f2 -> TEasedShadow(manager, parent, z, f2, 0.3))
				} else {
					TCopySize(
						f(),
						\tr ->
							TIfLazy2(
								fOr(fOr(focus.hover, openMenu.opened), focus.focused), \foc ->
								TFrame(
									0.0,
									4.0,
									if (foc) [
										Fill(if (getLightBackground(parent)) 0x999999 else 0xcccccc),
										FillOpacity(if (getLightBackground(parent)) 0.2 else 0.15)
									] else interactiveRectangleStyle,
									tr
								),
								true
							),
						false
					)
				})
				|> (\f2 -> TIfLazy2(focus.enabled, \en -> if (en) f2() else disabled(), false))
			},
			m2t
		)
	)
	|> (\f -> TBaselineOffset(const(-10.0), f))
}

MMenuLinesState(
	manager : MaterialManager,
	m2t : (Material, MFocusGroup) -> Tropic,
	lineHeight : double,
	elevation : double,
	nearTitle : bool,
	popupId : string,
	activeDescendantId : DynamicBehaviour<string>,
	makeTitle : (MFocusGroup, [MTextStyle], Transform<string>, bool, bool, Maybe<DynamicBehaviour<double>>, Maybe<DynamicBehaviour<double>>) -> Tropic,
	singleSelectionToggle : bool
);

MMenuLines2Material(
	items0 : [MMenuLine],
	style0 : [MMenuStyle],
	lineBorders : double,
	closeBelow : () -> void,
	focusedItem : DynamicBehaviour<Maybe<MMenuFocusedItem>>,
	state : MMenuLinesState
) -> [[Material]] {

	tableRow = contains(style0, MDataTableRow());
	tableFooter = contains(style0, MDataTableFooter());
	condensed = extractStruct(style0, MCondensed(true)).condensed;
	singleSelection = tryExtractStruct(style0, MSingleSelection(make(-1)));
	selectedId = eitherMap(singleSelection, \ss -> getValue(ss.selected), -1);
	selectedColor : (MFocusGroup) -> MColor = \parent -> MThemeColor2MColor(parent, extractStruct(style0, MSelectedColor(MAccentColor())).color);
	openMenu = extractStruct(style0, MOpenMenu(make(false)));
	onListClick = extractStruct(style0, MOnListClick(const(true), nop1));
	indent = contains(style0, MMenuIndent());
	fixPosition = tryExtractStruct(style0, MFixPosition(true));
	selectedOnTop = tryExtractStruct(style0, MSelectedAlwaysOnTop(MMenuSingleLine("", [])));
	nonspecAlwaysOnTopM = tryExtractStruct(style0, MMenuNonSpecifiedAlwaysOnTop(MSeparatorLine()));
	nonspecAlwaysOnTop = isSome(nonspecAlwaysOnTopM);
	indexShift = nonspecAlwaysOnTop || (isSome(selectedOnTop) && isSome(singleSelection));
	cols = if (indexShift) 0 else extractStruct(style0, MMenuCols(1)).cols - 1;
	nextFn = if (contains(style0, MForceUpdate())) next else nextDistinct;
	focusName = extractStruct(style0, MFocusName("MMenu")).name;
	popupRole = extractStruct(style0, AccessRole(if (strContains(toLowerCase(focusName), "drop")) "listbox" else "menu")).role;
	lineHeight = state.lineHeight;

	items1 : [MMenuLine] =
		(if (indexShift) {
			concat(
				[
					eitherMap(
						nonspecAlwaysOnTopM,
						\nsaot -> nsaot.emptySelection,
						if (selectedId < 0)
							eitherMap(selectedOnTop, \sot -> sot.emptySelection, MSeparatorLine())
						else
							MSeparatorLine()
					),
					MSeparatorLine()
				],
				items0
			)
		} else {
			items0;
		});

	hovered = make(-1);

	textStyle = extractStruct(
		style0,
		MCustomTextStyle([if (!condensed) MSubheading() else if (tableFooter) MCaption() else if (tableRow) MDataRow() else MSubheading()])
	).style;
	iconSize = if (tableRow || tableFooter) 16.0 else 20.0;
	iconBorders = extractStruct(style0, MDropDownMenuIconBorders(MIconBorder4(0., 0., 0., 0.))).borders;

	dropDownIcon =
		MDropDownIcon(openMenu.opened, [MIconSize(iconSize), iconBorders])
		|> (\m -> MCenterYIn(m, TFixed(0., lineHeight)));

	shiftGap = if (indexShift) 2 else 0;

	unselectPrevious = \ss -> {
		prevSelected = getValue(ss.selected);
		if (prevSelected >= 0 && prevSelected + shiftGap < length(items1)) {
			switch(items1[prevSelected + shiftGap]) {
				MMenuSingleLine(__, ___style): {
					nextDistinct(extractStruct(___style, MSelected(make(false))).selected, false);
				}
				MMenuCustomLine(__, ___style):{
					nextDistinct(extractStruct(___style, MSelected(make(false))).selected, false);
				}
				default : {}
			}
		}
	}

	onItemClick = \i, click, isSelected, focused, shouldClose -> \ -> {
		if (shouldClose()) {
			nextDistinct(openMenu.opened, false);
			closeBelow();
		}

		if (i >= shiftGap) {
			setSelectedFn = \ ->
				maybeApply(singleSelection, \ss -> {
					unselectPrevious(ss);
					if (state.singleSelectionToggle && getValue(ss.selected) == i - shiftGap) {
						nextFn(ss.selected, -1);
						nextDistinct(isSelected, false)
					} else {
						nextFn(ss.selected, i - shiftGap);
						nextDistinct(isSelected, true)
					}
				});
			setSelectedFn();
			if (fgetValue(onListClick.enabled)) onListClick.onClick(i - shiftGap);
			click(); // action is moved outside delayed code - to solve issue with copying something to clipboard in a firefox.
		} else if (nonspecAlwaysOnTop && i == 0) maybeApply(singleSelection, \ss -> {
			unselectPrevious(ss);
			nextFn(ss.selected, -1)
		})
	};

	itemOnTop = \i -> {
		indexShift && (
			if (nonspecAlwaysOnTop) i == 0
			else (selectedId >= 0 && i == selectedId + 2) || (selectedId == -1 && i == 0)
		);
	}

	getLineStyle = \style, i ->
		if (itemOnTop(i))
			replaceStruct(style,
				MSecondaryAction(
					MCols2A(
						extractStruct(style, MSecondaryAction(TEmpty())).content,
						dropDownIcon
					)
				)
			)
		else
			style;

	addActions = \parent, style : [flow], selected, addPlayArrow, primaryWidth, secondaryWidth -> \t ->
		TColsDir([
			MMenuPrimaryAction2T(state.manager, parent, style, lineHeight, lineBorders, getTextColor(parent),
				selectedColor(parent), selected, indent, state.m2t, primaryWidth),
			t,
			MMenuSecondaryAction2T(parent, style, lineHeight, lineBorders, addPlayArrow, state.m2t, secondaryWidth)
		], parent.rtl)
		|> (\t2 -> if (state.nearTitle) TGroup2(t2, TFillX()) else t2);

	shouldCloseFn = \def -> \ -> fgetValue(extractStruct(style0, MCloseOnClickEnabled(const(def))).enabled);

	shouldFocus = \fi, i, selectedM ->
		switch (fi) {
			MMenuFirstItem() : eitherMap(selectedM, \s -> s || i == 0, i == shiftGap);
			MMenuLastItem() : i == length(items1) - 1;
		}

	focusOnOpen = \i, st, selectedM ->
		eitherMap(getValue(focusedItem),
			\fi ->
				if (shouldFocus(fi, i, selectedM)) {
					focused = extractStruct(st, MFocused(make(false))).focused;
					// Delay is to make sure screenreader (NVDA) is ready to react on line is focused.
					timer(300, \ -> {
						nextDistinct(focusedItem, None());
						nextDistinct(focused, true);
					});
					replaceStruct(st, MFocused(focused))
				} else st,
			st
		);

	makeMMenuLine = \i, title : Maybe<string>, content : Maybe<Material>, _style ->
		MGetFocusGroup(\parent -> {
			style = getLineStyle(_style, i);
			hgt = extractStruct(style, MHeight(lineHeight)).height;
			selectedInspector = extractStruct(style, MSelected(make(false))).selected;
			focused = extractStruct(style, MFocused(make(false))).focused;
			onClick = onItemClick(i, extractStruct(style, MOnClick(nop)).click, selectedInspector, focused, shouldCloseFn(true));
			visuallySelected = selectedId == i && !indexShift;
			selected = i == if (!indexShift) selectedId else if (selectedId == -1) 0 else selectedId + shiftGap;
			id = state.popupId + "_menuitem" + i2s(i);
			focusState =
				replaceStructMany(
					style,
					[
						MOnClick(onClick),
						extractStruct(_style, AccessRole(if (popupRole == "menu") "button" else "option")),
						MRippleType(const(MRippleFill())),
						extractStruct(style, MHighlightOnFocus(const(true))),
						extractStruct(style, MHighlightOnHover(const(true))),
						MFocusOnDown(ref true),
						FAccessAttribute("aria-selected", const(if (popupRole == "menu") "" else b2s(selected))),
						extractStruct(_style, MRippleOutlineEnabled(const(false))),
						MFocused(focused)
					]
					|> (\arr -> arrayPush(arr,
							if (popupRole == "menu" && !mobile) FAccessAttribute("aria-hidden", fselectLift(focused, \foc -> b2s(!foc)))
							else FAccessAttribute("id", const(id))
						))
					|> (\arr -> focusOnOpen(i, arr, Some(selected)))
					|> (\arr -> eitherMap(title, \t -> arrayPush(arr, extractStruct(_style, MButtonTitle(const(t)))), arr))
				);
			lineTextStyle = extractStruct(style, MCustomTextStyle(arrayPush(textStyle, getTextColor(parent)))).style;

			primaryWidth = make(0.);
			secondaryWidth = make(0.);
			lineAlpha = make(0.);

			lineContent =
				eitherFn(title,
					\t -> state.makeTitle(parent, lineTextStyle, const(t), visuallySelected, itemOnTop(i), Some(primaryWidth), Some(secondaryWidth)),
					\ ->
						state.m2t(MAlignStart(either(content, TEmpty())), parent)
						|> (\t -> TCenterYIn(t, TFixed(0., hgt)))
						|> (\t -> TGroup2(TFillX(), t))
				)
				|> (\ttl -> TAccess([FAccessHidden()], ttl))
				|> addActions(parent, style, visuallySelected, false, primaryWidth, secondaryWidth)
				|> (\t -> TFrame(0., 0., mgraphicsStyle2tgraphicsStyle(parent, extractStruct(style0, MBackgroundStyle([])).style), t))
				|> (\t -> TAlpha(lineAlpha, t));


			wrapConstructors = \focus, t ->
				TConstruct(
					[
						makeSubscribe2(fmax(focus.hover, focus.down), \h -> if (h) nextDistinct(hovered, i)),
						makeSubscribe(focus.focused, \foc -> if (foc) nextDistinct(state.activeDescendantId, id)),
						\ -> fconnect(getMenuAlpha(focus, focus.parent), lineAlpha)
					],
					t
				);

			MComponent2T(state.manager, parent, "MMenuSingleLine", focusState, \focus -> wrapConstructors(focus, lineContent), state.m2t)
			|> (\t -> if (popupRole == "menu" && !mobile) TAccess(
				[
					AccessRole("menuitem"),
					TagName("div"),
					FAccessAttribute("id", const(id))
				],
				t
			) else t)
			|> if (isSome(title)) makeTropicConstantHeightDef(hgt) else idfn
		});

	makeMMenuGroupLine = \i, acc : Pair<int, [[Material]]>, title, style -> {
		if (indexShift && i < length(items0) && selectedId >= 0 && selectedId == i - 1 && isSameStructType(items0[i], MMenuGroupLine("", []))) {
			acc
		} else {
			addLine = \parent, f ->
				if (((i - shiftGap) != 0) && !(indexShift && i > 3 && selectedId == i - 3 &&
						isSameStructType(items0[i - 4], MMenuGroupLine("", []))))
					TLines2(
						TAlpha(const(0.12), TRectangle([Fill(contrastingColor(parent))], TFillXH(1.0)))
						|> (\f2 -> TBorder(0.0, 16.0, 0.0, 8.0, f2)),
						f
					)
				else
					f;
			primaryWidth = make(0.);
			secondaryWidth = make(0.);

			MGetFocusGroup(\parent -> {
				groupColor = extractMColor(parent, style, MPrimaryColor());
				lineTextStyle = extractStruct(style, MCustomTextStyle([groupColor, MBodyBold()])).style;

				state.makeTitle(parent, lineTextStyle, const(title), false, false, Some(primaryWidth), Some(secondaryWidth))
				|> addActions(parent, style, false, false, primaryWidth, secondaryWidth)
				|> makeTropicConstantHeight(Some(lineHeight))
				|> (\f -> addLine(parent, f))
			})
			|> (\f -> Pair(cols, arrayPush(acc.second,
				concat([f], generate(0, cols, \__ -> MGetFocusGroup(\parent -> addLine(parent, TFillX()))))
			)))
		}
	}

	makeMSubMenu = \i, title, contentM : Maybe<Material>, items, style : [MSubMenuStyle] -> {
		subOpenMenu : MOpenMenu = extractStruct(style, MOpenMenu(make(false)));
		hgt = extractStruct(style, MHeight(lineHeight)).height;
		expanding = contains(style, MExpanding());
		lineTextStyle = \p -> extractStruct(style, MCustomTextStyle(arrayPush(textStyle, getTextColor(p)))).style;
		isCloseParentOnClick = extractStruct(style, MCloseParentOnClick(true)).close;
		focused = extractStruct(style, MFocused(make(false))).focused;
		onClick = onItemClick(i, extractStruct(style, MOnClick(nop)).click, make(false), focused, shouldCloseFn(false));

		onClose = \ -> if (isCloseParentOnClick) {
			next(openMenu.opened, false);
			closeBelow();
		}

		if (expanding) {
			mainLine = MGetFocusGroup(\parent -> {
				focusState =
					replaceStructMany(
						style,
						[
							MOnClick(\ -> {
								reverseBehaviour(subOpenMenu.opened);
								onClick()
							}),
							AccessRole("menuitem"),
							FAccessAttribute("aria-expanded", fselectLift(subOpenMenu.opened, b2s)),
							MRippleType(const(MRippleFill())),
							extractStruct(style, MButtonTitle(title)),
							MHighlightOnFocus(const(true)),
							MHighlightOnHover(const(true)),
							extractStruct(style, MRippleOutlineEnabled(const(false))),
							MFocused(focused)
						]
					)
					|> (\focusState -> replaceStruct(focusState, MFocusOnPrevious(false)));

				sAc =
					MCols2A(
						extractStruct(style, MSecondaryAction(TEmpty())).content,
						MDropDownIcon(subOpenMenu.opened, [MIconSize(iconSize), iconBorders])
					);
				actionsStyle = replaceStruct(style, MSecondaryAction(sAc));

				primaryWidth = make(0.);
				secondaryWidth = make(0.);

				MComponent2T(state.manager, parent, "MSubMenuDynamic", focusState, \focus ->
					eitherFn(contentM,
						\content ->
							state.m2t(content, parent)
							|> (\t -> TCenterYIn(t, TFixed(0., hgt)))
							|> (\t -> TGroup2(TFillX(), t)),
						\ -> state.makeTitle(parent, lineTextStyle(parent), title, false, false, Some(primaryWidth), Some(secondaryWidth)),
					)
					|> addActions(parent, actionsStyle, false, false, primaryWidth, secondaryWidth)
					|> (\t ->
						TAlpha(
							getMenuAlpha(focus, parent),
							TFrame(0., 0., mgraphicsStyle2tgraphicsStyle(parent, extractStruct(style0, MBackgroundStyle([])).style), t)
						)
					)
					|> (\t -> TConstruct([makeSubscribe2(items, \__ -> reopenMenu(openMenu))], t)),
					state.m2t
				)
				|> makeTropicConstantHeight(Some(lineHeight))
			});

			subMenuStyle =
				replaceStructMany(style, [subOpenMenu, extractStruct(style, MButtonTitle(title))])
				|> MSubMenuStyle2MMenuStyle;

			children =
				MMenuLines2Material(fgetValue(items), subMenuStyle, lineBorders + 8., onClose, make(None()), state)
				|> concatA
				|> (\arr -> map(arr, \it -> MShow(subOpenMenu.opened, it)));

			concat([mainLine], children)
		} else {
			MGetFocusGroup(\parent -> {
				subButtonWH = makeWH();
				subPosScale = make(zeroPositionScale);
				isOpenOnClick = contains(style, MSubMenuOpenOnClick());
				subMenuPopupId = getPopupId(state.manager);
				subFocusedItem = make(None());

				primaryWidth = make(0.);
				secondaryWidth = make(0.);

				focusState =
					replaceStructMany(
						style,
						[
							MOnClick(\ -> {
								if (isOpenOnClick) deferred(\-> nextDistinct(subOpenMenu.opened, true));
								onClick();
							}),
							AccessRole("menuitem"),
							FAccessAttribute("aria-haspopup", const("menu")),
							FAccessAttribute("aria-expanded", fselectLift(subOpenMenu.opened, b2s)),
							FAccessAttribute("aria-owns", fif(subOpenMenu.opened, const(subMenuPopupId), const(""))),
							MRippleType(const(MRippleFill())),
							extractStruct(style, MButtonTitle(title)),
							MHighlightOnFocus(const(true)),
							MHighlightOnHover(const(true)),
							MFocusOnDown(ref true),
							extractStruct(style, MRippleOutlineEnabled(const(false))),
							MFocused(focused)
						]
					)
					|> (\arr -> focusOnOpen(i, arr, None()))
					|> (\focusState -> replaceStruct(focusState, MFocusOnPrevious(false)));

				MComponent2T(state.manager, parent, "MSubMenuDynamic", focusState, \focus ->
					eitherFn(contentM,
						\content ->
							state.m2t(content, parent)
							|> (\t -> TCenterYIn(t, TFixed(0., hgt)))
							|> (\t -> TGroup2(TFillX(), t)),
						\ -> state.makeTitle(parent, lineTextStyle(parent), title, false, false, Some(primaryWidth), Some(secondaryWidth))
					)
					|> addActions(parent, style, false, true, primaryWidth, secondaryWidth)
					|> (\t ->
						TAlpha(
							getMenuAlpha(focus, parent),
							TFrame(0., 0., mgraphicsStyle2tgraphicsStyle(parent, extractStruct(style0, MBackgroundStyle([])).style), t)
						)
					)
					|> (\t -> TInteractive([
							KeyDown(\ke -> {
								if (ke.utf == "left" && fgetValue(subOpenMenu.opened)) {
									nextDistinct(hovered, -1);
									deferred(\ -> nextDistinct(focus.focused, true));
								} else if ((ke.utf == "enter" || ke.utf == " ") && getValue(focus.focused)) {
									nextDistinct(subFocusedItem, Some(MMenuFirstItem()))
								}
							})
						], t))
					|> (\f2 ->
						TConstruct(
							[
								makeSubscribe2(fmax(focus.hover, focus.down), \h -> if (h) nextDistinct(hovered, i)),
								makeSubscribe2(hovered, \h ->
									if (h != i)
										nextDistinct(subOpenMenu.opened, false)
									else if (!isOpenOnClick)
										deferred(\ -> nextDistinct(subOpenMenu.opened, true))
								),
								makeSubscribe2(items, \__ -> reopenMenu(subOpenMenu)),
								makeSubscribe(subOpenMenu.opened, \op -> {
									itms = fgetValue(items);
									if (op)
										RenderMPopup(
											state.manager,
											parent,
											MMenuLines2MPopup(
												state.manager,
												itms,
												MSubMenuStyle2MMenuStyle(
													replaceStructMany(
														style,
														concat(
															[
																subOpenMenu,
																extractStruct(style, MSameZorder(true)),
																extractStruct(style, MButtonTitle(title))
															],
															extractStructMany(style0, MCloseOnClickEnabled(const(false)))
														)
														|> (\arr : [MMenuStyle] -> eitherMap(fixPosition, \fp -> arrayPush(arr, fp), arr))
													)
													|> (\subMenuStyle -> replaceStruct(subMenuStyle, MFocusOnPrevious(false)))
												),
												state.m2t,
												subPosScale,
												subButtonWH,
												state.elevation + 1.,
												onClose,
												subMenuPopupId,
												subFocusedItem
											),
											state.m2t
										)
								}),
								\ -> \ -> next(subOpenMenu.opened, false)
							],
							f2
						)
					), state.m2t
				)
				|> (\f -> MPositionScaleAttachBox(subPosScale, subButtonWH, f, openMenu.opened))
				|> makeTropicConstantHeight(Some(lineHeight))
			}) |> v2a
		}
	}

	makeSeparatorLine = \acc ->
		MGetFocusGroup(\parent ->
			TRectangle([Fill(contrastingColor(parent)), FillOpacity(0.12)], TFillXH(1.0))
			|> TBorderTopBottom(8.)
		)
		|> (\f -> Pair(cols, arrayPush(acc.second, generate(0, cols + 1, \__ -> f))));

	distributeToCols = \acc : Pair<int, [[Material]]> -> \f : Material ->
		if (acc.first < cols && length(acc.second) > 0)
			Pair(
				acc.first + 1,
				arrayPush(
					removeIndex(acc.second, length(acc.second) - 1),
					arrayPush(lastElement(acc.second, []), f)
				))
		else
			Pair(0, arrayPush(acc.second, [f]));

	distributeToColsA = \acc : Pair<int, [[Material]]> -> \arr : [Material] ->
		fold(arr, acc, \acc2, line -> line |> distributeToCols(acc2));

	foldi(items1, Pair(0, []), \i, acc : Pair<int, [[Material]]>, it : MMenuLine -> {
		switch (it : MMenuLine) {
			MMenuSingleLine(title, style):
				makeMMenuLine(i, Some(title), None(), style) |> distributeToCols(acc);
			MMenuCustomLine(content, style):
				makeMMenuLine(i, None(), Some(content), style) |> distributeToCols(acc);
			MMenuGroupLine(title, style):
				makeMMenuGroupLine(i, acc, title, style);
			MSubMenu(title, items, style):
				makeMSubMenu(i, const(title), None(), const(items), style) |> distributeToColsA(acc);
			MSubMenuDynamic(title, items, style):
				makeMSubMenu(i, title, None(), items, style) |> distributeToColsA(acc);
			MSubMenuCustom(content, items, style):
				makeMSubMenu(i, const(""), Some(content), items, style) |> distributeToColsA(acc);
			MSeparatorLine():
				makeSeparatorLine(acc);
		}
	}).second;
}

MMenuLines2MPopup(
	manager : MaterialManager,
	items0 : [MMenuLine],
	style0 : [MMenuStyle],
	m2t : (Material, MFocusGroup) -> Tropic,
	posScale : Transform<PositionScale>,
	buttonWH : Behaviour<WidthHeight>,
	elevation : double,
	closeBelow : () -> void,
	popupId : string,
	focusedItem : DynamicBehaviour<Maybe<MMenuFocusedItem>>
) -> MPopup {
	tableFooter = contains(style0, MDataTableFooter());
	condensed = extractStruct(style0, MCondensed(true)).condensed;
	maxHeight = extractStruct(style0, MMaxHeight(-1.));
	mWidth = extractStruct(style0, MWidth(-1.)).width;
	widthByButton = contains(style0, MWidthByButton());
	mWidthLimits = tryExtractStruct(style0, MMenuWidthLimits(zero, zero));
	useFocusInspector = contains(style0, MMenuUseFocusInspector());
	singleSelection = tryExtractStruct(style0, MSingleSelection(make(-1)));
	singleSelectionToggle = contains(style0, MSingleSelectionToggle());
	selectedId = eitherMap(singleSelection, \ss -> getValue(ss.selected), -1);
	selectedColor : (MFocusGroup) -> MColor = \parent -> MThemeColor2MColor(parent, extractStruct(style0, MSelectedColor(MAccentColor())).color);
	openMenu = extractStruct(style0, MOpenMenu(make(false)));
	belowButton = contains(style0, MBelowButton());
	fixPosition = tryExtractStruct(style0, MFixPosition(true));
	selectedOnTop = tryExtractStruct(style0, MSelectedAlwaysOnTop(MMenuSingleLine("", [])));
	nonspecAlwaysOnTopM = tryExtractStruct(style0, MMenuNonSpecifiedAlwaysOnTop(MSeparatorLine()));
	nonspecAlwaysOnTop = isSome(nonspecAlwaysOnTopM);
	indexShift = nonspecAlwaysOnTop || (isSome(selectedOnTop) && isSome(singleSelection));
	dpiScale = extractStruct(manager.manager.renderStyle, TInspectDpiFactor(make(Factor(1.0, 1.0)))).factor;
	menuShift = extractStruct(style0, MMenuShift(const(zeroPoint))).shift;
	showTooltip = extractStruct(style0, MShowTooltip(const(false))).show;
	customScale = tryExtractStruct(style0, MCustomScale(const(Factor(1., 1.))));
	cols = if (indexShift) 0 else extractStruct(style0, MMenuCols(1)).cols - 1;
	mLabel = tryExtractStruct(style0, MLabel(""));
	sameZorder = extractStruct(style0, MSameZorder(false)).same;
	focusName = extractStruct(style0, MFocusName("MMenu")).name;
	popupRole = extractStruct(style0, AccessRole(if (strContains(toLowerCase(focusName), "drop")) "listbox" else "menu")).role;
	menuScrollStyle = extractStruct(style0, MMenuScrollStyle([])).style;
	activeDescendantId = make("");

	leftAnimation =
		widthByButton ||
		(if (mWidth > 0.)
			fgetValue(posScale).pos.x / getValue(dpiScale).x + mWidth <= getRealStageWidthHeight(manager).width
		else
			fgetValue(posScale).pos.x / getValue(dpiScale).x <= getRealStageWidthHeight(manager).width / 2.);

	expandingAnimation = contains(style0, MMenuExpandingAnimation());
	lineHeight = extractStruct(style0, MCustomLineHeight(if (!condensed) 48. else 32.)).height;
	borders = extractStruct(style0, MMenuPopupBorders(if (lineHeight == 32.) 16. else 8.)).borders;
	lineBorders = extractStruct(style0, MMenuLineBorders(if (tableFooter) 16. else 24.)).borders;
	nearTitle = contains(style0, MDropDownIconNearTitle());

	makeTitle = \parent, lineTextStyle, ttl, selected, onTop, primaryWidth, secondaryWidth ->
		MMenuTitle2T(
			manager, parent, ttl, lineHeight, selectedColor(parent), selected, widthByButton, mWidth, mWidthLimits,
			primaryWidth, secondaryWidth, showTooltip, lineTextStyle, None(), m2t
		)
		|> (\t -> TAlignStartDir(t, parent.rtl))
		|> (\f -> if (onTop && nearTitle) f else TGroup2(TFillX(), f));

	addLabel = \t ->
		eitherMap(
			mLabel,
			\lbl ->
				concat(
					[[
						MGetFocusGroup(\p ->
							makeTitle(p, [MBodyBold(), MPrimaryColor()], const(lbl.label), false, false, None(), None())
							|> TBorderLeftRight(lineBorders)
							|> makeTropicConstantHeight(Some(lineHeight))
						)
					]],
					t
				),
			t
		);

	itemsWithFocuses = map(items0, MMenuLineAttachToFocused);
	items1 = map(itemsWithFocuses, firstOfPair);

	popupWasClicked = make(false);

	// Used for closing popup, when click happens inside iframe
	addFocusInspector = \arr -> if (useFocusInspector) {
		focused = make(false);
		focusEnabled = make(true);
		itemFocuses = map(itemsWithFocuses, secondOfPair);
		isAnyFocused = fstall(fOrs(concat(itemFocuses, [focused, popupWasClicked]), false), 0);

		concat([[
			MComponent(
				[MFocused(focused), MFocusEnabled(focusEnabled)],
				\__ -> TFixed(1., 1.)
			)
			|> (\m -> MConstruct([
					\ -> {
						timer(500, \ -> {
							if (isNone(fgetValue(getCurrentFocusedItemBehaviour(manager)))) nextDistinct(focused, true)
							else nextDistinct(focusEnabled, false);
						});
						nop;
					},
					makeSubscribe2(focused, \f -> if (!f) nextDistinct(focusEnabled, false)),
					makeSubscribe2(isAnyFocused, \f -> if (!f) {
						if (!getValue(popupWasClicked)) nextDistinct(openMenu.opened, false);
					})
				], m))
			|> (\m -> MFixSize(m, TEmpty()))
		]], arr)
	} else arr;

	menuLinesState = MMenuLinesState(manager, m2t, lineHeight, elevation, nearTitle, popupId, activeDescendantId, makeTitle, singleSelectionToggle);

	items = MMenuLines2Material(items1, style0, lineBorders, closeBelow, focusedItem, menuLinesState);

	newItems =
		(if (indexShift && selectedId >= 0 && !nonspecAlwaysOnTop) {
			if (selectedId > 0 && selectedId < length(items1) - 1 &&
				items1[selectedId - 1].structname == "MMenuGroupLine" && items1[selectedId + 1].structname == "MMenuGroupLine") {
				selIt = items[selectedId + 1];

				concat(
					[selIt],
					removeIndex(removeIndex(items, 0), selectedId)
				);
			} else {
				selIt = items[selectedId + 2];

				concat(
					[selIt],
					removeIndex(removeIndex(items, 0), selectedId + 1)
				);
			}
		} else
			items
		)
		|> addLabel
		|> addFocusInspector;

	labelIdx = b2i(isSome(mLabel)) + b2i(useFocusInspector);
	itemsLen = length(newItems);

	popupStyle =
		[
			RMBorders(borders),
			RMOutterBorder(8.0),
			MElevation(const(elevation)),
			RMLeftAnimation(leftAnimation),
			openMenu,
			RMHeight(32. + borders * 2., maxHeight.height),
			MSameZorder(sameZorder),
			RMAlphaAnimation(),
			RMScaleAnimation(),
			MRippleShape("MMenu"),
			MFocusHorizontal(false),
			MActive(make(true)),
			AccessRole(popupRole),
			FAccessAttribute(
				"aria-label",
				extractStruct(style0, MButtonTitle(const(eitherMap(mLabel, \l -> l.label, "")))).title
			),
			FAccessAttribute("aria-activedescendant", activeDescendantId),
			FAccessAttribute("id", const(popupId)),
			extractStruct(style0, MFocusOnPrevious(true)),
		]
		|> (\arr -> ifArrayPush(arr, useFocusInspector, RMOnClick(\ -> {
				nextDistinct(popupWasClicked, true);
				timer(500, \ -> nextDistinct(popupWasClicked, false));
			})))
		|> (\arr : [MPopupStyle] -> maybeArrayPush(arr, tryExtractStruct(menuScrollStyle, TScrollPersistent(const(true)))))
		|> (\arr -> maybeArrayPush(arr, tryExtractStruct(menuScrollStyle, MScrollWidthHeight(makeWH(), makeWH()))))
		|> (\arr -> maybeArrayPush(arr, tryExtractStruct(menuScrollStyle, MScrollPosition(makePoint()))))
		|> (\arr -> eitherMap(fixPosition, \fp : MPopupStyle -> arrayPush(arr, fp), arr))
		|> (\f : [MPopupStyle] ->
			if (indexShift && !expandingAnimation)
				concat(f, [RMSelected(labelIdx), RMScrollArea(2 + labelIdx, itemsLen)])
			else if (isSome(singleSelection) && !expandingAnimation)
				concat(f, [RMSelected(labelIdx + selectedId / (cols + 1)), RMScrollArea(labelIdx, itemsLen)])
			else
				arrayPush(f, RMScrollArea(labelIdx, itemsLen))
		)
		|> (\f : [MPopupStyle] ->
			if (widthByButton) {
				if (mWidth > 0.)
					arrayPush(f, RMWidth(fmin(fwidth(buttonWH), const(mWidth))))
				else
					arrayPush(f, RMWidth(fwidth(buttonWH)))
			} else {
				if (mWidth > 0.) {
					arrayPush(f, RMWidth(const(mWidth)))
				} else {
					eitherMap(mWidthLimits, \limits ->
						arrayPush(f, RMWidthLimits(limits.minWidth, limits.maxWidth)),
						f
					)
				}
			}
		)
		|> (\f -> {
			offset =
				if (belowButton)
					fselect2(buttonWH, menuShift, FLift2(\b : WidthHeight, ms -> Pair(WidthHeight(ms.x + if (!leftAnimation) b.width else 0., b.height), ms.y)))
				else if ((elevation > 8.) == leftAnimation)
					fselect2(buttonWH, menuShift, FLift2(\b : WidthHeight, ms -> Pair(WidthHeight(b.width + ms.x, 0.), ms.y)))
				else
					fselect(menuShift, FLift(\ms -> Pair(WidthHeight(ms.x, 0.), ms.y)));

			arrayPush(f, RMOffset(offset))
		})
		|> (\f -> maybeArrayPush(f, customScale))
		|> (\f ->
				ifArrayPush(f,
					!expandingAnimation && elevation == 8. && getValue(either(singleSelection, MSingleSelection(make(-1))).selected) == -1 && !indexShift,
					RMTranslateAnimation()
				)
		)
		|> (\f -> ifArrayPush(f, expandingAnimation, RMExpandingAnimation()))
		|> (\f -> ifArrayPush(f, elevation == 8., RMClickOutToClose()))
		|> (\f -> ifArrayPush(f, contains(style0, MMenuNoSnapSize()), RMNoSnapSize()))
		|> (\f -> concat(f, extractStructMany(style0, MBlockClicks())))
		|> (\arr -> ifArrayPush(arr, itemsLen > 1, MFocusVertical(true)));

	MPopup(
		newItems,
		posScale,
		popupStyle
	)
}

MSubMenuStyle2MMenuStyle(style : [MSubMenuStyle]) -> [MMenuStyle] {
	filtermap(style, \st -> switch (st) {
		MMenuStyle() : {a : Maybe<MMenuStyle> = Some(st); a};
		default : None()
	})
}

MDropDownMenuButtonStyle2MMenuStyle(style : [MDropDownMenuStyle]) -> [MMenuStyle] {
	fold(style, extractStructMany(style, MEnabled(const(true))), \acc, st -> {
		switch (st) {
			MDataTableFooter(): arrayPush(acc, st);
			MDataTableRow(): arrayPush(acc, st);
			MForceUpdate(): arrayPush(acc, st);
			default : acc;
		}
	})
}

MDropDownMenuStyle2MMenuStyle(style : [MDropDownMenuStyle]) -> [MMenuStyle] {
	filtermap(style, \st -> switch (st) {
		MMenuStyle() : {a : Maybe<MMenuStyle> = Some(st); a};
		default : None()
	})
}

MDropDownIcon(opened : Transform<bool>, style : [MDropDownIconStyle]) -> Material {
	iconColorM = tryExtractStruct(style, MWhite());
	iconSize = extractStruct(style, MIconSize(20.)).size;
	borders = extractStruct(style, MIconBorder4(0., 0., 0., 0.));
	MGetFocusGroup(\parent -> TIfLazy2(
		opened,
		\op ->
			MIcon2T(
				parent,
				if (op)
					"arrow_drop_up"
				else
					"arrow_drop_down",
				arrayPushMaybe([MIconSize(iconSize)], iconColorM)
			),
		true
	))
	|> (\m -> MFixSizeKeepBaseline(m, TFixed(iconSize, iconSize)))
	|> (\m -> MBorder(borders.left, borders.top, borders.right, borders.bottom, m))
}

MDropDownClearIcon(selected : DynamicBehaviour<?>, emptySelection : ?, iconSize : double) -> Material {
	MIconButton("clear", \ -> nextDistinct(selected, emptySelection), [
			MIconSize(iconSize / 1.5),
			MIconButtonBorder(0.),
			MCircleBackground(MGrey(400), iconSize)
		], []
	)
	|> (\m -> MShow(fneq(selected, emptySelection), m))
}

getMenuAlpha(focus : MFocus, parent : MFocusGroup) -> Transform<double> {
	fif(focus.enabled, const(1.), const(defaultDisabledItemOpacity(getLightBackground(parent))))
}

getPopupId(manager : MaterialManager) {
	"menu" + i2s(makeTropicTag(manager))
}

reopenMenu(openMenu : MOpenMenu) -> void {
	if (fgetValue(openMenu.opened)) {
		next(openMenu.opened, false);
		next(openMenu.opened, true)
	}
}

MMenuLineAttachToFocused(line : MMenuLine) -> Pair<MMenuLine, DynamicBehaviour<bool>> {
	switch(line) {
		MSeparatorLine() : Pair(line, make(false));
		MMenuSingleLine(__, style) : {
			focused = extractStruct(style, MFocused(make(false)));
			Pair(MMenuSingleLine(line with style = replaceStruct(style, focused)), focused.focused);
		};
		MMenuCustomLine(__, style) : {
			focused = extractStruct(style, MFocused(make(false)));
			Pair(MMenuCustomLine(line with style = replaceStruct(style, focused)), focused.focused);
		};
		MMenuGroupLine(__, style) : {
			focused = extractStruct(style, MFocused(make(false)));
			Pair(MMenuGroupLine(line with style = replaceStruct(style, focused)), focused.focused);
		};
		MSubMenu(__, __, style) : {
			focused = extractStruct(style, MFocused(make(false)));
			Pair(MSubMenu(line with style = replaceStruct(style, focused)), focused.focused);
		};
		MSubMenuDynamic(__, __, style) : {
			focused = extractStruct(style, MFocused(make(false)));
			Pair(MSubMenuDynamic(line with style = replaceStruct(style, focused)), focused.focused);
		};
		MSubMenuCustom(__, __, style) : {
			focused = extractStruct(style, MFocused(make(false)));
			Pair(MSubMenuCustom(line with style = replaceStruct(style, focused)), focused.focused);
		};
	}
}