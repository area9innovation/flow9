import material/internal/material_icons;
import material/internal/material_component;
import material/internal/material_ellipsis;

export {
	MTextButton2T(manager : MaterialManager, parent : MFocusGroup, m : MTextButton, m2t : (Material, MFocusGroup) -> Tropic) -> Tropic;
	MTextClickable2T(manager : MaterialManager, parent : MFocusGroup, m : MTextClickable, m2t : (Material, MFocusGroup) -> Tropic) -> Tropic;
	MIconButton2T(manager : MaterialManager, parent : MFocusGroup, m : MIconButton, m2t : (Material, MFocusGroup) -> Tropic) -> Tropic;
	MIconToggle2T(manager : MaterialManager, parent : MFocusGroup, m : MIconToggle, m2t : (Material, MFocusGroup) -> Tropic) -> Tropic;

	MCheckBox2T(manager : MaterialManager, parent : MFocusGroup, m : MCheckBox, m2t : (Material, MFocusGroup) -> Tropic) -> Tropic;
	MRadio2T(manager : MaterialManager, parent : MFocusGroup, m : MRadio, m2t : (Material, MFocusGroup) -> Tropic) -> Tropic;
	MSwitchControl2T(manager : MaterialManager, parent : MFocusGroup, m : MSwitchControl, m2t : (Material, MFocusGroup) -> Tropic) -> Tropic;
	MFloatingButton2T(manager : MaterialManager, parent : MFocusGroup, m : MFloatingButton, m2t : (Material, MFocusGroup) -> Tropic) -> Tropic;
	MChip2T(manager : MaterialManager, parent : MFocusGroup, m : MChip, m2t : (Material, MFocusGroup) -> Tropic) -> Tropic;

	MRawButton2T(manager : MaterialManager, parent : MFocusGroup, m : MRawButton, m2t : (Material, MFocusGroup) -> Tropic) -> Tropic;

	style2MIconStyle(style : [?]) -> [MIconStyle];
}

MTextButton2T(manager : MaterialManager, parent : MFocusGroup, m : MTextButton, m2t : (Material, MFocusGroup) -> Tropic) -> Tropic {
	color : MColor = extractMColor(parent, m.style, MPrimaryColor());
	outlineColor = extractStruct(m.style, MOutlineColor(MCustomColor(contrastingColor(parent)))).color;
	outlineOpacity = extractStruct(m.style, MOutlineOpacity(0.12)).opacity;
	outlineWidth = extractStruct(m.style, MOutlineWidth(1.)).width;
	contained = contains(m.style, MContained());
	outlined = contains(m.style, MOutlined());
	fullWidth = contains(m.style, MFullWidth());
	iconNearTitleEnabled = extractStruct(m.style, MIconNearTitleEnabled(true)).enabled;
	buttonTextColor = extractStructMany(m.style, MButtonTextColor(false));
	progress = tryExtractStruct(m.style, MTextButtonProgress(make(false), false));
	onClick = extractStruct(m.state, MOnClick(nop)).click |> (\f -> MOnClick(\ -> {m.onClick(); f();}));	
	elevation = \focus ->
		extractStruct(m.style,
			MElevation(
				if (contained)
					fif(focus.down, const(6.), const(if (getLightBackground(parent)) 2. else 3.))
				else
					zero
			)
		).elevation;

	isRTL = parent.rtl;

	paddingsAM = tryExtractStruct(m.style, MButtonPaddingsA(16.0, 9.5, 16.0, 9.5));
	paddings = eitherFn(
		paddingsAM,
		\paddingsA -> {
			left = if (isRTL) paddingsA.end else paddingsA.start;
			right = if (isRTL) paddingsA.start else paddingsA.end;
			MButtonPaddings(left, paddingsA.top, right, paddingsA.bottom)
		},
		\-> extractStruct(m.style, MButtonPaddings(16.0, 9.5, 16.0, 9.5))
	);

	textAlignment = commonAlignment2abs(extractStruct(m.style, MTextAlignment(CenterAlign())).alignment, isRTL);
	textAlignmentX = switch (textAlignment) {
		LeftAlign() : 0.0;
		RightAlign() : 1.0;
		default : 0.5;
	};

	bgStyle =
		if (outlined)
			[
				MThemeStroke(parent, outlineColor),
				StrokeOpacity(outlineOpacity),
				StrokeWidth(outlineWidth),
				Fill(black),
				FillOpacity(0.0)
			]
		else if (contained)
			[
				MFill(color),
				FillOpacity(1.0)
			]
		else
			[];

	disabledBgStyle =
		if (outlined)
			[
				Stroke(contrastingColor(parent)),
				StrokeOpacity(0.2),
				StrokeWidth(outlineWidth),
				Fill(black),
				FillOpacity(0.0)
			]
		else
			[
				Fill(contrastingColor(parent)),
				FillOpacity(if (contained) 0.12 else 0.0)
			];

	textColor : MColor =
		if (contained) {
			getTextColorWithBackground(parent, bgStyle)
		} else {
			color
		};
	textStyle =
		extractStruct(m.style, MCustomTextStyle([MButton1(), textColor])).style
		|> (\textStyle ->
			if (isNone(tryExtractStruct(textStyle, textColor)))
				arrayPush(textStyle, textColor)
			else
				textStyle
		);

	progressState = makeButtonProgressState(manager, parent, m.style, textColor, onClick); 

	alignButtonTitle = \f -> if (fullWidth) TTweak([TAlign(const(textAlignmentX), const(0.0))], f, TFillX()) else f;

	disabled = \ ->
		MText2T(
			parent,
			m.text,
			replaceStructMany(textStyle, [contrastingMColor(parent), MTextDisabled()])
		)
		|> progressState.wrapContent(false)
		|> (if (!iconNearTitleEnabled) alignButtonTitle else idfn)
		|> (\f -> addLeftRightIcons(parent, f, m.style, textColor, true))
		|> (\f -> TBorder(paddings.left, paddings.top, paddings.right, paddings.bottom, f))
		|> (if (iconNearTitleEnabled) alignButtonTitle else idfn)
		|> (\f ->
			MShapeFrame(
				parent,
				disabledBgStyle,
				f,
				"MTextButton"
			)
		);

	focusState =
		concatStyles(
			replaceStruct(m.state, progressState.onClick),
			[
				MRippleType(const(MRippleFill())),
				MRippleColor(const(textColor)),
				MHighlightOnFocus(const(true)),
				MHighlightOnHover(const(true)),
				MRippleShape("MTextButton"),
				MButtonTitle(const(m.text)),
				MClickEnabled(progressState.clickEnabled)
			]
		);

	(\ ->
		MText2T(parent, m.text, textStyle)
		|> progressState.wrapContent(true)
		|> (if (!iconNearTitleEnabled) alignButtonTitle else idfn)
		|> (\f -> addLeftRightIcons(parent, f, m.style, textColor, false))
		|> (\f -> TBorder(paddings.left, paddings.top, paddings.right, paddings.bottom, f))
		|> (if (iconNearTitleEnabled) alignButtonTitle else idfn)
	)
	|> (\f ->
		MComponent2T(
			manager,
			parent,
			"MTextButton",
			focusState,
			\focus -> {
				el = elevation(focus);

				(\ -> f()
				|> (\f2 ->
					if (contained || outlined)
						MShapeFrame(
							parent,
							bgStyle,
							f2,
							"MTextButton"
						)
					else
						f2
				)
				|> (\f2 ->
					if (el != zero)
						TEasedShadowShape(
							manager,
							parent,
							el,
							if (contained)
								f2
							else
								MShapeFrame(parent, [MThemeFill(parent, MSurfaceColor())], f2, "MTextButton"),
							0.3,
							RectangleShape("MTextButton")
						)
					else
						f2
				))
				|> (\f2 -> TIfLazy2(focus.enabled, \b -> if (b) f2() else disabled(), !fullWidth && isNone(parent.theme.fontWrapper)))
			},
			m2t
		)
	)
	|> (if (isSome(parent.theme.fontWrapper)) idfn else if (fullWidth) makeTropicConstantHeight(None()) else makeTropicConstant(None(), None()))
}

// This type is added for the correct typechecking of variable 'paddings'.
MButtonBordersOrPaddings ::= MButtonBorders, MButtonPaddings;

MTextClickable2T(manager : MaterialManager, parent : MFocusGroup, m : MTextClickable, m2t : (Material, MFocusGroup) -> Tropic) -> Tropic {
	isRTL = parent.rtl;
	paddings : MButtonBordersOrPaddings = if (
		containsStruct(m.style, MButtonPaddingsA(8., 4., 8., 4.)) ||
		containsStruct(m.style, MButtonPaddings(8., 4., 8., 4.))
	) {
		paddingsAM = tryExtractStruct(m.style, MButtonPaddingsA(16.0, 9.5, 16.0, 9.5));
		eitherFn(
			paddingsAM,
			\paddingsA -> {
				left = if (isRTL) paddingsA.end else paddingsA.start;
				right = if (isRTL) paddingsA.start else paddingsA.end;
				MButtonPaddings(left, paddingsA.top, right, paddingsA.bottom)
			},
			\-> extractStruct(m.style, MButtonPaddings(16.0, 9.5, 16.0, 9.5))
		);
	} else {
		extractStruct(m.style, MButtonBorders(8., 4., 8., 4.))
	}
	onClick = extractStruct(m.state, MOnClick(nop)).click |> (\f -> MOnClick(\ -> {m.onClick(); f();}));
	backgroundStyle = extractStruct(m.style, MBackgroundStyle([])).style;
	raised = isSome(tryExtractStruct(backgroundStyle, Fill(black))) && extractStruct(backgroundStyle, FillOpacity(1.)).opacity > 0.;
	elevation = \focus ->
		extractStruct(m.style,
			MElevation(
				if (raised && extractStruct(backgroundStyle, FillOpacity(1.)).opacity == 1.)
					fif(focus.down, const(6.), const(if (getLightBackground(parent)) 2. else 3.))
				else
					zero
			)
		).elevation;
	fullWidth = contains(m.style, MFullWidth());

	textStyle : [MTextStyle] =
		filtermap(m.style, \st ->
			switch (st : MClickableTextStyle) {
				MTextStyle() : {a : Maybe<MTextStyle> = Some(st); a}
				default : None();
			}
		)
		|> (\arr -> ifArrayPush(arr, raised, extractStruct(m.style, MTextMColor(extractStruct(backgroundStyle, Fill(black)).color |> MCustomColor))));

	focusState =
		concat(
			replaceStructMany(
				m.state,
				[
					onClick,
					extractStruct(m.state, MRippleType(const(MRippleFill()))),
					extractStruct(m.state, MRippleShape("MTextClickable")),
					extractStruct(m.state, MHighlightOnFocus(const(true))),
					extractStruct(m.state, MHighlightOnHover(const(true)))
				]
			),
			[MButtonTitle(const(m.text))]
		);

	(\en -> MText2T(parent, m.text, if (en) textStyle else arrayPush(textStyle, MTextDisabled()))
	|> (\f -> addLeftRightIcons(parent, f, m.style, extractStruct(textStyle, MWhite()), !en))
	|> (\f -> TBorderDir(paddings.left, paddings.top, paddings.right, paddings.bottom, f, parent.rtl))
	|> (\f -> if (fullWidth) TCenterX(f) else f)
	|> (\f -> if (raised) MShapeFrame(parent, if (en) backgroundStyle else [Fill(contrastingColor(parent)), FillOpacity(0.12)], f, "MTextClickable") else f))
	|> (\f ->
		MComponent2T(
			manager,
			parent,
			"MTextClickable",
			focusState,
			\focus -> {
				el = elevation(focus);

				TIfLazy2(focus.enabled, f, !fullWidth)
				|> (\f2 ->
					if (el != zero)
						TEasedShadowShape(
							manager,
							parent,
							el,
							if (raised)
								f2
							else
								MShapeFrame(parent, [MThemeFill(parent, MSurfaceColor())], f2, "MTextClickable"),
							0.3,
							RectangleShape("MTextClickable")
						)
					else
						f2
				)
			},
			m2t
		)
	)
	|> (if (fullWidth) makeTropicConstantHeight(None()) else makeTropicConstant(None(), None()))
}

addLeftRightIcons(parent : MFocusGroup, t : Tropic, style : [flow], textColor : MColor, disabled : bool) {
	leftIcon = tryExtractStruct(style, MLeftIcon("", []));
	rightIcon = tryExtractStruct(style, MRightIcon("", []));

	eitherMap(
		leftIcon,
		\li -> addButtonIcon(parent, t, li.icon, li.style, textColor, disabled, true),
		t
	)
	|> (\f ->
		eitherMap(
			rightIcon,
			\ri -> addButtonIcon(parent, f, ri.icon, ri.style, textColor, disabled, false),
			f
		)
	)
}

addButtonIcon(parent : MFocusGroup, text : Tropic, iconStr : string, style : [MIconStyle], textColor : MColor, disabled : bool, isLeft : bool) -> Tropic {
	rtl = parent.rtl == isLeft;
	iconHeight = make(0.);
	textHeight = make(0.);
	textBaseline = make(0.);
	baseline = faddition(textBaseline, fmax(fdivide(fsubtract(iconHeight, textHeight), const(2.)), zero));
	heightBox = TSizedHeight(0., fmax(iconHeight, textHeight));

	icon = MIcon2T(parent, iconStr, arrayPush(style, if (disabled) MIconDisabled() else textColor)) |> TBorderEnd(8., rtl);

	TColsDir(
		map([
			TInspect([IHeight(iconHeight)], icon),
			TInspect([IHeight(textHeight), IBaseline(textBaseline)], text)
		], \t -> TCenterYIn(t, heightBox)),
		rtl
	)
	|> (\t -> TBaseline(baseline, t))
}

style2MIconStyle(style : [?]) -> [MIconStyle] {
	concatA([
		extractMThemeColorMany(style),
		extractStructMany(style, FillOpacity(0.)),
		extractStructMany(style, MIconSize(0.)),
		extractStructMany(style, MIconType(MIconFilled())),
		extractStructMany(style, MIconDisabled()),
		extractStructMany(style, MCircleBackground(MWhite(), 0.)),
		extractStructMany(style, MElevation(zero)),
		extractStructMany(style, MIconCounter(const(0), [])),
	])
}

MIconButton2T(manager : MaterialManager, parent : MFocusGroup, m : MIconButton, m2t : (Material, MFocusGroup) -> Tropic) -> Tropic {
	circleBackground = extractStruct(m.style, MCircleBackground(MRed(500), 0.));
	iconSize = extractStruct(m.style, MIconSize(standardIconSize)).size;
	border = max(extractStruct(m.style, MIconButtonBorder(iconSize / 2.0)).border - max(circleBackground.size - iconSize, 0.) / 2., 0.);
	borders = tryExtractStruct(m.style, MIconButtonBorders(0., 0., 0., 0.));
	onClick = extractStruct(m.state, MOnClick(nop)).click |> (\f -> MOnClick(\ -> {m.onClick(); f();}));
	disabled = contains(m.style, MIconDisabled());
	defaultIconColor =
		if (circleBackground.size > 0.)
			MContrastingTextColor(circleBackground.color)
		else
			MIconsColor();
	iconColor =
		extractMColor(parent, m.style, defaultIconColor)
		|> (\iconColor ->
			if (disabled && iconColor != MBlack() && iconColor != MWhite())
				MThemeColor2MColor(parent, defaultIconColor)
			else
				iconColor
		);

	progressState = makeButtonProgressState(manager, parent, m.style, iconColor, onClick); 

	focusState = concatStyles(
		replaceStruct(m.state, progressState.onClick),
		[
			MRippleType(const(MRippleCenter())),
			MRippleColor(const(iconColor)),
			MHighlightOnFocus(const(true)),
			MHighlightOnHover(const(true)),
			MButtonTitle(const(m.name)),
			MRippleShape("MIconButton"),
			MClickEnabled(progressState.clickEnabled)
		]
	);

	MComponent2T(
		manager,
		parent,
		"MIconButton " + m.name,
		focusState,
		\focus ->
			TIfLazy2(focus.enabled, \en ->
				MIcon2T(
					parent,
					m.name,
					style2MIconStyle(m.style)
					|> (\f -> if (!en) replaceStruct(f, MIconDisabled()) else f)
				)
				|> progressState.wrapContent(en),
				true
			)
			|> (\f -> eitherMap(borders,
				\b -> TBorder(b.left, b.top, b.right, b.bottom, f),
				TBorder4(border * 3.0 / 4.0, f)
			))
			|> MHintMarker(manager, focus, Some(iconSize / 2.)),
		m2t
	)
	|> (\f -> if (isNone(borders)) TBorder4(border / 4.0, f) else f)
	|> makeTropicConstant(None(), None())
}

MIconToggle2T(manager : MaterialManager, parent : MFocusGroup, m : MIconToggle, m2t : (Material, MFocusGroup) -> Tropic) -> Tropic {
	value = extractStruct(m.state, MToggleValue(make(false))).value;
	valueLink = tryExtractStruct(m.state, MToggleValueLink(const(false), nop1));
	onClick = extractStruct(m.state, MOnClick(nop)).click |> (\f -> MOnClick(\ -> {reverseBehaviour(value); f();}));
	rippleType = extractStruct(m.state, MRippleType(const(MRippleCenter())));
	highlightOnFocus = extractStruct(m.state, MHighlightOnFocus(const(true)));
	animated = contains(m.style, MAnimatedIcon());

	iconSize = extractStruct(m.style, MIconSize(standardIconSize)).size;
	buttonBorder = extractStruct(m.style, MIconButtonBorder(iconSize / 2.0)).border;
	circleBackground = extractStruct(m.style, MCircleBackground(MRed(500), 0.));
	border = max(buttonBorder - circleBackground.size, 0.);
	iconStyle = style2MIconStyle(m.style);
	disabled = contains(m.style, MIconDisabled());
	defaultIconColor =
		if (circleBackground.size > 0.)
			MContrastingTextColor(circleBackground.color)
		else
			MIconsColor();
	iconColor =
		extractMColor(parent, m.style, defaultIconColor)
		|> (\iconColor ->
			if (disabled && iconColor != MBlack() && iconColor != MWhite())
				MThemeColor2MColor(parent, defaultIconColor)
			else
				iconColor
		);

	falseIcon = extractStruct(m.style, MToggleFalseIcon(m.icon, []));
	falseIconSize = extractStruct(falseIcon.style, MIconSize(iconSize)).size;
	falseCircleBackground : MCircleBackground = extractStruct(falseIcon.style, circleBackground);
	falseIconStyle = replaceStructMany(falseIcon.style, [falseCircleBackground, MIconSize(falseIconSize)]);
	falseDisabled = contains(falseIconStyle, MIconDisabled());
	falseDefaultIconColor =
		if (circleBackground.size > 0.)
			MContrastingTextColor(circleBackground.color)
		else
			MIconsColor();
	falseIconColor =
		extractMColor(parent, falseIconStyle, defaultIconColor)
		|> (\falseIconColor ->
			if (falseDisabled && falseIconColor != MBlack() && falseIconColor != MWhite())
				MThemeColor2MColor(parent, falseDefaultIconColor)
			else
				falseIconColor
		);

	sameSize = iconSize == falseIconSize && circleBackground.size == falseCircleBackground.size;

	attributes : [FAccessAttribute] = extractStructMany(m.state, FAccessAttribute("", const("")));
	ariaPressed =
		findDef(attributes,
			\a -> a.name == "aria-pressed",
			FAccessAttribute("aria-pressed", fif(value, const("true"), const("false")))
		);

	focusState =
		concat(
			replaceStructMany(
				m.state,
				[
					onClick,
					rippleType,
					MRippleColor(fif(value, const(iconColor), const(falseIconColor))),
					extractStruct(m.state, MHighlightOnFocus(const(true))),
					extractStruct(m.state, MHighlightOnHover(const(true)))
				]
			),
			[
				IScriptBehaviour("value", value, ISInputValue([], "bool", true)),
				ariaPressed,
				extractStruct(m.state, MButtonTitle(const(m.icon + " " + falseIcon.icon)))
			]
		);

	checkEnabled = \en -> \st -> if (en) st else replaceStruct(st, MIconDisabled());

	MComponent2T(
		manager,
		parent,
		"MIconToggle",
		focusState,
		\focus ->
			TIfLazy2(focus.enabled, \en ->
				(if (animated)
					MAnimatedIcon2T(
						parent,
						MIcon(m.icon, iconStyle |> checkEnabled(en)),
						MIcon(falseIcon.icon, falseIconStyle |> checkEnabled(en)),
						value,
						sameSize,
						m2t
					)
				else
					TIfLazy2(value, \val ->
						if (val)
							MIcon2T(parent, m.icon, iconStyle |> checkEnabled(en))
						else
							MIcon2T(parent, falseIcon.icon, falseIconStyle |> checkEnabled(en)),
						sameSize
					)
				)
				|> (\iconToggle -> TBorder4(border * 3.0 / 4.0, iconToggle)),
				sameSize
			)
			|> MHintMarker(manager, focus, Some(iconSize / 2.)),
		m2t
	)
	|> (\iconToggle -> TBorder4(border / 4.0, iconToggle))
	|> (\iconToggle ->
		eitherMap(
			valueLink,
			\vl -> {
				TConstruct(
					[
						\ -> fBidirectionalLink(
							vl.value,
							value,
							\v -> nextDistinct(value, v),
							vl.onChange
						)
					],
					iconToggle
				)
			},
			iconToggle
		)
	)
	|> if (sameSize) makeTropicConstant(None(), None()) else idfn
}

MCheckBox2T(manager : MaterialManager, parent : MFocusGroup, m : MCheckBox, m2t : (Material, MFocusGroup) -> Tropic) -> Tropic {
	MCheckable2T(manager, parent, "MCheckBox", m.value, m.caption, m.style, "check_box", "check_box_outline_blank", false, "checkbox", m2t)
}

MRadio2T(manager : MaterialManager, parent : MFocusGroup, m : MRadio, m2t : (Material, MFocusGroup) -> Tropic) -> Tropic {
	checked = extractStruct(m.style, MSelected(make(getValue(m.activeValue) == m.thisValue))).selected;
	TConstruct(
		[
			\ -> fBidirectionalLink(m.activeValue, checked, \v -> nextDistinct(checked, v == m.thisValue), \ch -> if (ch) nextDistinct(m.activeValue, m.thisValue))
		],
		MCheckable2T(manager, parent, "MRadio", checked, m.caption, m.style, "radio_button_checked", "radio_button_unchecked", true, "radio", m2t)
	)
}

MCheckable2T(manager : MaterialManager, parent : MFocusGroup, name : string, value : DynamicBehaviour<bool>, captionM : Material, style : [MCheckableStyle],
	iNameChecked : string, iNameUnchecked : string, cannotUncheck : bool, accessRole : string, m2t : (Material, MFocusGroup) -> Tropic) -> Tropic {
	mcolor : MColor = extractMColor(parent, style, MAccentColor());
	iconStyle = MCheckableStyle2IconStyle(style);
	iconSize = extractStruct(style, MIconSize(standardIconSize)).size;
	iconButtonBorder = extractStruct(style, MIconButtonBorder(iconSize / 2.)).border;
	border4 = extractStruct(style, MIconBorder4(iconButtonBorder, iconButtonBorder, iconButtonBorder, iconButtonBorder));
	uncheckedIconStyle = extractStruct(style, MUncheckedIconStyle(replaceMThemeColor(iconStyle, MIconsColor()))).style;
	captionPosition = extractStruct(style, MCaptionPosition(MAfterPosition()));
	confirmFn = extractStruct(style, MCheckableConfirm(\__ -> true)).fn;
	onClick =
		extractStruct(style, MOnClick(nop)).click
		|> (\f -> MOnClick(\ -> {
			newValue = cannotUncheck || !getValue(value);
			if (newValue != getValue(value) && confirmFn(newValue)) next(value, newValue);
			f();
		}));
	onNewValue =
		eitherMap(
			tryExtractStruct(style, MOnNewValue(nop1)),
			\onv -> Some(Pair(onv.fn, true)),
			maybeMap(tryExtractStruct(style, MOnNewValue2(nop1)), \onv -> Pair(onv.fn, false))
		);
	mWidth = extractStruct(style, MWidth(-1.)).width;
	clickEnabled = extractStruct(style, MClickEnabled(const(true)));
	enabled = extractStruct(style, MEnabled(const(true))).enabled;
	captionClickable = !contains(style, MCaptionNonClickable());
	checkableTitle = make(name); 

	defFn = \en -> MComponentGroup2T(manager, parent, name + "Caption", [MEnabled(en)], \p2 -> m2t(captionM, p2));
	caption = \en ->
		switch (captionM) {
			MText(text, tStyle): {
				nextDistinct(checkableTitle, text);
				MIfLazy2T(
					manager,
					parent,
					en,
					\e, p2 ->
						if (e)
							m2t(captionM, p2)
						else
							MText2T(p2, text, arrayPush(tStyle, MTextDisabled())),
					true
				)
			}
			MIcon(icon, icStyle): {
				MIfLazy2T(
					manager,
					parent,
					en,
					\e, p2 ->
						if (e)
							m2t(captionM, p2)
						else
							MIcon2T(p2, icon, arrayPush(icStyle, MIconDisabled())),
					true
				)
			}
			MEllipsisText(text, __): {
				nextDistinct(checkableTitle, text);
				defFn(en);
			}
			MDynamicParagraph(text, pStyle): {
				TConstruct(
					[makeSubscribe(text, \t -> nextDistinct(checkableTitle, t))],
					MSelect2T(
						manager,
						parent,
						"MDynamicParagraph",
						[],
						en,
						\e, p2 ->
							if (e)
								m2t(captionM, p2)
							else
								MDynamicParagraph2T(p2, text, arrayPush(pStyle, MTextDisabled()))
					)
				)
			}
			default: defFn(en);
		}

	pressed = make(false);

	focusState =
		concat(
			concatStyles(
				replaceStruct(style, onClick),
				[
					MRippleColor(fif(value, const(mcolor), const(MBlack()))),
					MRippleType(const(MRippleCenter())),
					MHighlightOnFocus(const(true)),
					MHighlightOnHover(const(true)),
					TPressed(pressed),
					MRippleOverlay(false),
					AccessRole(accessRole),
					MAddFocusGroup(true)
				]
			),
			[
				IScriptBehaviour("value", value, ISInputValue([], "bool", true)),
				FAccessAttribute("aria-checked", fif(value, const("true"), const("false"))),
				extractStruct(style, MButtonTitle(checkableTitle))
			]
		);

	MComponent2T(
		manager,
		parent,
		name,
		focusState,
		\focus ->
			TIfLazy2(focus.enabled, \en ->
				TIfLazy2(value, \val ->
					if (val)
						MIcon2T(parent, iNameChecked, if (en) replaceStruct(iconStyle, mcolor) else arrayPush(iconStyle, MIconDisabled()))
					else
						MIcon2T(parent, iNameUnchecked, if (en) uncheckedIconStyle else arrayPush(uncheckedIconStyle, MIconDisabled())),
					true
				),
				true
			)
			|> (\t -> TAccess([FAccessHidden()], t))
			|> (\f -> TBorder(border4.left * 3.0 / 4.0, border4.top * 3.0 / 4.0, border4.right * 3.0 / 4.0, border4.bottom * 3.0 / 4.0, f)),
		m2t
	)
	|> (\f -> TBorder(border4.left / 4.0, border4.top / 4.0, border4.right / 4.0, border4.bottom / 4.0, f))
	|> (\f -> {
		cap =
			if (captionClickable)
				MComponent2T(
					manager,
					parent,
					name + "Caption",
					[onClick, clickEnabled, MEnabled(enabled), MFocusEnabled(const(false)), FAccessHidden()],
					\foc ->
						TConstruct([\ -> fconnect(foc.down, pressed)], caption(foc.enabled)),
					m2t
				)
			else
				caption(fmin(enabled, parent.enabled));

		switch (captionPosition.pos) {
			MBeforePosition() : TBaselineCols2Dir(cap, f, parent.rtl);
			MAfterPosition() : TBaselineCols2Dir(f, cap, parent.rtl);
			MRightPosition() : TBaselineCols2(f, cap);
			MLeftPosition() : TBaselineCols2(cap, f);
			MTopPosition() : TLinesXCenter([cap, f]);
			MBottomPosition() : TLinesXCenter([f, cap]);
			MBeforeCenteredPosition() : TColsYCenterA([cap, f]);
			MAfterCenteredPosition() : TColsYCenterA([f, cap]);
		}
	})
	|> (\checkable ->
		eitherMap(
			onNewValue,
			\onv ->
				TConstruct(
					if (onv.second) [makeSubscribe(value, onv.first)]
					else [makeSubscribe2(value, onv.first)],
					checkable
				),
			checkable
		)
	)
	|> (\checkable -> MAddLabelAndLeftIcon(manager, parent, checkable, style, const(false), 0.))
	|> (\checkable -> if (mWidth >= 0.) TAvailableWidth(checkable, const(mWidth)) else checkable)
}

MCheckableStyle2IconStyle(style : [MCheckableStyle]) -> [MIconStyle] {
	filtermap(style, \st ->
		switch (st) {
			MIconStyle() : {a : Maybe<MIconStyle> = Some(st); a}
			default : None()
		}
	)
}

MSwitchControl2T(manager : MaterialManager, parent : MFocusGroup, m : MSwitchControl, m2t : (Material, MFocusGroup) -> Tropic) -> Tropic {
	color : MColor = extractMColor(parent, m.style, MAccentColor());
	onOffText = tryExtractStruct(m.style, MOnOffText("", ""));
	thumbPosition = makePoint();
	onClick =
		extractStruct(m.style, MOnClick(nop)).click
		|> (\f -> MOnClick(\ -> {reverseBehaviour(m.value); f();}));
	enabled = extractStruct(m.style, MEnabled(const(true))).enabled;
	isRTL = parent.rtl;

	focusState =
		concat(
			concatStyles(
				replaceStruct(m.style, onClick),
				[
					MRippleType(const(MRippleCenter())),
					MRippleColor(fif(m.value, const(color), const(MGrey(500)))),
					MRipplePosition(const(Point(24., 24.))),
					MRippleShape("MSwitchControl"),
					MRippleOverlay(false),
					MHighlightOnFocus(const(true)),
					MHighlightOnHover(const(true)),
				]
			),
			[
				AccessRole("switch"),
				IScriptBehaviour("value", m.value, ISInputValue(eitherMap(onOffText, \txt -> [txt.off, txt.on], ["False", "True"]), "bool", true)),
				FAccessAttribute("aria-checked", fif(m.value, const("true"), const("false"))),
				extractStruct(m.style, MButtonTitle(const(eitherMap(onOffText, \txt -> txt.off + " " + txt.on, "Switch Control"))))
			]
		);
	TGroup2WithoutMetrics( // Track
		TIfLazy2(
			m.value,
			\v ->
				TIfLazy2(
					fmin(parent.enabled, enabled),
					\en ->
						TFrame(
							0.,
							7.,
							[
								MFill(if (en && v) color else contrastingMColor(parent)),
								FillOpacity(
									if (en) {
										if (v) 0.5 else 0.45
									} else {
										if (getLightBackground(parent)) 0.12 else 0.1
									}
								)
							],
							TFixed(32., 14.)
						),
					true
				),
			true
		)
		|> (\f -> TTranslate(const(Point(17., 17.)), f)),
		MComponent2T(
			manager,
			parent,
			"MSwitchControl",
			focusState,
			\focus ->
				TIfLazy2( // Thumb
					m.value,
					\v ->
						TIfLazy2(
							focus.enabled,
							\en ->
								MShape(
									parent,
									[
										MFill(
											if (en && v)
												color
											else
												MGrey(if (getLightBackground(parent) && en) 50 else if (!en && !getLightBackground(parent)) 800 else 400)
										)
									],
									TFixed(20., 20.),
									"MSwitchControl"
								),
							true
						),
					true
				)
				|> (\t -> TShadowShape(parent, const(3.), t, RectangleShape("MSwitchControl")))
				|> (\t -> TBorder4(11., t)),
			m2t
		)
		|> (\t -> TBorder4(3., t))
		|> (\f -> TTranslate(thumbPosition, f))
	)
	|> makeTropicConstant(64. |> Some, 48. |> Some)
	|> (\f -> TBaseline(const(29.), f))
	|> (\f ->
		eitherMap(
			onOffText,
			\text -> {
				onOffTextFontM = tryExtractStruct(m.style, MOnOffTextFont(MSecondaryButtonStyle()));
				TGroup2(
					TIfLazy2(
						fmin(parent.enabled, enabled),
						\en -> MText2T(
							parent, text.on,
							[eitherMap(onOffTextFontM, \s -> s.font, MButton1()), if (en) color else MTextDisabled()]
						),
						true
					)
					|> (\t -> TVisible(feq(m.value, true), t)),

					TIfLazy2(
						fmin(parent.enabled, enabled),
						\en -> MText2T(
							parent, if (text.off != "") text.off else text.on,
							[eitherMap(onOffTextFontM, \s -> s.font, MSecondaryButtonStyle()), if (en) MTextColor() else MTextDisabled()]
						),
						true
					)
					|> (\t -> TVisible(feq(m.value, false), t))
				)
				|> (\t -> TBorderDir(0., 0., 24., 0., t, isRTL))
				|> (\t -> TBaselineCols2Dir(f, t, isRTL))
			},
			f
		)
	)
	|> (\f ->
		MEasingAnimation(
			manager,
			parent,
			const(easingTransitionDuration),
			const(easingStandartCurve),
			m.value,
			\v ->
				Some(v),
			\v, p ->
				nextDistinct(thumbPosition, Point(lerp(0., 18., if (v != isRTL) p else 1. - p), 0.)),
			[],
			f
		)
	)
	|> (\f -> MAddLabelAndLeftIcon(manager, parent, f, m.style, const(false), 0.))
	|> (\f ->
		TConstruct(
			[
				\ -> {
					nextDistinct(
						thumbPosition,
						Point(if (getValue(m.value) != isRTL) 18. else 0., 0.)
					);
					nop
				}
			],
			f
		)
	)
	|> makeTropicConstant(None(), None())
}

MFloatingButton2T(manager : MaterialManager, parent : MFocusGroup, m : MFloatingButton, m2t : (Material, MFocusGroup) -> Tropic) -> Tropic {
	speedDial = tryExtractStruct(m.style, MFabSpeedDial("", [], []));
	bgColor = extractMColor(parent, m.style, MAccentColor());
	iconColor = MThemeColor2MColor(parent, extractStruct(m.style, MIconColor(MWhite())).color);
	iconOpacity = extractStruct(m.style, FillOpacity(1.));
	buttonSize = extractStruct(m.style, MFabSize(if (extractStruct(m.style, MFabMini(false)).mini) 40. else 56.)).size;
	elevation = \down -> extractStruct(m.style, MElevation(fif(down, const(12.), const(6.)))).elevation;
	scrollPoint = extractStruct(m.style, makeTScrollInspectVisible()).topleft;
	centeredShape = contains(m.style, MFloatingButtonCenteredShape());

	showActionButtons = make(false);
	enabled = extractStruct(m.state, MEnabled(const(true))).enabled;
	onClick =
		extractStruct(m.state, MOnClick(nop)).click
		|> (\click ->
			eitherFn(
				speedDial,
				\sd -> \ -> {
					sab = getValue(showActionButtons);
					if (sab) click();

					next(showActionButtons, !sab);
				},
				\ -> click
			)
		);

	buttonScale = make(if (fgetValue(enabled)) Factor(1., 1.) else Factor(0., 0.));
	iconRotate = make(if (fgetValue(enabled)) 0. else -30.);
	buttonBorders = if (mobile) 16. else 24.;
	height = buttonSize + buttonBorders + 56.;
	scrollUp = make(true);
	point = make(Point(0.0, if (fgetValue(scrollUp)) 0. else height));
	scrollShift = ref 0.;

	focusState =
		replaceStructMany(
			m.state,
			[
				MEnabled(fand(scrollUp, enabled)),
				MOnClick(onClick),
				MHighlightOnFocus(const(true)),
				MRippleType(const(MRippleCenter())),
				MRippleColor(const(iconColor)),
				MButtonTitle(const(m.icon))
			]
		);

	eitherFn(
		speedDial,
		\sd -> {
			openIcon = extractStruct(sd.style, MOpenIcon("close")).icon;

			TIfLazy2(
				showActionButtons,
				\s ->
					MIcon2T(parent, if (s) openIcon else m.icon, [iconColor, iconOpacity]),
				true
			)
		},
		\ -> MIcon2T(parent, m.icon, [iconColor, iconOpacity])
	)
	|> (\f -> TRotate(iconRotate, f))
	|> (\f -> TCenterIn(f, TFixed(buttonSize, buttonSize)))
	|> (\f ->
		TGroup2(
			MShape(
				parent,
				[MFill(bgColor)],
				TFixed(buttonSize, buttonSize),
				"MFloatingButton"
			),
			f
		)
	)
	|> (\f ->
		MComponent2T(
			manager,
			parent,
			"MFloatingButton",
			focusState,
			\focus ->
				TEasedShadowShape(manager, parent, elevation(focus.down), f, 0.3,
					if (centeredShape) RectangleCenteredShape("MFloatingButton") else RectangleShape("MFloatingButton")
				)
				|> (\f2 ->
					eitherFn(
						speedDial,
						\sd -> {
							hover2 = make(false);

							TGroup2SameMetrics(
								f2,
								TShowLazy(showActionButtons, \ -> MFabSpeedDial2T(manager, parent, sd, buttonSize, showActionButtons, hover2, m2t))
							)
							|> (\f3 ->
								TConstruct(
									if (!mobile)
										[\ -> fconnect(fOr(focus.hover, hover2), showActionButtons)]
									else
										[],
									f3
								)
							)
						},
						\ -> f2
					)
				),
			m2t
		)
	)
	|> (\f ->
		MEasingAnimation(
			manager,
			parent,
			const(easingTransitionDuration),
			const(easingStandartCurve),
			enabled,
			\s -> {
				next(showActionButtons, false);
				Some(s)
			},
			\s, d0 -> {
				d = if (s) d0 else 1. - d0;

				next(iconRotate, lerp(-30., 0., d));
				next(buttonScale, Factor(d, d));
			},
			[],
			TScale(buttonScale, f)
		)
	)
	|> (\f -> TCenterIn(f, TFixed(buttonSize, buttonSize)))
	|> (\f -> TBorder4(buttonBorders, f))
	|> makeTropicConstant(None(), None())
	|> (\f ->
		if (contains(m.style, MFabHalfUp()))
			TTranslate(const(Point(0., -buttonSize / 2. - buttonBorders)), f)
		else
			f
	)
	|> (\f -> if (commonAlignment2abs(extractMFloatingButtonCommonAlignment(m.style), parent.rtl) == RightAlign()) TCols2(TFillX(), f) else f)
	|> (\f ->
		if (contains(m.style, MTop()) || contains(m.style, MBottom()))
			TTweak([TAlign(zero, const(b2d(contains(m.style, MBottom()))))], f, TFillY())
		else
			f
	)
	|> (\f -> TTranslate(point, f))
	|> (\f ->
		MEasingAnimation(
			manager,
			parent,
			fif(scrollUp, const(easingEnteringDuration), const(easingLeavingDuration)),
			fif(scrollUp, const(easingDecelerationCurve), const(easingAccelerationCurve)),
			scrollUp,
			\s ->
				Some(s),
			\s, py ->
				next(point, Point(0., lerp(0., height, if (s) 1. - py else py))),
			[],
			f
		)
	)
	|> (\f ->
		TConstruct([
				makeSubscribe2(scrollPoint, \sp -> {
					su = getValue(scrollUp);

					if (sp.y < ^scrollShift - 160. && !su) {
						scrollShift := sp.y;
						nextDistinct(scrollUp, true);
					} else if (sp.y > ^scrollShift + 160. && su) {
						scrollShift := sp.y;
						nextDistinct(scrollUp, false);
					} else if (sp.y < ^scrollShift && su || sp.y > ^scrollShift && !su) {
						scrollShift := sp.y;
					}
				}),
			],
			f
		)
	)
}

MFabSpeedDial2T(manager : MaterialManager, parent : MFocusGroup, m : MFabSpeedDial, mainSize : double, showActionButtons : DynamicBehaviour<bool>,
	hover : DynamicBehaviour<bool>, m2t : (Material, MFocusGroup) -> Tropic) -> Tropic {
	size = extractStruct(m.style, MIconSize(42.)).size;
	textStyle =
		extractStruct(m.style,
			MFabLabelsTextStyle([
				if (mobile)
					contrastingMColor(parent)
				else
					sameLightMColor(parent)
			])
		).textStyle;
	textBgStyle = [MFill(extractStruct(m.style, MDialogMColor(mobile == getLightBackground(parent))))];
	buttonBorder = (mainSize - size) / 2.;
	mainLabelSize = getTWordMetrics(MText2T(parent, m.label, textStyle), makeTree()).width + 8.;
	textSize = either(maxA(map(m.actions, \a -> getTWordMetrics(MText2T(parent, a.label, textStyle), makeTree()).width)), 142.) + 8.;
	actionsLength = length(m.actions);
	isOpenDown = extractStruct(m.style, MOpenDialDirection(false)).down;

	map(m.actions, \a -> {
		onClick = \ -> {a.onClick(); reverseBehaviour(showActionButtons)};

		TCols([
			TFillX(),
			if (a.label != "")
				TCenterY(
					TFrame(4., 2., textBgStyle, MText2T(parent, a.label, textStyle))
					|> (\f -> TShadowShape(parent, const(4.), f, RectangleShape("MFloatingButton")))
				)
			else
				TFixed(8., 0.),
			switch (a) {
				MFabIconButton(icon, __, __, iconStyle): {
					bgColor = extractMColor(parent, iconStyle, MAccentColor());
					iconColor = extractStruct(iconStyle, MIconColor(MTextMColor(bgColor))).color;

					MIconButton2T(
						manager,
						parent,
						MIconButton(
							icon,
							onClick,
							eitherFn(
								tryExtractStruct(iconStyle, FillOpacity(1.)),
								\fo -> [fo, iconColor, MIconButtonBorder((size - 24.) / 2.)],
								\ -> [iconColor, MIconButtonBorder((size - 24.) / 2.)]
							),
							[]
						),
						m2t
					)
					|> (\f ->
						TGroup2(
							MShape(
								parent,
								[MFill(bgColor)],
								TFixed(size, size),
								"MIconButton"
							),
							f
						)
					)
				}
				MFabAvatar(imageurl, __, __): {
					MAvatar2T(parent, imageurl, [MIconSize(size)])
					|> (\f ->
						TGroup2(
							MShape(
								parent,
								[MFill(MDialogMColor(getLightBackground(parent)))],
								TFixed(size, size),
								"MAvatar"
							),
							f
						)
					)
					|> (\f ->
						MComponent2T(
							manager,
							parent,
							"MFabAvatar",
							[MOnClick(onClick), MRippleType(const(MRippleCenter()))],
							\__ -> f,
							m2t
						)
					)
				}
				MFabLetterIcon(text, __, __, letterTextStyle, bgColor): {
					MLetterIcon2T(manager, parent, MLetterIcon(text, [MIconSize(size), bgColor, FillOpacity(1.)], letterTextStyle))
					|> (\f ->
						MComponent2T(
							manager,
							parent,
							"MFabLetterIcon",
							[MOnClick(onClick), MRippleType(const(MRippleCenter()))],
							\__ -> f,
							m2t
						)
					)
				}
			}
			|> (\f -> TShadowShape(parent, const(4.), f, RectangleShape(substring(a.structname, 0, 1) + substring(a.structname, 4, strlen(a.structname)))))
			|> (\f -> TBorder(buttonBorder + 16. , buttonBorder, buttonBorder, buttonBorder, f))
		])
	})
	|> (\f -> if (isOpenDown) reverseA(f) else f)
	|> (\f -> TAvailable(TLines(f), TFixed(max(textSize, mainLabelSize + 16.0) + mainSize, mainSize * i2d(actionsLength))))
	|> (\f -> [
		f,
		TTweak(
			[TAlign(const(1.), const(0.5))],
			if (m.label == "") TEmpty()
			else TFrame(4., 2., textBgStyle, MText2T(parent, m.label, textStyle))
				|> (\f2 -> TShadowShape(parent, const(4.), f2, RectangleShape("MFloatingButton"))),
			TFixed(max(textSize, mainLabelSize), mainSize + 16.),
		)
	])
	|> (\f -> TLines(if (isOpenDown) reverseA(f) else f))
	|> (\f -> if (!mobile) TCopySize(f, \tr -> TInteractive([TMouseInside(hover, false)], tr), true) else f)
	|> (\f ->
		TTranslate(const(Point(
			-max(textSize, mainLabelSize) - 16.,
			-(if (isOpenDown) 8. else (mainSize * i2d(actionsLength) + 8.))
		)), f)
	)
}

MChip2T(manager : MaterialManager, parent : MFocusGroup, m : MChip, m2t : (Material, MFocusGroup) -> Tropic) -> Tropic {
	if (contains(m.style, MNewChip()))
		MNewChip2T(manager, parent, m, m2t)
	else {

	title = m.title;
	style = m.style;

	chipContentHeight = 16.;
	visible =  extractStruct(style, MChipVisible(make(true))).visible;
	enabled = extractStruct(style, MEnabled(const(true))).enabled;
	selectable = extractStruct(style, MChipSelectable(const(false), make(false)));
	chipHoverActive = extractStruct(style, MChipHoverActive(const(-1), const(false)));
	extHover = fneq(chipHoverActive.hover, -1);
	active = chipHoverActive.active;
	onClose = tryExtractStruct(style, MOnClose(\ -> true));
	onClick0 = extractStruct(style, MOnClick(nop)).click;
	onClick = \ -> {
		onClick0();
		if (fgetValue(selectable.enabled)) reverseBehaviour(selectable.selected)
	};
	width = tryExtractStruct(style, MWidth(-1.));
	textStyle0 = tryExtractStruct(style, MCustomTextStyle([]));
	textStyle = eitherMap(textStyle0, \ts -> ts.style, [MDataRow()]);
	color = extractMColor(parent, style, MPrimaryColor());
	shadeColor = MColor(color.color, min(900, color.shade + 200), color.accent);
	chipCorners = tryExtractStruct(style, MChipCorners(RoundedCorner(0.), RoundedCorner(0.), RoundedCorner(0.), RoundedCorner(0.)));
	icon : Material =
		extractStructMany(style, MAvatar("", []))
		|> (\f ->
			if (length(f) > 0)
				f[0]
			else
				extractStructMany(style, MLetterIcon("", [], []))
				|> (\f2 ->
					if (length(f2) > 0)
						f2[0]
					else
						extractStructMany(style, MIcon("", []))
						|> (\f3 -> if (length(f3) > 0) f3[0] else TEmpty())
				)
		);
	focusEnabled = make(true);
	focusHover = make(false);
	focusDown = make(false);
	focusFocused = make(false);

	focusState = concatA([
		[MEnabled(enabled), MOnClick(onClick), MRippleType(const(MNoRipple())), MButtonTitle(const(m.title)), MAdditionalRollOutCheck()],
		extractStructMany(style, MTooltipText(const(""))),
		extractStructMany(style, MTooltipAlignment(MBottom())),
	]);

	(\p -> (\hov, sel -> {
		col : MColor = if (sel) {if (hov) MTextMColor(shadeColor) else MTextMColor(color) } else if (hov) MWhite() else MBlack();
		op : double = if (col == MWhite()) 1. else 0.32;
		isRTL = p.rtl;

		eitherMap(
			width,
			\w -> MEllipsisText2T(manager, p, MEllipsisText(title, arrayPush(textStyle, col)), m2t),
			MText2T(p, title, arrayPush(textStyle, col))
		)
		|> (\f -> eitherMap(textStyle0, \__ -> f, TCenterYIn(f, TFixed(0., chipContentHeight))))
		|> (\f ->
			if (icon != TEmpty()) {
				TCols2Dir(
					switch (icon) {
						MLetterIcon(text, iconStyle, txtStyle): {
							MLetterIcon2T(
								manager,
								p,
								MLetterIcon(
									text,
									replaceStruct(iconStyle, MIconSize(32.))
									|> (\f2 ->
										if (hov) {
											extractMColor(p, iconStyle, MPrimaryColor())
											|> (\f3 -> replaceStruct(f2, MColor(f3.color, min(900, f3.shade + 200), f3.accent)))
										} else f2),
									txtStyle
								)
							)
						}
						MAvatar(url, avatarStyle): {
							MAvatar2T(p, url, replaceStruct(avatarStyle, MIconSize(32.)))
						}
						MIcon(name, iconStyle): {
							st = eitherMap(textStyle0, \__ -> iconStyle, replaceStruct(iconStyle, MIconSize(20.)));
							TBorder(12.0, 6.0, 4.0, 6.0, MIcon2T(p, name, st))
						}
						default: TEmpty();
					}
					|> (\f2 -> TBorderDir(-13., -8., 8., -8., f2, isRTL)),
					f,
					isRTL)
			} else
				f)
		|> TBorderLeftRight(4.)
		|> (\f ->
			if (contains(style, MCloseButton()) || isSome(onClose)) {
				onClickClose = \ -> eitherFn(onClose, \oc -> if (oc.close()) next(visible, false), \ -> next(visible, false));
				defaultCloseIconStyle = [MIconSize(20.), FillOpacity(op), col, MIconButtonBorder(0.)];
				closeIconStyle = eitherMap(
					tryExtractStruct(style, MCustomCloseButtonIconStyle(\__, __ -> [])),
					\customStyle : MCustomCloseButtonIconStyle -> replaceStructMany(defaultCloseIconStyle, customStyle.styleFn(hov, sel)),
					defaultCloseIconStyle
				);

				MIconButton2T(
					manager,
					p,
					MIconButton(
						extractStruct(style, MCustomCloseButtonIcon("cancel")).icon,
						onClickClose,
						closeIconStyle,
						[MEnabled(enabled), MRippleType(const(MNoRipple())), MFocusEnabled(const(false)), MDisableHover(),
							MCursorShape(const(DefaultCursor())), AccessRole("")]
					),
					m2t
				)
				|> (\f2 -> TBorderDir(4., -2., 0., -2., f2, isRTL))
				|> (\f2 -> TCols2Dir(f, f2, isRTL))
			} else {
				f
			}
		)
	})
	|> (\f ->
		TCopySize(
			TIfLazy2(fOr(focusEnabled, active), \en ->
				if (en)
					(\hov ->
						TIfLazy2(
							fOr(fand(selectable.enabled, selectable.selected), active),
							\sel -> {
								col =
									if (sel) {
										if (hov) shadeColor else color
									} else
										MThemeColor2MColor(p, extractStruct(style, MUnselectedColor(MGrey(if (hov) 600 else 300))).color);
								MShapeFrame(
									p,
									[MFill(col)],
									TBorder4(8., f(hov, sel)),
									"MChip"
								)
							},
							true
						)
					)
					|> (\f2 -> TIfLazy2(fmaxA([focusHover, focusDown, focusFocused, extHover], true), f2, true))
				else
					TAlpha(
						const(0.63),
						MShapeFrame(
							p,
							[MThemeFill(p, extractStruct(style, MUnselectedColor(MGrey(300))).color)],
							TBorder4(8., f(false, false)),
							"MChip"
						)
					),
				true
			),
			\tr ->
				MComponent2T(
					manager,
					p,
					"MChip",
					focusState,
					\focus ->
						TConstruct(
							[
								\ -> fconnect(focus.enabled, focusEnabled),
								\ -> fconnect(focus.hover, focusHover),
								\ -> fconnect(focus.down, focusDown),
								\ -> fconnect(focus.focused, focusFocused)
							],
							tr
						),
					m2t
				),
			false
		)
	)
	|> (\t -> eitherMap(width, \w -> TAvailableWidth(t, const(w.width)), t))
	|> (\f -> TBorder4(4., f))
	)
	|> (\f ->
		MComponentGroup2T(
			manager,
			parent,
			"MChipContainer",
			concat(
				[
					IScriptBehaviour("visible", visible, ISAppearanceEvent()),
					IScriptBehaviour("selected", selectable.selected, ISSelectionEvent())
				],
				eitherMap(chipCorners, \cc -> [MUpdateShapeCorners("chip", MaterialShape(cc.leftTop, cc.rightTop, cc.rightBottom, cc.leftBottom))], [])
			),
			\par -> MIfLazy2T(manager, par, visible, \v, p -> if (v) makeTropicConstant(None(), None())(f(p)) else TEmpty(), false)
		)
	)}
}

MNewChip2T(manager : MaterialManager, parent : MFocusGroup, m : MChip, m2t : (Material, MFocusGroup) -> Tropic) -> Tropic {
	title = m.title;
	style = m.style;

	chipContentHeight = 16.;
	visible =  extractStruct(style, MChipVisible(make(true))).visible;
	enabled = extractStruct(style, MEnabled(const(true))).enabled;
	selectable = extractStruct(style, MChipSelectable(const(false), make(false)));
	chipHoverActive = extractStruct(style, MChipHoverActive(const(-1), const(false)));
	extHover = fneq(chipHoverActive.hover, -1);
	active = chipHoverActive.active;
	onClose = tryExtractStruct(style, MOnClose(\ -> true));
	onClick0 = extractStruct(style, MOnClick(nop)).click;
	onClick = \ -> {
		onClick0();
		if (fgetValue(selectable.enabled)) reverseBehaviour(selectable.selected)
	};
	width = tryExtractStruct(style, MWidth(-1.));
	textStyle0 = tryExtractStruct(style, MCustomTextStyle([]));
	textStyle = eitherMap(textStyle0, \ts -> ts.style, [MDataRow()]);
	mousePosition = makePoint();
	outlined = contains(style, MOutlined());
	outlineColor = tryExtractStruct(style, MOutlineColor(MBlack()));
	outlineOpacity = extractStruct(style, MOutlineOpacity(1.)).opacity;
	strokeWidth = extractStruct(style, MOutlineWidth(1.)).width;
	chipCorners = tryExtractStruct(style, MChipCorners(RoundedCorner(0.), RoundedCorner(0.), RoundedCorner(0.), RoundedCorner(0.)));
	chipBorder = extractStruct(style, MChipBorder(8.)).border;

	selectedColor = extractMColor(parent, style, MPrimaryColor());
	colorOpacityDef = extractStruct(style, FillOpacity(1.)).opacity;
	unselectedColor = MThemeColor2MColor(parent, extractStruct(style, MUnselectedColor(if (outlined) MWhite() else MGrey(300))).color);

	growth = make(1.);
	fade = make(1.);
	isInside = make(false);

	icon : Maybe<Material> =
		eitherMap(
			tryExtractStruct(style, MAvatar("", [])),
			\v -> Some(v),
			eitherMap(
				tryExtractStruct(style, MLetterIcon("", [], [])),
				\v -> Some(v),
				tryExtractStruct(style, MIcon("", []))
			)
		);

	focusState = concatA([
		[
			MEnabled(enabled),
			MOnClick(onClick),
			MMousePosition(mousePosition),
			MButtonTitle(const(m.title)),
			MAdditionalRollOutCheck(),
			MPassClicks(),
			MOnMouseUp(\__, ins -> nextDistinct(isInside, ins))
		],
		extractStructMany(style, MTooltipText(const(""))),
		extractStructMany(style, MTooltipAlignment(MBottom())),
	]);

	(\p -> (\textColor, isEnabled, selected, hovered -> {
		isRTL = p.rtl;

		titleStyle : Transform<[MTextStyle]> =
			fselect2(textColor, isEnabled, FLift2(\col, en ->
				ifArrayPush(arrayPush(textStyle, col), !en, MTextDisabled())
			));

		TSelect(titleStyle, \st : [MTextStyle] ->
			eitherMap(
				width,
				\w -> MEllipsisText2T(manager, p, MEllipsisText(title, st), m2t),
				MText2T(p, title, st)
			)
		)
		|> (\f -> eitherMap(textStyle0, \__ -> f, TCenterYIn(f, TFixed(0., chipContentHeight))))
		|> (\f -> eitherMap(icon, \ic -> {
				TCols2Dir(
					switch (ic) {
						MLetterIcon(text, iconStyle, txtStyle): {
							MLetterIcon2T(
								manager,
								p,
								MLetterIcon(
									text,
									replaceStruct(iconStyle, MIconSize(32.)),
									txtStyle
								)
							)
						}
						MAvatar(url, avatarStyle): {
							MAvatar2T(p, url, replaceStruct(avatarStyle, MIconSize(32.)))
						}
						MIcon(name, iconStyle): {
							st = eitherMap(textStyle0, \__ -> iconStyle, replaceStruct(iconStyle, MIconSize(20.)));
							TBorder(12.0, 6.0, 4.0, 6.0, MIcon2T(p, name, st))
						}
						default: TEmpty();
					}
					|> (\f2 -> TAlpha(fif(isEnabled, const(1.), const(defaultDisabledItemOpacity(getLightBackground(parent)))), f2))
					|> (\f2 -> TBorderDir(-13., -8., 8., -8., f2, isRTL)),
					f,
					isRTL
			)}, f)
		)
		|> TBorderLeftRight(4.)
		|> (\f ->
			if (contains(style, MCloseButton()) || isSome(onClose)) {
				onClickClose = \ -> eitherFn(onClose, \oc -> if (oc.close()) next(visible, false), \ -> next(visible, false));

				closeIconStyleFn = tryExtractStruct(style, MCustomCloseButtonIconStyle(\__, __ -> []));

				iconStyle =
					fselect4(textColor, isEnabled, selected, hovered, \col : MColor, en, sel, hov -> {
						op = if (col == MWhite()) 1. else 0.32;
						defaultCloseIconStyle = [MIconSize(20.), FillOpacity(op), col, MIconButtonBorder(0.)];

						eitherMap(closeIconStyleFn, \customStyle : MCustomCloseButtonIconStyle ->
							replaceStructMany(defaultCloseIconStyle, customStyle.styleFn(sel, hov)),
							defaultCloseIconStyle
						)
						|> (\arr -> ifArrayPush(arr, !en, MIconDisabled()))
					});

				TSelect(iconStyle, \st ->
					MIconButton2T(
						manager,
						p,
						MIconButton(
							extractStruct(style, MCustomCloseButtonIcon("cancel")).icon,
							onClickClose,
							st,
							[MEnabled(enabled), MRippleType(const(MNoRipple())), MFocusEnabled(const(false)), MDisableHover(),
								MCursorShape(const(DefaultCursor())), AccessRole("")]
						),
						m2t
					)
				)
				|> (\f2 -> TBorderDir(4., -2., 0., -2., f2, isRTL))
				|> (\f2 -> TCols2Dir(f, f2, isRTL))
			} else {
				f
			}
		)
		|> (\t -> TBorder4(chipBorder, t))
	})
	|> (\makeChipFn ->
			MComponent2T(manager, p, "MChip", focusState, \foc -> {
				isEnabled = fOr(foc.enabled, active);

				rippleEnabled = fOr(fnot(selectable.enabled), fOr(fnot(isInside), foc.down));
				selected = fOr(fand(selectable.enabled, selectable.selected), active);

				selectedProgress = fif(selectable.enabled,
					fselect3(
						fif(rippleEnabled, growth, const(1.)),
						fif(rippleEnabled, fade, const(0.)),
						fif(foc.down, fnot(selectable.selected), selectable.selected),
						\gr, f, sel -> {
							if (gr != 0. && abs(gr - 1.) > 0.1) {
								if (sel) gr else 1. - gr
							} else if (f != 0. && abs(f - 1.) > 0.1) {
								if (sel) f else 1. - f
							} else {
								if (sel) 1. else 0.
							}
						}
					),
					const(0.)
				);

				selectedColorWithOpacity =
					MCustomColor(
						mixColors(MColor2int(selectedColor), white, colorOpacityDef, 1. - colorOpacityDef)
					);

				mainLayerColor =
					fif(fand(selected, isEnabled), const(selectedColor), const(unselectedColor));
				mainLayerOpacity = fif(isEnabled, fif(selected, const(colorOpacityDef), const(1.)), const(defaultDisabledItemOpacity(getLightBackground(parent))));

				textColor =
					fselect(selectedProgress, FLift(\pr ->
						MCustomColor(mixColors(MColor2int(MTextMColor(unselectedColor)), MColor2int(MTextMColor(selectedColor)), 1. - pr, pr))
					));

				outlineMColor = maybeMap(outlineColor, \oc -> MThemeColor2MColor(foc, oc.color));

				hovered = fand(isEnabled, fOr(foc.hover, extHover));
				hoveredLayerOpacity =
					fselect3(hovered, foc.focused, foc.down, \hov, focused, down ->
						if (down) 0.04 else if (focused) 0.12 else if (hov) 0.04 else 0.
					);

				TCopySize2(makeChipFn(textColor, isEnabled, selected, hovered), \sz, tr ->
					TGroup([
						TSelect2(mainLayerColor, mainLayerOpacity, \col, op ->
							MShape(p, [MFill(col), FillOpacity(op)], sz, "MChip")
						),
						MRipple2T(manager, p, TBorder4(strokeWidth / 2., sz), foc.down, [
							MRippleType(const(MRippleFill())),
							MRipplePosition(mousePosition),
							MRippleColor(
								fif(selectable.enabled,
									fselect(selectedProgress, FLift(\pr ->
										MCustomColor(mixColors(MColor2int(unselectedColor), MColor2int(selectedColor), 1. - pr, pr))
									)),
									const(contrastingMColor(parent))
								)
							),
							MRippleOpacity(fif(selectable.enabled, const(1.), const(0.1))),
							MRippleShape("MChip"),
							MEnabled(rippleEnabled),
							MRipplePercents(growth, fade)
						])
						|> (\t -> TBorder4(-strokeWidth / 2., t)),
						if (outlined) {
							TSelect(selectedProgress, \pr ->
								TGroup2(
									MShape(p, [
										MStroke(either(outlineMColor, MGrey(300))),
										StrokeOpacity((1. - pr) * outlineOpacity),
										StrokeWidth(strokeWidth)
									], sz, "MChip"),
									MShape(p, [
										MStroke(either(outlineMColor, selectedColor)),
										StrokeOpacity(min(1., 2. * colorOpacityDef) * pr * outlineOpacity),
										StrokeWidth(strokeWidth)
									], sz, "MChip")
								)
							)
						} else TEmpty(),

						TSelect(hoveredLayerOpacity, \op ->
							MShape(p, [MFill(MBlack()), FillOpacity(op)], sz, "MChip")
						),
						tr
					])
					|> (\t -> TEasedShadowShape(manager, p, fif(foc.down, const(4.), const(0.)), t, 0.6, RectangleShape("MChip")))
				)
			},
			m2t
		))
	|> (\t -> eitherMap(width, \w -> TAvailableWidth(t, const(w.width)), t))
	|> (\f -> TBorder4(4., f))
	)
	|> (\f ->
		MComponentGroup2T(
			manager,
			parent,
			"MChipContainer",
			concat(
				[
					IScriptBehaviour("visible", visible, ISAppearanceEvent()),
					IScriptBehaviour("selected", selectable.selected, ISSelectionEvent())
				],
				eitherMap(chipCorners, \cc -> [MUpdateShapeCorners("chip", MaterialShape(cc.leftTop, cc.rightTop, cc.rightBottom, cc.leftBottom))], [])
			),
			\par -> MIfLazy2T(manager, par, visible, \v, p -> if (v) makeTropicConstant(None(), None())(f(p)) else TEmpty(), false)
		)
	)
}

MRawButton2T(manager : MaterialManager, parent : MFocusGroup, m : MRawButton, m2t : (Material, MFocusGroup) -> Tropic) -> Tropic {
	normal = \ -> m2t(m.normal, parent);
	hovered = \ -> m2t(m.hover, parent);
	pressed = \ -> m2t(m.pressed, parent);
	disabled = \ -> m2t(m.disabled, parent);

	state : [MRawButtonState] =
		if (m.shortcut == "")
			arrayPush(m.state, MShortcut(m.shortcut))
		else
			m.state;

	MComponent2T(
		manager,
		parent,
		"MRawButton",
		state,
		\focus ->
			TIfLazy2(focus.enabled, \en ->
				if (en)
					TIfLazy2(focus.down, \d ->
						if (d)
							pressed()
						else
							TIfLazy2(fOr(focus.hover, focus.focused), \h ->
								if (h) hovered() else normal(), false
							),
						false
					)
				else
					disabled(),
				false
			),
		m2t
	);
}

extractMFloatingButtonCommonAlignment(style : [MFabStyle]) -> CommonAlignment {
	alignments = filtermap(style, \st ->
		switch (st) {
			MLeft() : {a : Maybe<CommonAlignment> = Some(LeftAlign()); a};
			MRight() : Some(RightAlign());
			MStart() : Some(StartAlign());
			MEnd() : Some(EndAlign());
			default : None();
		}
	);

	extractCommonAlignment(alignments)
}

MButtonProgressState(
	onClick : MOnClick,
	clickEnabled : Transform<bool>,
	wrapContent : (isEnabled : bool) -> (Tropic) -> Tropic
);
makeButtonProgressState(manager : MaterialManager, parent : MFocusGroup, style : [flow], activeColor : MColor, onClick0 : MOnClick) -> MButtonProgressState {
	progress = tryExtractStruct(style, MButtonProgress(make(false), false));
	onClick = MOnClick(\ -> {onClick0.click(); maybeApply(progress, \pr -> if (pr.activateOnClick) nextDistinct(pr.activated, true))});
	clickEnabled = eitherMap(progress, \pr -> fnot(pr.activated), const(true));

	disabledColor = contrastingMColor(parent);
	wrapContent = \isEnabled -> \t ->
		eitherMap(progress, \pr ->
			TCopySize2(t, \sz, tr ->
				TIf(pr.activated, TZoom(MProgressCircle2T(manager, parent, MProgressCircle([if (isEnabled) activeColor else disabledColor])), sz, true), tr)
			),
			t
		);

	MButtonProgressState(
		onClick,
		clickEnabled,
		wrapContent
	)
}