import material/internal/material_clickable;
import material/internal/material_progress;
import sys/keycodes;

export {
	MScroll2T(manager : MaterialManager, parent : MFocusGroup, m : MScroll, m2t : (Material, MFocusGroup) -> Tropic) -> Tropic;
	MRecyclerGrid2T(manager : MaterialManager, parent : MFocusGroup, m : MRecyclerGrid, m2t : (Material, MFocusGroup) -> Tropic) -> Tropic;

	extractMScrollStyle(style : [flow]) -> [MScrollStyle];
	extractTScrollStyle(style : [flow]) -> [TScrollStyle];
}

//TODO: Add arrows to scrollbars
MScroll2T(manager : MaterialManager, parent : MFocusGroup, m : MScroll, m2t : (Material, MFocusGroup) -> Tropic) -> Tropic {
	scrollToFocusEnabled = extractStruct(m.style, MScrollToFocusEnabled(const(true))).enabled;
	currentPoint : TMouseXY = extractStruct(m.style, TMouseXY(makePoint()));
	scrollPosition : TScrollPosition = extractStruct(m.style, TScrollPosition(makePoint()));
	moving : TScrollMoving = extractStruct(m.style, TScrollMoving(make(false)));
	scrollWH : TScrollWidthHeight = extractStruct(m.style, TScrollWidthHeight(makeWH(), makeWH()));
	persistent : TScrollPersistent = extractStruct(m.style, TScrollPersistent(const(false)));
	barstyles : TScrollbars = extractStruct(m.style, TScrollbars(materialScrollBar, materialScrollBar));
	expandOnHover : TExpandOnHover = extractStruct(m.style, TExpandOnHover(true));
	keyFilter : TKeyFilter =
		tryExtractStruct(m.style, TKeyFilter(\__ -> true))
		|> (\kf ->
			extractStruct(
				m.style,
				TKeyFilter(\ke -> {
					eitherMap(kf, \fn -> fn.fn(ke), true) &&
					((ke.utf == "up" && eitherMap(getCurrentFocusedItem(manager), \fc -> isNone(fc.parent.vertical), true)) ||
					(ke.utf == "down" && eitherMap(getCurrentFocusedItem(manager), \fc -> isNone(fc.parent.vertical), true)) ||
					(ke.utf == "left" && eitherMap(getCurrentFocusedItem(manager), \fc -> isNone(fc.parent.horizontal), true)) ||
					(ke.utf == "right" && eitherMap(getCurrentFocusedItem(manager), \fc -> isNone(fc.parent.horizontal), true)))
				})
			)
		);

	// Maximum scroll offset (0 if content fits available box)
	maxWH = fwhmax(fwhsubtract(scrollWH.content, scrollWH.box), const(WidthHeight(0., 0.)));

	uns = initUnsM();
	subscribedToCurrent = ref false;
	scrollToFocusBorder = 8.;

	scrollContent = \newParent ->
		TConstruct(
			[
				makeSubscribe(ftransistor(scrollToFocusEnabled, newParent.focusedId), \foc ->
					if (foc != -1 && !^subscribedToCurrent) {
						subscribedToCurrent := true;
						dispUnsM(uns);

						setUnsM(
							uns,
							makeSubscribeUns(fthrottle(getCurrentFocusedItemBehaviour(manager), 33), \currentMFocusM -> {
								eitherMap(currentMFocusM, \currentMFocus -> {
									focusedPositionScale = fgetValue(currentMFocus.position);

									focusedPosition =
										if (focusedPositionScale.scale.x == 0. || focusedPositionScale.scale.y == 0.) {
											position = make(zeroPoint);
											u = interruptibleTimer(600, \ -> nextDistinct(position, fgetValue(currentMFocus.position).pos)); // For scroll into animated dialog
											Pair(position, u)
										}
										else
											Pair(const(zeroPoint), nop);

									focusedWH = currentMFocus.widthHeight;

									uns2 = make3Subscribe(focusedWH, maxWH, focusedPosition.first, \fWH, mwh, __ -> {
										sp = getValue(scrollPosition.position);
										bwh = getValue(scrollWH.box);
										sfp = PositionScale2Point(fgetValue(newParent.position));
										fps = fgetValue(currentMFocus.position).pos;

										realPosX = fps.x - sfp.x;
										realPosY = fps.y - sfp.y;

										nextDistinct(
											scrollPosition.position,
											Point(
												if (realPosX < 0.)
													forceRange(sp.x + realPosX - scrollToFocusBorder, 0., mwh.width)
												else if (realPosX + fWH.width > bwh.width)
													forceRange(
														sp.x + realPosX + min(fWH.width - bwh.width + scrollToFocusBorder, -scrollToFocusBorder),
														0.,
														mwh.width
													)
												else
													sp.x,
												if (realPosY < 0.)
													forceRange(sp.y + realPosY - scrollToFocusBorder, 0., mwh.height)
												else if (realPosY + fWH.height > bwh.height)
													forceRange(
														sp.y + realPosY + min(fWH.height - bwh.height + scrollToFocusBorder, -scrollToFocusBorder),
														0.,
														mwh.height
													)
												else
													sp.y
											)
										);
									})();

									[focusedPosition.second, uns2]
								}, [])
							})()
						)
					} else if (^subscribedToCurrent && foc == -1) {
						subscribedToCurrent := false;

						dispUnsM(uns)
					}
				),
				\ -> \ -> dispUnsM(uns)
			],
			m2t(m.content, newParent)
		);

	MComponentGroup2T(
		manager,
		parent,
		extractStruct(m.style, MFocusName("MScroll")).name,
		concat(
			extractMComponentGroupState(m.style),
			[
				IScriptBehaviour("point", currentPoint.point, ISInputValue([], serialize(getValue(currentPoint.point)), true)),
				IScriptBehaviour("down", moving.moving, ISInputValue([], serialize(getValue(moving.moving)), true)),
				IScriptBehaviour("position", scrollPosition.position, ISInputValue([], serialize(getValue(scrollPosition.position)), true))
			]
		),
		\newParent ->
			TScroll(
				manager.manager,
				scrollContent(newParent),
				m2t(m.box, newParent),
				replaceStructMany(
					extractTScrollStyle(m.style),
					[
						currentPoint,
						scrollPosition,
						moving,
						scrollWH,
						persistent,
						barstyles,
						expandOnHover,
						keyFilter,
						TSetRTL(newParent.rtl)
					]
				)
			)
	);
}

extractMScrollStyle(style : [flow]) -> [MScrollStyle] {
	filtermap(style, \st: flow ->
		switch (st : flow) {
			MScrollStyle(): {v : Maybe<MScrollStyle> = Some(st); v};
			default: None();
		}
	)
}

extractTScrollStyle(style : [flow]) -> [TScrollStyle] {
	filtermap(style, \st: flow ->
		switch (st : flow) {
			TScrollStyle(): {v : Maybe<TScrollStyle> = Some(st); v};
			default: None();
		}
	)
}

MRecyclerGridContainer(row : int, column : int, material : Material, size : DynamicBehaviour<WidthHeight>, position : DynamicBehaviour<Point>, mutable cached : Maybe<Tropic>);
emptyMRecyclerGridContainer = MRecyclerGridContainer(-1, -1, TEmpty(), makeWH(), makePoint(), None());

boundsOverlap(bounds1 : Bounds, bounds2 : Bounds) -> bool {
	max(bounds1.minX, bounds1.maxX) >= min(bounds2.minX, bounds2.maxX) &&
		min(bounds1.minX, bounds1.maxX) <= max(bounds2.minX, bounds2.maxX) &&
		max(bounds1.minY, bounds1.maxY) >= min(bounds2.minY, bounds2.maxY) &&
		min(bounds1.minY, bounds1.maxY) <= max(bounds2.minY, bounds2.maxY)
}

pointwh2bounds(point : Point, wh : WidthHeight) -> Bounds {
	Bounds(point.x, point.y, point.x + wh.width, point.y + wh.height);
}

fpointwh2bounds(point : Transform<Point>, wh : Transform<WidthHeight>) -> Transform<Bounds> {
	fselect2(point, wh, pointwh2bounds |> FLift2);
}

bounds2w(bounds : Bounds) -> double {
	bounds.maxX - bounds.minX
}

bounds2h(bounds : Bounds) -> double {
	bounds.maxY - bounds.minY
}

insetBounds(bounds : Bounds, left : double, top : double, right : double, bottom : double) -> Bounds {
	Bounds(bounds.minX + left, bounds.minY + top, bounds.maxX - right, bounds.maxY - bottom);
}

MRecyclerGridId(row : int, column : int);

updateMRecyclerGridContainers(containers : [[MRecyclerGridContainer]], lastRow : Maybe<int>, lastColumn : Maybe<int>, availableWH : WidthHeight) -> void {
	updateMRecyclerGridContainers2(zeroPoint, containers, 0, 0, lastRow, lastColumn, availableWH);
}

updateMRecyclerGridContainers2(
	position : Point,
	containers : [[MRecyclerGridContainer]],
	row : int,
	column : int,
	lastRow : Maybe<int>,
	lastColumn : Maybe<int>,
	availableWH : WidthHeight
) -> void {
	if (length(containers) > row && length(containers[row]) > column &&
		eitherMap(lastRow, \lr -> lr > row || (lr == row && eitherMap(lastColumn, \lc -> lc >= column, true)), true)) {
		container = containers[row][column];
		next(container.position, position);

		initSize = getValue(container.size);
		emptyInitSize = initSize.width <= 0.0 || initSize.height <= 0.0;

		if (emptyInitSize) {
			next(container.size, availableWH);
		}

		size = getValue(container.size);
		containerBounds = pointwh2bounds(position, size);

		if (column == 0 && length(containers) > 1) {
			updateMRecyclerGridContainers2(Point(position.x + size.width, position.y), containers, row, column + 1, lastRow, lastColumn, availableWH);
			newPosition = fold(containers[row], Point(0.0, containerBounds.maxY), \acc, c -> {
				Point(0.0, max(acc.y, getValue(c.position).y + getValue(c.size).height));
			});
			updateMRecyclerGridContainers2(newPosition, containers, row + 1, column, lastRow, lastColumn, availableWH);
		} else {
			updateMRecyclerGridContainers2(Point(position.x + size.width, position.y), containers, row, column + 1, lastRow, lastColumn, availableWH);
		}
	}
}

filterVisibleMRecyclerGridContainers(containers : [[MRecyclerGridContainer]], scrollBounds : Bounds, availableWH : WidthHeight) -> [MRecyclerGridId] {
	position = ref zeroPoint;
	filterDone = ref false;
	chunkSize = 1000;

	concatA(
		generate(0, ceil(i2d(length(containers)) / i2d(chunkSize)), \i -> {
			if (^filterDone) {
				[]
			} else {
				containersChunk = subrange(containers, 0, chunkSize * (i + 1));

				r = filterVisibleMRecyclerGridContainers2(^position, containersChunk, chunkSize * i, 0, scrollBounds, availableWH);

				if (length(r) > 0 && !exists(r, \rr -> rr.row == chunkSize * (i + 1) - 1)) {
					filterDone := true;
					r;
				} else {
					position := fold(containersChunk[length(containersChunk) - 1], ^position, \acc, c -> {
						Point(0.0, max(acc.y, getValue(c.position).y + getValue(c.size).height));
					});
					r;
				}
			}
		})
	)
}

filterVisibleMRecyclerGridContainers2(position : Point, containers : [[MRecyclerGridContainer]], row : int, column : int, scrollBounds : Bounds, availableWH : WidthHeight) -> [MRecyclerGridId] {
	if (length(containers) > row && length(containers[row]) > column) {
		container = containers[row][column];
		next(container.position, position);

		initSize = getValue(container.size);
		emptyInitSize = initSize.width <= 0.0 || initSize.height <= 0.0;

		if (emptyInitSize) {
			next(container.size, availableWH);
		}

		size = getValue(container.size);
		containerBounds = pointwh2bounds(position, size);
		emptySize = size.width <= 0.0 || size.height <= 0.0;

		if (emptySize) {
			[MRecyclerGridId(row, column)]
		} else if (boundsOverlap(scrollBounds, containerBounds)) {
			if (column == 0 && length(containers) > 1) {
				r = filterVisibleMRecyclerGridContainers2(Point(position.x + size.width, position.y), containers, row, column + 1, scrollBounds, availableWH);
				newPosition = fold(containers[row], Point(0.0, containerBounds.maxY), \acc, c -> {
					Point(0.0, max(acc.y, getValue(c.position).y + getValue(c.size).height));
				});

				concat3(
					[MRecyclerGridId(row, column)],
					r,
					filterVisibleMRecyclerGridContainers2(newPosition, containers, row + 1, column, scrollBounds, availableWH)
				);
			} else {
				concat(
					[MRecyclerGridId(row, column)],
					filterVisibleMRecyclerGridContainers2(Point(position.x + size.width, position.y), containers, row, column + 1, scrollBounds, availableWH)
				);
			}
		} else if (position.x > scrollBounds.maxX || position.y > scrollBounds.maxY) {
			[];
		} else {
			if (column == 0 && length(containers) > 1) {
				r = filterVisibleMRecyclerGridContainers2(Point(position.x + size.width, position.y), containers, row, column + 1, scrollBounds, availableWH);
				newPosition = fold(containers[row], zeroPoint, \acc, c -> {
					Point(0.0, max(acc.y, getValue(c.position).y + getValue(c.size).height));
				});

				concat(
					r,
					filterVisibleMRecyclerGridContainers2(newPosition, containers, row + 1, column, scrollBounds, availableWH)
				);
			} else {
				filterVisibleMRecyclerGridContainers2(Point(position.x + size.width, position.y), containers, row, column + 1, scrollBounds, availableWH);
			}
		}
	} else {
		[];
	}
}

getMRecyclerGridContentSize(containers : [[MRecyclerGridContainer]]) -> WidthHeight {
	gridSize : Pair<int, WidthHeight> =
		foldWhile(containers, Pair(0, WidthHeight(0.0, 0.0)), \accHeight : Pair<int, WidthHeight>, cc -> {
			rowSize : Pair<int, WidthHeight> =
				foldWhile(cc, Pair(0, WidthHeight(0.0, 0.0)), \accWidth : Pair<int, WidthHeight>, c -> {
					size = getValue(c.size);

					if (size.width > 0.0 && size.height > 0.0) {
						Some(Pair(accWidth.first + 1, WidthHeight(accWidth.second.width + size.width, max(accWidth.second.height, size.height))));
					} else {
						None();
					}
				});

			size =
				WidthHeight(
					rowSize.second.width / i2d(max(rowSize.first, 1)) * i2d(length(cc)),
					rowSize.second.height
				);

			if (size.width > 0.0 && size.height > 0.0) {
				Some(Pair(accHeight.first + 1, WidthHeight(max(accHeight.second.width, size.width), accHeight.second.height + size.height)));
			} else {
				None();
			}
		});

	WidthHeight(
		gridSize.second.width,
		gridSize.second.height / i2d(max(gridSize.first, 1)) * i2d(length(containers))
	);
}

TCached(t : Tropic) -> Tropic {
	cachedB = ref None();
	uns = ref nop;
	instancesCounter = ref 0;

	TransformTAcc2(\t2a -> {
		instancesCounter := ^instancesCounter + 1;
		^uns();
		uns := nop;
		b = eitherFn(^cachedB, \cb -> cb, \ -> { b = t2a(t); cachedB := Some(b); b; });

		TAcc(b with
			disposers =
				[
					\ -> {
						instancesCounter := ^instancesCounter - 1;

						^uns();
						uns := interruptibleTimer(10000, \ -> // Dispose if clip is detroyed for more than 10s
							if (^instancesCounter == 0) {
								maybeApply(^cachedB, \cb -> {
									applyall(cb.disposers);
									cachedB := None();
								})
							}
						);
					}
				]
		)
	})
}

MRecyclerGrid2T(manager : MaterialManager, parent : MFocusGroup, m : MRecyclerGrid, m2t : (Material, MFocusGroup) -> Tropic) -> Tropic {
	sameSize = if (contains(m.style, TSameSize())) Some(makeWH()) else None();
	scrollSize : TScrollWidthHeight = extractStruct(m.style, MScrollWidthHeight(make(zeroWH), make(zeroWH)));
	contentSize = make(zeroWH);
	initWH = fselect2(contentSize, m.items, FLift2(\cs, it -> WidthHeight(cs.width / i2d(max(either(maxA(map(it, length)), 0), 1)), cs.height / i2d(max(length(it), 1)))));
	availableWH = fselect2(scrollSize.box, m.items, FLift2(\cs, it -> WidthHeight(cs.width / i2d(max(either(maxA(map(it, length)), 0), 1)), cs.height / i2d(max(length(it), 1)))));
	items =
		selectDynamicArray(
			fmapi(fsplit2d(m.items), \row, mi ->
				selectDynamicArray(
					fmapi(mi, \column, it ->
						MRecyclerGridContainer(
							row,
							column,
							it,
							either(sameSize, makeWH()),
							makePoint(),
							None()
						)
					),
					idfn
				)
			),
			idfn
		);
	position = extractStruct(m.style, MScrollPosition(makePoint())).position;
	getScrollBounds = \p, bwh -> {
		Bounds(
			dfloor(p.x / bwh.width - 0.1) * bwh.width,
			dfloor(p.y / bwh.height - 0.1) * bwh.height,
			dceil(p.x / bwh.width + 1.1) * bwh.width,
			dceil(p.y / bwh.height + 1.1) * bwh.height
		);
	}
	scrollBounds = fselect2(position, scrollSize.box, getScrollBounds |> FLift2);
	scrollPercent = tryExtractStruct(m.style, TScrollPercent(makePoint()));
	cachedPercent = ref zeroPoint;

	containers : DynamicArray<MRecyclerGridId> = makeDynamicArray([]);
	needsUpdate = make(true);
	contentSizeNeedsUpdate = make(true);

	scrollToItemPending = ref None();
	maybeApply(
		tryExtractStruct(m.style, MScrollToItem(ref nop2)),
		\msti -> {
			msti.fn := \r, c -> {
				scrollToItemPending := Some(Pair(r, c));
				next(needsUpdate, true);
				next(contentSizeNeedsUpdate, true);
			}
		}
	);

	SelectTDynamicGroup(
		containers,
		\index, __, id ->
			TSelect(
				fsubselect(
					elementAtDynamicArrayDef(items, const(id.row), makeDynamicArray([])),
					FLift(\el -> elementAtDynamicArrayDef(el, const(id.column),emptyMRecyclerGridContainer))
				),
				\c : MRecyclerGridContainer -> {
					wh = makeWH();

					TConstruct(
						[
							makeSubscribe(wh, \v -> {
								if (v.width > 0.0 && v.height > 0.0) {
									v2 = getValue(c.size);

									if (v != v2) {
										next(c.size, v);
										next(needsUpdate, true);
										next(contentSizeNeedsUpdate, true);
									}
								}
							})
						],
						TTranslate(
							c.position,
							TFixSize(
								TAvailable(
									eitherFn(
										c.cached,
										\tcached -> tcached,
										\ -> {
											tcached : Tropic = MComponentGroup2T(manager, parent, "MRecyclerGridItem", [], \p -> m2t(c.material, p));
											c.cached ::= Some(tcached);
											tcached;
										}
									)
									|> (\f ->
										if (isNone(sameSize) || (c.row == 0 && c.column == 0))
											TInspect(
												[ISize(wh)],
												f
											)
										else
											f
									),
									TSized(availableWH)
								),
								TEmpty()
							)
						)
					)
				}
			)
	)
	|> (\f ->
		TGroup2(
			f,
			TVisible(
				fselectdelay(contentSizeNeedsUpdate, \csnu -> if (csnu) 0 else 300),
				TTranslate(
					position,
					TCenterIn(MProgressCircle2T(manager, parent, MProgressCircle([])), TSized(scrollSize.box))
				)
			)
		)
	)
	|> (\f ->
		MScroll2T(
			manager,
			parent,
			MScroll(
				TFixSize(f, TSized(contentSize)),
				TFillXY(),
				replaceStructMany(
					extractMScrollStyle(m.style),
					[MScrollPosition(position), scrollSize]
				)
			),
			m2t
		)
	)
	|> (\f ->
		TConstruct(
			[
				// items.second,
				\ -> {
					manager.manager.deltaTimer.attach();
					manager.manager.deltaTimer.detach;
				},
				makeSubscribe(
					fthrottleUntilNextFrameRendered(fpair(
						fselectWithLast(lengthDynamicArray(items), FLift2(\prevLen, curLen -> {
							if (prevLen > curLen) {
								next(contentSizeNeedsUpdate, true);
							}

							curLen;
						})),
						scrollBounds
					)),
					\__ -> next(needsUpdate, true)
				),
				makeSubscribe(manager.manager.deltaTimer.timer, \__ -> {
					if (getValue(needsUpdate)) {
						next(needsUpdate, false);

						it = map(getDynamicArrayValue(items), getDynamicArrayValue);
						if (getValue(contentSizeNeedsUpdate)) {
							next(contentSizeNeedsUpdate, false);
							next(contentSize, getMRecyclerGridContentSize(it));
						}

						eitherFn(
							^scrollToItemPending,
							\sti -> {
								r = sti.first;
								c = sti.second;

								if (contains(getDynamicArrayValue(containers), MRecyclerGridId(r, c))) {
									updateMRecyclerGridContainers(it, Some(r), Some(c), fgetValue(initWH));

									if (getValue(position) == getValue(it[r][c].position)) {
										scrollToItemPending := None();
									} else {
										next(position, getValue(it[r][c].position));
										next(needsUpdate, true);
									}
								} else {
									nextDynamicArray(
										containers,
										mapi(it, \i, rr -> filtermapi(rr, \j, cc -> if (r > i || (r == i && c >= j)) Some(MRecyclerGridId(i, j)) else None()))
										|> concatA
									);
									next(needsUpdate, true);
								}
							},
							\ -> {
								sb = fgetValue(scrollBounds);

								newContainers = filterVisibleMRecyclerGridContainers(it, sb, fgetValue(initWH));
								nextDynamicArray(containers, newContainers);

								maybeApply(scrollPercent, \sp -> {
									next(sp.percent, ^cachedPercent);
								});
							}
						);
					}
				})
			]
			|> (\subs ->
				eitherMap(
					scrollPercent,
					\sp -> {
						concat(
							[
								makeSubscribe(sp.percent, \p -> {
									if (getValue(needsUpdate) == getValue(contentSizeNeedsUpdate)) {
										cachedPercent := p;
									}
								})
							],
							subs
						)
					},
					subs
				)
			),
			f
		)
	)
}