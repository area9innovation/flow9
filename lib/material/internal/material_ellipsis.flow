import material/internal/material_tooltip;
import material/internal/tropic_size_util;

export {
	MEllipsis2T(m : MEllipsis, m2t : (Material) -> Tropic) -> Tropic;
	MEllipsisText2T(manager : MaterialManager, parent : MFocusGroup, m : MEllipsisText, m2t : (Material, MFocusGroup) -> Tropic) -> Tropic;
}

getPrettyTextCut(first: int, last : int, wCroped : double, text : string, style : [MTextStyle], m2t : (Material) -> Tropic) -> Tropic {
	if (last <= first + 1)
		m2t(MText(strLeft(text, first + 1), style))
	else {
		mid = first + trunc(i2d(last - first) / 2.0);
		newT = m2t(MText(strLeft(text, mid + 1), style));
		if (getTropicMetrics(newT).width > wCroped)
			getPrettyTextCut(first, mid, wCroped, text, style, m2t)
		else
			getPrettyTextCut(mid, last, wCroped, text, style, m2t)
	}
}

MEllipsis2T(m : MEllipsis, m2t : (Material) -> Tropic) {
	style : [MEllipsisStyle] = m.style;
	showtooltip : Transform<bool> = extractStruct(style, MShowTooltip(const(false))).show;
	full = m.full;
	size = m.size;
	fullT = m2t(full);
	sizeT = m2t(size);
	sm = getTropicMetrics(sizeT);
	disableOnDragging = contains(style, MDisableOnDragging());
	rtl = getDefaultRtl();

	fits = if (isConstantSizeTropic(sizeT) && isConstantSizeTropic(fullT)) {
		fm = getTropicMetrics(fullT);
		fm.width <= sm.width && fm.height <= sm.height;
	} else false;

	if (fits) {
		// We completely fit. No need to do anything
		fullT
		|> makeTropicConstant(None(), None())
	} else {
		textStyle : [MEllipsisStyle] = switch (full) {
			MText(text, s): {
				elStyle : [MEllipsisStyle] = s;
				elStyle;
			}
			default: style;
		};

		tooltipText = switch (full) {
			MText(text, s): MParagraph(text, ifArrayPush(s, sm.width > 0., MWidth(sm.width)));
			default: full;
		};

		ellipsisText = m2t(MText(THREE_DOTS, style2MTextStyle(textStyle)));
		sizeWithoutEllipsis = TSubtractGroup2(sizeT, TWidth(ellipsisText));
		croped = TCropSize(sizeWithoutEllipsis, fullT);

		prettyCroped = switch (full) {
			MText(text, s): {
				wCroped = getTropicMetrics(croped).width;
				if ((strlen(text) > 0) && (wCroped > 0.0) && (wCroped < getTropicMetrics(fullT).width))
					getPrettyTextCut(0, strlen(text) - 1, wCroped, text, s, m2t)
				else
					croped;
			}
			default: croped;
		};

		// If cropped, display the complete content as a tooltip when requested
		truncated : (Tropic) -> Tropic = \tr : Tropic ->
			TCols2A(
				TCenterY(prettyCroped),
				TTweak([TAlign(const(b2d(rtl)), const(1.))], ellipsisText, THeight(prettyCroped))
			)
			|> (\t -> TAvailable(t, tr))
			|> (\t : Tropic ->
				if (showtooltip == ConstBehaviour(false)) t
				else
					MTooltip(t, tooltipText, ifArrayPush([MEnabled(showtooltip)], disableOnDragging, MDisableOnDragging()))
					|> m2t
			);

		TLet("t", fullT,
			TLet("s", sizeT,
				TCase([
					// We make the truncated version one pixel smaller so that if the item fits
					// completely, we never abbreviate it
					TSubtractGroup2(TDisplay("s"), TFixed(1.0, 1.0)),
					// The maximum size of the real thing, as well as the room available
					TGroup2(TGhost("s"), TDisplay("t")),
					// Get the original tropic, if possible
					TGhost("t")
				], [truncated(TGhost("s")), TDisplay("t"), TDisplay("t")])
			)
		)
	}
}

MEllipsisText2T(manager : MaterialManager, parent : MFocusGroup, m : MEllipsisText, m2t : (Material, MFocusGroup) -> Tropic) -> Tropic {
	mTextStyle = style2MTextStyle(m.style);
	minWidth = extractStruct(m.style, MMinWidth(-1.)).width;
	tooltipMaxWidth = extractStruct(m.style, MTooltipMaxWidth(400.0)).width;
	lines = extractStruct(m.style, MMaxLines(1)).lines;
	textAlignment = maybeMap(tryExtractStruct(m.style, MEllipsisTextAlignment(StartAlign())), \al -> al.alignment);
	rightAlign0 = contains(m.style, RightAlign());
	centerAlign0 = contains(m.style, CenterAlign());
	rightAlign = rightAlign0 || eitherMap(textAlignment, \al -> !centerAlign0 && commonAlignment2abs(al, parent.rtl) == RightAlign(), false);
	centerAlign = centerAlign0 || eitherMap(textAlignment, \al -> !rightAlign0 && al == CenterAlign(), false);
	truncateFromStart = contains(m.style, MTruncateFromStart());
	isTruncated = extractStruct(m.style, MTextIsTruncated(make(false))).isTruncated;
	setIsTruncated = \v -> nextDistinct(isTruncated, v);
	isFullWidth = contains(m.style, MFullWidth());
	interlineSpacing = extractStruct(m.style, InterlineSpacing(0.0));
	escapeHTML = extractStruct(m.style, EscapeHTML(true));
	unescape = \s -> if (escapeHTML.escape) s else unescapeHtml2(s);
	text = unescape(m.text);

	charStyle = MTextStyle2TCharacterStyle(parent, text, mTextStyle);
	textT = TText(text, charStyle);
	fullWidth = getTWordMetrics(textT, makeTree()).width;
	maybeApply(tryExtractStruct(m.style, MEllipsisTextGetFullWidth(nop1)), \getfw -> getfw.fn(fullWidth));
	variants = arrayPush(extractStruct(m.style, MTextVariants([])).variants, m.text);
	variantWidths = map(variants, \v -> getTWordMetrics(TText(v, charStyle), makeTree()).width);

	if (minWidth > 0. && minWidth >= fullWidth && strCountOf(text, "\n") < lines) {
		setIsTruncated(false);
		TText(text, charStyle);
	} else {
		availableWidth = make(fullWidth);
		disableOnDragging = contains(m.style, MDisableOnDragging());
		showTooltip0 = extractStruct(m.style, MShowTooltip(const(false))).show;
		showTooltip = fand(showTooltip0, isTruncated);

		dottedTextSize = TSizeOf(TText(substring(text, 0, 1) + THREE_DOTS, charStyle));

		(if (js && !truncateFromStart && false) { // Temporary disabled
			TParagraph(
				const(text),
				concat(
					charStyle,
					[
						ParagraphEllipsis(lines, setIsTruncated)
					]
				)
			)
		} else {
			currentText = make(text);

			TDynamicText(fselect(currentText, FLift(unescape)), concat3(charStyle, [ParagraphWidth(availableWidth), interlineSpacing], eitherMap(textAlignment, v2a, [])))
			|> (\t ->
				TConstruct(
					[
						\ -> fconnectSelect(availableWidth, currentText, \aw0 -> {
							aw = dceil(aw0 * 100.) / 100.; // To avoid false positive truncations in IE.
							if (aw >= fullWidth && strCountOf(text, "\n") < lines) {
								setIsTruncated(false);
								text;
							} else {
								varIdx = either(lastfindi(variantWidths, (\v -> v <= aw0)), 0);
								varText = variants[varIdx];
								truncatedText =
									getSplittedAndTruncatedByWidthString(if (truncateFromStart) reverse(varText) else varText, aw, charStyle, lines)
									|> if (truncateFromStart) reverse else idfn;
								setIsTruncated(varIdx!=length(variants)-1 || endsWith(truncatedText, THREE_DOTS));
								truncatedText
							}
						})
					],
					t
				)
			)
		})
		|> (\f : Tropic ->
			if (isFConst(showTooltip0) && fgetValue(showTooltip0) == false)
				f
			else {
				openTooltip = make(false);
				MTooltip2T(
					manager,
					parent,
					MTooltip(
						f,
						TShowLazy(
							showTooltip,
							\ ->
								MParagraph2T(
									parent,
									if (strlen(text) > 1000) strSubRange(text, 0, 1000) + THREE_DOTS else text,
									[sameLightMColor(parent), MTooltipDesktop(), CropWords(true), MWidth(min(fullWidth, tooltipMaxWidth)), escapeHTML]
								)
						),
						[MEnabled(showTooltip), MOpenMenu(openTooltip)]
						|> (\f2 -> ifArrayPush(f2, disableOnDragging, MDisableOnDragging()))
					),
					m2t
				)
				|> (\t -> TConstruct([\ -> fconnect(showTooltip, openTooltip)], t))
		})
		|> (\t -> if (centerAlign) TCenterX(t) else if (rightAlign) TCols2(TFillX(), t) else if (isFullWidth) TCols2(t, TFillX()) else t)
		|> (\t -> TGroup2(t, THeight(dottedTextSize)))
		|> (\t ->
			TAttachWidth2(
				if ((isFullWidth || centerAlign) && !getDefaultRtl()) TFillX() else TMinimumGroup2(TFixed(fullWidth, 0.0), TFillX())
				|> (\f ->
					if (strlen(text) > 1)
						TGroup2(TWidth(dottedTextSize), f)
					else
						f
				),
				availableWidth,
				t
			)
		)
	}
}