import material/internal/material_stage_util;
import material/internal/material_focus_util;
import tropic/trender;
import text/serialize;

export {
	// General utils
	getCallstackIfNeeded(manager : MaterialManager) -> string;
	getIScriptRecordingStarted(manager : MaterialManager) -> double;
	getIScriptDelay(manager : MaterialManager) -> double;
	getIScriptRecordCaption(aliases : Tree<IScriptComponentDescriptor, string>, script : Pair<double, IScriptRecord>) -> string;

	// FocusId utils
	getIScriptUniqueIdParent(focus : MaterialFocus) -> MFocusGroup;
	fixAllIScriptUniqueIds(focus : MFocusGroup) -> void;
	fixIScriptUniqueId(focus : MaterialFocus) -> void;
	getFullMFocusId(focus : MaterialFocus) -> List<IScriptIdentifier>;
	IScriptId2s(idList : List<IScriptIdentifier>) -> string;

	// IScript state utils
	isIScriptEmpty(manager : MaterialManager) -> bool;
	isIScriptScenarioEmpty(manager : MaterialManager) -> bool;

	isIScriptEmptyB(manager : MaterialManager) -> Transform<bool>;
	isIScriptScenarioEmptyB(manager : MaterialManager) -> Transform<bool>;

	clearIScriptAdditionalInfo(manager : MaterialManager) -> void;
	clearCurrentIScript(manager : MaterialManager) -> void;
	resumeCurrentIScript(manager : MaterialManager) -> void;

	isIScriptEnabled(manager : MaterialManager) -> bool;
	isIScriptEnabledB(manager : MaterialManager) -> Transform<bool>;

	getIScriptState(manager : MaterialManager) -> IScriptState;
	setIScriptState(manager : MaterialManager, state : IScriptState) -> void;

	getIScriptRecording(manager : MaterialManager) -> Maybe<IScriptRecording>;

	isIScriptRecording(manager : MaterialManager) -> bool;
	isIScriptRecordingPaused(manager : MaterialManager) -> bool;
	isIScriptReplaying(manager : MaterialManager) -> bool;
	isIScriptReplayingPaused(manager : MaterialManager) -> bool;
	isIScriptScenarioReplaying(manager : MaterialManager) -> bool;
	isIScriptScenarioReplayingPaused(manager : MaterialManager) -> bool;
	isIScriptStopped(manager : MaterialManager) -> bool;
	isIScriptAdding(manager : MaterialManager) -> bool;
	isIScriptReplayingOrRecording(manager : MaterialManager) -> bool;

	isIScriptReplayReady(manager : MaterialManager) -> bool;
	isIScriptScenarioReplayReady(manager : MaterialManager) -> bool;

	isIScriptRecordingB(manager : MaterialManager) -> Transform<bool>;
	isIScriptReplayingB(manager : MaterialManager) -> Transform<bool>;
	isIScriptScenarioReplayingB(manager : MaterialManager) -> Transform<bool>;
	isIScriptStoppedB(manager : MaterialManager) -> Transform<bool>;
	isIScriptAddingB(manager : MaterialManager) -> Transform<bool>;
	isIScriptReplayingOrRecordingB(manager : MaterialManager) -> Transform<bool>;

	isIScriptReplayReadyB(manager : MaterialManager) -> Transform<bool>;
	isIScriptScenarioReplayReadyB(manager : MaterialManager) -> Transform<bool>;

	isIScriptFilesystemDBPresent(manager : MaterialManager) -> bool;
	isIScriptFilesystemDBPresentB(manager : MaterialManager) -> Transform<bool>;

	checkIScriptRecordTypeCaptureOption(manager : MaterialManager, behaviourName : string, type : IScriptRecordType) -> bool;
	checkIScriptCaptureOption(manager : MaterialManager, option : IScriptCaptureOption) -> bool;

	pauseIScriptRecording(manager : MaterialManager) -> void;
	resumeIScriptRecording(manager : MaterialManager) -> void;

	// IScript stack utils
	mapIScriptStack(stack : Tree<double, [IScriptRecord]>, fn : (double, IScriptRecord) -> ?) -> [?];
	filtermapIScriptStack(stack : Tree<double, [IScriptRecord]>, fn : (double, IScriptRecord) -> Maybe<?>) -> [?];
	foldIScriptStack(stack : Tree<double, [IScriptRecord]>, init : ?, fn : (?, double, IScriptRecord) -> ?) -> ?;
	foldRIScriptStack(stack : Tree<double, [IScriptRecord]>, init : ?, fn : (?, double, IScriptRecord) -> ?) -> ?;

	mapIScriptStackTree(stack : Tree<double, [IScriptRecord]>, fn : (double, IScriptRecord) -> IScriptRecord) -> Tree<double, [IScriptRecord]>;
	filterIScriptStackTree(stack : Tree<double, [IScriptRecord]>, fn : (double, IScriptRecord) -> bool) -> Tree<double, [IScriptRecord]>;
	filtermapIScriptStackTree(stack : Tree<double, [IScriptRecord]>, fn : (double, IScriptRecord) -> Maybe<IScriptRecord>) -> Tree<double, [IScriptRecord]>;
	foldIScriptStackTree(stack : Tree<double, [IScriptRecord]>, init : ?, fn : (?, double, IScriptRecord) -> ?) -> ?;
	foldRIScriptStackTree(stack : Tree<double, [IScriptRecord]>, init : ?, fn : (?, double, IScriptRecord) -> ?) -> ?;

	findIScriptLastRecordKey(stack : Tree<double, [IScriptRecord]>) -> Maybe<double>;
	findIScriptLastRecordKeyValue(stack : Tree<double, [IScriptRecord]>) -> Maybe<Pair<double, IScriptRecord>>;
	extractIScriptLastRecord(stack : Tree<double, [IScriptRecord]>) -> Maybe<IScriptRecord>;

	findIScriptLastRecordKeyOfType(stack : Tree<double, [IScriptRecord]>, type : IScriptRecord) -> Maybe<double>;
	findIScriptLastRecordKeyValueOfType(stack : Tree<double, [IScriptRecord]>, type : IScriptRecord) -> Maybe<Pair<double, IScriptRecord>>;
	extractIScriptLastRecordOfType(stack : Tree<double, [IScriptRecord]>, type : IScriptRecord) -> Maybe<IScriptRecord>;

	addIScriptStackRecord(stack : Tree<double, [IScriptRecord]>, record : IScriptRecord) -> Tree<double, [IScriptRecord]>;
	replaceRecordInIScriptStack(stack : Tree<double, [IScriptRecord]>, delay : double, prevValue : IScriptRecord, nextValue : IScriptRecord) -> Tree<double, [IScriptRecord]>;
	getIScriptStackDelay(stack : Tree<double, [IScriptRecord]>) -> double;

	// Focus search
	getMaterialFocusById(parent : MFocusGroup, id : [int])  -> Maybe<MaterialFocus>;
	getMaterialFocusByUniqueId(parent : MFocusGroup, id : string) -> Maybe<MaterialFocus>;
	getMaterialFocusByIScriptId(parent : MFocusGroup, id : List<IScriptIdentifier>) -> Maybe<MaterialFocus>;
	collectMaterialFocuses(focusTree : Tree<int, MaterialFocus>, test : (MaterialFocus) -> bool) -> Tree<string, [MaterialFocus]>;
	getIScriptPairValueB(
		behaviours : Tree<string, Pair<DynamicBehaviour<flow>, IScriptRecordType>>,
		key : string,
		def : DynamicBehaviour<flow>
	) -> DynamicBehaviour<flow>;
	getIScriptPairValueBM(
		behaviours : Tree<string, Pair<DynamicBehaviour<flow>, IScriptRecordType>>,
		key : string
	) -> Maybe<DynamicBehaviour<flow>>;

	getFocusById(parent : MFocusGroup, id : [int]) -> Maybe<MFocus>;
	getFocusGroupById(parent : MFocusGroup, id : [int]) -> Maybe<MFocusGroup>;

	// Adding records
	ISRecDelayStyle ::= ISRecCurrentDelay, ISRecDelay, ISRecFirst, ISRecLast;
        ISRecCurrentDelay();
        ISRecDelay(delay : double);
        ISRecFirst();
        ISRecLast();
	addIScriptRecord(manager : MaterialManager, record : IScriptRecord) -> void;
	addIScriptRecordWithDelayStyle(manager : MaterialManager, delayStyle : ISRecDelayStyle, record : IScriptRecord) -> void;
	addIScriptRecordWithDelay(manager : MaterialManager, delay : double, record : IScriptRecord) -> void;
	addIScriptBehaviourRecord(manager : MaterialManager, componentName : string, behaviourName : string, value : flow, id : List<IScriptIdentifier>,
		type : IScriptRecordType, callstack : string) -> void;
	addIScriptRequestRecord(manager : MaterialManager, url : string, post : bool, headers : [KeyValue], params : [KeyValue], delay : double,
		response : IScriptRequestRespose) -> void;
	addGlobalAliasInIScript(manager : MaterialManager, focus : MaterialFocus, alias : string) -> void;
	addIScriptUrlRecord(manager : MaterialManager, url : string) -> void;

	// Logging
	iScriptInfo(manager : MaterialManager, text : string, id : Maybe<List<IScriptIdentifier>>) -> void;
	iScriptError(manager : MaterialManager, error : string, id : Maybe<List<IScriptIdentifier>>) -> void;

	// Replace record
	replaceRecordInIScript(manager : MaterialManager, prevRecord : Pair<double, IScriptRecord>, record : Pair<double, IScriptRecord>) -> void;

	// Remove record
	removeRecordFromIScript(manager : MaterialManager, record : Pair<double, IScriptRecord>) -> void;

	// Handling recording
	initIScriptRecording(manager : MaterialManager, f : MaterialFocus, disposeOnRecordStopped : bool) -> () -> void;
	captureIScriptKeyEvent(manager : MaterialManager, handled : bool, k : KeyEvent, component : string, type : string) -> bool;
	captureIScriptMouseEvent(manager : MaterialManager, handled : bool, miFn : () -> MouseInfo, canvasPosition : () -> Point, component : string, type : string) -> bool;
	captureIScriptMouseDownEvent(manager : MaterialManager, handled : bool, miFn : MouseDownInfo, canvasPosition : () -> Point, component : string) -> bool;
	addBufferedMouseDownAndDispose(ending : bool) -> void;

	loadAdditionalIScriptInfo(manager : MaterialManager, additionalInfo : IScriptAdditionalInfo) -> void;
	prepareCurrentIScriptForSave(manager : MaterialManager) -> StoredIScript;
	filterIScriptScreenshot(screenshot : IScriptScreenshot) -> IScriptScreenshot;

	makeSubscribe2focusHovered(manager : MaterialManager, focus : () -> Maybe<MaterialFocus>, hover : DynamicBehaviour<bool>) -> () -> () -> void;
	highlightMaterialFocus(manager : MaterialManager, focus : MaterialFocus) -> () -> void;
}

isIScriptEmpty(manager : MaterialManager) -> bool {
	sizeTree(getValue(manager.iscript.script).stack) == 0
}

isIScriptScenarioEmpty(manager : MaterialManager) -> bool {
	length(getValue(manager.iscript.scenario.scriptsB)) == 0
}

isIScriptEmptyB(manager : MaterialManager) -> Transform<bool> {
	fselect(manager.iscript.script, FLift(\s -> sizeTree(s.stack) == 0))
}

isIScriptScenarioEmptyB(manager : MaterialManager) -> Transform<bool> {
	fselect(manager.iscript.scenario.scriptsB, FLift(\l -> length(l) == 0))
}

getMaterialFocusParent(focus : MaterialFocus) -> Maybe<MFocusGroup> {
	switchMaterialFocus(
		focus,
		\f -> Some(f.parent),
		\f -> f.parent
	)
}

getCallstackIfNeeded(manager : MaterialManager) -> string {
	if (checkIScriptCaptureOption(manager, IScriptCaptureCallstack()))
		callstack2string(captureCallstack())
	else
		"";
}

getIScriptRecordingStarted(manager : MaterialManager) -> double {
	getValue(manager.iscript.script).recordingStarted;
}

getIScriptDelay(manager : MaterialManager) -> double {
	if (isIScriptRecording(manager)) {
		max(timestamp() - getIScriptRecordingStarted(manager), 1.0);
	} else {
		1.0;
	}
}

getIScriptRecordCaption(aliases : Tree<IScriptComponentDescriptor, string>, script : Pair<double, IScriptRecord>) -> string {
	recordTitle =
		switch (script.second : IScriptRecord) {
			IScriptBehaviourRecord(descriptor, value, type, callstack) : {
				componentTitle = lookupTreeDef(
					aliases,
					IScriptComponentDescriptor(descriptor.component.name, descriptor.component.id),
					descriptor.component.name + " [" + IScriptId2s(descriptor.component.id) + "]"
				);

				if (descriptor.name == "pebble_stack" || descriptor.name == "current_pebble")
					descriptor.name + " : " + toString(value)
				else
					componentTitle + " " + descriptor.name + " : " + toString(value);
			}
			IScriptRequestRecord(url, post, headers, params, delay, response) :
				url + " " + b2s(post) + " " + d2s(delay);
			IScriptScreenshot(__, __) :
				"Screenshot ";
			IScript(recordingStarted, stack) :
				"IScript " + d2s(script.first);
			IScriptLogicalScreenshot(screenshot, size) :
				"IScriptLogicalScreenshot " + toString(size);
			IScriptVisualScreenshot(screenshot) :
				"IScriptVisualScreenshot";
			IScriptInputRecord(__, name, __, __) :
				"Input    \"" + name + "\"";
			IScriptOutputRecord(__, name) :
				"Output    \"" + name + "\"";
			IScriptStageWidthHeight(wh) :
				"Stage size: " + toString(wh.width) + " x " + toString(wh.height);
			IScriptCheck(behaviourDescriptor, checkFn, type): "Check";
			IScriptNested(componentName, id, iScript): "Nested";
			IScriptUrlRecord(url): "Url " + url;
			IScriptSearchBehaviourRecord(descriptor, value): "Search: " + lookupTreeDef(
				aliases,
				IScriptComponentDescriptor(descriptor.component.name, descriptor.component.id),
				descriptor.component.name + " [" + IScriptId2s(descriptor.component.id) + "]"
			) + " " + descriptor.name + " : " + toString(value);
			IScriptSearchText(text, id): "Search text: " + text + " in [" + IScriptId2s(id) + "]";
			IScriptGeneratedRecord(): "Generated";
		}

	"Delay " + d2s(script.first) + "        " + recordTitle;
}

getIScriptUniqueIdParentMaybe(focus : MaterialFocus) -> Maybe<MFocusGroup> {
	switchMaterialFocus(
		focus,
		\f -> {
			eitherFn(
				f.parent.iScriptId,
				\__ -> Some(f.parent),
				\ -> getIScriptUniqueIdParentMaybe(f.parent)
			)
		},
		\f : MFocusGroup -> {
			eitherMap(
				f.parent,
				\p : MFocusGroup ->
					eitherFn(
						p.iScriptId,
						\__ -> Some(p),
						\ -> getIScriptUniqueIdParentMaybe(p)
					),
				None()
			)
		}
	)
}

getIScriptUniqueIdParent(focus : MaterialFocus) -> MFocusGroup {
	switchMaterialFocus(
		focus,
		\f -> {
			eitherFn(
				f.parent.iScriptId,
				\__ -> f.parent,
				\ -> getIScriptUniqueIdParent(f.parent)
			)
		},
		\f : MFocusGroup -> {
			eitherMap(
				f.parent,
				\p : MFocusGroup ->
					eitherFn(
						p.iScriptId,
						\__ -> p,
						\ -> getIScriptUniqueIdParent(p)
					),
				f
			)
		}
	)
}

fixAllIScriptUniqueIds(focus : MFocusGroup) -> void {
	iter(getTreeValues(getValue(focus.focusIds)), \v : MaterialFocus -> {
		switchMaterialFocus(
			v,
			fixIScriptUniqueId,
			\f -> {
				fixIScriptUniqueId(f);
				fixAllIScriptUniqueIds(f);
			}
		)
	})
}

fixIScriptUniqueId(focus : MaterialFocus) -> void {
	eitherFn(
		focus.iScriptId,
		\id0 -> {
			parent = getIScriptUniqueIdParent(focus);
			id = strReplaces(id0, [" ", "_", "[", "_", "]", "_", ",", "_"]);

			if (lookupTree(getValue(parent.iScriptIds), id) == Some(focus)) {
				next(parent.iScriptIds, removeFromTree(getValue(parent.iScriptIds), id))
			}

			switchMaterialFocus(
				focus,
				\f -> f.iScriptId ::= Some(id),
				\f -> f.iScriptId ::= Some(id)
			);

			eitherFn(
				lookupTree(getValue(parent.iScriptIds), id),
				\f -> {
					if (f != focus) {
						switchMaterialFocus(
							focus,
							\f2 -> f2.iScriptId ::= Some(id + "_"),
							\f2 -> f2.iScriptId ::= Some(id + "_")
						);
						fixIScriptUniqueId(focus);
					}
				},
				\ -> {
					next(parent.iScriptIds, setTree(getValue(parent.iScriptIds), id, focus));
				}
			);
		},
		\ -> {
			switchMaterialFocus(
				focus,
				\f -> {
					if (fgetValue(f.title) != "") {
						f.iScriptId ::= Some(fgetValue(f.title));
						fixIScriptUniqueId(f);
					} else if (f.name != "") {
						f.iScriptId ::= Some(f.name);
						fixIScriptUniqueId(f);
					}
				},
				\f -> {
					if (f.name != "" && f.name != "MComponentGroup" && f.name != "MComponentGroupMutable" && f.name != "MMutable" && f.name != "MIfLazy2" && f.name != "MAttach"
						&& f.name != "MIfPreRender true" && f.name != "MIfPreRender false" && f.name != "MRenderOnceContentContainer" && f.name != "MShow2T") {
						f.iScriptId ::= Some(f.name);
						fixIScriptUniqueId(f);
					}
				}
			);
		}
	)
}

getFullMFocusId(focus : MaterialFocus) -> List<IScriptIdentifier> {
	eitherFn(
		focus.iScriptId,
		\id -> {
			eitherMap(
				getIScriptUniqueIdParentMaybe(focus),
				\p -> concatList(getFullMFocusId(p), Cons(IScriptId(id), EmptyList())),
				Cons(IScriptId(id), EmptyList())
			)
		},
		\ -> {
			eitherMap(
				getMaterialFocusParent(focus),
				\p -> concatList(getFullMFocusId(p), Cons(IScriptFocusTreePosition(fgetValue(focus.id)), EmptyList())),
				EmptyList()
			)
		}
	)
}

IScriptId2s(idList : List<IScriptIdentifier>) -> string {
	foldList(idList, "", \acc, i ->
		acc + (if (acc != "") ", " else "") +
			switch (i : IScriptIdentifier) {
				IScriptFocusTreePosition(id): toString(id);
				IScriptId(id) : "\"" + id + "\"";
				IScriptFormPosition(id) : "{" + toString(id) + "}";
			}
	)
}

isIScriptEnabled(manager : MaterialManager) -> bool {
	getValue(manager.iscript.showPanel)
}

isIScriptEnabledB(manager : MaterialManager) -> Transform<bool> {
	manager.iscript.showPanel;
}

getIScriptState(manager : MaterialManager) -> IScriptState {
	getValue(manager.iscript.state);
}

setIScriptState(manager : MaterialManager, state : IScriptState) -> void {
	nextDistinct(manager.iscript.state, state);
}

getIScriptRecording(manager : MaterialManager) -> Maybe<IScriptRecording> {
	if (isIScriptEnabled(manager)) {
		iScriptState = getIScriptState(manager);

		switch (iScriptState) {
			IScriptRecording(__, __): Some(iScriptState);
			default: None();
		}
	} else {
		None();
	}
}

isIScriptRecording(manager : MaterialManager) -> bool {
	isIScriptEnabled(manager) && isSome(getIScriptRecording(manager))
}


getIScriptRecordingPaused(manager : MaterialManager) -> Maybe<IScriptRecordingPaused> {
	if (isIScriptEnabled(manager)) {
		iScriptState = getIScriptState(manager);

		switch (iScriptState) {
			IScriptRecordingPaused(__, __): Some(iScriptState);
			default: None();
		}
	} else {
		None();
	}
}

isIScriptRecordingPaused(manager : MaterialManager) -> bool {
	isIScriptEnabled(manager) && isSome(getIScriptRecordingPaused(manager))
}

isIScriptReplaying(manager : MaterialManager) -> bool {
	iScriptState = getIScriptState(manager);

	isIScriptEnabled(manager) && isSameStructType(iScriptState, IScriptReplaying(nop1))
}

isIScriptReplayingPaused(manager : MaterialManager) -> bool {
	iScriptState = getIScriptState(manager);

	isIScriptEnabled(manager) && isSameStructType(iScriptState, IScriptReplayingPaused())
}

isIScriptScenarioReplaying(manager : MaterialManager) -> bool {
	iScriptState = getIScriptState(manager);

	isIScriptEnabled(manager) && isSameStructType(iScriptState, IScriptScenarioReplaying(nop1))
}

isIScriptScenarioReplayingPaused(manager : MaterialManager) -> bool {
	iScriptState = getIScriptState(manager);

	isIScriptEnabled(manager) && isSameStructType(iScriptState, IScriptScenarioReplayingPaused())
}

isIScriptStopped(manager : MaterialManager) -> bool {
	iScriptState = getIScriptState(manager);

	isIScriptEnabled(manager) && iScriptState == IScriptStopped()
}

isIScriptAdding(manager : MaterialManager) -> bool {
	isIScriptEnabled(manager) &&
		switch (getValue(manager.iscript.state)) {
			IScriptAddMFocusRecord(__): true;
			IScriptAddMFocusGroupRecord(__): true;
			IScriptAddMFocusAlias(__): true;
			IScriptAddMFocusGroupAlias(__): true;

			default : false;
		}
}

isIScriptReplayingOrRecording(manager : MaterialManager) -> bool {
	isIScriptRecording(manager) || isIScriptReplaying(manager) || isIScriptScenarioReplaying(manager)
}

isIScriptReplayReady(manager : MaterialManager) -> bool {
	isIScriptEnabled(manager) && !isIScriptEmpty(manager)
}

isIScriptScenarioReplayReady(manager : MaterialManager) -> bool {
	isIScriptEnabled(manager) && !isIScriptScenarioEmpty(manager)
}

isIScriptRecordingB(manager : MaterialManager) -> Transform<bool> {
	fselect(manager.iscript.state, FLift(\__ -> isIScriptRecording(manager)));
}

isIScriptReplayingB(manager : MaterialManager) -> Transform<bool> {
	fselect(manager.iscript.state, FLift(\__ -> isIScriptReplaying(manager)));
}

isIScriptScenarioReplayingB(manager : MaterialManager) -> Transform<bool> {
	fselect(manager.iscript.state, FLift(\__ -> isIScriptScenarioReplaying(manager)));
}

isIScriptStoppedB(manager : MaterialManager) -> Transform<bool> {
	fselect(manager.iscript.state, FLift(\__ -> isIScriptStopped(manager)));
}

isIScriptAddingB(manager : MaterialManager) -> Transform<bool> {
	fselect(manager.iscript.state, FLift(\__ -> isIScriptAdding(manager)));
}

isIScriptReplayingOrRecordingB(manager : MaterialManager) -> Transform<bool> {
	fmax3(isIScriptRecordingB(manager), isIScriptReplayingB(manager), isIScriptScenarioReplayingB(manager))
}

isIScriptReplayReadyB(manager : MaterialManager) -> Transform<bool> {
	fmin(isIScriptEnabledB(manager), fnot(isIScriptEmptyB(manager)))
}

isIScriptScenarioReplayReadyB(manager : MaterialManager) -> Transform<bool> {
	fmin(isIScriptEnabledB(manager), fnot(isIScriptScenarioEmptyB(manager)))
}

isIScriptFilesystemDBPresent(manager : MaterialManager) -> bool {
	isSome(getValue(manager.iscript.filesystemDB))
}

isIScriptFilesystemDBPresentB(manager : MaterialManager) -> Transform<bool> {
	fselect(manager.iscript.filesystemDB, isSome |> FLift)
}

checkIScriptRecordTypeCaptureOption(manager : MaterialManager, behaviourName : string, type : IScriptRecordType) -> bool {
	switch (type) {
		ISDetailedTextEvent() : checkIScriptCaptureOption(manager, IScriptCaptureTextDetails());
		ISMouseEvent() : checkIScriptCaptureOption(manager, IScriptCaptureMouseEvents());
		ISKeyEvent() : checkIScriptCaptureOption(manager, IScriptCaptureKeyEvents());
		ISInteractionEvent() : {
			if (behaviourName == "hover")
				checkIScriptCaptureOption(manager, IScriptCaptureInteractionEvents()) && checkIScriptCaptureOption(manager, IScriptCaptureHover())
			else
				checkIScriptCaptureOption(manager, IScriptCaptureInteractionEvents());
		}
		ISClickEvent() : checkIScriptCaptureOption(manager, IScriptCaptureClickEvents());
		ISAppearanceEvent() : checkIScriptCaptureOption(manager, IScriptCaptureAppearanceEvents());
		ISValueEvent() : checkIScriptCaptureOption(manager, IScriptCaptureValueEvents());
		ISEnableEvent() : checkIScriptCaptureOption(manager, IScriptCaptureEnableEvents());
		ISSelectionEvent() : checkIScriptCaptureOption(manager, IScriptCaptureSelectionEvents());
		ISMiscEvent() : checkIScriptCaptureOption(manager, IScriptCaptureMiscEvents());
		ISWigiEvent() : checkIScriptCaptureOption(manager, IScriptCaptureWigiEvents());
		ISPebbleEvent() : checkIScriptCaptureOption(manager, IScriptCapturePebbleEvents());
		ISInputValue(__, __, __) : checkIScriptCaptureOption(manager, IScriptCaptureInputValues());
		ISCustomIScriptRecordType(__) : checkIScriptCaptureOption(manager, IScriptCaptureCustomTypes());
	}
}

checkIScriptCaptureOption(manager : MaterialManager, option : IScriptCaptureOption) -> bool {
	eitherMap(
		getIScriptRecording(manager),
		\r : IScriptRecording ->
			switch (option : IScriptCaptureOption) {
				IScriptCaptureCallstack() : (r.captureOptions).captureCallstack;
				IScriptCaptureTextDetails() : (r.captureOptions).captureTextDetails;
				IScriptCaptureHttpRequests() : (r.captureOptions).captureHttpRequests;
				IScriptCaptureMouseEvents() : (r.captureOptions).captureMouseEvents;
				IScriptCaptureKeyEvents() : (r.captureOptions).captureKeyEvents;
				IScriptCaptureInteractionEvents() : (r.captureOptions).captureInteractionEvents;
				IScriptCaptureHover() : (r.captureOptions).captureHover;
				IScriptCaptureClickEvents() : (r.captureOptions).captureClickEvents;
				IScriptCaptureAppearanceEvents() : (r.captureOptions).captureAppearanceEvents;
				IScriptCaptureValueEvents() : (r.captureOptions).captureValueEvents;
				IScriptCaptureEnableEvents() : (r.captureOptions).captureEnableEvents;
				IScriptCaptureSelectionEvents() : (r.captureOptions).captureSelectionEvents;
				IScriptCaptureInputValues() : (r.captureOptions).captureInputValues;
				IScriptCaptureWigiEvents() : (r.captureOptions).captureWigiEvents;
				IScriptCapturePebbleEvents() : (r.captureOptions).capturePebbleEvents;
				IScriptCaptureCustomTypes() : (r.captureOptions).captureCustomTypes;
				IScriptCaptureMiscEvents() : (r.captureOptions).captureMiscEvents;
			},
		false
	)
}

pauseIScriptRecording(manager : MaterialManager) -> void {
	switch(getIScriptState(manager) : IScriptState) {
		IScriptRecording(captureOptions, continueRecording) : {
			setIScriptState(manager, IScriptRecordingPaused(captureOptions, continueRecording))
		}
		default: {}
	}
}

resumeIScriptRecording(manager : MaterialManager) -> void {
	switch(getIScriptState(manager) : IScriptState) {
		IScriptRecordingPaused(captureOptions, continueRecording) : {
			setIScriptState(manager, IScriptRecording(captureOptions, continueRecording))
		}
		default: {}
	}
}

mapIScriptStack(stack : Tree<double, [IScriptRecord]>, fn : (double, IScriptRecord) -> ?) -> [?] {
	foldIScriptStack(stack, [], \acc, delay, record -> arrayPush(acc, fn(delay, record)))
}

filtermapIScriptStack(stack : Tree<double, [IScriptRecord]>, fn : (double, IScriptRecord) -> Maybe<?>) -> [?] {
	foldIScriptStack(stack, [], \acc, delay, record -> eitherMap(fn(delay, record), \r -> arrayPush(acc, r), acc))
}

foldIScriptStack(stack : Tree<double, [IScriptRecord]>, init : ?, fn : (?, double, IScriptRecord) -> ?) -> ? {
	foldTree(stack, init, \delay, records, acc -> {
		fold(records, acc, \acc2, record -> fn(acc2, delay, record))
	})
}

foldRIScriptStack(stack : Tree<double, [IScriptRecord]>, init : ?, fn : (?, double, IScriptRecord) -> ?) -> ? {
	foldRTree(stack, init, \delay, records, acc -> {
		fold(reverseA(records), acc, \acc2, record -> fn(acc2, delay, record))
	})
}

mapIScriptStackTree(stack : Tree<double, [IScriptRecord]>, fn : (double, IScriptRecord) -> IScriptRecord) -> Tree<double, [IScriptRecord]> {
	mapTree2(stack, \delay, records -> map(records, \record -> fn(delay, record)))
}

filterIScriptStackTree(stack : Tree<double, [IScriptRecord]>, fn : (double, IScriptRecord) -> bool) -> Tree<double, [IScriptRecord]> {
	mapTree2(stack, \delay, records -> filter(records, \record -> fn(delay, record)))
}

filtermapIScriptStackTree(stack : Tree<double, [IScriptRecord]>, fn : (double, IScriptRecord) -> Maybe<IScriptRecord>) -> Tree<double, [IScriptRecord]> {
	mapTree2(stack, \delay, records -> filtermap(records, \record -> fn(delay, record)))
}

foldIScriptStackTree(stack : Tree<double, [IScriptRecord]>, init : ?, fn : (?, double, IScriptRecord) -> ?) -> ? {
	foldTree(stack, init, \delay, records, acc -> fold(records, acc, \acc2, record -> fn(acc2, delay, record)))
}

foldRIScriptStackTree(stack : Tree<double, [IScriptRecord]>, init : ?, fn : (?, double, IScriptRecord) -> ?) -> ? {
	foldRTree(stack, init, \delay, records, acc -> fold(reverseA(records), acc, \acc2, record -> fn(acc2, delay, record)))
}

findIScriptLastRecordKeyValue(stack : Tree<double, [IScriptRecord]>) -> Maybe<Pair<double, IScriptRecord>> {
	foldIScriptStackTree(stack, None(), \acc, k, v -> {
			if (isNone(acc) || k > either(acc, Pair(k, v)).first) {
				Some(Pair(k, v))
			} else {
				acc
			}
		}
	);
}

findIScriptLastRecordKey(stack : Tree<double, [IScriptRecord]>) -> Maybe<double> {
	maybeMap(
		findIScriptLastRecordKeyValue(stack),
		\v -> v.first
	);
}

extractIScriptLastRecord(stack : Tree<double, [IScriptRecord]>) -> Maybe<IScriptRecord> {
	maybeMap(
		findIScriptLastRecordKeyValue(stack),
		\v -> v.second
	);
}

findIScriptLastRecordKeyValueOfType(stack : Tree<double, [IScriptRecord]>, type : IScriptRecord) -> Maybe<Pair<double, IScriptRecord>> {
	foldIScriptStackTree(stack, None(), \acc, k, v -> {
			if (isSameStructType(v, type)) {
				if (isNone(acc) || k > either(acc, Pair(k, v)).first) {
					Some(Pair(k, v))
				} else {
					acc
				}
			} else {
				acc
			}
		}
	);
}

findIScriptLastRecordKeyOfType(stack : Tree<double, [IScriptRecord]>, type : IScriptRecord) -> Maybe<double> {
	maybeMap(
		findIScriptLastRecordKeyValueOfType(stack, type),
		\v -> v.first
	);
}

extractIScriptLastRecordOfType(stack : Tree<double, [IScriptRecord]>, type : IScriptRecord) -> Maybe<IScriptRecord> {
	maybeMap(
		findIScriptLastRecordKeyValueOfType(stack, type),
		\v -> v.second
	);
}

addIScriptStackRecord(stack : Tree<double, [IScriptRecord]>, record : IScriptRecord) -> Tree<double, [IScriptRecord]> {
	addIScriptStackRecordWithDelay(stack, getIScriptStackDelay(stack), record)
}

addIScriptStackRecordWithDelay(stack : Tree<double, [IScriptRecord]>, delay : double, record : IScriptRecord) -> Tree<double, [IScriptRecord]> {
	treePushToArrayValue(stack,
		delay,
		record
	)
}

replaceRecordInIScriptStack(stack : Tree<double, [IScriptRecord]>, delay : double, prevValue : IScriptRecord, nextValue : IScriptRecord) -> Tree<double, [IScriptRecord]> {
	treePushToArrayValue(
		treeRemoveFromArrayValue(stack, delay, prevValue),
		delay,
		nextValue
	)
}

getIScriptStackDelay(stack : Tree<double, [IScriptRecord]>) -> double {
	lastElement(sort(getTreeKeys(stack)), 0.)
}

getMaterialFocusById(parent : MFocusGroup, id : [int]) -> Maybe<MaterialFocus> {
	if (length(id) > 0)
		eitherMap(
			lookupTree(getValue(parent.focusIds), id[0]),
			\p ->
				switchMaterialFocus(
					p,
					\f ->
						if (length(id) == 1)
							Some(f)
						else
							None(),
					\f ->
						if (length(id) == 1)
							Some(f)
						else
							getMaterialFocusById(f, tail(id))
				),
			None()
		)
	else
		Some(parent)
}

getMaterialFocusByUniqueId(parent : MFocusGroup, id : string) -> Maybe<MaterialFocus> {
	iScriptIdParent =
		if (isSome(parent.iScriptId))
			parent
		else
			getIScriptUniqueIdParent(parent);

	lookupTree(getValue(iScriptIdParent.iScriptIds), id);
}

getMaterialFocusByIScriptId(parent : MFocusGroup, id : List<IScriptIdentifier>) -> Maybe<MaterialFocus> {
	maybeBind(
		switch (headList(id, IScriptFocusTreePosition(0)) : IScriptIdentifier) {
			IScriptFocusTreePosition(treePosition): {
				getMaterialFocusById(parent, [treePosition])
			}
			IScriptId(iScriptId): {
				getMaterialFocusByUniqueId(parent, iScriptId)
			}
			default: None()
		},
		\mf -> {
			if (countList(id) > 1) {
				switchMaterialFocus(
					mf,
					\__ -> None(),
					\f -> getMaterialFocusByIScriptId(f, tailList(id))
				)
			} else {
				Some(mf)
			}
		}
	)
}

collectMaterialFocuses(focusTree : Tree<int, MaterialFocus>, test : (MaterialFocus) -> bool) -> Tree<string, [MaterialFocus]> {
	foldTree(
		focusTree,
		makeTree(),
		\__, focus : MaterialFocus, acc : Tree<string, [MaterialFocus]> -> {
			key = either(focus.iScriptId, "");
			focusOk = test(focus);
			switchMaterialFocus(
				focus,
				\__ -> {
					if (focusOk) {
						setTree(acc, key, arrayPush(lookupTreeDef(acc, key, []), focus))
					} else {
						acc
					}
				},
				\mFocusGroup -> {
					mergeTreeCustom(
						if (focusOk) {
							setTree(acc, key, arrayPush(lookupTreeDef(acc, key, []), focus))
						} else {
							acc
						},
						collectMaterialFocuses(getValue(mFocusGroup.focusIds), test),
						\__, v1, v2 -> concat(v2, v1)
					)
				}
			)
		}
	)
}

getFocusById(parent : MFocusGroup, id : [int]) -> Maybe<MFocus> {
	eitherMap(getMaterialFocusById(parent, id), \mf -> switchMaterialFocus(mf, \f -> Some(f), \__ -> None()), None())
}

getFocusGroupById(parent : MFocusGroup, id : [int]) -> Maybe<MFocusGroup> {
	eitherMap(getMaterialFocusById(parent, id), \mf -> switchMaterialFocus(mf, \__ -> None(), \f -> Some(f)), None())
}

addIScriptRecord(manager : MaterialManager, record : IScriptRecord) -> void {
	addIScriptRecordWithDelay(manager, getIScriptDelay(manager), record);
}

addIScriptRecordWithDelayStyle(manager : MaterialManager, delayStyle : ISRecDelayStyle, record : IScriptRecord) -> void {
	delayValue = switch (delayStyle : ISRecDelayStyle) {
		ISRecCurrentDelay() : getIScriptDelay(manager);
        ISRecDelay(delay) : delay;
        ISRecFirst() : {
			delays = getTreeKeys(getValue(manager.iscript.script).stack);
			fold(delays, delays[0], min)
		};
        ISRecLast() : {
			delays = getTreeKeys(getValue(manager.iscript.script).stack);
			fold(delays, delays[0], max)
		}
	}

	addIScriptRecordWithDelay(manager, delayValue, record);
}

addIScriptRecordWithDelay(manager : MaterialManager, delay : double, record : IScriptRecord) -> void {
	rs : IScript = getValue(manager.iscript.script);

	switch (record) {
		IScriptInputRecord(__, name, __, typeHint) : {
			next(manager.iscript.input, arrayPush(getValue(manager.iscript.input), IScriptInputValue(name, typeHint, None())));
		}
		IScriptOutputRecord(__, name) : {
			next(manager.iscript.output, arrayPush(getValue(manager.iscript.output), IScriptOutputValue(name, false, None())));
		}
		default : {}
	}

	next(
		manager.iscript.script,
		IScript(
			rs.recordingStarted,
			treePushToArrayValue(
				rs.stack,
				delay,
				record
			)
		)
	)
}

addIScriptBehaviourRecord(
	manager : MaterialManager,
	componentName : string,
	behaviourName : string,
	value : flow,
	id : List<IScriptIdentifier>,
	type : IScriptRecordType,
	callstack : string
) -> void {

	if (!checkIsFn(serialize(value)) && checkIScriptRecordTypeCaptureOption(manager, behaviourName, type)) {
		addIScriptRecord(
			manager,
			IScriptBehaviourRecord(
				IScriptBehaviourDescriptor(IScriptComponentDescriptor(componentName, id), behaviourName),
				value,
				type,
				callstack
			)
		)
	}
}

addIScriptBehaviourRecordWithDelay(
	manager : MaterialManager,
	delay : double,
	componentName : string,
	behaviourName : string,
	value : flow,
	id : List<IScriptIdentifier>,
	type : IScriptRecordType,
	callstack : string
) -> void {

	if (!checkIsFn(serialize(value)) && checkIScriptRecordTypeCaptureOption(manager, behaviourName, type)) {
		addIScriptRecordWithDelay(
			manager,
			delay,
			IScriptBehaviourRecord(
				IScriptBehaviourDescriptor(IScriptComponentDescriptor(componentName, id), behaviourName),
				value,
				type,
				callstack
			)
		)
	}
}

addIScriptRequestRecord(manager : MaterialManager, url : string, post : bool, headers : [KeyValue], params : [KeyValue], delay : double,
	response : IScriptRequestRespose) -> void {

	if (checkIScriptCaptureOption(manager, IScriptCaptureHttpRequests())) {
		addIScriptRecord(
			manager,
			IScriptRequestRecord(url, post, headers, params, delay, response)
		);
	}
}

iScriptInfo(manager : MaterialManager, text : string, id : Maybe<List<IScriptIdentifier>>) -> void {
	if (getValue(manager.iscript.settings.replayVerbose)) {
		idStr = switch (id : Maybe<List<IScriptIdentifier>>) {
			None(): "";
			Some(v): " : " + IScriptId2s(v);
		};
		println("ISCRIPT: " + text + idStr);
	}
}

iScriptError(manager : MaterialManager, error : string, id : Maybe<List<IScriptIdentifier>>) -> void {
	next(manager.iscript.errors, Cons(IScriptError(error, id), getValue(manager.iscript.errors)));

	if (getValue(manager.iscript.settings.replayVerbose)) {
		idStr = switch (id : Maybe<List<IScriptIdentifier>>) {
			None(): "";
			Some(v): " : " + IScriptId2s(v);
		};
		println("ISCRIPT ERROR: " + error + idStr);
	}
}

addGlobalAliasInIScript(manager : MaterialManager, focus : MaterialFocus, alias : string) -> void {
	next(
		manager.iscript.aliases,
		setTree(
			getValue(manager.iscript.aliases),
			IScriptComponentDescriptor(focus.name, getFullMFocusId(focus)),
			alias
		)
	);
}

addIScriptUrlRecord(manager : MaterialManager, url : string) -> void {
	addIScriptRecord(manager, IScriptUrlRecord(url));
}

replaceRecordInIScript(manager : MaterialManager, prevRecord : Pair<double, IScriptRecord>, record : Pair<double, IScriptRecord>) -> void {
	removeRecordFromIScript(manager, prevRecord);
	addIScriptRecordWithDelay(manager, record.first, record.second);
}

removeRecordFromIScript(manager : MaterialManager, record : Pair<double, IScriptRecord>) -> void {
	is = getValue(manager.iscript.script);

	switch (record.second) {
		IScriptInputRecord(__, name, __, typeHint) : {
			inputValues = getValue(manager.iscript.input);
			inputValueIndex = findiDef(inputValues, \inputValue -> inputValue.name == name, -1);
			next(manager.iscript.input, removeIndex(inputValues, inputValueIndex));
		}
		IScriptOutputRecord(__, name) : {
			outputValues = getValue(manager.iscript.output);
			outputValueIndex = findiDef(outputValues, \outputValue -> outputValue.name == name, -1);
			next(manager.iscript.output, removeIndex(outputValues, outputValueIndex));
		}
		default : {}
	}

	next(
		manager.iscript.script,
		IScript(
			is.recordingStarted,
			filterIScriptStackTree(is.stack, \d, r -> d != record.first || r != record.second)
		)
	);

	nextDistinct(manager.iscript.scriptChangedB, true);
}

initIScriptRecording(manager : MaterialManager, f : MaterialFocus, disposeOnRecordStopped : bool) -> () -> void {
	makeSubscribeUns(f.recordingEnabled, \en : bool -> {
		if (en)
			mapTree2(
				f.behaviours,
				\k, mb ->
					makeSubscribe2(mb.first, \v -> {
						id = getFullMFocusId(f);

						if (!containsList(id, IScriptFocusTreePosition(-1)) && !isIScriptRecordingPaused(manager)) {
							addIScriptBehaviourRecord(manager, f.name, k, v, id, mb.second, getCallstackIfNeeded(manager));
						}
					})()
			)
			|> getTreeValues
			// |> (\f2 ->
			// 	if (disposeOnRecordStopped)
			// 		arrayPush(
			// 			f2,
			// 			makeSubscribe2(manager.iscript.iScriptStateB, \iss : IScriptState ->
			// 				if (!isSameStructType(iss, IScriptRecording(defaultCaptureOptions, false)))
			// 					deferred(\ -> dispUnsA(disp))
			// 			)()
			// 		)
			// 	else
			// 		f2
			// )
		else
			[];
	})()
}

captureIScriptKeyEvent(manager : MaterialManager, handled : bool, k : KeyEvent, component : string, type : string) -> bool {
	if (!handled && isIScriptEnabled(manager)) {
		if (isIScriptRecording(manager) && checkIScriptCaptureOption(manager, IScriptCaptureKeyEvents())) {
			addIScriptBehaviourRecord(
				manager,
				component,
				type,
				KeyEventRecord(k.utf, k.ctrl, k.shift, k.alt, k.meta, k.keycode),
				makeList(),
				ISKeyEvent(),
				getCallstackIfNeeded(manager)
			)
		} else if (isIScriptReplaying(manager) || isIScriptScenarioReplaying(manager)) {
			iScriptInfo(manager, component + " " + type + ": " + toString(k), None());
		}
	}

	handled;
}

captureIScriptMouseEvent(manager : MaterialManager, handled : bool, miFn : () -> MouseInfo, canvasPosition : () -> Point, component : string, type : string) -> bool {
	if (!handled && isIScriptEnabled(manager)) {
		getPoint = \ -> {
			mi = miFn();
			p = canvasPosition();

			Point(mi.x + p.x, mi.y + p.y - 48.);
		};

		if (isIScriptRecording(manager) && checkIScriptCaptureOption(manager, IScriptCaptureMouseEvents())) {
			addIScriptBehaviourRecord(
				manager,
				component,
				type,
				getPoint(),
				makeList(),
				ISMouseEvent(),
				getCallstackIfNeeded(manager)
			)
		} else if (isIScriptReplaying(manager) || isIScriptScenarioReplaying(manager)) {
			iScriptInfo(manager, component + " " + type + ": " + toString(getPoint()), None());
		}
	}

	handled;
}

focusDownUns : ref List<() -> void> = ref makeList();
bufferedMouseDown : ref (bool) -> void = ref nop1;

captureIScriptMouseDownEvent(manager : MaterialManager, handled : bool, miFn : MouseDownInfo, canvasPosition : () -> Point, component : string) -> bool {
	if (!handled && isIScriptEnabled(manager)) {
		getPoint = \ -> {
			p = canvasPosition();

			Point(miFn.x + p.x, miFn.y + p.y - 48.);
		};

		delay = getIScriptDelay(manager) - 1.;

		updateBuffer = \path -> {
			bufferedMouseDown := \ending -> addIScriptBehaviourRecordWithDelay(
				manager,
				delay,
				component,
				"mousedown",
				getPoint(),
				if (!ending) eitherFn(path, getFullMFocusId, makeList) else makeList(),
				ISMouseEvent(),
				getCallstackIfNeeded(manager)
			)
		}

		addBufferedMouseDownAndDispose(false);

		if (isIScriptRecording(manager) && checkIScriptCaptureOption(manager, IScriptCaptureMouseEvents())) {
			updateBuffer(None());
			pressedItemB = getCurrentPressedItemBehaviour(manager);
			previousPressedB = make(None());
			focusDownUns := fsubscribe2(
				fsubselect(pressedItemB, FLift(\previousPressed -> {
					eitherMap(
						previousPressed,
						\pi -> {
							next(previousPressedB, Some(pi));
							pressedItemB
						},
						previousPressedB
					)
				})),
				updateBuffer
			);
			rlistPush(focusDownUns, interruptibleTimer(1000, \ -> addBufferedMouseDownAndDispose(false)))
		} else if (isIScriptReplaying(manager) || isIScriptScenarioReplaying(manager)) {
			iScriptInfo(manager, component + " mousedown: " + toString(getPoint()), None());
		}
	}

	handled;
}

addBufferedMouseDownAndDispose(ending : bool) -> void {
	if (^(bufferedMouseDown) != nop1 || ^focusDownUns != makeList()) {
		^bufferedMouseDown(ending);
		bufferedMouseDown := nop1;
		callList(^focusDownUns);
		focusDownUns := makeList();
	}
}

clearIScriptAdditionalInfo(manager : MaterialManager) -> void {
	nextDistinct(manager.iscript.errors, makeList());
	nextDistinct(manager.iscript.requests, makeList());

	nextDistinct(manager.iscript.output, []);
	nextDistinct(manager.iscript.input, []);
	nextDistinct(manager.iscript.aliases, makeTree());
}

clearCurrentIScript(manager : MaterialManager) -> void {
	clearIScriptAdditionalInfo(manager);

	next(
		manager.iscript.script,
		makeEmptyIScript()
	);
}

resumeCurrentIScript(manager : MaterialManager) -> void {
	iScript = getValue(manager.iscript.script);

	next(
		manager.iscript.script,
		IScript(
			// shifting recordingStarted to ignore paused time
			timestamp() - either(findIScriptLastRecordKey(getValue(manager.iscript.script).stack), 0.),
			iScript.stack
		)
	);
}

loadAdditionalIScriptInfo(manager : MaterialManager, additionalInfo : IScriptAdditionalInfo) -> void {
	next(manager.iscript.input, map(additionalInfo.inputs, \pair -> IScriptInputValue(pair.first, pair.second, None())));
	next(manager.iscript.output, map(additionalInfo.outputs, \outputName -> IScriptOutputValue(outputName, false, None())));
	next(manager.iscript.aliases, mergeTree(getValue(manager.iscript.aliases), pairs2tree(additionalInfo.aliases)));
}

prepareCurrentIScriptForSave(manager : MaterialManager) -> StoredIScript {
	prepareIScriptFromIScriptManagerForSave(manager.iscript)
}

prepareIScriptFromIScriptManagerForSave(ism : IScriptManager) -> StoredIScript {
	iScript = getValue(ism.script);
	aliases = getValue(ism.aliases);
	inputValues = getValue(ism.input);
	outputValues = getValue(ism.output);

	prepareIScriptForSave(iScript, aliases, inputValues, outputValues);
}

prepareIScriptForSave(
	iScript : IScript,
	aliases : Tree<IScriptComponentDescriptor, string>,
	inputValues : [IScriptInputValue],
	outputValues : [IScriptOutputValue]) {

	checkDescriptor = \descriptor : IScriptBehaviourDescriptor -> {
		alias = lookupTreeDef(aliases, descriptor.component, "");

		if (alias != "")
			Some(Pair(descriptor.component, alias))
		else
			None();
	}

	usedAliases = filtermapIScriptStack(iScript.stack, \delay, record -> {
		switch (record) {
			IScriptBehaviourRecord(descriptor, __, __, __) : checkDescriptor(descriptor);
			default : None();
		}
	});
	usedInputs = map(inputValues, \inputValue -> Pair(inputValue.name, inputValue.typeHelper));
	usedOutputs = map(outputValues, \outputValue -> outputValue.name);

	StoredIScript(
		storedIScriptCurrentVersion,
		IScriptAdditionalInfo(
			usedInputs,
			usedOutputs,
			usedAliases
		),
		IScript(
			iScript.recordingStarted,
			filtermapIScriptStackTree(
				iScript.stack,
				\delay, record ->
					switch (record : IScriptRecord) {
						IScriptScreenshot(__, __): {
							res : Maybe<IScriptRecord> = Some(filterIScriptScreenshot(record));
							res
						}
						IScriptLogicalScreenshot(__, __) : {
							Some(record)
						}
						default: {
							if (!checkIsFn(serialize(record)))
								Some(record)
							else
								None()
						}
					}
			)
		)
	)
}

filterIScriptScreenshot(screenshot : IScriptScreenshot) -> IScriptScreenshot {
	IScriptScreenshot(
		mapTree(
			screenshot.behaviours,
			\b -> filterTree(b, \k, v -> !checkIsFn(serialize(v)))
		),
		screenshot.check
	)
}

makeIScriptArrow(mainLength : double, mainHeight : double, arrowLength : double, arrowHeight : double, style : [TGraphicsStyle]) -> TGraphics {
	x1 = 0.;
	y1 = (arrowHeight - mainHeight) / 2.;
	x2 = x1;
	y2 = y1 + mainHeight;
	x3 = x1 + mainLength;
	y3 = y2;
	x4 = x3;
	y4 = y3 + y1;
	x5 = x4 + arrowLength;
	y5 = arrowHeight / 2.;
	x6 = x4;
	y6 = 0.;
	x7 = x6;
	y7 = y1;

	TGraphics(
		[
			MoveTo(x1, y1),
			LineTo(x2, y2),
			LineTo(x3, y3),
			LineTo(x4, y4),
			LineTo(x5, y5),
			LineTo(x6, y6),
			LineTo(x7, y7),
			ClosePath()
		],
		style
	)
}

makeSubscribe2focusHovered(manager : MaterialManager, focus : () -> Maybe<MaterialFocus>, hover : DynamicBehaviour<bool>) -> () -> () -> void {
	makeSubscribe2Uns(hover, \h ->
		if (h)
			eitherMap(
				focus(),
				\f -> [highlightMaterialFocus(manager, f)],
				[]
			)
		else
			[]
	)
}

highlightMaterialFocus(manager : MaterialManager, focus : MaterialFocus) -> () -> void {
	fillColor = switchMaterialFocus(focus, \__ -> MGreen(500), \__ -> MPurple(300));

	pos = applyTransformMatrix(fgetValue(focus.transformMatrix), zeroPoint);
	wh = fgetValue(focus.widthHeight);
	stage = getRealStageWidthHeight(manager);

	xTranscendMin = pos.x + wh.width < 0.;
	xTranscendMax = pos.x >= stage.width;
	yTranscendMin = pos.y + wh.height < 0.;
	yTranscendMax = pos.y >= stage.height;

	trender(
		if (xTranscendMin || xTranscendMax || yTranscendMin || yTranscendMax) {
			TTranslate(
				const(Point(min(max(pos.x + wh.width / 2., 0.), stage.width), min(max(pos.y + wh.height / 2., 0.), stage.height))),
				TRotate(
					const(if (xTranscendMin) {
						if (yTranscendMin) {
							180. + 45.
						} else if (yTranscendMax) {
							180. - 45.
						} else {
							180.
						}
					} else if (xTranscendMax) {
						if (yTranscendMin) {
							0. + 45.
						} else if (yTranscendMax) {
							0. - 45.
						} else {
							0.
						}
					} else if (yTranscendMin) {
						270.
					} else {
						90.
					}),
					TTranslate(
						const(Point(-40., -10.)),
						makeIScriptArrow(
							20.,
							8.,
							10.,
							20.,
							[
								MFill(fillColor),
								FillOpacity(0.8),
								MStroke(fillColor),
								StrokeWidth(1.),
								StrokeOpacity(1.)
							]
						)
					)
				)
			)
		} else {
			TTranslate(
				const(pos),
				TRounded(
					4.0,
					4.0,
					4.0,
					4.0,
					[
						MFill(fillColor),
						FillOpacity(0.3),
						MStroke(fillColor),
						StrokeWidth(1.),
						StrokeOpacity(1.)
					],
					TSized(const(wh))
				)
			)
		},
		manager.manager.renderStyle
	)
}

getIScriptPairValueB(
	behaviours : Tree<string, Pair<DynamicBehaviour<flow>, IScriptRecordType>>,
	key : string,
	def : DynamicBehaviour<flow>
) -> DynamicBehaviour<flow> {
	eitherMap(lookupTree(behaviours, key), firstOfPair, def)
}

getIScriptPairValueBM(
	behaviours : Tree<string, Pair<DynamicBehaviour<flow>, IScriptRecordType>>,
	key : string
) -> Maybe<DynamicBehaviour<flow>> {
	eitherMap(lookupTree(behaviours, key), \bp -> Some(bp.first), None())
}