import material/internal/material_component;
import material/internal/material_ellipsis;
import material/internal/material_icons;

export {
	MListLine2Height(line : MListLine, listState : MListInnerState) -> double;
	MListLine2T(parent : MFocusGroup, i : Transform<int>, line : Transform<MListLine>, listState : MListInnerState, down : DynamicBehaviour<bool>) -> Tropic;

	MListInnerState(
		manager : MaterialManager,
		m2t : (Material, MFocusGroup) -> Tropic,
		width : MListWidth,
		emptyMessage : Maybe<Material>,
		reorder : Maybe<MListReorder>,
		reorderShowIcon : bool,
		minimize : Transform<bool>,
		minimizedWidth : double,
		selection : MListSelection,
		condensed : bool,
		lightBackground : bool,
		color : Pair<MColor, MColor>,
		bgStyle : Pair<[TGraphicsStyle], [TGraphicsStyle]>,
		separators : bool,
		ellipsis : bool,
		onClick : (int) -> void,
		hoverEnabled : Transform<bool>,
		enabled : Transform<bool>,
		collapseUnactive : bool,
		currentSubmenu : ref Maybe<DynamicBehaviour<bool>>,
		sideBorders : Transform<double>,
		primaryActionWidth : Transform<double>,
		subs : [() -> () -> void]
	);

	defaultListState(manager : MaterialManager, parent : MFocusGroup, m2t : (Material, MFocusGroup) -> Tropic) -> MListInnerState;
	makeMListInnerState(listState : MListInnerState, state : [flow]) -> MListInnerState;

	hoverLine(tr : Tropic, lightBackground : bool) -> Tropic {
		TRectangle([
				Fill(if (lightBackground) black else white),
				FillOpacity(if (lightBackground) 0.04 else 0.08)
			], tr
		)
	}

	pressedLine(tr : Tropic, lightBackground : bool) -> Tropic {
		TRectangle([
				Fill(if (lightBackground) black else white),
				FillOpacity(if (lightBackground) 0.16 else 0.32)
			], tr
		)
	}

	MListOnClickHandler(selection : MListSelection, selectionEnabled : MListSelectionEnabled, onListClick : MOnListClick) -> (int) -> void;

	// Construct line with MList interactions: down, hover, selection
	makeTListLine(lightBackground : bool, line : Tropic, focus : MFocus, selected : Transform<bool>, hoverEnabled : Transform<bool>,
		bgStyle : [TGraphicsStyle], selectedBgStyle : [TGraphicsStyle]) -> Tropic;
	makeMListLine(line : Material, focus : MFocus, selected : Transform<bool>, hoverEnabled : Transform<bool>,
		bgStyle : [TGraphicsStyle], selectedBgStyle : [TGraphicsStyle]) -> Material;

	MListAddAvailable(state : MListInnerState) -> (Tropic) -> Tropic;

	MListIcon2T(manager : MaterialManager, content : Material, color : MColor, selectedColor : MColor,
		m2t : (Material, MFocusGroup) -> Tropic) -> Pair<(bool, MFocusGroup) -> Tropic, bool>;
}

getPrimaryAction(state : [MListLineState], listState : MListInnerState) -> Maybe<Pair<(bool, MFocusGroup) -> Tropic, bool>> {
	eitherMap(
		tryExtractStruct(state, MPrimaryAction(TEmpty())),
		\pa ->
			Some(MListIcon2T(listState.manager, pa.content, listState.color.first, listState.color.second, listState.m2t)),
		None()
	);
}

getSecondaryAction(state : [MListLineState], listState : MListInnerState) -> Maybe<Material> {
	eitherFn(
		tryExtractStruct(state, MSecondaryAction(TEmpty())),
		\sa ->
			eitherMap(
				tryExtractStruct(state, MAdditionalText("")),
				\txt -> Some(MCols2(sa.content, MText(txt.text, [MSubheading()]))),
				Some(sa.content)
			),
		\ ->
			eitherMap(
				tryExtractStruct(state, MAdditionalText("")),
				\txt -> Some(MText(txt.text, [MSubheading()])),
				None()
			)
	);
}

MListLine2Height(line : MListLine, listState : MListInnerState) -> double {
	switch (line : MListLine) {
		MSingleLine(__, state0): extractStruct(state0, MHeight(if (listState.condensed) 40. else 48. +
			eitherMap(getPrimaryAction(state0, listState), \sa -> if (sa.second) 8. else 0., 0.))).height;
		MDoubleLine(__, __, state0): extractStruct(state0, MHeight(if (listState.condensed) 60. else 72.)).height;
		MTripleLine(__, __, state0): extractStruct(state0, MHeight(if (listState.condensed) 76. else 88.)).height;
		MCustomLine(content0, state0):
			eitherFn(
				tryExtractStruct(state0, MHeight(-1.0)),
				\hgt -> hgt.height,
				\ -> getTWordMetrics(TAvailable(listState.m2t(content0, dummyParent(listState.manager)), TEmpty()), makeTree()).height
			);
		MSubmenuLine(__, __, __, __): 1.;
		MSeparatorLine(): if (listState.condensed) 9. else 17.;
	}
}

MListLine2T(parent : MFocusGroup, i : Transform<int>, line : Transform<MListLine>, listState : MListInnerState, down : DynamicBehaviour<bool>) -> Tropic {
	lineHeight = fselect(line, FLift(\ln -> MListLine2Height(ln, listState)));
	m2t = listState.m2t;

	makeMLine = \p -> {
		name = fselect(line, FLift(\ln -> ln.structname));
		state : Transform<[MListLineState]> =
			fselect(line, FLift(\ln ->
				switch (ln : MListLine) {
					MSingleLine(__, state0): state0;
					MDoubleLine(__, __, state0): state0;
					MTripleLine(__, __, state0): state0;
					MCustomLine(__, state0): state0;
					default: [];
				}
			));
		content : Transform<Maybe<Material>> =
			fselect(line, FLift(\ln ->
				switch (ln : MListLine) {
					MCustomLine(content, __): Some(content);
					default: None();
				}
			));
		title : Transform<string> =
			fselect(line, FLift(\ln ->
				switch (ln : MListLine) {
					MSingleLine(title, __): title;
					MDoubleLine(title, __, __): title;
					MTripleLine(title, __, __): title;
					default: fgetValue(extractStruct(fgetValue(state), MButtonTitle(const(""))).title);
				}
			));
		subtitle : Transform<Pair<string, int>> =
			fselect(line, FLift(\ln ->
				switch (ln : MListLine) {
					MDoubleLine(__, subtitle, __): Pair(subtitle, 1);
					MTripleLine(__, subtitle, __): Pair(subtitle, 2);
					default: Pair("", -1);
				}
			));

		defTextStyle : [MTextStyle] = [if (listState.condensed) MDataRow() else MSubheading()];
		defSecondaryTextStyle : [MTextStyle] = [if (listState.condensed) MCaption() else MListBody()];
		primaryAction : Transform<Maybe<Pair<(bool, MFocusGroup) -> Tropic, bool>>> =
			fselect(state, FLift(\st -> getPrimaryAction(st, listState)));
		secondaryAction : Transform<Maybe<Material>> =
			fselect(state, FLift(\st -> getSecondaryAction(st, listState)));
		sideBorders = listState.sideBorders;
		primaryWidth : Transform<double> = listState.primaryActionWidth;

		textStyle : Transform<[MTextStyle]> =
			fselect(state, FLift(\st -> extractStruct(st, MCustomTextStyle(defTextStyle)).style));
		secondaryTextStyle : Transform<[MTextStyle]> =
			fselect(state, FLift(\st -> extractStruct(st, MCustomSecondaryTextStyle(defSecondaryTextStyle)).style));

		hoverEnabled : Transform<bool> = listState.hoverEnabled;
		enabled : Transform<bool> =
			fsubselect(state, FLift(\st -> extractStruct(st, MEnabled(const(true))).enabled));

		hovering = make(false);
		onClick = \ -> {
			extractStruct(fgetValue(state), MOnClick(nop)).click();
			listState.onClick(fgetValue(i));
		};
		selected = fselect2(listState.selection.selected, i, FLift2(contains));
		focusSelected = extractStruct(fgetValue(state), MSelected(make(fgetValue(selected)))).selected;

		focusState : [flow] =
			replaceStructMany(
				extractMButtonState(fgetValue(state)),
				[
					MOnClick(onClick),
					MEnabled(enabled),
					MSelected(focusSelected),
					AccessRole("listitem"),
					MFocusEnabled(hoverEnabled),
					MAddFocusGroup(true),
					MRippleType(fif(hoverEnabled, const(MRippleFill()), const(MNoRipple()))),
					MHighlightOnFocus(const(true)),
					MHighlightOnHover(const(true)),
					// MHighlightOnSelect(const(true)),
					MCursorShape(fif(hoverEnabled, const(FingerCursor()), const(DefaultCursor()))),
					MButtonTitle(fselect2(title, subtitle, FLift2(\t, st -> trim(t + " " + st.first)))),
					THovering(hovering)
				]
			)
			|> (\fs -> ifArrayPush(fs, isSome(listState.reorder), MAdditionalRollOutCheck()));

		primaryAc = \p2 ->
			TSelect(primaryAction, \pac ->
				eitherMap(
					pac,
					\pa : Pair<(bool, MFocusGroup) -> Tropic, bool> ->
						MIfPreRender2T(
							listState.manager,
							p2,
							selected,
							\par -> pa.first(true, par),
							\par -> pa.first(false, par),
							false
						)
						|> (\f -> TCenterYIn(f, TSizedHeight(0., lineHeight)))
						|> (\t -> TTweak(
							[TAlign(fif(listState.minimize, const(0.5), const(b2d(p2.rtl))), const(0.))],
							t,
							TSizedHeight(listState.minimizedWidth, lineHeight)
						))
						|> (\f -> TCropSize(TSizedWidthHeight(primaryWidth, lineHeight), f)),
					TEmpty()
				)
			);

		isReorderIconEnabled = fand(
			eitherMap(listState.reorder, \r -> r.enabled, const(false)),
			const(listState.reorderShowIcon)
		);

		reorderIcon = \p2 ->
			TIfLazy(isReorderIconEnabled, \isRIE ->
				if (isRIE)
					listState.m2t(
						MTooltip(
							MIcon("drag_handle", [])
							|> MCenterY
							|> MBorderStart(16.),
							MText("Drag the item to reorder the list", []),
							[]
						), p2
					)
					|> (\t -> TInteractive([TMouseDown(make(false))], t))
				else
					TEmpty()
			);

		secondaryAc = \p2 ->
			TSelect(secondaryAction, \sac ->
				eitherMap(
					sac,
					\sa ->
						listState.m2t(sa, p2)
						|> (\t -> TBorder(8., 0., 0., 0., t))
						|> (\f -> TCenterYIn(f, TSizedHeight(0., lineHeight))),
					TEmpty()
				)
			);

		minimize = \f ->
			TShowLazy(fnot(listState.minimize), f);

		addActions = \p2 -> \f ->
			TBaselineCols2Dir(
				primaryAc(p2),
				(\ -> TBaselineCols2Dir(f, secondaryAc(p2), p2.rtl))
				|> minimize,
				p2.rtl
			);

		makeText = \p2, ttl -> \sel -> {
			color : MColor = if (sel) listState.color.second else listState.color.first;
			TSelect(textStyle, \tst : [MTextStyle] ->
				if (listState.ellipsis)
					MEllipsisText2T(listState.manager, p2, MEllipsisText(ttl, concat([color, MShowTooltip(const(true))], tst)), m2t)
				else
					MText2T(p2, ttl, arrayPush(tst, color))
			)
		};

		makeSubText = \p2, sbttl -> \sel -> {
			color : MColor = if (sel) listState.color.second else listState.color.first;
			TSelect(secondaryTextStyle, \stst : [MTextStyle] ->
				if (listState.ellipsis)
					MEllipsisText2T(
						listState.manager,
						p2,
						MEllipsisText(sbttl.first, concat([color, MShowTooltip(const(true)), MMaxLines(sbttl.second)], stst)),
						m2t
					)
				else
					MText2T(p2, sbttl.first, arrayPush(stst, color))
			)
		};

		(\p2 ->
			TSelect(content, \cc ->
				eitherFn(
					cc,
					\c ->
						TGroup2(
							(\ -> listState.m2t(MAlignStart(c), p2))
							|> minimize,

							TFillX()
							|> addActions(p2)
						)
						|> (\f -> TAvailable(f, TFillXHT(fmax(const(0.), lineHeight)))),
					\ ->
						TSelect(title, \ttl ->
							if (ttl == "")
								TFillX()
							else
								TIfLazy(selected, makeText(p2, ttl))
								|> (\f ->
									TSelect(subtitle, \sbttl ->
										if (sbttl.second > 0)
											TLines2Dir(
												f |> TBorderBottom(2.),
												TIfLazy(selected, makeSubText(p2, sbttl)),
												p2.rtl
											)
										else
											f
									)
								)
								|> (\t -> TAlignStartDir(t, p2.rtl))
								|> (\f -> TCenterYIn(f, TFillXHT(lineHeight)))
						)
						|> addActions(p2)
						|> (\f -> TIfLazy(isReorderIconEnabled, \isRIE ->
								if (isRIE) TCopySize2(f, \size, t ->
									TGroup2(t, TInteractive([TMouseDownGhost(down)], size))
								) else f)
						)
				)
			)
			|> (\t -> TCols2Dir(t, reorderIcon(p2), p2.rtl))
			|> (\t -> TBorderT(sideBorders, const(0.), sideBorders, const(0.), t))
		)
		|> (\f ->
			MComponent2T(
				listState.manager,
				p,
				if (isFConst(name)) fgetValue(name) else "MDynamicListLine",
				focusState,
				\focus ->
					TAlpha(
						fif(focus.enabled, const(1.), const(if (getLightBackground(parent)) 0.26 else 0.3)),
						TCopySize(
							f(focus.parent),
							\tr ->
								TIf(
									selected,
									TFrame(0., 0., listState.bgStyle.second, tr),
									TFrame(0., 0., listState.bgStyle.first, tr)
								),
							false
						)
					),
				m2t
			)
		)
		|> (\f -> TAvailable(f, TFillX()))
		|> (\f ->
			TConstruct(
				[
					\ -> fBidirectionalLink(
						selected,
						focusSelected,
						\s -> {
							nextDistinct(focusSelected, s);
						},
						\fs -> {
							nextDistinct(
								listState.selection.selected,
								if (fs)
									removeFirst(fgetValue(listState.selection.selected), fgetValue(i))
								else
									arrayPush(fgetValue(listState.selection.selected), fgetValue(i))
							);
						}
					),
					makeSubscribeUns(
						state,
						\st ->
							eitherFn(
								tryExtractStruct(st, THovering(hovering)),
								\h -> [bidirectionalLink(h.hovering, hovering, idfn, idfn)],
								\ -> {
									nextDistinct(hovering, false);
									[]
								}
							)
					)
				],
				f
			)
		)
		|> (\f -> MListAddLeaveBehinds(p, f, listState, enabled, state, m2t))
		|> if (isFConst(lineHeight) && fgetValue(lineHeight) > 0.) makeTropicConstantHeight(fgetValue(lineHeight) |> Some) else idfn
	};

	makeSubmenuLine = \p -> {
		subStyle : Transform<[MSubListStyle]> =
			fselect(line, FLift(\ln ->
				switch (ln : MListLine) {
					MSubmenuLine(__, __, subStyle, __): subStyle;
					default: [];
				}
			));

		subLines : Transform<[MListLine]> =
			fsubselect(line, FLift(\ln ->
				switch (ln : MListLine) {
					MSubmenuLine(__, subLines, __, __): subLines;
					default: const([]);
				}
			));

		subMain : Transform<MListLine> =
			fselect(line, FLift(\ln ->
				switch (ln : MListLine) {
					MSubmenuLine(subMain, __, __, __): subMain;
					default: MSingleLine("", []);
				}
			));

		expandedT : Transform<bool> =
			fsubselect(line, FLift(\ln ->
				switch (ln : MListLine) {
					MSubmenuLine(__, __, __, expanded): expanded;
					default: const(false);
				}
			));
		expanded = make(fgetValue(expandedT));

		subListState = fselect(subStyle, FLift(\style : [MSubListStyle] ->
			makeMListInnerState(listState, style)));

		selectedT = fsubselect(subListState, FLift(\sls : MListInnerState -> sls.selection.selected));
		selected = make(fgetValue(selectedT));

		subList = \ ->
			MSelect2T(
				listState.manager,
				p,
				"MListSubList",
				[
					IScriptBehaviour("selected", selected, ISInputValue([], "[int]", true)),
					IScriptBehaviour("expanded", expanded, ISInputValue([], "bool", false))
				],
				subLines,
				\sl, par ->
					mapi(sl, \j, l -> TSelect(subListState, \sls -> MListLine2T(par, const(j), const(l), sls, down)))
					|> TLines
			);
		yFact = make(b2d(fgetValue(expanded)));
		factor = fselect(yFact, FLift(\f -> Factor(1., f)));
		enabled = fsubselect(subStyle, FLift(\ss -> extractStruct(ss, MEnabled(const(true))).enabled));
		customExpanding = fselect(subStyle, FLift(\ss -> contains(ss, MCustomExpanding())));
		noDispose = fselect(subStyle, FLift(\ss -> contains(ss, MNoDispose())));

		TLines2(
			fif(customExpanding, subMain, addClickToSubMain(subMain, expanded))
			|> (\f -> MListLine2T(p, i, f, listState, down)),
			TCopySize2(
				TSelect(noDispose, \nd ->
					if (nd)
						TRenderOnce(fneq(yFact, 0.), subList)
					else
						TShowLazy(fneq(yFact, 0.), subList)
				),
				\tr, t ->
					MEasingAnimation(
						listState.manager,
						p,
						const(easingTransitionDuration),
						const(easingStandartCurve),
						expanded,
						\v -> {
							maybeApply(
								^(listState.currentSubmenu),
								\cs -> {
									if (v) {
										nextDistinct(cs, false);

										listState.currentSubmenu := Some(expanded);
									} else if (cs == expanded) {
										listState.currentSubmenu := Some(make(false));
									}
								}
							);

							Some(v)
						},
						\v, px -> next(yFact, if (v) px else (1. - px)),
						[],
						TCropSize(TScale(factor, tr), t)
					)
			)
		)
		|> (\f ->
			TConstruct(
				[
					makeSubscribe(expandedT, \ex -> nextDistinct(expanded, ex)),
					makeSubscribe2(expanded, \ex -> {
						switch (fgetValue(line) : MListLine) {
							MSubmenuLine(__, __, __, expanded_): nextDistinct(expanded_, ex);
							default: {}
						}
					}),
					makeSubscribe(selectedT, \sel -> nextDistinct(selected, sel)),
					makeSubscribe2(selected, \sel -> nextDistinct(fgetValue(subListState).selection.selected, sel))
				],
				f
			)
		)
		|> (\f -> MListAddLeaveBehinds(p, f, listState, enabled, const([]), m2t))
	}

	makeSeparatorLine = \p -> {
		padding = if (listState.condensed) 4. else 8.;

		MSeparator2T(listState.manager, p, true)
		|> TBorderTopBottom(padding);
	}

	MComponentGroup2T(listState.manager, parent, "MListLine", [MFocusId(i)], \p ->
		TSelect(
			fselect(line, FLift(\ln ->
				switch (ln : MListLine) {
					MSubmenuLine(__, __, __, __): makeSubmenuLine;
					MSeparatorLine(): makeSeparatorLine;
					default: makeMLine;
				}
			)),
			\fn -> fn(p)
		)
	)
}

addClickToSubMain(subMain : Transform<MListLine>, expanded : DynamicBehaviour<bool>) -> Transform<MListLine> {
	lineClick = \listLineState : [MListLineState] -> {
		click = tryExtractStruct(listLineState, MOnClick(nop));

		replaceStruct(
			listLineState,
			MOnClick(\ -> {
				maybeApply(click, \cl -> cl.click());
				reverseBehaviour(expanded)
			})
		)
	}

	fselect(subMain, FLift(\sm ->
		switch (sm : MListLine) {
			MSingleLine(title, state): MSingleLine(title, lineClick(state));
			MDoubleLine(title, subtitle, state1): MDoubleLine(title, subtitle, lineClick(state1));
			MTripleLine(title, subtitle, state1): MTripleLine(title, subtitle, lineClick(state1));
			MCustomLine(content, state): MCustomLine(content, lineClick(state));
			MSubmenuLine(subMain0, subLines, subStyle, expanded0):
				MSubmenuLine(fgetValue(addClickToSubMain(const(subMain0), expanded0)), subLines, subStyle, expanded);
			default: sm
		}
	))
}

defaultListState(manager : MaterialManager, parent : MFocusGroup, m2t : (Material, MFocusGroup) -> Tropic) -> MListInnerState {
	MListInnerState(
		manager,
		m2t,
		MListWidth(-1., -1.),
		None(),
		None(),
		true,
		const(false),
		72.,
		MListSelection(const(false), false, false, make([])),
		false,
		getLightBackground(parent),
		Pair(contrastingMColor(parent), contrastingMColor(parent)),
		Pair(
			[],
			[Fill(contrastingColor(parent)), FillOpacity(if (getLightBackground(parent)) 0.08 else 0.16)]
		),
		false,
		true,
		nop1,
		const(true),
		const(true),
		false,
		ref None(),
		const(16.),
		const(72.),
		[]
	);
}

makeMListInnerState(listState : MListInnerState, state : [flow]) -> MListInnerState {
	listWidth = extractStruct(state, listState.width);
	emptyMessage = maybeMap(tryExtractStruct(state, MEmptyMessage(either(listState.emptyMessage, TEmpty()))), \em -> em.message);
	reorderList = tryExtractStruct(state, MListReorder(make([]), const(false)));
	reorderShowIcon = !contains(state, MListReorderHideIcon());
	minimizeList = extractStruct(state, MListMinimize(listState.minimize)).minimize;
	minimizedWidth = extractStruct(state, MListMinimizedWidth(listState.minimizedWidth)).width;
	singleSelection = tryExtractStruct(state, MSingleSelection(make(-1)));
	multiSelection = tryExtractStruct(state, MMultiSelection(make(makeSet())));
	selection = extractStruct(state, MListSelection(const(isSome(singleSelection) || isSome(multiSelection)),
		isSome(multiSelection), false, make([])));
	selectionEnabled = extractStruct(state, MListSelectionEnabled(const([])));
	isCondensed = extractStruct(state, MCondensed(false)).condensed || listState.condensed;
	separators = contains(state, MAddSeparators()) || listState.separators;
	color =
		Pair(
			extractStruct(state, listState.color.first),
			extractStruct(state, MSelectedColor(listState.color.second)).color
		);
	bgStyle =
		Pair(
			extractStruct(state, MBackgroundStyle(listState.bgStyle.first)).style,
			extractStruct(state, MSelectedBackgroundStyle(listState.bgStyle.second)).style
		);
	onListClick = extractStruct(state, MOnListClick(const(false), nop1));
	hoverEnabled = extractStruct(state, MHoverEnabled(listState.hoverEnabled)).enabled;
	enabled = extractStruct(state, MEnabled(listState.enabled)).enabled;
	collapseUnactive = contains(state, MCollapseUnactive()) || listState.collapseUnactive;
	currentSubmenu = ref if (collapseUnactive) Some(make(false)) else None();
	ellipsisText = !contains(state, MNoEllipsis());

	sideBorders =
		extractStruct(state, MSideBorders(const(16.))).borders
		|> (\bord -> fif(minimizeList, const(0.), bord));

	primaryActionWidth = extractStruct(state, MPrimaryActionWidth(const(72.))).width;

	subs =
		concatA([
			eitherMap(
				singleSelection,
				\ss -> [\ -> bidirectionalLink(ss.selected, selection.selected, \sel -> if (sel >= 0) [sel] else [],
					\sel -> if (length(sel) > 0) sel[0] else -1)],
				[]
			),
			eitherMap(
				multiSelection,
				\ms -> [\ -> bidirectionalLink(ms.selected, selection.selected, set2array, buildSet)],
				[]
			)
		]);

	onClick = MListOnClickHandler(selection, selectionEnabled, onListClick);

	MListInnerState(
		listState.manager,
		listState.m2t,
		listWidth,
		emptyMessage,
		reorderList,
		reorderShowIcon,
		minimizeList,
		minimizedWidth,
		selection,
		isCondensed,
		listState.lightBackground,
		color,
		bgStyle,
		separators,
		ellipsisText,
		onClick,
		hoverEnabled,
		enabled,
		collapseUnactive,
		currentSubmenu,
		sideBorders,
		primaryActionWidth,
		subs
	)
}

makeTListLine(lightBackground : bool, line : Tropic, focus : MFocus, selected : Transform<bool>, hoverEnabled : Transform<bool>,
	bgStyle : [TGraphicsStyle], selectedBgStyle : [TGraphicsStyle]) -> Tropic {

	TDecorator(
		TAlpha(fif(focus.enabled, const(1.), const(if (lightBackground) 0.26 else 0.3)), line),
		[
			Pair(
				const(true),
				\wh -> TRectangle(bgStyle, TSized(wh))
			),
			Pair(
				selected,
				\wh -> TRectangle(selectedBgStyle, TSized(wh)),
			),
			Pair(
				fmin(hoverEnabled, fmin(focus.down, focus.enabled)),
				\wh -> pressedLine(TSized(wh), lightBackground)
			),
			Pair(
				fmin(hoverEnabled, fmin(fmax(focus.focused, focus.hover), focus.enabled)),
				\wh -> hoverLine(TSized(wh), lightBackground)
			),
		],
		false
	)
}

makeMListLine(line : Material, focus : MFocus, selected : Transform<bool>, hoverEnabled : Transform<bool>,
	bgStyle : [TGraphicsStyle], selectedBgStyle : [TGraphicsStyle]) -> Material {
	MGetFocusGroup(\p : MFocusGroup ->
		MLetDisplay(
			"MListLine",
			MAlpha(fif(focus.enabled, const(1.), const(if (getLightBackground(p)) 0.26 else 0.3)), line),
			TGroup([
				TRectangle(bgStyle, TGhost("MListLine")),
				TShowLazy(selected, \ -> TFrame(0.0, 0.0, selectedBgStyle, TGhost("MListLine"))),
				TShowLazy(fmin(hoverEnabled, fmin(focus.down, focus.enabled)), \ -> pressedLine(TGhost("MListLine"), getLightBackground(p))),
				TShowLazy(
					fmin(hoverEnabled, fmin(fmax(focus.focused, focus.hover), focus.enabled)),
					\ -> hoverLine(TGhost("MListLine"), getLightBackground(p))
				)
			]),
			false
		)
	)
}

MListAddAvailable(state : MListInnerState) -> (Tropic) -> Tropic {
	\tr ->
		(if (state.width.maxWidth > 0. && state.width.minWidth >= state.width.maxWidth)
			makeTropicConstantWidth(state.width.minWidth |> Some)(tr)
		else
			tr)
	|> (\t -> if (state.width.maxWidth < 0.) t else TAvailableWidth(t, const(max(state.width.minWidth, state.width.maxWidth))))
}

MListIcon2T(manager : MaterialManager, content : Material, color : MColor, selectedColor : MColor,
	m2t : (Material, MFocusGroup) -> Tropic) -> Pair<(bool, MFocusGroup) -> Tropic, bool> {
	switch (content) {
		MIcon(name, iconStyle): {
			Pair(
				\sel, p -> {
					iconColor = extractStruct(iconStyle, if (sel) selectedColor else color);

					MIcon2T(p, name, concat(replaceStruct(iconStyle, iconColor),
						[if (iconColor != MBlack()) FillOpacity(1.0) else FillOpacity(0.54)]))
				},
				false
			)
		}
		MLetterIcon(text, iconStyle, textStyle): {
			size = extractStruct(iconStyle, MIconSize(24.0)).size;

			Pair(
				\sel, p -> {
					iconColor = extractStruct(iconStyle, if (sel) selectedColor else color);

					TGroup2(
						TFrame(0.0, size / 2.0, [MFill(extractStruct(iconStyle, iconColor))], TFixed(size, size)),
						TCenterIn(MText2T(p, text, textStyle), TFixed(size, size))
					)
				},
				true
			)
		}
		MAvatar(imageurl, style): {
			Pair(
				\__, p ->
					MAvatar2T(p, imageurl, style),
				true
			)
		}
		MCenterX(content2): {
			innerIcon = MListIcon2T(manager, content2, color, selectedColor, m2t);

			Pair(
				\sel, p ->
					TCenterXIn(innerIcon.first(sel, p), TFixed(40., 0.)),
				innerIcon.second
			)
		}
		default: {
			Pair(
				\__, p ->
					m2t(content, p),
				false
			)
		}
	}
}

MListAddLeaveBehinds(parent : MFocusGroup, l : Tropic, listState : MListInnerState, enabled : Transform<bool>, state : Transform<[?]>,
	m2t : (Material, MFocusGroup) -> Tropic) -> Tropic {
	leaveBehinds : Transform<Pair<Maybe<MLeaveBehind>, Maybe<MLeaveBehind>>> =
		fselect(state, FLift(\st -> Pair(
			tryExtractStruct(st, MLeftLeaveBehind(TEmpty(), nop, [])),
			tryExtractStruct(st, MRightLeaveBehind(TEmpty(), nop, []))
		)));

	(if (listState.separators)
		TLines2(l, TBorder(0., -1., 0., 0., MSeparator2T(listState.manager, parent, true)))
	else
		l)
	|> (\f : Tropic ->
		TSelect(leaveBehinds, \lbP: Pair<Maybe<MLeaveBehind>, Maybe<MLeaveBehind>> -> {
			leftLeaveBehind : Maybe<MLeaveBehind> = if (parent.rtl) lbP.second else lbP.first;
			rightLeaveBehind : Maybe<MLeaveBehind> = if (parent.rtl) lbP.first else lbP.second;

			if (isSome(leftLeaveBehind) || isSome(rightLeaveBehind)) {
				down = make(false);
				point = make(zeroPoint);

				defaultGap = MGapSize(56., true);
				defaultPosition = make(0.);

				extractGap = \leaveBeh ->
					eitherMap(leaveBeh, \lb : MLeaveBehind -> extractStruct(lb.style, defaultGap), defaultGap);

				extractPosition = \leaveBeh ->
					eitherMap(leaveBeh, \lb : MLeaveBehind -> extractStruct(lb.style, MLeaveBehindPosition(defaultPosition)).position, defaultPosition);

				leftGap = extractGap(leftLeaveBehind);
				leftPosition = extractPosition(leftLeaveBehind);

				rightGap =	extractGap(rightLeaveBehind);
				rightPosition =	extractPosition(rightLeaveBehind);

				onSwipe = \isRight -> \__, delta -> {
					gap = if (isRight) rightGap else leftGap;
					newX = getValue(point).x + delta.x;

					newY =
						if (gap.stopOnGap)
							if (isRight)
								forceRange(newX, -gap.size, 0.0)
							else
								forceRange(newX, 0.0, gap.size)
						else
							max(newX, 0.0);
					nextDistinct(point, Point(newY, 0.));
					if (isRight)
						nextDistinct(rightPosition, -newY)
					else
						nextDistinct(leftPosition, newY);

					true
				}


				TCopySize(
					TTranslate(point, TFrame(0., 0., listState.bgStyle.first, f)),
					\tr ->
						MSwipe2T(
							listState.manager,
							parent,
							MSwipe(
								tr,
								[
									MEnabled(fand(enabled, fnot(listState.minimize))),
									TPressed(down),
									MSwipeGap(10.)
								]
								|> (\swipeState ->
									ifArrayPush(swipeState, isSome(leftLeaveBehind), MOnSwipeRight(onSwipe(false))))
								|> (\swipeState ->
									ifArrayPush(swipeState, isSome(rightLeaveBehind), MOnSwipeLeft(onSwipe(true))))
							),
							m2t
						),
					true
				)
				|> (\f3 ->
					TCopySize(
						f3,
						\tr ->
							TAvailable(
								TGroup2(
									eitherMap(leftLeaveBehind, \lb : MLeaveBehind ->
										TShowLazy(
											fand(fselect(point, FLift(\p -> p.x > 0.)), fnot(listState.minimize)),
											\ -> TTweak([TAlign(zero, const(0.5))], listState.m2t(lb.icon, parent), TFillXY())
										),
										TEmpty()
									),
									eitherMap(rightLeaveBehind, \lb : MLeaveBehind ->
										TShowLazy(
											fand(fselect(point, FLift(\p -> p.x < 0.)), fnot(listState.minimize)),
											\ -> TTweak([TAlign(const(1.), const(0.5))], listState.m2t(lb.icon, parent), TFillXY())
										),
										TEmpty()
									)
								),
								tr
							),
						false
					)
				)
				|> (\f3 ->
					TConstruct(
						[
							makeSubscribe(down, \d -> {
								if (!d) {
									if (getValue(point).x >= leftGap.size) maybeApply(leftLeaveBehind, \lb : MLeaveBehind -> lb.action());
									if (getValue(point).x <= -rightGap.size) maybeApply(rightLeaveBehind, \lb : MLeaveBehind -> lb.action());

									nextDistinct(point, zeroPoint);
									nextDistinct(leftPosition, 0.);
									nextDistinct(rightPosition, 0.);
								}
							})
						],
						f3
					)
				)
			} else
				f
		})
	)
}

MListOnClickHandler(selection : MListSelection, selectionEnabled : MListSelectionEnabled, onListClick : MOnListClick) -> (int) -> void {
	\i -> {
		if (fgetValue(selection.enabled) && fgetValue(elementAt(fgetValue(selectionEnabled.enabled), i, const(true))))
			if (selection.multiple) {
				if (contains(getValue(selection.selected), i) && selection.toggle)
					nextDistinct(selection.selected, removeAll(getValue(selection.selected), i))
				else if (!contains(getValue(selection.selected), i))
					nextDistinct(selection.selected, arrayPush(getValue(selection.selected), i));
			} else {
				if (selection.toggle)
					next(selection.selected, if (contains(getValue(selection.selected), i)) [] else [i])
				else
					nextDistinct(selection.selected, [i]);
			};

		if (fgetValue(onListClick.enabled))
			onListClick.onClick(i);
	}
}