import material/internal/material_menu;
import material/internal/material_slider;
import material/internal/material_progress;
import net/appurl;

export {
	MVideoPlayer2T(manager : MaterialManager, parent : MFocusGroup, m : MVideoPlayer, m2t : (Material, MFocusGroup) -> Tropic) -> Tropic;

	MVideoWithAnimatedSubtitles(
		filename : string,
		wh : DynamicBehaviour<WidthHeight>,
		style : [FVideoStyle],
		subtitles : MAnimatedSubtitles
	) -> Material;
}

MVideoPlayer2T(manager : MaterialManager, parent : MFocusGroup, m : MVideoPlayer, m2t : (Material, MFocusGroup) -> Tropic) -> Tropic {
	(\p -> eitherFn(
		getExternalPlayerURL(m.filename),
		\url -> {
			enableYoutubeJsApi = isSome(getYouTubeURL(m.filename)) && containsStruct(m.style, MPlayerYoutubeJsApi());
			if (enableYoutubeJsApi) m2t(MVideoYoutubePlayer(m.filename, m.wh, m.style), p)
			else MVideoPlayer2MRealHTML(url, p, m, m2t)
		},
		\ -> {
			itemsColorM : Maybe<MColor> = maybeMap(tryExtractStruct(m.style, MItemsColor(MWhite())), \ic -> MThemeColor2MColor(p, ic.color));
			color = extractMColor(p, m.style, MAccentColor());
			selectedColor = extractStruct(m.style, MSelectedColor(color));
			backgroundColor = extractStruct(m.style, MPlayerDynamicBackground(const(MDialogMColor(false)))).color;
			backgroundOpacity = extractStruct(m.style, MPlayerBackgroundOpacity(const(1.0))).opacity;
			customBarM = tryExtractStruct(m.style, MCustomBar(\__, __, __ -> MEmpty()));
			dynColorM = tryExtractStruct(m.style, MDynamicColor(const(color)));
			poster = extractStruct(m.style, MVideoPoster(TEmpty())).poster;

			addBackground = \vt : Tropic -> {
				TFrameT(zero, zero, fselect2Lift(backgroundColor, backgroundOpacity, \bgc, bgo -> [MFill(MThemeColor2MColor(p, bgc)), FillOpacity(bgo)]), vt)
			}

			videoHasErrors = make(false);
			enabled =
				fands([
					extractStruct(m.style, MEnabled(const(true))).enabled,
					fnot(videoHasErrors),
					p.enabled
				], true)
				|> MEnabled;

			mPlayerControls = extractStruct(m.style, MPlayerControls([VolumeControl()])).controls;

			controls : [PlayerControl] = concat(
				MPlayerControls2PlayerControls(mPlayerControls),
				extractStruct(m.style, FVideoControls([VolumeControl()])).controls
			);
			volumeControl = contains(controls, VolumeControl());
			fullScreenControl = contains(controls, FullScreenPlayer());
			playbackRateControl = !android() && contains(controls, PlaybackRateControl());
			customControlButtonM = tryExtractStruct(mPlayerControls, MPlayerCustomControl("", nop, [], []));
			subtitlesControl = tryExtractStruct(mPlayerControls, SubtitlesControl(const(false)));
			subtitlesSelector = tryExtractStruct(mPlayerControls, SubtitlesSelector(make(SubtitleSource("", "", "")), []));
			subtitles = tryExtractStruct(m.style, FVideoSubtitles(const(VideoSubtitle("", []))));
			animatedSubtitles = tryExtractStruct(m.style, MAnimatedSubtitles(const(VideoSubtitle("", [])), []));
			externalSubtitles = tryExtractStruct(m.style, MExternalSubtitles("", ""));
			shortcutsEnabled = !containsStruct(m.style, MPlayerDisableKeyboardShortcuts());

			streamStatus = extractStruct(m.style, StreamStatus(nop1)).fn;

			playing = extractStruct(m.style, FVideoPlay(make(false))).play;
			volume = extractStruct(m.style, FVideoVolume(make(1.))).volume;
			fullscreen =
				eitherFn(
					tryExtractStruct(m.style, FVideoFullscreen(make(false))),
					\fs -> Some(fs.fullscreen),
					\ ->
						if (fullScreenControl)
						 	Some(make(false))
						else
							None()
				);
			position = extractStruct(m.style, FVideoPosition(make(0.))).position;
			duration = extractStruct(m.style, FVideoLength(make(1.))).length;
			playbackRate = extractStruct(m.style, FVideoPlaybackRate(make(1.))).rate;
			autoHide = extractStruct(m.style, MPlayerPanelAutoHide(false)).enabled;
			showPanel = extractStruct(m.style, MPlayerShowPanel(const(true))).show;
			visibleRange = extractStruct(m.style, MPlayerVisibleRange(const(0.0), duration));
			visibleDuration = fselect3(visibleRange.start, visibleRange.end, duration, \st, en, d -> min(d, en - st));
			visiblePosition = fselect2(position, visibleRange.start, FLift2(\pos, vs -> max(pos - vs, 0.0)));

			highlightedRanges = tryExtractStruct(m.style, MPlayerHighlightedRanges(const([])));

			showPanelInner = make(true);

			controlsWH = makeWH();
			videoWH = makeWH();
			availableH = make(0.);
			sliderPosition = make(0.);
			volumeSliderDown = make(false);
			positionSliderDown = make(false);
			volumeSliderHovered = make(false);
			volumeButtonFocused = make(false);
			volumeButtonHovered = make(false);
			playPauseButtonFocused = make(false);
			subtitlesButtonFocused = make(false);
			playbackRateControlButtonFocused = make(false);
			fullScreenControlButtonFocused = make(false);
			volumeSliderFocused = make(false);
			videoFocused = make(false);
			panelHovered = make(false);
			playbackRateSelected = make(3);
			showProgressCircle = make(true);
			subtitlesVisible = make(true);
			subtitlesEnabled = fand(enabled.enabled, const(isSome(subtitles) || isSome(animatedSubtitles) || isSome(externalSubtitles)));
			playingPopup = make(None());
			volumePopup = make(None());
			positionPopup = make(None());
			mousePosition = makePoint();
			mouseDown = make(false);
			settingsMenuOpen = make(false);
			subtitlesMenuOpen = make(false);

			makeFadeOutIcon = \icon -> {
				MIcon2T(
					p,
					icon,
					[MCircleBackground(MBlack(), 56.), MIconSize(32.), FillOpacity(1.0)]
				)
				|> (\ic -> TOrigin(const(Factor(0.5, 0.5)), ic))
				|> (\ic ->
					TAnimation(
						ic,
						const([
							FAnimationKeyframe([
								FScaleValue(Factor(1.0, 1.0)),
								FAlphaValue(0.7)
							]),
							FAnimationKeyframe([
								FScaleValue(Factor(2.0, 2.0)),
								FAlphaValue(0.0)
							])
						]),
						[
							FAnimationDuration(const(0.5))
						]
					)
				)
				|> (\ic -> TBorder4(48.0, ic))
				|> TCenter
			}

			uns = initUnsM();

			videoStyle =
				m.style
				|> videoPlayerStyle2FVideoStyle
				|> (\st -> removeAllStructs(st, FVideoControls([])))
				|> (\st -> removeAllStructs(st, FVideoFullscreen(make(false))))
				|> (\st ->
					replaceStructMany(
						st,
						[
							FVideoPlay(playing),
							FVideoVolume(volume),
							FVideoPosition(position),
							FVideoLength(duration),
							FVideoPlaybackRate(playbackRate),
							OnVideoLoadingError(\ -> nextDistinct(videoHasErrors, true)),
							StreamStatus(\s -> {nextDistinct(showProgressCircle, false); streamStatus(s)})
						]
					)
				)
				|> (\st ->
					eitherMap(subtitles, \sbtl ->
						replaceStruct(st,
							FVideoSubtitles(fif(subtitlesVisible, sbtl.subtitles, const(VideoSubtitle("", []))))
						),
						st
					)
				)
				|> (\st ->
					eitherMap(externalSubtitles, \sbtl ->
						replaceStruct(st,
							FVideoExternalSubtitles(sbtl.src, sbtl.kind, subtitlesVisible)
						),
						st
					)
				)
				|> (\st -> ifArrayPush(
					st,
					containsStruct(m.style, MPlayerVisibleRange(const(0.0), const(0.0))) &&
						!containsStruct(st, FVideoTimeRange(const(0.0), const(0.0))),
					FVideoTimeRange(visibleRange.start, visibleRange.end)
				));

			videoBox =
				MComponent2T(
					manager,
					p,
					"MVideo",
					[MFocused(videoFocused), AccessRole("group"), MCursorShape(const(DefaultCursor()))],
					\foc ->
						TVideoWithAnimatedSubtitles(
							manager,
							p,
							TVideo(m.filename, videoWH, videoStyle),
							poster,
							maybeMap(animatedSubtitles, \sbtl -> Pair(sbtl, subtitlesVisible)),
							m2t
						)
						|> (\f -> TVisible(parent.ready, f)),
					m2t
				)
				|> (\video ->
					TCopySize(
						video,
						\videoSize ->
							TGroupWithoutMetrics([
								mouseOnDownAround(
									manager,
									[
										MOnClick(\ -> {
											if (!getValue(panelHovered)) {
												next(playingPopup, None());
												reverseBehaviour(playing);
												next(playingPopup, Some(getValue(playing)));
											}
										}),
										TPressed(mouseDown),
										MMousePosition(mousePosition),
										MPassClicks(),
										enabled
									],
									videoSize
								),
								TTweak(
									[TFitZoom(true, false)],
									TGroup([
										TSelect(playingPopup, \plM ->
											eitherMap(
												plM,
												\pl -> {
													nextDistinct(volumePopup, None());
													nextDistinct(positionPopup, None());

													makeFadeOutIcon(
														if (pl)
															"play_arrow"
														else
															"pause"
													);
												},
												TEmpty()
											)
										),
										TSelect(volumePopup, \vM ->
											eitherMap(
												vM,
												\v -> {
													nextDistinct(positionPopup, None());
													nextDistinct(playingPopup, None());

													makeFadeOutIcon(
														if (v == 0.)
															"volume_off"
														else if (v < 0.5)
															"volume_down"
														else
															"volume_up"
													);
												},
												TEmpty()
											)
										),
										TSelect(positionPopup, \posM ->
											eitherMap(
												posM,
												\pos -> {
													nextDistinct(volumePopup, None());
													nextDistinct(playingPopup, None());

													makeFadeOutIcon(
														if (pos)
															"forward_5"
														else
															"replay_5"
													);
												},
												TEmpty()
											)
										)
									])
									|> (\t -> TBorder4(16., t)),
									videoSize
								),
								TCenterIn(
									MProgressCircle2T(manager, p, MProgressCircle([MWhite()])),
									videoSize
								)
								|> (\t2 -> TShow(showProgressCircle, t2))
							]),
						true
					)
				)
				|> (\video -> TVisible(fselect(videoWH, FLift(\vwh -> vwh.width > 0. && vwh.height > 0.)), video))
				|> (\video ->
					TIf(videoHasErrors,
						TGroup2(
							TRectangle([Fill(black)], TFillXY()),
							TCenter(MDynamicParagraph2T(p, const("An error occurred. Please try again later."), [MWhite(), CenterAlign()]))
						),
						video
					)
				)
				|> addBackground;

			slider = \p2 ->
				MSelect2T(
					manager,
					p2,
					"Video Slider Container",
					[],
					duration,
					\d, p3 -> {
						rangeUns = ref [];
						MSlider2T(
							manager,
							p3,
							MSlider(
								sliderPosition,
								concatA([
									[
										MCondensed(true),
										MSliderTooltip(\v -> seconds2timelineString(v * fgetValue(visibleDuration))),
										MSliderThumbRadius(const(6.0)),
										MSliderStep(if (d > 0.0) min(max(0.001, 5.0 / d), 0.2) else 0.2),
										MSliderDiscrete(false),
										TPressed(positionSliderDown),
										color,
										MButtonTitle(const(_("Video Slider"))),
										enabled
									],
									eitherMap(customBarM, v2a, []),
									eitherMap(dynColorM, v2a, []),
									eitherMap(itemsColorM, \itemsColor -> [MInactiveAreaColor(itemsColor)], []),
									eitherMap(highlightedRanges, \highlighted -> [
										MSliderHighlightedRanges(fselect(highlighted.ranges, FLift(\ranges -> {
											dispUnsA(rangeUns);
											map(ranges, \range -> {
												start = make(0.);
												end = make(0.);
												refArrayPush(rangeUns, bidirectionalLink(
													range.start, start, \v -> v / d, \v -> v * d
												));
												refArrayPush(rangeUns, bidirectionalLink(
													range.end, end, \v -> v / d, \v -> v * d
												));
												MSliderHighlightedRange(start, end, range.style)
											})
										})))
									], [])
								])
							),
							m2t
						)
						|> (\t -> TDispose([\ -> dispUnsA(rangeUns)], t))
					}
				)
				|> (\f -> TBorder(-2.0, -6.0, -2.0, -2.0, f));

			onKeyDown = \h, ke ->
					if (!h && fgetValue(p.keysEnabled)) {
						if ((ke.utf == " " || ke.utf == "up" || ke.utf == "down" || ke.utf == "right" || ke.utf == "left")
							&& (!fgetValue(videoFocused) && isNone(getCurrentFocusedItem(manager)))) {
							nextDistinct(videoFocused, true);
						}

						if (fgetValue(videoFocused)) {
							if (ke.utf == " " && !getValue(playPauseButtonFocused) && !getValue(subtitlesButtonFocused) && !getValue(fullScreenControlButtonFocused)
								&& !getValue(playbackRateControlButtonFocused) && !getValue(volumeButtonFocused)) {
								next(playingPopup, None());
								reverseBehaviour(playing);
								next(playingPopup, Some(getValue(playing)));
								true;
							} else if (ke.utf == "up") {
								next(volumePopup, None());
								nextDistinct(volume, min(getValue(volume) + 0.1, 1.0));
								next(volumePopup, Some(getValue(volume)));
								true;
							} else if (ke.utf == "down") {
								next(volumePopup, None());
								nextDistinct(volume, max(getValue(volume) - 0.1, 0.0));
								next(volumePopup, Some(getValue(volume)));
								true;
							} else if (ke.utf == "right") {
								next(positionPopup, None());
								nextDistinct(position, min(getValue(position) + min(5.0, max(fgetValue(visibleDuration) / 5.0, 0.1)), fgetValue(visibleRange.end)));
								next(positionPopup, Some(true));
								true;
							} else if (ke.utf == "left") {
								next(positionPopup, None());
								nextDistinct(position, max(getValue(position) - min(5.0, max(fgetValue(visibleDuration) / 5.0, 0.1)), fgetValue(visibleRange.start)));
								next(positionPopup, Some(false));
								true;
							} else {
								false;
							}
						} else {
							false;
						}
					} else {
						h;
					};

			playPauseButton = \p2 -> {
				tooltipText = fif(playing, const(_("Pause")), const(_("Play")));
				MIconToggle2T(
					manager,
					p2,
					MIconToggle(
						"pause",
						[
							MToggleFalseIcon("play_arrow", arrayPushMaybe([MIconSize(30.)], itemsColorM)),
							MIconButtonBorder(3.), MIconSize(30.)
						]
						|> (\styles -> arrayPushMaybe(styles, itemsColorM)),
						[
							MToggleValue(playing),
							MTooltipAlignment(MTop()),
							MTooltipText(tooltipText),
							MButtonTitle(tooltipText),
							MFocused(playPauseButtonFocused),
							enabled
						]
					),
					m2t
				)
				|> (\t -> TBorder(4., 0., 8., 0., t));
			}

			showVolumeSlider =
				if (mobile) {
					// On iOS volume can be changed only by physical buttons
					if (ios()) const(false)
					else enabled.enabled
				} else
					fselectdelay(
						fand(fOr(fOr(fOr(volumeButtonHovered, volumeSliderHovered), fOr(volumeSliderFocused, volumeButtonFocused)), volumeSliderDown), enabled.enabled),
						\sh -> if (sh) 0 else 100
					);

			panelFillerW = make(0.);
			timeLabelHidden =
				if (mobile) const(false)
				else fselect(showVolumeSlider, FLift(\__ -> getValue(panelFillerW) <= 0.));

			customControlButton = \p2 -> {
				eitherMap(
					customControlButtonM,
					\customControlButton -> {
						MIconToggle2T(
							manager,
							p2,
							MIconToggle(
								customControlButton.icon,
								customControlButton.style
								|> (\styles -> arrayPushMaybe(styles, itemsColorM)),
								arrayPush(customControlButton.state, MOnClick(customControlButton.onClickAction))
							),
							m2t
						)
						|> (\t -> TBorder(4., 0., 8., 0., t));
					},
					TEmpty()
				)
				
			}

			volumeControlButton = \p2 ->
				if (volumeControl) {
					tooltipText = fif(feq(volume, 0.0), const(_("Unmute")), const(_("Mute")));
					TColsYCenter([
						MComponent2T(
							manager,
							p2,
							"MVolumeToggle",
							[
								enabled,
								MFocused(volumeButtonFocused),
								MOnClick(\ -> next(volume, if (getValue(volume) == 0.) 1. else 0.)),
								THovering(volumeButtonHovered),
								MTooltipAlignment(MTop()),
								MTooltipText(tooltipText),
								MButtonTitle(tooltipText),
								MRippleType(const(MRippleCenter())),
								MHighlightOnHover(const(true)),
								MHighlightOnFocus(const(true))
							],
							\f ->
								TSelect2(volume, enabled.enabled,
									\v, en ->
										MIcon2T(
											p2,
											if (v == 0.)
												"volume_off"
											else if (v < 0.5)
												"volume_down"
											else
												"volume_up",
											arrayPushMaybe(if (en) [] else [MIconDisabled()], itemsColorM)
										)
								)
								|> (\f2 -> TBorder4(6.0, f2)),
							m2t
						)
						|> TBorderRight(12.),
						MShow2T(
							manager,
							p2,
							showVolumeSlider,
							\p3 -> {
								sliderTooltipText = const(_("Volume Slider"));
								MSlider2T(
									manager,
									p3,
									MSlider(
										volume,
										concat(
											[
												TPressed(volumeSliderDown),
												MRippleType(const(MNoRipple())),
												MSliderThumbRadius(const(6.0)),
												enabled,
												MWidth(52.0),
												MTooltipAlignment(MTop()),
												MTooltipText(sliderTooltipText),
												MButtonTitle(sliderTooltipText),
												MFocused(volumeSliderFocused),
												MHighlightOnHover(const(false)),
												MHighlightOnSelect(const(false))
											],
											eitherMap(itemsColorM, \itemsColor -> [itemsColor, MInactiveAreaColor(itemsColor)], [MWhite()])
										)
									),
									m2t
								)
								|> (\volumeSlider ->
									TInteractive([if (mobile) TMouseDownGhost(volumeSliderHovered) else TMouseInside(volumeSliderHovered, false)], volumeSlider)
								)
								|> (\t -> TBorder(-22., 0., 0., 0., t))
								|> TFixWidth(TSizedWidth(fif(timeLabelHidden, zero, const(64.)), 0.))
							}
						)
					])
					|> v2a
				} else
					[];

			timeLabel = \p2 ->
				TSelect3(visiblePosition, visibleDuration, enabled.enabled, \pos, dur, en ->
					MText2T(
						p2,
						seconds2timelineString(pos) + " / " + seconds2timelineString(dur),
						arrayPushMaybe(if (en) [] else [MTextDisabled()], itemsColorM)
					)
				)
				|> TBorderRight(12.)
				|> (\t -> TVisible(fnot(fand(timeLabelHidden, showVolumeSlider)), t));

			chapterTitle = \p2 -> eitherMap(
				tryExtractStruct(m.style, MPlayerChapter(const(""))),
				\ch -> TSelect(ch.title, \title -> MEllipsisText2T(manager, p2,
					MEllipsisText(title, eitherMap(itemsColorM, v2a, [])),
					m2t
				)),
				TEmpty()
			);

			playbackRateControlButton = \p2 ->
				if (playbackRateControl) {
					tooltipText = const(_("Speed Settings"));
					MMenu2T(
						manager,
						p2,
						MMenu(
							MIconButton("settings", nop, arrayPushMaybe([MIconButtonBorder(4.)], itemsColorM), [
								MTooltipAlignment(MTop()),
								MTooltipText(tooltipText),
								MButtonTitle(tooltipText),
								MFocused(playbackRateControlButtonFocused)
							]),
							[
								MMenuSingleLine("0.25", []),
								MMenuSingleLine("0.5", []),
								MMenuSingleLine("0.75", []),
								MMenuSingleLine("Normal", []),
								MMenuSingleLine("1.25", []),
								MMenuSingleLine("1.5", []),
								MMenuSingleLine("2", [])
							],
							[
								MCondensed(true),
								MSingleSelection(playbackRateSelected),
								enabled,
								selectedColor,
								MOpenMenu(settingsMenuOpen)
							]
						),
						m2t
					)
					|> v2a
				} else
					[];

			subtitlesButton = \p2 -> {
				tooltipText = const(_("Subtitles"));

				btnStyle = [MIconButtonBorder(4.)];
				btnState = [
					MEnabled(subtitlesEnabled),
					MTooltipAlignment(MTop()),
					MTooltipText(tooltipText),
					MButtonTitle(tooltipText),
					MFocused(subtitlesButtonFocused)
				];
				toggleIcon = MIconToggle("subtitles",
					eitherMap(itemsColorM, \ic -> concat(btnStyle, [ic, MToggleFalseIcon("subtitles", [ic])]), btnStyle),
					arrayPush(btnState, MToggleValue(subtitlesVisible))
				);

				makeSubtitlesMenu = \subsSelector -> {
					currentSubtitle = getValue(subsSelector.current);
					currentSubtitleId = make(findiDef(subsSelector.available, eq(currentSubtitle), 0));
					TConstruct(
						[
							makeSubscribe(currentSubtitleId, \id -> eitherFn(
								elementAtM(subsSelector.available, id),
								\sub -> {
									nextDistinct(subsSelector.current, sub);
									next(subtitlesVisible, true);
								},
								\ -> next(subtitlesVisible, false)
							))
						],
						MMenu2T(manager, p2,
							MMenu(
								MIconButton(toggleIcon.icon, nop, arrayPushMaybe(btnStyle, itemsColorM), btnState),
								concat(
									map(subsSelector.available, \s -> {
										label = if (s.label != "") s.label else s.lang;
										MMenuSingleLine(label, []);
									}),
									[MSeparatorLine(), MMenuSingleLine(_("Disabled"), [])]
								),
								[
									MCondensed(true),
									MSingleSelection(currentSubtitleId),
									enabled,
									selectedColor,
									MOpenMenu(subtitlesMenuOpen)
								]
							),
							m2t
						)
					);
				}

				eitherMap(subtitlesControl, \sControl ->
					TCopySize(
						eitherFn(subtitlesSelector,
							makeSubtitlesMenu,
							\ -> MIconToggle2T(manager, p2, toggleIcon, m2t)
						),
						\tr ->
							TRectangle([MFill(MRed(500))], TFillXH(2.))
							|> (\t -> TShow(fand(subtitlesVisible, subtitlesEnabled), t))
							|> TBorderLeftRight(6.)
							|> (\t -> TAvailable(t, tr))
							|> TBorderBottom(4.)
							|> TAlignBottom,
						true
					)
					|> (\t -> TShow(sControl.enabled, t))
					|> v2a,
					[]
			)};

			fullScreenControlButton = \p2 ->
				if (fullScreenControl)
					MIconToggle2T(
						manager,
						p2,
						MIconToggle(
							"fullscreen_exit",
							[
								MToggleFalseIcon("fullscreen", arrayPushMaybe([MIconSize(28.)], itemsColorM)),
								MIconButtonBorder(4.), MIconSize(28.)
							]
							|> (\styles -> arrayPushMaybe(styles, itemsColorM)),
							eitherMap(
								fullscreen,
								\fs -> {
									tooltipText = fif(fs, const(_("Exit Fullsreen")), const(_("Enter Fullscreen")));
									[
										MToggleValue(fs),
										MTooltipAlignment(MTop()),
										MTooltipText(tooltipText),
										MButtonTitle(tooltipText),
										enabled,
										MFocused(fullScreenControlButtonFocused)
									]
								},
								[enabled, MFocused(fullScreenControlButtonFocused)]
							)
						),
						m2t
					)
					|> v2a
				else
					[];

			panel =
				(\p3 ->
					TLines2(
						slider(p3)
						|> TFixWidth(TEmpty())
						|> (\s -> eitherMap(highlightedRanges,
							\highlighted -> {
								hasCaptions = fselectLift(highlighted.ranges,
									\ranges -> exists(ranges, \r -> extractStruct(r.style, MRangeCaption("", nop)).text != "")
								);
								TBorderT(zero, zero, zero, fif(hasCaptions, const(24.0), zero), s)
							},
							s
						)),
						[
							[playPauseButton(p3)],
							volumeControlButton(p3),
							[
								timeLabel(p3),
								chapterTitle(p3),
								TAttachWidth(TFillX(), panelFillerW)
							],
							[customControlButton(p3)],
							playbackRateControlButton(p3),
							subtitlesButton(p3),
							fullScreenControlButton(p3)
						]
						|> concatA
						|> TColsYCenter
						|> (\videoButtons -> TBorder(12., 4., 12., 4., videoButtons))
					)
					|> (\f ->
						if (autoHide)
							TFrame(0.0, 0.0, [GradientFill(90.0, [GradientPoint(black, 0.0, 0.0), GradientPoint(black, 0.3, 0.3), GradientPoint(black, 0.8, 1.0)])], f)
						else
							addBackground(f)
					)
				)
				|> (\makePanel ->
					(\p2 -> MComponentGroup2T(
						manager,
						p2,
						"MVideoControls",
						[
							MLightBackground(false),
							MSetRTL(false)
						],
						makePanel
					)
					|> (\t -> TAttachBox(t, controlsWH))
				)
				|> (\f -> m2t(MShowAnimation(fOr(fand(showPanel, showPanelInner), fOr(fnot(playing), settingsMenuOpen)), MGetFocusGroup(f), []), p))
				|> TBorderTop(10.0)
				|> (\t -> TInteractive([if (mobile) TMouseDown(panelHovered) else TMouseInside(panelHovered, false)], t)))
				|> (\t -> TLines2(TFillY(), t));

			TGroup2(videoBox, panel)
			|> (\videoPlayer ->
				if (shortcutsEnabled)
					TInteractive([KeyDown2(onKeyDown)], videoPlayer)
				else
					videoPlayer
			)
			|> (\videoPlayer ->
				eitherMap(
					fullscreen,
					\fs ->
						TAttachAvailableHeight(videoPlayer, availableH)
						|> (\t -> TAvailable(t, TIf(fs, TFillXY(), TSized(m.wh))))
						|> (\t -> TFullScreen(fs, t)),
					TAvailable(videoPlayer, TSized(m.wh))
				)
			)
			|> (\t ->
				TConstruct(
					concat(
						[
							\ -> fconnect(fdivide(visiblePosition, visibleDuration), sliderPosition),
							makeSubscribe(
								faddition(fmultiply(sliderPosition, visibleDuration), visibleRange.start),
								\pos -> if (pos <= fgetValue(duration)) nextDistinct(position, pos)
							),
							\ -> fconnect2Select(
								eitherMap(fullscreen, \fs -> fif(fs, availableH, fheight(m.wh)), fheight(m.wh)),
								controlsWH,
								videoWH,
								\vh, cwh -> WidthHeight(cwh.width, max(0., if (autoHide) vh else vh - cwh.height))
							),
							\ -> bidirectionalLink(playbackRate, playbackRateSelected, playbackRate2selected, selected2playbackRate),
						],
						if (autoHide)
							[
								makeSubscribeUns(
									fpair(
										fpair(mousePosition, mouseDown),
										fpair(fpair(playingPopup, fpair(volumePopup, volumeSliderDown)), fpair(positionPopup, positionSliderDown))
									), \__ -> {
									next(showPanelInner, true);

									[
										interruptibleTimer(2000, \ -> next(showPanelInner, false))
									]
								})
							]
						else
							[]
					),
					t
				)
			)
		}
	))
	|> (\f -> MComponentGroup2T(manager, parent, "MVideoContainer", [MSetRTL(false)], f))
}

videoPlayerStyle2FVideoStyle(style : [MVideoPlayerStyle]) -> [FVideoStyle] {
	filtermap(style, \st ->
		switch (st) {
			FVideoStyle() : {a : Maybe<FVideoStyle> = Some(st); a};
			default : None()
		}
	)
}

playbackRate2selected(pr : double) -> int {
	if (pr <= 0.25)
		0
	else if (pr <= 0.5)
		1
	else if (pr <= 0.75)
		2
	else if (pr <= 1.)
		3
	else if (pr <= 1.25)
		4
	else if (pr <= 1.5)
		5
	else
		6
}

selected2playbackRate(rs : int) -> double {
	if (rs == 0)
		0.25
	else if (rs == 1)
		0.5
	else if (rs == 2)
		0.75
	else if (rs == 3)
		1.
	else if (rs == 4)
		1.25
	else if (rs == 5)
		1.5
	else
		2.
}

MVideoPlayer2MRealHTML(url : string, parent : MFocusGroup, m : MVideoPlayer, m2t : (Material, MFocusGroup) -> Tropic) -> Tropic {
	style = eitherMap(
		tryExtractStruct(m.style, MEnabled(const(true))),
		\en -> [MouseDisabled(fnot(en.enabled))],
		[]
	);

	m2t(MRealHTML(url, m.wh, style), parent)
}

MVideoYoutubePlayer(url : string, wh : Transform<WidthHeight>, style : [MVideoPlayerStyle]) -> Material {
	YT_PLAY = "PLAYING";
	YT_BUFFERING = "BUFFERING";
	YT_PAUSE = "PAUSED";

	playB = extractStruct(style, FVideoPlay(make(false))).play;
	lengthB = extractStruct(style, FVideoLength(make(0.0))).length;
	positionB = extractStruct(style, FVideoPosition(make(0.0))).position;
	loopB = extractStruct(style, FVideoLoop(make(false))).loop;
	volumeB = extractStruct(style, FVideoVolume(make(1.0))).volume;
	disableKeyboard = contains(style, MPlayerDisableKeyboardShortcuts());
	controls = extractStruct(style, MPlayerControls([FullScreenPlayer(), PlaybackRateControl(), VolumeControl()])).controls;
	timeRangeM = tryExtractStruct(style, FVideoTimeRange(const(0.0), const(0.0)));

	urlParams = strSplit(elementAt(strSplit(takeBefore(url, "#", url), "?"), 1, ""), "&");
	videoId = if (strContains(url, "/embed")) {
		takeBefore(takeAfter(url, "/embed/", ""), "?", "");
	} else {
		eitherMap(find(urlParams, \p -> startsWith(p, "v=")), \v -> takeAfter(v, "v=", v), "");
	}
	startParam = eitherFn(
		find(urlParams, \p -> startsWith(p, "start=")),
		\v -> takeAfter(v, "start=", ""),
		\ -> eitherMap(timeRangeM, \tr -> d2st(fgetValue(tr.start), 2), "")
	);
	endParam = eitherFn(
		find(urlParams, \p -> startsWith(p, "end=")),
		\v -> takeAfter(v, "end=", ""),
		\ -> eitherMap(timeRangeM, \tr -> d2st(fgetValue(tr.end), 2), "")
	);
	controlsParam = eitherFn(
		find(urlParams, \p -> startsWith(p, "controls=")),
		\v -> takeAfter(v, "controls=", "1"),
		\ -> b2i(controls != []) |> i2s
	);
	muteParam = eitherMap(
		find(urlParams, \p -> startsWith(p, "mute=")),
		\v -> takeAfter(v, "mute=", "0"),
		"0"
	);
	autoplayParam = eitherMap(
		find(urlParams, \p -> startsWith(p, "autoplay=")),
		\v -> takeAfter(v, "autoplay=", "0"),
		"0"
	);
	relatedParam = eitherMap(
		find(urlParams, \p -> startsWith(p, "rel=")),
		\v -> takeAfter(v, "rel=", "0"),
		"0"
	);
	loopParam = eitherMap(
		find(urlParams, \p -> startsWith(p, "loop=")),
		\v -> takeAfter(v, "loop=", "0"),
		fgetValue(loopB) |> b2i |> i2s
	);
	fsParam = eitherMap(
		find(urlParams, \p -> startsWith(p, "fs=")),
		\v -> takeAfter(v, "fs=", "0"),
		contains(controls, FullScreenPlayer()) |> b2i |> i2s
	);

	sendB = make("");
	receiveB = make("");

	sendState = \s -> next(sendB,
		JsonObject([Pair("playerState", JsonObject(s))]) |> json2string
	);
	fselectFromStateM = \name -> fselectLift(receiveB, \r -> {
		v = getJsonFieldValueCustom(parseJson(r), "playerState." + name, JsonNull(), [JsonFieldTreatAsPath(".")]);
		if (v == JsonNull()) None() else Some(v)
	});
	onLoaded = \ -> next(sendB,
		JsonObject([Pair("loadVideo", JsonObject([
			Pair("videoId", JsonString(videoId)),
			Pair("params", JsonObject(concatA([
				if (startParam == "") [] else [Pair("start", JsonString(startParam))],
				if (endParam == "") [] else [Pair("end", JsonString(endParam))],
				if (disableKeyboard) [Pair("disablekb", JsonString("1"))] else [],
				[
					Pair("controls", JsonString(controlsParam)),
					Pair("mute", JsonString(muteParam)),
					Pair("autoplay", JsonString(autoplayParam)),
					Pair("rel", JsonString(relatedParam)),
					Pair("loop", JsonString(loopParam)),
					Pair("fs", JsonString(fsParam)),
					// for other params see https://developers.google.com/youtube/player_parameters#Parameters
				]
			]))),
		]))]) |> json2string
	);

	sendToJS = ref nop1;
	getHostCall = \hc -> {
		sendToJS := \msg -> hc("postMessage", [msg, "*"]) |> ignore;
	}
	flowCallBack = \args -> {
		if (length(args) == 2 && args[0] == "postMessage") next(receiveB, args[1]);
		""
	}

	MConstruct(
		[
			makeSubscribe2(sendB, \s -> println("to YT -> " + s)),
			makeSubscribe2(receiveB, \s -> println("from YT -> " + s)),

			makeSubscribe(sendB, \m -> ^sendToJS(m)),
			\ -> fBidirectionalLink(playB, fselectFromStateM("status"),
				\external -> sendState([Pair("status", JsonString(if (external) YT_PLAY else YT_PAUSE))]),
				\internalM -> maybeApply(internalM,
					\internal -> {
						v = getJsonStringValue(internal, "");
						nextDistinct(playB, v == YT_PLAY || v == YT_BUFFERING)
					}
				)
			),
			\ -> fBidirectionalLink(positionB, fselectFromStateM("currentTime"),
				\external -> sendState([Pair("currentTime", JsonDouble(external))]),
				\internalM -> maybeApply(internalM,
					\internal -> nextDistinct(positionB, getJsonDoubleValue(internal, 0.0))
				)
			),
			\ -> fBidirectionalLink(volumeB, fselectFromStateM("volume"),
				\external -> sendState([Pair("volume", JsonDouble(external * 100.0))]),
				\internalM -> maybeApply(internalM,
					\internal -> nextDistinct(volumeB, getJsonDoubleValue(internal, 0.0) * 0.01)
				)
			),
			makeSubscribe2(fselectFromStateM("duration"),
				\durationM -> maybeApply(durationM, \d -> nextDistinct(lengthB, getJsonDoubleValue(d, 0.0)))
			),
		],
		MRealHTML(getAppUrl() + "yt_player.html", wh, [
			FlowCallback(flowCallBack),
			PageHostcallSetter(getHostCall),
			UpdateCachedContent(true),
			OnPageLoaded(onLoaded),
			ZoomEnabled(const(false)),
			NoScroll()
		])
	)
}


MPlayerControls2PlayerControls(mPlayerControls : [MPlayerControl]) -> [PlayerControl] {
	filtermap(mPlayerControls, \cntr : MPlayerControl ->
		switch (cntr) {
			BasicPlayerControl(): {a : Maybe<PlayerControl> = Some(cntr); a};
			default : None();
		}
	)
}

MVideoWithAnimatedSubtitles(
	filename : string,
	wh : DynamicBehaviour<WidthHeight>,
	style : [FVideoStyle],
	subtitles : MAnimatedSubtitles) -> Material {

	MGetManager(\manager -> MGetFocusGroup(\parent -> MGetMaterial2Tropic(\m2t ->
		TVideoWithAnimatedSubtitles(
			manager,
			parent,
			TVideo(filename, wh, style),
			TEmpty(),
			Some(Pair(subtitles, const(true))),
			m2t
		)
	)))
}

TVideoWithAnimatedSubtitles(
	manager : MaterialManager,
	parent : MFocusGroup,
	video : TVideo,
	poster : Tropic,
	subtitles : Maybe<Pair<MAnimatedSubtitles, Transform<bool>>>,
	m2t : (Material, MFocusGroup) -> Tropic) -> Tropic {

	videoAreaMetrics = extractStruct(video.style, FInspectVideoArea(make(FVideoAreaMetrics(zeroPoint, WidthHeight(0., 0.), Factor(1., 1.))))).metrics;
	style = eitherMap(subtitles, \__ -> replaceStruct(video.style, FInspectVideoArea(videoAreaMetrics)), video.style);

	applyRange = \scMode, value ->
		if (scMode.max == -1.) max(scMode.min, value)
		else forceRange(value, scMode.min, scMode.max);

	TGroupSameMetrics([
		TVideo(video.filename, video.wh, style),
		poster,
		eitherMap(subtitles,
			\sbtl -> {
				areaBox = TSized(fselect(videoAreaMetrics, FLift(\vam -> vam.wh)));
				areaTopLeft = fselect(videoAreaMetrics, FLift(\vam : FVideoAreaMetrics -> vam.topLeft));
				scaleMode = tryExtractStruct(sbtl.first.style, FVideoSubtitlesScaleMode(0., 0.));
				customOriginSize = tryExtractStruct(sbtl.first.style, MSubtitlesOriginSize(WidthHeight(0., 0.)));

				TAnimatedSubtitles(manager, parent, sbtl.first, m2t)
				|> (\t -> eitherMap(scaleMode, \scMode -> {
					factor =
						eitherMap(
							customOriginSize,
							\os ->
								fselect(videoAreaMetrics, FLift(\vam ->
									min(vam.wh.width / os.size.width, vam.wh.height / os.size.height)
									|> (\f -> applyRange(scMode, f))
									|> (\f -> Factor(f, f))
								)),
							fselect(videoAreaMetrics, FLift(\vam -> Factor(
								applyRange(scMode, vam.scale.x),
								applyRange(scMode, vam.scale.y)
							)))
						);
						TScale(factor, t)
					},
					t
				))
				|> (\t -> TAvailable(t, areaBox))
				|> (\t -> TTweak([TAlign(const(0.5), const(1.))], t, areaBox))
				|> (\t -> TCropSize(areaBox, t))
				|> (\t -> TTranslate(areaTopLeft, t))
				|> (\t -> TShow(sbtl.second, t))
			},
			TEmpty()
		)
	])
}

TAnimatedSubtitles(manager : MaterialManager, parent : MFocusGroup, subtitles : MAnimatedSubtitles, m2t : (Material, MFocusGroup) -> Tropic) -> Tropic {
	duration = extractStruct(subtitles.style, MDuration(const(0.5)));
	frame = extractStruct(subtitles.style, MSubtitlesFrame(4., 4.));

	percent = make(0.);
	old2LineSize = makeWH();
	oldLineSize = makeWH();
	newLineSize = makeWH();

	boxSize = fselect2(oldLineSize, newLineSize, FLift2(\old, new -> WidthHeight(max(old.width, new.width), old.height + new.height)));

	backgroundColor = make(0);
	backgroundOpacity = make(0.);

	backgroundStyle =
		fsubselect(subtitles.subtitles, FLift(\__ ->
			fselect3(
				fselectWithLast(backgroundColor, FLift2(\old, new -> Pair(old, new))),
				fselectWithLast(backgroundOpacity, FLift2(\old, new -> Pair(old, new))),
				percent,
				\col, opac, prc -> [
					Fill(colorLerp(col.first, col.second, prc)),
					FillOpacity(lerp(opac.first, opac.second, prc))
				]
			)
		));

	background =
		m2t(
			MAnimatedResizer(fwidth(boxSize), fheight(boxSize), [duration, MResizerPercent(percent)]),
			parent
		)
		|> (\sz -> TFrameT(const(frame.border), const(frame.radius), backgroundStyle, sz));

	makeSubtitleLine = \sbtl, size, translatePoint, dSize ->
		MDynamicParagraph2T(parent, const(sbtl.text), concat(MCharacterStyle2MTextStyle(sbtl.style), [
			MSetRTL(false),
			extractStruct(sbtl.style, EscapeHTML(true)),
			CenterAlign(),
			ParagraphMetrics(\met -> nextDistinct(size, WidthHeight(met.width, met.height + dSize)))
		]))
		|> TBorderBottom(dSize)
		|> TBorderTop(frame.border)
		|> (\t -> TTranslate(translatePoint, t))
		|> (\t -> TConstruct([\ -> \ -> nextDistinct(size, zeroWH)], t));

	TMutable(fselectWith2Last(subtitles.subtitles, \old2, old, new -> {
		innerPercent = make(0.);
		antiInnerPercent = fsubtract(const(1.), innerPercent);
		old2LineTranslatePoint = flerpPoint(fselect(old2LineSize, FLift(\sz -> Point(0., -sz.height - frame.border))), antiInnerPercent);
		oldLineTranslatePoint = flerpPoint(fselect(old2LineSize, FLift(\sz -> Point(0., sz.height))), innerPercent);
		newLineTranslatePoint = fpointaddition(
			flerpPoint(fselect(old2LineSize, FLift(\sz -> Point(0., sz.height))), innerPercent),
			fselect(oldLineSize, FLift(\sz -> Point(0., sz.height)))
		);

		TGroupWithoutMetrics([
			makeSubtitleLine(new, newLineSize, newLineTranslatePoint, -4.) |> (\t -> TAlpha(innerPercent, t)),
			makeSubtitleLine(old, oldLineSize, oldLineTranslatePoint, 0.),
			makeSubtitleLine(old2, old2LineSize, old2LineTranslatePoint, 0.) |> (\t -> TAlpha(antiInnerPercent, t))
		])
		|> (\t -> TConstruct([
			\ -> fconnectSelect(percent, innerPercent, \perc -> max(getValue(innerPercent), perc)),
			\ -> {
				color = extractStruct(new.style, BackgroundFill(0)).color;
				opacity =
					if (strlen(new.text) == 0) 0.
					else extractStruct(new.style, BackgroundFillOpacity(0.)).opacity;

				nextDistinct(backgroundColor, color);
				nextDistinct(backgroundOpacity, opacity);
				nop;
			}
		], t))
	}, VideoSubtitle("", [])))
	|> (\t -> TGroup2(
		TDisplay("TAnimatedSubtitlesBackground") |> TCenterX,
		TCropSize(TGroup2(TFillX(), TGhost("TAnimatedSubtitlesBackground")), t)
	))
	|> (\t -> TLet("TAnimatedSubtitlesBackground", background, t))
	|> TBorderBottom(8.)
}

fselectWith2Last(b : Transform<??>, fn : (??, ??, ??) -> ?, def : ??) -> Transform<?> {
	lastV : ref Maybe<Pair<??, ??>> = ref None();
	fselect(ftransistor(fneq(b, def), b), FLift(\v ->
		switch (^lastV) {
			Some(prevV): {
				r = fn(prevV.first, prevV.second, v);
				lastV := Some(Pair(prevV.second, v));
				r
			}
			None(): {
				lastV := Some(Pair(def, v));
				fn(def, def, v);
			}
		}
	))
}
