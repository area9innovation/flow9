import material/internal/material_toolbar;
// Internal to material

export {
	MAppStructure2T(manager : MaterialManager, parent : MFocusGroup, m : MAppStructure, m2t : (Material, MFocusGroup) -> Tropic) -> Tropic;
}

MAppState(
	interactionId : int,
	content : Pair<Material, Transform<bool>>,
	floatingContent : Pair<Material, Transform<bool>>,
	appBar : Maybe<MAppBarState>,
	leftNav : Maybe<MAppNav>,
	rightNav : Maybe<MAppNav>,
	flexible : Maybe<MAppFlexibleState>,
	point : DynamicBehaviour<Point>,
	down : DynamicBehaviour<bool>,
	wh : DynamicBehaviour<WidthHeight>,
	scrollInspect : TScrollInspectVisible,
	state : [MComponentGroupState],
);

MAppNav(content : Material, expander : DynamicBehaviour<bool>, mini : bool, persistent : Transform<bool>, width : double, miniWidth : double,
	gap : Transform<double>, swipeEnabled : Transform<bool>, focusEnabled : Transform<bool>);

MAppFlexibleState(persistent : Transform<bool>, persistentB : DynamicBehaviour<bool>, showExpander : Transform<bool>, showToolbar : Transform<bool>);

MAppBarState(
	content : Material,
	focusEnabled : Transform<bool>,
	scrollPosition : DynamicBehaviour<Point>,
	floatingToolbar : Maybe<MFloatingToolbarState>,
	extendToolbar : Maybe<MExtendedAppBarState>
);

MFloatingToolbarState(
	translation : Transform<double>,
	expanded : Transform<bool>,
	subs : [() -> () -> void]
);

MExtendedAppBarState(
	trigger : DynamicBehaviour<bool>,
	image : Maybe<MBackgroundImage>,
	style : [MExtendedToolbarStyle]
);

MAppStructure2T(manager : MaterialManager, parent : MFocusGroup, m : MAppStructure, m2t : (Material, MFocusGroup) -> Tropic) -> Tropic {
		state = makeMAppState(manager, m);

		TCols([
			if (isSome(state.leftNav))
				[TDisplay("MAppLeftPanelSize")]
			else
				[],
			[TGroup2(TDisplay("MAppContent"), TDisplay("MAppFloatingContent"))],
			if (isSome(state.rightNav))
				[TDisplay("MAppRightPanelSize")]
			else
				[]
		] |> concatA)
		|> (\f ->
			eitherMap(state.appBar, \ab -> {
				scrollEnabled = eitherMap(ab.extendToolbar, \eab -> fnot(eab.trigger), const(true));
				TLines2(TGhost("MAppBar"), f)
				|> (\t ->
					TGroup2SameMetrics(
						if (isSome(ab.floatingToolbar) || isSome(ab.extendToolbar))
							MScroll2T(
								manager,
								parent,
								MScroll(
									t,
									TFillXY(),
									[
										state.scrollInspect,
										MScrollPosition(ab.scrollPosition),
										MScrollKeysEnabled(const(true)),
										MScrollDisableOutOfBounds(ref true),
										TScrollBarsStyle(invisibleScrollBar, invisibleScrollBar),
										MScrollMouseEnabled(scrollEnabled)
									]
								),
								m2t
							)
						else
							t,
						TDisplay("MAppBar")
					))
				},
				f
			)
		)
		|> (\f -> eitherMap(state.appBar, \ab -> eitherMap(ab.extendToolbar, \eab ->
				MSwipe2T(manager, parent, MSwipe(f, [
					MOnSwipeUp(\p, delta -> {
						nextDistinct(eab.trigger, false);
						true
					}),
					MOnSwipeDown(\p, delta -> {
						if (getValue(ab.scrollPosition) == zeroPoint) nextDistinct(eab.trigger, true);
						true
					})
				]), m2t),
			f), f))
		|> (\f ->
			TGroup2SameMetrics(
				f,
				(if (isSome(state.leftNav))
					TDisplay("MAppLeftPanel")
				else
					TEmpty())
				|> (\f2 ->
					eitherMap(state.rightNav,
						\rn ->
							TIf(
								rn.persistent,
								TGroup2WithoutMetrics(TDisplay("MAppRightPanel"), f2),
								TGroup2WithoutMetrics(f2, TDisplay("MAppRightPanel"))
							),
						f2
					)
				)
			)
		)
		|> (\f -> letAppBar(manager, parent, f, state, m2t))
		|> (\f -> letContentAndSize(manager, parent, f, m.style, state, m2t))
		|> (\f -> letExpander(manager, parent, f, state, m2t, false))
		|> (\f -> letExpander(manager, parent, f, state, m2t, true))
		|> (\f -> letFloatingContent(manager, parent, f, state, m2t))
		|> (\f -> letFlextibleApp(f, state))
}

makeMAppState(manager : MaterialManager, m : MAppStructure) -> MAppState {
	appWH = extractStruct(m.style, MAppWH(makeWH())).wh;
	scrollInspect = extractStruct(m.style, makeTScrollInspectVisible());
	mouseDown = make(false);

	flexible =
		maybeMap(
			tryExtractStruct(m.style, MAppStructureFlexible([])),
			\asf -> {
				enabled = extractStruct(asf.style, MEnabled(const(true))).enabled;
				showExpander = extractStruct(asf.style, MShowExpander(const(false))).show;
				showToolbar = extractStruct(asf.style, MShowToolbar(const(true))).show;
				mWidth = extractStruct(asf.style, MWidth(1296.)).width;
				persistentB = extractStruct(asf.style, MPersistent(make(false))).persistent;
				persistent = fif(enabled, fselect(appWH, FLift(\wh -> wh.width > mWidth)), const(false));

				MAppFlexibleState(
					persistent,
					persistentB,
					fOr(fnot(persistent), showExpander),
					fOr(fnot(persistent), showToolbar)
				)
			}
		);

	tryExtractNav = \left : bool ->
		maybeMap(
			tryExtractStruct(m.parts, if (changeBoolIfRTL(left)) MLeftNav(TEmpty(), make(false), []) else MRightNav(TEmpty(), make(false), [])),
			\nav : MNav -> {
				navMini = contains(nav.style, MSideNavMini());
				navMiniWidth = extractStruct(nav.style, MListMinimizedWidth(72.)).width;
				navSwipe : MSwipeLeftOrRight =
					extractStruct(
						m.style,
						if (changeBoolIfRTL(left))
							MSwipeLeft(const(if (navMini) navMiniWidth else 16.), const(mobile))
						else
							MSwipeRight(const(if (navMini) navMiniWidth else 16.), const(mobile))
					);

				navPersistent = extractStruct(nav.style, MSideNavPersistent(const(false))).persistent;

				MAppNav(
					nav.content,
					nav.expander,
					navMini,
					eitherMap(
						flexible,
						\flx -> fOr(navPersistent, flx.persistent),
						navPersistent
					),
					extractStruct(nav.style, MSideNavWidth(if (getStageWidth() > 360. || cpp) 320. else getStageWidth() / 9. * 8.)).width,
					navMiniWidth,
					navSwipe.gapLength,
					navSwipe.enabled,
					if (navMini) const(true) else nav.expander
				)
			}
		);

	leftNav = tryExtractNav(true);
	rightNav = tryExtractNav(false);
	content =
		Pair(
			extractStruct(m.parts, MContent(TEmpty())).content,
			fand(
				eitherMap(leftNav, \ln -> fOr(ln.persistent, fnot(ln.expander)), const(true)),
				eitherMap(rightNav, \rn -> fOr(rn.persistent, fnot(rn.expander)), const(true))
			)
		);
	floatingContent = Pair(extractStruct(m.parts, MFloatingContent(TEmpty())).content, content.second);
	appBar =
		maybeMap(
			tryExtractStruct(m.parts, MAppBar(TEmpty())),
			\fc -> {
				focusEnabled =
					fand(
						eitherMap(leftNav, \ln -> if (ln.mini) const(true) else fOr(ln.persistent, fnot(ln.expander)), const(true)),
						eitherMap(rightNav, \rn -> if (rn.mini) const(true) else fOr(rn.persistent, fnot(rn.expander)), const(true))
					);

				scrollPosition = make(zeroPoint);

				extendToolbar =
					maybeMap(
						tryExtractStruct(m.style, MExtendedAppBar([])),
						\eab : MExtendedAppBar ->
							MExtendedAppBarState(
								make(false),
								tryExtractStruct(eab.style, MBackgroundImage("", false)),
								{filtermap(eab.style, \st -> switch (st) {
									MExtendedToolbarStyle() : Some(st);
									default : None()
								})}
							)
					);

				floatingToolbar =
					if (contains(m.style, MFloatingToolbar()) && mobile) {
						startPoint = ref 0.;
						updateStartPoint = \ -> startPoint := getValue(scrollPosition).y;

						isUp = fselectWithLast(scrollPosition, FLift2(\last, new ->
							new.y - last.y > 0.
						));

						expanded =
							ftransistor(
								fnot(mouseDown),
								fnot(isUp)
							);

						delta = fselect(scrollPosition, FLift(\sp -> sp.y - ^startPoint));

						subs = [
							makeSubscribe2(isUp, \__ ->
								if (!getValue(mouseDown)) updateStartPoint()
							),
							makeSubscribe2(mouseDown, \d ->
								if (d) updateStartPoint()
							)
						];

						Some(MFloatingToolbarState(delta, expanded, subs))
					} else None();

				MAppBarState(
					fc.content,
					focusEnabled,
					scrollPosition,
					floatingToolbar,
					extendToolbar
				)
			}
		);

	MAppState(
		makeTropicTag(manager),
		content,
		floatingContent,
		appBar,
		leftNav,
		rightNav,
		flexible,
		make(zeroPoint),
		mouseDown,
		appWH,
		scrollInspect,
		extractMComponentGroupState(m.style),
	);
}

letContentAndSize(manager : MaterialManager, parent : MFocusGroup, content : Tropic, style : [MAppStyle], state : MAppState,
	m2t : (Material, MFocusGroup) -> Tropic) -> Tropic {

	TGroup2(
		TAttachBox(TDisplay("MAppSize"), state.wh),
		TInteractive([TMouseDownGhost(state.down), TMouseXY(state.point)], TRectangle(interactiveRectangleStyle, TGhost("MAppSize")))
	)
	|> (\t -> TLet("MAppSize", content, t))
	|> (\f ->
		TLet(
			"MAppContent",
			MComponentGroup2T(
				manager,
				parent,
				"MAppContent",
				concat(state.state, [MFocusEnabled(state.content.second), MFocusId(const(2)), AccessRole("document")]),
				\p ->
					(\p2 -> state.content.first
					|> (\m -> m2t(m, p2))
					|> TBaseAlignA
					|> (\t ->
						if (contains(style, MNoContentBorder()))
							t
						else
							TBorder4(8., t))
					)
					|> (\t ->
						if (contains(style, MNoScroll()))
							TCenterXIn(t(p), TFillXY())
						else if (eitherMap(state.appBar, \ab -> isSome(ab.floatingToolbar) || isSome(ab.extendToolbar), false))
							t(p)
						else
							MScroll2T(
								manager,
								p,
								MScroll(
									MGetFocusGroup(t),
									TFillXY(),
									[
										state.scrollInspect,
										MScrollKeysEnabled(const(true)),
									]
									|> (\st -> arrayPushMaybe(st, maybeMap(state.appBar, \ab -> MScrollPosition(ab.scrollPosition))))
								),
								m2t
							)
					)
			),
			f
		)
	)
}

letAppBar(manager : MaterialManager, parent : MFocusGroup, content : Tropic, state : MAppState, m2t : (Material, MFocusGroup) -> Tropic) -> Tropic {

	makeAppBar = \ab -> {
		extTool =
			eitherMap(
				ab.extendToolbar,
				\eab : MExtendedAppBarState -> switch (ab.content : Material) {
							MToolbar(expander, title, right, style):
								MToolbar(
									expander,
									title,
									right,
									replaceStruct(style, MExtendedToolbar(eab.trigger, eab.style))
									|> (\st : [MToolbarStyle] -> eitherMap(eab.image, \im : MToolbarStyle -> arrayPush(st, im), st))
								)
								|> (\m -> MConstruct([makeSubscribe2(feq(ab.scrollPosition, zeroPoint), \v ->
										if (!v) nextDistinct(eab.trigger, false)
									)], m));
							default: ab.content;
						},
				ab.content
			);

		eitherFn(
			state.flexible,
			\flx ->
				MShow2(
					manager,
					parent,
					flx.showToolbar,
					\p ->
						MComponentGroup2T(
							manager,
							p,
							"MAppBar",
							[
								MFocusEnabled(ab.focusEnabled),
								MFocusId(const(0)),
								AccessRole("toolbar")
							],
							\p2 ->
								switch (extTool : Material) {
									MToolbar(expander, title, right, style):
										MToolbar2T(
											manager,
											p2,
											MToolbar(
												expander,
												title,
												right,
												replaceStruct(style,
													MShowExpander(fand(flx.showExpander, extractStruct(style, MShowExpander(const(true))).show))
												)
											),
											m2t
										);
									default: m2t(extTool, p2);
								}
						)
				),
			\ ->
				MComponentGroup2T(
					manager,
					parent,
					"MAppBar",
					[
						MFocusEnabled(ab.focusEnabled),
						MFocusId(const(0)),
						AccessRole("toolbar")
					],
					\p -> m2t(extTool, p)
				)
		)
		|> (\t ->
				eitherMap(
					ab.floatingToolbar, \ft ->
		 			TConstruct(ft.subs,	TCollapsingBox(manager, parent, t, ft.translation, ft.expanded)),
		 			t
		 		)
			);
	}

	eitherMap(
		state.appBar,
		\ab ->
			TLet("MAppBar", makeAppBar(ab), content),
		content
	)
}

letFloatingContent(manager : MaterialManager, parent : MFocusGroup, content : Tropic, state : MAppState, m2t : (Material, MFocusGroup) -> Tropic) -> Tropic {
	TLet(
		"MAppFloatingContent",
		MComponentGroup2T(
			manager,
			parent,
			"MAppFloatingContent",
			[
				MFocusEnabled(state.floatingContent.second),
				MFocusId(const(4)),
				AccessRole("presentation")
			],
			\p ->
				m2t(
					MLines2(
						state.floatingContent.first,
						MSelect(manager.floatingActions, \fac : [flow] -> MLinesA(
							map(fac, \l : flow -> cast(l : flow -> Material))
						))
					),
					p
				)
		),
		content
	)
}

letFlextibleApp(content : Tropic, state : MAppState) -> Tropic {
	eitherMap(
		state.flexible,
		\flx ->
			TConstruct(
				[
					make2Subscribe(flx.persistent, flx.showExpander, \p, se -> {
						maybeApply(state.leftNav, \ln -> deferred(\ -> nextDistinct(ln.expander, p && !se)));
						nextDistinct(flx.persistentB, p);
					})
				],
				content
			),
		content
	)
}

letExpander(manager : MaterialManager, parent : MFocusGroup, content : Tropic, state : MAppState,
	m2t : (Material, MFocusGroup) -> Tropic, left : bool) -> Tropic {
	eitherFn(
		if (left) state.leftNav else state.rightNav,
		\nav -> {
			eContent =
				switch (nav.content) {
					MSideNav(h, l, ex, st): {
						MSideNav(
							h,
							l,
							ex,
							replaceStructMany(
								st,
								if (nav.mini)
									[MSideNavMini(), MListMinimizedWidth(nav.miniWidth), MSideNavWidth(nav.width)]
								else
									[MSideNavWidth(nav.width)]
							)
						)
					}
					default: nav.content;
				}

			expander2Point = if (left) {\e -> if (e) 0. else -nav.width} else {\e -> if (e) 0. else nav.width};
			ePointX = make(expander2Point(getValue(nav.expander)));
			delta2Point =
				if (left)
					{\d -> min(max(-nav.width, expander2Point(getValue(nav.expander)) + d), 0.)}
				else
					{\d -> min(max(0., expander2Point(getValue(nav.expander)) + d), nav.width)};
			bgMouseDown = make(false);
			mouseDown = ref false;
			startingPoint = ref Point(-1., -1.);
			trigger = make(Pair(fgetValue(ePointX), fgetValue(ePointX)));
			showPanel = fneq(ePointX, expander2Point(false));
			panelName = if (left) "MAppLeftPanel" else "MAppRightPanel";
			bgAlpha =
				if (nav.width != 0.)
					fselect(ePointX, FLift(\ep -> lerp(0., 0.6, 1. - ep / expander2Point(false))))
				else
					const(0.6);

			TGroup2(
				(\ -> TRectangle([Fill(black)], TGhost("MAppSize"))
				|> (\f -> TAlpha(bgAlpha, f))
				|> (\f -> mouseDownAround(manager, None(), bgMouseDown, make(false), nop, f))
				|> disableInteractivesBelow
				|> disableMouseWheelBelow
				|> (\f -> TCursor(FingerCursor(), f)))
				|> (\f -> TShowLazy(fand(fnot(nav.persistent), showPanel), f)),
				(if (!nav.mini)
					(\ -> TTranslate(
						fselect(ePointX, FLift(\ep -> Point(ep, 0.))),
						TDisplay(panelName + "Inner")
						|> (\f -> TShadow(parent, const(2.), f))
					))
					|> (\f -> TRenderOnce(showPanel, f))
				else
					TCropSize(
						TScale(
							fselect(ePointX, FLift(\ep -> Factor(max(nav.width - abs(ep), nav.miniWidth) / nav.width, 1.))),
							TFillWY(nav.width)
						),
						TDisplay(panelName + "Inner")
					)
					|> (\f -> TShadow(parent, const(2.), f)))
				|> (\f -> if (left) f else TCols2(TFillX(), f))
			)
			|> (\f ->
				MEasingAnimation(
					manager,
					parent,
					fif(nav.expander, const(mEnteringDuration), const(mLeavingDuration)),
					fif(nav.expander, const(mDecelerationCurve), const(mAccelerationCurve)),
					trigger,
					\tr -> {
						if (tr.first != tr.second)
							Some(tr)
						else
							None()
					},
					\tr, px -> next(ePointX, lerp(tr.first, tr.second, px)),
					[],
					f
				)
			)
			|> (\f ->
				if (nav.mini)
					TLines2(THeight(TGhost("MAppBar")), f)
				else
					TIf(nav.persistent, TLines2(THeight(TGhost("MAppBar")), f), f)
			)
			|> (\f -> TCropSize(TGhost("MAppSize"), f))
			|> (\f ->
				TConstruct(
					[
						// Close expander on bg click, check if finger movement has begun
						makeSubscribe2(bgMouseDown, \d ->
							if (!d && (!^mouseDown || ^startingPoint == fgetValue(state.point)) && fgetValue(nav.expander))
								next(nav.expander, false)
						),
						makeSubscribe2(state.point, \pt ->
							if (^mouseDown && fgetValue(state.down) && isCurrentInteractionItemId(manager, state.interactionId)) {
								// Block other interaction items if panel is being moved
								if (abs(pt.x - ^startingPoint.x) >= 3.)
									blockOtherInteractionItemIds(manager, state.interactionId);

								// Update panel point
								next(ePointX, delta2Point(pt.x - ^startingPoint.x));
							}
						),
						makeSubscribe2(state.down, \d ->
							if (d) {
								if (fgetValue(nav.swipeEnabled) && !fgetValue(nav.persistent) && !^mouseDown) {
									pt = fgetValue(state.point);

									// Start panel movement
									if (pt.x < (if (left) fgetValue(nav.gap) else getRealStageWidthHeight(manager).width - fgetValue(nav.gap)) ||
										fgetValue(nav.expander)) {
										nextDistinct(trigger, Pair(fgetValue(ePointX), fgetValue(ePointX)));

										mouseDown := true;
										startingPoint := Point(pt.x, pt.y);

										addInteractionItemId(manager, state.interactionId);
									}
								}
							} else if (^mouseDown) {
								// Finish panel movement
								fn = \a, b -> if (left) a > b else a < b;
								next(nav.expander,
									fn(fgetValue(ePointX), expander2Point(false) / 3.0)
								);
								mouseDown := false;
							}
						),
						\ -> subscribe(nav.expander, \e -> nextDistinct(trigger, Pair(fgetValue(ePointX), expander2Point(e))))
					],
					f
				)
			)
			|> (\f -> TLet(panelName, f, content))
			|> (\f ->
				TLet(
					panelName + "Size",
					TIf(
						nav.persistent,
						TScale(
							fif(
								nav.expander,
								const(Factor(1., 1.)),
								const(Factor(if (nav.mini) nav.miniWidth / nav.width else 0., 1.))
							),
							TGhost(panelName + "Inner")
						),
						if (nav.mini)
							TScale(const(Factor(if (nav.mini) nav.miniWidth / nav.width else 0., 1.)), TGhost(panelName + "Inner"))
						else
							TEmpty()
					),
					f
				)
			)
			|> (\f ->
				TLet(
					panelName + "Inner",
					MComponentGroup2T(
						manager,
						parent,
						panelName,
						[
							MFocusEnabled(nav.focusEnabled),
							MFocusId(const(if (left) 1 else 3)),
							AccessRole("list"),
							IScriptBehaviour("expander", nav.expander, ISInputValue([], "bool", false))
						],
						\p -> m2t(eContent, p)
					),
					f
				)
			)
		},
		\ ->
			content
	)
}