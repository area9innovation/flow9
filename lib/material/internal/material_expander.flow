import material/internal/material_button;

// Internal to material

export {
	MExpander2T(manager : MaterialManager, parent : MFocusGroup, m : MExpander, m2t : (Material, MFocusGroup) -> Tropic) -> Tropic;
}

MExpander2T(manager : MaterialManager, parent : MFocusGroup, m : MExpander, m2t : (Material, MFocusGroup) -> Tropic) -> Tropic {
	header = m.header;
	expander = m.expander;
	details = m.details;

	hideSeparator = contains(m.style, MExpanderHideSeparator());
	expandByArrowOnly = contains(m.style, MExpandByArrowOnly());
	enabledState = extractStruct(m.style, MEnabled(const(true)));
	arrowColor = extractStruct(m.style, if (parent.theme.lightBackground) MGrey(600) else MWhite());
	arrowOpacity = extractStruct(m.style, FillOpacity(0.54));
	noDispose = contains(m.style, MNoDispose());
	narrowHeader = contains(m.style, MExpanderNarrowHeader());
	bgStyle = extractStruct(m.style, MExpanderBackgroundStyle([], []));
	front = 
		changeBoolIfRTL(contains(m.style, MExpanderFront()));
	width = extractStruct(m.style, MWidth(-1.0)).width;

	TCopySize2(
		MExpanderHeader(manager, parent, m2t(header, parent), expander, expandByArrowOnly, arrowColor, arrowOpacity, enabledState, narrowHeader, front, width),
		\tr, hd ->
			TLines2(
				hd
				|> (\f -> if (bgStyle.header != []) TGroup2(TRounded(2., 2., 0., 0., bgStyle.header, tr), f) else f),
				(\p ->
					m2t(details(), p)
					|> TBaseAlignA
					|> (\f -> if (bgStyle.details != []) TCopySize(f, \tr2 -> TRounded(0., 0., 2., 2., bgStyle.details, tr2), false) else f)
					|> (\f ->
						if (hideSeparator)
							f
						else
							TLines2(
								MSeparator2T(manager, parent, true)
								|> (\f2 -> TAvailable(f2, TGroup2(TWidth(tr), TFixed(0., 1.)))),
								f
							)
					)
				)
				|> (\f ->
					if (noDispose)
						MRenderOnce2T(manager, parent, expander, f)
					else
						MSelect2T(
							manager,
							parent,
							"MExpanderContent",
							[],
							expander,
							\ex, p ->
								if (ex)
									f(p)
								else
									TEmpty()
						)
				)
			)
	)
}

MExpanderHeader(manager : MaterialManager, parent : MFocusGroup, c : Tropic, expander: DynamicBehaviour<bool>, expandByArrowOnly : bool,
	arrowColor : MColor, arrowOpacity : FillOpacity, enabledState : MEnabled, narrowHeader : bool, front : bool, mWidth : double) -> Tropic {

	iconStyle : [MIconStyle] = [MIconSize(24.0), arrowColor, arrowOpacity];

	icon = MIconToggle2T(
			manager,
			parent,
			MIconToggle(
				"keyboard_arrow_up",
				concat(
					[MToggleFalseIcon("keyboard_arrow_down", iconStyle)],
					ifArrayPush(iconStyle, narrowHeader, MIconButtonBorder(0.))
				),
				[MToggleValue(expander), enabledState, FAccessAttribute("aria-expanded", fif(expander, const("true"), const("false")))]
			)
		)
		|> (if (narrowHeader) idfn else if (front) TBorderRight(16.0) else TBorderLeft(16.0));

	content =
		TBaseAlignA(c)
		|> (\t -> if (mWidth != 0.) TGroup2(t, TFillX()) else t);

	[icon, content]
	|> (\arr -> if (front) arr else reverseA(arr))
	|> TBaselineCols
	|> (\t -> if (mWidth > 0.) TAvailableWidth(t, const(mWidth)) else t)
	|> (\f ->
		if (expandByArrowOnly)
			f
		else
			TCopySize(
				f,
				\t ->
					mouseDownAround(
						manager,
						None(),
						make(false),
						make(false),
						\ -> if (fgetValue(enabledState.enabled)) reverseBehaviour(expander),
						t
					),
				false
			)
	)
}
