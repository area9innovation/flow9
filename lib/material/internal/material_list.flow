import material/internal/material_grid;
import material/selectmarray;
import material/internal/material_list_util;
import material/internal/material_dragdrop;

// Internal to material

export {
	MList2T(manager : MaterialManager, parent : MFocusGroup, m : MList, m2t : (Material, MFocusGroup) -> Tropic) -> Tropic;
	MDynamicList2T(manager : MaterialManager, parent : MFocusGroup, m : MDynamicList, m2t : (Material, MFocusGroup) -> Tropic) -> Tropic;
}

MList2T(manager : MaterialManager, parent : MFocusGroup, m : MList, m2t : (Material, MFocusGroup) -> Tropic) -> Tropic {
	state = makeMListInnerState(defaultListState(manager, parent, m2t), concat(m.style, m.state));

	down = make(false);
	MActivate2T(
		manager,
		parent,
		"MList",
		[
			IScriptBehaviour("selected", state.selection.selected, ISInputValue([], "[int]", true)),
			extractStruct(m.state, IScriptRecordingEnabled(const(true))),
			AccessRole("list"),
			MFocusVertical(true)
		],
		\p ->
			MGetFocusGroup(\p2 -> eitherFn(
				state.reorder,
				\rdr -> {
					grabDelay = extractStructMany(m.state, MGrabDelay(0));

					MReorderGrid2T(
						manager,
						p2,
						mapi(m.lines, \i, line -> MReorderItem(MGetFocusGroup(\par -> MListLine2T(par, const(i), const(line), state, down)), [])),
						rdr.order,
						concat([MEnabled(fminA([state.enabled, rdr.enabled, fnot(down)], false)), MGridFixSize()], grabDelay),
						m2t
					)
				},
				\ ->
					TLines(mapi(m.lines, \i, line -> MListLine2T(p2, const(i), const(line), state, down)))
			))
			|> (\f : Material ->
				eitherMap(
					tryExtractStruct(m.style, MAddScroll(None())),
					\addScroll -> {
						scrl = either(addScroll.scrollInpect, TScrollInspectVisible(make(zeroPoint), make(WidthHeight(-1., -1.))));
						wh = getValue(scrl.widthHeight);
						scrollBox =	wh2Tropic(wh);
						MScroll2T(manager, p, MScroll(f, scrollBox, [scrl]), m2t)
					},
					m2t(f, p)
				)
			)
			|> (\f -> TConstruct(state.subs, f))
			|> (\t -> if (m.lines == []) eitherMap(state.emptyMessage, \em -> TCenter(m2t(em, p)), t) else t)
	)
	|> MListAddAvailable(state)
}

MDynamicListData : (
	lineHeights : Pair<[Maybe<double>], int>, // lineHeights + itemsLength
	items : [MListLine],
	sameHeight : bool
);

MDynamicList2T(manager : MaterialManager, parent : MFocusGroup, m : MDynamicList, m2t : (Material, MFocusGroup) -> Tropic) -> Tropic {

	state = makeMListInnerState(defaultListState(manager, parent, m2t), concat(m.style, m.state));
	scrollPosition : MScrollPosition = extractStruct(m.state, MScrollPosition(make(zeroPoint)));
	addScroll = !contains(m.state, MNoScroll());

	boxH = make(0.);
	availableW = make(0.);
	hgt = make(0.);

	down = make(false);
	draggingItem = make(-1);
	draggingXY = make(zeroPoint);

	changingSize = ref false;
	metricsLock = ref false;
	prevBottomItem : ref Pair<int, double> = ref Pair(0, 0.);
	prevItemsCount : ref Pair<int, double> = ref Pair(0, 0.);
	prevLineHeights : ref Pair<[Maybe<double>], int> = ref Pair([], 0);
	
	itemsLoadQuota = 1000;
	loadQuota = make(itemsLoadQuota);
	
	itemsHeights0 = tryExtractStruct(m.state, MItemsHeights(\__ -> zero));
	heightsTree : ref Tree<int, DynamicBehaviour<Maybe<double>>> = ref makeTree();
	itemsHeights : (int) -> DynamicBehaviour<Maybe<double>> = \i ->
		lookupTreeSet(heightsTree, i, \__ ->
			eitherMap(
				itemsHeights0,
				\ih -> ih.height,
				\j -> const(MListLine2Height(fgetValue(m.items)[j], state))
			)
			|> (\ih : (int) -> Transform<double> -> {
				hg = fgetValue(ih(i));
				make(if (hg > 0.) Some(hg) else None())
			})
		);

	dynListData : Transform<MDynamicListData> =
		fsubselect(m.items, FLift(\itms : [MListLine] -> {
			sh = isNone(itemsHeights0) && !containsStruct(itms, dummySubmenuLine());

			if (sh) {
				il = length(itms);
				ih : Maybe<double> =	
					if (il > 0)
						Some(MListLine2Height(itms[0], state))
					else
						None();

				nextDistinct(hgt, i2d(il) * either(ih, 0.));
				const(
					MDynamicListData(
						Pair([ih], il),
						itms,
						sh
					)
				)
			}
			else
				fsubselect(loadQuota, FLift(\lq -> {
					il = min(length(itms), lq);
					fselect(
						fmerge(generate(0, il, itemsHeights)),
						FLift(\lh : [Maybe<double>] -> {
							nextDistinct(hgt, dsum(map(lh, \v -> either(v, 0.))));
							MDynamicListData(
								Pair(lh, il),
								itms,
								sh
							)
						})
					)
				}))
		}));

	items = fselect(dynListData, FLift(\data -> data.items));
	sameHeight = fselect(dynListData, FLift(\data -> data.sameHeight));
	itemsLength = fselect(dynListData, FLift(\data -> data.lineHeights.second));
	hasItems = fselect(itemsLength, FLift(\il -> il > 0));

	translates : DynamicBehaviour<[DynamicBehaviour<Pair<Point, int>>]> = make([]);

	(\par ->
		MGetFocusGroup(\par2 ->
			SelectMGroup2T(
				manager,
				par2,
				fthrottle(translates, 1),
				\__, __, tr : DynamicBehaviour<Pair<Point, int>>, p -> {
					materialLog("Rerender container " + i2s(getValue(tr).second), MaterialInfo());
					lineHeight = make(0.);
					hgtUns = initUnsM();

					lineId =
						eitherFn(
							state.reorder,
							\rdr ->
								fselect2(fSecondOfPair(tr), rdr.order, FLift2(\trn, sl ->
									if (trn >= 0 && length(sl) > trn)
										sl[trn]
									else
										trn
								)),
							\ ->
								fSecondOfPair(tr)
						);

					lineContent =
						fselect2(items, lineId, FLift2(\itms, i ->
							elementAt(itms, i, dummySingleLine())
						));

					MListLine2T(p, lineId, lineContent, state, down)
					|> (\line -> TAttachHeightTrigger(line, lineHeight, fnot(sameHeight)))
					|> (\t -> TConstruct(
							[
								make2SubscribeTrigger(fnot(sameHeight), lineHeight, lineId, \hg, i -> {
									dispUnsM(hgtUns);
									itemHgt : DynamicBehaviour<Maybe<double>> = itemsHeights(i);
									hgFn = \ -> nextDistinct(itemHgt, Some(hg));

									if (^metricsLock)
										setUnsM(
											hgtUns,
											interruptibleTimer(0, hgFn)
										)
									else
										hgFn();
								}),
								\ -> \ -> dispUnsM(hgtUns)
							],
							t
					))
					|> (\listLine ->
						eitherMap(
							state.reorder,
							\rdr ->
								if (isFConst(rdr.enabled) && !fgetValue(rdr.enabled)) {
									listLine
								} else {
									rdrdown = make(false);
									point = make(Point(-1., -1.));
									hover = make(false);
									grabDelay = extractStruct(m.state, MGrabDelay(300)).delay;

									TVisible(fselect2(draggingItem, lineId, FLift2(\dr, ln -> dr != ln)), listLine)
									|> (\listLineVisible ->
										TCopySize(
											listLineVisible,
											\trop ->
												MFocusClickable2T(
													manager,
													p,
													"MDynamicListDragDropHandle",
													[
														MFocusEnabled(const(false)),
														MClickEnabled(rdr.enabled),
														THovering(hover),
														TPressed(rdrdown),
														MMousePosition(point),
														MOnTouch(grabDelay, \ -> {
															if (!getValue(down)) {
																nextDistinct(draggingXY, getValue(point));
																nextDistinct(draggingItem, fgetValue(lineId));
															}
														}),
														MCursorShape(const(DefaultCursor())),
														MPassClicks(),
														MMobileForceHover()
													],
													\__ -> trop
												),
											true
										)
									)
									|> (\listLineVisible ->
										TConstruct(
											[
												make2Subscribe(hover, fif(rdr.enabled, draggingItem, const(-1)), \h, hId -> if (h && hId >= 0) {
													id = fgetValue(lineId);
													ordr = fgetValue(rdr.order);

													nextDistinct(
														rdr.order,
														insertArray(removeIndex(ordr, findiDef(ordr, eq(hId), -1)), findiDef(ordr, eq(id), -1), hId)
													);
												}),
												makeSubscribe2(fand(rdr.enabled, rdrdown), \d ->
													if (!d)
														nextDistinct(draggingItem, -1)
												)
											],
											listLineVisible
										)
									)
								},
							listLine
						)
					)
					|> makeTropicConstantHeight(Some(0.))
					|> (\listLine -> TTranslate(fFirstOfPair(tr), listLine))
				}
			)
			|> (\f ->
				TransformTAcc2(\t2a -> {
					bf = f |> t2a;

					TAcc(
						bf.form,
						TFormMetrics(
							bf.metrics.width,
							hgt,
							hgt
						),
						bf.minWidth,
						hgt,
						bf.maxWidth,
						hgt,
						zero,
						bf.yFillers,
						bf.addFillers,
						bf.xConstant,
						bf.yConstant,
						bf.disposers
					)
				})
			)
			|> MListAddAvailable(state)
		)
		|> (\f ->
			if (addScroll)
				MScroll2T(
					manager,
					par,
					MScroll(
						f,
						TFillXY(),
						replaceStructMany(extractMScrollStyle(m.state), [scrollPosition, MScrollToFocusEnabled(const(false))])
					),
					m2t
				)
			else
				m2t(f, par)
		)
		|> (\f ->
			TConstruct(
				[
					make3Subscribe(dynListData, scrollPosition.position, boxH, \data, sPosition, boxHeight -> {
						itms = data.items;
						lhgts = data.lineHeights;
						sh = data.sameHeight;

						if (!contains(lhgts.first, None())) {
							metricsLock := true;

							lineHeight = map(lhgts.first, \v -> either(v, 0.));
							il = lhgts.second;

							lineHeight2translate = \idStart, idEnd ->
								if (sh)
									lineHeight[0] * i2d(idEnd - idStart)
								else
									dsum(subrange(lineHeight, idStart, max(0, idEnd - idStart)));

							bottomItem : Pair<int, double> =
								updateWhile(
									if (^prevLineHeights == lhgts)
										^prevBottomItem
									else
										Pair(
											^prevBottomItem.first,
											lineHeight2translate(0, ^prevBottomItem.first)
										),
									\i -> {
										id = i.first;

										if (id < il && id >= 0) {
											if (sPosition.y <= i.second + lineHeight[if (sh) 0 else id]) {
												if (id == 0 || sPosition.y >= i.second) {
													None()
												} else {
													Some(Pair(id - 1, i.second - lineHeight[if (sh) 0 else id - 1]))
												}
											} else {
												if (id == il - 1)
													None()
												else
													Some(Pair(id + 1, i.second + lineHeight[if (sh) 0 else id]))
											}
										} else {
											Some(Pair(0, 0.))
										}
									}
								);

							itemsCount : Pair<int, double> =
								updateWhile(
									if (sh || (^prevBottomItem == bottomItem && ^prevLineHeights == lhgts))
										^prevItemsCount
									else
										Pair(
											^prevItemsCount.first,
											lineHeight2translate(bottomItem.first, bottomItem.first + ^prevItemsCount.first)
										),
									\i : Pair<int, double> -> {
										id = bottomItem.first + i.first;
										heightWithoutBottomItem = i.second - lineHeight[if (sh) 0 else bottomItem.first];

										if (id <= il && id >= 0) {
											if (boxHeight <= heightWithoutBottomItem && addScroll) {
												if (id == 0 || boxHeight >= heightWithoutBottomItem - lineHeight[if (sh) 0 else id - 1])
													None()
												else
													Some(Pair(i.first - 1, i.second - lineHeight[if (sh) 0 else id - 1]))
											} else {
												if (id == il) {
													None()
												} else {
													Some(Pair(i.first + 1, i.second + lineHeight[if (sh) 0 else id]))
												}
											}
										} else {
											Some(Pair(0, 0.))
										}
									}
								);

							if (itemsCount.first > 0) {
								topItem = Pair(bottomItem.first + itemsCount.first, bottomItem.second + itemsCount.second);

								if (^prevLineHeights != lhgts) {
									nextDistinct(
										translates,
										firstOfTriple(foldi(enumFromTo(bottomItem.first, topItem.first - 1), Triple([], 0., 0), \i, acc, id -> {
											itemTranslate = secondOfTriple(acc) + lineHeight2translate(thirdOfTriple(acc), id);

											tr =
												if (length(getValue(translates)) > i) {
													nextDistinct(getValue(translates)[i], Pair(Point(0., itemTranslate), id));
													getValue(translates)[i]
												} else {
													make(Pair(Point(0., itemTranslate), id));
												};

											Triple(arrayPush(firstOfTriple(acc), tr), itemTranslate, id)
										}))
									);
								} else if (^prevBottomItem != bottomItem || ^prevItemsCount != itemsCount) {
									getValue(translates)
									|> (\translatesPrev : [DynamicBehaviour<Pair<Point, int>>] ->
										if (itemsCount.first < length(translatesPrev)) {
											filter(translatesPrev, \tr : DynamicBehaviour<Pair<Point, int>> ->
												getValue(tr).second < topItem.first && getValue(tr).second >= bottomItem.first
											)
											|> uniq;
										} else {
											translatesPrev;
										}
									)
									|> (\translatesPrev : [DynamicBehaviour<Pair<Point, int>>] ->
										if (itemsCount.first > length(translatesPrev)) {
											maxId = either(maxA(map(translatesPrev, \tr -> getValue(tr).second)), -1);

											concat(translatesPrev, generate(0, itemsCount.first - length(translatesPrev), \i -> {
												id0 = maxId + i + 1;
												id = if (id0 > length(itms) - 1) id0 - itemsCount.first else id0;

												make(Pair(Point(0., bottomItem.second + lineHeight2translate(bottomItem.first, id)), id))
											}));
										} else {
											translatesPrev;
										}
									)
									|> (\translatesPrev : [DynamicBehaviour<Pair<Point, int>>] -> {
										bottomLine = bottomItem.first - bottomItem.first % itemsCount.first + itemsCount.first;

										iteri(translatesPrev, \i, trB -> {
											tr = getValue(trB);

											if (tr.second < bottomItem.first || tr.second >= topItem.first) {
												newId =
													(bottomLine + tr.second % itemsCount.first)
													|> (\f2 -> if (f2 >= topItem.first) f2 - itemsCount.first else f2);

												nextDistinct(
													trB,
													Pair(
														Point(
															0.,
															bottomItem.second + lineHeight2translate(bottomItem.first, newId)
														),
														newId
													)
												)
											}
										});

										nextDistinct(translates, translatesPrev);
									})
								};

								prevBottomItem := bottomItem;
								prevItemsCount := itemsCount;
								prevLineHeights := lhgts;

								materialLogFn(
									\ ->
										map(getValue(translates), \tr -> getValue(tr).second)
										|> (\f2 ->
											if (length(f2) != length(uniq(f2)) || either(minA(f2), bottomItem.first) < bottomItem.first ||
												either(maxA(f2), topItem.first - 1) >= topItem.first) {

												println("MDynamicList error");
												println(bottomItem);
												println(topItem);
												println(itemsCount);
												println(f2);
											}
										),
									MaterialInfo(),
									nop
								);

								if (addScroll && !^changingSize && !sh && il != length(itms)
									&& sPosition.y > (fgetValue(hgt) - boxHeight) * i2d(il - itemsLoadQuota / 5) / i2d(il)) {

									changingSize := true;
									newItemsLength = fgetValue(itemsLength) + itemsLoadQuota;

									deferred(\ -> {
										nextDistinct(loadQuota, newItemsLength);
										changingSize := false;
									})
								}
							} else {
								nextDistinct(translates, []);
								prevBottomItem := bottomItem;
								prevItemsCount := itemsCount;
								prevLineHeights := lhgts;
							};

							metricsLock := false;
						}
					})
				]
				|> (\subs ->
					eitherMap(
						state.reorder,
						\rdr ->
							arrayPush(
								subs,
								makeSubscribe(itemsLength, \il -> {
									sl = getValue(rdr.order);
									if (length(sl) < il) {
										nextDistinct(rdr.order, concat(sl, enumFromTo(length(sl), il - 1)))
									} else if (length(sl) > il) {
										nextDistinct(rdr.order, filter(sl, \s -> s < il))
									}
								})
							),
						subs
					)
				),
				f
			)
		)
		|> (\f2 -> TIf(hasItems, f2, eitherMap(state.emptyMessage, \em -> TCenter(m2t(em, par)), TFillX())))
	)
	|> (\f ->
		MActivate2T(
			manager,
			parent,
			"MDynamicList",
			concat(
				[
					IScriptBehaviour("selected", state.selection.selected, ISInputValue([], "[int]", true)),
					AccessRole("list"),
					MFocusVertical(true)
				],
				// |> (\st ->
				// 	eitherMap(
				// 		state.reorder,
				// 		\rdr -> {
				// 			arrayPush(st, IScriptBehaviour("order", rdr.order, ISInputValue([], "[int]", true)));
				// 		},
				// 		st
				// 	)
				// ),
				extractStructMany(m.state, IScriptRecordingEnabled(const(true)))
			),
			f
		)
	)
	|> (\f ->
		eitherMap(
			state.reorder,
			\rdr ->
				TConstruct(
					[
						makeSubscribe2Uns(fif(rdr.enabled, draggingItem, const(-1)), \dr ->
							if (dr >= 0) {
								mouseXY = make(zeroPoint);

								[
									(\par ->
										MListLine2T(par, const(dr), const(fgetValue(items)[dr]), state, down)
										|> (\t -> TAvailableWidth(t, availableW))
										|> (\t -> MGrabAnimation(state.manager, par, t))
									)
									|> (\fn -> MActivate2T(manager, parent, "MDynamicListDraggable", [], fn))
									|> (\t -> TTranslate(
											fselect(mouseXY, FLift(\xy0 -> Point(xy0.x - getValue(draggingXY).x, xy0.y - getValue(draggingXY).y))),
											t
										))
									|> (\t -> MMonitorMousePosition(manager, mouseXY, t)())
								]
							} else {
								[]
							}
						)
					],
					f
				),
			f
		)
	)
	|> (\f -> TAttachWidthCopy(f, availableW))
	|> (\f -> TAttachBoxCopyAvailableHeight(f, boxH))
	|> MListAddAvailable(state)
}

dummySubmenuLine() -> MSubmenuLine {
	MSubmenuLine(MSingleLine("", []), const([]), [], make(false))
}

dummySingleLine() -> MSingleLine {
	MSingleLine("", [])
}