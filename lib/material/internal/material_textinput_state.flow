import material/internal/material_list_util;
import material/internal/tropic_size_util;
import formats/email/email;
import tropic/selecttarray;

export {
	// Set to false for non-native inputs
	// See MNativeInput comments in material.flow for more info
	nativeInputs = ref !isUrlParameterFalse("nativeInputs");

	makeMInputState(manager : MaterialManager, style : [MAutoCompleteStyle], state : [MTextInputState],
		mfocus : MFocus, iScriptBehaviours : MTextEditorIScriptBehaviours) -> MInputState;

	makeMTextEditorIScriptBehaviours(content : DynamicBehaviour<string>, style : [MAutoCompleteStyle],
		state : [MTextInputState]) -> MTextEditorIScriptBehaviours;

	makeMTextEditorView(manager : MaterialManager, inputState : MInputState, m2t : (Material, MFocusGroup) -> Tropic) -> Tropic;
	makeNativeEditorView(manager : MaterialManager, parent : MFocusGroup, state : [MTextInputState],
		inputState : MInputState, m2t : (Material, MFocusGroup) -> Tropic) -> Tropic;

	defaultCompletionFn(manager : MaterialManager, parent : MFocusGroup, style : [MAutoCompleteStyle]) -> MCompletionFn;
	completionLineHeight(textMetrics : FormMetrics, inputBorders : MInputBorders) -> double;
	addMAutocompleteSuggestionInLine(inputState : MInputState) -> (Tropic) -> Tropic;

	MTextEditorIScriptBehaviours(
		content : DynamicBehaviour<string>,
		inputType : InputType,
		autoCompleteType : Maybe<AutoCompleteType>,
		label : string,
		dynamicSize : bool,
		focus : DynamicBehaviour<bool>,
		position : DynamicBehaviour<int>,
		selection : DynamicBehaviour<int>,
		readOnly : bool,
		numeric : bool,
		editIcon : Maybe<DynamicBehaviour<bool>>,
		filterAction : IScriptBehaviourDisposable1,
		error : Maybe<MInputErrorState>,
		iScriptBehaviours : [IScriptBehaviour],
		useNativeInput : bool,
		isTextInputInPopup : bool
	);

	MTextInputSkin ::= MFilled, MOutlined, MTextInputPlain;
		MTextInputPlain();

	MInputState(
		manager : MaterialManager,
		parent : MFocusGroup,
		content : DynamicBehaviour<string>,
		inputType : InputType,
		autoCompleteType : Maybe<AutoCompleteType>,
		mfocus : MFocus,
		focus : DynamicBehaviour<bool>,
		position : DynamicBehaviour<int>,
		selection : DynamicBehaviour<int>,
		cursorShape : DynamicBehaviour<CursorShape>,
		textStyle : Transform<[MTextStyle]>,
		tTextMetrics : Transform<FormMetrics>,
		smallEdit : bool,
		label : string,
		dynamicSize : bool,
		linesCount : int,
		underline : Maybe<DynamicBehaviour<Pair<[TGraphicsStyle], double>>>,
		multiline : bool,
		wordWrap : bool,
		numeric : bool,
		numericStep : Maybe<MNumericStep>,
		noNumericArrows : bool,
		readOnly : bool,
		preventContextMenu : bool,
		color : MColor,
		width : double,
		textWidth : DynamicBehaviour<double>,
		maxHeight : double,
		align : AutoAlignType,
		iconSize : double,
		iconBorders : double,
		startIcon : MLeftIcon,
		startButton : Maybe<MStartCustomButtonT>,
		editIcon : Maybe<DynamicBehaviour<bool>>,
		endButton : Maybe<Transform<string>>,
		endCustomButton : Maybe<Material>,
		inputBorders : MInputBorders,
		noLeftBorder : bool,
		maxChars : int,
		backgroundStyle : MInputBackgroundStyle,
		labelStyle : Transform<[CharacterStyle]>,
		floatingLabel : Maybe<MInputFloatingLabelState>,
		cursorState : MInputCursorState,
		popup : Maybe<MInputPopupState>,
		autocomplete : Maybe<MInputAutocompleteState>,
		error : Maybe<MInputErrorState>,
		limitError : Maybe<MInputLimitErrorState>,
		helperText : Maybe<MInputHelperState>,
		password : Maybe<MInputPasswordState>,
		eatKeyDown : (KeyEvent) -> bool,
		processedKeyDown : Maybe<MInputProcessKeyDown>,
		filterFn : Maybe<MInputFilter>,
		filterAction : (string) -> void,
		positionOnFocus : Maybe<(content : string, previous : int) -> int>,
		selectionOnFocus : Maybe<(content : string, previous : int) -> int>,
		clearContent : () -> void,
		goToPrev : () -> void,
		subs : [() -> () -> void],
		shift : Transform<double>,
		useNativeInput : bool,
		condensed : bool,
		skin : MTextInputSkin,
		scrollStyle : [MScrollStyle],
		allowEmojis : bool
	);

	MInputAutocompleteState(
		matchers : Transform<[Pair<int, SentenceMatcher>]>,
		sentenceMatcher : MSentenceMatcher,
		completionFn : MCompletionFn,
		sentences : DynamicBehaviour<[SentenceMatch]>,
		selected : DynamicBehaviour<int>,
		showAllOnEmpty : bool,
		maxResults : int,
		autoSelect : bool,
		includeSpaces : bool,
		currentMatches : Maybe<MCurrentMatches>,
		fill : [TGraphicsStyle],
		setWord : (word : string) -> void,
		isTextInputInPopup : bool,
		dynListMode : bool,
		sameZorderMode : bool,
		placementType : MSuggestionsPlacementType,
		inLine : Maybe<MAutoCompleteInLineState>,
		updateDelay : int,
		showMoreResults : Maybe<DynamicBehaviour<Pair<int, int>>>,
		autoCompleteAsync : Maybe<MAutoCompleteAsyncState>
	);

	MAutoCompleteInLineState(
		bestSuggestion : Transform<Maybe<Pair<string, string>>>,
		showPopup : bool
	);

	MAutoCompleteAsyncState(
		makeRequest : (txt : string, onResponse : ([string]) -> void) -> void,
		minChars : int,
		currentRequests : DynamicBehaviour<int>,
		prevRequestText : DynamicBehaviour<Maybe<string>>,
		setWordUpdateEnabled : DynamicBehaviour<bool>
	);

	MInputPopupState(
		openMenu : MOpenMenu,
		inputWH : DynamicBehaviour<WidthHeight>,
		contentWH : DynamicBehaviour<WidthHeight>,
		boxWH : DynamicBehaviour<WidthHeight>,
		scrollPosition : DynamicBehaviour<Point>,
		positionScale : DynamicBehaviour<PositionScale>,
		elevation : Transform<double>,
		outterBorder : Maybe<RMOutterBorder>,
		customMetrics : MCustomPopup
	);

	MInputErrorState(
		text : Transform<Maybe<Pair<string, bool>>>,
		lines : int,
		height : (MFocusGroup) -> double,
		requiredField : bool,
		color : Transform<MThemeColor>,
		style : Transform<[MTextStyle]>,
		ok : Maybe<MInputIsOk>,
		error : DynamicBehaviour<Pair<string, [MTextStyle]>>
	);

	MInputHelperState(
		text : Transform<Maybe<string>>,
		persistent : bool,
		lines : int,
		height : double,
		helper : DynamicBehaviour<Pair<string, [MTextStyle]>>
	);

	MInputLimitErrorState(
		lines : int,
		height : double,
		inline : bool,
		limit : DynamicBehaviour<Pair<string, [MTextStyle]>>
	);

	MInputPasswordState(
		showPassword : DynamicBehaviour<bool>,
		style : DynamicBehaviour<[MIconStyle]>
	);

	MInputFloatingLabelState(
		labelSize : double,
		labelSizeFocused : double,
		aboveLabel : double,
		betweenLabels : double,
		showFloatingLabel : DynamicBehaviour<bool>,
		labelWidth : DynamicBehaviour<double>,
		outlinedColor : DynamicBehaviour<MColor>,
		progress : DynamicBehaviour<double>
	);

	MInputCursorState(
		color : MColor,
		opacity : double,
		width : double
	);

	passwordFilter = \state : [MTextInputState] -> {
		inpe = extractStruct(state, MInputError(const(None()), []));
		inpf = extractStruct(state, MInputFilter(\c, __ -> c));
		defErColor = extractStruct(inpe.style, MInputErrorColor(const(MErrorColor()))).color;
		erColor = make(fgetValue(defErColor));
		passwordEr = make(None());

		specialCharacters = "!\"#$%&'()*+,-./:;<=>?@[\\]^_`{|}~";

		haveBothCasesAndDigitOrSpecChar = \c -> stringFold(c, Triple(false, false, false), \acc, i -> {
			char = fromCharCode(i);

			Triple(
				// check if exist upperCase letter
				firstOfTriple(acc) || (isLetter(char) && char == toUpperCase(char)),
				// check if exist lowerCase letter
				secondOfTriple(acc) || (isLetter(char) && char == toLowerCase(char)),
				// check if exist digit or special character
				thirdOfTriple(acc) || isDigit(char) || strContains(specialCharacters, char)
			);
		})
		|> (\f : Triple<bool, bool, bool> -> firstOfTriple(f) && secondOfTriple(f) && thirdOfTriple(f));

		replaceStructMany(
			state,
			[
				MInputFilter(\c, foc -> {
					deferred(\ ->
						if (strlen(c) < 8) {
							nextDistinct(erColor, fgetValue(defErColor));
							nextDistinct(passwordEr, Some(Pair(_("Password is too short"), true)))
						} else if (!containsLetters(c)) {
							nextDistinct(erColor, fgetValue(defErColor));
							nextDistinct(passwordEr, Some(Pair(_("Password is too weak"), true)))
						} else if (!haveBothCasesAndDigitOrSpecChar(c)) {
							nextDistinct(erColor, MOrangeA(400));
							nextDistinct(passwordEr, Some(Pair(_("Fair password"), false)))
						} else {
							nextDistinct(erColor, MGreenA(400));
							nextDistinct(passwordEr, Some(Pair(_("Strong password"), false)))
						}
					);

					c
				}),
				MInputError(fifsome(inpe.text, inpe.text, passwordEr), replaceStruct(inpe.style, MInputErrorColor(erColor)))
			]
		)
	};

	emailFilter = \state : [MTextInputState] -> {
		inpe = extractStruct(state, MInputError(const(None()), []));
		inpf = extractStruct(state, MInputFilter(\c, __ -> c));
		emailEr = make(None());

		replaceStructMany(
			state,
			[
				MInputFilter(\c, foc -> {
					deferred(\ -> nextDistinct(emailEr, if (!foc && !isEmail(c)) Some(Pair(_("Invalid email format"), true)) else None()));

					c
				}),
				MInputError(fifsome(inpe.text, inpe.text, emailEr), inpe.style)
			]
		)
	};

	defEatKeyDown(multiline : bool, readOnly : bool) -> (KeyEvent) -> bool {
		\k : KeyEvent -> {
			k.keycode == KEY_LEFT ||
			k.keycode == KEY_RIGHT ||
			k.keycode == KEY_UP ||
			k.keycode == KEY_DOWN ||
			(k.keycode == KEY_ESCAPE && !readOnly) ||
			(k.keycode == KEY_BACKSPACE && !readOnly) ||
			(k.keycode == KEY_TAB && !readOnly && multiline) ||
			(k.keycode == KEY_ENTER) ||
			(k.keycode == KEY_DELETE && !k.shift && !readOnly) ||
			(k.keycode == KEY_ENTER && !readOnly) ||
			(k.keycode == KEY_A && k.ctrl) ||
			((k.keycode == KEY_C || k.keycode == KEY_INSERT) && k.ctrl) ||
			(k.keycode == KEY_X && k.ctrl) ||
			(k.keycode == KEY_DELETE && k.shift) ||
			(
				strlen(k.utf) == 1 && !readOnly &&
				k.keycode != KEY_BACKTAB &&
				(k.keycode != 86 || !k.ctrl) &&
				(k.keycode != 187 && k.utf != "=" && !k.ctrl) &&
				(k.keycode != 95 && k.utf != "-" && !k.ctrl)
			)
		}
	};
}

numericFilter(s) {
	dotB = ref false;

	fold(enumFromTo(0, strlen(s) - 1), "", \acc, i ->
		getCharAt(s, i)
		|> (\c ->
			if (isDigit(c) || (i == 0 && c == "-"))
				acc + c
			else if ((c == "." || c == ",") && !^dotB && i != 0 && (i != 1 || getCharAt(s, 0) != "-")) {
				dotB := true;
				acc + c
			} else
				acc
		)
	);
}

makeMInputState(manager : MaterialManager, style : [MAutoCompleteStyle], state : [MTextInputState],
	mfocus : MFocus, iScriptBehaviours : MTextEditorIScriptBehaviours) -> MInputState {
	parent = mfocus.parent;
	content = iScriptBehaviours.content;
	inputType = iScriptBehaviours.inputType;
	autoCompleteType = iScriptBehaviours.autoCompleteType;
	readOnly = iScriptBehaviours.readOnly;
	numeric = iScriptBehaviours.numeric;
	numericStep = if (numeric) tryExtractStruct(style, MNumericStep(const(1.))) else None();
	noNumericArrows = contains(style, MTextInputNoNumericArrows());
	editIcon = iScriptBehaviours.editIcon;
	useNativeInput = iScriptBehaviours.useNativeInput;
	label = iScriptBehaviours.label;
	dynamicSize = iScriptBehaviours.dynamicSize;
	flAlwaysOnTop = contains(style, MFloatingLabelAlwaysOnTop());
	hasFloatingLabel = (contains(style, MFloatingLabel()) || flAlwaysOnTop) && label != "";
	linesCount = extractStruct(style, MMaxLines(1)).lines;
	showUnderline = extractStruct(style, MShowUnderline(true)).show;
	multiline = extractStruct(style, Multiline(false)).multiline;
	wordWrap = multiline && extractStruct(style, WordWrap(true)).wordWrap;
	condensed = extractStruct(style, MCondensed(false)).condensed;
	color = extractMColor(parent, style, MAccentColor());
	width = extractStruct(style, MWidth(-1.)).width;
	textWidth = make(0.);
	maxHeight = extractStruct(style, MMaxHeight(-1.)).height;
	align = extractStruct(style, AutoAlign(AutoAlignNone())).autoalign;
	filterAction = iScriptBehaviours.filterAction;
	smallEdit = contains(style, MEditDialog());
	elevation = tryExtractStruct(style, MElevation(const(8.)));
	isPopup = isSome(elevation) || smallEdit;
	eatKeyDown = extractStruct(state, MEatKeyDown(defEatKeyDown(multiline, readOnly))).fn;
	processedKeyDown = tryExtractStruct(state, MInputProcessKeyDown(\__ -> true));
	filterFn = tryExtractStruct(state, MInputFilter(\c, __ -> c));
	textInputCursorShape = make(DefaultCursor());
	noLeftBorder = contains(style, MInputNoLeftBorder());
	preventContextMenu = contains(state, MInputPreventContextMenu());
	scrollStyle = extractStruct(style, MTextInputScrollStyle([])).style;
	allowEmojis = extractStruct(style, MTextInputAllowEmojis(false)).allowEmojis;
	skin = calculateMTextInputSkin(style);

	customTextStyle : [MParagraphStyle] = extractStruct(style, MCustomTextStyle([])).style;

	// Text Style
	mTextStyle =
		concatA([
			extractMTextStyleDef(
				customTextStyle,
				MFontStyleBundle(getTextColor(parent), if (condensed) MBody2() else MSubtitle1(), true)
			),
			extractStructMany(customTextStyle, LetterSpacing(0.0)),
			extractStructMany(customTextStyle, EscapeHTML(true)),
			extractStructMany(customTextStyle, MDynamicColor(const(MBlack())))
		]);

	textStyle = fconcat(extractStruct(style, MDynamicTextStyle(const(mTextStyle))).style, const([LocalizationEnabled(false)]));
	liftFn : FLift<[MTextStyle], FormMetrics> = FLift(\ts : [MTextStyle] -> getTWordMetrics(TText(" ", MTextStyle2CharacterStyle(parent, ts)), makeTree()));
	tTextMetrics = fselect(textStyle, liftFn);

	prev = ref getValue(content);

	sideBorder =
		switch (skin : MTextInputSkin) {
			MTextInputPlain(): {
				if (isPopup && !noLeftBorder && !smallEdit) 8. else 0.;
			}
			MFilled(): {
				12.;
			}
			MOutlined(): {
				12.;
			}
		}
	inputBordersTopDef = 
		switch (skin : MTextInputSkin) {
			MTextInputPlain(): {
				if (hasFloatingLabel) (if (condensed) 20. else 28.) else if (condensed) 12. else 16.;
			}
			MFilled(): {
				if (hasFloatingLabel) 25.else if (condensed) 11. else 18.;
			}
			MOutlined(): {
				if (!hasFloatingLabel && condensed) 11. else 17.;
			}
		}
	inputBorders =
		extractStruct(
			style,
			MInputBorders(
				sideBorder,
				inputBordersTopDef,
				sideBorder,
				switch (skin : MTextInputSkin) {
					MTextInputPlain(): {
						if (condensed) 12. else 16.;
					}
					MFilled(): {
						if (hasFloatingLabel) (if (condensed) 8. else 10.) else if (condensed) 10. else 17.;
					}
					MOutlined(): {
						if (!hasFloatingLabel && condensed) 11. else 17.;
					}
				}
			)
		);

	// Cursor
	cursorStyle = extractStruct(style, MInputCursor([])).style;
	cursorColor = extractMColor(parent, cursorStyle, color);
	cursorOpacity = extractStruct(cursorStyle, FillOpacity(1.)).opacity;
	cursorWidth = extractStruct(cursorStyle, MWidth(2.)).width;
	cursorState = MInputCursorState(cursorColor, cursorOpacity, cursorWidth);

	// Underline
	inputUnderline : Maybe<DynamicBehaviour<Pair<[TGraphicsStyle], double>>> =
		if (showUnderline)
			Some(make(Pair([MFill(color)], 0.)))
		else
			None();

	emptyUnderline = Pair([], 2.);

	// TTextInputState
	focus = cloneBehaviour(mfocus.focused);
	position = iScriptBehaviours.position;
	selection = iScriptBehaviours.selection;

	// Popup
	popup =
		if (isPopup && !contains(style, MSuggestionsSameZorderMode()))
			Some(
				MInputPopupState(
					MOpenMenu(make(false)),
					makeWH(),
					makeWH(),
					makeWH(),
					extractStruct(style, MScrollPosition(make(zeroPoint))).position,
					make(zeroPositionScale),
					either(elevation, MElevation(const(0.))).elevation,
					maybeMap(tryExtractStruct(style, MPopupOutterBorder(0.)), \pob -> RMOutterBorder(pob.border)),
					extractStruct(style, MCustomPopup(None(), None(), None())),
				)
			)
		else
			None();

	backgroundDefaultColor = contrastingColor(parent);
	backgroundFill =
		extractStruct(
			style,
			if (skin == MFilled() && width > 0.0)
				MInputBackgroundStyle([Fill(backgroundDefaultColor), FillOpacity(0.06)], [Fill(backgroundDefaultColor), FillOpacity(0.12)])
			else if (!isPopup || !iScriptBehaviours.isTextInputInPopup)
				MInputBackgroundStyle([], [])
			else
				MInputBackgroundStyle([], [MFill(MDialogMColor(getLightBackground(parent)))])
		);

	// Icons
	iconSize = extractStruct(style, MIconSize(if (condensed) 20. else 24.)).size;
	iconBorders = extractStruct(style, MIconButtonBorder(8.)).border;
	showDropDownArrow = !readOnly && extractStruct(style, MShowDropDownArrow(false)).show;
	mClearIcon = extractStruct(style, MShowClearIcon2(mobile && (width <= 0. || width > 96.), false, false));
	showClearIcon = (mClearIcon.onFocus || mClearIcon.onHover || mClearIcon.always) && !readOnly;

	// Left icon
	leftIcon = extractStruct(style, MLeftIcon("", []));

	// Left Button
	leftButtonDef =
		MStartCustomButton(MIcon("search", [MIconSize(iconSize)]), MIcon("arrow_back", [MIconSize(iconSize)]), 56., true);

	showLeftButton = extractStruct(style, MShowLeftButton(false)).show;

	leftButton =
		if (showLeftButton)
			Some(extractStruct(style, leftButtonDef))
		else
			tryExtractStruct(style, leftButtonDef);

	// Right Button
	rightButton =
		if (showClearIcon)
			Some(
				fif(
					fand(
						fOr(
							fand(
								mfocus.enabled,
								fthrottle2(
									fOr(
										if (mClearIcon.onHover) mfocus.hover else const(false),
										if (mClearIcon.onFocus) mfocus.focused else const(false)
									),
									10
								)
							),
							const(mClearIcon.always)
						),
						fneq(content, "")
					),
					const("clear"),
					if (showDropDownArrow) fif(mfocus.focused, const("arrow_drop_up"), const("arrow_drop_down"))
					else const("")
				)
			)
		else if (showDropDownArrow)
			Some(fif(
				fand(mfocus.enabled, mfocus.focused),
				const("arrow_drop_up"),
				const("arrow_drop_down")
			))
		else
			None();

	rightCustomButton = maybeMap(tryExtractStruct(style, MRightCustomButton(TEmpty())), \rb -> rb.button);

	// Floating Label
	inactiveColor = contrastingColor(parent);
	inactiveOpacity = defaultInactiveItemLabelOpacity(MColor2int(color) == black);

	unfocusedUnderline = extractStruct(style, MUnderlineUnfocusedStyle([Fill(inactiveColor), FillOpacity(inactiveOpacity / 4.)])).style;

	mLabelStyle =
		extractMTextStyleDef(
			extractStruct(style, MLabelTextStyle(if (hasFloatingLabel) [] else mTextStyle)).style,
			MFontStyleBundle(getTextColor(parent), MCaptionSolid(), true)
		);
	labelStyle0 = MTextStyle2CharacterStyle(parent, mLabelStyle);
	labelSize = extractStruct(labelStyle0, FontSize(12.)).size;

	floatingLabelStyle =
		maybeMap(
			tryExtractStruct(style, MFloatingLabelStyle(mLabelStyle)),
			\fls -> MTextStyle2CharacterStyle(parent, fls.style)
		);

	labelStyle =
		if (hasFloatingLabel) either(floatingLabelStyle, labelStyle0)
		else labelStyle0;

	labelStyleB = make(labelStyle);

	inactiveStyle = replaceStruct(labelStyle, FillOpacity(inactiveOpacity));
	pressedStyle = replaceStruct(labelStyle, if (hasFloatingLabel) MFill(color) else FillOpacity(inactiveOpacity));
	errorTextStyle = replaceStruct(labelStyle, FillOpacity(1.));

	floatingLabel =
		if (hasFloatingLabel) {
			defFSize = if (condensed) 13. else 16.;
			fSize = eitherMap(floatingLabelStyle, \fls -> extractStruct(fls, FontSize(defFSize)).size, defFSize);
			fSizeFocused = max(0., labelSize);
			betweenFLabels =
				switch (skin : MTextInputSkin) {
					MTextInputPlain(): if (condensed) 4.0 else 8.0;
					MFilled(): -2.0 + (1. - inputBorders.top/inputBordersTopDef) * 8.;
					MOutlined(): (if (!hasFloatingLabel && condensed) 8.0 else 13.0) + (inputBorders.top - inputBordersTopDef);
				}
			aboveFLabel =
				switch (skin : MTextInputSkin) {
					MTextInputPlain(): inputBorders.top - fSizeFocused - betweenFLabels;
					MFilled(): 8.0 + (inputBorders.top - inputBordersTopDef);
					MOutlined(): inputBorders.top - fSizeFocused - betweenFLabels;
				}
			showFLabel = flAlwaysOnTop || fgetValue(mfocus.focused) || getValue(content) != "";

			Some(
				MInputFloatingLabelState(
					fSize,
					fSizeFocused,
					aboveFLabel,
					betweenFLabels,
					make(showFLabel),
					make(0.),
					make(MCustomColor(inactiveColor)),
					make(if (showFLabel) 0.0 else 1.0)
				)
			)
		} else {
			None()
		};

	// Error
	maxChars = extractStruct(style, MaxChars(-1)).n;

	limitError =
		if (maxChars > 0 && extractStruct(style, MShowMaxChars(true)).show)
			Some(MInputLimitErrorState(1, 16., contains(style, MInlineMaxChars()), make(Pair(if (dynamicSize) "" else " ", []))))
		else
			None();

	defaultStyle = [MCaption()];

	error = iScriptBehaviours.error;

	helperText =
		eitherMap(
			tryExtractStruct(state, MHelperText(const(None()), true)),
			\ht ->
				Some(
					MInputHelperState(
						ht.text,
						ht.persistent,
						1,
						16.,
						make(Pair(if (dynamicSize) "" else " ", []))
					)
				),
			None()
		);

	// Password
	passwordMode = extractStruct(style, PasswordMode(false)).password || inputType == PasswordType();
	showPasswordFallbackType =
		if (inputType == PasswordType()) {
			TextType();
		} else {
			inputType;
		}

	password =
		if (passwordMode)
			Some(
				MInputPasswordState(
					extractStruct(state, MInputShowPassword(make(false))).show,
					make([MWhite(), FillOpacity(0.)])
				)
			)
		else
			None();

	// Autocomplete
	startSearch = extractStruct(style, MAutoCompleteStartSearch(0, 0));
	preparedSentenceMatcher = extractStruct(style, MPreparedSentenceMatcher(const(dummySentenceMatcher)));
	sentenceMatcher = extractStruct(style, MSentenceMatcher(simpleBuildSentenceMatcher, makeAutocompleteMatcher(startSearch.minChars)));

	matchers =
		if (preparedSentenceMatcher.matcher != const(dummySentenceMatcher)) {
			Some(fselectLift(preparedSentenceMatcher.matcher, \mtchr ->
				[Pair(0, mtchr)]
			));
		} else {
			maybeMap(
				tryExtractStruct(style, MDictionaryDynamic(const([]))),
				\dictionaries ->
					fmapi(dictionaries.dictionaries, \i, mdictionary ->
						Pair(i, sentenceMatcher.matcher(filter(concatA(map(strSplit(mdictionary, "\n"), \s -> strSplit(s, fromCharCode(0x000D)))), \s -> strlen(s) > 0)))
					)
			)
		};

	autoCompleteAsync =
		maybeMap(
			tryExtractStruct(style, MAutoCompleteAsync(nop2)),
			\async -> {
				MAutoCompleteAsyncState(
					async.makeRequest,
					startSearch.minChars,
					make(0),
					make(None()),
					make(false)
				)
			}
		);

	autocomplete =
		if (isSome(matchers) || isSome(autoCompleteAsync)) {
			composeContentFn = extractStruct(style, TMatchedHandler(\m1, __, __ -> m1)).fn;
			maxResults = extractStruct(style, MMaxResults(10)).results;
			keepFocusOnSelect = contains(style, MKeepFocusOnSelect());

			setWord = \word : string -> {
					maybeApply(autoCompleteAsync, \as -> nextDistinct(as.setWordUpdateEnabled, true));
					newContent = composeContentFn(word, getValue(content), getValue(position));
					next(content, newContent);

					cw = getCurrentWordPosition(getValue(content), getValue(position), [newContent]);
					newPosition = forceRange(firstOfPair(cw) + strlen(newContent), 0, strlen(getValue(content)));
					nextDistinct(position, newPosition);
					nextDistinct(selection, newPosition);

					if (!multiline && !keepFocusOnSelect) nextDistinct(mfocus.focused, false);
					
					maybeApply(autoCompleteAsync, \as -> nextDistinct(as.setWordUpdateEnabled, false));
			}

			sentences = make([]);

			inLine =
				maybeMap(
					tryExtractStruct(style, MSuggestionInLine(false)),
					\inline -> MAutoCompleteInLineState(
						fselect(sentences, FLift(\sent -> {
							cont = getValue(content);
							findmap(sent, \s : SentenceMatch ->
								if (startsWith(toLowerCase(s.sentence), toLowerCase(cont)))
									Some(Pair(s.sentence, strRight(s.sentence, strlen(cont))))
								else None()
							)
						})),
						inline.showPopup
					)
				);

			showMoreResults =
				if (maxResults >= 0 && contains(style, MAutoCompleteShowMoreButton())) Some(make(Pair(maxResults, 0)))
				else None();

			Some(
				MInputAutocompleteState(
					either(matchers, const([])),
					sentenceMatcher,
					extractStructMany(style, TCompletionFn(\__, __, __ -> TEmpty()))
					|> (\f ->
						if (length(f) > 0)
							MCompletionFn(f[0].fn)
						else
							eitherFn(
								tryExtractStruct(style, MCompletionFn(\__, __, __ -> TEmpty())),
								idfn,
								\ -> defaultCompletionFn(manager, parent, style)
							)
					),
					sentences,
					make(-1),
					contains(style, MShowAllOnEmpty()),
					maxResults,
					contains(style, MAutoSelect()),
					extractStruct(style, MIncludeSpaces(!multiline)).includeSpaces,
					tryExtractStruct(style, MCurrentMatches(nop1)),
					extractStruct(style, MSuggestionsBackgroundStyle(backgroundFill.focused)).style,
					setWord,
					iScriptBehaviours.isTextInputInPopup,
					contains(style, MSuggestionsDynamicListMode()),
					contains(style, MSuggestionsSameZorderMode()),
					extractStruct(style, MSuggestionsPlacement(MTryBottomFirst())).type,
					inLine,
					startSearch.wait,
					showMoreResults,
					autoCompleteAsync
				)
			)
		} else
			None();

	positionOnFocus =
		eitherMap(
			tryExtractStruct(state, MPositionOnFocus(\__, __ -> -1)),
			\pof -> Some(pof.fn),
			maybeMap(autocomplete, \__ -> \c, p -> 0)
		);
	selectionOnFocus =
		eitherMap(
			tryExtractStruct(state, MSelectionOnFocus(\__, __ -> -1)),
			\sof -> Some(sof.fn),
			maybeMap(autocomplete, \__ -> \c, p -> strlen(c))
		);

	onClearContent = tryExtractStruct(style, MOnClearIconClick(nop));

	// Content functions
	clearContent = \ -> {
		next(content, if (inputType == TelType()) "+" else "");
		nextDistinct(mfocus.focused, true);
		maybeApply(onClearContent, \onClear -> onClear.onClick());

		if (useNativeInput) {
			if (mobile)
				deferUntilRender(\ -> nextDistinct(mfocus.focused, true))
			else
				deferred(\ -> nextDistinct(mfocus.focused, true));
		}
	}

	goToPrev = \ -> {
		nextDistinct(content, ^prev);
		nextDistinct(mfocus.focused, false);
	}

	// Update functions
	haveBeenFocused = extractStruct(style, MHaveBeenFocused(make(false))).focused;

	popupUns = initUnsM();

	updateFocus = \foc : bool -> {
		dispUnsM(popupUns);

		if (isPopup && foc) {
			setUnsM(
				popupUns,
				interruptibleTimer(1, \ -> {
					nextDistinct(focus, true);
					maybeApply(popup, \ps -> nextDistinct(ps.openMenu.opened, true));
				})
			)
		} else {
			nextDistinct(focus, foc);
			maybeApply(popup, \ps -> nextDistinct(ps.openMenu.opened, foc));
		}

		if (!foc)
			prev := getValue(content);

		foc;
	}

	autocompleteHandlerUns = initUnsM();
	showMoreHandlerUns = initUnsM();
	updateFocusContent = \c : string, foc : bool, mtch : [Pair<int, SentenceMatcher>] -> {
		dispUnsM(showMoreHandlerUns);
		maybeApply(editIcon, \ei -> nextDistinct(ei, !foc));
		maybeApply(floatingLabel, \fl -> nextDistinct(fl.showFloatingLabel, flAlwaysOnTop || foc || c != ""));

		maybeApply(
			autocomplete,
			\ac -> {
				dispUnsM(autocompleteHandlerUns);
				setWordUpdateEnabled = eitherMap(ac.autoCompleteAsync, \async -> fgetValue(async.setWordUpdateEnabled), false);
				autoCompleteHandler = \ -> {
					c2 =
						if (!ac.includeSpaces) {
							linesN = strSplit(c, "\n");
							words = strSplit(c, " ");
							lastElement(words, "");
						} else {
							c
						};

					onAllCompl = \allCompl : [SentenceMatch], needSort -> {
						compl = if (needSort) mergeSort(allCompl, \sm1, sm2 -> genericCompareDesc(sm1.score, sm2.score)) else allCompl;
						maybeApply(ac.showMoreResults, \results -> nextDistinct(results, Pair(ac.maxResults, length(compl))));

						updateFn = \sentences -> {
							maybeApply(
								ac.currentMatches,
								\cm ->
									map(sentences, \ns -> {
										sen = ns.sentence;
										dictId = switch(ns) {
											SentenceHit(__, __, __, __) : findiDef(mtch, \mch -> contains(mch.second.sentences, sen), -1);
											SentenceHitExtended(__, __, __, __, idx) : idx;
										}
										senId = if (dictId >= 0) findiDef(mtch[dictId].second.sentences, \sn -> sn == sen, -1) else -1;

										Triple(dictId, senId, ns)
									})
									|> cm.fn
							);

							nextDistinct(ac.sentences, sentences)
						};

						newSentences =
							if (isSome(popup) || ac.sameZorderMode) {
								if (ac.maxResults >= 0) {
									maybeApply(ac.showMoreResults, \results -> 
										setUnsM(showMoreHandlerUns, subscribe2(results, \res ->
											updateFn(subrange(compl, 0, res.first)))
										)
									);
									subrange(compl, 0, ac.maxResults)
								} else
									compl;
							} else {
								suggest = find(compl, \v -> startsWith(toLowerCase(v.sentence), toLowerCase(c2)));

								eitherMap(suggest, \sg -> [sg], [])
							};

						updateFn(newSentences)
					}

					eitherFn(
						ac.autoCompleteAsync,
						\async -> {
							enabled = (foc || setWordUpdateEnabled) && eitherMap(getValue(async.prevRequestText), \prevText -> prevText != c2, true);
							if (enabled) {
								if (strlen(c2) < async.minChars) onAllCompl([], false)
								else {
									onResponse = \items -> {
										mtchr = ac.sentenceMatcher.matcher([]);
										allCompl = map(items, \it ->
											SentenceHit(mtchr, it, 0., makeSet())
										);
										onAllCompl(allCompl, false);
										nextDistinct(async.currentRequests, getValue(async.currentRequests) - 1);
									};
									nextDistinct(async.currentRequests, getValue(async.currentRequests) + 1);
									nextDistinct(async.prevRequestText, Some(c2));
									async.makeRequest(c2, onResponse)
								}
							}
						},
						\ -> {
							showAll = ac.showAllOnEmpty && isSome(popup) && c2 == "";
							chunkSize = getUrlParameterDef("chunkSize", "5000") |> s2i;
							simultaneous = max(length(mtch) / chunkSize, 50);
							mapAsyncParallelChunked(
								mtch, chunkSize, simultaneous,
								\chunk, fulfill, __ -> {
									mapConcat(
										chunk,
										\matcherPair -> {
											if (showAll)
												filtermap(
													matcherPair.second.sentences, 
													\s -> {
														if (s != "") Some(SentenceHitExtended(matcherPair.second, s, 0., makeSet(), matcherPair.first))
														else None()
													}
												)
											else
												map(
													ac.sentenceMatcher.fn(matcherPair.second, c2, intMax, true, false, getValue(position)),
													\h -> SentenceHitExtended(h.matcher, h.sentence, h.score, h.origWords, matcherPair.first)
												)
										}
									) |> fulfill
								},
								\allCompl -> onAllCompl(allCompl, true),
								\localError -> {
									devtrace("Something goes wrong building completions.");
									devtrace(localError);
								}
							);
						}
					)
				}

				if (ac.updateDelay == 0)
					autoCompleteHandler()
				else
					setUnsM(autocompleteHandlerUns, interruptibleTimer(ac.updateDelay, autoCompleteHandler))
			}
		);

		newC =
			if (useNativeInput)
				// (if (cpp && !mobile && numeric) numericFilter(c) else c)
				c
				|> (\f -> if (isUrlParameterFalse("emoji") || allowEmojis) f else filterEmojis(f))
				|> (\f -> {
					if (f != c)
						timer(if (mobile) 10 else 0, \ -> next(content, f));

					f
				})
			else
				c;

		Pair(newC, foc)
	}

	updatedContent =
		fselect3(
			content,
			fselect(mfocus.focused, updateFocus |> FLift),
			eitherMap(autocomplete, \ac -> ac.matchers, const([])),
			updateFocusContent
		);

	updateErrors = \fc : Pair<string, bool>, en : bool, ie : Maybe<Pair<string, bool>>, hbf : bool -> {
		c = firstOfPair(fc);
		foc = secondOfPair(fc);

		cLength = strlen(c);
		fieldIsOk = ref true;
		currentError : ref Pair<string, [MTextStyle]> = ref Pair("", defaultStyle);

		maybeApply(error, \errorState ->
			eitherFn(
				ie,
				\s -> {
					currentError := Pair(firstOfPair(s), replaceStruct(fgetValue(errorState.style), fgetValue(errorState.color)));

					fieldIsOk := !secondOfPair(s);
				},
				\ -> if (errorState.requiredField && cLength == 0) {
					fieldIsOk := false;

					if (!foc && hbf)
						currentError :=
							Pair(
								formatString(_("%1 is required"), [if (label != "") label else _("Field")]),
								replaceMThemeColor(fgetValue(errorState.style), fgetValue(errorState.color))
							);

					if (foc)
						nextDistinct(haveBeenFocused, true);
				}
			)
		);

		maybeApply(limitError, \le -> {
			charsError = cLength > maxChars;
			if (charsError)
				fieldIsOk := false;

			nextDistinct(
				le.limit,
				Pair(
					if (foc) i2s(cLength) + "/" + i2s(maxChars) else if (dynamicSize) "" else " ",
					if (charsError) replaceMThemeColor(defaultStyle, MErrorColor()) else defaultStyle
				)
			);

			if (charsError && firstOfPair(^currentError) == "")
				currentError := Pair(" ", replaceMThemeColor(defaultStyle, MErrorColor()));
		});

		maybeApply(
			error,
			\errorState -> {
				maybeApply(errorState.ok, \he -> nextDistinct(he.ok, ^fieldIsOk));

				nextDistinct(
					errorState.error,
					if (!dynamicSize && firstOfPair(^currentError) == "")
						Pair(" ", secondOfPair(^currentError))
					else
						^currentError
				);
			}
		);

		if (!en) {
			nextDistinct(labelStyleB, labelStyle);

			maybeApply(inputUnderline, \iu ->
				nextDistinct(
					iu,
					if (smallEdit && !foc)
						emptyUnderline
					else
						Pair([Stroke(inactiveColor), StrokeOpacity(1.0)], 0.)
				)
			);
			maybeApply(password, \pw ->
				nextDistinct(pw.style, [FillOpacity(1.0)])
			);
		} else if (secondOfPair(^currentError) != defaultStyle) {
			cFill = extractMColor(parent, secondOfPair(^currentError), MErrorColor());

			nextDistinct(labelStyleB, replaceStruct(errorTextStyle, MFill(cFill)));

			maybeApply(inputUnderline, \iu ->
				nextDistinct(
					iu,
					if (smallEdit && !foc)
						emptyUnderline
					else
						Pair([MFill(cFill), FillOpacity(1.)], if (foc) 2. else 1.)
				)
			);
			maybeApply(password, \pw ->
				nextDistinct(pw.style, if (foc) [cFill, FillOpacity(1.)] else [cFill])
			);
		} else if (foc) {
			nextDistinct(labelStyleB, pressedStyle);

			maybeApply(inputUnderline, \iu ->
				nextDistinct(
					iu,
					if (smallEdit && !foc)
						emptyUnderline
					else
						Pair([MFill(color), FillOpacity(1.)], 2.)
				)
			);
			maybeApply(password, \pw ->
				nextDistinct(pw.style, [FillOpacity(inactiveOpacity)])
			);
		} else {
			nextDistinct(labelStyleB, inactiveStyle);

			maybeApply(inputUnderline, \iu ->
				nextDistinct(
					iu,
					if (smallEdit && !foc)
						emptyUnderline
					else
						Pair(unfocusedUnderline, 1.)
				)
			);
			maybeApply(password, \pw ->
				nextDistinct(pw.style, [FillOpacity(inactiveOpacity)])
			);
		}
	}

	subs =
		concatA([
			if (useNativeInput)
				[
					makeSubscribe2(fstall(focus, 0), \focused -> {
						nextDistinct(mfocus.focused, focused);

						maybeApply(
							filterFn,
							\inpf ->
								nextDistinct(content, inpf.fn(getValue(content), focused))
						);

						if (focused) {
							maybeApply(
								positionOnFocus,
								\pof -> deferUntilRender(\ ->
									nextDistinct(position, min(max(pof(getValue(content), getValue(position)), 0), strlen(getValue(content))))
								)
							);

							maybeApply(
								selectionOnFocus,
								\sof -> deferUntilRender(\ ->
									nextDistinct(selection, min(max(sof(getValue(content), getValue(selection)), 0), strlen(getValue(content))))
								)
							);
						} else {
							maybeApply(positionOnFocus, \__ -> deferUntilRender(\ -> nextDistinct(position, -1)));
							maybeApply(selectionOnFocus, \__ -> deferUntilRender(\ -> nextDistinct(selection, -1)));
						}
					}),
				]
			else
				[],
			[
				\ -> \ -> {
					nextDistinct(focus, false);
					nextDistinct(mfocus.focused, false);
				},

				make4Subscribe(
					updatedContent,
					mfocus.enabled,
					eitherMap(
						error,
						\errorState -> errorState.text,
						const(None())
					),
					haveBeenFocused,
					updateErrors
				),
				filterAction.subscribers,
				makeSubscribe(mfocus.enabled, \en -> nextDistinct(textInputCursorShape, if (en) TextCursor() else DefaultCursor()))
			],
			eitherMap(
				helperText,
				\helperState -> [
					if (helperState.persistent)
						makeSubscribe(helperState.text, \ht ->
							nextDistinct(helperState.helper,
								Pair(
									either(ht, "")
									|> (\f ->
										if (!dynamicSize && f == "")
											" "
										else
											f
									),
									defaultStyle
								)
							)
						)
					else
						make2Subscribe(helperState.text, mfocus.focused, \ht, foc ->
							nextDistinct(helperState.helper,
								Pair(
									(if (foc) either(ht, "") else "")
									|> (\f ->
										if (!dynamicSize && f == "")
											" "
										else
											f
									),
									defaultStyle
								)
							)
						)
				],
				[]
			),
			if (contains(style, MSetSelectedOnUnfocus())) {
				eitherMap(autocomplete, \ac -> [
					makeSubscribe2(mfocus.focused, \foc -> if (!foc) {
						completions = fgetValue(ac.sentences);
						selectedIdx = fgetValue(ac.selected);
						if (selectedIdx > -1 && length(completions) > 0 && selectedIdx < length(completions)) {
							nextDistinct(content, completions[selectedIdx].sentence)
						}
					})
				], [])
			} else []
		]);

	shift =
		if (hasFloatingLabel && dynamicSize)
			fif(
				fOr(mfocus.focused, fneq(content, "")),
				fselect(tTextMetrics, FLift(\tm -> tm.baseline + inputBorders.top + if (condensed) 8. else 12.)),
				fselect(tTextMetrics, FLift(\tm -> tm.baseline + inputBorders.top))
			)
		else
			fselect(tTextMetrics, FLift(\tm -> tm.baseline + inputBorders.top));

	MInputState(
		manager,
		parent,
		content,
		showPasswordFallbackType,
		autoCompleteType,
		mfocus,
		focus,
		position,
		selection,
		textInputCursorShape,
		textStyle,
		tTextMetrics,
		smallEdit,
		label,
		dynamicSize,
		linesCount,
		inputUnderline,
		multiline,
		wordWrap,
		numeric,
		numericStep,
		noNumericArrows,
		readOnly,
		preventContextMenu,
		color,
		width,
		textWidth,
		maxHeight,
		align,
		iconSize,
		iconBorders,
		leftIcon,
		leftButton,
		editIcon,
		rightButton,
		rightCustomButton,
		inputBorders,
		noLeftBorder,
		maxChars,
		backgroundFill,
		labelStyleB,
		floatingLabel,
		cursorState,
		popup,
		autocomplete,
		error,
		limitError,
		helperText,
		password,
		eatKeyDown,
		processedKeyDown,
		filterFn,
		filterAction.fn,
		positionOnFocus,
		selectionOnFocus,
		clearContent,
		goToPrev,
		subs,
		shift,
		useNativeInput,
		condensed,
		skin,
		scrollStyle,
		allowEmojis
	)
}

makeMTextEditorIScriptBehaviours(content : DynamicBehaviour<string>, style : [MAutoCompleteStyle],
	state : [MTextInputState]) -> MTextEditorIScriptBehaviours {
	dynamicSize = contains(style, MDynamicSize());
	label = extractStruct(style, MLabel("")).label;
	focus = extractStruct(state, TTextInputFocus(make(false))).focus;
	position = extractStruct(state, TTextInputPosition(make(strlen(getValue(content))))).position;
	selection = extractStruct(state, TTextInputSelection(make(-1))).selection;

	fa : (string) -> void = extractStruct(style, MFilterAction(nop1)).action;
	filterAction = fn2IScriptBehaviourDisposable1(
		\f : flow -> fa(flow2s(f)),
		"filter_action", ISMiscEvent()
	);
	readOnly = extractStruct(style, ReadOnly(false)).readOnly;
	inputType = extractStruct(style, TextInputType(TextType())).inputType;
	autoCompleteType = tryExtractStruct(style, AutoCompleteType(ACUserName()));
	numeric = inputType == NumericType();
	isTextInputInPopup = !contains(style, MTextInputOutOfPopup());
	useNativeInput = extractStruct(style, MNativeInput(^nativeInputs && !readOnly)).useNativeInput || mobile || macosx();
	// Edit Button
	showEditIcon = !readOnly && extractStruct(style, MShowEditIcon(false)).enabled;
	editIcon : Maybe<DynamicBehaviour<bool>> =
		if (showEditIcon && !readOnly)
			Some(make(false))
		else
			None();

	error : Maybe<MInputErrorState> =
		eitherMap(
			tryExtractStruct(state, MInputError(const(None()), [])),
			\ie -> {
				errorLines = extractStruct(ie.style, MMaxLines(1)).lines;
				inputErrorColor = extractStruct(ie.style, MInputErrorColor(const(MErrorColor()))).color;
				inputErrorFont = extractStruct(ie.style, MInputErrorFont(MCustomFont(12.0, "Roboto", 1.))).style;

				Some(
					MInputErrorState(
						ie.text,
						errorLines,
						\p -> i2d(errorLines) * (MFontStyle2MFont(p, inputErrorFont).size + 4.),
						contains(ie.style, MRequiredField()),
						inputErrorColor,
						fselect(inputErrorColor, FLift(\ec : MThemeColor -> [inputErrorFont, ec])),
						tryExtractStruct(ie.style, MInputIsOk(make(true))),
						make(Pair(if (dynamicSize) "" else " ", []))
					)
				)
			},
			None()
		);

	MTextEditorIScriptBehaviours(
		content,
		inputType,
		autoCompleteType,
		label,
		dynamicSize,
		focus,
		position,
		selection,
		readOnly,
		numeric,
		editIcon,
		filterAction,
		error,
		[
			IScriptBehaviour("selected", selection, ISDetailedTextEvent()),
			IScriptBehaviour("position", position, ISDetailedTextEvent()),
			IScriptBehaviour("content", content, ISDetailedTextEvent()),
			filterAction.monitorBehaviour
		]
		|> (\f2 : [IScriptBehaviour] ->
			eitherMap(
				error,
				\er : MInputErrorState ->
					arrayPush(
						f2,
						IScriptBehaviour("error", er.error, ISMiscEvent())
					)
					|> (\f3 : [IScriptBehaviour] ->
						eitherMap(
							er.ok,
							\he : MInputIsOk ->
								arrayPush(
									f3,
									IScriptBehaviour("is_ok", he.ok, ISMiscEvent())
								),
							f3
						)
					),
				f2
			)
		),
		useNativeInput,
		isTextInputInPopup
	)
}

MTextInputFilteredTag(from : int, to : int, filteredTagText : string, fullText : string);
MTextInputFilteredTagAcc(
	openedTags : int,
	openedBrackets : int,
	filteredText : string,
	currentFilteredTag : Maybe<MTextInputFilteredTag>,
	tags : [MTextInputFilteredTag]
);
MTextInputLine(visibleText : string, realText : string, filteredTagsText : Triple<string, string, [MTextInputFilteredTag]>, length : int, newLine : bool);

emptyMTextInputLine = MTextInputLine("", "", Triple("", "", []), 0, false);

MTextEditorState(
	mousexy : DynamicBehaviour<Point>,
	mouseRightDown : DynamicBehaviour<bool>,
	cursorPoint : DynamicBehaviour<Point>,
	selectionPosition : DynamicBehaviour<MTextEditorSelection>,
	selectionPoints : DynamicBehaviour<[Triple<int, Point, Point>]>,
	cursorVisible : Transform<bool>,
	focused : Transform<bool>,
	lines : Transform<[MTextInputLine]>,
	width : DynamicBehaviour<double>,
	contentWH : DynamicBehaviour<WidthHeight>,
	textHeight : double,
	scrollStyle : [MScrollStyle],
	handleDownKeys : (h : bool, k : KeyEvent) -> bool,
	pasteEventListener : () -> () -> void,
	handleMouseDown : (h : bool, mi : MouseDownInfo) -> bool,
	handleMouseUp : (h : bool, mi : () -> MouseInfo) -> bool,
	subs : [() -> () -> void]
);

MTextEditorPosition(
	symbol : int,
	line : int
);

MTextEditorSelection(
	start : MTextEditorPosition,
	end : MTextEditorPosition
);

makeMTextEditorState(inputState : MInputState) -> MTextEditorState {
	dummyEditorPosition = MTextEditorPosition(-1, -1);
	dummySelection = MTextEditorSelection(dummyEditorPosition, dummyEditorPosition);
	mousexy = make(zeroPoint);
	mouseDown = make(false);
	mouseRightDown = make(false);
	cursorPosition = make(MTextEditorPosition(0, 0));
	cursorPoint = make(zeroPoint);
	selectionPosition : DynamicBehaviour<MTextEditorSelection> = make(dummySelection);
	selectionPoints = make([]);

	cursorVisible = make(false);
	cursUns = initUnsM();
	prevPrevDown = ref 0.;
	prevDown = ref 0.;
	downDelay = 300.;

	scrollPosition = make(zeroPoint);
	contentWH = makeWH();
	boxWH = makeWH();

	width = make(0.);
	focused = inputState.mfocus.focused;
	readOnly = inputState.readOnly;
	multiline = inputState.multiline;
	linesCount = inputState.linesCount;
	maxChars = inputState.maxChars;
	numeric = inputState.numeric;
	textStyle = MTextStyle2CharacterStyle(inputState.parent, fgetValue(inputState.textStyle)); // TODO:
	textHeight = getTextSize(".", textStyle).height;

	scrollStyle =
		[
			TScrollbars(
				invisibleScrollBar,
				if (multiline && linesCount != 0 && linesCount != -1)
					getMaterialScrollBar().y
				else
					invisibleScrollBar
			),
			MScrollPosition(scrollPosition),
			MScrollWidthHeight(makeWH(), boxWH)
		];

	focusId = getFocusId();

	if (focusId == -1) {
		println("A TextInput should not have a focus id of -1.");
	}

	lines : DynamicBehaviour<[MTextInputLine]> = make([]);

	linesCache = ref Triple(-1., false, makeTree());

	filterTags = \txt -> {
		filtered = stringFoldi(txt, MTextInputFilteredTagAcc(0, 0, "", None(), []), \i, acc, c -> {
			s = fromCharCode(c);
			if (s == "<") {
				if (i + 1 < strlen(txt) && getCharAt(txt, i + 1) == "/") {
					MTextInputFilteredTagAcc(acc with
						openedTags = acc.openedTags - 1,
						openedBrackets = acc.openedBrackets + 1,
						currentFilteredTag = maybeMap(acc.currentFilteredTag, \ft -> MTextInputFilteredTag(ft with fullText = ft.fullText + s))
					)
				} else {
					MTextInputFilteredTagAcc(acc with
						openedTags = acc.openedTags + 1,
						openedBrackets = acc.openedBrackets + 1,
						currentFilteredTag =
							if (isNone(acc.currentFilteredTag)) Some(MTextInputFilteredTag(strlen(acc.filteredText), 0, "", s))
							else acc.currentFilteredTag
					)
				}
			} else if (s == ">") {
				if (acc.openedTags == 0) {
					MTextInputFilteredTagAcc(acc with
						openedBrackets = acc.openedBrackets - 1,
						currentFilteredTag = None(),
						tags = eitherMap(acc.currentFilteredTag, \ft ->
							arrayPush(acc.tags, MTextInputFilteredTag(ft with to = strlen(acc.filteredText), fullText = ft.fullText + s)),
							acc.tags
						)
					)
				} else {
					MTextInputFilteredTagAcc(acc with
						openedBrackets = acc.openedBrackets - 1,
						currentFilteredTag = maybeMap(acc.currentFilteredTag, \ft -> MTextInputFilteredTag(ft with fullText = ft.fullText + s))
					)
				}
			} else if (acc.openedBrackets > 0) {
				MTextInputFilteredTagAcc(acc with
					currentFilteredTag = maybeMap(acc.currentFilteredTag, \ft -> MTextInputFilteredTag(ft with fullText = ft.fullText + s))
				)
			} else {
				MTextInputFilteredTagAcc(acc with
					filteredText = acc.filteredText + s,
					currentFilteredTag = maybeMap(acc.currentFilteredTag, \ft ->
						MTextInputFilteredTag(ft with filteredTagText = ft.filteredTagText + s, fullText = ft.fullText + s)
					)
				)
			}
		});

		Triple(
			filtered.filteredText,
			filtered.filteredText,
			filtered.tags
		)
	}

	content2lines = \c : string, sp : bool, wd : double -> {
		map(strSplit(c, "\n"), \l ->
			Pair(
				l,
				eitherFn(
					if (wd != firstOfTriple(^linesCache))
						None()
					else
						lookupTree(thirdOfTriple(^linesCache), l),
					idfn,
					\ ->
						if (inputState.wordWrap)
							getSplittedByWidthString(l, wd - 2., textStyle, [CropWords(true)]
								|> (\f -> if (readOnly) arrayPush(f, ShiftLongWords()) else f))
							|> concatA
							|> (\f -> map(f, \f0 -> Pair(strlen(f0), f0)))
						else
							[Pair(strlen(l), l)]
				)
			)
		)
		|> (\l -> {
			linesCache := Triple(wd, sp, pairs2tree(l));
			map(l, secondOfPair);
		})
		|> (\splitted : [[Pair<int, string>]] ->
			mapi(splitted, \i, l ->
				mapi(if (length(l) > 0) l else [Pair(0, "")], \j, ns -> {
					addN = (i < length(splitted) - 1 && j == length(l) - 1);
					visibleText = if (sp) secondOfPair(ns) else concatStrings(generate(0, firstOfPair(ns), \__ -> "\u2022"));
					filteredTagsText = if (sp) filterTags(secondOfPair(ns)) else Triple(visibleText, secondOfPair(ns), []);

					MTextInputLine(visibleText + "\n", secondOfPair(ns), filteredTagsText, firstOfPair(ns), addN)
				})
			)
			|> concatA
		)
		|> (\l -> nextDistinct(lines, l))
	};

	resetCursor = \ -> if (fgetValue(focused)) {
		nextDistinct(cursorVisible, false);
		next(cursorVisible, true);
	}

	isSelection = \ -> {
		ss = getValue(selectionPosition).start;
		se = getValue(selectionPosition).end;

		ss != se && ss.symbol >= 0 && ss.line >= 0 && se.symbol >= 0 && se.line >= 0
	}

	editorClearSelection = \ ->
		nextDistinct(selectionPosition, dummySelection);

	maybeSwapSelection = \sel : MTextEditorSelection -> {
		st = sel.start;
		en = sel.end;
		doSwap = st.line > en.line || (st.line == en.line && st.symbol > en.symbol);
		if (doSwap) MTextEditorSelection(en, st) else sel;
	}

	newLineSymbol = \s : MTextInputLine -> if (s.newLine) "\n" else "";

	getFromTo = \sel : MTextEditorSelection -> {
		swapped = maybeSwapSelection(sel);
		st = swapped.start;
		en = swapped.end;

		subLength = en.line - st.line;

		foldi(subrange(getValue(lines), st.line, subLength + 1), "", \i, acc, s -> {
			textPart =
				if (i > 0 && i < subLength)
					s.filteredTagsText.second + newLineSymbol(s)
				else if (i == 0 && i == subLength)
					substring(s.filteredTagsText.second, st.symbol, en.symbol - st.symbol)
				else if (i == subLength)
					substring(s.filteredTagsText.second, 0, en.symbol)
				else if (i == 0)
					substring(s.filteredTagsText.second, st.symbol, s.length - st.symbol) + newLineSymbol(s)
				else
					"";

			if (textPart == "") {
				acc
			} else {
				acc + fold(s.filteredTagsText.third, textPart, \acc2, ft ->
					strReplace(acc2, ft.filteredTagText, ft.fullText)
				)
			}
		})
	}

	checkPair = \p : MTextEditorPosition -> {
		p.line >= 0 && p.line < length(getValue(lines)) &&
			p.symbol >= 0 && p.symbol <= getValue(lines)[p.line].length
	}

	checkPosition = \p : int -> {
		p >= 0 && p <= strlen(getValue(inputState.content))
	}

	position2pair = \p : int -> {
		if (checkPosition(p))
			foldiWhile(getValue(lines), Pair(0, dummyEditorPosition), \i, acc, l -> {
				if (p < firstOfPair(acc))
					None()
				else if (p > firstOfPair(acc) + l.length)
					Some(
						Pair(
							firstOfPair(acc) + l.length + if (l.newLine) 1 else 0,
							MTextEditorPosition(secondOfPair(acc).symbol, secondOfPair(acc).line + 1)
						)
					)
				else
					Some(
						Pair(
							firstOfPair(acc) + l.length + (if (l.newLine) 1 else 0) + 1,
							MTextEditorPosition(p - firstOfPair(acc), secondOfPair(acc).line + 1)
						)
					)
			})
			|> secondOfPair
		else
			getValue(cursorPosition)
	}

	pair2position = \p : MTextEditorPosition ->
		forceRange(
			if (checkPair(p))
				strlen(getFromTo(MTextEditorSelection(MTextEditorPosition(0, 0), p)))
			else
				getValue(inputState.position),
			0,
			strlen(getValue(inputState.content))
		);

	pair2selection = \p : MTextEditorSelection -> {
		st = p.start;
		en = p.end;

		cp = getValue(cursorPosition);

		if (st != en && checkPair(st) && checkPair(en)) {
			if (cp == st)
				strlen(getFromTo(MTextEditorSelection(cp, en)))
			else if (cp == en)
				strlen(getFromTo(MTextEditorSelection(cp, st)))
			else
				getValue(inputState.selection);
		} else {
			-1
		}
	}

	selection2pair = \s : int -> {
		if (s == -1)
			dummySelection
		else if (checkPosition(s))
			MTextEditorSelection(getValue(cursorPosition), position2pair(s))
		else
			getValue(selectionPosition)
	}

	updateContent = \s : string -> {
		prevS = getValue(inputState.content);
		newS =
			(if (numeric) numericFilter(s) else s)
			|> (\f -> if (isUrlParameterFalse("emoji") || inputState.allowEmojis) f else filterEmojis(f))
			|> (\newS -> eitherMap(inputState.filterFn, \tf -> tf.fn(newS, getValue(focused)), newS));

		if (newS != prevS) {
			prevSlength = strlen(prevS);
			newSlength = strlen(newS);

			if (newSlength > prevSlength) {
				next(inputState.content, newS);
				newPosition = position2pair(pair2position(getValue(cursorPosition)) + newSlength - prevSlength);
				nextDistinct(cursorPosition, newPosition);
			} else {
				newPosition = position2pair(pair2position(getValue(cursorPosition)) + newSlength - prevSlength);
				nextDistinct(cursorPosition, newPosition);
				next(inputState.content, newS);
			}
		}
	}

	deleteFromTo = \st0 : MTextEditorPosition, en0 : MTextEditorPosition -> {
		swapped = maybeSwapSelection(MTextEditorSelection(st0, en0));
		st = swapped.start;
		en = swapped.end;

		subLength = en.line - st.line;
		lns = getValue(lines);

		concatStrings([
			fold(subrange(lns, 0, st.line), "", \acc, s -> acc + s.realText + newLineSymbol(s)),
			foldi(subrange(lns, st.line, subLength + 1), "", \i, acc, s ->
				acc + (
					if (i > 0 && i < subLength)
						""
					else if (i == 0 && i == subLength)
						substring(s.realText, 0, st.symbol) + substring(s.realText, en.symbol, s.length - en.symbol) + newLineSymbol(s)
					else if (i == subLength)
						substring(s.realText, en.symbol, s.length - en.symbol) + newLineSymbol(s)
					else if (i == 0)
						substring(s.realText, 0, st.symbol)
					else
						s.realText + newLineSymbol(s)
				)
			),
			fold(subrange(lns, st.line + subLength + 1, length(lns) - subLength - 1 - st.line), "", \acc, s ->
				acc + s.realText + newLineSymbol(s)
			)
		])
		|> updateContent
	}

	handleSelection = \k : KeyEvent, oldCursorPos : MTextEditorPosition ->
		if (k.shift) {
			ss0 = getValue(selectionPosition).start;
			ss = if (ss0 == dummyEditorPosition) oldCursorPos else ss0;

			nextDistinct(selectionPosition,	MTextEditorSelection(ss, getValue(cursorPosition)))
		} else
			editorClearSelection();

	adjustY = \y -> forceRange(y, 0, length(getValue(lines)) - 1);

	adjustX = \x, y -> forceRange(x, 0, getValue(lines)[y].length);

	moveCursorUp = \ -> {
		if (isSelection())
			editorClearSelection();

		curs = getValue(cursorPosition);
		y = adjustY(curs.line - 1);
		x = adjustX(curs.symbol, y);

		nextDistinct(cursorPosition, MTextEditorPosition(x, y));
		resetCursor();
	}

	moveCursorDown = \ -> {
		if (isSelection())
			editorClearSelection();

		curs = getValue(cursorPosition);
		y = adjustY(curs.line + 1);
		x = adjustX(curs.symbol, y);

		nextDistinct(cursorPosition, MTextEditorPosition(x, y));
		resetCursor();
	}

	moveCursorHome = \k : KeyEvent -> {
		curs = getValue(cursorPosition);

		next(cursorPosition, MTextEditorPosition(0, if (k.ctrl) 0 else adjustY(curs.line)));
		handleSelection(k, curs)
	}

	moveCursorEnd = \k : KeyEvent -> {
		curs = getValue(cursorPosition);
		y = if (k.ctrl) length(getValue(lines)) - 1 else adjustY(curs.line);
		x = getValue(lines)[y].length;

		next(cursorPosition, MTextEditorPosition(x, y));
		handleSelection(k, curs)
	}

	moveCursorLeft = \k -> {
		if (isSelection() && !k.shift) {
			nextDistinct(cursorPosition, min(getValue(selectionPosition).start, getValue(selectionPosition).end));
			editorClearSelection();
		} else {
			curs = getValue(cursorPosition);

			y0 = adjustY(curs.line);
			x0 = adjustX(curs.symbol - 1, y0);

			moveUp = (x0 == curs.symbol || (y0 > 0 && x0 == 0 && !getValue(lines)[y0 - 1].newLine));

			y =
				if (moveUp)
					adjustY(curs.line - 1)
				else
					y0;

			x =
				if (moveUp && y0 != y)
					getValue(lines)[y].length
				else
					x0;

			nextDistinct(cursorPosition, MTextEditorPosition(x, y));
			handleSelection(k, curs)
		}

		resetCursor();
	}

	moveCursorRight = \k -> {
		if (isSelection() && !k.shift) {
			nextDistinct(cursorPosition, max(getValue(selectionPosition).start, getValue(selectionPosition).end));
			editorClearSelection();
		} else {
			curs = getValue(cursorPosition);

			y0 = adjustY(curs.line);
			x0 = adjustX(curs.symbol + 1, y0);

			moveDown = x0 == curs.symbol;

			y =
				if (moveDown)
					adjustY(curs.line + 1)
				else
					y0;

			x =
				if (moveDown && y0 != y)
					b2i(!getValue(lines)[y0].newLine)
				else
					x0;

			nextDistinct(cursorPosition, MTextEditorPosition(x, y));
			handleSelection(k, curs)
		}

		resetCursor();
	}

	cursorPoint2Position = \xy : Point -> {
		lns = getValue(lines);

		if (length(lns) > 0) {
			y = adjustY(floor(xy.y / textHeight));

			line = lns[y].filteredTagsText.first |> (\f -> if (endsWith(f, "\n")) substring(f, 0, strlen(f) - 1) else f);

			x = if (xy.x < 2.) 0 else strlen(getTruncatedByWidthString(line, if (xy.x > 4.) xy.x + 4. else xy.x, textStyle, false));

			MTextEditorPosition(x, y)
		} else {
			MTextEditorPosition(0, 0);
		}
	}

	cursorPosition2Point = \curs : MTextEditorPosition -> {
		lns = getValue(lines);
		lnsLength = length(lns);

		Point(
			max(1.,
				getTWordMetrics(
					TText(
						substring(
							(if (curs.line < 0)
								lns[0].filteredTagsText.first
							else if (curs.line >= lnsLength)
								lastElement(lns, emptyMTextInputLine).filteredTagsText.first
							else
								lns[curs.line].filteredTagsText.first
							)
							|> (\f -> if (endsWith(f, "\n")) substring(f, 0, strlen(f) - 1) else f),
							0,
							curs.symbol
						),
						textStyle
					),
					makeTree()
				).width
			),
			i2d(adjustY(curs.line)) * textHeight
		)
	}

	updateCursorPosition = \xy : Point -> {
		pos = cursorPoint2Position(xy);

		if (getValue(cursorPosition) != pos) {
			next(cursorPosition, pos);

			prevPrevDown := 0.;
			prevDown := 0.;
		}

		resetCursor();
	}

	updateCursorPoint = \ -> nextDistinct(cursorPoint, cursorPosition2Point(getValue(cursorPosition)));

	deleteSelectedChars = \ -> {
		st = getValue(selectionPosition).start;
		en = getValue(selectionPosition).end;

		swapped = maybeSwapSelection(getValue(selectionPosition));
		nextDistinct(cursorPosition, swapped.end);

		deleteFromTo(st, en);
		editorClearSelection();
	}

	editorDeletePreviousChar = \ -> {
		if (isSelection())
			deleteSelectedChars()
		else {
			curs = getValue(cursorPosition);
			lns = getValue(lines);

			if (curs.symbol > 0 || curs.line > 0) {
				concatStrings([
					fold(subrange(lns, 0, max(curs.line - 1, 0)), "", \acc, s -> acc + s.realText + newLineSymbol(s)),
					foldi(
						subrange(lns, max(curs.line - 1, 0), if (curs.line == 0) 1 else 2),
						"",
						\i, acc, s -> {
							(
								if (i == b2i(curs.line != 0)) {
									if (s.length == 0 || curs.symbol == 0)
										strRemove(acc, strlen(acc) - 1, 1) + s.realText
									else
										acc + strRemove(s.realText, curs.symbol - 1, 1)
								} else
									acc + s.realText
							) + newLineSymbol(s)
						}
					),
					fold(subrange(lns, curs.line + 1, length(lns) - curs.line - 1), "", \acc, s ->
						acc + s.realText + newLineSymbol(s)
					)
				])
				|> updateContent;
			}

			resetCursor();
		}
	}

	editorDeleteNextChar = \ -> {
		if (isSelection())
			deleteSelectedChars()
		else {
			curs = getValue(cursorPosition);
			lns = getValue(lines);

			concatStrings([
				fold(subrange(lns, 0, curs.line), "", \acc, s -> acc + s.realText + newLineSymbol(s)),
				strRemove(lns[curs.line].realText, curs.symbol, 1) + newLineSymbol(lns[curs.line]),
				fold(subrange(lns, curs.line + 1, length(lns) - curs.line - 1), "", \acc, s ->
					acc + s.realText + newLineSymbol(s)
				)
			])
			|> updateContent;

			nextDistinct(cursorPosition, curs);
			resetCursor();
		}
	}

	insertStr = \str0 : string -> {
		if (isSelection())
			deleteSelectedChars();

		str =
			str0
			|> (\st ->
				if (maxChars > 0) {
					clen = strlen(getValue(inputState.content));

					if (clen >= maxChars)
						""
					else if (clen + strlen(st) > maxChars)
						substring(st, 0, maxChars - clen)
					else
						st
				} else
					st
			);

		if (str != "") {
			curs = getValue(cursorPosition);
			lns = getValue(lines);

			concatStrings([
				fold(subrange(lns, 0, curs.line), "", \acc, s ->
					acc + s.realText + newLineSymbol(s)
				),
				strInsert(lns[curs.line].realText, str, curs.symbol) + newLineSymbol(lns[curs.line]),
				fold(subrange(lns, curs.line + 1, length(lns) - curs.line - 1), "", \acc, s ->
					acc + s.realText + newLineSymbol(s)
				)
			])
			|> updateContent;
		}

		p = pair2position(getValue(cursorPosition));
		if (substring(getValue(inputState.content), p, strlen(str0)) == str0) {
			next(cursorPosition, position2pair(p + strlen(str0)));
		};

		resetCursor();
	}

	selectAll = \ -> {
		lns = getValue(lines);
		en = MTextEditorPosition(lastElement(lns, emptyMTextInputLine).length, length(lns) - 1);

		nextDistinct(selectionPosition, MTextEditorSelection(MTextEditorPosition(0, 0), en));
		nextDistinct(cursorPosition, en);
	}

	selectCurrentLine = \ -> {
		cp = getValue(cursorPosition);
		en = MTextEditorPosition(getValue(lines)[cp.line].length, cp.line);

		nextDistinct(selectionPosition, MTextEditorSelection(MTextEditorPosition(0, cp.line), en));
		nextDistinct(cursorPosition, en);
	}

	selectCurrentWord = \ -> {
		cp = getValue(cursorPosition);

		currentLine = strSplit(getValue(lines)[cp.line].realText, " ");

		pr = foldi(currentLine, Pair(0, 0), \i, acc, s -> {
			if (secondOfPair(acc) >= cp.symbol) {
				acc
			} else {
				sLen = strlen(s);
				strt = firstOfPair(acc) + sLen;

				if (strt >= cp.symbol) {
					Pair(firstOfPair(acc), strt);
				} else {
					Pair(strt + if (i == length(currentLine) - 1) 0 else 1, secondOfPair(acc));
				}
			}
		});

		st = MTextEditorPosition(firstOfPair(pr), cp.line);
		en = MTextEditorPosition(secondOfPair(pr), cp.line);

		nextDistinct(selectionPosition, MTextEditorSelection(st, en));
		nextDistinct(cursorPosition, en);
	}

	handleDownKeys = \handled : bool, k : KeyEvent -> {
		if (fgetValue(focused) && !handled && eitherMap(inputState.processedKeyDown, \pk -> pk.fn(k), true)) {
			if (k.utf == "home") {
				moveCursorHome(k);
			} else if (k.utf == "end") {
				moveCursorEnd(k);
			} else if (k.keycode == KEY_LEFT) {
				moveCursorLeft(k);
			} else if (k.keycode == KEY_RIGHT) {
				moveCursorRight(k);
			} else if (k.keycode == KEY_UP) {
				if (multiline)
					moveCursorUp()
				else if (numeric)
					updateContent(i2s(s2i(getValue(inputState.content)) + 1));
			} else if (k.keycode == KEY_DOWN) {
				if (multiline)
					moveCursorDown()
				else if (numeric)
					updateContent(i2s(s2i(getValue(inputState.content)) - 1));
			} else if (k.keycode == KEY_BACKSPACE && !readOnly) {
				editorDeletePreviousChar();
			} else if ((k.keycode == KEY_TAB || k.keycode == 16777218 /* shift + tab */) && !readOnly) {
				if (multiline)
					insertStr("\t");
			} else if (k.keycode == KEY_DELETE && !k.shift && !readOnly) {
				editorDeleteNextChar();
			} else if (k.keycode == KEY_ENTER && !readOnly) {
				if (multiline)
					insertStr("\n");
			} else if (k.keycode == KEY_A && k.ctrl) {
				selectAll();
			} else if (((k.keycode == KEY_V && k.ctrl) || (k.keycode == KEY_INSERT && k.shift)) && !readOnly) {
				// handled in addPasteEventListener
			} else if ((((k.keycode == KEY_C || k.keycode == KEY_INSERT) && k.ctrl) || (readOnly &&
				((k.keycode == KEY_X && k.ctrl) || (k.keycode == KEY_DELETE && k.shift))))) {
				if (isSelection()) {
					sel = getFromTo(getValue(selectionPosition));
					setClipboard(sel);
				}
			} else if (((k.keycode == KEY_X && k.ctrl) || (k.keycode == KEY_DELETE && k.shift)) && !readOnly) {
				if (isSelection()) {
					sel = getFromTo(getValue(selectionPosition));
					setClipboard(sel);
					deleteSelectedChars();
				}
			} else if (strlen(k.utf) == 1 && !readOnly) {
				insertStr(k.utf);
			}

			eatKDown = inputState.eatKeyDown(k);
			if (eatKDown) k.preventDefault();
			eatKDown;
		} else
			handled
	}

	pasteEventListener = \ -> addPasteEventListener(\__ -> {
		if (fgetValue(focused)) {
			insertStr(getGlobalClipboard());
			deferUntilNextFrameRendered(\ -> nextDistinct(focused, true));
		}
	});

	handleMouseDown = \handled : bool, mi : MouseDownInfo -> {
		curDown = timestamp();

		if (mi.inside() && !handled) {
			nextDistinct(mouseDown, true);

			if (curDown - ^prevDown < downDelay) {
				if (^prevDown - ^prevPrevDown < downDelay) { // Triple click
					selectCurrentLine();

					prevDown := 0.;
				} else { // Double click
					selectCurrentWord();
				}
			} else {
				updateCursorPosition(getValue(mousexy));
				cp = getValue(cursorPosition);

				nextDistinct(selectionPosition, MTextEditorSelection(cp, cp));
			}

			prevPrevDown := ^prevDown;
			prevDown := curDown;
		}

		handled
	}

	handleMouseUp = \handled : bool, mi : () -> MouseInfo -> {
		nextDistinct(mouseDown, false);

		handled
	}

	updateSelectionPoints = \sp : MTextEditorSelection -> {
		newSelectionPoints =
			if (isSelection()) {
				swapped = maybeSwapSelection(sp);
				st = swapped.start;
				en = swapped.end;

				generate(st.line, en.line + 1, \i -> {
					selected =
						if (i == st.line && i == en.line)
							MTextEditorSelection(st, en)
						else if (i == st.line)
							MTextEditorSelection(st, MTextEditorPosition(getValue(lines)[st.line].length, st.line))
						else if (i == en.line)
							MTextEditorSelection(MTextEditorPosition(0, en.line), en)
						else
							MTextEditorSelection(
								MTextEditorPosition(0, i),
								MTextEditorPosition(getValue(lines)[i].length, i)
							);

					Triple(i, cursorPosition2Point(selected.start), cursorPosition2Point(selected.end))
				})
			} else [];

		nextDistinct(selectionPoints, newSelectionPoints);
	}

	subs =
		[
			make2Subscribe(contentWH, boxWH, \cwh, bwh -> {
				if (cwh.height <= bwh.height)
					nextDistinct(scrollPosition, Point(getValue(scrollPosition).x, 0.));
				if (cwh.width <= bwh.width)
					nextDistinct(scrollPosition, Point(0., getValue(scrollPosition).y));
			}),
			make3Subscribe(inputState.content, eitherMap(inputState.password, \ps -> ps.showPassword, const(true)), width, content2lines),
			makeSubscribe2(getKeyboardFocusBehaviour(), \kf ->
				if (kf != focusId)
					nextDistinct(focused, false)
			),
			makeSubscribe2(mousexy, \xy ->
				if (getValue(mouseDown)) {
					updateCursorPosition(xy);
					nextDistinct(selectionPosition, MTextEditorSelection(getValue(selectionPosition).start, getValue(cursorPosition)));
				}
			),
			\ -> bidirectionalLink(focused, inputState.focus, \foc -> {
				if (foc)
					updateKeyboardFocus(focusId)
				else if (currentKeyboardFocusId() == focusId)
					releaseKeyboardFocus();

				if (!foc) nextDistinct(scrollPosition, zeroPoint);

				if (foc) {
					maybeApply(
						inputState.positionOnFocus,
						\pof ->
							nextDistinct(
								inputState.position,
								min(max(pof(getValue(inputState.content), getValue(inputState.position)), 0), strlen(getValue(inputState.content)))
							)
					);
					maybeApply(
						inputState.selectionOnFocus,
						\sof ->
							nextDistinct(
								inputState.selection,
								min(max(sof(getValue(inputState.content), getValue(inputState.selection)), 0), strlen(getValue(inputState.content)))
							)
					);

					deferred(resetCursor);
				} else {
					dispUnsM(cursUns);
					nextDistinct(cursorVisible, false)
				};

				updateContent(getValue(inputState.content));

				foc;
			}, idfn),
			makeSubscribe2(cursorVisible, \cv ->
				if (fgetValue(focused)) {
					dispUnsM(cursUns);
					setUnsM(
						cursUns,
						interruptibleTimer(500, \ -> reverseBehaviour(cursorVisible))
					)
				} else {
					dispUnsM(cursUns);
					nextDistinct(cursorVisible, false)
				}
			),
			\ -> bidirectionalLink(inputState.position, cursorPosition, position2pair, pair2position),
			\ -> bidirectionalLink(inputState.selection, selectionPosition, selection2pair, \sp : MTextEditorSelection -> {
				updateSelectionPoints(sp);
				pair2selection(sp);
			}),
			\ -> fconnectSelect(cursorPosition, cursorPoint, cursorPosition2Point),
			make2Subscribe2(cursorPoint, boxWH, \cp, bwh -> {
				sp = getValue(scrollPosition);

				xp =
					if (cp.x - bwh.width + 2. > sp.x)
						max(cp.x - bwh.width + 2., 0.)
					else if (cp.x - 2. < sp.x)
						max(cp.x - 2., 0.)
					else
						sp.x;

				yp =
					if (cp.y - bwh.height + textHeight > sp.y)
						max(cp.y - bwh.height + textHeight, 0.)
					else if (cp.y < sp.y)
						max(cp.y, 0.)
					else
						sp.y;

				nextDistinct(scrollPosition, Point(xp, yp))

			}),
			\ -> \ -> {
				keyboardFocusDies(focusId);
				dispUnsM(cursUns);
			}
		];

	MTextEditorState(
		mousexy,
		mouseRightDown,
		cursorPoint,
		selectionPosition,
		selectionPoints,
		cursorVisible,
		focused,
		lines,
		width,
		contentWH,
		textHeight,
		scrollStyle,
		handleDownKeys,
		pasteEventListener,
		handleMouseDown,
		handleMouseUp,
		subs
	);
}

makeMTextEditorView(manager : MaterialManager, inputState : MInputState, m2t : (Material, MFocusGroup) -> Tropic) -> Tropic {
	editorState = makeMTextEditorState(inputState);

	makeInputBox = \ ->
		TSelect3(editorState.lines, editorState.width, inputState.textStyle, \lns, wd, ts ->
			TLines(
				map(lns, \l ->
					MText2T(
						inputState.parent,
						l.visibleText,
						ts
					)
					|> TFixHeight(TFixed(0., editorState.textHeight))
				)
			)
			|> (\f -> TAttachBox(f, editorState.contentWH))
			|> (\t -> TAttachWidth(t, inputState.textWidth))
			|> TSetMinWidth(TFixed(wd, 0.))
			|> TFixHeight(TFixed(0., i2d(length(lns)) * editorState.textHeight))
		);

	TGroup2(
		// Selection
		SelectTGroup(editorState.selectionPoints, \__, __, p ->
			TFixed(
				max(
					thirdOfTriple(p).x - secondOfTriple(p).x,
					if (getValue(editorState.selectionPosition).end.line == firstOfTriple(p)) 0. else 4.
				),
				thirdOfTriple(p).y + editorState.textHeight - secondOfTriple(p).y
			)
			|> (\f -> TRectangle([MFill(inputState.color), FillOpacity(0.2)], f))
			|> (\f -> TTranslate(const(secondOfTriple(p)), f))
		)
			|> (\f -> TShow(editorState.focused, f))
			|> (\f -> TFixSize(f, TEmpty())),
		TGroup2SameMetrics(
			// The lines themselves
			makeInputBox(),
			// The cursor
			TGraphics([MoveTo(0.0, 0.0), LineTo(0.0, editorState.textHeight)], [MStroke(inputState.color), StrokeWidth(2.)])
			|> (\f -> TVisible(editorState.cursorVisible, f))
			|> (\f -> TTranslate(editorState.cursorPoint, f))
			|> (\f -> TFixSize(f, TEmpty()))
		)
	)
	|> (\f ->
		TCopySize(
			f,
			\tr ->
				TConstruct(
					[
						makeSubscribeUns(inputState.mfocus.focused, \fc ->
							if (fc)
								[
									TInteractive(
										[KeyDown2(editorState.handleDownKeys)],
										TRectangle(interactiveRectangleStyle, TGroup2(TFillXY(), tr))
									)
									|> (\t -> if (inputState.readOnly) t else TConstruct([editorState.pasteEventListener], t))
									|> (\t -> trender(t, inputState.manager.manager.renderStyle))
								]
							else
								[]
						)
					],
					TInteractive(
						[
							TMouseXY(editorState.mousexy),
							MouseDown2(editorState.handleMouseDown),
							MouseUp2(editorState.handleMouseUp),
							TMouseRightDown(editorState.mouseRightDown)
						],
						TRectangle(interactiveRectangleStyle, TGroup2(TFillXY(), tr))
						|> (\f2 -> disableScrollInsideEnabled(manager, f2, inputState.mfocus.focused))
					)
				),
			true
		)
	)
	|> (\f ->
		if (inputState.align == AutoAlignCenter())
			TFixSize(f, TSized(editorState.contentWH)) |> TCenterX
		else if (inputState.align == AutoAlignRight())
			TFixSize(f, TSized(editorState.contentWH)) |> TAlignTopRight
		else
			f
	)
	|> (\f -> TAttachAvailableWidth(f, editorState.width))
	|> (\f -> {
		boxHeight =
			if (inputState.linesCount > 0)
				const(i2d(inputState.linesCount) * editorState.textHeight)
			else
				fselect(editorState.lines, FLift(\lns ->
					i2d(
						if (inputState.linesCount == 0 || inputState.linesCount == -1)
							max(length(lns), 1)
						else
							forceRange(-inputState.linesCount, 1, length(lns))
					) * editorState.textHeight
				));

		MScroll(
			f,
			TFillXHT(boxHeight),
			editorState.scrollStyle
		)
		|> (\f2 -> MScroll2T(manager, inputState.parent, f2, m2t))
	})
	|> (\f -> TConstruct(editorState.subs, f))
}

makeNativeEditorView(manager : MaterialManager, parent : MFocusGroup, state : [MTextInputState], inputState : MInputState, m2t : (Material, MFocusGroup) -> Tropic) -> Tropic {
	isEmailType = inputState.inputType == EmailType();
	interlineSpacing =
		if (inputState.multiline) {
			\ts -> MTextStyle2InterlineSpacing(parent, ts).d
		} else {
			\__ -> 0.0
		};

	paragraphInterlineStyles = \ts -> {
		is = interlineSpacing(ts);
		[InterlineSpacing(is), ParagraphMargin(0., is)];
	}

	inputFlexibleSize =
		if (mobile && ios())
			\ -> TAttach(THeight(TGhost("MTextInputText")), \met ->
				TSelect2(met.width, met.height, \w, h -> {
					mut = make(TFixed(2., 2.));
					timer(100, \ -> next(mut, TFixed(1., 1.)));
					timer(200, \ -> next(mut, TEmpty()));

					TLines2(
						TFixed(w, h),
						TMutable(mut)
					)
				})
			)
		else
			\ -> THeight(TGhost("MTextInputText"));

	inputFixedSize = \lines ->
		THeight(
			TSelect(inputState.textStyle, \ts : [MTextStyle] ->
				MDynamicParagraph2T(
					inputState.parent,
					const(generate(0, lines, \i -> "M\n") |> concatStrings),
					concatA([
						ts,
						paragraphInterlineStyles(ts),
						[MWidth(400.)]
					])
				)
			)
		);

	inputSize =
		TGroup2(
			if (inputState.width == 0.)
				TCols2(TWidth(TGhost("MTextInputText")), TFixed(4., 0.))
			else
				TFillX(),
			if (inputState.multiline) {
				if (inputState.linesCount == 0 || inputState.linesCount == -1) {
					inputFlexibleSize();
				} else if (inputState.linesCount > 0) {
					inputFixedSize(inputState.linesCount);
				} else {
					TMinimumGroup2(
						inputFlexibleSize(),
						inputFixedSize(-inputState.linesCount)
					);
				}
			} else {
				THeight(TSelect(inputState.textStyle, \ts -> TText("m", MTextStyle2CharacterStyle(inputState.parent, ts))))
			}
		);

	inpWH = makeWH();

	showInput =
		if (isSome(inputState.autoCompleteType)) const(true)
		else fOr(inputState.mfocus.focused, fand(const(inputState.multiline), inputState.mfocus.focusEnabled));

	inputAriaLabel =
		if (strlen(inputState.label) > 0) const(inputState.label)
		else fselect(inputState.mfocus.title, FLift(\title -> if (title == "") "Input" else title));

	textInput = \ ->
		TransformTAcc(\t2a, pi, ss, mo ->
			t2a(
				TFForm(
					FTextInput(
						inputState.content,
						inpWH,
						concatA([
							[
								InterlineSpacing(interlineSpacing(fgetValue(inputState.textStyle))),
								FWordWrap(const(inputState.wordWrap)),
								FMultiline(const(inputState.multiline)),
								FInputType(eitherFn(
									inputState.password,
									\ps ->
										fif(ps.showPassword, const(inputState.inputType), const(PasswordType())),
									\ ->
										const(if (inputState.numeric) NumericType() else inputState.inputType)
								)),
								FReadOnly(const(inputState.readOnly)),
								FMaxChars(const(inputState.maxChars)),
								FAutoAlign(const(inputState.align)),
								FFocus(inputState.focus),
								FPosition(inputState.position),
								FSelection(inputState.selection),
								FCursorColor(const(MColor2int(inputState.cursorState.color))),
								FCursorOpacity(const(inputState.cursorState.opacity)),
								FCursorWidth(const(inputState.cursorState.width)),
								FInputKeyFilter(\name, ke -> {
									if (getValue(inputState.focus)) {
										scrollIntoView(inputState.mfocus);
									}

									filterKey =
										eitherMap(inputState.processedKeyDown, \pk -> pk.fn(ke), true) &&
										(js || (inputState.multiline && !ke.shift) || (ke.keycode != KEY_TAB && ke.keycode != KEY_BACKTAB)) &&
										!((ke.ctrl && (ke.keycode  == 187 || ke.utf == "=")) || (ke.ctrl && (ke.keycode  == 95 || ke.utf == "-"))) &&
										eitherMap(
											inputState.autocomplete,
											\ac -> (ke.keycode != KEY_ENTER || getValue(ac.selected) < 0),
											true
										);

									if (filterKey && checkIScriptCaptureOption(manager, IScriptCaptureKeyEvents())) {
										addIScriptBehaviourRecord(
											manager,
											inputState.mfocus.name,
											name,
											KeyEventRecord(ke.utf, ke.ctrl, ke.shift, ke.alt, ke.meta, ke.keycode),
											eitherMap(fgetValue(getCurrentFocusedItemBehaviour(manager)), getFullMFocusId, makeList()),
											ISKeyEvent(),
											getCallstackIfNeeded(manager)
										)
									}

									filterKey;
								}),
								FCharacterStyle(fselect(inputState.textStyle, FLift(\ts : [MTextStyle] -> MTextStyle2CharacterStyle(parent, ts)))),
								SetRTL(parent.rtl)
							],
							eitherMap(
								inputState.autoCompleteType,
								\ac ->
									[FAutoCompleteType(const(ac.type))],
								[]
							),
							eitherMap(
								inputState.numericStep,
								\st ->
									[FNumericStep(st.step)],
								[]
							),
							eitherMap(
								inputState.filterFn,
								\fn ->
									[FInputFilter(\str -> fn.fn(str, getValue(inputState.focus)))],
								[]
							),
							if (inputState.numeric && inputState.noNumericArrows) [ClassName("no_numeric_arrows")] else [],
							if (inputState.preventContextMenu) [FPreventContextMenu()] else [],
							if ((^fAccessibilityEnabled || cpp) && !mobile) {
								accessProperties = extractStructMany(state, FAccessAttribute("", const("")));

								if (fgetValue(parent.id) != -2)
									concat(
										accessProperties,
										[
											FAccessTabOrder(fselect(parent.tabOrder, FLift(\to -> arrayPush(to, -1)))),
											FAccessEnabled(inputState.mfocus.focusEnabled),
											FAccessZorder(parent.zorder),
											FAccessAttribute("aria-label", inputAriaLabel)
										]
									)
								else
									concat(
										accessProperties,
										[
											FAccessZorder(parent.zorder),
											FAccessAttribute("aria-label", inputAriaLabel)
										]
									);
							} else {
								[]
							}
						])
					),
					zeroTMetrics
				),
				pi,
				ss,
				mo
			)
		)
		|> (\f -> TFixSize(f, TGhost("MTextInputSize")))
		|> (\f -> disableScrollInsideEnabled(manager, f, inputState.mfocus.focused))
		|> (\f -> TAlpha(fif(showInput, const(1.), zero), f))
		|> (\f ->
			TransformTAcc2(\t2a -> {
				acc = f |> t2a;

				TAcc(
					acc.form,
					TFormMetrics(
						acc.metrics.width,
						zero,
						zero
					),
					acc.minWidth,
					zero,
					acc.maxWidth,
					zero,
					acc.xFillers,
					zero,
					acc.addFillers,
					acc.xConstant,
					true,
					acc.disposers
				)
			})
		);

	(if (isEmailType) textInput() else TVisibleLazy(inputState.mfocus.focusEnabled, textInput))
	|> (\f ->
		TGroup2WithoutMetrics(
			TVisible(
				fnot(showInput),
				MScroll2T(
					manager,
					inputState.parent,
					MScroll(
						if (inputState.align == AutoAlignCenter())
							TCenterXIn(TDisplay("MTextInputText"), TGhost("MTextInputSize"))
						else if (inputState.align == AutoAlignRight())
							TTweak([TAlign(const(1.), const(0.))], TDisplay("MTextInputText"), TGhost("MTextInputSize"))
						else if (inputState.align == AutoAlignLeft())
							TDisplay("MTextInputText")
						else
							TAlignStartDir(TDisplay("MTextInputText"), inputState.parent.rtl),
						TGhost("MTextInputSize"),
						concat(inputState.scrollStyle, [TScrollbars(invisibleScrollBar, getMaterialScrollBar().y)])
					),
					m2t
				)
			),
			f
		)
	)
	|> (\f -> TGroup2SameMetrics(TDisplay("MTextInputSize"), f))
	|> (\f -> TLet("MTextInputSize", TAttachBox2(inputSize, inpWH, TEmpty()), f))
	|> (\f ->
		TLet(
			"MTextInputText",
			(\c0, sp, ts : [MTextStyle] -> {
				eol = getCharCodeAt("\n", 0);
				c =
					(if (sp)
						c0
					else
						stringFold(c0, "", \acc, c ->
							if (c == eol)
								acc + fromCharCode(c)
							else
								acc + "\u2022"
						))
					|> (\c ->
						if (inputState.multiline)
							strSplit(c, "\n")
							|> (\spl -> foldi(spl, "", \i, acc, ch -> acc + ch + "\t\n"))
						else
							strReplace(c, "\n", "")
					);

				if (inputState.multiline)
					MDynamicParagraph2T(
						inputState.parent,
						const(c),
						concatA([
							ts,
							paragraphInterlineStyles(ts),
							[MWidth(-1.)]
						])
					)
				else
					MText2T(inputState.parent, c, ts)
			})
			|> (\f2 ->
				eitherMap(
					inputState.password,
					\pw -> TSelect3(inputState.content, pw.showPassword, inputState.textStyle, f2),
					TSelect2(inputState.content, inputState.textStyle, \c, ts -> f2(c, true, ts))
				)
			)
			|> (\t -> TAttachWidth(t, inputState.textWidth)),
			f
		)
	)
}

defaultCompletionFn(manager : MaterialManager, parent : MFocusGroup, style : [MAutoCompleteStyle]) -> MCompletionFn {
	condensed = extractStruct(style, MCondensed(false)).condensed;
	textStyle : [MTextStyle] =
		extractMTextStyleDef(
			extractStruct(style, MCustomTextStyle([])).style,
			MFontStyleBundle(getTextColor(parent), if (condensed) MBody2() else MSubtitle1(), true)
		);
	isTextInputInPopup = !contains(style, MTextInputOutOfPopup());
	custLeftButton = extractStruct(style, MStartCustomButton(TEmpty(), TFixed(1., 1.), 56., true));
	leftButton = extractStruct(style, MShowLeftButton(false)).show || custLeftButton.closed != TEmpty();
	leftIcon = extractStruct(style, MLeftIcon("", [])).icon != "";
	label = extractStruct(style, MLabel("")).label;
	hasFloatingLabel = contains(style, MFloatingLabel()) && label != "";
	tTextMetrics = getTWordMetrics(MText2T(parent, " ", textStyle), makeTree());

	inputBorders =
		extractStruct(
			style,
			MInputBorders(
				8.,
				if (hasFloatingLabel) {if (condensed) 20. else 28.} else {if (condensed) 12. else 16.},
				8.,
				if (condensed) 12. else 16.
			)
		);
	skin = calculateMTextInputSkin(style);
	defLeftIconPadding = switch (skin) {
		MTextInputPlain(): 72.;
		MOutlined(): 36.;
		MFilled(): 36.;
	}

	lineHeight = completionLineHeight(tTextMetrics, inputBorders);

	MCompletionFn(\com, isSelected, setWordFn ->
		MGetMaterial2Tropic(\m2t -> MGetFocusGroup(\p -> {
			focusState = [
				MOnClick(\ -> setWordFn(com)),
				MRippleType(const(MRippleFill())),
				MFocusEnabled(const(false)),
				MShortcut(if (isSelected) "enter" else "")
			];
			isRTL = p.rtl;

			face =
				TLinesDir([
					TFillX(),
					MEllipsisText2T(manager, parent, MEllipsisText(com.sentence, arrayPush(textStyle, MShowTooltip(const(true)))), m2t)
					|> TCenterY
				], isRTL)
				|> (\f ->
					TBorderTDir(
						fsum(concat3(
							[const(inputBorders.start)],
							if (leftButton && isTextInputInPopup) [custLeftButton.inputIndent] else [],
							if (leftIcon) [const(defLeftIconPadding)] else []
						)),
						zero,
						const(inputBorders.end),
						zero,
						f,
						isRTL
					)
				)
				|> (\f -> TAvailable(f, TFillXH(lineHeight)))
				|> (\f -> TFixSize(f, TFillXH(lineHeight)));

				MComponent2T(
					manager,
					p,
					"CompletionLine",
					focusState,
					\focus ->
						makeTListLine(getLightBackground(p), face, focus, const(isSelected), const(true), [],
							[MThemeFill(p, MAccentColor()), FillOpacity(0.4)]),
					m2t
				)
				|> (\t -> if (isSelected) TInteractive([KeyDown2(\h, ke -> {
						if (ke.keycode == KEY_ENTER) {
							setWordFn(com);
							true
						} else false
					})], t) else t)
		}))
	)
}

completionLineHeight(textMetrics : FormMetrics, inputBorders : MInputBorders) -> double {
	dceil((textMetrics.height + inputBorders.top + inputBorders.bottom - 3.) / 4.) * 4.;
}

addMAutocompleteSuggestionInLine(inputState : MInputState) -> (Tropic) -> Tropic {
	dh = if (!inputState.useNativeInput) 0. else if (js) -1. else 1.; // workaround for better text alignment

	\t ->
		eitherMap(inputState.autocomplete, \ac ->
			eitherMap(ac.inLine, \inline ->
				TSelect2(inline.bestSuggestion, inputState.textStyle, \best, ts ->
					eitherMap(best,	\sg ->
						MText2T(inputState.parent, sg.second, arrayPush(ts, MTextDisabled()))
						|> (\t2 -> TTranslate(fselect(inputState.textWidth, FLift(\tw -> Point(tw, dh))), t2)),
						TEmpty()
					)
				)
				|> (\sg -> TShow(inputState.focus, sg))
				|> (\sg -> TGroup2SameMetrics(t, sg)),
				t
			),
			t
		)
}

makeAutocompleteMatcher(minChars : int) ->
	(matcher : SentenceMatcher, input : string, maxHits : int, prefix : bool, exhaustive : bool, position : int) -> [SentenceMatch] {

	if (minChars == 0) simpleSentenceMatcher 
	else \matcher, input, maxHits, prefix, exhaustive, position -> {
		if (strlen(input) < minChars) []
		else simpleSentenceMatcher(matcher, input, maxHits, prefix, exhaustive, position);
	}
}

calculateMTextInputSkin(style : [MAutoCompleteStyle]) -> MTextInputSkin {
	// For testing purposes
	urlSkin = getUrlParameter("inputSkin");
	smallEdit = contains(style, MEditDialog());

	defaultSkin =
		if (urlSkin == "filled" && !smallEdit) MFilled()
		else if (urlSkin == "outlined" && !smallEdit) MOutlined()
		else MTextInputPlain();
	
	fold(style, defaultSkin, \acc, st ->
		switch (st) {
			MFilled(): st;
			MOutlined(): st;
			default: acc;
		}
	);
}
