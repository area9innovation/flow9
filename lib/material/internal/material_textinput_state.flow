import material/internal/material_list;
import material/tropic_size_util;
import formats/email/email;
import ds/treeutils;

export {
	// Set to false for non-native inputs
	// See MNativeInput comments in material.flow for more info
	nativeInputs = ref !isUrlParameterFalse("nativeInputs");

	makeMInputState(manager : MaterialManager, style : [MAutoCompleteStyle], state : [MTextInputState],
		mfocus : MFocus, iScriptBehaviours : MTextEditorIScriptBehaviours) -> MInputState;

	makeMTextEditorIScriptBehaviours(content : DynamicBehaviour<string>, style : [MAutoCompleteStyle],
		state : [MTextInputState]) -> MTextEditorIScriptBehaviours;

	makeMTextEditorView(manager : MaterialManager, inputState : MInputState) -> Tropic;
	makeNativeEditorView(manager : MaterialManager, parent : MFocusGroup, state : [MTextInputState],
		inputState : MInputState) -> Tropic;

	defaultCompletionFn(manager : MaterialManager, parent : MFocusGroup, style : [MAutoCompleteStyle]) -> MCompletionFn;

	MTextEditorIScriptBehaviours(
		content : DynamicBehaviour<string>,
		inputType : InputType,
		label : string,
		dynamicSize : bool,
		focus : DynamicBehaviour<bool>,
		position : DynamicBehaviour<int>,
		selection : DynamicBehaviour<int>,
		readOnly : bool,
		numeric : bool,
		editIcon : Maybe<DynamicBehaviour<bool>>,
		filterAction : IScriptBehaviourDisposable1,
		error : Maybe<MInputErrorState>,
		iScriptBehaviours : [IScriptBehaviour],
		useNativeInput : bool,
		isTextInputInPopup : bool
	);

	MInputState(
		manager : MaterialManager,
		parent : MFocusGroup,
		content : DynamicBehaviour<string>,
		inputType : InputType,
		mfocus : MFocus,
		focus : DynamicBehaviour<bool>,
		position : DynamicBehaviour<int>,
		selection : DynamicBehaviour<int>,
		cursorShape : DynamicBehaviour<CursorShape>,
		mTextStyle : [MTextStyle],
		textStyle : [CharacterStyle],
		mTextStyleDisabled : [MTextStyle],
		tTextMetrics : FormMetrics,
		smallEdit : bool,
		label : string,
		dynamicSize : bool,
		linesCount : int,
		underline : Maybe<DynamicBehaviour<Pair<[TGraphicsStyle], double>>>,
		multiline : bool,
		wordWrap : bool,
		numeric : bool,
		numericStep : Maybe<MNumericStep>,
		readOnly : bool,
		color : MColor,
		width : double,
		align : AutoAlignType,
		iconSize : double,
		iconBorders : double,
		leftIcon : Maybe<DynamicBehaviour<Tropic>>,
		leftButton : Maybe<MLeftCustomButton>,
		editIcon : Maybe<DynamicBehaviour<bool>>,
		rightButton : Maybe<Transform<string>>,
		inputBorders : MInputBorders,
		noLeftBorder : bool,
		maxChars : int,
		backgroundStyle : MInputBackgroundStyle,
		labelStyle : Transform<[CharacterStyle]>,
		floatingLabel : Maybe<MInputFloatingLabelState>,
		popup : Maybe<MInputPopupState>,
		autocomplete : Maybe<MInputAutocompleteState>,
		error : Maybe<MInputErrorState>,
		limitError : Maybe<MInputLimitErrorState>,
		helperText : Maybe<MInputHelperState>,
		password : Maybe<MInputPasswordState>,
		eatKeyDown : (KeyEvent) -> bool,
		processedKeyDown : Maybe<MInputProcessKeyDown>,
		filterFn : Maybe<MInputFilter>,
		filterAction : (string) -> void,
		positionOnFocus : Maybe<(content : string, previous : int) -> int>,
		selectionOnFocus : Maybe<(content : string, previous : int) -> int>,
		clearContent : (focused : bool) -> void,
		goToPrev : () -> void,
		subs : [() -> () -> void],
		shift : Transform<double>,
		useNativeInput : bool
	);

	MInputAutocompleteState(
		matchers : [Transform<SentenceMatcher>],
		sentenceMatcher : MSentenceMatcher,
		completionFn : MCompletionFn,
		sentences : DynamicBehaviour<[SentenceHit]>,
		selected : DynamicBehaviour<int>,
		showAllOnEmpty : bool,
		maxResults : int,
		autoSelect : bool,
		includeSpaces : bool,
		currentMatches : Maybe<MCurrentMatches>,
		fill : [TGraphicsStyle],
		setWord : (matches : [SentenceMatch], match : SentenceMatch) -> void,
		isTextInputInPopup : bool
	);

	MInputPopupState(
		openMenu : MOpenMenu,
		maxHeight : double,
		inputWH : DynamicBehaviour<WidthHeight>,
		contentWH : DynamicBehaviour<WidthHeight>,
		boxWH : DynamicBehaviour<WidthHeight>,
		scrollPosition : DynamicBehaviour<Point>,
		positionScale : DynamicBehaviour<PositionScale>,
		elevation : Transform<double>
	);

	MInputErrorState(
		text : Transform<Maybe<Pair<string, bool>>>,
		lines : int,
		height : double,
		requiredField : bool,
		color : Transform<MColor>,
		style : Transform<[MTextStyle]>,
		ok : Maybe<MInputIsOk>,
		error : DynamicBehaviour<Pair<string, [MTextStyle]>>
	);

	MInputHelperState(
		text : Transform<Maybe<string>>,
		persistent : bool,
		lines : int,
		height : double,
		helper : DynamicBehaviour<Pair<string, [MTextStyle]>>
	);

	MInputLimitErrorState(
		lines : int,
		height : double,
		limit : DynamicBehaviour<Pair<string, [MTextStyle]>>
	);

	MInputPasswordState(
		showPassword : DynamicBehaviour<bool>,
		style : DynamicBehaviour<[MIconStyle]>
	);

	MInputFloatingLabelState(
		labelSize : double,
		labelSizeFocused : double,
		aboveLabel : double,
		betweenLabels : double,
		showFloatingLabel : DynamicBehaviour<bool>,
	);

	passwordFilter = \state : [MTextInputState] -> {
		inpe = extractStruct(state, MInputError(const(None()), []));
		inpf = extractStruct(state, MInputFilter(\c, __ -> c));
		defErColor = extractStruct(inpe.style, MInputErrorColor(const(MErrorColor()))).color;
		erColor = make(fgetValue(defErColor));
		passwordEr = make(None());

		specialCharacters = "!\"#$%&'()*+,-./:;<=>?@[\\]^_`{|}~";

		haveBothCasesAndDigitOrSpecChar = \c -> stringFold(c, Triple(false, false, false), \acc, i -> {
			char = fromCharCode(i);

			Triple(
				// check if exist upperCase letter
				firstOfTriple(acc) || (isLetter(char) && char == toUpperCase(char)),
				// check if exist lowerCase letter
				secondOfTriple(acc) || (isLetter(char) && char == toLowerCase(char)),
				// check if exist digit or special character
				thirdOfTriple(acc) || isDigit(char) || strContains(specialCharacters, char)
			);
		})
		|> (\f : Triple<bool, bool, bool> -> firstOfTriple(f) && secondOfTriple(f) && thirdOfTriple(f));

		replaceStructMany(
			state,
			[
				MInputFilter(\c, foc -> {
					deferred(\ ->
						if (strlen(c) < 8) {
							nextDistinct(erColor, fgetValue(defErColor));
							nextDistinct(passwordEr, Some(Pair(_("Password is too short"), true)))
						} else if (!containsLetters(c)) {
							nextDistinct(erColor, fgetValue(defErColor));
							nextDistinct(passwordEr, Some(Pair(_("Password is too weak"), true)))
						} else if (!haveBothCasesAndDigitOrSpecChar(c)) {
							nextDistinct(erColor, MOrangeA(400));
							nextDistinct(passwordEr, Some(Pair(_("Fair password"), false)))
						} else {
							nextDistinct(erColor, MGreenA(400));
							nextDistinct(passwordEr, Some(Pair(_("Strong password"), false)))
						}
					);

					c
				}),
				MInputError(fifsome(inpe.text, inpe.text, passwordEr), replaceStruct(inpe.style, MInputErrorColor(erColor)))
			]
		)
	};

	emailFilter = \state : [MTextInputState] -> {
		inpe = extractStruct(state, MInputError(const(None()), []));
		inpf = extractStruct(state, MInputFilter(\c, __ -> c));
		emailEr = make(None());

		replaceStructMany(
			state,
			[
				MInputFilter(\c, foc -> {
					deferred(\ -> nextDistinct(emailEr, if (!foc && !isEmail(c)) Some(Pair("Invalid email format", true)) else None()));

					c
				}),
				MInputError(fifsome(inpe.text, inpe.text, emailEr), inpe.style)
			]
		)
	};

	defEatKeyDown = \multiline : bool, readOnly : bool -> \k -> {
		k.keycode == 37 || k.keycode == 39 || k.keycode == 38 || k.keycode == 40 || (k.keycode == 27 && !readOnly) ||
		(k.keycode == 8 && !readOnly) || (k.keycode == 9 && !readOnly && multiline) || (k.keycode == 13) ||
		(k.keycode == 46 && !k.shift && !readOnly) || (k.keycode == 13 && !readOnly) || (k.keycode == 65 && k.ctrl) ||
		((k.keycode == 67 || k.keycode == 45) && k.ctrl) || (k.keycode == 88 && k.ctrl) || (k.keycode == 46 && k.shift) ||
		(strlen(k.utf) == 1 && !readOnly && k.keycode != 16777218 && (k.keycode != 86 || !k.ctrl))
	};
}

numericFilter = \s -> {
	dotB = ref false;

	fold(enumFromTo(0, strlen(s) - 1), "", \acc, i ->
		getCharAt(s, i)
		|> (\c ->
			if (isDigit(c) || (i == 0 && c == "-"))
				acc + c
			else if ((c == "." || c == ",") && !^dotB && i != 0 && (i != 1 || getCharAt(s, 0) != "-")) {
				dotB := true;
				acc + c
			} else
				acc
		)
	);
}

makeMInputState(manager : MaterialManager, style : [MAutoCompleteStyle], state : [MTextInputState],
	mfocus : MFocus, iScriptBehaviours : MTextEditorIScriptBehaviours) -> MInputState {
	parent = mfocus.parent;
	content = iScriptBehaviours.content;
	inputType = iScriptBehaviours.inputType;
	readOnly = iScriptBehaviours.readOnly;
	numeric = iScriptBehaviours.numeric;
	numericStep = if (numeric) tryExtractStruct(style, MNumericStep(const(1.))) else None();
	editIcon = iScriptBehaviours.editIcon;
	useNativeInput = iScriptBehaviours.useNativeInput;
	label = iScriptBehaviours.label;
	dynamicSize = iScriptBehaviours.dynamicSize;
	hasFloatingLabel = contains(style, MFloatingLabel()) && label != "";
	linesCount = extractStruct(style, MMaxLines(1)).lines;
	showUnderline = extractStruct(style, MShowUnderline(true)).show;
	multiline = extractStruct(style, Multiline(false)).multiline;
	wordWrap = multiline && extractStruct(style, WordWrap(true)).wordWrap;
	condensed = extractStruct(style, MCondensed(false)).condensed;
	color = extractStruct(style, getAccentColor(parent));
	width = extractStruct(style, MWidth(-1.)).width;
	align = extractStruct(style, AutoAlign(AutoAlignNone())).autoalign;
	fontPadding = extractStruct(style, MInputFontPadding(0.)).padding;
	filterAction = iScriptBehaviours.filterAction;
	smallEdit = contains(style, MEditDialog());
	elevation = tryExtractStruct(style, MElevation(const(8.)));
	isPopup = isSome(elevation) || smallEdit;
	eatKeyDown = extractStruct(state, MEatKeyDown(defEatKeyDown(multiline, readOnly))).fn;
	processedKeyDown = tryExtractStruct(state, MInputProcessKeyDown(\__ -> true));
	filterFn = tryExtractStruct(state, MInputFilter(\c, __ -> c));
	textInputCursorShape = make(DefaultCursor());
	noLeftBorder = contains(style, MInputNoLeftBorder());

	//Text Style
	mTextStyle =
		extractMTextStyleDef(
			extractStruct(style, MCustomTextStyle([])).style,
			Triple(getTextColor(parent), if (condensed) MBody() else MSubheading(), true)
		)
		|> (\f : Triple<MColor, MFontStyle, bool> ->
			[firstOfTriple(f), secondOfTriple(f)]
			|> (\f2 -> if (thirdOfTriple(f)) f2 else arrayPush(f2, MTextDisabled()))
		);

	textStyle : [CharacterStyle] = MTextStyle2CharacterStyle(mTextStyle, getLightBackground(parent));

	mTextStyleDisabled =
		extractMTextStyleDef(
			extractStruct(style, MCustomTextStyle([])).style,
			Triple(getTextColor(parent), if (condensed) MBody() else MSubheading(), false)
		)
		|> (\f : Triple<MColor, MFontStyle, bool> ->
			[firstOfTriple(f), secondOfTriple(f), MTextDisabled()]
		);

	tTextMetrics = getTWordMetrics(TText(" ", textStyle), makeTree());

	prev = ref getValue(content);

	inputBorders =
		extractStruct(
			style,
			MInputBorders(
				if (isPopup && !noLeftBorder && !smallEdit) 8. else 0.,
				if (hasFloatingLabel) {if (condensed) 20. else 28.} else {if (condensed) 12. else 16.},
				if (isPopup && !smallEdit) 8. else 0.,
				if (condensed) 12. else 16.
			)
		);

	// Underline
	inputUnderline : Maybe<DynamicBehaviour<Pair<[TGraphicsStyle], double>>> =
		if (showUnderline)
			Some(make(Pair([MFill(color)], 0.)))
		else
			None();

	emptyUnderline = Pair([], 2.);

	// TTextInputState
	focus = make(false);
	position = iScriptBehaviours.position;
	selection = iScriptBehaviours.selection;

	positionOnFocus =
		eitherMap(
			tryExtractStruct(state, MPositionOnFocus(\c, p -> 0)),
			\pof -> Some(pof.fn),
			None()
		);
	selectionOnFocus =
		eitherMap(
			tryExtractStruct(state, MSelectionOnFocus(\c, p -> strlen(c))),
			\sof -> Some(sof.fn),
			None()
		);

	// Popup
	popup =
		if (isPopup) {
			Some(
				MInputPopupState(
					MOpenMenu(make(false)),
					extractStruct(style, MMaxHeight(-1.)).height,
					makeWH(),
					makeWH(),
					makeWH(),
					extractStruct(style, MScrollPosition(make(zeroPoint))).position,
					make(zeroPositionScale),
					either(elevation, MElevation(const(0.))).elevation
				)
			)
		} else
			None();

	backgroundFill =
		extractStruct(
			style,
			if (!isPopup)
				MInputBackgroundStyle([], [])
			else
				MInputBackgroundStyle([], [MFill(MDialogColor(getLightBackground(parent)))])
		);

	//Icons
	iconSize = MIconSize(if (condensed) 20. else 24.).size;
	iconBorders = 8.;
	showDropDownArrow = !readOnly && extractStruct(style, MShowDropDownArrow(false)).show;
	mClearIcon = extractStruct(style, MShowClearIcon(mobile && (width <= 0. || width > 96.), false));
	showClearIcon = (mClearIcon.onFocus || mClearIcon.onHover) && !readOnly;

	// Left icon
	leftIconName = tryExtractStruct(style, MLeftIcon(""));
	leftIcon =
		maybeMap(
			leftIconName,
			\li -> make(
				if (li.icon != "")
					MIcon2T(parent, if (isMaterialIcon(li.icon)) li.icon else "subject", [MIconSize(iconSize)])
				else
					TEmpty()
			)
		);

	// Left Button
	leftButtonDef =
		MLeftCustomButton(MIcon("search", [MIconSize(iconSize)]), MIcon("arrow_back", [MIconSize(iconSize)]), 56.);

	showLeftButton = extractStruct(style, MShowLeftButton(false)).show;

	leftButton =
		if (showLeftButton)
			Some(extractStruct(style, leftButtonDef))
		else
			tryExtractStruct(style, leftButtonDef);

	// Right Button
	rightButton =
		if (showClearIcon)
			Some(
				fif(
					fand(
						fand(
							mfocus.enabled,
							fthrottle2(
								if (mClearIcon.onHover) mfocus.hover
								else if (mClearIcon.onFocus) mfocus.focused
								else const(false),
								10
							)
						),
						fneq(content, "")
					),
					const("clear"),
					if (showDropDownArrow) fif(mfocus.focused, const("arrow_drop_down"), const("arrow_drop_up"))
					else const("")
				)
			)
		else if (showDropDownArrow)
			Some(fif(
				fand(mfocus.enabled, mfocus.focused),
				const("arrow_drop_up"),
				const("arrow_drop_down")
			))
		else
			None();

	// Floating Label
	disabledColor = contrastingColor(parent);
	disabledOpacity = if (getLightBackground(parent)) 0.38 else 0.5;
	secondaryOpacity = if (getLightBackground(parent)) 0.54 else 0.7;

	unfocusedUnderline = extractStruct(style, MUnderlineUnfocusedStyle([Fill(disabledColor), FillOpacity(disabledOpacity / 4.)])).style;

	mLabelStyle =
		extractMTextStyleDef(
			extractStruct(style, MLabelTextStyle(if (hasFloatingLabel) [] else mTextStyle)).style,
			Triple(getTextColor(parent), MCaptionSolid(), true)
		)
		|> (\f : Triple<MColor, MFontStyle, bool> ->
			[firstOfTriple(f), secondOfTriple(f)]
			|> (\f2 -> if (f.third) f2 else arrayPush(f2, MTextDisabled()))
		);

	labelStyle = MTextStyle2CharacterStyle(mLabelStyle, getLightBackground(parent));
	labelSize = extractStruct(labelStyle, FontSize(12.)).size;
	labelStyleB = make(labelStyle);

	disabledStyle = replaceStruct(labelStyle, FillOpacity(disabledOpacity));
	pressedStyle = replaceStruct(labelStyle, if (hasFloatingLabel) MFill(color) else FillOpacity(secondaryOpacity));
	errorTextStyle = replaceStruct(labelStyle, FillOpacity(1.));

	floatingLabel =
		if (hasFloatingLabel) {
			fSize = if (condensed) 13. else 16.;
			fSizeFocused = forceRange(labelSize, 0., inputBorders.top);
			betweenFLabels = if (condensed) 4. else 8.;
			aFlabel = inputBorders.top - fSizeFocused - betweenFLabels;

			Some(
				MInputFloatingLabelState(
					fSize,
					fSizeFocused,
					aFlabel,
					betweenFLabels,
					make(fgetValue(mfocus.focused) || getValue(content) != "")
				)
			)
		} else {
			None()
		};

	// Error
	maxChars = extractStruct(style, MaxChars(-1)).n;

	limitError =
		if (maxChars > 0 && extractStruct(style, MShowMaxChars(true)).show)
			Some(MInputLimitErrorState(1, 16., make(Pair(if (dynamicSize) "" else " ", []))))
		else
			None();

	defaultStyle = [MCaption()];

	error = iScriptBehaviours.error;

	helperText =
		eitherMap(
			tryExtractStruct(state, MHelperText(const(None()), true)),
			\ht ->
				Some(
					MInputHelperState(
						ht.text,
						ht.persistent,
						1,
						16.,
						make(Pair(if (dynamicSize) "" else " ", []))
					)
				),
			None()
		);

	// Password
	passwordMode = extractStruct(style, PasswordMode(false)).password || inputType == PasswordType();
	showPasswordFallbackType =
		if (inputType == PasswordType()) {
			TextType();
		} else {
			inputType;
		}

	password =
		if (passwordMode)
			Some(
				MInputPasswordState(
					extractStruct(state, MInputShowPassword(make(false))).show,
					make([MWhite(), FillOpacity(0.)])
				)
			)
		else
			None();

	// Autocomplete
	preparedSentenceMatcher = extractStruct(style, MPreparedSentenceMatcher(const(dummySentenceMatcher)));
	sentenceMatcher = extractStruct(style, MSentenceMatcher(buildSentenceMatcher, simpleSentenceMatcher));

	matchers =
		if (preparedSentenceMatcher.matcher != const(dummySentenceMatcher)) {
			[preparedSentenceMatcher.matcher]
		} else {
			map(extractStruct(style, MDictionary([])).dictionaries, \mdictionary -> sentenceMatcher.matcher(strSplit(mdictionary, "\n")) |> const)
		};

	autocomplete =
		if (matchers != []) {
			composeContentFn = extractStruct(style, TMatchedHandler(\m1, __, __ -> m1)).fn;

			setWord = \matches : [SentenceMatch], match : SentenceMatch -> {
					nextDistinct(mfocus.focused, false);

					w = match.sentence;
					newContent = composeContentFn(w, getValue(content), getValue(position));
					next(content, newContent);

					if (multiline) nextDistinct(mfocus.focused, true);

					cw = getCurrentWordPosition(getValue(content), getValue(position), [newContent]);
					nextDistinct(position, forceRange(firstOfPair(cw) + strlen(newContent), 0, strlen(getValue(content))));
			}

			Some(
				MInputAutocompleteState(
					matchers,
					sentenceMatcher,
					extractStructMany(style, TCompletionFn(\__, __, __ -> TEmpty()))
					|> (\f ->
						if (length(f) > 0)
							MCompletionFn(f[0].fn)
						else
							extractStruct(style, defaultCompletionFn(manager, parent, style))
					),
					make([]),
					make(-1),
					contains(style, MShowAllOnEmpty()),
					extractStruct(style, MMaxResults(10)).results,
					contains(style, MAutoSelect()),
					extractStruct(style, MIncludeSpaces(!multiline)).includeSpaces,
					tryExtractStruct(style, MCurrentMatches(nop1)),
					extractStruct(style, MSuggestionsBackgroundStyle(backgroundFill.focused)).style,
					setWord,
					iScriptBehaviours.isTextInputInPopup
				)
			)
		} else
			None();

	// Content functions
	clearContent = \focused : bool -> {
		next(content, if (inputType == TelType()) "+" else "");
		nextDistinct(mfocus.focused, focused);

		if (useNativeInput) {
			if (mobile)
				deferUntilRender(\ -> nextDistinct(mfocus.focused, focused))
			else
				deferred(\ -> nextDistinct(mfocus.focused, focused));
		}
	}

	goToPrev = \ -> {
		nextDistinct(content, ^prev);
		nextDistinct(mfocus.focused, false);
	}

	// Update functions
	haveBeenFocused = extractStruct(style, MHaveBeenFocused(make(false))).focused;

	popupUns = initUnsM();

	updateFocus = \foc : bool -> {
		dispUnsM(popupUns);

		if (isPopup && foc) {
			setUnsM(
				popupUns,
				interruptibleTimer(1, \ -> {
					nextDistinct(focus, true);
					maybeApply(popup, \ps -> nextDistinct(ps.openMenu.opened, true));
				})
			)
		} else {
			nextDistinct(focus, foc);
			maybeApply(popup, \ps -> nextDistinct(ps.openMenu.opened, foc));
		}

		if (!foc)
			prev := getValue(content);

		foc;
	}

	updateFocusContent = \c : string, foc : bool, mtch : [SentenceMatcher] -> {
		maybeApply(editIcon, \ei -> nextDistinct(ei, !foc));
		maybeApply(floatingLabel, \fl -> nextDistinct(fl.showFloatingLabel, foc || c != ""));

		maybeApply(
			autocomplete,
			\ac -> {
				c2 =
					if (!ac.includeSpaces) {
						linesN = strSplit(c, "\n");
						words = strSplit(c, " ");
						lastElement(words, "");
					} else {
						c
					};

				allCompl =
					fold(mtch, [], \acc, matcher ->
						concat(acc,
							if (ac.showAllOnEmpty && isSome(popup) && c2 == "")
								map(filter(matcher.sentences, \s -> s != ""), \s -> SentenceHit(matcher, s, 0., makeSet()))
							else
								ac.sentenceMatcher.fn(matcher, c2, intMax, true, false, getValue(position))
						)
					);

				compl = mergeSort(allCompl, \sm1, sm2 -> genericCompareDesc(sm1.score, sm2.score));

				newSentences =
					if (isSome(popup)) {
						if (ac.maxResults >= 0)
							subrange(compl, 0, ac.maxResults)
						else
							compl;
					} else {
						suggest = find(compl, \v -> startsWith(toLowerCase(v.sentence), toLowerCase(c2)));

						eitherMap(suggest, \sg -> [sg], [])
					};

				maybeApply(
					ac.currentMatches,
					\cm ->
						map(newSentences, \ns -> {
							sen = ns.sentence;
							dictId = findiDef(mtch, \mch -> contains(mch.sentences, sen), -1);
							senId = if (dictId >= 0) findiDef(mtch[dictId].sentences, \sn -> sn == sen, -1) else -1;

							Triple(dictId, senId, ns)
						})
						|> cm.fn
				);

				nextDistinct(ac.sentences, newSentences)
			},
		);

		newC =
			if (useNativeInput)
				// (if (cpp && !mobile && numeric) numericFilter(c) else c)
				c
				|> (\f -> if (isUrlParameterFalse("emoji")) f else filterEmojis(f))
				|> (\f -> {
					if (f != c)
						timer(if (mobile) 10 else 0, \ -> next(content, f));

					f
				})
			else
				c;

		Pair(newC, foc)
	}

	updatedContent =
		fselect3(
			content,
			fselect(mfocus.focused, updateFocus |> FLift),
			eitherMap(autocomplete, \ac -> fmerge(ac.matchers), const([])),
			updateFocusContent
		);

	updateErrors = \fc : Pair<string, bool>, en : bool, ie : Maybe<Pair<string, bool>>, hbf : bool -> {
		c = firstOfPair(fc);
		foc = secondOfPair(fc);

		cLength = strlen(c);
		fieldIsOk = ref true;
		currentError : ref Pair<string, [MTextStyle]> = ref Pair("", defaultStyle);

		maybeApply(error, \errorState ->
			eitherFn(
				ie,
				\s -> {
					currentError := Pair(firstOfPair(s), replaceStruct(fgetValue(errorState.style), fgetValue(errorState.color)));

					fieldIsOk := !secondOfPair(s);
				},
				\ -> if (errorState.requiredField && cLength == 0) {
					fieldIsOk := false;

					if (!foc && hbf)
						currentError :=
							Pair(
								formatString(_("%1 is required"), [if (label != "") label else _("Field")]),
								replaceStruct(fgetValue(errorState.style), fgetValue(errorState.color))
							);

					if (foc)
						nextDistinct(haveBeenFocused, true);
				}
			)
		);

		maybeApply(limitError, \le -> {
			charsOk = cLength > maxChars;
			if (!charsOk)
				fieldIsOk := false;

			nextDistinct(
				le.limit,
				Pair(
					if (foc) i2s(cLength) + "/" + i2s(maxChars) else if (dynamicSize) "" else " ",
					if (charsOk) replaceStruct(defaultStyle, MErrorColor()) else defaultStyle
				)
			);

			if (charsOk && firstOfPair(^currentError) == "")
				currentError := Pair(" ", replaceStruct(defaultStyle, MErrorColor()));
		});

		maybeApply(
			error,
			\errorState -> {
				maybeApply(errorState.ok, \he -> nextDistinct(he.ok, ^fieldIsOk));

				nextDistinct(
					errorState.error,
					if (!dynamicSize && firstOfPair(^currentError) == "")
						Pair(" ", secondOfPair(^currentError))
					else
						^currentError
				);
			}
		);

		if (!en) {
			nextDistinct(labelStyleB, disabledStyle);

			maybeApply(inputUnderline, \iu ->
				nextDistinct(
					iu,
					if (smallEdit && !foc)
						emptyUnderline
					else
						Pair([Stroke(disabledColor), StrokeOpacity(disabledOpacity / 2.)], 0.)
				)
			);
			maybeApply(password, \pw ->
				nextDistinct(pw.style, [MIconDisabled()])
			);
			maybeApply(leftIcon, \li -> {
				iconName = either(leftIconName, MLeftIcon("")).icon;

				nextDistinct(
					li,
					if (getValue(li) != TEmpty())
						MIcon2T(
							parent,
							if (isMaterialIcon(iconName)) iconName else "subject",
							[MIconDisabled(), MIconSize(iconSize)])
					else
						TEmpty()
				)
			});
		} else if (secondOfPair(^currentError) != defaultStyle) {
			cFill = extractStruct(secondOfPair(^currentError), MErrorColor());
			iconStyle = if (foc) [cFill, FillOpacity(1.)] else [cFill];

			nextDistinct(labelStyleB, replaceStruct(errorTextStyle, MFill(cFill)));

			maybeApply(inputUnderline, \iu ->
				nextDistinct(
					iu,
					if (smallEdit && !foc)
						emptyUnderline
					else
						Pair([MFill(cFill), FillOpacity(1.)], if (foc) 2. else 1.)
				)
			);
			maybeApply(password, \pw ->
				nextDistinct(pw.style, iconStyle)
			);
			maybeApply(leftIcon, \li -> {
				iconName = either(leftIconName, MLeftIcon("")).icon;

				nextDistinct(
					li,
					if (getValue(li) != TEmpty())
						MIcon2T(
							parent,
							if (isMaterialIcon(iconName)) iconName else "subject",
							arrayPush(iconStyle, MIconSize(iconSize))
						)
					else
						TEmpty()
				)
			});
		} else if (foc) {
			nextDistinct(labelStyleB, pressedStyle);

			maybeApply(inputUnderline, \iu ->
				nextDistinct(
					iu,
					if (smallEdit && !foc)
						emptyUnderline
					else
						Pair([MFill(color), FillOpacity(1.)], 2.)
				)
			);
			maybeApply(password, \pw ->
				nextDistinct(pw.style, [FillOpacity(secondaryOpacity)]));
			maybeApply(leftIcon, \li -> {
				iconName = either(leftIconName, MLeftIcon("")).icon;

				nextDistinct(
					li,
					if (getValue(li) != TEmpty())
						MIcon2T(
							parent,
							if (isMaterialIcon(iconName)) iconName else "subject",
							[color, FillOpacity(1.), MIconSize(iconSize)]
						)
					else
						TEmpty()
				)
			});
		} else {
			nextDistinct(labelStyleB, disabledStyle);

			maybeApply(inputUnderline, \iu ->
				nextDistinct(
					iu,
					if (smallEdit && !foc)
						emptyUnderline
					else
						Pair(unfocusedUnderline, 1.)
				)
			);
			maybeApply(password, \pw ->
				nextDistinct(pw.style, [FillOpacity(disabledOpacity)])
			);
			maybeApply(leftIcon, \li -> {
				iconName = either(leftIconName, MLeftIcon("")).icon;

				nextDistinct(
					li,
					if (getValue(li) != TEmpty())
						MIcon2T(
							parent,
							if (isMaterialIcon(iconName)) iconName else "subject",
							[MIconSize(iconSize)]
						)
					else
						TEmpty()
				)
			});
		}
	}

	subs =
		concatA([
			if (useNativeInput)
				[
					makeSubscribe2(focus, \focused -> {
						nextDistinct(mfocus.focused, focused);

						maybeApply(
							filterFn,
							\inpf ->
								nextDistinct(content, inpf.fn(getValue(content), focused))
						);

						if (focused) {
							maybeApply(
								positionOnFocus,
								\pof ->
									nextDistinct(position, min(max(pof(getValue(content), getValue(position)), 0), strlen(getValue(content))))
							);

							maybeApply(
								selectionOnFocus,
								\sof ->
									nextDistinct(selection, min(max(sof(getValue(content), getValue(selection)), 0), strlen(getValue(content))))
							);
						}
					}),
				]
			else
				[],
			[
				\ -> \ -> {
					nextDistinct(focus, false);
					nextDistinct(mfocus.focused, false);
				},

				make4Subscribe(
					updatedContent,
					mfocus.enabled,
					eitherMap(
						error,
						\errorState -> errorState.text,
						const(None())
					),
					haveBeenFocused,
					updateErrors
				),
				filterAction.subscribers,
				makeSubscribe(mfocus.enabled, \en -> nextDistinct(textInputCursorShape, if (en) TextCursor() else DefaultCursor()))
			],
			eitherMap(
				helperText,
				\helperState -> [
					if (helperState.persistent)
						makeSubscribe(helperState.text, \ht ->
							nextDistinct(helperState.helper,
								Pair(
									either(ht, "")
									|> (\f ->
										if (!dynamicSize && f == "")
											" "
										else
											f
									),
									defaultStyle
								)
							)
						)
					else
						make2Subscribe(helperState.text, mfocus.focused, \ht, foc ->
							nextDistinct(helperState.helper,
								Pair(
									(if (foc) either(ht, "") else "")
									|> (\f ->
										if (!dynamicSize && f == "")
											" "
										else
											f
									),
									defaultStyle
								)
							)
						)
				],
				[]
			)
		]);

	shift =
		if (hasFloatingLabel && dynamicSize)
			fif(
				fOr(mfocus.focused, fneq(content, "")),
				const(tTextMetrics.baseline + inputBorders.top + if (condensed) 8. else 12.),
				const(tTextMetrics.baseline + inputBorders.top)
			)
		else
			const(tTextMetrics.baseline + inputBorders.top);

	MInputState(
		manager,
		parent,
		content,
		showPasswordFallbackType,
		mfocus,
		focus,
		position,
		selection,
		textInputCursorShape,
		mTextStyle,
		textStyle,
		mTextStyleDisabled,
		tTextMetrics,
		smallEdit,
		label,
		dynamicSize,
		linesCount,
		inputUnderline,
		multiline,
		wordWrap,
		numeric,
		numericStep,
		readOnly,
		color,
		width,
		align,
		iconSize,
		iconBorders,
		leftIcon,
		leftButton,
		editIcon,
		rightButton,
		inputBorders,
		noLeftBorder,
		maxChars,
		backgroundFill,
		labelStyleB,
		floatingLabel,
		popup,
		autocomplete,
		error,
		limitError,
		helperText,
		password,
		eatKeyDown,
		processedKeyDown,
		filterFn,
		filterAction.fn,
		positionOnFocus,
		selectionOnFocus,
		clearContent,
		goToPrev,
		subs,
		shift,
		useNativeInput
	)
}

makeMTextEditorIScriptBehaviours(content : DynamicBehaviour<string>, style : [MAutoCompleteStyle],
	state : [MTextInputState]) -> MTextEditorIScriptBehaviours {
	dynamicSize = contains(style, MDynamicSize());
	label = extractStruct(style, MLabel("")).label;
	focus = extractStruct(state, TTextInputFocus(make(false))).focus;
	position = extractStruct(state, TTextInputPosition(make(strlen(getValue(content))))).position;
	selection = extractStruct(state, TTextInputSelection(make(-1))).selection;

	fa : (string) -> void = extractStruct(style, MFilterAction(nop1)).action;
	filterAction = fn2IScriptBehaviourDisposable1(
		\f : flow -> fa(flow2s(f)),
		"filter_action", ISMiscEvent()
	);
	readOnly = extractStruct(style, ReadOnly(false)).readOnly;
	inputType = extractStruct(style, TextInputType(TextType())).inputType;
	numeric = inputType == NumericType();
	isTextInputInPopup = !contains(style, MTextInputOutOfPopup());
	useNativeInput = extractStruct(style, MNativeInput(^nativeInputs && !readOnly && isTextInputInPopup)).useNativeInput || mobile || macosx();
	// Edit Button
	showEditIcon = !readOnly && extractStruct(style, MShowEditIcon(false)).enabled;
	editIcon : Maybe<DynamicBehaviour<bool>> =
		if (showEditIcon && !readOnly)
			Some(make(false))
		else
			None();

	error : Maybe<MInputErrorState> =
		eitherMap(
			tryExtractStruct(state, MInputError(const(None()), [])),
			\ie -> {
				errorLines = extractStruct(ie.style, MMaxLines(1)).lines;
				inputErrorColor = extractStruct(ie.style, MInputErrorColor(const(MErrorColor()))).color;
				inputErrorFont = extractStruct(ie.style, MInputErrorFont(MCustomFont(12.0, "Roboto", 1.))).style;

				Some(
					MInputErrorState(
						ie.text,
						errorLines,
						i2d(errorLines) * (MFontStyle2MCustomFont(inputErrorFont, 0.87, 0.54).size + 4.),
						contains(ie.style, MRequiredField()),
						inputErrorColor,
						fselect(inputErrorColor, FLift(\ec : MColor -> [inputErrorFont, ec])),
						tryExtractStruct(ie.style, MInputIsOk(make(true))),
						make(Pair(if (dynamicSize) "" else " ", []))
					)
				)
			},
			None()
		);

	MTextEditorIScriptBehaviours(
		content,
		inputType,
		label,
		dynamicSize,
		focus,
		position,
		selection,
		readOnly,
		numeric,
		editIcon,
		filterAction,
		error,
		[
			IScriptBehaviour("selected", selection, ISDetailedTextEvent()),
			IScriptBehaviour("position", position, ISDetailedTextEvent()),
			IScriptBehaviour("content", content, ISDetailedTextEvent()),
			filterAction.monitorBehaviour
		]
		|> (\f2 : [IScriptBehaviour] ->
			eitherMap(
				error,
				\er : MInputErrorState ->
					arrayPush(
						f2,
						IScriptBehaviour("error", er.error, ISMiscEvent())
					)
					|> (\f3 : [IScriptBehaviour] ->
						eitherMap(
							er.ok,
							\he : MInputIsOk ->
								arrayPush(
									f3,
									IScriptBehaviour("is_ok", he.ok, ISMiscEvent())
								),
							f3
						)
					),
				f2
			)
		),
		useNativeInput,
		isTextInputInPopup
	)
}

MTextInputLine(visibleText : string, realText : string, length : int, newLine : bool);

emptyMTextInputLine = MTextInputLine("", "", 0, false);

MTextEditorState(
	mousexy : DynamicBehaviour<Point>,
	mouseRightDown : DynamicBehaviour<bool>,
	cursorPoint : DynamicBehaviour<Point>,
	selectionPosition : DynamicBehaviour<MTextEditorSelection>,
	selectionPoints : DynamicBehaviour<[Triple<int, Point, Point>]>,
	cursorVisible : Transform<bool>,
	focused : Transform<bool>,
	lines : Transform<[MTextInputLine]>,
	width : DynamicBehaviour<double>,
	contentWH : DynamicBehaviour<WidthHeight>,
	textHeight : double,
	scrollStyle : [MScrollStyle],
	handleDownKeys : (h : bool, k : KeyEvent) -> bool,
	pasteEventListener : () -> () -> void,
	handleMouseDown : (h : bool, mi : MouseDownInfo) -> bool,
	handleMouseUp : (h : bool, mi : () -> MouseInfo) -> bool,
	subs : [() -> () -> void]
);

MTextEditorPosition(
	symbol : int,
	line : int
);

MTextEditorSelection(
	start : MTextEditorPosition,
	end : MTextEditorPosition
);

makeMTextEditorState(inputState : MInputState) -> MTextEditorState {
	dummyEditorPosition = MTextEditorPosition(-1, -1);
	dummySelection = MTextEditorSelection(dummyEditorPosition, dummyEditorPosition);
	mousexy = make(zeroPoint);
	mouseDown = make(false);
	mouseRightDown = make(false);
	cursorPosition = make(MTextEditorPosition(0, 0));
	cursorPoint = make(zeroPoint);
	selectionPosition : DynamicBehaviour<MTextEditorSelection> = make(dummySelection);
	selectionPoints = make([]);

	cursorVisible = make(false);
	cursUns = initUnsM();
	prevPrevDown = ref 0.;
	prevDown = ref 0.;
	downDelay = 300.;

	scrollPosition = make(zeroPoint);
	contentWH = makeWH();
	boxWH = makeWH();

	width = make(0.);
	focused = inputState.mfocus.focused;
	readOnly = inputState.readOnly;
	multiline = inputState.multiline;
	linesCount = inputState.linesCount;
	maxChars = inputState.maxChars;
	numeric = inputState.numeric;
	textStyle = inputState.textStyle;
	textHeight = getTextSize(".", textStyle).height;

	scrollStyle =
		[
			TScrollBarsStyle(
				invisibleScrollBar,
				if (multiline && linesCount != 0 && linesCount != -1)
					getMaterialScrollBar().vert
				else
					invisibleScrollBar
			),
			MScrollPosition(scrollPosition),
			MScrollWidthHeight(makeWH(), boxWH)
		];

	focusId = getFocusId();

	if (focusId == -1) {
		println("A TextInput should not have a focus id of -1.");
	}

	lines : DynamicBehaviour<[MTextInputLine]> = make([]);

	linesCache = ref Triple(-1., false, makeTree());

	content2lines = \c : string, sp : bool, wd : double -> {
		map(strSplit(c, "\n"), \l ->
			Pair(
				l,
				eitherFn(
					if (wd != firstOfTriple(^linesCache))
						None()
					else
						lookupTree(thirdOfTriple(^linesCache), l),
					idfn,
					\ ->
						if (inputState.wordWrap)
							getSplittedByWidthString(l, wd - 2., textStyle, [CropWords(true)]
								|> (\f -> if (readOnly) arrayPush(f, ShiftLongWords()) else f))
							|> concatA
							|> (\f -> map(f, \f0 -> Pair(strlen(f0), f0)))
						else
							[Pair(strlen(l), l)]
				)
			)
		)
		|> (\l -> {
			linesCache := Triple(wd, sp, pairs2tree(l));
			map(l, secondOfPair);
		})
		|> (\splitted : [[Pair<int, string>]] ->
			mapi(splitted, \i, l ->
				mapi(if (length(l) > 0) l else [Pair(0, "")], \j, ns -> {
					addN = (i < length(splitted) - 1 && j == length(l) - 1);
					visibleText = (if (sp) secondOfPair(ns) else concatStrings(generate(0, firstOfPair(ns), \__ -> "\u2022")));

					MTextInputLine(visibleText + "\n", secondOfPair(ns), firstOfPair(ns), addN)
				})
			)
			|> concatA
		)
		|> (\l -> nextDistinct(lines, l))
	};

	resetCursor = \ -> if (fgetValue(focused)) {
		nextDistinct(cursorVisible, false);
		next(cursorVisible, true);
	}

	isSelection = \ -> {
		ss = getValue(selectionPosition).start;
		se = getValue(selectionPosition).end;

		ss != se && ss.symbol >= 0 && ss.line >= 0 && se.symbol >= 0 && se.line >= 0
	}

	editorClearSelection = \ ->
		nextDistinct(selectionPosition, dummySelection);

	maybeSwapSelection = \sel : MTextEditorSelection -> {
		st = sel.start;
		en = sel.end;
		doSwap = st.line > en.line || (st.line == en.line && st.symbol > en.symbol);
		if (doSwap) MTextEditorSelection(en, st) else sel;
	}

	newLineSymbol = \s : MTextInputLine -> if (s.newLine) "\n" else "";

	getFromTo = \sel : MTextEditorSelection -> {
		swapped = maybeSwapSelection(sel);
		st = swapped.start;
		en = swapped.end;

		subLength = en.line - st.line;

		foldi(subrange(getValue(lines), st.line, subLength + 1), "", \i, acc, s ->
			acc + (
				if (i > 0 && i < subLength)
					s.realText + newLineSymbol(s)
				else if (i == 0 && i == subLength)
					substring(s.realText, st.symbol, en.symbol - st.symbol)
				else if (i == subLength)
					substring(s.realText, 0, en.symbol)
				else if (i == 0)
					substring(s.realText, st.symbol, s.length - st.symbol) + newLineSymbol(s)
				else
					""
			)
		)
	}

	checkPair = \p : MTextEditorPosition -> {
		p.line >= 0 && p.line < length(getValue(lines)) &&
			p.symbol >= 0 && p.symbol <= getValue(lines)[p.line].length
	}

	checkPosition = \p : int -> {
		p >= 0 && p <= strlen(getValue(inputState.content))
	}

	position2pair = \p : int -> {
		if (checkPosition(p))
			foldiWhile(getValue(lines), Pair(0, dummyEditorPosition), \i, acc, l -> {
				if (p < firstOfPair(acc))
					None()
				else if (p > firstOfPair(acc) + l.length)
					Some(
						Pair(
							firstOfPair(acc) + l.length + if (l.newLine) 1 else 0,
							MTextEditorPosition(secondOfPair(acc).symbol, secondOfPair(acc).line + 1)
						)
					)
				else
					Some(
						Pair(
							firstOfPair(acc) + l.length + (if (l.newLine) 1 else 0) + 1,
							MTextEditorPosition(p - firstOfPair(acc), secondOfPair(acc).line + 1)
						)
					)
			})
			|> secondOfPair
		else
			getValue(cursorPosition)
	}

	pair2position = \p : MTextEditorPosition ->
		forceRange(
			if (checkPair(p))
				strlen(getFromTo(MTextEditorSelection(MTextEditorPosition(0, 0), p)))
			else
				getValue(inputState.position),
			0,
			strlen(getValue(inputState.content))
		);

	pair2selection = \p : MTextEditorSelection -> {
		st = p.start;
		en = p.end;

		cp = getValue(cursorPosition);

		if (st != en && checkPair(st) && checkPair(en)) {
			if (cp == st)
				strlen(getFromTo(MTextEditorSelection(cp, en)))
			else if (cp == en)
				strlen(getFromTo(MTextEditorSelection(cp, st)))
			else
				getValue(inputState.selection);
		} else {
			-1
		}
	}

	selection2pair = \s : int -> {
		if (s == -1)
			dummySelection
		else if (checkPosition(s))
			MTextEditorSelection(getValue(cursorPosition), position2pair(s))
		else
			getValue(selectionPosition)
	}

	updateContent = \s : string -> {
		prevS = getValue(inputState.content);
		newS =
			(if (numeric) numericFilter(s) else s)
			|> (\f -> if (isUrlParameterFalse("emoji")) f else filterEmojis(f))
			|> (\newS -> eitherMap(inputState.filterFn, \tf -> tf.fn(newS, getValue(focused)), newS));

		if (newS != prevS) {
			prevSlength = strlen(prevS);
			newSlength = strlen(newS);

			newPosition = position2pair(pair2position(getValue(cursorPosition)) + newSlength - prevSlength);

			if (newSlength > prevSlength) {
				next(inputState.content, newS);
				nextDistinct(cursorPosition, newPosition);
			} else {
				nextDistinct(cursorPosition, newPosition);
				next(inputState.content, newS);
			}
		}
	}

	deleteFromTo = \st0 : MTextEditorPosition, en0 : MTextEditorPosition -> {
		swapped = maybeSwapSelection(MTextEditorSelection(st0, en0));
		st = swapped.start;
		en = swapped.end;

		subLength = en.line - st.line;
		lns = getValue(lines);

		concatStrings([
			fold(subrange(lns, 0, st.line), "", \acc, s -> acc + s.realText + newLineSymbol(s)),
			foldi(subrange(lns, st.line, subLength + 1), "", \i, acc, s ->
				acc + (
					if (i > 0 && i < subLength)
						""
					else if (i == 0 && i == subLength)
						substring(s.realText, 0, st.symbol) + substring(s.realText, en.symbol, s.length - en.symbol) + newLineSymbol(s)
					else if (i == subLength)
						substring(s.realText, en.symbol, s.length - en.symbol) + newLineSymbol(s)
					else if (i == 0)
						substring(s.realText, 0, st.symbol)
					else
						s.realText + newLineSymbol(s)
				)
			),
			fold(subrange(lns, st.line + subLength + 1, length(lns) - subLength - 1 - st.line), "", \acc, s ->
				acc + s.realText + newLineSymbol(s)
			)
		])
		|> updateContent
	}

	handleSelection = \k : KeyEvent, oldCursorPos : MTextEditorPosition ->
		if (k.shift) {
			ss0 = getValue(selectionPosition).start;
			ss = if (ss0 == dummyEditorPosition) oldCursorPos else ss0;

			nextDistinct(selectionPosition,	MTextEditorSelection(ss, getValue(cursorPosition)))
		} else
			editorClearSelection();

	adjustY = \y -> forceRange(y, 0, length(getValue(lines)) - 1);

	adjustX = \x, y -> forceRange(x, 0, getValue(lines)[y].length);

	moveCursorUp = \ -> {
		if (isSelection())
			editorClearSelection();

		curs = getValue(cursorPosition);
		y = adjustY(curs.line - 1);
		x = adjustX(curs.symbol, y);

		nextDistinct(cursorPosition, MTextEditorPosition(x, y));
		resetCursor();
	}

	moveCursorDown = \ -> {
		if (isSelection())
			editorClearSelection();

		curs = getValue(cursorPosition);
		y = adjustY(curs.line + 1);
		x = adjustX(curs.symbol, y);

		nextDistinct(cursorPosition, MTextEditorPosition(x, y));
		resetCursor();
	}

	moveCursorHome = \k : KeyEvent -> {
		curs = getValue(cursorPosition);

		next(cursorPosition, MTextEditorPosition(0, if (k.ctrl) 0 else adjustY(curs.line)));
		handleSelection(k, curs)
	}

	moveCursorEnd = \k : KeyEvent -> {
		curs = getValue(cursorPosition);
		y = if (k.ctrl) length(getValue(lines)) - 1 else adjustY(curs.line);
		x = getValue(lines)[y].length;

		next(cursorPosition, MTextEditorPosition(x, y));
		handleSelection(k, curs)
	}

	moveCursorLeft = \k -> {
		if (isSelection() && !k.shift) {
			nextDistinct(cursorPosition, min(getValue(selectionPosition).start, getValue(selectionPosition).end));
			editorClearSelection();
		} else {
			curs = getValue(cursorPosition);

			y0 = adjustY(curs.line);
			x0 = adjustX(curs.symbol - 1, y0);

			moveUp = (x0 == curs.symbol || (y0 > 0 && x0 == 0 && !getValue(lines)[y0 - 1].newLine));

			y =
				if (moveUp)
					adjustY(curs.line - 1)
				else
					y0;

			x =
				if (moveUp && y0 != y)
					getValue(lines)[y].length
				else
					x0;

			nextDistinct(cursorPosition, MTextEditorPosition(x, y));
			handleSelection(k, curs)
		}

		resetCursor();
	}

	moveCursorRight = \k -> {
		if (isSelection() && !k.shift) {
			nextDistinct(cursorPosition, max(getValue(selectionPosition).start, getValue(selectionPosition).end));
			editorClearSelection();
		} else {
			curs = getValue(cursorPosition);

			y0 = adjustY(curs.line);
			x0 = adjustX(curs.symbol + 1, y0);

			moveDown = x0 == curs.symbol;

			y =
				if (moveDown)
					adjustY(curs.line + 1)
				else
					y0;

			x =
				if (moveDown && y0 != y)
					b2i(!getValue(lines)[y0].newLine)
				else
					x0;

			nextDistinct(cursorPosition, MTextEditorPosition(x, y));
			handleSelection(k, curs)
		}

		resetCursor();
	}

	cursorPoint2Position = \xy : Point -> {
		lns = getValue(lines);

		if (length(lns) > 0) {
			y = adjustY(floor(xy.y / textHeight));

			line = lns[y].visibleText |> (\f -> if (endsWith(f, "\n")) substring(f, 0, strlen(f) - 1) else f);

			x = if (xy.x < 2.) 0 else strlen(getTruncatedByWidthString(line, if (xy.x > 4.) xy.x + 4. else xy.x, textStyle, false));

			MTextEditorPosition(x, y)
		} else {
			MTextEditorPosition(0, 0);
		}
	}

	cursorPosition2Point = \curs : MTextEditorPosition -> {
		lns = getValue(lines);
		lnsLength = length(lns);

		Point(
			max(1.,
				getTWordMetrics(
					TText(
						substring(
							(if (curs.line < 0)
								lns[0].visibleText
							else if (curs.line >= lnsLength)
								lastElement(lns, emptyMTextInputLine).visibleText
							else
								lns[curs.line].visibleText)
							|> (\f -> if (endsWith(f, "\n")) substring(f, 0, strlen(f) - 1) else f),
							0,
							curs.symbol
						),
						textStyle
					),
					makeTree()
				).width
			),
			i2d(adjustY(curs.line)) * textHeight
		)
	}

	updateCursorPosition = \xy : Point -> {
		pos = cursorPoint2Position(xy);

		if (getValue(cursorPosition) != pos) {
			next(cursorPosition, pos);

			prevPrevDown := 0.;
			prevDown := 0.;
		}

		resetCursor();
	}

	updateCursorPoint = \ -> nextDistinct(cursorPoint, cursorPosition2Point(getValue(cursorPosition)));

	deleteSelectedChars = \ -> {
		st = getValue(selectionPosition).start;
		en = getValue(selectionPosition).end;

		swapped = maybeSwapSelection(getValue(selectionPosition));
		nextDistinct(cursorPosition, swapped.end);

		deleteFromTo(st, en);
		editorClearSelection();
	}

	editorDeletePreviousChar = \ -> {
		if (isSelection())
			deleteSelectedChars()
		else {
			curs = getValue(cursorPosition);
			lns = getValue(lines);

			if (curs.symbol > 0 || curs.line > 0) {
				concatStrings([
					fold(subrange(lns, 0, curs.line - 1), "", \acc, s -> acc + s.realText + newLineSymbol(s)),
					foldi(
						subrange(lns, max(curs.line - 1, 0), if (curs.line == 0) 1 else 2),
						"",
						\i, acc, s -> {
							(
								if (i == b2i(curs.line != 0)) {
									if (s.length == 0 || curs.symbol == 0)
										strRemove(acc, strlen(acc) - 1, 1) + s.realText
									else
										acc + strRemove(s.realText, curs.symbol - 1, 1)
								} else
									acc + s.realText
							) + newLineSymbol(s)
						}
					),
					fold(subrange(lns, curs.line + 1, length(lns) - curs.line - 1), "", \acc, s ->
						acc + s.realText + newLineSymbol(s)
					)
				])
				|> updateContent;
			}

			resetCursor();
		}
	}

	editorDeleteNextChar = \ -> {
		if (isSelection())
			deleteSelectedChars()
		else {
			curs = getValue(cursorPosition);
			lns = getValue(lines);

			concatStrings([
				fold(subrange(lns, 0, curs.line), "", \acc, s -> acc + s.realText + newLineSymbol(s)),
				strRemove(lns[curs.line].realText, curs.symbol, 1) + newLineSymbol(lns[curs.line]),
				fold(subrange(lns, curs.line + 1, length(lns) - curs.line - 1), "", \acc, s ->
					acc + s.realText + newLineSymbol(s)
				)
			])
			|> updateContent;

			nextDistinct(cursorPosition, curs);
			resetCursor();
		}
	}

	insertStr = \str0 : string -> {
		if (isSelection())
			deleteSelectedChars();

		str =
			str0
			|> (\st ->
				if (maxChars > 0) {
					clen = strlen(getValue(inputState.content));

					if (clen >= maxChars)
						""
					else if (clen + strlen(st) > maxChars)
						substring(st, 0, maxChars - clen)
					else
						st
				} else
					st
			);

		if (str != "") {
			curs = getValue(cursorPosition);
			lns = getValue(lines);

			concatStrings([
				fold(subrange(lns, 0, curs.line), "", \acc, s ->
					acc + s.realText + newLineSymbol(s)
				),
				strInsert(lns[curs.line].realText, str, curs.symbol) + newLineSymbol(lns[curs.line]),
				fold(subrange(lns, curs.line + 1, length(lns) - curs.line - 1), "", \acc, s ->
					acc + s.realText + newLineSymbol(s)
				)
			])
			|> updateContent;
		}

		p = pair2position(getValue(cursorPosition));
		if (substring(getValue(inputState.content), p, strlen(str0)) == str0) {
			next(cursorPosition, position2pair(p + strlen(str0)));
		};

		resetCursor();
	}

	selectAll = \ -> {
		lns = getValue(lines);
		en = MTextEditorPosition(lastElement(lns, emptyMTextInputLine).length, length(lns) - 1);

		nextDistinct(selectionPosition, MTextEditorSelection(MTextEditorPosition(0, 0), en));
		nextDistinct(cursorPosition, en);
	}

	selectCurrentLine = \ -> {
		cp = getValue(cursorPosition);
		en = MTextEditorPosition(getValue(lines)[cp.line].length, cp.line);

		nextDistinct(selectionPosition, MTextEditorSelection(MTextEditorPosition(0, cp.line), en));
		nextDistinct(cursorPosition, en);
	}

	selectCurrentWord = \ -> {
		cp = getValue(cursorPosition);

		currentLine = strSplit(getValue(lines)[cp.line].realText, " ");

		pr = foldi(currentLine, Pair(0, 0), \i, acc, s -> {
			if (secondOfPair(acc) >= cp.symbol) {
				acc
			} else {
				sLen = strlen(s);
				strt = firstOfPair(acc) + sLen;

				if (strt >= cp.symbol) {
					Pair(firstOfPair(acc), strt);
				} else {
					Pair(strt + if (i == length(currentLine) - 1) 0 else 1, secondOfPair(acc));
				}
			}
		});

		st = MTextEditorPosition(firstOfPair(pr), cp.line);
		en = MTextEditorPosition(secondOfPair(pr), cp.line);

		nextDistinct(selectionPosition, MTextEditorSelection(st, en));
		nextDistinct(cursorPosition, en);
	}

	handleDownKeys = \handled : bool, k : KeyEvent -> {
		if (fgetValue(focused) && !handled && eitherMap(inputState.processedKeyDown, \pk -> pk.fn(k), true)) {
			if (k.utf == "home") {
				moveCursorHome(k);
			} else if (k.utf == "end") {
				moveCursorEnd(k);
			} else if (k.keycode == 37) { // left
				moveCursorLeft(k);
			} else if (k.keycode == 39) { // right
				moveCursorRight(k);
			} else if (k.keycode == 38) { // up
				if (multiline)
					moveCursorUp()
				else if (numeric)
					updateContent(i2s(s2i(getValue(inputState.content)) + 1));
			} else if (k.keycode == 40) { // down
				if (multiline)
					moveCursorDown()
				else if (numeric)
					updateContent(i2s(s2i(getValue(inputState.content)) - 1));
			} else if (k.keycode == 8 && !readOnly) { // backspace
				editorDeletePreviousChar();
			} else if ((k.keycode == 9 || k.keycode == 16777218 /* shift + tab */) && !readOnly) { // tab
				if (multiline)
					insertStr("\t");
			} else if (k.keycode == 46 && !k.shift && !readOnly) { // delete
				editorDeleteNextChar();
			} else if (k.keycode == 13 && !readOnly) { // enter
				if (multiline)
					insertStr("\n");
			} else if (k.keycode == 65 && k.ctrl) { // ctrl+a
				selectAll();
			} else if (((k.keycode == 86 && k.ctrl) || (k.keycode == 45 && k.shift)) && !readOnly) { // ctrl+v | shift+ins
				// handled in addPasteEventListener
			} else if ((((k.keycode == 67 || k.keycode == 45) && k.ctrl) || (readOnly &&
				((k.keycode == 88 && k.ctrl) || (k.keycode == 46 && k.shift))))) { // ctrl+c | ctrl+ins
				if (isSelection()) {
					sel = getFromTo(getValue(selectionPosition));
					setClipboard(sel);
				}
			} else if (((k.keycode == 88 && k.ctrl) || (k.keycode == 46 && k.shift)) && !readOnly) { // ctrl+x | shift+del
				if (isSelection()) {
					sel = getFromTo(getValue(selectionPosition));
					setClipboard(sel);
					deleteSelectedChars();
				}
			} else if (strlen(k.utf) == 1 && !readOnly) {
				insertStr(k.utf);
			}

			eatKDown = inputState.eatKeyDown(k);
			if (eatKDown) k.preventDefault();
			eatKDown;
		} else
			handled
	}

	pasteEventListener = \ -> addPasteEventListener(\__ -> {
		if (fgetValue(focused))
			insertStr(getGlobalClipboard());
	});

	handleMouseDown = \handled : bool, mi : MouseDownInfo -> {
		curDown = timestamp();

		if (mi.inside() && !handled) {
			nextDistinct(mouseDown, true);

			if (curDown - ^prevDown < downDelay) {
				if (^prevDown - ^prevPrevDown < downDelay) { // Triple click
					selectCurrentLine();

					prevDown := 0.;
				} else { // Double click
					selectCurrentWord();
				}
			} else {
				updateCursorPosition(getValue(mousexy));
				cp = getValue(cursorPosition);

				nextDistinct(selectionPosition, MTextEditorSelection(cp, cp));
			}

			prevPrevDown := ^prevDown;
			prevDown := curDown;
		}

		handled
	}

	handleMouseUp = \handled : bool, mi : () -> MouseInfo -> {
		nextDistinct(mouseDown, false);

		handled
	}

	updateSelectionPoints = \sp : MTextEditorSelection -> {
		newSelectionPoints =
			if (isSelection()) {
				swapped = maybeSwapSelection(sp);
				st = swapped.start;
				en = swapped.end;

				generate(st.line, en.line + 1, \i -> {
					selected =
						if (i == st.line && i == en.line)
							MTextEditorSelection(st, en)
						else if (i == st.line)
							MTextEditorSelection(st, MTextEditorPosition(getValue(lines)[st.line].length, st.line))
						else if (i == en.line)
							MTextEditorSelection(MTextEditorPosition(0, en.line), en)
						else
							MTextEditorSelection(
								MTextEditorPosition(0, i),
								MTextEditorPosition(getValue(lines)[i].length, i)
							);

					Triple(i, cursorPosition2Point(selected.start), cursorPosition2Point(selected.end))
				})
			} else [];

		nextDistinct(selectionPoints, newSelectionPoints);
	}

	subs =
		[
			make2Subscribe(contentWH, boxWH, \cwh, bwh -> {
				if (cwh.height <= bwh.height)
					nextDistinct(scrollPosition, Point(getValue(scrollPosition).x, 0.));
				if (cwh.width <= bwh.width)
					nextDistinct(scrollPosition, Point(0., getValue(scrollPosition).y));
			}),
			make3Subscribe(inputState.content, eitherMap(inputState.password, \ps -> ps.showPassword, const(true)), width, content2lines),
			makeSubscribe2(getKeyboardFocusBehaviour(), \kf ->
				if (kf != focusId)
					nextDistinct(focused, false)
			),
			makeSubscribe2(mousexy, \xy ->
				if (getValue(mouseDown)) {
					updateCursorPosition(xy);
					nextDistinct(selectionPosition, MTextEditorSelection(getValue(selectionPosition).start, getValue(cursorPosition)));
				}
			),
			\ -> bidirectionalLink(focused, inputState.focus, \foc -> {
				if (foc)
					updateKeyboardFocus(focusId)
				else if (currentKeyboardFocusId() == focusId)
					releaseKeyboardFocus();

				if (!foc) nextDistinct(scrollPosition, zeroPoint);

				if (foc) {
					maybeApply(
						inputState.positionOnFocus,
						\pof ->
							nextDistinct(
								inputState.position,
								min(max(pof(getValue(inputState.content), getValue(inputState.position)), 0), strlen(getValue(inputState.content)))
							)
					);
					maybeApply(
						inputState.selectionOnFocus,
						\sof ->
							nextDistinct(
								inputState.selection,
								min(max(sof(getValue(inputState.content), getValue(inputState.selection)), 0), strlen(getValue(inputState.content)))
							)
					);

					deferred(resetCursor);
				} else {
					dispUnsM(cursUns);
					nextDistinct(cursorVisible, false)
				};

				updateContent(getValue(inputState.content));

				foc;
			}, idfn),
			makeSubscribe2(cursorVisible, \cv ->
				if (fgetValue(focused)) {
					dispUnsM(cursUns);
					setUnsM(
						cursUns,
						interruptibleTimer(500, \ -> reverseBehaviour(cursorVisible))
					)
				} else {
					dispUnsM(cursUns);
					nextDistinct(cursorVisible, false)
				}
			),
			\ -> bidirectionalLink(inputState.position, cursorPosition, position2pair, pair2position),
			\ -> bidirectionalLink(inputState.selection, selectionPosition, selection2pair, \sp : MTextEditorSelection -> {
				updateSelectionPoints(sp);
				pair2selection(sp);
			}),
			\ -> fconnectSelect(cursorPosition, cursorPoint, cursorPosition2Point),
			make2Subscribe2(cursorPoint, boxWH, \cp, bwh -> {
				sp = getValue(scrollPosition);

				xp =
					if (cp.x - bwh.width + 2. > sp.x)
						max(cp.x - bwh.width + 2., 0.)
					else if (cp.x - 2. < sp.x)
						max(cp.x - 2., 0.)
					else
						sp.x;

				yp =
					if (cp.y - bwh.height + textHeight > sp.y)
						max(cp.y - bwh.height + textHeight, 0.)
					else if (cp.y < sp.y)
						max(cp.y, 0.)
					else
						sp.y;

				nextDistinct(scrollPosition, Point(xp, yp))

			}),
			\ -> \ -> {
				keyboardFocusDies(focusId);
				dispUnsM(cursUns);
			}
		];

	MTextEditorState(
		mousexy,
		mouseRightDown,
		cursorPoint,
		selectionPosition,
		selectionPoints,
		cursorVisible,
		focused,
		lines,
		width,
		contentWH,
		textHeight,
		scrollStyle,
		handleDownKeys,
		pasteEventListener,
		handleMouseDown,
		handleMouseUp,
		subs
	);
}

makeMTextEditorView(manager : MaterialManager, inputState : MInputState) -> Tropic {
	editorState = makeMTextEditorState(inputState);

	makeInputBox = \en : bool ->
		TSelect2(editorState.lines, editorState.width, \lns, wd ->
			MText2T(
				inputState.parent,
				fold(lns, "", \acc, s -> acc + s.visibleText),
				if (en) inputState.mTextStyle else inputState.mTextStyleDisabled
			)
			|> (\f -> TAttachBox(f, editorState.contentWH))
			|> TSetMinWidth(TFixed(wd, 0.))
			|> TFixHeight(TFixed(0., i2d(length(lns)) * editorState.textHeight))
		);

	TGroup2(
		// Selection
		SelectTGroup(editorState.selectionPoints, \__, __, p ->
			TFixed(
				max(
					thirdOfTriple(p).x - secondOfTriple(p).x,
					if (getValue(editorState.selectionPosition).end.line == firstOfTriple(p)) 0. else 4.
				),
				thirdOfTriple(p).y + editorState.textHeight - secondOfTriple(p).y
			)
			|> (\f -> TRectangle([MFill(inputState.color), FillOpacity(0.2)], f))
			|> (\f -> TTranslate(const(secondOfTriple(p)), f))
		)
			|> (\f -> TShow(editorState.focused, f))
			|> (\f -> TFixSize(f, TEmpty())),
		TGroup2SameMetrics(
			// The lines themselves
			makeInputBox(true),
			// The cursor
			TGraphics([MoveTo(0.0, 0.0), LineTo(0.0, editorState.textHeight)], [MStroke(inputState.color), StrokeWidth(2.)])
			|> (\f -> TVisible(editorState.cursorVisible, f))
			|> (\f -> TTranslate(editorState.cursorPoint, f))
			|> (\f -> TFixSize(f, TEmpty()))
		)
	)
	|> (\f -> TIf(inputState.mfocus.enabled, f, makeInputBox(false)))
	|> (\f ->
		TCopySize(
			f,
			\tr ->
				TConstruct(
					[
						makeSubscribeUns(inputState.mfocus.focused, \fc ->
							if (fc)
								[
									TInteractive(
										[KeyDown2(editorState.handleDownKeys)],
										TRectangle(interactiveRectangleStyle, TGroup2(TFillXY(), tr))
									)
									|> (\t -> if (inputState.readOnly) t else TConstruct([editorState.pasteEventListener], t))
									|> (\t -> trender(t, inputState.manager.manager.renderStyle))
								]
							else
								[]
						)
					],
					TInteractive(
						[
							TMouseXY(editorState.mousexy),
							MouseDown2(editorState.handleMouseDown),
							MouseUp2(editorState.handleMouseUp),
							TMouseRightDown(editorState.mouseRightDown)
						],
						TRectangle(interactiveRectangleStyle, TGroup2(TFillXY(), tr))
						|> (\f2 -> disableScrollInsideEnabled(manager, f2, inputState.mfocus.focused))
					)
				),
			true
		)
	)
	|> (\f ->
		if (inputState.align == AutoAlignCenter())
			TCenterXIn(TFixSize(f, TSized(editorState.contentWH)), TFillXY())
		else if (inputState.align == AutoAlignRight())
			TTweak([TAlign(const(1.), zero)], TFixSize(f, TSized(editorState.contentWH)), TFillXY())
		else
			f
	)
	|> (\f -> TAttachWidth2(TFillX(), editorState.width, f))

	|> (\f -> {
		boxHeight =
			if (inputState.linesCount > 0)
				const(i2d(inputState.linesCount) * editorState.textHeight)
			else
				fselect(editorState.lines, FLift(\lns ->
					i2d(
						if (inputState.linesCount == 0 || inputState.linesCount == -1)
							max(length(lns), 1)
						else
							forceRange(-inputState.linesCount, 1, length(lns))
					) * editorState.textHeight
				));

		MScroll(
			f,
			TFillXHT(boxHeight),
			editorState.scrollStyle
		)
		|> (\f2 -> MScroll2T(manager, dummyParent(manager), f2, dummyM2t))
	})
	|> (\f -> TConstruct(editorState.subs, f))
}

makeNativeEditorView(manager : MaterialManager, parent : MFocusGroup, state : [MTextInputState], inputState : MInputState) -> Tropic {
	charStyle = MTextStyle2CharacterStyle(inputState.mTextStyle, true);
	fontSize = extractStruct(charStyle, FontSize(0.)).size;
	interlineSpacing = fontSize * 1.2 - getTextSize("M", charStyle).height;

	inputFlexibleSize =
		if (mobile && ios())
			\ -> TAttach(THeight(TGhost("MTextInputText")), \met ->
				TSelect2(met.width, met.height, \w, h -> {
					mut = make(TFixed(2., 2.));
					timer(100, \ -> next(mut, TFixed(1., 1.)));
					timer(200, \ -> next(mut, TEmpty()));

					TLines2(
						TFixed(w, h),
						TMutable(mut)
					)
				})
			)
		else
			\ -> THeight(TGhost("MTextInputText"));

	inputFixedSize = \lines ->
		THeight(
			MParagraph2T(
				inputState.parent,
				generate(0, lines, \i -> "M\n") |> concatStrings,
				concat(
					inputState.mTextStyle,
					[
						MWidth(400.),
						InterlineSpacing(interlineSpacing),
						ParagraphMargin(0., 0.)
					]
				)
			)
		);

	inputSize =
		TGroup2(
			if (inputState.width == 0.)
				TCols2(TWidth(TGhost("MTextInputText")), TFixed(4., 0.))
			else
				TFillX(),
			if (inputState.multiline) {
				if (inputState.linesCount == 0 || inputState.linesCount == -1) {
					inputFlexibleSize();
				} else if (inputState.linesCount > 0) {
					inputFixedSize(inputState.linesCount);
				} else {
					TMinimumGroup2(
						inputFlexibleSize(),
						inputFixedSize(-inputState.linesCount)
					);
				}
			} else {
				THeight(TText("m", inputState.textStyle))
			}
		);

	inpWH = makeWH();

	textInput = \ ->
		TFForm(
			FTextInput(
				inputState.content,
				inpWH,
				concatA([
					inputState.textStyle,
					[
						FWordWrap(const(inputState.wordWrap)),
						FMultiline(const(inputState.multiline)),
						FInputType(eitherFn(
							inputState.password,
							\ps ->
								fif(ps.showPassword, const(inputState.inputType), const(PasswordType())),
							\ ->
								const(if (inputState.numeric) NumericType() else inputState.inputType)
						)),
						FReadOnly(const(inputState.readOnly)),
						FMaxChars(const(inputState.maxChars)),
						FAutoAlign(const(inputState.align)),
						FFocus(inputState.focus),
						FPosition(inputState.position),
						FSelection(inputState.selection),
						FCursorColor(const(MColor2int(inputState.color))),
						FCursorOpacity(const(1.)),
						FCursorWidth(const(2.)),
						FInputKeyFilter(\name, ke -> {
							filterKey =
								eitherMap(inputState.processedKeyDown, \pk -> pk.fn(ke), true) &&
								(js || (inputState.multiline && !ke.shift) || (ke.keycode != 9 && ke.keycode != 16777218)) &&
								eitherMap(
									inputState.autocomplete,
									\ac -> (ke.keycode != 13 || getValue(ac.selected) < 0),
									true
								);

							if (filterKey && checkIScriptCaptureOption(manager, IScriptCaptureKeyEvents())) {
								addIScriptBehaviourRecord(
									manager,
									inputState.mfocus.name,
									name,
									KeyEventRecord(ke.utf, ke.ctrl, ke.shift, ke.alt, ke.meta, ke.keycode),
									makeList(),
									ISKeyEvent(),
									getCallstackIfNeeded(manager)
								)
							}

							filterKey;
						})
					],
					eitherMap(
						inputState.numericStep,
						\st ->
							[FNumericStep(st.step)],
						[]
					),
					eitherMap(
						inputState.filterFn,
						\fn ->
							[FInputFilter(\str -> fn.fn(str, getValue(inputState.focus)))],
						[]
					)
				])
			)
			|> (\f ->
				if ((^fAccessibilityEnabled || cpp) && !mobile) {
					accessProperties = extractStructMany(state, FAccessAttribute("", const("")));

					if (fgetValue(parent.id) != -2)
						FAccess(
							concat(
								accessProperties,
								[
									FAccessTabOrder(fselect(parent.tabOrder, FLift(\to -> arrayPush(to, -1)))),
									FAccessEnabled(inputState.mfocus.focusEnabled),
									FAccessZorder(parent.zorder)
								]
							),
							f
						)
					else
						FAccess(
							concat(
								accessProperties,
								[
									FAccessZorder(parent.zorder)
								]
							),
							f
						)
				} else {
					f
				}
			),
			zeroTMetrics
		)
		|> (\f -> TFixSize(f, TGhost("MTextInputSize")))
		|> (\f -> disableScrollInsideEnabled(manager, f, inputState.mfocus.focused))
		|> (\f -> TAlpha(fif(inputState.mfocus.focused, const(1.), zero), f))
		|> (\f ->
			TransformTAcc2(\t2a -> {
				acc = f |> t2a;

				TAcc(
					acc.form,
					TFormMetrics(
						acc.metrics.width,
						zero,
						zero
					),
					acc.minWidth,
					zero,
					acc.maxWidth,
					zero,
					acc.xFillers,
					zero,
					acc.addFillers,
					acc.xConstant,
					true,
					acc.disposers
				)
			})
		);

	TVisibleLazy(inputState.mfocus.focusEnabled, textInput)
	|> (\f ->
		TGroup2WithoutMetrics(
			f,
			TVisible(
				fnot(inputState.mfocus.focused),
				MScroll2T(
					manager,
					dummyParent(manager),
					MScroll(
						if (inputState.align == AutoAlignCenter())
							TCenterXIn(TDisplay("MTextInputText"), TGhost("MTextInputSize"))
						else if (inputState.align == AutoAlignRight())
							TTweak([TAlign(const(1.), const(0.))], TDisplay("MTextInputText"), TGhost("MTextInputSize"))
						else if (inputState.align == AutoAlignLeft())
							TDisplay("MTextInputText")
						else
							TBaseAlignA(TDisplay("MTextInputText")),
						TGhost("MTextInputSize"),
						[MScrollbars(invisibleScrollBar |> const, getMaterialScrollBar().vert |> const)]
					),
					dummyM2t
				)
			)
		)
	)
	|> (\f -> TGroup2SameMetrics(TDisplay("MTextInputSize"), f))
	|> (\f -> TLet("MTextInputSize", TAttachBox2(inputSize, inpWH, TEmpty()), f))
	|> (\f ->
		TLet(
			"MTextInputText",
			(\c0, en, sp -> {
				eol = getCharCodeAt("\n", 0);
				c =
					(if (sp)
						c0
					else
						stringFold(c0, "", \acc, c ->
							if (c == eol)
								acc + fromCharCode(c)
							else
								acc + "\u2022"
						))
					|> (\c ->
						if (inputState.multiline)
							strSplit(c, "\n")
							|> (\spl -> foldi(spl, "", \i, acc, ch -> acc + ch + "\t\n"))
						else
							c
					);

				if (inputState.multiline)
					MParagraph2T(
						inputState.parent,
						c,
						concat(
							if (en) inputState.mTextStyle else inputState.mTextStyleDisabled,
							[
								MWidth(-1.),
								InterlineSpacing(interlineSpacing),
								ParagraphMargin(0., 0.)
							]
						)
					)
				else
					MText2T(inputState.parent, c, if (en) inputState.mTextStyle else inputState.mTextStyleDisabled)
			})
			|> (\f2 ->
				eitherMap(
					inputState.password,
					\pw -> TSelect3(inputState.content, inputState.mfocus.enabled, pw.showPassword, f2),
					TSelect2(inputState.content, inputState.mfocus.enabled, \c, en -> f2(c, en, true))
				)
			),
			f
		)
	)
	|> (\f ->
		if (!mobile)
			eitherMap(
				inputState.processedKeyDown,
				\pk -> {
					prevC = ref fgetValue(inputState.content);

					TConstruct(
						[
							makeSubscribeUns(inputState.mfocus.focused, \fc ->
								if (fc) {
									uns = ref None();

									[
										interruptibleTimer(
											10,
											\ -> {
												uns := Some(trender(
													TInteractive(
														[
															KeyDown2(\h, k -> {
																c = fgetValue(inputState.content);

																if (!pk.fn(k) && (js || ^prevC != fgetValue(inputState.content))) {
																	if (js)
																		deferred(\ -> next(inputState.content, c));

																	next(inputState.content, ^prevC);
																}

																prevC := fgetValue(inputState.content);

																h
															})
														],
														TRectangle(interactiveRectangleStyle, TFillXY())
													),
													inputState.manager.manager.renderStyle
												))
											}
										),
										\ -> dispUnsM(uns)
									]
								} else {
									[]
								}
							)
						],
						f
					)
				},
				f
			)
		else
			f
	)
}

defaultCompletionFn(manager : MaterialManager, parent : MFocusGroup, style : [MAutoCompleteStyle]) -> MCompletionFn {
	condensed = extractStruct(style, MCondensed(false)).condensed;
	textStyle : [MTextStyle] =
		extractMTextStyleDef(
			extractStruct(style, MCustomTextStyle([])).style,
			Triple(getTextColor(parent), if (condensed) MBody() else MSubheading(), true)
		)
		|> (\f : Triple<MColor, MFontStyle, bool> ->
			[firstOfTriple(f), secondOfTriple(f)]
			|> (\f2 -> if (f.third) f2 else arrayPush(f2, MTextDisabled()))
		);
	isTextInputInPopup = !contains(style, MTextInputOutOfPopup());
	custLeftButton = extractStruct(style, MLeftCustomButton(TEmpty(), TFixed(1., 1.), 56.));
	leftButton = extractStruct(style, MShowLeftButton(false)).show || custLeftButton.closed != TEmpty();
	leftIcon = extractStruct(style, MLeftIcon("")).icon != "";
	label = extractStruct(style, MLabel("")).label;
	hasFloatingLabel = contains(style, MFloatingLabel()) && label != "";
	tTextMetrics = getTWordMetrics(MText2T(parent, " ", textStyle), makeTree());

	inputBorders =
		extractStruct(
			style,
			MInputBorders(
				8.,
				if (hasFloatingLabel) {if (condensed) 20. else 28.} else {if (condensed) 12. else 16.},
				8.,
				if (condensed) 12. else 16.
			)
		);

	lineHeight = dceil((tTextMetrics.height + inputBorders.top + inputBorders.bottom - 3.) / 4.) * 4.;

	MCompletionFn(\com, isSelected, setWordFn -> {
		focusState = [MOnClick(\ -> setWordFn(com)), MRippleType(const(MRippleFill())), MFocusEnabled(const(false))];

		face =
			TLinesA([
				TFillX(),
				MEllipsisText2T(manager, parent, MEllipsisText(com.sentence, arrayPush(textStyle, MShowTooltip(const(true)))))
				|> TCenterY
			])
			|> (\f ->
				TBorderA(
					inputBorders.start + (if (leftButton && isTextInputInPopup) custLeftButton.inputIndent else 0.) + (if (leftIcon) 72. else 0.),
					0.,
					inputBorders.end,
					0.,
					f
				)
			)
			|> (\f -> TAvailable(f, TFillXH(lineHeight)))
			|> (\f -> TFixSize(f, TFillXH(lineHeight)));

		MGetFocusGroup(\p ->
			MFocusClickable2T(manager, p, "CompletionLine", focusState, \focus ->
				makeTListLine(getLightBackground(p), face, focus, const(isSelected), const(true), [],
					[MFill(getAccentColor(p)), FillOpacity(0.4)])
			)
		)
	})
}