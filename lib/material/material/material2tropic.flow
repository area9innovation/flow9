import material/internal/material_app_structure;
import material/internal/material_card;
import material/internal/material_sidenav;
import material/internal/material_expander;
import material/internal/material_gridlist;
import material/internal/material_chart;
import material/internal/material_steppers;
import material/internal/material_navigation;
import material/internal/material_imagemap;
import material/internal/material_bottom_nav;
import material/internal/material_carousel;
import material/internal/material_movable;
import material/internal/material_dragdrop;
import material/internal/material_pickers;
import material/debug_subscribers;
import material/iscript/material_iscript;
import material/internal/material_player;
import material/internal/material_tree;

import tropic/tropic_profile;
import serviceworkercache;

export {
	// Use this if you render multiple materials with single MaterialManager
	// 'captureKeys' assumes that material has the entire screen and captures tab , ctr+i
	mrender(manager : MaterialManager, captureKeys : bool, m : Material) -> () -> void;

	// Only for special use
	material2tropic(manager : MaterialManager, m : Material) -> Tropic;
	material2tropicWithParent(manager : MaterialManager, parent : MFocusGroup, m : Material) -> Tropic;

	material2nativeForm(manager : MaterialManager, m : Material) -> Form;

	// This is not for general use
	staticMaterial2tropic(manager : MaterialManager, m : Material) -> Tropic;

	// Set true to enable service worker for your js app by default
	// Read more about service worker in lib\serviceworkercache.flow
	serviceWorkerEnabled = ref isUrlParameterTrue("sw");
}

// You can have more than one render counter only if you have dialogs opened.
// Otherwise somebody forgot to call disposer from mrender
renderCounterRef = ref 0;

iScriptInit = ref false;

mrender(manager : MaterialManager, captureKeys : bool, m : Material) -> () -> void {
	mrenderInit = timestamp();

	if (^serviceWorkerEnabled)
		checkServiceWorkerCachingEnabled(\en -> if (!en) enableServiceWorkerCaching(\r -> println(if (r) "Service Worker Enabled" else "Service Worker Error")))
	else
		checkServiceWorkerCachingEnabled(\en -> if (en) disableServiceWorkerCaching(\r -> println(if (r) "Service Worker Disabled" else "Service Worker Error")));

	renderCounterRef := ^renderCounterRef + 1;

	if (^mSpeechAccessiblityEnabled)
		initSpeechSynthesis();

	if (js && (isUrlParameterTrue("accessenabled") || ((strContains(toLowerCase(getBrowser()), "chrom") || strContains(toLowerCase(getBrowser()), "crios") ||
		strContains(toLowerCase(getBrowser()), "firefox") || strContains(toLowerCase(getBrowser()), "safari")) && !isUrlParameterFalse("accessenabled")))) {
		fAccessibilityEnabled := true;
		setAccessibilityEnabled(true);
		setEnableFocusFrame(false);
	}

	setDropCurrentFocusOnDown(false);

	materialLogFn(
		\ -> {
			println("render counter: " + i2s(^renderCounterRef));

			setLeakingSubscribersHandler(100, 50, \subscribersCount, value -> {
				if (subscribersCount != subscribersCountBelowThreshold) {
					dumpValue = value |> getValue |> behaviourValueToString;
					println("ERROR: Too many subscribers (" + toString(subscribersCount) + ") to " + dumpValue);
					materialLogFn(
						printCallstack,
						MaterialWarning(),
						nop
					)
				}
			});
		},
		MaterialError(),
		nop
	);

	if (!^iScriptInit && contains(manager.style, MIScriptPanel())) {
		iScriptInit := true;

		handleRealEvents(
			MouseDown2(\h, mi -> captureIScriptMouseDownEvent(manager, h, mi, \ -> Point(0., 0.), "canvas")),
			getStage(),
			ref true,
			getStage(),
			[intMax],
			false,
			false
		)
		|> ignore;
		handleRealEvents(
			MouseUp2(\h, mi -> captureIScriptMouseEvent(manager, h, mi, \ -> Point(0., 0.), "canvas", "mouseup")),
			getStage(),
			ref true,
			getStage(),
			[intMax],
			false,
			false
		)
		|> ignore;
		handleRealEvents(
			MouseMove2(\h, mi -> captureIScriptMouseEvent(manager, h, mi, \ -> Point(0., 0.), "canvas", "mousemove")),
			getStage(),
			ref true,
			getStage(),
			[intMax],
			false,
			false
		)
		|> ignore;
	}

	t0 = material2tropic(manager, m);

	mouseCapture = extractStruct(manager.style, MCaptureMouse(\__ -> TEmpty())).capture(manager);
	longTouchCapture = extractStruct(manager.style, MCaptureLongTouch(\__ -> TEmpty())).capture(manager);

	t1 =
		[
			mouseCapture,
			t0,
			longTouchCapture,
		]
		|> (\t ->
			if (captureKeys)
				concat([extractStruct(manager.style, MCaptureKeys(\__ -> TEmpty())).capture(manager)], t)
			else
				t
		)
		|> TGroup;

	// Create the top IScript menu last.
	t = t1
		|> (\f ->
			if (contains(manager.style, MIScriptPanel()))
				MIScriptPanels2T(manager, f, \mat, p -> material2tropicWithParent(manager, p, mat))
			else
				f
		)
		|> (\f ->
			materialLogFn(
				\ -> {
					println("render counter: " + i2s(^renderCounterRef));

					MSubscribersPanel2T(manager, f, \mat, p -> material2tropicWithParent(manager, p, mat))
				},
				MaterialError(),
				\ -> f
			)
		);


	// trenderManager without warning
	// TTweak for integer width on mobile
	r =
		trender2(
			if (mobile)
				TTweak([TSnapSize(1., 1., true)], t, TEmpty())
			else
				t,
			manager.manager.renderStyle
		);

	manager.manager.findPositionScaleFn := r.second;
	dispose = r.first;

	renderId = manager.nextRenderId();
	manager.findPositionScaleFns ::= setTree(manager.findPositionScaleFns, renderId, ^(manager.manager.findPositionScaleFn));

	disp = \ -> {
		renderCounterRef := ^renderCounterRef - 1;

		manager.findPositionScaleFns ::= removeFromTree(manager.findPositionScaleFns, renderId);

		manager.manager.findPositionScaleFn :=
			foldTree(
				manager.findPositionScaleFns,
				Pair(-1, dummyTFinder),
				\key, tFinder, acc : Pair<int, (int) -> PositionScale> ->
					if (acc.first < key)
						Pair(key, tFinder)
					else
						acc
			).second;

		dispose();

		manager.disposers ::= removeFromTree(manager.disposers, renderId);
	}

	manager.disposers ::= setTree(manager.disposers, renderId, disp);

	if (getUrlParameterDef("profile", "") >= "1") {
		println("mrender took " + d2s(timestamp() - mrenderInit) + " ms");
	}

	disp;
}

material2nativeForm(manager : MaterialManager, m : Material) -> Form {
	tropic2nativeForm(material2tropic(manager, m), emptyStylesheet);
}

material2tropic(manager : MaterialManager, m : Material) -> Tropic {
	rend = MaterialRender(manager, manager.nextRenderId());

	TConstruct(
		[
			makeSubscribe(manager.white, \w ->
				if (w != manager.theme.lightBackground)
					updateMaterialTheme(manager, MLightTheme(manager.theme, w))
			),
			makeSubscribe2(feq(getLangB(), "ar"), \__ -> reverseBehaviour(manager.forceRender)), // TODO : Rerender for all RTL languages, not for arabic only.
		],
		TSelect(
			manager.forceRender,
			\__ -> {
				trop = doMaterial2tropic(rend, m, manager.focus);

				if (getUrlParameterDef("profile", "") >= "1") {
					profileTropic(trop);
				}

				trop;
			}
		)
	)
}

material2tropicWithParent(manager : MaterialManager, parent : MFocusGroup, m : Material) -> Tropic {
	rend = MaterialRender(manager, manager.nextRenderId());

	doMaterial2tropic(rend, m, parent)
}

staticMaterial2tropic(manager : MaterialManager, m : Material) -> Tropic {
	rend = MaterialRender(manager, manager.nextRenderId());

	doMaterial2tropic(rend, m, dummyEnabledParentWithTheme(manager, manager.theme.lightBackground));
}

objectCreatedMap : ref Tree<string, int> = ref makeTree();

doMaterial2tropic(rend : MaterialRender, m : Material, parent : MFocusGroup) -> Tropic {
	//considers created material elements
	if (false && startsWith(m.structname, "")) {
		objectCreatedMap := setTree(^objectCreatedMap, m.structname, lookupTreeDef(^objectCreatedMap, m.structname, 0) + 1);
		println(m.structname + ":" + i2s(lookupTreeDef(^objectCreatedMap, m.structname, 0)));
	}

	createTropic : () -> Tropic = \ -> switch (m) {
		MText(text, style): {
			MText2T(parent, text, style)
		}
		MParagraph(text, style): {
			MParagraph2T(parent, text, style)
		}
		MIcon(name, style): {
			MIcon2T(parent, name, style)
		}
		MLetterIcon(__, __, __): {
			MLetterIcon2T(rend.manager, parent, m);
		}
		MAvatar(imageurl, style): {
			MAvatar2T(imageurl, style)
		}
		MTextButton(__, __, __, __): {
			MTextButton2T(rend.manager, parent, m,)
		}
		MTextClickable(__, __, __, __): {
			MTextClickable2T(rend.manager, parent, m)
		}
		MIconButton(__, __, __, __): {
			MIconButton2T(rend.manager, parent, m)
		}
		MIconToggle(__, __, __): {
			MIconToggle2T(rend.manager, parent, m)
		}
		MFloatingButton(__, __, __): {
			MFloatingButton2T(rend.manager, parent, m)
		}
		MProgressBar(__): {
			MProgressBar2T(rend.manager, parent, m)
		}
		MProgressCircle(__): {
			MProgressCircle2T(rend.manager, parent, m)
		}
		MProgressBarDeterm(__, __): {
			MProgressBarDeterm2T(rend.manager, parent, m)
		}
		MProgressCircleDeterm(__, __): {
			MProgressCircleDeterm2T(rend.manager, parent, m)
		}
		MRipple(mat): {
			MRippleOnDownDefault2T(rend.manager, parent, doMaterial2tropic(rend, mat, parent), const(MRippleFill()))
		}
		MRippleCircle(mat): {
			MRippleOnDownDefault2T(rend.manager, parent, doMaterial2tropic(rend, mat, parent), const(MRippleCenter()))
		}
		MTimePicker(__, __): {
			MTimePicker2T(rend.manager, parent, m)
		}
		MDatePicker(__, __): {
			MDatePicker2T(rend.manager, parent, m)
		}
		MColorPicker(colorB, style): {
			MColorPicker2T(rend.manager, parent, colorB, style, None())
		}
		MColorPickerMultiSelect(colorSetB, style) : {
			MColorPicker2T(rend.manager, parent, make(MBlack()), style, Some(colorSetB))
		}
		MCheckBox(__, __, __): {
			MCheckBox2T(rend.manager, parent, m, \mat, p -> doMaterial2tropic(rend, mat, p))
		}
		MTooltip(__, __, __): {
			MTooltip2T(rend.manager, parent, m, \mat, p -> doMaterial2tropic(rend, mat, p))
		}
		MRadio(__, __, __, __): {
			MRadio2T(rend.manager, parent, m, \mat, p -> doMaterial2tropic(rend, mat, p))
		}
		MSwitchControl(__, __): {
			MSwitchControl2T(rend.manager, parent, m)
		}
		MSlider(__, __): {
			MSlider2T(rend.manager, parent, m, \mat, p -> doMaterial2tropic(rend, mat, p))
		}
		MBackground(depth, c): {
			tc = doMaterial2tropic(rend, c, parent);
			TShadow(
				const(i2d(depth)),
				parent.theme.lightBackground,
				TFrame(8.0, 2.0, [if (parent.theme.lightBackground) Fill(white) else Fill(0x303030)], tc),
			)
		}
		MMenu(__, __, __): {
			MMenu2T(rend.manager, parent, m, \mat, p -> doMaterial2tropic(rend, mat, p))
		}
		MDynamicMenu(__, __, __): {
			MDynamicMenu2T(rend.manager, parent, m, \mat, p -> doMaterial2tropic(rend, mat, p))
		}
		MDropDownMenu(__, __, __): {
			MDropDownMenu2T(rend.manager, parent, m, \mat, p -> doMaterial2tropic(rend, mat, p))
		}
		MMenuPanel(__, __): {
			MMenuPanel2T(rend.manager, parent, m, \mat, p -> doMaterial2tropic(rend, mat, p))
		}
		MList(__, __, __): {
			MList2T(rend.manager, parent, m, \mat, p -> doMaterial2tropic(rend, mat, p));
		}
		MDynamicList(__, __, __): {
			MDynamicList2T(rend.manager, parent, m, \mat, p -> doMaterial2tropic(rend, mat, p));
		}
		MDropDown(__, __, __, __): {
			MDropDown2T(rend.manager, parent, m, \mat, p -> doMaterial2tropic(rend, mat, p))
		}
		MMultiSelectDropDown(__, __, __): {
			MMultiSelectDropDown2T(rend.manager, parent, m, \mat, p -> doMaterial2tropic(rend, mat, p))
		}

		MDynamicDataTable(__, __, __): {
			MDynamicDataTable2T(rend.manager, parent, m, \mat, p -> doMaterial2tropic(rend, mat, p))
		}

		MChart(__, __): {
			MChart2T(rend.manager, parent, m, \mat -> doMaterial2tropic(rend, mat, parent));
		}

		MGridList(__, __): {
			MGridList2T(rend.manager, parent, m, \mat, p -> doMaterial2tropic(rend, mat, p));
		}

		MDynamicTabs(__, __, __): {
			MDynamicTabs2T(rend.manager, parent, m, \mat, p -> doMaterial2tropic(rend, mat, p));
		}

		MSplitter(__, __, __, __): {
			MSplitter2T(rend.manager, parent, m, \mat, p -> doMaterial2tropic(rend, mat, p))
		}

		MCard(__, __, __): {
			MCard2T(rend.manager, parent, m, \mat, p -> doMaterial2tropic(rend, mat, p))
		}

		MFlexibleGrid(__, __): {
			MFlexibleGrid2T(rend.manager, parent, m, \mat, p -> doMaterial2tropic(rend, mat, p));
		}

		MDynamicGrid(__, __): {
			MDynamicGrid2T(rend.manager, parent, m, \mat, p -> doMaterial2tropic(rend, mat, p));
		}

		MTree(__, __): {
			MTree2T(rend.manager, parent, m, \mat, p -> doMaterial2tropic(rend, mat, p));
		}

		MReorderGrids(__, __, __, __): {
			MReorderGrids2T(rend.manager, parent, m, \mat, p -> doMaterial2tropic(rend, mat, p));
		}

		MReorderGrid(items, order, style): {
			MReorderGrid2T(rend.manager, parent, items, order, style, \mat, p -> doMaterial2tropic(rend, mat, p))
		}

		MSeparator(horizontal): {
			MSeparator2T(rend.manager, parent, horizontal)
		}

		MSeparatorSize(horizontal, size): {
			MSeparator2T(rend.manager, parent, horizontal)
			|> TSetMinSize(if (horizontal) TFixed(size, 1.) else TFixed(1., size))
		}

		MTextCard(title, text, style, state): {
			doMaterial2tropic(rend, MCard([MPrimaryTextBlock(title, text, [])], style, state), parent);
		}

		MBaselineCols(cs): TBaselineCols(map(cs, \c -> doMaterial2tropic(rend, c, parent)));
		MBaselineLines(cs): TBaselineLines(map(cs, \c -> doMaterial2tropic(rend, c, parent)));

		MEllipsis(__, __, __): MEllipsis2T(m, \mat -> doMaterial2tropic(rend, mat, parent));
		MEllipsisText(__, __): MEllipsisText2T(rend.manager, parent, m);
		MShadow(z, mat) : TShadow(z, parent.theme.lightBackground, doMaterial2tropic(rend, mat, parent));
		MShadowShape(z, mat, shape) : TShadowShape(z, parent.theme.lightBackground, doMaterial2tropic(rend, mat, parent), shape);

		MStepper(__, __, __, __): {
			MStepper2T(parent, m, \mat, p -> doMaterial2tropic(rend, mat, p))
		}

		MCarousel(__, __, __): {
			MCarousel2T(rend.manager, parent, m, \mat, p -> doMaterial2tropic(rend, mat, p))
		}
		MMovable(__, __, __): {
			MMovable2T(rend.manager, parent, m, \mat, p -> doMaterial2tropic(rend, mat, p))
		}
		MResizable(__, __): {
			MResizable2T(rend.manager, parent, m, \mat, p -> doMaterial2tropic(rend, mat, p))
		}

		// Copies of Tropic
		MLines(ls): TLines(map(ls, \l -> doMaterial2tropic(rend, l, parent)));
		MCols(cs): TCols(map(cs, \c -> doMaterial2tropic(rend, c, parent)));
		MGroup(ms): TGroup(map(ms, \gm -> doMaterial2tropic(rend, gm, parent)));
		MGrid(mls): TGrid(map(mls, \ms -> map(ms, \gm -> doMaterial2tropic(rend, gm, parent)) |> (\arr -> if (getDefaultRtl()) reverseA(arr) else arr)));
		MLines2(m1, m2) : TLines2(doMaterial2tropic(rend, m1, parent), doMaterial2tropic(rend, m2, parent));
		MCols2(m1, m2) : TCols2(doMaterial2tropic(rend, m1, parent), doMaterial2tropic(rend, m2, parent));
		MGroup2(m1, m2) : TGroup2(doMaterial2tropic(rend, m1, parent), doMaterial2tropic(rend, m2, parent));
		MBaselineCols2(m1, m2) : TBaselineCols2(doMaterial2tropic(rend, m1, parent), doMaterial2tropic(rend, m2, parent));
		MBaselineLines2(m1, m2) : TBaselineLines2(doMaterial2tropic(rend, m1, parent), doMaterial2tropic(rend, m2, parent));
		MMinimumGroup2(m1, m2) : TMinimumGroup2(doMaterial2tropic(rend, m1, parent), doMaterial2tropic(rend, m2, parent));
		MSubtractGroup2(m1, m2) : TSubtractGroup2(doMaterial2tropic(rend, m1, parent), doMaterial2tropic(rend, m2, parent));
		MBaselineOffset(of, m1) : TBaselineOffset(of, doMaterial2tropic(rend, m1, parent));
		MBorder(l, t, r, d, c): TBorder(l, t, r, d, doMaterial2tropic(rend, c, parent));
		MLet(n, v, s): TLet(n, doMaterial2tropic(rend, v, parent), doMaterial2tropic(rend, s, parent));
		MLetMany(i, s): TLetMany(map(i, \it -> Pair(it.first, doMaterial2tropic(rend, it.second, parent))), doMaterial2tropic(rend, s, parent));
		MLetAvailable(n, s): TLetAvailable(n, doMaterial2tropic(rend, s, parent));
		MAlpha(al, mat): TAlpha(al, doMaterial2tropic(rend, mat, parent));
		MCrop(topleft, wh, mat): TCrop(topleft, wh, doMaterial2tropic(rend, mat, parent));
		MCropSize(size, mat): TCropSize(doMaterial2tropic(rend, size, parent), doMaterial2tropic(rend, mat, parent));
		MVisible(val, mat): TVisible(val, doMaterial2tropic(rend, mat, parent));
		MShow(sh, mat): TShow(sh, doMaterial2tropic(rend, mat, parent));
		MAvailable(b, a): TAvailable(doMaterial2tropic(rend, b, parent), doMaterial2tropic(rend, a, parent));
		MShift(m1, d1): TShift(doMaterial2tropic(rend, m1, parent), doMaterial2tropic(rend, d1, parent));
		MMutable(material): MSelect2T(rend.manager, parent, "MMutable", [], material, \mat, p -> doMaterial2tropic(rend, mat, p));
		MIf(c, t, e): TIf(c, doMaterial2tropic(rend, t, parent), doMaterial2tropic(rend, e, parent));
		MIfPreRender(c, t, e, ss): MIfPreRender2T(rend.manager, parent, c, \p -> doMaterial2tropic(rend, t, p), \p -> doMaterial2tropic(rend, e, p), ss);
		MIfLazy(c, fn): MIfLazy2T(rend.manager, parent, c, \c0, p -> doMaterial2tropic(rend, fn(c0), p), false);
		MConstruct(c, mat): TConstruct(c, doMaterial2tropic(rend, mat, parent));
		MCreate2(current, fn): TCreate2(ref doMaterial2tropic(rend, ^current, parent), \ -> doMaterial2tropic(rend, fn(), parent));
		MDynamicGroup2(__, __, __): MDynamicGroup2T(rend.manager, parent, m, \mat, p -> doMaterial2tropic(rend, mat, p));
		MDispose(d, mat): TConstruct([\ -> \ -> applyall(d)], doMaterial2tropic(rend, mat, parent));
		MInteractive(i, mat): TInteractive(i, doMaterial2tropic(rend, mat, parent));
		MCursor(kind, mat): TCursor(kind, doMaterial2tropic(rend, mat, parent));
		MFilter(filters, mat): TFilter(filters, doMaterial2tropic(rend, mat, parent));
		MTranslate(p, mat): TTranslate(p, doMaterial2tropic(rend, mat, parent));
		MOffset(x, y, mat): TTranslate(const(Point(x, y)), doMaterial2tropic(rend, mat, parent));
		MRotate(degree, mat) : TRotate(degree, doMaterial2tropic(rend, mat, parent));
		MCenter(mat): TCenter(doMaterial2tropic(rend, mat, parent));
		MCenterIn(mat, f): TCenterIn(doMaterial2tropic(rend, mat, parent), doMaterial2tropic(rend, f, parent));
		MCenterY(mat): TCenterY(doMaterial2tropic(rend, mat, parent));
		MCenterXIn(mat, f): TCenterXIn(doMaterial2tropic(rend, mat, parent), doMaterial2tropic(rend, f, parent));
		MCenterYIn(mat, f): TCenterYIn(doMaterial2tropic(rend, mat, parent), doMaterial2tropic(rend, f, parent));
		MCase(sz, ms): TCase(map(sz, \gm -> doMaterial2tropic(rend, gm, parent)), map(ms, \gm -> doMaterial2tropic(rend, gm, parent)));
		MScroll(__, __, __): MScroll2T(rend.manager, parent, m, \mat, p -> doMaterial2tropic(rend, mat, p));
		MCenterX(mat): TCenterX(doMaterial2tropic(rend, mat, parent));
		MFrame(mar, r, s, b): TFrame(mar, r, s, doMaterial2tropic(rend, b, parent));
		MScale(factor, mat) : TScale(factor, doMaterial2tropic(rend, mat, parent));
		MTag(tag, mat) : TTag(tag, doMaterial2tropic(rend, mat, parent));
		MTag2(setfn, mat) : TTag2(setfn, doMaterial2tropic(rend, mat, parent));
		MFullWindow(fw, f): TFullWindow(fw, doMaterial2tropic(rend, f, parent));
		MFullScreen(fs, f): TFullScreen(fs, doMaterial2tropic(rend, f, parent));
		MRawButton(__, __, __, __, __, __, __): {
			MRawButton2T(rend.manager, parent, m, \mat -> doMaterial2tropic(rend, mat, parent))
		}
		MTextInput(__, __, __): {
			MTextInput2T(rend.manager, parent, m, \mat, p -> doMaterial2tropic(rend, mat, p))
		}

		MSmallEditDialog(__, __, __): {
			MSmallEditDialog2T(rend.manager, parent, m, \mat, p -> doMaterial2tropic(rend, mat, p))
		}

		MAutoComplete(__, __, __, __): {
			MAutoComplete2T(rend.manager, parent, m, \mat, p -> doMaterial2tropic(rend, mat, p))
		}

		MAttach(ghost, fn) : {
			(\p -> TAttach(doMaterial2tropic(rend, ghost, parent), \fm -> doMaterial2tropic(rend, fn(fm), p)))
			|> (\f -> MActivate2T(rend.manager, parent, "MAttach", [], f))
		}

		MFixSize(childm, size) : {
			m2t = \mat -> doMaterial2tropic(rend, mat, parent);
			TFixSize(m2t(childm), m2t(size));
		}

		MSize(size, childm) : {
			TSize(doMaterial2tropic(rend, size, parent), doMaterial2tropic(rend, childm, parent));
		}
		MSizeOf(mat): TSizeOf(doMaterial2tropic(rend, mat, parent));

		MDraggable(id, stationary, style) : {
			TDraggable(
				rend.manager.manager, id, doMaterial2tropic(rend, stationary, parent),
				map(style, \s -> switch (s) {
					MDragShape(shape) : TDragShape(doMaterial2tropic(rend, shape, parent));
					TDragShape(tropic) : TDragShape(tropic);
					TOnHover(tropic) : TOnHover(tropic);
					TClick(click) : TClick(click);
					TOnClickFn(click) : TOnClickFn(click);
					TDraggingEnabled(enabled) : TDraggingEnabled(enabled);
					TCursorShape(cursor) : TCursorShape(cursor);
				})
			);
		}
		MDropSpot(onHover, onDrop, dropTropic) : {
			TDropSpot(rend.manager.manager, onHover, onDrop, doMaterial2tropic(rend, dropTropic, parent));
		}
		MDropSpot2(onHover, onDrop, dropTropic, handle) : {
			TDropSpot2(rend.manager.manager, onHover, onDrop, doMaterial2tropic(rend, dropTropic, parent), handle);
		}

		MZoom(box, target, keepAspect) : TZoom(doMaterial2tropic(rend, box, parent), doMaterial2tropic(rend, target, parent), keepAspect);

		MZoomToFill(b, t, crop): TZoomToFill(doMaterial2tropic(rend, b, parent), doMaterial2tropic(rend, t, parent), crop);

		MImageMap(__, __, __, __): {
			MImageMap2T(rend.manager, parent, m)
		}

		MToolbar(__, __, __, __): {
			MToolbar2T(rend.manager, parent, m, \mat, p -> doMaterial2tropic(rend, mat, p))
		}

		MAppStructure(__, __): {
			MAppStructure2T(rend.manager, parent, m, \mat, p -> doMaterial2tropic(rend, mat, p))
		}

		MNavigation(__, __): {
			MNavigation2T(rend.manager, parent, m, \mat, p -> doMaterial2tropic(rend, mat, p))
		}

		MBottomNav(__, __, __, __): {
			MBottomNav2T(rend.manager, parent, m)
		}

		MChip(__, __): {
			MChip2T(rend.manager, parent, m)
		}

		MClickable(mat, onClick): clickable(rend.manager, parent, doMaterial2tropic(rend, mat, parent), onClick);
		MMouseDownAround(point, down, hover, click, mat): mouseDownAround(rend.manager, point, down, hover, click, doMaterial2tropic(rend, mat, parent));

		MFocusClickable(state, fn): {
			focusState = replaceStruct(state, extractStruct(state, MAddFocusGroup(true)));

			MFocusClickable2T(rend.manager, parent, "MFocusClickable", focusState, \focus -> doMaterial2tropic(rend, fn(focus), parent));
		}

		MSwipe(__, __):
			MSwipe2T(rend.manager, parent, m, \mat, p -> doMaterial2tropic(rend, mat, p));

		MPicture(__, __):
			MPicture2T(rend.manager, parent, m);

		MSideNav(__, __, __, __): MSideNav2T(rend.manager, parent, m, \mat, p -> doMaterial2tropic(rend, mat, p));
		MExpander(__, __, __, __): MExpander2T(rend.manager, parent, m, \mat, p -> doMaterial2tropic(rend, mat, p));
		MDebug(c, content): TDebug(c, doMaterial2tropic(rend, content, parent));
		MTweak(style, c, s): TTweak(style, doMaterial2tropic(rend, c, parent), doMaterial2tropic(rend, s, parent));
		MPad(x, y, c): TPad(x, y, doMaterial2tropic(rend, c, parent));
		MMask(content, mask) : {
			m2t = \mat -> doMaterial2tropic(rend, mat, parent);
			TMask(m2t(content), m2t(mask));
		}
		MExplicitTheme(target, light, state): {
			MExplicitTheme2T(rend.manager, parent, state, light, \p -> doMaterial2tropic(rend, target, p));
		}
		MScaleAvailable(factor, mat): {
			doMaterial2tropic(rend, mat, parent)
			|> (\trop ->
				TCopySize2(
					TFillXY(),
					\tr, t ->
						TAvailable(trop, TScale(factor, t))
				)
			)
		};
		MActivate(content, state): {
			MActivate2T(
				rend.manager,
				parent,
				extractStruct(state, MFocusName(extractStruct(state, IScriptId("MActivate")).id)).name,
				state,
				\p -> doMaterial2tropic(rend, content, p)
			);
		}

		MActivateMutable(content, state): {
			MSelect2T(
				rend.manager,
				parent,
				extractStruct(state, MFocusName(extractStruct(state, IScriptId("MActivateMutable")).id)).name,
				state,
				content,
				\c, p -> doMaterial2tropic(rend, c, p)
			);
		}

		MGetManager(fn): {
			doMaterial2tropic(rend, fn(rend.manager), parent)
		}

		MGetFocusGroup(fn): {
			doMaterial2tropic(rend, fn(parent), parent)
		}

		MGetMaterial2Tropic(fn): {
			doMaterial2tropic(rend, fn(\mat, p -> doMaterial2tropic(rend, mat, p)), parent)
		}

		MDragDrop(__, __, __): {
			MDragDrop2T(rend.manager, parent, m, \mat, p -> doMaterial2tropic(rend, mat, p));
		}

		MTransformTAcc(fn): {
			TransformTAcc(\t2a, p, s, mo -> fn(\mat, p2, s2, mo2 -> t2a(doMaterial2tropic(rend, mat, parent), p2, s2, mo2), p, s, mo));
		}
		MAccess(prop, mat): {
			TAccess(prop, doMaterial2tropic(rend, mat, parent));
		}
		MPositionScale(ps, mat): {
			TPositionScale(ps, doMaterial2tropic(rend, mat, parent));
		}
		MRealHTML(url, wh, style): {
			MActivate2T(rend.manager, parent, "MRealHTML", [AccessRole("iframe")], \__ -> TRealHTML(url, wh, style));
		}
		MVideoPlayer(__, __, __): {
			MVideoPlayer2T(rend.manager, parent, m, \mat, p -> doMaterial2tropic(rend, mat, p));
		}

		MEmpty(): TEmpty();

		default: cast(m : Material -> Tropic);
	}

	materialLogFn(
		\ -> {
			if (!^debugMaterialSubs && startsWith(m.structname, "M"))
				debugMaterialSubscribers(rend.manager, createTropic, m.structname, false, 0)
			else
				createTropic();
		},
		MaterialDebug(),
		\ ->
			materialLogFn(
				\ ->
					TCopySize(
						createTropic(),
						\tr0 ->
							TransformTAcc2(\t2a -> {
								bf = tr0 |> t2a;
								met = bf.metrics;
								dynamicSize = ref false;
								wd = fgetValue(met.width);
								hgt = fgetValue(met.height);

								b2 =
									TSelect2(
										met.width, met.height, \wd0, hgt0 ->
										if (!^dynamicSize) {
											if (wd == wd0 && !isFConst(met.width) && hgt == hgt0 && !isFConst(met.height))
												TRectangle([Fill(purple), FillOpacity(0.1)], TFixed(wd0, hgt0))
											else if (hgt == hgt0 && !isFConst(met.height))
												TRectangle([Fill(red), FillOpacity(0.1)], TFixed(wd0, hgt0))
											else if (wd == wd0 && !isFConst(met.width))
												TRectangle([Fill(green), FillOpacity(0.1)], TFixed(wd0, hgt0))
											else {
												dynamicSize := true;
												TEmpty()
											}
										} else
											TEmpty()
									)
									|> (\f -> TFixSize(f, TEmpty()))
									|> t2a;

								TAcc(
									FGroup([
										bf.form,
										b2.form
									], false),
									TFormMetrics(
										bf.metrics.width,
										bf.metrics.height,
										bf.metrics.baseline
									),
									bf.minWidth,
									bf.minHeight,
									bf.maxWidth,
									bf.maxHeight,
									bf.xFillers,
									bf.yFillers,
									bf.addFillers,
									bf.xConstant,
									bf.yConstant,
									concat(bf.disposers, b2.disposers)
								)
							}),
						true
					),
				MaterialDebug(),
				createTropic
			)
	)
}


