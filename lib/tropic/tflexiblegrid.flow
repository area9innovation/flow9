import tropic/selecttarray;
import tropic/tropic_gui;
import ui/animate/teasing;
import form/gui;

export {
	TFlexibleGrid(items : Transform<[Tropic]>, style : [TFlexibleGridStyle]) -> Tropic;
		TFlexibleGridStyle ::= TGroupByCols, TOrdered, TVertical, TCropView, CenterAlign, EndAlign, TAnimation, TOrder, TEnabled;
			TGroupByCols(); // "TGroupByLines" in case with TVertical
			TOrdered(newLine : bool); // Lines (Cols in case with TVertical) won't overlap if newLine is true
			TVertical();
			TCropView(); // Crop grid size by items sizes
			TAnimation(deltaTimer : LazyDeltaTimer);
			TOrder(order : Transform<[int]>);
}

TFlexibleGridItem(t : Tropic, tr : DynamicBehaviour<Point>, wh : DynamicBehaviour<Maybe<WidthHeight>>);

TFlexibleGrid(items : Transform<[Tropic]>, style : [TFlexibleGridStyle]) -> Tropic {
	groupByCols = contains(style, TGroupByCols());
	order = tryExtractStruct(style, TOrder(const([])));
	orderedGrid = maybeMap(tryExtractStruct(style, TOrdered(false)), \o -> o.newLine);
	verticalGrid = contains(style, TVertical());
	cropView = contains(style, TCropView());
	gridEnabled = extractStruct(style, TEnabled(const(true))).enabled;
	animation = tryExtractStruct(style, TAnimation(LazyDeltaTimer(make(0.0), nop, nop)));

	contentSize = makeWH();
	contentBaseline = make(0.);
	stageSizeB = make(0.);
	itemsB = ffuseinit(fmapi(items, \__, it -> TFlexibleGridItem(it, make(zeroPoint), make(None()))), make([]));

	prevSize : ref double = ref getValue(stageSizeB);
	prevSizes : ref [Maybe<WidthHeight>] = ref [];
	prevTranslates : ref [Pair<Point, Point>] = ref [];

	SelectTGroup(itemsB.first, \idx, __, item -> {
		TransformTAcc2(\t2a -> {
				b1 =
					eitherMap(
						animation,
						\a -> {
							pos = make(getValue(item.tr));

							TEasingAnimation(
								a.deltaTimer,
								0.2,
								CubicBezierEasing(0.4, 0.0, 0.2, 1.0),
								item.tr,
								\tr -> Some(Pair(getValue(pos), tr)),
								\__ -> {},
								\tr, p -> nextDistinct(pos, Point(lerp(tr.first.x, tr.second.x, p), lerp(tr.first.y, tr.second.y, p))),
								TTranslate(pos, item.t)
							)
							|> TOnConstruct(\ -> nextDistinct(pos, getValue(item.tr)))
						},
						TTranslate(item.tr, item.t)
					)
					|> t2a;

				TAcc(
					b1.form,
					TFormMetrics(
						zero,
						zero,
						zero
					),
					zero,
					zero,
					zero,
					zero,
					zero,
					zero,
					const(false),
					false,
					false,
					concat(
						b1.disposers,
						[
							make2Subscribe(b1.metrics.width, b1.metrics.height, \_wd, _hgt ->
								nextDistinct(item.wh, Some(WidthHeight(_wd, _hgt)))
							)(),
							makeSubscribeUns(feq(idx, 0), \b -> {
								if (b)
									[fconnect(b1.metrics.baseline, contentBaseline)]
								else
									[]
							})()
						]
					)
				)
			}
		)
	})
	|> (\f ->
		TransformTAcc2(\t2a -> {
				b1 = f |> t2a;

				wd = fwidth(contentSize);
				hgt = fheight(contentSize);

				TAcc(
					b1.form,
					TFormMetrics(
						wd,
						hgt,
						contentBaseline
					),
					if (verticalGrid) wd else zero,
					if (verticalGrid) zero else hgt,
					if (verticalGrid) wd else zero,
					if (verticalGrid) zero else hgt,
					zero,
					zero,
					b1.addFillers,
					false,
					false,
					b1.disposers
				)
			}
		)
	)
	|> (\f -> {
			if (contains(style, CenterAlign())) {
				if (verticalGrid)
					TTweak([TAlign(const(b2d(getDefaultRtl())), const(0.5))], f, TFillXY())
				else
					TTweak([TAlign(const(0.5), zero)], f, TFillX())
			} else if (contains(style, EndAlign())) {
				if (verticalGrid)
					TTweak([TAlign(const(b2d(getDefaultRtl())), const(1.))], f, TFillXY())
				else if (getDefaultRtl())
					f
				else
					TTweak([TAlign(const(1.), zero)], f, TFillX())
			} else {
				if (getDefaultRtl())
					TTweak([TAlign(const(1.), zero)], f, TFillX())
				else
					f
			}
	})
	|> (\f ->
		TConstruct(
			[
				make2Subscribe(
					eitherFn(
						order,
						\or -> forder(fsubmap(itemsB.first, \it -> it.wh), or.order),
						\ -> fsubmap(itemsB.first, \it -> it.wh)
					),
					ftransistor(gridEnabled, stageSizeB),
					\itemsSizes, stageSize -> {
						if (!contains(itemsSizes, None())) {
							gridItems = eitherFn(order, \or -> fgetValue(forder(itemsB.first, or.order)), \ -> getValue(itemsB.first));
							blocks = map(itemsSizes, \sz -> either(sz, WidthHeight(0., 0.)) |> (\wh -> BPBlock(wh.width, wh.height)));

							root = if (verticalGrid) BPRoot(0., 0., 0., stageSize, []) else BPRoot(0., 0., stageSize, 0., []);
							parameters =
								BPParameters(
									groupByCols,
									eitherFn(orderedGrid, \og -> Some(og), \ -> if (length(uniq(itemsSizes)) == 1) Some(true) else None()),
									verticalGrid
								);

							iteri(bpFit(root, blocks, parameters), \i, tr -> nextDistinct(gridItems[i].tr, either(tr, Point(0., 0.))));
							next(
								contentSize,
								foldi(blocks, WidthHeight(0., 0.), \i, acc, b ->
									WidthHeight(
										max(acc.width, b.w + getValue(gridItems[i].tr).x),
										max(acc.height, b.h + getValue(gridItems[i].tr).y)
									)
								)
							);
						}
				})
			],
			f
		)
	)
	|> (\f ->
		TConstruct(
			[
				itemsB.second
			],
			f
		)
	)
	|> (\f -> if (verticalGrid) {
			if (cropView) TAttachBoxCopyAvailableHeight(f, stageSizeB) else TAttachHeight2(TFillY(), stageSizeB, f)
		} else {
			if (cropView) TAttachBoxCopyAvailableWidth(f, stageSizeB) else TAttachWidth2(TFillX(), stageSizeB, f)
		}
	)
}

BPRoot(x : double, y : double, w : double, h : double, c : [BPRoot]);
BPBlock(w : double, h : double);
BPState(r : BPRoot, p : Tree<int, Pair<BPBlock, Point>>);

BPParameters(
	groupByCols : bool,
	ordered : Maybe<bool>,
	vertical : bool
);

// Binary packing algorithm
bpFit(root : BPRoot, blocks : [BPBlock], par : BPParameters) -> [Maybe<Point>] {
	if (isSome(par.ordered)) {
		wh =
			if (par.vertical)
				WidthHeight(doubleMax, max(root.h, either(maxA(map(blocks, \b -> b.h)), 0.0)))
			else
				WidthHeight(max(root.w, either(maxA(map(blocks, \b -> b.w)), 0.0)), doubleMax);

		bpFitBlocks(BPRoot(root.x, root.y, wh.width, wh.height, root.c), blocks, par);
	} else {
		blocksI =
			mergeSort(mapi(blocks, \i, b -> Pair(i, b)), \a : Pair<int, BPBlock>, b : Pair<int, BPBlock> ->
				if (par.vertical) {
					if (a.second.h == b.second.h)
						b2i(a.second.w < b.second.w)
					else
						b2i(a.second.h < b.second.h)
				} else {
					if (a.second.w == b.second.w)
						b2i(a.second.h < b.second.h)
					else
						b2i(a.second.w < b.second.w)
				}
			);

		orderI = map(blocksI, \b -> b.first);

		wh =
			if (par.vertical)
				WidthHeight(blocksI[0].second.w, max(blocksI[0].second.h, root.h))
			else
				WidthHeight(max(blocksI[0].second.w, root.w), blocksI[0].second.h);

		getTreeValues(
			foldi(
				bpFitBlocks(BPRoot(root.x, root.y, wh.width, wh.height, root.c), map(blocksI, secondOfPair), par),
				makeTree(),
				\i, acc, tr -> setTree(acc, orderI[i], tr)
			)
		);
	}
}

bpFitBlocks(root : BPRoot, blocks : [BPBlock], par : BPParameters) -> [Maybe<Point>] {
	points = foldi(blocks, BPState(root, makeTree()), \i, state, block -> {
		newState = bpFindNode(i, state, block, par);

		if (isNone(lookupTree(newState.p, i))) {
			bpGrowNode(i, newState, block, par);
		} else {
			newState;
		}
	}).p;

	generate(0, length(blocks), \i -> maybeMap(lookupTree(points, i), \p -> p.second));
}

bpFindNode(i : int, state : BPState, block : BPBlock, par : BPParameters) -> BPState {
	if (length(state.r.c) > 0) {
		if (isSome(par.ordered)) {
			p = ref state.p;

			newChildren =
				map(state.r.c, \c -> {
					if (isNone(lookupTree(^p, i))) {
						newState = bpFindNode(i, BPState(c, ^p), block, par);
						p := newState.p;
						newState.r.c;
					} else {
						[c];
					}
				})
				|> concatA
				|> (\newChildren -> bpFilterRoots(newChildren, BPState(state.r, ^p), par));

			BPState(BPRoot(state.r.x, state.r.y, state.r.w, state.r.h, newChildren), ^p);
		} else {
			p = ref state.p;

			newChildren =
				map(state.r.c, \c -> {
					if (isNone(lookupTree(^p, i))) {
						newState = bpFindNode(i, BPState(c, ^p), block, par);
						p := newState.p;
						newState.r;
					} else {
						c;
					}
				});

			BPState(BPRoot(state.r.x, state.r.y, state.r.w, state.r.h, newChildren), ^p);
		}
	} else if (state.r.w >= block.w && state.r.h >= block.h && (isNone(par.ordered) || !bpCheckIntersect(state, block))) {
		BPState(bpSplitNode(state.r, block, par), setTree(state.p, i, Pair(block, Point(state.r.x, state.r.y))));
	} else {
		state;
	}
}

bpFilterRoots(roots : [BPRoot], state : BPState, par : BPParameters) -> [BPRoot] {
	lastMetric = ref 0.;
	maxMetric = foldTree(state.p, Pair(0.0, 0.0), \k, v, acc ->
		if (par.vertical) {
			lastMetric := v.second.y;

			Pair(max(v.second.x, acc.first), max(v.second.x + v.first.w, acc.second))
		} else {
			lastMetric := v.second.x;

			Pair(max(v.second.y, acc.first), max(v.second.y + v.first.h, acc.second))
		}
	);

	filter(roots, \b ->
		if (par.vertical)
			eitherMap(par.ordered, \o ->
				if (o)
					b.x >= maxMetric.second || (b.x >= maxMetric.first && b.y >= ^lastMetric)
				else
					b.x >= maxMetric.first && (b.y == 0.0 || b.y >= ^lastMetric),
				true
			)
		else
			eitherMap(par.ordered, \o ->
				if (o)
					b.y >= maxMetric.second || (b.x >= ^lastMetric && b.y >= maxMetric.first)
				else
					b.y >= maxMetric.first && (b.x == 0.0 || b.x >= ^lastMetric),
				true
			)
	)
	|> (\f ->
		if (par.vertical)
			mergeSort(f, \a : BPRoot, b : BPRoot -> if (a.x < b.x) -1 else if (a.x > b.x) 1 else genericCompare(a.y, b.y))
		else
			mergeSort(f, \a : BPRoot, b : BPRoot-> if (a.y < b.y) -1 else if (a.y > b.y) 1 else genericCompare(a.x, b.x))
	);
}

bpCheckIntersect(state : BPState, block : BPBlock) -> bool {
	foldTree(state.p, false, \k, v, acc -> {
		if (!acc) {
			doIntersect(v.second.x, v.second.y, v.first.w, v.first.h, state.r.x, state.r.y, block.w, block.h)
		} else {
			acc;
		}
	})
}

doIntersect(x1 : double, y1 : double, w1 : double, h1 : double, x2 : double, y2 : double, w2 : double, h2 : double) -> bool {
	x1 + w1 > x2 && x1 < x2 + w2 && y1 + h1 > y2 && y1 < y2 + h2;
}

bpSplitNode(root : BPRoot, block : BPBlock, par : BPParameters) -> BPRoot {
	BPRoot(
		root.x,
		root.y,
		root.w,
		root.h,
		if (par.vertical)
			[
				if (isSome(par.ordered))
					BPRoot(root.x + block.w, 0.0, root.w - block.w, root.h + root.y, [])
				else
					BPRoot(root.x + block.w, root.y, root.w - block.w, if (par.groupByCols) block.h else root.h, []),
				BPRoot(root.x, root.y + block.h, if (isSome(par.ordered) || par.groupByCols) root.w else block.w, root.h - block.h, []),
			]
			|> (\c -> if (isSome(par.ordered)) reverseA(c) else c)
		else
			[
				BPRoot(root.x + block.w, root.y, root.w - block.w, if (isSome(par.ordered) || par.groupByCols) root.h else block.h, []),
				if (isSome(par.ordered))
					BPRoot(0.0, root.y + block.h, root.w + root.x, root.h - block.h, [])
				else
					BPRoot(root.x, root.y + block.h, if (par.groupByCols) block.w else root.w, root.h - block.h, [])
			]
	)
}

bpGrowNode(i : int, state : BPState, block : BPBlock, par : BPParameters) -> BPState {
	// canGrowDown = block.w <= state.r.w;
	// canGrowRight = block.h <= state.r.h;

	// if (canGrowRight)
	// 	bpGrowRight(i, state, block, par)
	// else if (canGrowDown)
	// 	bpGrowDown(i, state, block, par)
	// else
	// 	state;
	// if (canGrowDown)
	if (par.vertical)
		bpGrowRight(i, state, block, par)
	else
		bpGrowDown(i, state, block, par);
	// else
	// 	None();
}

bpGrowRight(i : int, state : BPState, block : BPBlock, par : BPParameters) -> BPState {
	newState = BPState(bpGrowRight2(state.r, block, par), state.p);

	bpFindNode(i, newState, block, par);
}

bpGrowRight2(root : BPRoot, block : BPBlock, par : BPParameters) -> BPRoot {
	if (length(root.c) == 0) {
		BPRoot(root.x, root.y, root.w + block.w, root.h, []);
	} else {
		c =
			if (par.groupByCols)
				map(root.c, \c -> bpGrowRight2(c, block, par))
			else
				[bpGrowRight2(root.c[0], block, par), root.c[1]];

		BPRoot(root.x, root.y, root.w + block.w, root.h, c);
	}
}

bpGrowDown(i : int, state : BPState, block : BPBlock, par : BPParameters) -> BPState {
	newState = BPState(bpGrowDown2(state.r, block, par), state.p);

	bpFindNode(i, newState, block, par);
}

bpGrowDown2(root : BPRoot, block : BPBlock, par : BPParameters) -> BPRoot {
	if (length(root.c) == 0) {
		BPRoot(root.x, root.y, root.w, root.h + block.h, []);
	} else {
		c =
			if (par.groupByCols)
				map(root.c, \c -> bpGrowDown2(c, block, par))
			else
				[root.c[0], bpGrowDown2(root.c[1], block, par)];

		BPRoot(root.x, root.y, root.w, root.h + block.h, c);
	}
}