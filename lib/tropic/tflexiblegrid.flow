import tropic/selecttarray;
import tropic/tropic_gui;
import ui/animate/teasing;
import form/gui;
import form/paragraphalignments;
import tropic/tropic2form;

export {

	TFlexibleGrid(items : Transform<[Tropic]>, style : [TFlexibleGridStyle]) -> Tropic;
		FlexibleGridAlignment ::= RelativeAlignment, CenterAlign, TightWidth;
		TFlexibleGridStyle ::= TWrapNewRow, TWrapNewColumn, TVertical, TMaxRows, FlexibleGridAlignment,
			TAnimationTimer, TOrder, TLockWidth, TEnabled, TSetRTL, TSameSize, TFlexibleGridContentSizeInspector, TFlexibleGridMaxContentWidthInspector,
			TBaselineAlign, TFillersSupport, TAvailableMinMax, TArrayThreshold, TFlexibleGridLazyRenderingMode, TSpacing;

			TWrapNewRow(wrap : bool); // New row should be below all the elements in the previous one (true by default for horizontal grid)
			TWrapNewColumn(wrap : bool); // New column should be to the right of all the elements in the previous one (true by default for vertical grid)
			TVertical(); // Pack elements vertically and bound them with available height
			TMaxRows(rows : int); // Max elements in a first column (Max elements in a first row if TVertical is passed)
			TAnimationTimer(deltaTimer : LazyDeltaTimer); // Enables animation
			TOrder(order : Transform<[int]>); // Set items order
			TLockWidth(lock : bool); // If true size only grows in height not in width (false for TVertical and true for horizontal grid)
			TSameSize(); // Some optimization for performance boosting in case of same sized items
			TBaselineAlign(); // Align items to baseline (ignored with TVertical)
			TFillersSupport(); // Allow size of the items to grow by available space
			TCenterSupport() -> TFlexibleGridStyle { TFillersSupport(); };
			TAvailableMinMax(min : Transform<double>, max : Transform<double>);
			TArrayThreshold(threshold : Transform<int>); // Fine efficiency tuning : what algorithm to use depending on array size
			TSpacing(x : Transform<double>, y : Transform<double>); // Spacing between items

			// Size of the box, which content occupies inside the grid. Less or equal to outer grid box size
			TFlexibleGridContentSizeInspector(wh : DynamicBehaviour<WidthHeight>);
			// Sum of all content widths
			TFlexibleGridMaxContentWidthInspector(maxWidth : DynamicBehaviour<double>);
			// Renders only items inside a viewport, keeps their metrics when outside
			TFlexibleGridLazyRenderingMode(viewport : Transform<WidthHeight>, scrollPosition : Transform<Point>);

	TFlex(items : Transform<[Tropic]>, style : [TFlexStyle]) -> Tropic;
		TFlexAlignment ::= RelativeAlignment, CenterAlign, TAlign;
		TFlexStyle ::= TVertical, TWrap, TFlexAlignment, TAnimationTimer, TOrder, TEnabled, TSetRTL, TSameSize,
			TBaselineAlign, TAvailableMinMax, TArrayThreshold, TFlexibleGridLazyRenderingMode, TSpacing, TSpacingView, TBalanced, TPreventOverflow, TMinMaxSizeLerp;

			// Controls how flex items are distributed into rows/columns by interpolating between minSize and maxSize
			// for layout calculations when fillers > 0.0. Items will still grow to fill available space in their
			// final row/column, but this factor determines how much space they're assumed to need for wrapping decisions.
			// factor = 0.0: uses minSize for layout - more items fit per row/column before wrapping (default behavior)
			// factor = 1.0: uses maxSize for layout - fewer items fit per row/column before wrapping
			// factor = 0.5: uses average size for layout - moderate items per row/column
			// This allows fine-tuning the density of item distribution without affecting final rendering size
			TMinMaxSizeLerp(factor : Transform<double>);

			 // Amount of elements in each row (Amount of elements in each column if TVertical is passed)
			 // By default wrap is 0, which means that all elements are fitted by their size
			TWrap(wrap : int);
			// Spread amount of elements evenly in the columns (rows if TVertical is passed)
			// Total amount of elements is divided by the available amount of rows (columns if TVertical is passed)
			// which is calculated by dividing total size of elements by the available space
			// Overwritten by TWrap if wrap > 0
			TBalanced();
			// Views to use as spacing between elements
			// Gets size of the spacing box as available
			TSpacingView(x : Tropic, y : Tropic);
			// Prevent overflow of the available height (width if TVertical is passed)
			// Ignored for TWrap > 0 or TBalanced
			TPreventOverflow();

			// Fill spacing between elements with color
			TSpacingFill(color : int) -> TSpacingView {
				TSpacingView(
					TFrame(0.0, 0.0, [Fill(color)], TFillXY()),
					TFrame(0.0, 0.0, [Fill(color)], TFillXY()),
				)
			};

	bfFit(stageSize : double, blocks : [BFBlock], par : BFParameters) -> [Maybe<Point>];
	bfFitBlocks(size : WidthHeight, blocks : [BFBlock], par : BFParameters) -> BFState;

		BFBlock(w : double, h : double);
		BFState(l : [Point], s : WidthHeight, p : Tree<int, Pair<BFBlock, Point>>);
		BFParameters(
			wrapNewRow : bool,
			wrapNewColumn : bool,
			ordered : bool,
			vertical : bool,
			maxRows : Maybe<int>,
			lockWidth : bool,
			isRTL : bool
		);
}

TFlexibleGridItem(
	id : int,
	t : Tropic,
	tr : DynamicBehaviour<Transform<Point>>,
	wh : DynamicBehaviour<WidthHeight>,
	baseline : DynamicBehaviour<double>,
	minWH : DynamicBehaviour<WidthHeight>,
	maxWH : DynamicBehaviour<WidthHeight>,
	fillers : DynamicBehaviour<Point>,
	av : DynamicBehaviour<Transform<WidthHeight>>,
	alignWH : DynamicBehaviour<Transform<WidthHeight>>,
	addSpacingX : DynamicBehaviour<bool>,
	addSpacingY : DynamicBehaviour<bool>,
);

TFlexibleGridConstantItem(
	id : int,
	t : Tropic,
	tr : DynamicBehaviour<Transform<Point>>,
	wh : Transform<WidthHeight>,
	baseline : Transform<double>,
	minWH : Transform<WidthHeight>,
	maxWH : Transform<WidthHeight>,
	fillers : Transform<Point>,
	av : DynamicBehaviour<Transform<WidthHeight>>,
	alignWH : DynamicBehaviour<Transform<WidthHeight>>,
	addSpacingX : DynamicBehaviour<bool>,
	addSpacingY : DynamicBehaviour<bool>,
	rows : int,
	columns: int
);

emptyTFlexibleGridItem = TFlexibleGridItem(-1, TEmpty(), make(const(zeroPoint)), makeWH(), make(0.0), makeWH(), makeWH(), makePoint(), make(const(zeroWH)), make(const(zeroWH)), make(false), make(false));
flexibleGridItemId = ref 0;
flexibleGridDeferred = isUrlParameterTrue("flexible_deferred");

TFlexibleGrid(items : Transform<[Tropic]>, style : [TFlexibleGridStyle]) -> Tropic {
	verticalGrid = contains(style, TVertical());
	lockWidth = extractStruct(style, TLockWidth(!verticalGrid)).lock;
	wrapNewRow = extractStruct(style, TWrapNewRow(!verticalGrid)).wrap;
	wrapNewColumn = extractStruct(style, TWrapNewColumn(verticalGrid)).wrap;
	order = tryExtractStruct(style, TOrder(const([])));
	gridEnabled = extractStruct(style, TEnabled(const(true))).enabled;
	animation = tryExtractStruct(style, TAnimationTimer(LazyDeltaTimer(make(0.0), nop, nop)));
	maxRows = maybeMap(tryExtractStruct(style, TMaxRows(0)), \mr -> mr.rows);
	contentSizeInspector = tryExtractStruct(style, TFlexibleGridContentSizeInspector(makeWH()));
	maxContentWidthInspector = tryExtractStruct(style, TFlexibleGridMaxContentWidthInspector(make(0.)));
	stageSizeB = make(0.);
	lazyRenderingMode = tryExtractStruct(style, TFlexibleGridLazyRenderingMode(makeWH(), makePoint()));
	availableMinMax = extractStruct(style, TAvailableMinMax(stageSizeB, stageSizeB));
	alignment : FlexibleGridAlignment =
		if (contains(style, TightWidth()))
			TightWidth()
		else if (contains(style, CenterAlign()))
			CenterAlign()
		else if (contains(style, EndAlign()))
			EndAlign()
		else
			StartAlign();
	alignBaselines = contains(style, TBaselineAlign());
	fillersSupport = contains(style, TFillersSupport()) || alignBaselines;
	arrayThreshold = extractStruct(style, TArrayThreshold(const(ARRAY_DIFF_TRESHOLD))).threshold;
	spacing = extractStruct(style, TSpacing(zero, zero));
	spacingB = if (lockWidth) spacing.x else spacing.y;

	isRTL = extractStruct(style, TSetRTL(getDefaultRtl())).rtl;
	isSameSize = contains(style, TSameSize());

	sameSizeWH : DynamicBehaviour<WidthHeight> = make(zeroWH);
	sameSizeBaseline : DynamicBehaviour<double> = make(0.0);
	sameSizeMinWH : DynamicBehaviour<WidthHeight> = make(zeroWH);
	sameSizeMaxWH : DynamicBehaviour<WidthHeight> = make(zeroWH);
	firstItemWH = makeWH();

	itemsB0 =
		fmap(items, \it -> {
			flexibleGridItemId := ^flexibleGridItemId + 1;

			TFlexibleGridItem(
				^flexibleGridItemId,
				TBorderTDir(zero, zero, spacing.x, spacing.y, it, isRTL),
				make(const(zeroPoint)),
				if (isSameSize) sameSizeWH else make(zeroWH),
				if (isSameSize) sameSizeBaseline else make(0.0),
				if (isSameSize) sameSizeMinWH else make(zeroWH),
				if (isSameSize) sameSizeMaxWH else make(zeroWH),
				make(Point(1.0, 0.0)),
				make(const(zeroWH)),
				make(const(zeroWH)),
				make(false),
				make(false),
			)
		});
	// To protect itemsB0 fn from being called multiple times for each item
	itemsB = fsubselect(itemsB0, FLift(\v -> const(v)));

	contentBaseline = fsubselect(felementAt(itemsB, const(0), const(emptyTFlexibleGridItem)), FLift(\e : TFlexibleGridItem -> e.baseline));
	contentSize0 =
		fselect3(
			fsubmap(itemsB, \it : TFlexibleGridItem -> fpair(fsubselect(it.tr, idfn |> FLift), it.wh)),
			spacing.x,
			spacing.y,
			\pairs : [Pair<Point, WidthHeight>], spacingX, spacingY-> {
				fold(pairs, Triple(zeroWH, doubleMax, 0.), \acc, v ->
					Triple(
						WidthHeight(
							max(acc.first.width, dfloor(v.second.width + v.first.x - spacingX)),
							max(acc.first.height, dfloor(v.second.height + v.first.y - spacingY))
						),
						min(acc.second, v.first.x),
						acc.third + dfloor(v.second.width - spacingX)
					)
				)
			}
		);

	contentSize = fFirstOfTriple(contentSize0);

	contentMinSize = fselect2(fsubmap(itemsB, \it -> if (lockWidth) fwidth(it.minWH) else fheight(it.minWH)), spacingB, FLift2(\v, sp -> either(maxA(v), sp) - sp));

	parameters =
		BFParameters(
			wrapNewRow,
			wrapNewColumn,
			isSome(order),
			verticalGrid,
			maxRows,
			lockWidth,
			isRTL
		);

	item2Tropic = \item : TFlexibleGridItem, isFirst : Transform<bool> -> {
		translatePoint = fsubselect(item.tr, FLift(idfn));
		TIfLazy(if (isSameSize || isSome(lazyRenderingMode)) isFirst else const(true), \b -> {
			eitherMap(lazyRenderingMode, \lrm -> {
					if (b)
						TInspect([ISize(firstItemWH)],
							TInspect([ISize(item.wh), IMinSize(item.minWH), IMaxSize(item.maxWH), IBaseline(item.baseline)], item.t)
						)
					else {
						showInitialSize = make(!b);
						showItem0 =
							if (verticalGrid)
								fselect4(fwidth(item.wh), fpointX(translatePoint), fwidth(lrm.viewport), fpointX(lrm.scrollPosition),
									\w, trX, vw, spX -> {pos = trX - spX; pos >= -w && pos <= vw}
								)
							else
								fselect4(fheight(item.wh), fpointY(translatePoint), fheight(lrm.viewport), fpointY(lrm.scrollPosition),
									\h, trY, vh, spY -> {pos = trY - spY; pos >= -h && pos <= vh}
								);
						showItem = fguard(showItem0, make(false));
						TInspect(
							[ISize(item.wh), IMinSize(item.minWH), IMaxSize(item.maxWH), IBaseline(item.baseline)],
							TGroup2(
								TShow(showInitialSize, TSized(firstItemWH)),
								TShowKeepMetrics(showItem.first, item.t)
							)
						)
						|> (\t -> TConstruct([\ -> fwhen(showItem.first, \ -> nextDistinct(showInitialSize, false)), showItem.second], t))
					}
				},
				TInspect(
					if (b) {
						[ISize(item.wh), IMinSize(item.minWH), IMaxSize(item.maxWH), IBaseline(item.baseline)];
					} else {
						[];
					},
					item.t
				)
			)
			|> (\f ->
				if (isSameSize) {
					visible = make(false);
					TRenderable(visible, TShowKeepMetrics(fstall(visible, 1), f));
				} else {
					f;
				}
			)
		})
		|> (\f ->
			if (fillersSupport)
				TAvailable(
					f,
					TSized(fsubselect(item.av, idfn |> FLift))
				)
			else
				f
		)
		|> (\tropic ->
			eitherMap(
				animation,
				\a -> {
					pos = make(None());
					trigger = ffuse(translatePoint);

					TEasingAnimation(
						a.deltaTimer,
						0.2,
						CubicBezierEasing(0.4, 0.0, 0.2, 1.0),
						trigger.first,
						\tr -> eitherMap(getValue(pos), \p -> Some(Pair(p, tr)), None()),
						\tr -> nextDistinct(pos, Some(tr.second)),
						\tr, p -> nextDistinct(pos, Some(Point(lerp(tr.first.x, tr.second.x, p), lerp(tr.first.y, tr.second.y, p)))),
						TTranslate(feither(pos, translatePoint), tropic)
					)
					|> (\f -> TConstruct(trigger.second, f))
					|> TOnConstruct(\ -> nextDistinct(pos, Some(fgetValue(getValue(item.tr)))))
				},
				TTranslate(translatePoint, tropic)
			)
		);
	}

	SelectTGroupFixed(itemsB, \idx, __, item -> item2Tropic(item, feq(idx, 0)), arrayThreshold)
	|> (\f ->
		TransformTAcc2(\t2a -> {
				b1 = f |> t2a;

				TAcc(
					b1.form,
					TFormMetrics(
						fwidth(contentSize),
						fheight(contentSize),
						contentBaseline
					),
					if (lockWidth) contentMinSize else fwidth(contentSize),
					if (!lockWidth) contentMinSize else fheight(contentSize),
					if (lockWidth) const(doubleMax) else fwidth(contentSize),
					if (!lockWidth) const(doubleMax) else fheight(contentSize),
					const(b2d(lockWidth)),
					const(b2d(!lockWidth)),
					b1.addFillers,
					false,
					false,
					b1.disposers
				)
			}
		)
	)
	|> (\f ->
		if (fillersSupport) {
			f
		} else switch (alignment) {
			StartAlign(): if (verticalGrid) TAlignTop else if (isRTL) TAlignRight else TAlignLeft
			EndAlign(): if (verticalGrid) TAlignBottom else if (isRTL) TAlignLeft else TAlignRight
			CenterAlign(): if (verticalGrid) TCenterY else TCenterX
			TightWidth(): idfn
		}(f)
	)
	|> (\f ->
		if (fillersSupport) {
			TConstruct(
				[
					if (isSameSize)
						make3Subscribe2(
							fdelayUntilNextFrameRendered(eitherMap(order, \or -> forder(fselect(itemsB, FLift(idfn)), or.order), itemsB)),
							sameSizeMinWH,
							fthrottleUntilNextFrameRendered(ftransistor(gridEnabled, fpair(faddition(availableMinMax.min, spacingB), faddition(availableMinMax.max, spacingB)))),
							\itms, __, stageSize ->
								fitTFlexibleGrid(itms, stageSize.first, stageSize.second, verticalGrid, alignment, alignBaselines, maxRows, isRTL)
						)
					else
						make2Subscribe2(
							fsubmap(
								fdelayUntilNextFrameRendered(eitherMap(order, \or -> forder(fselect(itemsB, FLift(idfn)), or.order), itemsB)),
								\it -> fpair(const(it), fpair(it.minWH, it.maxWH))
							),
							fthrottleUntilNextFrameRendered(ftransistor(gridEnabled, fpair(faddition(availableMinMax.min, spacingB), faddition(availableMinMax.max, spacingB)))),
							\itms, stageSize ->
								fitTFlexibleGrid(map(itms, firstOfPair), stageSize.first, stageSize.second, verticalGrid, alignment, alignBaselines, maxRows, isRTL)
						)
				],
				f
			)
		} else {
			itemTranslations =
				fselect2(
					fsubmap(eitherMap(order, \or -> forder(fselect(itemsB, FLift(idfn)), or.order), itemsB), \it -> it.wh),
					ftransistor(gridEnabled, faddition(availableMinMax.min, spacingB)),
					FLift2(\itemsSizes, stageSize -> {
						blocks = map(itemsSizes, \wh -> BFBlock(wh.width, wh.height));
						bfFit(stageSize, blocks, parameters);
					})
				)
				|> (\tr -> eitherMap(order, \or -> fdeorder(tr, or.order), tr));

			initialRender = ref true;

			TConstruct(
				if (isSameSize) {
					applyTranslationsTrigger = make(false);
					[
						makeSubscribe(itemTranslations, \__ -> reverseBehaviour(applyTranslationsTrigger)),
						makeSubscribe(itemsB, \__ -> reverseBehaviour(applyTranslationsTrigger)),

						makeSubscribe(applyTranslationsTrigger, \__ -> {
							gridItems = fgetValue(itemsB);
							iteri(fgetValue(itemTranslations), \i, p ->
								if (length(gridItems) > i) {
									nextDistinct(gridItems[i].tr, const(either(p, Point(0., 0.))));
								}
							);
						})
					]
				} else [
					make2Subscribe(
						itemTranslations,
						itemsB,
						\tr, gridItems -> {
							iteri(tr, \i, p ->
								if (length(gridItems) > i) {
									fn = \ -> nextDistinct(gridItems[i].tr, const(either(p, Point(0., 0.))));
									if (flexibleGridDeferred && isSome(lazyRenderingMode) && !^initialRender) deferred(fn) else fn()
								}
							)
							initialRender := false;
						}
					)
				],
				f
			)
		}
	)
	|> (\f ->
		eitherMap(
			contentSizeInspector,
			\inspector ->
				TConstruct(
					[
						if (isRTL) {
							\ -> fconnectSelect(contentSize0, inspector.wh, \cs -> WidthHeight(cs.first.width - cs.second, cs.first.height))
						} else {
							\ -> fconnect(contentSize, inspector.wh)
						}
					],
					f
				),
			f
		)
	)
	|> (\f ->
		eitherMap(
			maxContentWidthInspector,
			\inspector ->
				TConstruct(
					[\ -> fconnect(fThirdOfTriple(contentSize0), inspector.maxWidth)],
					f
				),
			f
		)
	)
	|> (\f ->
		TGroup2(
			if (lockWidth)
				TSizedWidth(contentMinSize, 0.0)
			else
				TSizedHeight(0.0, contentMinSize),
			TInspect(
				[if (lockWidth) IAvailableWidth(stageSizeB) else IAvailableHeight(stageSizeB)],
				f
			)
		)
	)
}

foldBinary(a : [?], fn : (e1 : ?, e2 : ?) -> ?) -> ? {
	if (length(a) == 2) {
		fn(a[0], a[1]);
	} else if (length(a) < 2) {
		a[0]
	} else {
		fn(foldBinary(subrange(a, 0, length(a) / 2), fn), foldBinary(subrange(a, length(a) / 2, length(a) - length(a) / 2), fn));
	}
}

TFlexibleGridItem2TFlexibleGridConstantItem(t : TFlexibleGridItem) -> TFlexibleGridConstantItem {
	TFlexibleGridConstantItem(
		t.id,
		t.t,
		t.tr,
		t.wh,
		t.baseline,
		t.minWH,
		t.maxWH,
		t.fillers,
		t.av,
		t.alignWH,
		t.addSpacingX,
		t.addSpacingY,
		1,
		1
	)
}

distributeTFlexibleGridAsks(
	fillers1 : Transform<double>,
	fillers2 : Transform<double>,
	min1 : Transform<double>,
	min2 : Transform<double>,
	max1 : Transform<double>,
	max2 : Transform<double>,
	available : Transform<double>
) -> Pair<Transform<double>, Transform<double>> {
	fselect7(
		fillers1,
		fillers2,
		min1,
		min2,
		max1,
		max2,
		available,
		\f1, f2, mn1, mn2, mx1, mx2, a -> {
			mn = mn1 + mn2;

			if (mn >= a || f1 + f2 <= 0.0) { // If minimum is more than available or there are no fillers then use min values
				Pair(mn1, mn2);
			} else if (f1 <= 0.0) {
				if (f2 <= 0.0) {
					Pair(mn1, mn2);
				} else {
					Pair(mn1, max(min(a - mn1, mx2), mn2));
				}
			} else if (f2 <= 0.0) {
				Pair(max(min(a - mn2, mx1), mn1), mn2);
			} else {
				mx = mx1 + mx2;

				if (mx <= a || mn >= mx) { // If maximum is less than available or max equals min then use max values
					Pair(mx1, mx2);
				} else {
					ad = a - mn1 - mn2;
					s1 = max(min(ad * f1 / (f1 + f2) + mn1, mx1), mn1);
					s2 = a - s1;

					if (s2 < mn2) {
						Pair(max(a - mn2, mn1), mn2);
					} else if (s2 > mx2) {
						Pair(min(a - mx2, mx1), mx2);
					} else {
						Pair(s1, s2);
					}
				}
			}
		}
	)
	|> (\f -> Pair(fFirstOfPair(f), fSecondOfPair(f)))
}

mergeTFlexibleGridConstantItemsHorizontal(t1 : TFlexibleGridConstantItem, t2 : TFlexibleGridConstantItem, alignBaselines : bool) -> TFlexibleGridConstantItem {
	tr = make(const(zeroPoint));
	av = make(const(zeroWH));
	baseline = fmax(t1.baseline, t2.baseline);

	da =
		distributeTFlexibleGridAsks(
			fpointX(t1.fillers),
			fpointX(t2.fillers),
			fwidth(t1.minWH),
			fwidth(t2.minWH),
			fwidth(t1.maxWH),
			fwidth(t2.maxWH),
			fwidth(fsubselect(av, idfn |> FLift))
		);

	uns = ref nop;
	uns := subscribe2(tr, \__ -> {
		next(t1.av, fwh(da.first, fheight(t1.minWH)));
		next(t2.av, fwh(da.second, fheight(t2.minWH)));

		next(
			t1.tr,
			fsubselect(
				tr,
				if (!alignBaselines)
					FLift(\p -> p)
				else
					FLift(\p -> fpoint(fpointX(p), faddition(fpointY(p), fsubtract(baseline, t1.baseline))))
			)
		);
		next(
			t2.tr,
			fsubselect(
				tr,
				FLift(\p ->
					fpoint(
						faddition(fpointX(p), da.first),
						if (!alignBaselines)
							fpointY(p)
						else
							faddition(fpointY(p), fsubtract(baseline, t2.baseline))
					)
				)
			)
		);

		^uns();
		uns := nop;
	});

	flexibleGridItemId := ^flexibleGridItemId + 1;

	TFlexibleGridConstantItem(
		^flexibleGridItemId,
		TEmpty(),
		tr,
		fwh(
			faddition(fwidth(t1.wh), fwidth(t2.wh)),
			fmax(fheight(t1.wh), fheight(t2.wh))
		),
		baseline,
		fwh(
			faddition(fwidth(t1.minWH), fwidth(t2.minWH)),
			fmax(fheight(t1.minWH), fheight(t2.minWH))
		),
		fwh(
			faddition(fwidth(t1.maxWH), fwidth(t2.maxWH)),
			fmax(fheight(t1.maxWH), fheight(t2.maxWH))
		),
		fpoint(
			faddition(fpointX(t1.fillers), fpointX(t2.fillers)),
			faddition(fpointY(t1.fillers), fpointY(t2.fillers))
		),
		av,
		make(const(zeroWH)),
		t1.addSpacingX,
		t1.addSpacingY,
		max(t1.rows, t2.rows),
		t1.columns + t2.columns
	);
}

mergeTFlexibleGridConstantItemsVertical(t1 : TFlexibleGridConstantItem, t2 : TFlexibleGridConstantItem) -> TFlexibleGridConstantItem {
	tr = make(const(zeroPoint));
	av = make(const(zeroWH));

	da =
		distributeTFlexibleGridAsks(
			fpointY(t1.fillers),
			fpointY(t2.fillers),
			fheight(t1.minWH),
			fheight(t2.minWH),
			fheight(t1.maxWH),
			fheight(t2.maxWH),
			fheight(fsubselect(av, idfn |> FLift))
		);

	uns = ref nop;
	uns := subscribe2(tr, \__ -> {
		next(t1.av, fwh(fwidth(t1.minWH), da.first));
		next(t2.av, fwh(fwidth(t2.minWH), da.second));

		next(t1.tr, fsubselect(tr, idfn |> FLift));
		next(t2.tr, fsubselect(tr, FLift(\p -> fpoint(fpointX(p), faddition(fpointY(p), da.first)))));

		^uns();
		uns := nop;
	});

	flexibleGridItemId := ^flexibleGridItemId + 1;

	TFlexibleGridConstantItem(
		^flexibleGridItemId,
		TEmpty(),
		tr,
		fwh(
			fmax(fwidth(t1.wh), fwidth(t2.wh)),
			faddition(fheight(t1.wh), fheight(t2.wh))
		),
		fmax(
			t1.baseline,
			t2.baseline
		),
		fwh(
			fmax(fwidth(t1.minWH), fwidth(t2.minWH)),
			faddition(fheight(t1.minWH), fheight(t2.minWH))
		),
		fwh(
			fmax(fwidth(t1.maxWH), fwidth(t2.maxWH)),
			faddition(fheight(t1.maxWH), fheight(t2.maxWH))
		),
		fpoint(
			faddition(fpointX(t1.fillers), fpointX(t2.fillers)),
			faddition(fpointY(t1.fillers), fpointY(t2.fillers))
		),
		av,
		make(const(zeroWH)),
		t1.addSpacingX,
		t1.addSpacingY,
		t1.rows + t2.rows,
		max(t1.columns, t2.columns)
	);
}

fitTFlexibleGrid(
	items : [TFlexibleGridItem],
	sizeMin : double,
	sizeMax : double,
	vertical : bool,
	alignment : FlexibleGridAlignment,
	alignBaselines : bool,
	maxRows : Maybe<int>,
	isRTL : bool
) -> void {
	currentPoint = ref const(zeroPoint);
	currentCoord = ref const(0.);
	currentLine = ref [];
	availableSize = make(const(sizeMin));

	addLineFn = \ -> {
		if (length(^currentLine) > 0) {
			t =
				foldBinary(
					map(^currentLine, TFlexibleGridItem2TFlexibleGridConstantItem),
					\t1, t2 ->
						if (vertical)
							mergeTFlexibleGridConstantItemsVertical(t1, t2)
						else
							mergeTFlexibleGridConstantItemsHorizontal(if (isRTL) t2 else t1, if (isRTL) t1 else t2, alignBaselines)
				);

			if (vertical) {
				next(t.av, fwh(fwidth(t.wh), fsubselect(availableSize, idfn |> FLift)));
				next(
					t.tr,
					fpoint(
						fpointX(^currentPoint),
						fmax(
							if (alignment == CenterAlign())
								fdivide(fsubtract(fsubselect(availableSize, idfn |> FLift), fheight(t.wh)), const(2.0))
							else if (alignment == EndAlign())
								fsubtract(fsubselect(availableSize, idfn |> FLift), fheight(t.wh))
							else
								zero,
							zero
						)
					)
				);
				next(availableSize, fmax(getValue(availableSize), fheight(t.minWH)));

				currentPoint := fpoint(faddition(fpointX(^currentPoint), fwidth(t.wh)), fpointY(^currentPoint));
			} else {
				next(t.av, fwh(fsubselect(availableSize, idfn |> FLift), fheight(t.wh)));
				next(
					t.tr,
					fpoint(
						fmax(
							if (alignment == CenterAlign())
								fdivide(fsubtract(fsubselect(availableSize, idfn |> FLift), fwidth(t.wh)), const(2.0))
							else if ((!isRTL && alignment == EndAlign()) || (isRTL && alignment == StartAlign()))
								fsubtract(fsubselect(availableSize, idfn |> FLift), fwidth(t.wh))
							else
								zero,
							zero
						),
						fpointY(^currentPoint)
					)
				);
				next(availableSize, fmax(getValue(availableSize), fwidth(t.minWH)));

				currentPoint := fpoint(fpointX(^currentPoint), faddition(fpointY(^currentPoint), fheight(t.wh)));
			}
		}
	}

	iter(items, \it -> {
		minSize = if (vertical) fheight(it.minWH) else fwidth(it.minWH);
		doesFit = fgetValue(^currentCoord) + fgetValue(minSize) < sizeMax;

		if (eitherMap(maxRows, \mr -> length(^currentLine) < mr, true) && (doesFit || length(^currentLine) == 0)) {
			currentLine := arrayPush(^currentLine, it);

			currentCoord := faddition(^currentCoord, minSize);
			if (vertical) {
				currentPoint := fpoint(fpointX(^currentPoint), ^currentCoord);
			} else {
				currentPoint := fpoint(^currentCoord, fpointY(^currentPoint));
			}
		} else {
			addLineFn();
			currentLine := [it];
			currentCoord := minSize;

			if (vertical) {
				currentPoint := fpoint(fpointX(^currentPoint), ^currentCoord);
			} else {
				currentPoint := fpoint(^currentCoord, fpointY(^currentPoint));
			}
		}
	});

	addLineFn();
}

bfFit(stageSize : double, blocks : [BFBlock], par : BFParameters) -> [Maybe<Point>] {
	sz = WidthHeight(
		max(if (par.lockWidth) stageSize else 0.0, either(maxA(map(blocks, \b -> b.w)), 0.0)),
		max(if (!par.lockWidth) stageSize else 0.0, either(maxA(map(blocks, \b -> b.h)), 0.0))
	);

	if (par.ordered) {
		state = bfFitBlocks(sz, blocks, par);

		generate(0, length(blocks), \i -> maybeMap(lookupTree(state.p, i), \p -> p.second));
	} else {
		blocksI =
			mergeSort(mapi(blocks, \i, b -> Pair(i, b)), \a : Pair<int, BFBlock>, b : Pair<int, BFBlock> ->
				if (par.vertical) {
					if (a.second.h == b.second.h)
						b2i(a.second.w < b.second.w)
					else
						b2i(a.second.h < b.second.h)
				} else {
					if (a.second.w == b.second.w)
						b2i(a.second.h < b.second.h)
					else
						b2i(a.second.w < b.second.w)
				}
			);

		orderI = map(blocksI, \b -> b.first);

		state = bfFitBlocks(sz, map(blocksI, secondOfPair), par);

		getTreeValues(
			foldi(
				generate(0, length(blocks), \i -> maybeMap(lookupTree(state.p, i), \p -> p.second)),
				makeTree(),
				\i, acc, tr -> setTree(acc, orderI[i], tr)
			)
		);
	}
}

preventInfinity(v : double) -> double {
	if (isNanOrInf(v)) {
		doubleMax;
	} else {
		v;
	}
}

bfFitBlocks(size : WidthHeight, blocks : [BFBlock], par : BFParameters) -> BFState {
	initialState = BFState([Point(0.0, 0.0)], size, makeTree());
	state = ref bfFindNodes(initialState, blocks, par);

	// In case provided size is not big enough to fit all the blocks then try to find the smallest size that fits them
	if (isNone(^state)) {
		blockWidths = map(blocks, \b -> b.w);
		blockHeights = map(blocks, \b -> b.h);

		maxWidth = preventInfinity(dsum(blockWidths) + 1.0);
		maxHeight = preventInfinity(dsum(blockHeights) + 1.0);

		maxAvailableState = bfFindNodes(
			BFState(initialState.l, if (par.lockWidth) WidthHeight(size.width, maxHeight) else WidthHeight(maxWidth, size.height), makeTree()),
			blocks,
			par
		);
		minSize = ref WidthHeight(
			max(size.width, either(maxA(blockWidths), size.width) + 1.0),
			max(size.height, either(maxA(blockHeights), size.height) + 1.0)
		);
		// If the stage with provided width (height if !par.lockWidth) and max content height (width if !par.lockWidth) can't fit all the blocks
		// then try to find the smallest width (height if !par.lockWidth) that fits them
		if (isNone(maxAvailableState)) {
			maxSize = ref WidthHeight(
				if (!par.lockWidth) ^minSize.width else maxWidth,
				if (par.lockWidth) ^minSize.height else maxHeight
			);

			maybeApply(
				bfFitBlocksBinarySearch(initialState, blocks, par, minSize, maxSize, !par.lockWidth),
				\newState -> {
					minSize := WidthHeight(
						max(^minSize.width, newState.s.width),
						max(^minSize.height, newState.s.height)
					);
				}
			);
		}
		maxSize = ref WidthHeight(
			if (par.lockWidth) ^minSize.width else maxWidth,
			if (!par.lockWidth) ^minSize.height else maxHeight
		);
		state := bfFitBlocksBinarySearch(initialState, blocks, par, minSize, maxSize, par.lockWidth);
	}

	either(^state, initialState)
	|> (\s -> {
		if (!par.vertical && par.isRTL) {
			dx = foldTree(s.p, size.width, \__, p, acc -> min(acc, size.width - p.second.x - p.first.w));

			BFState(s with
				p = mapTree(s.p, \p ->
					Pair(
						p.first,
						Point(
							size.width - p.second.x - p.first.w - dx,
							p.second.y
						)
					)
				)
			)
		} else {
			s;
		}
	})
}

bfFitBlocksBinarySearch(initialState : BFState, blocks : [BFBlock], par : BFParameters, minSize : ref WidthHeight, maxSize : ref WidthHeight, lockWidth : bool) -> Maybe<BFState> {
	state = ref None();
	lastState = ref Some(initialState);

	// Perform single binary search for final size refinement
	while(\ -> isNone(^state), \ -> {
		midSize = WidthHeight(
			if (lockWidth) ^maxSize.width else (^minSize.width / 2.0 + ^maxSize.width / 2.0),
			if (!lockWidth) ^maxSize.height else (^minSize.height / 2.0 + ^maxSize.height / 2.0)
		);

		eitherFn(
			// Check if we can fit all the blocks
			bfFindNodes(BFState(initialState.l, midSize, makeTree()), blocks, par),
			\newState -> {
				maxSize := midSize;

				if (
					if (!lockWidth) {
						round(^minSize.width) < round(^maxSize.width) && midSize.width >= ^minSize.width;
					} else {
						round(^minSize.height) < round(^maxSize.height) && midSize.height >= ^minSize.height;
					}
				) {
					// Save the state if we haven't come to the end of the binary search (state fits all the blocks but not exactly the smallest one)
					lastState := Some(newState);
				} else {
					// otherwise return current state
					state := Some(newState);
				}
			},
			\ -> {
				if (
					if (!lockWidth) {
						^minSize.width >= ^maxSize.width || midSize.width <= ^minSize.width;
					} else {
						^minSize.height >= ^maxSize.height || midSize.height <= ^minSize.height;
					}
				) {
					// Return the last state if we've come to the end of the binary search
					state := ^lastState;
				} else {
					// otherwise increase min size
					minSize := WidthHeight(
						if (lockWidth) ^maxSize.width else midSize.width + 1.0,
						if (!lockWidth) ^maxSize.height else midSize.height + 1.0
					);
				}
			}
		);
	});

	^state;
}

bfFindNodes(state : BFState, blocks : [BFBlock], par : BFParameters) -> Maybe<BFState> {
	foldi(
		blocks,
		Some(state),
		\i, accM, block -> {
			maybeBind(accM, \acc -> bfFindNode(i, acc, block, par));
		}
	);
}

bfFindNode(i : int, state : BFState, block : BFBlock, par : BFParameters) -> Maybe<BFState> {
	if (block.w == 0.0 || block.h == 0.0) {
		Some(state)
	} else {
		maybeBind(
			fold(enumFromTo(0, length(state.l) - 1), None(), \accM : Maybe<Point>, l -> {
				if (par.vertical) {
					if (state.l[l].y <= state.s.height - block.h && (if (par.lockWidth) state.l[l].x <= state.s.width - block.w else true)) {
						p = getBFLinePoint(state.l, l, block, par);

						if (checkBFMaxRows(state, block, p, par) && eitherMap(accM, \acc -> p.x < acc.x, true)) {
							Some(p);
						} else {
							accM;
						}
					} else {
						accM;
					}
				} else {
					if (state.l[l].x <= state.s.width - block.w && (par.lockWidth || state.l[l].y <= state.s.height - block.h)) {
						p = getBFLinePoint(state.l, l, block, par);

						if (checkBFMaxRows(state, block, p, par) && eitherMap(accM, \acc -> p.y < acc.y, true)) {
							Some(p);
						} else {
							accM;
						}
					} else {
						accM;
					}
				}
			}),
			\p -> {
				Some(BFState(updateBFLine(state, block, p, par), state.s, setTree(state.p, i, Pair(block, p))));
			}
		);
	}
}

updateBFLine(state : BFState, block : BFBlock, point : Point, par : BFParameters) -> [Point] {
	(if (par.vertical) {
		i = ref 0;
		lastX = ref 0.0;

		filter(state.l, \l ->
			if (l.y <= point.y + block.h) {
				lastX := l.x;

				if (l.y < point.y) {
					i := ^i + 1;

					true;
				} else {
					false;
				}
			} else {
				!par.ordered || l.x >= point.x
			}
		)
		|> (\ln -> {
			insertArray(
				insertArray(
					ln,
					^i,
					Point(if (par.wrapNewColumn) max(^lastX, point.x) else ^lastX, point.y + block.h)
				),
				^i,
				Point(preventInfinity(point.x + block.w), point.y)
			)
		});
	} else {
		i = ref 0;
		lastY = ref 0.0;

		filter(state.l, \l ->
			if (l.x <= point.x + block.w) {
				lastY := l.y;

				if (l.x < point.x) {
					i := ^i + 1;

					true;
				} else {
					false;
				}
			} else {
				!par.ordered || l.y >= point.y
			}
		)
		|> (\ln -> {
			insertArray(
				insertArray(
					ln,
					^i,
					Point(point.x + block.w, if (par.wrapNewRow) max(^lastY, point.y) else ^lastY)
				),
				^i,
				Point(point.x, preventInfinity(point.y + block.h))
			)
		})
	})
	|> (\ln ->
		if (par.wrapNewColumn) {
			p = arrayPush(getTreeValues(state.p), Pair(block, point));

			map(ln, \l ->
				Point(
					fold(
						p,
						l.x,
						\acc, pt ->
							if (pt.second.x < l.x && pt.second.x + pt.first.w > l.x)
								max(acc, pt.second.x + pt.first.w)
							else
								acc
					),
					l.y
				)
			);
		} else {
			ln
		}
	)
	|> (\ln ->
		if (par.wrapNewRow) {
			p = arrayPush(getTreeValues(state.p), Pair(block, point));

			map(ln, \l ->
				Point(
					l.x,
					fold(
						p,
						l.y,
						\acc, pt ->
							if (pt.second.y < l.y && pt.second.y + pt.first.h > l.y)
								max(acc, pt.second.y + pt.first.h)
							else
								acc
					)
				)
			);
		} else {
			ln
		}
	)
}

getBFLinePoint(line : [Point], i : int, block : BFBlock, par : BFParameters) -> Point {
	if (par.vertical) {
		minY = line[i].y;
		maxY = minY + block.h;

		fold(subrange(line, i, length(line)), 0.0, \acc, l -> {
			if (l.y >= minY && l.y < maxY && l.x > acc) {
				l.x;
			} else {
				acc;
			}
		})
		|> (\f -> Point(f, minY))
	} else {
		minX = line[i].x;
		maxX = minX + block.w;

		fold(tailFrom(line, i), 0.0, \acc, l -> {
			if (l.x >= minX && l.x < maxX && l.y > acc) {
				l.y;
			} else {
				acc;
			}
		})
		|> (\f -> Point(minX, f))
	}
}

checkBFMaxRows(state : BFState, block : BFBlock, point : Point, par : BFParameters) -> bool {
	eitherMap(
		par.maxRows,
		\mr -> {
			filteredTree = filterTree(state.p, \k, v -> if (par.vertical) v.second.y == 0.0 else v.second.x == 0.0);

			if (sizeTree(filteredTree) < mr) {
				true
			} else {
				maxSize =
					foldTree(filteredTree, 0.0, \k, v, acc ->
						if (par.vertical) {
							if (v.second.x > acc)
								v.second.x
							else
								acc;
						} else {
							if (v.second.y > acc)
								v.second.y
							else
								acc;
						}
					);

				if (par.vertical)
					point.x <= maxSize
				else
					point.y <= maxSize;
			}
		},
		true
	)
}

SelectTGroupFixed(values : Transform<[?]>, makeTropicFn : (index :  Transform<int>, id : int, ?) -> Tropic, threshold : Transform<int>) -> Tropic {
	TIf(
		flessi(flength(values), threshold),
		SelectTGroup(values, makeTropicFn),
		TSelect(values, \vals ->
			mapi(vals, \i, v -> makeTropicFn(const(i), i, v))
			|> TGroup
		)
	)
}

TFlex(items : Transform<[Tropic]>, style : [TFlexStyle]) -> Tropic {
	vertical = contains(style, TVertical());
	order = tryExtractStruct(style, TOrder(const([])));
	gridEnabled = extractStruct(style, TEnabled(const(true))).enabled;
	animation = tryExtractStruct(style, TAnimationTimer(LazyDeltaTimer(make(0.0), nop, nop)));
	wrap = extractStruct(style, TWrap(0)).wrap;
	stageSizeB = make(0.);
	lazyRenderingMode = tryExtractStruct(style, TFlexibleGridLazyRenderingMode(makeWH(), makePoint()));
	availableMinMax = extractStruct(style, TAvailableMinMax(stageSizeB, stageSizeB));
	alignment : TFlexAlignment =
		if (contains(style, CenterAlign()))
			CenterAlign()
		else if (contains(style, EndAlign()))
			EndAlign()
		else
			either(tryExtractStruct(style, TAlign(zero, zero)), StartAlign());
	alignBaselines = contains(style, TBaselineAlign());
	arrayThreshold = extractStruct(style, TArrayThreshold(const(ARRAY_DIFF_TRESHOLD))).threshold;
	spacing = extractStruct(style, TSpacing(zero, zero));
	spacingView = tryExtractStruct(style, TSpacingView(TEmpty(), TEmpty()));
	spacingB = if (!vertical) spacing.x else spacing.y;
	availableB = make(0.);
	balanced = contains(style, TBalanced());
	preventOverflow = contains(style, TPreventOverflow());
	minMaxSizeLerp = extractStruct(style, TMinMaxSizeLerp(const(0.0))).factor;

	isRTL = extractStruct(style, TSetRTL(getDefaultRtl())).rtl;
	isSameSize = contains(style, TSameSize());

	sameSizeWH : DynamicBehaviour<WidthHeight> = make(zeroWH);
	sameSizeBaseline : DynamicBehaviour<double> = make(0.0);
	sameSizeMinWH : DynamicBehaviour<WidthHeight> = make(zeroWH);
	sameSizeMaxWH : DynamicBehaviour<WidthHeight> = make(zeroWH);
	firstItemWH = makeWH();

	itemsB0 =
		fmap(items, \it -> {
			flexibleGridItemId := ^flexibleGridItemId + 1;

			TFlexibleGridItem(
				^flexibleGridItemId,
				TBorderTDir(zero, zero, spacing.x, spacing.y, it, isRTL),
				make(const(zeroPoint)),
				if (isSameSize) sameSizeWH else make(zeroWH),
				if (isSameSize) sameSizeBaseline else make(0.0),
				if (isSameSize) sameSizeMinWH else make(zeroWH),
				if (isSameSize) sameSizeMaxWH else make(zeroWH),
				make(Point(1.0, 0.0)),
				make(const(zeroWH)),
				make(const(zeroWH)),
				make(false),
				make(false),
			)
		});
	// To protect itemsB0 fn from being called multiple times for each item
	itemsB = fsubselect(itemsB0, FLift(\v -> const(v)));

	rootItem = make(TFlexibleGridItem2TFlexibleGridConstantItem(emptyTFlexibleGridItem));
	contentSize = fsubselect(rootItem, FLift(\cs -> fwh(fsubtract(fmax(fwidth(cs.wh), spacing.x), spacing.x), fsubtract(fmax(fheight(cs.wh), spacing.y), spacing.y))));
	contentMinSize = fsubselect(rootItem, FLift(\cs -> fwh(fsubtract(fmax(fwidth(cs.minWH), spacing.x), spacing.x), fsubtract(fmax(fheight(cs.minWH), spacing.y), spacing.y))));
	contentMaxSize = fsubselect(rootItem, FLift(\cs -> fwh(fsubtract(fmax(fwidth(cs.maxWH), spacing.x), spacing.x), fsubtract(fmax(fheight(cs.maxWH), spacing.y), spacing.y))));
	contentFillers = fsubselect(rootItem, FLift(\cs -> cs.fillers));
	contentBaseline = fsubselect(rootItem, FLift(\cs -> cs.baseline));

	itemsMinSize = fselect3(fsubmap(itemsB, \it -> it.minWH), spacing.x, spacing.y, \v, sx, sy -> WidthHeight(either(maxA(map(v, \vv -> vv.width)), sx) - sx, either(maxA(map(v, \vv -> vv.height)), sy) - sy));
	itemsMaxSize = fselect3(fsubmap(itemsB, \it -> it.maxWH), spacing.x, spacing.y, \v, sx, sy -> WidthHeight(max(dsum(map(v, \vv -> vv.width)), sx) - sx, either(maxA(map(v, \vv -> vv.height)), sy) - sy));

	item2Tropic = \item : TFlexibleGridItem, isFirst : Transform<bool> -> {
		translatePoint = fsubselect(item.tr, FLift(idfn));
		TIfLazy(if (isSameSize || isSome(lazyRenderingMode)) isFirst else const(true), \b -> {
			eitherMap(lazyRenderingMode, \lrm -> {
					if (b)
						TInspect([ISize(firstItemWH)],
							TInspect([ISize(item.wh), IMinSize(item.minWH), IMaxSize(item.maxWH), IBaseline(item.baseline), IFillers(item.fillers)], item.t)
						)
					else {
						showInitialSize = make(!b);
						showItem0 =
							if (vertical)
								fselect4(fwidth(item.wh), fpointX(translatePoint), fwidth(lrm.viewport), fpointX(lrm.scrollPosition),
									\w, trX, vw, spX -> {pos = trX - spX; pos >= -w && pos <= vw}
								)
							else
								fselect4(fheight(item.wh), fpointY(translatePoint), fheight(lrm.viewport), fpointY(lrm.scrollPosition),
									\h, trY, vh, spY -> {pos = trY - spY; pos >= -h && pos <= vh}
								);
						showItem = fguard(showItem0, make(false));
						TInspect(
							[ISize(item.wh), IMinSize(item.minWH), IMaxSize(item.maxWH), IBaseline(item.baseline), IFillers(item.fillers)],
							TGroup2(
								TShow(showInitialSize, TSized(firstItemWH)),
								TShowKeepMetrics(showItem.first, item.t)
							)
						)
						|> (\t -> TConstruct([\ -> fwhen(showItem.first, \ -> nextDistinct(showInitialSize, false)), showItem.second], t))
					}
				},
				TInspect(
					if (b) {
						[ISize(item.wh), IMinSize(item.minWH), IMaxSize(item.maxWH), IBaseline(item.baseline), IFillers(item.fillers)];
					} else {
						[];
					},
					item.t
				)
			)
			|> (\f ->
				if (isSameSize) {
					visible = make(false);
					TRenderable(visible, TShowKeepMetrics(fstall(visible, 1), f));
				} else {
					f;
				}
			)
		})
		|> (\f ->
			TAvailable(
				f,
				TSized(fsubselect(item.av, idfn |> FLift))
			)
		)
		|> (\f ->
			eitherMap(
				spacingView,
				\sv -> {
					alignWH = fsubselect(item.alignWH, FLift(idfn));
					sizeWithouSpacing = fwh(
						fsubtract(fwidth(alignWH), spacing.x),
						fsubtract(fheight(alignWH), spacing.y)
					);

					TGroup2(
						if (vertical) {
							TShow(
								item.addSpacingY,
								TLines2(
									TSized(sizeWithouSpacing),
									TAvailable(sv.y, TSized(fwh(fwidth(sizeWithouSpacing), spacing.y)))
								)
							)
						} else {
							TShow(
								item.addSpacingX,
								TCols2Dir(
									TSized(sizeWithouSpacing),
									TAvailable(sv.x, TSized(fwh(spacing.x, fheight(sizeWithouSpacing)))),
									isRTL
								)
							)
						},
						f
					)
				},
				f,
			)
		)
		|> (\tropic ->
			eitherMap(
				animation,
				\a -> {
					pos = make(None());
					trigger = ffuse(translatePoint);

					TEasingAnimation(
						a.deltaTimer,
						0.2,
						CubicBezierEasing(0.4, 0.0, 0.2, 1.0),
						trigger.first,
						\tr -> eitherMap(getValue(pos), \p -> Some(Pair(p, tr)), None()),
						\tr -> nextDistinct(pos, Some(tr.second)),
						\tr, p -> nextDistinct(pos, Some(Point(lerp(tr.first.x, tr.second.x, p), lerp(tr.first.y, tr.second.y, p)))),
						TTranslate(feither(pos, translatePoint), tropic)
					)
					|> (\f -> TConstruct(trigger.second, f))
					|> TOnConstruct(\ -> nextDistinct(pos, Some(fgetValue(getValue(item.tr)))))
				},
				TTranslate(translatePoint, tropic)
			)
		)
		|> (\f ->
			eitherMap(
				spacingView,
				\sv -> {
					itemSize = fselect2Lift(fsubselect(item.alignWH, FLift(idfn)), fsubselect(item.tr, FLift(idfn)), \awh, tr -> WidthHeight(tr.x + awh.width, tr.y + awh.height));
					itemSizeWithouSpacing = fwh(
						fsubtract(fwidth(itemSize), spacing.x),
						fsubtract(fheight(itemSize), spacing.y)
					);
					sizeWithouSpacing = contentSize;

					TGroup2(
						if (vertical) {
							TShow(
								item.addSpacingX,
								TCols2Dir(
									TSized(itemSizeWithouSpacing),
									TAvailable(sv.x, TSized(fwh(spacing.x, fheight(sizeWithouSpacing)))),
									isRTL
								)
							)
						} else {
							TShow(
								item.addSpacingY,
								TLines2(
									TSized(itemSizeWithouSpacing),
									TAvailable(sv.y, TSized(fwh(fwidth(sizeWithouSpacing), spacing.y)))
								)
							)
						},
						f
					)
				},
				f,
			)
		);
	}

	SelectTGroupFixed(itemsB, \idx, __, item -> item2Tropic(item, feq(idx, 0)), arrayThreshold)
	|> (\f ->
		TransformTAcc(\t2a, p, s, mo -> {
			b1 = t2a(f, p, s, mo);
			inspectAvailable = fconnect(if (vertical) p.maxX else p.maxY, availableB);
			inspectStageSize = fconnect(if (!vertical) p.maxX else p.maxY, stageSizeB);

			TAcc(
				b1.form,
				TFormMetrics(
					fwidth(contentSize),
					fheight(contentSize),
					contentBaseline
				),
				// Use actual content size if wrapping ignores available size
				fwidth(if (!vertical && wrap <= 0 || preventOverflow) itemsMinSize else contentMinSize),
				fheight(if (vertical && wrap <= 0 || preventOverflow) itemsMinSize else contentMinSize),
				if (!vertical && wrap <= 0 || preventOverflow) const(doubleMax) else fwidth(contentMaxSize),
				if (vertical && wrap <= 0 || preventOverflow) const(doubleMax) else fheight(contentMaxSize),
				if (!vertical && wrap <= 0 || preventOverflow) const(1.0) else fpointX(contentFillers),
				if (vertical && wrap <= 0 || preventOverflow) const(1.0) else fpointY(contentFillers),
				const(false),
				false,
				false,
				concat(b1.disposers, [inspectAvailable, inspectStageSize])
			)
		})
	)
	|> (\f -> {
		itemsOrderedB = fdelayUntilNextFrameRendered(eitherMap(order, \or -> forder(fselect(itemsB, FLift(idfn)), or.order), itemsB));
		availableMinMaxB = fthrottleUntilNextFrameRendered(ftransistor(gridEnabled, fpair(faddition(availableMinMax.min, spacingB), faddition(availableMinMax.max, spacingB))));

		TConstruct(
			[
				make3Subscribe(
					fsubmap(
						itemsOrderedB,
						\it ->
							fpair(
								const(it),
								if (wrap > 0) {
									fwh(zero, zero)
								} else if (isSameSize) {
									sameSizeMinWH
								} else {
									fwh(
										fwidth(fif(feq(fpointX(it.fillers), 0.0), it.wh,
											fselect3(it.minWH, it.maxWH, if (vertical) zero else minMaxSizeLerp, \minWH, maxWH, factor ->
												WidthHeight(lerp(minWH.width, maxWH.width, factor), lerp(minWH.height, maxWH.height, factor))))),
										fheight(fif(feq(fpointY(it.fillers), 0.0), it.wh,
											fselect3(it.minWH, it.maxWH, if (!vertical) zero else minMaxSizeLerp, \minWH, maxWH, factor ->
												WidthHeight(lerp(minWH.width, maxWH.width, factor), lerp(minWH.height, maxWH.height, factor)))))
									)
								}
							)
					),
					availableMinMaxB,
					fthrottleUntilNextFrameRendered(faddition(availableB, if (vertical) spacing.x else spacing.y)),
					\itms, stageSize, available -> {
						next(rootItem, fitTFlex(itms, stageSize.first, stageSize.second, available, vertical, alignment, alignBaselines, wrap, isRTL, balanced, preventOverflow));
					}
				)
			],
			f
		)
	})
}

mergeTFlexConstantItemsHorizontal(t1 : TFlexibleGridConstantItem, t2 : TFlexibleGridConstantItem, alignBaselines : bool) -> TFlexibleGridConstantItem {
	tr = make(const(zeroPoint));
	trB = fsubselect(tr, idfn |> FLift);
	av = make(const(zeroWH));
	avB = fsubselect(av, idfn |> FLift);
	alignWH = make(const(zeroWH));
	alignWHB = fsubselect(alignWH, idfn |> FLift);

	baseline = fmax(t1.baseline, t2.baseline);
	minHgtB = fmax(fheight(t1.minWH), fheight(t2.minWH));
	avHgtB = fmax(fheight(avB), minHgtB);

	da =
		distributeAsks(
			fpointX(t1.fillers),
			fpointX(t2.fillers),
			fwidth(t1.minWH),
			fwidth(t2.minWH),
			fwidth(t1.maxWH),
			fwidth(t2.maxWH),
			fwidth(avB),
			const(false),
			const(false)
		);

	uns = ref nop;
	uns := subscribe2(tr, \__ -> {
		next(t1.av, fwh(da.first, avHgtB));
		next(t2.av, fwh(da.second, avHgtB));

		next(t1.alignWH, fwh(fwidth(t1.wh), fheight(alignWHB)));
		next(t2.alignWH, fwh(fwidth(t2.wh), fheight(alignWHB)));

		next(
			t1.tr,
			if (!alignBaselines)
				trB
			else
				fpoint(fpointX(trB), faddition(fpointY(trB), fsubtract(baseline, t1.baseline)))
		);
		next(
			t2.tr,
			fpoint(
				faddition(fpointX(trB), fwidth(t1.wh)),
				if (!alignBaselines)
					fpointY(trB)
				else
					faddition(fpointY(trB), fsubtract(baseline, t2.baseline))
			)
		);

		^uns();
		uns := nop;
	});

	flexibleGridItemId := ^flexibleGridItemId + 1;

	TFlexibleGridConstantItem(
		^flexibleGridItemId,
		TEmpty(),
		tr,
		fwh(
			faddition(fwidth(t1.wh), fwidth(t2.wh)),
			fmax(fheight(t1.wh), fheight(t2.wh))
		),
		baseline,
		fwh(
			faddition(fwidth(t1.minWH), fwidth(t2.minWH)),
			minHgtB
		),
		fwh(
			faddition(fwidth(t1.maxWH), fwidth(t2.maxWH)),
			fmax(fheight(t1.maxWH), fheight(t2.maxWH))
		),
		fpoint(
			faddition(fpointX(t1.fillers), fpointX(t2.fillers)),
			fmax(fpointY(t1.fillers), fpointY(t2.fillers))
		),
		av,
		alignWH,
		t1.addSpacingX,
		t1.addSpacingY,
		max(t1.rows, t2.rows),
		t1.columns + t2.columns
	);
}

mergeTFlexConstantItemsVertical(t1 : TFlexibleGridConstantItem, t2 : TFlexibleGridConstantItem) -> TFlexibleGridConstantItem {
	tr = make(const(zeroPoint));
	trB = fsubselect(tr, idfn |> FLift);
	av = make(const(zeroWH));
	avB = fsubselect(av, idfn |> FLift);
	alignWH = make(const(zeroWH));
	alignWHB = fsubselect(alignWH, idfn |> FLift);

	minWdB = fmax(fwidth(t1.minWH), fwidth(t2.minWH));
	avWdB = fmax(fwidth(avB), minWdB);

	da =
		distributeAsks(
			fpointY(t1.fillers),
			fpointY(t2.fillers),
			fheight(t1.minWH),
			fheight(t2.minWH),
			fheight(t1.maxWH),
			fheight(t2.maxWH),
			fheight(avB),
			const(false),
			const(false)
		);

	uns = ref nop;
	uns := subscribe2(tr, \__ -> {
		next(t1.av, fwh(avWdB, da.first));
		next(t2.av, fwh(avWdB, da.second));

		next(t1.alignWH, fwh(fwidth(alignWHB), fheight(t1.wh)));
		next(t2.alignWH, fwh(fwidth(alignWHB), fheight(t2.wh)));

		next(t1.tr, trB);
		next(t2.tr, fpoint(fpointX(trB), faddition(fpointY(trB), fheight(t1.wh))));

		^uns();
		uns := nop;
	});

	flexibleGridItemId := ^flexibleGridItemId + 1;

	TFlexibleGridConstantItem(
		^flexibleGridItemId,
		TEmpty(),
		tr,
		fwh(
			fmax(fwidth(t1.wh), fwidth(t2.wh)),
			faddition(fheight(t1.wh), fheight(t2.wh))
		),
		faddition(fheight(t1.wh), t2.baseline),
		fwh(
			minWdB,
			faddition(fheight(t1.minWH), fheight(t2.minWH))
		),
		fwh(
			fmax(fwidth(t1.maxWH), fwidth(t2.maxWH)),
			faddition(fheight(t1.maxWH), fheight(t2.maxWH))
		),
		fpoint(
			fmax(fpointX(t1.fillers), fpointX(t2.fillers)),
			faddition(fpointY(t1.fillers), fpointY(t2.fillers))
		),
		av,
		alignWH,
		t1.addSpacingX,
		t1.addSpacingY,
		t1.rows + t2.rows,
		max(t1.columns, t2.columns)
	);
}

alignTFlexConstantItems(
	t : TFlexibleGridConstantItem,
	vertical : bool,
	alignment : TFlexAlignment
) -> TFlexibleGridConstantItem {
	if (alignment != StartAlign()) {
		tr = make(const(zeroPoint));
		trB = fsubselect(tr, idfn |> FLift);
		avB = fsubselect(t.alignWH, idfn |> FLift);

		uns = ref nop;
		uns := subscribe2(tr, \__ -> {
			next(t.tr, fpoint(
				faddition(
					fpointX(trB),
					if (vertical)
						zero
					else
						fmax(
							switch (alignment) {
								StartAlign(): zero;
								CenterAlign(): fdivide(fsubtract(fwidth(avB), fwidth(t.wh)), const(2.0));
								EndAlign(): fsubtract(fwidth(avB), fwidth(t.wh));
								TAlign(xalign, __): fmultiply(fsubtract(fwidth(avB), fwidth(t.wh)), xalign);
							},
							zero
						)
				),
				faddition(
					fpointY(trB),
					if (vertical)
						fmax(
							switch (alignment) {
								StartAlign(): zero;
								CenterAlign(): fdivide(fsubtract(fheight(avB), fheight(t.wh)), const(2.0));
								EndAlign(): fsubtract(fheight(avB), fheight(t.wh));
								TAlign(__, yalign): fmultiply(fsubtract(fheight(avB), fheight(t.wh)), yalign);
							},
							zero
						)
					else
						zero
				)
			));

			^uns();
			uns := nop;
		});

		TFlexibleGridConstantItem(
			t with tr = tr
		);
	} else {
		t
	}
}

fitTFlex(
	items : [Pair<TFlexibleGridItem, WidthHeight>],
	sizeMin : double,
	sizeMax : double,
	available : double,
	vertical : bool,
	alignment0 : TFlexAlignment,
	alignBaselines : bool,
	wrap0 : int,
	isRTL : bool,
	balanced : bool,
	preventOverflow: bool
) -> TFlexibleGridConstantItem {
	currentLine = ref [];
	lines = ref [];
	size = WidthHeight(
		if (vertical) available else sizeMax,
		if (vertical) sizeMax else available
	);
	wdB = if (vertical) const(available) else const(sizeMin);
	hgtB = if (vertical) const(sizeMin) else const(available);

	alignment = if (vertical && isRTL) {
		if (alignment0 == StartAlign())
			EndAlign()
		else if (alignment0 == EndAlign())
			StartAlign()
		else
			alignment0
	} else {
		alignment0
	};

	addLineFn = \ -> {
		if (length(^currentLine) > 0) {
			t =
				foldBinary(
					mapi(map(^currentLine, TFlexibleGridItem2TFlexibleGridConstantItem), \i, l -> {
						next(if (vertical) l.addSpacingY else l.addSpacingX, i < length(^currentLine) - 1);

						switch (alignment) {
							TAlign(__, __): alignTFlexConstantItems(l, !vertical, alignment);
							default: l;
						}
					}),
					\t1, t2 ->
						if (vertical)
							mergeTFlexConstantItemsVertical(t1, t2)
						else
							mergeTFlexConstantItemsHorizontal(
								if (isRTL) t2 else t1,
								if (isRTL) t1 else t2,
								alignBaselines
							)
				);
			lines := arrayPush(^lines, t);
		}
	}

	wrap = if (wrap0 > 0) {
		wrap0;
	} else if (balanced) {
		totalSize = dsum(map(items, \item -> if (vertical) item.second.height else item.second.width));
		totalLines = dceil(totalSize / sizeMax);
		ceil(i2d(length(items)) / totalLines);
	} else {
		0;
	};

	if (wrap > 0) {
		iter(items, \item -> {
			if (length(^currentLine) == 0 || length(^currentLine) < wrap) {
				currentLine := arrayPush(^currentLine, item.first);
			} else {
				addLineFn();
				currentLine := [item.first];
			}
		});

		addLineFn();
	} else {
		par = BFParameters(
			!vertical,
			vertical,
			true,
			vertical,
			None(),
			if (preventOverflow) vertical else !vertical,
			false
		);
		blocks = map(items, \item -> BFBlock(item.second.width, item.second.height));
		state = bfFitBlocks(size, blocks, par);
		lastPoint = ref Point(0.0, 0.0);

		newLines = fold(tree2pairs(state.p), [], \acc : [[TFlexibleGridItem]], p : Pair<int, Pair<BFBlock, Point>> -> {
			item = items[p.first].first;

			if (length(acc) == 0) {
				[[item]];
			} else {
				lastLine = lastElement(acc, []);
				if (length(lastLine) == 0 || (if (vertical) ^lastPoint.x == p.second.second.x else ^lastPoint.y == p.second.second.y)) {
					lastPoint := p.second.second;
					replace(acc, length(acc) - 1, arrayPush(lastLine, item));
				} else {
					lastPoint := p.second.second;
					arrayPush(acc, [item]);
				}
			}
		});

		iter(newLines, \line -> {
			currentLine := line;
			addLineFn();
		});
	}

	if (length(^lines) > 0) {
		t =
			foldBinary(
				// Adding emptyTFlexibleGridItem to enforce mergeTFlexConstantItems* to be called at least once to distribute the available space
				arrayPush(mapi(^lines, \i, l -> {
					next(if (vertical) l.addSpacingX else l.addSpacingY, i < length(^lines) - 1);

					alignTFlexConstantItems(l, vertical, alignment);
				}), TFlexibleGridItem2TFlexibleGridConstantItem(emptyTFlexibleGridItem)),
				\t1, t2 ->
					if (vertical)
						mergeTFlexConstantItemsHorizontal(t1, t2, false)
					else
						mergeTFlexConstantItemsVertical(t1, t2)
			);

		next(t.av, fwh(fmax(wdB, fwidth(t.minWH)), fmax(hgtB, fheight(t.minWH))));
		next(t.alignWH, t.wh);
		next(
			t.tr,
			fpoint(
				fmax(
					switch (alignment) {
						StartAlign(): zero;
						CenterAlign(): if (vertical) zero else fdivide(fsubtract(wdB, fwidth(t.wh)), const(2.0));
						EndAlign(): if (vertical) zero else fsubtract(wdB, fwidth(t.wh));
						TAlign(xalign, __): fmultiply(fsubtract(wdB, fwidth(t.wh)), xalign);
					},
					zero
				),
				fmax(
					switch (alignment) {
						StartAlign(): zero;
						CenterAlign(): if (vertical) fdivide(fsubtract(hgtB, fheight(t.wh)), const(2.0)) else zero;
						EndAlign(): if (vertical) fsubtract(hgtB, fheight(t.wh)) else zero;
						TAlign(__, yalign): fmultiply(fsubtract(hgtB, fheight(t.wh)), yalign);
					},
					zero
				)
			)
		);

		t;
	} else {
		TFlexibleGridItem2TFlexibleGridConstantItem(emptyTFlexibleGridItem)
	}
}