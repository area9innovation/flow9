import tropic/selecttarray;
import tropic/tropic_gui;
import ui/animate/teasing;
import form/gui;
import form/paragraphalignments;
import tropic/tropic2form;

export {

	TFlexibleGrid(items : Transform<[Tropic]>, style : [TFlexibleGridStyle]) -> Tropic;
		FlexibleGridAlignment ::= RelativeAlignment, CenterAlign, TightWidth;
		TFlexibleGridStyle ::= TWrapNewRow, TWrapNewColumn, TVertical, TMaxRows, FlexibleGridAlignment,
			TAnimationTimer, TOrder, TLockWidth, TEnabled, TSetRTL, TSameSize, TFlexibleGridContentSizeInspector, TFlexibleGridMaxContentWidthInspector,
			TBaselineAlign, TFillersSupport, TAvailableMinMax, TArrayThreshold, TFlexibleGridLazyRenderingMode, TSpacing;

			TWrapNewRow(wrap : bool); // New row should be below all the elements in the previous one (true by default for horizontal grid)
			TWrapNewColumn(wrap : bool); // New column should be to the right of all the elements in the previous one (true by default for vertical grid)
			TVertical(); // Pack elements vertically and bound them with available height
			TMaxRows(rows : int); // Max elements in a first column (Max elements in a first row if TVertical is passed)
			TAnimationTimer(deltaTimer : LazyDeltaTimer); // Enables animation
			TOrder(order : Transform<[int]>); // Set items order
			TLockWidth(lock : bool); // If true size only grows in height not in width (false for TVertical and true for horizontal grid)
			TSameSize(); // Some optimization for performance boosting in case of same sized items
			TBaselineAlign(); // Align items to baseline (ignored with TVertical)
			TFillersSupport(); // Allow size of the items to grow by available space
			TCenterSupport() -> TFlexibleGridStyle { TFillersSupport(); };
			TAvailableMinMax(min : Transform<double>, max : Transform<double>);
			TArrayThreshold(threshold : Transform<int>); // Fine efficiency tuning : what algorithm to use depending on array size
			TSpacing(x : Transform<double>, y : Transform<double>); // Spacing between items

			// Size of the box, which content occupies inside the grid. Less or equal to outer grid box size
			TFlexibleGridContentSizeInspector(wh : DynamicBehaviour<WidthHeight>);
			// Sum of all content widths
			TFlexibleGridMaxContentWidthInspector(maxWidth : DynamicBehaviour<double>);
			// Renders only items inside a viewport, keeps their metrics when outside
			TFlexibleGridLazyRenderingMode(viewport : Transform<WidthHeight>, scrollPosition : Transform<Point>);

	TFlex(items : Transform<[Tropic]>, style : [TFlexStyle]) -> Tropic;
		TFlexAlignment ::= RelativeAlignment, CenterAlign;
		TFlexStyle ::= TVertical, TMaxRows, FlexibleGridAlignment, TAnimationTimer, TOrder, TEnabled, TSetRTL, TSameSize,
			TBaselineAlign, TAvailableMinMax, TArrayThreshold, TFlexibleGridLazyRenderingMode, TSpacing;
}

TFlexibleGridItem(
	id : int,
	t : Tropic,
	tr : DynamicBehaviour<Transform<Point>>,
	wh : DynamicBehaviour<WidthHeight>,
	baseline : DynamicBehaviour<double>,
	minWH : DynamicBehaviour<WidthHeight>,
	maxWH : DynamicBehaviour<WidthHeight>,
	fillers : DynamicBehaviour<Point>,
	av : DynamicBehaviour<Transform<WidthHeight>>
);

TFlexibleGridConstantItem(
	id : int,
	t : Tropic,
	tr : DynamicBehaviour<Transform<Point>>,
	wh : Transform<WidthHeight>,
	baseline : Transform<double>,
	minWH : Transform<WidthHeight>,
	maxWH : Transform<WidthHeight>,
	fillers : Transform<Point>,
	av : DynamicBehaviour<Transform<WidthHeight>>
);

emptyTFlexibleGridItem = TFlexibleGridItem(-1, TEmpty(), make(const(zeroPoint)), makeWH(), make(0.0), makeWH(), makeWH(), makePoint(), make(const(zeroWH)));
flexibleGridItemId = ref 0;
flexibleGridDeferred = isUrlParameterTrue("flexible_deferred");

TFlexibleGrid(items : Transform<[Tropic]>, style : [TFlexibleGridStyle]) -> Tropic {
	verticalGrid = contains(style, TVertical());
	lockWidth = extractStruct(style, TLockWidth(!verticalGrid)).lock;
	wrapNewRow = extractStruct(style, TWrapNewRow(!verticalGrid)).wrap;
	wrapNewColumn = extractStruct(style, TWrapNewColumn(verticalGrid)).wrap;
	order = tryExtractStruct(style, TOrder(const([])));
	gridEnabled = extractStruct(style, TEnabled(const(true))).enabled;
	animation = tryExtractStruct(style, TAnimationTimer(LazyDeltaTimer(make(0.0), nop, nop)));
	maxRows = maybeMap(tryExtractStruct(style, TMaxRows(0)), \mr -> mr.rows);
	contentSizeInspector = tryExtractStruct(style, TFlexibleGridContentSizeInspector(makeWH()));
	maxContentWidthInspector = tryExtractStruct(style, TFlexibleGridMaxContentWidthInspector(make(0.)));
	stageSizeB = make(0.);
	lazyRenderingMode = tryExtractStruct(style, TFlexibleGridLazyRenderingMode(makeWH(), makePoint()));
	availableMinMax = extractStruct(style, TAvailableMinMax(stageSizeB, stageSizeB));
	alignment : FlexibleGridAlignment =
		if (contains(style, TightWidth()))
			TightWidth()
		else if (contains(style, CenterAlign()))
			CenterAlign()
		else if (contains(style, EndAlign()))
			EndAlign()
		else
			StartAlign();
	alignBaselines = contains(style, TBaselineAlign());
	fillersSupport = contains(style, TFillersSupport()) || alignBaselines;
	arrayThreshold = extractStruct(style, TArrayThreshold(const(ARRAY_DIFF_TRESHOLD))).threshold;
	spacing = extractStruct(style, TSpacing(zero, zero));
	spacingB = if (lockWidth) spacing.x else spacing.y;

	isRTL = extractStruct(style, TSetRTL(getDefaultRtl())).rtl;
	isSameSize = contains(style, TSameSize());

	sameSizeWH : DynamicBehaviour<WidthHeight> = make(zeroWH);
	sameSizeBaseline : DynamicBehaviour<double> = make(0.0);
	sameSizeMinWH : DynamicBehaviour<WidthHeight> = make(zeroWH);
	sameSizeMaxWH : DynamicBehaviour<WidthHeight> = make(zeroWH);
	firstItemWH = makeWH();

	itemsB0 =
		fmap(items, \it -> {
			flexibleGridItemId := ^flexibleGridItemId + 1;

			TFlexibleGridItem(
				^flexibleGridItemId,
				TBorderTDir(zero, zero, spacing.x, spacing.y, it, isRTL),
				make(const(zeroPoint)),
				if (isSameSize) sameSizeWH else make(zeroWH),
				if (isSameSize) sameSizeBaseline else make(0.0),
				if (isSameSize) sameSizeMinWH else make(zeroWH),
				if (isSameSize) sameSizeMaxWH else make(zeroWH),
				make(Point(1.0, 0.0)),
				make(const(zeroWH))
			)
		});
	// To protect itemsB0 fn from being called multiple times for each item
	itemsB = fsubselect(itemsB0, FLift(\v -> const(v)));

	contentBaseline = fsubselect(felementAt(itemsB, const(0), const(emptyTFlexibleGridItem)), FLift(\e : TFlexibleGridItem -> e.baseline));
	contentSize0 =
		fselect3(
			fsubmap(itemsB, \it : TFlexibleGridItem -> fpair(fsubselect(it.tr, idfn |> FLift), it.wh)),
			spacing.x,
			spacing.y,
			\pairs : [Pair<Point, WidthHeight>], spacingX, spacingY-> {
				fold(pairs, Triple(zeroWH, doubleMax, 0.), \acc, v ->
					Triple(
						WidthHeight(
							max(acc.first.width, dfloor(v.second.width + v.first.x - spacingX)),
							max(acc.first.height, dfloor(v.second.height + v.first.y - spacingY))
						),
						min(acc.second, v.first.x),
						acc.third + dfloor(v.second.width - spacingX)
					)
				)
			}
		);

	contentSize = fFirstOfTriple(contentSize0);

	contentMinSize = fselect2(fsubmap(itemsB, \it -> if (lockWidth) fwidth(it.minWH) else fheight(it.minWH)), spacingB, FLift2(\v, sp -> either(maxA(v), sp) - sp));

	parameters =
		BFParameters(
			wrapNewRow,
			wrapNewColumn,
			isSome(order),
			verticalGrid,
			maxRows,
			lockWidth,
			isRTL
		);

	item2Tropic = \item : TFlexibleGridItem, isFirst : Transform<bool> -> {
		translatePoint = fsubselect(item.tr, FLift(idfn));
		TIfLazy(if (isSameSize || isSome(lazyRenderingMode)) isFirst else const(true), \b -> {
			eitherMap(lazyRenderingMode, \lrm -> {
					if (b)
						TInspect([ISize(firstItemWH)],
							TInspect([ISize(item.wh), IMinSize(item.minWH), IMaxSize(item.maxWH), IBaseline(item.baseline)], item.t)
						)
					else {
						showInitialSize = make(!b);
						showItem0 =
							if (verticalGrid)
								fselect4(fwidth(item.wh), fpointX(translatePoint), fwidth(lrm.viewport), fpointX(lrm.scrollPosition),
									\w, trX, vw, spX -> {pos = trX - spX; pos >= -w && pos <= vw}
								)
							else
								fselect4(fheight(item.wh), fpointY(translatePoint), fheight(lrm.viewport), fpointY(lrm.scrollPosition),
									\h, trY, vh, spY -> {pos = trY - spY; pos >= -h && pos <= vh}
								);
						showItem = fguard(showItem0, make(false));
						TInspect(
							[ISize(item.wh), IMinSize(item.minWH), IMaxSize(item.maxWH), IBaseline(item.baseline)],
							TGroup2(
								TShow(showInitialSize, TSized(firstItemWH)),
								TShowKeepMetrics(showItem.first, item.t)
							)
						)
						|> (\t -> TConstruct([\ -> fwhen(showItem.first, \ -> nextDistinct(showInitialSize, false)), showItem.second], t))
					}
				},
				TInspect(
					if (b) {
						[ISize(item.wh), IMinSize(item.minWH), IMaxSize(item.maxWH), IBaseline(item.baseline)];
					} else {
						[];
					},
					item.t
				)
			)
			|> (\f ->
				if (isSameSize) {
					visible = make(false);
					TRenderable(visible, TShowKeepMetrics(fstall(visible, 1), f));
				} else {
					f;
				}
			)
		})
		|> (\f ->
			if (fillersSupport)
				TAvailable(
					f,
					TSized(fsubselect(item.av, idfn |> FLift))
				)
			else
				f
		)
		|> (\tropic ->
			eitherMap(
				animation,
				\a -> {
					pos = make(None());
					trigger = ffuse(translatePoint);

					TEasingAnimation(
						a.deltaTimer,
						0.2,
						CubicBezierEasing(0.4, 0.0, 0.2, 1.0),
						trigger.first,
						\tr -> eitherMap(getValue(pos), \p -> Some(Pair(p, tr)), None()),
						\tr -> nextDistinct(pos, Some(tr.second)),
						\tr, p -> nextDistinct(pos, Some(Point(lerp(tr.first.x, tr.second.x, p), lerp(tr.first.y, tr.second.y, p)))),
						TTranslate(feither(pos, translatePoint), tropic)
					)
					|> (\f -> TConstruct(trigger.second, f))
					|> TOnConstruct(\ -> nextDistinct(pos, Some(fgetValue(getValue(item.tr)))))
				},
				TTranslate(translatePoint, tropic)
			)
		);
	}

	SelectTGroupFixed(itemsB, \idx, __, item -> item2Tropic(item, feq(idx, 0)), arrayThreshold)
	|> (\f ->
		TransformTAcc2(\t2a -> {
				b1 = f |> t2a;

				TAcc(
					b1.form,
					TFormMetrics(
						fwidth(contentSize),
						fheight(contentSize),
						contentBaseline
					),
					if (lockWidth) contentMinSize else fwidth(contentSize),
					if (!lockWidth) contentMinSize else fheight(contentSize),
					if (lockWidth) const(doubleMax) else fwidth(contentSize),
					if (!lockWidth) const(doubleMax) else fheight(contentSize),
					const(b2d(lockWidth)),
					const(b2d(!lockWidth)),
					b1.addFillers,
					false,
					false,
					b1.disposers
				)
			}
		)
	)
	|> (\f ->
		if (fillersSupport) {
			f
		} else switch (alignment) {
			StartAlign(): if (verticalGrid) TAlignTop else if (isRTL) TAlignRight else TAlignLeft
			EndAlign(): if (verticalGrid) TAlignBottom else if (isRTL) TAlignLeft else TAlignRight
			CenterAlign(): if (verticalGrid) TCenterY else TCenterX
			TightWidth(): idfn
		}(f)
	)
	|> (\f ->
		if (fillersSupport) {
			TConstruct(
				[
					if (isSameSize)
						make3Subscribe2(
							fdelayUntilNextFrameRendered(eitherMap(order, \or -> forder(fselect(itemsB, FLift(idfn)), or.order), itemsB)),
							sameSizeMinWH,
							fthrottleUntilNextFrameRendered(ftransistor(gridEnabled, fpair(faddition(availableMinMax.min, spacingB), faddition(availableMinMax.max, spacingB)))),
							\itms, __, stageSize ->
								fitTFlexibleGrid(itms, stageSize.first, stageSize.second, verticalGrid, alignment, alignBaselines, maxRows, isRTL)
						)
					else
						make2Subscribe2(
							fsubmap(
								fdelayUntilNextFrameRendered(eitherMap(order, \or -> forder(fselect(itemsB, FLift(idfn)), or.order), itemsB)),
								\it -> fpair(const(it), fpair(it.minWH, it.maxWH))
							),
							fthrottleUntilNextFrameRendered(ftransistor(gridEnabled, fpair(faddition(availableMinMax.min, spacingB), faddition(availableMinMax.max, spacingB)))),
							\itms, stageSize ->
								fitTFlexibleGrid(map(itms, firstOfPair), stageSize.first, stageSize.second, verticalGrid, alignment, alignBaselines, maxRows, isRTL)
						)
				],
				f
			)
		} else {
			itemTranslations =
				fselect2(
					fsubmap(eitherMap(order, \or -> forder(fselect(itemsB, FLift(idfn)), or.order), itemsB), \it -> it.wh),
					ftransistor(gridEnabled, faddition(availableMinMax.min, spacingB)),
					FLift2(\itemsSizes, stageSize -> {
						blocks = map(itemsSizes, \wh -> BFBlock(wh.width, wh.height));
						bfFit(stageSize, blocks, parameters);
					})
				)
				|> (\tr -> eitherMap(order, \or -> fdeorder(tr, or.order), tr));

			initialRender = ref true;

			TConstruct(
				if (isSameSize) {
					applyTranslationsTrigger = make(false);
					[
						makeSubscribe(itemTranslations, \__ -> reverseBehaviour(applyTranslationsTrigger)),
						makeSubscribe(itemsB, \__ -> reverseBehaviour(applyTranslationsTrigger)),

						makeSubscribe(applyTranslationsTrigger, \__ -> {
							gridItems = fgetValue(itemsB);
							iteri(fgetValue(itemTranslations), \i, p ->
								if (length(gridItems) > i) {
									nextDistinct(gridItems[i].tr, const(either(p, Point(0., 0.))));
								}
							);
						})
					]
				} else [
					make2Subscribe(
						itemTranslations,
						itemsB,
						\tr, gridItems -> {
							iteri(tr, \i, p ->
								if (length(gridItems) > i) {
									fn = \ -> nextDistinct(gridItems[i].tr, const(either(p, Point(0., 0.))));
									if (flexibleGridDeferred && isSome(lazyRenderingMode) && !^initialRender) deferred(fn) else fn()
								}
							)
							initialRender := false;
						}
					)
				],
				f
			)
		}
	)
	|> (\f ->
		eitherMap(
			contentSizeInspector,
			\inspector ->
				TConstruct(
					[
						if (isRTL) {
							\ -> fconnectSelect(contentSize0, inspector.wh, \cs -> WidthHeight(cs.first.width - cs.second, cs.first.height))
						} else {
							\ -> fconnect(contentSize, inspector.wh)
						}
					],
					f
				),
			f
		)
	)
	|> (\f ->
		eitherMap(
			maxContentWidthInspector,
			\inspector ->
				TConstruct(
					[\ -> fconnect(fThirdOfTriple(contentSize0), inspector.maxWidth)],
					f
				),
			f
		)
	)
	|> (\f ->
		TGroup2(
			if (lockWidth)
				TSizedWidth(contentMinSize, 0.0)
			else
				TSizedHeight(0.0, contentMinSize),
			TInspect(
				[if (lockWidth) IAvailableWidth(stageSizeB) else IAvailableHeight(stageSizeB)],
				f
			)
		)
	)
}

foldBinary(a : [?], fn : (e1 : ?, e2 : ?) -> ?) -> ? {
	if (length(a) == 2) {
		fn(a[0], a[1]);
	} else if (length(a) < 2) {
		a[0]
	} else {
		fn(foldBinary(subrange(a, 0, length(a) / 2), fn), foldBinary(subrange(a, length(a) / 2, length(a) - length(a) / 2), fn));
	}
}

TFlexibleGridItem2TFlexibleGridConstantItem(t : TFlexibleGridItem) -> TFlexibleGridConstantItem {
	TFlexibleGridConstantItem(
		t.id,
		t.t,
		t.tr,
		t.wh,
		t.baseline,
		t.minWH,
		t.maxWH,
		t.fillers,
		t.av
	)
}

distributeTFlexibleGridAsks(
	fillers1 : Transform<double>,
	fillers2 : Transform<double>,
	min1 : Transform<double>,
	min2 : Transform<double>,
	max1 : Transform<double>,
	max2 : Transform<double>,
	available : Transform<double>
) -> Pair<Transform<double>, Transform<double>> {
	fselect7(
		fillers1,
		fillers2,
		min1,
		min2,
		max1,
		max2,
		available,
		\f1, f2, mn1, mn2, mx1, mx2, a -> {
			mn = mn1 + mn2;

			if (mn >= a || f1 + f2 <= 0.0) { // If minimum is more than available or there are no fillers then use min values
				Pair(mn1, mn2);
			} else if (f1 <= 0.0) {
				if (f2 <= 0.0) {
					Pair(mn1, mn2);
				} else {
					Pair(mn1, max(min(a - mn1, mx2), mn2));
				}
			} else if (f2 <= 0.0) {
				Pair(max(min(a - mn2, mx1), mn1), mn2);
			} else {
				mx = mx1 + mx2;

				if (mx <= a || mn >= mx) { // If maximum is less than available or max equals min then use max values
					Pair(mx1, mx2);
				} else {
					ad = a - mn1 - mn2;
					s1 = max(min(ad * f1 / (f1 + f2) + mn1, mx1), mn1);
					s2 = a - s1;

					if (s2 < mn2) {
						Pair(max(a - mn2, mn1), mn2);
					} else if (s2 > mx2) {
						Pair(min(a - mx2, mx1), mx2);
					} else {
						Pair(s1, s2);
					}
				}
			}
		}
	)
	|> (\f -> Pair(fFirstOfPair(f), fSecondOfPair(f)))
}

mergeTFlexibleGridConstantItemsHorizontal(t1 : TFlexibleGridConstantItem, t2 : TFlexibleGridConstantItem, alignBaselines : bool) -> TFlexibleGridConstantItem {
	tr = make(const(zeroPoint));
	av = make(const(zeroWH));
	baseline = fmax(t1.baseline, t2.baseline);

	da =
		distributeTFlexibleGridAsks(
			fpointX(t1.fillers),
			fpointX(t2.fillers),
			fwidth(t1.minWH),
			fwidth(t2.minWH),
			fwidth(t1.maxWH),
			fwidth(t2.maxWH),
			fwidth(fsubselect(av, idfn |> FLift))
		);

	uns = ref nop;
	uns := subscribe2(tr, \__ -> {
		next(t1.av, fwh(da.first, fheight(t1.minWH)));
		next(t2.av, fwh(da.second, fheight(t2.minWH)));

		next(
			t1.tr,
			fsubselect(
				tr,
				if (!alignBaselines)
					FLift(\p -> p)
				else
					FLift(\p -> fpoint(fpointX(p), faddition(fpointY(p), fsubtract(baseline, t1.baseline))))
			)
		);
		next(
			t2.tr,
			fsubselect(
				tr,
				FLift(\p ->
					fpoint(
						faddition(fpointX(p), da.first),
						if (!alignBaselines)
							fpointY(p)
						else
							faddition(fpointY(p), fsubtract(baseline, t2.baseline))
					)
				)
			)
		);

		^uns();
		uns := nop;
	});

	flexibleGridItemId := ^flexibleGridItemId + 1;

	TFlexibleGridConstantItem(
		^flexibleGridItemId,
		TEmpty(),
		tr,
		fwh(
			faddition(fwidth(t1.wh), fwidth(t2.wh)),
			fmax(fheight(t1.wh), fheight(t2.wh))
		),
		baseline,
		fwh(
			faddition(fwidth(t1.minWH), fwidth(t2.minWH)),
			fmax(fheight(t1.minWH), fheight(t2.minWH))
		),
		fwh(
			faddition(fwidth(t1.maxWH), fwidth(t2.maxWH)),
			fmax(fheight(t1.maxWH), fheight(t2.maxWH))
		),
		fpoint(
			faddition(fpointX(t1.fillers), fpointX(t2.fillers)),
			faddition(fpointY(t1.fillers), fpointY(t2.fillers))
		),
		av
	);
}

mergeTFlexibleGridConstantItemsVertical(t1 : TFlexibleGridConstantItem, t2 : TFlexibleGridConstantItem) -> TFlexibleGridConstantItem {
	tr = make(const(zeroPoint));
	av = make(const(zeroWH));

	da =
		distributeTFlexibleGridAsks(
			fpointY(t1.fillers),
			fpointY(t2.fillers),
			fheight(t1.minWH),
			fheight(t2.minWH),
			fheight(t1.maxWH),
			fheight(t2.maxWH),
			fheight(fsubselect(av, idfn |> FLift))
		);

	uns = ref nop;
	uns := subscribe2(tr, \__ -> {
		next(t1.av, fwh(fwidth(t1.minWH), da.first));
		next(t2.av, fwh(fwidth(t2.minWH), da.second));

		next(t1.tr, fsubselect(tr, idfn |> FLift));
		next(t2.tr, fsubselect(tr, FLift(\p -> fpoint(fpointX(p), faddition(fpointY(p), da.first)))));

		^uns();
		uns := nop;
	});

	flexibleGridItemId := ^flexibleGridItemId + 1;

	TFlexibleGridConstantItem(
		^flexibleGridItemId,
		TEmpty(),
		tr,
		fwh(
			fmax(fwidth(t1.wh), fwidth(t2.wh)),
			faddition(fheight(t1.wh), fheight(t2.wh))
		),
		fmax(
			t1.baseline,
			t2.baseline
		),
		fwh(
			fmax(fwidth(t1.minWH), fwidth(t2.minWH)),
			faddition(fheight(t1.minWH), fheight(t2.minWH))
		),
		fwh(
			fmax(fwidth(t1.maxWH), fwidth(t2.maxWH)),
			faddition(fheight(t1.maxWH), fheight(t2.maxWH))
		),
		fpoint(
			faddition(fpointX(t1.fillers), fpointX(t2.fillers)),
			faddition(fpointY(t1.fillers), fpointY(t2.fillers))
		),
		av
	);
}

fitTFlexibleGrid(
	items : [TFlexibleGridItem],
	sizeMin : double,
	sizeMax : double,
	vertical : bool,
	alignment : FlexibleGridAlignment,
	alignBaselines : bool,
	maxRows : Maybe<int>,
	isRTL : bool
) -> void {
	currentPoint = ref const(zeroPoint);
	currentCoord = ref const(0.);
	currentLine = ref [];
	availableSize = make(const(sizeMin));

	addLineFn = \ -> {
		if (length(^currentLine) > 0) {
			t =
				foldBinary(
					map(^currentLine, TFlexibleGridItem2TFlexibleGridConstantItem),
					\t1, t2 ->
						if (vertical)
							mergeTFlexibleGridConstantItemsVertical(t1, t2)
						else
							mergeTFlexibleGridConstantItemsHorizontal(if (isRTL) t2 else t1, if (isRTL) t1 else t2, alignBaselines)
				);

			if (vertical) {
				next(t.av, fwh(fwidth(t.wh), fsubselect(availableSize, idfn |> FLift)));
				next(
					t.tr,
					fpoint(
						fpointX(^currentPoint),
						fmax(
							if (alignment == CenterAlign())
								fdivide(fsubtract(fsubselect(availableSize, idfn |> FLift), fheight(t.wh)), const(2.0))
							else if (alignment == EndAlign())
								fsubtract(fsubselect(availableSize, idfn |> FLift), fheight(t.wh))
							else
								zero,
							zero
						)
					)
				);
				next(availableSize, fmax(getValue(availableSize), fheight(t.minWH)));

				currentPoint := fpoint(faddition(fpointX(^currentPoint), fwidth(t.wh)), fpointY(^currentPoint));
			} else {
				next(t.av, fwh(fsubselect(availableSize, idfn |> FLift), fheight(t.wh)));
				next(
					t.tr,
					fpoint(
						fmax(
							if (alignment == CenterAlign())
								fdivide(fsubtract(fsubselect(availableSize, idfn |> FLift), fwidth(t.wh)), const(2.0))
							else if ((!isRTL && alignment == EndAlign()) || (isRTL && alignment == StartAlign()) || (alignment == RightAlign()))
								fsubtract(fsubselect(availableSize, idfn |> FLift), fwidth(t.wh))
							else
								zero,
							zero
						),
						fpointY(^currentPoint)
					)
				);
				next(availableSize, fmax(getValue(availableSize), fwidth(t.minWH)));

				currentPoint := fpoint(fpointX(^currentPoint), faddition(fpointY(^currentPoint), fheight(t.wh)));
			}
		}
	}

	iter(items, \it -> {
		minSize = if (vertical) fheight(it.minWH) else fwidth(it.minWH);
		doesFit = fgetValue(^currentCoord) + fgetValue(minSize) < sizeMax;

		if (eitherMap(maxRows, \mr -> length(^currentLine) < mr, true) && (doesFit || length(^currentLine) == 0)) {
			currentLine := arrayPush(^currentLine, it);

			currentCoord := faddition(^currentCoord, minSize);
			if (vertical) {
				currentPoint := fpoint(fpointX(^currentPoint), ^currentCoord);
			} else {
				currentPoint := fpoint(^currentCoord, fpointY(^currentPoint));
			}
		} else {
			addLineFn();
			currentLine := [it];
			currentCoord := minSize;

			if (vertical) {
				currentPoint := fpoint(fpointX(^currentPoint), ^currentCoord);
			} else {
				currentPoint := fpoint(^currentCoord, fpointY(^currentPoint));
			}
		}
	});

	addLineFn();
}

BFBlock(w : double, h : double);
BFState(l : [Point], s : WidthHeight, p : Tree<int, Pair<BFBlock, Point>>);
BFParameters(
	wrapNewRow : bool,
	wrapNewColumn : bool,
	ordered : bool,
	vertical : bool,
	maxRows : Maybe<int>,
	lockWidth : bool,
	isRTL : bool
);

bfFit(stageSize : double, blocks : [BFBlock], par : BFParameters) -> [Maybe<Point>] {
	sz = WidthHeight(
		max(if (par.lockWidth) stageSize else 0.0, either(maxA(map(blocks, \b -> b.w)), 0.0)),
		max(if (!par.lockWidth) stageSize else 0.0, either(maxA(map(blocks, \b -> b.h)), 0.0))
	);

	if (par.ordered) {
		state = bfFitBlocks([Point(0.0, 0.0)], sz, blocks, par, true);

		generate(0, length(blocks), \i -> maybeMap(lookupTree(state.p, i), \p -> p.second));
	} else {
		blocksI =
			mergeSort(mapi(blocks, \i, b -> Pair(i, b)), \a : Pair<int, BFBlock>, b : Pair<int, BFBlock> ->
				if (par.vertical) {
					if (a.second.h == b.second.h)
						b2i(a.second.w < b.second.w)
					else
						b2i(a.second.h < b.second.h)
				} else {
					if (a.second.w == b.second.w)
						b2i(a.second.h < b.second.h)
					else
						b2i(a.second.w < b.second.w)
				}
			);

		orderI = map(blocksI, \b -> b.first);

		state = bfFitBlocks([Point(0.0, 0.0)], sz, map(blocksI, secondOfPair), par, true);

		getTreeValues(
			foldi(
				generate(0, length(blocks), \i -> maybeMap(lookupTree(state.p, i), \p -> p.second)),
				makeTree(),
				\i, acc, tr -> setTree(acc, orderI[i], tr)
			)
		);
	}
}

bfFitBlocks(line : [Point], size : WidthHeight, blocks : [BFBlock], par : BFParameters, reverseEnable : bool) -> BFState {
	foldi(blocks, BFState(line, size, makeTree()), \i, acc, block -> {
		state = bfFindNode(i, acc, block, par);

		if (state.s.width > acc.s.width || state.s.height > acc.s.height) {
			bfFitBlocks(line, state.s, subrange(blocks, 0, i + 1), par, false)
		} else {
			state;
		}
	})
	|> (\state -> {
		if (!par.vertical && par.isRTL && reverseEnable) {
			dx = foldTree(state.p, size.width, \__, p, acc -> min(acc, size.width - p.second.x - p.first.w));

			BFState(state with
				p = mapTree(state.p, \p ->
					Pair(
						p.first,
						Point(
							size.width - p.second.x - p.first.w - dx,
							p.second.y
						)
					)
				)
			);
		} else {
			state;
		}
	})
}

bfFindNode(i : int, state : BFState, block : BFBlock, par : BFParameters) -> BFState {
	if(block.w == 0.0 || block.h == 0.0) {
		state
	} else {
		p =
			fold(enumFromTo(0, length(state.l) - 1), Point(doubleMax, doubleMax), \acc : Point, l -> {
				if (par.vertical) {
					if (state.l[l].y <= state.s.height - block.h && (if (par.lockWidth) state.l[l].x <= state.s.width - block.w else true)) {
						p = getBFLinePoint(state.l, l, block, par);

						if (p.x < acc.x && checkBFMaxRows(state, block, p, par)) {
							p;
						} else {
							acc;
						}
					} else {
						acc;
					}
				} else {
					if (state.l[l].x <= state.s.width - block.w && (par.lockWidth || state.l[l].y <= state.s.height - block.h)) {
						p = getBFLinePoint(state.l, l, block, par);

						if (p.y < acc.y && checkBFMaxRows(state, block, p, par)) {
							p;
						} else {
							acc;
						}
					} else {
						acc;
					}
				}
			});

		if (p == Point(doubleMax, doubleMax)) {
			if (par.vertical) {
				maxY = foldTree(state.p, 0.0, \k, v, acc -> if (v.second.y + v.first.h > acc) v.second.y + v.first.h else acc);

				BFState(state.l, WidthHeight(state.s.width, maxY + block.h + 1.0), state.p);
			} else {
				maxX = foldTree(state.p, 0.0, \k, v, acc -> if (v.second.x + v.first.w > acc) v.second.x + v.first.w else acc);

				BFState(state.l, WidthHeight(maxX + block.w + 1.0, state.s.height), state.p);
			}
		} else {
			BFState(updateBFLine(state, block, p, par), state.s, setTree(state.p, i, Pair(block, p)));
		}
	}
}

updateBFLine(state : BFState, block : BFBlock, point : Point, par : BFParameters) -> [Point] {
	(if (par.vertical) {
		i = ref 0;
		lastX = ref 0.0;

		filter(state.l, \l ->
			if (l.y <= point.y + block.h) {
				lastX := l.x;

				if (l.y < point.y) {
					i := ^i + 1;

					true;
				} else {
					false;
				}
			} else {
				!par.ordered || l.x >= point.x
			}
		)
		|> (\ln -> {
			insertArray(
				insertArray(
					ln,
					^i,
					Point(if (par.wrapNewColumn) max(^lastX, point.x) else ^lastX, point.y + block.h)
				),
				^i,
				Point(point.x + block.w, point.y)
			)
		});
	} else {
		i = ref 0;
		lastY = ref 0.0;

		filter(state.l, \l ->
			if (l.x <= point.x + block.w) {
				lastY := l.y;

				if (l.x < point.x) {
					i := ^i + 1;

					true;
				} else {
					false;
				}
			} else {
				!par.ordered || l.y >= point.y
			}
		)
		|> (\ln -> {
			insertArray(
				insertArray(
					ln,
					^i,
					Point(point.x + block.w, if (par.wrapNewRow) max(^lastY, point.y) else ^lastY)
				),
				^i,
				Point(point.x, point.y + block.h)
			)
		})
	})
	|> (\ln ->
		if (par.wrapNewColumn) {
			p = arrayPush(getTreeValues(state.p), Pair(block, point));

			map(ln, \l ->
				Point(
					fold(
						p,
						l.x,
						\acc, pt ->
							if (pt.second.x < l.x && pt.second.x + pt.first.w > l.x)
								max(acc, pt.second.x + pt.first.w)
							else
								acc
					),
					l.y
				)
			);
		} else {
			ln
		}
	)
	|> (\ln ->
		if (par.wrapNewRow) {
			p = arrayPush(getTreeValues(state.p), Pair(block, point));

			map(ln, \l ->
				Point(
					l.x,
					fold(
						p,
						l.y,
						\acc, pt ->
							if (pt.second.y < l.y && pt.second.y + pt.first.h > l.y)
								max(acc, pt.second.y + pt.first.h)
							else
								acc
					)
				)
			);
		} else {
			ln
		}
	)
}

getBFLinePoint(line : [Point], i : int, block : BFBlock, par : BFParameters) -> Point {
	if (par.vertical) {
		minY = line[i].y;
		maxY = minY + block.h;

		fold(subrange(line, i, length(line)), 0.0, \acc, l -> {
			if (l.y >= minY && l.y < maxY && l.x > acc) {
				l.x;
			} else {
				acc;
			}
		})
		|> (\f -> Point(f, minY))
	} else {
		minX = line[i].x;
		maxX = minX + block.w;

		fold(tailFrom(line, i), 0.0, \acc, l -> {
			if (l.x >= minX && l.x < maxX && l.y > acc) {
				l.y;
			} else {
				acc;
			}
		})
		|> (\f -> Point(minX, f))
	}
}

checkBFMaxRows(state : BFState, block : BFBlock, point : Point, par : BFParameters) -> bool {
	eitherMap(
		par.maxRows,
		\mr -> {
			filteredTree = filterTree(state.p, \k, v -> if (par.vertical) v.second.y == 0.0 else v.second.x == 0.0);

			if (sizeTree(filteredTree) < mr) {
				true
			} else {
				maxSize =
					foldTree(filteredTree, 0.0, \k, v, acc ->
						if (par.vertical) {
							if (v.second.x > acc)
								v.second.x
							else
								acc;
						} else {
							if (v.second.y > acc)
								v.second.y
							else
								acc;
						}
					);

				if (par.vertical)
					point.x <= maxSize
				else
					point.y <= maxSize;
			}
		},
		true
	)
}

SelectTGroupFixed(values : Transform<[?]>, makeTropicFn : (index :  Transform<int>, id : int, ?) -> Tropic, threshold : Transform<int>) -> Tropic {
	TIf(
		flessi(flength(values), threshold),
		SelectTGroup(values, makeTropicFn),
		TSelect(values, \vals ->
			mapi(vals, \i, v -> makeTropicFn(const(i), i, v))
			|> TGroup
		)
	)
}

TFlex(items : Transform<[Tropic]>, style : [TFlexStyle]) -> Tropic {
	verticalGrid = contains(style, TVertical());
	order = tryExtractStruct(style, TOrder(const([])));
	gridEnabled = extractStruct(style, TEnabled(const(true))).enabled;
	animation = tryExtractStruct(style, TAnimationTimer(LazyDeltaTimer(make(0.0), nop, nop)));
	maxRows = maybeMap(tryExtractStruct(style, TMaxRows(0)), \mr -> mr.rows);
	stageSizeB = make(0.);
	lazyRenderingMode = tryExtractStruct(style, TFlexibleGridLazyRenderingMode(makeWH(), makePoint()));
	availableMinMax = extractStruct(style, TAvailableMinMax(stageSizeB, stageSizeB));
	alignment : FlexibleGridAlignment =
		if (contains(style, CenterAlign()))
			CenterAlign()
		else if (contains(style, EndAlign()))
			EndAlign()
		else
			StartAlign();
	alignBaselines = contains(style, TBaselineAlign());
	arrayThreshold = extractStruct(style, TArrayThreshold(const(ARRAY_DIFF_TRESHOLD))).threshold;
	spacing = extractStruct(style, TSpacing(zero, zero));
	spacingB = if (!verticalGrid) spacing.x else spacing.y;
	availableB = make(0.);

	isRTL = extractStruct(style, TSetRTL(getDefaultRtl())).rtl;
	isSameSize = contains(style, TSameSize());

	sameSizeWH : DynamicBehaviour<WidthHeight> = make(zeroWH);
	sameSizeBaseline : DynamicBehaviour<double> = make(0.0);
	sameSizeMinWH : DynamicBehaviour<WidthHeight> = make(zeroWH);
	sameSizeMaxWH : DynamicBehaviour<WidthHeight> = make(zeroWH);
	firstItemWH = makeWH();

	itemsB0 =
		fmap(items, \it -> {
			flexibleGridItemId := ^flexibleGridItemId + 1;

			TFlexibleGridItem(
				^flexibleGridItemId,
				TBorderTDir(zero, zero, spacing.x, spacing.y, it, isRTL),
				make(const(zeroPoint)),
				if (isSameSize) sameSizeWH else make(zeroWH),
				if (isSameSize) sameSizeBaseline else make(0.0),
				if (isSameSize) sameSizeMinWH else make(zeroWH),
				if (isSameSize) sameSizeMaxWH else make(zeroWH),
				make(Point(1.0, 0.0)),
				make(const(zeroWH))
			)
		});
	// To protect itemsB0 fn from being called multiple times for each item
	itemsB = fsubselect(itemsB0, FLift(\v -> const(v)));

	contentBaseline = fsubselect(felementAt(itemsB, const(0), const(emptyTFlexibleGridItem)), FLift(\e : TFlexibleGridItem -> e.baseline));
	topItem = make(TFlexibleGridItem2TFlexibleGridConstantItem(emptyTFlexibleGridItem));
	contentSize = fsubselect(topItem, FLift(\cs -> fwh(fsubtract(fwidth(cs.wh), spacing.x), fsubtract(fheight(cs.wh), spacing.y))));
	contentMinSize = fsubselect(topItem, FLift(\cs -> fwh(fsubtract(fwidth(cs.minWH), spacing.x), fsubtract(fheight(cs.minWH), spacing.y))));
	contentMaxSize = fsubselect(topItem, FLift(\cs -> fwh(fsubtract(fwidth(cs.maxWH), spacing.x), fsubtract(fheight(cs.maxWH), spacing.y))));

	item2Tropic = \item : TFlexibleGridItem, isFirst : Transform<bool> -> {
		translatePoint = fsubselect(item.tr, FLift(idfn));
		TIfLazy(if (isSameSize || isSome(lazyRenderingMode)) isFirst else const(true), \b -> {
			eitherMap(lazyRenderingMode, \lrm -> {
					if (b)
						TInspect([ISize(firstItemWH)],
							TInspect([ISize(item.wh), IMinSize(item.minWH), IMaxSize(item.maxWH), IBaseline(item.baseline), IFillers(item.fillers)], item.t)
						)
					else {
						showInitialSize = make(!b);
						showItem0 =
							if (verticalGrid)
								fselect4(fwidth(item.wh), fpointX(translatePoint), fwidth(lrm.viewport), fpointX(lrm.scrollPosition),
									\w, trX, vw, spX -> {pos = trX - spX; pos >= -w && pos <= vw}
								)
							else
								fselect4(fheight(item.wh), fpointY(translatePoint), fheight(lrm.viewport), fpointY(lrm.scrollPosition),
									\h, trY, vh, spY -> {pos = trY - spY; pos >= -h && pos <= vh}
								);
						showItem = fguard(showItem0, make(false));
						TInspect(
							[ISize(item.wh), IMinSize(item.minWH), IMaxSize(item.maxWH), IBaseline(item.baseline), IFillers(item.fillers)],
							TGroup2(
								TShow(showInitialSize, TSized(firstItemWH)),
								TShowKeepMetrics(showItem.first, item.t)
							)
						)
						|> (\t -> TConstruct([\ -> fwhen(showItem.first, \ -> nextDistinct(showInitialSize, false)), showItem.second], t))
					}
				},
				TInspect(
					if (b) {
						[ISize(item.wh), IMinSize(item.minWH), IMaxSize(item.maxWH), IBaseline(item.baseline), IFillers(item.fillers)];
					} else {
						[];
					},
					item.t
				)
			)
			|> (\f ->
				if (isSameSize) {
					visible = make(false);
					TRenderable(visible, TShowKeepMetrics(fstall(visible, 1), f));
				} else {
					f;
				}
			)
		})
		|> (\f ->
			TAvailable(
				f,
				TSized(fsubselect(item.av, idfn |> FLift))
			)
		)
		|> (\tropic ->
			eitherMap(
				animation,
				\a -> {
					pos = make(None());
					trigger = ffuse(translatePoint);

					TEasingAnimation(
						a.deltaTimer,
						0.2,
						CubicBezierEasing(0.4, 0.0, 0.2, 1.0),
						trigger.first,
						\tr -> eitherMap(getValue(pos), \p -> Some(Pair(p, tr)), None()),
						\tr -> nextDistinct(pos, Some(tr.second)),
						\tr, p -> nextDistinct(pos, Some(Point(lerp(tr.first.x, tr.second.x, p), lerp(tr.first.y, tr.second.y, p)))),
						TTranslate(feither(pos, translatePoint), tropic)
					)
					|> (\f -> TConstruct(trigger.second, f))
					|> TOnConstruct(\ -> nextDistinct(pos, Some(fgetValue(getValue(item.tr)))))
				},
				TTranslate(translatePoint, tropic)
			)
		);
	}

	SelectTGroupFixed(itemsB, \idx, __, item -> item2Tropic(item, feq(idx, 0)), arrayThreshold)
	|> (\f ->
		TransformTAcc(\t2a, p, s, mo -> {

			b1 = t2a(f, p, s, mo);
			inspectAv = fconnect(if (verticalGrid) p.maxX else p.maxY, availableB);

			TAcc(
				b1.form,
				TFormMetrics(
					fwidth(contentSize),
					fheight(contentSize),
					contentBaseline
				),
				fwidth(contentMinSize),
				fheight(contentMinSize),
				fwidth(contentMaxSize),
				fheight(contentMaxSize),
				const(b2d(!verticalGrid)),
				const(b2d(verticalGrid)),
				b1.addFillers,
				false,
				false,
				arrayPush(b1.disposers, inspectAv)
			)
		})
	)
	|> (\f ->
		TConstruct(
			[
				if (isSameSize)
					make3Subscribe2(
						fdelayUntilNextFrameRendered(eitherMap(order, \or -> forder(fselect(itemsB, FLift(idfn)), or.order), itemsB)),
						sameSizeMinWH,
						fthrottleUntilNextFrameRendered(ftransistor(gridEnabled, fpair(faddition(availableMinMax.min, spacingB), faddition(availableMinMax.max, spacingB)))),
						\itms, __, stageSize ->
							next(topItem, fitTFlex(itms, stageSize.first, stageSize.second, faddition(availableB, spacingB), verticalGrid, alignment, alignBaselines, maxRows, isRTL))
					)
				else
					make2Subscribe2(
						fsubmap(
							fdelayUntilNextFrameRendered(eitherMap(order, \or -> forder(fselect(itemsB, FLift(idfn)), or.order), itemsB)),
							\it -> fpair(const(it), fpair(it.minWH, it.maxWH))
						),
						fthrottleUntilNextFrameRendered(ftransistor(gridEnabled, fpair(faddition(availableMinMax.min, spacingB), faddition(availableMinMax.max, spacingB)))),
						\itms, stageSize ->
							next(topItem, fitTFlex(map(itms, firstOfPair), stageSize.first, stageSize.second, faddition(availableB, spacingB), verticalGrid, alignment, alignBaselines, maxRows, isRTL))
					)
			],
			f
		)
	)
	|> (\f ->
		TGroup2(
			if (!verticalGrid)
				TSizedWidth(fwidth(contentMinSize), 0.0)
			else
				TSizedHeight(0.0, fheight(contentMinSize)),
			TInspect(
				[if (!verticalGrid) IAvailableWidth(stageSizeB) else IAvailableHeight(stageSizeB)],
				f
			)
		)
	)
}

mergeTFlexConstantItemsHorizontal(t1 : TFlexibleGridConstantItem, t2 : TFlexibleGridConstantItem, alignBaselines : bool) -> TFlexibleGridConstantItem {
	tr = make(const(zeroPoint));
	trB = fsubselect(tr, idfn |> FLift);
	av = make(const(zeroWH));
	avB = fsubselect(av, idfn |> FLift);
	baseline = fmax(t1.baseline, t2.baseline);

	da =
		distributeTFlexibleGridAsks(
			fpointX(t1.fillers),
			fpointX(t2.fillers),
			fwidth(t1.minWH),
			fwidth(t2.minWH),
			fwidth(t1.maxWH),
			fwidth(t2.maxWH),
			fwidth(avB)
		);

	uns = ref nop;
	uns := subscribe2(tr, \__ -> {
		next(t1.av, fwh(da.first, fmax(fheight(t1.minWH), fheight(avB))));
		next(t2.av, fwh(da.second, fmax(fheight(t2.minWH), fheight(avB))));

		next(
			t1.tr,
			if (!alignBaselines)
				trB
			else
				fpoint(fpointX(trB), faddition(fpointY(trB), fsubtract(baseline, t1.baseline)))
		);
		next(
			t2.tr,
			fpoint(
				faddition(fpointX(trB), da.first),
				if (!alignBaselines)
					fpointY(trB)
				else
					faddition(fpointY(trB), fsubtract(baseline, t2.baseline))
			)
		);

		^uns();
		uns := nop;
	});

	flexibleGridItemId := ^flexibleGridItemId + 1;

	TFlexibleGridConstantItem(
		^flexibleGridItemId,
		TEmpty(),
		tr,
		fwh(
			faddition(fwidth(t1.wh), fwidth(t2.wh)),
			fmax(fheight(t1.wh), fheight(t2.wh))
		),
		baseline,
		fwh(
			faddition(fwidth(t1.minWH), fwidth(t2.minWH)),
			fmax(fheight(t1.minWH), fheight(t2.minWH))
		),
		fwh(
			faddition(fwidth(t1.maxWH), fwidth(t2.maxWH)),
			fmax(fheight(t1.maxWH), fheight(t2.maxWH))
		),
		fpoint(
			faddition(fpointX(t1.fillers), fpointX(t2.fillers)),
			fmax(fpointY(t1.fillers), fpointY(t2.fillers))
		),
		av
	);
}

mergeTFlexConstantItemsVertical(t1 : TFlexibleGridConstantItem, t2 : TFlexibleGridConstantItem) -> TFlexibleGridConstantItem {
	tr = make(const(zeroPoint));
	trB = fsubselect(tr, idfn |> FLift);
	av = make(const(zeroWH));
	avB = fsubselect(av, idfn |> FLift);

	da =
		distributeTFlexibleGridAsks(
			fpointY(t1.fillers),
			fpointY(t2.fillers),
			fheight(t1.minWH),
			fheight(t2.minWH),
			fheight(t1.maxWH),
			fheight(t2.maxWH),
			fheight(avB)
		);

	uns = ref nop;
	uns := subscribe2(tr, \__ -> {
		next(t1.av, fwh(fmax(fwidth(t1.minWH), fwidth(avB)), da.first));
		next(t2.av, fwh(fmax(fwidth(t2.minWH), fwidth(avB)), da.second));

		next(t1.tr, trB);
		next(t2.tr, fpoint(fpointX(trB), faddition(fpointY(trB), da.first)));

		^uns();
		uns := nop;
	});

	flexibleGridItemId := ^flexibleGridItemId + 1;

	TFlexibleGridConstantItem(
		^flexibleGridItemId,
		TEmpty(),
		tr,
		fwh(
			fmax(fwidth(t1.wh), fwidth(t2.wh)),
			faddition(fheight(t1.wh), fheight(t2.wh))
		),
		fmax(
			t1.baseline,
			t2.baseline
		),
		fwh(
			fmax(fwidth(t1.minWH), fwidth(t2.minWH)),
			faddition(fheight(t1.minWH), fheight(t2.minWH))
		),
		fwh(
			fmax(fwidth(t1.maxWH), fwidth(t2.maxWH)),
			faddition(fheight(t1.maxWH), fheight(t2.maxWH))
		),
		fpoint(
			fmax(fpointX(t1.fillers), fpointX(t2.fillers)),
			faddition(fpointY(t1.fillers), fpointY(t2.fillers))
		),
		av
	);
}

alignTFlexConstantItems(
	t : TFlexibleGridConstantItem,
	vertical : bool,
	alignment0 : FlexibleGridAlignment,
	isRTL : bool
) -> TFlexibleGridConstantItem {
	alignment = if (vertical && isRTL) {
		if (alignment0 == StartAlign())
			EndAlign()
		else if (alignment0 == EndAlign())
			StartAlign()
		else
			alignment0
	} else {
		alignment0
	};

	if (alignment == CenterAlign() || alignment == EndAlign()) {
		tr = make(const(zeroPoint));
		trB = fsubselect(tr, idfn |> FLift);
		avB = fsubselect(t.av, idfn |> FLift);

		uns = ref nop;
		uns := subscribe2(tr, \__ -> {
			next(t.tr, fpoint(
				faddition(
					fpointX(trB),
					if (vertical)
						zero
					else
						fmax(
							if (alignment == CenterAlign())
								fdivide(fsubtract(fwidth(avB), fwidth(t.wh)), const(2.0))
							else if (alignment == EndAlign())
								fsubtract(fwidth(avB), fwidth(t.wh))
							else
								zero,
							zero
						)
				),
				faddition(
					fpointY(trB),
					if (vertical)
						fmax(
							if (alignment == CenterAlign())
								fdivide(fsubtract(fheight(avB), fheight(t.wh)), const(2.0))
							else if (alignment == EndAlign())
								fsubtract(fheight(avB), fheight(t.wh))
							else
								zero,
							zero
						)
					else
						zero
				)
			));

			^uns();
			uns := nop;
		});

		TFlexibleGridConstantItem(
			t with tr = tr
		);
	} else {
		t
	}
}

fitTFlex(
	items : [TFlexibleGridItem],
	sizeMin : double,
	sizeMax : double,
	availableB : Transform<double>,
	vertical : bool,
	alignment : FlexibleGridAlignment,
	alignBaselines : bool,
	maxRows : Maybe<int>,
	isRTL : bool
) -> TFlexibleGridConstantItem {
	currentCoord = ref const(0.);
	currentLine = ref [];
	lines = ref [];

	addLineFn = \ -> {
		if (length(^currentLine) > 0) {
			t =
				foldBinary(
					map(^currentLine, TFlexibleGridItem2TFlexibleGridConstantItem),
					\t1, t2 ->
						if (vertical)
							mergeTFlexConstantItemsVertical(t1, t2)
						else
							mergeTFlexConstantItemsHorizontal(
								if (isRTL) t2 else t1,
								if (isRTL) t1 else t2,
								alignBaselines
							)
				);
			lines := arrayPush(^lines, t);
		}
	}

	iter(items, \it -> {
		minSize = if (vertical) fheight(it.minWH) else fwidth(it.minWH);
		doesFit = fgetValue(^currentCoord) + fgetValue(minSize) < sizeMax;

		if (eitherMap(maxRows, \mr -> length(^currentLine) < mr, true) && (doesFit || length(^currentLine) == 0)) {
			currentLine := arrayPush(^currentLine, it);

			currentCoord := faddition(^currentCoord, minSize);
		} else {
			addLineFn();
			currentLine := [it];
			currentCoord := minSize;
		}
	});

	addLineFn();

	if (length(^lines) > 0) {
		t =
			foldBinary(
				map(^lines, \l -> alignTFlexConstantItems(l, vertical, alignment, isRTL)),
				\t1, t2 ->
					if (vertical)
						mergeTFlexConstantItemsHorizontal(t1, t2, false)
					else
						mergeTFlexConstantItemsVertical(t1, t2)
			);

		if (vertical) {
			next(t.av, fwh(fmax(availableB, fwidth(t.minWH)), fmax(const(sizeMin), fheight(t.minWH))));
		} else {
			next(t.av, fwh(fmax(const(sizeMin), fwidth(t.minWH)), fmax(availableB, fheight(t.minWH))));
		}
		next(t.tr, fpoint(zero, zero));

		t;
	} else {
		TFlexibleGridItem2TFlexibleGridConstantItem(emptyTFlexibleGridItem)
	}
}
