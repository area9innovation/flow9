import tropic/selecttarray;
import tropic/tropic_gui;
import ui/animate/teasing;
import form/gui;
import tropic/tropic2form;

export {
	TFlexibleGrid(items : Transform<[Tropic]>, style : [TFlexibleGridStyle]) -> Tropic;
		TFlexibleGridStyle ::= TWrapNewRow, TWrapNewColumn, TVertical, TMaxRows, TCropView,
			CenterAlign, EndAlign, TAnimation, TOrder, TLockWidth, TEnabled, TSetRTL, TSameSize, TFlexibleGridContentSizeInspector,
			TFillersSupport;

			TWrapNewRow(); // New row should be below all the elements in the previous one
			TWrapNewColumn(); // New column should be to the right of all the elements in the previous one
			TVertical(); // Pack elements vertically and bound them with available height
			TMaxRows(rows : int); // Max elements in a first column (Max elements in a first row if TVertical is passed)
			TCropView(crop : bool); // Crop grid size by items sizes (true by default)
			TAnimation(deltaTimer : LazyDeltaTimer); // Enables animation
			TOrder(order : Transform<[int]>); // Set items order
			TLockWidth(lock : bool); // If true size only grows in height not in width (false for TVertical and true for horizontal grid)
			TSameSize(); // Some optimization for performance boosting in case of same sized items
			TFillersSupport(); // Allow items size to grow by available, (ignores TWrapNewRow, TWrapNewColumn, TVertical, TMaxRows, TLockWidth, alignment)

			TFlexibleGridContentSizeInspector(wh : DynamicBehaviour<WidthHeight>);
}

TFlexibleGridItem(
	id : int,
	t : Tropic,
	tr : DynamicBehaviour<Transform<Point>>,
	wh : DynamicBehaviour<WidthHeight>,
	minWH : DynamicBehaviour<WidthHeight>,
	maxWH : DynamicBehaviour<WidthHeight>,
	fillers : Transform<Point>,
	av : DynamicBehaviour<Transform<WidthHeight>>
);

TFlexibleGridConstantItem(
	id : int,
	t : Tropic,
	tr : DynamicBehaviour<Transform<Point>>,
	wh : Transform<WidthHeight>,
	minWH : Transform<WidthHeight>,
	maxWH : Transform<WidthHeight>,
	fillers : Transform<Point>,
	av : DynamicBehaviour<Transform<WidthHeight>>
);

emptyTFlexibleGridItem = TFlexibleGridItem(-1, TEmpty(), make(const(zeroPoint)), makeWH(), makeWH(), makeWH(), const(zeroPoint), make(const(zeroWH)));
flexibleGridItemId = ref 0;

TFlexibleGrid(items : Transform<[Tropic]>, style : [TFlexibleGridStyle]) -> Tropic {
	wrapNewRow = contains(style, TWrapNewRow());
	wrapNewColumn = contains(style, TWrapNewColumn());
	order = tryExtractStruct(style, TOrder(const([])));
	verticalGrid = contains(style, TVertical());
	cropView = extractStruct(style, TCropView(true)).crop;
	gridEnabled = extractStruct(style, TEnabled(const(true))).enabled;
	animation = tryExtractStruct(style, TAnimation(LazyDeltaTimer(make(0.0), nop, nop)));
	maxRows = maybeMap(tryExtractStruct(style, TMaxRows(0)), \mr -> mr.rows);
	lockWidth = extractStruct(style, TLockWidth(!verticalGrid)).lock;
	contentSizeInspector = tryExtractStruct(style, TFlexibleGridContentSizeInspector(makeWH()));
	fillersSupport = contains(style, TFillersSupport());

	isRTL = extractStruct(style, TSetRTL(getDefaultRtl())).rtl;
	isSameSize = contains(style, TSameSize());

	sameSizeWH : DynamicBehaviour<WidthHeight> = make(zeroWH);
	sameSizeMinWH : DynamicBehaviour<WidthHeight> = make(zeroWH);
	sameSizeMaxWH : DynamicBehaviour<WidthHeight> = make(zeroWH);
	contentBaseline = make(0.);
	stageSizeB = makeWH();

	itemsB =
		fmap(items, \it -> {
			flexibleGridItemId := ^flexibleGridItemId + 1;

			TFlexibleGridItem(
				^flexibleGridItemId,
				it,
				make(const(zeroPoint)),
				if (isSameSize) sameSizeWH else make(zeroWH),
				if (isSameSize) sameSizeMinWH else make(zeroWH),
				if (isSameSize) sameSizeMaxWH else make(zeroWH),
				const(Point(1.0, 0.0)),
				make(const(zeroWH))
			)
		});

	contentSize =
		fselect(
			fsubmap(itemsB, \it : TFlexibleGridItem -> fpair(fsubselect(it.tr, idfn |> FLift), it.wh)),
			FLift(\pairs : [Pair<Point, WidthHeight>] -> {
				fold(pairs, Pair(zeroWH, zeroWH), \acc : Pair, v ->
					Pair(
						WidthHeight(
							max(acc.first.width, v.second.width + v.first.x),
							max(acc.first.height, v.second.height + v.first.y)
						),
						WidthHeight(
							max(acc.second.width, v.second.width),
							max(acc.second.height, v.second.height)
						)
					)
				)
			})
		);

	parameters =
		BFParameters(
			wrapNewRow,
			wrapNewColumn,
			isSome(order),
			verticalGrid,
			maxRows,
			lockWidth
		);

	item2Tropic = \item : TFlexibleGridItem, isFirst : Transform<bool> ->
		TIfLazy(isFirst, \b -> {
			TInspect(
				if (b) {
					if (fillersSupport)
						[ISize(item.wh), IMinSize(item.minWH), IMaxSize(item.maxWH), IBaseline(contentBaseline)]
					else
						[ISize(item.wh), IBaseline(contentBaseline)];
				} else if (isSameSize) {
					[];
				} else {
					if (fillersSupport)
						[ISize(item.wh), IMinSize(item.minWH), IMaxSize(item.maxWH)]
					else
						[ISize(item.wh)];
				},
				item.t
			)
			|> (\f ->
				if (isSameSize) {
					visible = make(false);
					TRenderable(visible, TShow(fstall(visible, 1), f));
				} else {
					f;
				}
			)
		})
		|> (\f ->
			if (fillersSupport)
				TAvailable(
					f,
					TSized(fsubselect(item.av, idfn |> FLift))
				)
			else
				f
		)
		|> (\tropic ->
			eitherMap(
				animation,
				\a -> {
					pos = make(zeroPoint);
					trigger = ffuse(fsubselect(item.tr, idfn |> FLift));

					TEasingAnimation(
						a.deltaTimer,
						0.2,
						CubicBezierEasing(0.4, 0.0, 0.2, 1.0),
						trigger.first,
						\tr -> if (getValue(pos) != tr) Some(Pair(getValue(pos), tr)) else None(),
						\tr -> nextDistinct(pos, tr.second),
						\tr, p -> nextDistinct(pos, Point(lerp(tr.first.x, tr.second.x, p), lerp(tr.first.y, tr.second.y, p))),
						TTranslate(pos, tropic)
					)
					|> (\f -> TConstruct(trigger.second, f))
					|> TOnConstruct(\ -> nextDistinct(pos, fgetValue(getValue(item.tr))))
				},
				TTranslate(fsubselect(item.tr, idfn |> FLift), tropic)
			)
		);

	form2TAcc = \form, disposers ->
		TAcc(
			form,
			TFormMetrics(
				zero,
				zero,
				zero
			),
			zero,
			zero,
			zero,
			zero,
			zero,
			zero,
			const(false),
			false,
			false,
			disposers
		);

	SelectTGroupFixed(itemsB, \idx, __, item -> item2Tropic(item, feq(idx, 0)))
	|> (\f ->
		TransformTAcc2(\t2a -> {
				b1 = f |> t2a;

				wd = fwidth(fFirstOfPair(contentSize));
				hgt = fheight(fFirstOfPair(contentSize));

				minWd = fwidth(fSecondOfPair(contentSize));
				minHgt = fheight(fSecondOfPair(contentSize));

				TAcc(
					b1.form,
					TFormMetrics(
						wd,
						hgt,
						contentBaseline
					),
					if (verticalGrid) wd else minWd,
					if (verticalGrid) minHgt else hgt,
					if (verticalGrid) wd else minWd,
					if (verticalGrid) minHgt else hgt,
					zero,
					zero,
					b1.addFillers,
					false,
					false,
					b1.disposers
				)
			}
		)
	)
	|> (\f ->
			if (contains(style, CenterAlign())) {
				if (verticalGrid)
					TTweak([TAlign(const(b2d(isRTL)), const(0.5))], f, TFillXY())
				else
					TTweak([TAlign(const(0.5), zero)], f, TFillX())
			} else if (contains(style, EndAlign())) {
				if (verticalGrid)
					TTweak([TAlign(const(b2d(isRTL)), const(1.))], f, TFillXY())
				else if (isRTL)
					f
				else
					TTweak([TAlign(const(1.), zero)], f, TFillX())
			} else {
				if (isRTL)
					TTweak([TAlign(const(1.), zero)], f, TFillX())
				else
					f
			}
	)
	|> (\f ->
		if (fillersSupport) {
			TConstruct(
				[
					if (isSameSize)
						make3Subscribe2(
							fdelayUntilNextFrameRendered(eitherMap(order, \or -> forder(fselect(itemsB, FLift(idfn)), or.order), itemsB)),
							sameSizeMinWH,
							ftransistor(gridEnabled, stageSizeB),
							\itms, __, stageSize -> fitTFlexibleGrid(itms, stageSize.width)
						)
					else
						make2Subscribe2(
							fsubmap(
								fdelayUntilNextFrameRendered(eitherMap(order, \or -> forder(fselect(itemsB, FLift(idfn)), or.order), itemsB)),
								\it -> fpair(const(it), it.minWH)
							),
							ftransistor(gridEnabled, stageSizeB),
							\itms, stageSize -> fitTFlexibleGrid(map(itms, firstOfPair), stageSize.width)
						)
				],
				f
			)
		} else {
			itemTranslations =
				fselect2(
					fsubmap(eitherMap(order, \or -> forder(fselect(itemsB, FLift(idfn)), or.order), itemsB), \it -> it.wh),
					ftransistor(gridEnabled, stageSizeB),
					FLift2(\itemsSizes, stageSize -> {
						blocks = map(itemsSizes, \wh -> BFBlock(wh.width, wh.height));
						bfFit(stageSize, blocks, parameters);
					})
				)
				|> (\tr -> eitherMap(order, \or -> fdeorder(tr, or.order), tr));

			TConstruct(
				if (isSameSize) {
					applyTranslationsTrigger = make(false);
					[
						makeSubscribe(itemTranslations, \__ -> reverseBehaviour(applyTranslationsTrigger)),
						makeSubscribe(itemsB, \__ -> reverseBehaviour(applyTranslationsTrigger)),

						makeSubscribe(applyTranslationsTrigger, \__ -> {
							gridItems = fgetValue(itemsB);
							iteri(fgetValue(itemTranslations), \i, p ->
								if (length(gridItems) > i) {
									nextDistinct(gridItems[i].tr, const(either(p, Point(0., 0.))));
								}
							);
						})
					]
				} else [
					make2Subscribe(
						itemTranslations,
						itemsB,
						\tr, gridItems ->
							iteri(tr, \i, p ->
								if (length(gridItems) > i) {
									nextDistinct(gridItems[i].tr, const(either(p, Point(0., 0.))));
								}
							)
					)
				],
				f
			)
		}
	)
	|> (\f -> eitherMap(contentSizeInspector, \inspector ->
			TConstruct([
				makeSubscribe2(contentSize, \cz -> nextDistinct(inspector.wh, cz.first))
			], f),
			f
		))
	|> (\f ->
		if (cropView) {
			TCopySize2(
				f,
				\sz, c ->
					TFixSize(
						TAttachAvailable(c, stageSizeB),
						if (parameters.lockWidth)
							TGroup2(TFillX(), sz)
						else
							TGroup2(sz, TFillY())
					)
			)
		} else {
			TCopySize2(
				f,
				\sz, c -> TGroup2(if (parameters.lockWidth) THeight(sz) else TWidth(sz), TAttachBox2(TFillXY(), stageSizeB, c))
			)
		}
	)
}

foldBinary(a : [?], fn : (e1 : ?, e2 : ?) -> ?) -> ? {
	if (length(a) == 2) {
		fn(a[0], a[1]);
	} else if (length(a) < 2) {
		a[0]
	} else {
		fn(foldBinary(subrange(a, 0, length(a) / 2), fn), foldBinary(subrange(a, length(a) / 2, length(a) - length(a) / 2), fn));
	}
}

TFlexibleGridItem2TFlexibleGridConstantItem(t : TFlexibleGridItem) -> TFlexibleGridConstantItem {
	TFlexibleGridConstantItem(
		t.id,
		t.t,
		t.tr,
		t.wh,
		t.minWH,
		t.maxWH,
		t.fillers,
		t.av
	)
}

mergeTFlexibleGridConstantItems(t1 : TFlexibleGridConstantItem, t2 : TFlexibleGridConstantItem) -> TFlexibleGridConstantItem {
	tr = make(const(zeroPoint));
	av = make(const(zeroWH));

	da = distributeAsks(
		fpointX(t1.fillers),
		fpointX(t2.fillers),
		fwidth(t1.minWH),
		fwidth(t2.minWH),
		fwidth(t1.maxWH),
		fwidth(t2.maxWH),
		fwidth(fsubselect(av, idfn |> FLift)),
		const(true),
		const(true)
	);

	uns = ref nop;
	uns := subscribe2(tr, \__ -> {
		next(t1.av, fwh(da.first, fheight(t1.minWH)));
		next(t2.av, fwh(da.second, fheight(t2.minWH)));

		next(t1.tr, fsubselect(tr, idfn |> FLift));
		next(t2.tr, fsubselect(tr, FLift(\p -> fpoint(faddition(fpointX(p), da.first), fpointY(p)))));

		^uns();
		uns := nop;
	});

	flexibleGridItemId := ^flexibleGridItemId + 1;

	TFlexibleGridConstantItem(
		^flexibleGridItemId,
		TEmpty(),
		tr,
		fwh(
			faddition(fwidth(t1.wh), fwidth(t2.wh)),
			fmax(fheight(t1.wh), fheight(t2.wh))
		),
		fwh(
			faddition(fwidth(t1.minWH), fwidth(t2.minWH)),
			fmax(fheight(t1.minWH), fheight(t2.minWH))
		),
		fwh(
			faddition(fwidth(t1.maxWH), fwidth(t2.maxWH)),
			fmax(fheight(t1.maxWH), fheight(t2.maxWH))
		),
		fpoint(
			faddition(fpointX(t1.fillers), fpointX(t2.fillers)),
			faddition(fpointY(t1.fillers), fpointY(t2.fillers))
		),
		av
	);
}

fitTFlexibleGrid(items : [TFlexibleGridItem], size : double) -> void {
	currentPoint = ref zeroPoint;
	currentLine = ref [];

	iter(items, \it -> {
		if (^currentPoint.x + fgetValue(fwidth(it.minWH)) < size || length(^currentLine) == 0) {
			currentLine := arrayPush(^currentLine, it);
			currentPoint := Point(^currentPoint.x + fgetValue(fwidth(it.minWH)), ^currentPoint.y);
		} else {
			t = foldBinary(map(^currentLine, TFlexibleGridItem2TFlexibleGridConstantItem), mergeTFlexibleGridConstantItems);
			next(t.av, const(WidthHeight(size, fgetValue(fheight(t.minWH)))));
			next(t.tr, const(Point(0.0, ^currentPoint.y)));

			currentLine := [it];
			currentPoint := Point(fgetValue(fwidth(it.minWH)), ^currentPoint.y + fgetValue(fheight(t.minWH)));
		}
	});

	if (length(^currentLine) > 0) {
		t = foldBinary(map(^currentLine, TFlexibleGridItem2TFlexibleGridConstantItem), mergeTFlexibleGridConstantItems);
		next(t.av, const(WidthHeight(size, fgetValue(fheight(t.minWH)))));
		next(t.tr, const(Point(0.0, ^currentPoint.y)));
	}
}

BFBlock(w : double, h : double);
BFState(l : [Point], s : WidthHeight, p : Tree<int, Pair<BFBlock, Point>>);
BFParameters(
	wrapNewRow : bool,
	wrapNewColumn : bool,
	ordered : bool,
	vertical : bool,
	maxRows : Maybe<int>,
	lockWidth : bool
);

bfFit(size : WidthHeight, blocks : [BFBlock], par : BFParameters) -> [Maybe<Point>] {
	sz = WidthHeight(max(size.width, either(maxA(map(blocks, \b -> b.w)), 0.0)), max(size.height, either(maxA(map(blocks, \b -> b.h)), 0.0)));

	if (par.ordered) {
		state = bfFitBlocks([Point(0.0, 0.0)], sz, blocks, par);

		generate(0, length(blocks), \i -> maybeMap(lookupTree(state.p, i), \p -> p.second));
	} else {
		blocksI =
			mergeSort(mapi(blocks, \i, b -> Pair(i, b)), \a : Pair<int, BFBlock>, b : Pair<int, BFBlock> ->
				if (par.vertical) {
					if (a.second.h == b.second.h)
						b2i(a.second.w < b.second.w)
					else
						b2i(a.second.h < b.second.h)
				} else {
					if (a.second.w == b.second.w)
						b2i(a.second.h < b.second.h)
					else
						b2i(a.second.w < b.second.w)
				}
			);

		orderI = map(blocksI, \b -> b.first);

		state = bfFitBlocks([Point(0.0, 0.0)], sz, map(blocksI, secondOfPair), par);

		getTreeValues(
			foldi(
				generate(0, length(blocks), \i -> maybeMap(lookupTree(state.p, i), \p -> p.second)),
				makeTree(),
				\i, acc, tr -> setTree(acc, orderI[i], tr)
			)
		);
	}
}

bfFitBlocks(line : [Point], size : WidthHeight, blocks : [BFBlock], par : BFParameters) -> BFState {
	foldi(blocks, BFState(line, size, makeTree()), \i, acc, block -> {
		state = bfFindNode(i, acc, block, par);

		if (state.s.width > acc.s.width || state.s.height > acc.s.height) {
			bfFitBlocks(line, state.s, subrange(blocks, 0, i + 1), par)
		} else {
			state;
		}
	});
}

bfFindNode(i : int, state : BFState, block : BFBlock, par : BFParameters) -> BFState {
	p =
		fold(enumFromTo(0, length(state.l) - 1), Point(doubleMax, doubleMax), \acc : Point, l -> {
			if (par.vertical) {
				if (state.l[l].y <= state.s.height - block.h && (if (par.lockWidth) state.l[l].x <= state.s.width - block.w else true)) {
					p = getBFLinePoint(state.l, l, block, par);

					if (p.x < acc.x && checkBFMaxRows(state, block, p, par)) {
						p;
					} else {
						acc;
					}
				} else {
					acc;
				}
			} else {
				if (state.l[l].x <= state.s.width - block.w && (par.lockWidth || state.l[l].y <= state.s.height - block.h)) {
					p = getBFLinePoint(state.l, l, block, par);

					if (p.y < acc.y && checkBFMaxRows(state, block, p, par)) {
						p;
					} else {
						acc;
					}
				} else {
					acc;
				}
			}
		});

	if (p == Point(doubleMax, doubleMax)) {
		if (par.vertical) {
			maxY = foldTree(state.p, 0.0, \k, v, acc -> if (v.second.y + v.first.h > acc) v.second.y + v.first.h else acc);

			BFState(state.l, WidthHeight(state.s.width, maxY + block.h + 1.0), state.p);
		} else {
			maxX = foldTree(state.p, 0.0, \k, v, acc -> if (v.second.x + v.first.w > acc) v.second.x + v.first.w else acc);

			BFState(state.l, WidthHeight(maxX + block.w + 1.0, state.s.height), state.p);
		}
	} else {
		BFState(updateBFLine(state, block, p, par), state.s, setTree(state.p, i, Pair(block, p)));
	}
}

updateBFLine(state : BFState, block : BFBlock, point : Point, par : BFParameters) -> [Point] {
	(if (par.vertical) {
		i = ref 0;
		lastX = ref 0.0;

		filter(state.l, \l ->
			if (l.y <= point.y + block.h) {
				lastX := l.x;

				if (l.y < point.y) {
					i := ^i + 1;

					true;
				} else {
					false;
				}
			} else {
				!par.ordered || l.x >= point.x
			}
		)
		|> (\ln -> {
			insertArray(
				insertArray(
					ln,
					^i,
					Point(^lastX, point.y + block.h)
				),
				^i,
				Point(point.x + block.w, point.y)
			)
		});
	} else {
		i = ref 0;
		lastY = ref 0.0;

		filter(state.l, \l ->
			if (l.x <= point.x + block.w) {
				lastY := l.y;

				if (l.x < point.x) {
					i := ^i + 1;

					true;
				} else {
					false;
				}
			} else {
				!par.ordered || l.y >= point.y
			}
		)
		|> (\ln -> {
			insertArray(
				insertArray(
					ln,
					^i,
					Point(point.x + block.w, ^lastY)
				),
				^i,
				Point(point.x, point.y + block.h)
			)
		})
	})
	|> (\ln ->
		if (par.wrapNewColumn) {
			p = arrayPush(getTreeValues(state.p), Pair(block, point));

			map(ln, \l ->
				Point(
					fold(
						p,
						l.x,
						\acc, pt ->
							if (pt.second.x < l.x && pt.second.x + pt.first.w > l.x)
								max(acc, pt.second.x + pt.first.w)
							else
								acc
					),
					l.y
				)
			);
		} else {
			ln
		}
	)
	|> (\ln ->
		if (par.wrapNewRow) {
			p = arrayPush(getTreeValues(state.p), Pair(block, point));

			map(ln, \l ->
				Point(
					l.x,
					fold(
						p,
						l.y,
						\acc, pt ->
							if (pt.second.y < l.y && pt.second.y + pt.first.h > l.y)
								max(acc, pt.second.y + pt.first.h)
							else
								acc
					)
				)
			);
		} else {
			ln
		}
	)
}

getBFLinePoint(line : [Point], i : int, block : BFBlock, par : BFParameters) -> Point {
	if (par.vertical) {
		minY = line[i].y;
		maxY = minY + block.h;

		fold(subrange(line, i, length(line)), 0.0, \acc, l -> {
			if (l.y >= minY && l.y < maxY && l.x > acc) {
				l.x;
			} else {
				acc;
			}
		})
		|> (\f -> Point(f, minY))
	} else {
		minX = line[i].x;
		maxX = minX + block.w;

		fold(tailFrom(line, i), 0.0, \acc, l -> {
			if (l.x >= minX && l.x < maxX && l.y > acc) {
				l.y;
			} else {
				acc;
			}
		})
		|> (\f -> Point(minX, f))
	}
}

checkBFMaxRows(state : BFState, block : BFBlock, point : Point, par : BFParameters) -> bool {
	eitherMap(
		par.maxRows,
		\mr -> {
			filteredTree = filterTree(state.p, \k, v -> if (par.vertical) v.second.y == 0.0 else v.second.x == 0.0);

			if (sizeTree(filteredTree) < mr) {
				true
			} else {
				maxSize =
					foldTree(filteredTree, 0.0, \k, v, acc ->
						if (par.vertical) {
							if (v.second.x > acc)
								v.second.x
							else
								acc;
						} else {
							if (v.second.y > acc)
								v.second.y
							else
								acc;
						}
					);

				if (par.vertical)
					point.x <= maxSize
				else
					point.y <= maxSize;
			}
		},
		true
	)
}

SelectTGroupFixed(values : Transform<[?]>, makeTropicFn : (index :  Transform<int>, id : int, ?) -> Tropic) -> Tropic {
	if (isUrlParameterTrue("check_same_item"))
		SelectTGroup(values, makeTropicFn)
	else
		TIf(
			flessi(flength(values), const(ARRAY_DIFF_TRESHOLD)),
			SelectTGroup(values, makeTropicFn),
			TSelect(values, \vals ->
				mapi(vals, \i, v -> makeTropicFn(const(i), i, v))
				|> TGroup
			)
		)
}