import form/paragraph;
import tropic/tropic_paragraph_types;

export {
	breakTropicTextFragment(
		text : string,
		style : [CharacterStyle],
		moreLineBreaks : bool,
		indexingInit : int,
		init : List<TWrapElement>,
		isLastChild : bool
	) -> List<TWrapElement>;
	makeTZeroSpaceElement(style : [CharacterStyle]) -> Tropic;
	makeTEmptyLineInspectElement(indexing : int, style : [CharacterStyle]) -> TWrapElement;
}

breakTropicTextFragment(
	text : string,
	style : [CharacterStyle],
	moreLineBreaks : bool,
	indexingInit : int,
	init : List<TWrapElement>,
	isLastChild : bool
) -> List<TWrapElement> {
	EmptyList();

	// toInspectingElementIfNecessary : (int, int, TWord) -> TWrapElement = \indexing, offset, f -> {
	// 	if (0 <= indexing) {
	// 		TInspectElement(f, offset, make(0.), make(0.), makeWH(), make(0.0), make(-1), make(false))
	// 	} else {
	// 		f
	// 	}
	// };

	// // Text with LetterSpacing honors spacing between characters only (JS, CPP)
	// // If paragraph has several successive WigiText fragments with letterspacing, then the space between them will be lost
	// // so we make a trick - add zerro-width space to the end of text in Text to force it to add last letterspacing space
	// makeLetterSpacing = !isLastChild && containsStruct(style, LetterSpacing(0.0));

	// makeTextFn = \indexing, t -> toInspectingElementIfNecessary(
	// 	indexing,
	// 	indexing,
	// 	TText(if (makeLetterSpacing) t + "\u200b" else t, overrideCharacterStylePerAlphabet(t, style))
	// );

	// textLen = strlen(text);

	// space1Pos = ref -1;                                        // next pos of space char
	// space2Pos = ref -1;                                        // next pos of zero-width space char
	// space3Pos = ref -1;                                        // next pos of no-break space
	// newLinePos = ref -1;                                       // next pos of newline symbol
	// hyphenPos : ref Pair<int, bool> = ref Pair(-1, false);     // pair of next pos of hyphen and soft sign
	// chrCatPos = ref (if (isBiDiEnabled()) -1 else textLen);    // next pos of split in respect of characters' categories

	// remapMinusOne = \p -> if (p >= 0) p else textLen;
	// loop1 = ref \i, indexing, acc -> EmptyList();
	// loop1 := \i, indexing, acc -> {
	// 	if (i >= textLen) {
	// 		acc
	// 	} else {

	// 		// update key positions

	// 		if (isBiDiEnabled()) {
	// 			if (i >= ^chrCatPos) chrCatPos := remapMinusOne(getCharCatSplitPos(text, i+1, textLen)-1);
	// 		} else chrCatPos := i;
	// 		if (^chrCatPos > ^space1Pos) space1Pos := remapMinusOne(strRangeIndexOf(text, " ", ^chrCatPos, textLen));
	// 		if (^chrCatPos > ^space2Pos) space2Pos := remapMinusOne(strRangeIndexOf(text, "\u200b", ^chrCatPos, textLen));  // \u200b is zero-width space
	// 		if (^chrCatPos > ^space3Pos) space3Pos := remapMinusOne(strRangeIndexOf(text, "\u00a0", ^chrCatPos, textLen)); // \u00a0 is no-break space
	// 		if (^chrCatPos > ^newLinePos) newLinePos := remapMinusOne(strRangeIndexOf(text, "\n", ^chrCatPos, textLen));

	// 		if (^chrCatPos >= ^hyphenPos.first) {  // soft inequality because we want to keep hyphenPos greater than ^chrCatPos (findBreakAfterAllowPos2 returns at least ^chrCatPos+1)
	// 			hyphenPos := {
	// 				if (!allowBreaksAfterHyphen)
	// 					Pair(textLen, false)
	// 				else {
	// 					posAndSoft = findBreakAfterAllowPos2(text, ^chrCatPos, moreLineBreaks);
	// 					Pair(remapMinusOne(posAndSoft.first), posAndSoft.second);
	// 				}
	// 			};
	// 		}

	// 		// TODO try to get rid of array hence malloc optimisation needed.
	// 		noBiDiPositions : [Pair<int, SymbolAtPositionType>] = [
	// 			Pair(^space1Pos, PositionSpace()),
	// 			Pair(^space2Pos, PositionSpace()),
	// 			Pair(^space3Pos, PositionSpace()),
	// 			Pair(^newLinePos, PositionLineBreak()),
	// 			Pair(^hyphenPos.first,
	// 				if (^hyphenPos.second) {
	// 					PositionAllowSoftBreakAfter()
	// 				} else {
	// 					PositionAllowBreakAfter()
	// 				}
	// 			)
	// 		];
	// 		positions = if (isBiDiEnabled())
	// 			arrayPush(noBiDiPositions, Pair(^chrCatPos, PositionCharCat()))
	// 		else
	// 			noBiDiPositions;

	// 		keyPosM = fold(positions, None(), \pos : Maybe<Pair<int, SymbolAtPositionType>>, currPos : Pair<int, SymbolAtPositionType> -> {
	// 			if (currPos.first >= textLen) {
	// 				pos
	// 			} else {
	// 				switch(pos) {
	// 					None(): Some(currPos);
	// 					Some(p): {
	// 						if (p.first <= currPos.first) {
	// 							Some(p)
	// 						} else {
	// 							Some(currPos)
	// 						}
	// 					}
	// 				}
	// 			}
	// 		});

	// 		//Do not replace with eitherFn - tail recursion optimization will not happen
	// 		switch(keyPosM : Maybe<Pair<int, SymbolAtPositionType>>) {
	// 			Some(keyPosPair) : {
	// 				keyPos = keyPosPair.first;
	// 				keyPosRelative = keyPos - i;
	// 				posType = keyPosPair.second;
	// 				keyFragment = switch(posType : SymbolAtPositionType) {
	// 					PositionLineBreak() : {
	// 						NewLine();
	// 					}
	// 					PositionSpace() : {
	// 						// To get constant time concatenation of paragraph strings to work, we send
	// 						// the space from the original string to this guy.
	// 						space = makeTSpace(getCharAt(text, keyPos), style);
	// 						toInspectingElementIfNecessary(indexing, indexing + keyPosRelative, space)
	// 					}
	// 					PositionAllowBreakAfter() : {
	// 						toInspectingElementIfNecessary(indexing,
	// 							indexing + keyPosRelative,
	// 							makeTSpace(getCharAt(text, keyPos),
	// 								style
	// 							)
	// 						);
	// 					}
	// 					PositionAllowSoftBreakAfter() : {
	// 						toInspectingElementIfNecessary(indexing,
	// 							indexing + keyPosRelative,
	// 							TLinePart(TEmpty(),
	// 								TEmpty(),
	// 								TText(getCharAt(text, keyPos), style)
	// 							)
	// 						)
	// 					}
	// 					PositionCharCat(): {
	// 						// Used only for case break happens immediately after current position
	// 						// not to remake current implementation.
	// 						makeTextFn(indexing, getCharAt(text, keyPos));
	// 					}
	// 				};

	// 				if (keyPos == i) {
	// 					//Cannot happen for hyphen
	// 					// if we have only NewLine, we have to add empty space form to be able to position on this line
	// 					// we can't treat "\n" as two lines because in SmartBuilder a lot of content think different (treats it as one line)
	// 					newAcc = if (text == "\n") {
	// 						Cons(keyFragment, acc)
	// 					} else {
	// 						switch (keyFragment) {
	// 							NewLine(): {
	// 								// we should insert special element that forms empty line in rendering time.
	// 								// in edit mode (indexing >= 0) it should be InspectElement in order to be able to position in the line
	// 								// in preview mode (indexing < 0) it should be fixBaseline with appropriate height
	// 								newLineElement = if (0 <= indexing)
	// 									makeTEmptyLineInspectElement(indexing, style)
	// 								else 
	// 									makeTZeroSpaceElement(style);
	// 								Cons(keyFragment, Cons(newLineElement, acc))
	// 							}

	// 							default: Cons(keyFragment, acc);
	// 						}
	// 					}
	// 					^loop1(i + 1, indexing + 1, newAcc);
	// 				} else if (keyPos == textLen - 1) {
	// 					word = substring(text, i, keyPos - i); //println("word:" + word);
	// 					//Cannot happen for hyphen
	// 					//We have found following pattern: <more than zero non-special symbols><special symbol><end>
	// 					//So, recursive call will return Cons(makeTextFn(word), acc) in
	// 					//Cons(keyFragment, breakTextFragment(word, style, moreLineBreaks, indexing, acc));
	// 					//So, refactored as
	// 					Cons(keyFragment, Cons(makeTextFn(indexing, word), acc));
	// 					//to make the function tail recursive
	// 				} else {
	// 					doNotSkipSymbolDelta = if (posType == PositionCharCat()) 1 else 0;
	// 					word = substring(text, i, keyPos - i + doNotSkipSymbolDelta); //println("word:" + word);
	// 					^loop1(
	// 						keyPos + 1, indexing + keyPosRelative + 1,
	// 						if (posType == PositionCharCat())
	// 							Cons(makeTextFn(indexing, word), acc)
	// 						else
	// 							Cons(keyFragment, Cons(makeTextFn(indexing, word), acc))
	// 					)
	// 				}
	// 			}
	// 			None() : {
	// 				Cons(makeTextFn(indexing, strRight(text, i)), acc)
	// 			}
	// 		}
	// 	}
	// }; // loop1

	// ^loop1(0, indexingInit, init);
}

makeTSpace(space : string, style : [CharacterStyle]) -> TWord {
	if (space == "\u200b") TZeroWidthSpace(style) else TSpace(style)
}


makeTZeroSpaceElement(style : [CharacterStyle]) -> Tropic {
	spaceMetrics = getStaticFormSize(Text(" ", style));
	if (spaceMetrics.baseline > 0.0) { // incl. normal baseline and superscript
		TBaseline(const(spaceMetrics.baseline), TText(" ", style));
	} else {
		TBorder(0.0, -spaceMetrics.baseline, 0.0, 0.0, TText(" ", style))
	}
}

makeTEmptyLineInspectElement(indexing : int, style : [CharacterStyle]) -> TWrapElement {
	TInspectElement(
		ParaElementInspector(indexing, make(0.), make(0.), makeWH(), make(0.0), make(-1), make(false)),
		makeTZeroSpaceElement(style)
	)
}