import fusion_utils;
import tropic/tropic;
import tropic/tropic_optimize;
import tropic/tropic_resolve_css;
import tropic/tropic_util;
import ui/animate/spring;
import fform/renderfform;
import ui/scrollable;
import text/bidi_text;
// import tropic/tropic2string;

export {
	// Convert a tropic layout to a form
	tropic2form(b : Tropic, sheet : Stylesheet) -> Form;
	// Convert a tropic layout to a fform with availableWH as available
	tropic2fform(b : Tropic, sheet : Stylesheet, availableWH : Transform<WidthHeight>) -> FForm;
	// Convert a tropic layout to a real form that located not in zero point
	tropic2fformTranslated(b : Tropic, sheet : Stylesheet) -> FForm;
	tropic2formTranslated(b : Tropic, sheet : Stylesheet) -> Form;
	// This is not for general use
	staticTropic2fform(b : Tropic, sheet : Stylesheet) -> FForm;
	staticTropic2form(b : Tropic, sheet : Stylesheet) -> Form {staticTropic2fform(b, sheet) |> fform2form};

	tropic2nativeForm(b : Tropic, sheet : Stylesheet) -> Form;

	distributeAsks(
		fillers1 : Transform<double>,
		fillers2 : Transform<double>,
		min1 : Transform<double>,
		min2 : Transform<double>,
		max1 : Transform<double>,
		max2 : Transform<double>,
		av : Transform<double>,
		addFillers1 : Transform<bool>,
		addFillers2 : Transform<bool>
	) -> Pair<Transform<double>, Transform<double>>;
}

makeContext(availableWH : Transform<WidthHeight>) -> TParentInfo {
	TParentInfo(
		fwidth(availableWH),
		fheight(availableWH),
		makeTree(),
		const(zeroTransformMatrix)
	);
}

tropic2form(b : Tropic, sheet : Stylesheet) -> Form {
	availableWH = makeWH();

	tropic2fformWithContext(b, sheet, makeContext(availableWH), availableWH)
	|> fform2form
	|> (\f -> Inspect([IAvailable(availableWH)], f))
}

tropic2fform(b : Tropic, sheet : Stylesheet, availableWH : Transform<WidthHeight>) -> FForm {
	ot = optimizeTropic(resolveTropicCss(b, sheet));
	form = make(FEmpty());

	FConstructor(
		FMutable(form),
		\ -> {
			ba = tropic2Acc(ot, makeContext(availableWH), sheet, false);
			next(form, ba.form);

			\ -> applyall(ba.disposers)
		}
	)
}

tropic2fformTranslated(b : Tropic, sheet : Stylesheet) -> FForm {
	availableWH = makeWH();
	transformMatrix = make(getDummyTransformMatrix());

	transformMatrixFn = ref \ -> TransformMatrix(1., 0., 0., 1., 0., 0.);

	FConstructor(
		tropic2fformWithContext(TTag2(\fn -> transformMatrixFn := fn, b), sheet, makeContext(availableWH), availableWH),
		\ -> {
			// Repeatable timer to check transform matrix every new frame
			drawFrameDeltaTimer = makeDrawFrameEventListener();
			drawFrameDeltaTimer.attach();

			subscribe2(drawFrameDeltaTimer.timer, \__ -> {
				nextDistinct(
					transformMatrix,
					^transformMatrixFn()
				);
			})
			|> (\disp ->
				\ -> {
					drawFrameDeltaTimer.detach();
					disp();
					transformMatrixFn := \ -> TransformMatrix(1., 0., 0., 1., 0., 0.)
				}
			)
		}
	)
}

tropic2formTranslated(b : Tropic, sheet : Stylesheet) -> Form {
	availableWH = makeWH();
	transformMatrix = make(getDummyTransformMatrix());

	transformMatrixFn = ref \ -> TransformMatrix(1., 0., 0., 1., 0., 0.);

	FConstructor(
		tropic2fformWithContext(TTag2(\fn -> transformMatrixFn := fn, b), sheet, makeContext(availableWH), availableWH),
		\ -> {
			// Repeatable timer to check transform matrix every new frame
			drawFrameDeltaTimer = makeDrawFrameEventListener();
			drawFrameDeltaTimer.attach();

			subscribe2(drawFrameDeltaTimer.timer, \__ -> {
				nextDistinct(
					transformMatrix,
					^transformMatrixFn()
				);
			})
			|> (\disp ->
				\ -> {
					drawFrameDeltaTimer.detach();
					disp();
					transformMatrixFn := \ -> TransformMatrix(1., 0., 0., 1., 0., 0.)
				}
			)
		}
	)
	|> fform2form
	|> (\f -> Inspect([IAvailable(availableWH)], f))
}

tropic2fformWithContext(b : Tropic, sheet : Stylesheet, context : TParentInfo, availableWH : DynamicBehaviour<WidthHeight>) -> FForm {
	ot = optimizeTropic(resolveTropicCss(b, sheet));
	form = make(FEmpty());
	baseline = make(0.);
	wh = makeWH();

	FConstructor(
		FMutable(form),
		\ -> {
			ba = tropic2Acc(ot, context, sheet, false);
			next(form, ba.form);

			uns =
				[
					fconnect(ba.metrics.baseline, baseline),
					fconnect(fwidthheight(ba.metrics.width, ba.metrics.height), wh)
				];

			\ -> applyall(concat(ba.disposers, uns))
		}
	)
	|> (\f -> FBaseline(baseline, FSize2(wh, FAvailable2(availableWH, f))))
}

staticTropic2fform(b : Tropic, sheet : Stylesheet) -> FForm {
	ot = optimizeTropic(resolveTropicCss(b, sheet));

	context = TParentInfo(
		zero,
		zero,
		makeTree(),
		const(zeroTransformMatrix)
	);

	tropic2Acc(ot, context, sheet, false).form;
}

tropic2nativeForm(tr : Tropic, sheet : Stylesheet) -> Form {
	metrics = make(FormMetrics(0., 0., 0., 0.));
	transformMatrix = make(getDummyTransformMatrix());

	trop =
		TransformTAcc2(\t2a -> {
			b = tr |> t2a;

			TAcc(b with disposers =
				arrayPush(
					b.disposers,
					fconnect(
						fselect3(b.metrics.width, b.metrics.height, b.metrics.baseline,
							\wd, hgt, bsln -> FormMetrics(wd, hgt, bsln, hgt)),
						metrics
					)
				)
			)
		});

	form : ref Pair<int, FForm> = ref Pair(-1, FEmpty());
	transformMatrixFn = ref \ -> TransformMatrix(1., 0., 0., 1., 0., 0.);
	available = makeWH();

	Inspect(
		[IAvailable2(available)],
		NativeForm(
			trop,
			metrics,
			\ -> fform2form(^form.second),
			\__, zorder, tabOrder -> {
				tropic2Acc(
					TTag2(\fn -> transformMatrixFn := fn, trop),
					TParentInfo(
						fwidth(available),
						fheight(available),
						makeTree(),
						transformMatrix
					),
					sheet,
					false
				)
				|> (\f : TAcc -> {
					formId = ^form.first + 1;
					form := Pair(formId, f.form);

					FDisposer(
						f.form,
						\ -> {
							applyall(f.disposers);
							if (^form.first == formId) {
								form := Pair(formId, FEmpty());
								nextDistinct(metrics, FormMetrics(0., 0., 0., 0.));
							}
						}
					);
				})
				|> (\f -> renderFForm(f, const(zorder)))
				|> (\f -> {
					disposers =
						concat(
							[
								addEventListener(f.clips[0], "transformchanged", \ -> nextDistinct(transformMatrix, ^transformMatrixFn())),
								\ -> transformMatrixFn := \ -> TransformMatrix(1., 0., 0., 1., 0., 0.)
							],
							f.disposers
						);

					NativeRenderResult(
						f.clips,
						\ -> applyall(disposers)
					);
				})
			}
		)
	)
}

tropic2Acc(b : Tropic, parent : TParentInfo, sheet : Stylesheet, metricsOnly : bool) -> TAcc {
	TAcc(FEmpty(), TFormMetrics(zero, zero, zero), zero, zero, zero, zero, zero, zero, const(false), false, false, [])
}

returnTAcc(bf : TAcc, fform : () -> FForm, metricsOnly : bool) -> TAcc {
	if (metricsOnly)
		bf
	else
		TAcc(bf with form = fform())
}


// Given asks for a budget, as well as a minimum, allocate the budget we have fairly
distributeAsks(
	fillers1 : Transform<double>,
	fillers2 : Transform<double>,
	min1 : Transform<double>,
	min2 : Transform<double>,
	max1 : Transform<double>,
	max2 : Transform<double>,
	av : Transform<double>,
	addFillers1 : Transform<bool>,
	addFillers2 : Transform<bool>
) -> Pair<Transform<double>, Transform<double>> {
	fselect9(fillers1, fillers2, fpreventNanOrInf(min1), fpreventNanOrInf(min2), max1, max2, av, addFillers1, addFillers2,
		\f1, f2, mn1, mn2, mx1, mx2, a, af1, af2 -> {
			mn = mn1 + mn2;

			if (mn >= a || f1 + f2 <= 0.0) { // If minimum is more than available or there are no fillers then use min values
				Pair(mn1, mn2);
			} else if (f1 <= 0.0) {
				if (f2 <= 0.0) {
					Pair(mn1, mn2);
				} else {
					Pair(mn1, max(min(a - mn1, mx2), mn2));
				}
			} else if (f2 <= 0.0) {
				Pair(max(min(a - mn2, mx1), mn1), mn2);
			} else {
				mx = mx1 + mx2;

				if (mx <= a || mn >= mx) { // If maximum is less than available or max equals min then use max values
					Pair(mx1, mx2);
				} else {
					ad = a - (if (af1) mn1 else 0.0) - (if (af2) mn2 else 0.0);
					s1 = max(min(ad * f1 / (f1 + f2) + (if (af1) mn1 else 0.0), mx1), mn1);
					s2 = a - s1;

					if (s2 < mn2) {
						Pair(max(a - mn2, mn1), mn2);
					} else if (s2 > mx2) {
						Pair(min(a - mx2, mx1), mx2);
					} else {
						Pair(s1, s2);
					}
				}
			}
		}
	)
	|> (\f -> Pair(fFirstOfPair(f), fSecondOfPair(f)))
}

// TDynamicGroup tools

TDynamicGroupItem : (
	acc : TAcc,
	index : DynamicBehaviour<int>,
	position : Transform<Point>
);

zeroTDynamicGroupItem = TDynamicGroupItem(zeroTAcc, make(0), const(zeroPoint));

fsubselectFn(
	array : Transform<[?]>,
	key : (?) -> Transform<??>,
	fn : FFn2<??, ??, ??>,
	def : ??
) -> Transform<??> {
	fsubselect(
		fselect(array, FLift(\a -> map(a, key))),
		FLift(\v : [Transform<??>] ->
			if (length(v) > 0)
				fold(v, const(def), \acc : Transform<??>, v1 : Transform<??> -> fselect2(acc, v1, fn))
			else
				ConstBehaviour(def)
		)
	);
}