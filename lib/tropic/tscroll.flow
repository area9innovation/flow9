import tropic/tropic_gui;
import tropic/tropic_manager;
import ui/animate/teasing;
import sys/keycodes;
import ui/focus;

export {
	TScroll(manager : TManager, content : Tropic, box : Tropic, style : [TScrollStyle]) -> Tropic;

	TScrollStyle ::= TScrollSetPosition, TScrollBound, TScrollInspectVisible, TScrollEnabled, TScrollDontHandle, TScrollPersistent,
		TScrollDisableMouseWheel, TReverseMouseWheel, TScrollDisableOutOfBounds, TScrollKeysEnabled, TScrollbarsVisible,
		TScrollbars, TExpandOnHover, TScrollBarTop, TScrollBarLeft, TScrollCropByContent, TScrollOutOfBounds, TScrollWidthHeight, TEnabled,
		TOnScrolledToBottom, TOnScrolledToSide, TKeyFilter, TScrollFadeContent, TScrollMouseEnabled, TScrollPosition,
		TCurrentInteractive, TMouseXY, TScrollMoving, TScrollXMoving, TScrollYMoving, TScrollInspectShowScrolling, TSetRTL, TScrollPercent,
		TScrollbarsAdditionalBox, TScrollbarOverlapContent;

		// Provides ability to move to a specific place. (Does not reflect where it is placed)
		TScrollSetPosition(position : Transform<Point>);

			TTopLeft(top : Transform<double>, left : Transform<double>) -> TScrollSetPosition { TScrollSetPosition(fpoint(top, left)); };

		// Do we restrict dragging "out" of bounds? Setting to false will allow swiping content over of bound.
		TScrollBound(x : Transform<bool>, y : Transform<bool>);

		// Provide insight into what is currently visible.
		TScrollInspectVisible(topleft : DynamicBehaviour<Point>, widthHeight : DynamicBehaviour<WidthHeight>);

		TScrollEnabled(enabled : Transform<bool>);

		// Do not handle the mouse events, so they are also sent to stuff below
		TScrollDontHandle();

		// Disables Mouse Wheel
		TScrollDisableMouseWheel();
		TReverseMouseWheel();

		TScrollDisableOutOfBounds(disable : Transform<bool>);
		TScrollKeysEnabled(enabled : Transform<bool>);
		TKeyFilter(fn : (key : KeyEvent) -> bool);
		TScrollbarsVisible(x : DynamicBehaviour<bool>, y : DynamicBehaviour<bool>);

		// If false - hides scrollbars if no scroll is happening
		// true by default
		TScrollPersistent(persistent : Transform<bool>);

			TShowScrollbars(show : bool) -> TScrollPersistent { TScrollPersistent(const(!mobile || show)); };

		TScrollbars(x : TScrollbarStyle, y : TScrollbarStyle);

			TScrollbarStyle(visible : Transform<bool>, thickness : Transform<double>, bar : (down : Transform<bool>, hover : Transform<bool>) -> Tropic, background : (down : Transform<bool>, hover : Transform<bool>) -> Tropic);

			standardScrollBar =
				TScrollbarStyle(
					const(true),
					const(if (mobile) 8. else 16.),
					\__, __ -> TBorder4(
						2.,
						TRounded4(2., [Fill(0xeeeeee)], TFillXY())
					),
					\__, __ -> TRectangle([Fill(0x888888)], TFillXY())
				);
			invisibleScrollBar =
				TScrollbarStyle(
					const(false),
					zero,
					\__, __ -> TEmpty(),
					\__, __ -> TEmpty()
				);
			minimalScrollBarLight =
				TScrollbarStyle(
					const(true),
					const(if (mobile) 8. else 16.),
					\__, __ -> TRectangle([Fill(0xeeeeee)], TFillXY()),
					\__, __ -> TEmpty()
				);
			minimalScrollBarDark =
				TScrollbarStyle(
					const(true),
					const(if (mobile) 8. else 16.),
					\__, __ -> TRectangle([Fill(0x101010)], TFillXY()),
					\__, __ -> TEmpty()
				);
			materialScrollBar =
				TScrollbarStyle(
					const(true),
					const(if (mobile) 8. else 16.),
					\ins, dwn ->
						TBorder4(
							if (mobile) 2. else 4.,
							TAlpha(
								fif(dwn, const(1.0), fif(ins, const(0.8), const(0.6))),
								TRoundedFull([Fill(0x888888), Stroke(white), StrokeOpacity(0.3)], TFillXY())
							)
						),
					\__, __ -> TEmpty()
					// \ins, dwn ->
					// 	TAlpha(
					// 		fselectdelay(fif(fOr(dwn, ins), const(0.7), zero), \v -> if (v == 0.7) 0 else 800),
					// 		TRectangle([Fill(white), Stroke(0x888888), StrokeOpacity(0.3)], TFillXY())
					// 	)
				);

			TScrollBarStyle(visible : Behaviour<bool>, thickness : double, fg : [TGraphicsStyle], bg : [TGraphicsStyle]) -> TScrollbarStyle {
				TScrollbarStyle(visible, const(thickness), \__, __ -> TRectangle(fg, TFillXY()), \__, __ -> TRectangle(bg, TFillXY()));
			};

			TScrollBarsStyle(x : TScrollbarStyle, y : TScrollbarStyle) -> TScrollbars { TScrollbars(x, y); };

		TScrollbarsAdditionalBox(box : Transform<WidthHeight>);

		TExpandOnHover(expand : bool);

		TScrollBarTop();
		TScrollBarLeft();

		TScrollCropByContent();
		TScrollOutOfBounds(x : DynamicBehaviour<double>, y : DynamicBehaviour<double>);

		TScrollWidthHeight(content : DynamicBehaviour<WidthHeight>, box : DynamicBehaviour<WidthHeight>);

		TOnScrolledToBottom(event : () -> void);
		TOnScrolledToSide(event : () -> void);

		TScrollFadeContent(color : int, width : double);

		TScrollMouseEnabled(enabled : Transform<bool>);
		TScrollPosition(position : DynamicBehaviour<Point>);
		TScrollPercent(percent : DynamicBehaviour<Point>);

		TCurrentInteractive(current : DynamicBehaviour<Maybe<bool>>);
		TScrollMoving(moving : DynamicBehaviour<bool>);
		TScrollXMoving(moving : DynamicBehaviour<bool>);
		TScrollYMoving(moving : DynamicBehaviour<bool>);

		TScrollInspectShowScrolling(show : DynamicBehaviour<bool>);

		TScrollbarOverlapContent(overlap : bool); // true by default

	makeTScrollInspectVisible() -> TScrollInspectVisible;

	nativeScroll = \ -> isUrlParameterTrue("native_scroll") && getRendererType() == "html";
}

TScroll(manager : TManager, content : Tropic, box : Tropic, style : [TScrollStyle]) -> Tropic {
	scrollId = makeTagId(manager);
	isRTL = extractStruct(style, TSetRTL(getDefaultRtl())).rtl;
	// Current scroll offset
	scrollPosition = make(zeroPoint);
	scrollPercent = tryExtractStruct(style, TScrollPercent(make(zeroPoint)));
	cropByContent = contains(style, TScrollCropByContent());
	inspectVisible = tryExtractStruct(style, makeTScrollInspectVisible());
	setPosition = tryExtractStruct(style, TScrollSetPosition(const(zeroPoint)));
	// Do we restrict dragging "out" of bounds? Setting to false will allow swiping content over of bound.
	scrollBound = extractStruct(style, TScrollBound(const(true), const(true)));
	scrollOutOfBounds = tryExtractStruct(style, TScrollOutOfBounds(make(0.), make(0.)));
	enabled = extractStruct(style, TScrollEnabled(const(true))).enabled;
	wh = extractStruct(style, TScrollWidthHeight(makeWH(), makeWH()));
	// Pass clicks to lower elements
	scrollHandle = !contains(style, TScrollDontHandle());
	currentInteractive = extractStruct(style, TCurrentInteractive(make(None()))).current;
	mouseEnabled = extractStruct(style, TScrollMouseEnabled(const(true))).enabled;

	overlapContent =
		if (isUrlParameterTrue("scroll_overlap_debug"))
			false
		else
			extractStruct(style, TScrollbarOverlapContent(true)).overlap;

	scrollBarStyles = extractStruct(style, TScrollbars(standardScrollBar, standardScrollBar));
	scrollBarsVisible = extractStruct(style, TScrollbarsVisible(make(false), make(false)));
	scrollBarsAdditionalBox = extractStruct(style, TScrollbarsAdditionalBox(
		if (overlapContent) const(WidthHeight(0., 0.))
		else fwh(scrollBarStyles.y.thickness, scrollBarStyles.x.thickness)
	)).box;
	scrollFadeContent = tryExtractStruct(style, TScrollFadeContent(0, 0.0));

	onScrolledToBottom = tryExtractStruct(style, TOnScrolledToBottom(nop));
	onScrolledToSide = tryExtractStruct(style, TOnScrolledToSide(nop));

	// WidthHeight of content
	contentWH = wh.content;
	// WidthHeight of available box
	boxWH0 : DynamicBehaviour<WidthHeight> = wh.box;
	boxWHCutted =
		if (overlapContent)
			boxWH0
		else
			fwhsubtract(boxWH0, fstall(fwh(
				fif(scrollBarsVisible.y, scrollBarStyles.y.thickness, const(0.)),
				fif(scrollBarsVisible.x, scrollBarStyles.x.thickness, const(0.))
			), 0));

	// Maximum scroll offset (0 if content fits available box)
	maxWH = fwhmax(fwhsubtract(contentWH, boxWHCutted), const(WidthHeight(0., 0.)));

	// Is moving by axis
	xMoving = extractStruct(style, TScrollXMoving(make(false))).moving;
	yMoving = extractStruct(style, TScrollYMoving(make(false))).moving;
	currentPoint = extractStruct(style, TMouseXY(make(zeroPoint))).point;
	// Is mouse down and scroll is moving
	moving = extractStruct(style, TScrollMoving(make(false))).moving;

	// Mouse down of the bars
	downXBar = make(false);
	downYBar = make(false);

	showScrolling =
		fthrottleNextFrame(fselect2(contentWH, boxWH0, FLift2(\cwh, bwh ->
			cwh.height > 0. && cwh.width > 0. && (dfloor(cwh.height) > bwh.height || dfloor(cwh.width) > bwh.width)
		)));

	inspectShowScrolling = tryExtractStruct(style, TScrollInspectShowScrolling(make(false)));

	TransformTAcc2(\t2a -> {
		boxWH =
			if (cropByContent)
				fwhmin(boxWHCutted, contentWH)
			else
				boxWHCutted;

		b = TAttachBox(box, boxWH0) |> t2a;

		cAcc = ref zeroTAcc;
		c0 = {
			cont =
				TFrame(
					0.0,
					0.0,
					interactiveRectangleStyle,
					TAttachBox(content, contentWH)
				)
				|> (\t -> TAvailable(t,	
					if (overlapContent) TSizedWidthHeight(b.metrics.width, b.metrics.height)
					else TSized(boxWHCutted)
				));

			if (cropByContent)
				TransformTAcc2(\t2a2 -> {
					cAcc := cont |> t2a2;
					^cAcc;
				})
			else
				cont
		}

		c =
			TGroupWithoutMetrics([
				TShowLazy(
					fand(showScrolling, enabled),
					\ -> TScrollHandlePosition(scrollId, manager, style, contentWH, boxWH, scrollPosition, maxWH,
						currentPoint, xMoving, yMoving, inspectVisible, scrollBound, moving, currentInteractive, downXBar, downYBar,
						TRectangle(interactiveRectangleStyle, TSized(boxWH)))
				),
				TConstruct(
					[
						make3SubscribeTrigger(fnot(showScrolling), maxWH, scrollBound.x, scrollBound.y, \mwh, by, bx ->
							nextDistinct(scrollPosition, boundScrollPosition(getValue(scrollPosition), mwh, by, bx))
						)
					]
					|> (\f2 ->
						eitherMap(
							scrollPercent,
							\percent ->
								arrayPush(
									f2,
									\ -> fBidirectionalLink(
										fselect(percent.percent, FLift(\p -> {
											mwh = fgetValue(maxWH);
											newScrollPosition = Point(
												p.x * mwh.width,
												p.y * mwh.height
											);
											boundScrollPosition(newScrollPosition, mwh, fgetValue(scrollBound.x), fgetValue(scrollBound.y))
										})),
										fselect2(scrollPosition, maxWH, FLift2(\sp, mwh ->
											Point(
												if (equalDoubles(mwh.width, 0.0)) 0.0 else sp.x / mwh.width,
												if (equalDoubles(mwh.height, 0.0)) 0.0 else sp.y / mwh.height
											)
										)),
										\sp -> nextDistinct(scrollPosition, sp),
										\p -> next(percent.percent, p)
									)
								),
							f2
						)
					)
					|> (\f2 ->
						eitherMap(
							inspectShowScrolling,
							\iss ->
								concat(
									f2,
									[
										\ -> fconnect(showScrolling, iss.show)
									]
								),
							f2
						)
					)
					|> (\f2 ->
						eitherMap(
							inspectVisible,
							\iv ->
								concat(
									f2,
									[
										\ -> fconnect(scrollPosition, iv.topleft),
										\ -> fconnect(boxWH, iv.widthHeight)
									]
								),
							f2
						)
					)
					|> (\f2 ->
						eitherMap(
							setPosition,
							\sp ->
								arrayPush(
									f2,
									makeSubscribe(
										sp.position,
										\p ->
											nextDistinct(
												scrollPosition,
												boundScrollPosition(p, fgetValue(maxWH), fgetValue(scrollBound.x), fgetValue(scrollBound.y))
											)
									)
								),
							f2
						)
					)
					|> (\f2 ->
						eitherMap(
							scrollOutOfBounds,
							\soob ->
								arrayPush(
									f2,
									make2Subscribe(scrollPosition, maxWH, \sp, mwh -> {
										nextDistinct(soob.x, if (sp.x < 0.) sp.x else max(sp.x - mwh.width, 0.));
										nextDistinct(soob.y, if (sp.y < 0.) sp.y else max(sp.y - mwh.height, 0.));
									})
								),
							f2
						)
					)
					|> (\f2 ->
						arrayPush(
							f2,
							makeSubscribe(currentInteractive, \ci -> {
								eitherFn(
									ci,
									\bl -> {
										if (!bl) {
											addInteractionItemId(manager, scrollId);
										} else {
											blockOtherInteractionItemIds(manager, scrollId);
										}
									},
									\ -> {
										removeInteractionItemId(manager, scrollId);
										next(moving, false);
										nextDistinct(downXBar, false);
										nextDistinct(downYBar, false);
									}
								)
							})
						)
					)
					|> (\f2 ->
						eitherMap(
							tryExtractStruct(style, TScrollPosition(make(zeroPoint))),
							\sp ->
								arrayPush(
									f2,
									\ -> bidirectionalLink(
										sp.position,
										scrollPosition,
										\p -> boundScrollPosition(p, fgetValue(maxWH), fgetValue(scrollBound.x), fgetValue(scrollBound.y)),
										idfn
									)
								),
							f2
						)
					),
					c0
					|> (\t -> if (isSome(onScrolledToBottom) || isSome(onScrolledToSide))
							TransformTAcc2(\t2a2 -> {
								c1 = t2a2(t);
								disp =
									concatA([
										c1.disposers,
										eitherMap(
											onScrolledToBottom,
											\onBottom ->
											[
												makeSubscribe(
													fselect3(
														b.metrics.height,
														c1.metrics.height,
														scrollPosition,
														\bH, cH, sPos ->
															bH + sPos.y >= cH
													),
													\isBottom ->
														if (isBottom)
															onBottom.event()
												)()
											],
											[]
										),
										eitherMap(
											onScrolledToSide,
											\onSide ->
											[
												makeSubscribe(
													if (isRTL)
														fselect(
															scrollPosition,
															FLift(\sPos ->
																sPos.x <= 0.0
															)
														)
													else
														fselect3(
															b.metrics.width,
															c1.metrics.width,
															scrollPosition,
															\bW, cW, sPos ->
																bW + sPos.x >= cW
														),
													\isSide ->
														if (isSide)
															onSide.event()
												)()
											],
											[]
										)
									]);

								TAcc(c1 with disposers = disp)
							})
						else
							t
					)
					|> (\t ->
						if (nativeScroll())
							TScrollRectT(scrollPosition, boxWH, t, enabled)
						else
							TCrop(scrollPosition, boxWH, t)
					)
				),
				eitherMap(
					scrollFadeContent,
					\sfc -> {
						gradientPointsStart = [GradientPoint(sfc.color, 0.0, 1.0), GradientPoint(sfc.color, 1.0, 0.0)];
						gradientPointsEnd = [GradientPoint(sfc.color, 0.0, 0.0), GradientPoint(sfc.color, 1.0, 1.0)];

						makeGradientBorder = \vertical -> {
							gradientBlock = \offset, gradientPoints ->
								TFrame(
									0.0,
									0.0,
									[GradientFill(if (vertical) 90.0 else 0.0, gradientPoints)],
									if (vertical) TFillXH(sfc.width) else TFillWY(sfc.width)
								)
								|> (\t -> TAlpha(fmin(fdivide(offset, const(sfc.width)), const(1.)), t));

							[
								gradientBlock(
									if (vertical) fpointY(scrollPosition)
									else fpointX(scrollPosition),
									gradientPointsStart
								),
								if (vertical) TFillY() else TFillX(),
								gradientBlock(
									if (vertical) fsubtract(fheight(maxWH), fpointY(scrollPosition))
									else fsubtract(fwidth(maxWH), fpointX(scrollPosition)),
									gradientPointsEnd
								)
							]
							|> (\t -> if (vertical) TLines(t) else TColsDir(t, isRTL));
						}
						TGroup2(
							TShowLazy(
								fgreater(fheight(maxWH), const(0.)),
								\ -> makeGradientBorder(true)
							),
							TShowLazy(
								fgreater(fwidth(maxWH), const(0.)),
								\ -> makeGradientBorder(false)
							)
						)
					},
					TEmpty()
				)
				|> (\t -> TAvailable(t, TSized(boxWH))),
				TInteractive(
					[
						MouseDown(\mi -> {
							if (fgetValue(mouseEnabled) && fgetValue(showScrolling) && fgetValue(enabled) && mi.inside()) {
								next(currentPoint, Point(mi.x, mi.y));
								next(moving, true);
								nextDistinct(currentInteractive, Some(false));
								scrollHandle && (getValue(xMoving) || getValue(yMoving))
							} else {
								false
							}
						}),
						MouseUp(\__ -> { nextDistinct(currentInteractive, None()); false })
					],
					TRectangle(interactiveRectangleStyle, TSized(boxWH))
				),
				if (nativeScroll())
					TEmpty()
				else
					TShowLazy(
						showScrolling,
						\ -> createTScrollBars(
							manager,
							scrollId,
							replaceStruct(style, scrollBarsVisible),
							contentWH,
							boxWH,
							scrollPosition,
							currentInteractive,
							downXBar,
							downYBar,
							xMoving,
							yMoving,
							TRectangle(interactiveRectangleStyle, TSized(fwhaddition(boxWH, scrollBarsAdditionalBox)))
						)
					)
			])
			|> t2a;

		if (cropByContent)
			TAcc(
				c.form,
				minMetrics(b.metrics, ^cAcc.metrics),
				fmin(b.minWidth, ^cAcc.minWidth),
				fmin(b.minHeight, ^cAcc.minHeight),
				b.maxWidth,
				b.maxHeight,
				b.xFillers,
				b.yFillers,
				const(false),
				false,
				false,
				concat(b.disposers, c.disposers)
			)
		else
			TAcc(
				c.form,
				b.metrics,
				b.minWidth,
				b.minHeight,
				b.maxWidth,
				b.maxHeight,
				b.xFillers,
				b.yFillers,
				b.addFillers,
				b.xConstant,
				b.yConstant,
				concat(b.disposers, c.disposers)
			)
	})
}

TScrollRectT(scrollPosition : DynamicBehaviour<Point>, boxWH : Transform<WidthHeight>, t : Tropic, enabled : Transform<bool>) -> Tropic {
	TransformTAcc(\t2a, parent, sheet, metricsOnly -> {
		x1 = fpointX(scrollPosition);
		y1 = fpointY(scrollPosition);
		wi = fwidth(boxWH);
		he = fheight(boxWH);

		bf =
			t2a(
				t,
				TParentInfo(parent with
					transformMatrix = fworldtransform(parent.transformMatrix, fpoint2transform(fpoint(fnegate(x1), fnegate(y1))))
				),
				sheet,
				metricsOnly
			);
		fm = make(zeroMetrics);

		TAcc(
			if (metricsOnly)
				FEmpty()
			else
				FNativeForm(
					t,
					fm,
					\ -> FCrop(
							x1,
							y1,
							wi,
							he,
							bf.form
						),
					\av, zo, to -> {
						scrollResponse = ref false;
						scrollPositionResponse = ref false;

						clip = makeClip();

						d0 = renderFForm(bf.form, const(zo));
						d = attachFChildren(clip, d0.clips, d0.disposers, [FClipMove(), FClipRotate(), FClipScale(), FClipMask()]);

						disposers =
							concat(
								d.disposers,
								[
									make2Subscribe(bf.metrics.width, bf.metrics.height, \wd, hgt ->
										setContentRect(clip, wd, hgt)
									)(),
									make2Subscribe(scrollPosition, boxWH, \sp, bwh -> {
										if (!^scrollResponse) {
											scrollPositionResponse := true;
											setScrollRect(clip, sp.x, sp.y, bwh.width, bwh.height);
											scrollPositionResponse := false;
										}
									})(),
									makeSubscribeUns(enabled, \en ->
										if (en)
											[
												listenScrollRect(clip, \dx, dy -> {
													if (!^scrollPositionResponse) {
														scrollResponse := true;
														nextDistinct(scrollPosition, Point(dx, dy));
														scrollResponse := false;
													}
												})
											]
										else
											[]
									)(),
									fconnect(fselect(boxWH, FLift(\wh -> FormMetrics(wh.width, wh.height, wh.height, wh.height))), fm)
								]
							);

						NativeRenderResult(
							[clip],
							\ -> applyall(disposers)
						)
					}
				),
			TFormMetrics(
				wi,
				he,
				he
			),
			wi,
			he,
			wi,
			he,
			bf.xFillers, bf.yFillers, bf.addFillers,
			bf.xConstant && isFConst(x1) && isFConst(wi),
			bf.yConstant && isFConst(y1) && isFConst(he),
			bf.disposers
		)
	})
}

TScrollHandlePosition(scrollId : int, manager : TManager, style : [TScrollStyle], contentWH : Transform<WidthHeight>,
	boxWH : Transform<WidthHeight>, scrollPosition : DynamicBehaviour<Point>, maxWH : Transform<WidthHeight>, currentPoint : DynamicBehaviour<Point>,
	xMoving: DynamicBehaviour<bool>, yMoving : DynamicBehaviour<bool>, inspectVisible : Maybe<TScrollInspectVisible>, scrollBound : TScrollBound,
	moving : DynamicBehaviour<bool>, currentInteractive : DynamicBehaviour<Maybe<bool>>, downXBar : DynamicBehaviour<bool>,
	downYBar : DynamicBehaviour<bool>, tr : Tropic) -> Tropic {
	// Disable mouse wheel
	disableWheel = contains(style, TScrollDisableMouseWheel());
	// Reverse mouse wheel
	reverseWheel = contains(style, TReverseMouseWheel());
	disableOutOfBounds = extractStruct(style, TScrollDisableOutOfBounds(const(false))).disable;

	keysEnabled = extractStruct(style, TScrollKeysEnabled(const(false))).enabled;
	keyFilter = extractStruct(style, TKeyFilter(\__ -> true)).fn;

	// Previous point on mouse down
	startPoint = ref zeroPoint;

	// last 10 velocities by axis
	speedX : ref [double] = ref [];
	speedY : ref [double] = ref [];

	blocked = ref false;
	frRate = 66;
	deltaX = make(0.);
	deltaY = make(0.);

	// Speed of slowing down after mouse is released
	slowingSpeedX = 1. - 7. / i2d(frRate);
	slowingSpeedY = 1. - 7. / i2d(frRate);
	borderSlowingSpeed = 0.3;
	borderSlowingSpeed2 = borderSlowingSpeed * 33. / i2d(frRate);
	borderAcceleration = 1. - borderSlowingSpeed2;

	// Looks much smoother with twice the rate of deltaTimer in manager.
	deltaTimer = manager.deltaTimer;

	uns = initUnsM();
	draggingUns = initUnsM();

	releasedFn = \p -> {
		sp = getValue(scrollPosition);

		sx = length(^speedX) |> (\f3 -> if (f3 > 0) dsum(^speedX) / i2d(f3) else 0.);
		sy = length(^speedY) |> (\f3 -> if (f3 > 0) dsum(^speedY) / i2d(f3) else 0.);

		newX =
			(if (abs(sx) > 33.) {
				nx = sp.x + sx * p;
				speedX := [sx * slowingSpeedX *
					(if (nx < 0. || nx > fgetValue(maxWH).width) borderSlowingSpeed2 else 1.)];
				nx
			} else if (sp.x < 0.) {
				if (sp.x > -0.5) 0. else sp.x * borderAcceleration
			} else if (sp.x > fgetValue(maxWH).width) {
				if (sp.x < fgetValue(maxWH).width + 0.5)
					fgetValue(maxWH).width
				else
					fgetValue(maxWH).width + (sp.x - fgetValue(maxWH).width) * borderAcceleration
			} else {
				sp.x
			})
			|> (\f -> if (fgetValue(disableOutOfBounds)) min(max(0., f), fgetValue(maxWH).width) else f);

		newY =
			(if (abs(sy) > 33.) {
				ny = sp.y + sy * p;
				speedY := [sy * slowingSpeedY *
					(if (ny < 0. || ny > fgetValue(maxWH).height) borderSlowingSpeed2 else 1.)];
				ny
			} else if (sp.y < 0.) {
				if (sp.y > -0.5) 0. else sp.y * borderAcceleration
			} else if (sp.y > fgetValue(maxWH).height) {
				if (sp.y < fgetValue(maxWH).height + 0.5)
					fgetValue(maxWH).height
				else
					fgetValue(maxWH).height + (sp.y - fgetValue(maxWH).height) * borderAcceleration
			} else {
				sp.y
			})
			|> (\f -> if (fgetValue(disableOutOfBounds)) min(max(0., f), fgetValue(maxWH).height) else f);

		xMoving0 = newX != sp.x;
		yMoving0 = newY != sp.y;

		nextDistinct(xMoving, xMoving0);
		nextDistinct(yMoving, yMoving0);

		nextDistinct(scrollPosition, Point(newX, newY));

		if (!xMoving0 && !yMoving0)
			dispUnsM(uns);
	}

	attachNewFn = \fn -> {
		dispUnsM(uns);
		deltaTimer.attach();

		setUnsM(
			uns,
			subscribe(deltaTimer.timer, fn)
			|> (\f -> \ -> {f(); deltaTimer.detach();})
		);
	}

	movingFn = \p -> {
		if (getValue(moving) && isCurrentInteractionItemId(manager, scrollId) && getValue(manager.dragging) == -1) {
			sp = getValue(scrollPosition);

			dx = ^startPoint.x - getValue(currentPoint).x;
			nx = sp.x + dx;

			dy = ^startPoint.y - getValue(currentPoint).y;
			ny = sp.y + dy;

			newX =
				if (fgetValue(scrollBound.x)) {
					if (fgetValue(maxWH).width == 0. || fgetValue(disableOutOfBounds)) {
						min(max(0., nx), fgetValue(maxWH).width)
					} else if (nx < 0. || nx > fgetValue(maxWH).width) {
						sp.x + dx * borderSlowingSpeed;
					} else {
						nx
					}
				} else {
					nx
				}

			newY =
				if (fgetValue(scrollBound.y)) {
					if (fgetValue(maxWH).height == 0. || fgetValue(disableOutOfBounds)) {
						min(max(0., ny), fgetValue(maxWH).height)
					} else if (ny < 0. || ny > fgetValue(maxWH).height) {
						sp.y + dy * borderSlowingSpeed;
					} else {
						ny
					}
				} else {
					ny
				}

			xMoving0 = newX != sp.x;
			yMoving0 = newY != sp.y;

			if (!^blocked && ((xMoving0 && abs(dx) > abs(dy) && abs(dx) > 4.) || (yMoving0 && abs(dy) > abs(dx) && abs(dy) > 4.))) {
				blocked := true;

				nextDistinct(currentInteractive, Some(true))
			} else {
				nextDistinct(scrollPosition, Point(newX, newY));

				nextDistinct(xMoving, xMoving0);
				nextDistinct(yMoving, yMoving0);
			}

			speedX := pushWithLimit(^speedX, (newX - sp.x) / p, 5);
			speedY := pushWithLimit(^speedY, (newY - sp.y) / p, 5);

			startPoint := getValue(currentPoint);
		} else {
			nextDistinct(currentInteractive, None());

			attachNewFn(releasedFn);
		}
	}

	updateContentAndBoxPosition = \content, box -> {
		nextDistinct(
			scrollPosition,
			boundScrollPosition(getValue(scrollPosition), fgetValue(maxWH), fgetValue(scrollBound.x), fgetValue(scrollBound.y))
		);
	}

	startMoving = \xy -> {
		blocked := false;
		next(currentPoint, xy);
		startPoint := xy;
		next(moving, true);

		attachNewFn(movingFn);

		maybeApply(inspectVisible, \iv ->
			if (getValue(xMoving) || getValue(yMoving)) {
				sp = getValue(scrollPosition);

				if ((fgetValue(maxWH).height == 0. || (sp.y > 0. && sp.y < fgetValue(maxWH).height)) &&
					(fgetValue(maxWH).width == 0. || (sp.x > 0. && sp.x < fgetValue(maxWH).width))) {
					next(iv.topleft, getValue(scrollPosition));
				}
			}
		);

		speedX := [];
		speedY := [];
	}

	scrollStep = 20.;
	changeDirection = \ke -> if (js) ke.shift else ke.alt;
	inside = make(false);
	mouseWheelPos = ref None();

	// Interactives for mouse and keyboard handling
	TInteractive(
		[
			TMouseInside(inside, false),
			KeyDown2(\handled, ke -> {
				if (fgetValue(keysEnabled) && !handled && !hasKeyboardFocus() && getValue(inside) && keyFilter(ke)) {
					if (ke.utf == "up") {
						sp = getValue(scrollPosition);
						nextDistinct(scrollPosition, Point(sp.x, max(0., sp.y - scrollStep)));
						true
					} else if (ke.utf == "down") {
						sp = getValue(scrollPosition);
						nextDistinct(scrollPosition, Point(sp.x, min(sp.y + scrollStep, fgetValue(maxWH).height)));
						true
					} else if (ke.utf == "left") {
						sp = getValue(scrollPosition);
						nextDistinct(scrollPosition, Point(max(0., sp.x - scrollStep), sp.y));
						true
					} else if (ke.utf == "right") {
						sp = getValue(scrollPosition);
						nextDistinct(scrollPosition, Point(min(sp.x + scrollStep, fgetValue(maxWH).width), sp.y));
						true
					} else if (ke.keycode == KEY_PAGEUP) {
						sp = getValue(scrollPosition);
						if (changeDirection(ke))
							nextDistinct(scrollPosition, Point(max(0., sp.x - fgetValue(boxWH).width), sp.y))
						else
							nextDistinct(scrollPosition, Point(sp.x, max(0., sp.y - fgetValue(boxWH).height)));
						true
					} else if (ke.keycode == KEY_PAGEDOWN) {
						sp = getValue(scrollPosition);
						if (changeDirection(ke))
							nextDistinct(scrollPosition, Point(min(sp.x + fgetValue(boxWH).width, fgetValue(maxWH).width), sp.y))
						else
							nextDistinct(scrollPosition, Point(sp.x, min(sp.y + fgetValue(boxWH).height, fgetValue(maxWH).height)));
						true
					} else if (ke.keycode == KEY_HOME) {
						sp = getValue(scrollPosition);
						if (changeDirection(ke))
							nextDistinct(scrollPosition, Point(0., sp.y))
						else
							nextDistinct(scrollPosition, Point(sp.x, 0.));
						true
					} else if (ke.keycode == KEY_END) {
						sp = getValue(scrollPosition);
						if (changeDirection(ke))
							nextDistinct(scrollPosition, Point(fgetValue(maxWH).width, sp.y))
						else
							nextDistinct(scrollPosition, Point(sp.x, fgetValue(maxWH).height));
						true
					} else {
						false
					}
				} else {
					false
				}
			}),
			MouseDown2(\h, mi -> {
				if (getValue(moving) && isCurrentInteractionItemId(manager, scrollId)) {
					if (mi.inside()) {
						startMoving(Point(mi.x, mi.y));
					}
				}
				h
			}),
			MouseUp2(\__, mi -> {
				if (getValue(moving)) {
					nextDistinct(currentInteractive, None());

					attachNewFn(releasedFn);
				}

				dispUnsM(draggingUns);

				false
			}),
			IgnoreHitTest(MouseMove2(\h, mi -> {
				if (getValue(moving)) {
					next(currentPoint, mi() |> (\f -> Point(f.x, f.y)));
				} else if (isSome(getValue(currentInteractive)) && !getValue(downXBar) && !getValue(downYBar)) {
					startMoving(mi() |> (\f -> Point(f.x, f.y)))
				} else if (getValue(manager.dragging) != -1) {
					p = mi() |> (\f -> Point(f.x, f.y));

					updateScrollPositionOnDragging(scrollPosition, boxWH, maxWH, scrollBound, p, draggingUns);
				}

				h
			})),
		],
		tr
	)
	|> (\f2 ->
		if (disableWheel || nativeScroll())
			f2
		else
			TGroupWithoutMetrics([
				f2,
				TMouseWheelInteractive(
					manager,
					tr,
					TScrollMouseWheelCallback(scrollPosition, scrollBound, maxWH, mouseWheelPos,
						deltaTimer, reverseWheel, speedX, speedY,xMoving, yMoving, true),
					TScrollMouseWheelCallback(scrollPosition, scrollBound, maxWH, mouseWheelPos,
						deltaTimer, reverseWheel, speedX, speedY, xMoving, yMoving, false)
				)
			])
	)
	|> (\f2 ->
		TConstruct(
			[
				make2Subscribe(contentWH, boxWH, updateContentAndBoxPosition),
				\ -> \ -> {
					dispUnsM(uns);
					dispUnsM(draggingUns);

					updateContentAndBoxPosition(fgetValue(contentWH), fgetValue(boxWH))
				}
			],
			f2
		)
	)
}

TScrollMouseWheelCallback(
	scrollPosition : DynamicBehaviour<Point>,
	scrollBound : TScrollBound,
	maxWH : Transform<WidthHeight>,
	mousePos : ref Maybe<Point>,
	deltaTimer : LazyDeltaTimer,
	reverseWheel : bool,
	speedX : ref [double],
	speedY : ref [double],
	xMoving : DynamicBehaviour<bool>,
	yMoving : DynamicBehaviour<bool>,
	horizontal : bool
) -> (double) -> bool {
	uns = initUnsM();

	\d -> {
		dispUnsM(uns);
		currentMousePos = Point(getMouseX(getStage()), getMouseY(getStage()));

		speedX := [];
		speedY := [];

		sp = getValue(scrollPosition);
		spV = if (horizontal) sp.x else sp.y;
		bound = fgetValue(if (horizontal) scrollBound.y else scrollBound.x);

		delta = -d * 100. * if (!reverseWheel) 1. else -1.;

		newV =
			if (bound)
				min(
					max(spV + delta, 0.),
					if (horizontal)
						fgetValue(maxWH).width
					else
						fgetValue(maxWH).height
				)
			else
				spV + delta;

		updateScrollPosition = \v -> {
			nextDistinct(scrollPosition, if (horizontal) Point(v, getValue(scrollPosition).y) else Point(getValue(scrollPosition).x, v));
			// Emit mousemove to update hovers and tooltips
			emitMouseEvent(getStage(), "mousemove", getMouseX(getStage()), getMouseY(getStage()));
		}

		if (newV != spV || eitherMap(^mousePos, \mp -> mp == currentMousePos, false)) {
			mousePos := Some(currentMousePos);
			easing = makeTEasing(easingTransitionDuration, easingStandartCurve, deltaTimer);

			setUnsM(
				uns,
				[
					makeSubscribe2(easing.percent, \p -> updateScrollPosition(lerp(spV, newV, p)))(),
					easing.stop,
					\ -> updateScrollPosition(newV),
					interruptibleTimer(floor(easingTransitionDuration * 1000.0), \ -> dispUnsM(uns)),
					\ -> next(if (horizontal) xMoving else yMoving, false)
				]
				|> (\u -> \ -> applyall(u))
			);

			next(if (horizontal) xMoving else yMoving, true);
			easing.start();

			true
		} else {
			mousePos := None();

			false
		}
	}
}

createTScrollBars(
	manager : TManager,
	scrollId : int,
	style : [TScrollStyle],
	contentWH : Transform<WidthHeight>,
	boxWH : Transform<WidthHeight>,
	scrollPosition : DynamicBehaviour<Point>,
	currentInteractive : DynamicBehaviour<Maybe<bool>>,
	downXBar : DynamicBehaviour<bool>,
	downYBar : DynamicBehaviour<bool>,
	xMoving : DynamicBehaviour<bool>,
	yMoving : DynamicBehaviour<bool>,
	tr : Tropic
) -> Tropic {
	// Expand scrollbars when on hover
	expandOnHover = extractStruct(style, TExpandOnHover(false)).expand;
	barstyles = extractStruct(style, TScrollbars(standardScrollBar, standardScrollBar));
	enabled = fand(extractStruct(style, TScrollEnabled(const(true))).enabled, extractStruct(style, TEnabled(const(true))).enabled);
	scrollBarsVisible = extractStruct(style, TScrollbarsVisible(make(false), make(false)));
	scrollPersistent = extractStruct(style, TScrollPersistent(const(false))).persistent;
	isRTL = extractStruct(style, TSetRTL(getDefaultRtl())).rtl;

	makeScrollBar =	\horizontal : bool -> {
		down = make(false);
		point = make(zeroPoint);
		hover = make(false);
		scrollbarLength = make(0.);
		barGap = make(0.);

		barStyle = if (horizontal) barstyles.x else barstyles.y;
		barVisible = if (horizontal) scrollBarsVisible.x else scrollBarsVisible.y;
		down0 = if (horizontal) downXBar else downYBar;

		checkAlign =
			if (horizontal)
				\f2 -> if (contains(style, TScrollBarTop())) f2 else TLines2(TFillY(), f2)
			else
				\f2 -> if (changeBoolIfRTL2(contains(style, TScrollBarLeft()), isRTL)) f2 else TCols2(TFillX(), f2);

		sizeFn = if (horizontal) fwidth else fheight;
		coord2point = \c -> if (horizontal) Point(c, 0.) else Point(0., c);
		point2coord = \p -> if (horizontal) p.x else p.y;
		updatePoint = \p, c -> if (horizontal) Point(c, p.y) else Point(p.x, c);

		boxSize = sizeFn(boxWH);
		contentSize = sizeFn(contentWH);
		scale = fdivide(boxSize, contentSize);

		updateScrollPosition = \coord -> {
			contentSz = fgetValue(contentSize);
			boxSz = fgetValue(boxSize);
			scl = fgetValue(scale);
			height = getValue(scrollbarLength);
			gap = getValue(barGap);

			ncoord = (coord - height / 2.) / scl / (boxSz + gap) * boxSz;
			newCoord = max(0., min(ncoord, contentSz - boxSz));

			nextDistinct(scrollPosition, updatePoint(getValue(scrollPosition), newCoord));
		};

		(\dwn, ins ->
			TShowLazy(fand(fless(scale, const(1.)), barStyle.visible), \ -> {
				translatePoint = fselect3(boxSize, scrollPosition, barGap, \boxSz, sp, gap -> {
					scl = fgetValue(scale);
					coord2point(if (boxSz > 0.) point2coord(sp) * scl * (boxSz + gap) / boxSz else 0.)
				});

				thickness =
					if (mobile || !expandOnHover)
						barStyle.thickness
					else
						fmultiply(barStyle.thickness, fif(fselectdelay(fOr(ins, dwn), \v -> if (v) 0 else 800), const(1.2), const(1.0)));

				makeScrollbarBox = \size -> if (horizontal) TSizedWidthHeight(size, thickness) else TSizedWidthHeight(thickness, size);

				TAvailable(barStyle.bar(dwn, ins), makeScrollbarBox(scrollbarLength))
				|> (\t ->
					if (mobile)
						t
					else
						TCopySize(t, \tr2 -> TInteractive([TMouseXY(point), TMouseDownGhost(down)], tr2), false)
				)
				|> (\t -> TTranslate(translatePoint, t))
				|> (\t ->
					TGroup2(
						TAvailable(if (mobile || !expandOnHover) barStyle.background(const(false), const(false)) else barStyle.background(dwn, ins), makeScrollbarBox(boxSize))
						|> (\f -> TCursor(ArrowCursor(), f)),
						t
					)
				)
				|> (\t -> TFixSize(t, makeScrollbarBox(boxSize)))
			})
			|> (\t -> {
				prevSize = ref 0.0;

				TConstruct(
					[
						\ -> {
							prevSize := if (horizontal) fgetValue(contentWH).width else fgetValue(contentWH).height;
							nop;
						},
						make2Subscribe(boxSize, contentWH, \boxSz, cSz -> {
							if (horizontal) {
								if (cSz.width != ^prevSize) {
									prevSize := cSz.width;
									nextDistinct(xMoving, true);
									nextDistinct(xMoving, false);
								}
							} else {
								if (cSz.height != ^prevSize) {
									prevSize := cSz.height;
									nextDistinct(yMoving, true);
									nextDistinct(yMoving, false);
								}
							}

							scl = fgetValue(scale);
							nextDistinct(barVisible, scl < 1.);
							minBSize = min(24., boxSz / 2.);
							bSize0 = boxSz * scl;
							nextDistinct(scrollbarLength, max(bSize0, minBSize));
							nextDistinct(barGap, min(bSize0 - minBSize, 0.));
						})
					],
					t
				)
			})
		)
		|> (\makeBar ->
			if (mobile) {
				makeBar(const(false), const(false));
			} else {
				point0 = make(zeroPoint);
				pointDelta = ref 0.;

				TIf(
					enabled,
					TCopySize(
						makeBar(down0, fthrottle2(hover, 33)),
						\tr2 -> TInteractive([TMouseDown(down0), TMouseXY(point0), TMouseInside(hover, true)], tr2),
						false
					)
					|> (\f3 -> TConstruct(
						[
							makeSubscribe2(point0, \p ->
								if (isCurrentInteractionItemId(manager, scrollId) && getValue(down0)) {
									blockOtherInteractionItemIds(manager, scrollId);
									updateScrollPosition(point2coord(p) + ^pointDelta)
							}),
							makeSubscribe2(down0, \d -> {
								if (d) {
									nextDistinct(currentInteractive, Some(false));
									updateScrollPosition(point2coord(getValue(point0)) + ^pointDelta)
								} else {
									nextDistinct(currentInteractive, None());
									nextDistinct(point, coord2point(getValue(scrollbarLength) / 2.));
									deferred(\ -> next(hover, true));
								}
							}),
							makeSubscribe2(down, \d ->
								pointDelta :=
									if (d)
										getValue(scrollbarLength) / 2. - point2coord(getValue(point))
									else
										0.
							)
						],
						f3
					)),
					TAlpha(const(0.5), makeBar(const(false), const(false)))
				)
			}
		)
		|> (\f2 ->
			TFadeInOut(
				manager,
				fselectdelay(
					fOr(
						fthrottle2(fOr(fOr(hover, down), fselect(currentInteractive, FLift(\ci -> eitherMap(ci, \c -> c, false)))), 33),
						fOr(scrollPersistent, fOr(xMoving, yMoving))
					),
					\m -> if (m) 0 else 500
				),
				f2
			)
		)
		|> (\f2 -> TCursor(DefaultCursor(), f2))
		|> checkAlign
		|> (\f2 -> TAvailable(f2, tr))
	};

	TGroupWithoutMetrics([
		// x scrollbar
		makeScrollBar(true),
		// y scrollbar
		makeScrollBar(false)
	])
	|> (\f -> TDispose([\ -> next(scrollBarsVisible.x, false), \ -> next(scrollBarsVisible.y, false)], f))
}

makeTScrollInspectVisible() -> TScrollInspectVisible {
	topleft = make(zeroPoint);
	widthHeight = makeWH();

	TScrollInspectVisible(topleft, widthHeight);
}

boundScrollPosition(scrollPosition : Point, maxWH : WidthHeight, xbound : bool, ybound : bool) -> Point {
	if (xbound) {
		if (ybound)
			Point(
				min(max(0., scrollPosition.x), maxWH.width),
				min(max(0., scrollPosition.y), maxWH.height)
			)
		else
			Point(
				min(max(0., scrollPosition.x), maxWH.width),
				scrollPosition.y
			)
	} else if (ybound) {
		Point(
			scrollPosition.x,
			min(max(0., scrollPosition.y), maxWH.height)
		)
	} else {
		scrollPosition
	}
}

updateScrollPositionOnDragging(scrollPosition : DynamicBehaviour<Point>, boxWH : Transform<WidthHeight>, maxWH : Transform<WidthHeight>,
	scrollBound : TScrollBound, p : Point, disposer : ref Maybe<() -> void>) -> void {
	dispUnsM(disposer);

	if (p.x > 0.0 && p.x < fgetValue(boxWH).width && p.y > 0.0 && p.y < fgetValue(boxWH).height) {
		draggingGap = 40.0;
		draggingDelta = 20.0;
		draggingTimerDelta = 40;

		goUp = p.y < draggingGap;
		goDown = p.y > fgetValue(boxWH).height - draggingGap;
		goLeft = p.x < draggingGap;
		goRight = p.x > fgetValue(boxWH).width - draggingGap;

		if (goUp || goDown || goLeft || goRight) {
			nextDistinct(
				scrollPosition,
				boundScrollPosition(
					Point(
						getValue(scrollPosition).x + if (goLeft) -draggingDelta else if (goRight) draggingDelta else 0.0,
						getValue(scrollPosition).y + if (goUp) -draggingDelta else if (goDown) draggingDelta else 0.0
					),
					fgetValue(maxWH),
					fgetValue(scrollBound.x),
					fgetValue(scrollBound.y)
				)
			);

			setUnsM(
				disposer,
				interruptibleTimer(draggingTimerDelta, \ -> updateScrollPositionOnDragging(scrollPosition, boxWH, maxWH, scrollBound, p, disposer))
			)
		}
	}
}

TFadeInOut(manager : TManager, fadeIn : Transform<bool>, content : Tropic) -> Tropic {
	TCreate(\ -> {
		alpha = make(0.0);

		TConstruct(
			[
				makeSubscribeUns(fadeIn, \fi -> {
					if (equalDoubles(b2d(fi), getValue(alpha))) {
						[]
					} else {
						e = makeTEasing(
							if (fi) easingEnteringDuration else easingTransitionDuration,
							easingStandartCurve,
							manager.deltaTimer
						);
						e.start();

						[fconnect(flerp(getValue(alpha), b2d(fi), e.percent), alpha)]
					}
				})
			],
			TAlpha(alpha, content)
		)
	})
}