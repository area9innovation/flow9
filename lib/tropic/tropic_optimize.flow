import tropic/tropic;

export {
	optimizeTropic(tropic : Tropic) -> Tropic;
}

optimizeTropic(t : Tropic) -> Tropic {
	switch (t : Tropic) {
		TEmpty(): t;
		TText(__, __): t;
		TParagraph(__, __): t;
		TGraphics(__, __): t;
		TPicture(__, __): t;
		TBorder(l, to, r, b, tr): {
			ot = optimizeTropic(tr);
			if (l == 0.0 && l == to && to == b && b == r) {
				ot;
			} else if (ot == tr) {
				t
			} else {
				TBorder(l, to, r, b, ot);
			}
		}
		TTranslate(p, tr): {
			ot = optimizeTropic(tr);
			if (ot == tr) t else TTranslate(p, ot);
		}
		TScale(f, tr): {
			ot = optimizeTropic(tr);
			if (ot == tr) t else TScale(f, ot);
		}
		TRotate(r, tr): {
			ot = optimizeTropic(tr);
			if (ot == tr) t else TRotate(r, ot);
		}
		TAlpha(a, tr): {
			ot = optimizeTropic(tr);
			if (ot == tr) t else TAlpha(a, ot);
		}
		TVisible(v, tr): {
			ot = optimizeTropic(tr);
			if (ot == tr) t
			else TVisible(v, ot);
		}
		TMask(t1, t2): {
			o1 = optimizeTropic(t1);
			o2 = optimizeTropic(t2);
			if (o1 == t1 && o2 == t2) t
			else TMask(o1, o2);
		}
		TFilter(f, tr): {
			ot = optimizeTropic(tr);
			if (ot == tr) t else TFilter(f, ot);
		}
		TCursor(c, tr): {
			ot = optimizeTropic(tr);
			if (ot == tr) t else TCursor(c, ot);
		}
		TCrop(tl, wh, tr): {
			ot = optimizeTropic(tr);
			if (ot == tr) t else TCrop(tl, wh, ot);
		}
		TInteractive(ia, tr): {
			ot = optimizeTropic(tr);
			if (ia == []) ot
			else if (ot == tr) t else TInteractive(ia, ot);
		}
		TBaselineOffset(b, tr): {
			ot = optimizeTropic(tr);
			if (ot == tr) t else TBaselineOffset(b, ot)
		}
		TAccess(p, tr): {
			ot = optimizeTropic(tr);
			if (ot == tr) t else TAccess(p, ot);
		}
		TRealHTML(__, __, __): t;
		TVideo(__, __, __): t;
		TForm(__): t;
		TFForm(__, __): t;
		TSFForm(__, __): t;
		TFormIn(f, tr): {
			ot = optimizeTropic(tr);
			if (ot == tr) t
			else TFormIn(f, ot);
		}
		TFormAvailable(f, tr): {
			ot = optimizeTropic(tr);
			if (ot == tr) t
			else TFormAvailable(f, ot);
		}
		TCase(sz, cs): {
			os = map(sz, optimizeTropic);
			oc = map(cs, optimizeTropic);
			if (os == sz && oc == cs) t
			else TCase(os, oc);
		}
		TConstruct(cs, tr): {
			ot = optimizeTropic(tr);
			if (cs == []) ot
			else if (ot == tr) t
			else {
				if (isSameStructType(ot, t)) {
					// Nested construct
					cd = cast(ot : Tropic -> TConstruct);
					TConstruct(concat(cd.constructors, cs), cd.tropic);
				} else {
					TConstruct(cs, ot);
				}
			}
		}
		TCreate2(__, __): t;
		TDispose(ds, tr): {
			ot = optimizeTropic(tr);
			if (ds == []) ot
			else if (ot == tr) t
			else {
				if (isSameStructType(ot, t)) {
					// Nested disposer
					cd = cast(ot : Tropic -> TDispose);
					TDispose(concat(cd.disposers, ds), cd.tropic);
				} else {
					TDispose(ds, ot);
				}
			}
		}
		TMutable(tr): {
			if (isFConst(tr)) {
				optimizeTropic( fgetValue(tr) );
			} else {
				t; // The child is optimized by tropic2Acc
			}
		}
		TIf(b, th, el): {
			switch (b : Transform<bool>) {
				ConstBehaviour(v): {
					if (v) {
						optimizeTropic(th)
					} else  {
						optimizeTropic(el)
					}
				}
				default: {
					ot = optimizeTropic(th);
					oe = optimizeTropic(el);

					if (ot == oe) ot // then and else-branch are identical!
					else {
						if (isSameStructType(ot, oe)) {
							optimizeTIf(b, ot, oe);
						} else {
							if (ot == th && oe == el) t
							else TIf(b, ot, oe);
						}
					}
				}
			}
		}
		TGroup2(t1, t2): {
			o1 = optimizeTropic(t1);
			o2 = optimizeTropic(t2);
			if (o1 == TEmpty()) o2
			else if (o2 == TEmpty()) o1
			else if (o1 == t1 && o2 == t2) t
			else TGroup2(o1, o2);
		}
		TCols2(t1, t2): {
			o1 = optimizeTropic(t1);
			o2 = optimizeTropic(t2);
			if (o1 == TEmpty()) o2
			else if (o2 == TEmpty()) o1
			else t
		}
		TBaselineCols2(t1, t2): {
			o1 = optimizeTropic(t1);
			o2 = optimizeTropic(t2);
			if (o1 == TEmpty()) o2
			else if (o2 == TEmpty()) o1
			else {
				if (o1 == t1 && o2 == t2) t else TBaselineCols2(o1, o2);
			}
		}
		TLines2(t1, t2): {
			o1 = optimizeTropic(t1);
			o2 = optimizeTropic(t2);

			if (o1 == TEmpty()) {
				o2
			} else if (o2 == TEmpty()) {
				o1
			} else {
				defaultLines = \ -> {
					if (o1 == t1 && o2 == t2)
						t
					else
						TLines2(o1, o2);
				}

				switch (o1) {
					TBorder(l, to, r, b, tr): {
						if (tr == TEmpty() && l == 0. && r == 0.) {
							TBorder(l, to + b, r, 0., if (o2 == t2) t2 else o2)
						} else {
							defaultLines();
						}
					}
					default: {
						switch (o2) {
							TBorder(l, to, r, b, tr): {
								if (tr == TEmpty() && l == 0. && r == 0.) {
									TBorder(l, 0., r, to + b, if (o1 == t1) t1 else o1)
								} else {
									defaultLines();
								}
							}
							default: {
								defaultLines();
							}
						}
					}
				}
			}
		}
		TBaselineLines2(t1, t2): {
			o1 = optimizeTropic(t1);
			o2 = optimizeTropic(t2);
			if (o1 == TEmpty()) o2
			else if (o2 == TEmpty()) o1
			else {
				if (isSameStructType(o1, o2) && isSameStructType(o1, TText("", []))) {
					// Both are texts.
					ot1 : TText = cast(o1 : Tropic -> TText);
					ot2 : TText = cast(o2 : Tropic -> TText);

					if (ot1.style == ot2.style && !strContains(ot1.text, "\n") && !strContains(ot2.text, "\n")) {
						TText(ot1.text + "\n" + ot2.text, ot1.style);
					} else {
						// TODO: We might be able to join styles here, but that is for another day
						TBaselineLines2(o1, o2);
					}
				} else if (o1 == t1 && o2 == t2) t
				else TBaselineLines2(o1, o2);
			}
		}
		TAvailable(box, parent): {
			ob = optimizeTropic(box);
			op = optimizeTropic(parent);
			if (ob == box && op == parent) t
			else TAvailable(ob, op);

		}
		TTweak(style, content, size): {
			ob = optimizeTropic(content);
			ot = optimizeTropic(size);
			if (ob == content && ot == size) t
			else TTweak(style, ob, ot);
		}
		TZoomFill(b): {
			ob = optimizeTropic(b);
			if (ob == b) t
			else TZoomFill(ob);
		}
		TFillX(): t;
		TFillY(): t;
		TAttach(b, fn): {
			ob = optimizeTropic(b);
			if (ob == b) t
			else TAttach(b, fn)
		}
		TRounded(nw, ne, lw, le, style, size): {
			os = optimizeTropic(size);
			if (os == size) t
			else TRounded(nw, ne, lw, le, style, os);
		}
		TScrollable(content, maxbox, style, state): {
			oc = optimizeTropic(content);
			om = optimizeTropic(maxbox);
			if (oc == content && om == maxbox) t
			else TScrollable(oc, om, style, state)
		}
		TCropSize(t1, t2): {
			o1 = optimizeTropic(t1);
			o2 = optimizeTropic(t2);
			if (o1 == t1 && o2 == t2) t
			else TCropSize(o1, o2);
		}
		TShift(t1, t2): {
			o1 = optimizeTropic(t1);
			o2 = optimizeTropic(t2);
			if (o1 == t1 && o2 == t2) t
			else TShift(o1, o2);
		}
		TSize(t1, t2): {
			o1 = optimizeTropic(t1);
			o2 = optimizeTropic(t2);
			if (o1 == t1 && o2 == t2) t
			else TSize(o1, o2);
		}
		TSizeOf(t1): {
			o1 = optimizeTropic(t1);
			if (o1 == t1) t
			else TSizeOf(o1);
		}
		TMinimumGroup2(t1, t2): {
			o1 = optimizeTropic(t1);
			o2 = optimizeTropic(t2);
			if (o1 == t1 && o2 == t2) t
			else if (o1 == TEmpty() && o2 == TEmpty()) TEmpty()
			else TMinimumGroup2(o1, o2);
		}
		TSubtractGroup2(t1, t2): {
			o1 = optimizeTropic(t1);
			o2 = optimizeTropic(t2);
			if (o1 == t1 && o2 == t2) t
			else if (o2 == TEmpty()) o1
			else TSubtractGroup2(o1, o2);
		}
		TDebug(c, tr): t; // We intentionally do not optimize this
		TLet(name, value, scope): {
			ov = optimizeTropic(value);
			os = optimizeTropic(scope);
			// Let(a, value, Display(a)) == value
			if (os == TDisplay(name)) ov
			else if (ov == value && os == scope) t
			else TLet(name, ov, os)
		}
		TLetAvailable(name, scope): {
			os = optimizeTropic(scope);

			if (os == scope) t
			else TLetAvailable(name, os)
		}
		TNamespace(__): t;
		TDisplay(__): t;
		TGhost(__): t;
		TGhostMin(__): t;
		TTag(tag, tr): {
			ot = optimizeTropic(tr);
			if (ot == tr) t
			else TTag(tag, ot)
		}
		TTag2(setfn, tr): {
			ot = optimizeTropic(tr);
			if (ot == tr) t
			else TTag2(setfn, ot)
		}
		TCssBlock(st, tr): {
			ot = optimizeTropic(tr);
			if (ot == tr) t
			else TCssBlock(st, ot)
		}
		TNative(fn): t;
		TransformTAcc(__): t;
		TFullWindow(fs, tr): {
			ot = optimizeTropic(tr);
			if (ot == tr) t
			else TFullWindow(fs, tr)
		}
		TPositionScale(p, tr): {
			ot = optimizeTropic(tr);
			if (ot == tr) t else TPositionScale(p, ot);
		};
		TDynamicGroup2(__, __, __) : t;
		TInspect(inspectors, tr) : {
			ot = optimizeTropic(tr);
			if (length(inspectors) == 0) ot
			else if (ot == tr) t
			else TInspect(inspectors, ot)
		}
		TOverride(overriders, tr) : {
			ot = optimizeTropic(tr);
			if (length(overriders) == 0) ot
			else if (ot == tr) t
			else TOverride(overriders, ot)
		}
/*
		default: {
			println("Did not optimize tropic " + t.structname);
			t;
		}*/
	}
}

// We know then and else are the same type!
optimizeTIf(b : Transform<bool>, then : Tropic, else_ : Tropic) -> Tropic {
	switch (then : Tropic) {
		TGroup2(t1, t2): {
			elseg = cast(else_ : Tropic -> TGroup2);
			e1 = elseg.box1;
			e2 = elseg.box2;
			if (t1 == e1) {
				// TIf(b, TGroup2(c1, t2), TGroup2(c1, e2)) -> TGroup2(c1, TIf(b, t2, e2))
				TGroup2(t1, optimizeTropic(TIf(b, t2, e2)));
			} else if (t2 == e2) {
				// TIf(b, TGroup2(t1, c2), TGroup2(e1, c2)) -> TGroup2(TIf(b, t1, e1), c2)
				TGroup2(optimizeTropic(TIf(b, t1, e1)), t2);
			} else {
				TIf(b, then, else_)
			}
		}
		TCols2(t1, t2): {
			elseg = cast(else_ : Tropic -> TCols2);
			e1 = elseg.box1;
			e2 = elseg.box2;
			if (t1 == e1) {
				TCols2(t1, optimizeTropic(TIf(b, t2, e2)));
			} else if (t2 == e2) {
				TCols2(optimizeTropic(TIf(b, t1, e1)), t2);
			} else {
				TIf(b, then, else_)
			}
		}
		TLines2(t1, t2): {
			elseg = cast(else_ : Tropic -> TLines2);
			e1 = elseg.box1;
			e2 = elseg.box2;
			if (t1 == e1) {
				TLines2(t1, optimizeTropic(TIf(b, t2, e2)));
			} else if (t2 == e2) {
				TLines2(optimizeTropic(TIf(b, t1, e1)), t2);
			} else {
				TIf(b, then, else_)
			}
		}
		TLet(n1, v1, s1): {
			elselet = cast(else_ : Tropic -> TLet);
			if (elselet.name == n1 && elselet.value == v1) {
				// We can move the TLet up
				TLet(n1, v1, optimizeTropic(TIf(b, s1, elselet.scope)));
			} else {
				TIf(b, then, else_);
			}
		}
		default: {
			TIf(b, then, else_);
		}
	}
}
