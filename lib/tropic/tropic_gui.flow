import tropic/tropic;
import tropic/tropic_util;
import fform/fform_gui;
import sys/fullscreen;
import ui/fontmapping;
import fusion_utils;
import fform/renderfform;
import tropic/tropic_manager;

export {
	// A fixed size, empty block
	TFixed(width : double, height : double) -> Tropic;

	// TBorder with equal borders on all 4 sides
	TBorder4(border : double, t : Tropic) -> Tropic;

	// A block of given size
	TSized(size : Transform<WidthHeight>) -> Tropic;
	// A block of given size with constant height or width
	TSizedWidth(width : Transform<double>, height : double) -> Tropic;
	TSizedHeight(width : double, height : Transform<double>) -> Tropic;
	TSizedWidthHeight(width : Transform<double>, height : Transform<double>) -> Tropic;

	// Bunch of helpers to inspect sizes. Consider using TInspect also.

	TAttachBox(t : Tropic, box : DynamicBehaviour<WidthHeight>) -> Tropic;
	TAttachWidth(t : Tropic, width : DynamicBehaviour<double>) -> Tropic;
	TAttachHeight(t : Tropic, height : DynamicBehaviour<double>) -> Tropic;
	TAttachWidthHeight(t : Tropic, width : DynamicBehaviour<double>, height : DynamicBehaviour<double>) -> Tropic;

	TAttachAvailable(t : Tropic, box : DynamicBehaviour<WidthHeight>) -> Tropic;
	TAttachAvailableWidth(t : Tropic, width : DynamicBehaviour<double>) -> Tropic;
	TAttachAvailableHeight(t : Tropic, height : DynamicBehaviour<double>) -> Tropic;
	TAttachAvailableWidthHeight(t : Tropic, width : DynamicBehaviour<double>, height : DynamicBehaviour<double>) -> Tropic;

	// Inspects t, draws content
	TAttachBox2(t : Tropic, box : DynamicBehaviour<WidthHeight>, content : Tropic) -> Tropic;
	TAttachWidth2(t : Tropic, width : DynamicBehaviour<double>, content : Tropic) -> Tropic;
	TAttachHeight2(t : Tropic, height : DynamicBehaviour<double>, content : Tropic) -> Tropic;

	// Special cases to inspect
	TAttachMinWidth(t : Tropic, minWidth : DynamicBehaviour<double>) -> Tropic;
	TAttachBoxThrottle(t : Tropic, box : DynamicBehaviour<WidthHeight>, maxDelta : int) -> Tropic;
	TAttachHeightTrigger(t : Tropic, height : DynamicBehaviour<double>, trigger : Transform<bool>) -> Tropic;

	TThrottleMetrics(t : Tropic, maxDelta : int) -> Tropic;

	// A rectangle that expands to the given size
	TRectangle(style : [TGraphicsStyle], size : Tropic) -> Tropic;

	TCircle(radius : double, style : [TGraphicsStyle]) -> Tropic;

	TGroup(c : [Tropic]) -> Tropic;
	TCols(c : [Tropic]) -> Tropic;
	TBaselineCols(c : [Tropic]) -> Tropic;
	TBaselineLines(c : [Tropic]) -> Tropic;
	TLines(c : [Tropic]) -> Tropic;
	TGrid(c : [[Tropic]]) -> Tropic;

	// Arabic(RTL) versions
	TColsA(t : [Tropic]) -> Tropic;
	TCols2A(t1 : Tropic, t2 : Tropic) -> Tropic;
	TBaselineColsA(t : [Tropic]) -> Tropic;
	TBaselineCols2A(t1 : Tropic, t2 : Tropic) -> Tropic;
	TLinesA(arr : [Tropic]) -> Tropic;
	TLines2A(t1 : Tropic, t2 : Tropic) -> Tropic;
	TBaselineLinesA(t : [Tropic]) -> Tropic;
	TBaselineLines2A(t1 : Tropic, t2 : Tropic) -> Tropic;
	TBorderA(start : double, top : double, end : double, bottom : double, t : Tropic) -> Tropic;
	TPadA(x : double, y : double, t : Tropic) -> Tropic;

	// TGroup with zero metrics
	// Useful inside complicated components with lots of layers, metrics of which aren't used
	TGroupWithoutMetrics(g : [Tropic]) -> Tropic;
	TGroup2WithoutMetrics(g1 : Tropic, g2 : Tropic) -> Tropic {TGroupWithoutMetrics([g1, g2])};
	// TGroup that has metrics of the first tropic
	TGroupSameMetrics(g : [Tropic]) -> Tropic;
	TGroup2SameMetrics(g1 : Tropic, g2 : Tropic) -> Tropic {TGroupSameMetrics([g1, g2])};

	// Common helpers of centering a number of tropics
	TColsXCenter(cols : [Tropic]) -> Tropic;
	TColsYCenter(cols : [Tropic]) -> Tropic;
	TBaselineColsXCenter(cols : [Tropic]) -> Tropic;
	TBaselineColsYCenter(cols : [Tropic]) -> Tropic;
	TColsYCenterA(cols : [Tropic]) -> Tropic;
	TLinesXCenter(lines : [Tropic]) -> Tropic;
	TLinesYCenter(lines : [Tropic]) -> Tropic;
	TBaselineLinesXCenter(lines : [Tropic]) -> Tropic;
	TBaselineLinesYCenter(lines : [Tropic]) -> Tropic;

	// Common helpers for creating groups of elements with the same available width or height
	TColsSameWidth(cols : [Tropic]) -> Tropic;
	TColsSameHeight(cols : [Tropic]) -> Tropic;
	TLinesSameWidth(lines : [Tropic]) -> Tropic;
	TLinesSameHeight(lines : [Tropic]) -> Tropic;

	// Move the box x, y pixels, changing the size
	TPad(x : double, y : double, t : Tropic) -> Tropic;

	// Add a rounded frame behind the given box
	TFrame(margin : double, radius : double, style : [TGraphicsStyle], box : Tropic) -> Tropic;
	TFrameT(margin : Transform<double>, radius : Transform<double>, style : [TGraphicsStyle], box : Tropic) -> Tropic;
	TFrameCustom(l : double, tl : double, tlRounded : bool, t : double, tr : double, trRounded : bool, r : double,
		br : double, brRounded : bool, b : double, bl : double, blRounded : bool, style : [TGraphicsStyle], box : Tropic) -> Tropic;

	// Round rectangle corners to maximum possible radius
	TRoundedFull(style : [TGraphicsStyle], size : Tropic) -> Tropic;
	TRounded4(radius : double, style : [TGraphicsStyle], size : Tropic) -> Tropic;

	// Resizes the form to fill the target metrics
	TZoom(content : Tropic, container : Tropic, keepAspect : bool) -> Tropic;

	// Resizes the form to fill the target metrics croping borders that don't fit, always keeps aspect ratio.
	TZoomToFill(content : Tropic, container : Tropic, crop : bool) -> Tropic;

	TZoomOnOverflow(content : Tropic, container : Tropic, keepAspect : bool) -> Tropic;

	// Horizontal centering
	TCenterX(b : Tropic) -> Tropic;
	// Horizontal centering inside the box
	TCenterXIn(t : Tropic, box : Tropic) -> Tropic;

	// Vertical centering
	TCenterY(b : Tropic) -> Tropic;
	// Vertical centering inside the box
	TCenterYIn(t : Tropic, box : Tropic) -> Tropic;

	// Center in both directions
	TCenter(b : Tropic) -> Tropic;
	// Center inside the given box
	TCenterIn(b : Tropic, frame : Tropic) -> Tropic;
	// Center and scale with variable fill percentage, use 1.0/3.0 for centering
	TCenterScale(tropic : Tropic, xscale : double, yscale: double) -> Tropic;

	// Returns tropic with its minimum metrics
	TMinimumMetrics(content : Tropic) -> Tropic;

	// Grows in both direction
	TFillXY() -> Tropic;

	// Defines a filler which grows from 0,0 up to the maximum size, without preserving aspect ratio
	TFillMax(maxWidth : double, maxHeight : double) -> Tropic;
	TFillMaxWY(maxWidth : double) -> Tropic;

	TFillMin(minWidth : double, minHeight : double) -> Tropic;

	// Define a maximum expanding fill, and a given height/width
	TFillXH(height : double) -> Tropic;
	TFillXW(minWidth : double) -> Tropic;
	TFillWY(width : double) -> Tropic;
	TFillYH(minHeight : double) -> Tropic;
	TFillXHT(height : Transform<double>) -> Tropic;
	TFillXWT(minWidth : Transform<double>) -> Tropic;
	TFillWYT(width : Transform<double>) -> Tropic;
	TFillYHT(minHeight : Transform<double>) -> Tropic;

	// Define an expanding rectangle from minimum size to maximum size, without preserving aspect ratios in between.
	TFillXYXY(minWidth : double, minHeight : double, maxWidth : double, maxHeight : double) -> Tropic;

	// Crunch the tropic down to just the height. Notice if it has any interactivity, those are still active.
	THeight(tropic : Tropic) -> Tropic;
	// Crunch the tropic flat to just the width. Notice if it has any interactivity, those are still active.
	TWidth(tropic : Tropic) -> Tropic;

	// Override the size of this given tropic to the child
	TFixSize(tropic : Tropic, size : Tropic) -> Tropic;

	// Similar to TFormIn, but gets truthful wh available
	TFormWH(form : Form, wh : WidthHeight) -> Tropic;

	// A lazy version of TIf. Notice that TIf allows significant optimizations, so normally, that is the
	// right choice.
	TIfLazy(value : Transform<bool>, f : (bool) -> Tropic) -> Tropic;

	// Normal interface to TSelect
	TSelect(value : Transform<?>, fn : (?) -> Tropic) -> Tropic;
	TSelect2(v1 : Transform<?>, v2 : Transform<??>, fn : (?, ??) -> Tropic) -> Tropic;
	TSelect3(v1 : Transform<?>, v2 : Transform<??>, v3 : Transform<???>, fn : (?, ??, ???) -> Tropic) -> Tropic;

	TMutableMaybe(v : Transform<Maybe<Tropic>>) -> Tropic;
	TSelectMaybe(v : Transform<Maybe<?>>, fn : (?) -> Tropic) -> Tropic;

	// TSelect supporting fusion, which can help with managing disposing
	TFSelect(value : Transform<?>, fn : FFn<?, Tropic>) -> Tropic;

	// Shorthand to define a bunch of named tropics
	TLetMany(items : [Pair<string, Tropic>], scope : Tropic) -> Tropic;

	// Rotate 90 degrees, including the sizes
	TRotate90(tropic : Tropic) -> Tropic;
	// Rotate 90 degrees counter-clockwise, including the sizes
	TRotate90Left(tropic : Tropic) -> Tropic;
	// Rotate 180 degrees and translate by size
	TRotate180(enabled : Transform<bool>, size : Tropic) -> (Tropic) -> Tropic;

	// The tropic is actually destroyed/reconstructed when 'show' becomes false/true, in contrast
	// to TVisible. This is an exact alias to the common TIf(show, tropic, TEmpty) construct.
	// See TVisible for an optimized version that only hides the tropic.
	TShow : (show : Transform<bool>, tropic : Tropic) -> Tropic;
	// The tropic is destroyed/reconstructed when 'show' becomes false/true but tr fn called only once
	// and only when show becomes true
	TShowLazy(show : Transform<bool>, tr : () -> Tropic) -> Tropic;
	// Similar to TShowLazy
	// Constructs tr when show is true and just hides it when show is false
	// If show is false initially tr function isn't called until show is true
	TVisibleLazy(show : Transform<bool>, tr : () -> Tropic) -> Tropic;

	// Crops only in X dimension
	TCropSizeX : (content : Tropic, width : Tropic) -> Tropic;
	// Crops only in Y dimension
	TCropSizeY : (content : Tropic, height : Tropic) -> Tropic;

	// TScrollable with extra margins for scroll bars at the right and bottom
	TScrollableWithBars(content : Tropic, maxbox : Tropic, style : ScrollableStyle, state : [TScrollableState]) -> Tropic;

	//Another approach to make scrollable with bars, but now the space for the scrollbars isn't reserved all the time:
	//they appear only when needed. Also, scrollbars drawn by this function are always visible on the screen
	TScrollableEdged(content : Tropic, maxbox : Tropic,  style : ScrollableStyle, state : [TScrollableState], background : Maybe<(Tropic) -> Tropic>,
		foreground : Maybe<(Tropic) -> Tropic>) -> Tropic;

	// Converts TAcc to Tropic with empty form and same size
	// Doesn't dispose TAcc disposers
	TAcc2Size(acc : TAcc) -> Tropic;

	// Copies size of content to copyFn, copyFn result has no effect on overall metrics
	// If above is true result of copyFn is placed on top of content
	// Useful when you need to place TInteractive above or below another one
	TCopySize(content : Tropic, copyFn : (size : Tropic) -> Tropic, above : bool) -> Tropic;
	// Similar to TCopySize, only resulting tropic has metrics of copyFn
	// copyFn has two parameters: size of the content, and content itself
	TCopySize2(content : Tropic, copyFn : (size : Tropic, content : Tropic) -> Tropic) -> Tropic;

	// Set tropic baseline from top of it
	TBaseline(baseline : Transform<double>, content : Tropic) -> Tropic;

	// Display form in fullscreen
	// Similar to TFullWindow
	TFullScreen(fs : DynamicBehaviour<bool>, tr : Tropic) -> Tropic;

	// Handling long tapping
	TLongTouch(duration : int, fn : () -> void, handle : bool, tropic : Tropic) -> Tropic;

	// Simplified version of TransformTAcc
	TransformTAcc2(fn : ((Tropic) -> TAcc) -> TAcc) -> Tropic;

	// without Fill doesn't work in flash
	// with Fill doesn't work on  Windows Phone (text input loses focus on touch up)
	interactiveRectangleStyle : [GraphicsStyle] = if (csharp) [FillOpacity(0.0)] else [FillOpacity(0.0), Fill(0)];

	TProportionGrid(c : [[Pair<Transform<Factor>, Tropic>]]) -> Tropic;
	TProportionLines(c : [Pair<Transform<double>, Tropic>]) -> Tropic;
	TProportionCols(c : [Pair<Transform<double>, Tropic>]) -> Tropic;
	TProportionBaselineCols(c : [Pair<Transform<double>, Tropic>]) -> Tropic;
	TProportionColsA(c : [Pair<Transform<double>, Tropic>]) -> Tropic;

	// Helpers to set available for only width or only height
	TAvailableWidth(tr : Tropic, available : Transform<double>) -> Tropic;
	TAvailableHeight(tr : Tropic, available : Transform<double>) -> Tropic;
	TAvailableWidthHeight(tr : Tropic, availableW : Transform<double>, availableH : Transform<double>) -> Tropic;

	TAlignHorizontal(align : CommonAlignment) -> (Tropic) -> Tropic;
	TAlignStart(t : Tropic) -> Tropic; // Align left if LTR, align right if RTL
	TAlignEnd(t : Tropic) -> Tropic;   // Align right if LTR, align left if RTL
	TAlignLeft(t : Tropic) -> Tropic;
	TAlignTop(t : Tropic) -> Tropic;
	TAlignRight(t : Tropic) -> Tropic;
	TAlignBottom(t : Tropic) -> Tropic;

	TAlignTopLeft(t : Tropic) -> Tropic;
	TAlignTopCenter(t : Tropic) -> Tropic;
	TAlignTopRight(t : Tropic) -> Tropic;
	TAlignCenterRight(t : Tropic) -> Tropic;
	TAlignBottomRight(t : Tropic) -> Tropic;
	TAlignBottomCenter(t : Tropic) -> Tropic;
	TAlignBottomLeft(t : Tropic) -> Tropic;
	TAlignCenterLeft(t : Tropic) -> Tropic;

	TBorderTop(border : double) -> (Tropic) -> Tropic;
	TBorderBottom(border : double) -> (Tropic) -> Tropic;
	TBorderLeft(border : double) -> (Tropic) -> Tropic;
	TBorderRight(border : double) -> (Tropic) -> Tropic;

	TBorderTopBottom(border : double) -> (Tropic) -> Tropic;
	TBorderLeftRight(border : double) -> (Tropic) -> Tropic;

	// Dynamic version of TBorder
	TBorderT(left : Transform<double>, top : Transform<double>, right : Transform<double>, bottom : Transform<double>, t : Tropic) -> Tropic;

	TDecorator(tr : Tropic, decorators : [Pair<Transform<bool>, (Transform<WidthHeight>) -> Tropic>], above : bool) -> Tropic;
	// Helper for dynamic text
	TDynamicText(text : Transform<string>, style : [TCharacterStyle]) -> Tropic;

	// TDebug that shows metrics on top of the tropic
	TDebugMetrics(c : int, tr : Tropic) -> Tropic;
	TDebugPositionScale(c : int, tr : Tropic) -> Tropic;
	TDebugViewBounds(c : int, tr : Tropic) -> Tropic;

	TDebugConstruct(tag : string, tr : Tropic) -> Tropic;

	// Hide tropic if available size is less than tropic metrics
	TIfFits(tr : Tropic) -> Tropic;

	TOnConstruct(fn : () -> void) -> (Tropic) -> Tropic;

	TEvenGrid(content : [[Tropic]]) -> Tropic;

	TConstructRenderable(constructors : [() -> () -> void], content : Tropic) -> Tropic;

	wh2Tropic(wh : WidthHeight) -> Tropic;

	// Zoom tropic if its metrics are bigger than maxWH
	TZoomMax(tr : Tropic, maxWH : Transform<WidthHeight>) -> Tropic;
	// Zoom tropic if its width is bigger than maxWidth
	TZoomMaxWidth(tr : Tropic, maxWidth : Transform<double>) -> Tropic;
	// Zoom tropic if its height is bigger than maxHeight
	TZoomMaxHeight(tr : Tropic, maxHeight : Transform<double>) -> Tropic;

	// Helpers to make Tropic not transparent for events
	disableMouseWheelBelow(content : Tropic) -> Tropic;
	disableInteractivesBelow(content : Tropic) -> Tropic;

	// Helpers to make checkered graphics
	TCheckeredRectangle(style1 : [TGraphicsStyle], style2 : [TGraphicsStyle], content : Tropic) -> Tropic;
	TCheckeredRounded(nw : double, ne : double, lw : double, le : double, style1 : [TGraphicsStyle],
		style2 : [TGraphicsStyle], content : Tropic) -> Tropic;

	TMouseWheelInteractive(manager : TManager, content : Tropic, deltaX : (double) -> bool, deltaY : (double) -> bool) -> Tropic;

	T3DStage(scene : F3DObject, camera : F3DObject, size : Tropic, style : [F3DStageStyle]) -> Tropic;
}

TFixed(width : double, height : double) -> Tropic {
	if (width == 0.0 && height == 0.0) TEmpty()
	else TBorder(width, height, 0.0, 0.0, TEmpty())
}

TBorder4(border : double, t : Tropic) -> Tropic {
	TBorder(border, border, border, border, t);
}

TSized(size : Transform<WidthHeight>) -> Tropic {
	TSizedWidthHeight(fwidth(size), fheight(size))
}

TSizedWidth(width : Transform<double>, height : double) -> Tropic {
	TSizedWidthHeight(width, const(height))
}

TSizedHeight(width : double, height : Transform<double>) -> Tropic {
	TSizedWidthHeight(const(width), height)
}

TSizedWidthHeight(width : Transform<double>, height : Transform<double>) -> Tropic {
	TBorderT(width, height, zero, zero, TEmpty())
}

TRectangle(style : [TGraphicsStyle], size : Tropic) -> Tropic {
	TRounded(0., 0., 0., 0., style, size)
}

TCircle(radius : double, style : [TGraphicsStyle]) -> Tropic {
	TGraphics([GCircle(radius, radius, radius)], style);
}

TGroup(c : [Tropic]) -> Tropic {
	len = length(c);
	if (len == 0) TEmpty()
	else if (len == 1) c[0]
	else if (len == 2) TGroup2(c[0], c[1])
	else TGroup2(TGroup(subrange(c, 0, len / 2)), TGroup(subrange(c, len / 2, len - (len / 2))));
}

TGroupWithoutMetrics(c : [Tropic]) -> Tropic {
	TransformTAcc2(\tac -> {
			r = map(c, tac);

			TAcc(
				FGroup(map(r, \r0 -> r0.form), true),
				TFormMetrics(zero, zero, zero),
				zero,
				zero,
				zero,
				zero,
				zero,
				zero,
				const(false),
				true,
				true,
				map(r, \r0 -> r0.disposers) |> concatA
			)
		}
	)
}

TGroupSameMetrics(c : [Tropic]) -> Tropic {
	if (length(c) > 0)
		TransformTAcc2(\tac -> {
				r = map(c, tac);

				TAcc(
					FGroup(map(r, \r0 -> r0.form), true),
					r[0].metrics,
					r[0].minWidth,
					r[0].minHeight,
					r[0].maxWidth,
					r[0].maxHeight,
					r[0].xFillers,
					r[0].yFillers,
					r[0].addFillers,
					r[0].xConstant,
					r[0].yConstant,
					map(r, \r0 -> r0.disposers) |> concatA
				)
			}
		)
	else
		TEmpty();
}

TCols(c : [Tropic]) -> Tropic {
	len = length(c);
	if (len == 0) TEmpty()
	else if (len == 1) c[0]
	else if (len == 2) TCols2(c[0], c[1])
	else TCols2(TCols(subrange(c, 0, len / 2)), TCols(subrange(c, len / 2, len - (len / 2))));
}

TBaselineCols(c : [Tropic]) -> Tropic {
	len = length(c);
	if (len == 0) TEmpty()
	else if (len == 1) c[0]
	else if (len == 2) TBaselineCols2(c[0], c[1])
	else TBaselineCols2(TBaselineCols(subrange(c, 0, len / 2)), TBaselineCols(subrange(c, len / 2, len - (len / 2))));
}

TBaselineLines(c : [Tropic]) -> Tropic {
	len = length(c);
	if (len == 0) TEmpty()
	else if (len == 1) c[0]
	else if (len == 2) TBaselineLines2(c[0], c[1])
	else TBaselineLines2(TBaselineLines(subrange(c, 0, len / 2)), TBaselineLines(subrange(c, len / 2, len - (len / 2))));
}

TLines(c : [Tropic]) -> Tropic {
	len = length(c);
	if (len == 0) TEmpty()
	else if (len == 1) c[0]
	else if (len == 2) TLines2(c[0], c[1])
	else TLines2(TLines(subrange(c, 0, len / 2)), TLines(subrange(c, len / 2, len - (len / 2))));
}

TGrid(c : [[Tropic]]) -> Tropic {
	if (c == []) TEmpty()
	else fold(tail(c), TCols(c[0]), \acc, row -> TLines2(acc, TCols(row)))
}

TColsA(t : [Tropic]) -> Tropic {
	if (getDefaultRtl()) TCols(reverseA(t)) else TCols(t)
}

TCols2A(t1 : Tropic, t2 : Tropic) -> Tropic {
	if (getDefaultRtl()) TCols2(t2, t1) else TCols2(t1, t2)
}

TBaselineColsA(t : [Tropic]) -> Tropic {
	if (getDefaultRtl()) TBaselineCols(reverseA(t)) else TBaselineCols(t)
}

TBaselineCols2A(t1 : Tropic, t2 : Tropic) -> Tropic {
	if (getDefaultRtl()) TBaselineCols2(t2, t1) else TBaselineCols2(t1, t2)
}

TBorderA(start : double, top : double, end : double, bottom : double, t : Tropic) -> Tropic {
	if (getDefaultRtl()) TBorder(end, top, start, bottom, t) else TBorder(start, top, end, bottom, t)
}

// Helper for supporting RTL in TLines variations
linesToLinesA(ls : [Tropic]) -> [Tropic] {
	if (getDefaultRtl()) linesToLinesRTL(ls) else ls;
}

linesToLinesRTL(ls : [Tropic]) -> [Tropic] {
	widths = map(ls, \l -> make(0.0));
	maxWidth = fmaxA(widths, 0.0);

	mapi(
		ls,
		\i, l -> TransformTAcc2(\t2a -> {
			b1 = t2a(l);

			form = FTranslate(
				fsubtract(maxWidth, b1.metrics.width),
				const(0.0),
				b1.form
			);

			disp =
				arrayPush(
					b1.disposers,
					fconnect(b1.metrics.width, widths[i])
				);

			TAcc(b1 with form = form, disposers = disp)
		})
	);
}

TLinesA(arr : [Tropic]) -> Tropic {
	TLines(linesToLinesA(arr));
}

TLines2A(t1 : Tropic, t2 : Tropic) -> Tropic {
	TLinesA([t1, t2])
}

TBaselineLinesA(arr : [Tropic]) -> Tropic {
	TBaselineLines(linesToLinesA(arr));
}

TBaselineLines2A(t1 : Tropic, t2 : Tropic) -> Tropic {
	TBaselineLinesA([t1, t2])
}

TColsXCenter(cols : [Tropic]) -> Tropic {
	TSegmentCenter(cols, false, true, false)
}

TColsYCenter(cols : [Tropic]) -> Tropic {
	TSegmentCenter(cols, false, true, true)
}

TBaselineColsXCenter(cols : [Tropic]) -> Tropic {
	TSegmentCenter(cols, true, true, false)
}

TBaselineColsYCenter(cols : [Tropic]) -> Tropic {
	TSegmentCenter(cols, true, true, true)
}

TColsYCenterA(cols : [Tropic]) -> Tropic {
	sizes = generate(0, length(cols), \__ -> make(0.0));

	segmentsAttaches =
		mapi(cols, \i, segment ->
			TAttachHeight(segment, sizes[i])
		);

	TColsA(map(segmentsAttaches, \sa ->
		TCenterYIn(sa, TSizedHeight(0.0, fmaxA(sizes, 0.0)))
	));
}

TLinesXCenter(lines : [Tropic]) -> Tropic {
	TSegmentCenter(lines, false, false, false)
}

TLinesYCenter(lines : [Tropic]) -> Tropic {
	TSegmentCenter(lines, false, false, true)
}

TBaselineLinesXCenter(lines : [Tropic]) -> Tropic {
	TSegmentCenter(lines, true, false, false)
}

TBaselineLinesYCenter(lines : [Tropic]) -> Tropic {
	TSegmentCenter(lines, true, false, true)
}

TColsSameWidth(cols : [Tropic]) -> Tropic {
	TSegmentSameMetric(cols, true, false)
}

TColsSameHeight(cols : [Tropic]) -> Tropic {
	TSegmentSameMetric(cols, true, true)
}

TLinesSameWidth(lines : [Tropic]) -> Tropic {
	TSegmentSameMetric(lines, false, false)
}

TLinesSameHeight(lines : [Tropic]) -> Tropic {
	TSegmentSameMetric(lines, false, true)
}

// Only for internal use. Do not export
TSegmentCenter(segments : [Tropic], baseline : bool, cols : bool, vertical : bool) -> Tropic {
	sizes = generate(0, length(segments), \__ -> make(0.0));

	segmentsAttaches =
		mapi(segments, \i, segment ->
			if (vertical)
				TAttachHeight(segment, sizes[i])
			else
				TAttachWidth(segment, sizes[i])
		);

	(if (vertical)
		map(segmentsAttaches, \sa -> TCenterYIn(sa, TSizedHeight(0.0, fmaxA(sizes, 0.0))))
	else
		map(segmentsAttaches, \sa -> TCenterXIn(sa, TSizedWidth(fmaxA(sizes, 0.0), 0.0))))
	|> (
		if (cols) {
			if (baseline)
				TBaselineCols
			else
				TCols
		} else {
			if (baseline)
				TBaselineLines
			else
				TLines
		}
	)
}

// Only for internal use. Do not export
TSegmentSameMetric(segments : [Tropic], cols : bool, vertical : bool) -> Tropic {
	sizes = generate(0, length(segments), \__ -> make(0.0));

	segmentsAttaches =
		mapi(segments, \i, segment ->
			if (vertical)
				TAttachHeight(segment, sizes[i])
			else
				TAttachWidth(segment, sizes[i])
		);

	(if (vertical)
		map(segmentsAttaches, \sa -> TAvailableHeight(sa, fmaxA(sizes, 0.0)))
	else
		map(segmentsAttaches, \sa -> TAvailableWidth(sa, fmaxA(sizes, 0.0))))
	|> if (cols) TCols else TLines
}

TPad(x : double, y : double, t : Tropic) -> Tropic {
	// TODO: Handle negative coordinates here
	TBorder(x, y, 0.0, 0.0, t)
}

TPadA(x : double, y : double, t : Tropic) -> Tropic {
	if (getDefaultRtl()) TBorder(0.0, y, x, 0.0, t)
	else TPad(x, y, t);
}

TFrame(margin : double, radius : double, style : [TGraphicsStyle], box : Tropic) -> Tropic {
	borderedBox = TBorder(margin, margin, margin, margin, box);

	if (style != [])
		TransformTAcc2(\tac -> {
			b1 = borderedBox |> tac;

			gstyle = tgraphicsStyle2graphicsStyle(style);

			makeFGraphics = \w, h ->
				FGraphics(
					if (equalDoubles(radius, 0.))
						[GRect(0.0, 0.0, w, h)]
					else if (equalDoubles(w, h) && equalDoubles(radius, w / 2.0))
						[GCircle(radius, radius, radius)]
					else
						[GRoundedRect(0.0, 0.0, w, h, radius)],
					gstyle
				);

			TAcc(b1 with form =
				FGroup([
					if (b1.xConstant && b1.yConstant)
						makeFGraphics(fgetValue(b1.metrics.width), fgetValue(b1.metrics.height))
					else
						FMutable(fselect2(b1.metrics.width, b1.metrics.height, FLift2(makeFGraphics))),
					b1.form
				], false)
			)
		})
	else
		borderedBox
}

TFrameT(margin : Transform<double>, radius : Transform<double>, style : [TGraphicsStyle], box : Tropic) -> Tropic {
	borderedBox = TBorderT(margin, margin, margin, margin, box);

	if (style != [])
		TransformTAcc2(\tac -> {
			b1 = borderedBox |> tac;

			gstyle = tgraphicsStyle2graphicsStyle(style);

			makeFGraphics = \w, h ->
				FMutable(fselect(radius, FLift(\r ->
					FGraphics(
						if (r == 0.)
							rectangle(0., 0., w, h)
						else
							perfectRoundedRect(w, h, r),
						gstyle
					)
				)));

			TAcc(b1 with form =
				FGroup([
					if (b1.xConstant && b1.yConstant)
						makeFGraphics(fgetValue(b1.metrics.width), fgetValue(b1.metrics.height))
					else
						FMutable(fselect2(b1.metrics.width, b1.metrics.height, FLift2(makeFGraphics))),
					b1.form
				], false)
			)
		})
	else
		borderedBox
}

TFrameCustom(l : double, tl : double, tlRounded : bool, t : double, tr : double, trRounded : bool, r : double,
	br : double, brRounded : bool, b : double, bl : double, blRounded : bool, style : [TGraphicsStyle], box : Tropic) -> Tropic {
	if (style != [])
		TransformTAcc2(\tac -> {
				b1 = TBorder(r, t, l, b, box) |> tac;

				gstyle = tgraphicsStyle2graphicsStyle(style);

				makeFGraphics = \w, h ->
					FGraphics(
						customRect(w, h, tl, tr, br, bl, tlRounded, trRounded, brRounded, blRounded),
						gstyle
					);

				TAcc(b1 with form =
					FGroup([
						if (b1.xConstant && b1.yConstant)
							makeFGraphics(fgetValue(b1.metrics.width), fgetValue(b1.metrics.height))
						else
							FMutable(fselect2(b1.metrics.width, b1.metrics.height, FLift2(makeFGraphics))),
						b1.form
					], false)
				)
			}
		)
	else if (r != 0. || t != 0. || l != 0. || b != 0.)
		TBorder(r, t, l, b, box)
	else
		box
}

TRoundedFull(style : [TGraphicsStyle], size : Tropic) -> Tropic {
	TransformTAcc(\tac, pi, ss, mo -> {
		b1 = tac(size, pi, ss, true);

		if (style != []) {
			gstyle = tgraphicsStyle2graphicsStyle(style);

			makeFGraphics = \w, h -> {
				r = min(w, h) / 2.0;

				if (r > 0.)
					FGraphics(perfectRoundedRect(w, h, r), gstyle)
				else
					FEmpty()
			};

			TAcc(b1 with form =
				FGroup([
					if (b1.xConstant && b1.yConstant)
						makeFGraphics(fgetValue(b1.metrics.width), fgetValue(b1.metrics.height))
					else
						FMutable(fselect2(b1.metrics.width, b1.metrics.height, FLift2(makeFGraphics))),
					b1.form
				], false)
			)
		} else {
			b1;
		}
	})
}

TRounded4(radius : double, style : [TGraphicsStyle], size : Tropic) -> Tropic {
	TRounded(radius, radius, radius, radius, style, size);
}

TScrollableWithBars(content : Tropic, maxbox : Tropic, style : ScrollableStyle, state : [TScrollableState]) -> Tropic {
	margin = 20.0 + style.borderGap;
	TBorder(0.0, 0.0, margin, margin, TScrollable(content, maxbox, style, state));
}

TScrollableEdged(content : Tropic, maxbox : Tropic,  style : ScrollableStyle, state : [TScrollableState], background : Maybe<(Tropic) -> Tropic>,
	foreground : Maybe<(Tropic) -> Tropic>) -> Tropic {
	state2 = concat(state, [TStickToEdge()]);
	TLet("scrollable",
		TScrollable(content, maxbox, style, state2),
		TGroup([
			eitherMap(background, \fn -> TGhost("scrollable") |> fn, TEmpty()),
			TDisplay("scrollable"),
			maxbox,
			eitherMap(foreground, \fn -> TGhost("scrollable") |> fn, TEmpty())
		])
	)
}

TCenterX(b : Tropic) -> Tropic {
	TTweak([TAlign(const(0.5), const(0.0))], b, TFillX())
}

TCenterY(b : Tropic) -> Tropic {
	TTweak([TAlign(const(0.0), const(0.5))], b, TFillY())
}

TCenterXIn(t : Tropic, box : Tropic) -> Tropic {
	TTweak([TAlign(const(0.5), const(0.0))], t, box)
}

TCenterYIn(t : Tropic, box : Tropic) -> Tropic {
	TTweak([TAlign(const(0.0), const(0.5))], t, box)
}

TCenter(b : Tropic) -> Tropic {
	TTweak([TAlign(const(0.5), const(0.5))], b, TFillXY())
}

TCenterIn(b : Tropic, frame : Tropic) -> Tropic {
	TTweak([TAlign(const(0.5), const(0.5))], b, frame)
}

TZoom(content : Tropic, container : Tropic, keepAspect : bool) -> Tropic {
	TTweak([TFitZoom(keepAspect, false)], content, container);
}

TZoomToFill(content : Tropic, container : Tropic, crop : bool) -> Tropic {
	TTweak([TFillZoom(crop)], content, container);
}

TZoomOnOverflow(content : Tropic, container : Tropic, keepAspect : bool) -> Tropic {
	TCopySize(
		container,
		\tr ->
			TTweak([TFitZoom(keepAspect, false)], TGroup2(content, tr), tr),
		true
	);
}

TCenterScale(tropic : Tropic, xscale : double, yscale: double) -> Tropic {
	norm = \v -> forceRange(v, 0.0, 1.0);
	shift = \v -> (v - 1.0) / 2.0;
	fx = norm(xscale);
	fy = norm(yscale);
	TLet("wh", TFillXY(), TMinimumGroup2(
		TShift(
			TZoom(tropic, TScale(const(Factor(fx, fy)), TGhost("wh")), false),
			TScale(const(Factor(shift(fx), shift(fy))), TGhost("wh"))),
		TDisplay("wh")
	))
}

TMinimumMetrics(content : Tropic) -> Tropic {
	TransformTAcc2(\t2a -> {
		b1 = content |> t2a;

		TAcc(b1 with metrics =
			TFormMetrics(
				b1.minWidth,
				b1.minHeight,
				b1.metrics.baseline
			)
		)
	})
}

TFillXY() -> Tropic {
	TNative(\x, y -> {
		wd = fmax(x, zero);
		hgt = fmax(y, zero);

		TAcc(
			FEmpty(),
			TFormMetrics(wd, hgt, hgt),
			zero,
			zero,
			const(^tropicFillersMax),
			const(^tropicFillersMax),
			const(1.),
			const(1.),
			const(false),
			isFConst(x),
			isFConst(y),
			[]
		)
	})
}

TFillXH(height : double) -> Tropic {
	TFillXHT(const(height))
}

TFillXHT(hgt : Transform<double>) -> Tropic {
	TNative(\x, __ -> {
		wd = fmax(x, zero);

		TAcc(
			FEmpty(),
			TFormMetrics(wd, hgt, hgt),
			zero,
			hgt,
			const(^tropicFillersMax),
			hgt,
			const(1.),
			zero,
			const(false),
			isFConst(x),
			true,
			[]
		)
	})
}

TFillXW(minWidth : double) -> Tropic {
	TFillXWT(const(minWidth))
}

TFillXWT(minWidth : Transform<double>) -> Tropic {
	TNative(\x, __ -> {
		wd = fmax(fmax(minWidth, x), zero);
		hgt = zero;

		TAcc(
			FEmpty(),
			TFormMetrics(wd, hgt, hgt),
			minWidth,
			hgt,
			const(^tropicFillersMax),
			hgt,
			const(1.),
			zero,
			const(false),
			isFConst(x),
			true,
			[]
		)
	})
}

TFillWY(width : double) -> Tropic {
	TFillWYT(const(width))
}

TFillWYT(wd : Transform<double>) -> Tropic {
	TNative(\__, y -> {
		hgt = fmax(y, zero);

		TAcc(
			FEmpty(),
			TFormMetrics(wd, hgt, hgt),
			wd,
			zero,
			wd,
			const(^tropicFillersMax),
			zero,
			const(1.),
			const(false),
			true,
			isFConst(y),
			[]
		)
	})
}

TFillYH(minHeight : double) -> Tropic {
	TFillYHT(const(minHeight))
}

TFillYHT(minHeight : Transform<double>) -> Tropic {
	TNative(\x, y -> {
		wd = zero;
		hgt = fmax(fmax(minHeight, y), zero);

		TAcc(
			FEmpty(),
			TFormMetrics(wd, hgt, hgt),
			wd,
			minHeight,
			wd,
			const(^tropicFillersMax),
			zero,
			const(1.),
			const(false),
			true,
			isFConst(y),
			[]
		)
	})
}

TFillXYXY(minWidth : double, minHeight : double, maxWidth : double, maxHeight : double) -> Tropic {
	TNative(\x, y -> {
		miw = const(minWidth);
		mih = const(minHeight);
		maw = const(maxWidth);
		mah = const(maxHeight);

		mwc = maxWidth > minWidth;
		mhc = maxHeight > minHeight;

		wd = fmin(fmax(x, miw), maw);
		hgt = fmin(fmax(y, mih), mah);

		TAcc(
			FEmpty(),
			TFormMetrics(wd, hgt, hgt),
			miw,
			mih,
			maw,
			mah,
			const(b2d(mwc)),
			const(b2d(mhc)),
			const(false),
			!mwc || isFConst(x),
			!mhc || isFConst(y),
			[]
		)
	})
}

TFillMax(maxWidth : double, maxHeight : double) -> Tropic {
	TFillXYXY(0., 0., maxWidth, maxHeight)
}

TFillMaxWY(maxWidth : double) -> Tropic {
	TFillMax(maxWidth, ^tropicFillersMax)
}

TFillMin(minWidth : double, minHeight : double) -> Tropic {
	TFillXYXY(minWidth, minHeight, ^tropicFillersMax, ^tropicFillersMax)
}

THeight(tropic : Tropic) -> Tropic {
	TransformTAcc2(\tac -> {
		bf = TSizeOf(tropic) |> tac;

		TAcc(
			FEmpty(),
			TFormMetrics(
				zero,
				bf.metrics.height,
				bf.metrics.baseline
			),
			zero,
			bf.minHeight,
			zero,
			bf.maxHeight,
			zero,
			bf.yFillers,
			bf.addFillers,
			true,
			bf.yConstant,
			bf.disposers
		)
	})
}

TWidth(tropic : Tropic) -> Tropic {
	TransformTAcc2(\tac -> {
		bf = TSizeOf(tropic) |> tac;

		TAcc(
			FEmpty(),
			TFormMetrics(
				bf.metrics.width, zero, zero
			),
			bf.minWidth,
			zero,
			bf.maxWidth,
			zero,
			bf.xFillers,
			zero,
			bf.addFillers,
			bf.xConstant,
			true,
			bf.disposers
		)
	})
}

TIfLazy(value : Transform<bool>, f : (bool) -> Tropic) -> Tropic {
	tTrue : ref Maybe<Tropic> = ref None();
	tFalse : ref Maybe<Tropic> = ref None();

	TFSelect(value, FLift(\v -> {
		onlyOnce(if (v) tTrue else tFalse, \ -> f(v))
	}))
}

TFSelect(value : Transform<?>, fn : FFn<?, Tropic>) -> Tropic {
	t = fselect(value, fn);
	if (isFConst(t)) {
		// If we are constant, let's avoid the mutable altogether
		fgetValue(t)
	} else {
		TMutable(t);
	}
}

TSelect(value : Transform<?>, fn : (?) -> Tropic) -> Tropic {
	TFSelect(value, FLift(fn));
}

TSelect2(v1 : Transform<?>, v2 : Transform<??>, fn : (?, ??) -> Tropic) -> Tropic {
	t = fselect2(v1, v2, FLift2(fn));

	if (isFConst(t)) {
		// If we are constant, let's avoid the mutable altogether
		fgetValue(t)
	} else {
		TMutable(t);
	}
}

TSelect3(v1 : Transform<?>, v2 : Transform<??>, v3 : Transform<???>, fn : (?, ??, ???) -> Tropic) -> Tropic {
	t = fselect3(v1, v2, v3, fn);

	if (isFConst(t)) {
		// If we are constant, let's avoid the mutable altogether
		fgetValue(t)
	} else {
		TMutable(t);
	}
}

TMutableMaybe(v : Transform<Maybe<Tropic>>) -> Tropic {
	if (isFConst(v)) {
		// If we are constant, let's avoid the mutable altogether
		either(fgetValue(v), TEmpty())
	} else {
		TMutable(feither(v, const(TEmpty())));
	}
}

TSelectMaybe(v : Transform<Maybe<?>>, fn : (?) -> Tropic) -> Tropic {
	if (isFConst(v)) {
		// If we are constant, let's avoid the mutable altogether
		eitherMap(fgetValue(v), fn, TEmpty())
	} else {
		TMutable(feitherMap(v, fn, const(TEmpty())));
	}
}

TFixSize(tropic : Tropic, size : Tropic) -> Tropic {
	TSize(size, tropic)
}

TFormWH(form : Form, wh : WidthHeight) -> Tropic {
	TForm(Available2(const(wh), form));
}

TLetMany(items : [Pair<string, Tropic>], scope : Tropic) -> Tropic {
	fold(items, scope, \s, i -> TLet(i.first, i.second, s))
}

TRotate90(tropic : Tropic) -> Tropic {
	TransformTAcc(\t2a, p, s, mo -> {
		bf = t2a(tropic, TParentInfo(p.maxY, p.maxX, p.environment, p.transformMatrix, p.worldVisible, p.viewBounds), s, mo);

		TAcc(
			FRotate(const(90.), bf.form)
			|> (\t -> FTranslate(bf.metrics.height, const(0.), t)),
			TFormMetrics(
				bf.metrics.height,
				bf.metrics.width,
				bf.metrics.width
			),
			bf.minHeight,
			bf.minWidth,
			bf.maxHeight,
			bf.maxWidth,
			bf.yFillers,
			bf.xFillers,
			bf.addFillers,
			bf.yConstant,
			bf.xConstant,
			bf.disposers
		)
	})
}

TRotate90Left(tropic: Tropic) -> Tropic {
	TransformTAcc(\t2a, p, s, mo -> {
		bf = t2a(tropic, TParentInfo(p.maxY, p.maxX, p.environment, p.transformMatrix, p.worldVisible, p.viewBounds), s, mo);

		TAcc(
			FRotate(const(-90.), bf.form)
			|> (\f -> FTranslate(const(0.), bf.metrics.width, f)),
			TFormMetrics(
				bf.metrics.height,
				bf.metrics.width,
				bf.metrics.width
			),
			bf.minHeight,
			bf.minWidth,
			bf.maxHeight,
			bf.maxWidth,
			bf.yFillers,
			bf.xFillers,
			bf.addFillers,
			bf.yConstant,
			bf.xConstant,
			bf.disposers
		)
	})
}

TRotate180(enabled : Transform<bool>, size : Tropic) -> (Tropic) -> Tropic {
	\t ->
		TShift(
			TRotate(fif(enabled, const(180.), const(0.)), t),
			TScale(const(Factor(-1., -1.)), TShow(enabled, size))
		)
}

TShow(show : Transform<bool>, tropic : Tropic) -> Tropic {
	TIf(show, tropic, TEmpty());
}

TShowLazy(show : Transform<bool>, tr : () -> Tropic) -> Tropic {
	t : ref Maybe<Tropic> = ref None();

	TFSelect(show, FLift(\s -> {
		if (s) onlyOnce(t, \ -> tr()) else TEmpty()
	}))
}

TVisibleLazy(show : Transform<bool>, tr : () -> Tropic) -> Tropic {
	if (fgetValue(show)) {
		TVisible(show, tr());
	} else if (show == const(false)) {
		TEmpty();
	} else {
		content = make(TEmpty());

		TConstruct(
			[
				\ -> fwhen(show, \ -> next(content, TVisible(show, tr())))
			],
			TMutable(content)
		);
	}
}

TCropSizeX(content : Tropic, width : Tropic) -> Tropic {
	TCropSize(TGroup2(THeight(content), TWidth(width)), content);
}

TCropSizeY(content : Tropic, height : Tropic) -> Tropic {
	TCropSize(TGroup2(TWidth(content), THeight(height)), content);
}

TAcc2Size(acc : TAcc) -> Tropic {
	TNative(\__, __ -> {
		f =
			FMutable(
				fselect2(acc.metrics.width, acc.metrics.height, FLift2(\wd, hgt ->
					FRectangle(wd, hgt, interactiveRectangleStyle)
				))
			);

		TAcc(acc with form = f, disposers = [])
	})
}

TCopySize(content : Tropic, copyFn : (Tropic) -> Tropic, above : bool) -> Tropic {
	TransformTAcc2(\t2a -> {
		b1 = content |> t2a;
		tr = TAcc2Size(b1);
		b2 = copyFn(tr) |> t2a;

		TAcc(b1 with
			form = FGroup([
				b1.form,
				b2.form
			] |> (\f : [FForm] -> if (above) f else reverseA(f)),
			true),
			disposers = concat(b1.disposers, b2.disposers)
		)
	})
}

TCopySize2(content : Tropic, copyFn : (Tropic, Tropic) -> Tropic) -> Tropic {
	TransformTAcc(\t2a, pi, sheet, mo -> {
			innerParentInfo = make(pi);

			parentInfo =
				TParentInfo(
					pi.maxX,
					pi.maxY,
					makeTree(),
					fsubselect(innerParentInfo, FLift(\v -> v.transformMatrix)), // Handle properly view bounds in child
					fsubselect(innerParentInfo, FLift(\v -> v.worldVisible)),
					fsubselect(innerParentInfo, FLift(\v -> v.viewBounds))
				);


			b1 = t2a(content, parentInfo, sheet, mo);
			tr = TAcc2Size(b1);

			t2a(
				copyFn(
					tr,
					TransformTAcc(\t2a2, pi2, sheet2, mo2 -> {
						next(innerParentInfo, pi2);

						b1;
					})
				),
				pi,
				sheet,
				mo
			)
		}
	)
}

TBaseline(baseline : Transform<double>, content : Tropic) -> Tropic {
	TransformTAcc2(\t2a -> {
			b1 = content |> t2a;

			TAcc(
				b1.form,
				TFormMetrics(
					b1.metrics.width,
					b1.metrics.height,
					baseline
				),
				b1.minWidth,
				b1.minHeight,
				b1.maxWidth,
				b1.maxHeight,
				b1.xFillers,
				b1.yFillers,
				b1.addFillers,
				b1.xConstant,
				b1.yConstant && isFConst(baseline),
				b1.disposers
			)
		}
	)
}

TFullScreen(fs : DynamicBehaviour<bool>, tr : Tropic) -> Tropic {
	fw = make(false);

	changeFullscreen = \fsc -> {
		toggleFullScreen(fsc);

		// For targets without fullscreen available
		if (targetNoFullscreen())
			nextDistinct(fw, fsc);
	}

	TConstruct(
		[
			\ -> \ -> if (getValue(fs)) {
				toggleFullScreen(false);
			},
			\ -> onFullScreen(\change -> {
				nextDistinct(fs, change);
				nextDistinct(fw, change);
			}),
			\ -> {
				if (getValue(fs)) changeFullscreen(true);
				nop;
			},
			\ -> subscribe2(fs, changeFullscreen)
		],
		TFullWindow(fw, tr)
	);
}

longTouchCounter = ref 0;

TLongTouch(duration : int, fn : () -> void, handle : bool, tropic : Tropic) -> Tropic {
	pressed = ref false;
	mdowni = ref MouseDownInfo(0.0, 0.0, 0.0, 0.0, \ -> false);

	TInteractive(
		[
			MouseDown2(\handled, mdi -> {
				if (mdi.inside()) {
					pressed := true;
					longTouchCounter := ^longTouchCounter + 1;
					longTouchId = ^longTouchCounter;
					timer(duration, \ -> {
						if(^longTouchCounter == longTouchId) {
							fn(); // TAP!
						}
					});
				}
				handle
			}),
			MouseUp2(\handled, mui -> {
				pressed := false;
				longTouchCounter := ^longTouchCounter + 1;
				handled // let it fall through
			}),
			MouseMove2(\handled, mmi -> {
				mi = mmi();
				mmovedx = mi.x - (^mdowni).x;
				mmovedy = mi.y - (^mdowni).y;

				sqdelta = mmovedx * mmovedx + mmovedy * mmovedy;
				if(^pressed && (!mi.inside || sqdelta > 200.0)){
					longTouchCounter := ^longTouchCounter + 1;
				}
				handled // let it fall through
			})
		],
		tropic
	)
}

TransformTAcc2(fn : ((Tropic) -> TAcc) -> TAcc) -> Tropic {
	TransformTAcc(\t2a, p, s, mo -> fn(\tr -> t2a(tr, p, s, mo)))
}

TAttachWidth2(t : Tropic, width : DynamicBehaviour<double>, content : Tropic) -> Tropic {
	TransformTAcc2(\t2a -> {
			b1 = t |> t2a;
			b2 = content |> t2a;

			TAcc(
				b2.form,
				TFormMetrics(
					b1.metrics.width,
					b2.metrics.height,
					b2.metrics.baseline
				),
				b1.minWidth,
				b2.minHeight,
				b1.maxWidth,
				b2.maxHeight,
				b1.xFillers,
				b2.yFillers,
				b1.addFillers,
				b1.xConstant,
				b2.yConstant,
				concat(arrayPush(b1.disposers, fconnect(b1.metrics.width, width)), b2.disposers)
			)
		}
	)
}

TAttachHeight2(t : Tropic, height : DynamicBehaviour<double>, content : Tropic) -> Tropic {
	TransformTAcc2(\t2a -> {
			b1 = t |> t2a;
			b2 = content |> t2a;

			TAcc(
				b2.form,
				TFormMetrics(
					b2.metrics.width,
					b1.metrics.height,
					b2.metrics.baseline
				),
				b2.minWidth,
				b1.minHeight,
				b2.maxWidth,
				b1.maxHeight,
				b2.xFillers,
				b1.yFillers,
				b1.addFillers,
				b2.xConstant,
				b1.yConstant,
				concat(arrayPush(b1.disposers, fconnect(b1.metrics.height, height)), b2.disposers)
			)
		}
	)
}

TAttachBox2(t : Tropic, box : DynamicBehaviour<WidthHeight>, content : Tropic) -> Tropic {
	TransformTAcc2(\t2a -> {
		b1 = t |> t2a;
		b2 = content |> t2a;

		disp =
			concat(arrayPush(b1.disposers, fconnect(fwidthheight(b1.metrics.width, b1.metrics.height), box)), b2.disposers);

		TAcc(b1 with form = b2.form, disposers = disp)
	})
}

TAttachBox(t : Tropic, box : DynamicBehaviour<WidthHeight>) -> Tropic {
	TInspect([ISize(box)], t)
}

TAttachWidth(t : Tropic, width : DynamicBehaviour<double>) -> Tropic {
	TInspect([Width(width)], t)
}

TAttachMinWidth(t : Tropic, minWidth : DynamicBehaviour<double>) -> Tropic {
	TransformTAcc2(\t2a -> {
		b1 = t |> t2a;
		disp = arrayPush(b1.disposers, fconnect(b1.minWidth, minWidth));
		TAcc(b1 with disposers = disp)
	})
}

TAttachHeight(t : Tropic, height : DynamicBehaviour<double>) -> Tropic {
	TInspect([Height(height)], t)
}

TAttachHeightTrigger(t : Tropic, height : DynamicBehaviour<double>, trigger : Transform<bool>) -> Tropic {
	TransformTAcc2(\t2a -> {
		b1 = t |> t2a;
		disp =
			arrayPush(b1.disposers, makeSubscribeTrigger(trigger, b1.metrics.height, \h -> nextDistinct(height, h))());

		TAcc(b1 with disposers = disp)
	})
}

TAttachWidthHeight(
	t : Tropic,
	width : DynamicBehaviour<double>,
	height : DynamicBehaviour<double>) -> Tropic {

	TInspect([Width(width), Height(height)], t)
}

TAttachBoxThrottle(t : Tropic, box : DynamicBehaviour<WidthHeight>, maxDelta : int) -> Tropic {
	TransformTAcc2(\t2a -> {
		b1 = t |> t2a;

		disp =
			arrayPush(b1.disposers, fconnect(fthrottle2(fwidthheight(b1.metrics.width, b1.metrics.height), maxDelta), box));

		TAcc(b1 with disposers = disp)
	})
}

TThrottleMetrics(t : Tropic, maxDelta : int) -> Tropic {
	TransformTAcc2(\t2a -> {
		b1 = t |> t2a;

		TAcc(
			b1.form,
			TFormMetrics(
				fthrottle2(b1.metrics.width, maxDelta),
				fthrottle2(b1.metrics.height, maxDelta),
				fthrottle2(b1.metrics.baseline, maxDelta)
			),
			fthrottle2(b1.minWidth, maxDelta),
			fthrottle2(b1.minHeight, maxDelta),
			fthrottle2(b1.maxWidth, maxDelta),
			fthrottle2(b1.maxHeight, maxDelta),
			fthrottle2(b1.xFillers, maxDelta),
			fthrottle2(b1.yFillers, maxDelta),
			fthrottle2(b1.addFillers, maxDelta),
			b1.xConstant,
			b1.yConstant,
			b1.disposers
		)
	})
}

TAttachAvailable(t : Tropic, box : DynamicBehaviour<WidthHeight>) -> Tropic {
	TInspect([IAvailable(box)], t)
}

TAttachAvailableWidth(t : Tropic, width : DynamicBehaviour<double>) -> Tropic {
	TInspect([AvailableWidth(width)], t)
}

TAttachAvailableHeight(t : Tropic, height : DynamicBehaviour<double>) -> Tropic {
	TInspect([AvailableHeight(height)], t)
}

TAttachAvailableWidthHeight(
	t : Tropic,
	width : DynamicBehaviour<double> ,
	height : DynamicBehaviour<double>) -> Tropic {

	TInspect([AvailableWidth(width), AvailableHeight(height)], t)
}

TProportionGrid(c : [[Pair<Transform<Factor>, Tropic>]]) -> Tropic {
	map(c, \r ->
		map(r, \t ->
			TransformTAcc2(\t2a -> {
					b1 = t.second |> t2a;

					TAcc(b1 with
						xFillers = ffactorX(t.first),
						yFillers = ffactorY(t.first),
						addFillers = const(false),
					)
				}
			)
		)
	)
	|> TGrid
}

TProportionLines(c : [Pair<Transform<double>, Tropic>]) -> Tropic {
	map(c, \t ->
		TransformTAcc2(\t2a -> {
				b1 = t.second |> t2a;

				TAcc(b1 with
					yFillers = t.first,
					addFillers = const(false),
					xConstant = false,
				)
			}
		)
	)
	|> TLines
}

TProportionCols(c : [Pair<Transform<double>, Tropic>]) -> Tropic {
	map(c, \t ->
		TransformTAcc2(\t2a -> {
				b1 = t.second |> t2a;

				TAcc(b1 with
					xFillers = t.first,
					addFillers = const(false),
					xConstant = false,
				)
			}
		)
	)
	|> TCols
}

TProportionBaselineCols(c : [Pair<Transform<double>, Tropic>]) -> Tropic {
	map(c, \t ->
		TransformTAcc2(\t2a -> {
				b1 = t.second |> t2a;

				TAcc(b1 with
					xFillers = t.first,
					addFillers = const(false),
					xConstant = false,
				)
			}
		)
	)
	|> TBaselineCols
}

TProportionColsA(c : [Pair<Transform<double>, Tropic>]) -> Tropic {
	map(c, \t ->
		TransformTAcc2(\t2a -> {
				b1 = t.second |> t2a;

				TAcc(b1 with
					xFillers = t.first,
					addFillers = const(false),
					xConstant = false,
				)
			}
		)
	)
	|> TColsA
}

TAvailableWidth(tr : Tropic, available : Transform<double>) -> Tropic {
	TransformTAcc(\t2a, pi, st, mo ->
		t2a(tr, TParentInfo(pi with maxX = available), st, mo)
	)
}

TAvailableHeight(tr : Tropic, available : Transform<double>) -> Tropic {
	TransformTAcc(\t2a, pi, st, mo ->
		t2a(tr, TParentInfo(pi with maxY = available), st, mo)
	)
}

TAvailableWidthHeight(tr : Tropic, availableW : Transform<double>, availableH : Transform<double>) -> Tropic {
	TransformTAcc(\t2a, pi, st, mo ->
		t2a(tr, TParentInfo(pi with maxX = availableW, maxY = availableH), st, mo)
	)
}

TAlignHorizontal(align : CommonAlignment) -> (Tropic) -> Tropic {
	switch (align : CommonAlignment) {
		StartAlign() : TAlignStart;
		EndAlign() : TAlignEnd;
		LeftAlign() : TAlignLeft;
		RightAlign() : TAlignRight;
		CenterAlign() : \t -> TTweak([TAlign(const(0.5), const(0.0))], t, TFillX());
	}
}

TAlignStart(t : Tropic) -> Tropic {
	if (getDefaultRtl()) TAlignRight(t) else t
}

TAlignEnd(t : Tropic) -> Tropic {
	if (!getDefaultRtl()) TAlignRight(t) else t
}

TAlignLeft(t : Tropic) -> Tropic {
	TTweak([TAlign(const(0.0), const(0.0))], t, TFillX())
}

TAlignTop(t : Tropic) -> Tropic {
	TTweak([TAlign(const(0.0), const(0.0))], t, TFillY())
}

TAlignRight(t : Tropic) -> Tropic {
	TTweak([TAlign(const(1.0), const(0.0))], t, TFillX())
}

TAlignBottom(t : Tropic) -> Tropic {
	TTweak([TAlign(const(0.0), const(1.0))], t, TFillY())
}

TAlignTopLeft(t : Tropic) -> Tropic {
	TTweak([TAlign(const(0.0), const(0.0))], t, TFillXY())
}

TAlignTopCenter(t : Tropic) -> Tropic {
	TTweak([TAlign(const(0.5), const(0.0))], t, TFillXY())
}

TAlignTopRight(t : Tropic) -> Tropic {
	TTweak([TAlign(const(1.0), const(0.0))], t, TFillXY())
}

TAlignCenterRight(t : Tropic) -> Tropic {
	TTweak([TAlign(const(1.0), const(0.5))], t, TFillXY())
}

TAlignBottomRight(t : Tropic) -> Tropic {
	TTweak([TAlign(const(1.0), const(1.0))], t, TFillXY())
}

TAlignBottomCenter(t : Tropic) -> Tropic {
	TTweak([TAlign(const(0.5), const(1.0))], t, TFillXY())
}

TAlignBottomLeft(t : Tropic) -> Tropic {
	TTweak([TAlign(const(0.0), const(1.0))], t, TFillXY())
}

TAlignCenterLeft(t : Tropic) -> Tropic {
	TTweak([TAlign(const(0.0), const(0.5))], t, TFillXY())
}

TBorderTop(border : double) -> (Tropic) -> Tropic {
	\tr -> TBorder(0., border, 0., 0., tr)
}

TBorderBottom(border : double) -> (Tropic) -> Tropic {
	\tr -> TBorder(0., 0., 0., border, tr)
}

TBorderLeft(border : double) -> (Tropic) -> Tropic {
	\tr -> TBorder(border, 0., 0., 0., tr)
}

TBorderRight(border : double) -> (Tropic) -> Tropic {
	\tr -> TBorder(0., 0., border, 0., tr)
}

TBorderTopBottom(border : double) -> (Tropic) -> Tropic {
	\tr -> TBorder(0., border, 0., border, tr)
}

TBorderLeftRight(border : double) -> (Tropic) -> Tropic {
	\tr -> TBorder(border, 0., border, 0., tr)
}

TBorderT(left : Transform<double>, top : Transform<double>, right : Transform<double>, bottom : Transform<double>, t : Tropic) -> Tropic {
	TransformTAcc(\tropic2acc, parent, sheet, metricsOnly -> {
		wSum = faddition(left, right);
		hSum = faddition(top, bottom);

		t2a = \tr -> tropic2acc(
			tr,
			TParentInfo(
				fsubtract(parent.maxX, wSum),
				fsubtract(parent.maxY, hSum),
				parent.environment,
				parent.transformMatrix,
				parent.worldVisible, // TODO: Update
				parent.viewBounds
			),
			sheet,
			metricsOnly
		);

		b = t |> t2a;

		width = faddition(b.metrics.width, wSum);
		height = faddition(b.metrics.height, hSum);
		baseline = faddition(b.metrics.baseline, top);

		TAcc(
			b.form,
			TFormMetrics(width, height, baseline),
			faddition(b.minWidth, wSum),
			faddition(b.minHeight, hSum),
			faddition(b.maxWidth, wSum),
			faddition(b.maxHeight, hSum),
			b.xFillers,
			b.yFillers,
			b.addFillers,
			b.xConstant && isFConst(left) && isFConst(right),
			b.yConstant && isFConst(top) && isFConst(bottom),
			b.disposers
		)
	})
	|> (\f -> TTranslate(fpoint(left, top), f))
}

TDecorator(tr : Tropic, decorators : [Pair<Transform<bool>, (Transform<WidthHeight>) -> Tropic>], above : bool) -> Tropic {
	TransformTAcc2(\t2a -> {
		b1 = tr |> t2a;
		wh = fwidthheight(b1.metrics.width, b1.metrics.height);

		TAcc(b1 with form =
			FDecorator(
				b1.form,
				map(decorators, \d -> {
					Pair(
						d.first,
						\ -> d.second(wh) |> t2a |> (\b2 -> FConstructor(b2.form, \ -> \ -> applyall(b2.disposers)))
					)
				}),
				above
			)
		)
	})
}

TDynamicText(text : Transform<string>, style : [TCharacterStyle]) -> Tropic {
	if (isFConst(text)) {
		if (text == const("")) {
			TEmpty()
		} else {
			TText(fgetValue(text), style)
		}
	} else {
		replaceTextFn = ref None();

		TConstruct(
			[
				makeSubscribe(text, \t -> maybeApply(^replaceTextFn, \fn -> fn(t) |> ignore))
			],
			TText(fgetValue(text), arrayPush(style, FReplaceText(replaceTextFn)))
		)
	}
}

TDebugMetrics(c : int, tr : Tropic) -> Tropic {
	TransformTAcc2(\t2a -> {
		b = TDebug(c, tr) |> t2a;

		TAcc(b with form =
			FGroup2(
				FMutable(fselect2(b.metrics.width, b.metrics.height, FLift2(\wd, hgt -> FText(d2s(wd) + "x" + d2s(hgt), [])))),
				b.form,
				false
			)
		)
	})
}

TDebugPositionScale(c : int, tr : Tropic) -> Tropic {
	TransformTAcc(\t2a, pi, ss, mo -> {
		b = t2a(TDebug(c, tr), pi, ss, mo);

		TAcc(b with form =
			FConstructor(
				b.form,
				makeSubscribeUns(fapplytransform(fwidthheight(b.metrics.width, b.metrics.height), pi.transformMatrix), \vb -> {
					[
						frender(
							FTranslate(
								const(vb.minX),
								const(vb.minY),
								FRectangle(vb.maxX - vb.minX, vb.maxY - vb.minY, [Fill(c), FillOpacity(0.3)])
							),
							makeWH()
						)
					]
				})
			)
		)
	})
}

TDebugViewBounds(c : int, tr : Tropic) -> Tropic {
	TransformTAcc(\t2a, pi, ss, mo -> {
		b = t2a(tr, pi, ss, mo);

		TAcc(b with form =
			FConstructor(
				b.form,
				makeSubscribeUns(pi.viewBounds, \vb -> {
					[
						frender(
							FTranslate(
								const(vb.minX),
								const(vb.minY),
								FRectangle(vb.maxX - vb.minX, vb.maxY - vb.minY, [Fill(c), FillOpacity(0.3)])
							),
							makeWH()
						)
					]
				})
			)
		)
	})
}

TDebugConstruct(tag : string, tr : Tropic) -> Tropic {
	name = if (tag == "") tr.structname else tag;

	TConstruct(
		[
			\ -> {
				println(name + " constructed");
				\ -> println(name + " destroyed");
			}
		],
		tr
	)
}

TIfFits(tr : Tropic) -> Tropic {
	TransformTAcc(\t2a, pi, ss, mo -> {
		b = t2a(tr, pi, ss, mo);
		visible =
			fselect2(
				fwidthheight(pi.maxX, pi.maxY),
				fwidthheight(b.metrics.width, b.metrics.height),
				FLift2(\a, m -> {
					m.width <= a.width && m.height <= a.height
				})
			);

		TAcc(
			FMutable(fif(visible, const(b.form), const(FEmpty()))),
			TFormMetrics(
				fif(visible, b.metrics.width, zero),
				fif(visible, b.metrics.height, zero),
				fif(visible, b.metrics.baseline, zero)
			),
			zero,
			zero,
			b.maxWidth,
			b.maxHeight,
			const(1.),
			const(1.),
			b.addFillers,
			b.xConstant && isFConst(visible),
			b.yConstant && isFConst(visible),
			b.disposers
		)
	});
}

TOnConstruct(fn : () -> void) -> (Tropic) -> Tropic {
	\tr -> TConstruct(
		[
			\ -> {
				fn();
				nop;
			}
		],
		tr
	)
}

TEvenGrid(content : [[Tropic]]) -> Tropic {
	if (length(content) > 0 && length(content[0]) > 0)
		TransformTAcc(\t2a, p, s, mo -> {
			maxX = p.maxX;
			maxY = p.maxY;

			columnWidths = generate(0, either(maxA(map(content, length)), 0), \__ -> make(0.));
			rowHeights = generate(0, length(content), \__ -> make(0.));

			translatesX = generate(0, length(columnWidths), \__ -> make(0.));
			translatesY = generate(0, length(rowHeights), \__ -> make(0.));

			contentAcc =
				mapi(content, \j, c -> mapi(c, \i, tr ->
					t2a(
						tr,
						TParentInfo(
							columnWidths[i],
							rowHeights[j],
							p.environment,
							fworldtransform(p.transformMatrix, fpoint2transform(fpoint(translatesX[i], translatesY[j]))),
							p.worldVisible,
							p.viewBounds
						),
						s,
						mo
					)
				));
			form =
				FGroup(
					mapi(contentAcc, \j, c -> mapi(c, \i, tacc -> FTranslate(translatesX[i], translatesY[j], tacc.form))) |> concatA,
					true
				);
			disp = concatA(map(concatA(contentAcc), \tacc -> tacc.disposers));

			minWidths = generate(0, length(columnWidths), \i -> fmaxA(map(contentAcc, \c -> if (i < length(c)) c[i].minWidth else zero), 0.)) |> fmerge;
			minHeights = map(contentAcc, \c -> fmaxA(map(c, \tacc -> tacc.minHeight), 0.)) |> fmerge;
			maxWidths = generate(0, length(columnWidths), \i -> fmaxA(map(contentAcc, \c -> if (i < length(c)) c[i].maxWidth else zero), 0.)) |> fmerge;
			maxHeights = map(contentAcc, \c -> fmaxA(map(c, \tacc -> tacc.maxHeight), 0.)) |> fmerge;
			xFillers = generate(0, length(columnWidths), \i -> fmaxA(map(contentAcc, \c -> if (i < length(c)) c[i].xFillers else zero), 0.)) |> fmerge;
			yFillers = map(contentAcc, \c -> fmaxA(map(c, \tacc -> tacc.yFillers), 0.)) |> fmerge;

			realWidths = generate(0, length(columnWidths), \i -> fmaxA(map(contentAcc, \c -> if (i < length(c)) c[i].minWidth else zero), 0.));
			realHeights = map(contentAcc, \c -> fmaxA(map(c, \tacc -> tacc.metrics.height), 0.));

			uns1 =
				make4Subscribe(minWidths, maxWidths, maxX, xFillers, \minW, maxW, mx, xf -> {
					wd = ref 0.;

					iteri(distributeSizesEvenly2(minW, maxW, map(columnWidths, getValue), xf, max(mx, dsum(minW))), \i, nw -> {
						nextDistinct(translatesX[i], ^wd);
						wd := ^wd + nw;
						nextDistinct(columnWidths[i], nw);
					})
				})();

			uns2 =
				make4Subscribe(minHeights, maxHeights, maxY, yFillers, \minH, maxH, my, yf -> {
					hgt = ref 0.;

					iteri(distributeSizesEvenly2(minH, maxH, map(rowHeights, getValue), yf, max(my, dsum(minH))), \i, nh -> {
						nextDistinct(translatesY[i], ^hgt);
						hgt := ^hgt + nh;
						nextDistinct(rowHeights[i], nh);
					})
				})();

			TAcc(
				form,
				TFormMetrics(
					fsum(realWidths),
					fsum(realHeights),
					zero
				),
				fselect(minWidths, FLift(dsum)),
				fselect(minHeights, FLift(dsum)),
				fselect(maxWidths, FLift(dsum)),
				fselect(maxHeights, FLift(dsum)),
				fselect(xFillers, FLift(dsum)),
				fselect(yFillers, FLift(dsum)),
				const(false),
				false,
				false,
				concatA([disp, [uns1, uns2]])
			)
		})
	else
		TEmpty()
}

distributeSizesEvenly2(minWidths : [double], maxWidths : [double], columnWidths0 : [double], xFillers : [double], availableWidth : double) -> [double] {
	columnsCount = either(minA([length(minWidths), length(maxWidths), length(columnWidths0)]), 0);

	additionThreshold = 0.;
	sumFillers = max(dsum(xFillers), 1.);

	if (columnsCount > 0) {
		columnWidths = generate(0, columnsCount, \i -> max(columnWidths0[i], minWidths[i]));
		sumWidth = dsum(columnWidths);

		if (sumWidth < availableWidth - additionThreshold || sumWidth > availableWidth + additionThreshold) {
			available = availableWidth - sumWidth;
			addition = available / sumFillers;

			availableForAddition =
				mapi(subrange(maxWidths, 0, columnsCount), \i, mw -> ref
					xFillers[i] > 0. && (if (sumWidth < availableWidth)
						(mw > minWidths[i] && columnWidths[i] < mw) || (mw < minWidths[i])
					else
						columnWidths[i] > minWidths[i])
				);

			newWidths =
				mapi(subrange(columnWidths, 0, columnsCount), \i, cw -> ref
					if (^(availableForAddition[i])) {
						nw = cw + addition * xFillers[i];

						if (nw < minWidths[i]) {
							availableForAddition[i] := false;
							minWidths[i];
						} else if (maxWidths[i] >= minWidths[i] && nw > maxWidths[i]) {
							availableForAddition[i] := false;
							maxWidths[i];
						} else {
							nw
						}
					} else {
						if (minWidths[i] > 0.) {
							if (minWidths[i] <= maxWidths[i])
								min(max(cw, minWidths[i]), maxWidths[i])
							else
								max(cw, minWidths[i])
						} else
							cw
					}
				);

			updateWhile(
				countA(availableForAddition, \afa -> ^afa)
				|> (\afa ->
					if (afa > 0)
						(availableWidth - fold(newWidths, 0., \acc, nw -> acc + ^nw)) / sumFillers
					else
						0.
				),
				\newAddition -> {
					if ((newAddition > additionThreshold || newAddition < additionThreshold) &&
						foldi(availableForAddition, false, \i, acc, afa -> {
							if (^afa) {
								newWidths[i] :=
									max(minWidths[i], ^(newWidths[i]) + newAddition * xFillers[i])
									|> (\f -> if (minWidths[i] < maxWidths[i]) min(f, maxWidths[i]) else f);
								false
							} else {
								acc
							}
						}))
						Some((availableWidth - fold(newWidths, 0., \acc, nw -> acc + ^nw)) / i2d(countA(availableForAddition, \afa -> ^afa)))
					else
						None()
				}
			);

			map(newWidths, \nw -> ^nw);
		} else {
			columnWidths
		}
	} else
		columnWidths0
}

TConstructRenderable(constructors : [() -> () -> void], tr : Tropic) -> Tropic {
	TransformTAcc(\t2a, pi, ss, mo -> {
		b = t2a(tr, pi, ss, mo);

		TAcc(
			FDecorator(
				b.form,
				[
					Pair(pi.worldVisible, \ -> FConstruct(constructors, FEmpty()))
				],
				true
			),
			b.metrics,
			b.minWidth,
			b.minHeight,
			b.maxWidth,
			b.maxHeight,
			b.xFillers,
			b.yFillers,
			b.addFillers,
			b.xConstant,
			b.yConstant,
			b.disposers
		)
	})
}

wh2Tropic(wh : WidthHeight) -> Tropic {
	if (wh.width >= 0.) {
		if (wh.height >= 0.)
			TFixed(wh.width, wh.height)
		else
			TFillWY(wh.width)
	} else if (wh.height >= 0.)
		TFillXH(wh.height)
	else
		TFillXY();
}

TZoomMax(tr : Tropic, maxWH : Transform<WidthHeight>) -> Tropic {
	availableWH = makeWH();
	scaleFactor = fselect2(availableWH, maxWH, FLift2(\awh, mwh -> max3(awh.width / mwh.width, awh.height / mwh.height, 1.0)));

	TScale(ffactor2(scaleFactor), tr)
	|> (\f -> TAttachAvailable(f, availableWH))
}

TZoomMaxWidth(tr : Tropic, maxWidth : Transform<double>) -> Tropic {
	availableX = make(0.0);
	scaleFactor = fmax(fdivide(availableX, maxWidth), const(1.0));

	TScale(ffactor2(scaleFactor), tr)
	|> (\f -> TAttachAvailableWidth(f, availableX))
}

TZoomMaxHeight(tr : Tropic, maxHeight : Transform<double>) -> Tropic {
	availableY = make(0.0);
	scaleFactor = fmax(fdivide(availableY, maxHeight), const(1.0));

	TScale(ffactor2(scaleFactor), tr)
	|> (\f -> TAttachAvailableHeight(f, availableY))
}

disableMouseWheelBelow(content : Tropic) -> Tropic {
	if (mobile)
		content
	else {
		TInteractive(
			[
				FineGrainMouseWheel2(\__, mi -> mi().inside)
			],
			content
		)
	}
}

disableInteractivesBelow(content : Tropic) -> Tropic {
	TCopySize(
		content,
		\tr ->
			TInteractive(
				[
					MouseDown(\mi -> mi.inside()),
					MouseUp(\mi -> mi().inside),
					MouseMove(\mi -> mi().inside),
					RollOver(nop1),
					RollOut(nop1)
				],
				TRectangle(interactiveRectangleStyle, tr)
			),
		false
	)
}

TCheckeredRectangle(style1 : [TGraphicsStyle], style2 : [TGraphicsStyle], content : Tropic) -> Tropic {
	size = makeWH();

	TGroup2(
		TInspect([ISize(size)], content),
		TCropSize(
			TSized(size),
			TFrame(
				0.,
				0.,
				style1,
				TSelect(size, \s -> {
					generate(0, ceil(s.width / 10.0), \i -> {
						generate(0, ceil(s.height / 10.0), \j -> {
							if ((i + j) % 2 == 0)
								TGraphics([GRect(i2d(i * 10), i2d(j * 10), 10.0, 10.0)], style2)
							else
								TEmpty()
						})
					})
					|> concatA
					|> TGroup
				})
			)
		)
	);
}

TCheckeredRounded(
	nw : double,
	ne : double,
	lw : double,
	le : double,
	style1 : [TGraphicsStyle],
	style2 : [TGraphicsStyle],
	content : Tropic
) -> Tropic {
	size = makeWH();

	TGroup2(
		TInspect([ISize(size)], content),
		TMask(
			TFrame(
				0.,
				0.,
				style1,
				TSelect(size, \s -> {
					generate(0, ceil(s.width / 10.0), \i -> {
						generate(0, ceil(s.height / 10.0), \j -> {
							if ((i + j) % 2 == 0)
								TGraphics([GRect(i2d(i * 10), i2d(j * 10), 10.0, 10.0)], style2)
							else
								TEmpty()
						})
					})
					|> concatA
					|> TGroup
				})
			),
			TRounded(nw, ne, lw, le, [Fill(white)], TSized(size))
		)
	);
}

TMouseWheelInteractive(manager : TManager, content : Tropic, deltaX : (double) -> bool, deltaY : (double) -> bool) -> Tropic {
	// Qt target on OSX returns the scroll in pixels, so we scale it by 80.
	scrollScale = if (qt && macosx()) 80. else 1.;

	if (mobile)
		content
	else {
		zorder = ref getValue(manager.zorder);

		TConstruct(
			[
				\ -> {
					zorder := getValue(manager.zorder);
					nop
				}
			],
			TInteractive(
				[
					FineGrainMouseWheel2(\h, mi ->
						if (!h && ^zorder >= getValue(manager.zorder)) {
							m = mi();

							if (m.inside && (m.dx != 0. || m.dy != 0.)) {
								dx = deltaX(m.dx / scrollScale);
								dy = deltaY(m.dy / scrollScale);

								dx || dy
							} else {
								h
							}
						} else
							h
					)
				],
				content
			)
		)
	}
}

T3DStage(scene : F3DObject, camera : F3DObject, size : Tropic, style : [F3DStageStyle]) -> Tropic {
	wh = makeWH();

	TGroup2(
		TInspect(
			[
				ISize(wh),
				IMetricsOnly()
			],
			size
		),
		TFForm(
			F3DStage(
				wh,
				scene,
				camera,
				style
			),
			TFormMetrics(
				fwidth(wh),
				fheight(wh),
				fheight(wh)
			)
		)
	);
}