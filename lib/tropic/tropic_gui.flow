import tropic/selecttarray;
import tropic/tropic_util;
import fform/fform_gui;
import sys/fullscreen;
import ui/fontmapping;
import fusion_utils;
import fform/renderfform;
import tropic/tropic_manager;
import fform/renderform3d;
import fform/fpdf;
import ui/scrollable;

export {
	// A fixed size, empty block
	TFixed(width : double, height : double) -> Tropic;

	// TBorder with equal borders on all 4 sides
	TBorder4(border : double, t : Tropic) -> Tropic;

	// A block of given size
	TSized(size : Transform<WidthHeight>) -> Tropic;
	// A block of given size with constant height or width
	TSizedWidth(width : Transform<double>, height : double) -> Tropic;
	TSizedHeight(width : double, height : Transform<double>) -> Tropic;
	TSizedWidthHeight(width : Transform<double>, height : Transform<double>) -> Tropic;

	TSizedX(width : Transform<double>) -> Tropic;
	TSizedY(height : Transform<double>) -> Tropic;

	// Bunch of helpers to inspect sizes. Consider using TInspect also.

	TAttachBox(t : Tropic, box : DynamicBehaviour<WidthHeight>) -> Tropic;
	TAttachWidth(t : Tropic, width : DynamicBehaviour<double>) -> Tropic;
	TAttachHeight(t : Tropic, height : DynamicBehaviour<double>) -> Tropic;
	TAttachWidthHeight(t : Tropic, width : DynamicBehaviour<double>, height : DynamicBehaviour<double>) -> Tropic;

	TAttachAvailable(t : Tropic, box : DynamicBehaviour<WidthHeight>) -> Tropic;
	TAttachAvailableWidth(t : Tropic, width : DynamicBehaviour<double>) -> Tropic;
	TAttachAvailableHeight(t : Tropic, height : DynamicBehaviour<double>) -> Tropic;
	TAttachAvailableWidthHeight(t : Tropic, width : DynamicBehaviour<double>, height : DynamicBehaviour<double>) -> Tropic;

	// Inspects t, draws content
	TAttachBox2(t : Tropic, box : DynamicBehaviour<WidthHeight>, content : Tropic) -> Tropic;
	TAttachWidth2(t : Tropic, width : DynamicBehaviour<double>, content : Tropic) -> Tropic;
	TAttachHeight2(t : Tropic, height : DynamicBehaviour<double>, content : Tropic) -> Tropic;

	// Special cases to inspect
	TAttachMinWidth(t : Tropic, minWidth : DynamicBehaviour<double>) -> Tropic;
	TAttachBoxThrottle(t : Tropic, box : DynamicBehaviour<WidthHeight>, maxDelta : int) -> Tropic;
	TAttachHeightTrigger(t : Tropic, height : DynamicBehaviour<double>, trigger : Transform<bool>) -> Tropic;

	TThrottleMetrics(t : Tropic, maxDelta : int) -> Tropic;

	// A rectangle that expands to the given size
	TRectangle(style : [TGraphicsStyle], size : Tropic) -> Tropic;

	TCircle(radius : double, style : [TGraphicsStyle]) -> Tropic;

	TGroup(c : [Tropic]) -> Tropic;
	TCols(c : [Tropic]) -> Tropic;
	TBaselineCols(c : [Tropic]) -> Tropic;
	TBaselineLines(c : [Tropic]) -> Tropic;
	TLines(c : [Tropic]) -> Tropic;
	TGrid(c : [[Tropic]]) -> Tropic;

	// Arabic(RTL) versions. T*Dir are intended to use into Material. Generally, T*A versions are preferable.
	TColsDir(t : [Tropic], isRTL : bool) -> Tropic;
	TCols2Dir(t1 : Tropic, t2 : Tropic, isRTL : bool) -> Tropic;
	TColsA(t : [Tropic]) -> Tropic;
	TCols2A(t1 : Tropic, t2 : Tropic) -> Tropic;

	TBaselineColsDir(t : [Tropic], isRTL : bool) -> Tropic;
	TBaselineCols2Dir(t1 : Tropic, t2 : Tropic, isRTL : bool) -> Tropic;
	TBaselineColsA(t : [Tropic]) -> Tropic;
	TBaselineCols2A(t1 : Tropic, t2 : Tropic) -> Tropic;

	TLinesDir(arr : [Tropic], isRTL : bool) -> Tropic;
	TLines2Dir(t1 : Tropic, t2 : Tropic, isRTL : bool) -> Tropic;
	TLinesA(arr : [Tropic]) -> Tropic;
	TLines2A(t1 : Tropic, t2 : Tropic) -> Tropic;
	TBaselineLinesDir(arr : [Tropic], isRTL : bool) -> Tropic;
	TBaselineLinesA(t : [Tropic]) -> Tropic;
	TBaselineLines2A(t1 : Tropic, t2 : Tropic) -> Tropic;

	TBorderA(start : double, top : double, end : double, bottom : double, t : Tropic) -> Tropic;
	TBorderDir(start : double, top : double, end : double, bottom : double, t : Tropic, isRTL : bool) -> Tropic;
	TPadA(x : double, y : double, t : Tropic) -> Tropic;
	TPadDir(x : double, y : double, t : Tropic, isRTL : bool) -> Tropic;

	// TGroup with zero metrics
	// Useful inside complicated components with lots of layers, metrics of which aren't used
	TGroupWithoutMetrics(g : [Tropic]) -> Tropic;
	TGroup2WithoutMetrics(g1 : Tropic, g2 : Tropic) -> Tropic {TGroupWithoutMetrics([g1, g2])};
	// TGroup that has metrics of the first tropic
	TGroupSameMetrics(g : [Tropic]) -> Tropic;
	TGroup2SameMetrics(g1 : Tropic, g2 : Tropic) -> Tropic {TGroupSameMetrics([g1, g2])};

	// Common helpers of centering a number of tropics
	TColsXCenter(cols : [Tropic]) -> Tropic;
	TColsYCenter(cols : [Tropic]) -> Tropic;
	TBaselineColsXCenter(cols : [Tropic]) -> Tropic;
	TBaselineColsYCenter(cols : [Tropic]) -> Tropic;
	TColsYCenterA(cols : [Tropic]) -> Tropic;
	TBaselineColsYCenterA(cols : [Tropic]) -> Tropic;
	TLinesXCenter(lines : [Tropic]) -> Tropic;
	TLinesYCenter(lines : [Tropic]) -> Tropic;
	TBaselineLinesXCenter(lines : [Tropic]) -> Tropic;
	TBaselineLinesYCenter(lines : [Tropic]) -> Tropic;

	// Common helpers for creating groups of elements with the same available width or height
	TColsSameWidth(cols : [Tropic]) -> Tropic;
	TColsSameHeight(cols : [Tropic]) -> Tropic;
	TLinesSameWidth(lines : [Tropic]) -> Tropic;
	TLinesSameHeight(lines : [Tropic]) -> Tropic;

	// Move the box x, y pixels, changing the size
	TPad(x : double, y : double, t : Tropic) -> Tropic;

	// Add a rounded frame behind the given box
	TFrame(margin : double, radius : double, style : [TGraphicsStyle], box : Tropic) -> Tropic;
	TFrameT(margin : Transform<double>, radius : Transform<double>, style : Transform<[TGraphicsStyle]>, box : Tropic) -> Tropic;
	TFrameCustom(l : double, tl : double, tlRounded : bool, t : double, tr : double, trRounded : bool, r : double,
		br : double, brRounded : bool, b : double, bl : double, blRounded : bool, style : [TGraphicsStyle], box : Tropic) -> Tropic;

	// Round rectangle corners to maximum possible radius
	TRoundedFull(style : [TGraphicsStyle], size : Tropic) -> Tropic;
	TRounded4(radius : double, style : [TGraphicsStyle], size : Tropic) -> Tropic;

	// Resizes the form to fill the target metrics
	TZoom(content : Tropic, container : Tropic, keepAspect : bool) -> Tropic;

	// Resizes the form to fill the target metrics croping borders that don't fit, always keeps aspect ratio.
	TZoomToFill(content : Tropic, container : Tropic, crop : bool) -> Tropic;

	TZoomOnOverflow(content : Tropic, container : Tropic, keepAspect : bool) -> Tropic;

	// Horizontal centering
	TCenterX(b : Tropic) -> Tropic;
	// Horizontal centering inside the box
	TCenterXIn(t : Tropic, box : Tropic) -> Tropic;

	// Vertical centering
	TCenterY(b : Tropic) -> Tropic;
	// Vertical centering inside the box
	TCenterYIn(t : Tropic, box : Tropic) -> Tropic;

	// Center in both directions
	TCenter(b : Tropic) -> Tropic;
	// Center inside the given box
	TCenterIn(b : Tropic, frame : Tropic) -> Tropic;
	TCenterInFixSize(b : Tropic, frame : Tropic) -> Tropic;
	// Center and scale with variable fill percentage, use 1.0/3.0 for centering
	TCenterScale(tropic : Tropic, xscale : double, yscale: double) -> Tropic;

	// Grows in both direction
	TFillXY() -> Tropic;

	// Defines a filler which grows from 0,0 up to the maximum size, without preserving aspect ratio
	TFillMax(maxWidth : double, maxHeight : double) -> Tropic;
	TFillMaxWY(maxWidth : double) -> Tropic;
	TFillMaxHX(maxHeight : double) -> Tropic;

	TFillMin(minWidth : double, minHeight : double) -> Tropic;

	// Define a maximum expanding fill, and a given height/width
	TFillXH(height : double) -> Tropic;
	TFillXW(minWidth : double) -> Tropic;
	TFillWY(width : double) -> Tropic;
	TFillYH(minHeight : double) -> Tropic;
	TFillXHT(height : Transform<double>) -> Tropic;
	TFillXWT(minWidth : Transform<double>) -> Tropic;
	TFillWYT(width : Transform<double>) -> Tropic;
	TFillYHT(minHeight : Transform<double>) -> Tropic;

	// Define an expanding rectangle from minimum size to maximum size, without preserving aspect ratios in between.
	TFillXYXY(minWidth : double, minHeight : double, maxWidth : double, maxHeight : double) -> Tropic;

	// Crunch the tropic down to just the height. Notice if it has any interactivity, those are still active.
	THeight(tropic : Tropic) -> Tropic;
	// Crunch the tropic flat to just the width. Notice if it has any interactivity, those are still active.
	TWidth(tropic : Tropic) -> Tropic;

	// Override the size of this given tropic to the child
	TFixSize(tropic : Tropic, size : Tropic) -> Tropic;

	// Similar to TFormIn, but gets truthful wh available
	TFormWH(form : Form, wh : WidthHeight) -> Tropic;

	// A lazy version of TIf. Notice that TIf allows significant optimizations, so normally, that is the
	// right choice.
	TIfLazy(value : Transform<bool>, f : (bool) -> Tropic) -> Tropic;

	// Normal interface to TSelect
	TSelect(value : Transform<?>, fn : (?) -> Tropic) -> Tropic;
	TSelect2(v1 : Transform<?>, v2 : Transform<??>, fn : (?, ??) -> Tropic) -> Tropic;
	TSelect3(v1 : Transform<?>, v2 : Transform<??>, v3 : Transform<???>, fn : (?, ??, ???) -> Tropic) -> Tropic;
	TSelect4(v1 : Transform<?>, v2 : Transform<??>, v3 : Transform<???>, v4 : Transform<????>, fn : (?, ??, ???, ????) -> Tropic) -> Tropic;

	TMutableMaybe(v : Transform<Maybe<Tropic>>) -> Tropic;
	TSelectMaybe(v : Transform<Maybe<?>>, fn : (?) -> Tropic) -> Tropic;

	// TSelect supporting fusion, which can help with managing disposing
	TFSelect(value : Transform<?>, fn : FFn<?, Tropic>) -> Tropic;

	// Shorthand to define a bunch of named tropics
	TLetMany(items : [Pair<string, Tropic>], scope : Tropic) -> Tropic;

	// Rotate 90 degrees, including the sizes
	TRotate90(tropic : Tropic) -> Tropic;
	// Rotate 90 degrees counter-clockwise, including the sizes
	TRotate90Left(tropic : Tropic) -> Tropic;
	// Rotate 180 degrees and translate by size
	TRotate180(enabled : Transform<bool>, size : Tropic) -> (Tropic) -> Tropic;

	// The tropic is actually destroyed/reconstructed when 'show' becomes false/true, in contrast
	// to TVisible. This is an exact alias to the common TIf(show, tropic, TEmpty) construct.
	// See TVisible for an optimized version that only hides the tropic.
	TShow : (show : Transform<bool>, tropic : Tropic) -> Tropic;
	// The tropic is destroyed/reconstructed when 'show' becomes false/true but tr fn called only once
	// and only when show becomes true
	TShowLazy(show : Transform<bool>, tr : () -> Tropic) -> Tropic;
	// Calls content function only on first condition true value
	// Hides content if condition is false
	TRenderOnce(condition : Transform<bool>, content : () -> Tropic) -> Tropic;
	// Similar to TShowLazy
	// Constructs tr when show is true and just hides it when show is false
	// If show is false initially tr function isn't called until show is true
	TVisibleLazy(show : Transform<bool>, tr : () -> Tropic) -> Tropic;

	// Crops only in X dimension
	TCropSizeX : (content : Tropic, width : Tropic) -> Tropic;
	// Crops only in Y dimension
	TCropSizeY : (content : Tropic, height : Tropic) -> Tropic;

	// ---
	// TScrollable - DEPRECATED, use TScroll
	// ---
	// If content is smaller than maxbox, the content size wins. The content gets the fill size from maxbox
	// [--Explain--] Could we remove this, as we already have tscroll.flow? Or probably just mark this as DEPRECATED or something like that
	TScrollable(content : Tropic, maxbox : Tropic, style : ScrollableStyle, state : [TScrollableState]) -> Tropic;
		TScrollableState ::= TScrollRect, TScrollOffset, TAnimate, TScrollInspect, TStickToEdge;
			// If you need to control the area
			TScrollRect(x : DynamicBehaviour<double>, y : DynamicBehaviour<double>, width : DynamicBehaviour<double>, height : DynamicBehaviour<double>);
			// If you need to control the position
			TScrollOffset(t : Behaviour<Tropic>);
			// If scrolling should animate.
			TAnimate(tension : double, friction : double);
			// explicitely inspect the size of the content to make sure scroll bars are visible when both TScrollable and its content form rely on TFillXY(). Inspired by case 38798.
			TScrollInspect();
			// pushes the scrollbars to egdes of the screen
			TStickToEdge();

	// TScrollable with extra margins for scroll bars at the right and bottom
	TScrollableWithBars(content : Tropic, maxbox : Tropic, style : ScrollableStyle, state : [TScrollableState]) -> Tropic;

	//Another approach to make scrollable with bars, but now the space for the scrollbars isn't reserved all the time:
	//they appear only when needed. Also, scrollbars drawn by this function are always visible on the screen
	TScrollableEdged(content : Tropic, maxbox : Tropic,  style : ScrollableStyle, state : [TScrollableState], background : Maybe<(Tropic) -> Tropic>,
		foreground : Maybe<(Tropic) -> Tropic>) -> Tropic;

	// Converts TAcc to Tropic with empty form and same size
	// Doesn't dispose TAcc disposers
	TAcc2Size(acc : TAcc) -> Tropic;

	// Copies size of content to copyFn, copyFn result has no effect on overall metrics
	// If above is true result of copyFn is placed on top of content
	// Useful when you need to place TInteractive above or below another one
	TCopySize(content : Tropic, copyFn : (size : Tropic) -> Tropic, above : bool) -> Tropic;
	// Similar to TCopySize, only resulting tropic has metrics of copyFn
	// copyFn has two parameters: size of the content, and content itself
	TCopySize2(content : Tropic, copyFn : (size : Tropic, content : Tropic) -> Tropic) -> Tropic;

	// Set tropic baseline from top of it
	TBaseline(baseline : Transform<double>, content : Tropic) -> Tropic;

	// Handling long tapping
	TLongTouch(duration : int, fn : () -> void, handle : bool, tropic : Tropic) -> Tropic;

	// Simplified version of TransformTAcc
	TransformTAcc2(fn : ((Tropic) -> TAcc) -> TAcc) -> Tropic;

	// without Fill doesn't work in flash
	// with Fill doesn't work on  Windows Phone (text input loses focus on touch up)
	interactiveRectangleStyle : [GraphicsStyle] = if (csharp) [FillOpacity(0.0)] else [FillOpacity(0.0), Fill(0)];

	TProportionGrid(c : [[Pair<Transform<Factor>, Tropic>]]) -> Tropic;
	TProportionLines(c : [Pair<Transform<double>, Tropic>]) -> Tropic;
	TProportionCols(c : [Pair<Transform<double>, Tropic>]) -> Tropic;
	TProportionBaselineCols(c : [Pair<Transform<double>, Tropic>]) -> Tropic;
	TProportionColsA(c : [Pair<Transform<double>, Tropic>], isRTL : bool) -> Tropic;

	// Helpers to set available for only width or only height
	TAvailableWidth(tr : Tropic, available : Transform<double>) -> Tropic;
	TAvailableHeight(tr : Tropic, available : Transform<double>) -> Tropic;
	TAvailableWidthHeight(tr : Tropic, availableW : Transform<double>, availableH : Transform<double>) -> Tropic;

	TCropWidth(tr : Tropic, w : Transform<double>) -> Tropic;
	TCropHeight(tr : Tropic, h : Transform<double>) -> Tropic;

	TAlignHorizontal(align : CommonAlignment) -> (Tropic) -> Tropic;
	TAlignHorizontalDir(align : CommonAlignment, isRTL : bool) -> (Tropic) -> Tropic;
	TAlignStart(t : Tropic) -> Tropic; // Align left if LTR, align right if RTL
	TAlignStartDir(t : Tropic, isRTL : bool) -> Tropic;
	TAlignEnd(t : Tropic) -> Tropic;   // Align right if LTR, align left if RTL
	TAlignEndDir(t : Tropic, isRTL : bool) -> Tropic;
	TAlignLeft(t : Tropic) -> Tropic;
	TAlignTop(t : Tropic) -> Tropic;
	TAlignRight(t : Tropic) -> Tropic;
	TAlignBottom(t : Tropic) -> Tropic;

	TAlignTopLeft(t : Tropic) -> Tropic;
	TAlignTopCenter(t : Tropic) -> Tropic;
	TAlignTopRight(t : Tropic) -> Tropic;
	TAlignCenterRight(t : Tropic) -> Tropic;
	TAlignBottomRight(t : Tropic) -> Tropic;
	TAlignBottomCenter(t : Tropic) -> Tropic;
	TAlignBottomLeft(t : Tropic) -> Tropic;
	TAlignCenterLeft(t : Tropic) -> Tropic;

	TBorderTop(border : double) -> (Tropic) -> Tropic;
	TBorderBottom(border : double) -> (Tropic) -> Tropic;
	TBorderLeft(border : double) -> (Tropic) -> Tropic;
	TBorderRight(border : double) -> (Tropic) -> Tropic;

	TBorderTopBottom(border : double) -> (Tropic) -> Tropic;
	TBorderLeftRight(border : double) -> (Tropic) -> Tropic;

	// Dynamic version of TBorder
	TBorderT(left : Transform<double>, top : Transform<double>, right : Transform<double>, bottom : Transform<double>, t : Tropic) -> Tropic;
	TBorderTDir(left : Transform<double>, top : Transform<double>, right : Transform<double>, bottom : Transform<double>, t : Tropic, isRTL : bool) -> Tropic;

	TDecorator(tr : Tropic, decorators : [Pair<Transform<bool>, (Transform<WidthHeight>) -> Tropic>], above : bool) -> Tropic;
	// Helper for dynamic text
	TDynamicText(text : Transform<string>, style : [TParagraphStyle]) -> Tropic;

	THTMLText(text : string, style : [TCharacterStyle]) -> Tropic;
	THTMLDynamicText(text : Transform<string>, style : [TParagraphStyle]) -> Tropic;

	// TDebug that shows metrics on top of the tropic
	TDebugMetrics(c : int, tr : Tropic) -> Tropic;
	TDebugPositionScale(c : int, tr : Tropic) -> Tropic;

	TDebugRed(t : Tropic) -> Tropic { TDebug(red, t); };
	TDebugGreen(t : Tropic) -> Tropic { TDebug(green, t); };
	TDebugBlue(t : Tropic) -> Tropic { TDebug(blue, t); };
	TDebugPurple(t : Tropic) -> Tropic { TDebug(purple, t); };

	TDebugMetricsRed(t : Tropic) -> Tropic { TDebugMetrics(red, t); };
	TDebugMetricsGreen(t : Tropic) -> Tropic { TDebugMetrics(green, t); };
	TDebugMetricsBlue(t : Tropic) -> Tropic { TDebugMetrics(blue, t); };
	TDebugMetricsPurple(t : Tropic) -> Tropic { TDebugMetrics(purple, t); };

	TDebugConstruct(tag : string, tr : Tropic) -> Tropic;

	TDebugInteractive(tr : Tropic) -> Tropic;

	TOnConstruct(fn : () -> void) -> (Tropic) -> Tropic;

	TEvenGrid(content : [[Tropic]]) -> Tropic;

	TConstructRenderable(constructors : [() -> () -> void], content : Tropic) -> Tropic;

	wh2Tropic(wh : WidthHeight) -> Tropic;

	// Zoom tropic if its metrics are bigger than maxWH
	TZoomMax(tr : Tropic, maxWH : Transform<WidthHeight>) -> Tropic;
	// Zoom tropic if its width is bigger than maxWidth
	TZoomMaxWidth(tr : Tropic, maxWidth : Transform<double>) -> Tropic;
	// Zoom tropic if its height is bigger than maxHeight
	TZoomMaxHeight(tr : Tropic, maxHeight : Transform<double>) -> Tropic;

	// Helpers to make Tropic not transparent for events
	disableMouseWheelBelow(content : Tropic) -> Tropic;
	disableInteractivesBelow(content : Tropic) -> Tropic;

	// Helper to create event blocker layer above element
	blockInteractives(content : Tropic) -> Tropic;

	// Helpers to make checkered graphics
	TCheckeredRectangle(style1 : [TGraphicsStyle], style2 : [TGraphicsStyle], content : Tropic) -> Tropic;
	TCheckeredRounded(nw : double, ne : double, lw : double, le : double, style1 : [TGraphicsStyle],
		style2 : [TGraphicsStyle], content : Tropic) -> Tropic;

	TMouseWheelInteractive(manager : TManager, content : Tropic, deltaX : (double) -> bool, deltaY : (double) -> bool) -> Tropic;

	T3DStage(scene : F3DObject, camera : F3DObject, size : Tropic, style : [F3DStageStyle]) -> Tropic;

	THTMLStage(wh : Transform<WidthHeight>, constructor : (stage : native) -> () -> void) -> Tropic;

	// Helper to move already rendered clip from one spot to another
	// Automatically dettaches and reattaches to original clip if tropic passed to 'fn' is rendered anywhere
	TMoveClip(t : Tropic, fn : (Tropic) -> void) -> Tropic;

	// Draws content with 'canvas' renderer
	// Works only in js with 'html' renderer, for other targets identical to regular clip
	// WARNING: Doesn't support native widgets making it applicable only to groups of graphical objects
	TCanvas(content : Tropic) -> Tropic;


	loadTPdfDocument(url : string, onLoad : (TPdfDocument) -> void, style : [TPdfDocumentStyle]) -> void;

	TPdfDocumentStyle ::= OnError;

	TPdfDocument(
		pageCount : int,
		getPageView : (page : Transform<int>) -> Tropic,
	);

	// TShow that doesn't shrink in size after content is hidden
	// Has empty size initially if content is hidden
	TShowKeepMetrics(show : Transform<bool>, content : Tropic) -> Tropic;

	// Shows fullSizeContent only if available space is greater than minimum size required to show it,
	// Otherwise shows reducedSizeContent
	TIfFits(fullSizeContent : Tropic, reducedSizeContent : Tropic) -> Tropic;
	TIfFitsWidth(fullSizeContent : Tropic, reducedSizeContent : Tropic) -> Tropic;
	TIfFitsWidthDelay(fullSizeContent : Tropic, reducedSizeContent : Tropic, delay : int) -> Tropic;
	TIfFitsHeight(fullSizeContent : Tropic, reducedSizeContent : Tropic) -> Tropic;

	// Shows content only if available space is greater than minimum size required to show it
	TShowIfFits(content : Tropic) -> Tropic;
	TShowIfFitsWidth(content : Tropic) -> Tropic;
	TShowIfFitsHeight(content : Tropic) -> Tropic;

	// Detect is tropic inside viewbox
	TRenderable(renderable : DynamicBehaviour<bool>, t : Tropic) -> Tropic;

	// Content displayed in browser print dialog
	TPrintTarget(t : Tropic) -> Tropic;
	// Similar to TPrintTarget, only every element is printed on different page
	TPrintPages(t : [Tropic]) -> Tropic;
	// By default TPrintPages uses web view size as available space for printing
	// TPrintPageSize lets to redefine this size with any other
	TPrintPageSize : DynamicBehaviour<Maybe<WidthHeight>> = make(None());
	// Change content when printing
	TIfPrint(then : Tropic, elset : Tropic) -> Tropic;

	// JS HTML Renderer: Extract rendered static html from the clip
	// Use wrapFlowHTML to wrap resulting html string with root tags, flow stylesheet and Roboto webfonts
	TExtractHTML(t : Tropic, setfn : (fn : () -> string) -> void) -> Tropic;
}

TFixed(width : double, height : double) -> Tropic {
	if (width == 0.0 && height == 0.0) TEmpty()
	else TBorder(width, height, 0.0, 0.0, TEmpty())
}

TBorder4(border : double, t : Tropic) -> Tropic {
	TBorder(border, border, border, border, t);
}

TSized(size : Transform<WidthHeight>) -> Tropic {
	TSizedWidthHeight(fwidth(size), fheight(size))
}

TSizedWidth(width : Transform<double>, height : double) -> Tropic {
	TSizedWidthHeight(width, const(height))
}

TSizedHeight(width : double, height : Transform<double>) -> Tropic {
	TSizedWidthHeight(const(width), height)
}

TSizedWidthHeight(width : Transform<double>, height : Transform<double>) -> Tropic {
	TBorderT(width, height, zero, zero, TEmpty())
}

TSizedX(width : Transform<double>) -> Tropic {
	TSizedWidth(width, 0.0);
}

TSizedY(height : Transform<double>) -> Tropic {
	TSizedHeight(0.0, height);
}

TRectangle(style : [TGraphicsStyle], size : Tropic) -> Tropic {
	TRounded(0., 0., 0., 0., style, size)
}

TCircle(radius : double, style : [TGraphicsStyle]) -> Tropic {
	TGraphics([GCircle(radius, radius, radius)], style);
}

TGroup(c : [Tropic]) -> Tropic {
	len = length(c);
	if (len == 0) TEmpty()
	else if (len == 1) c[0]
	else if (len == 2) TGroup2(c[0], c[1])
	else TGroup2(TGroup(subrange(c, 0, len / 2)), TGroup(subrange(c, len / 2, len - (len / 2))));
}

TGroupWithoutMetrics(c : [Tropic]) -> Tropic {
	TransformTAcc2(\tac -> {
			r = map(c, tac);

			TAcc(
				FGroup(map(r, \r0 -> r0.form), true),
				TFormMetrics(zero, zero, zero),
				zero,
				zero,
				zero,
				zero,
				zero,
				zero,
				const(false),
				true,
				true,
				map(r, \r0 -> r0.disposers) |> concatA
			)
		}
	)
}

TGroupSameMetrics(c : [Tropic]) -> Tropic {
	if (length(c) > 0)
		TransformTAcc2(\tac -> {
				r = map(c, tac);

				TAcc(
					FGroup(map(r, \r0 -> r0.form), true),
					r[0].metrics,
					r[0].minWidth,
					r[0].minHeight,
					r[0].maxWidth,
					r[0].maxHeight,
					r[0].xFillers,
					r[0].yFillers,
					r[0].addFillers,
					r[0].xConstant,
					r[0].yConstant,
					map(r, \r0 -> r0.disposers) |> concatA
				)
			}
		)
	else
		TEmpty();
}

TCols(c : [Tropic]) -> Tropic {
	len = length(c);
	if (len == 0) TEmpty()
	else if (len == 1) c[0]
	else if (len == 2) TCols2(c[0], c[1])
	else TCols2(TCols(subrange(c, 0, len / 2)), TCols(subrange(c, len / 2, len - (len / 2))));
}

TBaselineCols(c : [Tropic]) -> Tropic {
	len = length(c);
	if (len == 0) TEmpty()
	else if (len == 1) c[0]
	else if (len == 2) TBaselineCols2(c[0], c[1])
	else TBaselineCols2(TBaselineCols(subrange(c, 0, len / 2)), TBaselineCols(subrange(c, len / 2, len - (len / 2))));
}

TBaselineLines(c : [Tropic]) -> Tropic {
	len = length(c);
	if (len == 0) TEmpty()
	else if (len == 1) c[0]
	else if (len == 2) TBaselineLines2(c[0], c[1])
	else TBaselineLines2(TBaselineLines(subrange(c, 0, len / 2)), TBaselineLines(subrange(c, len / 2, len - (len / 2))));
}

TLines(c : [Tropic]) -> Tropic {
	len = length(c);
	if (len == 0) TEmpty()
	else if (len == 1) c[0]
	else if (len == 2) TLines2(c[0], c[1])
	else TLines2(TLines(subrange(c, 0, len / 2)), TLines(subrange(c, len / 2, len - (len / 2))));
}

TGrid(c : [[Tropic]]) -> Tropic {
	if (c == []) TEmpty()
	else fold(tail(c), TCols(c[0]), \acc, row -> TLines2(acc, TCols(row)))
}

TColsDir(t : [Tropic], isRTL : bool) -> Tropic {
	TCols(if (isRTL) reverseA(t) else t)
}

TCols2Dir(t1 : Tropic, t2 : Tropic, isRTL : bool) -> Tropic {
	TColsDir([t1, t2], isRTL)
}

TColsA(t : [Tropic]) -> Tropic {
	TColsDir(t, getDefaultRtl())
}

TCols2A(t1 : Tropic, t2 : Tropic) -> Tropic {
	TCols2Dir(t1, t2, getDefaultRtl())
}

TBaselineColsDir(t : [Tropic], isRTL : bool) -> Tropic {
	TBaselineCols(if (isRTL) reverseA(t) else t)
}

TBaselineCols2Dir(t1 : Tropic, t2 : Tropic, isRTL : bool) -> Tropic {
	TBaselineColsDir([t1, t2], isRTL)
}

TBaselineColsA(t : [Tropic]) -> Tropic {
	TBaselineColsDir(t, getDefaultRtl())
}

TBaselineCols2A(t1 : Tropic, t2 : Tropic) -> Tropic {
	TBaselineCols2Dir(t1, t2, getDefaultRtl())
}

TBorderA(start : double, top : double, end : double, bottom : double, t : Tropic) -> Tropic {
	TBorderDir(start, top, end, bottom, t, getDefaultRtl())
}

TBorderDir(start : double, top : double, end : double, bottom : double, t : Tropic, isRTL : bool) -> Tropic {
	if (isRTL) TBorder(end, top, start, bottom, t) else TBorder(start, top, end, bottom, t)
}

// Helper for supporting RTL in TLines variations
linesToLinesA(ls : [Tropic], isRTL : bool) -> [Tropic] {
	if (isRTL) linesToLinesRTL(ls) else ls
}

linesToLinesRTL(ls : [Tropic]) -> [Tropic] {
	widths = map(ls, \l -> make(0.0));
	maxWidth = fmaxA(widths, 0.0);

	mapi(
		ls,
		\i, l -> TransformTAcc(\t2a, pi, s, mo -> {
			x = fsubtract(maxWidth, widths[i]);

			newParentInfo =
				TParentInfo(pi with
					transformMatrix = fworldtransform(pi.transformMatrix, fx2transform(x))
				);

			b1 = t2a(l, newParentInfo, s, mo);
			form = FTranslate(x, const(0.0), b1.form);

			disp =
				arrayPush(
					b1.disposers,
					fconnect(b1.metrics.width, widths[i])
				);

			TAcc(b1 with form = form, disposers = disp)
		})
	);
}

TLinesDir(arr : [Tropic], isRTL : bool) -> Tropic {
	TLines(linesToLinesA(arr, isRTL))
}

TLines2Dir(t1 : Tropic, t2 : Tropic, isRTL : bool) -> Tropic {
	TLinesDir([t1, t2], isRTL)
}

TLinesA(arr : [Tropic]) -> Tropic {
	TLinesDir(arr, getDefaultRtl())
}

TLines2A(t1 : Tropic, t2 : Tropic) -> Tropic {
	TLines2Dir(t1, t2, getDefaultRtl())
}

TBaselineLinesDir(arr : [Tropic], isRTL : bool) -> Tropic {
	TBaselineLines(linesToLinesA(arr, isRTL))
}

TBaselineLines2Dir(t1 : Tropic, t2 : Tropic, isRTL : bool) -> Tropic {
	TBaselineLinesDir([t1, t2], isRTL)
}

TBaselineLinesA(arr : [Tropic]) -> Tropic {
	TBaselineLinesDir(arr, getDefaultRtl())
}

TBaselineLines2A(t1 : Tropic, t2 : Tropic) -> Tropic {
	TBaselineLines2Dir(t1, t2, getDefaultRtl())
}

TColsXCenter(cols : [Tropic]) -> Tropic {
	TSegmentCenter(cols, false, true, false)
}

TColsYCenter(cols : [Tropic]) -> Tropic {
	TSegmentCenter(cols, false, true, true)
}

TBaselineColsXCenter(cols : [Tropic]) -> Tropic {
	TSegmentCenter(cols, true, true, false)
}

TBaselineColsYCenter(cols : [Tropic]) -> Tropic {
	TSegmentCenter(cols, true, true, true)
}

TColsYCenterA(cols : [Tropic]) -> Tropic {
	sizes = generate(0, length(cols), \__ -> make(0.0));

	segmentsAttaches =
		mapi(cols, \i, segment ->
			TAttachHeight(segment, sizes[i])
		);

	TColsA(map(segmentsAttaches, \sa ->
		TCenterYIn(sa, TSizedHeight(0.0, fmaxA(sizes, 0.0)))
	));
}

TBaselineColsYCenterA(cols : [Tropic]) -> Tropic {
	sizes = generate(0, length(cols), \__ -> make(0.0));

	segmentsAttaches =
		mapi(cols, \i, segment ->
			TAttachHeight(segment, sizes[i])
		);

	TBaselineColsA(map(segmentsAttaches, \sa ->
		TCenterYIn(sa, TSizedHeight(0.0, fmaxA(sizes, 0.0)))
	));
}

TLinesXCenter(lines : [Tropic]) -> Tropic {
	TSegmentCenter(lines, false, false, false)
}

TLinesYCenter(lines : [Tropic]) -> Tropic {
	TSegmentCenter(lines, false, false, true)
}

TBaselineLinesXCenter(lines : [Tropic]) -> Tropic {
	TSegmentCenter(lines, true, false, false)
}

TBaselineLinesYCenter(lines : [Tropic]) -> Tropic {
	TSegmentCenter(lines, true, false, true)
}

TColsSameWidth(cols : [Tropic]) -> Tropic {
	TSegmentSameMetric(cols, true, false)
}

TColsSameHeight(cols : [Tropic]) -> Tropic {
	TSegmentSameMetric(cols, true, true)
}

TLinesSameWidth(lines : [Tropic]) -> Tropic {
	TSegmentSameMetric(lines, false, false)
}

TLinesSameHeight(lines : [Tropic]) -> Tropic {
	TSegmentSameMetric(lines, false, true)
}

// Only for internal use. Do not export
TSegmentCenter(segments : [Tropic], baseline : bool, cols : bool, vertical : bool) -> Tropic {
	sizes = generate(0, length(segments), \__ -> make(0.0));

	segmentsAttaches =
		mapi(segments, \i, segment ->
			if (vertical)
				TAttachHeight(segment, sizes[i])
			else
				TAttachWidth(segment, sizes[i])
		);

	(if (vertical)
		map(segmentsAttaches, \sa -> TCenterYIn(sa, TSizedHeight(0.0, fmaxA(sizes, 0.0))))
	else
		map(segmentsAttaches, \sa -> TCenterXIn(sa, TSizedWidth(fmaxA(sizes, 0.0), 0.0))))
	|> (
		if (cols) {
			if (baseline)
				TBaselineCols
			else
				TCols
		} else {
			if (baseline)
				TBaselineLines
			else
				TLines
		}
	)
}

// Only for internal use. Do not export
TSegmentSameMetric(segments : [Tropic], cols : bool, vertical : bool) -> Tropic {
	sizes = generate(0, length(segments), \__ -> make(0.0));

	segmentsAttaches =
		mapi(segments, \i, segment ->
			if (vertical)
				TAttachHeight(segment, sizes[i])
			else
				TAttachWidth(segment, sizes[i])
		);

	(if (vertical)
		map(segmentsAttaches, \sa -> TAvailable(sa, TFillXHT(fmaxA(sizes, 0.0))))
	else
		map(segmentsAttaches, \sa -> TAvailable(sa, TFillWYT(fmaxA(sizes, 0.0))))
	)
	|> if (cols) TCols else TLines
}

TPad(x : double, y : double, t : Tropic) -> Tropic {
	// TODO: Handle negative coordinates here
	TBorder(x, y, 0.0, 0.0, t)
}

TPadDir(x : double, y : double, t : Tropic, isRTL : bool) -> Tropic {
	if (isRTL) TBorder(0.0, y, x, 0.0, t)
	else TPad(x, y, t);
}

TPadA(x : double, y : double, t : Tropic) -> Tropic {
	TPadDir(x, y, t, getDefaultRtl())
}

TFrame(margin : double, radius : double, style : [TGraphicsStyle], box : Tropic) -> Tropic {
	borderedBox = TBorder(margin, margin, margin, margin, box);

	if (style != [])
		TransformTAcc2(\tac -> {
			b1 = borderedBox |> tac;

			TAcc(b1 with form =
				FGroup([
					FGraphics(
						fselect2(b1.metrics.width, b1.metrics.height, FLift2(\w, h ->
							if (equalDoubles(radius, 0.))
								[GRect(0.0, 0.0, w, h)]
							else if (equalDoubles(w, h) && equalDoubles(radius, w / 2.0))
								[GCircle(radius, radius, radius)]
							else
								[GRoundedRect(0.0, 0.0, w, h, radius)]
						)),
						const(tgraphicsStyle2graphicsStyle(style))
					),
					b1.form
				], false)
			)
		})
	else
		borderedBox
}

TFrameT(margin : Transform<double>, radius : Transform<double>, style : Transform<[TGraphicsStyle]>, box : Tropic) -> Tropic {
	borderedBox = TBorderT(margin, margin, margin, margin, box);

	if (isFConst(style) && length(fgetValue(style)) == 0)
		borderedBox
	else
		TransformTAcc2(\tac -> {
			b1 = borderedBox |> tac;

			gstyle = fselect(style, FLift(tgraphicsStyle2graphicsStyle));

			isconst = b1.xConstant && b1.yConstant;
			wd = if (isconst) const(fgetValue(b1.metrics.width)) else b1.metrics.width;
			hgt = if (isconst) const(fgetValue(b1.metrics.height)) else b1.metrics.height;

			TAcc(b1 with form =
				FGroup([
					FGraphics(
						fselect3(radius, wd, hgt, \r, w, h ->
							if (r == 0.)
								rectangle(0., 0., w, h)
							else
								perfectRoundedRect(w, h, r)
						),
						gstyle
					),
					b1.form
				], false)
			)
		})
}

TFrameCustom(l : double, tl : double, tlRounded : bool, t : double, tr : double, trRounded : bool, r : double,
	br : double, brRounded : bool, b : double, bl : double, blRounded : bool, style : [TGraphicsStyle], box : Tropic) -> Tropic {
	if (style != [])
		TransformTAcc2(\tac -> {
				b1 = TBorder(r, t, l, b, box) |> tac;

				gstyle = tgraphicsStyle2graphicsStyle(style);

				TAcc(b1 with form =
					FGroup([
						FGraphics(
							fselect2(b1.metrics.width, b1.metrics.height, FLift2(\w, h ->
								customRect(w, h, tl, tr, br, bl, tlRounded, trRounded, brRounded, blRounded)
							)),
							const(gstyle)
						),
						b1.form
					], false)
				)
			}
		)
	else if (r != 0. || t != 0. || l != 0. || b != 0.)
		TBorder(r, t, l, b, box)
	else
		box
}

TRoundedFull(style : [TGraphicsStyle], size : Tropic) -> Tropic {
	TransformTAcc(\tac, pi, ss, mo -> {
		b1 = tac(size, pi, ss, true);

		if (style != []) {
			gstyle = tgraphicsStyle2graphicsStyle(style);

			TAcc(b1 with form =
				FGroup([
					FGraphics(
						fselect2(b1.metrics.width, b1.metrics.height, FLift2(\w, h -> [GRoundedRect(0.0, 0.0, w, h, min(w, h) / 2.0)])),
						const(gstyle)
					),
					b1.form
				], false)
			)
		} else {
			b1;
		}
	})
}

TRounded4(radius : double, style : [TGraphicsStyle], size : Tropic) -> Tropic {
	TRounded(radius, radius, radius, radius, style, size);
}

TScrollable(content : Tropic, maxbox : Tropic, style : ScrollableStyle, state : [TScrollableState]) -> Tropic {
	TransformTAcc(\t2a, parent, sheet, metricsOnly -> {
		ba2 = t2a(maxbox, parent, sheet, true);
		if (metricsOnly) ba2
		else {
			stickToEdge = contains(state, TStickToEdge());

			showHorizontal = make(false);
			showVertical = make(false);

			addedMarginX = style.borderGap + if (stickToEdge) getVScrollWidth(style) else 0.0;
			addedMarginY = style.borderGap + if (stickToEdge) getHScrollHeight(style) else 0.0;

			borderLeft = 9.9;
			constMargin = Point(borderLeft + addedMarginX, borderLeft + addedMarginY);

			w = fuse(ba2.metrics.width);
			h = fuse(ba2.metrics.height);

			realWidth = select2u(w.first, showVertical, \w2, show -> w2 - if (show) constMargin.x else 0.0);
			realHeight = select2u(h.first, showHorizontal, \h2, show -> h2 - if (show) constMargin.y else 0.0);

			wb = if (stickToEdge) realWidth.first else w.first;
			hb = if (stickToEdge) realHeight.first else h.first;

			scrollRect = extractStruct(state, TScrollRect(make(0.0), make(0.0), make(0.0), make(0.0)));

			ba1 =
				t2a(
					content,
					TParentInfo(
						wb,
						hb,
						parent.environment,
						fworldtransform(parent.transformMatrix, fpoint2transform(fpoint(scrollRect.x, scrollRect.y)))
					),
					sheet,
					metricsOnly
				);
			ba1form = Available(wb, hb, fform2form(ba1.form));

			width = fuse(ba1.metrics.width);
			height = fuse(ba1.metrics.height);
			//those subscriptions are monitoring if we need to display the scrollbars
			unsWidth = subscribe(width.first, \ww -> if(ww - getValue(w.first) >= 2.0) nextDistinct(showHorizontal, true) else nextDistinct(showHorizontal, false));
			unsWidth2 = subscribe(w.first, \ww -> if(getValue(width.first) - ww >= 2.0) nextDistinct(showHorizontal, true) else nextDistinct(showHorizontal, false));
			unsHeight = subscribe(height.first, \hh -> if(hh - getValue(h.first) >= 2.0) nextDistinct(showVertical, true) else nextDistinct(showVertical, false));
			unsHeight2 = subscribe(h.first, \hh -> if(getValue(height.first) - hh >= 2.0) nextDistinct(showVertical, true) else nextDistinct(showVertical, false));

			contentWH = select2u(width.first, height.first, \w1, h1 -> WidthHeight(w1, h1));

			sizeAdded = if(!stickToEdge) constMargin.x else 0.0;
			sizeFn = \dimension, vis -> dimension;

			scrollAnimate = extractStruct(state, TAnimate(0.0, 0.0));
			scrollAnimateTimer = makeDeltaTimer(30);
			springy = makeSpring(scrollAnimate.tension, scrollAnimate.friction, make(0.0), scrollAnimateTimer, nop);
			springyUns = if (scrollAnimate == TAnimate(0.0, 0.0)) connectDistinct(springy.goal, scrollRect.y)
			else connectDistinct(springy.position, scrollRect.y);
			springx = makeSpring(scrollAnimate.tension, scrollAnimate.friction, make(0.0), scrollAnimateTimer, nop);
			springxUns = if (scrollAnimate == TAnimate(0.0, 0.0)) connectDistinct(springx.goal, scrollRect.x)
			else connectDistinct(springx.position, scrollRect.x);

			offsetAccDisposers = ref [];
			offsetUns = subscribe(extractStruct(state, TScrollOffset(const(TEmpty()))).t, \offsetTropic -> {
				applyall(^offsetAccDisposers);
				offsetAcc = t2a(offsetTropic, parent, sheet, true);
				offsetAccDisposers := offsetAcc.disposers;

				offsetUpdate = \ -> {
					owidth = fgetValue(offsetAcc.metrics.width);
					oheight = fgetValue(offsetAcc.metrics.height);

					if (getValue(scrollRect.y) != oheight) {
						next(springy.position, getValue(scrollRect.y));
						next(springy.goal, oheight);
					}
					if (getValue(scrollRect.x) != owidth) {
						next(springx.position, getValue(scrollRect.x));
						next(springx.goal, owidth);
					}
				};

				if (isStaticForm(ba1form)) {
					offsetUpdate();
				} else {
					deferred(offsetUpdate);
				};
			});

			offsetDisposers = [
				offsetUns,
				springyUns,
				springxUns,
				\ -> applyall(concat([^(springx.dispose), ^(springy.dispose)], ^offsetAccDisposers))
			];

			// case 38798 - inspect real size of the content to make sure the scroll bars are visible when necessary
			inspectContentSize = contains(state, TScrollInspect());
			formToScroll = if (inspectContentSize) {
				realSize = makeWH();
				Size2(
					select2(contentWH.first, realSize, \s1, s2 -> WidthHeight(max(s1.width, s2.width), max(s1.height, s2.height))),
					Inspect([ISize(realSize)], ba1form)
				)
			} else {
				Size2(contentWH.first, ba1form)
			}

			stickToEdgeDisposers = [realHeight.second, realWidth.second, unsWidth, unsWidth2, unsHeight, unsHeight2];
			addBorderLeft = \f -> if (stickToEdge) Offset(borderLeft, 0.0, f) else f;
			addBorderTop = \f -> if (stickToEdge) Offset(0.0, borderLeft, f) else f;
			TAcc(
				doStyledScrollableCustom(scrollRect.x, scrollRect.y, wb, hb, formToScroll,
					style, true, true, false,
					\cForm, hBar, vBar -> if (mobile) {
						wh = makeWH();
						Group([
							Inspect([ISize(wh)], cForm),
							Available2(wh, Group([
								Align2(1.0, 0.0, Offset(constMargin.x, 0.0, vBar)),
								Align2(0.0, 1.0, Offset (0.0, constMargin.y, hBar))
							]))
						]);
					} else Grid([[cForm, vBar |> addBorderLeft], [hBar |> addBorderTop, Empty()]]),
					sizeFn, sizeFn, true, false
				) |> FMForm,
				TFormMetrics(
					wb,
					hb,
					ba2.metrics.baseline
				),
				ba2.minWidth,
				ba2.minHeight,
				ba2.maxWidth,
				ba2.maxHeight,
				ba2.xFillers,
				ba2.yFillers,
				ba2.addFillers,
				ba2.xConstant && isConst(wb),
				ba2.yConstant && isConst(hb),
				concatA([ba1.disposers, ba2.disposers, stickToEdgeDisposers, w.second, h.second, width.second, height.second, [contentWH.second], offsetDisposers])
			);
		}
	})
}

TScrollableWithBars(content : Tropic, maxbox : Tropic, style : ScrollableStyle, state : [TScrollableState]) -> Tropic {
	margin = 20.0 + style.borderGap;
	TBorder(0.0, 0.0, margin, margin, TScrollable(content, maxbox, style, state));
}

TScrollableEdged(content : Tropic, maxbox : Tropic,  style : ScrollableStyle, state : [TScrollableState], background : Maybe<(Tropic) -> Tropic>,
	foreground : Maybe<(Tropic) -> Tropic>) -> Tropic {
	state2 = concat(state, [TStickToEdge()]);
	TLet("scrollable",
		TScrollable(content, maxbox, style, state2),
		TGroup([
			eitherMap(background, \fn -> TGhost("scrollable") |> fn, TEmpty()),
			TDisplay("scrollable"),
			maxbox,
			eitherMap(foreground, \fn -> TGhost("scrollable") |> fn, TEmpty())
		])
	)
}

TCenterX(b : Tropic) -> Tropic {
	TTweak([TAlign(const(0.5), const(0.0))], b, TFillX())
}

TCenterY(b : Tropic) -> Tropic {
	TTweak([TAlign(const(0.0), const(0.5))], b, TFillY())
}

TCenterXIn(t : Tropic, box : Tropic) -> Tropic {
	TTweak([TAlign(const(0.5), const(0.0))], t, box)
}

TCenterYIn(t : Tropic, box : Tropic) -> Tropic {
	TTweak([TAlign(const(0.0), const(0.5))], t, box)
}

TCenter(b : Tropic) -> Tropic {
	TTweak([TAlign(const(0.5), const(0.5))], b, TFillXY())
}

TCenterIn(b : Tropic, frame : Tropic) -> Tropic {
	TTweak([TAlign(const(0.5), const(0.5))], b, frame)
}

TCenterInFixSize(content : Tropic, frame : Tropic) -> Tropic {
	TransformTAcc2(\t2a -> {
		c = content |> t2a;
		fr = frame |> t2a;

		TAcc(fr with
			form = FTranslate(
				fdivide(fsubtract(fr.metrics.width, c.metrics.width), const(2.0)),
				fdivide(fsubtract(fr.metrics.height, c.metrics.height), const(2.0)),
				c.form
			),
			disposers = concat(c.disposers, fr.disposers)
		)
	})
}

TZoom(content : Tropic, container : Tropic, keepAspect : bool) -> Tropic {
	TTweak([TFitZoom(keepAspect, false)], content, container);
}

TZoomToFill(content : Tropic, container : Tropic, crop : bool) -> Tropic {
	TTweak([TFillZoom(crop)], content, container);
}

TZoomOnOverflow(content : Tropic, container : Tropic, keepAspect : bool) -> Tropic {
	TCopySize(
		container,
		\tr ->
			TTweak([TFitZoom(keepAspect, false)], TGroup2(content, tr), tr),
		true
	);
}

TCenterScale(tropic : Tropic, xscale : double, yscale: double) -> Tropic {
	norm = \v -> forceRange(v, 0.0, 1.0);
	shift = \v -> (v - 1.0) / 2.0;
	fx = norm(xscale);
	fy = norm(yscale);
	TLet("wh", TFillXY(), TMinimumGroup2(
		TShift(
			TZoom(tropic, TScale(const(Factor(fx, fy)), TGhost("wh")), false),
			TScale(const(Factor(shift(fx), shift(fy))), TGhost("wh"))),
		TDisplay("wh")
	))
}

TFillXY() -> Tropic {
	TNative(\x, y -> {
		wd = fmax(x, zero);
		hgt = fmax(y, zero);

		TAcc(
			FEmpty(),
			TFormMetrics(wd, hgt, hgt),
			zero,
			zero,
			const(doubleMax),
			const(doubleMax),
			const(1.),
			const(1.),
			const(false),
			isFConst(x),
			isFConst(y),
			[]
		)
	})
}

TFillXH(height : double) -> Tropic {
	TFillXHT(const(height))
}

TFillXHT(hgt : Transform<double>) -> Tropic {
	TNative(\x, __ -> {
		wd = fmax(x, zero);

		TAcc(
			FEmpty(),
			TFormMetrics(wd, hgt, hgt),
			zero,
			hgt,
			const(doubleMax),
			hgt,
			const(1.),
			zero,
			const(false),
			isFConst(x),
			isFConst(hgt),
			[]
		)
	})
}

TFillXW(minWidth : double) -> Tropic {
	TFillXWT(const(minWidth))
}

TFillXWT(minWidth : Transform<double>) -> Tropic {
	TNative(\x, __ -> {
		wd = fmax(fmax(minWidth, x), zero);
		hgt = zero;

		TAcc(
			FEmpty(),
			TFormMetrics(wd, hgt, hgt),
			minWidth,
			hgt,
			const(doubleMax),
			hgt,
			const(1.),
			zero,
			const(false),
			isFConst(x),
			true,
			[]
		)
	})
}

TFillWY(width : double) -> Tropic {
	TFillWYT(const(width))
}

TFillWYT(wd : Transform<double>) -> Tropic {
	TNative(\__, y -> {
		hgt = fmax(y, zero);

		TAcc(
			FEmpty(),
			TFormMetrics(wd, hgt, hgt),
			wd,
			zero,
			wd,
			const(doubleMax),
			zero,
			const(1.),
			const(false),
			isFConst(wd),
			isFConst(y),
			[]
		)
	})
}

TFillYH(minHeight : double) -> Tropic {
	TFillYHT(const(minHeight))
}

TFillYHT(minHeight : Transform<double>) -> Tropic {
	TNative(\x, y -> {
		wd = zero;
		hgt = fmax(fmax(minHeight, y), zero);

		TAcc(
			FEmpty(),
			TFormMetrics(wd, hgt, hgt),
			wd,
			minHeight,
			wd,
			const(doubleMax),
			zero,
			const(1.),
			const(false),
			true,
			isFConst(y),
			[]
		)
	})
}

TFillXYXY(minWidth : double, minHeight : double, maxWidth : double, maxHeight : double) -> Tropic {
	TNative(\x, y -> {
		miw = const(minWidth);
		mih = const(minHeight);
		maw = const(maxWidth);
		mah = const(maxHeight);

		mwc = maxWidth > minWidth;
		mhc = maxHeight > minHeight;

		wd = fmin(fmax(x, miw), maw);
		hgt = fmin(fmax(y, mih), mah);

		TAcc(
			FEmpty(),
			TFormMetrics(wd, hgt, hgt),
			miw,
			mih,
			maw,
			mah,
			const(b2d(mwc)),
			const(b2d(mhc)),
			const(false),
			!mwc || isFConst(x),
			!mhc || isFConst(y),
			[]
		)
	})
}

TFillMax(maxWidth : double, maxHeight : double) -> Tropic {
	TFillXYXY(0., 0., maxWidth, maxHeight)
}

TFillMaxWY(maxWidth : double) -> Tropic {
	TFillMax(maxWidth, doubleMax)
}

TFillMaxHX(maxHeight : double) -> Tropic {
	TFillMax(doubleMax, maxHeight)
}

TFillMin(minWidth : double, minHeight : double) -> Tropic {
	TFillXYXY(minWidth, minHeight, doubleMax, doubleMax)
}

THeight(tropic : Tropic) -> Tropic {
	TransformTAcc2(\tac -> {
		bf = TSizeOf(tropic) |> tac;

		TAcc(
			FEmpty(),
			TFormMetrics(
				zero,
				bf.metrics.height,
				bf.metrics.baseline
			),
			zero,
			bf.minHeight,
			zero,
			bf.maxHeight,
			zero,
			bf.yFillers,
			bf.addFillers,
			true,
			bf.yConstant,
			bf.disposers
		)
	})
}

TWidth(tropic : Tropic) -> Tropic {
	TransformTAcc2(\tac -> {
		bf = TSizeOf(tropic) |> tac;

		TAcc(
			FEmpty(),
			TFormMetrics(
				bf.metrics.width, zero, zero
			),
			bf.minWidth,
			zero,
			bf.maxWidth,
			zero,
			bf.xFillers,
			zero,
			bf.addFillers,
			bf.xConstant,
			true,
			bf.disposers
		)
	})
}

TIfLazy(value : Transform<bool>, f : (bool) -> Tropic) -> Tropic {
	tTrue : ref Maybe<Tropic> = ref None();
	tFalse : ref Maybe<Tropic> = ref None();

	TFSelect(value, FLift(\v -> {
		onlyOnce(if (v) tTrue else tFalse, \ -> f(v))
	}))
}

TFSelect(value : Transform<?>, fn : FFn<?, Tropic>) -> Tropic {
	t = fselect(value, fn);
	if (isFConst(t)) {
		// If we are constant, let's avoid the mutable altogether
		fgetValue(t)
	} else {
		TMutable(t);
	}
}

TSelect(value : Transform<?>, fn : (?) -> Tropic) -> Tropic {
	TFSelect(value, FLift(fn));
}

TSelect2(v1 : Transform<?>, v2 : Transform<??>, fn : (?, ??) -> Tropic) -> Tropic {
	t = fselect2(v1, v2, FLift2(fn));

	if (isFConst(t)) {
		// If we are constant, let's avoid the mutable altogether
		fgetValue(t)
	} else {
		TMutable(t);
	}
}

TSelect3(v1 : Transform<?>, v2 : Transform<??>, v3 : Transform<???>, fn : (?, ??, ???) -> Tropic) -> Tropic {
	t = fselect3(v1, v2, v3, fn);

	if (isFConst(t)) {
		// If we are constant, let's avoid the mutable altogether
		fgetValue(t)
	} else {
		TMutable(t);
	}
}

TSelect4(v1 : Transform<?>, v2 : Transform<??>, v3 : Transform<???>, v4 : Transform<????>, fn : (?, ??, ???, ????) -> Tropic) -> Tropic {
	t = fselect4(v1, v2, v3, v4, fn);

	if (isFConst(t)) {
		// If we are constant, let's avoid the mutable altogether
		fgetValue(t)
	} else {
		TMutable(t);
	}
}

TMutableMaybe(v : Transform<Maybe<Tropic>>) -> Tropic {
	if (isFConst(v)) {
		// If we are constant, let's avoid the mutable altogether
		either(fgetValue(v), TEmpty())
	} else {
		TMutable(feither(v, const(TEmpty())));
	}
}

TSelectMaybe(v : Transform<Maybe<?>>, fn : (?) -> Tropic) -> Tropic {
	if (isFConst(v)) {
		// If we are constant, let's avoid the mutable altogether
		eitherMap(fgetValue(v), fn, TEmpty())
	} else {
		TMutable(feitherMap(v, fn, const(TEmpty())));
	}
}

TFixSize(tropic : Tropic, size : Tropic) -> Tropic {
	TSize(size, tropic)
}

TFormWH(form : Form, wh : WidthHeight) -> Tropic {
	TForm(Available2(const(wh), form));
}

TLetMany(items : [Pair<string, Tropic>], scope : Tropic) -> Tropic {
	fold(items, scope, \s, i -> TLet(i.first, i.second, s))
}

TRotate90(tropic : Tropic) -> Tropic {
	TransformTAcc(\t2a, p, s, mo -> {
		bf = t2a(tropic, TParentInfo(p.maxY, p.maxX, p.environment, p.transformMatrix), s, mo);

		TAcc(
			FRotate(const(90.), bf.form)
			|> (\t -> FTranslate(bf.metrics.height, const(0.), t)),
			TFormMetrics(
				bf.metrics.height,
				bf.metrics.width,
				bf.metrics.width
			),
			bf.minHeight,
			bf.minWidth,
			bf.maxHeight,
			bf.maxWidth,
			bf.yFillers,
			bf.xFillers,
			bf.addFillers,
			bf.yConstant,
			bf.xConstant,
			bf.disposers
		)
	})
}

TRotate90Left(tropic : Tropic) -> Tropic {
	TransformTAcc(\t2a, p, s, mo -> {
		bf = t2a(tropic, TParentInfo(p.maxY, p.maxX, p.environment, p.transformMatrix), s, mo);

		TAcc(
			FRotate(const(-90.), bf.form)
			|> (\f -> FTranslate(zero, bf.metrics.width, f)),
			TFormMetrics(
				bf.metrics.height,
				bf.metrics.width,
				bf.metrics.width
			),
			bf.minHeight,
			bf.minWidth,
			bf.maxHeight,
			bf.maxWidth,
			bf.yFillers,
			bf.xFillers,
			bf.addFillers,
			bf.yConstant,
			bf.xConstant,
			bf.disposers
		)
	})
}

TRotate180(enabled : Transform<bool>, size : Tropic) -> (Tropic) -> Tropic {
	\t ->
		TShift(
			TRotate(fif(enabled, const(180.), const(0.)), t),
			TScale(const(Factor(-1., -1.)), TShow(enabled, size))
		)
}

TShow(show : Transform<bool>, tropic : Tropic) -> Tropic {
	TIf(show, tropic, TEmpty());
}

TShowLazy(show : Transform<bool>, tr : () -> Tropic) -> Tropic {
	t : ref Maybe<Tropic> = ref None();

	TFSelect(show, FLift(\s -> {
		if (s) onlyOnce(t, \ -> tr()) else TEmpty()
	}))
}

TRenderOnce(condition : Transform<bool>, content : () -> Tropic) -> Tropic {
	contRendered = ref false;

	TCopySize2(
		TShowLazy(
			fselect(condition,
				FLift(\c -> {
					if (^contRendered) {
						true
					} else if (c) {
						contRendered := true;
						true
					} else
						false
				})
			),
			content
		),
		\sz, t -> TFixSize(TVisible(condition, t), TIf(condition, sz, TEmpty()))
	)
}

TVisibleLazy(show : Transform<bool>, tr : () -> Tropic) -> Tropic {
	if (fgetValue(show)) {
		TVisible(show, tr());
	} else if (show == const(false)) {
		TEmpty();
	} else {
		content = make(TEmpty());

		TConstruct(
			[
				\ -> fwhen(show, \ -> next(content, TVisible(show, tr())))
			],
			TMutable(content)
		);
	}
}

TCropSizeX(content : Tropic, width : Tropic) -> Tropic {
	TransformTAcc(\t2a, parent, sheet, metricsOnly -> {
		c = t2a(content, parent, sheet, metricsOnly);
		b = t2a(width, parent, sheet, true);
		form =
			if (metricsOnly)
				FEmpty()
			else
				FCrop(
					zero,
					zero,
					b.metrics.width,
					c.metrics.height,
					c.form
				);
		TAcc(c with
			form = form,
			minWidth = b.minWidth,
			maxWidth = b.maxWidth,
			metrics = TFormMetrics(c.metrics with width = b.metrics.width),
			xFillers = b.xFillers
		)
	});
}

TCropSizeY(content : Tropic, height : Tropic) -> Tropic {
	TransformTAcc(\t2a, parent, sheet, metricsOnly -> {
		c = t2a(content, parent, sheet, metricsOnly);
		b = t2a(height, parent, sheet, true);
		form =
			if (metricsOnly)
				FEmpty()
			else
				FCrop(
					zero,
					zero,
					c.metrics.width,
					b.metrics.height,
					c.form
				);
		TAcc(c with
			form = form,
			minHeight = b.minHeight,
			maxHeight = b.maxHeight,
			metrics = TFormMetrics(c.metrics with height = b.metrics.height),
			yFillers = b.yFillers
		)
	});
}

TAcc2Size(acc : TAcc) -> Tropic {
	TNative(\__, __ -> {
		f =
			FMutable(
				fselect2(acc.metrics.width, acc.metrics.height, FLift2(\wd, hgt ->
					FRectangle(wd, hgt, interactiveRectangleStyle)
				))
			);

		TAcc(acc with form = f, disposers = [])
	})
}

TCopySize(content : Tropic, copyFn : (Tropic) -> Tropic, above : bool) -> Tropic {
	TransformTAcc2(\t2a -> {
		b1 = content |> t2a;
		tr = TAcc2Size(b1);
		b2 = copyFn(tr) |> t2a;

		TAcc(b1 with
			form = FGroup([
				b1.form,
				b2.form
			] |> (\f : [FForm] -> if (above) f else reverseA(f)),
			true),
			disposers = concat(b1.disposers, b2.disposers)
		)
	})
}

TCopySize2(content : Tropic, copyFn : (Tropic, Tropic) -> Tropic) -> Tropic {
	TransformTAcc(\t2a, pi, sheet, mo -> {
			innerParentInfo = make(pi);

			parentInfo =
				TParentInfo(
					pi.maxX,
					pi.maxY,
					makeTree(),
					fsubselect(innerParentInfo, FLift(\v -> v.transformMatrix)) // Handle properly view bounds in child
				);


			b1 = t2a(content, parentInfo, sheet, mo);
			tr = TAcc2Size(b1);

			t2a(
				copyFn(
					tr,
					TransformTAcc(\t2a2, pi2, sheet2, mo2 -> {
						next(innerParentInfo, pi2);

						b1;
					})
				),
				pi,
				sheet,
				mo
			)
		}
	)
}

TBaseline(baseline : Transform<double>, content : Tropic) -> Tropic {
	TransformTAcc2(\t2a -> {
			b1 = content |> t2a;

			TAcc(
				b1.form,
				TFormMetrics(
					b1.metrics.width,
					b1.metrics.height,
					baseline
				),
				b1.minWidth,
				b1.minHeight,
				b1.maxWidth,
				b1.maxHeight,
				b1.xFillers,
				b1.yFillers,
				b1.addFillers,
				b1.xConstant,
				b1.yConstant && isFConst(baseline),
				b1.disposers
			)
		}
	)
}

longTouchCounter = ref 0;

TLongTouch(duration : int, fn : () -> void, handle : bool, tropic : Tropic) -> Tropic {
	pressed = ref false;
	mdowni = ref MouseDownInfo(0.0, 0.0, \ -> false);

	TInteractive(
		[
			MouseDown2(\handled, mdi -> {
				if (mdi.inside()) {
					pressed := true;
					longTouchCounter := ^longTouchCounter + 1;
					longTouchId = ^longTouchCounter;
					timer(duration, \ -> {
						if(^longTouchCounter == longTouchId) {
							fn(); // TAP!
						}
					});
				}
				handle
			}),
			MouseUp2(\handled, mui -> {
				pressed := false;
				longTouchCounter := ^longTouchCounter + 1;
				handled // let it fall through
			}),
			MouseMove2(\handled, mmi -> {
				mi = mmi();
				mmovedx = mi.x - (^mdowni).x;
				mmovedy = mi.y - (^mdowni).y;

				sqdelta = mmovedx * mmovedx + mmovedy * mmovedy;
				if(^pressed && (!mi.inside || sqdelta > 200.0)){
					longTouchCounter := ^longTouchCounter + 1;
				}
				handled // let it fall through
			})
		],
		tropic
	)
}

TransformTAcc2(fn : ((Tropic) -> TAcc) -> TAcc) -> Tropic {
	TransformTAcc(\t2a, p, s, mo -> fn(\tr -> t2a(tr, p, s, mo)))
}

TAttachWidth2(t : Tropic, width : DynamicBehaviour<double>, content : Tropic) -> Tropic {
	TransformTAcc2(\t2a -> {
			b1 = t |> t2a;
			b2 = content |> t2a;

			TAcc(
				b2.form,
				TFormMetrics(
					b1.metrics.width,
					b2.metrics.height,
					b2.metrics.baseline
				),
				b1.minWidth,
				b2.minHeight,
				b1.maxWidth,
				b2.maxHeight,
				b1.xFillers,
				b2.yFillers,
				b1.addFillers,
				b1.xConstant,
				b2.yConstant,
				concat(arrayPush(b1.disposers, fconnect(b1.metrics.width, width)), b2.disposers)
			)
		}
	)
}

TAttachHeight2(t : Tropic, height : DynamicBehaviour<double>, content : Tropic) -> Tropic {
	TransformTAcc2(\t2a -> {
			b1 = t |> t2a;
			b2 = content |> t2a;

			TAcc(
				b2.form,
				TFormMetrics(
					b2.metrics.width,
					b1.metrics.height,
					b2.metrics.baseline
				),
				b2.minWidth,
				b1.minHeight,
				b2.maxWidth,
				b1.maxHeight,
				b2.xFillers,
				b1.yFillers,
				b1.addFillers,
				b2.xConstant,
				b1.yConstant,
				concat(arrayPush(b1.disposers, fconnect(b1.metrics.height, height)), b2.disposers)
			)
		}
	)
}

TAttachBox2(t : Tropic, box : DynamicBehaviour<WidthHeight>, content : Tropic) -> Tropic {
	TransformTAcc2(\t2a -> {
		b1 = t |> t2a;
		b2 = content |> t2a;

		disp =
			concat(arrayPush(b1.disposers, fconnect(fwidthheight(b1.metrics.width, b1.metrics.height), box)), b2.disposers);

		TAcc(b1 with form = b2.form, disposers = disp)
	})
}

TAttachBox(t : Tropic, box : DynamicBehaviour<WidthHeight>) -> Tropic {
	TInspect([ISize(box)], t)
}

TAttachWidth(t : Tropic, width : DynamicBehaviour<double>) -> Tropic {
	TInspect([Width(width)], t)
}

TAttachMinWidth(t : Tropic, minWidth : DynamicBehaviour<double>) -> Tropic {
	TInspect([IMinWidth(minWidth)], t)
}

TAttachHeight(t : Tropic, height : DynamicBehaviour<double>) -> Tropic {
	TInspect([Height(height)], t)
}

TAttachHeightTrigger(t : Tropic, height : DynamicBehaviour<double>, trigger : Transform<bool>) -> Tropic {
	TransformTAcc2(\t2a -> {
		b1 = t |> t2a;
		disp =
			arrayPush(b1.disposers, makeSubscribeTrigger(trigger, b1.metrics.height, \h -> nextDistinct(height, h))());

		TAcc(b1 with disposers = disp)
	})
}

TAttachWidthHeight(
	t : Tropic,
	width : DynamicBehaviour<double>,
	height : DynamicBehaviour<double>) -> Tropic {

	TInspect([Width(width), Height(height)], t)
}

TAttachBoxThrottle(t : Tropic, box : DynamicBehaviour<WidthHeight>, maxDelta : int) -> Tropic {
	TransformTAcc2(\t2a -> {
		b1 = t |> t2a;

		disp =
			arrayPush(b1.disposers, fconnect(fthrottle2(fwidthheight(b1.metrics.width, b1.metrics.height), maxDelta), box));

		TAcc(b1 with disposers = disp)
	})
}

TThrottleMetrics(t : Tropic, maxDelta : int) -> Tropic {
	TransformTAcc2(\t2a -> {
		b1 = t |> t2a;

		TAcc(
			b1.form,
			TFormMetrics(
				fthrottle2(b1.metrics.width, maxDelta),
				fthrottle2(b1.metrics.height, maxDelta),
				fthrottle2(b1.metrics.baseline, maxDelta)
			),
			fthrottle2(b1.minWidth, maxDelta),
			fthrottle2(b1.minHeight, maxDelta),
			fthrottle2(b1.maxWidth, maxDelta),
			fthrottle2(b1.maxHeight, maxDelta),
			fthrottle2(b1.xFillers, maxDelta),
			fthrottle2(b1.yFillers, maxDelta),
			fthrottle2(b1.addFillers, maxDelta),
			b1.xConstant,
			b1.yConstant,
			b1.disposers
		)
	})
}

TAttachAvailable(t : Tropic, box : DynamicBehaviour<WidthHeight>) -> Tropic {
	TInspect([IAvailable(box)], t)
}

TAttachAvailableWidth(t : Tropic, width : DynamicBehaviour<double>) -> Tropic {
	TInspect([AvailableWidth(width)], t)
}

TAttachAvailableHeight(t : Tropic, height : DynamicBehaviour<double>) -> Tropic {
	TInspect([AvailableHeight(height)], t)
}

TAttachAvailableWidthHeight(
	t : Tropic,
	width : DynamicBehaviour<double> ,
	height : DynamicBehaviour<double>) -> Tropic {

	TInspect([AvailableWidth(width), AvailableHeight(height)], t)
}

TProportionGrid(c : [[Pair<Transform<Factor>, Tropic>]]) -> Tropic {
	map(c, \r ->
		map(r, \t ->
			TransformTAcc2(\t2a -> {
					b1 = t.second |> t2a;

					TAcc(b1 with
						xFillers = ffactorX(t.first),
						yFillers = ffactorY(t.first),
						addFillers = const(false),
					)
				}
			)
		)
	)
	|> TGrid
}

TProportionLines(c : [Pair<Transform<double>, Tropic>]) -> Tropic {
	map(c, \t ->
		TransformTAcc2(\t2a -> {
				b1 = t.second |> t2a;

				TAcc(b1 with
					yFillers = t.first,
					addFillers = const(false),
					xConstant = false,
				)
			}
		)
	)
	|> TLines
}

TProportionCols(c : [Pair<Transform<double>, Tropic>]) -> Tropic {
	map(c, \t ->
		TransformTAcc2(\t2a -> {
				b1 = t.second |> t2a;

				TAcc(b1 with
					xFillers = t.first,
					addFillers = const(false),
					xConstant = false,
				)
			}
		)
	)
	|> TCols
}

TProportionBaselineCols(c : [Pair<Transform<double>, Tropic>]) -> Tropic {
	map(c, \t ->
		TransformTAcc2(\t2a -> {
				b1 = t.second |> t2a;

				TAcc(b1 with
					xFillers = t.first,
					addFillers = const(false),
					xConstant = false,
				)
			}
		)
	)
	|> TBaselineCols
}

TProportionColsA(c : [Pair<Transform<double>, Tropic>], isRTL : bool) -> Tropic {
	map(c, \t ->
		TransformTAcc2(\t2a -> {
				b1 = t.second |> t2a;

				TAcc(b1 with
					xFillers = t.first,
					addFillers = const(false),
					xConstant = false,
				)
			}
		)
	)
	|> (\arr -> TColsDir(arr, isRTL))
}

TAvailableWidth(tr : Tropic, available : Transform<double>) -> Tropic {
	TransformTAcc(\t2a, pi, st, mo ->
		t2a(tr, TParentInfo(pi with maxX = available), st, mo)
	)
}

TAvailableHeight(tr : Tropic, available : Transform<double>) -> Tropic {
	TransformTAcc(\t2a, pi, st, mo ->
		t2a(tr, TParentInfo(pi with maxY = available), st, mo)
	)
}

TAvailableWidthHeight(tr : Tropic, availableW : Transform<double>, availableH : Transform<double>) -> Tropic {
	TransformTAcc(\t2a, pi, st, mo ->
		t2a(tr, TParentInfo(pi with maxX = availableW, maxY = availableH), st, mo)
	)
}

TCropWidth(tr : Tropic, width : Transform<double>) -> Tropic {
	TransformTAcc(\t2a, parent, sheet, metricsOnly -> {
		a = t2a(tr, parent, sheet, metricsOnly);
		metrics = TFormMetrics(a.metrics with width = width);
		form =
			if (metricsOnly)
				FEmpty()
			else
				FCrop(
					zero,
					zero,
					metrics.width,
					metrics.height,
					a.form
				);
		TAcc(
			a with
				form = form,
				minWidth = width,
				maxWidth = width,
				metrics = metrics,
				xFillers = const(0.0),
				xConstant = isFConst(width)
		)
	});
}

TCropHeight(tr : Tropic, height : Transform<double>) -> Tropic {
	TransformTAcc(\t2a, parent, sheet, metricsOnly -> {
		a = t2a(tr, parent, sheet, metricsOnly);
		metrics = TFormMetrics(a.metrics with height = height);
		form =
			if (metricsOnly)
				FEmpty()
			else
				FCrop(
					zero,
					zero,
					metrics.width,
					metrics.height,
					a.form
				);
		TAcc(
			a with
				form = form,
				minHeight = height,
				maxHeight = height,
				metrics = metrics,
				yFillers = const(0.0),
				yConstant = isFConst(height)
		)
	});
}

TAlignHorizontal(align : CommonAlignment) -> (Tropic) -> Tropic {
	switch (align : CommonAlignment) {
		StartAlign() : TAlignStart;
		EndAlign() : TAlignEnd;
		LeftAlign() : TAlignLeft;
		RightAlign() : TAlignRight;
		CenterAlign() : \t -> TTweak([TAlign(const(0.5), const(0.0))], t, TFillX());
	}
}

TAlignHorizontalDir(align : CommonAlignment, isRTL : bool) -> (Tropic) -> Tropic {
	switch (align : CommonAlignment) {
		StartAlign() : \t -> TAlignStartDir(t, isRTL);
		EndAlign() : \t -> TAlignEndDir(t, isRTL);
		LeftAlign() : TAlignLeft;
		RightAlign() : TAlignRight;
		CenterAlign() : \t -> TTweak([TAlign(const(0.5), const(0.0))], t, TFillX());
	}
}

TAlignStart(t : Tropic) -> Tropic {
	TAlignStartDir(t, getDefaultRtl())
}

TAlignStartDir(t : Tropic, isRTL : bool) -> Tropic {
	if (isRTL) TAlignRight(t) else t
}

TAlignEnd(t : Tropic) -> Tropic {
	TAlignEndDir(t, getDefaultRtl())
}

TAlignEndDir(t : Tropic, isRTL : bool) -> Tropic {
	if (!isRTL) TAlignRight(t) else t
}

TAlignLeft(t : Tropic) -> Tropic {
	TTweak([TAlign(const(0.0), const(0.0))], t, TFillX())
}

TAlignTop(t : Tropic) -> Tropic {
	TTweak([TAlign(const(0.0), const(0.0))], t, TFillY())
}

TAlignRight(t : Tropic) -> Tropic {
	TTweak([TAlign(const(1.0), const(0.0))], t, TFillX())
}

TAlignBottom(t : Tropic) -> Tropic {
	TTweak([TAlign(const(0.0), const(1.0))], t, TFillY())
}

TAlignTopLeft(t : Tropic) -> Tropic {
	TTweak([TAlign(const(0.0), const(0.0))], t, TFillXY())
}

TAlignTopCenter(t : Tropic) -> Tropic {
	TTweak([TAlign(const(0.5), const(0.0))], t, TFillXY())
}

TAlignTopRight(t : Tropic) -> Tropic {
	TTweak([TAlign(const(1.0), const(0.0))], t, TFillXY())
}

TAlignCenterRight(t : Tropic) -> Tropic {
	TTweak([TAlign(const(1.0), const(0.5))], t, TFillXY())
}

TAlignBottomRight(t : Tropic) -> Tropic {
	TTweak([TAlign(const(1.0), const(1.0))], t, TFillXY())
}

TAlignBottomCenter(t : Tropic) -> Tropic {
	TTweak([TAlign(const(0.5), const(1.0))], t, TFillXY())
}

TAlignBottomLeft(t : Tropic) -> Tropic {
	TTweak([TAlign(const(0.0), const(1.0))], t, TFillXY())
}

TAlignCenterLeft(t : Tropic) -> Tropic {
	TTweak([TAlign(const(0.0), const(0.5))], t, TFillXY())
}

TBorderTop(border : double) -> (Tropic) -> Tropic {
	\tr -> TBorder(0., border, 0., 0., tr)
}

TBorderBottom(border : double) -> (Tropic) -> Tropic {
	\tr -> TBorder(0., 0., 0., border, tr)
}

TBorderLeft(border : double) -> (Tropic) -> Tropic {
	\tr -> TBorder(border, 0., 0., 0., tr)
}

TBorderRight(border : double) -> (Tropic) -> Tropic {
	\tr -> TBorder(0., 0., border, 0., tr)
}

TBorderTopBottom(border : double) -> (Tropic) -> Tropic {
	\tr -> TBorder(0., border, 0., border, tr)
}

TBorderLeftRight(border : double) -> (Tropic) -> Tropic {
	\tr -> TBorder(border, 0., border, 0., tr)
}

TBorderT(left : Transform<double>, top : Transform<double>, right : Transform<double>, bottom : Transform<double>, t : Tropic) -> Tropic {
	TransformTAcc(\tropic2acc, parent, sheet, metricsOnly -> {
		wSum = faddition(left, right);
		hSum = faddition(top, bottom);

		t2a = \tr -> tropic2acc(
			tr,
			TParentInfo(
				fsubtract(parent.maxX, wSum),
				fsubtract(parent.maxY, hSum),
				parent.environment,
				parent.transformMatrix
			),
			sheet,
			metricsOnly
		);

		b = t |> t2a;

		width = faddition(b.metrics.width, wSum);
		height = faddition(b.metrics.height, hSum);
		baseline = faddition(b.metrics.baseline, top);

		TAcc(
			b.form,
			TFormMetrics(width, height, baseline),
			faddition(b.minWidth, wSum),
			faddition(b.minHeight, hSum),
			faddition(b.maxWidth, wSum),
			faddition(b.maxHeight, hSum),
			b.xFillers,
			b.yFillers,
			b.addFillers,
			b.xConstant && isFConst(left) && isFConst(right),
			b.yConstant && isFConst(top) && isFConst(bottom),
			b.disposers
		)
	})
	|> (\f -> TTranslate(fpoint(left, top), f))
}

TBorderTDir(left : Transform<double>, top : Transform<double>, right : Transform<double>, bottom : Transform<double>, t : Tropic, isRTL : bool) -> Tropic {
	if (isRTL) TBorderT(right, top, left, bottom, t)
	else TBorderT(left, top, right, bottom, t)
}

TDecorator(tr : Tropic, decorators : [Pair<Transform<bool>, (Transform<WidthHeight>) -> Tropic>], above : bool) -> Tropic {
	TransformTAcc2(\t2a -> {
		b1 = tr |> t2a;
		wh = fwidthheight(b1.metrics.width, b1.metrics.height);

		TAcc(b1 with form =
			FDecorator(
				b1.form,
				map(decorators, \d -> {
					Pair(
						d.first,
						\ -> d.second(wh) |> t2a |> (\b2 -> FConstructor(b2.form, \ -> \ -> applyall(b2.disposers)))
					)
				}),
				above
			)
		)
	})
}

TDynamicText(text : Transform<string>, style : [TParagraphStyle]) -> Tropic {
	if (text == const(""))
		TEmpty()
	else
		TParagraph(text, style);
}

THTMLText(text : string, style : [TCharacterStyle]) -> Tropic {
	TText(text, replaceStruct(style, EscapeHTML(false)));
}

THTMLDynamicText(text : Transform<string>, style : [TParagraphStyle]) -> Tropic {
	TDynamicText(text, replaceStruct(style, EscapeHTML(false)));
}

TDebugMetrics(c : int, tr : Tropic) -> Tropic {
	TransformTAcc2(\t2a -> {
		b = TDebug(c, tr) |> t2a;

		TAcc(b with form =
			FGroup2(
				b.form,
				FText(fselect2(b.metrics.width, b.metrics.height, FLift2(\wd, hgt -> d2s(wd) + "x" + d2s(hgt))), []),
				false
			)
		)
	})
}

TDebugPositionScale(c : int, tr : Tropic) -> Tropic {
	TransformTAcc(\t2a, pi, ss, mo -> {
		b = t2a(TDebug(c, tr), pi, ss, mo);

		TAcc(b with form =
			FConstructor(
				b.form,
				makeSubscribeUns(fapplytransform(fwidthheight(b.metrics.width, b.metrics.height), pi.transformMatrix), \vb -> {
					[
						frender(
							FTranslate(
								const(vb.minX),
								const(vb.minY),
								FRectangle(vb.maxX - vb.minX, vb.maxY - vb.minY, [Fill(c), FillOpacity(0.3)])
							),
							makeWH()
						)
					]
				})
			)
		)
	})
}

TDebugConstruct(tag : string, tr : Tropic) -> Tropic {
	name = if (tag == "") tr.structname else tag;

	TConstruct(
		[
			\ -> {
				println(name + " constructed");
				\ -> println(name + " destroyed");
			}
		],
		tr
	)
}

TDebugInteractive(tr : Tropic) -> Tropic {
	da = makeDynamicArray([]);
	daDown = makeDynamicArray([]);
	daUp = makeDynamicArray([]);

	TInteractive(
		[
			MouseMove2(\h, mi -> {
				m = mi();

				println("mouse move: " + toString(Point(m.x, m.y)));

				pushDynamicArray(da, Point(m.x, m.y));

				h;
			}),
			MouseDown2(\h, m -> {
				println("mouse down: " + toString(Point(m.x, m.y)));

				pushDynamicArray(daDown, Point(m.x, m.y));

				h;
			}),
			MouseUp2(\h, mi -> {
				m = mi();

				println("mouse up: " + toString(Point(m.x, m.y)));

				pushDynamicArray(daUp, Point(m.x, m.y));

				h;
			}),
		],
		TGroupSameMetrics([
			tr,
			SelectTDynamicGroup(
				da,
				\index, id, v -> {
					timer(500, \ -> removeDynamicArray(da, v) |> ignore);

					TGraphics(
						[GCircle(v.x, v.y, 10.0)],
						[Fill(red), FillOpacity(0.2)]
					)
				}
			),
			SelectTDynamicGroup(
				daDown,
				\index, id, v -> {
					timer(500, \ -> removeDynamicArray(daDown, v) |> ignore);

					TGraphics(
						[GCircle(v.x, v.y, 10.0)],
						[Fill(blue), FillOpacity(0.2)]
					)
				}
			),
			SelectTDynamicGroup(
				daUp,
				\index, id, v -> {
					timer(500, \ -> removeDynamicArray(daUp, v) |> ignore);

					TGraphics(
						[GCircle(v.x, v.y, 10.0)],
						[Fill(green), FillOpacity(0.2)]
					)
				}
			)
		])
	)
}

TOnConstruct(fn : () -> void) -> (Tropic) -> Tropic {
	\tr -> TConstruct(
		[
			\ -> {
				fn();
				nop;
			}
		],
		tr
	)
}

TEvenGrid(content : [[Tropic]]) -> Tropic {
	if (length(content) > 0 && length(content[0]) > 0)
		TransformTAcc(\t2a, p, s, mo -> {
			maxX = p.maxX;
			maxY = p.maxY;

			columnWidths = generate(0, either(maxA(map(content, length)), 0), \__ -> make(0.));
			rowHeights = generate(0, length(content), \__ -> make(0.));

			translatesX = generate(0, length(columnWidths), \__ -> make(0.));
			translatesY = generate(0, length(rowHeights), \__ -> make(0.));

			contentAcc =
				mapi(content, \j, c -> mapi(c, \i, tr ->
					t2a(
						tr,
						TParentInfo(
							columnWidths[i],
							rowHeights[j],
							p.environment,
							fworldtransform(p.transformMatrix, fpoint2transform(fpoint(translatesX[i], translatesY[j])))
						),
						s,
						mo
					)
				));
			form =
				FGroup(
					mapi(contentAcc, \j, c -> mapi(c, \i, tacc -> FTranslate(translatesX[i], translatesY[j], tacc.form))) |> concatA,
					true
				);
			disp = concatA(map(concatA(contentAcc), \tacc -> tacc.disposers));

			minWidths = generate(0, length(columnWidths), \i -> fmaxA(map(contentAcc, \c -> if (i < length(c)) c[i].minWidth else zero), 0.)) |> fmerge;
			minHeights = map(contentAcc, \c -> fmaxA(map(c, \tacc -> tacc.minHeight), 0.)) |> fmerge;
			maxWidths = generate(0, length(columnWidths), \i -> fmaxA(map(contentAcc, \c -> if (i < length(c)) c[i].maxWidth else zero), 0.)) |> fmerge;
			maxHeights = map(contentAcc, \c -> fmaxA(map(c, \tacc -> tacc.maxHeight), 0.)) |> fmerge;
			xFillers = generate(0, length(columnWidths), \i -> fmaxA(map(contentAcc, \c -> if (i < length(c)) c[i].xFillers else zero), 0.)) |> fmerge;
			yFillers = map(contentAcc, \c -> fmaxA(map(c, \tacc -> tacc.yFillers), 0.)) |> fmerge;

			realWidths = generate(0, length(columnWidths), \i -> fmaxA(map(contentAcc, \c -> if (i < length(c)) c[i].minWidth else zero), 0.));
			realHeights = map(contentAcc, \c -> fmaxA(map(c, \tacc -> tacc.metrics.height), 0.));

			uns1 =
				make4Subscribe(minWidths, maxWidths, maxX, xFillers, \minW, maxW, mx, xf -> {
					wd = ref 0.;

					iteri(distributeSizesEvenly2(minW, maxW, map(columnWidths, getValue), xf, max(mx, dsum(minW))), \i, nw -> {
						nextDistinct(translatesX[i], ^wd);
						wd := ^wd + nw;
						nextDistinct(columnWidths[i], nw);
					})
				})();

			uns2 =
				make4Subscribe(minHeights, maxHeights, maxY, yFillers, \minH, maxH, my, yf -> {
					hgt = ref 0.;

					iteri(distributeSizesEvenly2(minH, maxH, map(rowHeights, getValue), yf, max(my, dsum(minH))), \i, nh -> {
						nextDistinct(translatesY[i], ^hgt);
						hgt := ^hgt + nh;
						nextDistinct(rowHeights[i], nh);
					})
				})();

			TAcc(
				form,
				TFormMetrics(
					fsum(realWidths),
					fsum(realHeights),
					zero
				),
				fselect(minWidths, FLift(dsum)),
				fselect(minHeights, FLift(dsum)),
				fselect(maxWidths, FLift(dsum)),
				fselect(maxHeights, FLift(dsum)),
				fselect(xFillers, FLift(dsum)),
				fselect(yFillers, FLift(dsum)),
				const(false),
				false,
				false,
				concatA([disp, [uns1, uns2]])
			)
		})
	else
		TEmpty()
}

distributeSizesEvenly2(minWidths : [double], maxWidths : [double], columnWidths0 : [double], xFillers : [double], availableWidth : double) -> [double] {
	columnsCount = either(minA([length(minWidths), length(maxWidths), length(columnWidths0)]), 0);

	additionThreshold = 0.;
	sumFillers = max(dsum(xFillers), 1.);

	if (columnsCount > 0) {
		columnWidths = generate(0, columnsCount, \i -> max(columnWidths0[i], minWidths[i]));
		sumWidth = dsum(columnWidths);

		if (sumWidth < availableWidth - additionThreshold || sumWidth > availableWidth + additionThreshold) {
			available = availableWidth - sumWidth;
			addition = available / sumFillers;

			availableForAddition =
				mapi(subrange(maxWidths, 0, columnsCount), \i, mw -> ref
					xFillers[i] > 0. && (if (sumWidth < availableWidth)
						(mw > minWidths[i] && columnWidths[i] < mw) || (mw < minWidths[i])
					else
						columnWidths[i] > minWidths[i])
				);

			newWidths =
				mapi(subrange(columnWidths, 0, columnsCount), \i, cw -> ref
					if (^(availableForAddition[i])) {
						nw = cw + addition * xFillers[i];

						if (nw < minWidths[i]) {
							availableForAddition[i] := false;
							minWidths[i];
						} else if (maxWidths[i] >= minWidths[i] && nw > maxWidths[i]) {
							availableForAddition[i] := false;
							maxWidths[i];
						} else {
							nw
						}
					} else {
						if (minWidths[i] > 0.) {
							if (minWidths[i] <= maxWidths[i])
								min(max(cw, minWidths[i]), maxWidths[i])
							else
								max(cw, minWidths[i])
						} else
							cw
					}
				);

			updateWhile(
				countA(availableForAddition, \afa -> ^afa)
				|> (\afa ->
					if (afa > 0)
						(availableWidth - fold(newWidths, 0., \acc, nw -> acc + ^nw)) / sumFillers
					else
						0.
				),
				\newAddition -> {
					if ((newAddition > additionThreshold || newAddition < additionThreshold) &&
						foldi(availableForAddition, false, \i, acc, afa -> {
							if (^afa) {
								newWidths[i] :=
									max(minWidths[i], ^(newWidths[i]) + newAddition * xFillers[i])
									|> (\f -> if (minWidths[i] < maxWidths[i]) min(f, maxWidths[i]) else f);
								false
							} else {
								acc
							}
						}))
						Some((availableWidth - fold(newWidths, 0., \acc, nw -> acc + ^nw)) / i2d(countA(availableForAddition, \afa -> ^afa)))
					else
						None()
				}
			);

			map(newWidths, \nw -> ^nw);
		} else {
			columnWidths
		}
	} else
		columnWidths0
}

TConstructRenderable(constructors : [() -> () -> void], tr : Tropic) -> Tropic {
	TransformTAcc(\t2a, pi, ss, mo -> {
		b = t2a(tr, pi, ss, mo);
		renderable = make(false);

		TAcc(b with form =
			FDecorator(
				FRenderable(renderable, b.form),
				[
					Pair(renderable, \ -> FConstruct(constructors, FEmpty()))
				],
				true
			)
		)
	})
}

wh2Tropic(wh : WidthHeight) -> Tropic {
	if (wh.width >= 0.) {
		if (wh.height >= 0.)
			TFixed(wh.width, wh.height)
		else
			TFillWY(wh.width)
	} else if (wh.height >= 0.)
		TFillXH(wh.height)
	else
		TFillXY();
}

TZoomMax(tr : Tropic, maxWH : Transform<WidthHeight>) -> Tropic {
	availableWH = makeWH();
	scaleFactor = fselect2(availableWH, maxWH, FLift2(\awh, mwh -> max3(awh.width / mwh.width, awh.height / mwh.height, 1.0)));

	TScale(ffactor2(scaleFactor), tr)
	|> (\f -> TAttachAvailable(f, availableWH))
}

TZoomMaxWidth(tr : Tropic, maxWidth : Transform<double>) -> Tropic {
	availableX = make(0.0);
	scaleFactor = fmax(fdivide(availableX, maxWidth), const(1.0));

	TScale(ffactor2(scaleFactor), tr)
	|> (\f -> TAttachAvailableWidth(f, availableX))
}

TZoomMaxHeight(tr : Tropic, maxHeight : Transform<double>) -> Tropic {
	availableY = make(0.0);
	scaleFactor = fmax(fdivide(availableY, maxHeight), const(1.0));

	TScale(ffactor2(scaleFactor), tr)
	|> (\f -> TAttachAvailableHeight(f, availableY))
}

disableMouseWheelBelow(content : Tropic) -> Tropic {
	if (mobile)
		content
	else {
		TInteractive(
			[
				FineGrainMouseWheel2(\__, mi -> mi().inside)
			],
			content
		)
	}
}

disableInteractivesBelow(content : Tropic) -> Tropic {
	TCopySize(content, interactivesBlockerLayer, false)
}

blockInteractives(content : Tropic) -> Tropic {
	TCopySize(content, interactivesBlockerLayer, true)
}

interactivesBlockerLayer(tr : Tropic) -> Tropic {
	TInteractive(
		[
			MouseDown(\mi -> mi.inside()),
			MouseRightDown(\mi -> mi.inside()),
			MouseMiddleDown(\mi -> mi.inside()),
			MouseUp(\mi -> mi().inside),
			MouseMove(\mi -> mi().inside),
			TouchStart(\mi -> length(mi.inside) > 0 && !exists(mi.inside, \m -> !m())),
			TouchMove(\mi -> length(mi.inside) > 0 && !exists(mi.inside, \m -> !m())),
			TouchEnd(\mi -> length(mi.inside) > 0 && !exists(mi.inside, \m -> !m())),
			RollOver(nop1),
			RollOut(nop1)
		],
		TRectangle(interactiveRectangleStyle, tr)
	)
}

TCheckeredRectangle(style1 : [TGraphicsStyle], style2 : [TGraphicsStyle], content : Tropic) -> Tropic {
	size = makeWH();

	TGroup2(
		TInspect([ISize(size)], content),
		TCropSize(
			TSized(size),
			TFrame(
				0.,
				0.,
				style1,
				TSelect(size, \s -> {
					generate(0, ceil(s.width / 10.0), \i -> {
						generate(0, ceil(s.height / 10.0), \j -> {
							if ((i + j) % 2 == 0)
								TGraphics([GRect(i2d(i * 10), i2d(j * 10), 10.0, 10.0)], style2)
							else
								TEmpty()
						})
					})
					|> concatA
					|> TGroup
				})
			)
		)
	);
}

TCheckeredRounded(
	nw : double,
	ne : double,
	lw : double,
	le : double,
	style1 : [TGraphicsStyle],
	style2 : [TGraphicsStyle],
	content : Tropic
) -> Tropic {
	size = makeWH();

	TGroup2(
		TInspect([ISize(size)], content),
		TMask(
			TFrame(
				0.,
				0.,
				style1,
				TSelect(size, \s -> {
					generate(0, ceil(s.width / 10.0), \i -> {
						generate(0, ceil(s.height / 10.0), \j -> {
							if ((i + j) % 2 == 0)
								TGraphics([GRect(i2d(i * 10), i2d(j * 10), 10.0, 10.0)], style2)
							else
								TEmpty()
						})
					})
					|> concatA
					|> TGroup
				})
			),
			TRounded(nw, ne, lw, le, [Fill(white)], TSized(size))
		)
	);
}

TMouseWheelInteractive(manager : TManager, content : Tropic, deltaX : (double) -> bool, deltaY : (double) -> bool) -> Tropic {
	// Qt target on OSX returns the scroll in pixels, so we scale it by 80.
	scrollScale = if (qt && macosx()) 80. else 1.;

	if (mobile)
		content
	else {
		zorder = ref getValue(manager.zorder);

		TConstruct(
			[
				\ -> {
					zorder := getValue(manager.zorder);
					nop
				}
			],
			TInteractive(
				[
					FineGrainMouseWheel2(\h, mi ->
						if (!h && ^zorder >= getValue(manager.zorder)) {
							m = mi();

							if (m.inside && (m.dx != 0. || m.dy != 0.)) {
								dx = deltaX(m.dx / scrollScale);
								dy = deltaY(m.dy / scrollScale);

								dx || dy
							} else {
								h
							}
						} else
							h
					)
				],
				content
			)
		)
	}
}

T3DStage(scene : F3DObject, camera : F3DObject, size : Tropic, style : [F3DStageStyle]) -> Tropic {
	wh = makeWH();

	TGroup2(
		TInspect(
			[
				ISize(wh),
				IMetricsOnly()
			],
			size
		),
		TFForm(
			F3DStage(
				wh,
				scene,
				camera,
				style
			),
			TFormMetrics(
				fwidth(wh),
				fheight(wh),
				fheight(wh)
			)
		)
	);
}

THTMLStage(wh : Transform<WidthHeight>, constructor : (stage : native) -> () -> void) -> Tropic {
	TFForm(
		FHTMLStage(wh, constructor),
		TFormMetrics(
			fwidth(wh),
			fheight(wh),
			fheight(wh)
		)
	)
}

TMoveClip(t : Tropic, fn : (Tropic) -> void) -> Tropic {
	TransformTAcc2(\t2a -> {
		b = t2a(t);

		TAcc(b with
			form = FNativeForm(
				t,
				const(FormMetrics(0., 0., 0., 0.)),
				\ -> b.form,
				\__, z, __ -> {
					zorder = make(z);
					rr = renderFForm(b.form, zorder);
					originalParent = makeClip();
					alive = ref false;
					iter(rr.clips, \c -> addChild(originalParent, c));
					parent = makeClip();

					fn(
						TFForm(
							FNativeForm(
								t,
								const(FormMetrics(0., 0., 0., 0.)),
								\ -> b.form,
								\__, z2, __ -> {
									alive := true;
									iter(rr.clips, \c -> addChild(parent, c));
									nextDistinct(zorder, z2);

									NativeRenderResult(
										[parent],
										\ -> {
											nextDistinct(zorder, z);

											if (^alive) {
												iter(rr.clips, \c -> addChild(originalParent, c));
												alive := false;
											}
										}
									)
								}
							),
							b.metrics
						)
					);

					NativeRenderResult(
						[originalParent],
						\ -> {
							if (^alive) {
								iter(rr.clips, \c -> removeChild(parent, c));
								alive := false;
							}

							applyall(rr.disposers);
						}
					)
				}
			)
		)
	})
}

TCanvas(content : Tropic) -> Tropic {
	TransformTAcc2(\t2a -> {
		b = t2a(content);

		TAcc(b with form = FCanvas(b.form));
	})
}

filterFPdfDocumentStyle(style : [TPdfDocumentStyle]) -> [FPdfDocumentStyle] {
	filtermap(style, \st ->
		switch (st) {
			OnError(__): Some(st);
		}
	)
}

loadTPdfDocument(url : string, onLoad : (TPdfDocument) -> void, style : [TPdfDocumentStyle]) {
	makeTViewFn = \document -> \page -> {
		availableWH = makeWH();
		metrics = make(FormMetrics(0.0, 0.0, 0.0, 0.0));
		tMetrics = TFormMetrics(
			fselect(metrics, FLift(\m -> m.width)),
			fselect(metrics, FLift(\m -> m.height)),
			fselect(metrics, FLift(\m -> m.baseline))
		);

		TInspect(
			[
				IAvailable(availableWH)
			],
			TFForm(
				document.getPageView(page, [FPdfMetrics(metrics)], availableWH),
				tMetrics
			)
		)
	}

	loadFPdfDocument(
		url,
		\fPdfDocument -> {
			onLoad(
				TPdfDocument(
					fPdfDocument.pageCount,
					makeTViewFn(fPdfDocument)
				)
			)
		},
		filterFPdfDocumentStyle(style)
	)
}

TShowKeepMetrics(show : Transform<bool>, content : Tropic) -> Tropic {
	TransformTAcc(\t2a, parent, ss, mo -> {
		b = t2a(TShow(fselectWithLast(show, FusionOr()), content), parent, ss, mo);

		TAcc(
			b with form = FShow(show, b.form)
		)
	})
}

TIfFits(fullSizeContent : Tropic, reducedSizeContent : Tropic) -> Tropic {
	TransformTAcc(\t2a, parent, ss, mo -> {
			b = t2a(fullSizeContent, parent, ss, mo);

			ifAvailable =
				fand(
					fnot(fless(parent.maxX, b.minWidth)),
					fnot(fless(parent.maxY, b.minHeight))
				);

			b2 = t2a(TShowKeepMetrics(fnot(ifAvailable), reducedSizeContent), parent, ss, mo);

			TAcc(
				FMutable(fif(ifAvailable, const(b.form), const(b2.form))),
				TFormMetrics(
					fif(ifAvailable, b.metrics.width, b2.metrics.width),
					fif(ifAvailable, b.metrics.height, b2.metrics.height),
					fif(ifAvailable, b.metrics.baseline, b2.metrics.baseline)
				),
				fmin(b.minWidth, b2.minWidth),
				fmin(b.minHeight, b2.minWidth),
				b.maxWidth,
				b.maxHeight,
				fmax(fif(ifAvailable, b.xFillers, b2.xFillers), const(1.0)),
				fmax(fif(ifAvailable, b.yFillers, b2.yFillers), const(1.0)),
				const(false),
				false,
				false,
				concat(b.disposers, b2.disposers)
			)
		}
	)
}

TIfFitsWidth(fullSizeContent : Tropic, reducedSizeContent : Tropic) -> Tropic {
	TransformTAcc(\t2a, parent, ss, mo -> {
			b = t2a(fullSizeContent, parent, ss, mo);

			ifAvailable = fnot(fless(parent.maxX, b.minWidth));

			b2 = t2a(TShowKeepMetrics(fnot(ifAvailable), reducedSizeContent), parent, ss, mo);

			TAcc(
				FMutable(fif(ifAvailable, const(b.form), const(b2.form))),
				TFormMetrics(
					fif(ifAvailable, b.metrics.width, b2.metrics.width),
					fif(ifAvailable, b.metrics.height, b2.metrics.height),
					fif(ifAvailable, b.metrics.baseline, b2.metrics.baseline)
				),
				fmin(b.minWidth, b2.minWidth),
				fif(ifAvailable, b.minHeight, b2.minHeight),
				b.maxWidth,
				fif(ifAvailable, b.maxHeight, b2.maxHeight),
				fmax(fif(ifAvailable, b.xFillers, b2.xFillers), const(1.0)),
				fif(ifAvailable, b.yFillers, b2.yFillers),
				const(false),
				false,
				false,
				concat(b.disposers, b2.disposers)
			)
		}
	)
}

TIfFitsWidthDelay(fullSizeContent : Tropic, reducedSizeContent : Tropic, delay : int) -> Tropic {
	TransformTAcc(\t2a, parent, ss, mo -> {
			b = t2a(fullSizeContent, parent, ss, mo);

			ifAvailable = fstall(fnot(fless(parent.maxX, b.minWidth)), delay);

			b2 = t2a(TShowKeepMetrics(fnot(ifAvailable), reducedSizeContent), parent, ss, mo);

			TAcc(
				FMutable(fif(ifAvailable, const(b.form), const(b2.form))),
				TFormMetrics(
					fif(ifAvailable, b.metrics.width, b2.metrics.width),
					fif(ifAvailable, b.metrics.height, b2.metrics.height),
					fif(ifAvailable, b.metrics.baseline, b2.metrics.baseline)
				),
				fmin(b.minWidth, b2.minWidth),
				fif(ifAvailable, b.minHeight, b2.minHeight),
				b.maxWidth,
				fif(ifAvailable, b.maxHeight, b2.maxHeight),
				fmax(fif(ifAvailable, b.xFillers, b2.xFillers), const(1.0)),
				fif(ifAvailable, b.yFillers, b2.yFillers),
				const(false),
				false,
				false,
				concat(b.disposers, b2.disposers)
			)
		}
	)
}

TIfFitsHeight(fullSizeContent : Tropic, reducedSizeContent : Tropic) -> Tropic {
	TransformTAcc(\t2a, parent, ss, mo -> {
			b = t2a(fullSizeContent, parent, ss, mo);

			ifAvailable = fnot(fless(parent.maxY, b.minHeight));

			b2 = t2a(TShowKeepMetrics(fnot(ifAvailable), reducedSizeContent), parent, ss, mo);

			TAcc(
				FMutable(fif(ifAvailable, const(b.form), const(b2.form))),
				TFormMetrics(
					fif(ifAvailable, b.metrics.width, b2.metrics.width),
					fif(ifAvailable, b.metrics.height, b2.metrics.height),
					fif(ifAvailable, b.metrics.baseline, b2.metrics.baseline)
				),
				fif(ifAvailable, b.minWidth, b2.minWidth),
				fmin(b.minHeight, b2.minHeight),
				fif(ifAvailable, b.maxWidth, b2.maxWidth),
				b.maxHeight,
				fif(ifAvailable, b.xFillers, b2.xFillers),
				fmax(fif(ifAvailable, b.yFillers, b2.yFillers), const(1.0)),
				const(false),
				false,
				false,
				concat(b.disposers, b2.disposers)
			)
		}
	)
}

TShowIfFits(content : Tropic) -> Tropic {
	TIfFits(content, TEmpty())
}

TShowIfFitsWidth(content : Tropic) -> Tropic {
	TIfFitsWidth(content, TEmpty())
}

TShowIfFitsHeight(content : Tropic) -> Tropic {
	TIfFitsHeight(content, TEmpty())
}

TRenderable(renderable : DynamicBehaviour<bool>, t : Tropic) -> Tropic {
	TransformTAcc2(\t2a -> t2a(t) |> (\b -> TAcc(b with form = FRenderable(renderable, b.form))))
}

TPrintTarget(t : Tropic) -> Tropic {
	printMode = make(false);

	TConstruct(
		[
			\ -> \ -> next(printMode, false),
			\ -> addEventListener(getStage(), "beforeprint", \ -> next(printMode, true)),
			\ -> addEventListener(getStage(), "afterprint", \ -> next(printMode, false))
		],
		TFullWindow(printMode, t)
	)
}

TPrintPages(t : [Tropic]) -> Tropic {
	printMode = make(false);
	stageWH = makeWH();

	TConstruct(
		[
			\ -> \ -> next(printMode, false),
			\ -> addEventListener(getStage(), "beforeprint", \ -> {
				next(stageWH, WidthHeight(getStageWidth(), getStageHeight()));
				next(printMode, true);
			}),
			\ -> addEventListener(getStage(), "afterprint", \ -> next(printMode, false)),
			make2SubscribeUns(printMode, TPrintPageSize, \pm, sz -> {
				eitherMap(sz, \ssz -> if (pm) [setPrintPageSize(ssz.width, ssz.height)] else [], []);
			})
		],
		TFullWindow(
			printMode,
			TLines(map(t, \tt ->
				TAccess(
					[
						ClassName("print-page")
					],
					TAvailable(tt, TIf(printMode, TSized(feither(TPrintPageSize, stageWH)), TFillXY()))
				)
			))
		)
	)
}

TIfPrint(then : Tropic, elset : Tropic) -> Tropic {
	printMode = make(false);

	TConstruct(
		[
			\ -> \ -> next(printMode, false),
			\ -> addEventListener(getStage(), "beforeprint", \ -> next(printMode, true)),
			\ -> addEventListener(getStage(), "afterprint", \ -> next(printMode, false))
		],
		TIf(
			printMode,
			then,
			elset
		)
	)
}

TExtractHTML(t : Tropic, setfn : (fn : () -> string) -> void) -> Tropic {
	TransformTAcc2(\t2a -> {
		b = t2a(t);

		TAcc(b with
			form = FNativeForm(
				t,
				const(FormMetrics(0., 0., 0., 0.)),
				\ -> b.form,
				\__, z, __ -> {
					rr = renderFForm(b.form, const(z));
					parent = makeClip();
					iter(rr.clips, \c -> addChild(parent, c));
					setfn(\ -> getClipHTML(parent));

					NativeRenderResult(
						[parent],
						\ -> {
							applyall(rr.disposers);
						}
					)
				}
			)
		)
	})
}