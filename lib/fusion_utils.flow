import fusion;
import math/transformmatrix;

export {
	fmap(v : Transform<[??]>, fn : (??) -> ?) -> Transform<[?]>;
	fmapi(v : Transform<[??]>, fn : (int, ??) -> ?) -> Transform<[?]>;
	fsubmap(v : Transform<[??]>, fn : (??) -> Transform<?>) -> Transform<[?]>;
	fsubmapi(v : Transform<[??]>, fn : (int, ??) -> Transform<?>) -> Transform<[?]>;
	ffiltermap(v : Transform<[??]>, fn : (??) -> Maybe<?>) -> Transform<[?]>;
	ffiltermapi(v : Transform<[??]>, fn : (int, ??) -> Maybe<?>) -> Transform<[?]>;
	flength(v : Transform<[?]>) -> Transform<int>;

	fpointaddition(p1 : Transform<Point>, p2 : Transform<Point>) -> Transform<Point>;
	fpointsubtract(p1 : Transform<Point>, p2 : Transform<Point>) -> Transform<Point>;
	fpointmultiply(p1 : Transform<Point>, p2 : Transform<Point>) -> Transform<Point>;
	fpointdivide(p1 : Transform<Point>, p2 : Transform<Point>) -> Transform<Point>;

	fwhaddition(wh1 : Transform<WidthHeight>, wh2 : Transform<WidthHeight>) -> Transform<WidthHeight>;
	fwhsubtract(wh1 : Transform<WidthHeight>, wh2 : Transform<WidthHeight>) -> Transform<WidthHeight>;
	fwhmultiply(wh1 : Transform<WidthHeight>, wh2 : Transform<WidthHeight>) -> Transform<WidthHeight>;
	fwhdivide(wh1 : Transform<WidthHeight>, wh2 : Transform<WidthHeight>) -> Transform<WidthHeight>;

	fwidthaddition(wh : Transform<WidthHeight>, width : Transform<double>) -> Transform<WidthHeight>;
	fwidthsubtract(wh : Transform<WidthHeight>, width : Transform<double>) -> Transform<WidthHeight>;
	fheightaddition(wh : Transform<WidthHeight>, height : Transform<double>) -> Transform<WidthHeight>;
	fheightsubtract(wh : Transform<WidthHeight>, height : Transform<double>) -> Transform<WidthHeight>;

	fpoint2transform(point : Transform<Point>) -> Transform<TransformMatrix>;
	fx2transform(x : Transform<double>) -> Transform<TransformMatrix>;
	fy2transform(y : Transform<double>) -> Transform<TransformMatrix>;
	ffactor2transform(factor : Transform<Factor>) -> Transform<TransformMatrix>;
	frotate2transform(rotate : Transform<double>) -> Transform<TransformMatrix>; // In degrees

	fpointfactor2transform(point : Transform<Point>, factor : Transform<Factor>) -> Transform<TransformMatrix>;
	fworldtransform(parent : Transform<TransformMatrix>, child : Transform<TransformMatrix>) -> Transform<TransformMatrix>;

	fwh2bounds(wh : Transform<WidthHeight>) -> Transform<Bounds>;
	fapplytransform(wh : Transform<WidthHeight>, t : Transform<TransformMatrix>) -> Transform<Bounds>;
	fboundscrop(b1 : Transform<Bounds>, b2 : Transform<Bounds>) -> Transform<Bounds>;
	fboundsoverlap(b1 : Transform<Bounds>, b2 : Transform<Bounds>) -> Transform<bool>;

	fIsSome(b : Transform<Maybe<?>>) -> Transform<bool>;
	fIsNone(b : Transform<Maybe<?>>) -> Transform<bool>;

	fFirstOfPair(b : Transform<Pair<?, ??>>) -> Transform<?>;
	fSecondOfPair(b : Transform<Pair<?, ??>>) -> Transform<??>;

	feq2(a : Transform<?>, b : Transform<?>) -> Transform<bool>;
	fneq2(a : Transform<?>, b : Transform<?>) -> Transform<bool>;

	fands(a : [Transform<bool>], def : bool) -> Transform<bool>;
	fOrs(a : [Transform<bool>], def : bool) -> Transform<bool>;

	ftriple(v1 : Transform<?>, v2 : Transform<??>, v3 : Transform<???>) -> Transform<Triple<?, ??, ???>>;
	fquadruple(v1 : Transform<?>, v2 : Transform<??>, v3 : Transform<???>, v4 : Transform<????>) -> Transform<Quadruple<?, ??, ???, ????>>;

	fsome(b : Transform<??>) -> Transform<Some<??>>;

	fmaybeBind(b : Transform<Maybe<?>>, fn : (?) -> Maybe<??>) -> Transform<Maybe<??>>;
	fmaybeMap(b : Transform<Maybe<?>>, fn : (?) -> ??) -> Transform<Maybe<??>>;

	fsubmaybeBind(b : Transform<Maybe<?>>, fn : (?) -> Transform<Maybe<??>>) -> Transform<Maybe<??>>;
	fsubmaybeMap(b : Transform<Maybe<?>>, fn : (?) -> Transform<??>) -> Transform<Maybe<??>>;

	forder(b : Transform<[?]>, order : Transform<[int]>) -> Transform<[?]>;

	fpprint(title : string) -> (Transform<?>) -> Transform<?>;
}

fmap(v : Transform<[??]>, fn : (??) -> ?) -> Transform<[?]> {
	prevV : ref Tree<??, ?> = ref makeTree();

	fselect(v, FLift(\v0 -> {
		map(v0, \val ->
			eitherFn(
				lookupTree(^prevV, val),
				idfn,
				\ -> {
					pVal = fn(val);
					prevV := setTree(^prevV, val, pVal);
					pVal
				}
			)
		)
	}))
}

fmapi(v : Transform<[??]>, fn : (int, ??) -> ?) -> Transform<[?]> {
	prevV : ref Tree<Pair<int, ??>, ?> = ref makeTree();

	fselect(v, FLift(\v0 -> {
		mapi(v0, \i, val ->
			eitherFn(
				lookupTree(^prevV, Pair(i, val)),
				idfn,
				\ -> {
					pVal = fn(i, val);
					prevV := setTree(^prevV, Pair(i, val), pVal);
					pVal
				}
			)
		)
	}))
}

fsubmap(v : Transform<[??]>, fn : (??) -> Transform<?>) -> Transform<[?]> {
	prevV : ref Tree<??, Transform<?>> = ref makeTree();

	fsubselect(v, FLift(\v0 -> {
		map(v0, \val ->
			eitherFn(
				lookupTree(^prevV, val),
				idfn,
				\ -> {
					pVal = fn(val);
					prevV := setTree(^prevV, val, pVal);
					pVal
				}
			)
		)
		|> fmerge
	}))
}

fsubmapi(v : Transform<[??]>, fn : (int, ??) -> Transform<?>) -> Transform<[?]> {
	prevV : ref Tree<Pair<int, ??>, Transform<?>> = ref makeTree();

	fsubselect(v, FLift(\v0 -> {
		mapi(v0, \i, val ->
			eitherFn(
				lookupTree(^prevV, Pair(i, val)),
				idfn,
				\ -> {
					pVal = fn(i, val);
					prevV := setTree(^prevV, Pair(i, val), pVal);
					pVal
				}
			)
		)
		|> fmerge
	}))
}

ffiltermap(v : Transform<[??]>, fn : (??) -> Maybe<?>) -> Transform<[?]> {
	prevV : ref Tree<??, Maybe<?>> = ref makeTree();

	fselect(v, FLift(\v0 -> {
		filtermap(v0, \val ->
			eitherFn(
				lookupTree(^prevV, val),
				idfn,
				\ -> {
					pVal = fn(val);
					prevV := setTree(^prevV, val, pVal);
					pVal
				}
			)
		)
	}))
}

ffiltermapi(v : Transform<[??]>, fn : (int, ??) -> Maybe<?>) -> Transform<[?]> {
	prevV : ref Tree<Pair<int, ??>, Maybe<?>> = ref makeTree();

	fselect(v, FLift(\v0 -> {
		filtermapi(v0, \i, val ->
			eitherFn(
				lookupTree(^prevV, Pair(i, val)),
				idfn,
				\ -> {
					pVal = fn(i, val);
					prevV := setTree(^prevV, Pair(i, val), pVal);
					pVal
				}
			)
		)
	}))
}

flength(v : Transform<[?]>) -> Transform<int> {
	fselect(v, FLift(length))
}

fpointaddition(p1 : Transform<Point>, p2 : Transform<Point>) -> Transform<Point> {
	fselect2(p1, p2, FLift2(\v1, v2 -> Point(v1.x + v2.x, v1.y + v2.y)));
}

fpointsubtract(p1 : Transform<Point>, p2 : Transform<Point>) -> Transform<Point> {
	fselect2(p1, p2, FLift2(\v1, v2 -> Point(v1.x - v2.x, v1.y - v2.y)));
}

fpointmultiply(p1 : Transform<Point>, p2 : Transform<Point>) -> Transform<Point> {
	fselect2(p1, p2, FLift2(\v1, v2 -> Point(v1.x * v2.x, v1.y * v2.y)));
}

fpointdivide(p1 : Transform<Point>, p2 : Transform<Point>) -> Transform<Point> {
	fselect2(p1, p2, FLift2(\v1, v2 -> Point(v1.x / v2.x, v1.y / v2.y)));
}

fwhaddition(wh1 : Transform<WidthHeight>, wh2 : Transform<WidthHeight>) -> Transform<WidthHeight> {
	fselect2(wh1, wh2, FLift2(\v1, v2 -> WidthHeight(v1.width + v2.width, v1.height + v2.height)));
}

fwhsubtract(wh1 : Transform<WidthHeight>, wh2 : Transform<WidthHeight>) -> Transform<WidthHeight> {
	fselect2(wh1, wh2, FLift2(\v1, v2 -> WidthHeight(v1.width - v2.width, v1.height - v2.height)));
}

fwhmultiply(wh1 : Transform<WidthHeight>, wh2 : Transform<WidthHeight>) -> Transform<WidthHeight> {
	fselect2(wh1, wh2, FLift2(\v1, v2 -> WidthHeight(v1.width * v2.width, v1.height * v2.height)));
}

fwhdivide(wh1 : Transform<WidthHeight>, wh2 : Transform<WidthHeight>) -> Transform<WidthHeight> {
	fselect2(wh1, wh2, FLift2(\v1, v2 -> WidthHeight(v1.width / v2.width, v1.height / v2.height)));
}

fwidthaddition(wh : Transform<WidthHeight>, width : Transform<double>) -> Transform<WidthHeight> {
	fselect2(wh, width, FLift2(\v, wd -> WidthHeight(v.width + wd, v.height)));
}

fwidthsubtract(wh : Transform<WidthHeight>, width : Transform<double>) -> Transform<WidthHeight> {
	fselect2(wh, width, FLift2(\v, wd -> WidthHeight(v.width - wd, v.height)));
}

fheightaddition(wh : Transform<WidthHeight>, height : Transform<double>) -> Transform<WidthHeight> {
	fselect2(wh, height, FLift2(\v, hgt -> WidthHeight(v.width, v.height + hgt)));
}

fheightsubtract(wh : Transform<WidthHeight>, height : Transform<double>) -> Transform<WidthHeight> {
	fselect2(wh, height, FLift2(\v, hgt -> WidthHeight(v.width, v.height - hgt)));
}

fpoint2transform(point : Transform<Point>) -> Transform<TransformMatrix> {
	fselect(point, FLift(\v -> {
		TransformMatrix(
			1.0,
			0.0,
			0.0,
			1.0,
			v.x,
			v.y
		)
	}));
}

fx2transform(x : Transform<double>) -> Transform<TransformMatrix> {
	fselect(x, FLift(\v -> {
		TransformMatrix(
			1.0,
			0.0,
			0.0,
			1.0,
			v,
			0.0
		)
	}));
}

fy2transform(y : Transform<double>) -> Transform<TransformMatrix> {
	fselect(y, FLift(\v -> {
		TransformMatrix(
			1.0,
			0.0,
			0.0,
			1.0,
			0.0,
			v
		)
	}));
}

ffactor2transform(factor : Transform<Factor>) -> Transform<TransformMatrix> {
	fselect(factor, FLift(\v -> {
		TransformMatrix(
			v.x,
			0.0,
			0.0,
			v.y,
			0.0,
			0.0
		)
	}));
}

frotate2transform(rotate : Transform<double>) -> Transform<TransformMatrix> {
	fselect(rotate, FLift(\v -> {
		cosv = cosinus(v);
		sinv = sinus(v);

		TransformMatrix(
			cosv,
			sinv,
			-sinv,
			cosv,
			0.0,
			0.0
		)
	}));
}

fpointfactor2transform(point : Transform<Point>, factor : Transform<Factor>) -> Transform<TransformMatrix> {
	fselect2(point, factor, FLift2(\p, f -> {
		TransformMatrix(
			f.x,
			0.0,
			0.0,
			f.y,
			p.x,
			p.y
		)
	}));
}

fworldtransform(parent : Transform<TransformMatrix>, child : Transform<TransformMatrix>) -> Transform<TransformMatrix> {
	fselect2(parent, child, FLift2(\pt, lt -> {
		TransformMatrix(
			(lt.a * pt.a) + (lt.b * pt.c),
			(lt.a * pt.b) + (lt.b * pt.d),
			(lt.c * pt.a) + (lt.d * pt.c),
			(lt.c * pt.b) + (lt.d * pt.d),
			(lt.tx * pt.a) + (lt.ty * pt.c) + pt.tx,
			(lt.tx * pt.b) + (lt.ty * pt.d) + pt.ty
		)
	}));
}

fwh2bounds(wh : Transform<WidthHeight>) -> Transform<Bounds> {
	fselect(wh, FLift(\v -> Bounds(0., 0., v.width, v.height)));
}

fapplytransform(box : Transform<WidthHeight>, tm : Transform<TransformMatrix>) -> Transform<Bounds> {
	fselect2(box, tm, FLift2(\wh, t -> Bounds(t.tx, t.ty, wh.width * t.a + wh.height * t.c + t.tx, wh.width * t.b + wh.height * t.d + t.ty)));
}

fboundscrop(b1 : Transform<Bounds>, b2 : Transform<Bounds>) -> Transform<Bounds> {
	if (b1 == const(zeroBounds)) {
		b2;
	} else if (b2 == const(zeroBounds)) {
		b1;
	} else {
		fselect2(b1, b2, FLift2(\v1, v2 -> Bounds(max(v1.minX, v2.minX), max(v1.minY, v2.minY), min(v1.maxX, v2.maxX), min(v1.maxY, v2.maxY))));
	}
}

fboundsoverlap(b1 : Transform<Bounds>, b2 : Transform<Bounds>) -> Transform<bool> {
	if (b1 == const(zeroBounds) || b2 == const(zeroBounds)) {
		const(true)
	} else {
		fselect2(b1, b2, FLift2(\v1, v2 -> {
			max(v1.minX, v1.maxX) >= min(v2.minX, v2.maxX) &&
				min(v1.minX, v1.maxX) <= max(v2.minX, v2.maxX) &&
				max(v1.minY, v1.maxY) >= min(v2.minY, v2.maxY) &&
				min(v1.minY, v1.maxY) <= max(v2.minY, v2.maxY)
		}));
	}
}

fIsSome(b : Transform<Maybe<?>>) -> Transform<bool> {
	fselect(b, FLift(isSome));
}

fIsNone(b : Transform<Maybe<?>>) -> Transform<bool> {
	fselect(b, FLift(isNone));
}

fFirstOfPair(b : Transform<Pair<?, ??>>) -> Transform<?> {
	fselect(b, FLift(\p : Pair<?, ??> -> p.first))
}

fSecondOfPair(b : Transform<Pair<?, ??>>) -> Transform<??> {
	fselect(b, FLift(\p : Pair<?, ??> -> p.second))
}

feq2(a : Transform<?>, b : Transform<?>) -> Transform<bool> {
	fselect2(a, b, FLift2(\v1, v2 -> v1 == v2))
}

fneq2(a : Transform<?>, b : Transform<?>) -> Transform<bool> {
	fnot(feq2(a, b))
}

fFoldBool(a : [Transform<bool>], def : bool, fn : (Transform<bool>, Transform<bool>) -> Transform<bool>) -> Transform<bool> {
	l = length(a);
	if (l == 0) const(def)
	else if (l == 1) a[0]
	else if (l == 2) fn(a[0], a[1])
	else {
		half = l / 2;
		fn(fFoldBool(take(a, half), def, fn), fFoldBool(tailFrom(a, half), def, fn))
	}
}

fands(a : [Transform<bool>], def : bool) -> Transform<bool> {
	fFoldBool(a, def, fand);
}

fOrs(a : [Transform<bool>], def : bool) -> Transform<bool> {
	fFoldBool(a, def, fOr);
}

ftriple(v1 : Transform<?>, v2 : Transform<??>, v3 : Transform<???>) -> Transform<Triple<?, ??, ???>> {
	fselect3(v1, v2, v3, \a1, a2, a3 -> Triple(a1, a2, a3));
}

fquadruple(v1 : Transform<?>, v2 : Transform<??>, v3 : Transform<???>, v4 : Transform<????>) -> Transform<Quadruple<?, ??, ???, ????>> {
	fselect4(v1, v2, v3, v4, \a1, a2, a3, a4 -> Quadruple(a1, a2, a3, a4));
}

fsome(b : Transform<??>) -> Transform<Some<??>> {
	fselect(b, FLift(\v -> Some(v)));
}

fmaybeBind(b : Transform<Maybe<?>>, fn : (?) -> Maybe<??>) -> Transform<Maybe<??>> {
	fselect(b, FLift(\v -> maybeBind(v, fn)));
}

fmaybeMap(b : Transform<Maybe<?>>, fn : (?) -> ??) -> Transform<Maybe<??>> {
	fmaybeBind(b, \v -> Some(fn(v)));
}

fsubmaybeBind(b : Transform<Maybe<?>>, fn : (?) -> Transform<Maybe<??>>) -> Transform<Maybe<??>> {
	fsubselect(b, FLift(\v -> eitherMap(v, fn, const(None()))));
}

fsubmaybeMap(b : Transform<Maybe<?>>, fn : (?) -> Transform<??>) -> Transform<Maybe<??>> {
	fsubselect(b, FLift(\v -> eitherMap(v, \v0 -> fselect(fn(v0), FLift(\v1 -> Some(v1))), const(None()))));
}

forder(b : Transform<[?]>, order : Transform<[int]>) -> Transform<[?]> {
	fselect2(b, order, FLift2(\v, o -> fold(o, [], \acc, i -> if (i >= 0 && i < length(v)) arrayPush(acc, v[i]) else acc)))
}

// For debug purposes

fpprint(title : string) -> (Transform<?>) -> Transform<?> {
	\tr -> {
		fsubscribe(tr, \v -> pprint(title)(v) |> ignore);
		tr
	}
}
