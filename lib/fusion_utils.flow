import fusion;
import math/transformmatrix;
import ds/array_diff;

export {
	fi2d(i : Transform<int>) -> Transform<double>;

	fmap(a : Transform<[??]>, fn : (??) -> ?) -> Transform<[?]>;
	fmapu(a : Transform<[??]>, fn : (??) -> Pair<?, [() -> void]>) -> Transform<[?]>;
	fmapi(a : Transform<[??]>, fn : (int, ??) -> ?) -> Transform<[?]>;
	fmapiu(a : Transform<[??]>, fn : (Transform<int>, ??) -> Pair<?, [() -> void]>) -> Transform<[?]>;

	fiteriu(a : Transform<[??]>, fn : (Transform<int>, ??) -> [() -> void]) -> () -> void;

	fsubmap(a : Transform<[??]>, fn : (??) -> Transform<?>) -> Transform<[?]>;
	fsubmapi(a : Transform<[??]>, fn : (Transform<int>, ??) -> Transform<?>) -> Transform<[?]>;

	ffold(a : Transform<[??]>, def : ?, fn : (?, ??) -> ?) -> Transform<?>;
	ffoldi(a : Transform<[??]>, def : ?, fn : (int, ?, ??) -> ?) -> Transform<?>;

	ffilter(a : Transform<[?]>, fn : (?) -> bool) -> Transform<[?]>;
	ffiltermap(a : Transform<[??]>, fn : (??) -> Maybe<?>) -> Transform<[?]>;
	ffiltermapi(a : Transform<[??]>, fn : (int, ??) -> Maybe<?>) -> Transform<[?]>;

	fsubfilter(a : Transform<[?]>, fn : (?) -> Transform<bool>) -> Transform<[?]>;
	fsubfiltermap(a : Transform<[??]>, fn : (??) -> Transform<Maybe<?>>) -> Transform<[?]>;
	fsubfiltermapi(a : Transform<[??]>, fn : (Transform<int>, ??) -> Transform<Maybe<?>>) -> Transform<[?]>;

	flength(a : Transform<[?]>) -> Transform<int>;
	fsubrange(a : Transform<[?]>, from : Transform<int>, to : Transform<int>) -> Transform<[?]>;
	felementAt(a : Transform<[?]>, idx : Transform<int>, def : Transform<?>) -> Transform<?>;

	fsplit2d(a : Transform<[[?]]>) -> Transform<[Transform<[?]>]>;

	fpointaddition(p1 : Transform<Point>, p2 : Transform<Point>) -> Transform<Point>;
	fpointsubtract(p1 : Transform<Point>, p2 : Transform<Point>) -> Transform<Point>;
	fpointmultiply(p1 : Transform<Point>, p2 : Transform<Point>) -> Transform<Point>;
	fpointdivide(p1 : Transform<Point>, p2 : Transform<Point>) -> Transform<Point>;

	fwhaddition(wh1 : Transform<WidthHeight>, wh2 : Transform<WidthHeight>) -> Transform<WidthHeight>;
	fwhsubtract(wh1 : Transform<WidthHeight>, wh2 : Transform<WidthHeight>) -> Transform<WidthHeight>;
	fwhmultiply(wh1 : Transform<WidthHeight>, wh2 : Transform<WidthHeight>) -> Transform<WidthHeight>;
	fwhdivide(wh1 : Transform<WidthHeight>, wh2 : Transform<WidthHeight>) -> Transform<WidthHeight>;
	fwhmin(wh1 : Transform<WidthHeight>, wh2 : Transform<WidthHeight>) -> Transform<WidthHeight>;
	fwhmax(wh1 : Transform<WidthHeight>, wh2 : Transform<WidthHeight>) -> Transform<WidthHeight>;

	fwidthaddition(wh : Transform<WidthHeight>, width : Transform<double>) -> Transform<WidthHeight>;
	fwidthsubtract(wh : Transform<WidthHeight>, width : Transform<double>) -> Transform<WidthHeight>;
	fheightaddition(wh : Transform<WidthHeight>, height : Transform<double>) -> Transform<WidthHeight>;
	fheightsubtract(wh : Transform<WidthHeight>, height : Transform<double>) -> Transform<WidthHeight>;

	fpoint2transform(point : Transform<Point>) -> Transform<TransformMatrix>;
	fx2transform(x : Transform<double>) -> Transform<TransformMatrix>;
	fy2transform(y : Transform<double>) -> Transform<TransformMatrix>;
	ffactor2transform(factor : Transform<Factor>) -> Transform<TransformMatrix>;
	frotate2transform(rotate : Transform<double>) -> Transform<TransformMatrix>; // In degrees

	fpointfactor2transform(point : Transform<Point>, factor : Transform<Factor>) -> Transform<TransformMatrix>;
	fworldtransform(parent : Transform<TransformMatrix>, child : Transform<TransformMatrix>) -> Transform<TransformMatrix>;
	finverttransform(transform : Transform<TransformMatrix>) -> Transform<TransformMatrix>;

	fwh2bounds(wh : Transform<WidthHeight>) -> Transform<Bounds>;
	fapplytransform(wh : Transform<WidthHeight>, t : Transform<TransformMatrix>) -> Transform<Bounds>;
	fboundsapplytransform(bounds : Transform<Bounds>, tm : Transform<TransformMatrix>) -> Transform<Bounds>;
	fboundscrop(b1 : Transform<Bounds>, b2 : Transform<Bounds>) -> Transform<Bounds>;
	fboundsoverlap(b1 : Transform<Bounds>, b2 : Transform<Bounds>) -> Transform<bool>;
	flocalbounds(bounds : Transform<Bounds>, tm : Transform<TransformMatrix>) -> Transform<Bounds>;

	fIsSome(b : Transform<Maybe<?>>) -> Transform<bool>;
	fIsNone(b : Transform<Maybe<?>>) -> Transform<bool>;
	fifsome(b1 : Transform<Maybe<??>>, then1 : Transform<?>, else1 : Transform<?>)  -> Transform<?>;

	fFirstOfPair(b : Transform<Pair<?, ??>>) -> Transform<?>;
	fSecondOfPair(b : Transform<Pair<?, ??>>) -> Transform<??>;

	feq2(a : Transform<?>, b : Transform<?>) -> Transform<bool>;
	fneq2(a : Transform<?>, b : Transform<?>) -> Transform<bool>;

	fands(a : [Transform<bool>], def : bool) -> Transform<bool>;
	fOrs(a : [Transform<bool>], def : bool) -> Transform<bool>;

	ftriple(v1 : Transform<?>, v2 : Transform<??>, v3 : Transform<???>) -> Transform<Triple<?, ??, ???>>;
	fquadruple(v1 : Transform<?>, v2 : Transform<??>, v3 : Transform<???>, v4 : Transform<????>) -> Transform<Quadruple<?, ??, ???, ????>>;

	fsome(b : Transform<??>) -> Transform<Some<??>>;

	feither(b : Transform<Maybe<?>>, alternative : Transform<?>) -> Transform<?>;

	feitherMap(b : Transform<Maybe<?>>, fn : (?) -> ??, alternative : Transform<??>) -> Transform<??>;
	feitherFn(b : Transform<Maybe<?>>, fn : (?) -> ??, alternative : () -> ??) -> Transform<??>;

	fsubeitherMap(b : Transform<Maybe<?>>, fn : (?) -> Transform<??>, alternative : Transform<??>) -> Transform<??>;
	fsubeitherFn(b : Transform<Maybe<?>>, fn : (?) -> Transform<??>, alternative : () -> Transform<??>) -> Transform<??>;

	fmaybeBind(b : Transform<Maybe<?>>, fn : (?) -> Maybe<??>) -> Transform<Maybe<??>>;
	fmaybeMap(b : Transform<Maybe<?>>, fn : (?) -> ??) -> Transform<Maybe<??>>;

	fsubmaybeBind(b : Transform<Maybe<?>>, fn : (?) -> Transform<Maybe<??>>) -> Transform<Maybe<??>>;
	fsubmaybeMap(b : Transform<Maybe<?>>, fn : (?) -> Transform<??>) -> Transform<Maybe<??>>;

	forder(b : Transform<[?]>, order : Transform<[int]>) -> Transform<[?]>;
	fdeorder(b : Transform<[?]>, order : Transform<[int]>) -> Transform<[?]>;

	fpprint(title : string) -> (Transform<?>) -> Transform<?>;

	ffuse(t : Transform<?>) -> Pair<Behaviour<?>, [() -> () -> void]>;
	applyallsubs(array : [() -> () -> void]) -> [() -> void];

	fselectdelay(b : Transform<?>, fn : (?) -> int) -> Transform<?>;
	fdelayUntilNextFrameRendered(b : Transform<?>) -> Transform<?>;
	fthrottleUntilNextFrameRendered(b : Transform<?>) -> Transform<?>;
	flerp(start : double, end : double, t : Transform<double>) -> Transform<double>;

	flookupTree(tree : Transform<Tree<?, ??>>, key : Transform<?>) -> Transform<Maybe<??>>;
	fremoveFromTree(tree : Transform<Tree<?, ??>>, key : Transform<?>) -> Transform<Tree<?, ??>>;

	fextractStruct(a : Transform<[?]>, e : Transform<??>) -> Transform<??>;

	// Advised dispose helpers
	initUnsM() -> ref Maybe<() -> void>;
	setUnsM(uns : ref Maybe<() -> void>, v : () -> void) -> void;
	dispUnsM(uns : ref Maybe<() -> void>) -> void;

	fselectLift(b : Transform<??>, fn : (??) -> ?) -> Transform<?>;
	fselect2Lift(b1 : Transform<??>, b2 : Transform<???>, fn : (??, ???) -> ?) -> Transform<?>;
}

ARRAY_DIFF_TRESHOLD = 400;

fi2d(i : Transform<int>) -> Transform<double> {
	fselect(i, i2d |> FLift);
}

fmap(a : Transform<[??]>, fn : (??) -> ?) -> Transform<[?]> {
	if (isFConst(a)) {
		const(map(fgetValue(a), fn));
	} else {
		input = ref [];
		output = ref [];

		fselect(a, FLift(\a0 -> {
			if (length(a0) == 0) {
				output := [];
			} else if (length(a0) < ARRAY_DIFF_TRESHOLD && length(^input) > 0 && length(^input) < ARRAY_DIFF_TRESHOLD) {
				iter(arrayDiff(^input, a0, false), \op ->
					switch (op : ArrayOperation) {
						ArrayNop(__, __): {}
						ArrayInsert(x, __, v): {
							output := insertArray(^output, x, fn(v));
						}
						ArrayReplace(x, __, v): {
							output := replace(^output, x, fn(v));
						}
						ArrayRemove(x, __): {
							output := removeIndex(^output, x);
						}
					}
				);
			} else {
				output := map(a0, fn);
			}

			input := a0;
			^output;
		}));
	}
}

fmapu(a : Transform<[??]>, fn : (??) -> Pair<?, [() -> void]>) -> Transform<[?]> {
	if (isFConst(a)) {
		fmapu(make(fgetValue(a)), fn);
	} else {
		nested = ref false;
		input = ref [];
		output = ref [];
		disposers = ref [];

		fdisposable(
			fselect(a, FLift(\a0 -> {
				if (!^nested) {
					nested := true;

					if (length(a0) == 0) {
						iter(^disposers, applyall);

						output := [];
						disposers := [];
					} else if (length(a0) < ARRAY_DIFF_TRESHOLD && length(^input) > 0 && length(^input) < ARRAY_DIFF_TRESHOLD) {
						// Call disposers before initializers
						filtermap(arrayDiff(^input, a0, false), \op ->
							switch (op : ArrayOperation) {
								ArrayNop(x, y): {
									None();
								}
								ArrayInsert(x, y, v): {
									disposers := insertArray(^disposers, x, []);

									Some(\ -> {
										d = fn(v);

										output := insertArray(^output, x, d.first);
										disposers := replace(^disposers, y, d.second);
									});
								}
								ArrayReplace(x, y, v): {
									if (length(^disposers) > x) {
										applyall(^disposers[x]);
									}

									Some(\ -> {
										d = fn(v);

										output := replace(^output, x, d.first);
										disposers := replace(^disposers, y, d.second);
									});
								}
								ArrayRemove(x, y): {
									if (length(^disposers) > x) {
										applyall(^disposers[x]);
									}

									disposers := removeIndex(^disposers, x);

									Some(\ -> {
										output := removeIndex(^output, x);
									});
								}
							}
						)
						|> applyall;
					} else {
						iter(^disposers, applyall);

						d = map(a0, fn);

						output := map(d, firstOfPair);
						disposers := map(d, secondOfPair);
					}

					input := a0;
					nested := false;
				}

				^output;
			})),
			\ -> {
				nested := true;
				iter(^disposers, applyall);

				input := [];
				output := [];
				disposers := [];
				nested := false;
			}
		);
	}
}

fmapi(a : Transform<[??]>, fn : (int, ??) -> ?) -> Transform<[?]> {
	if (isFConst(a)) {
		const(mapi(fgetValue(a), fn));
	} else {
		input = ref [];
		output = ref [];

		fselect(a, FLift(\a0 -> {
			if (length(a0) == 0) {
				output := [];
			} else if (length(a0) < ARRAY_DIFF_TRESHOLD && length(^input) > 0 && length(^input) < ARRAY_DIFF_TRESHOLD) {
				iter(arrayDiff(^input, a0, true), \op -> {
					switch (op : ArrayOperation) {
						ArrayNop(x, y): {
							if (x != y) {
								output := replace(^output, x, fn(y, ^input[x]));
							}
						}
						ArrayInsert(x, y, v): {
							output := insertArray(^output, x, fn(y, v));
						}
						ArrayReplace(x, y, v): {
							output := replace(^output, x, fn(y, v));
						}
						ArrayRemove(x, y): {
							output := removeIndex(^output, x);
						}
					}
				});
			} else {
				output := mapi(a0, fn);
			}

			input := a0;
			^output;
		}));
	}
}

fmapiu(a : Transform<[??]>, fn : (Transform<int>, ??) -> Pair<?, [() -> void]>) -> Transform<[?]> {
	if (isFConst(a)) {
		fmapiu(make(fgetValue(a)), fn);
	} else {
		nested = ref false;
		input = ref [];
		output = ref [];
		disposers = ref [];
		indexes = ref [];

		fdisposable(
			fselect(a, FLift(\a0 -> {
				if (!^nested) {
					nested := true;

					if (length(a0) == 0) {
						iter(^disposers, applyall);

						disposers := [];
						output := [];
						indexes := [];
					} else if (length(a0) < ARRAY_DIFF_TRESHOLD && length(^input) > 0 && length(^input) < ARRAY_DIFF_TRESHOLD) {
						// Call disposers before initializers
						filtermap(arrayDiff(^input, a0, true), \op ->
							switch (op : ArrayOperation) {
								ArrayNop(x, y): {
									if (x != y) {
										Some(\ -> {
											nextDistinct(^indexes[x], y);
										});
									} else {
										None();
									}
								}
								ArrayInsert(x, y, v): {
									disposers := insertArray(^disposers, x, []);

									Some(\ -> {
										index = make(y);
										d = fn(index, v);

										indexes := insertArray(^indexes, x, index);
										output := insertArray(^output, x, d.first);
										disposers := replace(^disposers, y, d.second);
									});
								}
								ArrayReplace(x, y, v): {
									if (length(^disposers) > x) {
										applyall(^disposers[x]);
									}

									Some(\ -> {
										index = ^indexes[x];
										nextDistinct(index, y);
										d = fn(index, v);

										output := replace(^output, x, d.first);
										disposers := replace(^disposers, y, d.second);
									});
								}
								ArrayRemove(x, y): {
									if (length(^disposers) > x) {
										applyall(^disposers[x]);
									}

									disposers := removeIndex(^disposers, x);

									Some(\ -> {
										indexes := removeIndex(^indexes, x);
										output := removeIndex(^output, x);
									});
								}
							}
						)
						|> applyall;
					} else {
						iter(^disposers, applyall);

						d = mapi(a0, \i, v -> {
							index = make(i);
							indexes := replace(^indexes, i, index);

							fn(index, v);
						});

						output := map(d, firstOfPair);
						disposers := map(d, secondOfPair);
					}

					input := a0;
					nested := false;
				}

				^output;
			})),
			\ -> {
				nested := true;
				iter(^disposers, applyall);

				input := [];
				output := [];
				disposers := [];
				indexes := [];
				nested := false;
			}
		);
	}
}

fiteriu(a : Transform<[??]>, fn : (Transform<int>, ??) -> [() -> void]) -> () -> void {
	makeSubscribe(fmapiu(a, \i, v -> Pair(false, fn(i, v))), nop1)();
}

fsubmap(a : Transform<[??]>, fn : (??) -> Transform<?>) -> Transform<[?]> {
	if (isFConst(a)) {
		map(fgetValue(a), fn)
		|> fmerge
	} else {
		nested = ref false;
		input = ref [];
		output = make([]);
		disposers = ref [];
		indexes = ref [];
		newOutput = ref [];
		isNopFnsApplying = make(false);

		fdisposable(
			fsubselect(a, FLift(\a0 -> {
				if (!^nested) {
					nested := true;
					newOutput := getValue(output);

					if (length(a0) == 0) {
						applyall(^disposers);

						disposers := [];
						indexes := [];
						newOutput := [];
					} else if (length(a0) < ARRAY_DIFF_TRESHOLD && length(^input) > 0 && length(^input) < ARRAY_DIFF_TRESHOLD) {
						nopFns = ref [];

						// Call disposers before initializers
						filtermap(arrayDiff(^input, a0, true), \op ->
							switch (op : ArrayOperation) {
								ArrayNop(x, y): {
									if (x != y) {
										Some(\ -> {
											i = ^indexes[x];
											refArrayPush(nopFns, \ -> nextDistinct(i, y));
										});
									} else {
										None();
									}
								}
								ArrayInsert(x, y, v): {
									disposers := insertArray(^disposers, x, nop);

									Some(\ -> {
										index = make(y);
										d = fn(v);

										indexes := insertArray(^indexes, x, index);
										disposers :=
											replace(
												^disposers,
												y,
												makeSubscribe2(d, \v0 ->
													if (getValue(isNopFnsApplying))
														newOutput := replace(^newOutput, getValue(index), v0)
													else
														next(output, replace(getValue(output), getValue(index), v0))
												)()
											);
										newOutput := insertArray(^newOutput, x, fgetValue(d));
									});
								}
								ArrayReplace(x, y, v): {
									if (length(^disposers) > x) {
										^disposers[x]();
									}

									Some(\ -> {
										index = ^indexes[x];
										nextDistinct(index, y);
										d = fn(v);

										disposers :=
											replace(
												^disposers,
												y,
												makeSubscribe2(d, \v0 ->
													if (getValue(isNopFnsApplying))
														newOutput := replace(^newOutput, getValue(index), v0)
													else
														next(output, replace(getValue(output), getValue(index), v0))
												)()
											);
										newOutput := replace(^newOutput, x, fgetValue(d));
									});
								}
								ArrayRemove(x, y): {
									if (length(^disposers) > x) {
										^disposers[x]();
									}

									disposers := removeIndex(^disposers, x);

									Some(\ -> {
										indexes := removeIndex(^indexes, x);
										newOutput := removeIndex(^newOutput, x);
									});
								}
							}
						)
						|> applyall;

						next(isNopFnsApplying, true);
						applyall(^nopFns);
						next(isNopFnsApplying, false);
					} else {
						applyall(^disposers);

						d = map(a0, fn);

						disposers := mapi(d, \i, v -> {
							index = make(i);
							indexes := replace(^indexes, i, index);

							makeSubscribe2(v, \v0 ->
								if (getValue(isNopFnsApplying))
									newOutput := replace(^newOutput, getValue(index), v0)
								else
									next(output, replace(getValue(output), getValue(index), v0))
							)();
						});

						newOutput := map(d, fgetValue);
					}

					next(output, ^newOutput);

					input := a0;
					nested := false;
				}

				output;
			})),
			\ -> {
				nested := true;
				applyall(^disposers);

				input := [];
				next(output, []);
				disposers := [];
				indexes := [];
				nested := false;
			}
		);
	}
}

fsubmapi(a : Transform<[??]>, fn : (Transform<int>, ??) -> Transform<?>) -> Transform<[?]> {
	if (isFConst(a)) {
		mapi(fgetValue(a), \i, v -> fn(const(i), v))
		|> fmerge
	} else {
		nested = ref false;
		input = ref [];
		output = make([]);
		disposers = ref [];
		indexes = ref [];
		newOutput = ref [];
		isNopFnsApplying = make(false);

		fdisposable(
			fsubselect(a, FLift(\a0 -> {
				if (!^nested) {
					nested := true;
					newOutput := getValue(output);

					if (length(a0) == 0) {
						applyall(^disposers);

						disposers := [];
						newOutput := [];
						indexes := [];
					} else if (length(a0) < ARRAY_DIFF_TRESHOLD && length(^input) > 0 && length(^input) < ARRAY_DIFF_TRESHOLD) {
						nopFns = ref [];

						// Call disposers before initializers
						filtermap(arrayDiff(^input, a0, true), \op ->
							switch (op : ArrayOperation) {
								ArrayNop(x, y): {
									if (x != y) {
										Some(\ -> {
											i = ^indexes[x];
											refArrayPush(nopFns, \ -> nextDistinct(i, y));
										});
									} else {
										None();
									}
								}
								ArrayInsert(x, y, v): {
									disposers := insertArray(^disposers, x, nop);

									Some(\ -> {
										index = make(y);
										d = fn(index, v);

										indexes := insertArray(^indexes, x, index);
										disposers :=
											replace(
												^disposers,
												y,
												makeSubscribe2(d, \v0 ->
													if (getValue(isNopFnsApplying))
														newOutput := replace(^newOutput, getValue(index), v0)
													else
														next(output, replace(getValue(output), getValue(index), v0))
												)()
											);
										newOutput := insertArray(^newOutput, x, fgetValue(d));
									});
								}
								ArrayReplace(x, y, v): {
									if (length(^disposers) > x) {
										^disposers[x]();
									}

									Some(\ -> {
										index = ^indexes[x];
										nextDistinct(index, y);
										d = fn(index, v);

										disposers :=
											replace(
												^disposers,
												y,
												makeSubscribe2(d, \v0 ->
													if (getValue(isNopFnsApplying))
														newOutput := replace(^newOutput, getValue(index), v0)
													else
														next(output, replace(getValue(output), getValue(index), v0))
												)()
											);
										newOutput := replace(^newOutput, x, fgetValue(d));
									});
								}
								ArrayRemove(x, y): {
									if (length(^disposers) > x) {
										^disposers[x]();
									}

									disposers := removeIndex(^disposers, x);

									Some(\ -> {
										indexes := removeIndex(^indexes, x);
										newOutput := removeIndex(^newOutput, x);
									});
								}
							}
						)
						|> applyall;

						next(isNopFnsApplying, true);
						applyall(^nopFns);
						next(isNopFnsApplying, false);
					} else {
						applyall(^disposers);

						d = mapi(a0, \i, v -> {
							index = make(i);
							indexes := replace(^indexes, i, index);

							fn(index, v);
						});

						disposers := mapi(d, \i, v -> {
							index = ^indexes[i];
							makeSubscribe2(v, \v0 ->
								if (getValue(isNopFnsApplying))
									newOutput := replace(^newOutput, getValue(index), v0)
								else
									next(output, replace(getValue(output), getValue(index), v0))
							)()
						});

						newOutput := map(d, fgetValue);
					}

					next(output, ^newOutput);

					input := a0;
					nested := false;
				}

				output;
			})),
			\ -> {
				nested := true;
				applyall(^disposers);

				input := [];
				next(output, []);
				disposers := [];
				indexes := [];
				nested := false;
			}
		);
	}
}

ffold(a : Transform<[??]>, def : ?, fn : (?, ??) -> ?) -> Transform<?> {
	if (isFConst(a)) {
		const(fold(fgetValue(a), def, fn));
	} else {
		nested = ref false;
		input = ref [];
		output : ref [Pair<?, ?>] = ref [];

		fselect(a, FLift(\a0 -> {
			if (!^nested) {
				nested := true;

				if (length(a0) == 0) {
					output := [];
				} else if (length(a0) < ARRAY_DIFF_TRESHOLD && length(^input) > 0 && length(^input) < ARRAY_DIFF_TRESHOLD) {
					// Call disposers before initializers
					iter(arrayDiff(^input, a0, true) |> reverseA, \op ->
						switch (op : ArrayOperation) {
							ArrayNop(x, y): {
								acc = if (y > 0) (^output[y - 1]).second else def;
								if (^output[y].first != acc) {
									output := replace(^output, y, Pair(acc, fn(acc, a0[y])));
								}
							}
							ArrayInsert(x, y, v): {
								acc = if (y > 0) (^output[y - 1]).second else def;
								output := insertArray(^output, y, Pair(acc, fn(acc, v)));
							}
							ArrayReplace(x, y, v): {
								acc = if (y > 0) (^output[y - 1]).second else def;
								output := replace(^output, y, Pair(acc, fn(acc, v)));
							}
							ArrayRemove(x, y): {
								output := removeIndex(^output, y);
							}
						}
					);
				} else {
					output :=
						fold(a0, Pair(def, []), \acc : Pair<?, [Pair<?, ?>]>, v : ?? -> {
							newAcc = fn(acc.first, v);
							Pair(newAcc, arrayPush(acc.second, Pair(acc.first, newAcc)));
						}).second;
				}

				input := a0;
				nested := false;
			}

			if (length(^output) > 0) {
				^output[length(^output) - 1].second;
			} else {
				def;
			}
		}))
	}
}

ffoldi(a : Transform<[??]>, def : ?, fn : (int, ?, ??) -> ?) -> Transform<?> {
	if (isFConst(a)) {
		const(foldi(fgetValue(a), def, fn));
	} else {
		nested = ref false;
		input = ref [];
		output : ref [Pair<?, ?>] = ref [];

		fselect(a, FLift(\a0 -> {
			if (!^nested) {
				nested := true;

				if (length(a0) == 0) {
					output := [];
				} else if (length(a0) < ARRAY_DIFF_TRESHOLD && length(^input) < ARRAY_DIFF_TRESHOLD) {
					// Call disposers before initializers
					iter(arrayDiff(^input, a0, true) |> reverseA, \op ->
						switch (op : ArrayOperation) {
							ArrayNop(x, y): {
								acc = if (y > 0) (^output[y - 1]).second else def;
								if (^output[y].first != acc) {
									output := replace(^output, y, Pair(acc, fn(y, acc, a0[y])));
								}
							}
							ArrayInsert(x, y, v): {
								acc = if (y > 0) (^output[y - 1]).second else def;
								output := insertArray(^output, y, Pair(acc, fn(y, acc, v)));
							}
							ArrayReplace(x, y, v): {
								acc = if (y > 0) (^output[y - 1]).second else def;
								output := replace(^output, y, Pair(acc, fn(y, acc, v)));
							}
							ArrayRemove(x, y): {
								output := removeIndex(^output, y);
							}
						}
					);
				} else {
					output :=
						foldi(a0, Pair(def, []), \y : int, acc : Pair<?, [Pair<?, ?>]>, v : ?? -> {
							newAcc = fn(y, acc.first, v);
							Pair(newAcc, arrayPush(acc.second, Pair(acc.first, newAcc)));
						}).second;
				}

				input := a0;
				nested := false;
			}

			if (length(^output) > 0) {
				^output[length(^output) - 1].second;
			} else {
				def;
			}
		}))
	}
}

ffilter(v : Transform<[?]>, fn : (?) -> bool) -> Transform<[?]> {
	ffiltermap(v, \vv -> if (fn(vv)) Some(vv) else None());
}

ffiltermap(v : Transform<[??]>, fn : (??) -> Maybe<?>) -> Transform<[?]> {
	fselect(fmap(v, fn), FLift(\vv -> filtermap(vv, idfn)));
}

ffiltermapi(v : Transform<[??]>, fn : (int, ??) -> Maybe<?>) -> Transform<[?]> {
	fselect(fmapi(v, fn), FLift(\vv -> filtermap(vv, idfn)));
}

fsubfilter(v : Transform<[?]>, fn : (?) -> Transform<bool>) -> Transform<[?]> {
	fsubfiltermap(v, \vv -> fif(fn(vv), const(Some(vv)), const(None())));
}

fsubfiltermap(v : Transform<[??]>, fn : (??) -> Transform<Maybe<?>>) -> Transform<[?]> {
	fselect(fsubmap(v, fn), FLift(\vv -> filtermap(vv, idfn)));
}

fsubfiltermapi(v : Transform<[??]>, fn : (Transform<int>, ??) -> Transform<Maybe<?>>) -> Transform<[?]> {
	fselect(fsubmapi(v, fn), FLift(\vv -> filtermap(vv, idfn)));
}

flength(v : Transform<[?]>) -> Transform<int> {
	fselect(v, FLift(length))
}

fsubrange(a : Transform<[?]>, from : Transform<int>, to : Transform<int>) -> Transform<[?]> {
	fselect3(a, from, to, \aa, f, t -> subrange(aa, f, t));
}

felementAt(a : Transform<[?]>, idx : Transform<int>, def : Transform<?>) -> Transform<?> {
	fselect3(a, idx, def, \v, i, d -> elementAt(v, i, d))
}

fsplit2d(a : Transform<[[?]]>) -> Transform<[Transform<[?]>]> {
	if (isFConst(a)) {
		const(map(fgetValue(a), const));
	} else {
		input = ref [];
		output : ref [DynamicBehaviour<[?]>] = ref [];

		fselect(a, FLift(\a0 -> {
			if (length(a0) == 0) {
				output := [];
			} else if (length(a0) < ARRAY_DIFF_TRESHOLD && length(^input) > 0 && length(^input) < ARRAY_DIFF_TRESHOLD) {
				iter(arrayDiff(^input, a0, false), \op ->
					switch (op : ArrayOperation) {
						ArrayNop(__, __): {}
						ArrayInsert(x, __, v): {
							output := insertArray(^output, x, make(v));
						}
						ArrayReplace(x, __, v): {
							nextDistinct(^output[x], v);
						}
						ArrayRemove(x, __): {
							output := removeIndex(^output, x);
						}
					}
				);
			} else {
				output := map(a0, make);
			}

			input := a0;
			cast(^output : [DynamicBehaviour<[?]>] -> [Transform<[?]>]);
		}));
	}
}

fpointaddition(p1 : Transform<Point>, p2 : Transform<Point>) -> Transform<Point> {
	fselect2(p1, p2, FLift2(\v1, v2 -> Point(v1.x + v2.x, v1.y + v2.y)));
}

fpointsubtract(p1 : Transform<Point>, p2 : Transform<Point>) -> Transform<Point> {
	fselect2(p1, p2, FLift2(\v1, v2 -> Point(v1.x - v2.x, v1.y - v2.y)));
}

fpointmultiply(p1 : Transform<Point>, p2 : Transform<Point>) -> Transform<Point> {
	fselect2(p1, p2, FLift2(\v1, v2 -> Point(v1.x * v2.x, v1.y * v2.y)));
}

fpointdivide(p1 : Transform<Point>, p2 : Transform<Point>) -> Transform<Point> {
	fselect2(p1, p2, FLift2(\v1, v2 -> Point(v1.x / v2.x, v1.y / v2.y)));
}

fwhaddition(wh1 : Transform<WidthHeight>, wh2 : Transform<WidthHeight>) -> Transform<WidthHeight> {
	fselect2(wh1, wh2, FLift2(\v1, v2 -> WidthHeight(v1.width + v2.width, v1.height + v2.height)));
}

fwhsubtract(wh1 : Transform<WidthHeight>, wh2 : Transform<WidthHeight>) -> Transform<WidthHeight> {
	fselect2(wh1, wh2, FLift2(\v1, v2 -> WidthHeight(v1.width - v2.width, v1.height - v2.height)));
}

fwhmultiply(wh1 : Transform<WidthHeight>, wh2 : Transform<WidthHeight>) -> Transform<WidthHeight> {
	fselect2(wh1, wh2, FLift2(\v1, v2 -> WidthHeight(v1.width * v2.width, v1.height * v2.height)));
}

fwhdivide(wh1 : Transform<WidthHeight>, wh2 : Transform<WidthHeight>) -> Transform<WidthHeight> {
	fselect2(wh1, wh2, FLift2(\v1, v2 -> WidthHeight(v1.width / v2.width, v1.height / v2.height)));
}

fwhmin(wh1 : Transform<WidthHeight>, wh2 : Transform<WidthHeight>) -> Transform<WidthHeight> {
	fselect2(wh1, wh2, FLift2(\v1, v2 -> WidthHeight(min(v1.width, v2.width), min(v1.height, v2.height))));
}

fwhmax(wh1 : Transform<WidthHeight>, wh2 : Transform<WidthHeight>) -> Transform<WidthHeight> {
	fselect2(wh1, wh2, FLift2(\v1, v2 -> WidthHeight(max(v1.width, v2.width), max(v1.height, v2.height))));
}

fwidthaddition(wh : Transform<WidthHeight>, width : Transform<double>) -> Transform<WidthHeight> {
	fselect2(wh, width, FLift2(\v, wd -> WidthHeight(v.width + wd, v.height)));
}

fwidthsubtract(wh : Transform<WidthHeight>, width : Transform<double>) -> Transform<WidthHeight> {
	fselect2(wh, width, FLift2(\v, wd -> WidthHeight(v.width - wd, v.height)));
}

fheightaddition(wh : Transform<WidthHeight>, height : Transform<double>) -> Transform<WidthHeight> {
	fselect2(wh, height, FLift2(\v, hgt -> WidthHeight(v.width, v.height + hgt)));
}

fheightsubtract(wh : Transform<WidthHeight>, height : Transform<double>) -> Transform<WidthHeight> {
	fselect2(wh, height, FLift2(\v, hgt -> WidthHeight(v.width, v.height - hgt)));
}

fpoint2transform(point : Transform<Point>) -> Transform<TransformMatrix> {
	fselect(point, FLift(\v -> {
		TransformMatrix(
			1.0,
			0.0,
			0.0,
			1.0,
			v.x,
			v.y
		)
	}));
}

fx2transform(x : Transform<double>) -> Transform<TransformMatrix> {
	fselect(x, FLift(\v -> {
		TransformMatrix(
			1.0,
			0.0,
			0.0,
			1.0,
			v,
			0.0
		)
	}));
}

fy2transform(y : Transform<double>) -> Transform<TransformMatrix> {
	fselect(y, FLift(\v -> {
		TransformMatrix(
			1.0,
			0.0,
			0.0,
			1.0,
			0.0,
			v
		)
	}));
}

ffactor2transform(factor : Transform<Factor>) -> Transform<TransformMatrix> {
	fselect(factor, FLift(\v -> {
		TransformMatrix(
			v.x,
			0.0,
			0.0,
			v.y,
			0.0,
			0.0
		)
	}));
}

frotate2transform(rotate : Transform<double>) -> Transform<TransformMatrix> {
	fselect(rotate, FLift(\v -> {
		cosv = cosinus(v);
		sinv = sinus(v);

		TransformMatrix(
			cosv,
			sinv,
			-sinv,
			cosv,
			0.0,
			0.0
		)
	}));
}

fpointfactor2transform(point : Transform<Point>, factor : Transform<Factor>) -> Transform<TransformMatrix> {
	fselect2(point, factor, FLift2(\p, f -> {
		TransformMatrix(
			f.x,
			0.0,
			0.0,
			f.y,
			p.x,
			p.y
		)
	}));
}

fworldtransform(parent : Transform<TransformMatrix>, child : Transform<TransformMatrix>) -> Transform<TransformMatrix> {
	fselect2(parent, child, FLift2(\pt, lt -> {
		TransformMatrix(
			(lt.a * pt.a) + (lt.b * pt.c),
			(lt.a * pt.b) + (lt.b * pt.d),
			(lt.c * pt.a) + (lt.d * pt.c),
			(lt.c * pt.b) + (lt.d * pt.d),
			(lt.tx * pt.a) + (lt.ty * pt.c) + pt.tx,
			(lt.tx * pt.b) + (lt.ty * pt.d) + pt.ty
		)
	}));
}

finverttransform(transform : Transform<TransformMatrix>) -> Transform<TransformMatrix> {
	fselect(transform, FLift(\tr -> {
		n = tr.a * tr.d - tr.b * tr.c;

		TransformMatrix(
			tr.d / n,
			-tr.b / n,
			-tr.c / n,
			tr.a / n,
			((tr.c * tr.ty) - (tr.d * tr.tx)) / n,
			-((tr.a * tr.ty) - (tr.b * tr.tx)) / n
		)
	}));
}

fwh2bounds(wh : Transform<WidthHeight>) -> Transform<Bounds> {
	fselect(wh, FLift(\v -> Bounds(0., 0., v.width, v.height)));
}

fapplytransform(box : Transform<WidthHeight>, tm : Transform<TransformMatrix>) -> Transform<Bounds> {
	fselect2(box, tm, FLift2(\wh, t -> Bounds(t.tx, t.ty, wh.width * t.a + wh.height * t.c + t.tx, wh.width * t.b + wh.height * t.d + t.ty)));
}

fboundsapplytransform(bounds : Transform<Bounds>, tm : Transform<TransformMatrix>) -> Transform<Bounds> {
	fselect2(bounds, tm, FLift2(\b, t ->
		Bounds(
			b.minX * t.a + b.minY * t.c + t.tx,
			b.minX * t.b + b.minY * t.d + t.ty,
			b.maxX * t.a + b.maxY * t.c + t.tx,
			b.maxX * t.b + b.maxY * t.d + t.ty
		)
	));
}

fboundscrop(b1 : Transform<Bounds>, b2 : Transform<Bounds>) -> Transform<Bounds> {
	if (b1 == const(zeroBounds)) {
		b2;
	} else if (b2 == const(zeroBounds)) {
		b1;
	} else {
		fselect2(b1, b2, FLift2(\v1, v2 -> Bounds(max(v1.minX, v2.minX), max(v1.minY, v2.minY), min(v1.maxX, v2.maxX), min(v1.maxY, v2.maxY))));
	}
}

fboundsoverlap(b1 : Transform<Bounds>, b2 : Transform<Bounds>) -> Transform<bool> {
	if (b1 == const(zeroBounds) || b2 == const(zeroBounds)) {
		const(true)
	} else {
		fselect2(b1, b2, FLift2(\v1, v2 -> {
			max(v1.minX, v1.maxX) >= min(v2.minX, v2.maxX) &&
				min(v1.minX, v1.maxX) <= max(v2.minX, v2.maxX) &&
				max(v1.minY, v1.maxY) >= min(v2.minY, v2.maxY) &&
				min(v1.minY, v1.maxY) <= max(v2.minY, v2.maxY)
		}))
	}
}

flocalbounds(bounds : Transform<Bounds>, tm : Transform<TransformMatrix>) -> Transform<Bounds> {
	fselect2(bounds, tm, FLift2(\b, t ->
		Bounds(
			(b.minX - t.tx) / t.a,
			(b.minY - t.ty) / t.d,
			(b.maxX - t.tx) / t.a,
			(b.maxY - t.ty) / t.d
		)
	));
}

fIsSome(b : Transform<Maybe<?>>) -> Transform<bool> {
	fselect(b, FLift(isSome));
}

fIsNone(b : Transform<Maybe<?>>) -> Transform<bool> {
	fselect(b, FLift(isNone));
}

fifsome(b1 : Transform<Maybe<??>>, then1 : Transform<?>, else1 : Transform<?>)  -> Transform<?> {
	fif(fIsSome(b1), then1, else1)
}

fFirstOfPair(b : Transform<Pair<?, ??>>) -> Transform<?> {
	fselect(b, FLift(\p : Pair<?, ??> -> p.first))
}

fSecondOfPair(b : Transform<Pair<?, ??>>) -> Transform<??> {
	fselect(b, FLift(\p : Pair<?, ??> -> p.second))
}

feq2(a : Transform<?>, b : Transform<?>) -> Transform<bool> {
	fselect2(a, b, FLift2(\v1, v2 -> v1 == v2))
}

fneq2(a : Transform<?>, b : Transform<?>) -> Transform<bool> {
	fnot(feq2(a, b))
}

fFoldBool(a : [Transform<bool>], def : bool, fn : (Transform<bool>, Transform<bool>) -> Transform<bool>) -> Transform<bool> {
	l = length(a);
	if (l == 0) const(def)
	else if (l == 1) a[0]
	else if (l == 2) fn(a[0], a[1])
	else {
		half = l / 2;
		fn(fFoldBool(take(a, half), def, fn), fFoldBool(tailFrom(a, half), def, fn))
	}
}

fands(a : [Transform<bool>], def : bool) -> Transform<bool> {
	fFoldBool(a, def, fand);
}

fOrs(a : [Transform<bool>], def : bool) -> Transform<bool> {
	fFoldBool(a, def, fOr);
}

ftriple(v1 : Transform<?>, v2 : Transform<??>, v3 : Transform<???>) -> Transform<Triple<?, ??, ???>> {
	fselect3(v1, v2, v3, \a1, a2, a3 -> Triple(a1, a2, a3));
}

fquadruple(v1 : Transform<?>, v2 : Transform<??>, v3 : Transform<???>, v4 : Transform<????>) -> Transform<Quadruple<?, ??, ???, ????>> {
	fselect4(v1, v2, v3, v4, \a1, a2, a3, a4 -> Quadruple(a1, a2, a3, a4));
}

fsome(b : Transform<??>) -> Transform<Some<??>> {
	fselect(b, FLift(\v -> Some(v)));
}

feither(b : Transform<Maybe<?>>, alternative : Transform<?>) -> Transform<?> {
	fsubselect(b, FLift(\v ->
		eitherMap(
			v,
			\v0 -> const(v0),
			alternative
		)
	));
}

feitherMap(b : Transform<Maybe<?>>, fn : (?) -> ??, alternative : Transform<??>) -> Transform<??> {
	fsubselect(b, FLift(\v ->
		eitherMap(
			v,
			\v0 -> const(fn(v0)),
			alternative
		)
	));
}

feitherFn(b : Transform<Maybe<?>>, fn : (?) -> ??, alternative : () -> ??) -> Transform<??> {
	fselect(b, FLift(\v ->
		eitherFn(
			v,
			fn,
			alternative
		)
	));
}

fsubeitherMap(b : Transform<Maybe<?>>, fn : (?) -> Transform<??>, alternative : Transform<??>) -> Transform<??> {
	fsubselect(b, FLift(\v ->
		eitherMap(
			v,
			fn,
			alternative
		)
	));
}

fsubeitherFn(b : Transform<Maybe<?>>, fn : (?) -> Transform<??>, alternative : () -> Transform<??>) -> Transform<??> {
	fsubselect(b, FLift(\v ->
		eitherFn(
			v,
			fn,
			alternative
		)
	));
}

fmaybeBind(b : Transform<Maybe<?>>, fn : (?) -> Maybe<??>) -> Transform<Maybe<??>> {
	fselect(b, FLift(\v -> maybeBind(v, fn)));
}

fmaybeMap(b : Transform<Maybe<?>>, fn : (?) -> ??) -> Transform<Maybe<??>> {
	fmaybeBind(b, \v -> Some(fn(v)));
}

fsubmaybeBind(b : Transform<Maybe<?>>, fn : (?) -> Transform<Maybe<??>>) -> Transform<Maybe<??>> {
	fsubselect(b, FLift(\v -> eitherMap(v, fn, const(None()))));
}

fsubmaybeMap(b : Transform<Maybe<?>>, fn : (?) -> Transform<??>) -> Transform<Maybe<??>> {
	fsubselect(b, FLift(\v -> eitherMap(v, \v0 -> fselect(fn(v0), FLift(\v1 -> Some(v1))), const(None()))));
}

forder(b : Transform<[?]>, order : Transform<[int]>) -> Transform<[?]> {
	fselect2(b, order, FLift2(\v, o -> fold(o, [], \acc, i -> if (i >= 0 && i < length(v)) arrayPush(acc, v[i]) else acc)))
}

fdeorder(b : Transform<[?]>, order : Transform<[int]>) -> Transform<[?]> {
	fselect2(b, order, FLift2(\v, o -> foldi(v, [], \i, acc, it -> {
		id = findiDef(o, \oi -> oi == i, -1);

		if (id >= 0 && id < length(v))
			arrayPush(acc, v[id])
		else
			acc;
	})))
}

ffuse(t : Transform<?>) -> Pair<Behaviour<?>, [() -> () -> void]> {
	switch (t) {
		ConstBehaviour(v): Pair(t, []);
		default: {
			b = make(fgetValue(t));

			Pair(b, [\ -> fconnect(t, b)])
		}
	}
}

applyallsubs(array : [() -> () -> void]) -> [() -> void] {
	map(array, apply0)
}

fselectdelay(b : Transform<?>, fn : (?) -> int) -> Transform<?> {
	provider : ref Maybe<DynamicBehaviour<?>> = ref None();
	uns = ref nop;

	fdisposable(
		fsubselect(b, FLift(\v -> {
			^uns();
			r = fn(v);

			eitherFn(
				^provider,
				\p -> {
					uns :=
						if (r > 0) {
							interruptibleTimer(r, \ -> nextDistinct(p, v));
						} else {
							nextDistinct(p, v);
							nop;
						};

					cast(p : DynamicBehaviour<?> -> Behaviour<?>);
				},
				\ -> {
					provider := Some(make(v));
					either(^provider, const(v));
				}
			);
		})),
		\ -> ^uns()
	)
}

fdelayUntilNextFrameRendered(b : Transform<?>) -> Transform<?> {
	provider : ref Maybe<DynamicBehaviour<?>> = ref None();
	uns = ref nop;

	fdisposable(
		fsubselect(b, FLift(\v -> {
			^uns();

			eitherFn(
				^provider,
				\p -> {
					uns := interruptibleDeferUntilNextFrameRendered(\ -> nextDistinct(p, v));
					cast(p : DynamicBehaviour<?> -> Behaviour<?>);
				},
				\ -> {
					provider := Some(make(v));
					either(^provider, const(v));
				}
			);
		})),
		\ -> ^uns()
	);
}

fthrottleUntilNextFrameRendered(b : Transform<?>) -> Transform<?> {
	provider : ref Maybe<DynamicBehaviour<?>> = ref None();
	ts = ref timestamp();
	uns = ref nop;

	fdisposable(
		fsubselect(b, FLift(\v -> {
			^uns();

			eitherFn(
				^provider,
				\p -> {
					if (^ts + 33.0 > timestamp()) {
						ts := timestamp();
						provider := Some(make(v));
						either(^provider, const(v));
					} else {
						ts := timestamp();
						uns := interruptibleDeferUntilNextFrameRendered(\ -> {
							nextDistinct(p, v);
							uns := nop;
						});
						cast(p : DynamicBehaviour<?> -> Behaviour<?>);
					}
				},
				\ -> {
					ts := timestamp();
					provider := Some(make(v));
					either(^provider, const(v));
				}
			);
		})),
		\ -> ^uns()
	);
}

flerp(start : double, end : double, t : Transform<double>) -> Transform<double> {
	fselect(t, FLift(\v -> (1.0 - v) * start + v * end));
}

flookupTree(tree : Transform<Tree<?, ??>>, key : Transform<?>) -> Transform<Maybe<??>> {
	fselect2(tree, key, FLift2(\t, k -> lookupTree(t, k)));
}

fremoveFromTree(tree : Transform<Tree<?, ??>>, key : Transform<?>) -> Transform<Tree<?, ??>> {
	fselect2(tree, key, FLift2(\t, k -> removeFromTree(t, k)));
}

fextractStruct(a : Transform<[?]>, e : Transform<??>) -> Transform<??> {
	fselect2(a, e, FLift2(\aa, ee -> extractStruct(aa, ee)));
}

initUnsM() -> ref Maybe<() -> void> {
	ref None()
}

setUnsM(uns : ref Maybe<() -> void>, v : () -> void) -> void {
	uns := Some(v);
}

dispUnsM(uns : ref Maybe<() -> void>) -> void {
	// a version of dispUns() without functions comparison
	switch (^uns) {
		Some(f): {
			f();
			uns := None();
		}
		None(): {}
	}
}

// For debug purposes

fpprint(title : string) -> (Transform<?>) -> Transform<?> {
	\tr -> {
		fsubscribe(tr, \v -> pprint(title + " : ")(v) |> ignore);
		tr
	}
}

fselectLift(b : Transform<??>, fn : (??) -> ?) -> Transform<?> {
	fselect(b, FLift(fn));
}

fselect2Lift(b1 : Transform<??>, b2 : Transform<???>, fn : (??, ???) -> ?) -> Transform<?> {
	fselect2(b1, b2, FLift2(fn));
}