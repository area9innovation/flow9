import ds/array;
import formats/json/json;

export {
	// Create a JWT signed with HS256 (HmacSHA256).
	native createJwt : (
		key : string,
		issuer : string,
		subject : string,
		audience : string,
		// Dates are expected to be ISO 8601 format
		expiration : string,
		notbefore : string,
		issuedat : string,
		id : string
	) -> string = FlowJwt.createJwt;

	// Create a JWT signed with HS256 (HmacSHA256).
	// Only JsonString and JsonDouble can be used
	createJwtClaims(
		key : string,
		claims : JsonObject
	) -> string;

	// Verify JWT's signed with HS256 (HmacSHA256). The key is the base64 encoded secret.
	// Return "OK" if the JWT signatuer is valid.
	native verifyJwt : (jwt : string, key : string) -> string = FlowJwt.verifyJwt;

	// Decode an JWT signed with HS256 (HmacSHA256). The key is the base64 encoded secret.
	native decodeJwt : (
		jwt : string,
		key : string,
		callback : (issuer : string, subject : string, audience : string, expiration : string, notBefore : string, issuedAt : string, id : string, impersonatedByUserId : string) -> void,
		onError : (verify : string) -> void
	) -> void = FlowJwt.decodeJwt;

/*
	// Verify JWT's, signed with the public/private key algorithms: RSA or ECDSA
	// The alg must be one of the "RS256", "RS384", "RS512", "ES256", "ES384" or "ES512"
	// When the alg is RS (RSA), then the key array must be of length 2, where "p" is key[0], "n" is key[1], the key is the public key modulus and exponent.
	// When the alg is ES (ECDSA) then the array must be of length 3, where "crv" is key[0], "x" is key[1] and "y" is key[2].
	// The keys are base64url encoded integers.
	// See https://datatracker.ietf.org/doc/html/rfc7518 for all the details.
	// Return "OK" if the JWT is valid.
	native verifyJwtAlt(jwt: string, alg: string, key: [string]) -> string = FlowJwt.verifyJwtRSA;
*/
}

createJwtClaims(
	key : string,
	claims : JsonObject
) -> string {

	pair = fold(
		claims.members,
		Pair([],[]),
		\acc : Pair<[string], [flow]>, p : Pair<string, Json> -> {
			switch(p.second) {
				JsonString(s): Pair(arrayPush(acc.first, p.first), arrayPush(acc.second, s));
				JsonDouble(d): Pair(arrayPush(acc.first, p.first), arrayPush(acc.second, d));
				default: acc; // skip
			}
		}
	);
	createJwtClaimsNative(key, pair.first, pair.second);
}

native createJwtClaimsNative : (
	key : string,
	keys : [string],
	values : [flow]
) -> string = FlowJwt.createJwtClaims;


createJwtClaimsNative(
	key : string,
	keys : [string],
	values : [flow]
) -> string {
	""; // Not implemented
}

createJwt(
	key : string,
	issuer : string,
	subject : string,
	audience : string,
	// Dates are expected to be ISO 8601 format
	expiration : string,
	notbefore : string,
	issuedat : string,
	id : string
) -> string {
	""; // Not implemented
}

verifyJwt(jwt : string, key : string) -> string {
	""; // Not implemented
}

decodeJwt(
	jwt : string,
	key : string,
	callback : (issuer : string, subject : string, audience : string, expiration : string, notBefore : string, issuedAt : string, id : string, impersonatedByUserId : string) -> void,
	onError : (verify : string) -> void
) -> void {
	onError("decodeJwt is not implemented");
}
