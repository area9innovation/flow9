import formats/json/json;
import text/translation;

export {
    AuthenticationTransport ::= Usb, Nfc, Ble, Internal, Lightning;
        Usb();
        Nfc();
        Ble();
        Internal();
        Lightning();

    AuthenticatorAttachment ::= Platform, CrossPlatform;
        // The authenticator which is bound to the client and which is generally not removable.
        Platform();
        // The authenticator which may be used across different platform (such as a USB or NFC device).
        CrossPlatform(); //default value

    UserVerificationRequirement ::= Discouraged, Preferred, Required;
        // User verification should not be employed as to minimize the user interaction during the process.
        Discouraged();
        // User verification is prefered, the operation will not fail if the response does not have the UV flag
        // (as part of the authenticatorData property of AuthenticatorAttestationResponse.attestationObject)
        Preferred(); //default value
        // User verification is required, the operation will fail if the response does not have the UV flag
        // (as part of the authenticatorData property of AuthenticatorAttestationResponse.attestationObject)
        Required();

    AttestationConveyancePreference ::= Direct, Indirect, None;
        // The relying party wants to receive the attestation as generated by the authenticator.
        Direct();
        // The client may change the assertion from the authenticator.
        // This value is used when the relying party wishes to verify the attestation.
        Indirect();
        // The relying party is not interested in this attestation.
        // This avoids making a check with the attestation certificate authority
        // and asking the user consent for sharing identifying information
        // None(); //default value

    PublicKeyCredentialType ::= PublicKey;
        PublicKey();

    AuthenticatorResponse ::= AuthenticatorAttestationResponse, AuthenticationAssertionResponse;
        AuthenticatorAttestationResponse(
            // base 64 encoded Json
            clientDataJSON : string,
            attestationObject : string, // CBOR encoded base64 encoded(?) Json
            getTransports : () -> [AuthenticationTransport],
        );
        AuthenticationAssertionResponse(
            // base 64 encoded Json
            clientDataJSON : string,
            authenticatorData : string,
            signature : string,
            userHandle : string
        );

    AuthenticatorSelectionCriteria(
        authenticatorAttachment : Maybe<AuthenticatorAttachment>,
        // A boolean which indicated that the credential private key must be stored in the authenticator,
        // the client or in a client device. The default value is false.
        requireResidentKey : Maybe<bool>,
        userVerification : Maybe<UserVerificationRequirement>
    );

    PublicCredentialDescriptor(type : PublicKeyCredentialType, id : string, transports : [AuthenticationTransport]);

    PublicKeyCredentialRPEntity(
        // The id must be a subset of the domain currently in the browser.
        id : string,
        name : string,
        icon : Maybe<string>
    );
    PublicKeyCredentialUserEntity(
        // The authenticator uses the id to associate a credential with the user.
        // It is suggested to not use personally identifying information as the id,
        // as it may be stored in an authenticator.
        id : string,
        name : string,
        displayName : string,
        icon : Maybe<string>
    );
    PublicKeyCredParam(
        type : PublicKeyCredentialType,
        // https://www.iana.org/assignments/cose/cose.xhtml#algorithms
        alg : int
    );

    PublicKeyCredentialCreationOptions(
        rp : PublicKeyCredentialRPEntity,
        user : PublicKeyCredentialUserEntity,
        // The challenge is a buffer of cryptographically random bytes generated on the server,
        // and is needed to prevent "replay attacks". 
        challenge : string,
        pubKeyCredParams : [PublicKeyCredParam],
        timeout : Maybe<int>,
        excludeCredentials : [PublicCredentialDescriptor],
        authenticatorSelection : Maybe<AuthenticatorSelectionCriteria>,
        attestation : Maybe<AttestationConveyancePreference>
    );
    jsonToPublicKeyCredentialCreationOptions(creationOptions : Json) -> Maybe<PublicKeyCredentialCreationOptions>;

    PublicKeyCredentialRequestOptions(
        challenge : string,
        timeout : Maybe<int>,
        rpId : Maybe<string>,
        allowCredentials : [PublicCredentialDescriptor],
        userVerification : Maybe<UserVerificationRequirement>
    );
    jsonToPublicKeyCredentialRequestOptions(requestOptions : Json) -> Maybe<PublicKeyCredentialRequestOptions>;

    PublicKeyCredential(
        id : string,
        rawId : string,
        type : PublicKeyCredentialType,
        response : AuthenticatorResponse
    );
    jsonToPublicKeyCredential(credential : Json, isAttestation : bool) -> Maybe<PublicKeyCredential>;

    authenticationTransportToString(transport : AuthenticationTransport) -> string;
    stringToAuthenticationTransport(s : string) -> Maybe<AuthenticationTransport>;

    authenticatorAttachmentToString(attachment : AuthenticatorAttachment) -> string;
    stringToAuthenticatorAttachment(s : string) -> Maybe<AuthenticatorAttachment>;

    userVerificationRequirementToString(requirement : UserVerificationRequirement) -> string;
    stringToUserVerificationRequirement(s : string) -> Maybe<UserVerificationRequirement>;

    attestationConveyancePreferenceToString(attestation : AttestationConveyancePreference) -> string;
    stringToAttestationConveyancePreference(s : string) -> Maybe<AttestationConveyancePreference>;

    publicKeyCredentialTypeToString(type : PublicKeyCredentialType) -> string;
    stringToPublicKeyCredentialType(s : string) -> Maybe<PublicKeyCredentialType>;
}

makeAuthenticatorSelectionCriteria() -> AuthenticatorSelectionCriteria {
    AuthenticatorSelectionCriteria(None(), None(), None())
}

jsonToAuthenticatorSelectionCriteria(pk : Json) -> Maybe<AuthenticatorSelectionCriteria> {
    eitherMap(
        getJsonFieldValueM(pk, "authenticatorSelection"),
        \as -> Some(
            AuthenticatorSelectionCriteria(
                stringToAuthenticatorAttachment(getJsonStringField(as, "authenticatorAttachment", "cross-platform")),
                getJsonMaybeField(as, getJsonBoolValue, "requireResidentKey", false),
                stringToUserVerificationRequirement(getJsonStringField(as, "userVerification", "preferred"))
            )
        ),
        None()
    )
}

makePublicCredentialDescriptor() -> PublicCredentialDescriptor {
    PublicCredentialDescriptor(PublicKey(), "", [])
}

jsonToAllowExcludeCredentials(pk : Json, isAllow : bool) -> [PublicCredentialDescriptor] {
    eitherMap(
        getJsonFieldValueM(pk, if (isAllow) "allowCredentials" else "excludeCredentials"),
        \pcd -> filtermap(
            getJsonArrayValue(pcd, []),
            \pcdEl -> eitherMap(
                stringToPublicKeyCredentialType(getJsonStringField(pcdEl, "type", "")),
                \type -> eitherMap(
                    getJsonMaybeField(pcdEl, getJsonStringValue, "id", ""),
                    \id -> Some(
                        PublicCredentialDescriptor(
                            type,
                            id,
                            filtermap(
                                getJsonArrayField(pcdEl, "transports"),
                                \transportJson -> stringToAuthenticationTransport(getJsonStringValue(transportJson, ""))
                            )
                        )
                    ),
                    None()
                ),
                None()
            )
        ),
        []
    )
}

makePublicKeyCredentialRPEntity() -> PublicKeyCredentialRPEntity {
    PublicKeyCredentialRPEntity("", "", None())
}

jsonToPublicKeyCredentialRPEntity(pk : Json) -> PublicKeyCredentialRPEntity {
    eitherFn(
        getJsonFieldValueM(pk, "rp"),
        \rp -> PublicKeyCredentialRPEntity(
            getJsonStringField(rp, "id", ""),
            getJsonStringField(rp, "name", ""),
            getJsonMaybeField(rp, getJsonStringValue, "icon", "")
        ),
        makePublicKeyCredentialRPEntity
    )
}

makePublicKeyCredentialUserEntity() -> PublicKeyCredentialUserEntity {
    PublicKeyCredentialUserEntity("", "", "", None())
}

jsonToPublicKeyCredentialUserEntity(pk : Json) -> PublicKeyCredentialUserEntity {
    eitherFn(
        getJsonFieldValueM(pk, "user"),
        \user -> PublicKeyCredentialUserEntity(
            getJsonStringField(user, "id", ""),
            getJsonStringField(user, "name", ""),
            getJsonStringField(user, "displayName", ""),
            getJsonMaybeField(user, getJsonStringValue, "icon", "")
        ),
        makePublicKeyCredentialUserEntity
    )
}

jsonToPubKeyCredParams(pk : Json) -> [PublicKeyCredParam] {
    eitherMap(
        getJsonFieldValueM(pk, "pubKeyCredParams"),
        \pkcp -> filtermap(
            getJsonArrayValue(pkcp, []),
            \pkcpEl -> eitherMap(
                stringToPublicKeyCredentialType(getJsonStringField(pkcpEl, "type", "")),
                \type -> eitherMap(
                    getJsonMaybeField(pkcpEl, getJsonIntValue, "alg", 0),
                    \alg -> Some(PublicKeyCredParam(type, alg)),
                    None()
                ),
                None()
            )
        ),
        []
    )
}

jsonToPublicKeyCredentialCreationOptions(creationOptions : Json) -> Maybe<PublicKeyCredentialCreationOptions >{
    eitherMap(
        getJsonFieldValueM(creationOptions, "publicKey"),
        \pk -> Some(
            PublicKeyCredentialCreationOptions(
                jsonToPublicKeyCredentialRPEntity(pk),
                jsonToPublicKeyCredentialUserEntity(pk),
                getJsonStringField(pk, "challenge", ""),
                jsonToPubKeyCredParams(pk),
                getJsonMaybeField(pk, getJsonIntValue, "timeout", 0),
                jsonToAllowExcludeCredentials(pk, false),
                jsonToAuthenticatorSelectionCriteria(pk),
                stringToAttestationConveyancePreference(getJsonStringField(pk, "attestation", ""))
            )
        ),
        None()
    )
}

jsonToPublicKeyCredentialRequestOptions(requestOptions : Json) -> Maybe<PublicKeyCredentialRequestOptions> {
    eitherMap(
        getJsonFieldValueM(requestOptions, "publicKey"),
        \pk -> Some(
            PublicKeyCredentialRequestOptions(
                getJsonStringField(pk, "challenge", ""),
                getJsonMaybeField(pk, getJsonIntValue, "timeout", 0),
                getJsonMaybeField(pk, getJsonStringValue, "rpId", ""),
                jsonToAllowExcludeCredentials(pk, true),
                stringToUserVerificationRequirement(getJsonStringField(pk, "userVerification", "preferred"))
            )
        ),
        None()
    )
}

makeAuthenticatorAttestationResponse() -> AuthenticatorAttestationResponse {
    AuthenticatorAttestationResponse("", "", \ -> [])
}

jsonToAuthenticatorAttestationResponse(response : Json) -> AuthenticatorAttestationResponse {
    AuthenticatorAttestationResponse(
        getJsonStringField(response, "clientDataJSON", ""),
        getJsonStringField(response, "attestationObject", ""),
        \-> []
    )
}

makeAuthenticationAssertionResponse() -> AuthenticationAssertionResponse {
    AuthenticationAssertionResponse("", "", "", "")
}

jsonToAuthenticationAssertionResponse(response : Json) -> AuthenticationAssertionResponse {
    AuthenticationAssertionResponse(
        getJsonStringField(response, "clientDataJSON", ""),
        getJsonStringField(response, "authenticatorData", ""),
        getJsonStringField(response, "signature", ""),
        getJsonStringField(response, "userHandle", "")
    )
}

jsonToPublicKeyCredential(credential : Json, isAttestation : bool) -> Maybe<PublicKeyCredential> {
    eitherMap(
        stringToPublicKeyCredentialType(getJsonStringField(credential, "type", "")),
        \type -> Some(
            PublicKeyCredential(
                getJsonStringField(credential, "id", ""),
                getJsonStringField(credential, "rawId", ""),
                type,
                eitherFn(
                    getJsonMaybeField(credential, getJsonStringValue, "response", ""),
                    \responseJsonString -> {
                        responseJson = parseJson(responseJsonString);
                        if (isAttestation) {
                            jsonToAuthenticatorAttestationResponse(responseJson)
                        } else {
                            jsonToAuthenticationAssertionResponse(responseJson)
                        }
                    },
                    if (isAttestation) makeAuthenticatorAttestationResponse
                    else makeAuthenticationAssertionResponse
                )
            )
        ),
        None()
    )
}

authenticationTransportToString(transport : AuthenticationTransport) -> string {
    switch (transport : AuthenticationTransport) {
        Usb():          "usb";
        Nfc():          "nfc";
        Ble():          "ble";
        Internal():     "internal";
        Lightning():    "lightning";
    }
}

stringToAuthenticationTransport(s : string) -> Maybe<AuthenticationTransport> {
    if (s == "usb")             Some(Usb())
    else if (s == "nfc")        Some(Nfc())
    else if (s == "ble")        Some(Ble())
    else if (s == "internal")   Some(Internal())
    else if (s == "lightning")  Some(Lightning())
    else                        None()
}

authenticatorAttachmentToString(attachment : AuthenticatorAttachment) -> string {
    switch (attachment : AuthenticatorAttachment) {
        Platform():         "platform";
        CrossPlatform():    "cross-platform";
    }
}

stringToAuthenticatorAttachment(s : string) -> Maybe<AuthenticatorAttachment> {
    if (s == "platform")            Some(Platform())
    else if (s == "cross-platform") Some(CrossPlatform())
    else                            None()
}

userVerificationRequirementToString(requirement : UserVerificationRequirement) -> string {
    switch (requirement : UserVerificationRequirement) {
        Discouraged():  "discouraged";
        Preferred():    "preferred";
        Required():     "required";
    }
}

stringToUserVerificationRequirement(s : string) -> Maybe<UserVerificationRequirement> {
    if (s == "discouraged")     Some(Discouraged())
    else if (s == "preferred")  Some(Preferred())
    else if (s == "required")   Some(Required())
    else                        None()
}

attestationConveyancePreferenceToString(attestation : AttestationConveyancePreference) -> string {
    switch (attestation : AttestationConveyancePreference) {
        Direct():   "direct";
        Indirect(): "indirect";
        None():     "none";
    }
}

stringToAttestationConveyancePreference(s : string) -> Maybe<AttestationConveyancePreference> {
    if (s == "direct")          Some(Direct())
    else if (s == "indirect")   Some(Indirect())
    else                        None()
}

publicKeyCredentialTypeToString(type : PublicKeyCredentialType) -> string {
    switch (type : PublicKeyCredentialType) {
        PublicKey(): "public-key";
    }
}

stringToPublicKeyCredentialType(s : string) -> Maybe<PublicKeyCredentialType> {
    if (s == "public-key")  Some(PublicKey())
    else                    None()
}