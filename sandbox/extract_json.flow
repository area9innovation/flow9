import formats/json/json_pegop;
import lingo/pegcode/parsic;
import lingo/pegaction;

export {
	// Parse all JSON objects in this text, and extract them
	// Give a function to convert the JSON object to a string as a short tag
	extractJsonsFromText(text : string, json2tag : (Json) -> string) -> Pair<string, [Json]>;
}

extractJsonsFromText(text : string, json2tag : (Json) -> string) -> Pair<string, [Json]> {
	acc = doExtractJsonFromText(JsonExtracts(text, 0, []));
	replaced = fold(reverseA(acc.jsons), text, \t, p -> {
		endsWithSpace = substring(text, p.third - 1, 1) == " ";
		tag = json2tag(p.first);
		strLeft(t, p.second) + tag + (if (endsWithSpace) " " else "") + strRight(t, p.third);
	});
	Pair(replaced, map(acc.jsons, \t -> t.first));
}

JsonExtracts(
	text : string, 
	i : int,
	jsons : [Triple<Json, int, int>],
);

doExtractJsonFromText(acc : JsonExtracts) -> JsonExtracts {
	if (acc.i >= strlen(acc.text)) {
		acc;
	} else {
		nb = strRangeIndexOf(acc.text, "{", acc.i, strlen(acc.text));
		if (nb == -1) {
			acc
		} else {
			// println(strRight(acc.text, nb));

			result = runPegPartial(acc.text, nb, pegOps4Json, defaultPegActions);
			ni = max(result.pos, acc.i + 1);
			switch (result.result) {
				None(): {
					doExtractJsonFromText(JsonExtracts(acc with i = ni));
				}
				Some(j): {
					if (j != JsonNull()) {
						package = Triple(j, nb, result.pos);
						doExtractJsonFromText(JsonExtracts(acc with i = result.pos, jsons = arrayPush(acc.jsons, package)));
					} else {
						doExtractJsonFromText(JsonExtracts(acc with i = ni));
					}
				}
			}
		}
	}
}

// main() {
// 	println(extractJsonsFromText("Hello {\"a\":1} and more {\"b\":2}}", \json -> "<JSON>"));
// 	quit(0);
// }
