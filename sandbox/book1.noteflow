{"cells":[{"kind":1,"language":"markdown","value":"This is an example of a flow-notebook, integrated into vscode.\n--------------------------------------------------------------\n"},{"kind":1,"language":"markdown","value":"The simplest form of cells - expressions, which are evaluated and\nthe obtained value is printed in the cell output"},{"kind":2,"language":"flow","value":"// Add 1 and 2:\n1 + 2"},{"kind":2,"language":"flow","value":"/* Add strings: */\n\"1\" + \"2\""},{"kind":1,"language":"markdown","value":"Also we can write a block of code with some variables introduced (locally) - statements block."},{"kind":2,"language":"flow","value":"x = 1 + 2;\ny = \"ABC\";\nprintln(i2s(x) + \" \" + y);\nprintln(\"x\" + y + i2s(x - 3));"},{"kind":1,"language":"markdown","value":"If a code is incorrect in flow, the cell won't be compiled. Unfortunately currently the REPL engine can't show the diagnostic message, because it decides which type of code (expressions, statements or declarations) is in the cell by trial typechecking. Thus, in case of errors, REPL engine can't decide the kind of a code in cell, and can't pick up the appropriate error messages."},{"kind":2,"language":"flow","value":"1 + \"AA\""},{"kind":1,"language":"markdown","value":"Functions and global variables (toplevel declarations) may be introduced as well."},{"kind":2,"language":"flow","value":"factorial(i : int) -> int {\n    if (i == 0) 1 else i * factorial(i - 1);\n}\n\n\nfive_fact = factorial(5);"},{"kind":1,"language":"markdown","value":"Now let's use the introduced toplevels. After running the cell with the declarations, they will be stored and may be referenced by other code later."},{"kind":2,"language":"flow","value":"println(\"5! = \" + i2s(five_fact));\nprintln(\"7! = \" + i2s(factorial(7)));"},{"kind":1,"language":"markdown","value":"CAUTION! We can't mix up toplevel declarations and evaluated expressions:"},{"kind":2,"language":"flow","value":"factorial(i : int) -> int {\n    if (i == 0) 1 else i * factorial(i - 1);\n}\n\n\nfive_fact = factorial(5);\n\n// Error! Attempt to eval expression among declarations\nprintln(\"5! = \" + i2s(five_fact)); "},{"kind":1,"language":"markdown","value":"The REPL engine as a built-in help. The help may be invoked by 'help' or 'help <command>' for a particular command."},{"kind":2,"language":"flow","value":"help"},{"kind":2,"language":"flow","value":"help eval"},{"kind":1,"language":"markdown","value":"The code in cells is stored in REPL engine with 'cell_<num>' labels. It is possible to look at the internally stored code by 'show cell_<ind>' command."},{"kind":2,"language":"flow","value":"show cell_5"},{"kind":2,"language":"flow","value":"show all"},{"kind":1,"language":"markdown","value":"The 'exit' command may be used to restart the REPL engine. This command shuts it down, and when any other cell is run afterwards, the REPL engine automatically starts."},{"kind":2,"language":"flow","value":"exit"},{"kind":1,"language":"markdown","value":"The code with graphical UI also may be inserted. Yet this feature works not correctly - it renders the output on the complete window, not only in the output window for a current cell."},{"kind":2,"language":"flow","value":"import form/renderform;\n\nmain() {\n\tprintln(\"Hello console\");\n\tus = render(Text(\"Hello window!\", []));\n\t{}\n}\n"},{"kind":1,"language":"markdown","value":"A complex example of a code with UI - tetris game. Not works correctly now."},{"kind":2,"language":"flow","value":"import material/material;\nimport material/material2tropic;\n\nBoard(\n\trows : [[int]]\n);\n\nGame(\n\tboard : Board,\n\tpiece : int,\n\trotation : int,\n\tx : int,\n\ty : int,\n\tspeed : int,\n\tscore : int,\n\tnextPiece : int,\n\tlinesRemoved : int,\n);\n\n\npieces = [\n\tmap([\"022\\n220\", \"020\\n022\\n002\"], parsePiece),\n\tmap([\"330\\n033\", \"030\\n330\\n300\"], parsePiece),\n\tmap([\"4444\", \"04\\n04\\n04\\n04\"], parsePiece),\n\tmap([\"55\\n55\"], parsePiece),\n\tmap([\"666\\n006\", \"06\\n06\\n66\", \"600\\n666\", \"66\\n60\\n60\"], parsePiece),\n\tmap([\"007\\n777\", \"70\\n70\\n77\", \"777\\n700\", \"77\\n07\\n07\"], parsePiece),\n\tmap([\"888\\n080\", \"80\\n88\\n80\", \"080\\n888\", \"08\\n88\\n08\"], parsePiece),\n];\n\n\ndrawGame(g : Game) -> Material {\n\tMCols([\n\t\tMGroup([\n\t\t\tMFrame(0.0, 0.0, [Fill(0x00)],\n\t\t\t\tdrawBoard(g.board),\n\t\t\t),\n\t\t\tMOffset(i2d(g.x) * 24.0, i2d(g.y) * 24.0, drawBoard(pieces[g.piece][g.rotation]))\n\t\t]),\n\t\tTFixed(24.0, 0.0),\n\t\tMLines([\n\t\t\tMText(i2s(g.score), []),\n\t\t\tdrawBoard(pieces[g.nextPiece][0])\n\t\t])\n\t])\n}\n\ndrawBoard(b : Board) -> Material {\n\tMLines(map(b.rows, \\row -> {\n\t\tMCols(map(row, \\cell -> {\n\t\t\tif (cell == 0) {\n\t\t\t\tTFixed(24.0, 24.0)\n\t\t\t} else {\n\t\t\t\tcolors = [0x000000, 0x787878, 0xffc000, 0xf6921e, 0xfff100, 0x00adee, 0xec1b24, 0x8bc53f, 0xff00ff];\n\t\t\t\tTRectangle([Fill(colors[cell]), Stroke(white)], TFixed(24.0, 24.0))\n\t\t\t}\n\t\t}))\n\t}));\n}\n\n\tboard = Board([\n\t\t[1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],\n\t\t[1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],\n\t\t[1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],\n\t\t[1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],\n\t\t[1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],\n\t\t[1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],\n\t\t[1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],\n\t\t[1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],\n\t\t[1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],\n\t\t[1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],\n\t\t[1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],\n\t\t[1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],\n\t\t[1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],\n\t\t[1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],\n\t\t[1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],\n\t\t[1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],\n\t\t[1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],\n\t\t[1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],\n\t\t[1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],\n\t\t[1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],\n\t\t[1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],\n\t]);\n\nemptyLine = [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1];\n\nfullLine =  [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1];\n\nparsePiece(t : string) -> Board {\n\trows = strSplit(t, \"\\n\");\n\tBoard(map(rows, \\row : string -> {\n\t\tmap(s2a(row), \\code -> code - 48)\n\t}));\n}\n\ngame = make(Game(\n\t\tboard,\n\t\tfloor(random() * 7.0),\n\t\t0,\n\t\t5, 0,\n\t\t200,\n\t\t0,\n\t\tfloor(random() * 7.0),\n\t\t0\n\t));\n\ndropPiece() -> void {\n\tg = getValue(game);\n\tng = Game(g with y = g.y + 1); \n\tnext(game, ng);\n\n\tcollision = ref false;\n\tnewBoard = addPieceToBoard(g.board, pieces[g.piece][g.rotation], ng.x, ng.y, collision);\n\n\tig = if (^collision) {\n\t\tcollision := false;\n\t\tprevBoard = addPieceToBoard(g.board, pieces[g.piece][g.rotation], g.x, g.y, collision);\n\t\tif (^collision) {\n\t\t\tprintln(\"GAME OVER\");\n\t\t\tGame(ng with speed = intMax);\n\t\t} else {\n\t\t\tfixed = Game(ng with \n\t\t\t\tboard = prevBoard,\n\t\t\t\tx = 5,\n\t\t\t\ty = 0,\n\t\t\t\tpiece = ng.nextPiece,\n\t\t\t\tnextPiece = floor(random() * 7.0),\n\t\t\t\trotation = 0,\n\t\t\t);\n\n\t\t\tremoveFullLines(fixed);\n\t\t}\n\t} else {\n\t\tng;\n\t};\n\tnext(game, ig);\n\n\ttimer(getValue(game).speed, dropPiece);\n}\n\naddPieceToBoard(b : Board, piece : Board, x : int, y : int, collision : ref bool) -> Board {\n\twidth = length(piece.rows[0]);\n\theight = length(piece.rows);\n\tBoard(\n\t\tmapi(b.rows, \\yc, row -> {\n\t\t\tmapi(row, \\xc, cell -> {\n\t\t\t\tpx = xc - x;\n\t\t\t\tpy = yc - y;\n\t\t\t\tif (0 <= px && px < width) {\n\t\t\t\t\tif (0 <= py && py < height) {\n\t\t\t\t\t\tcolor = piece.rows[py][px];\n\t\t\t\t\t\tif (color == 0) {\n\t\t\t\t\t\t\tcell\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tif (cell != 0) {\n\t\t\t\t\t\t\t\tcollision := true;\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\tcolor;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else cell\n\t\t\t\t} else cell\n\t\t\t})\n\t\t})\n\t);\n}\n\n\nmain() {\n\ttimer(getValue(game).speed, dropPiece);\n\n\tg = getValue(game);\n\tcollision = ref false;\n\tnewBoard = addPieceToBoard(g.board, pieces[g.piece][g.rotation], 0, g.y, collision);\n\n\tkey = makeTKey(\\key -> {\n\t\tcontains([\"left\", \"right\", \"down\", \"up\", \" \"], key.utf);\n\t});\n\n\tmrender(makeMaterialManager([]), true, \n\t\tMInteractive([\n\t\t\t\tkey\n\t\t\t],\n\t\t\tMConstruct([\n\t\t\t\t\tmakeSubscribe(key.pressed, \\k -> {\n\t\t\t\t\t\tif (k.utf == \"left\") {\n\t\t\t\t\t\t\tmovePiece(-1, 0);\n\t\t\t\t\t\t} else if (k.utf == \"right\") {\n\t\t\t\t\t\t\tmovePiece(1, 0);\n\t\t\t\t\t\t} else if (k.utf == \"down\") {\n\t\t\t\t\t\t\tmovePiece(0, 1);\n\t\t\t\t\t\t} else if (k.utf == \"up\") {\n\t\t\t\t\t\t\trotatePiece();\n\t\t\t\t\t\t} else if (k.utf == \" \") {\n\t\t\t\t\t\t\tdropPieceDown();\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t}\n\t\t\t\t\t})\n\t\t\t\t],\n\t\t\t\tMSelect(game, drawGame)\n\t\t\t)\n\t\t)\n\t)\n}\n\nmovePiece(dx : int, dy : int) -> void {\n\tg = getValue(game);\n\tng = Game(g with x = g.x + dx, y = g.y + dy); \n\tcollision = ref false;\n\tnewBoard = addPieceToBoard(g.board, pieces[g.piece][g.rotation], ng.x, ng.y, collision);\n\tif (!^collision) {\n\t\tnext(game, ng)\n\t}\n}\n\ndropPieceDown() -> void {\n\tg = getValue(game);\n\tng = Game(g with x = g.x + 0, y = g.y + 1); \n\tcollision = ref false;\n\tnewBoard = addPieceToBoard(g.board, pieces[g.piece][g.rotation], ng.x, ng.y, collision);\n\tif (!^collision) {\n\t\tnext(game, ng);\n\t\tdropPieceDown();\n\t} \n}\n\nrotatePiece() {\n\tg = getValue(game);\n\tng = Game(g with rotation = (g.rotation + 1) % length(pieces[g.piece]) ); \n\tcollision = ref false;\n\taddPieceToBoard(g.board, pieces[g.piece][ng.rotation], ng.x, ng.y, collision);\n\tif (!^collision) {\n\t\tnext(game, ng)\n\t}\n}\n\nremoveFullLines(g : Game) -> Game {\n\tfullLines = filter(g.board.rows, \\row -> {\n\t\t!forall(row, \\cell -> cell != 0)\n\t});\n\tlastLine = arrayPush(fullLines, fullLine);\n\tremoved = 21 - length(lastLine);\n\n\tscore = elementAt([0, 40, 100, 300, 1200], removed, 0);\n\n\tnewLines = concat(\n\t\tgenerate(0, removed, \\__ -> emptyLine),\n\t\tlastLine\n\t);\n\n\tlinesRemoved = g.linesRemoved + removed;\n\n\tspeed = max(20, 200 - 10 * (linesRemoved / 10));\n\n\tGame(g with board = Board(newLines), score = g.score + score, linesRemoved = linesRemoved, speed = speed);\n}\n"}]}