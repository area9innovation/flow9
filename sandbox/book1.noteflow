{"cells":[{"kind":1,"language":"markdown","value":""},{"kind":1,"language":"markdown","value":"the test flow notebook"},{"kind":2,"language":"flow","value":"hw1() -> void {\n    println(\"BBB\");\n}"},{"kind":2,"language":"flow","value":"hw1();"},{"kind":2,"language":"flow","value":"println(1 + 2);"},{"kind":2,"language":"flow","value":"1 + 5"},{"kind":2,"language":"flow","value":"help"},{"kind":2,"language":"flow","value":"show cell_1"},{"kind":2,"language":"flow","value":"exit"},{"kind":2,"language":"flow","value":"import material/material;\nimport material/material2tropic;\n\nBoard(\n\trows : [[int]]\n);\n\nGame(\n\tboard : Board,\n\tpiece : int,\n\trotation : int,\n\tx : int,\n\ty : int,\n\tspeed : int,\n\tscore : int,\n\tnextPiece : int,\n\tlinesRemoved : int,\n);\n\n\npieces = [\n\tmap([\"022\\n220\", \"020\\n022\\n002\"], parsePiece),\n\tmap([\"330\\n033\", \"030\\n330\\n300\"], parsePiece),\n\tmap([\"4444\", \"04\\n04\\n04\\n04\"], parsePiece),\n\tmap([\"55\\n55\"], parsePiece),\n\tmap([\"666\\n006\", \"06\\n06\\n66\", \"600\\n666\", \"66\\n60\\n60\"], parsePiece),\n\tmap([\"007\\n777\", \"70\\n70\\n77\", \"777\\n700\", \"77\\n07\\n07\"], parsePiece),\n\tmap([\"888\\n080\", \"80\\n88\\n80\", \"080\\n888\", \"08\\n88\\n08\"], parsePiece),\n];\n\n\ndrawGame(g : Game) -> Material {\n\tMCols([\n\t\tMGroup([\n\t\t\tMFrame(0.0, 0.0, [Fill(0x00)],\n\t\t\t\tdrawBoard(g.board),\n\t\t\t),\n\t\t\tMOffset(i2d(g.x) * 24.0, i2d(g.y) * 24.0, drawBoard(pieces[g.piece][g.rotation]))\n\t\t]),\n\t\tTFixed(24.0, 0.0),\n\t\tMLines([\n\t\t\tMText(i2s(g.score), []),\n\t\t\tdrawBoard(pieces[g.nextPiece][0])\n\t\t])\n\t])\n}\n\ndrawBoard(b : Board) -> Material {\n\tMLines(map(b.rows, \\row -> {\n\t\tMCols(map(row, \\cell -> {\n\t\t\tif (cell == 0) {\n\t\t\t\tTFixed(24.0, 24.0)\n\t\t\t} else {\n\t\t\t\tcolors = [0x000000, 0x787878, 0xffc000, 0xf6921e, 0xfff100, 0x00adee, 0xec1b24, 0x8bc53f, 0xff00ff];\n\t\t\t\tTRectangle([Fill(colors[cell]), Stroke(white)], TFixed(24.0, 24.0))\n\t\t\t}\n\t\t}))\n\t}));\n}\n\n\tboard = Board([\n\t\t[1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],\n\t\t[1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],\n\t\t[1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],\n\t\t[1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],\n\t\t[1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],\n\t\t[1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],\n\t\t[1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],\n\t\t[1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],\n\t\t[1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],\n\t\t[1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],\n\t\t[1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],\n\t\t[1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],\n\t\t[1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],\n\t\t[1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],\n\t\t[1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],\n\t\t[1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],\n\t\t[1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],\n\t\t[1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],\n\t\t[1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],\n\t\t[1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],\n\t\t[1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],\n\t]);\n\nemptyLine = [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1];\n\nfullLine =  [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1];\n\nparsePiece(t : string) -> Board {\n\trows = strSplit(t, \"\\n\");\n\tBoard(map(rows, \\row : string -> {\n\t\tmap(s2a(row), \\code -> code - 48)\n\t}));\n}\n\ngame = make(Game(\n\t\tboard,\n\t\tfloor(random() * 7.0),\n\t\t0,\n\t\t5, 0,\n\t\t200,\n\t\t0,\n\t\tfloor(random() * 7.0),\n\t\t0\n\t));\n\ndropPiece() -> void {\n\tg = getValue(game);\n\tng = Game(g with y = g.y + 1); \n\tnext(game, ng);\n\n\tcollision = ref false;\n\tnewBoard = addPieceToBoard(g.board, pieces[g.piece][g.rotation], ng.x, ng.y, collision);\n\n\tig = if (^collision) {\n\t\tcollision := false;\n\t\tprevBoard = addPieceToBoard(g.board, pieces[g.piece][g.rotation], g.x, g.y, collision);\n\t\tif (^collision) {\n\t\t\tprintln(\"GAME OVER\");\n\t\t\tGame(ng with speed = intMax);\n\t\t} else {\n\t\t\tfixed = Game(ng with \n\t\t\t\tboard = prevBoard,\n\t\t\t\tx = 5,\n\t\t\t\ty = 0,\n\t\t\t\tpiece = ng.nextPiece,\n\t\t\t\tnextPiece = floor(random() * 7.0),\n\t\t\t\trotation = 0,\n\t\t\t);\n\n\t\t\tremoveFullLines(fixed);\n\t\t}\n\t} else {\n\t\tng;\n\t};\n\tnext(game, ig);\n\n\ttimer(getValue(game).speed, dropPiece);\n}\n\naddPieceToBoard(b : Board, piece : Board, x : int, y : int, collision : ref bool) -> Board {\n\twidth = length(piece.rows[0]);\n\theight = length(piece.rows);\n\tBoard(\n\t\tmapi(b.rows, \\yc, row -> {\n\t\t\tmapi(row, \\xc, cell -> {\n\t\t\t\tpx = xc - x;\n\t\t\t\tpy = yc - y;\n\t\t\t\tif (0 <= px && px < width) {\n\t\t\t\t\tif (0 <= py && py < height) {\n\t\t\t\t\t\tcolor = piece.rows[py][px];\n\t\t\t\t\t\tif (color == 0) {\n\t\t\t\t\t\t\tcell\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tif (cell != 0) {\n\t\t\t\t\t\t\t\tcollision := true;\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\tcolor;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else cell\n\t\t\t\t} else cell\n\t\t\t})\n\t\t})\n\t);\n}\n\n\nmain() {\n\ttimer(getValue(game).speed, dropPiece);\n\n\tg = getValue(game);\n\tcollision = ref false;\n\tnewBoard = addPieceToBoard(g.board, pieces[g.piece][g.rotation], 0, g.y, collision);\n\n\tkey = makeTKey(\\key -> {\n\t\tcontains([\"left\", \"right\", \"down\", \"up\", \" \"], key.utf);\n\t});\n\n\tmrender(makeMaterialManager([]), true, \n\t\tMInteractive([\n\t\t\t\tkey\n\t\t\t],\n\t\t\tMConstruct([\n\t\t\t\t\tmakeSubscribe(key.pressed, \\k -> {\n\t\t\t\t\t\tif (k.utf == \"left\") {\n\t\t\t\t\t\t\tmovePiece(-1, 0);\n\t\t\t\t\t\t} else if (k.utf == \"right\") {\n\t\t\t\t\t\t\tmovePiece(1, 0);\n\t\t\t\t\t\t} else if (k.utf == \"down\") {\n\t\t\t\t\t\t\tmovePiece(0, 1);\n\t\t\t\t\t\t} else if (k.utf == \"up\") {\n\t\t\t\t\t\t\trotatePiece();\n\t\t\t\t\t\t} else if (k.utf == \" \") {\n\t\t\t\t\t\t\tdropPieceDown();\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t}\n\t\t\t\t\t})\n\t\t\t\t],\n\t\t\t\tMSelect(game, drawGame)\n\t\t\t)\n\t\t)\n\t)\n}\n\nmovePiece(dx : int, dy : int) -> void {\n\tg = getValue(game);\n\tng = Game(g with x = g.x + dx, y = g.y + dy); \n\tcollision = ref false;\n\tnewBoard = addPieceToBoard(g.board, pieces[g.piece][g.rotation], ng.x, ng.y, collision);\n\tif (!^collision) {\n\t\tnext(game, ng)\n\t}\n}\n\ndropPieceDown() -> void {\n\tg = getValue(game);\n\tng = Game(g with x = g.x + 0, y = g.y + 1); \n\tcollision = ref false;\n\tnewBoard = addPieceToBoard(g.board, pieces[g.piece][g.rotation], ng.x, ng.y, collision);\n\tif (!^collision) {\n\t\tnext(game, ng);\n\t\tdropPieceDown();\n\t} \n}\n\nrotatePiece() {\n\tg = getValue(game);\n\tng = Game(g with rotation = (g.rotation + 1) % length(pieces[g.piece]) ); \n\tcollision = ref false;\n\taddPieceToBoard(g.board, pieces[g.piece][ng.rotation], ng.x, ng.y, collision);\n\tif (!^collision) {\n\t\tnext(game, ng)\n\t}\n}\n\nremoveFullLines(g : Game) -> Game {\n\tfullLines = filter(g.board.rows, \\row -> {\n\t\t!forall(row, \\cell -> cell != 0)\n\t});\n\tlastLine = arrayPush(fullLines, fullLine);\n\tremoved = 21 - length(lastLine);\n\n\tscore = elementAt([0, 40, 100, 300, 1200], removed, 0);\n\n\tnewLines = concat(\n\t\tgenerate(0, removed, \\__ -> emptyLine),\n\t\tlastLine\n\t);\n\n\tlinesRemoved = g.linesRemoved + removed;\n\n\tspeed = max(20, 200 - 10 * (linesRemoved / 10));\n\n\tGame(g with board = Board(newLines), score = g.score + score, linesRemoved = linesRemoved, speed = speed);\n}\n"},{"kind":2,"language":"flow","value":"import form/renderform;\n\nmain() {\n\tprintln(\"Hello console\");\n\tus = render(Text(\"Hello window!\", []));\n\t{}\n}\n"}]}