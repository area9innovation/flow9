import material/material2tropic;
import material/material_ui;

displayHtml(shaderV : string, shaderF : string, scriptContent : string) -> Material {
	wh = make(WidthHeight(0.0, 0.0));
	MInspect([IAvailable(wh)], 
		MHTMLStage(wh, \stage -> {
			canvas = createElement("canvas");
			scriptGLM = createElement("script");
			scriptShaderV = createElement("script");
			scriptShaderF = createElement("script");
			script = createElement("script");

			setAttribute(scriptGLM, "src", "https://git.io/glm-js.min.js", true);
			setAttribute(scriptGLM, "onload", "RayMain()", true);
			setAttribute(canvas, "id", "rayCanvas", true);
			setAttribute(canvas, "width", "1080", true);
			setAttribute(canvas, "height", "600", true);
			setAttribute(scriptShaderV, "type", "text/plain", true);
			setAttribute(scriptShaderV, "id", "vertex-shader", true);
			setAttribute(scriptShaderV, "innerHTML", shaderV, true);
			setAttribute(scriptShaderF, "type", "text/plain", true);
			setAttribute(scriptShaderF, "id", "fragment-shader", true);
			setAttribute(scriptShaderF, "innerHTML", shaderF, false);
			setAttribute(script, "innerHTML", scriptContent, true);

			setClipStyle(stage, "overflow", "auto");

			appendChild(stage, scriptGLM);
			appendChild(stage, canvas);
			appendChild(stage, scriptShaderV);
			appendChild(stage, scriptShaderF);
			appendChild(stage, script);
			\ -> {
				removeElementChild(stage, scriptGLM);
				removeElementChild(stage, canvas);
				removeElementChild(stage, scriptShaderV);
				removeElementChild(stage, scriptShaderF);
				removeElementChild(stage, script);
			}
		})
	)
}

RMCoordinate(x : double, y : double, z : double);

RMFigure ::= RMSphere;
	RMSphere(position : RMCoordinate, radius : double);

RMScene(figures : [RMFigure]);

generateSpheres(spheres : [RMSphere]) -> string {
	amount = length(spheres);
	initSpheres =  formatString("vec4 spheres[%1];", [i2s(amount)]);
	sphereData = generate(
		0, amount,
		\i -> formatString(
			"spheres[%1] = vec4(%2, %3, %4, %5);",
			[
				i2s(i),
				d2s(spheres[i].position.x),
				d2s(spheres[i].position.y),
				d2s(spheres[i].position.z),
				d2s(spheres[i].radius)
			]
		)
	);
	minDistance = formatString("for (int i = 0; i < %1; i++) {
		minSphereDist = min(minSphereDist, length (p - spheres[i].xyz) - spheres[i].w);
	}", [i2s(amount)]);
	strGlue(concat3([initSpheres], sphereData, [minDistance]), "\n");
}

main() {
	setRendererType("html");

	spheres = [
		RMSphere(RMCoordinate(0., 1., 6.), 1.),
		RMSphere(RMCoordinate(2., 2., 8.), 0.5),
		RMSphere(RMCoordinate(-2., 2., 8.), 0.5),
		RMSphere(RMCoordinate(0., 0., 3.), 0.5),
		RMSphere(RMCoordinate(-2., 0., 3.), 0.5),
		RMSphere(RMCoordinate(2., 0., 3.), 0.5),
	];

	mrender(makeMaterialManager([]), true, MLines([
		MText("Hello", []),
		displayHtml(
			"#include raymarching.vert",
			blueprint("#include raymarching.frag", ["spheres", generateSpheres(spheres)]),
			"function RayMain(){"+"#include raymarching.js"+"}"
		)
	]));
}
